ileSize(pReserveRec->GetInteger(ircSourceCost), uiClusteredSize)) != 0)
			return piErrRec;
		iSourceCost += uiClusteredSize;
		iNoRbSourceCost += uiClusteredSize;
	}
	return 0;
}

/*---------------------------------------------------------------------------
	FileCost action
---------------------------------------------------------------------------*/
iesEnum FileCost(IMsiEngine& riEngine)
{
	if ((riEngine.GetMode() & iefSecondSequence) && g_scServerContext == scClient)
	{
		DEBUGMSG("Skipping FileCost: action already run in this engine.");
		return iesNoAction;
	}

	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiServices pServices(riEngine.GetServices());
	if(riEngine.ActionProgress() == imsCancel)
		return iesUserExit;

	// Register a RemoveFile cost adjuster only if the RemoveFile
	// table is present.  If so, must be registered before File cost adjuster
	PMsiRecord pErrRec(0);
	PMsiSelectionManager pSelectionMgr(riEngine, IID_IMsiSelectionManager);
	if (pDatabase->FindTable(*MsiString(sztblRemoveFile)) != itsUnknown)
	{
		PMsiCostAdjuster pRemoveFileCostAdjuster = new CMsiRemoveFileCost(riEngine);
		if (pErrRec = pSelectionMgr->RegisterCostAdjuster(*pRemoveFileCostAdjuster))
			return riEngine.FatalError(*pErrRec);
	}

	// File cost adjuster
	PMsiCostAdjuster pFileCostAdjuster = new CMsiFileCost(riEngine);
	if (pErrRec = pSelectionMgr->RegisterCostAdjuster(*pFileCostAdjuster))
		return riEngine.FatalError(*pErrRec);

	// Registry cost adjuster
	PMsiCostAdjuster pRegistryCostAdjuster = new CMsiRegistryCost(riEngine);
	if ((pErrRec = pSelectionMgr->RegisterCostAdjuster(*pRegistryCostAdjuster)) != 0)
		return riEngine.FatalError(*pErrRec);

	// Register an IniFile cost adjuster only if the IniFile
	// table is present
	if (pDatabase->FindTable(*MsiString(sztblIniFile)) != itsUnknown)
	{
		PMsiCostAdjuster pIniFileCostAdjuster = new CMsiIniFileCost(riEngine);
		if (pErrRec = pSelectionMgr->RegisterCostAdjuster(*pIniFileCostAdjuster))
			return riEngine.FatalError(*pErrRec);
	}

	// Register a MoveFile cost adjuster only if the MoveFile
	// table is present
	if (pDatabase->FindTable(*MsiString(sztblMoveFile)) != itsUnknown)
	{
		PMsiCostAdjuster pMoveFileCostAdjuster = new CMsiMoveFileCost(riEngine);
		if (pErrRec = pSelectionMgr->RegisterCostAdjuster(*pMoveFileCostAdjuster))
			return riEngine.FatalError(*pErrRec);
	}

	// Register a DuplicateFile cost adjuster only if the DuplicateFile
	// table is present
	if (pDatabase->FindTable(*MsiString(sztblDuplicateFile)) != itsUnknown)
	{
		PMsiCostAdjuster pDupFileCostAdjuster = new CMsiDuplicateFileCost(riEngine);
		if (pErrRec = pSelectionMgr->RegisterCostAdjuster(*pDupFileCostAdjuster))
			return riEngine.FatalError(*pErrRec);
	}

	// Register a ReserveCost cost adjuster only if the ReserveCost
	// table is present
	if (pDatabase->FindTable(*MsiString(sztblReserveCost)) != itsUnknown)
	{
		PMsiCostAdjuster pReserveCostAdjuster = new CMsiReserveCost(riEngine);
		if (pErrRec = pSelectionMgr->RegisterCostAdjuster(*pReserveCostAdjuster))
			return riEngine.FatalError(*pErrRec);
	}

	// Register a Shortcut cost adjuster only if the Shortcut
	// table is present
	if (pDatabase->FindTable(*MsiString(sztblShortcut)) != itsUnknown)
	{
		PMsiCostAdjuster pShortcutCostAdjuster = new CMsiShortcutCost(riEngine);
		if (pErrRec = pSelectionMgr->RegisterCostAdjuster(*pShortcutCostAdjuster))
			return riEngine.FatalError(*pErrRec);
	}

	// Register a SFPCatalog cost adjuster only if the SFPCatalog and FileSFPCatalog tables
	// are present and system is Win9X > Millennium
	if ((pDatabase->FindTable(*MsiString(sztblSFPCatalog)) != itsUnknown) 
		&& (pDatabase->FindTable(*MsiString(sztblFileSFPCatalog)) != itsUnknown)
		&& (MinimumPlatform(true, 4, 90)))
	{
		PMsiCostAdjuster pSFPCatalogCostAdjuster = new CMsiSFPCatalogCost(riEngine);
		if (pErrRec = pSelectionMgr->RegisterCostAdjuster(*pSFPCatalogCostAdjuster))
			return riEngine.FatalError(*pErrRec);
	}

	if(riEngine.ActionProgress() == imsCancel)
		return iesUserExit;

	return iesSuccess;
}

/*---------------------------------------------------------------------------
	PatchFiles action - applies patch to selected files
---------------------------------------------------------------------------*/

enum ipfqEnum
{
	ipfqFile = 1,
	ipfqFileName,
	ipfqFileSize,
	ipfqDirectory,
	ipfqPatchSize,
	ipfqFileAttributes,
	ipfqPatchAttributes,
	ipfqPatchSequence,
	ipfqFileSequence,
	ipfqComponent,
	ipfqComponentId,
	ipfqNextEnum,
};

static const ICHAR sqlPatchFiles[] =
TEXT("SELECT `File`,`FileName`,`FileSize`,`Directory_`,`PatchSize`,`File`.`Attributes`,`Patch`.`Attributes`,`Patch`.`Sequence`,`File`.`Sequence`,`Component`.`Component`,`Component`.`ComponentId` ")
TEXT("FROM `File`,`Component`,`Patch` ")
TEXT("WHERE `File`=`File_` AND `Component`=`Component_` AND `Action`=1 ")
TEXT("ORDER BY `Patch`.`Sequence`");

iesEnum PatchFiles(IMsiEngine& riEngine)
{
	PMsiServices pServices(riEngine.GetServices());
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	Assert(pDirectoryMgr);
	int fMode = riEngine.GetMode();

	PMsiRecord pErrRec(0);

	// open the views
	PMsiView pMediaView(0);
	PMsiView pPatchView(0);
	MsiString strFirstVolumeLabel;
	
	if((pErrRec = OpenMediaView(riEngine, *&pMediaView, *&strFirstVolumeLabel))       != 0 ||
		(pErrRec = pMediaView->Execute(0))                                   != 0 ||
		(pErrRec = riEngine.OpenView(sqlPatchFiles, ivcFetch, *&pPatchView)) != 0 ||
		(pErrRec = pPatchView->Execute(0))                                   != 0)
	{
		if(pErrRec->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction;
		else
			return riEngine.FatalError(*pErrRec);
	}

	PMsiRecord pRecord(0); // fetched records
	
	int cExecuteFields = IxoPatchApply::Args;
	if(cExecuteFields < IxoAssemblyPatch::Args)
		cExecuteFields = IxoAssemblyPatch::Args;
	PMsiRecord pExecuteRecord = &pServices->CreateRecord(cExecuteFields); // passed to Engine::ExecuteRecord

	iesEnum iesExecute = iesNoAction; // return from Engine::ExecuteRecord

	// determine total size of all files to patch, used for progress
	unsigned int cbTotalCost = 0;
	while((pRecord = pPatchView->Fetch()) != 0)
	{
		Assert(pRecord->GetInteger(ipfqFileSize != iMsiNullInteger));
		Assert(pRecord->GetInteger(ipfqPatchSize != iMsiNullInteger));
		cbTotalCost += pRecord->GetInteger(ipfqFileSize);
		cbTotalCost += pRecord->GetInteger(ipfqPatchSize);
	}

	// set progress total
	unsigned int cbPerTick =0;
	if(cbTotalCost)
	{
		pExecuteRecord->ClearData();
		pExecuteRecord->SetInteger(1, cbTotalCost);
		pExecuteRecord->SetInteger(2, 0); // 0: separate progress and action data messages
		pExecuteRecord->SetInteger(IxoProgressTotal::ByteEquivalent, 1);
		if ((iesExecute = riEngine.ExecuteRecord(ixoProgressTotal,*pExecuteRecord)) != iesSuccess)
			return iesExecute;
	}

	if((pErrRec = pPatchView->Execute(0)) != 0)
		return riEngine.FatalError(*pErrRec);
		
	// start fetching records
	int iFilePatchCount = 0;
	int iMediaEnd = 0;  // set to 0 to force media table fetch
	MsiString strDiskPromptTemplate = riEngine.GetErrorTableString(imsgPromptForDisk);
	bool fCheckCRC = 
		MsiString(riEngine.GetPropertyFromSz(IPROPNAME_CHECKCRCS)).TextSize() ? true : false;
	for(;;)
	{
		pRecord = pPatchView->Fetch();
		if (!pRecord)
		{
			if (iFilePatchCount > 0)
			{
				// Ok, we're done processing all files in the File table.
				// If there are any Media table entries left unprocessed,
				// flush out ChangeMedia operations for each, in case the
				// last file copied was split across disk(s). Otherwise,
				// we'll never change disks to finish copying the last
				// part(s) of the split file.
				PMsiRecord pMediaRec(0);
				while ((pMediaRec = pMediaView->Fetch()) != 0)
				{
					iesExecute = ExecuteChangeMedia(riEngine,*pMediaRec,*pExecuteRecord,*strDiskPromptTemplate,cbPerTick,*strFirstVolumeLabel);
					if (iesExecute != iesSuccess)
						return iesExecute;
				}
			}
			break;
		}
		
		// get full file path of target file
		PMsiPath pTargetPath(0);
		if((pErrRec = pDirectoryMgr->GetTargetPath(*MsiString(pRecord->GetMsiString(ipfqDirectory)),
																 *&pTargetPath)) != 0)
			return riEngine.FatalError(*pErrRec);

		Bool fLFN = ((riEngine.GetMode() & iefSuppressLFN) == 0 && pTargetPath->SupportsLFN()) ? fTrue : fFalse;
		MsiString strFileName;
		if((pErrRec = pServices->ExtractFileName(MsiString(pRecord->GetMsiString(ipfqFileName)),
															  fLFN,*&strFileName)) != 0)
			return riEngine.FatalError(*pErrRec);

		MsiString strFileFullPath;
		if((pErrRec = pTargetPath->GetFullFilePath(strFileName, *&strFileFullPath)) != 0)
			return riEngine.FatalError(*pErrRec);
		
		// if patch sequence number is less than file sequence number, skip the patch
		// it means the file doesn't need the patch, since it is assumed to be newer or equal to what
		// the patch would change it to
		int iPatchSequence = pRecord->GetInteger(ipfqPatchSequence);
		int iFileSequence  = pRecord->GetInteger(ipfqFileSequence);
		Assert(iPatchSequence != iMsiNullInteger && iFileSequence != iMsiNullInteger);
		if(iPatchSequence < iFileSequence)
		{
			DEBUGMSG3(TEXT("Skipping patch for file '%s' because patch is older than file. Patch sequence number: %d, File sequence number: %d"),
						 (const ICHAR*)strFileFullPath, (const ICHAR*)(INT_PTR)iPatchSequence, (const ICHAR*)(INT_PTR)iFileSequence);
			continue;
		}

		// If iPatchSequence is past the end of the current media, switch to
		// the next disk.  Use a loop in case the file we want isn't on the
		// next consecutive disk.
		Assert(iPatchSequence > 0);
		while (iPatchSequence > iMediaEnd)
		{
			PMsiRecord pMediaRec(pMediaView->Fetch());
			if (pMediaRec == 0)
			{
				pErrRec = PostError(Imsg(idbgMissingMediaTable), *MsiString(sztblPatch),
					*MsiString(pRecord->GetString(ipfqFile)));
				return riEngine.FatalError(*pErrRec);
			}
			iMediaEnd = pMediaRec->GetInteger(mfnLastSequence);

			// Always execute the ChangeMedia operation for each Media table entry, even
			// if the next file we want is not on the very next disk - we don't want
			// to miss a ChangeMedia for a split file that needs the next disk (even if
			// we don't have any other files to copy on that next disk).  If it turns out
			// that we don't need to copy any files at all from a particular disk, no
			// problem - the execute operations won't prompt for a disk that isn't needed.
			
			// for patching, don't execute the ChangeMedia operation if we haven't gotten to the
			// media with the first patch file on it
			if(iFilePatchCount > 0 || iPatchSequence <= iMediaEnd)
			{
				iesExecute = ExecuteChangeMedia(riEngine,*pMediaRec,*pExecuteRecord,*strDiskPromptTemplate,cbPerTick,*strFirstVolumeLabel);
				if (iesExecute != iesSuccess)
					return iesExecute;
			}
		}

		// set up ixoPatchApply record

		// is this file part of a fusion assembly?
		MsiString strComponentKey = pRecord->GetMsiString(ipfqComponent);
		iatAssemblyType iatType = iatNone;
		MsiString strManifest;
		if((pErrRec = riEngine.GetAssemblyInfo(*strComponentKey, iatType, 0, &strManifest)) != 0)
			return riEngine.FatalError(*pErrRec);

		bool fAssemblyFile = false;
		if(iatType == iatURTAssembly || iatType == iatWin32Assembly)
		{
			fAssemblyFile = true;
		}
		
		MsiString strSourceFileKey(pRecord->GetMsiString(ipfqFile));
		if (((const ICHAR*)strSourceFileKey)[strSourceFileKey.TextSize() - 1] == ')') // check for compound key
			AssertNonZero(strSourceFileKey.Remove(iseFrom, '('));

		
		// set fields shared by IxoPatchApply and IxoAssemblyPatch
		{
			Assert(IxoFilePatchCore::PatchName       == IxoPatchApply::PatchName       && IxoFilePatchCore::PatchName       == IxoAssemblyPatch::PatchName);
			Assert(IxoFilePatchCore::TargetName      == IxoPatchApply::TargetName      && IxoFilePatchCore::TargetName      == IxoAssemblyPatch::TargetName);
			Assert(IxoFilePatchCore::PatchSize       == IxoPatchApply::PatchSize       && IxoFilePatchCore::PatchSize       == IxoAssemblyPatch::PatchSize);
			Assert(IxoFilePatchCore::TargetSize      == IxoPatchApply::TargetSize      && IxoFilePatchCore::TargetSize      == IxoAssemblyPatch::TargetSize);
			Assert(IxoFilePatchCore::PerTick         == IxoPatchApply::PerTick         && IxoFilePatchCore::PerTick         == IxoAssemblyPatch::PerTick);
			Assert(IxoFilePatchCore::IsCompressed    == IxoPatchApply::IsCompressed    && IxoFilePatchCore::IsCompressed    == IxoAssemblyPatch::IsCompressed);
			Assert(IxoFilePatchCore::FileAttributes  == IxoPatchApply::FileAttributes  && IxoFilePatchCore::FileAttributes  == IxoAssemblyPatch::FileAttributes);
			Assert(IxoFilePatchCore::PatchAttributes == IxoPatchApply::PatchAttributes && IxoFilePatchCore::PatchAttributes == IxoAssemblyPatch::PatchAttributes);
			
			using namespace IxoPatchApply;
			pExecuteRecord->ClearData();
			AssertNonZero(pExecuteRecord->SetMsiString(PatchName,*strSourceFileKey));
			AssertNonZero(pExecuteRecord->SetInteger(TargetSize,pRecord->GetInteger(ipfqFileSize)));
			AssertNonZero(pExecuteRecord->SetInteger(PatchSize,pRecord->GetInteger(ipfqPatchSize)));
			AssertNonZero(pExecuteRecord->SetInteger(PerTick,cbPerTick));
			AssertNonZero(pExecuteRecord->SetInteger(FileAttributes,pRecord->GetInteger(ipfqFileAttributes)));
			AssertNonZero(pExecuteRecord->SetInteger(PatchAttributes,pRecord->GetInteger(ipfqPatchAttributes)));
		}

		if(fAssemblyFile)
		{
			using namespace IxoAssemblyPatch;
			AssertNonZero(pExecuteRecord->SetMsiString(TargetName,*strFileName));
			AssertNonZero(pExecuteRecord->SetMsiString(ComponentId,*MsiString(pRecord->GetMsiString(ipfqComponentId))));

			// is this file the manifest file?
			if(strManifest.Compare(iscExact, strSourceFileKey))
			{
				pExecuteRecord->SetInteger(IsManifest, fTrue); // need to know the manifest file during assembly installation
			}

		}
		else
		{
			using namespace IxoPatchApply;
			AssertNonZero(pExecuteRecord->SetMsiString(TargetName,*strFileFullPath));
			AssertNonZero(pExecuteRecord->SetInteger(CheckCRC,ShouldCheckCRC(fCheckCRC, iisLocal, pRecord->GetInteger(ipfqFileAttributes))));
		}

		if((iesExecute = riEngine.ExecuteRecord(fAssemblyFile ? ixoAssemblyPatch : ixoPatchApply,
															 *pExecuteRecord)) != iesSuccess)
		{
			return iesExecute;
		}

		iFilePatchCount++;
	}

	return iesSuccess;
}

/*---------------------------------------------------------------------------
	CreateFolders and RemoveFolders actions
---------------------------------------------------------------------------*/
const ICHAR szCreateFolderTable[] = TEXT("CreateFolder");
const ICHAR sqlCreateFolders[] =
	TEXT("SELECT `CreateFolder`.`Directory_`, `ComponentId` FROM `CreateFolder`, `Component`")
	TEXT(" WHERE `Component_` = `Component` AND (`Action` = 1 OR `Action` = 2)");
const ICHAR sqlRemoveFolders[] =
	TEXT("SELECT `CreateFolder`.`Directory_`, `ComponentId` FROM `CreateFolder`, `Component`")
	TEXT(" WHERE `Component_` = `Component` AND (`Action` = 0)");

enum icfqEnum
{
	icfqFolder = 1,
	icfqComponent,
};

static iesEnum CreateOrRemoveFolders(IMsiEngine& riEngine, const ICHAR* sqlQuery, ixoEnum ixoOpCode)
{
	iesEnum iesRet = iesNoAction;
	if(PMsiDatabase(riEngine.GetDatabase())->FindTable(*MsiString(*szCreateFolderTable)) == itsUnknown)
		return iesNoAction;

	PMsiServices pServices(riEngine.GetServices());
	PMsiView pView(0);
	PMsiRecord pError(riEngine.OpenView(sqlQuery, ivcFetch, *&pView));
	if (!pError)
		pError = pView->Execute(0);
	if (pError)
		return riEngine.FatalError(*pError);

	Bool fUseACLs = fFalse;
	PMsiView pviewLockObjects(0);
	PMsiRecord precLockExecute(0);
	if (	g_fWin9X || 
			(riEngine.GetMode() & iefAdmin) || // don't use ACLs on Admin mode
			(itsUnknown == PMsiDatabase(riEngine.GetDatabase())->FindTable(*MsiString(*TEXT("LockPermissions")))) ||
			(pError = riEngine.OpenView(sqlLockPermissions, ivcFetch, *&pviewLockObjects)))
	{
		if (pError)
				return riEngine.FatalError(*pError);
	}
	else
		fUseACLs = fTrue;
	
	if (fUseACLs)
	{
		precLockExecute = &pServices->CreateRecord(2);
		AssertNonZero(precLockExecute->SetMsiString(1, *MsiString(*szCreateFolderTable)));
	}


	PMsiRecord pParams(&pServices->CreateRecord(IxoFolderCreate::Args));
	PMsiRecord pRecord(0);
	while ((pRecord = pView->Fetch()) != 0)       
	{
		MsiString strFolder(pRecord->GetMsiString(icfqFolder));

		PMsiStream pSD(0);

		if (fUseACLs && (ixoFolderCreate == ixoOpCode))
		{
			// generate security descriptor
			AssertNonZero(precLockExecute->SetMsiString(2, *strFolder));
			pError = pviewLockObjects->Execute(precLockExecute);
			if (pError)
				return riEngine.FatalError(*pError);

			pError = GenerateSD(riEngine, *pviewLockObjects, precLockExecute, *&pSD);
			if (pError)
				return riEngine.FatalError(*pError);

			if ((pError = pviewLockObjects->Close()))
				return riEngine.FatalError(*pError);
			
			AssertNonZero(pParams->SetMsiData(IxoFolderCreate::SecurityDescriptor, pSD));
		}


		// folder locations are stored in properties after DirectoryInitialize
		AssertNonZero(pParams->SetMsiString(IxoFolderCreate::Folder,
														*MsiString(riEngine.GetProperty(*strFolder))));
		AssertNonZero(pParams->SetInteger(IxoFolderCreate::Foreign, 0));

		if((iesRet = riEngine.ExecuteRecord(ixoOpCode, *pParams)) != iesSuccess)
			return iesRet;
	}
	return iesSuccess;
}

iesEnum CreateFolders(IMsiEngine& riEngine)
{
	return ::CreateOrRemoveFolders(riEngine, sqlCreateFolders, ixoFolderCreate);
}

iesEnum RemoveFolders(IMsiEngine& riEngine)
{
	return ::CreateOrRemoveFolders(riEngine, sqlRemoveFolders, ixoFolderRemove);
}

/*---------------------------------------------------------------------------
	InstallAdminPackage action - 
		Copies database to Admin install point, update summary info and strips
		out cabinets and digital signature

    OR

		Patches admin package by persisting transforms and updating suminfo props
---------------------------------------------------------------------------*/

const ICHAR szDigitalSignatureStream[] = TEXT("\005DigitalSignature");
const ICHAR sqlAdminPatchTransforms[] = TEXT("SELECT `PatchId`, `PackageName`, `TransformList`, `TempCopy`, `SourcePath` FROM `#_PatchCache` ORDER BY `Sequence`");

enum aptEnum
{
	aptPatchId = 1,
	aptPackageName,
	aptTransformList,
	aptTempCopy,
	aptSourcePath,
};

iesEnum InstallAdminPackage(IMsiEngine& riEngine)
{
	iesEnum iesRet;
	PMsiRecord pRecErr(0);
	PMsiServices pServices(riEngine.GetServices());
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiDirectoryManager pDirectoryManager(riEngine, IID_IMsiDirectoryManager);

	Bool fSuppressLFN = riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;

	Bool fPatch = MsiString(riEngine.GetPropertyFromSz(IPROPNAME_PATCH)).TextSize() ? fTrue : fFalse;

	MsiString strDbFullFilePath = riEngine.GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE);
	MsiString strDbTargetFullFilePath;

	// nested installs in substorages will get copied with the parent storage
	// but we need to process the summaryinfo changes if the files are copied
	bool fSubstorage = false;
	if (*(const ICHAR*)strDbFullFilePath == ':')  // substorage for nested install
		fSubstorage = true;
	else if(PathType(strDbFullFilePath) != iptFull)
	{
		pRecErr = PostError(Imsg(idbgPropValueNotFullPath),*MsiString(*IPROPNAME_ORIGINALDATABASE),*strDbFullFilePath);
		return riEngine.FatalError(*pRecErr);
	}

	if(fPatch)
	{
		// apply and persist a set of transforms to the existing database
		PMsiView pView(0);
		if((pRecErr = riEngine.OpenView(sqlAdminPatchTransforms, ivcFetch, *&pView)) == 0 &&
			(pRecErr = pView->Execute(0)) == 0)
		{	
			using namespace IxoDatabasePatch;

			PMsiRecord pFetchRecord(0);
			while((pFetchRecord = pView->Fetch()) != 0)
			{
				MsiString strPatchId = pFetchRecord->GetMsiString(aptPatchId);
				MsiString strTempCopy = pFetchRecord->GetMsiString(aptTempCopy);
				MsiString strTransformList = pFetchRecord->GetMsiString(aptTransformList);
				Assert(strPatchId.TextSize());
				Assert(strTempCopy.TextSize());
				Assert(strTransformList.TextSize());

				// create storage on patch to access imbedded streams
				PMsiStorage pPatchStorage(0);
				if ((pRecErr = pServices->CreateStorage(strTempCopy, ismReadOnly, *&pPatchStorage)) != 0)
				{
					return riEngine.FatalError(*pRecErr); //!! new error?
				}

				const ICHAR* pchTransformList = strTransformList;
				int cCount = 0;
				while(*pchTransformList != 0)
				{
					cCount++;
					while((*pchTransformList != 0) && (*pchTransformList++ != ';'));
				}

				PMsiRecord pExecuteRecord = &pServices->CreateRecord(DatabasePath+cCount);
				PMsiRecord pTempFilesRecord = &pServices->CreateRecord(cCount);

				// set database path
				AssertNonZero(pExecuteRecord->SetMsiString(IxoDatabasePatch::DatabasePath,*strDbFullFilePath));
				
				cCount = DatabasePath + 1;
				int iTempFilesIndex = 1;
				while(strTransformList.TextSize() != 0)
				{
					MsiString strTransform = strTransformList.Extract(iseUpto, ';');

					PMsiStream pStream(0);
					Bool fStorageTransform = fFalse;
					Bool fPatchTransform = fFalse;
					if(*(const ICHAR*)strTransform == STORAGE_TOKEN)
						fStorageTransform = fTrue;

					if(*((const ICHAR*)strTransform + (fStorageTransform ? 1 : 0)) == PATCHONLY_TOKEN)
						fPatchTransform = fTrue;

					if(!fPatchTransform) // only persist non-patch transforms to admin package
					{
						PMsiPath pTempPath(0);
						MsiString strTempName;
						MsiString strTempFileFullPath;
						if(!fStorageTransform)
						{
							// cache the transform
							if(pRecErr = pServices->CreateFileStream(strTransform, fFalse, *&pStream))
							{
								//!! reformat error message?
								break;
							}
						}
						else // transform is in the storage
						{
							if(pRecErr = pServices->CreatePath(MsiString(GetTempDirectory()),
																		  *&pTempPath))
								break;
							
							// need to elevate when writing to secured folder
							{
								CElevate elevate;
								
								if(pRecErr = pTempPath->TempFileName(0,0,fTrue,*&strTempName, 0))
									break;

								if(pRecErr = pTempPath->GetFullFilePath(strTempName,*&strTempFileFullPath))
									break;
								
								AssertNonZero(pTempFilesRecord->SetMsiString(iTempFilesIndex++, *strTempFileFullPath));

								PMsiStorage pTransformStorage(0);
								if(pRecErr = pPatchStorage->OpenStorage(((const ICHAR*)strTransform)+1,ismReadOnly,
																				  *&pTransformStorage))
									break;

								PMsiStorage pTransformFileStorage(0);
								if(pRecErr = pServices->CreateStorage(strTempFileFullPath,ismCreate,
																				 *&pTransformFileStorage))
									break;

								if(pRecErr = pTransformStorage->CopyTo(*pTransformFileStorage,0))
									break;

								if(pRecErr = pTransformFileStorage->Commit())
									break;

								pTransformFileStorage = 0; // release so that a stream can be opened
								
								// cache the transform
								if(pRecErr = pServices->CreateFileStream(strTempFileFullPath, fFalse, *&pStream))
									break;

								// end elevate block
							}
						}

						AssertNonZero(pExecuteRecord->SetMsiData(cCount++, pStream));
					}
					
					strTransformList.Remove(iseFirst, strTransform.CharacterCount());
					if((*(const ICHAR*)strTransformList == ';'))
						strTransformList.Remove(iseFirst, 1);
				}
				
				if(!pRecErr)
				{
					if((iesRet = riEngine.ExecuteRecord(ixoDatabasePatch,*pExecuteRecord)) != iesSuccess)
						return iesRet;
				}

				pExecuteRecord = 0; // releases hold on any temp files

				// remove any temp transform files
				{
					CElevate elevate; // need to elevate to delete files from secured folder
					for(int i = 1; i < iTempFilesIndex; i++)
						AssertNonZero(WIN::DeleteFile(pTempFilesRecord->GetString(i)));
				}
			
				if(pRecErr)
					return riEngine.FatalError(*pRecErr);
			}	
		}
		else if(pRecErr->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pRecErr);

		// update summary info properties in admin package
		using namespace IxoSummaryInfoUpdate;
		
		MsiString strNewPackageCode = riEngine.GetPropertyFromSz(IPROPNAME_PATCHNEWPACKAGECODE);
		MsiString strNewSummarySubject = riEngine.GetPropertyFromSz(IPROPNAME_PATCHNEWSUMMARYSUBJECT);
		MsiString strNewSummaryComments = riEngine.GetPropertyFromSz(IPROPNAME_PATCHNEWSUMMARYCOMMENTS);
			
		PMsiRecord pUpdateSumInfoRec = &pServices->CreateRecord(IxoSummaryInfoUpdate::Args);
		AssertNonZero(pUpdateSumInfoRec->SetMsiString(Database, *strDbFullFilePath));
		AssertNonZero(pUpdateSumInfoRec->SetMsiString(Revision, *strNewPackageCode));
		AssertNonZero(pUpdateSumInfoRec->SetMsiString(Subject, *strNewSummarySubject));
		AssertNonZero(pUpdateSumInfoRec->SetMsiString(Comments, *strNewSummaryComments));

		if((iesRet = riEngine.ExecuteRecord(ixoSummaryInfoUpdate,*pUpdateSumInfoRec)) != iesSuccess)
			return iesRet;
		
	}
	else if (!fSubstorage)  //!! temporary until logic implemented
	{
		// copy database to network image

		MsiString strDbName;
		PMsiPath pSourcePath(0);
		if((pRecErr = pServices->CreateFilePath(strDbFullFilePath,*&pSourcePath,*&strDbName)) != 0)
			return riEngine.FatalError(*pRecErr);

		PMsiPath pTargetPath(0);
		if((pRecErr = pDirectoryManager->GetTargetPath(*MsiString(*IPROPNAME_TARGETDIR),*&pTargetPath)) != 0)
			return riEngine.FatalError(*pRecErr);
		if((pRecErr = pTargetPath->GetFullFilePath(strDbName,*&strDbTargetFullFilePath)) != 0)
			return riEngine.FatalError(*pRecErr);
		
		// Open media table
		PMsiView pMediaView(0);
		MsiString strFirstVolumeLabel;
		pRecErr = OpenMediaView(riEngine,*&pMediaView,*&strFirstVolumeLabel);
		if (pRecErr)
		{
			if (pRecErr->GetInteger(1) == idbgDbQueryUnknownTable)
				pRecErr = PostError(Imsg(idbgMediaTableRequired));

			return riEngine.FatalError(*pRecErr);
		}
		pRecErr = pMediaView->Execute(0);
		if (pRecErr)
			return riEngine.FatalError(*pRecErr);

		PMsiRecord pMediaRec(0);
		PMsiRecord pChangeMediaParams = &pServices->CreateRecord(IxoChangeMedia::Args);
		pMediaRec = pMediaView->Fetch();
		if(!pMediaRec)
		{
			pRecErr = PostError(Imsg(idbgMediaTableRequired));
				return riEngine.FatalError(*pRecErr);
		}
		MsiString strDiskPromptTemplate = riEngine.GetErrorTableString(imsgPromptForDisk);
		if((iesRet = ExecuteChangeMedia(riEngine, *pMediaRec, *pChangeMediaParams, *strDiskPromptTemplate, iBytesPerTick, *strFirstVolumeLabel)) != iesSuccess)
			return iesRet;

		MsiString strStreams;
		CreateCabinetStreamList(riEngine, *&strStreams);

		using namespace IxoDatabaseCopy;
		PMsiRecord pDatabaseCopyParams = &pServices->CreateRecord(Args);
		AssertNonZero(pDatabaseCopyParams->SetMsiString(DatabasePath, *strDbFullFilePath));
		AssertNonZero(pDatabaseCopyParams->SetMsiString(CabinetStreams, *strStreams));
		AssertNonZero(pDatabaseCopyParams->SetMsiString(AdminDestFolder, *MsiString(riEngine.GetPropertyFromSz(IPROPNAME_TARGETDIR))));
		if((iesRet = riEngine.ExecuteRecord(ixoDatabaseCopy, *pDatabaseCopyParams)) != iesSuccess)
			return iesRet;

		// admin property stream
		const ICHAR chDelimiter = TEXT(';');
		MsiString strAdminPropertiesName(*IPROPNAME_ADMIN_PROPERTIES);
		MsiString strAdminProperties(riEngine.GetProperty(*strAdminPropertiesName));

		riEngine.SetProperty(*MsiString(*IPROPNAME_ISADMINPACKAGE),*MsiString(TEXT("1")));
		if (strAdminProperties.TextSize())
			strAdminProperties += MsiChar(chDelimiter);
		strAdminProperties += *MsiString(*IPROPNAME_ISADMINPACKAGE);

		// provide new summary information for copied database
		using namespace IxoSummaryInfoUpdate;
		PMsiRecord pSummary = &pServices->CreateRecord(IxoSummaryInfoUpdate::Args);
		if (PMsiVolume(&pSourcePath->GetVolume())->DriveType() == idtCDROM)
		{
			// set MEDIAPACKAGEPATH so it can be put in the admin property stream below
			MsiString strRelativePath = pSourcePath->GetRelativePath();
			riEngine.SetProperty(*MsiString(*IPROPNAME_MEDIAPACKAGEPATH), *strRelativePath);
			if (strAdminProperties.TextSize())
				strAdminProperties += MsiChar(chDelimiter);
			
			strAdminProperties += *MsiString(*IPROPNAME_MEDIAPACKAGEPATH);
		}

		int iSourceType = msidbSumInfoSourceTypeAdminImage;
		if(PMsiVolume(&pTargetPath->GetVolume())->SupportsLFN() == fFalse || fSuppressLFN != fFalse)
			iSourceType |= msidbSumInfoSourceTypeSFN;
		
		MsiDate idDateTime = ENG::GetCurrentDateTime();
		pSummary->SetMsiString(Database, *strDbTargetFullFilePath);
		/*pSummary->SetNull(LastUpdate);*/ //!! why isn't this set? what is its purpose? - BENCH
		pSummary->SetMsiString(LastAuthor, *MsiString(riEngine.GetPropertyFromSz(IPROPNAME_LOGONUSER)));
		pSummary->SetInteger(InstallDate, idDateTime);
		pSummary->SetInteger(SourceType, iSourceType);
		if((iesRet = riEngine.ExecuteRecord(ixoSummaryInfoUpdate, *pSummary)) != iesSuccess)
			return iesRet;

		// generate new admin property stream
		
		// set DISABLEMEDIA in the AdminProperties stream if running against a compressed package that doesn't require
		// 1.5 MSI and the MSINODISABLEMEDIA property is not set
		int iMinInstallerVersion = riEngine.GetPropertyInt(*MsiString(IPROPNAME_VERSIONDATABASE));
		if ((iMinInstallerVersion == iMsiStringBadInteger || iMinInstallerVersion < 150) &&
			 MsiString(riEngine.GetProperty(*MsiString(IPROPNAME_MSINODISABLEMEDIA))).TextSize() == 0 &&
			 riEngine.GetMode() & iefCabinet)
		{
			riEngine.SetPropertyInt(*MsiString(*IPROPNAME_DISABLEMEDIA), 1);
			if (strAdminProperties.TextSize())
				strAdminProperties += MsiChar(chDelimiter);
			strAdminProperties += *MsiString(*IPROPNAME_DISABLEMEDIA);
		}

		// Note that we pass through *all* properties specified, not just the ones
		// that have changed.  This allows external tools better access to the available
		// values.
		if (strAdminProperties.TextSize())
		{
			using namespace IxoStreamAdd;

			PMsiRecord pAdminParams = &pServices->CreateRecord(IxoStreamAdd::Args);
			Assert(pAdminParams);

			AssertNonZero(pAdminParams->SetMsiString(File, *strDbTargetFullFilePath));
			AssertNonZero(pAdminParams->SetMsiString(Stream, *strAdminPropertiesName));

			// build command line string, and pass in as data.
			MsiString strData;
			MsiString strProperty;
			MsiString strPropertyValue;
			MsiString strSegment;

			while(strAdminProperties.TextSize())
			{
				strProperty = strAdminProperties.Extract(iseUpto, chDelimiter);
				strData += strProperty;
				strPropertyValue = riEngine.GetProperty(*strProperty);

				strData += TEXT("=\"");
				strPropertyValue = riEngine.GetProperty(*strProperty);

				MsiString strEscapedValue;
				while (strPropertyValue.TextSize()) // Escape quotes. Change all instances of " to ""
				{
					strSegment = strPropertyValue.Extract(iseIncluding, '\"');
					strEscapedValue += strSegment;
					if (!strPropertyValue.Remove(iseIncluding, '\"'))
						break;
					strEscapedValue += TEXT("\"");
				}
				strData += strEscapedValue;
				strData += TEXT("\" ");

				if (!strAdminProperties.Remove(iseIncluding, chDelimiter))
					break;
			}

			PMsiStream pData(0);
			char* pbData;
			// copy the data string into a UNICODE stream.

#ifdef UNICODE
			int cchData = strData.TextSize();
			pbData = pServices->AllocateMemoryStream((cchData+1) * sizeof(ICHAR), *&pData);
			Assert(pbData && pData);
			memcpy(pbData, (const ICHAR*) strData, cchData * sizeof(ICHAR));
			((ICHAR*)pbData)[cchData] = 0; // null terminate
#else
			int cchWideNeeded = WIN::MultiByteToWideChar(CP_ACP, 0, (const ICHAR*) strData, -1, 0, 0);
			pbData = pServices->AllocateMemoryStream(cchWideNeeded*sizeof(WCHAR), *&pData);
			WIN::MultiByteToWideChar(CP_ACP, 0, (const ICHAR*) strData, -1, (WCHAR*) pbData, cchWideNeeded);
#endif
			AssertNonZero(pAdminParams->SetMsiData(Data, pData));
			if (iesSuccess != (iesRet = riEngine.ExecuteRecord(ixoStreamAdd, *pAdminParams)))
				return iesRet;
		}
	}

	if (fPatch || !fSubstorage)
	{
		// remove digital signature stream if present
		PMsiStorage pStorage = pDatabase->GetStorage(1);
		PMsiStream pDgtlSig(0);
		pRecErr = pStorage->OpenStream(szDigitalSignatureStream, /* fWrite = */fFalse, *&pDgtlSig);
		if (pRecErr)
		{
			if (idbgStgStreamMissing == pRecErr->GetInteger(1))
			{
				// MSI does not have a digital signature, so release error and ignore
				pRecErr->Release();
			}
			else
				return riEngine.FatalError(*pRecErr);
		}
		else // MSI has a digital signature
		{
			// execute record to remove stream
			using namespace IxoStreamsRemove;
			PMsiRecord pRemoveDgtlSig = &pServices->CreateRecord(IxoStreamsRemove::Args);
			Assert(pRemoveDgtlSig); // fail??

			AssertNonZero(pRemoveDgtlSig->SetMsiString(File, fPatch ? *strDbFullFilePath : *strDbTargetFullFilePath));
			AssertNonZero(pRemoveDgtlSig->SetMsiString(Streams, *MsiString(szDigitalSignatureStream)));

			if((iesRet = riEngine.ExecuteRecord(ixoStreamsRemove, *pRemoveDgtlSig)) != iesSuccess)
			return iesRet;
		}
	}

	
	return iesSuccess;
}

/*---------------------------------------------------------------------------
	IsolateComponents action
---------------------------------------------------------------------------*/

const IMsiString& CompositeKey(const IMsiString& riKey, const IMsiString& riComponent)
{
	ICHAR rgchBuf[512]; // current limits are 72 chars for both strings
	AssertNonZero(SUCCEEDED(StringCbPrintf(rgchBuf, sizeof(rgchBuf), TEXT("%s(%s)"), riKey.GetString(), riComponent.GetString()) < sizeof(rgchBuf)/sizeof(ICHAR)));
	MsiString strRet = rgchBuf;
	return strRet.Return();
}

IMsiStream* CreateStreamOnMemory(const char* pbReadOnly, unsigned int cbSize);

const ICHAR sqlPatchFetchOld[] = TEXT("SELECT `File_`,`Sequence`,`PatchSize`,`Attributes`, NULL FROM `Patch` WHERE File_ = ?");
const ICHAR sqlPatchInsertOld[] = TEXT("SELECT `File_`,`Sequence`,`PatchSize`,`Attributes`,`Header` FROM `Patch`");

const ICHAR sqlPatchFetchNew[] = TEXT("SELECT `File_`,`Sequence`,`PatchSize`,`Attributes`, NULL, `StreamRef_` FROM `Patch` WHERE File_ = ?");
const ICHAR sqlPatchInsertNew[] = TEXT("SELECT `File_`,`Sequence`,`PatchSize`,`Attributes`,`Header`,`StreamRef_` FROM `Patch`");

iesEnum IsolateComponents(IMsiEngine& riEngine)
{
	if ((riEngine.GetMode() & iefSecondSequence) && g_scServerContext == scClient)
	{
		DEBUGMSG("Skipping IsolateComponents: action already run in this engine.");
		return iesNoAction;
	}

	PMsiRecord pError(0);
	PMsiServices pServices(riEngine.GetServices());
	PMsiDatabase pDatabase(riEngine.GetDatabase());

	// Check for existence of IsolatedComponent table
	if (!pDatabase->GetTableState(TEXT("IsolatedComponent"), itsTableExists))
		return iesNoAction;

	// Prepare views on the various tables up front for efficiency
	PMsiView pIsolateView(0);
	PMsiView pComponentView(0);
	PMsiView pFileView(0);
	PMsiView pFileKeyView(0);
	PMsiView pFeatureView1(0);
	PMsiView pFeatureView2(0);
	PMsiView pBindView(0);
	PMsiView pPatchFetchView(0);
	PMsiView pPatchInsertView(0);
	bool fUsedOldPatchSchema = false;

	if ((pError = pDatabase->OpenView(TEXT("SELECT `Component_Shared`,`Component_Application` FROM `IsolatedComponent`"), ivcFetch, *&pIsolateView)) != 0
	 || (pError = pDatabase->OpenView(TEXT("SELECT `Component`,`RuntimeFlags`,`KeyPath`, `Attributes` FROM `Component` WHERE `Component` = ?"), ivcFetch, *&pComponentView)) != 0
	 || (pError = pDatabase->OpenView(TEXT("SELECT `File`,`Component_`,`FileName`,`FileSize`,`Version`,`Language`,`Attributes`,`Sequence` FROM File WHERE `Component_` = ?"), ivcFetch, *&pFileView)) != 0
	 || (pError = pDatabase->OpenView(TEXT("SELECT `File`,`Component_`,`FileName`,`FileSize`,`Version`,`Language`,`Attributes`,`Sequence` FROM File WHERE `File` = ?"), ivcFetch, *&pFileKeyView)) != 0
	 || (pError = pDatabase->OpenView(TEXT("SELECT `Feature_` FROM `FeatureComponents` WHERE `Component_` = ?"), ivcFetch, *&pFeatureView1)) != 0
	 || (pError = pDatabase->OpenView(TEXT("SELECT NULL FROM `FeatureComponents` WHERE `Feature_` = ? AND `Component_` = ?"), ivcFetch, *&pFeatureView2)) != 0
	 || (pDatabase->GetTableState(TEXT("BindImage"), itsTableExists)
	 && (pError = pDatabase->OpenView(TEXT("SELECT `File_`,`Path` FROM BindImage WHERE File_ = ?"), ivcFetch, *&pBindView)) != 0))
		return riEngine.FatalError(*pError);

	if (pDatabase->GetTableState(TEXT("Patch"), itsTableExists))
	{
		// try new Patch table schema first
		if ((pError = pDatabase->OpenView(sqlPatchFetchNew, ivcFetch, *&pPatchFetchView)) != 0)
		{
			if (pError->GetInteger(1) == idbgDbQueryUnknownColumn)
			{
				// try old Patch table schema
				fUsedOldPatchSchema = true;
				if ((pError = pDatabase->OpenView(sqlPatchFetchOld, ivcFetch, *&pPatchFetchView)) != 0
					|| (pError = pDatabase->OpenView(sqlPatchInsertOld, ivcFetch, *&pPatchInsertView)) != 0)
					return riEngine.FatalError(*pError);
			}
			else
				return riEngine.FatalError(*pError);
		}
		else if ((pError = pDatabase->OpenView(sqlPatchInsertNew, ivcFetch, *&pPatchInsertView)) != 0)
			return riEngine.FatalError(*pError);
	}

	int iIsolateLevel = riEngine.GetPropertyInt(*MsiString(*IPROPNAME_REDIRECTEDDLLSUPPORT));
	if(iIsolateLevel == iMsiNullInteger)
		return iesSuccess; // there is no support for isolation

	PMsiRecord pParams(&ENG::CreateRecord(2));

	// Loop to process rows in IsolatedComponent table
	if ((pError = pIsolateView->Execute(0)) != 0)
		return riEngine.FatalError(*pError);
	PMsiRecord pIsolateRow(0);
	while((pIsolateRow = pIsolateView->Fetch()) != 0)
	{
		MsiString strSharedComponent  = pIsolateRow->GetMsiString(1);
		MsiString strPrivateComponent = pIsolateRow->GetMsiString(2);

		// Fetch shared component from Component table, set ForceOverwrite attribute
		pParams->SetMsiString(1, *strSharedComponent);
		if ((pError = pComponentView->Execute(pParams)) != 0)
			return riEngine.FatalError(*pError);
		PMsiRecord pComponentRow = pComponentView->Fetch();
		if (!pComponentRow)
			return riEngine.FatalError(*PMsiRecord(PostError(Imsg(idbgIsolateNoSharedComponent), *strSharedComponent)));
		int iRuntimeFlags= pComponentRow->GetInteger(2);
		if (iRuntimeFlags == iMsiNullInteger)
			iRuntimeFlags = 0;

		// if component is a Win32 assembly AND SXS support is present on the machine, then do not 
		// process the component as an IsolateComponent
		// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
		// Win32 assemblies, hence there is no need to separately check the SXS support here
		iatAssemblyType iatAT;
		if ((pError = riEngine.GetAssemblyInfo(*strSharedComponent, iatAT, 0, 0)) != 0)
			return riEngine.FatalError(*pError);

		if(iatWin32Assembly == iatAT || iatWin32AssemblyPvt == iatAT)
		{
			DEBUGMSG1(TEXT("skipping processing of isolate component %s as it is a Win32 assembly."), strSharedComponent);
			continue;// skip processing this component as an isolate component
		}

		pComponentRow->SetInteger(2, iRuntimeFlags | bfComponentNeverOverwrite);

		if ((pError = pComponentView->Modify(*pComponentRow, irmUpdate)) != 0)      
			return riEngine.FatalError(*pError);

		// Validate that components supplied are part of same feature, !!could remove when validation implemented
		pParams->SetMsiString(1, *strPrivateComponent);
		if ((pError = pFeatureView1->Execute(pParams)) != 0)
			return riEngine.FatalError(*pError);
		PMsiRecord pFeatureRow = pFeatureView1->Fetch();
		if (!pFeatureRow)
			return riEngine.FatalError(*PMsiRecord(PostError(Imsg(idbgBadFeature), *strPrivateComponent)));
		MsiString strFeature = pFeatureRow->GetMsiString(1);
		pParams->SetMsiString(1, *strFeature);
		pParams->SetMsiString(2, *strSharedComponent);
		if ((pError = pFeatureView2->Execute(pParams)) != 0)
			return riEngine.FatalError(*pError);
		pFeatureRow = pFeatureView2->Fetch();
		if (!pFeatureRow)
			return riEngine.FatalError(*PMsiRecord(PostError(Imsg(idbgIsolateNotSameFeature), *strPrivateComponent, *strSharedComponent)));
		// Could walk up feature tree with application feature to see if shared component in a parent feature

		// Duplicate all files in shared component, creating compound File key and changing the component the to application
		pParams->SetMsiString(1, *strSharedComponent);
		if ((pError = pFileView->Execute(pParams)) != 0)
			return riEngine.FatalError(*pError);
		PMsiRecord pFileRow(0);
		PMsiRecord pFileKeyRow(0);
		while((pFileRow = pFileView->Fetch()) != 0)
		{
			MsiString strFileKey = pFileRow->GetMsiString(1);
			MsiString strVersion = pFileRow->GetMsiString(5);
			pFileRow->SetMsiString(1, *MsiString(CompositeKey(*strFileKey, *strPrivateComponent)));
			pFileRow->SetMsiString(2, *strPrivateComponent);
			DWORD dwMS, dwLS;
			if (::ParseVersionString(strVersion, dwMS, dwLS) == fFalse) // not a version, not null, must be a companion file ref
			{
				pParams->SetMsiString(1, *strVersion);
				if ((pError = pFileKeyView->Execute(pParams)) != 0)
					return riEngine.FatalError(*pError);
				pFileKeyRow = pFileKeyView->Fetch();
				if (!pFileKeyRow)
					return riEngine.FatalError(*PMsiRecord(PostError(Imsg(idbgNoCompanionParent), *strVersion)));
				if (MsiString(pFileKeyRow->GetMsiString(2)).Compare(iscExact, strSharedComponent) == 1)
				 	pFileRow->SetMsiString(5, *MsiString(CompositeKey(*strVersion, *strPrivateComponent)));
			}
			//!! Avoid bug inserting into same view being fetched in a read-only database
			pParams->SetNull(1);  // value doesn't matter, we never will fetch
			if ((pError = pFileKeyView->Execute(pParams)) != 0)
				return riEngine.FatalError(*pError);
			if ((pError = pFileKeyView->Modify(*pFileRow, irmInsertTemporary)) != 0)
				return riEngine.FatalError(*pError);

			//  Check BindImage table for bound executables and duplicate rows if found
			if (pBindView)
			{
				pParams->SetMsiString(1, *strFileKey);
				if ((pError = pBindView->Execute(pParams)) != 0)
					return riEngine.FatalError(*pError);
				PMsiRecord pBindRow = pBindView->Fetch();
				if (pBindRow)
				{
					pBindRow->SetMsiString(1, *MsiString(pFileRow->GetMsiString(1)));
					if ((pError = pBindView->Modify(*pBindRow, irmInsertTemporary)) != 0)
						return riEngine.FatalError(*pError);
				}
			}

			// Check Patch table for patched files and duplicate rows if found
			// the header information does not have to be duplicated because the InstallFiles and PatchFiles code is smart enough
			// to detect the special IsolateComponents naming convention and redirect to the correct entry
			if (pPatchInsertView)
			{
				pParams->SetMsiString(1, *strFileKey);
				if ((pError = pPatchFetchView->Execute(pParams)) != 0)
					return riEngine.FatalError(*pError);
				if ((pError = pPatchInsertView->Execute(0)) != 0)
					return riEngine.FatalError(*pError);
				PMsiRecord pPatchRow = pPatchFetchView->Fetch();
				if (pPatchRow)
				{
					pPatchRow->SetMsiString(1, *MsiString(pFileRow->GetMsiString(1)));
					// only create the header stream (0-length stream) if this is the old Patch table view OR new Patch table view and StreamRef_ is NULL
					// otherwise, leaving all fields as before is fine
					if (fUsedOldPatchSchema || fTrue == pPatchRow->IsNull(6))
						pPatchRow->SetMsiData(5, PMsiStream(CreateStreamOnMemory((const char*)0, 0)));
					if ((pError = pPatchInsertView->Modify(*pPatchRow, irmInsertTemporary)) != 0)
						return riEngine.FatalError(*pError);
				}
			}
		} // end while fetch pFileView

		//  Generate the .LOCAL file entry and insert in file table
		pParams->SetMsiString(1, *strPrivateComponent);
		if ((pError = pComponentView->Execute(pParams)) != 0)
			return riEngine.FatalError(*pError);
		pComponentRow = pComponentView->Fetch();
		if (!pComponentRow)
			return riEngine.FatalError(*PMsiRecord(PostError(Imsg(idbgIsolateNoApplicationComponent), *strPrivateComponent)));
		MsiString strFileKey = pComponentRow->GetMsiString(3);
		pParams->SetMsiString(1, *strFileKey);
		if ((pError = pFileKeyView->Execute(pParams)) != 0)
			return riEngine.FatalError(*pError);
		pFileKeyRow = pFileKeyView->Fetch();
		if (!pFileKeyRow)
			return riEngine.FatalError(*PMsiRecord(PostError(Imsg(idbgIsolateNoKeyFile), *strFileKey)));
		// Generate unique File table key using same mechanism used for duplicated files
		strFileKey = CompositeKey(*strFileKey, *strPrivateComponent);
		pFileKeyRow->SetMsiString(1, *strFileKey);
		//  Component_ left as application Component_
		//  FileName need .LOCAL appended, must also make some short file name to avoid installer errors
		MsiString strShortName = MsiString(pFileKeyRow->GetMsiString(3)).Extract(iseUpto,  '|');
		MsiString strLongName  = MsiString(pFileKeyRow->GetMsiString(3)).Extract(iseAfter, '|');
		CTempBuffer<ICHAR,1> rgchBuf(MAX_PATH);
		StringCchPrintf(rgchBuf, rgchBuf.GetSize(), TEXT("%s.~~~|%s.LOCAL"), (const ICHAR*)MsiString(strShortName.Extract(iseUpto, '.')), (const ICHAR*)strLongName);
		pFileKeyRow->SetString(3, rgchBuf); // FileName
		pFileKeyRow->SetInteger(4, 0);      // FileSize
		pFileKeyRow->SetNull(5);            // Version
		pFileKeyRow->SetNull(6);            // Language
		pFileKeyRow->SetInteger(7, msidbFileAttributesNoncompressed | msidbFileAttributesCompressed);
		// Sequence left same as application Sequence, for runtime efficiency
		if ((pError = pFileView->Modify(*pFileKeyRow, irmMerge)) != 0)
			return riEngine.FatalError(*pError);
	} // end while fetch pIsolateView
	return iesSuccess;
}

// FN: FindNonDisabledPvtComponents
// checks if there is a component associated with szComponent in the IsolatedComponent table
// that is not disabled
// returns true in fPresent, if there is, false otherwise
// returns IMsiRecord error on error 
IMsiRecord* FindNonDisabledPvtComponents(IMsiEngine& riEngine, const ICHAR szComponent[], bool& fPresent)
{
	PMsiView pIsolateView(0);
	PMsiDatabase pDatabase(riEngine.GetDatabase());

	IMsiRecord *piError = 0;
	const ICHAR* szIsolateComponent = TEXT("SELECT `Component`.`RuntimeFlags` FROM `IsolatedComponent`, `Component` WHERE `IsolatedComponent`.`Component_Shared` = `Component`.`Component` AND `IsolatedComponent`.`Component_Application` = ?");
	if ((piError = pDatabase->OpenView(szIsolateComponent, ivcFetch, *&pIsolateView)) != 0)
		return piError;

	PMsiRecord pParams(&ENG::CreateRecord(1));
	pParams->SetString(1, szComponent);
	if ((piError = pIsolateView->Execute(pParams)) != 0)
		return piError;
	fPresent = false;
	PMsiRecord pIsolateRow(0);
	while((pIsolateRow = pIsolateView->Fetch()) != 0)
	{
		if(!(pIsolateRow->GetInteger(1) & bfComponentDisabled))
		{
			fPresent = true;
			return 0;
		}
	}
	return 0;
}


// FN: RemoveIsolateEntriesForDisabledComponent
// checks if there is a component that has become disabled has an entry in the IsolatedComponent table
// is yes, it removes entries if any from the file, patch and bindimage tables that were added by
// the IsolateComponents action
// returns IMsiRecord error on error 
IMsiRecord* RemoveIsolateEntriesForDisabledComponent(IMsiEngine& riEngine, const ICHAR szComponent[])
{
	IMsiRecord* piError = 0;

	PMsiDatabase pDatabase(riEngine.GetDatabase());

	// Check for existence of IsolatedComponent table
	if (!pDatabase->GetTableState(TEXT("IsolatedComponent"), itsTableExists))
		return 0;

	// Prepare views on the various tables up front for efficiency
	PMsiView pIsolateView(0);
	PMsiView pComponentView(0);
	PMsiView pFileView(0);
	PMsiView pFileViewForDeletion(0);
	PMsiView pBindView(0);
	PMsiView pPatchView(0);

	// set up query just for the entries for a particular component
	if ((piError = pDatabase->OpenView(TEXT("SELECT `Component_Shared`,`Component_Application` FROM `IsolatedComponent` WHERE `Component_Shared` = ?"), ivcFetch, *&pIsolateView)) != 0
	 || (piError = pDatabase->OpenView(TEXT("SELECT `KeyPath` FROM `Component` WHERE `Component` = ?"), ivcFetch, *&pComponentView)) != 0
	 || (piError = pDatabase->OpenView(TEXT("SELECT `File` FROM File WHERE `Component_` = ?"), ivcFetch, *&pFileView)) != 0
	 || (piError = pDatabase->OpenView(TEXT("SELECT `File` FROM File WHERE `File` = ?"), ivcFetch, *&pFileViewForDeletion)) != 0
	 || (pDatabase->GetTableState(TEXT("BindImage"), itsTableExists)
	 && (piError = pDatabase->OpenView(TEXT("SELECT `File_` FROM BindImage WHERE File_ = ?"), ivcFetch, *&pBindView)) != 0)
	 || (pDatabase->GetTableState(TEXT("Patch"), itsTableExists)
	 &&((piError = pDatabase->OpenView(TEXT("SELECT `File_` FROM `Patch` WHERE File_ = ?"), ivcFetch, *&pPatchView)) != 0)))
		return piError;

	int iIsolateLevel = riEngine.GetPropertyInt(*MsiString(*IPROPNAME_REDIRECTEDDLLSUPPORT));
	if(iIsolateLevel == iMsiNullInteger)
		return 0; // there is no support for isolation

	PMsiRecord pParams(&ENG::CreateRecord(1));
	pParams->SetString(1, szComponent);

	if ((piError = pIsolateView->Execute(pParams)) != 0)
		return piError;
	PMsiRecord pIsolateRow(0);
	if((pIsolateRow = pIsolateView->Fetch()) != 0)
	{
		// there is an entry for this particular component
		MsiString strSharedComponent  = pIsolateRow->GetMsiString(1);
		MsiString strPrivateComponent = pIsolateRow->GetMsiString(2);

		// if component is a Win32 assembly AND SXS support is present on the machine, then do not 
		// process the component as an IsolateComponent
		// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
		// Win32 assemblies, hence there is no need to separately check the SXS support here
		iatAssemblyType iatAT;
		if ((piError = riEngine.GetAssemblyInfo(*strSharedComponent, iatAT, 0, 0)) != 0)
			return piError;

		if(iatWin32Assembly == iatAT || iatWin32AssemblyPvt == iatAT)
		{
			DEBUGMSG1(TEXT("skipping processing of isolate component %s as it is a Win32 assembly."), strSharedComponent);
			return 0;// skip processing this component as an isolate component
		}

		// remove all entries that we had duplicated in the application component
		pParams->SetMsiString(1, *strSharedComponent);
		if ((piError = pFileView->Execute(pParams)) != 0)
			return piError;
		PMsiRecord pFileRow(0);
		PMsiRecord pFileKeyRow(0);
		while((pFileRow = pFileView->Fetch()) != 0)
		{
			MsiString strFileKey = pFileRow->GetMsiString(1);
			pParams->SetMsiString(1, *MsiString(CompositeKey(*strFileKey, *strPrivateComponent)));

			//!! Avoid bug inserting into same view being fetched in a read-only database
			if ((piError = pFileViewForDeletion->Execute(pParams)) != 0)
				return piError;
			PMsiRecord pRecRead = pFileViewForDeletion->Fetch();
			if(pRecRead)
			{
				if ((piError = pFileViewForDeletion->Modify(*pRecRead, irmDelete)) != 0)
					return piError;
			}

			//  Check BindImage table for bound executables and duplicate rows if found
			if (pBindView)
			{
				pParams->SetMsiString(1, *MsiString(CompositeKey(*strFileKey, *strPrivateComponent)));
				if ((piError = pBindView->Execute(pParams)) != 0)
					return piError;
				PMsiRecord pRecRead = pBindView->Fetch();
				if (pRecRead)
				{
					if ((piError = pBindView->Modify(*pRecRead, irmDelete)) != 0)
						return piError;
				}
			}

			// Check Patch table for patched files and duplicate rows if found
			if (pPatchView)
			{
				pParams->SetMsiString(1, *MsiString(CompositeKey(*strFileKey, *strPrivateComponent)));
				if ((piError = pPatchView->Execute(pParams)) != 0)
					piError;
				PMsiRecord pRecRead = pPatchView->Fetch();
				if(pRecRead)
				{
					if ((piError = pPatchView->Modify(*pRecRead, irmDelete)) != 0)
						return piError;
				}
			}
		} // end while fetch pFileView

		// are there any more nondisabled components isolated to the parent component
		bool fPresent = false;
		if ((piError = FindNonDisabledPvtComponents(riEngine, strPrivateComponent, fPresent)) != 0)
			return piError;
		if(true == fPresent)
			return 0;// this component has other non-disabled components attached to it, so we would still need the .local file

		//  Generate the .LOCAL file entry and delete from file table
		pParams->SetMsiString(1, *strPrivateComponent);
		if ((piError = pComponentView->Execute(pParams)) != 0)
			return piError;
		PMsiRecord pComponentRow = pComponentView->Fetch();
		if (!pComponentRow)
			return PostError(Imsg(idbgIsolateNoApplicationComponent), *strPrivateComponent);
		MsiString strFileKey = pComponentRow->GetMsiString(1);
		// Generate unique File table key using same mechanism used for duplicated files
		pParams->SetMsiString(1, *MsiString(CompositeKey(*strFileKey, *strPrivateComponent)));
		// delete the entry
		if ((piError = pFileViewForDeletion->Execute(pParams)) != 0)
			return piError;
		PMsiRecord pRecRead = pFileViewForDeletion->Fetch();
		if(pRecRead)
		{
			if ((piError = pFileViewForDeletion->Modify(*pRecRead, irmDelete)) != 0)
				return piError;
		}
	} // end fetch pIsolateView
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\intrface.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       intrface.cpp
//
//--------------------------------------------------------------------------

//                                                      
// File: interface.cpp
// Purpose: implements the FDI_Interface objects methods
// Notes: 
//____________________________________________________________________________

#include "precomp.h"
#include "services.h"
#ifdef MAC
#include <macos\msvcmac.h>
#include <macos\processe.h>
#include <macos\events.h>
#include <macos\eppc.h>
#include "macutil.h"
#endif //MAC

#include "intrface.h"

#include "notify.h"

#ifdef WIN
    // This is what we call to start up the FDI Server thread
    DWORD WINAPI StartFDIServer(LPVOID /*lpvThreadParam*/);
#endif
    
#ifdef WIN
extern scEnum g_scServerContext;
extern bool g_fWin9X;   // true if Windows 95 or 98, else false
#endif

///////////////////////////////////////////////////////////////////////////////
// FDI_Interface class definitions
///////////////////////////////////////////////////////////////////////////////

HANDLE g_hInterfaceInterfaceEvent = INVALID_HANDLE_VALUE;
HANDLE g_hInterfaceServerEvent = INVALID_HANDLE_VALUE;

// See intrface.h
FDI_Interface::FDI_Interface()
{

}

// See intrface.h
FDIInterfaceError FDI_Interface::Init(IMsiServices *piAsvc, IMsiStorage* piStorage)
{
    m_piAsvc = piAsvc;
    m_fdis.cbNotification = 0;
    m_fdis.cbNotifyPending = 0;
    m_fdis.fdic = fdicNoCommand;
    m_fServerLaunched = fFalse;
    m_piStorage = piStorage;
    if (m_piStorage)
        m_piStorage->AddRef();

    if (ContactFDIServer())
    {
        m_fServerLaunched = fTrue;
        return ifdiServerLaunched;
    }
    else
        return ifdiServerLaunchFailed;
}

// See intrface.h
int FDI_Interface::ContactFDIServer()
{
    return LaunchFDIServer();
}


// See intrface.h   
int FDI_Interface::LaunchFDIServer()
{
    DWORD dwThreadID, dw;

    // Init the events we'll use to synchronize with the FDI Server
    g_hInterfaceServerEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    int q = GetLastError();
    if (g_hInterfaceServerEvent)
        MsiRegisterSysHandle(g_hInterfaceServerEvent);
    else
        return 0;

    g_hInterfaceInterfaceEvent = CreateEvent(NULL, FALSE,FALSE, NULL);
    if (g_hInterfaceInterfaceEvent)
        MsiRegisterSysHandle(g_hInterfaceInterfaceEvent);
    else
    {
        AssertNonZero(MsiCloseSysHandle(g_hInterfaceServerEvent));
        g_hInterfaceServerEvent = INVALID_HANDLE_VALUE;
        return 0;
    }

    m_fdis.hClientToken = INVALID_HANDLE_VALUE;
    m_fdis.hImpersonationToken = INVALID_HANDLE_VALUE;

    if (g_scServerContext == scService)
    {
        StartImpersonating();
        Bool fResult = ToBool(WIN::OpenThreadToken(GetCurrentThread(), MAXIMUM_ALLOWED, TRUE, &m_fdis.hClientToken) &&
            WIN::DuplicateToken (m_fdis.hClientToken, SecurityImpersonation, &m_fdis.hImpersonationToken));
        StopImpersonating();
        if (!fResult)
        {
            if (m_fdis.hClientToken != INVALID_HANDLE_VALUE)
                AssertNonZero(MsiCloseUnregisteredSysHandle(m_fdis.hClientToken));
            if (m_fdis.hImpersonationToken != INVALID_HANDLE_VALUE)
                AssertNonZero(MsiCloseUnregisteredSysHandle(m_fdis.hImpersonationToken));
            return 0;
        }
        MsiRegisterSysHandle(m_fdis.hClientToken);
        MsiRegisterSysHandle(m_fdis.hImpersonationToken);
    }

    m_fdis.fServerIsImpersonated = g_fWin9X ? false : IsImpersonating(true /*strict*/);

    // Start up the server thread
    HANDLE hThread = CreateThread(NULL, 0, StartFDIServer, &m_fdis, 0, &dwThreadID);
    dw = WaitForSingleObject(g_hInterfaceServerEvent, INFINITE);
    AssertNonZero(WIN::CloseHandle(hThread));
    if (dw == WAIT_OBJECT_0 && m_fdis.fdir != fdirServerDied)
    {
        return 1;
    }
    else
    {
        AssertNonZero(MsiCloseSysHandle(g_hInterfaceServerEvent));
        AssertNonZero(MsiCloseSysHandle(g_hInterfaceInterfaceEvent));
        g_hInterfaceServerEvent = INVALID_HANDLE_VALUE;
        g_hInterfaceInterfaceEvent = INVALID_HANDLE_VALUE;
        return 0;
    }
}


// See intrface.h
FDIInterfaceError FDI_Interface::OpenCabinet(const ICHAR *pszCabinetName, const ICHAR *pszCabinetPath,
                                             icbtEnum icbtCabinetType, int iCabDriveType, Bool fSignatureRequired, IMsiStream* piSignatureCert, IMsiStream* piSignatureHash, HRESULT& hrWVT)
{
    // Set up shared data structures
    MsiString strCabinetName(pszCabinetName);
    MsiString strCabinetPath(pszCabinetPath);

    if (icbtCabinetType == icbtStreamCabinet)
    {
        m_fdis.achCabinetPath[0] = 0;
    }
    else
    {
        strCabinetPath.CopyToBuf(m_fdis.achCabinetPath,FDIShared_BUFSIZE - 1);
    }

    m_fdis.icbtCabinetType = icbtCabinetType;
    strCabinetName.CopyToBuf(m_fdis.achCabinetName,FDIShared_BUFSIZE - 1);
    m_fdis.piStorage = m_piStorage;
    m_fdis.iCabDriveType = iCabDriveType;
    
    // digital signature information
    m_fdis.fSignatureRequired = fSignatureRequired;
    m_fdis.piSignatureCert = piSignatureCert;
    m_fdis.piSignatureHash = piSignatureHash;

    // Tell FDI Server to open the cabinet
    FDIServerResponse fdiResponse = WaitResponse(fdicOpenCabinet);
    if (fdiResponse == fdirUserAbort)
    {
        // we must have been in the middle of a read, which just got interrupted.
        // Try again, to let things re-start.
        fdiResponse = WaitResponse(fdicOpenCabinet);
    }

    switch (fdiResponse)
    {
    case fdirSuccessfulCompletion:
    case fdirNotification:
        hrWVT = S_OK; // not a digital signature error
        return ifdiNoError;
    case fdirDriveNotReady:
        hrWVT = S_OK; // not a digital signature error
        return ifdiDriveNotReady;
    case fdirNetError:
        hrWVT = S_OK; // not a digital signature error
        return ifdiNetError;
    case fdirMissingSignature:
        hrWVT = m_fdis.hrWVT;
        return ifdiMissingSignature;
    case fdirBadSignature:
        hrWVT = m_fdis.hrWVT;
        return ifdiBadSignature;
    case fdirCorruptCabinet:
        hrWVT = S_OK; // not a digital signature error
        return ifdiCorruptCabinet;
    default:
        hrWVT = S_OK; // not a digital signature error
        return ifdiErrorOpeningCabinet;
    }
}

HRESULT FDI_Interface::RetrieveWVTReturnCode()
{
    return m_fdis.hrWVT;
}

// See intrface.h
FDIServerResponse FDI_Interface::WaitResponse(FDIServerCommand fdic)
{
    // Set up our command
    m_fdis.fdir = fdirNoResponse;
    m_fdis.fdic = fdic;

    // Wait for response
    SetEvent(g_hInterfaceInterfaceEvent);
    DWORD dw = WaitForSingleObject(g_hInterfaceServerEvent, INFINITE);
    
    return m_fdirLastResponse = m_fdis.fdir;
}

int FDI_Interface::SetNotification(int cbNotification, int cbPending)
{
    int cbReturn = m_fdis.cbNotifyPending;
    m_fdis.cbNotification = cbNotification;
    m_fdis.cbNotifyPending = cbPending;
    return cbReturn; 
}

// See intrface.h
FDIServerResponse FDI_Interface::Done()
{
    if (m_fServerLaunched)
        return WaitResponse(fdicClose);
    else
        return fdirSuccessfulCompletion;
}

// See intrface.h
FDI_Interface::~FDI_Interface()
{
    if (m_piStorage)
        m_piStorage->Release();

    if (g_hInterfaceInterfaceEvent != INVALID_HANDLE_VALUE )
    {
        AssertNonZero(MsiCloseSysHandle(g_hInterfaceInterfaceEvent));
        g_hInterfaceInterfaceEvent = INVALID_HANDLE_VALUE;
    }
    if (g_hInterfaceServerEvent != INVALID_HANDLE_VALUE )
    {
        AssertNonZero(MsiCloseSysHandle(g_hInterfaceServerEvent));
        g_hInterfaceServerEvent = INVALID_HANDLE_VALUE;
    }
}

// See intrface.h
FDIServerResponse FDI_Interface::SendCommand(FDIServerCommand fdic)
{
    return WaitResponse(fdic);
}



// See intrface.h
FDIServerResponse FDI_Interface::ExtractFile(const ICHAR *pszNameInCabinet,
                                             IAssemblyCacheItem* piASM,
                                             bool fManifest,
                                             const ICHAR *pszPathOnDisk,
                                             FileAttributes *pfa,
                                             int iDestDriveType,
                                             LPSECURITY_ATTRIBUTES pSecurityAttributes)
{
    BOOL fNamesMatch;

    // If we were halfway extracting a file, or the last response was
    // a notify, then check to make sure we're doing the same file
    if ((m_fdirLastResponse == fdirNeedNextCabinet) ||
        (m_fdirLastResponse == fdirNotification))
    {
        fNamesMatch = !IStrComp(m_fdis.achFileSourceName, pszNameInCabinet)
                       && !IStrComp(m_fdis.achFileDestinationPath, pszPathOnDisk);
        if (!fNamesMatch)
        {
            // If names don't match, then something's wrong!
            return fdirCannotBreakExtractInProgress;
        }
        else
        {
            // The last command was either fdirNeedNextCabinet or fdirNotification,
            // so the correct thing to do is just continue....
            return SendCommand(fdicContinue);
        }
    }
    else
    {
        // Okay, set up shared data
        StringCbCopy(m_fdis.achFileSourceName, sizeof(m_fdis.achFileSourceName), pszNameInCabinet);
        StringCbCopy(m_fdis.achFileDestinationPath, sizeof(m_fdis.achFileDestinationPath), pszPathOnDisk);
        m_fdis.fileAttributes = *pfa;
        m_fdis.iDestDriveType = iDestDriveType;
        m_fdis.piASM = piASM;
        m_fdis.fManifest = fManifest;
        m_fdis.pSecurityAttributes = pSecurityAttributes;

        // Let the FDI Server handle it
        return WaitResponse(fdicExtractFile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\istring.cpp ===
/* istring.cpp

  Copyright (C) Microsoft Corporation, 1995 - 1999

 IMsiString implementation,  IEnumM iString implementation    

                   
                    IMsiString 
                   
                         
                 
                  CMsiStringBase 
                 
        
                                                          
   
CMsiStringNull CMsiString     CMsiStringRef     CMsiStringLive
   
                  
 (not Unicode)-> CMsiStringSBCS CMsiStringSBCSRef
                  
                  
 (not Unicode)-> CMsiStringDBCS CMsiStringDBCSRef
                  

____________________________________________________________________________*/

#include "precomp.h"    // must be first for precompiled headers
#define  _ISTRING_CPP
#include "services.h"
// namespace ID for local functions - for readability only
#define LOC

#ifndef UNICODE   // must handle DBCS if not Unicode
#ifdef DEBUG  // intercept CharNext, CharPrev to permit testing on non-DBCS systems
static const char* ICharPrev(const char* sz, const char* pch);
#else  // if SHIP, call OS directly, inline optimized away
inline const char* ICharPrev(const char* sz, const char* pch) { return WIN::CharPrev(sz, pch); }
#endif
#endif

#ifdef UNICODE
#define IStrStr(szFull, szSeg) wcsstr(szFull, szSeg)
#else
#define IStrStr(szFull, szSeg) strstr(szFull, szSeg)
#endif

inline ICHAR* ICharNextWithNulls(const ICHAR* pch, const ICHAR* pchEnd)
{
	Assert(pch <= pchEnd);
	ICHAR *pchTemp = WIN::CharNext(pch);
	if (pchTemp == pch && pch < pchEnd)
	{
		Assert(*pchTemp == '\0');
		// embedded null, continue
		pchTemp++;
	}
	return pchTemp;
}

const GUID IID_IEnumMsiString= GUID_IID_IEnumMsiString;

Bool g_fDBCSEnabled = fFalse; // DBCS OS, set by services initialization

//____________________________________________________________________________
//
//  IMsiString implementation class definitions
//____________________________________________________________________________

// CMsiString - base implementation class for IMsiString, still partially pure

class CMsiStringBase : public IMsiString
{
 public: // IMsiString virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	const IMsiString&   __stdcall GetMsiStringValue() const;
	int           __stdcall GetIntegerValue() const;
#ifdef USE_OBJECT_POOL
	unsigned int  __stdcall GetUniqueId() const;
	void          __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
	int           __stdcall TextSize() const;
	int           __stdcall CharacterCount() const;
	Bool          __stdcall IsDBCS() const;
	void          __stdcall RefString(const ICHAR* sz, const IMsiString*& rpi) const;
	void          __stdcall RemoveRef(const IMsiString*& rpi) const;
	void          __stdcall SetChar  (ICHAR ch, const IMsiString*& rpi) const;
	void          __stdcall SetInteger(int i,   const IMsiString*& rpi) const;
	void          __stdcall SetBinary(const unsigned char* rgb, unsigned int cb, const IMsiString*& rpi) const;
	void          __stdcall AppendString(const ICHAR* sz, const IMsiString*& rpi) const;
	void          __stdcall AppendMsiString(const IMsiString& pi, const IMsiString*& rpi) const;
	const IMsiString&   __stdcall AddString(const ICHAR* sz) const;
	const IMsiString&   __stdcall AddMsiString(const IMsiString& ri) const;
	const IMsiString&   __stdcall Extract(iseEnum ase, unsigned int iLimit) const;
	Bool          __stdcall Remove(iseEnum ase, unsigned int iLimit, const IMsiString*& rpi) const;
	int           __stdcall Compare(iscEnum asc, const ICHAR* sz) const;
	void          __stdcall UpperCase(const IMsiString*& rpi) const;
	void          __stdcall LowerCase(const IMsiString*& rpi) const;
	ICHAR*        __stdcall AllocateString(unsigned int cb, Bool fDBCS, const IMsiString*& rpi) const;
 protected:  // constructor
	CMsiStringBase() : m_iRefCnt(1) {} //!! remove for performance--now needs own vTable setup
	// inline redirectors to allow IUnknown methods on const objects
	HRESULT QueryInterface(const IID& riid, void** ppv) const  {return const_cast<CMsiStringBase*>(this)->QueryInterface(riid,ppv);}
	unsigned long AddRef() const  {return const_cast<CMsiStringBase*>(this)->AddRef();}
	unsigned long Release() const {return const_cast<CMsiStringBase*>(this)->Release();}
 public:
	void* operator new(size_t cb);
	void  operator delete(void * pv);
 protected:  // state data
	int  m_iRefCnt;
	unsigned int  m_cchLen;
};
inline void* CMsiStringBase::operator new(size_t cb) {return AllocObject(cb);}
inline void  CMsiStringBase::operator delete(void * pv) { FreeObject(pv); }

// CMsiStringNull - special implementation for shared null string object

class CMsiStringNull : public CMsiStringBase
{
 public: // IMsiString virtual functions
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	const ICHAR*  __stdcall GetString() const;
	int           __stdcall GetInteger() const;
	int           __stdcall CopyToBuf(ICHAR* rgch, unsigned int cchMax) const;
	void          __stdcall SetString(const ICHAR* sz, const IMsiString*& rpi) const;
	void          __stdcall AppendString(const ICHAR* sz, const IMsiString*& rpi) const;
	void          __stdcall AppendMsiString(const IMsiString& pi, const IMsiString*& rpi) const;
	const IMsiString&   __stdcall AddString(const ICHAR* sz) const;
	const IMsiString&   __stdcall AddMsiString(const IMsiString& ri) const;
	const IMsiString&   __stdcall Extract(iseEnum, unsigned int iLimit) const;
	Bool          __stdcall Remove(iseEnum ase, unsigned int iLimit, const IMsiString*& rpi) const;
	void          __stdcall UpperCase(const IMsiString*& rpi) const;
	void          __stdcall LowerCase(const IMsiString*& rpi) const;
 public:
	CMsiStringNull()  {m_cchLen = 0;}
};

// CMsiString - normal strings for non-DBCS enabled operating systems

class CMsiString : public CMsiStringBase 
{
 public: // IMsiString virtual functions
	const ICHAR*  __stdcall GetString() const;
	int           __stdcall CopyToBuf(ICHAR* rgch, unsigned int cchMax) const;
	void          __stdcall SetString(const ICHAR* sz, const IMsiString*& rpi) const;
	void          __stdcall UpperCase(const IMsiString*& rpi) const;
	void          __stdcall LowerCase(const IMsiString*& rpi) const;
 public:  // constructors
	CMsiString(const ICHAR& sz, int cch);
	CMsiString(int cch);
	void* operator new(size_t iBase, int cch);
	static const IMsiString& Create(const ICHAR* sz);
	static CMsiString& Create(unsigned int cch); // caller fills in string data
 protected:
	CMsiString(){}  // default constructor for derived classes
 public:   // internal accessors
	ICHAR* StringData();
 protected: //  state data
	ICHAR m_szData[1];  // room for termintor, string data follows
};
inline ICHAR* CMsiString::StringData(){ return m_szData; }
inline void*  CMsiString::operator new(size_t iBase, int cch){return AllocObject(iBase + cch*sizeof(ICHAR));}
inline CMsiString& CMsiString::Create(unsigned int cch){return *new(cch) CMsiString(cch);}

// CMsiStringRef - string reference const data for non-DBCS enabled operating systems

class CMsiStringRef : public CMsiStringBase 
{
 public: // IMsiString virtual functions
	const ICHAR*  __stdcall GetString() const;
	int           __stdcall CopyToBuf(ICHAR* rgch, unsigned int cchMax) const;
	void          __stdcall SetString(const ICHAR* sz, const IMsiString*& rpi) const;
	void          __stdcall RemoveRef(const IMsiString*& rpi) const;
 public:  // constructors
	CMsiStringRef(const ICHAR& sz);
 protected:
	CMsiStringRef(){}  // default constructor for derived classes
 protected: //  state data
	const ICHAR* m_szRef;
};

// CMsiStringLive - dynamic string evaulating to current data when text extracted

typedef int (*LiveCallback)(ICHAR* rgchBuf, unsigned int cchBuf);

class CMsiStringLive : public CMsiStringBase 
{
 public: // IMsiString virtual functions
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	int           __stdcall TextSize() const;
	const ICHAR*  __stdcall GetString() const;
	int           __stdcall CopyToBuf(ICHAR* rgch, unsigned int cchMax) const;
	void          __stdcall SetString(const ICHAR* sz, const IMsiString*& rpi) const;
 public:
	CMsiStringLive(LiveCallback pfCallback) {m_pfCallback = pfCallback;}
 protected: //  state data
	LiveCallback  m_pfCallback;
	ICHAR m_rgchBuf[32];  // large enough for Date, Time, and test properties
};

#ifndef UNICODE // DBCS support for non-Unicode build

// CMsiStringSBCS - single byte character string in DBCS enabled operating system

class CMsiStringSBCS : public CMsiString
{
 public: // IMsiString virtual functions
	void        __stdcall SetString(const ICHAR* sz, const IMsiString*& rpi) const;
	void        __stdcall RefString(const ICHAR* sz, const IMsiString*& rpi) const;
	void        __stdcall AppendString(const ICHAR* sz, const IMsiString*& rpi) const;
	void        __stdcall AppendMsiString(const IMsiString& pi, const IMsiString*& rpi) const;
	const IMsiString& __stdcall AddString(const ICHAR* sz) const;
	const IMsiString& __stdcall AddMsiString(const IMsiString& ri) const;
 public:   // factory
	static const IMsiString& Create(const ICHAR* sz);
	static IMsiString& Create(unsigned int cch); // caller fills in string data
 protected:
  ~CMsiStringSBCS(){}  // protected to prevent creation on stack
 public:    // constructors
	CMsiStringSBCS(const ICHAR& sz, int cch);
	CMsiStringSBCS(int cch);
 protected: // constructors
	CMsiStringSBCS(){}  // default constructor for derived classes
};
inline IMsiString& CMsiStringSBCS::Create(unsigned int cch)
{
	return *new(cch) CMsiStringSBCS(cch);
}

// CMsiStringSBCSRef - single byte string reference in DBCS enabled operating system

class CMsiStringSBCSRef : public CMsiStringRef
{
 protected: // IMsiString virtual functions
	void        __stdcall SetString(const ICHAR* sz, const IMsiString*& rpi) const;
	void        __stdcall RefString(const ICHAR* sz, const IMsiString*& rpi) const;
	void        __stdcall RemoveRef(const IMsiString*& rpi) const;
	void        __stdcall AppendString(const ICHAR* sz, const IMsiString*& rpi) const;
	void        __stdcall AppendMsiString(const IMsiString& pi, const IMsiString*& rpi) const;
	const IMsiString& __stdcall AddString(const ICHAR* sz) const;
	const IMsiString& __stdcall AddMsiString(const IMsiString& ri) const;
 public:  // constructor
	CMsiStringSBCSRef(const ICHAR& sz);
 protected:
  ~CMsiStringSBCSRef(){}  // protected to prevent creation on stack
	CMsiStringSBCSRef(){}  // default constructor for derived classes
};

class CMsiStringDBCS : public CMsiStringSBCS
{
 protected: // IMsiString virtual functions
	Bool        __stdcall IsDBCS() const;
	int         __stdcall CharacterCount() const;
	void        __stdcall AppendString(const ICHAR* sz, const IMsiString*& rpi) const;
	void        __stdcall AppendMsiString(const IMsiString& pi, const IMsiString*& rpi) const;
	const IMsiString& __stdcall AddString(const ICHAR* sz) const;
	const IMsiString& __stdcall AddMsiString(const IMsiString& ri) const;
	const IMsiString& __stdcall Extract(iseEnum ase, unsigned int iLimit) const;
	Bool        __stdcall Remove(iseEnum ase, unsigned int iLimit, const IMsiString*& rpi) const;
	int         __stdcall Compare(iscEnum asc, const ICHAR* sz) const;
 public:   // factory
	static const IMsiString& Create(const ICHAR* sz);
	static IMsiString& Create(unsigned int cch); // caller fills in string data
	CMsiStringDBCS(const ICHAR& sz, int cch);
 public:   // constructor
	CMsiStringDBCS(int cch);
 protected:
  ~CMsiStringDBCS(){}  // protected to prevent creation on stack
}; // NOTE: new data members cannot be added unless inheritance is changed to CMsiStringBase

class CMsiStringDBCSRef : public CMsiStringSBCSRef
{
 protected: // IMsiString virtual functions
	Bool        __stdcall IsDBCS() const;
	int         __stdcall CharacterCount() const;
	void        __stdcall RemoveRef(const IMsiString*& rpi) const;
	void        __stdcall AppendString(const ICHAR* sz, const IMsiString*& rpi) const;
	void        __stdcall AppendMsiString(const IMsiString& pi, const IMsiString*& rpi) const;
	const IMsiString& __stdcall AddString(const ICHAR* sz) const;
	const IMsiString& __stdcall AddMsiString(const IMsiString& ri) const;
	const IMsiString& __stdcall Extract(iseEnum ase, unsigned int iLimit) const;
	Bool        __stdcall Remove(iseEnum ase, unsigned int iLimit, const IMsiString*& rpi) const;
	int         __stdcall Compare(iscEnum asc, const ICHAR* sz) const;
 public:   // constructor
	CMsiStringDBCSRef(const ICHAR& sz);
 protected:
  ~CMsiStringDBCSRef(){}  // protected to prevent creation on stack
};

#endif // !UNICODE - DBCS support for non-Unicode build

// CMsiStringComRef - reference string, holding refcnt to object containing string

#ifdef UNICODE
class CMsiStringComRef : public CMsiStringRef
#else
class CMsiStringComRef : public CMsiStringSBCSRef
#endif
{
 public: // IMsiString virtual functions
	unsigned long __stdcall Release();
 public:  // constructor
	CMsiStringComRef(const ICHAR& sz, unsigned int cbSize, const IUnknown& riOwner);
  ~CMsiStringComRef();
 protected:
   const IUnknown& m_riOwner;  // refcnt kept until destruction
 private:  // suppress warning
	void operator =(const CMsiStringComRef&);
};

// Static functions used within this module - use LOC::

const IMsiString& CreateMsiString(const ICHAR& rch);
ICHAR*            AllocateString(unsigned int cbSize, Bool fDBCS, const IMsiString*& rpiStr);
#ifndef UNICODE
Bool              CheckDBCS(const ICHAR* sz, unsigned int& riSize); // use only for SBCS/DBCS classes
const IMsiString& StringCatSBCS(const ICHAR* sz1, int cch1, const ICHAR* sz2, int cch2, Bool fDBCS);
const IMsiString& StringCatDBCS(const ICHAR* sz1, int cch1, const ICHAR* sz2, int cch2);
const IMsiString* GetSubstringDBCS(const IMsiString& riThis, iseEnum ase, unsigned int iLimit, Bool fRemove);
int               CompareDBCS(iscEnum isc, int cchLen, const ICHAR* sz1, const ICHAR* sz2);
#endif 

//____________________________________________________________________________

#include "_service.h"  // externs for global string objects, prototype for CreateStringEnumerator

//____________________________________________________________________________
//
//  CMsiStringNull implementation, allow for shared static object
//____________________________________________________________________________

const CMsiStringNull g_MsiStringNull;     // shared global null string object
const IMsiString&    g_riMsiStringNull = g_MsiStringNull;   // external reference to null string
static const ICHAR   g_szNull[] = TEXT("");     // shared static null string

//const IMsiString& CreateString()
//{
//	return g_MsiStringNull;
//}

unsigned long CMsiStringNull::AddRef()
{
	return 1;  // static object
}

unsigned long CMsiStringNull::Release()
{
	return 1;  // static object, never deleted
}

const ICHAR* CMsiStringNull::GetString() const
{
	return g_szNull;
}

void CMsiStringNull::UpperCase(const IMsiString*& rpi) const
{
	if (rpi && rpi != this)
		rpi->Release();  // won't destruct this
	rpi = this;
}

void CMsiStringNull::LowerCase(const IMsiString*& rpi) const
{
	if (rpi && rpi != this)
		rpi->Release();  // won't destruct this
	rpi = this;
}

int CMsiStringNull::GetInteger() const
{
	return iMsiStringBadInteger;
}

int CMsiStringNull::CopyToBuf(ICHAR* rgch, unsigned int /*cchMax*/) const
{
	if (rgch)
		*rgch = 0;
	return 0;
}

void CMsiStringNull::SetString(const ICHAR* sz, const IMsiString*& rpi) const
{
	if (sz == 0 || *sz == 0)
		return;
	if (rpi)
		rpi->Release();
	rpi = &LOC::CreateMsiString(*sz);
}

void CMsiStringNull::AppendString(const ICHAR* sz, const IMsiString*& rpi) const
{
	const IMsiString* piOld = rpi;
	if (!sz || !*sz)
	{
		rpi = this;
	}
	else
	{
		rpi = &LOC::CreateMsiString(*sz);
	}
	if (piOld)
		piOld->Release();  // caution: may release ourself, do this last
}

void CMsiStringNull::AppendMsiString(const IMsiString& ri, const IMsiString*& rpi) const
{
	if (rpi)
		rpi->Release();  // OK to release ourselves, we're a static object
	int cch2 = ri.TextSize();
	if (!cch2)
	{
		rpi = this;
	}
	else
	{
		rpi = &ri;
		ri.AddRef();
	}
}

const IMsiString& CMsiStringNull::AddString(const ICHAR* sz) const
{
	return CreateMsiString(*sz);
}

const IMsiString& CMsiStringNull::AddMsiString(const IMsiString& ri) const
{
	ri.AddRef();
	return ri;
}

const IMsiString& CMsiStringNull::Extract(iseEnum /*ase*/, unsigned int /*iLimit*/) const
{
	return *this;
}

Bool CMsiStringNull::Remove(iseEnum ase, unsigned int /*iLimit*/, const IMsiString*& rpi) const
{
	if (!(ase & iseChar))
	{
		if (rpi != 0)
			rpi->Release();  // OK if ourselves, we're not ref counted
		rpi = this;
		return fTrue;
	}
	return fFalse;
}

//____________________________________________________________________________
//
//  CMsiStringBase implementation, common for most methods of derived classes
//____________________________________________________________________________

HRESULT CMsiStringBase::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown)
	 || MsGuidEqual(riid, IID_IMsiString)
	 || MsGuidEqual(riid, IID_IMsiData))
	{
		*ppvObj = this;
		AddRef();
		return S_OK;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}
unsigned long CMsiStringBase::AddRef()
{
	return ++m_iRefCnt;
}
unsigned long CMsiStringBase::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

const IMsiString& CMsiStringBase::GetMsiStringValue() const
{
	AddRef();
	return *this;
}

#ifdef USE_OBJECT_POOL
unsigned int CMsiStringBase::GetUniqueId() const
{
	Assert(fFalse);
	return 0;
}

void CMsiStringBase::SetUniqueId(unsigned int /* id */)
{
	Assert(fFalse);
}
#endif //USE_OBJECT_POOL

int CMsiStringBase::TextSize() const
{
	return m_cchLen;
}

int CMsiStringBase::CharacterCount() const
{
	return m_cchLen;
}

Bool CMsiStringBase::IsDBCS() const
{
	return fFalse;
}

int CMsiStringBase::GetIntegerValue() const // written for speed, not beauty
{
	const ICHAR* sz = GetString(); // length will never be 0
	return ::GetIntegerValue(sz, 0);
}

ICHAR* CMsiStringBase::AllocateString(unsigned int cb, Bool fDBCS, const IMsiString*& rpi) const
{
	if (rpi)
		rpi->Release();  // caution: may release ourself, can't access data
	if (!cb)
	{
		rpi = &g_MsiStringNull;
		return 0;
	}
	return LOC::AllocateString(cb, fDBCS, rpi);
}

void CMsiStringBase::RefString(const ICHAR* sz, const IMsiString*& rpi) const
{
	if (rpi)
		rpi->Release();  // caution: may release ourself, can't access data

	const IMsiString* piStr;
	rpi = (sz && *sz && (piStr=new CMsiStringRef(*sz)) != 0)
			? piStr : &g_MsiStringNull;
}

void CMsiStringBase::SetChar(ICHAR ch, const IMsiString*& rpi) const
{
	if (rpi)
		rpi->Release();  // caution: may release ourself, can't access data

	ICHAR* pch = LOC::AllocateString(1, fFalse, rpi);
	if (pch)
		*pch = ch;
}

void CMsiStringBase::SetInteger(int i, const IMsiString*& rpi) const
{
	if (rpi)
		rpi->Release();  // caution: may release ourself, can't access data

	if (i == iMsiStringBadInteger)
		rpi = &g_MsiStringNull;
	else
	{
		ICHAR buf[12];
		ltostr(buf, i);
		rpi = &LOC::CreateMsiString(*buf);
	}
}

void CMsiStringBase::SetBinary(const unsigned char* rgb, unsigned int cb, const IMsiString*& rpi) const
{
	if (rpi)
		rpi->Release();  // caution: may release ourself, can't access data
	if (rgb == 0 || cb == 0)
		rpi = &g_MsiStringNull;
	else
	{
		ICHAR* pch = LOC::AllocateString(cb*2 + 2, fFalse, rpi); // "0x" + 2chars/byte
		if (!pch)
			return;
		*pch++ = '0';
		*pch++ = 'x';
		while (cb--)
		{
			if ((*pch = ICHAR((*rgb >> 4) + '0')) > '9')
				*pch += ('A' - ('0' + 10));
			pch++;
			if ((*pch = ICHAR((*rgb & 15) + '0')) > '9')
				*pch += ('A' - ('0' + 10));
			pch++;
			rgb++;
		}
	}
}

void CMsiStringBase::AppendString(const ICHAR* sz, const IMsiString*& rpi) const
{
	const IMsiString* piOld = rpi;
	int cch2;
	if (!sz || (cch2 = IStrLen(sz)) == 0)
	{
		rpi = this;
		AddRef();
	}
	else
	{
		CMsiString& riStr = CMsiString::Create(m_cchLen + cch2);
		rpi = &riStr;
		ICHAR* szNew = riStr.StringData();
		memmove(szNew, GetString(), m_cchLen*sizeof(ICHAR));
		StringCchCopy(szNew + m_cchLen, cch2+1, sz);
	}
	if (piOld)
		piOld->Release();  // caution: may release ourself, do this last
}

void CMsiStringBase::AppendMsiString(const IMsiString& ri, const IMsiString*& rpi) const
{
	const IMsiString* piOld = rpi;
	int cch2 = ri.TextSize();
	if (!cch2)
	{
		rpi = this;
		AddRef();
	}
	else
	{
		rpi = &CMsiString::Create(m_cchLen + cch2);
		ICHAR* szNew = const_cast<ICHAR*>(rpi->GetString());
		memmove(szNew, GetString(), m_cchLen*sizeof(ICHAR));
		memmove((szNew + m_cchLen), ri.GetString(), (cch2 + 1)*sizeof(ICHAR));// copy over null too
	}
	if (piOld)
		piOld->Release();  // caution: may release ourself, do this last
}

const IMsiString& CMsiStringBase::AddString(const ICHAR* sz) const
{
	int cch2;
	if (!sz || (cch2 = IStrLen(sz)) == 0)
	{
		AddRef();
		return *this;
	}
	const IMsiString& ri = CMsiString::Create(m_cchLen + cch2);
	ICHAR* szNew = const_cast<ICHAR*>(ri.GetString());
	memmove(szNew, GetString(), m_cchLen*sizeof(ICHAR));
	StringCchCopy(szNew + m_cchLen, cch2+1, sz);
	return ri;
}

const IMsiString& CMsiStringBase::AddMsiString(const IMsiString& ri) const
{
	int cch2 = ri.TextSize();
	if (!cch2)
	{
		AddRef();
		return *this;
	}
	const IMsiString& riNew = CMsiString::Create(m_cchLen + cch2);
	ICHAR* szNew = const_cast<ICHAR*>(riNew.GetString());
	memmove(szNew, GetString(), m_cchLen*sizeof(ICHAR));
	memmove((szNew + m_cchLen), ri.GetString(), (cch2 + 1)*sizeof(ICHAR));// copy over null too
	return riNew;
}

const IMsiString& CMsiStringBase::Extract(iseEnum ase, unsigned int iLimit) const
{
	const ICHAR* pchEnd;
	const ICHAR* pch = GetString();
	unsigned int cch = TextSize();
	if (ase & iseChar)
	{
		if (ase & iseEnd)
		{
			for (pchEnd = pch + cch; pchEnd-- != pch && *pchEnd != iLimit;)
				;
//			Assert((pch + cch - pchEnd) <= UINT_MAX);				//--merced: 64-bit ptr subtraction may theoretically lead to values too big for iLimit.
			iLimit = (unsigned int)(UINT_PTR)(pch + cch - pchEnd);
			if (!(ase & iseInclude))
				iLimit--;
		}
		else
		{
			for (pchEnd = pch; *pchEnd != iLimit && pchEnd != pch + cch; pchEnd++)
				;
//			Assert((pchEnd - pch) <= UINT_MAX);						//--merced: 64-bit ptr subtraction may theoretically lead to values too big for iLimit.
			iLimit = (unsigned int)(UINT_PTR)(pchEnd - pch);
			if (ase & iseInclude)
				iLimit++;
		}
	}
	else if (iLimit > cch)
		iLimit = cch;
		
	if (ase & iseEnd)
	{
		pchEnd = pch + cch;
		pch = pchEnd - iLimit;
	}
	else
	{
		pchEnd = pch + iLimit;
	}
	if (ase & iseTrim)
	{
		while (iLimit && *pch == ' ' || *pch == '\t')
		{
			pch++;
			iLimit--;
		}
		while (iLimit && *(--pchEnd) == ' ' || *pchEnd == '\t')
		{
			iLimit--;
		}
	}
	if (iLimit < cch)
	{
#ifdef UNICODE
		const IMsiString& ri = CMsiString::Create(iLimit);
#else
		// on DBCS enabled systems we should create CMsiStringSBCS strings that would be aware of future DBCS string appending and such
		const IMsiString& ri = g_fDBCSEnabled ? (const IMsiString&)CMsiStringSBCS::Create(iLimit) : (const IMsiString&)CMsiString::Create(iLimit);
#endif
		ICHAR* pchNew = const_cast<ICHAR*>(ri.GetString());
		memmove(pchNew, pch, iLimit*sizeof(ICHAR));
		pchNew[iLimit] = 0;// the end null terminator
		return ri;
	}
	AddRef();
	return *this;
}

Bool CMsiStringBase::Remove(iseEnum ase, unsigned int iLimit, const IMsiString*& rpi) const
{
	const IMsiString* piOld = rpi;
	const ICHAR* pchEnd;
	const ICHAR* pch = GetString();
	unsigned int cch = TextSize();
	if (ase & iseChar)
	{
		if (ase & iseEnd)
		{
			for (pchEnd = pch + cch; *(--pchEnd) != iLimit;)
				if (pchEnd == pch)
					return fFalse;
//			Assert((pch + cch - pchEnd) <= UINT_MAX);				//--merced: 64-bit ptr subtraction may lead to values too big for iLimit.
			iLimit = (unsigned int)(UINT_PTR)(pch + cch - pchEnd);
			if (!(ase & iseInclude))
				iLimit--;
		}
		else
		{
			pchEnd = pch;

			for (;;)
			{
				if (pchEnd == pch + cch)
					return fFalse;
				if (*pchEnd == iLimit)
					break;
				pchEnd++;
			}

//			Assert((pchEnd - pch) <= UINT_MAX);						//--merced: 64-bit ptr subtraction may lead to values too big for iLimit.
			iLimit = (unsigned int)(UINT_PTR)(pchEnd - pch);
			if (ase & iseInclude)
				iLimit++;
		}
	}
	if (iLimit == 0)
		(rpi = this)->AddRef();
	else if (iLimit < cch)
	{
#ifdef UNICODE
		rpi = &CMsiString::Create(cch - iLimit);
#else
		// on DBCS enabled systems we should create CMsiStringSBCS strings that would be aware of future DBCS string appending and such
		rpi = g_fDBCSEnabled ? &CMsiStringSBCS::Create(cch - iLimit) : &CMsiString::Create(cch - iLimit);
#endif

		ICHAR* pchNew = const_cast<ICHAR*>(rpi->GetString());
		if (!(ase & iseEnd))
			pch += iLimit;
		memmove(pchNew, pch, (cch - iLimit)*sizeof(ICHAR));
		pchNew[cch - iLimit] = 0;// the end null terminator
	}
	else
		rpi = &g_MsiStringNull;

	if (piOld)
		piOld->Release();  // caution: may release ourself, do this last

	return fTrue;
}

int CMsiStringBase::Compare(iscEnum asc, const ICHAR* sz) const
{
// this code could be made smaller by extracting out common code
// however, the performance is more critical here than saving a few bytes
// CMsiStringDBCS has its own Compare to handle international chars
	if (sz == 0)
		sz = TEXT("");
	
	// non-Unicode, need to move this to derived class if Unicode enabled
	const ICHAR* szThis = GetString();
	int cb, i;
	ICHAR* szTemp;
	ICHAR rgchBuf[512];  // for temp copy to avoid allocation

	if (asc == iscExact)
		return (lstrcmp(szThis, sz)==0) ? 1 : 0;
	else if (asc == iscExactI)
		return (lstrcmpi(szThis, sz)==0) ? 1 : 0;
	else
	{
		if (m_cchLen == 0)
			return 0;

		switch (asc)
		{
			case iscStart:
				if ((cb = IStrLen(sz)) > m_cchLen)
					return 0;
				i = memcmp(szThis, sz, cb * sizeof(ICHAR));
				return i == 0 ? 1 : 0;
			case iscStartI:
				if ((cb = IStrLen(sz)) > m_cchLen)
					return 0;
				szTemp= cb < sizeof(rgchBuf) ?  rgchBuf : new ICHAR[cb+1];
				if ( ! szTemp )
					return 0;
				IStrCopyLen(szTemp, szThis, cb);
				i = lstrcmpi(szTemp, sz);
				if (szTemp != rgchBuf)
					delete[] szTemp;
				return i == 0 ? 1 : 0;
			case iscEnd:
				if ((cb = IStrLen(sz)) > m_cchLen)
					return 0;
				return (lstrcmp(szThis + m_cchLen - cb, sz) == 0)
							? m_cchLen-cb+1 : 0;
			case iscEndI:
				if ((cb=IStrLen(sz)) > m_cchLen)
					return 0;
				return (lstrcmpi(szThis + m_cchLen - cb, sz)==0)
							? m_cchLen-cb+1 : 0;										   
			case iscWithin:
				if (IStrLen(sz) > m_cchLen)
					return 0;
				szTemp = IStrStr(szThis, sz);
//				Assert((szTemp-szThis+1) <= INT_MAX);				//--merced: 64-bit ptr subtraction may lead to values too big for an int.
				return (szTemp==NULL) ? 0 : (int)(INT_PTR)((szTemp-szThis) + 1);
			case iscWithinI:
				if (IStrLen(sz) > m_cchLen)
					return 0;
				else
				{	
					cb = IStrLen(sz)+1;
					ICHAR *szLowerCch= new ICHAR[m_cchLen+1];
					ICHAR *szLowerSz = new ICHAR[cb];
					if ( ! szLowerCch || ! szLowerSz )
						return 0;
					StringCchCopy(szLowerCch, m_cchLen+1, szThis);
					StringCchCopy(szLowerSz, cb, sz);
					CharLower(szLowerCch);
					CharLower(szLowerSz);
					ICHAR *pch = IStrStr(szLowerCch, szLowerSz);
					delete [] szLowerCch;
					delete [] szLowerSz;
//					Assert((pch-szLowerCch+1) <= INT_MAX);			//--merced: 64-bit ptr subtraction may lead to values too big for an int.
					return (pch==NULL) ? 0 : (int)(INT_PTR)((pch-szLowerCch) + 1);
				}
			default:
				//FIXmsh: Error;
				return 0;
		}	
	}
}

void CMsiStringBase::RemoveRef(const IMsiString*& rpi) const
{
	rpi = this;
}

void CMsiStringBase::UpperCase(const IMsiString*& rpi) const
{
	const IMsiString* piOld = rpi;
	ICHAR* pch = LOC::AllocateString(m_cchLen, IsDBCS(), rpi);
	if ( ! pch )
	{
		rpi = &g_MsiStringNull;
		return;
	}
	StringCchCopy(pch, m_cchLen+1, GetString());
	IStrUpper(pch);
	if (piOld)
		piOld->Release();  // caution: may release ourself, do this last
}

void CMsiStringBase::LowerCase(const IMsiString*& rpi) const
{
	const IMsiString* piOld = rpi;
	ICHAR* pch = LOC::AllocateString(m_cchLen, IsDBCS(), rpi);
	if ( ! pch )
	{
		rpi = &g_MsiStringNull;
		return;
	}
	StringCchCopy(pch, m_cchLen+1, GetString());
	IStrLower(pch);
	if (piOld)
		piOld->Release();  // caution: may release ourself, do this last
}

//____________________________________________________________________________
//
//  CMsiString implementation
//____________________________________________________________________________

const IMsiString& CMsiString::Create(const ICHAR* sz)
{
	int cch;
	const IMsiString* piStr;
	if (sz && (cch = IStrLen(sz)) != 0 && (piStr = new(cch) CMsiString(*sz, cch)) != 0)
		return *piStr;
	return g_MsiStringNull;
}

CMsiString::CMsiString(const ICHAR& sz, int cch)
{
	m_cchLen = cch;
	StringCchCopy(m_szData, m_cchLen+1, &sz);
}

CMsiString::CMsiString(int cch)
{
	m_cchLen = cch;
}

const ICHAR* CMsiString::GetString() const
{
	return m_szData;
}

int CMsiString::CopyToBuf(ICHAR* rgchBuf, unsigned int cchMax) const
{
	if (m_cchLen <= cchMax)
		memmove(rgchBuf, m_szData, (m_cchLen+1)*sizeof(ICHAR));// copy over null too
	else
		IStrCopyLen(rgchBuf, m_szData, cchMax);//?? is this correct
	return m_cchLen;
}

void CMsiString::SetString(const ICHAR* sz, const IMsiString*& rpi) const
{
	if (sz == m_szData)  // passing in our own private string, optimize
	{                    // also required to make RemoveReferences() efficient
		if (rpi == this)
			return;
		rpi = this;
		AddRef();
	}
	if (rpi)
		rpi->Release();  // caution: may release ourself, can't access data
	rpi = &CMsiString::Create(sz);
}

void CMsiString::UpperCase(const IMsiString*& rpi) const
{
	if (rpi == this && m_iRefCnt == 1) // single ref, can overwrite buffer
		IStrUpper(const_cast<ICHAR*>(m_szData));
	else // need to make new string
		CMsiStringBase::UpperCase(rpi);
}

void CMsiString::LowerCase(const IMsiString*& rpi) const
{
	if (rpi == this && m_iRefCnt == 1) // single ref, can overwrite buffer
		IStrLower(const_cast<ICHAR*>(m_szData));
	else // need to make new string
		CMsiStringBase::LowerCase(rpi);
}

//____________________________________________________________________________
//
//  CMsiStringRef implementation
//____________________________________________________________________________

CMsiStringRef::CMsiStringRef(const ICHAR& sz) : m_szRef(&sz)
{
	m_cchLen = IStrLen(&sz);
}

void CMsiStringRef::SetString(const ICHAR* sz, const IMsiString*& rpi) const
{
	if (rpi)
		rpi->Release();  // caution: may release ourself, can't access data
	rpi = &CMsiString::Create(sz);
}

void CMsiStringRef::RemoveRef(const IMsiString*& rpi) const
{
	const ICHAR* sz = m_szRef; // save string before we're gone
	int cch = m_cchLen;
	if (rpi)
		rpi->Release();  // caution: may release ourself, can't access data
	rpi = new(cch) CMsiString(*sz, cch);
}

const ICHAR* CMsiStringRef::GetString() const
{
	return m_szRef;
}

int CMsiStringRef::CopyToBuf(ICHAR* rgchBuf, unsigned int cchMax) const
{
	if (m_cchLen <= cchMax)
		memmove(rgchBuf, m_szRef, (m_cchLen+1)*sizeof(ICHAR));// copy over null too
	else
		IStrCopyLen(rgchBuf, m_szRef, cchMax);//?? is this correct
	return m_cchLen;
}

//____________________________________________________________________________
//
//  CMsiStringComRef implementation
//____________________________________________________________________________

const IMsiString& CreateStringComRef(const ICHAR& sz, unsigned int cbSize, const IUnknown& riOwner)
{
	IMsiString* pi;
	if (!cbSize || (pi = new CMsiStringComRef(sz, cbSize, riOwner))==0)
		return g_MsiStringNull;

	return *pi;
}


CMsiStringComRef::CMsiStringComRef(const ICHAR& sz, unsigned int cbSize, const IUnknown& riOwner)
	: m_riOwner(riOwner)
{
	m_cchLen = cbSize;
	m_szRef = &sz;
	const_cast<IUnknown&>(riOwner).AddRef();
}

CMsiStringComRef::~CMsiStringComRef()
{
	const_cast<IUnknown&>(m_riOwner).Release();
}

unsigned long CMsiStringComRef::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

//____________________________________________________________________________
//
//  CMsiStringLive implementation
//____________________________________________________________________________

int LiveDate(ICHAR* rgchBuf, unsigned int cchBuf)
{
	SYSTEMTIME systime;
	WIN::GetLocalTime(&systime);
	return WIN::GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systime, 0,	rgchBuf, cchBuf) - 1;
}

int LiveTime(ICHAR* rgchBuf, unsigned int cchBuf)
{
	SYSTEMTIME systime;
	WIN::GetLocalTime(&systime);
	return WIN::GetTimeFormat(LOCALE_USER_DEFAULT, TIME_FORCE24HOURFORMAT | TIME_NOTIMEMARKER, &systime, 0,
							  rgchBuf, cchBuf) - 1;
}

int MemoryInfo(ICHAR* rgchBuf, unsigned int index)
{
	MEMORYSTATUS memorystatus;
	memorystatus.dwLength = sizeof(memorystatus);
	::GlobalMemoryStatus(&memorystatus);
	return ltostr(rgchBuf, (((DWORD*)&memorystatus)[index]+650000) >> 20);
}
#ifdef _WIN64	//!!merced: #defined to 0; temp. tofix this.
#define MEMSTATINDEX(m) 0
#else			// merced: win-32.
#define MEMSTATINDEX(m) (&((MEMORYSTATUS*)0)->m - (DWORD*)0)
#endif

int AvailPhys    (ICHAR* rgchBuf, unsigned int) {return MemoryInfo(rgchBuf, MEMSTATINDEX(dwAvailPhys));}
int AvailVirtual (ICHAR* rgchBuf, unsigned int) {return MemoryInfo(rgchBuf, MEMSTATINDEX(dwAvailVirtual));}
int AvailPageFile(ICHAR* rgchBuf, unsigned int) {return MemoryInfo(rgchBuf, MEMSTATINDEX(dwAvailPageFile));}
int TotalPhys    (ICHAR* rgchBuf, unsigned int) {return MemoryInfo(rgchBuf, MEMSTATINDEX(dwTotalPhys));}
int TotalVirtual (ICHAR* rgchBuf, unsigned int) {return MemoryInfo(rgchBuf, MEMSTATINDEX(dwTotalVirtual));}
int TotalPageFile(ICHAR* rgchBuf, unsigned int) {return MemoryInfo(rgchBuf, MEMSTATINDEX(dwTotalPageFile));}

const CMsiStringLive g_MsiStringDate(LiveDate);            // dynamic global date string object
const CMsiStringLive g_MsiStringTime(LiveTime);            // dynamic global time string object
const CMsiStringLive g_MsiStringAvailPhys(AvailPhys);
const CMsiStringLive g_MsiStringAvailVirtual(AvailVirtual);
const CMsiStringLive g_MsiStringAvailPageFile(AvailPageFile);
const CMsiStringLive g_MsiStringTotalPhys(TotalPhys);
const CMsiStringLive g_MsiStringTotalVirtual(TotalVirtual);
const CMsiStringLive g_MsiStringTotalPageFile(TotalPageFile);

unsigned long CMsiStringLive::AddRef()
{
	return 1;  // static object
}

unsigned long CMsiStringLive::Release()
{
	return 1;  // static object, never deleted
}

int CMsiStringLive::TextSize() const
{
	GetString();
	return m_cchLen;
}

const ICHAR* CMsiStringLive::GetString() const
{
	*const_cast<unsigned int*>(&m_cchLen) = (*m_pfCallback)(const_cast<ICHAR*>(m_rgchBuf), sizeof(m_rgchBuf)/sizeof(ICHAR));
	if (m_cchLen == 0xFFFFFFFF)  // date or time formatting failed, return null string
	{
		Assert(0);
		*const_cast<unsigned int*>(&m_cchLen) = 0;
		*(const_cast<ICHAR*>(m_rgchBuf)) = 0;
	}
	return m_rgchBuf;
}

int CMsiStringLive::CopyToBuf(ICHAR* rgchBuf, unsigned int cchMax) const
{
	const ICHAR* sz = GetString();
	int cch = IStrLen(sz);
	StringCchCopy(rgchBuf, cchMax+1, sz);
	return cch;
}

void CMsiStringLive::SetString(const ICHAR*, const IMsiString*&) const
{  // string is read-only;
}

//____________________________________________________________________________
//
//  IMsiString factories
//____________________________________________________________________________

const IMsiString& CreateMsiString(const ICHAR& rch)
{
	CMsiString* piStr;
	unsigned int cbSize = cbSize = IStrLen(&rch);

#ifndef UNICODE
	if (g_fDBCSEnabled)
	{
		int cch = cbSize;
		const ICHAR* pch = &rch;
		while (*pch)
		{
			pch = ::ICharNext(pch);
			cch--;
		}
		piStr = cch ? new(cbSize) CMsiStringDBCS(cbSize)
						: new(cbSize) CMsiStringSBCS(cbSize);
	}
	else
#endif
		piStr = new(cbSize) CMsiString(cbSize);

	if (!piStr)
		return g_MsiStringNull; //!! out of mem string
	IStrCopyLen(piStr->StringData(), &rch, cbSize);
	return *piStr;
}

ICHAR* AllocateString(unsigned int cbSize, Bool fDBCS, const IMsiString*& rpiStr)
{
	Assert(cbSize != 0);
#ifdef UNICODE
	fDBCS;  // ignored
	CMsiString* piStr = new(cbSize) CMsiString(cbSize);
#else
	CMsiString* piStr = fDBCS ? new(cbSize) CMsiStringDBCS(cbSize)
				: (g_fDBCSEnabled ? new(cbSize) CMsiStringSBCS(cbSize)
										: new(cbSize) CMsiString(cbSize));
#endif
	if (!piStr)
		return 0; //!! what else to do here?
	rpiStr = piStr;
	*(piStr->StringData() + cbSize) = 0;  // insure null terminator
	return piStr->StringData();
}

#ifndef UNICODE  // remainder of string methods is DBCS handling for non-Unicode build

//____________________________________________________________________________
//
//  CMsiStringSBCS implementation
//____________________________________________________________________________

const IMsiString& CMsiStringSBCS::Create(const ICHAR* sz)      
{
	int cch;
	const IMsiString* piStr;
	if (sz && (cch = IStrLen(sz)) != 0 && (piStr = new(cch) CMsiStringSBCS(*sz, cch)) != 0)
		return *piStr;
	return g_MsiStringNull;
}

CMsiStringSBCS::CMsiStringSBCS(const ICHAR& sz, int cch)
{
	m_cchLen = cch;
	StringCchCopy(m_szData, m_cchLen+1, &sz);
}

CMsiStringSBCS::CMsiStringSBCS(int cch)
{
	m_cchLen = cch;
}

void CMsiStringSBCS::SetString(const ICHAR* sz, const IMsiString*& rpi) const
{
	if (sz == m_szData)  // passing in our own private string, optimize
	{                    // also required to make RemoveReferences() efficient
		if (rpi == this)
			return;
		rpi = this;
		AddRef();
	}
	if (rpi)
		rpi->Release();  // caution: may release ourself, can't access data
	rpi = (sz == 0 || *sz == 0) ? (const IMsiString*)&g_MsiStringNull : &CreateMsiString(*sz);
}

void CMsiStringSBCS::RefString(const ICHAR* sz, const IMsiString*& rpi) const
{
	if (rpi)
		rpi->Release();  // caution: may release ourself, can't access data

	unsigned int cch2;
	Bool fDBCS = LOC::CheckDBCS(sz, cch2);
	const IMsiString* piStr =  LOC::CheckDBCS(sz, cch2) ? new CMsiStringDBCSRef(*sz)
																 : new CMsiStringSBCSRef(*sz);

	rpi = (sz && *sz && piStr != 0) ? piStr : &g_MsiStringNull;
}

void CMsiStringSBCS::AppendString(const ICHAR* sz, const IMsiString*& rpi) const
{
	const IMsiString* piOld = rpi;
	unsigned int cch2;
	Bool fDBCS = LOC::CheckDBCS(sz, cch2);
	if (!cch2)
	{
		rpi = this;
		AddRef();
	}
	else
		rpi = &LOC::StringCatSBCS(m_szData, m_cchLen, sz, cch2, fDBCS);
	if (piOld)
		piOld->Release();  // caution: may release ourself, do this last
}

void CMsiStringSBCS::AppendMsiString(const IMsiString& ri, const IMsiString*& rpi) const
{
	const IMsiString* piOld = rpi;
	int cch2 = ri.TextSize();
	if (!cch2)
	{
		rpi = this;
		AddRef();
	}
	else
		rpi = &LOC::StringCatSBCS(m_szData, m_cchLen, ri.GetString(), cch2, ri.IsDBCS());
	if (piOld)
		piOld->Release();  // caution: may release ourself, do this last
}

const IMsiString& CMsiStringSBCS::AddString(const ICHAR* sz) const
{
	unsigned int cch2;
	Bool fDBCS = LOC::CheckDBCS(sz, cch2);
	if (!cch2)
	{
		AddRef();
		return *this;
	}
	return LOC::StringCatSBCS(m_szData, m_cchLen, sz, cch2, fDBCS);
}

const IMsiString& CMsiStringSBCS::AddMsiString(const IMsiString& ri) const
{
	int cch2 = ri.TextSize();
	if (!cch2)
	{
		AddRef();
		return *this;
	}
	return LOC::StringCatSBCS(m_szData, m_cchLen, ri.GetString(), cch2, ri.IsDBCS());
}

//____________________________________________________________________________
//
//  CMsiStringSBCSRef implementation
//____________________________________________________________________________

CMsiStringSBCSRef::CMsiStringSBCSRef(const ICHAR& sz) : CMsiStringRef(sz)
{
}

void CMsiStringSBCSRef::SetString(const ICHAR* sz, const IMsiString*& rpi) const
{
	((CMsiStringSBCS*)this)->SetString(sz, rpi); // internal data not accessed
}

void CMsiStringSBCSRef::RefString(const ICHAR* sz, const IMsiString*& rpi) const
{
	((CMsiStringSBCS*)this)->RefString(sz, rpi); // internal data not accessed
}

void CMsiStringSBCSRef::RemoveRef(const IMsiString*& rpi) const
{
	const ICHAR* sz = m_szRef; // save string before we're gone
	int cch = m_cchLen;
	if (rpi)
		rpi->Release();  // caution: may release ourself, can't access data
	if (!(rpi = new(cch) CMsiStringSBCS(*sz, cch)))
		rpi = &g_MsiStringNull;
}

void CMsiStringSBCSRef::AppendString(const ICHAR* sz, const IMsiString*& rpi) const
{
	const IMsiString* piOld = rpi;
	unsigned int cch2;
	Bool fDBCS = LOC::CheckDBCS(sz, cch2);
	if (!cch2)
	{
		rpi = this;
		AddRef();
	}
	else
		rpi = &LOC::StringCatSBCS(m_szRef, m_cchLen, sz, cch2, fDBCS);
	if (piOld)
		piOld->Release();  // caution: may release ourself, do this last
}

void CMsiStringSBCSRef::AppendMsiString(const IMsiString& ri, const IMsiString*& rpi) const
{
	const IMsiString* piOld = rpi;
	int cch2 = ri.TextSize();
	if (!cch2)
	{
		rpi = this;
		AddRef();
	}
	else
		rpi = &LOC::StringCatSBCS(m_szRef, m_cchLen, ri.GetString(), cch2, ri.IsDBCS());
	if (piOld)
		piOld->Release();  // caution: may release ourself, do this last
}

const IMsiString& CMsiStringSBCSRef::AddString(const ICHAR* sz) const
{
	unsigned int cch2;
	Bool fDBCS = LOC::CheckDBCS(sz, cch2);
	if (!cch2)
	{
		AddRef();
		return *this;
	}
	return LOC::StringCatSBCS(m_szRef, m_cchLen, sz, cch2, fDBCS);
}

const IMsiString& CMsiStringSBCSRef::AddMsiString(const IMsiString& ri) const
{
	int cch2 = ri.TextSize();
	if (!cch2)
	{
		AddRef();
		return *this;
	}
	return LOC::StringCatSBCS(m_szRef, m_cchLen, ri.GetString(), cch2, ri.IsDBCS());
}

//____________________________________________________________________________
//
//  CMsiStringDBCS implementation
//____________________________________________________________________________

const IMsiString& CMsiStringDBCS::Create(const ICHAR* sz)
{
	int cch;
	const IMsiString* piStr;
	if (sz && (cch = IStrLen(sz)) != 0 && (piStr = new(cch) CMsiStringDBCS(*sz, cch)) != 0)
		return *piStr;
	return g_MsiStringNull;
}

CMsiStringDBCS::CMsiStringDBCS(const ICHAR& sz, int cch)
{
	m_cchLen = cch;
	StringCchCopy(m_szData, m_cchLen+1, &sz);
}

CMsiStringDBCS::CMsiStringDBCS(int cch)
{
	m_cchLen = cch;
}

Bool CMsiStringDBCS::IsDBCS() const
{
	return fTrue;
}

int CMsiStringDBCS::CharacterCount() const
{
	return CountChars(m_szData);
}

void CMsiStringDBCS::AppendString(const ICHAR* sz, const IMsiString*& rpi) const
{
	const IMsiString* piOld = rpi;
	unsigned int cch2;
	Bool fDBCS = LOC::CheckDBCS(sz, cch2);
	if (!cch2)
	{
		rpi = this;
		AddRef();
	}
	else
		rpi = &LOC::StringCatDBCS(m_szData, m_cchLen, sz, cch2);
	if (piOld)
		piOld->Release();  // caution: may release ourself, do this last
}

void CMsiStringDBCS::AppendMsiString(const IMsiString& ri, const IMsiString*& rpi) const
{
	const IMsiString* piOld = rpi;
	int cch2 = ri.TextSize();
	if (!cch2)
	{
		rpi = this;
		AddRef();
	}
	else
		rpi = &LOC::StringCatDBCS(m_szData, m_cchLen, ri.GetString(), cch2);
	if (piOld)
		piOld->Release();  // caution: may release ourself, do this last
}

const IMsiString& CMsiStringDBCS::AddString(const ICHAR* sz) const
{
	unsigned int cch2;
	Bool fDBCS = LOC::CheckDBCS(sz, cch2);
	if (!cch2)
	{
		AddRef();
		return *this;
	}
	return LOC::StringCatDBCS(m_szData, m_cchLen, sz, cch2);
}

const IMsiString& CMsiStringDBCS::AddMsiString(const IMsiString& ri) const
{
	int cch2 = ri.TextSize();
	if (!cch2)
	{
		AddRef();
		return *this;
	}
	return LOC::StringCatDBCS(m_szData, m_cchLen, ri.GetString(), cch2);
}

const IMsiString& CMsiStringDBCS::Extract(iseEnum ase, unsigned int iLimit) const
{
	return *GetSubstringDBCS(*this, ase, iLimit, fFalse);
}

Bool CMsiStringDBCS::Remove(iseEnum ase, unsigned int iLimit, const IMsiString*& rpi) const
{
	const IMsiString* piStr = GetSubstringDBCS(*this, ase, iLimit, fTrue);
	if (!piStr)
		return fFalse;
	if (rpi)
		rpi->Release();  // caution: may release ourself, do this last
	rpi = piStr;
	return fTrue;
}

int CMsiStringDBCS::Compare(iscEnum asc, const ICHAR* sz) const
{
	return CompareDBCS(asc, m_cchLen, GetString(), sz);
}

//____________________________________________________________________________
//
//  CMsiStringDBCSRef implementation
//____________________________________________________________________________

CMsiStringDBCSRef::CMsiStringDBCSRef(const ICHAR& sz) : CMsiStringSBCSRef(sz)
{
}

Bool CMsiStringDBCSRef::IsDBCS() const
{
	return fTrue;
}

int CMsiStringDBCSRef::CharacterCount() const
{
	return CountChars(m_szRef);
}

void CMsiStringDBCSRef::RemoveRef(const IMsiString*& rpi) const
{
	const ICHAR* sz = m_szRef; // save string before we're gone
	if (rpi)
		rpi->Release();  // caution: may release ourself, can't access data
	rpi = &CMsiStringDBCS::Create(sz);
}

void CMsiStringDBCSRef::AppendString(const ICHAR* sz, const IMsiString*& rpi) const
{
	const IMsiString* piOld = rpi;
	unsigned int cch2;
	Bool fDBCS = LOC::CheckDBCS(sz, cch2);
	if (!cch2)
	{
		rpi = this;
		AddRef();
	}
	else
		rpi = &LOC::StringCatDBCS(m_szRef, m_cchLen, sz, cch2);
	if (piOld)
		piOld->Release();  // caution: may release ourself, do this last
}

void CMsiStringDBCSRef::AppendMsiString(const IMsiString& ri, const IMsiString*& rpi) const
{
	const IMsiString* piOld = rpi;
	int cch2 = ri.TextSize();
	if (!cch2)
	{
		rpi = this;
		AddRef();
	}
	else
		rpi = &LOC::StringCatDBCS(m_szRef, m_cchLen, ri.GetString(), cch2);
	if (piOld)
		piOld->Release();  // caution: may release ourself, do this last
}

const IMsiString& CMsiStringDBCSRef::AddString(const ICHAR* sz) const
{
	unsigned int cch2;
	Bool fDBCS = LOC::CheckDBCS(sz, cch2);
	if (!cch2)
	{
		AddRef();
		return *this;
	}
	return LOC::StringCatDBCS(m_szRef, m_cchLen, sz, cch2);
}

const IMsiString& CMsiStringDBCSRef::AddMsiString(const IMsiString& ri) const
{
	int cch2 = ri.TextSize();
	if (!cch2)
	{
		AddRef();
		return *this;
	}
	return LOC::StringCatDBCS(m_szRef, m_cchLen, ri.GetString(), cch2);
}

const IMsiString& CMsiStringDBCSRef::Extract(iseEnum ase, unsigned int iLimit) const
{
	return *GetSubstringDBCS(*this, ase, iLimit, fFalse);
}

Bool CMsiStringDBCSRef::Remove(iseEnum ase, unsigned int iLimit, const IMsiString*& rpi) const
{
	const IMsiString* piStr = GetSubstringDBCS(*this, ase, iLimit, fTrue);
	if (!piStr)
		return fFalse;
	if (rpi)
		rpi->Release();  // caution: may release ourself, do this last
	rpi = piStr;
	return fTrue;
}

int CMsiStringDBCSRef::Compare(iscEnum asc, const ICHAR* sz) const
{
	return CompareDBCS(asc, m_cchLen, m_szRef, sz);
}

//____________________________________________________________________________
//
// DBCS Extract and Remove common search function
//____________________________________________________________________________

const IMsiString* GetSubstringDBCS(const IMsiString& riThis, iseEnum ase, unsigned int iLimit, Bool fRemove)
{
	const ICHAR* pch = riThis.GetString();
	unsigned int cch = riThis.TextSize();
	const ICHAR* pchEnd;
	unsigned int cbCopy;
	unsigned int cchCopy;
	if (ase & iseChar)
	{
		cchCopy = 0;
		if (ase & iseEnd)
		{
			for (pchEnd = pch + cch; pchEnd > pch && *pchEnd != iLimit; pchEnd=::ICharPrev(pch, pchEnd))
				cchCopy++;
			if (fRemove && *pchEnd != iLimit)
				pchEnd--;  // force Remove to fail if not found
			else if (!(ase & iseInclude) && *pchEnd == iLimit && iLimit != 0)
			{
				pchEnd++;  // OK in DBCS, since this character is passed in as single byte
				cchCopy--;
			}
//			Assert((pch + cch - pchEnd) <= UINT_MAX);	//--merced: 64-bit ptr subtraction may lead to values too big for cbCopy
			cbCopy = (unsigned int)(pch + cch - pchEnd);
//			pch = pchEnd;
		}
		else
		{
			for (pchEnd = pch; *pchEnd != iLimit && pchEnd != pch + cch; pchEnd = ::ICharNextWithNulls(pchEnd, (pch+cch)))
				cchCopy++;
//			Assert((pchEnd - pch) <= UINT_MAX);			//--merced: 64-bit ptr subtraction may lead to values too big for cbCopy
			cbCopy = (unsigned int)(pchEnd - pch);
			if (((ase & iseInclude) && pchEnd != pch + cch)
			 || (fRemove && pchEnd == pch + cch && iLimit != 0)) // force Remove to fail if not found
			{
				cbCopy++;
				cchCopy++;
			}
		}
	}
	else  // must count the hard way since DBCS chars are known to be in the string
	{
		cchCopy = iLimit;  // save requested count
		if (ase & iseEnd)
		{
			for (pchEnd = pch + cch; iLimit && pchEnd > pch; pchEnd=::ICharPrev(pch, pchEnd))
				iLimit--;
//			Assert((pch + cch - pchEnd) <= UINT_MAX);	//--merced: 64-bit ptr subtraction may lead to values too big for cbCopy
			cbCopy = (unsigned int)(pch + cch - pchEnd);
		}
		else
		{
			for (pchEnd = pch; iLimit && pchEnd != pch + cch; pchEnd = ::ICharNextWithNulls(pchEnd, (pch + cch)))
				iLimit--;
//			Assert((pchEnd - pch) <= UINT_MAX);			//--merced: 64-bit ptr subtraction may lead to values too big for cbCopy
			cbCopy = (unsigned int)(pchEnd - pch);
		}
		cchCopy -= iLimit;
	}
	if (cbCopy > cch)
	{
		cbCopy = cch;
		if (fRemove)
			return 0;
	}

	cchCopy -= cbCopy;  // zero if no double-byte characters

	if (fRemove)
	{
		if (!(ase & iseEnd))
			pch += cbCopy;
//		Assert(cch - cbCopy < UINT_MAX);			//--merced: 64-bit ptr subtraction may lead to values too big for cbCopy
		cbCopy = (unsigned int)(cch - cbCopy);

		if (cchCopy == 0) // no double-byte chars removed
			cchCopy++;   // force remaining string to DBCS
		else  // possibly double byte characters remaining, must scan
		{
			for (pchEnd = pch, cchCopy = cbCopy; cchCopy; cchCopy--, pchEnd++)
			{
				if (::ICharNextWithNulls(pchEnd, (pch + cch)) != pchEnd + 1)
					break;  // double byte char found
			}
		}
	}
	else // Extract
	{
		if (ase & iseEnd)
		{
			pchEnd = pch + cch;
			pch = pchEnd - cbCopy;
		}
		else
		{
			pchEnd = pch + cbCopy;
		}
		if (ase & iseTrim)
		{
			while (cbCopy && *pch == ' ' || *pch == '\t')
			{
				pch++;
				cbCopy--;
			}
			while (cbCopy && *(--pchEnd) == ' ' || *pchEnd == '\t')
			{
				cbCopy--;
			}
		}
	}
	if (cbCopy == 0)
		return &g_MsiStringNull;
	if (cbCopy == cch)
	{
		riThis.AddRef();
		return &riThis;
	}
	CMsiString* piStr = cchCopy ? new(cbCopy) CMsiStringDBCS(cbCopy)
										 : new(cbCopy) CMsiStringSBCS(cbCopy);
	if (!piStr)
		return &g_MsiStringNull; //!! out of mem string
	IStrCopyLen(piStr->StringData(), pch, cbCopy);
	memmove(piStr->StringData(), pch, cbCopy*sizeof(ICHAR));
	(piStr->StringData())[cbCopy] = 0;
	return piStr;
}

#if 0 // SBCS version of above for testing purposes only
const IMsiString* GetSubstringSBCS(const IMsiString& riThis, iseEnum ase, unsigned int iLimit, Bool fRemove)
{
	const ICHAR* pch = riThis.GetString();
	unsigned int cch = riThis.TextSize();
	const ICHAR* pchEnd;
	if (ase & iseChar)
	{
		if (ase & iseEnd)
		{
			for (pchEnd = pch + cch; --pchEnd >= pch && *pchEnd != iLimit;)
				;
			iLimit = pch + cch - pchEnd;
			if (!(ase & iseInclude) && (pchEnd >= pch)) // insure Remove fail
				iLimit--;
		}
		else if (fRemove && iLimit == 0)  //!! fRemove test not needed
			iLimit = cch;
		else
		{
			for (pchEnd = pch; *pchEnd != iLimit && *pchEnd != 0; pchEnd++)
				;
			iLimit = pchEnd - pch;
			if ((ase & iseInclude) || (fRemove && *pchEnd == 0)) // force Remove fail
				iLimit++;
		}
	}
	if (iLimit > cch)
	{
		iLimit = cch;
		if (fRemove)
			return 0;
	}

	if (fRemove)
	{
		if (!(ase & iseEnd))
			pch += iLimit;
		iLimit = cch - iLimit;
	}
	else // Extract
	{
		if (ase & iseEnd)
		{
			pchEnd = pch + cch;
			pch = pchEnd - iLimit;
		}
		else
		{
			pchEnd = pch + iLimit;
		}
		if (ase & iseTrim)
		{
			while (iLimit && *pch == ' ' || *pch == '\t')
			{
				pch++;
				iLimit--;
			}
			while (iLimit && *(--pchEnd) == ' ' || *pchEnd == '\t')
			{
				iLimit--;
			}
		}
	}
	if (iLimit == 0)
		return &g_MsiStringNull;
	else if (iLimit == cch)
	{
		riThis.AddRef();
		return &riThis;
	}
	else // if (iLimit < cch)
	{
		CMsiString& riStr = CMsiString::Create(iLimit);
		IStrCopyLen(riStr.StringData(), pch, iLimit);
		return &riStr;
	}
}
#endif

//____________________________________________________________________________
//
// DBCS utility functions 
//____________________________________________________________________________

Bool CheckDBCS(const ICHAR* pch, unsigned int& riSize)
{
	if (!pch)
		return (riSize = 0, fFalse);
	unsigned int cch = IStrLen(pch);
	riSize = cch;
	while (*pch)
	{
		pch = ::ICharNext(pch);
		cch--;
	}
	return cch ? fTrue : fFalse;
}

const IMsiString& StringCatSBCS(const ICHAR* sz1, int cch1, const ICHAR* sz2, int cch2, Bool fDBCS)
{
	int cchTotal = cch1 + cch2;
	CMsiString* piStr = fDBCS ? new(cchTotal) CMsiStringDBCS(cchTotal)									  : new(cchTotal) CMsiStringSBCS(cchTotal);
	if (!piStr)
		return g_MsiStringNull; //!! out of mem string
	ICHAR* szNew = piStr->StringData();
	memmove(szNew, sz1, cch1*sizeof(ICHAR));
	memmove((szNew + cch1), sz2, (cch2 + 1)*sizeof(ICHAR));// copy over null too
	return *piStr;
}

const IMsiString& StringCatDBCS(const ICHAR* sz1, int cch1, const ICHAR* sz2, int cch2)
{
	int cchTotal = cch1 + cch2;
	CMsiString* piStr = new(cchTotal) CMsiStringDBCS(cchTotal);
	if (!piStr)
		return g_MsiStringNull; //!! out of mem string
	ICHAR* szNew = piStr->StringData();
	memmove(szNew, sz1, cch1*sizeof(ICHAR));
	memmove((szNew + cch1), sz2, (cch2 + 1)*sizeof(ICHAR));// copy over null too
	return *piStr;
}

inline int DBCSDifference(const ICHAR* sz1, const ICHAR* sz2)
{
	// return the number of DBCS characters between sz1 and sz2 (in Ansi terms, sz2 - sz1)
	// assumes sz2 is within sz1
	Assert(sz1 <= sz2);
	int cch = 0;
	while(sz1 < sz2)
	{
		sz1 = ICharNextWithNulls(sz1, sz2);
		cch++;
	}
	return cch;
}

int CompareDBCS(iscEnum asc, int ccbLen, const ICHAR* sz1, const ICHAR* sz2)
{
// ccbLen: length of object string
// sz1: string contained in object
// sz2: string passed to ::Compare
// this code could be made smaller by extracting out common code
// however, the performance is more critical here than saving a few bytes
	if (sz2 == 0)
		sz2 = TEXT("");

	int cb, i;
	ICHAR* szTemp;
	const ICHAR *pchComp;
	ICHAR rgchBuf[512];  // for temp copy to avoid allocation
	int cch;

	if (asc == iscExact)
		return (lstrcmp(sz1, sz2)==0) ? 1 : 0;
	else if (asc == iscExactI)
		return (lstrcmpi(sz1, sz2)==0) ? 1 : 0;
	else
	{
		if (ccbLen == 0)
			return 0;

		switch (asc)
		{
			case iscStart:
					if ((cb = IStrLen(sz2)) > ccbLen)
					return 0;
				i = memcmp(sz1, sz2, cb * sizeof(ICHAR));
				return i == 0 ? 1 : 0;
			case iscStartI:
				if ((cb = IStrLen(sz2)) > ccbLen)
					return 0;
				szTemp= cb < sizeof(rgchBuf) ?  rgchBuf : new ICHAR[cb+1];
				if ( ! szTemp )
					return 0;
				IStrCopyLen(szTemp, sz1, cb);
				i = lstrcmpi(szTemp, sz2);
				if (szTemp != rgchBuf)
					delete szTemp;
				return i == 0 ? 1 : 0;
			case iscEnd:
				if ((cb = IStrLen(sz2)) > ccbLen)
					return 0;
				cch = CountChars(sz2);
				if ((pchComp = CharPrevCch(sz1, sz1+ccbLen, cch)) == 0)
					return 0;
				return (lstrcmp(pchComp, sz2) == 0)
							? CountChars(sz1) - cch+1 : 0;
			case iscEndI:
				if ((cb=IStrLen(sz2)) > ccbLen)
					return 0;
				cch = CountChars(sz2);
				if ((pchComp = CharPrevCch(sz1, sz1+ccbLen, cch)) == 0)
					return 0;
				return (lstrcmpi(pchComp, sz2) == 0)
							? CountChars(sz1) - cch+1 : 0;
			case iscWithin:
				if (IStrLen(sz2) > ccbLen)
					return 0;
				szTemp = (char*)PchMbsStr((const unsigned char*)sz1, (const unsigned char*)sz2);
				return (szTemp==NULL) ? 0 : (DBCSDifference(sz1,szTemp) + 1);
			case iscWithinI:
				if (IStrLen(sz2) > ccbLen)
					return 0;
				else
				{	
					cb = IStrLen(sz2)+1;
					ICHAR *szLowerCch= new ICHAR[ccbLen+1];
					ICHAR *szLowerSz = new ICHAR[cb];
					if ( ! szLowerCch || ! szLowerSz )
					{
						delete [] szLowerCch;
						delete [] szLowerSz;
						return 0;
					}
					StringCchCopy(szLowerCch, ccbLen+1, sz1);
					StringCchCopy(szLowerSz, cb, sz2);
					CharLower(szLowerCch);
					CharLower(szLowerSz);
					ICHAR* pch = (char*)PchMbsStr((const unsigned char*)szLowerCch, (const unsigned char*)szLowerSz);
					delete [] szLowerCch;
					delete [] szLowerSz;
					return (pch==NULL) ? 0 : (DBCSDifference(szLowerCch,pch) + 1);
				}
			default:
				//FIXmsh: Error;
				return 0;
		}	
	}
}

//____________________________________________________________________________
//
// DEBUG DBCS Simulation, for testing purposes only
//____________________________________________________________________________

#ifdef DEBUG
static int s_chLeadByte = 0;

void IMsiString_SetDBCSSimulation(char chLeadByte)
{
	static Bool g_fDBCSEnabledSave = g_fDBCSEnabled;  // save original copy
	if ((s_chLeadByte = chLeadByte) == 0)
		g_fDBCSEnabled = g_fDBCSEnabledSave;  // restore system state
	else
		g_fDBCSEnabled = fTrue;  // enable DBCS mode for testing
}

ICHAR* ICharNext(const ICHAR* pch)
{
	if (!s_chLeadByte || s_chLeadByte != *pch)
		return WIN::CharNext(pch);
	if (*(++pch) != 0)
		pch++;
	return const_cast<ICHAR*>(pch);
}

ICHAR* INextChar(const ICHAR* pch)
{
	if (!s_chLeadByte || s_chLeadByte != *pch)
		return WIN::CharNext(pch);
	if (*(++pch) != 0)
		pch++;
	return const_cast<ICHAR*>(pch);
}

const char* ICharPrev(const char* sz, const char* pch)
{
	const char* pchPrev = pch - 2;
	if (!s_chLeadByte || pchPrev < sz || *pchPrev != s_chLeadByte)
		return WIN::CharPrev(sz, pch);
	int cRepeat = 0;
	for (pch = pchPrev; *(--pch) == s_chLeadByte; cRepeat ^= 1)
		; // not a lead byte if pairs of lead bytes
	return pchPrev + cRepeat;
}
#endif // DEBUG

#endif // !UNICODE  // preceding section of file is DBCS handling for non-Unicode build

//____________________________________________________________________________
//
// CEnumMsiString definition, implementation class for IEnumMsiString
//____________________________________________________________________________

class CEnumMsiString : public IEnumMsiString
{
 public:
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();

	HRESULT __stdcall Next(unsigned long cFetch, const IMsiString** rgpi, unsigned long* pcFetched);
	HRESULT __stdcall Skip(unsigned long cSkip);
	HRESULT __stdcall Reset();
	HRESULT __stdcall Clone(IEnumMsiString** ppiEnum);

	CEnumMsiString(const IMsiString** ppstr, unsigned long i_Size);
 protected:
	virtual ~CEnumMsiString(void);  // protected to prevent creation on stack
	unsigned long      m_iRefCnt;      // reference count
	unsigned long      m_iCur;         // current enum position
	const IMsiString** m_ppstr;        // string we enumerate
	unsigned long      m_iSize;        // size of string array
};

HRESULT CreateStringEnumerator(const IMsiString **ppstr, unsigned long iSize, IEnumMsiString* &rpaEnumStr)
{
	rpaEnumStr = new CEnumMsiString(ppstr, iSize);
	return S_OK;
}

CEnumMsiString::CEnumMsiString(const IMsiString **ppstr, unsigned long iSize):
		m_iCur(0), m_iSize(iSize), m_iRefCnt(1), m_ppstr(0)
{
	if(m_iSize > 0)
	{
		m_ppstr = new const IMsiString* [m_iSize];
		if ( ! m_ppstr )
		{
			m_iSize = 0;
			return;
		}
		for (unsigned long itmp = 0; itmp < m_iSize; itmp++)
		{
			// just share the interface
			m_ppstr[itmp] = ppstr[itmp];
			
			// therefore bump up the reference
			m_ppstr[itmp]->AddRef();
		}
	}
}


CEnumMsiString::~CEnumMsiString()
{
	if(m_iSize > 0)
	{
		for(unsigned long itmp = 0; itmp < m_iSize; itmp++)
		{
			if(m_ppstr[itmp])
				m_ppstr[itmp]->Release();       
		}
		delete [] m_ppstr;
	}
}


unsigned long CEnumMsiString::AddRef()
{
	return ++m_iRefCnt;
}


unsigned long CEnumMsiString::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}


HRESULT CEnumMsiString::Next(unsigned long cFetch, const IMsiString** rgpi, unsigned long* pcFetched)
{
	unsigned long cFetched = 0;
	unsigned long cRequested = cFetch;

	if(rgpi)
	{
		while (m_iCur < m_iSize && cFetch > 0)
		{
			*rgpi = m_ppstr[m_iCur];
			m_ppstr[m_iCur]->AddRef();
			rgpi++;
			cFetched++;
			m_iCur ++;
			cFetch--;
		}
	}
	if (pcFetched)
		*pcFetched = cFetched;
	return (cFetched == cRequested ? S_OK : S_FALSE);
}


HRESULT CEnumMsiString::Skip(unsigned long cSkip)
{
	if ((m_iCur+cSkip) > m_iSize)
	return S_FALSE;

	m_iCur+= cSkip;
	return S_OK;
}

HRESULT CEnumMsiString::Reset()
{
	m_iCur=0;
	return S_OK;
}

HRESULT CEnumMsiString::Clone(IEnumMsiString** ppiEnum)
{
	*ppiEnum = new CEnumMsiString(m_ppstr, m_iSize);
	if ( ! *ppiEnum )
		return E_OUTOFMEMORY;
	((CEnumMsiString* )*ppiEnum)->m_iCur = m_iCur;
	return S_OK;
}

HRESULT CEnumMsiString::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IEnumMsiString)
	{
		*ppvObj = this;
		AddRef();
		return S_OK;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

int CountChars(const ICHAR *sz)
{
#ifndef UNICODE
	const ICHAR* pch = sz;
	for (int cch = 0; *pch; pch = ::ICharNext(pch), cch++)
		;
	return cch;
#else
	return lstrlen(sz);
#endif //UNICODE
}

#ifndef UNICODE
//
// Backs up cch chars from pchEnd if pchStart is the beginning
// returns 0 if not enough characters
//
const ICHAR *CharPrevCch(const ICHAR *pchStart, const ICHAR *pchEnd, int cch)
{
	const ICHAR *pchRet = pchEnd;

	while (cch > 0)
	{
		if (pchRet <= pchStart)
			return 0;
		pchRet = ICharPrev(pchStart, pchRet);
		cch--;
	}
	
	return pchRet;

}
#endif //!UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\latebind.cpp ===
#include "precomp.h"
#include "combind.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\msidbg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msidbg.cpp
//
//--------------------------------------------------------------------------

/* msidbg.cpp - IMsiDebug implementation for services

	Implements a debug object for the services DLL
____________________________________________________________________________*/

#include "precomp.h" 

#ifdef DEBUG

const HANDLE iFileNotOpen = 0;

const char rgchLFCR[2] = {'\r', '\n'};

extern const GUID IID_IMsiDebug;
extern CMsiDebug vDebug;
extern bool g_fFlushDebugLog;	// Set to true when we're shutting down so it's faster.
extern UINT MsiGetWindowsDirectory(LPTSTR lpBuffer, UINT cchBuffer);

CMsiDebug::CMsiDebug()
{
	m_hLogFile = iFileNotOpen;
}

CMsiDebug::~CMsiDebug()
{
	CloseHandle(m_hLogFile);
	m_hLogFile = iFileNotOpen;
}

HRESULT CMsiDebug::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown
		|| riid == IID_IMsiDebug)
		*ppvObj = this;
	else
	{
		*ppvObj = 0;
		return E_NOINTERFACE;
	}
	
	AddRef();
	return NOERROR;

}

unsigned long CMsiDebug::AddRef()
{
	return 1;
}

unsigned long CMsiDebug::Release()
{
	return 0;
}


void CMsiDebug::SetAssertFlag(Bool fShowAsserts)
{
	g_fNoAsserts = fShowAsserts;
}

#ifndef UNICODE
extern void IMsiString_SetDBCSSimulation(char chLeadByte);
#endif 

void CMsiDebug::SetDBCSSimulation(char chLeadByte)
{
#ifndef UNICODE
	IMsiString_SetDBCSSimulation(chLeadByte);
#else
	chLeadByte;
#endif
}

IMsiDebug* CreateMsiDebug()
{
	return &vDebug;
}

Bool CMsiDebug::WriteLog(const ICHAR *szText) // cannot allocate memory
{

	DWORD dwBytesWritten;

	if (!szText)
		return fFalse;
	if (iFileNotOpen == m_hLogFile)
		if (!CreateLog())
			return fFalse;
			
	if (!WriteFile(m_hLogFile, szText, lstrlen(szText)*sizeof(ICHAR), 
	 &dwBytesWritten, 0))
		return fFalse;
	WriteFile(m_hLogFile, rgchLFCR, sizeof(rgchLFCR), &dwBytesWritten, 0);
	if (g_fFlushDebugLog && !FlushFileBuffers(m_hLogFile))
		return fFalse;

	return fTrue;
}

void CMsiDebug::AssertNoObjects()
{
	AssertEmptyRefList(&g_refHead);
}

void  CMsiDebug::SetRefTracking(long iid, Bool fTrack)
{

	::SetFTrackFlag(iid, fTrack);

}

Bool CMsiDebug::CreateLog()
{
	const ICHAR *szConfigFolder = TEXT("\\MSI");
	const ICHAR *szFile = TEXT("log");
	ICHAR rgchTemp[MAX_PATH];
	ICHAR rgchPath[MAX_PATH];
	
	MsiGetWindowsDirectory(rgchPath, sizeof(rgchPath)/sizeof(ICHAR));
	StringCbCat(rgchPath, sizeof(rgchPath), szConfigFolder);
	if (GetTempFileName(rgchPath, szFile, 0, rgchTemp))
	{	
		m_hLogFile = CreateFile(rgchTemp, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ, 
										0, CREATE_ALWAYS,
										FILE_ATTRIBUTE_NORMAL, 0);


		if (m_hLogFile == INVALID_HANDLE_VALUE)
		{
			m_hLogFile = iFileNotOpen;
			return fFalse;
		}
		return fTrue;
	}
	return fFalse;
}

#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\msiprops.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       msiprops.cpp
//
//--------------------------------------------------------------------------

#include "precomp.h"
#include "_msiutil.h"
#pragma warning(disable : 4005)  // macro redefinition

#ifdef TEXT
#undef TEXT
#undef _TEXT
#undef __TEXT
#endif

#ifdef ProductProperty
#undef ProductProperty
#undef g_ProductPropertyTable
#endif 

#ifdef SPECIALTEXT
#undef SPECIALTEXT
#undef _SPECIALTEXT
#undef __SPECIALTEXT
#endif

#ifdef MSIUNICODE 
#define UNICODE
#else
#undef UNICODE
#endif
#include "msi.h"
#include "_msinst.h"
#ifndef MSIUNICODE
#pragma message("Building Install Properties ANSI")
#endif


#ifdef MSIUNICODE
#define TEXT(quote) L##quote
#define _TEXT(quote) L##quote
#define __TEXT(quote) L##quote
#define ProductProperty ProductPropertyW
#define g_ProductPropertyTable g_ProductPropertyTableW
#else
#define TEXT(quote) quote
#define _TEXT(quote) quote
#define __TEXT(quote) quote
#define ProductProperty ProductPropertyA
#define g_ProductPropertyTable g_ProductPropertyTableA
#endif


ProductProperty g_ProductPropertyTable[] = 
{
//  Property                         Valuename                   Location        Property type
//  -------------------------------------------------------------------------------------------

	INSTALLPROPERTY_TRANSFORMS,      szTransformsValueName,      pplAdvertised,  ptProduct,
	INSTALLPROPERTY_LANGUAGE,        szLanguageValueName,        pplAdvertised,  ptProduct,
	INSTALLPROPERTY_PRODUCTNAME,     szProductNameValueName,     pplAdvertised,  ptProduct,
	INSTALLPROPERTY_PACKAGECODE,     szPackageCodeValueName,     pplAdvertised,  (ptPropertyType)(ptProduct|ptPatch|ptSQUID),
	INSTALLPROPERTY_VERSION,         szVersionValueName,         pplAdvertised,  ptProduct,
	INSTALLPROPERTY_ASSIGNMENTTYPE,  szAssignmentTypeValueName,  pplAdvertised,  ptProduct,
	INSTALLPROPERTY_ADVTFLAGS,       szAdvertisementFlags,       pplAdvertised,  ptProduct,
	szAssignedValueName,             szAssignedValueName,        pplAdvertised,  ptProduct,
	INSTALLPROPERTY_PRODUCTICON,     szProductIconValueName,     pplAdvertised,  ptProduct,
	INSTALLPROPERTY_INSTALLEDPRODUCTNAME, szDisplayNameValueName,pplUninstall,   ptProduct,
	INSTALLPROPERTY_VERSIONSTRING,   szDisplayVersionValueName,  pplUninstall,   ptProduct,
	INSTALLPROPERTY_HELPLINK,        szHelpLinkValueName,        pplUninstall,   ptProduct,
	INSTALLPROPERTY_HELPTELEPHONE,   szHelpTelephoneValueName,   pplUninstall,   ptProduct,
	INSTALLPROPERTY_INSTALLLOCATION, szInstallLocationValueName, pplUninstall,   ptProduct,
	INSTALLPROPERTY_INSTALLSOURCE,   szInstallSourceValueName,   pplUninstall,   ptProduct,
	INSTALLPROPERTY_INSTALLDATE,     szInstallDateValueName,     pplUninstall,   ptProduct,
	INSTALLPROPERTY_PUBLISHER,       szPublisherValueName,       pplUninstall,   ptProduct,
	INSTALLPROPERTY_LOCALPACKAGE,    szLocalPackageValueName,    pplUninstall,   (ptPropertyType)(ptProduct|ptPatch),
	INSTALLPROPERTY_URLINFOABOUT,    szURLInfoAboutValueName,    pplUninstall,   ptProduct,
	INSTALLPROPERTY_URLUPDATEINFO,   szURLUpdateInfoValueName,   pplUninstall,   ptProduct,
	INSTALLPROPERTY_VERSIONMINOR,    szVersionMinorValueName,    pplUninstall,   ptProduct,
	INSTALLPROPERTY_VERSIONMAJOR,    szVersionMajorValueName,    pplUninstall,   ptProduct,
	szUserNameValueName,             szUserNameValueName,        pplUninstall,   ptProduct,
	szOrgNameValueName,              szOrgNameValueName,         pplUninstall,   ptProduct,
	szPIDValueName,                  szPIDValueName,             pplUninstall,   ptProduct,
	TEXT("PackageName"),             szPackageNameValueName,     pplSourceList,  (ptPropertyType)(ptProduct|ptPatch),
	TEXT("Clients"),                 szClientsValueName,         pplAdvertised,  ptProduct,
	szWindowsInstallerValueName,     szWindowsInstallerValueName,pplUninstall,   ptProduct,
	szInstanceTypeValueName,         szInstanceTypeValueName,    pplAdvertised,  ptProduct,
	0,0,pplNext,
};


#ifndef MSIUNICODE
#define MSIUNICODE
#pragma message("Building Install Properties UNICODE")
#include "msiprops.cpp"
#endif //MSIUNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\precomp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       precomp.h
//
//--------------------------------------------------------------------------

#ifndef __PRECOMP
#define __PRECOMP

#include "common.h"

extern const IMsiString& g_riMsiStringNull;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\msinst.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       msinst.cpp
//
//--------------------------------------------------------------------------

/* msinst.cpp - Installer Service implementation
____________________________________________________________________________*/
#pragma warning(disable : 4005)  // macro redefinition
#include "precomp.h"  // must be first for use with pre-compiled headers

#ifdef UNICODE
#define UNICODEDEFINED
#else
#undef UNICODEDEFINED
#endif
#ifdef MSIUNICODE
#define UNICODE
#endif

#include "msi.h"
#ifndef UNICODEDEFINED
#undef UNICODE
#endif

#include "_engine.h"
#ifndef MSINST
#define MSINST
#endif
#include "_msinst.h"
#include "_msiutil.h"
#include "_srcmgmt.h"
#include "_execute.h"
#include "eventlog.h"
#include "resource.h"

#ifndef MSIUNICODE
#pragma message("Building MSI API ANSI")
#endif

// Define WIN95TEST to pretend we only have ANSI reg APIs available. 
// #define WIN95TEST

/*
 * This file MUST be compiled with MSIUNICODE undefined. The Ansi
 * (non-MSIUNICODE) functions are defined in the first pass. At the
 * end of the file we define MSIUNICODE and include this file to 
 * be compiled again, this time defining the MSIUNICODE functions.
 */

//____________________________________________________________________________
//
// During the first pass we included the headers (windows.h, etc)
// with MSIUNICODE undefined. We can't include the headers a second
// time with MSIUNICODE defined as the headers are guarded against
// multiple includes. Thus, we have to manually redefine these
// macros to their MSIUNICODE versions. 
//____________________________________________________________________________

#if defined(_WIN64)
#pragma warning(disable : 4042)		// A compiler bug causes this warning to be generated on CAPITempBuffer uses
#endif

#ifdef MSIUNICODE
#pragma warning(disable : 4005)  // macro redefinition

// Windows APIs
#define RegQueryValueEx      RegQueryValueExW
#define RegEnumKeyEx         RegEnumKeyExW
#define RegEnumValue         RegEnumValueW
#define RegDeleteValue       RegDeleteValueW
#define RegSetValueEx        RegSetValueExW
#define LoadLibraryEx        LoadLibraryExW
#define lstrcmpi             lstrcmpiW
#define lstrcmp              lstrcmpW
#define lstrlen              lstrlenW
#define lstrcpyn             lstrcpynW
#define MessageBox           MessageBoxW
#define GetModuleFileName    GetModuleFileNameW
#define CreateFile               CreateFileW
#define ExpandEnvironmentStrings ExpandEnvironmentStringsW
#define GetEnvironmentVariable   GetEnvironmentVariableW
#define CharNext                 CharNextW
#define CSCQueryFileStatus       CSCQueryFileStatusW
#define CharPrev             CharPrevW
#define StringCchLength      StringCchLengthW
#define StringCbCopy		 StringCbCopyW
#define StringCchCopy		 StringCchCopyW
#define StringCchCat		 StringCchCatW
#define StringCbCat			 StringCbCatW
#define StringCbPrintf		 StringCbPrintfW
#define StringCchPrintf		 StringCchPrintfW
// Darwin APIs
#define MsiGetComponentPath                  MsiGetComponentPathW
#define MsiLocateComponent                   MsiLocateComponentW
#define MsiQueryProductState                 MsiQueryProductStateW
#define MsiQueryFeatureState                 MsiQueryFeatureStateW
#define MsiGetProductCode                    MsiGetProductCodeW
#define MsiVerifyPackage                     MsiVerifyPackageW
#define MsiGetUserInfo                       MsiGetUserInfoW
#define MsiCollectUserInfo                   MsiCollectUserInfoW
#define MsiConfigureFeature                  MsiConfigureFeatureW
#define MsiInstallProduct                    MsiInstallProductW
#define MsiConfigureProduct                  MsiConfigureProductW
#define MsiConfigureProductEx                MsiConfigureProductExW
#define MsiReinstallProduct                  MsiReinstallProductW
#define MsiReinstallFeature                  MsiReinstallFeatureW
#define MsiAdvertiseProduct                  MsiAdvertiseProductW
#define MsiProcessAdvertiseScript            MsiProcessAdvertiseScriptW
#define MsiAdvertiseScript                   MsiAdvertiseScriptW
#define MsiProvideComponent                  MsiProvideComponentW
#define MsiProvideQualifiedComponent         MsiProvideQualifiedComponentW
#define MsiProvideQualifiedComponentEx       MsiProvideQualifiedComponentExW
#define MsiProvideComponentFromDescriptor    MsiProvideComponentFromDescriptorW
#define MsiQueryFeatureStateFromDescriptor   MsiQueryFeatureStateFromDescriptorW
#define MsiConfigureFeatureFromDescriptor    MsiConfigureFeatureFromDescriptorW
#define MsiInstallMissingComponent           MsiInstallMissingComponentW
#define MsiInstallMissingFile                MsiInstallMissingFileW
#define MsiReinstallFeatureFromDescriptor    MsiReinstallFeatureFromDescriptorW
#define MsiEnumProducts                      MsiEnumProductsW
#define MsiEnumRelatedProducts               MsiEnumRelatedProductsW
#define MsiEnumClients                       MsiEnumClientsW
#define MsiEnumComponents                    MsiEnumComponentsW
#define MsiEnumFeatures                      MsiEnumFeaturesW
#define MsiGetFeatureParent                  MsiGetFeatureParentW
#define MsiEnumComponentQualifiers           MsiEnumComponentQualifiersW
#define MsiGetQualifierDescription           MsiGetQualifierDescriptionW
#define MsiGetProductInfoFromScript          MsiGetProductInfoFromScriptW
#define MsiUseFeature                        MsiUseFeatureW
#define MsiUseFeatureEx                      MsiUseFeatureExW
#define MsiGetFeatureUsage                   MsiGetFeatureUsageW
#define MsiOpenProduct                       MsiOpenProductW
#define MsiCloseProduct                      MsiCloseProductW
#define MsiGetProductProperty                MsiGetProductPropertyW
#define MsiGetProductInfo                    MsiGetProductInfoW
#define MsiGetFeatureInfo                    MsiGetFeatureInfoW
#define MsiOpenPackage                       MsiOpenPackageW
#define MsiOpenPackageEx                     MsiOpenPackageExW
#define MsiEnableLog                         MsiEnableLogW
#define INSTALLUI_HANDLER                    INSTALLUI_HANDLERW
#define MsiSetExternalUI                     MsiSetExternalUIW
#define MsiApplyPatch                        MsiApplyPatchW
#define MsiEnumPatches                       MsiEnumPatchesW
#define MsiGetPatchInfo                      MsiGetPatchInfoW
#define MsiGetProductCodeFromPackageCode     MsiGetProductCodeFromPackageCodeW
#define MsiGetFileVersion                    MsiGetFileVersionW
#define MsiLoadString                        MsiLoadStringW
#define MsiMessageBox                        MsiMessageBoxW
#define MsiDecomposeDescriptor               MsiDecomposeDescriptorW
#define MsiGetShortcutTarget                 MsiGetShortcutTargetW
#define MsiSourceListClearAll                MsiSourceListClearAllW
#define MsiSourceListAddSource               MsiSourceListAddSourceW
#define MsiSourceListForceResolution         MsiSourceListForceResolutionW
#define MsiIsProductElevated                 MsiIsProductElevatedW
#define MsiGetFileHash                       MsiGetFileHashW
#define MsiGetFileSignatureInformation       MsiGetFileSignatureInformationW
#define MsiProvideAssembly                   MsiProvideAssemblyW
#define MsiAdvertiseProductEx                MsiAdvertiseProductExW
#define MsiNotifySidChange                   MsiNotifySidChangeW
#define MsiDeleteUserData					 MsiDeleteUserDataW

// Darwin internal functions
#define ProductProperty                      ProductPropertyW 
#define g_ProductPropertyTable               g_ProductPropertyTableW
#define FeatureContainsComponentPacked       FeatureContainsComponentPackedW
#define IncrementFeatureUsagePacked          IncrementFeatureUsagePackedW
#define MsiRegQueryValueEx                   MsiRegQueryValueExW
#define EnumProducts                         EnumProductsW
#define EnumAllClients                       EnumAllClientsW
#define Migrate10CachedPackages              Migrate10CachedPackagesW

#pragma warning(default : 4005)
#else
#pragma warning(disable : 4005)  // macro redefinition
// Windows APIs
#define RegQueryValueEx      RegQueryValueExA
#define RegEnumKeyEx         RegEnumKeyExA
#define RegEnumValue         RegEnumValueA
#define RegDeleteValue       RegDeleteValueA
#define RegSetValueEx        RegSetValueExA
#define LoadLibraryEx        LoadLibraryExA
#define lstrcmpi             lstrcmpiA
#define lstrcmp              lstrcmpA
#define lstrlen              lstrlenA
#define lstrcpyn             lstrcpynA
#define MessageBox           MessageBoxA
#define GetModuleFileName    GetModuleFileNameA
#define CreateFile               CreateFileA
#define ExpandEnvironmentStrings ExpandEnvironmentStringsA
#define GetEnvironmentVariable   GetEnvironmentVariableA
#define CSCQueryFileStatus       CSCQueryFileStatusA
#define CharNext                             CharNextA
#define CharPrev             CharPrevA
#define StringCchLength      StringCchLengthA
#define StringCbCopy		 StringCbCopyA
#define StringCchCopy		 StringCchCopyA
#define StringCchCat		 StringCchCatA
#define StringCbCat			 StringCbCatA
#define StringCbPrintf		 StringCbPrintfA
#define StringCchPrintf		 StringCchPrintfA
// Darwin APIs
#define MsiGetComponentPath                  MsiGetComponentPathA
#define MsiLocateComponent                   MsiLocateComponentA
#define MsiQueryProductState                 MsiQueryProductStateA
#define MsiQueryFeatureState                 MsiQueryFeatureStateA
#define MsiGetProductCode                    MsiGetProductCodeA
#define MsiVerifyPackage                     MsiVerifyPackageA
#define MsiGetUserInfo                       MsiGetUserInfoA
#define MsiCollectUserInfo                   MsiCollectUserInfoA
#define MsiConfigureFeature                  MsiConfigureFeatureA
#define MsiInstallProduct                    MsiInstallProductA
#define MsiConfigureProduct                  MsiConfigureProductA
#define MsiConfigureProductEx                MsiConfigureProductExA
#define MsiReinstallProduct                  MsiReinstallProductA
#define MsiReinstallFeature                  MsiReinstallFeatureA
#define MsiAdvertiseProduct                  MsiAdvertiseProductA
#define MsiProcessAdvertiseScript            MsiProcessAdvertiseScriptA
#define MsiAdvertiseScript                   MsiAdvertiseScriptA
#define MsiProvideComponent                  MsiProvideComponentA
#define MsiProvideQualifiedComponent         MsiProvideQualifiedComponentA
#define MsiProvideQualifiedComponentEx       MsiProvideQualifiedComponentExA
#define MsiProvideComponentFromDescriptor    MsiProvideComponentFromDescriptorA
#define MsiQueryFeatureStateFromDescriptor   MsiQueryFeatureStateFromDescriptorA
#define MsiConfigureFeatureFromDescriptor    MsiConfigureFeatureFromDescriptorA
#define MsiInstallMissingComponent           MsiInstallMissingComponentA
#define MsiInstallMissingFile                MsiInstallMissingFileA
#define MsiReinstallFeatureFromDescriptor    MsiReinstallFeatureFromDescriptorA
#define MsiEnumProducts                      MsiEnumProductsA
#define MsiEnumRelatedProducts               MsiEnumRelatedProductsA
#define MsiEnumClients                       MsiEnumClientsA
#define MsiEnumComponents                    MsiEnumComponentsA
#define MsiEnumFeatures                      MsiEnumFeaturesA
#define MsiGetFeatureParent                  MsiGetFeatureParentA
#define MsiEnumComponentQualifiers           MsiEnumComponentQualifiersA
#define MsiGetQualifierDescription           MsiGetQualifierDescriptionA
#define MsiGetProductInfoFromScript          MsiGetProductInfoFromScriptA
#define MsiUseFeature                        MsiUseFeatureA
#define MsiUseFeatureEx                      MsiUseFeatureExA
#define MsiGetFeatureUsage                   MsiGetFeatureUsageA
#define MsiOpenProduct                       MsiOpenProductA
#define MsiCloseProduct                      MsiCloseProductA
#define MsiGetProductProperty                MsiGetProductPropertyA
#define MsiGetProductInfo                    MsiGetProductInfoA
#define MsiGetFeatureInfo                    MsiGetFeatureInfoA
#define MsiOpenPackage                       MsiOpenPackageA
#define MsiOpenPackageEx                     MsiOpenPackageExA
#define MsiEnableLog                         MsiEnableLogA
#define INSTALLUI_HANDLER                    INSTALLUI_HANDLERA
#define MsiSetExternalUI                     MsiSetExternalUIA
#define MsiApplyPatch                        MsiApplyPatchA
#define MsiEnumPatches                       MsiEnumPatchesA
#define MsiGetPatchInfo                      MsiGetPatchInfoA
#define MsiGetProductCodeFromPackageCode     MsiGetProductCodeFromPackageCodeA
#define MsiGetFileVersion                    MsiGetFileVersionA
#define MsiLoadString                        MsiLoadStringA
#define MsiMessageBox                        MsiMessageBoxA
#define MsiDecomposeDescriptor               MsiDecomposeDescriptorA
#define MsiGetShortcutTarget                 MsiGetShortcutTargetA
#define MsiSourceListClearAll                MsiSourceListClearAllA
#define MsiSourceListAddSource               MsiSourceListAddSourceA
#define MsiSourceListForceResolution         MsiSourceListForceResolutionA
#define MsiIsProductElevated                 MsiIsProductElevatedA
#define MsiGetFileHash                       MsiGetFileHashA
#define MsiGetFileSignatureInformation       MsiGetFileSignatureInformationA
#define MsiProvideAssembly                   MsiProvideAssemblyA
#define MsiAdvertiseProductEx                MsiAdvertiseProductExA
#define MsiNotifySidChange                   MsiNotifySidChangeA
#define MsiDeleteUserData					 MsiDeleteUserDataA

// Darwin internal functions
#define ProductProperty                      ProductPropertyA
#define g_ProductPropertyTable               g_ProductPropertyTableA

#define FeatureContainsComponentPacked       FeatureContainsComponentPackedA
#define IncrementFeatureUsagePacked          IncrementFeatureUsagePackedA
#define MsiRegQueryValueEx                   MsiRegQueryValueExA
#define EnumProducts                         EnumProductsA
#define EnumAllClients                       EnumAllClientsA
#define Migrate10CachedPackages              Migrate10CachedPackagesA
#pragma warning(default : 4005)
#endif // MSIUNICODE

//____________________________________________________________________________
//
// Because we can't include the Windows headers twice we need to use
// our own generic character type, DCHAR, instead of the traditional
// TCHAR. We'll use the MSIUNICODE flag to set DCHAR to the right thing
// just like the Windows headers do it.
//____________________________________________________________________________

#ifdef MSIUNICODE
#pragma warning(disable : 4005)  // macro redefinition
#define DCHAR WCHAR
#define LPCDSTR LPCWSTR
#define LPDSTR LPWSTR
#define MSITEXT(quote) L##quote
#define _MSITEXT(quote) L##quote
#define __MSITEXT(quote) L##quote
#pragma warning(default : 4005)
#else // !MSIUNICODE
#define DCHAR char
#define LPCDSTR LPCSTR
#define LPDSTR LPSTR
#define MSITEXT(quote) quote
#define _MSITEXT(quote) quote
#define __MSITEXT(quote) quote
#endif

#undef CMsInstApiConvertString
#undef CACHED_CONVERTSTRING
#if (defined(UNICODE) && defined(MSIUNICODE)) || (!defined(UNICODE) && !defined(MSIUNICODE))
#define CMsInstApiConvertString(X) X
#define CACHED_CONVERTSTRING(T,X,Y) const T* X= Y;
#else
#define CMsInstApiConvertString(X) CApiConvertString(X)
#define CACHED_CONVERTSTRING(T,X,Y) CApiConvertString X(Y);
#endif

//
// We only want the following code included once, during the first, Ansi pass.
//____________________________________________________________________________

#ifndef MSIUNICODE  // start of Ansi-only data and helper functions

#include "_engine.h"
#include "engine.h"

extern HINSTANCE g_hInstance;

const int cchMsiProductsKey           = sizeof(szMsiProductsKey)/sizeof(DCHAR);
const int cchGPTProductsKey           = sizeof(szGPTProductsKey)/sizeof(DCHAR);
const int cchGPTComponentsKey         = sizeof(szGPTComponentsKey)/sizeof(DCHAR);
const int cchGPTFeaturesKey           = sizeof(szGPTFeaturesKey)/sizeof(DCHAR);
const int cchMsiInProgressKey         = sizeof(szMsiInProgressKey)/sizeof(DCHAR);
const int cchMergedClassesSuffix      = sizeof(szMergedClassesSuffix)/sizeof(DCHAR);
const int cchMsiPatchesKey            = sizeof(szPatchesSubKey)/sizeof(DCHAR);
const int cchMsiUserDataKey		      = sizeof(szMsiUserDataKey)/sizeof(DCHAR);

//____________________________________________________________________________
//
// Globals.
//____________________________________________________________________________

// GUID <--> SQUID transform helper buffers
const unsigned char rgEncodeSQUID[85+1] = "!$%&'()*+,-.0123456789=?@"
										  "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "[]^_`"
										  "abcdefghijklmnopqrstuvwxyz" "{}~";

const unsigned char rgDecodeSQUID[95] =
{  0,85,85,1,2,3,4,5,6,7,8,9,10,11,85,12,13,14,15,16,17,18,19,20,21,85,85,85,22,85,23,24,
// !  "  # $ % & ' ( ) * + ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?  @
  25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,85,52,53,54,55,
// A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _  `
  56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,85,83,84,85};
// a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~  ^ 0x7F

const unsigned char rgOrderGUID[32] = {8,7,6,5,4,3,2,1, 13,12,11,10, 18,17,16,15,
									   21,20, 23,22, 26,25, 28,27, 30,29, 32,31, 34,33, 36,35}; 

const unsigned char rgTrimGUID[32]  = {1,2,3,4,5,6,7,8, 10,11,12,13, 15,16,17,18,
									   20,21, 22,23, 25,26, 27,28, 29,30, 31,32, 33,34, 35,36}; 

const unsigned char rgOrderDash[4] = {9, 14, 19, 24};

DWORD   g_dwLogMode = 0;
Bool    g_fLogAppend = fFalse;
bool    g_fFlushEachLine = false;
ICHAR   g_szLogFile[MAX_PATH+1] = TEXT("");

// the various enumerations possible for the EnumInfo function
enum eetEnumerationType{
	eetProducts,
	eetUpgradeCode,
	eetComponents,
	eetComponentClients,
	eetComponentAllClients,
};



// process-level source cache - used for all RFS resolutions except from descriptors.
CRFSCachedSourceInfo g_RFSSourceCache;

// sets the resolved source into the cache for the specified SQUID and disk. Does not
// validate the source, SQUID, or DiskID. Thread Safe.
bool CRFSCachedSourceInfo::SetCachedSource(const ICHAR *szProductSQUID, int uiDiskID, const ICHAR* const szSource)
{
	// synchronize calls across threads
	while (TestAndSet(&m_iBusyLock) == true)
	{
		Sleep(500);
	}

	if ( !szProductSQUID || !szSource ||
		  IStrLen(szProductSQUID) != cchProductCodePacked )

	{
		// release synchronization
		m_iBusyLock = 0;
		return false;
	}

	m_fValid = false;

	// store DiskID and SQUID
	m_uiDiskID = uiDiskID;
	StringCbCopyW(m_rgchValidatedProductSQUID, sizeof(m_rgchValidatedProductSQUID), szProductSQUID);

	// resize path buffer if necessary. Add 1 for terminating NULL
	UINT cchSource = IStrLen(szSource);
	if (m_rgchValidatedSource.GetSize() < cchSource+1)
	{
		if (!m_rgchValidatedSource.SetSize(cchSource+1))
		{
			// unable to allocate memory
			m_iBusyLock = 0;
			return false;
		}
	}

	StringCchCopyW(m_rgchValidatedSource, m_rgchValidatedSource.GetSize(), szSource);

	// cache is now valid
	m_fValid = true;

	// release synchronization
	m_iBusyLock = 0;
	return true;
}

// checks the current state of the cache against the provided SQUID and DiskId. If a match
// is found, place the cached path in rgchPath and return true, otherwise return false. Thread safe. 
bool CRFSCachedSourceInfo::RetrieveCachedSource(const ICHAR* szProductSQUID, int uiDiskID, CAPITempBufferRef<ICHAR>& rgchPath) const
{
	// synchronize access to the cache across threads.
	while (TestAndSet(&m_iBusyLock) == true)
	{
		Sleep(500);
	}

	bool fResult = false;
	if (m_fValid)
	{
		// if the SQUID and DiskId match, return the path			 
		if ((uiDiskID == m_uiDiskID) &&
			(0 == IStrComp(szProductSQUID, m_rgchValidatedProductSQUID)))
		{
			// resize the output buffer if necessary. GetSize() is always >= IStrLen+1, and
			// is faster.
			UINT cchSource = m_rgchValidatedSource.GetSize();
			if (rgchPath.GetSize() < cchSource)
			{
				if (!rgchPath.SetSize(cchSource))
				{
					// release synchronization lock.
					m_iBusyLock = 0;
					return false;
				}
			}
			StringCchCopyW(rgchPath, rgchPath.GetSize(), (const ICHAR *)m_rgchValidatedSource);
			fResult = true;
			DEBUGMSG3(TEXT("Retrieving cached source for product %s, disk %d: %s"), m_rgchValidatedProductSQUID, reinterpret_cast<ICHAR*>(static_cast<INT_PTR>(uiDiskID)), rgchPath);
		}
	}
			
	// release synchronization lock.
	m_iBusyLock = 0;
	return fResult;
}


// (there's one more global after the definition of OpenProduct)

iuiEnum GetStandardUILevel()
{
	if (g_message.m_iuiLevel == iuiDefault)
		return iuiDefaultUILevel;
	else
	{
		iuiEnum iuiLevel = g_message.m_iuiLevel;
		if (g_message.m_fNoModalDialogs)
			iuiLevel = iuiEnum((int)iuiLevel | iuiNoModalDialogs);
		if (g_message.m_fHideCancel)
			iuiLevel = (iuiEnum)((int)iuiLevel | iuiHideCancel);
		if (g_message.m_fSourceResolutionOnly)
			iuiLevel = (iuiEnum)((int)iuiLevel | iuiSourceResOnly);
		
		return iuiLevel;
	}
}

UINT DoCoInitialize()
{
	bool fOLEInitialized = false;

	HRESULT hRes = OLE32::CoInitialize(0);

	if (SUCCEEDED(hRes))
	{
		return hRes;
	}
	else if (RPC_E_CHANGED_MODE == hRes)
	{
		//?? Is this OK to ignore? 

		// ignore -- OLE has been initialized with COINIT_MULTITHREADED
	}
	else
	{
		return ERROR_INSTALL_FAILURE;
	}

	return E_FAIL;
}

extern CMsiAPIMessage g_message;

//____________________________________________________________________________
//
// Helper functions.
//____________________________________________________________________________

// class to handle strings fixed length, NON-LOCALIZED IN/OUT parameters
// Will update the original buffer whenever cast, or destroyed.
// Will operate on the original buffer whenever cast to the original type.
// once cast, you should always use the latest pointer. The ideal use is 
// in a function call:   Foo(CFixedLengthParam(pointer));

const DWORD DwGuardValue = 0xDEADDEAD;

template<UINT SIZE> class CFixedLengthParam
{
public:

	// cchBuf should include NULL
	CFixedLengthParam(LPWSTR szBuf)
		{
#ifdef DEBUG
			m_dwGuard = DwGuardValue;
#endif
			m_pchWideBuf = szBuf; 
			m_fWideOriginal = m_fWideLastReferenced = true; 

			m_pchMultiBuf = (LPSTR) m_rgchRawBuf;
		}	
	
	CFixedLengthParam(LPSTR szBuf)
		{
#ifdef DEBUG
			m_dwGuard = DwGuardValue;
#endif

			m_pchMultiBuf = szBuf; 
			m_fWideOriginal = m_fWideLastReferenced = false; 
	
			m_pchWideBuf = (LPWSTR) m_rgchRawBuf;
		}


	// guarantees that the original is correct.
	~CFixedLengthParam()
		{
			Assert(DwGuardValue == m_dwGuard);

			if (m_fWideLastReferenced != m_fWideOriginal)
				Update();
		}


	// guarantee both strings match.
	void Update()
		{
			Assert(DwGuardValue == m_dwGuard);

			int cchConverted = 0;

			if (m_fWideLastReferenced)
			{
				// update the char version.
				cchConverted = WIN::WideCharToMultiByte(CP_ACP, 0, m_pchWideBuf, SIZE, m_pchMultiBuf, SIZE, 0, 0);
			}
			else
			{
				// update the wide version
				cchConverted = WIN::MultiByteToWideChar(CP_ACP, 0, m_pchMultiBuf, SIZE, m_pchWideBuf, SIZE);
			}

			Assert(DwGuardValue == m_dwGuard);
			Assert(cchConverted <= SIZE);
		}

	// avoids re-copying when cast to the same type repeatedly
	operator LPWSTR()
		{ 
			Assert(DwGuardValue == m_dwGuard);

			if (!m_fWideLastReferenced) 
			{
				Update(); 
				m_fWideLastReferenced = true;  
			}
			return m_pchWideBuf; 
		}
	operator LPSTR()
		{ 
			Assert(DwGuardValue == m_dwGuard);

			if (m_fWideLastReferenced)  
			{
				Update();
				m_fWideLastReferenced = false; 
			}
			return m_pchMultiBuf; 
		}	

protected:
		

	char*  m_pchMultiBuf;
	WCHAR* m_pchWideBuf;



	// only used when MSIUNICODE != UNICODE
	ICHAR   m_rgchRawBuf[SIZE];

#ifdef DEBUG
	DWORD m_dwGuard; // MUST BE AFTER RAW BUFFER, to catch buffer overruns.
#endif



	// when m_fWideOriginal != m_fWideLastReferenced, the temporary needs duplication
	// back to the original string.
	bool   m_fWideOriginal;
	bool   m_fWideLastReferenced;
};




// class to handle MSIUNICODE conversion for OUT parameters
class CWideToAnsiOutParam
{
public:
	CWideToAnsiOutParam(LPWSTR szBuf, DWORD* pcchBuf);
	CWideToAnsiOutParam(LPWSTR szBuf, DWORD* pcchBuf, int* piRetval, int iMoreData=ERROR_MORE_DATA, int iSuccess1=ERROR_SUCCESS);
	CWideToAnsiOutParam(LPWSTR szBuf, DWORD* pcchBuf, int* piRetval, int iMoreData, int iSuccess1, int iSuccess2);
	void Initialize(LPWSTR szBuf, DWORD* pcchBuf, int* piRetval, int iMoreData, int iSuccess1, int iSuccess2);

	CWideToAnsiOutParam(LPWSTR szBuf, const DWORD cchBuf)
	{
		// We presume in this constructor that we're only dealing
		// with SBCS characters and it's therefore safe to 
		// use a buffer of size cchBuf

		if (cchBuf > m_rgchAnsiBuf.GetSize())
			m_rgchAnsiBuf.SetSize(cchBuf);
		*m_rgchAnsiBuf = 0;
		m_szWideBuf    = szBuf;
		m_pcchBuf      = 0;
		// Because we're dealing only with SBCS chars, set this to the right size fo
		// the destructor
		m_cbBuf       = cchBuf * sizeof(WCHAR);
		m_piRetval    = 0;
	}

	~CWideToAnsiOutParam();
	operator char*() {if (m_szWideBuf) return m_rgchAnsiBuf; else return 0;}
protected:
	CAPITempBuffer<char, cchApiConversionBuf+1> m_rgchAnsiBuf;
	LPWSTR m_szWideBuf;
	DWORD* m_pcchBuf;
	DWORD  m_cbBuf;
	unsigned int m_cSuccessValues;
	int m_iSuccess1;
	int m_iSuccess2;
	int *m_piRetval;
	int m_iMoreData;
};

CWideToAnsiOutParam::CWideToAnsiOutParam(LPWSTR szBuf, DWORD* pcchBuf, int* piRetval, int iMoreData, int iSuccess1) 
{
	Assert(piRetval);
	Initialize(szBuf,  pcchBuf,  piRetval, iMoreData, iSuccess1, 0);
	m_cSuccessValues = 1;
}

void CWideToAnsiOutParam::Initialize(LPWSTR szBuf, DWORD* pcchBuf, int* piRetval, int iMoreData, int iSuccess1, int iSuccess2)
{
	if (pcchBuf)
	{
		// We need to make sure we can accomodate up to *pcchBuf UNICODE
		// characters. If they're all DBCS this will require double *pcchBuf
		// characters, so we'll pass in the entire buffer we were given.

		*pcchBuf = *pcchBuf * sizeof(WCHAR);
		if ((m_cbBuf = *pcchBuf) > m_rgchAnsiBuf.GetSize())
			m_rgchAnsiBuf.SetSize(*pcchBuf);
	}
	*m_rgchAnsiBuf = 0;
	m_szWideBuf    = szBuf;
	m_pcchBuf      = pcchBuf;
	m_iSuccess1    = iSuccess1;
	m_iSuccess2    = iSuccess2;
	m_piRetval     = piRetval;
	m_iMoreData    = iMoreData;
}

CWideToAnsiOutParam::CWideToAnsiOutParam(LPWSTR szBuf, DWORD* pcchBuf, int* piRetval, int iMoreData, int iSuccess1, int iSuccess2)  
{
	Assert(piRetval);
	Initialize(szBuf, pcchBuf, piRetval, iMoreData, iSuccess1, iSuccess2);
	m_cSuccessValues = 2;
}

CWideToAnsiOutParam::~CWideToAnsiOutParam()
	{
			int iRet = 0;
			DWORD dwError = ERROR_INSUFFICIENT_BUFFER;

			bool fSuccess = !m_piRetval || (m_iSuccess1 == *m_piRetval || (m_cSuccessValues == 2 && m_iSuccess2 == *m_piRetval));

			if (fSuccess)
			{
				if (m_szWideBuf)
				{
					iRet = MultiByteToWideChar(CP_ACP, 0, m_rgchAnsiBuf, -1, m_szWideBuf, m_cbBuf/sizeof(WCHAR));
					if (0 == iRet)
					{
						// Conversion failed. Probably our wide buffer is too small because some
						// of the Ansi characters turned out to be DBCS. We'll get the necessary wide buffer
						// size

						dwError = GetLastError();
				
						if (ERROR_INSUFFICIENT_BUFFER == dwError)
						{
							iRet = MultiByteToWideChar(CP_ACP, 0, m_rgchAnsiBuf, -1, 0, 0);
						}
					}
					
					if (m_pcchBuf && iRet)
					{
						*m_pcchBuf = iRet - 1;  // don't count the returned null

						// if the buffer size that we're returning is greater than the original size
						// then we need to return the more_data return value.
						
						if (*m_pcchBuf + 1 > m_cbBuf / sizeof(WCHAR))
						{
							if (m_piRetval)
								*m_piRetval = m_iMoreData;
						}
					}

				}
			}
			else if (m_iMoreData == *m_piRetval || !m_szWideBuf)
			{
				// we know how many ansi characters we have but because we had no buffer to fill or the
				// buffer was too small, we can't do the conversion. we'll have to assume the worst, 
				// and return that we require *m_pcchBuf UNICODE characters. If any of the ANSI characters 
				// are DBCS then this estimate is too big but we'll have to live with it.

				// m_pcchBuf is already set correctly
			}
			
	};


inline DWORD OpenGlobalSubKeyEx(HKEY hive, const ICHAR* subkey, CRegHandle& riHandle, bool fSetKeyString)
{
	DWORD dwResult = ERROR_SUCCESS;

	for (int cRetry = 0 ; cRetry < 2; cRetry++)
	{
		// since it's called only from OpenInstalledProductInstallPropertiesKey...
		CACHED_CONVERTSTRING(ICHAR, szUnicodeSubkey, subkey)
		dwResult = MsiRegOpen64bitKey(hive, szUnicodeSubkey, 0, g_samRead, &riHandle);

		if (ERROR_KEY_DELETED == dwResult) //?? should we be handling this case or just asserting?... see similar cases in other Open*Key fns
		{
			// close key and restart, re-opening the key
			DEBUGMSG("Re-opening deleted key");
		}
		else
		{
			if (ERROR_SUCCESS == dwResult && fSetKeyString)
			{
				riHandle.SetKey(hive, szUnicodeSubkey);
			}
			return dwResult;
		}
	}
	return dwResult;
}

// Win64 WARNING: if called from other place than _GetComponentPath, make sure you
// take the time to set samAddon correctly.
DWORD OpenUserKey(HKEY* phKey, bool fMergedClasses, REGSAM samAddon)
{
	if (g_fWin9X || g_iMajorVersion < 5)
		return ERROR_PROC_NOT_FOUND;
		
	DWORD dwResult;

	if(fMergedClasses)
	{
		HANDLE hToken;
		bool fCloseHandle = false;
		dwResult = GetCurrentUserToken(hToken, fCloseHandle);
		if(dwResult == ERROR_SUCCESS)
		{
			if(IsLocalSystemToken(hToken) || (ERROR_FILE_NOT_FOUND == (dwResult = ADVAPI32::RegOpenUserClassesRoot(hToken, 0, KEY_READ | samAddon, phKey))))
			{
				// the user is the system and is not impersonated OR 
				// error reading merged hive since user's profile is not loaded,
				// return HKLM\S\C
				dwResult = RegOpenKeyAPI(HKEY_LOCAL_MACHINE,  szClassInfoSubKey, 0, KEY_READ | samAddon, phKey);
			}
		}
		if (fCloseHandle)
			WIN::CloseHandle(hToken);
	}
	else
		dwResult = ADVAPI32::RegOpenCurrentUser(KEY_READ | samAddon, phKey);
	
	return dwResult;
}

bool AllowInstallation()
{
	static Bool s_fPreventCalls = (Bool)-1;

	if (s_fPreventCalls == -1)
	{
		// Bug 7854. This code is a hack to work around an issue with early shell
		// release wherein calling IShellLink::Resolve faults in the shortcut. 
		// This causes problems with some apps (e.g. Win98 fat16->fat32 converter
		// that enumerate the Start Menu, resolving each of the links). Suddenly
		// the user will notice all of their advertised apps being faulted in. The
		// hack is as follows:
		//
		// 1) Are we in the explorer's process? Allow call to proceed; otherwise
		// 2) Does our shell have the issue fixed? Allow call to proceed; otherwise
		// 3) Is the ResolveIOD policy set? Allow call to proceed; otherwise
		// 4) Are we in a process that really wants IShellLink::Resolve to really
		//    resolve? This list is in the registry. If so, proceed; otherwise
		// 5) Return 1603. This should (hopefully) cause Darwin-unaware apps to 
		//    ignore the link.

		DCHAR rgchOurModule[MAX_PATH+1];
		DCHAR* pchOurModule;
		// GetModuleFileName does not guarantee null termination if buffer is exactly the right size
		rgchOurModule[ARRAY_ELEMENTS(rgchOurModule)-1] = TEXT('\0');
		int cchOurModule = WIN::GetModuleFileName(NULL, rgchOurModule, MAX_PATH);
		if (rgchOurModule[ARRAY_ELEMENTS(rgchOurModule)-1] != TEXT('\0'))
		{
			// buffer overflow, we better don't go any further with this.
			DEBUGMSG("Installations through MsiProvideComponentFromDescriptor are disallowed.");
			return false;
		}
		
		s_fPreventCalls = fFalse;
		pchOurModule = rgchOurModule + cchOurModule;
		
		if (cchOurModule)
		{
			cchOurModule = 0;
			while ((pchOurModule != rgchOurModule) && (*(pchOurModule-1) != '\\')) 
			{
				pchOurModule = WIN::CharPrev(rgchOurModule, pchOurModule);
				cchOurModule++;
			}
		}
		
		const DCHAR rgchExplorer[] = MSITEXT("explorer.exe");
		const int cchExplorer = sizeof(rgchExplorer)/sizeof(DCHAR) - 1;
		if ((cchOurModule != cchExplorer) || (0 != lstrcmpi(pchOurModule, rgchExplorer)))
		{
			// We're not explorer. Is our shell late enough that it doesn't matter?

			DLLVERSIONINFO verinfoShell;
			verinfoShell.dwMajorVersion = 0;  // initialize to unknown
			verinfoShell.cbSize = sizeof(DLLVERSIONINFO);
			if ((SHELL32::DllGetVersion(&verinfoShell) != NOERROR) ||
				 ((verinfoShell.dwMajorVersion < 5)))
			{
				// Shell is an early version. Check the policy.

				if (!GetIntegerPolicyValue(szResolveIODValueName, fTrue))
				{
					// Policy is not set. Check for other apps that want to
					// IShellLink::Resolve to work.

					s_fPreventCalls = fTrue; // if we find an app we'll set it to false

					for (int cAttempt=0; cAttempt < 2; cAttempt++)
					{
						DWORD dwRes = ERROR_SUCCESS;
						CRegHandle HKey;
						dwRes = MsiRegOpen64bitKey(cAttempt == 0  ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER, 
													szMsiResolveIODKey, 0,
													KEY_READ, &HKey);

						if (ERROR_SUCCESS == dwRes)
						{
							if (ERROR_SUCCESS == RegQueryValueEx(HKey, pchOurModule, 0, 0, 0, 0))
							{
								s_fPreventCalls = fFalse;
								break;
							}
						}
					}
				}
			}
		}
	}

	if (s_fPreventCalls)
	{
		DEBUGMSG("Installations through MsiProvideComponentFromDescriptor are disallowed.");
		return false;
	}

	return true;
}

inline bool IsValidAssignmentValue(int a) { return a >= iaaUserAssign && a <= iaaMachineAssign ? true : false; }

// constants for short circuiting COM calls for component whose key path is oleaut32.dll
const WCHAR g_szOLEAUT32W[] = L"oleaut32.dll";
const WCHAR g_szOLEAUT32_ComponentIDW[] = L"{997FA962-E067-11D1-9396-00A0C90F27F9}";
const char g_szOLEAUT32A[] = "oleaut32.dll";
const char g_szOLEAUT32_ComponentIDA[] = "{997FA962-E067-11D1-9396-00A0C90F27F9}";

#endif // !MSIUNICODE  // end of Ansi-only data and helper functions

#ifdef MSIUNICODE
#undef g_szOLEAUT32
#undef g_szOLEAUT32_ComponentID
#define g_szOLEAUT32 g_szOLEAUT32W
#define g_szOLEAUT32_ComponentID g_szOLEAUT32_ComponentIDW
#else
// constants for short circuiting COM calls for component whose key path is oleaut32.dll
#undef g_szOLEAUT32
#undef g_szOLEAUT32_ComponentID
#define g_szOLEAUT32 g_szOLEAUT32A
#define g_szOLEAUT32_ComponentID g_szOLEAUT32_ComponentIDA
#endif

//____________________________________________________________________________
//
// Helper function prototypes for those that have ANSI and MSIUNICODE version
//____________________________________________________________________________

INSTALLSTATE GetComponentClientState(const DCHAR* szUserId, const DCHAR* szProductSQUID, const DCHAR* szComponentSQUID, CAPITempBufferRef<DCHAR>& rgchComponentRegValue, DWORD& dwValueType, iaaAppAssignment* piaaAsgnType);
INSTALLSTATE GetComponentPath(LPCDSTR szUserId, LPCDSTR szProductSQUID, LPCDSTR szComponentSQUID, CAPITempBufferRef<DCHAR>& rgchPathBuf, bool fFromDescriptor, CRFSCachedSourceInfo& rCacheInfo, int iDetectMode, const DCHAR* rgchComponentRegValue, DWORD dwValueType);
INSTALLSTATE GetComponentPath (LPCDSTR szUserId, LPCDSTR szProductSQUID, LPCDSTR szComponentSQUID, LPDSTR  lpPathBuf, DWORD *pcchBuf, bool fFromDescriptor, CRFSCachedSourceInfo& rCacheInfo, int iDetectMode = DETECTMODE_VALIDATEALL, const DCHAR* rgchComponentRegValue = 0, DWORD dwValueType=0, LPDSTR lpPathBuf2=0, DWORD* pcchBuf2=0, DWORD* pdwLastErrorOnFileDetect = 0);
INSTALLSTATE _GetComponentPath(LPCDSTR szProductSQUID,LPDSTR  lpPathBuf, DWORD *pcchBuf, int iDetectMode, const DCHAR* rgchComponentRegValue, bool fFromDescriptor, DWORD* pdwLastErrorOnFileDetect, CRFSCachedSourceInfo& rCacheInfo);

//____________________________________________________________________________


DWORD GetInstalledUserDataKeySz(const ICHAR* szSID, DCHAR szUserDataKey[], DWORD cbUserDataKeySize)
{
	Assert(szUserDataKey); // pass in sufficient buffer for szKey
	if(!g_fWin9X)
	{
		// open the UserData key
		StringCbPrintf(szUserDataKey, cbUserDataKeySize, MSITEXT("%s\\%s"), szMsiUserDataKey, static_cast<const DCHAR*>(CMsInstApiConvertString(szSID)));
	}
	else
	{
		// open the Installer key
		StringCbCopy(szUserDataKey, cbUserDataKeySize, szMsiLocalInstallerKey);
	}
	return ERROR_SUCCESS;
}

// FN:GetInstalledUserDataKeyByAssignmentType
// Gets the appropriate UserData key based upon the assignment type on Win NT
// Gets the "global" location on Win9x 
DWORD GetInstalledUserDataKeySzByAssignmentType(iaaAppAssignment iaaAsgnType, DCHAR szUserDataKey[], DWORD cbUserDataKeySize)
{
	DWORD dwResult;
	if(!g_fWin9X)
	{
		// sets the appropriate HKLM\S\M\W\CV\Installer\UserData\<user id> key in szUserDataKey
		// map the assignment type to the user sid
		ICHAR szSID[cchMaxSID];
		switch(iaaAsgnType)
		{
			case iaaUserAssign:
			case iaaUserAssignNonManaged:
				dwResult = GetCurrentUserStringSID(szSID);
				if (ERROR_SUCCESS != dwResult)
					return dwResult;
				break;

			case iaaMachineAssign:
				StringCbCopyW(szSID, sizeof(szSID), szLocalSystemSID);
				break;
			case iaaNone:
				// product is not visible to the user
				//!!
				return ERROR_FILE_NOT_FOUND;
		}
		// is the sid the same as the cached one?
		return GetInstalledUserDataKeySz(szSID, szUserDataKey, cbUserDataKeySize);
	}
	else
	{
		//we put everything under the Installer key for Win9x
		switch (iaaAsgnType)
		{
			case iaaUserAssign:
			case iaaUserAssignNonManaged:
			case iaaMachineAssign:
				return GetInstalledUserDataKeySz(0, szUserDataKey, cbUserDataKeySize);
			case iaaNone:
				// product is not visible to the user
				//!!
				return ERROR_FILE_NOT_FOUND;
		}
	}
	return ERROR_SUCCESS;
}


LONG MsiRegQueryValueEx(HKEY hKey, const DCHAR* lpValueName, LPDWORD /*lpReserved*/, LPDWORD lpType, CAPITempBufferRef<DCHAR>& rgchBuf, LPDWORD lpcbBuf)
{
	DWORD cbBuf = rgchBuf.GetSize() * sizeof(DCHAR);
	LONG lResult = RegQueryValueEx(hKey, lpValueName, 0,
		lpType, (LPBYTE)&rgchBuf[0], &cbBuf);

	if (ERROR_MORE_DATA == lResult)
	{
		if (!rgchBuf.SetSize(cbBuf/sizeof(DCHAR)))
			return ERROR_OUTOFMEMORY;

		lResult = RegQueryValueEx(hKey, lpValueName, 0,
			lpType, (LPBYTE)&rgchBuf[0], &cbBuf);
	}

	if (lpcbBuf)
		*lpcbBuf = cbBuf;

	return lResult;
}

// number of locations to search for published information about a product
#define NUM_PUBLISHED_INFO_LOCATIONS 3 

// user SID May be NULL to use current users sid.
DWORD OpenSpecificUsersAdvertisedSubKeyPacked(enum iaaAppAssignment iaaAsgnType, const DCHAR* szUserSID, const DCHAR* szItemSubKey, const DCHAR* szItemSQUID, CRegHandle &riHandle, bool fSetKeyString)
{
	DWORD dwResult = ERROR_FILE_NOT_FOUND;
	HKEY hRoot = 0;
	CAPITempBuffer<DCHAR, 1> rgchSubKey;
	ICHAR szSID[cchMaxSID];

	if (!rgchSubKey.SetSize(MAX_PATH))
		return ERROR_OUTOFMEMORY;

	switch (iaaAsgnType)
	{
		case iaaUserAssign:
			if(!g_fWin9X)
			{
				if (GetIntegerPolicyValue(szDisableUserInstallsValueName, fTrue))// ignore user installs 
					return dwResult; // return ERROR_FILE_NOT_FOUND

				hRoot = HKEY_LOCAL_MACHINE;
				if (FAILED(StringCchCopy(rgchSubKey, rgchSubKey.GetSize(), szManagedUserSubKey)) ||
					FAILED(StringCchCat(rgchSubKey, rgchSubKey.GetSize(), MSITEXT("\\"))))
					return ERROR_FUNCTION_FAILED;

				if (!szUserSID)
				{
					CImpersonate impersonate(fTrue); 
					DWORD dwError = GetCurrentUserStringSID(szSID);
					if (ERROR_SUCCESS != dwError)
						return dwError;
					if (FAILED(StringCchCat(rgchSubKey, rgchSubKey.GetSize(), CMsInstApiConvertString(szSID))))
						return ERROR_FUNCTION_FAILED;
				}
				else
				{
					if (FAILED(StringCchCat(rgchSubKey, rgchSubKey.GetSize(), szUserSID)))
						return ERROR_FUNCTION_FAILED;
				}
					
				if (FAILED(StringCchCat(rgchSubKey, rgchSubKey.GetSize(), MSITEXT("\\"))) ||
					FAILED(StringCchCat(rgchSubKey, rgchSubKey.GetSize(), MSITEXT("Installer"))))
					return ERROR_FUNCTION_FAILED;
			}
			break;
		case iaaUserAssignNonManaged:
			if (g_fWin9X)
			{
				hRoot = HKEY_CURRENT_USER;
				rgchSubKey[0] = 0;
			}
			else
			{
				Assert(!szUserSID);

				if (GetIntegerPolicyValue(szDisableUserInstallsValueName, fTrue))// ignore user installs 
					return dwResult; // return ERROR_FILE_NOT_FOUND
				
				CImpersonate impersonate(fTrue);
				DWORD dwError = GetCurrentUserStringSID(szSID);
				if (ERROR_SUCCESS != dwError)
						return dwError;

				if (FAILED(StringCchCopy(rgchSubKey, rgchSubKey.GetSize(), CMsInstApiConvertString(szSID))) ||
					FAILED(StringCchCat(rgchSubKey, rgchSubKey.GetSize(), MSITEXT("\\"))))
					return ERROR_FUNCTION_FAILED;

				hRoot = HKEY_USERS;
			}
			if (FAILED(StringCchCat(rgchSubKey, rgchSubKey.GetSize(), szNonManagedUserSubKey)))
				return ERROR_FUNCTION_FAILED;
			break;
		case iaaMachineAssign:
			if (FAILED(StringCchCopy(rgchSubKey, rgchSubKey.GetSize(), szMachineSubKey)))
				return ERROR_FUNCTION_FAILED;
			hRoot = HKEY_LOCAL_MACHINE;
			break;
		default:
			Assert(0);
			return dwResult;
		}

		if(!g_fWin9X || (iaaAsgnType != iaaUserAssign))
		{
			if (!szItemSubKey)
			{
				Assert(0);
				return ERROR_INVALID_PARAMETER;
			}
								  
			if (FAILED(StringCchCat(rgchSubKey, rgchSubKey.GetSize(), MSITEXT("\\"))) ||
				FAILED(StringCchCat(rgchSubKey, rgchSubKey.GetSize(), szItemSubKey)))
				return ERROR_FUNCTION_FAILED;

			if (szItemSQUID)
			{
				// we use this arg to pass in assembly contexts which can be long if parent assembly installed
				// to deep folder, hence we use a dynamic buffer to resize appropriately
				if (!rgchSubKey.Resize(lstrlen(rgchSubKey) + lstrlen(szItemSQUID) + 2)) // resize buffer for potential deeply installed pvt assemblies
					return ERROR_OUTOFMEMORY;

				if (FAILED(StringCchCat(rgchSubKey, rgchSubKey.GetSize(), MSITEXT("\\"))) ||
					FAILED(StringCchCat(rgchSubKey, rgchSubKey.GetSize(), szItemSQUID)))
					return ERROR_FUNCTION_FAILED;
			}

			CACHED_CONVERTSTRING(ICHAR, szUnicodeSubKey, rgchSubKey);
			dwResult = MsiRegOpen64bitKey(hRoot, szUnicodeSubKey, 0, g_samRead, &riHandle);
			if (ERROR_SUCCESS == dwResult)
			{
				if (fSetKeyString)
					riHandle.SetKey(hRoot, szUnicodeSubKey);
				return ERROR_SUCCESS;
			}
		}
	return dwResult;
}


DWORD OpenAdvertisedSubKeyNonGUID(const DCHAR* szItemSubKey, const DCHAR* szItemSQUID, CRegHandle &riHandle, bool fSetKeyString, int iKey = -1, iaaAppAssignment* piRet = 0)
{

	DWORD dwResult = ERROR_FILE_NOT_FOUND;

	// 0: Check per-user managed key
	// 1: Check per-user non-managed key
	// 2: Check per-machine key
	
	CRegHandle HMergedKey; //!! TEMP legacy
	int c;

	if (iKey == -1)
		c = 0;
	else
		c = iKey;

	const int iProductLocations = NUM_PUBLISHED_INFO_LOCATIONS;

	for (; c < iProductLocations; c++)
	{
		iaaAppAssignment iaaAsgnType;
		switch(c)
		{
		case 0 : iaaAsgnType = iaaUserAssign; break;
		case 1 : iaaAsgnType = iaaUserAssignNonManaged; break;
		case 2 : iaaAsgnType = iaaMachineAssign; break;
		default: 
			AssertSz(0, TEXT("Bad Type in OpenAdvertisedSubKeyPacked"));
			return dwResult;
		}

		dwResult = OpenSpecificUsersAdvertisedSubKeyPacked(iaaAsgnType, NULL, szItemSubKey, szItemSQUID, riHandle, fSetKeyString);
		if (ERROR_SUCCESS == dwResult)
		{
			if(piRet)
				*piRet = (iaaAppAssignment)c;
			break;
		}
		if (iKey != -1)
			break;
		
	}

	if (iKey > (iProductLocations - 1))
		return ERROR_NO_MORE_ITEMS;

	return dwResult;
}

DWORD OpenAdvertisedSubKeyPacked(const DCHAR* szItemSubKey, const DCHAR* szItemSQUID, CRegHandle &riHandle, bool fSetKeyString, int iKey = -1, iaaAppAssignment* piRet = 0)
{
	if ( szItemSQUID && (lstrlen(szItemSQUID) != cchGUIDPacked) )
	{
		Assert(0);
		return ERROR_INVALID_PARAMETER;
	}

	return OpenAdvertisedSubKeyNonGUID(szItemSubKey, szItemSQUID, riHandle, fSetKeyString, iKey, piRet);
}

DWORD OpenAdvertisedSubKey(const DCHAR* szSubKey, const DCHAR* szItemGUID, CRegHandle& riHandle, bool fSetKeyString, int iKey = -1, iaaAppAssignment* piRet = 0)
//----------------------------------------------------------------------------
{
	// look up component in GPTComponents
	//!! TEMP
	// currently we look up the HKCU\\SID_Merged_Classes key
	// if absent, then we look up under the HKCR key
	// the NT folks (adam edwards) hope to combine the 2 soon
	// so that we can lool up only under the HKCR key

	DCHAR szItemSQUID[cchGUIDPacked + 1];

	if(!szItemGUID || lstrlen(szItemGUID) != cchGUID || !PackGUID(szItemGUID, szItemSQUID))
		return ERROR_INVALID_PARAMETER;

	return OpenAdvertisedSubKeyPacked(szSubKey, szItemSQUID, riHandle, fSetKeyString, iKey, piRet);
}

#define OpenAdvertisedComponentKey(componentGUID, phKey, fSetKeyString) \
 OpenAdvertisedSubKey(szGPTComponentsKey, componentGUID, phKey, fSetKeyString)
#define OpenAdvertisedFeatureKey(productGUID, phKey, fSetKeyString) \
 OpenAdvertisedSubKey(szGPTFeaturesKey, productGUID, phKey, fSetKeyString)


#define OpenAdvertisedProductsKeyPacked(uiKey, phKey, fSetKeyString) \
 OpenAdvertisedSubKeyPacked(szGPTProductsKey, 0, phKey, fSetKeyString, uiKey)

DWORD OpenAdvertisedUpgradeCodeKey(int iKey, LPCDSTR szUpgradeCode, CRegHandle &riHandle, bool fSetKeyString)
{
	return OpenAdvertisedSubKey(szGPTUpgradeCodesKey, szUpgradeCode, riHandle, fSetKeyString, iKey);
}

#ifndef DEBUG
inline
#endif
DWORD OpenAdvertisedProductKeyPacked(LPCDSTR szProductSQUID, CRegHandle &riHandle, bool fSetKeyString, int iKey = -1, iaaAppAssignment* piRet = 0)
{
	if ( !szProductSQUID || lstrlen(szProductSQUID) != cchProductCodePacked)
	{
		Assert(0);
		return ERROR_INVALID_PARAMETER;
	}


	CProductContextCache cpc(static_cast<const ICHAR*>(CMsInstApiConvertString(szProductSQUID)));
	// use temp var. to get the assignment context, if not passed into fn.
	iaaAppAssignment iaaType;
	if(!piRet)
		piRet = &iaaType;

	// if previously cached context
	int iKeyPrev = -1;
	bool fCached = cpc.GetProductContext((iaaAppAssignment&)iKeyPrev);
	if(fCached) // previous product context cached
	{
		Assert(iKey == -1 || iKey == iKeyPrev);
		iKey = iKeyPrev;
	}
	
	DWORD dwRet =  OpenAdvertisedSubKeyPacked(szGPTProductsKey, szProductSQUID, riHandle, fSetKeyString, iKey, piRet);

	// if not already cached, set the cached context
	if(dwRet == ERROR_SUCCESS && !fCached)
	{
		cpc.SetProductContext(*piRet);
	}

	return dwRet;
}

DWORD OpenAdvertisedProductKey(LPCDSTR szProductGUID, CRegHandle &riHandle, bool fSetKeyString, iaaAppAssignment* piRet = 0)
{
	DCHAR szProductSQUID[cchProductCodePacked + 1];

	if(!szProductGUID || lstrlen(szProductGUID) != cchProductCode || !PackGUID(szProductGUID, szProductSQUID))
		return ERROR_INVALID_PARAMETER;

	// use OpenAdvertisedProductKeyPacked fn rather than OpenAdvertisedSubKey, to allow for use of the product context caching
	return OpenAdvertisedProductKeyPacked(szProductSQUID, riHandle, fSetKeyString, -1, piRet);
}

DWORD OpenAdvertisedPatchKey(LPCDSTR szPatchGUID, CRegHandle &riHandle, bool fSetKeyString)
{
	return OpenAdvertisedSubKey(szGPTPatchesKey, szPatchGUID, riHandle, fSetKeyString);
}


// FN:get the "visible" product assignment type
DWORD GetProductAssignmentType(const DCHAR* szProductSQUID, iaaAppAssignment& riType, CRegHandle& riKey)
{
	DWORD dwResult = OpenAdvertisedProductKeyPacked(szProductSQUID, riKey, false, -1, &riType);
	if(dwResult == ERROR_NO_MORE_ITEMS)
	{
		// assignment type none
		riType = iaaNone;
		return ERROR_SUCCESS; 
	}
	return dwResult;
}

// FN:get the "visible" product assignment type
DWORD GetProductAssignmentType(const DCHAR* szProductSQUID, iaaAppAssignment& riType)
{
	CRegHandle hKey;
	return GetProductAssignmentType(szProductSQUID, riType, hKey);
}



// 
// FN: Gets the appropriate UserData key based upon the assignment type on Win NT
// by figuring out the "visibility" of the product
DWORD GetInstalledUserDataKeySzByProduct(const DCHAR* szProductSQUID, DCHAR szUserDataKey[], DWORD cbUserDataKeySize, int iKey = -1, iaaAppAssignment* piaaAssign = 0)
{
	iaaAppAssignment iaaAsgnType;
	if ( iKey == -1 || !IsValidAssignmentValue(iKey) )
	{
		DWORD dwResult;
		dwResult = GetProductAssignmentType(szProductSQUID, iaaAsgnType);
		if(ERROR_SUCCESS != dwResult)
			return dwResult;
		else if ( piaaAssign )
			*piaaAssign = iaaAsgnType;
	}
	else
		iaaAsgnType = (iaaAppAssignment)iKey;
	return GetInstalledUserDataKeySzByAssignmentType(iaaAsgnType, szUserDataKey, cbUserDataKeySize);
}


DWORD OpenInstalledUserDataSubKeyPacked(LPCDSTR szUserId, LPCDSTR szProductSQUID, LPCDSTR szSubKey, CRegHandle& rhKey, bool fSetKeyString, REGSAM RegSam, int iKey = -1, iaaAppAssignment* piaaAssign = 0)
{
	DWORD dwResult;
	DCHAR szUserDataKey[cchMaxSID + cchMsiUserDataKey + 1];
	// open the appropriate userdata key
	if(szUserId) // required UserData key already passed in
		dwResult = GetInstalledUserDataKeySz(CMsInstApiConvertString(szUserId), szUserDataKey, sizeof(szUserDataKey));
	else
		dwResult = GetInstalledUserDataKeySzByProduct(szProductSQUID, szUserDataKey, sizeof(szUserDataKey), iKey, piaaAssign);
	if(ERROR_SUCCESS != dwResult)
		return dwResult;

	CAPITempBuffer<DCHAR,1> szKey;
	if (!szKey.SetSize(1024))
		return ERROR_OUTOFMEMORY;
	
	StringCchPrintf(szKey, szKey.GetSize(), MSITEXT("%s\\%s"), szUserDataKey, szSubKey);
	CACHED_CONVERTSTRING(ICHAR, szUnicodeKey, szKey);
	if( (RegSam & KEY_READ) && !(RegSam & (KEY_SET_VALUE|KEY_CREATE_SUB_KEY)))
		 dwResult = MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE, szUnicodeKey, 0, RegSam, &rhKey);
	else
		dwResult = MsiRegCreate64bitKey(HKEY_LOCAL_MACHINE, szUnicodeKey,  0, 0, 0, RegSam, 0, &rhKey, 0);

	if (ERROR_SUCCESS == dwResult)
	{
		if(fSetKeyString)
			rhKey.SetKey(HKEY_LOCAL_MACHINE, CMsInstApiConvertString(szSubKey));
	}
	return dwResult;
}

inline DWORD OpenInstalledComponentKeyPacked(LPCDSTR szUserId, LPCDSTR szProductSQUID, LPCDSTR szComponentSQUID, CRegHandle& rhKey, bool fSetKeyString)
{
	// generate the appr, components subkey
	CAPITempBuffer<DCHAR, 1> rgchSubKey;
	if (!rgchSubKey.SetSize(MAX_PATH))
		return ERROR_OUTOFMEMORY;
	if (FAILED(StringCchPrintf(rgchSubKey, rgchSubKey.GetSize(), MSITEXT("%s\\%s"), szMsiComponentsSubKey, szComponentSQUID)))
		return ERROR_FUNCTION_FAILED;
	return OpenInstalledUserDataSubKeyPacked(szUserId, szProductSQUID, rgchSubKey, rhKey, fSetKeyString, g_samRead);
}

inline DWORD OpenInstalledComponentKey(LPCDSTR szUserId, LPCDSTR szProduct, LPCDSTR szComponent, CRegHandle& rhKey, bool fSetKeyString)
{
	// first convert the params to the corr. SQUIDs
	DCHAR szProductSQUID[cchGUIDPacked + 1];
	DCHAR szComponentSQUID[cchGUIDPacked + 1];

	if(!szProduct || lstrlen(szProduct) != cchGUID || !PackGUID(szProduct, szProductSQUID))
		return ERROR_INVALID_PARAMETER;

	if(!szComponent || lstrlen(szComponent) != cchGUID || !PackGUID(szComponent, szComponentSQUID))
		return ERROR_INVALID_PARAMETER;

	return OpenInstalledComponentKeyPacked(szUserId, szProductSQUID, szComponentSQUID, rhKey, fSetKeyString);
}

// FN: opens specific HKLM\S\M\W\CV\Installer\UserData\<user id>\Components\<szComponentSQUID> components key 
// if szComponentSQUID is null, opens specific HKLM\S\M\W\CV\Installer\UserData\<user id>\Components key
inline DWORD OpenSpecificInstalledComponentKey(iaaAppAssignment iaaAsgnType, LPCDSTR szComponentSQUID, CRegHandle& rhKey, bool fSetKeyString)
{
	// generate the appr, components subkey
	DWORD dwResult;
	DCHAR szUserDataKey[cchMaxSID + cchMsiUserDataKey + 1];
	CAPITempBuffer<DCHAR,1> rgchSubKey;
	if (!rgchSubKey.SetSize(1024))
		return ERROR_OUTOFMEMORY;
	dwResult = GetInstalledUserDataKeySzByAssignmentType(iaaAsgnType, szUserDataKey, sizeof(szUserDataKey));
	if(ERROR_SUCCESS != dwResult)
		return dwResult;

	if(szComponentSQUID)
	{
		dwResult = StringCchPrintf(rgchSubKey, rgchSubKey.GetSize(), MSITEXT("%s\\%s\\%s"), szUserDataKey, szMsiComponentsSubKey, szComponentSQUID);
	}
	else
	{
		dwResult = StringCchPrintf(rgchSubKey, rgchSubKey.GetSize(), MSITEXT("%s\\%s"), szUserDataKey, szMsiComponentsSubKey);
	}
	if (FAILED(dwResult))
		return ERROR_FUNCTION_FAILED;

	CACHED_CONVERTSTRING(ICHAR, szSubKey, rgchSubKey);
	dwResult = MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE, szSubKey, 0, g_samRead, &rhKey);
	if (ERROR_SUCCESS == dwResult)
	{
		if(fSetKeyString)
			rhKey.SetKey(HKEY_LOCAL_MACHINE, szSubKey);
	}
	return dwResult;
}

#ifndef DEBUG
inline
#endif
DWORD OpenInstalledFeatureKeyPacked(LPCDSTR szProductSQUID, CRegHandle& rhKey, bool fSetKeyString, int iKey = -1, iaaAppAssignment* piaaAssign = 0)
{
	// generate the appr, subkey
	CAPITempBuffer<DCHAR, 1> rgchSubKey;
	if (!rgchSubKey.SetSize(MAX_PATH))
		return ERROR_OUTOFMEMORY;
	if (FAILED(StringCchPrintf(rgchSubKey, rgchSubKey.GetSize(), MSITEXT("%s\\%s\\%s"), szMsiProductsSubKey, szProductSQUID, szMsiFeaturesSubKey)))
		return ERROR_FUNCTION_FAILED;
	return OpenInstalledUserDataSubKeyPacked(0, szProductSQUID, rgchSubKey, rhKey, fSetKeyString, g_samRead, iKey, piaaAssign);
}

DWORD OpenInstalledFeatureKey(LPCDSTR szProduct, CRegHandle& rhKey, bool fSetKeyString)
{
	DCHAR szProductSQUID[cchGUIDPacked + 1];
	if(!szProduct || lstrlen(szProduct) != cchGUID || !PackGUID(szProduct, szProductSQUID))
		return ERROR_INVALID_PARAMETER;
	return OpenInstalledFeatureKeyPacked(szProductSQUID, rhKey, fSetKeyString);
}

inline DWORD OpenInstalledFeatureUsageKeyPacked(LPCDSTR szProductSQUID, CRegHandle& rhKey, bool fSetKeyString, REGSAM RegSam)
{
	// generate the appr, subkey
	CAPITempBuffer<DCHAR, 1> rgchSubKey;
	if (!rgchSubKey.SetSize(MAX_PATH))
		return ERROR_OUTOFMEMORY;
	if (FAILED(StringCchPrintf(rgchSubKey, rgchSubKey.GetSize(), MSITEXT("%s\\%s\\%s"), szMsiProductsSubKey, szProductSQUID, szMsiFeatureUsageSubKey)))
		return ERROR_FUNCTION_FAILED;
	return OpenInstalledUserDataSubKeyPacked(0, szProductSQUID, rgchSubKey, rhKey, fSetKeyString, RegSam);
}

inline DWORD OpenInstalledFeatureUsageKey(LPCDSTR szProduct, CRegHandle& rhKey, bool fSetKeyString, REGSAM RegSam)
{
	DCHAR szProductSQUID[cchGUIDPacked + 1];
	if(!szProduct || lstrlen(szProduct) != cchGUID || !PackGUID(szProduct, szProductSQUID))
		return ERROR_INVALID_PARAMETER;
	return OpenInstalledFeatureUsageKeyPacked(szProductSQUID, rhKey, fSetKeyString, RegSam);
}

DWORD OpenInstalledProductInstallPropertiesKey(LPCDSTR szProduct, CRegHandle& rhKey, bool fSetKeyString);

inline DWORD OpenInstalledProductInstallPropertiesKeyPacked(LPCDSTR szProductSQUID, CRegHandle& rhKey, bool fSetKeyString)
{
	// generate the appr, InstallProperties subkey
	if(!g_fWin9X)
	{
		CAPITempBuffer<DCHAR, 1> rgchSubKey;
		if (!rgchSubKey.SetSize(MAX_PATH))
			return ERROR_OUTOFMEMORY;
		if (FAILED(StringCchPrintf(rgchSubKey, rgchSubKey.GetSize(), MSITEXT("%s\\%s\\%s"), szMsiProductsSubKey, szProductSQUID, szMsiInstallPropertiesSubKey)))
			return ERROR_FUNCTION_FAILED;
		return OpenInstalledUserDataSubKeyPacked(0, szProductSQUID, rgchSubKey, rhKey, fSetKeyString, g_samRead);
	}
	else
	{
		// first convert the params to the corr. GUIDs
		DCHAR szProductId[cchGUID+1] = {0};
		if ( !UnpackGUID(szProductSQUID, szProductId, ipgPacked) )
			return ERROR_INVALID_PARAMETER;
		return OpenInstalledProductInstallPropertiesKey(szProductId, rhKey, fSetKeyString);
	}
}


inline DWORD OpenInstalledProductInstallPropertiesKey(LPCDSTR szProduct, CRegHandle& rhKey, bool fSetKeyString)
{
	// first convert the params to the corr. SQUIDs
	DCHAR szProductSQUID[cchGUIDPacked + 1];

	if(!szProduct || lstrlen(szProduct) != cchGUID || !PackGUID(szProduct, szProductSQUID))
		return ERROR_INVALID_PARAMETER;

	return OpenInstalledProductInstallPropertiesKeyPacked(szProductSQUID, rhKey, fSetKeyString);
}

DWORD OpenInstalledProductTransformsKey(LPCDSTR szProduct, CRegHandle& rhKey, bool fSetKeyString)
{
	// first convert the params to the corr. SQUIDs
	DCHAR szProductSQUID[cchGUIDPacked + 1];

	if(!szProduct || lstrlen(szProduct) != cchGUID || !PackGUID(szProduct, szProductSQUID))
		return ERROR_INVALID_PARAMETER;

	// generate the appr, InstallProperties subkey
	CAPITempBuffer<DCHAR, 1> rgchSubKey;
	if (!rgchSubKey.SetSize(MAX_PATH))
		return ERROR_OUTOFMEMORY;
	if (FAILED(StringCchPrintf(rgchSubKey, rgchSubKey.GetSize(), MSITEXT("%s\\%s\\%s"), szMsiProductsSubKey, szProductSQUID, szMsiTransformsSubKey)))
		return ERROR_FUNCTION_FAILED;
	return OpenInstalledUserDataSubKeyPacked(0, szProductSQUID, rgchSubKey, rhKey, fSetKeyString, g_samRead);
}

#define OpenAdvertisedComponentKeyPacked(componentSQUID, phKey, fSetKeyString) \
 OpenAdvertisedSubKeyPacked(szGPTComponentsKey, componentSQUID, phKey, fSetKeyString)

#ifndef DEBUG
inline
#endif
DWORD OpenAdvertisedFeatureKeyPacked(LPCDSTR productSQUID, CRegHandle& phKey, bool fSetKeyString, int iKey = -1, iaaAppAssignment* piaaAssign = 0)
{
	return OpenAdvertisedSubKeyPacked(szGPTFeaturesKey, productSQUID, phKey, fSetKeyString, iKey, piaaAssign);
}


#define OpenAdvertisedPatchKeyPacked(patchSQUID, phKey, fSetKeyString) \
 OpenAdvertisedSubKeyPacked(szGPTPatchesKey, patchSQUID, phKey, fSetKeyString)

#define OpenAdvertisedPackageKey(package, phKey, fSetKeyString) \
 OpenAdvertisedSubKey(szGPTPackagesKey, package, phKey, fSetKeyString)


DWORD OpenSpecificUsersAdvertisedProductKeyPacked(enum iaaAppAssignment iaaAsgnType, LPCDSTR szUserSID, LPCDSTR szProductSQUID, CRegHandle &riHandle, bool fSetKeyString)
{
	return OpenSpecificUsersAdvertisedSubKeyPacked(iaaAsgnType, szUserSID, szGPTProductsKey, szProductSQUID, riHandle, fSetKeyString);
}

inline DWORD OpenInstalledPatchKeyPackedByAssignmentType(const DCHAR* szPatchSQUID, iaaAppAssignment iaaAsgnType, CRegHandle& riHandle, bool fSetKeyString)
{
	DCHAR szUserDataKey[cchMaxSID + cchMsiUserDataKey + 1];
	DWORD dwResult = GetInstalledUserDataKeySzByAssignmentType(iaaAsgnType, szUserDataKey, sizeof(szUserDataKey));
	if(ERROR_SUCCESS == dwResult)
	{
		CAPITempBuffer<DCHAR,1> rgchItemKey;
		if (!rgchItemKey.SetSize(1024))
			return ERROR_OUTOFMEMORY;
		if (FAILED(StringCchPrintf(rgchItemKey, rgchItemKey.GetSize(), MSITEXT("%s\\%s\\%s"), szUserDataKey, szPatchesSubKey, szPatchSQUID)))
			return ERROR_FUNCTION_FAILED;
		CACHED_CONVERTSTRING(ICHAR, szItemKey, rgchItemKey);
		dwResult = MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE, szItemKey, 0, g_samRead, &riHandle);
		if (ERROR_SUCCESS == dwResult && fSetKeyString)
			riHandle.SetSubKey(szItemKey);
	}
	return dwResult;
}

inline DWORD OpenInstalledPatchKeyPacked(const DCHAR* szPatchSQUID, const DCHAR* szProductSQUID, CRegHandle& riHandle, bool fSetKeyString)
{
	if ( !szPatchSQUID || (lstrlen(szPatchSQUID) != cchPatchCodePacked) )
	{
		Assert(0);
		return ERROR_INVALID_PARAMETER;
	}

	DWORD dwResult;
	if(!szProductSQUID)
	{
		// no product asssociation mentioned: first try user assignments then try machine assignments
		dwResult = OpenInstalledPatchKeyPackedByAssignmentType(szPatchSQUID, iaaUserAssign, riHandle, fSetKeyString);
		if(ERROR_SUCCESS != dwResult)
			dwResult = OpenInstalledPatchKeyPackedByAssignmentType(szPatchSQUID, iaaMachineAssign, riHandle, fSetKeyString);
	}
	else
	{
		iaaAppAssignment iaaType;
		dwResult = GetProductAssignmentType(szProductSQUID, iaaType);
		if(ERROR_SUCCESS == dwResult)
			dwResult = OpenInstalledPatchKeyPackedByAssignmentType(szPatchSQUID, iaaType, riHandle, fSetKeyString);
	}
	return dwResult;
}

DWORD OpenInstalledPatchKey(const DCHAR* szPatchGUID, const DCHAR* szProductGUID, CRegHandle &riHandle, bool fSetKeyString)
//----------------------------------------------------------------------------
{
	DCHAR szPatchSQUID[cchPatchCodePacked + 1];
	DCHAR szProductSQUID[cchProductCodePacked + 1];

	if(!szPatchGUID || lstrlen(szPatchGUID) != cchPatchCode || !PackGUID(szPatchGUID, szPatchSQUID))
		return ERROR_INVALID_PARAMETER;
	if(szProductGUID && (lstrlen(szProductGUID) != cchProductCode || !PackGUID(szProductGUID, szProductSQUID)))
		return ERROR_INVALID_PARAMETER;

	return OpenInstalledPatchKeyPacked(szPatchSQUID, szProductGUID ? szProductSQUID : 0, riHandle, fSetKeyString);
}

LONG MsiRegEnumValue(HKEY hKey, DWORD dwIndex, CAPITempBufferRef<DCHAR>& rgchValueNameBuf, LPDWORD lpcbValueName, LPDWORD lpReserved,
							LPDWORD lpType, CAPITempBufferRef<DCHAR>& rgchValueBuf, LPDWORD lpcbValue)
{
	DWORD cbValueBuf     = rgchValueBuf.GetSize()*sizeof(DCHAR);
	DWORD cbValueNameBuf = rgchValueNameBuf.GetSize()*sizeof(DCHAR);
	DWORD lResult;

	lResult = RegEnumValue(hKey, dwIndex, (DCHAR*)rgchValueNameBuf,
							  &cbValueNameBuf, lpReserved, lpType, (LPBYTE)(DCHAR*)rgchValueBuf, &cbValueBuf);

	if (ERROR_MORE_DATA == lResult)
	{
		if (ERROR_SUCCESS == RegQueryInfoKey (hKey, 0, 0, 0, 0, 0,
			0, 0, &cbValueNameBuf, &cbValueBuf, 0, 0))
		{
			rgchValueBuf.SetSize(cbValueBuf/sizeof(DCHAR));
			rgchValueNameBuf.SetSize(cbValueNameBuf/sizeof(DCHAR));
			lResult = RegEnumValue(hKey, dwIndex, (DCHAR*)rgchValueNameBuf,
							  &cbValueNameBuf, lpReserved, lpType, (LPBYTE)(DCHAR*)rgchValueBuf, &cbValueBuf);
		}
	}

	if (lpcbValue)
		*lpcbValue = cbValueBuf;

	if (lpcbValueName)
		*lpcbValueName = cbValueNameBuf;

	return lResult;
}

void ResolveComponentPathForLogging(CAPITempBufferRef<DCHAR>& rgchPathBuf)
{
	DCHAR chFirst  = rgchPathBuf[0];
	DCHAR chSecond = chFirst ?  rgchPathBuf[1] : (DCHAR)0;
	DCHAR chThird  = chSecond ? rgchPathBuf[2] : (DCHAR)0;

	if (chFirst == 0)
	{
		return;
	}
	else if (chFirst >= '0' && chFirst <= '9')
	{
		if (chSecond >= '0' && chSecond <= '9') 
		{
			int cchPath    = lstrlen((DCHAR*)rgchPathBuf)+1;
			if (chThird == ':')                   // reg key
			{
				if(chFirst != '0' && chFirst != '2')
					return; // unknown root
				
				const DCHAR* szRoot = 0;
				// need to substitute first 3 chars with a string representation of the root
				switch(chSecond)
				{
				case '0':
					if(chFirst == '2')
						szRoot = MSITEXT("HKEY_CLASSES_ROOT(64)");
					else
						szRoot = MSITEXT("HKEY_CLASSES_ROOT");
					break;
				case '1':
					if(chFirst == '2')
						szRoot = MSITEXT("HKEY_CURRENT_USER(64)");
					else
						szRoot = MSITEXT("HKEY_CURRENT_USER");
					break;
				case '2':
					if(chFirst == '2')
						szRoot = MSITEXT("HKEY_LOCAL_MACHINE(64)");
					else
						szRoot = MSITEXT("HKEY_LOCAL_MACHINE");
					break;
				case '3':
					if(chFirst == '2')
						szRoot = MSITEXT("HKEY_USERS(64)");
					else
						szRoot = MSITEXT("HKEY_USERS");
					break;
				default:
					return; // unknown root
				};

				Assert(szRoot);

				int cchRoot    = lstrlen(szRoot);

				rgchPathBuf.Resize(cchPath + cchRoot - 3); // assumes szRoot longer than 3

				if(rgchPathBuf.GetSize() >= cchPath + cchRoot - 3) // make sure re-size worked
				{
					memmove(((BYTE*)(DCHAR*)rgchPathBuf) + (cchRoot*sizeof(DCHAR)), ((BYTE*)(DCHAR*)rgchPathBuf) + (3*sizeof(DCHAR)), (cchPath - 3)*sizeof(DCHAR));
					memcpy((BYTE*)(DCHAR*)rgchPathBuf, szRoot, cchRoot*sizeof(DCHAR));
				}
			}
			else                                  // rfs file/folder
			{
				// need to remove first 2 chars (won't put in full sourcepath)
				// this move includes the null terminator
				memmove((BYTE*)(DCHAR*)rgchPathBuf, ((BYTE*)(DCHAR*)rgchPathBuf) + (2*sizeof(DCHAR)), (cchPath - 2)*sizeof(DCHAR));
			}
		}
	}

	// otherwise, bad config or a local file/folder that doesn't need fixup

}


INSTALLSTATE QueryFeatureStatePacked(const DCHAR* szProductSQUID, const DCHAR* szFeature, BOOL fLocateComponents, bool fFromDescriptor, CRFSCachedSourceInfo& rCacheInfo,
												 int iKey = -1, iaaAppAssignment* piaaAssign = 0)
{
	size_t cchProduct = 0;
	if ( !szProductSQUID || !szFeature ||
		  FAILED(StringCchLength(szProductSQUID, cchProductCodePacked+1, &cchProduct)) ||
		  cchProduct != cchProductCodePacked )
		return INSTALLSTATE_INVALIDARG;

	INSTALLSTATE is = INSTALLSTATE_LOCAL;
		
	// cache conversion to unicode in ANSI calls to prevent excessive temporary objects
	CACHED_CONVERTSTRING(ICHAR, szUnicodeProductSQUID, szProductSQUID);
	CACHED_CONVERTSTRING(ICHAR, szUnicodeFeature, szFeature);

	if ( !IsValidAssignmentValue(iKey) && iKey != -1 )
	{
		Assert(0);
		iKey = -1;
	}
	// to handle properly the case where it has been called w/ piaaAssign = 0;
	iaaAppAssignment iaaTemp = iaaNone;

	CRegHandle HProductKey;
//!! need to avoid opening advertised info when called internally
	LONG lError = OpenAdvertisedFeatureKeyPacked(szProductSQUID, HProductKey, false, iKey, &iaaTemp);

	if (ERROR_SUCCESS != lError)
	{
		return INSTALLSTATE_UNKNOWN;
	}
	else
	{
		if ( IsValidAssignmentValue(iaaTemp) )
		{
			if ( piaaAssign )
				*piaaAssign = iaaTemp;
			if ( iKey == -1 )
				iKey = iaaTemp;
		}
		else
			Assert(0);
	}

	// following code added to look first in per-user registration, followed by machine registration
	DCHAR rgchTemp[MAX_FEATURE_CHARS + 16];
	DWORD cbTemp = sizeof(rgchTemp);
	if (ERROR_SUCCESS != RegQueryValueEx(HProductKey, szFeature, 0, 0, (BYTE*)rgchTemp, &cbTemp))
	{
		return INSTALLSTATE_UNKNOWN;
	}
	
	if (*rgchTemp == chAbsentToken)  // was the feature set to absent?
	{
		return INSTALLSTATE_ABSENT;
	}

	lError = OpenInstalledFeatureKeyPacked(szProductSQUID, HProductKey, false, iKey/*, piaaAssign*/);
	if (ERROR_SUCCESS != lError)
	{
		return INSTALLSTATE_ADVERTISED;
	}
	// end of added code to support machine registration of feature-component mapping

	// Get Feature-Component mapping. MsiRegQueryValueEx will resize buffer as needed.
	DWORD dwType;
	CAPITempBuffer<DCHAR, 1> szComponentList;
	lError = MsiRegQueryValueEx(HProductKey, szFeature, 0, &dwType,
		szComponentList, 0);
	
	if (ERROR_SUCCESS != lError)
	{
		return INSTALLSTATE_ADVERTISED; // in case transform adds a feature
	}
	int cchCompId = cchComponentIdCompressed;

	DCHAR *pchComponentList = szComponentList;

	// For each component in the feature get the client state
	DCHAR *pchBeginComponentId;
	int cComponents = 0;
	BOOL fSourceAbsent = FALSE;

	pchBeginComponentId = pchComponentList;
	int cchComponentListLen = lstrlen(pchBeginComponentId);

	while (*pchBeginComponentId != 0 && !fSourceAbsent)
	{
		if (*pchBeginComponentId == chFeatureIdTerminator)
		{
			// we've found a parent feature name

			int cchFeatureName = lstrlen(pchBeginComponentId+1);
			if (cchFeatureName > cchMaxFeatureName)
				return INSTALLSTATE_BADCONFIG;

			DCHAR szParentFeature[cchMaxFeatureName + 1];
			memcpy(szParentFeature, pchBeginComponentId+1, cchFeatureName*sizeof(DCHAR));
			szParentFeature[cchFeatureName] = 0;

			INSTALLSTATE isParent = QueryFeatureStatePacked(szProductSQUID, szParentFeature, fLocateComponents, fFromDescriptor, rCacheInfo, iKey/*, piaaAssign*/);
			switch (isParent)
			{
			case INSTALLSTATE_ADVERTISED:
			case INSTALLSTATE_ABSENT:
			case INSTALLSTATE_BROKEN:
			case INSTALLSTATE_SOURCEABSENT:
				is = isParent;
				break;
			case INSTALLSTATE_LOCAL:
				break;
			case INSTALLSTATE_SOURCE:
				is = fSourceAbsent ? INSTALLSTATE_SOURCEABSENT : INSTALLSTATE_SOURCE;
				break;
			default:
				AssertSz(0, "Unexpected return from QueryFeatureState");
				is = INSTALLSTATE_UNKNOWN;
				break;
			}
			return is;
		}
		else
		{
			if(cchComponentListLen < cchCompId)
				return INSTALLSTATE_BADCONFIG;

			DCHAR szComponentIdSQUID[cchComponentIdPacked+1];
			if (cchCompId == cchComponentIdPacked)
			{
				memcpy((DCHAR*)szComponentIdSQUID, pchBeginComponentId, cchComponentIdPacked*sizeof(DCHAR));
				szComponentIdSQUID[cchCompId] = 0;
			}
			else if (!UnpackGUID(pchBeginComponentId, szComponentIdSQUID, ipgPartial))
				return INSTALLSTATE_BROKEN;

			CAPITempBuffer<DCHAR, 1> rgchComponentRegValue;
			CAPITempBuffer<DCHAR, 1> rgchComponentPath;

			if (!rgchComponentRegValue.SetSize(MAX_PATH) || !rgchComponentPath.SetSize(MAX_PATH))
				return INSTALLSTATE_BADCONFIG;

			DWORD dwValueType;

			INSTALLSTATE isComp;
			if ( iKey != -1 && IsValidAssignmentValue(iKey) )
			{
				iaaAppAssignment iaaTemp = (iaaAppAssignment)iKey;
				isComp = GetComponentClientState(0, szProductSQUID, szComponentIdSQUID, rgchComponentRegValue, dwValueType, &iaaTemp);
			}
			else
				isComp = GetComponentClientState(0, szProductSQUID, szComponentIdSQUID, rgchComponentRegValue, dwValueType, 0);
			switch (isComp)
			{
			case INSTALLSTATE_SOURCE:
			{
				INSTALLSTATE isTmp;
				is = INSTALLSTATE_SOURCE;
				if (fLocateComponents &&
					 (INSTALLSTATE_SOURCE != (isTmp = GetComponentPath(0,
																						szProductSQUID,
																						szComponentIdSQUID,
																						rgchComponentPath,
																						fFromDescriptor,
																						rCacheInfo,
																						DETECTMODE_VALIDATEALL,
																						rgchComponentRegValue,
																						dwValueType))))
				{
					if(INSTALLSTATE_BADCONFIG != isTmp &&
						INSTALLSTATE_MOREDATA  != isTmp)
					{
						DCHAR szComponentId[cchGUID+1]  = {0};
						DCHAR szProductId[cchGUID+1] = {0};
						UnpackGUID(szComponentIdSQUID, szComponentId, ipgPacked);
						UnpackGUID(szProductSQUID,     szProductId,   ipgPacked);
						ResolveComponentPathForLogging(rgchComponentPath);
						DEBUGMSGE3(EVENTLOG_WARNING_TYPE, EVENTLOG_TEMPLATE_COMPONENT_DETECTION_RFS, szProductId, szFeature, szComponentId, (DCHAR*)rgchComponentPath);
					}
					if(INSTALLSTATE_SOURCEABSENT == isTmp)
						fSourceAbsent = true;
					else
						return INSTALLSTATE_BROKEN; // for RFS components with registry key paths
				}
				break;
			}
			case INSTALLSTATE_LOCAL:
				INSTALLSTATE isTmp;
				if (fLocateComponents &&
					 (INSTALLSTATE_LOCAL != (isTmp = GetComponentPath(0,
																		  szProductSQUID,
																		  szComponentIdSQUID,
																		  rgchComponentPath,
																		  fFromDescriptor,
																		  rCacheInfo,
																		  DETECTMODE_VALIDATEALL,
																		  rgchComponentRegValue,
																		  dwValueType))))
				{
					if(INSTALLSTATE_BADCONFIG != isTmp &&
						INSTALLSTATE_MOREDATA  != isTmp)
					{
						DCHAR szComponentId[cchGUID+1] = {0};
						DCHAR szProductId[cchGUID+1] = {0};
						UnpackGUID(szComponentIdSQUID, szComponentId, ipgPacked);
						UnpackGUID(szProductSQUID,     szProductId,   ipgPacked);
						ResolveComponentPathForLogging(rgchComponentPath);
						DEBUGMSGE3(EVENTLOG_WARNING_TYPE, EVENTLOG_TEMPLATE_COMPONENT_DETECTION, szProductId, szFeature, szComponentId, (DCHAR*)rgchComponentPath);
					}
					return INSTALLSTATE_BROKEN;
				}
				break;
			case INSTALLSTATE_NOTUSED: // the component is disabled, ignore for feature state determination
				break;
			case INSTALLSTATE_UNKNOWN:
				return INSTALLSTATE_ADVERTISED;
			default:
				AssertSz(0, "Invalid component client state in MsiQueryFeatureState");
				return INSTALLSTATE_UNKNOWN;
			}
			pchBeginComponentId += cchCompId;
			cchComponentListLen -= cchCompId;
		}
	}

	if (fSourceAbsent)
		is = INSTALLSTATE_SOURCEABSENT;

	return is;
}


/*inline */DWORD OpenInProgressProductKeyPacked(LPCDSTR szProductSQUID, CRegHandle& riKey, bool fSetKeyString)
{
	if ( !szProductSQUID || (lstrlen(szProductSQUID) != cchProductCodePacked) )
	{
		Assert(0);
		return ERROR_INVALID_PARAMETER;
	}

	// look up Product in MsiInProgress
	DWORD dwResult = MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE, szMsiInProgressKey, 0,
	KEY_READ, &riKey);

	if (ERROR_SUCCESS == dwResult)
	{
		DCHAR szProductKey[cchProductCodePacked + 1];
		DWORD cbProductKey = sizeof(szProductKey);

		dwResult = RegQueryValueEx(riKey, szMsiInProgressProductCodeValue,
							0, 0, (LPBYTE)szProductKey, &cbProductKey);

		if (ERROR_SUCCESS == dwResult)
		{
			if (0 != lstrcmp(szProductSQUID, szProductKey))
			{
				dwResult = ERROR_UNKNOWN_PRODUCT;
			}
		}
	}

	if (ERROR_SUCCESS == dwResult)
	{
		if (fSetKeyString)
		{
			riKey.SetKey(HKEY_LOCAL_MACHINE, szMsiInProgressKey);
		}
	}

	return dwResult;
}

inline DWORD OpenInProgressProductKey(LPCDSTR szProductGUID, CRegHandle& riKey, bool fSetKeyString)
/*----------------------------------------------------------------------------
Opens the InProgress product key.

Arguments:
	szProduct: the product whose key is to be opened
	*phKey:      upon success, the open key
Returns:
	any error returnable by RegOpenKeyEx
------------------------------------------------------------------------------*/
{
	DCHAR szProductSQUID[cchProductCodePacked + 1];

	if(!szProductGUID || lstrlen(szProductGUID) != cchProductCode || !PackGUID(szProductGUID, szProductSQUID))
		return ERROR_INVALID_PARAMETER;

	return OpenInProgressProductKeyPacked(szProductSQUID, riKey, fSetKeyString);
}


// Opens a specific users sourcelist key in write mode. NULL as the User SID means the current user. 
// attempting to open a per-user non-managed sourcelist for a user other than the current user will cause
// an assert. (The HKCU for that user may be roamed away, we can't guarantee that it is valid)
DWORD OpenSpecificUsersSourceListKeyPacked(enum iaaAppAssignment iaaAsgnType, LPCDSTR szUserSID, LPCDSTR szProductOrPatchCodeSQUID, CRegHandle &riHandle, Bool fWrite, bool &fOpenedProductKey, bool &fProductIsSystemOwned)
{
	DWORD dwResult;
	CRegHandle HProductKey;

	fOpenedProductKey = false;
	fProductIsSystemOwned = false;

	CACHED_CONVERTSTRING(ICHAR, szUnicodeUserSID, szUserSID);
	if (fWrite)
	{
		if ((dwResult = OpenSpecificUsersWritableAdvertisedProductKey(iaaAsgnType, szUserSID ? static_cast<const ICHAR*>(szUnicodeUserSID) : (ICHAR *)NULL, CMsInstApiConvertString(szProductOrPatchCodeSQUID), HProductKey, false)) != 0)
			DEBUGMSG1(MSITEXT("OpenWritableAdvertisedProductKey failed with %d"), (const DCHAR*)(INT_PTR)dwResult);
	}
	else
		dwResult = OpenSpecificUsersAdvertisedProductKeyPacked(iaaAsgnType, szUserSID ? static_cast<const DCHAR*>(szUnicodeUserSID) : (DCHAR *)NULL, szProductOrPatchCodeSQUID, HProductKey, false);

	if (ERROR_SUCCESS != dwResult)
		return dwResult;

	// only check managed or not on NT. FIsKeySystemOrAdminOwned fails on 9X
	fOpenedProductKey = true;
	if (!g_fWin9X && (ERROR_SUCCESS != (dwResult = FIsKeySystemOrAdminOwned(HProductKey, fProductIsSystemOwned))))
		return dwResult;

	if (fWrite)
	{
		if (ERROR_SUCCESS != (dwResult = MsiRegCreate64bitKey(HProductKey, szSourceListSubKey, 0, 0, 0, g_samRead|KEY_WRITE, 0, &riHandle, 0)))
			DEBUGMSG1(MSITEXT("RegCreateKeyEx in OpenSpecificUsersSourceListKeyPacked failed with %d"), (const DCHAR*)(INT_PTR)dwResult);
	}
	else
		dwResult = MsiRegOpen64bitKey(HProductKey, szSourceListSubKey, 
										0, g_samRead, &riHandle);

	return dwResult;
}

/*inline*/DWORD OpenSourceListKeyPacked(LPCDSTR szProductOrPatchCodeSQUID, Bool fPatch, CRegHandle &riHandle, Bool fWrite, bool fSetKeyString)
{
	DWORD dwResult;
	CRegHandle HProductKey;

	CACHED_CONVERTSTRING(ICHAR, szUnicodeProductOrPatchCodeSQUID, szProductOrPatchCodeSQUID);
	if (fPatch)
		dwResult = OpenAdvertisedPatchKeyPacked(szUnicodeProductOrPatchCodeSQUID, HProductKey, fSetKeyString);
	else
	{
		if (fWrite)
		{
			if ((dwResult = OpenWritableAdvertisedProductKey(szUnicodeProductOrPatchCodeSQUID, HProductKey, fSetKeyString)) != 0)
				DEBUGMSG1(MSITEXT("OpenWritableAdvertisedProductKey failed with %d"), (const DCHAR*)(INT_PTR)dwResult);
		}
		else
			dwResult = OpenAdvertisedProductKeyPacked(szProductOrPatchCodeSQUID, HProductKey, fSetKeyString);
	}

	if (ERROR_SUCCESS != dwResult)
		return dwResult;

	if (fWrite)
	{
		REGSAM sam = KEY_READ | KEY_WRITE;
#ifndef _WIN64
		if ( g_fWinNT64 )
			sam |= KEY_WOW64_64KEY;
#endif
		if (ERROR_SUCCESS != (dwResult = MsiRegCreate64bitKey(HProductKey, szSourceListSubKey, 0, 0, 0, 
													sam, 0, &riHandle, 0)))
			DEBUGMSG1(MSITEXT("RegCreateKeyEx in OpenSourceListKeyPacked failed with %d"), (const DCHAR*)(INT_PTR)dwResult);
	}
	else
	{
		REGSAM sam = KEY_READ;
#ifndef _WIN64
		if ( g_fWinNT64 )
			sam |= KEY_WOW64_64KEY;
#endif
		dwResult = MsiRegOpen64bitKey(HProductKey, szSourceListSubKey, 
										0, sam, &riHandle);
	}

	if (fSetKeyString && ERROR_SUCCESS == dwResult)
	{
		riHandle.SetSubKey(HProductKey, szSourceListSubKey);
	}

	return dwResult;
}

/*inline*/DWORD OpenSourceListKey(LPCDSTR szProductOrPatchCodeGUID, Bool fPatch, CRegHandle &riHandle, Bool fWrite, bool fSetKeyString)
/*----------------------------------------------------------------------------
Opens the sourcelist key.

Arguments:
	szProduct: the product whose key is to be opened
	*phKey:      upon success, the open key
Returns:
	any error returnable by RegOpenKeyEx
------------------------------------------------------------------------------*/
{
	DCHAR szProductOrPatchCodeSQUID[cchGUIDPacked + 1];
	if(!szProductOrPatchCodeGUID || lstrlen(szProductOrPatchCodeGUID) != cchGUID || !PackGUID(szProductOrPatchCodeGUID, szProductOrPatchCodeSQUID))
		return ERROR_INVALID_PARAMETER;

	return OpenSourceListKeyPacked(szProductOrPatchCodeSQUID, fPatch, riHandle, fWrite, fSetKeyString);
}


UINT GetInfo(
	LPCDSTR   szCodeSQUID,         // product or patch code
	ptPropertyType ptType,    // type of property - product,patch
	LPCDSTR   szProperty,     // property name, case-sensitive
	LPDSTR    lpValueBuf,     // returned value, NULL if not desired
	DWORD     *pcchValueBuf)  // in/out buffer character count
{
	AssertSz(szCodeSQUID && szProperty && !(lpValueBuf && !pcchValueBuf), "invalid param to GetInfo");
	if ( ! (szCodeSQUID && szProperty && !(lpValueBuf && !pcchValueBuf)) )
		return ERROR_OUTOFMEMORY;
	
#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		UINT ui = GetInfo(
			static_cast<const char *>(CMsInstApiConvertString(szCodeSQUID)),
			ptType,
			static_cast<const char *>(CMsInstApiConvertString(szProperty)),
			CWideToAnsiOutParam(lpValueBuf, pcchValueBuf, (int*)&ui),
			pcchValueBuf);

		return ui;
	}
	else // g_fWin9X == false
	{
#endif
		bool fSetKeyString = false;

		for (int c=0;c<2;c++)
		{
			CRegHandle HKey;

			ProductProperty* prop = g_ProductPropertyTable;
			CApiConvertString strProperty(szProperty);
			for (; prop->szProperty && (0 != lstrcmp(prop->szProperty, strProperty)); prop++)
				;

			if (! prop->szProperty || !(prop->pt & ptType))
				return ERROR_UNKNOWN_PROPERTY;

			DWORD lError = ERROR_SUCCESS;

			const DCHAR* pszValueName = prop->szValueName;
			pplProductPropertyLocation ppl;
			switch (ppl = prop->ppl)
			{
			case pplAdvertised:
				if(ptType == ptProduct)
					lError = OpenAdvertisedProductKeyPacked(szCodeSQUID, HKey, fSetKeyString);
				else if(ptType == ptPatch)
					lError = OpenAdvertisedPatchKeyPacked(szCodeSQUID, HKey, fSetKeyString);
				else
				{
					AssertSz(0, "Unknown property type");
					lError = ERROR_INVALID_PARAMETER;
				}
				break;
			case pplUninstall:
				if(ptType == ptProduct)
				{
					DCHAR szProductCode[cchProductCode + 1];
					if(!UnpackGUID(szCodeSQUID, szProductCode))
						return ERROR_INVALID_PARAMETER;
					lError = OpenInstalledProductInstallPropertiesKey(szProductCode, HKey, fSetKeyString);
					if (ERROR_FILE_NOT_FOUND == lError)
					{
						if (ERROR_SUCCESS == OpenAdvertisedProductKeyPacked(szCodeSQUID, HKey, fSetKeyString))
							lError = ERROR_UNKNOWN_PROPERTY;
					}
					else if(ERROR_SUCCESS == lError && !lstrcmp(strProperty, CMsInstApiConvertString(INSTALLPROPERTY_LOCALPACKAGE)))
					{
						// special case for managed user apps
						iaaAppAssignment iaaAsgnType;
						lError = GetProductAssignmentType(szCodeSQUID, iaaAsgnType);
						if(ERROR_SUCCESS == lError && iaaUserAssign == iaaAsgnType)
						{
							pszValueName = szLocalPackageManagedValueName;
						}
					}
				}
				else if(ptType == ptPatch)
					lError = OpenInstalledPatchKeyPacked(szCodeSQUID, 0, HKey, fSetKeyString);
				else
				{
					AssertSz(0, "Unknown property type");
					lError = ERROR_INVALID_PARAMETER;
				}
				break;
			case pplIntegerPolicy:
				if(ptType == ptProduct)
				{
					// do nothing; we don't care about the product as policy is at the user level
				}
				else
				{
					AssertSz(0, "Unknown property type");
					lError = ERROR_INVALID_PARAMETER;
				}

				break;
			default:
				AssertSz(0, "Unknown product property location");
			case pplSourceList:
				if(ptType == ptProduct)
					lError = OpenSourceListKeyPacked(szCodeSQUID, fFalse, HKey, fFalse, fSetKeyString);
				else if(ptType == ptPatch)
					lError = OpenSourceListKeyPacked(szCodeSQUID, fTrue, HKey, fFalse, fSetKeyString);
				else
				{
					AssertSz(0, "Unknown property type");
					lError = ERROR_INVALID_PARAMETER;
				}
				break;
			}
			
			if (ERROR_SUCCESS != lError)
			{
				if (ERROR_FILE_NOT_FOUND == lError)
				{
					return ERROR_UNKNOWN_PRODUCT;
				}
				else if (ERROR_UNKNOWN_PROPERTY == lError)
				{
					return ERROR_UNKNOWN_PROPERTY;
				}
				else  // unknown error
				{
					return lError;
				}
			}

			DWORD dwType = REG_NONE;

			// Get property value

			if (lpValueBuf || pcchValueBuf)
			{
				DWORD cbValueBuf = 0;
				if (ppl == pplIntegerPolicy)
				{
					if (lpValueBuf)
					{
						Bool fUsedDefault = fFalse;
						*(int*)lpValueBuf = GetIntegerPolicyValue(CMsInstApiConvertString(pszValueName), fFalse, &fUsedDefault);
						if (fUsedDefault)
						{
							lError = ERROR_FILE_NOT_FOUND;
						}
						else
						{
							dwType = REG_DWORD;
							lError = ERROR_SUCCESS;
						}
					}
				}

				else
				{
					cbValueBuf = *pcchValueBuf * sizeof(DCHAR);
					lError = RegQueryValueEx(HKey, pszValueName, NULL, &dwType,
					 (unsigned char*)lpValueBuf, &cbValueBuf);
				}

				if (ERROR_SUCCESS == lError)
				{
					if (REG_DWORD == dwType)
					{
						if (lpValueBuf)
						{
							CAPITempBuffer<DCHAR, 20> rgchInt;
	#ifdef MSIUNICODE
							_itow
	#else
							_itoa
	#endif
								(*(int UNALIGNED *)lpValueBuf, rgchInt, 10);


							if (*pcchValueBuf < lstrlen(rgchInt)+1) 
							{
								lError = ERROR_MORE_DATA;
							}
							else
							{
								StringCchCopy(lpValueBuf, *pcchValueBuf, rgchInt);
								lError = ERROR_SUCCESS;
							}
							*pcchValueBuf = lstrlen(rgchInt);
							return lError;
						}
						else
						{
							*pcchValueBuf = 10; // max char representation of DWORD
							return lError;
						}
					}
					else // REG_SZ or REG_EXPAND_SZ
					{
						if(prop->pt & ptSQUID)
						{
							// need to unpack SQUID - assume size of unpacked SQUID is cchGUID

							if (!lpValueBuf)
							{
								*pcchValueBuf = cchGUID;
								return ERROR_SUCCESS;
							}

							if(*pcchValueBuf < cchGUID + 1)
							{
								*pcchValueBuf = cchGUID;
								return ERROR_MORE_DATA;
							}

							DCHAR szUnpacked[cchGUID+1];

							if(!UnpackGUID(lpValueBuf,szUnpacked))
							{
								if (c==0)
								{
									fSetKeyString = true;
									continue; // go around again to get the key's string
								}

								// malformed squid
								DEBUGMSGE2(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_BAD_CONFIGURATION_VALUE, CMsInstApiConvertString(prop->szValueName), CMsInstApiConvertString(lpValueBuf), HKey.GetKey());
								return ERROR_BAD_CONFIGURATION;
							}

							StringCchCopy(lpValueBuf, *pcchValueBuf, szUnpacked);
							*pcchValueBuf = cchGUID;
						}
						else
						{
							*pcchValueBuf = (cbValueBuf/sizeof(DCHAR) - 1);
						}
					}
				}
				else 
				{
					if (ERROR_MORE_DATA == lError)
					{
						if (REG_SZ == dwType || REG_EXPAND_SZ == dwType)
						{
							*pcchValueBuf = (cbValueBuf/sizeof(DCHAR) - 1);
						}
						else if (REG_DWORD == dwType)
						{			
							*pcchValueBuf = 10; // max char representation of DWORD
						}

						return ERROR_MORE_DATA;
					}
					else if (ERROR_FILE_NOT_FOUND == lError)
					{
						if (lpValueBuf)
							*lpValueBuf = 0;
						*pcchValueBuf = 0;
						return ERROR_SUCCESS;
					}
					else
						return lError;
				}
			}
			break;
		}
#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif // MSIUNICODE

	return ERROR_SUCCESS;
}

void MsiExpandEnvironmentStrings(const DCHAR* sz,CAPITempBufferRef<DCHAR>& rgch)
{
	Assert(sz);
	DWORD dwSize = WIN::ExpandEnvironmentStrings(sz,(DCHAR*)rgch,rgch.GetSize());
	if(dwSize > rgch.GetSize())
	{
		// try again with the correct size
		rgch.SetSize(dwSize);
		dwSize = WIN::ExpandEnvironmentStrings(sz,(DCHAR*)rgch, dwSize);
	}
	Assert(dwSize && dwSize <= rgch.GetSize());
}

INSTALLSTATE GetComponentClientState(const DCHAR* szUserId, const DCHAR* szProductSQUID, const DCHAR* szComponentSQUID,CAPITempBufferRef<DCHAR>& rgchComponentRegValue, DWORD& dwValueType, iaaAppAssignment* piaaAsgnType)
{
	// need to read the registry for the component info
	CRegHandle HComponentKey;
	LONG lError;
	if(piaaAsgnType)
	{
		Assert(!szUserId); // cannot be called with a user specific
		lError = OpenSpecificInstalledComponentKey(*piaaAsgnType, szComponentSQUID, HComponentKey, false);
	}
	else
		lError = OpenInstalledComponentKeyPacked(szUserId, szProductSQUID, szComponentSQUID, HComponentKey, false);

	if (ERROR_SUCCESS != lError)
		return INSTALLSTATE_UNKNOWN;

	lError = MsiRegQueryValueEx(HComponentKey, szProductSQUID, 0, &dwValueType, rgchComponentRegValue, 0);
	if(ERROR_SUCCESS != lError)
		return INSTALLSTATE_UNKNOWN;

	if (0 == rgchComponentRegValue[0])
		return INSTALLSTATE_NOTUSED;
	else if (rgchComponentRegValue[1] && rgchComponentRegValue[2] && rgchComponentRegValue[0] >= '0' && rgchComponentRegValue[0] <= '9' && rgchComponentRegValue[1] >= '0' && rgchComponentRegValue[1] <= '9')
	{
		// "##RelativePath" == Run From Source  
		// "##:SubKey"      == Registry Value. If ## >= 50 then it's run-from-source  (50 == iRegistryHiveSourceOffset)

			if ((rgchComponentRegValue[2] != ':' && rgchComponentRegValue[2] != '*') || rgchComponentRegValue[0] >= '5')
				return INSTALLSTATE_SOURCE;
	}
	return INSTALLSTATE_LOCAL;
}

Bool ResolveSource(const DCHAR* szProduct, unsigned int uiDisk, CAPITempBufferRef<DCHAR>& rgchSource, Bool fSetLastUsedSource, HWND hWnd)
{	
	IMsiServices* piServices = ENG::LoadServices();
	if ( !piServices )
	{
		Assert(0);
		return fFalse;
	}

	PMsiRecord pError(0);

	{ // scope MsiStrings
	MsiString strSource;
	MsiString strProduct;
	CResolveSource source(piServices, false /*fPackageRecache*/);
	pError = source.ResolveSource(CMsInstApiConvertString(szProduct), fFalse, uiDisk, *&strSource, *&strProduct, fSetLastUsedSource, hWnd, false);
	if (pError == 0)
	{
		if (rgchSource.GetSize() + 1 < strSource.TextSize())
			rgchSource.SetSize(strSource.TextSize() + 1);

		StringCchCopy((DCHAR*)(const DCHAR*)rgchSource, rgchSource.GetSize(), CMsInstApiConvertString((const ICHAR*)strSource));
	}
	}
	Bool fRet = (Bool)(pError == 0);
	pError = 0;
	ENG::FreeServices();
	return fRet;
}


int GetPackageFullPath(
						  LPCDSTR szProduct, CAPITempBufferRef<DCHAR>& rgchPackagePath,
						  plEnum &plPackageLocation, Bool /*fShowSourceUI*/) //!! UI shouldn't be a parameter
/*----------------------------------------------------------------------------
Retrieve the full path to a product's package. Three locations are searched
for the package:

  1) Look for a local cached database
  2) Look for a database at the advertised source
  3) Look for an in-progress install

rguments:
	szPath: The path to be expanded
	rgchExpandedPath: The buffer for the expanded path

Returns:
	fTrue -   Success
	fFalse -  Error getting the current directory
------------------------------------------------------------------------------*/
{
	CRegHandle HProductKey;
	DWORD lResult;
	DWORD dwType;
	DWORD cbPackage;
	CAPITempBuffer<DCHAR, 1> rgchPackage;
	if (!rgchPackage.SetSize(MAX_PATH))
		return ERROR_OUTOFMEMORY;

	
	DCHAR szProductSQUID[cchProductCodePacked + 1];
	if(!szProduct || lstrlen(szProduct) != cchProductCode || !PackGUID(szProduct, szProductSQUID))
		return ERROR_INVALID_PARAMETER;

	// Attempt #1 : Look for local cached database

	if ((int)plPackageLocation & (int)plLocalCache)
	{
		if(ERROR_SUCCESS == OpenInstalledProductInstallPropertiesKeyPacked(szProductSQUID, HProductKey, false))
		{
			// special case for managed user apps
			iaaAppAssignment iaaAsgnType;
			DCHAR* pszValueName = szLocalPackageValueName;
			lResult = GetProductAssignmentType(szProductSQUID, iaaAsgnType);
			if(ERROR_SUCCESS == lResult && iaaUserAssign == iaaAsgnType)
			{
				pszValueName = szLocalPackageManagedValueName;
			}

			lResult = MsiRegQueryValueEx(HProductKey, pszValueName, 0, &dwType, rgchPackage, &cbPackage);
			if ((ERROR_SUCCESS == lResult) && (cbPackage > 1)) // success and non-empty string
			{
				MsiExpandEnvironmentStrings(&rgchPackage[0], rgchPackagePath);

				// cache unicode conversion of the resolved path to prevent creation of expensive temporary objects
				CACHED_CONVERTSTRING(ICHAR, szUnicodePackagePath, rgchPackagePath);
				if (0xFFFFFFFF != MsiGetFileAttributes(szUnicodePackagePath))
				{
					// found the cached package
					// if a package code registered for this product, verify that the package code
					// of the cached package matches, else ignore the cached package
					
					bool fAcceptCachedPackage = false;
					
					IMsiServices* piServices = ENG::LoadServices();
					if (!piServices)
						return ERROR_FUNCTION_FAILED;
					
					{ // block for loaded services

						CTempBuffer<ICHAR, cchProductCode+1> szPackageCode;
						ENG::GetProductInfo(CMsInstApiConvertString(szProduct), INSTALLPROPERTY_PACKAGECODE, szPackageCode);

						if(szPackageCode[0])
						{

							PMsiStorage pStorage(0);
							ICHAR rgchExtractedPackageCode[cchProductCode+1];
							
							//
							// SAFER: only opening package to pull out package code.  no safer check is necessary.
							//

							if(ERROR_SUCCESS != OpenAndValidateMsiStorage(szUnicodePackagePath, stDatabase, *piServices, *&pStorage,
																			/* fCallSAFER = */ false, /* szFriendlyName = */ NULL,
																			/* phSaferLevel = */ NULL))
							{
								DEBUGMSG1(MSITEXT("Warning: Local cached package '%s' could not be opened as a storage file."), (const DCHAR*)rgchPackagePath);
							}
							else if(ERROR_SUCCESS != GetPackageCodeAndLanguageFromStorage(*pStorage, rgchExtractedPackageCode, 0))
							{
								DEBUGMSG1(MSITEXT("Warning: Local cached package '%s' does not contain valid package code."), (const DCHAR*)rgchPackagePath);
							}
							else if(lstrcmpiW(szPackageCode,rgchExtractedPackageCode) != 0)
							{
								DEBUGMSG1(MSITEXT("Warning: The package code in the cached package '%s' does not match the registered package code.  Cached package will be ignored."), (const DCHAR*)rgchPackagePath);
							}
							else
							{
								fAcceptCachedPackage = true;
							}

						}
						else
						{
							fAcceptCachedPackage = true;
						}
					}
					ENG::FreeServices();

					if(fAcceptCachedPackage)
					{
						plPackageLocation = plLocalCache;
						return ERROR_SUCCESS;
					}
				}
				else
				{
					DEBUGMSG1(MSITEXT("Warning: Local cached package '%s' is missing."), (const DCHAR*)rgchPackagePath);
				}
			}
		}
	}

	// Attempt #2 : Look to advertised product source 
	
	if ((int)plPackageLocation & (int)plSource)
	{
		lResult = OpenSourceListKeyPacked(szProductSQUID, fFalse, HProductKey, fFalse, false);

		if (ERROR_SUCCESS == lResult)
		{
			lResult = MsiRegQueryValueEx(HProductKey, szPackageNameValueName, 0,
				&dwType, rgchPackage, 0);

			if (ERROR_SUCCESS != lResult)
			{
				// expected to find package name.

				OpenSourceListKeyPacked(szProductSQUID, fFalse, HProductKey, fFalse, true);
				DEBUGMSGE2(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_BAD_CONFIGURATION_VALUE, CMsInstApiConvertString(szPackageNameValueName), TEXT(""), HProductKey.GetKey());
				return ERROR_BAD_CONFIGURATION;
			}

			CAPITempBuffer<DCHAR, 1> rgchSource;
			if (!rgchSource.SetSize(MAX_PATH))
				return ERROR_OUTOFMEMORY;
			BOOL fResult = ResolveSource(CMsInstApiConvertString(szProduct), 1, rgchSource, fTrue, g_message.m_hwnd); // the package is on disk 1
			if ((!fResult) || (0 == rgchSource[0]))
			{
				return ERROR_INSTALL_SOURCE_ABSENT;
			}
			
			const DCHAR* szSource = rgchSource;

			// combine source and package name

			const int cchSource = lstrlen(szSource);
			if (!rgchPackagePath.SetSize(cchSource + 1 + lstrlen(rgchPackage) + 1))
				return ERROR_OUTOFMEMORY;

			StringCchCopy(&rgchPackagePath[0], rgchPackagePath.GetSize(), szSource);

			if (szSource[cchSource - 1] != '\\' && szSource[cchSource - 1] != '/')
				StringCchCat(&rgchPackagePath[0], rgchPackagePath.GetSize(), MSITEXT("\\"));

			StringCchCat(&rgchPackagePath[0], rgchPackagePath.GetSize(), &rgchPackage[0]);
			plPackageLocation = plSource;
			return ERROR_SUCCESS;
		}
	}	


//!! does this ever a valid scenario?
//!! need to remove, if not
//!! need to indirect to inprogress file, if yes
	return ERROR_UNKNOWN_PRODUCT;
}



//____________________________________________________________________________
//
// GUID compression routines
//
//   A SQUID (SQuished UID) is a compacted form of a GUID that takes
//   only 20 characters instead of the usual 38. Only standard ASCII characters
//   are used, to allow use as registry keys. The following are never used:
//     (space)
//     (0x7F)
//     :  (colon, used as delimeter by shell for shortcut information
//     ;  (semicolon)
//     \  (illegal for use in registry key)
//     /  (forward slash)
//     "  (double quote)
//     #  (illegal for registry value as first character)
//     >  (greater than, output redirector)
//     <  (less than, input redirector)
//     |  (pipe)
//____________________________________________________________________________

Bool PackGUID(const DCHAR* szGUID, DCHAR* szSQUID, ipgEnum ipg)
{ 
	int cchTemp = 0;
	while (cchTemp < cchGUID)		// check if string is atleast cchGUID chars long,
		if (!(szGUID[cchTemp++]))		// can't use lstrlen as string doesn't HAVE to be null-terminated.
			return fFalse;

	if (szGUID[0] != '{' || szGUID[cchGUID-1] != '}')
		return fFalse;
	const unsigned char* pch = rgOrderGUID;
	switch (ipg)
	{
	case ipgFull:
		lstrcpyn(szSQUID, szGUID, cchGUID+1);
		return fTrue;
	case ipgPacked:
		while (pch < rgOrderGUID + sizeof(rgOrderGUID))
			*szSQUID++ = szGUID[*pch++];
		*szSQUID = 0;
		return fTrue;
	case ipgTrimmed:
		pch = rgTrimGUID;
		while (pch < rgTrimGUID + sizeof(rgTrimGUID))
			*szSQUID++ = szGUID[*pch++];
		*szSQUID = 0;
		return fTrue;
	case ipgCompressed:
	{
		int cl = 4;
		while (cl--)
		{
			unsigned int iTotal = 0;
			int cch = 8;  // 8 hex chars to 32-bit word
			while (cch--)
			{
				unsigned int ch = szGUID[pch[cch]] - '0'; // go from low order to high
				if (ch > 9)  // hex char (or error)
				{
					ch = (ch - 7) & ~0x20;
					if (ch > 15)
						return fFalse;
				}
				iTotal = iTotal * 16 + ch;
			}
			pch += 8;
			cch = 5;  // 32-bit char to 5 text chars
			while (cch--)
			{
				*szSQUID++ = rgEncodeSQUID[iTotal%85];
				iTotal /= 85;
			}
		}
		*szSQUID = 0;  // null terminate
		return fTrue;
	}
	case ipgPartial:  // not implemented, but can be if the need arises
		Assert(0);
	default:
		return fFalse;
	} // end switch
}

Bool UnpackGUID(const DCHAR* szSQUID, DCHAR* szGUID, ipgEnum ipg)
{ 
	const unsigned char* pch;
	switch (ipg)
	{
	case ipgFull:
		lstrcpyn(szGUID, szSQUID, cchGUID+1);
		return fTrue;
	case ipgPacked:
	{
		pch = rgOrderGUID;
		while (pch < rgOrderGUID + sizeof(rgOrderGUID))
			if (*szSQUID)
				szGUID[*pch++] = *szSQUID++;
			else              // unexpected end of string
				return fFalse;
		break;
	}
	case ipgTrimmed:
	{
		pch = rgTrimGUID;
		while (pch < rgTrimGUID + sizeof(rgTrimGUID))
			if (*szSQUID)
				szGUID[*pch++] = *szSQUID++;
			else              // unexpected end of string
				return fFalse;
		break;
	}
	case ipgCompressed:
	{
		pch = rgOrderGUID;
#ifdef DEBUG //!! should not be here for performance reasons, onus is on caller to insure buffer is sized properly
		int cchTemp = 0;
		while (cchTemp < cchGUIDCompressed)     // check if string is atleast cchGUIDCompressed chars long,
			if (!(szSQUID[cchTemp++]))          // can't use lstrlen as string doesn't HAVE to be null-terminated.
				return fFalse;
#endif
		for (int il = 0; il < 4; il++)
		{
			int cch = 5;
			unsigned int iTotal = 0;
			while (cch--)
			{
				unsigned int iNew = szSQUID[cch] - '!';
				if (iNew >= sizeof(rgDecodeSQUID) || (iNew = rgDecodeSQUID[iNew]) == 85)
					return fFalse;   // illegal character
				iTotal = iTotal * 85 + iNew;
			}
			szSQUID += 5;
			for (int ich = 0; ich < 8; ich++)
			{
				int ch = (iTotal & 15) + '0';
				if (ch > '9')
					ch += 'A' - ('9' + 1);
				szGUID[*pch++] = (DCHAR)ch;
				iTotal >>= 4;
			}
		}
		break;
	}
	case ipgPartial:
	{
		for (int il = 0; il < 4; il++)
		{
			int cch = 5;
			unsigned int iTotal = 0;
			while (cch--)
			{
				unsigned int iNew = szSQUID[cch] - '!';
				if (iNew >= sizeof(rgDecodeSQUID) || (iNew = rgDecodeSQUID[iNew]) == 85)
					return fFalse;   // illegal character
				iTotal = iTotal * 85 + iNew;
			}
			szSQUID += 5;
			for (int ich = 0; ich < 8; ich++)
			{
				int ch = (iTotal & 15) + '0';
				if (ch > '9')
					ch += 'A' - ('9' + 1);
				*szGUID++ = (DCHAR)ch;
				iTotal >>= 4;
			}
		}
		*szGUID = 0;
		return fTrue;
	}
	default:
		return fFalse;
	} // end switch
	pch = rgOrderDash;
	while (pch < rgOrderDash + sizeof(rgOrderDash))
		szGUID[*pch++] = '-';
	szGUID[0]         = '{';
	szGUID[cchGUID-1] = '}';
	szGUID[cchGUID]   = 0;
	return fTrue;
}


BOOL DecomposeDescriptor(
							const DCHAR* szDescriptor,
							DCHAR* szProductCode,
							DCHAR* szFeatureId,
							DCHAR* szComponentCode,
							DWORD* pcchArgsOffset,	
							DWORD* pcchArgs = 0,
							bool* pfComClassicInteropForAssembly = 0
							)
/*----------------------------------------------------------------------------
Decomposes a descriptor plus optional args into its constituent parts. 

Arguments:
	szDescriptor:  the descriptor optionally followed by arguments
	szProductCode: a buffer of size cchGUID+1 to contain the descriptor's
						product code. May be NULL if not desired.
	szFeatureId:   a buffer of size cchMaxFeatureName+1 to contain the
						descriptor's feature ID. May be NULL if not desired.
	szComponentCode: a buffer of size cchGUID+1 to contain the
						  descriptor's component code. May be NULL if not desired.
	pcchArgsOffset: Will contain the character offset to the args. May be NULL
						 if not desired.
Returns:
	TRUE - Success
	FALSE - szDescriptor was of invalid form
------------------------------------------------------------------------------*/
{
	if (!szDescriptor)
	{
		Assert(0);
		return FALSE;
	}

	const DCHAR* pchDescriptor = szDescriptor;
	int cchDescriptor          = lstrlen(pchDescriptor);
	int cchDescriptorRemaining = cchDescriptor;

	if (cchDescriptorRemaining < cchProductCodeCompressed) // minimum size of a descriptor
		return FALSE;

	DCHAR szProductCodeLocal[cchProductCode + 1];
	DCHAR szFeatureIdLocal[cchMaxFeatureName + 1];
	bool fComClassicInteropForAssembly = false;


	// we need these values locally for optimised descriptors
	if (!szProductCode)
		szProductCode = szProductCodeLocal; 
	if (!szFeatureId)
		szFeatureId = szFeatureIdLocal;
	if(!pfComClassicInteropForAssembly)
		pfComClassicInteropForAssembly = &fComClassicInteropForAssembly;
	DCHAR* pszCurr = szFeatureId;

	if(*pchDescriptor == chGUIDCOMToCOMPlusInteropToken)
	{
		pchDescriptor++;
		*pfComClassicInteropForAssembly = true;
	}
	else
	{
		*pfComClassicInteropForAssembly = false;
	}

	// unpack the product code
	if (!UnpackGUID(pchDescriptor, szProductCode, ipgCompressed))
		return FALSE;

	pchDescriptor += cchProductCodeCompressed;
	cchDescriptorRemaining -= cchProductCodeCompressed;

	int cchFeatureRemaining = cchMaxFeatureName;

	// look for the feature
	while ((*pchDescriptor != chComponentGUIDSeparatorToken) && (*pchDescriptor != chGUIDAbsentToken))
	{
		// have we exceeded the maximum feature size
		if(!cchFeatureRemaining--)
			return FALSE; 

		*pszCurr++ = *pchDescriptor;

		pchDescriptor++;
		// have we reached the end without encountering either 
		// the chComponentGUIDSeparatorToken or the chGUIDAbsentToken
		if(--cchDescriptorRemaining == 0)
			return FALSE; 
	}

	if(pchDescriptor - szDescriptor == (*pfComClassicInteropForAssembly == false ? cchProductCodeCompressed : cchProductCodeCompressed + 1))// we do not have the feature
	{
		if(MsiEnumFeatures(szProductCode, 0, szFeatureId, 0) != ERROR_SUCCESS)
			return FALSE;
		DCHAR szFeatureIdTmp[cchMaxFeatureName + 1];
		if(MsiEnumFeatures(szProductCode, 1, szFeatureIdTmp, 0) != ERROR_NO_MORE_ITEMS) //?? product was supposed to have only one feature
			return FALSE;
	}
	else
		*pszCurr = 0;
	
	cchDescriptorRemaining--; // for the chComponentGUIDSeparatorToken or the chGUIDAbsentToken
	if (*pchDescriptor++ == chComponentGUIDSeparatorToken)// we do have the component id
	{
		// do we have enough characters left for a Compressed guid
		if (cchDescriptorRemaining < cchComponentIdCompressed)
			return FALSE;

		if (szComponentCode)
		{
			if (!UnpackGUID(pchDescriptor, szComponentCode, ipgCompressed))
				return FALSE;
		}

		pchDescriptor  += cchComponentIdCompressed;
		cchDescriptorRemaining  -= cchComponentIdCompressed;
	}
	else
	{
		// we do not have a component id
		Assert(*(pchDescriptor - 1) == chGUIDAbsentToken);

		if (szComponentCode) // we need to get component code			
			*szComponentCode = 0; // initialize to null since we were not able to get the component here
	}

	if (pcchArgsOffset)
	{
		Assert((pchDescriptor - szDescriptor) <= UINT_MAX);			//--merced: 64-bit ptr subtraction may lead to values too big for *pcchArgsOffset
		*pcchArgsOffset = (DWORD)(pchDescriptor - szDescriptor);

		if (pcchArgs)
		{
			*pcchArgs = cchDescriptor - *pcchArgsOffset;
		}
	}

	return TRUE;
}

//____________________________________________________________________________
//
// Special API's (don't create an engine, but are not just registry lookups)
//____________________________________________________________________________

extern "C"
UINT __stdcall MsiProcessAdvertiseScript(
	LPCDSTR      szScriptFile,  // path to script from MsiAdvertiseProduct
	LPCDSTR      szIconFolder,  // optional path to folder for icon files and transforms
	HKEY         hRegData,      // optional parent registry key
	BOOL         fShortcuts,    // TRUE if shortcuts output to special folder
	BOOL         fRemoveItems)  // TRUE if specified items are to be removed
//----------------------------------------------
{
	DEBUGMSG4 (
		MSITEXT("Entering MsiProcessAdvertiseScript. Script file: %s, Icon Folder: %s. Shortcuts %s output to special folder. Specified items %s removed."),
		szScriptFile?szScriptFile:MSITEXT(""),
		szIconFolder?szIconFolder:MSITEXT(""),
		fShortcuts?MSITEXT("will be"):MSITEXT("will not be"),
		fRemoveItems?MSITEXT("will be"):MSITEXT("will not be")
		);      
	
	CForbidTokenChangesDuringCall impForbid;
	UINT uiRet = ERROR_SUCCESS;
	DWORD dwFlags = SCRIPTFLAGS_MACHINEASSIGN; // we set this to machine assign for the older NT5 Beta1 builds that do not support "true" user assignment
	
	// This API should only work on Win2K and higher platforms.
	//?? should we be expanding scriptfile relative to the current working dir (as we do in MsiInstallProduct)?
	if (! MinimumPlatformWindows2000())
	{
		uiRet = ERROR_CALL_NOT_IMPLEMENTED;
	}
	else if (!szScriptFile)
	{
		uiRet = ERROR_INVALID_PARAMETER;
	}
	else
	{
		if(szIconFolder && *szIconFolder)
			dwFlags |= SCRIPTFLAGS_CACHEINFO;
		if(hRegData)
			dwFlags |= SCRIPTFLAGS_REGDATA;
		if(fShortcuts)
			dwFlags |= SCRIPTFLAGS_SHORTCUTS;

		uiRet = MsiAdvertiseScript(szScriptFile, dwFlags, hRegData ? &hRegData : 0, fRemoveItems);
	}
	
	DEBUGMSG1(MSITEXT("MsiProcessAdvertiseScript is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;

}

//!! temp until DoAdvertiseScript get compiled natively
#ifdef MSIUNICODE
#pragma warning(disable : 4005)  // macro redefinition
#define DoAdvertiseScript            DoAdvertiseScriptW
#pragma warning(default : 4005)
#endif
UINT DoAdvertiseScript(
	LPCDSTR    szScriptFile, // path to script from MsiAdvertiseProduct
	DWORD      dwFlags,      // the bit flags from SCRIPTFLAGS
	PHKEY      phRegData,    // optional registry key handle if reg data to be populated elsewhere
	BOOL       fRemoveItems);// TRUE if specified items are to be removed

extern "C"
UINT __stdcall MsiAdvertiseScript(
	LPCDSTR    szScriptFile,  // path to script from MsiAdvertiseProduct
	DWORD      dwFlags,      // the bit flags from SCRIPTFLAGS
	PHKEY      phRegData,    // optional registry key handle if reg data to be populated elsewhere
	BOOL       fRemoveItems) // TRUE if specified items are to be removed
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;
	
	DEBUGMSG4(MSITEXT("Entering MsiAdvertiseScript. scriptfile: %s, flags: %d, hkey: %d, remove: %s"), 
		szScriptFile ? szScriptFile : MSITEXT("(null)"), 
		(const DCHAR*)(INT_PTR)dwFlags, 
		phRegData ? (const DCHAR*)(INT_PTR)*phRegData : (const DCHAR*)(INT_PTR)0, 
		fRemoveItems ? MSITEXT("true") : MSITEXT("false"));
	
	UINT uiRet = ERROR_SUCCESS;
	
	if (! MinimumPlatformWindows2000())
	{
		// Allow this API to run only on Windows2000 and higher platforms
		uiRet = ERROR_CALL_NOT_IMPLEMENTED;
	}
	else if(!phRegData && !RunningAsLocalSystem())
	{
		// Only Local System can call this API.
		// EXCEPT passing in phRegData means you are doing a fake advertise to a mini reg key, we'll allow this when not
		// local_system (this isn't a security feature). This is required for success with the Win2K ADE
		uiRet = ERROR_ACCESS_DENIED;
	}
	else
	{
		uiRet = g_MessageContext.Initialize(fTrue, iuiNone);  //!! correct UI level? or just use this if iuiDefault set
		if (uiRet == NOERROR)
		{
			uiRet = DoAdvertiseScript(szScriptFile, dwFlags, phRegData, fRemoveItems);
			g_MessageContext.Terminate(false);
		}
	}

	DEBUGMSG1(MSITEXT("MsiAdvertiseScript is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}
//!! this function should track Darwin's UNICODE state instead of always calling the ANSI version
UINT DoAdvertiseScript(
	LPCDSTR    szScriptFile,  // path to script from MsiAdvertiseProduct
	DWORD      dwFlags,      // the bit flags from SCRIPTFLAGS
	PHKEY      phRegData,    // optional registry key handle if reg data to be populated elsewhere
	BOOL       fRemoveItems) // TRUE if specified items are to be removed
//----------------------------------------------
{
	//!! binary level backward compatibility 
	if(dwFlags & SCRIPTFLAGS_REGDATA_OLD)
		dwFlags = (dwFlags & ~SCRIPTFLAGS_REGDATA_OLD) | SCRIPTFLAGS_REGDATA;

	if(dwFlags & SCRIPTFLAGS_REGDATA_APPINFO_OLD)
		dwFlags = (dwFlags & ~SCRIPTFLAGS_REGDATA_APPINFO_OLD) | SCRIPTFLAGS_REGDATA_APPINFO;

	//?? should we be expanding scriptfile relative to the current working dir (as we do in MsiInstallProduct)?

	// we dont allow bits we dont know about as also a null scriptfile
	unsigned int SCRIPTFLAGS_MASK = SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS | SCRIPTFLAGS_MACHINEASSIGN | SCRIPTFLAGS_REGDATA | SCRIPTFLAGS_VALIDATE_TRANSFORMS_LIST; // mask for the relevant bits

	if((dwFlags & ~SCRIPTFLAGS_MASK) || (!szScriptFile))
		return ERROR_INVALID_PARAMETER;

	// passing in phRegData means you are doing a fake advertise to a mini reg key, we'll allow this when not
	// local_system (this isn't a security feature). This is required for success with the Win2K ADE
	if (!phRegData && !RunningAsLocalSystem())
	{
		DEBUGMSG("Attempt to execute advertise script when not running as local system");
		return ERROR_ACCESS_DENIED;
	}

	if (!(dwFlags & SCRIPTFLAGS_MACHINEASSIGN) && !IsImpersonating())
	{
		DEBUGMSG("Attempt to do an unimpersonated user assignment");
		return ERROR_INVALID_PARAMETER;
	}

	DWORD dwErr = MsiGetFileAttributes(CMsInstApiConvertString(szScriptFile)); // does the file exist
	if(0xFFFFFFFF == dwErr)
		return GetLastError();

	bool fOLEInitialized = false;
	HRESULT hRes = DoCoInitialize();

	if (ERROR_INSTALL_FAILURE == hRes)
		return hRes;

	if (SUCCEEDED(hRes))
	{
		fOLEInitialized = true;
	}

	CCoUninitialize coUninit(fOLEInitialized);

	UINT uiStat = ERROR_INSTALL_FAILURE;

	// scope to ensure object destruction before OLE is unitialized
	{
	PMsiConfigurationManager pConfigManager(ENG::CreateConfigurationManager());
	PMsiServices pServices(0);
	if((pServices = &pConfigManager->GetServices()) == 0)
		return ERROR_INSTALL_SERVICE_FAILURE;
	

	// If the product is in the registry then... do a mini-Advertise
	// else do a full PAS
	
	if (pConfigManager)
	{
		PMsiExecute piExecute(0);
		PMsiMessage pMessage = new CMsiClientMessage();
		if(fRemoveItems) 
			dwFlags |= SCRIPTFLAGS_REVERSE_SCRIPT; // flag to force the reversal of the script operations 
		piExecute = CreateExecutor(*pConfigManager, *pMessage,
											0, /* DirectoryManager not required during advertisement */
											fFalse, dwFlags | SCRIPTFLAGS_INPROC_ADVERTISEMENT, phRegData);

		if (dwFlags & SCRIPTFLAGS_VALIDATE_TRANSFORMS_LIST)
		{
			PMsiRecord pError(0);
			PEnumMsiRecord piEnumRecord = 0;
			if((pError = piExecute->EnumerateScript(CMsInstApiConvertString(szScriptFile), *&piEnumRecord)) != 0)
				return ERROR_INSTALL_FAILURE;

			PMsiRecord pRecord(0);
			PMsiRecord pProductInfoRec(0);
			unsigned long cFetched;
			MsiString strProductKey;
			CTempBuffer<ICHAR, 1> rgchTransformsList(MAX_PATH);
			rgchTransformsList[0] = 0;
			while (piEnumRecord->Next(1, &pRecord, &cFetched) == NOERROR)
			{
				ixoEnum ixoOperation = (ixoEnum)pRecord->GetInteger(0);
				
				if (ixoProductInfo == ixoOperation)
				{
					strProductKey = pRecord->GetString(IxoProductInfo::ProductKey);
					
					if (!GetProductInfo(strProductKey, INSTALLPROPERTY_TRANSFORMS, rgchTransformsList))
						break;
					pProductInfoRec = pRecord;
				}
				else if (ixoProductPublish == ixoOperation)
				{
					// need to run elevated
					CElevate elevate;
					MsiString strTransformsList;
					if (iesSuccess != piExecute->GetTransformsList(*pProductInfoRec, *pRecord, *&strTransformsList))
						return ERROR_INSTALL_FAILURE;

					if (!strTransformsList.Compare(iscExactI, rgchTransformsList))
						return ERROR_INSTALL_TRANSFORM_FAILURE;
					else
						break;
				}
			}
		}

		iesEnum iesRet = iesSuccess;
		MsiDate dtDate = ENG::GetCurrentDateTime();

		{
			// need to run entire script elevated
			CElevate elevate;

			// this may be run from winlogon directly, so we must ref-count the read privileges.
			CRefCountedTokenPrivileges cPriv(itkpSD_READ);

			iesRet = piExecute->RunScript(CMsInstApiConvertString(szScriptFile), true /*fForceElevation*/);
			piExecute->RollbackFinalize((iesRet == iesUnsupportedScriptVersion ? iesFailure : iesRet), dtDate, false /*fUserChangedDuringInstall*/);// ignore return
			AssertNonZero(pConfigManager->CleanupTempPackages(*pMessage, false)); // cleanup any temp files that need cleanup post install
		}

		switch (iesRet)
		{
		case iesFinished:
		case iesSuccess:
		case iesNoAction:
			uiStat = ERROR_SUCCESS;
			break;
		case iesUnsupportedScriptVersion: // private return from CMsiExecute::RunScript
			uiStat = ERROR_INSTALL_PACKAGE_VERSION;
			break;
		default:
			break; // uiStat = ERROR_INSTALL_FAILURE
		}
	
	}
	
	} // end scope

	DEBUGMSG1(TEXT("DoAdvertiseScript is returning: %u"), (const ICHAR*)(INT_PTR)uiStat);
	return uiStat;
}

extern "C"
UINT __stdcall MsiVerifyPackage(LPCDSTR szPackagePath)
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;
	
	//?? Should we be expanding this path relative to the current working dir
	if (!szPackagePath ||
		 FAILED(StringCchLength(szPackagePath, cchMaxPath+1, NULL)))
		return ERROR_INVALID_PARAMETER;

	UINT uiErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
	UINT iStat = ERROR_SUCCESS;
	// Check for our database CLSID
	IStorage* piStorage = 0;
	if (S_OK == OpenRootStorage(CMsInstApiConvertString(szPackagePath), ismReadOnly, &piStorage))
	{
		if (!ValidateStorageClass(*piStorage, ivscDatabase))
		{
			iStat = ERROR_INSTALL_PACKAGE_INVALID;
		}
		piStorage->Release();
	}
	else
	{
		iStat = ERROR_INSTALL_PACKAGE_OPEN_FAILED;
	}
	SetErrorMode(uiErrorMode);

	return iStat;
}

extern "C"
UINT __stdcall MsiGetProductInfoFromScript(
	LPCDSTR  szScriptFile,    // path to installer script file
	LPDSTR   lpProductBuf39,  // buffer for product code string GUID, 39 chars
	LANGID   *plgidLanguage,  // return language Id
	DWORD    *pdwVersion,     // return version: Maj:Min:Build <8:8:16>
	LPDSTR   lpNameBuf,       // buffer to return readable product name
	DWORD    *pcchNameBuf,    // in/out name buffer character count
	LPDSTR   lpLauncherBuf,   // buffer for path to product launcher 
	DWORD    *pcchLauncherBuf)// in/out path buffer character count
//----------------------------------------------
{
	DEBUGMSG1 (
		MSITEXT("Entering MsiGetProductInfoFromScript. Script file: %s."),
		szScriptFile?szScriptFile:MSITEXT("")
	);
	
	CForbidTokenChangesDuringCall impForbid;
	UINT iStat = ERROR_INSTALL_FAILURE;
	bool fOLEInitialized = false;
	HRESULT hRes = S_OK;
	IMsiServices * piServices = NULL;
	
	// Allow this API to run only on Windows2000 and higher platforms
	if (! MinimumPlatformWindows2000())
	{
		iStat = ERROR_CALL_NOT_IMPLEMENTED;
		goto MsiGetProductInfoFromScriptEnd;
	}
	
	if (0 == szScriptFile)
	{
		iStat = ERROR_INVALID_PARAMETER;
		goto MsiGetProductInfoFromScriptEnd;
	}

	hRes = DoCoInitialize();

	if (ERROR_INSTALL_FAILURE == hRes)
	{
		iStat = ERROR_INSTALL_FAILURE;
		goto MsiGetProductInfoFromScriptEnd;
	}

	if (SUCCEEDED(hRes))
	{
		fOLEInitialized = true;
	}

	piServices = ENG::LoadServices();
	
	if (piServices)
	{
		PMsiRecord pError(0);
		PEnumMsiRecord pEnum(0);
		pError = CreateScriptEnumerator(CMsInstApiConvertString(szScriptFile), *piServices, *&pEnum);
		if (!pError)
		{
			PMsiRecord pRec(0);
			unsigned long pcFetched;

			if ((S_OK == pEnum->Next(1, &pRec, &pcFetched)) &&
				 (pRec->GetInteger(0) == ixoHeader) &&
				 (pRec->GetInteger(IxoHeader::Signature) == iScriptSignature) &&
				 (S_OK == pEnum->Next(1, &pRec, &pcFetched)) &&
				 (pRec->GetInteger(0) == ixoProductInfo))
			{
				DWORD cchProductKey = 39;
				int iFillStat;
#ifdef MSIUNICODE
				iStat = FillBufferW(MsiString(pRec->GetString(IxoProductInfo::ProductKey)), 
										 lpProductBuf39, &cchProductKey);

				iFillStat = FillBufferW(MsiString(pRec->GetMsiString(IxoProductInfo::ProductName)),
												lpNameBuf, pcchNameBuf);
				if (ERROR_SUCCESS != iFillStat)
					iStat = iFillStat;

				iFillStat = FillBufferW(MsiString(pRec->GetMsiString(IxoProductInfo::PackageName)), //!! packagename is correct?
												lpLauncherBuf, pcchLauncherBuf);
				if (ERROR_SUCCESS != iFillStat)
					iStat = iFillStat;
#else // ANSI
				iStat = FillBufferA(MsiString(pRec->GetString(IxoProductInfo::ProductKey)), 
										 lpProductBuf39, &cchProductKey);

				iFillStat = FillBufferA(MsiString(pRec->GetMsiString(IxoProductInfo::ProductName)), 
												lpNameBuf, pcchNameBuf);
				if (ERROR_SUCCESS != iFillStat)
					iStat = iFillStat;

				iFillStat = FillBufferA(MsiString(pRec->GetMsiString(IxoProductInfo::PackageName)),  //!! packagename is correct?
												lpLauncherBuf, pcchLauncherBuf);
				if (ERROR_SUCCESS != iFillStat)
					iStat = iFillStat;
#endif 
				if (plgidLanguage)
					*plgidLanguage = (LANGID)pRec->GetInteger(IxoProductInfo::Language);

				if (pdwVersion)
					*pdwVersion = (DWORD)pRec->GetInteger(IxoProductInfo::Version);
			}
		}
		pError = 0;
		pEnum = 0;
		ENG::FreeServices();
	}
	
MsiGetProductInfoFromScriptEnd:
	CCoUninitialize coUninit(fOLEInitialized);
	DEBUGMSG1 (MSITEXT("MsiGetProductInfoFromScriptEnd is returning %u"), (const DCHAR*)(INT_PTR)iStat);
	return iStat;
}

UINT __stdcall MsiGetProductCodeFromPackageCode(LPCDSTR szPackageCode, // package code
																LPDSTR szProductCode)  // a buffer of size 39 to recieve product code
{
	CForbidTokenChangesDuringCall impForbid;

	size_t cchPackageCodeLen = 0;
	if ( !szPackageCode || !szProductCode ||
		  FAILED(StringCchLength(szPackageCode, cchPackageCode+1, &cchPackageCodeLen)) ||
		  cchPackageCodeLen != cchPackageCode )
		return ERROR_INVALID_PARAMETER;

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		return MsiGetProductCodeFromPackageCodeA(
					CMsInstApiConvertString(szPackageCode),
					CWideToAnsiOutParam(szProductCode, cchProductCode+1));
	}
	else // g_fWin9X == false
	{
#endif // MSIUNICODE
	int iProductIndex = 0;
	DCHAR rgchProductCode[39];
	for(;;)
	{
		UINT uiRes = MsiEnumProducts(iProductIndex++,rgchProductCode);
		if(uiRes == ERROR_SUCCESS)
		{
			DCHAR rgchPackageCode[39];
			DWORD cchPkgCode = 39;
			if((MsiGetProductInfo(rgchProductCode,MSITEXT("PackageCode"),rgchPackageCode,&cchPkgCode)) != ERROR_SUCCESS)
				continue; //!! ignore error?
			
			bool fProductInstance = false;

			DCHAR rgchInstanceType[5]; // buffer should be big enough for all possible cases
			DWORD cchInstanceType = sizeof(rgchInstanceType)/sizeof(DCHAR);
			if ((MsiGetProductInfo(rgchProductCode,MSITEXT("InstanceType"),rgchInstanceType,&cchInstanceType)) == ERROR_SUCCESS)
			{
				fProductInstance = (*rgchInstanceType == '1');
			}
			// else <> ERROR_SUCCESS which is ok since that means we never registered InstanceType and thus default to original behavior
			
			// we ignore all multiple instance specifications (INSTANCETYPE=1) since multiple package codes are registered for same product code
			// this allows MsiGetProductCodeFromPackageCode to work as before
			if(!fProductInstance && lstrcmpi(szPackageCode,rgchPackageCode) == 0)
			{
				// return first one found - even if there are more
				StringCchCopy(szProductCode, cchProductCode+1, rgchProductCode);
				return ERROR_SUCCESS;
			}

		}
		else
			return ERROR_UNKNOWN_PRODUCT; //!! ignore error?
	}
#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif // MSIUNICODE

}

//____________________________________________________________________________
//
// API's that create an engine but do not invoke an install
//____________________________________________________________________________


UINT __stdcall MsiGetProductProperty(MSIHANDLE hProduct, LPCDSTR szProperty,
										LPDSTR lpValueBuf, DWORD *pcchValueBuf)
//----------------------------------------------
{
	if (0 == szProperty || (lpValueBuf && !pcchValueBuf))
		return ERROR_INVALID_PARAMETER;

	CForbidTokenChangesDuringCall impForbid;

	PMsiEngine pEngine = GetEngineFromHandle(hProduct);
	
	if (pEngine == 0)
		return ERROR_INVALID_HANDLE;

	PMsiView pView = 0;
	PMsiRecord pRecord = pEngine->OpenView(TEXT("SELECT `Value` FROM `Property` WHERE `Property` = ?"), ivcFetch, *&pView);
	if (pRecord != 0)
		return ERROR_FUNCTION_FAILED;
	PMsiServices pServices = pEngine->GetServices();
	pRecord = &pServices->CreateRecord(1);
	pRecord->SetString(1, CMsInstApiConvertString(szProperty));
	pRecord = pView->Execute(pRecord);
	pRecord = pView->Fetch();
	MsiString istr;
	if (pRecord != 0)
		istr = pRecord->GetMsiString(1);
	else
		istr = (const ICHAR*)0;
#ifdef MSIUNICODE
	return ::FillBufferW(istr, lpValueBuf, pcchValueBuf);
#else // ANSI
	return ::FillBufferA(istr, lpValueBuf, pcchValueBuf);
#endif
}

UINT __stdcall MsiGetFeatureInfo(
	MSIHANDLE  hProduct,       // product handle obtained from MsiOpenProduct
	LPCDSTR    szFeature,      // feature name
	DWORD      *lpAttributes,  // attribute flags for the feature <to be defined>
	LPDSTR     lpTitleBuf,     // returned localized name, NULL if not desired
	DWORD      *pcchTitleBuf,  // in/out buffer character count
	LPDSTR     lpHelpBuf,      // returned description, NULL if not desired
	DWORD      *pcchHelpBuf)   // in/out buffer character count
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;

	// Validate args
	int cchFeature = 0;
	if (0 == szFeature || ((cchFeature = lstrlen(szFeature)) > cchMaxFeatureName) ||
		(lpTitleBuf && !pcchTitleBuf) || (lpHelpBuf && !pcchHelpBuf) || ((pcchTitleBuf == pcchHelpBuf) && (pcchTitleBuf != 0)))
		return ERROR_INVALID_PARAMETER;

	PMsiEngine pEngine = GetEngineFromHandle(hProduct);
	
	if (pEngine == 0)
		return ERROR_INVALID_HANDLE;

	const GUID IID_IMsiSelectionManager = GUID_IID_IMsiSelectionManager;

	PMsiSelectionManager pSelectionManager(*pEngine, IID_IMsiSelectionManager);
	if ( !pSelectionManager )
	{
		Assert(0);
		return ERROR_INVALID_HANDLE;
	}

	MsiString strTitle;
	MsiString strHelp;
	int iAttributes;
	int iRes = ERROR_UNKNOWN_FEATURE;
	int iFillRes;

#ifdef MSIUNICODE
	if (pSelectionManager->GetFeatureInfo(*MsiString(CMsInstApiConvertString(szFeature)), *&strTitle, *&strHelp, iAttributes))
	{
		iRes = FillBufferW(strTitle, lpTitleBuf, pcchTitleBuf);
		
		if (ERROR_SUCCESS != (iFillRes = FillBufferW(strHelp, lpHelpBuf, pcchHelpBuf)))
			iRes = iFillRes;

		if (lpAttributes)
			*lpAttributes = iAttributes;
	}
#else // ANSI
	if (pSelectionManager->GetFeatureInfo(*MsiString(CMsInstApiConvertString(szFeature)), *&strTitle, *&strHelp, iAttributes))
	{
		iRes = FillBufferA(strTitle, lpTitleBuf, pcchTitleBuf);
		if (ERROR_SUCCESS != (iFillRes = FillBufferA(strHelp, lpHelpBuf, pcchHelpBuf)))
			iRes = iFillRes;

		if (lpAttributes)
			*lpAttributes = iAttributes;
	}
#endif // MSIUNICODE-ANSI

	return iRes;
}

UINT __stdcall MsiOpenPackage(LPCDSTR szPackagePath, MSIHANDLE *hProduct)
//----------------------------------------------
{
	DEBUGMSG2(MSITEXT("Entering MsiOpenPackage. szPackagePath: %s, hProduct: %X"), szPackagePath ? szPackagePath : MSITEXT("(null)"), (const DCHAR*)hProduct);

	UINT uiRet = MsiOpenPackageEx(szPackagePath, /* dwOptions = */ 0, hProduct);

	DEBUGMSG1(MSITEXT("MsiOpenPackage is returning %d"), (const DCHAR*)(INT_PTR)uiRet);

	return uiRet;
}

UINT __stdcall MsiOpenPackageEx(LPCDSTR szPackagePath, DWORD dwOptions, MSIHANDLE *hProduct)
//----------------------------------------------
{
	DEBUGMSG3(MSITEXT("Entering MsiOpenPackageEx. szPackagePath: %s, dwOptions: %d, hProduct: %X"), szPackagePath ? szPackagePath : MSITEXT("(null)"),
				(const DCHAR*)(INT_PTR)dwOptions, (const DCHAR*)hProduct);

	DWORD dwValidFlags = MSIOPENPACKAGEFLAGS_IGNOREMACHINESTATE;
	if (0 == szPackagePath || 0 == hProduct || (dwOptions & (~dwValidFlags)))
		return ERROR_INVALID_PARAMETER;

	CForbidTokenChangesDuringCall impForbid;

	IMsiEngine* piEngine = NULL;
	unsigned int uiRet;
	iuiEnum iuiLevel = g_message.m_iuiLevel;
	if (g_message.m_iuiLevel == iuiDefault)
		iuiLevel = iuiBasic;  //!! is this correct default for programmatic access?

	if (g_message.m_fNoModalDialogs)
		iuiLevel = iuiEnum((int)iuiLevel | iuiNoModalDialogs);
	
	if (g_message.m_fHideCancel)
		iuiLevel = (iuiEnum)((int)iuiLevel | iuiHideCancel);

	iioEnum iioOptions = iioDisablePlatformValidation;
	bool fIgnoreSAFER = false;
	if (dwOptions & MSIOPENPACKAGEFLAGS_IGNOREMACHINESTATE)
	{
		iioOptions = iioEnum(iioOptions | iioRestrictedEngine);
		// restricted engine does not incur SAFER check since it cannot modify machine state
		fIgnoreSAFER = true;
	}

	if (szPackagePath[0] == '#')   // database handle passed in
	{
		int ch;
		MSIHANDLE hDatabase = 0;
		PMsiDatabase pDatabase(0);
		size_t cchMaxUintLong = 10;  // length of ULONG_MAX (= 4294967295)
		while ((ch = *(++szPackagePath)) != 0)
		{
			if (ch < '0' || ch > '9' || !cchMaxUintLong--)
			{
				hDatabase = 0;
				break;
			}
			hDatabase = hDatabase * 10 + (ch - '0');
		}
		pDatabase = (IMsiDatabase*)FindMsiHandle(hDatabase, iidMsiDatabase);
		if (pDatabase == 0)
			uiRet = ERROR_INVALID_HANDLE;
		else if (NOERROR == (uiRet = g_MessageContext.Initialize(fTrue, iuiLevel)))
		{
			// SAFER for handles is handled by CreateInitializedEngine; hSaferLevel = 0 in this case
			if (ERROR_SUCCESS != (uiRet = CreateInitializedEngine(0, 0, 0, FALSE, iuiLevel, 0, pDatabase, 0,
																	iioOptions, piEngine, /* hSaferLevel = */ 0)))
				g_MessageContext.Terminate(false);
		}
	}
	else
	{
		if (NOERROR == (uiRet = g_MessageContext.Initialize(fTrue, iuiLevel))) // engine must run in main thread to allow access, UI in child thread
		{
			// perform SAFER check for package path
			// want to avoid security scenario where MsiOpenPackage is called to get an engine and then we start
			// performing installation actions (like MsiDoAction, etc.)
			SAFER_LEVEL_HANDLE hSaferLevel = 0;
			if (*szPackagePath != 0)
			{
				IMsiServices *piServices = ENG::LoadServices();
				if (!piServices)
				{
					g_MessageContext.Terminate(false);
					DEBUGMSG1(MSITEXT("MsiOpenPackageEx is returning %d. Unable to load services."), (const DCHAR*)(INT_PTR)ERROR_FUNCTION_FAILED);
					return ERROR_FUNCTION_FAILED;
				}
				if (!fIgnoreSAFER)
				{
					PMsiStorage pStorage(0);
					if (ERROR_SUCCESS != (uiRet = OpenAndValidateMsiStorage(CMsInstApiConvertString(szPackagePath), stDatabase, *piServices, *&pStorage, /* fCallSAFER = */ true, CMsInstApiConvertString(szPackagePath), &hSaferLevel)))
					{
						g_MessageContext.Terminate(false);
						ENG::FreeServices();
						DEBUGMSG1(MSITEXT("MsiOpenPackageEx is returning %d."), (const DCHAR*)(INT_PTR)uiRet);
						return uiRet;
					}
				}
				ENG::FreeServices();
			}
			
			if (ERROR_SUCCESS != (uiRet = CreateInitializedEngine(CMsInstApiConvertString(szPackagePath), 0, 0, FALSE, iuiLevel, 0, 0, 0,
																	iioOptions, piEngine, hSaferLevel)))
			{
				g_MessageContext.Terminate(false);
			}
		}
	}
	if (ERROR_SUCCESS == uiRet)
	{
		*hProduct = CreateMsiProductHandle(piEngine);
		if (!*hProduct)
		{
			uiRet = ERROR_INSTALL_FAILURE;
			piEngine->Release();
		}
	}

	DEBUGMSG1(MSITEXT("MsiOpenPackageEx is returning %d"), (const DCHAR*)(INT_PTR)uiRet);

	return uiRet;
}

extern "C"
UINT __stdcall MsiOpenProduct(LPCDSTR szProduct, MSIHANDLE *hProduct)
//----------------------------------------------
{
	if (0 == szProduct || cchProductCode != lstrlen(szProduct) || 
		 !hProduct)
		return ERROR_INVALID_PARAMETER;;

	CForbidTokenChangesDuringCall impForbid;

	CAPITempBuffer<char, 1> rgchPackagePath;
	if (!rgchPackagePath.SetSize(cchExpectedMaxPath + 1))
		return ERROR_OUTOFMEMORY;
	plEnum plPackageLocation = plAny;
	UINT uiRet = GetPackageFullPath(CApiConvertString(szProduct), rgchPackagePath, plPackageLocation, fFalse);

	if (ERROR_SUCCESS != uiRet)
		return uiRet;

	return MsiOpenPackageA(rgchPackagePath, hProduct);
}

//____________________________________________________________________________
//
// API's that do not create an engine
//____________________________________________________________________________

UINT __stdcall MsiGetFileVersion(LPCDSTR szFilePath,
								LPDSTR lpVersionBuf,
								DWORD *pcchVersionBuf,
								LPDSTR lpLangBuf,
								DWORD *pcchLangBuf)
//----------------------------------------------
{
	if (0 == szFilePath || (lpVersionBuf && !pcchVersionBuf) ||
					(lpLangBuf && !pcchLangBuf))
		return ERROR_INVALID_PARAMETER;

	CForbidTokenChangesDuringCall impForbid;

	ifiEnum ifiRet;
	DWORD dwMS, dwLS;
	unsigned short rgwLangID[cLangArrSize];
	int iExistLangCount;

	UINT iCurrMode = WIN::SetErrorMode(SEM_FAILCRITICALERRORS);
	ifiRet = GetAllFileVersionInfo(CMsInstApiConvertString(szFilePath), &dwMS, &dwLS, rgwLangID, cLangArrSize, &iExistLangCount, fFalse);
	WIN::SetErrorMode(iCurrMode);

	switch (ifiRet)
	{
		case ifiNoError:
			break;
		case ifiNoFile :
			return ERROR_FILE_NOT_FOUND;
		case ifiFileInUseError :
		case ifiAccessDenied :
			return ERROR_ACCESS_DENIED;
		case ifiNoFileInfo :
			return ERROR_FILE_INVALID;
		case ifiFileInfoError :
			return ERROR_INVALID_DATA;
		default:
			AssertSz(fFalse, "Unexpected return from GetAllFileVersionInfo");
			return E_FAIL;
	}
	ICHAR szVersion[3 + cchMaxIntLength * 4 + 1];
	unsigned int cch;
	DWORD dw1 = ERROR_SUCCESS;
	DWORD dw2 = ERROR_SUCCESS;
	
	if (pcchVersionBuf)
	{
#ifdef UNICODE
		StringCbPrintfW(szVersion, sizeof(szVersion), TEXT("%d.%d.%d.%d"), dwMS >> 16, dwMS & 0xFFFF, dwLS>>16, dwLS & 0xFFFF);
#else
		StringCbPrintfA(szVersion, sizeof(szVersion), TEXT("%d.%d.%d.%d"), dwMS >> 16, dwMS & 0xFFFF, dwLS>>16, dwLS & 0xFFFF);
#endif
#ifdef MSIUNICODE
		dw1 = FillBufferW((const ICHAR *)szVersion, lstrlenW(szVersion), lpVersionBuf, pcchVersionBuf);
#else
		dw1 = FillBufferA((const ICHAR *)szVersion, lstrlenW(szVersion), lpVersionBuf, pcchVersionBuf);
#endif //MSIUNICODE
	}
	if (pcchLangBuf)
	{
		CAPITempBuffer<ICHAR, 256> rgchLangID;

		if (iExistLangCount > 0)
			rgchLangID.SetSize(iExistLangCount * (cchMaxIntLength + 1) + 1);
		cch = 0;

		while (iExistLangCount-- > 0)
		{
			if (cch != 0)
				rgchLangID[cch++]=',';
			cch += ltostr(&rgchLangID[cch], rgwLangID[iExistLangCount]);
		}
		rgchLangID[cch] = 0;
	
#ifdef MSIUNICODE
		dw2 = FillBufferW((const ICHAR *)rgchLangID, cch, lpLangBuf, pcchLangBuf);
#else
		dw2 = FillBufferA((const ICHAR *)rgchLangID, cch, lpLangBuf, pcchLangBuf);
#endif //MSIUNICODE


	}

	if (dw1 != ERROR_SUCCESS)
		return dw1;
		
	return dw2;
}


UINT __stdcall MsiGetFileHash(LPCDSTR szFilePath,
								DWORD dwOptions,
								PMSIFILEHASHINFO pHash)
//----------------------------------------------
{
	if (0 == szFilePath || dwOptions != 0 ||
		 0 == pHash || pHash->dwFileHashInfoSize != sizeof(MSIFILEHASHINFO))
		return ERROR_INVALID_PARAMETER;

	CForbidTokenChangesDuringCall impForbid;

	return GetMD5HashFromFile(CMsInstApiConvertString(szFilePath),
									  pHash->dwData,
									  fFalse,
									  0);
}

//______________________________________________________________________________
//
//  MsiGetFileSignatureInformation
//______________________________________________________________________________

HRESULT __stdcall MsiGetFileSignatureInformation(LPCDSTR szFilePath, DWORD dwFlags, PCCERT_CONTEXT *ppcCertContext, BYTE *pbHash, DWORD *pcbHash)
{
	DEBUGMSG5(MSITEXT("Entering MsiGetFileSignatureInformation. szFilePath: %s, dwFlags: %d, ppcCertContext: %X, pbHash: %X, pcbHash: %X"), 
		szFilePath ? szFilePath : MSITEXT("(null)"), 
		(const DCHAR*)(INT_PTR)dwFlags, 
		(const DCHAR*)ppcCertContext, 
		(const DCHAR*)pbHash,
		(const DCHAR*)pcbHash);

	DWORD dwValidFlags = MSI_INVALID_HASH_IS_FATAL;
	if (0 == szFilePath || 0 == ppcCertContext || (pbHash && !pcbHash) || (dwFlags & (~dwValidFlags)))
		return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

	CForbidTokenChangesDuringCall impForbid;

	HRESULT hr = GetFileSignatureInformation(CMsInstApiConvertString(szFilePath), dwFlags, ppcCertContext, pbHash, pcbHash);

	DEBUGMSG1(MSITEXT("MsiGetFileSignatureInformation is returning: 0x%X"), (const DCHAR*)(INT_PTR)hr);

	return hr;
}

//______________________________________________________________________________
//
//  MsiLoadString - language specific, returns codepage of string
//______________________________________________________________________________

UINT __stdcall MsiLoadString(HINSTANCE hInstance, UINT uID, LPDSTR lpBuffer, int nBufferMax, WORD wLanguage)
{
	CForbidTokenChangesDuringCall impForbid;

	HRSRC   hRsrc;
	HGLOBAL hGlobal;
	WCHAR* pch;
	if (hInstance == (HINSTANCE)-1)
		hInstance = g_hInstance;
	if (lpBuffer == 0 || nBufferMax <= 0)
		return 0;
	int iRetry = (wLanguage == 0) ? 1: 0; // no language, can't let FindResource search, we won't know what codepage to use
	for (;;)  // first try requested language, then follow system search order
	{
		if ( !MsiSwitchLanguage(iRetry, wLanguage) )
			return 0;
		if ((hRsrc = FindResourceEx(hInstance, RT_STRING, MAKEINTRESOURCE(uID/16+1), wLanguage)) != 0
		 && (hGlobal = LoadResource(hInstance, hRsrc)) != 0
		 && (pch = (WCHAR*)LockResource(hGlobal)) != 0)
		{
			int cch;
			for (int iCnt = uID % 16; cch = *pch++, iCnt--; pch += cch)
				;
			if (cch)
			{
				unsigned int iCodePage = MsiGetCodepage(wLanguage);
#ifdef MSIUNICODE
				if (cch >= nBufferMax)  // truncate, just like LoadString does
					cch = nBufferMax - 1;
				memcpy(lpBuffer, pch, cch * sizeof(WCHAR));
				lpBuffer[cch] = 0;
#else
				cch = WIN::WideCharToMultiByte(iCodePage, 0, pch, cch, lpBuffer, nBufferMax-1, 0, 0);
				lpBuffer[cch] = 0;
#endif
				return iCodePage;
			}
		}
	}
}

//______________________________________________________________________________
//
//  MsiMessageBox replacement that supports non-system codepages.
//   Ignores MB_APPMODAL, MB_TASKMODAL, and MB_SYSTEMMODAL flags.
//______________________________________________________________________________

#define MB_ICONWINDOWS 0x50  // not standard message box icon type, but avaiable from user32

int __stdcall MsiMessageBox(HWND hWnd, LPCDSTR szText, LPCDSTR szCaption, UINT uiType, UINT uiCodepage, WORD iLangId)
{
	int id1, id2, id3, iBtnEsc, iBtnDef, idIcon;
	switch (uiType & MB_TYPEMASK)
	{
		default: Assert(0); // fall through
		case MB_OK:               iBtnEsc = 1; id1 = IDOK;    id2 = -1;      id3 = -1;       break;
		case MB_ABORTRETRYIGNORE: iBtnEsc = 0; id1 = IDABORT; id2 = IDRETRY; id3 = IDIGNORE; break;
		case MB_OKCANCEL:         iBtnEsc = 2; id1 = IDOK;    id2 = IDCANCEL;id3 = -1;       break;
		case MB_RETRYCANCEL:	  iBtnEsc = 2; id1 = IDRETRY; id2 = IDCANCEL;id3 = -1;       break;
		case MB_YESNO:            iBtnEsc = 0; id1 = IDYES;   id2 = IDNO;    id3 = -1;       break;  
		case MB_YESNOCANCEL:      iBtnEsc = 3; id1 = IDYES;   id2 = IDNO;    id3 = IDCANCEL; break; 
	}
	switch (uiType & MB_DEFMASK)
	{
		default:            iBtnDef = 0; break;
		case MB_DEFBUTTON1: iBtnDef = 1; break;
		case MB_DEFBUTTON2: iBtnDef = 2; break;
		case MB_DEFBUTTON3: iBtnDef = 3; break;
	}
	switch (uiType & MB_ICONMASK)
	{
		case MB_ICONSTOP:        idIcon = IDI_SYS_STOP;        break;
		case MB_ICONQUESTION:    idIcon = IDI_SYS_QUESTION;    break;
		case MB_ICONEXCLAMATION: idIcon = IDI_SYS_EXCLAMATION; break;
		case MB_ICONINFORMATION: idIcon = IDI_SYS_INFORMATION; break;
		case MB_ICONWINDOWS:     idIcon = IDI_SYS_WINDOWS;     break;
		default:                 idIcon = 0;                   break;
	}
	CMsiMessageBox msgbox(CMsInstApiConvertString(szText), CMsInstApiConvertString(szCaption), iBtnDef, iBtnEsc, id1, id2, id3, uiCodepage, iLangId);
	int iDlg = IDD_MSGBOX;
	// if on Win2K or greater and Arabic or Hebrew, then use mirrored dialog
	if (MinimumPlatformWindows2000() && (uiCodepage == 1255 || uiCodepage == 1256))
		iDlg = (uiType & MB_ICONMASK) ? IDD_MSGBOXMIRRORED : IDD_MSGBOXNOICONMIRRORED;
	else
		iDlg = (uiType & MB_ICONMASK) ? IDD_MSGBOX : IDD_MSGBOXNOICON;
	return msgbox.Execute(hWnd, iDlg, idIcon);
}

//______________________________________________________________________________


#ifndef MSIUNICODE

void EnumEntityList::RemoveThreadInfo()
{
	unsigned int c = FindEntry();
	Assert(c);

	if (c)
	{
		m_rgEnumList[c-1].SetThreadId(0);
	}
}

unsigned int EnumEntityList::FindEntry()
{
	// see whether this thread is in our list
	
	DWORD dwThreadId = MsiGetCurrentThreadId();
	for (int c=0; c < m_cEntries; c++)
	{
		if (m_rgEnumList[c].GetThreadId() == dwThreadId)
			return c+1;
	}
	return 0;
}

bool EnumEntityList::GetInfo(unsigned int& uiKey, unsigned int& uiOffset, int& iPrevIndex, const char** szComponent, const WCHAR** szwComponent)
{
	int c = FindEntry();

	if (c)
	{
		uiKey      = m_rgEnumList[c-1].GetKey();
		uiOffset   = m_rgEnumList[c-1].GetOffset();
		iPrevIndex = m_rgEnumList[c-1].GetPrevIndex();

		if (szComponent)
			*szComponent  = m_rgEnumList[c-1].GetComponentA();

		if (szwComponent)
			*szwComponent = m_rgEnumList[c-1].GetComponentW();
		return true;
	}

	return false;
}

bool EnumEntityList::SetInfo(unsigned int uiKey, unsigned int uiOffset, int iPrevIndex, const WCHAR* szComponent)
{
	return SetInfo(uiKey, uiOffset, iPrevIndex, 0, szComponent);
}

bool EnumEntityList::SetInfo(unsigned int uiKey, unsigned int uiOffset, int iPrevIndex, const char* szComponent=0, const WCHAR* szwComponent=0)
{
	int c = FindEntry();
	bool fReturn = true;

	if (c)
	{
		m_rgEnumList[c-1].SetKey(uiKey);
		m_rgEnumList[c-1].SetOffset(uiOffset);
		m_rgEnumList[c-1].SetPrevIndex(iPrevIndex);
		m_rgEnumList[c-1].SetComponent(szComponent);
		m_rgEnumList[c-1].SetComponent(szwComponent);
		return fReturn;
	}

	// thread's not in our list; need to add it

	// acquire the lock

	while (TestAndSet(&m_iLock) == true)
	{
		Sleep(500);
	}

	unsigned int cNewEntry = m_cEntries + 1;
	unsigned int cEntries  = m_cEntries + 1;
	if (cNewEntry > m_rgEnumList.GetSize())
	{
		// if we've reached our max threads, look for a empty
		// spot before increasing our buffer

		bool fFoundSpot = false;
		for (int c = 1; c <= m_cEntries-1; c++)
		{
			if (m_rgEnumList[c-1].GetThreadId() == 0)
			{
				fFoundSpot = true;
				cNewEntry  = c;
				cEntries--;
				break;
			}
		}

		if (!fFoundSpot)
		{
			if ( !m_rgEnumList.Resize(m_cEntries + 10) )
			{
				// this indicates that the memory allocation in Resize failed,
				// so we must not attempt the assignements below.
				Assert(false);
				fReturn = false;
				goto Return;
			}
		}
	}

	
	m_rgEnumList[cNewEntry-1].SetKey(uiKey);
	m_rgEnumList[cNewEntry-1].SetOffset(uiOffset);
	m_rgEnumList[cNewEntry-1].SetPrevIndex(iPrevIndex);
	m_rgEnumList[cNewEntry-1].SetThreadId(MsiGetCurrentThreadId());
	m_rgEnumList[cNewEntry-1].SetComponent(szComponent);
	m_rgEnumList[cNewEntry-1].SetComponent(szwComponent);

	m_cEntries = cEntries; // set this _after_ we've populated the new entry

Return:	
	// release the lock

	m_iLock = 0;
	return fReturn;
}	

EnumEntityList g_EnumProducts;
EnumEntityList g_EnumComponentQualifiers;
EnumEntityList g_EnumComponents;
EnumEntityList g_EnumComponentClients;
EnumEntityList g_EnumAssemblies;
EnumEntityList g_EnumComponentAllClients;
#endif



// FN: enums the HKLM\S\M\W\CV\Installer\UserData\<user id>\Components components key
// Used by the enumeration routine
inline DWORD OpenInstalledComponentKeyForEnumeration(unsigned int uiKey, LPCDSTR szComponent, CRegHandle& rhKey)
{
	iaaAppAssignment iaaAsgnType;
	if(0 == uiKey)
		iaaAsgnType = iaaUserAssign;
	else if(!g_fWin9X && 1 == uiKey) // can have only one type of installations on Win9X
		iaaAsgnType = iaaMachineAssign;
	else
		return ERROR_NO_MORE_ITEMS;

	DCHAR szComponentSQUID[cchGUIDPacked + 1];
	if(szComponent && (lstrlen(szComponent) != cchGUID || !PackGUID(szComponent, szComponentSQUID)))
		return ERROR_INVALID_PARAMETER;

	return OpenSpecificInstalledComponentKey(iaaAsgnType, szComponent ? szComponentSQUID : 0, rhKey, false);
}

// returns the SID of uiIndex-th user that has apps installed.
//
// FUNCTION REQUIREMENT: szUserSID must be able to accomodate cchMaxSID chars,
// so don't pass in mere pointers.

DWORD EnumInstalledUsers(unsigned int uiIndex, LPDSTR szUserSID, DWORD cbUserSIDSize)
{
	if ( g_fWin9X )
	{
		if (uiIndex == 0)
		{
			*szUserSID = 0;
			return ERROR_SUCCESS;
		}
		else
			return ERROR_NO_MORE_ITEMS;
	}

	CRegHandle HUserData;
	// getting to the uiIndex-th user in HKLM\S\M\W\CV\Installer\UserData key
	DWORD dwResult = MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE, CMsInstApiConvertString(szMsiUserDataKey), 0, g_samRead, &HUserData);
	if ( dwResult == ERROR_FILE_NOT_FOUND )
		return ERROR_NO_MORE_ITEMS;
	if ( dwResult != ERROR_SUCCESS )
		return dwResult;
	
	DCHAR szSID[cchMaxSID+1];
	DWORD cchSID = cchMaxSID+1;
	dwResult = RegEnumKeyEx(HUserData, uiIndex, szSID, &cchSID, 0, 0, 0, 0);
	if ( dwResult == ERROR_FILE_NOT_FOUND )
		return ERROR_NO_MORE_ITEMS; // just making doubly sure we dont ever cause the caller to loop forever
	if ( dwResult != ERROR_SUCCESS )
		return dwResult;

	StringCbCopy(szUserSID, cbUserSIDSize, szSID);
	return ERROR_SUCCESS;
}

DWORD OpenEnumedUserInstalledKeyPacked(unsigned int uiUser,
											  LPCDSTR szWhichSubKey,
											  LPCDSTR szItemSQUID,
											  CRegHandle& rhKey)

{
	if ( !szWhichSubKey )
		// we wouldn't get far anyways, and we even cause an AV in the string copy.
		return ERROR_INVALID_PARAMETER;
	
	DCHAR szSID[cchMaxSID+1];
	DWORD dwResult = EnumInstalledUsers(uiUser, szSID, sizeof(szSID));
	Assert(dwResult != ERROR_FILE_NOT_FOUND);
	if ( dwResult != ERROR_SUCCESS )
		return dwResult;

	CAPITempBuffer<DCHAR, 1> rgchSubKey;
	if (!rgchSubKey.SetSize(MAX_PATH))
		return ERROR_OUTOFMEMORY;
	
	if ( szItemSQUID )
		dwResult = StringCchPrintf(rgchSubKey, rgchSubKey.GetSize(), MSITEXT("%s\\%s"), szWhichSubKey, szItemSQUID);
	else
		dwResult = StringCchCopy(rgchSubKey, rgchSubKey.GetSize(), szWhichSubKey);
	if (FAILED(dwResult))
		return ERROR_FUNCTION_FAILED;
	return OpenInstalledUserDataSubKeyPacked(szSID, 0, rgchSubKey, rhKey, false, g_samRead);
}

DWORD OpenEnumedUserInstalledComponentKeyPacked(
										unsigned int uiUser,
										LPCDSTR szComponentSQUID,
										CRegHandle& rhKey)
{
	return OpenEnumedUserInstalledKeyPacked(uiUser,
													szGPTComponentsKey,
													szComponentSQUID,
													rhKey);
}

// FN: opens the HKLM\S\M\W\CV\Installer\UserData\<user id>\Components\szComponent key
// for the uiUser-th user.
// Used by the enumeration routine
DWORD OpenEnumedUserInstalledComponentKey(unsigned int uiUser,
												  LPCDSTR szComponent,
												  CRegHandle& rhKey)
{
	DCHAR szComponentSQUID[cchGUIDPacked + 1];
	if(szComponent && (lstrlen(szComponent) != cchGUID || !PackGUID(szComponent, szComponentSQUID)))
		return ERROR_INVALID_PARAMETER;

	return OpenEnumedUserInstalledComponentKeyPacked(uiUser,
											szComponent ? szComponentSQUID : 0,
											rhKey);
}

DWORD OpenEnumedUserInstalledProductInstallPropertiesKeyPacked(
										unsigned int uiUser,
										LPCDSTR szProductSQUID,
										CRegHandle& rhKey)
{
	if ( !szProductSQUID )
		return ERROR_INVALID_PARAMETER;

	CAPITempBuffer<DCHAR, 1> rgchSubKey;
	if (!rgchSubKey.SetSize(MAX_PATH))
		return ERROR_OUTOFMEMORY;
	
	if (FAILED(StringCchPrintf(rgchSubKey, rgchSubKey.GetSize(), MSITEXT("%s\\%s\\%s"), szMsiProductsSubKey, szProductSQUID, szMsiInstallPropertiesSubKey)))
		return ERROR_FUNCTION_FAILED;

	return OpenEnumedUserInstalledKeyPacked(uiUser,
													rgchSubKey,
													NULL,
													rhKey);
}

// FN: opens the HKLM\S\M\W\CV\Installer\UserData\<user id>\Products\szProduct\InstallProperties
// key for the uiUser-th user.
// Used by the enumeration routine
DWORD OpenEnumedUserInstalledProductInstallPropertiesKey(unsigned int uiUser,
															LPCDSTR szProduct,
															CRegHandle& rhKey)
{
	DCHAR szProductSQUID[cchGUIDPacked + 1];
	if( !szProduct || lstrlen(szProduct) != cchGUID || !PackGUID(szProduct, szProductSQUID) )
		return ERROR_INVALID_PARAMETER;

	return OpenEnumedUserInstalledProductInstallPropertiesKeyPacked(uiUser,
															szProductSQUID,
															rhKey);
}


UINT EnumInfo(DWORD iIndex, LPDSTR lpOutBuf, eetEnumerationType enumType, LPCDSTR szKeyGUID = 0)
// If an upgrade code is passed in then we'll look for products as value names
// under the UpgradeCodes key. Otherwise we'll look for products as key names
// under the Products key.
{
	unsigned int uiKey    =  0;
	unsigned int uiOffset =  0;
	int iPrevIndex        = -1;

	EnumEntityList* pEnumEntityList = NULL;

	Assert(lpOutBuf);

	switch(enumType)
	{
	case eetProducts:
	case eetUpgradeCode:		
		pEnumEntityList = &g_EnumProducts;
		break;
	case eetComponents:
		pEnumEntityList = &g_EnumComponents;
		break;
	case eetComponentClients:
		pEnumEntityList = &g_EnumComponentClients;
		break;
	case eetComponentAllClients:
		if ( !szKeyGUID )
			return ERROR_INVALID_PARAMETER;
		pEnumEntityList = &g_EnumComponentAllClients;
		break;
	}
	pEnumEntityList->GetInfo(uiKey, uiOffset, iPrevIndex);

	if (++iPrevIndex != iIndex) // if we receive an unexpected index then we start afresh
	{
		// we can't handle an unexpected index other than 0

		if (iIndex != 0)
			return ERROR_INVALID_PARAMETER;

		uiKey    = 0;
		uiOffset = 0;
		iPrevIndex = iIndex;
	}

	CRegHandle HKey;
	
	UINT uiFinalRes = ERROR_SUCCESS;

	while (ERROR_SUCCESS == uiFinalRes)
	{
		// iterate through all possible loacations, starting with uiKey, until we 
		// find a key that exists or we get an error

		for (;;)
		{
			switch(enumType)
			{
			case eetProducts:
				uiFinalRes = OpenAdvertisedProductsKeyPacked(uiKey, HKey, false);
				break;
			case eetUpgradeCode:
				uiFinalRes = OpenAdvertisedUpgradeCodeKey(uiKey, szKeyGUID, HKey, false);
				break;
			case eetComponents:
			case eetComponentClients:
				uiFinalRes = OpenInstalledComponentKeyForEnumeration(uiKey, szKeyGUID, HKey);
				break;
			case eetComponentAllClients:
				uiFinalRes = OpenEnumedUserInstalledComponentKey(uiKey, szKeyGUID, HKey);
				break;
			}
			if (ERROR_FILE_NOT_FOUND != uiFinalRes)
				break;
			
			uiKey++;
		}
		
		if (ERROR_SUCCESS != uiFinalRes)
			break;

		DCHAR szNameSQUID[cchGUIDPacked + 1];
		DWORD cchName = cchGUIDPacked + 1;

		LONG lResult = ERROR_FUNCTION_FAILED;
		
		switch(enumType)
		{
			case eetProducts:
			case eetComponents:
			lResult = RegEnumKeyEx(HKey, uiOffset, szNameSQUID, &cchName, 0, 0, 0, 0);
				break;
			case eetComponentClients:
			case eetUpgradeCode:
			case eetComponentAllClients:
				lResult = RegEnumValue(HKey, uiOffset, szNameSQUID, &cchName, 0, 0, 0, 0);
				break;
		}

		if (ERROR_SUCCESS == lResult)
		{
			// we've found the information in the current key. now we need to make sure that 
			// the information isn't in any of the higher priority keys. if it is then we
			// ignore this info, as it's effectively masked by the higher priority key

			uiOffset++;

			if((cchName != cchGUIDPacked) || !UnpackGUID(szNameSQUID, lpOutBuf))
				uiFinalRes = ERROR_BAD_CONFIGURATION; // messed up registration
			else
			{
				bool fFound = false;
				unsigned int uiPrevKey = 0;			//--merced: changed int to unsigned int
				for (; uiPrevKey < uiKey && !fFound; uiPrevKey++)
				{
					CRegHandle HKey;
					UINT ui = ERROR_FUNCTION_FAILED;

					switch(enumType)
					{
					case eetProducts:
						ui = OpenAdvertisedProductsKeyPacked(uiPrevKey, HKey, false);
						break;
					case eetUpgradeCode:
						ui = OpenAdvertisedUpgradeCodeKey(uiPrevKey, szKeyGUID, HKey, false);
						break;
					case eetComponents:
					case eetComponentClients:
						ui = OpenInstalledComponentKeyForEnumeration(uiPrevKey, szKeyGUID, HKey);
						break;
					case eetComponentAllClients:
						ui = OpenEnumedUserInstalledComponentKey(uiPrevKey, szKeyGUID, HKey);
						break;
					}

					if (ui != ERROR_SUCCESS)
						continue;
					
					switch(enumType)
					{
					case eetProducts:
					case eetComponents:
					{
						CRegHandle HSubKey;
						if (ERROR_SUCCESS == MsiRegOpen64bitKey(HKey, CMsInstApiConvertString(szNameSQUID), 0, g_samRead, &HSubKey))
							fFound = true;
						break;
					}
					case eetComponentClients:
					case eetUpgradeCode:
					case eetComponentAllClients:
						if (ERROR_SUCCESS == RegQueryValueEx(HKey, szNameSQUID, 0, 0, 0, 0))
							fFound = true;
						break;
					}
				}
			
				if (!fFound)
				{
					// the info wasn't found in a higher priority key. we can return it.
					uiFinalRes = ERROR_SUCCESS;
					break;
				}
			}
		}
		else if(ERROR_NO_MORE_ITEMS == lResult)
		{
			// we've run out of items in the current products key. time to move on to the next one.

			uiKey++;
			uiOffset = 0;
		}
		else if(ERROR_MORE_DATA == lResult)
		{
			// the registry is messed up
			uiOffset++; // make sure we skip this entry the next time around
			uiFinalRes = ERROR_BAD_CONFIGURATION;
		}
		else
			return lResult;
	}

	if (ERROR_NO_MORE_ITEMS == uiFinalRes)
	{
		// if we're all out of info and we've added this thread to the list, then we remove this thread from our list
		if (iIndex != 0)
			pEnumEntityList->RemoveThreadInfo();
	}
	else if ( !pEnumEntityList->SetInfo(uiKey, uiOffset, iPrevIndex) )
	{
		uiFinalRes = ERROR_NOT_ENOUGH_MEMORY;
	}
	return uiFinalRes;
}







extern "C"
UINT __stdcall MsiEnumRelatedProducts(
	LPCDSTR  lpUpgradeCode,
	DWORD     dwReserved,       // reserved, must be 0
	DWORD    iProductIndex,    // 0-based index into registered products
	LPDSTR   lpProductBuf)     // buffer of char count: 39 (size of string GUID)
{
	size_t cchUpgradeCode = 0;
	if (!lpProductBuf || !lpUpgradeCode || (dwReserved != 0) ||
		 FAILED(StringCchLength(lpUpgradeCode, cchGUID+1, &cchUpgradeCode)) ||
		 cchUpgradeCode != cchGUID)
		return ERROR_INVALID_PARAMETER;

	CForbidTokenChangesDuringCall impForbid;

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		return MsiEnumRelatedProductsA(
					CApiConvertString(lpUpgradeCode),
					0,
					iProductIndex, 
					CWideToAnsiOutParam(lpProductBuf, cchProductCode+1));
	}
	else // g_fWin9X == false
	{
#endif // MSIUNICODE
		return EnumInfo(iProductIndex, lpProductBuf, eetUpgradeCode, lpUpgradeCode);
#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif // MSIUNICODE
}

extern "C"
UINT __stdcall MsiEnumProducts(
	DWORD    iProductIndex,    // 0-based index into registered products
	LPDSTR   lpProductBuf)     // buffer of char count: 39 (size of string GUID)
{
	if (!lpProductBuf)
		return ERROR_INVALID_PARAMETER;

	CForbidTokenChangesDuringCall impForbid;

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		return MsiEnumProductsA(iProductIndex, 
					CWideToAnsiOutParam(lpProductBuf, cchProductCode+1));
	}
	else // g_fWin9X == false
	{
#endif // MSIUNICODE

		return EnumInfo(iProductIndex, lpProductBuf, eetProducts);

#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif // MSIUNICODE
}


extern "C"
UINT __stdcall MsiEnumClients(const DCHAR* szComponent, 
							  DWORD iProductIndex,
							  DCHAR* lpProductBuf)
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		return MsiEnumClientsA(
			CApiConvertString(szComponent),
			iProductIndex,
			CWideToAnsiOutParam(lpProductBuf, cchProductCode+1));

	}
	
#endif // MSIUNICODE

		if (!szComponent || !lpProductBuf || (cchComponentId != lstrlen(szComponent)))
			return ERROR_INVALID_PARAMETER; //!! should we support NULL lpProductBuf?

		DWORD dwResult = EnumInfo(iProductIndex, lpProductBuf, eetComponentClients, szComponent);
		if(!iProductIndex && ERROR_NO_MORE_ITEMS == dwResult)
			return ERROR_UNKNOWN_COMPONENT; // the component is not present on the machine for this user
		return dwResult;
}

UINT EnumAllClients(const DCHAR* szComponent, 
						  DWORD iProductIndex,
						  DCHAR* lpProductBuf)
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		return EnumAllClientsA(
						CApiConvertString(szComponent),
						iProductIndex,
						CWideToAnsiOutParam(lpProductBuf, cchProductCode+1));

	}
	
#endif // MSIUNICODE

	if (!szComponent || !lpProductBuf || (cchComponentId != lstrlen(szComponent)))
		return ERROR_INVALID_PARAMETER; //!! should we support NULL lpProductBuf?

	DWORD dwResult = EnumInfo(iProductIndex, lpProductBuf, eetComponentAllClients, szComponent);
	if(!iProductIndex && ERROR_NO_MORE_ITEMS == dwResult)
		return ERROR_UNKNOWN_COMPONENT; // the component is not present on the machine for this user
	return dwResult;
}

extern "C"
UINT __stdcall MsiEnumComponents(
	DWORD   iComponentIndex,  // 0-based index into installed components
	LPDSTR  lpComponentBuf)   // buffer of char count: cchMaxFeatureName 
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;

	if (!lpComponentBuf)
		return ERROR_INVALID_PARAMETER;

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		return MsiEnumComponentsA(iComponentIndex,
					CWideToAnsiOutParam(lpComponentBuf, cchComponentId + 1));
	}
	else // g_fWin9X == false
	{
#endif // MSIUNICODE
		return EnumInfo(iComponentIndex, lpComponentBuf, eetComponents);
#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif // MSIUNICODE
}


extern "C"
USERINFOSTATE __stdcall MsiGetUserInfo(
	LPCDSTR  szProduct,         // product code, string GUID
	LPDSTR   lpUserNameBuf,     // return user name           
	DWORD    *pcchUserNameBuf,  // buffer byte count, including null
	LPDSTR   lpOrgNameBuf,      // return company name           
	DWORD    *pcchOrgNameBuf,   // buffer byte count, including null
	LPDSTR   lpPIDBuf,          // return PID string for this installation
	DWORD    *pcchPIDBuf)       // buffer byte count, including null
//----------------------------------------------
{	
	CForbidTokenChangesDuringCall impForbid;

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		USERINFOSTATE uis = MsiGetUserInfoA(
			CApiConvertString(szProduct),
			CWideToAnsiOutParam(lpUserNameBuf, pcchUserNameBuf, (int*)&uis, USERINFOSTATE_MOREDATA, USERINFOSTATE_PRESENT),
			pcchUserNameBuf,
			CWideToAnsiOutParam(lpOrgNameBuf, pcchOrgNameBuf, (int*)&uis, USERINFOSTATE_MOREDATA, USERINFOSTATE_PRESENT),
			pcchOrgNameBuf,
			CWideToAnsiOutParam(lpPIDBuf, pcchPIDBuf, (int*)&uis, USERINFOSTATE_MOREDATA, USERINFOSTATE_PRESENT),
			pcchPIDBuf);

		return uis;
	}
	else // g_fWin9X == false
	{
#endif // MSIUNICODE

		if (0 == szProduct || cchProductCode != lstrlen(szProduct) || 
			 (lpUserNameBuf &&  !pcchUserNameBuf)   || 
			 (lpOrgNameBuf &&   !pcchOrgNameBuf)    ||
			 (lpPIDBuf     &&   !pcchPIDBuf))
			return USERINFOSTATE_INVALIDARG;

		CRegHandle HProductKey;

		// Open product key

		LONG lError = OpenInstalledProductInstallPropertiesKey(szProduct, HProductKey, false);

		if (ERROR_SUCCESS != lError)
		{
			if (ERROR_FILE_NOT_FOUND == lError)
			{
				if (ERROR_SUCCESS == OpenAdvertisedProductKey(szProduct, HProductKey, false))
					return USERINFOSTATE_ABSENT;
				else
					return USERINFOSTATE_UNKNOWN;
			}
			else // unknown error
			{
				return USERINFOSTATE_UNKNOWN;
			}
		}

		DWORD dwType;
		
		// Get user name

		if (lpUserNameBuf || pcchUserNameBuf)
		{
			DWORD cbUserNameBuf = *pcchUserNameBuf * sizeof(DCHAR);

			lError = RegQueryValueEx(HProductKey, szUserNameValueName, NULL,
							&dwType, (unsigned char*)lpUserNameBuf, &cbUserNameBuf);
			
			*pcchUserNameBuf = (cbUserNameBuf / sizeof(DCHAR)) - 1;
				
			if ((ERROR_SUCCESS != lError) || (REG_SZ != dwType))
			{
				if (lError == ERROR_MORE_DATA)
				{
					return USERINFOSTATE_MOREDATA;
				}
				else
				{
					return USERINFOSTATE_ABSENT;
				}
			}

		}

		// Get org name

		if (lpOrgNameBuf || pcchOrgNameBuf)
		{
			DWORD cbOrgNameBuf = *pcchOrgNameBuf * sizeof(DCHAR);

			lError = RegQueryValueEx(HProductKey, szOrgNameValueName, NULL, &dwType,
			 (unsigned char*)lpOrgNameBuf, &cbOrgNameBuf);
						
			*pcchOrgNameBuf = (cbOrgNameBuf / sizeof(DCHAR)) - 1;

			if ((ERROR_SUCCESS != lError) || (REG_SZ != dwType))
			{
				if (ERROR_FILE_NOT_FOUND == lError) // OK, org can be missing
				{
					if (lpOrgNameBuf)
						lpOrgNameBuf[0] = 0;

					*pcchOrgNameBuf = 0;
				}
				else if (lError == ERROR_MORE_DATA)
				{
					return USERINFOSTATE_MOREDATA;
				}
				else // unknown error
				{
					return USERINFOSTATE_ABSENT;
				}
			}
		}

		// Get PID

		if (lpPIDBuf || pcchPIDBuf)
		{
			DWORD cbPIDBuf = *pcchPIDBuf * sizeof(DCHAR);

			lError = RegQueryValueEx(HProductKey, szPIDValueName, NULL, &dwType,
			 (unsigned char*)lpPIDBuf, &cbPIDBuf);
						
			*pcchPIDBuf = (cbPIDBuf / sizeof(DCHAR)) - 1;

			if ((ERROR_SUCCESS != lError) || (REG_SZ != dwType))
			{
				if (lError == ERROR_MORE_DATA)
				{
					return USERINFOSTATE_MOREDATA;
				}
				else
				{
					return USERINFOSTATE_ABSENT;
				}
			}
		}

		return USERINFOSTATE_PRESENT;
#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif // MSIUNICODE
}

#ifndef MSIUNICODE
extern "C"
INSTALLUILEVEL __stdcall MsiSetInternalUI(
	INSTALLUILEVEL dwUILevel,            // UI level
	HWND  *phWnd)                // window handle to parent UI to
{
	return g_message.SetInternalHandler(dwUILevel, phWnd);
}


extern "C"
INSTALLUI_HANDLERA __stdcall MsiSetExternalUIA(
	INSTALLUI_HANDLERA puiHandler,   // for progress and error handling 
	DWORD              dwMessageFilter, // bit flags designating messages to handle
	void*              pvContext)   // application context
{
	return (INSTALLUI_HANDLERA)g_message.SetExternalHandler(0, puiHandler, dwMessageFilter, pvContext);
}

extern "C"
INSTALLUI_HANDLERW __stdcall MsiSetExternalUIW(
	INSTALLUI_HANDLERW puiHandler,   // for progress and error handling 
	DWORD              dwMessageFilter, // bit flags designating messages to handle
	void*              pvContext)   // application context
{
	return g_message.SetExternalHandler(puiHandler, 0, dwMessageFilter, pvContext);
}
#endif



extern "C"
UINT __stdcall MsiGetProductCode(LPCDSTR szComponent,   
												LPDSTR lpBuf39)
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;

	if (!lpBuf39 || (0 == szComponent) || (lstrlen(szComponent) != cchComponentId))
		return ERROR_INVALID_PARAMETER;

#ifdef MSIUNICODE
		return MsiGetProductCodeA(
			CApiConvertString(szComponent),
			CWideToAnsiOutParam(lpBuf39, cchProductCode+1));
#else
	// Look up the component's clients. 
	char rgchProductCode[cchProductCode + 1];
	int iProductIndex = 0;
	UINT uiRet;
	
	for (int cClients=0; cClients < 2; cClients++)
	{
		uiRet = MsiEnumClientsA(szComponent, cClients, rgchProductCode);
		
		if (ERROR_NO_MORE_ITEMS == uiRet)
		{
			break;
		}
		else if (ERROR_SUCCESS != uiRet)
		{
			return uiRet;
		}
		else
		{
			StringCchCopy(lpBuf39, cchProductCode+1, rgchProductCode);
		}
	}

	if (0 == cClients)
	{
		// If it's got zero clients then we're in a 
		// screwy case. The user launched an app that's not advertised to him
		// or even installed by him. No can do; return an error.
		return ERROR_INSTALL_FAILURE; //!! fix error code
	}
	else if (1 == cClients)
	{
		// If the component has only one client then we're set;
		// return the client product code.
		
		return ERROR_SUCCESS;
	}
	// else we have 2 or more clients
	
	// Look to see how many of the clients are advertised. 
	
	int cAdvertised = 0;
	
	CRegHandle HKey;

	for (cClients = 0 ; ; cClients++)
	{
		uiRet = MsiEnumClientsA(szComponent, cClients, lpBuf39);
		
		if (ERROR_NO_MORE_ITEMS == uiRet)
		{
			break;
		}
		else if (ERROR_SUCCESS == uiRet)
		{
			if (ERROR_SUCCESS == OpenAdvertisedProductKey(lpBuf39, HKey, false))
			{
				cAdvertised++;
				if (cAdvertised > 1)
					break;
				else
					StringCbCopy(rgchProductCode, sizeof(rgchProductCode), lpBuf39);
			}
		}
		else
		{
			return uiRet;
		}
	}

	if (0 == cAdvertised)
	{
		// If none of the clients are advertised then something is wrong.
		return ERROR_INSTALL_FAILURE; //!! fix error code
	}
	else if (1 == cAdvertised)
	{
		// If only one is advertised then we've got it; return that client.
		StringCchCopy(lpBuf39, cchProductCode+1, rgchProductCode);
		return ERROR_SUCCESS;
	}
	// else more than 1 of our clients were advertised

	// We'll have to arbitrarily
	// choose a product code. We'll look for the first client that's 
	// installed and advertised.

	for (cClients = 0 ; ; cClients++)
	{
		uiRet = MsiEnumClientsA(szComponent, cClients, lpBuf39);
		
		if (ERROR_NO_MORE_ITEMS == uiRet)
		{
			break;
		}
		else if (ERROR_SUCCESS == uiRet)
		{
//!! faster not to actually open the keys....
			CRegHandle HAdvertised;
			CRegHandle HInstalled;
			if ((ERROR_SUCCESS == OpenAdvertisedProductKey(lpBuf39, HAdvertised, false)))
			{
				if (ERROR_SUCCESS == OpenInstalledProductInstallPropertiesKey(lpBuf39, HInstalled, false))
				{
					return ERROR_SUCCESS;
				}
			}
		}
		else
		{
			return uiRet;
		}
	}

	// There are no clients that are installed and advertised. Return
	// the first advertised product

	for (cClients = 0 ; ; cClients++)
	{
		uiRet = MsiEnumClientsA(szComponent, cClients, lpBuf39);
		
		if (ERROR_NO_MORE_ITEMS == uiRet)
		{
			break;
		}
		else if (ERROR_SUCCESS == uiRet)
		{
//!! faster not to actually open the key....
			CRegHandle HAdvertised;
			if ((ERROR_SUCCESS == OpenAdvertisedProductKey(lpBuf39, HAdvertised, false)))
			{
				return ERROR_SUCCESS;
			}
		}
		else
		{
			return uiRet;
		}
	}

	return ERROR_INSTALL_FAILURE;
#endif
}

Bool ValidatePackage(CAPITempBufferRef<DCHAR>& szSource, CAPITempBufferRef<DCHAR>& szPackageName)
{
	if ( !(DCHAR*)szSource || !(DCHAR*)szPackageName )
		// an AV less
		return fFalse;
	
	CAPITempBuffer<DCHAR, 1> rgchPackagePath;
	int cch = 0;

	if (rgchPackagePath.GetSize() < (cch = szSource.GetSize() + szPackageName.GetSize() - 1))
	{
		if ( !rgchPackagePath.SetSize(cch+1))
			return fFalse;
	}

	Assert((lstrlen(szSource) + lstrlen(szPackageName) + 1) <= rgchPackagePath.GetSize());
	StringCchCopy(rgchPackagePath, rgchPackagePath.GetSize(), szSource);
	StringCchCat(rgchPackagePath, rgchPackagePath.GetSize(), szPackageName);

	//?? Should we validate the label as well.
	
	Bool fRet = (0xFFFFFFFF == MsiGetFileAttributes(CMsInstApiConvertString(rgchPackagePath))) ? fFalse : fTrue;

	DEBUGMSG2(MSITEXT("Package validation of '%s' %s"), (const DCHAR*)rgchPackagePath, fRet ? MSITEXT("succeeded") : MSITEXT("failed"));
	return fRet;
}

DWORD ValidateSource(const DCHAR* szProductSQUID, unsigned int uiDisk, bool fShowUI, CAPITempBufferRef<DCHAR>& rgchResultantValidatedSource, bool& fSafeToCache)
{
	DEBUGMSG2(MSITEXT("RFS validation of product '%s', disk '%u'"), szProductSQUID, (const DCHAR*)(INT_PTR)uiDisk);

	Bool fValidated = fFalse;
	CRegHandle HSourceListKey;
	if (ERROR_SUCCESS == OpenSourceListKeyPacked(szProductSQUID, fFalse, HSourceListKey, fFalse, false))
	{
		CAPITempBuffer<DCHAR, 1> rgchPackageName;
		CAPITempBuffer<DCHAR, 1> rgchLastUsedSource;
		CAPITempBuffer<DCHAR, 12>        rgchSourceType;
		CAPITempBuffer<DCHAR, 12>        rgchSourceIndex;
		
		if (!rgchPackageName.SetSize(MAX_PATH) || !rgchLastUsedSource.SetSize(MAX_PATH))
			return ERROR_OUTOFMEMORY;

		if ((ERROR_SUCCESS == MsiRegQueryValueEx(HSourceListKey, szLastUsedSourceValueName, 0, 0, 
															 rgchSourceType, 0)) &&
			 (ERROR_SUCCESS == MsiRegQueryValueEx(HSourceListKey, szPackageNameValueName, 0, 0, 
															 rgchPackageName, 0)))
		{
			isfEnum isf;
			unsigned int uiIndex = 0;
			bool fCacheValidSource = true;

			// rgchSourceType contains:  type;index;source
			DCHAR* pch = rgchSourceType;

			if ( ! pch )
				return ERROR_OUTOFMEMORY;

			// skip source type
			while (*pch && *pch != ';')
				pch = WIN::CharNext(pch);
			
			Assert(*pch);

			if (*pch)
			{
				*pch = 0; // overwrite ';' with null

				DCHAR* pchSourceIndex       = ++pch;
				DCHAR* pchSourceIndexBuffer = rgchSourceIndex;

				// get source index
				size_t cchLen = 0;
				while (*pchSourceIndex && *pchSourceIndex != ';')
				{
					if ( pchSourceIndex - pch + 1 >= rgchSourceIndex.GetSize() ||
						  cchLen >= 2 || !isdigit(*pchSourceIndex) )
						// malformed index
						return ERROR_FUNCTION_FAILED;
					*pchSourceIndexBuffer++ = *pchSourceIndex++;
					cchLen++;
				}

				*pchSourceIndexBuffer = 0;

				if (*pchSourceIndex)
					// this is an actual condition to end the while loop above
					pchSourceIndex++; // skip over ';'

				Assert(*pchSourceIndex);

				if (*pchSourceIndex)
				{
					rgchLastUsedSource.SetSize(rgchSourceType.GetSize());
					lstrcpyn(rgchLastUsedSource, pchSourceIndex, rgchLastUsedSource.GetSize());
				}

				if (MapSourceCharToIsf((const ICHAR)*(const DCHAR*)rgchSourceType, isf))
				{
					switch (isf)
					{
					case isfNet: // network
						{
						fValidated = ValidatePackage(rgchLastUsedSource, rgchPackageName);

						switch (CheckShareCSCStatus(isfNet, CMsInstApiConvertString(rgchLastUsedSource)))
						{
						case cscConnected: 
							DEBUGMSG(TEXT("RFS Source is valid, but will not be cached due to CSC state."));
							fCacheValidSource = false;
							break;
						case cscDisconnected:
							DEBUGMSG(TEXT("RFS Source is not valid due to CSC state."));
							fValidated=fFalse;
							break;
						default:
							break;
						}
						break;
						}
					case isfMedia:
						{
						const DCHAR* szIndex = rgchSourceIndex;
						unsigned int uiIndex;
						if (szIndex[0] && szIndex[1])
							uiIndex = (szIndex[1] - '0') + (10 * (szIndex[0] - '0'));
						else
							uiIndex = (szIndex[0] - '0');

						if (uiIndex == uiDisk)
							fValidated = ValidatePackage(rgchLastUsedSource, rgchPackageName);
						break;
						}
					case isfURL:
					default:
						Assert(0);
					}
				}
			}
			if (fValidated)
			{
				fSafeToCache = fCacheValidSource;
				if (rgchResultantValidatedSource.GetSize() < rgchLastUsedSource.GetSize())
					rgchResultantValidatedSource.SetSize(rgchLastUsedSource.GetSize());

				StringCchCopy(rgchResultantValidatedSource, rgchResultantValidatedSource.GetSize(), rgchLastUsedSource);
			}
		}
	}

	if (!fValidated)
	{
		DEBUGMSG("Quick RFS source validation failed. Falling back to source resolver.");
		CAPITempBuffer<DCHAR, 1> rgchValidatedSource;
		if (!rgchValidatedSource.SetSize(MAX_PATH))
			return ERROR_OUTOFMEMORY;

		DCHAR szProduct[cchProductCode + 1];
		if(!UnpackGUID(szProductSQUID, szProduct))
			return ERROR_INVALID_PARAMETER;

		iuiEnum iui = fShowUI ? GetStandardUILevel() : iuiNone;
		iui = iuiEnum(iui | iuiHideBasicUI);
		UINT uiRet = g_MessageContext.Initialize(fTrue, iui);
		
		if (uiRet == NOERROR)
		{
			CRegHandle HProductKey;
			DWORD iLangId;
			DWORD cbLangId = sizeof(iLangId);
			DWORD dwType;
			if (ERROR_SUCCESS == OpenAdvertisedProductKey(szProduct, HProductKey, false)
			 && ERROR_SUCCESS == RegQueryValueEx(HProductKey, szLanguageValueName, 0, &dwType, (LPBYTE)&iLangId, &cbLangId)
			 && dwType == REG_DWORD)
			{

				PMsiRecord pLangId = &CreateRecord(3);
				pLangId->SetInteger(1, icmtLangId);
				pLangId->SetInteger(2, iLangId);
				pLangId->SetInteger(3, ::MsiGetCodepage(iLangId));
				g_MessageContext.Invoke(imtCommonData, pLangId);
			}

			if (ResolveSource(szProduct, uiDisk, rgchValidatedSource, fTrue, g_message.m_hwnd))
			{
				// check CSC state of the source resolved. We set the last used source above, so
				// can retrieve the type from the registry. Ignore the possibility that the
				// source has gone disconnected between the ResolveSource() call and now.
				PMsiServices pServices = ENG::LoadServices();
				isfEnum isf = isfNet;
				bool fSuccess = GetLastUsedSourceType(*pServices, CMsInstApiConvertString(szProduct), isf);
				if (fSuccess && isf == isfMedia)
				{
					DEBUGMSG(TEXT("SOURCEMGMT: RFS Source is valid, but will not be cached because it is Media."));
					fSafeToCache = false;
				}
				else if (fSuccess && cscNoCaching != CheckShareCSCStatus(isf, CMsInstApiConvertString(rgchValidatedSource)))
				{
					DEBUGMSG(TEXT("SOURCEMGMT: RFS Source is valid, but will not be cached due to CSC state."));
					fSafeToCache = false;
				} 
				else 
				{
					fSafeToCache = true;
				}

				if (rgchResultantValidatedSource.GetSize() < rgchValidatedSource.GetSize())
					rgchResultantValidatedSource.SetSize(rgchValidatedSource.GetSize());

				StringCchCopy(rgchResultantValidatedSource, rgchResultantValidatedSource.GetSize(), rgchValidatedSource);				
			}
			else
			{
				uiRet = ERROR_INSTALL_SOURCE_ABSENT;
			}

			g_MessageContext.Terminate(false);

		}
		return uiRet;
	}

	return ERROR_SUCCESS;
}

INSTALLSTATE GetComponentPath(LPCDSTR szUserId, LPCDSTR szProductSQUID, LPCDSTR szComponentSQUID,
								CAPITempBufferRef<DCHAR>& rgchPathBuf, bool fFromDescriptor, CRFSCachedSourceInfo& rCacheInfo,
								int iDetectMode, const DCHAR* rgchComponentRegValue,
								DWORD dwValueType)
{
	DWORD cchPathBuf    = rgchPathBuf.GetSize();
	INSTALLSTATE is = INSTALLSTATE_UNKNOWN;

	for (int c=1; c <= 2; c++)
	{
		is = GetComponentPath(szUserId,
									 szProductSQUID,
									 szComponentSQUID,
									 (DCHAR*)rgchPathBuf,
									 &cchPathBuf,
									 fFromDescriptor,
									 rCacheInfo,
									 iDetectMode,
									 rgchComponentRegValue,
									 dwValueType);

		if (INSTALLSTATE_MOREDATA == is)
		{
			rgchPathBuf.SetSize(++cchPathBuf);  // adjust buffer size for char count + 1 for null terminator
		}
		else
		{
			break;
		}
	}

	return is;
}

INSTALLSTATE GetComponentPath(LPCDSTR szUserId, LPCDSTR szProductSQUID, LPCDSTR szComponentSQUID,
								LPDSTR  lpPathBuf, DWORD *pcchBuf, bool fFromDescriptor, CRFSCachedSourceInfo& rCacheInfo,
								int iDetectMode, const DCHAR* rgchComponentRegValue,
								DWORD dwValueType, LPDSTR lpPathBuf2, DWORD* pcchBuf2,
								DWORD* pdwLastErrorOnFileDetect)
{
	CAPITempBuffer<DCHAR, 1> rgchOurComponentRegValue;
	if (!rgchOurComponentRegValue.SetSize(MAX_PATH))
		return INSTALLSTATE_BADCONFIG;

	LONG lError = ERROR_SUCCESS;
	CRegHandle HComponentKey;

	// If rgchComponentRegValue is set then we already have the registry value. Otherwise
	// we need to read it.	
	if (!rgchComponentRegValue)
	{
		lError = OpenInstalledComponentKeyPacked(szUserId, szProductSQUID, szComponentSQUID, HComponentKey, false);

		if (ERROR_SUCCESS != lError)
		{
			return INSTALLSTATE_UNKNOWN;
		}

		for (int cRetry = 0; cRetry < 2; cRetry++)
		{
			DWORD cbBuf = rgchOurComponentRegValue.GetSize() * sizeof(DCHAR);
			lError = RegQueryValueEx(HComponentKey, szProductSQUID, 0, &dwValueType,
				(LPBYTE)(DCHAR*) rgchOurComponentRegValue, &cbBuf);

			if (ERROR_SUCCESS == lError && (REG_SZ == dwValueType || REG_MULTI_SZ == dwValueType))
			{
				rgchComponentRegValue = rgchOurComponentRegValue;
				break;
			}
			else if (ERROR_MORE_DATA == lError)
			{
				rgchOurComponentRegValue.SetSize(cbBuf/sizeof(DCHAR));
			}
			else if (ERROR_FILE_NOT_FOUND == lError)
			{
				return INSTALLSTATE_UNKNOWN;
			}
			else // unknown registry error
			{
				return INSTALLSTATE_BADCONFIG;
			}
		}
		Assert(lError == ERROR_SUCCESS);
	}

	// get the first key path state and value
	INSTALLSTATE is1 = _GetComponentPath(szProductSQUID, lpPathBuf, pcchBuf, iDetectMode, rgchComponentRegValue, fFromDescriptor, pdwLastErrorOnFileDetect, rCacheInfo);
	if(REG_SZ == dwValueType)
	{
		if(pcchBuf2)
		{
			if(lpPathBuf2 && *pcchBuf2)
				*lpPathBuf2 = 0; // no auxiliary path
			*pcchBuf2 = 0; // no auxiliary path
		}
		return is1;
	}

	Assert(REG_MULTI_SZ == dwValueType);

	// advance to the 2nd path		
	while (*rgchComponentRegValue++)
		;

	// second path is a registry key, dont overwrite the pdwLastErrorOnFileDetect here
	INSTALLSTATE is2 = _GetComponentPath(szProductSQUID, lpPathBuf2, pcchBuf2, iDetectMode, rgchComponentRegValue, fFromDescriptor, NULL, rCacheInfo);

	// determine what to return based on is1 and is2

	if (is1 == INSTALLSTATE_MOREDATA || is2 == INSTALLSTATE_MOREDATA) // we always want to return more data, even if the component is broken, for rollback
		return INSTALLSTATE_MOREDATA;
	else if (is1 == INSTALLSTATE_LOCAL || is1 == INSTALLSTATE_SOURCE) // if is1 is okay, return whatever is2 is
		return is2;
	else
		return is1;
}


#ifdef MSIUNICODE // no ansi version

//FN: to get and detect fusion assembly paths
// fn can be passed in a path in lpPath, we will attempt to use first
// If path cannot fit passed in buffer OR if no buffer is passed in
// and the path needs to be determined THEN rgchPathOverflow is used
INSTALLSTATE GetFusionPath(LPCWSTR szRegistration, LPWSTR lpPath, DWORD *pcchPath, CAPITempBufferRef<WCHAR>& rgchPathOverflow, int iDetectMode, iatAssemblyType iatAT, WCHAR* szManifest, DWORD cbManifestSize)
{
	if ( !szRegistration || (lpPath && !pcchPath) )
		return INSTALLSTATE_INVALIDARG;

	// skip the file name, if this is a directory only path, then we will have a '\' in the beginning
	// else we will have 'filename\'. This will be followed by the strong name of the assembly
	LPCWSTR lpBuf = szRegistration;
	while(*lpBuf && *lpBuf != '\\')
		lpBuf = WIN::CharNext(lpBuf);

	unsigned int cchFileName = (unsigned int)(UINT_PTR)(lpBuf - szRegistration);

	PAssemblyName pAssemblyName(0);
	HRESULT hr;
	if(iatAT == iatURTAssembly)
	{
		hr = FUSION::CreateAssemblyNameObject(&pAssemblyName, lpBuf + 1, CANOF_PARSE_DISPLAY_NAME, 0);
	}
	else
	{
		Assert(iatAT == iatWin32Assembly);
		hr = SXS::CreateAssemblyNameObject(&pAssemblyName, lpBuf + 1, CANOF_PARSE_DISPLAY_NAME, 0);
	}

	if(!SUCCEEDED(hr))
		return INSTALLSTATE_BADCONFIG; //!! need to do some elaborate fault finding here

	// use the name object to detect where the component is located
	PAssemblyCache pASMCache(0);
	if(iatAT == iatURTAssembly)
	{
		hr = FUSION::CreateAssemblyCache(&pASMCache, 0); 
	}
	else
	{
		Assert(iatAT == iatWin32Assembly);
		hr = SXS::CreateAssemblyCache(&pASMCache, 0); 
	}
	if(!SUCCEEDED(hr) || !pASMCache)
		return INSTALLSTATE_BADCONFIG; //!! need to do some elaborate fault finding here

    ASSEMBLY_INFO AsmInfo;
    memset((LPVOID)&AsmInfo, 0, sizeof(ASSEMBLY_INFO));
    AsmInfo.cbAssemblyInfo = sizeof(ASSEMBLY_INFO);

	if(lpPath)
	{
		// default buffer passed in
		AsmInfo.pszCurrentAssemblyPathBuf = lpPath;
		AsmInfo.cchBuf = *pcchPath;
	}
	else if(pcchPath || iDetectMode & DETECTMODE_VALIDATEPATH)
	{
		// need path, though no default buffer has been passed in
		AsmInfo.pszCurrentAssemblyPathBuf = rgchPathOverflow;
		AsmInfo.cchBuf = rgchPathOverflow.GetSize();
	}

    hr = pASMCache->QueryAssemblyInfo(0, lpBuf + 1, &AsmInfo);
	if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) // insufficient buffer size
	{
		// resize buffer/try our own buffer and try again
		//!!bugbug the GetAssemblyInstallInfo API return no. of bytes not characters, so we are allocating more memory than required, but so what
		rgchPathOverflow.SetSize(AsmInfo.cchBuf + cchFileName + 1);
		AsmInfo.pszCurrentAssemblyPathBuf = rgchPathOverflow;
		AsmInfo.cchBuf = rgchPathOverflow.GetSize();
		hr = pASMCache->QueryAssemblyInfo(0, lpBuf + 1, &AsmInfo);
	}

	if(!SUCCEEDED(hr))
		return INSTALLSTATE_ABSENT;

	// remove the manifest file name
	if(AsmInfo.pszCurrentAssemblyPathBuf)
	{
		// we will have to search for the last '\\'
		WCHAR* lpCur = AsmInfo.pszCurrentAssemblyPathBuf;
		WCHAR* lpBS = 0;
		//!!bugbug the GetAssemblyInstallInfo API return no. of bytes not characters
		// once that fixed, we can ensure that we dont overshoot a non-null terminated return string
		while(*(++lpCur)) // this fn is unicode only
		{
			if(*lpCur == '\\')
				lpBS = lpCur;
		}
		if(!lpBS)
			return INSTALLSTATE_BADCONFIG; //!! need to do some elaborate fault finding here

		lpBS++; // point to the next location after the last '\\'

		// if we have been passed in the szManifest buffer, copy the manifest filename there
		if(szManifest)
			StringCbCopy(szManifest, cbManifestSize, lpBS);

		// calculate the actual size for the full key file path (w/o the terminating null)
		// unfortunately QueryAssemblyInfo does not set this
		if(lpBuf != szRegistration) // use registered keypath instead of any manifest file passed back by the fusion API
		{
			// size is the full path returned by the fusion API minus any file component plus the keyfile size
			AsmInfo.cchBuf = (DWORD)((lpBS - AsmInfo.pszCurrentAssemblyPathBuf) + cchFileName);
		}
		else
		{
			AsmInfo.cchBuf = (DWORD)(lpCur - AsmInfo.pszCurrentAssemblyPathBuf);
		}
	
		if(AsmInfo.pszCurrentAssemblyPathBuf == lpPath) // still using passed in buffer
		{
			if(AsmInfo.cchBuf + 1 > *pcchPath)
				return INSTALLSTATE_MOREDATA; // cannot fit the full file path
		}
		else
		{
			Assert(AsmInfo.pszCurrentAssemblyPathBuf == rgchPathOverflow);
			if(AsmInfo.cchBuf + 1> rgchPathOverflow.GetSize())
			{
				rgchPathOverflow.Resize(AsmInfo.cchBuf + 1);
				AsmInfo.pszCurrentAssemblyPathBuf = rgchPathOverflow;
			}
		}
		if(lpBuf != szRegistration) // use registered keypath instead of any manifest file passed back by the fusion API
			lstrcpyn(AsmInfo.pszCurrentAssemblyPathBuf + (AsmInfo.cchBuf - cchFileName), szRegistration, cchFileName + 1);


		if(pcchPath) // passed in  size
			*pcchPath = AsmInfo.cchBuf; // new total path length
	}

	// detect key path, if so desired
	if(iDetectMode & DETECTMODE_VALIDATEPATH)
	{
		Assert(AsmInfo.pszCurrentAssemblyPathBuf);
		UINT uiErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
		DWORD dwAttributes = MsiGetFileAttributes(CMsInstApiConvertString(AsmInfo.pszCurrentAssemblyPathBuf));
		SetErrorMode(uiErrorMode);

		if (0xFFFFFFFF == dwAttributes)
			return INSTALLSTATE_ABSENT;
	}
	return INSTALLSTATE_LOCAL;
}
#else
// simply declare the fn for the ANSI compilation
INSTALLSTATE GetFusionPath(LPCWSTR szRegistration, LPWSTR lpPath, DWORD *pcchPath, CAPITempBufferRef<WCHAR>& rgchPathOverflow, int iDetectMode, iatAssemblyType iatAT, WCHAR* szManifest, DWORD cbManifestSize);
#endif

INSTALLSTATE _GetComponentPath( LPCDSTR szProductSQUID, LPDSTR  lpPathBuf,
								DWORD *pcchBuf, int iDetectMode,
								const DCHAR* rgchComponentRegValue,
								bool fFromDescriptor,
								DWORD* pdwLastErrorOnFileDetect,
								CRFSCachedSourceInfo& rCacheInfo)
{
	Assert(rgchComponentRegValue);

	DCHAR chFirst  = rgchComponentRegValue[0];
	DCHAR chSecond = chFirst ?  rgchComponentRegValue[1] : (DCHAR)0;
	DCHAR chThird  = chSecond ? rgchComponentRegValue[2] : (DCHAR)0;

	if(pdwLastErrorOnFileDetect) *pdwLastErrorOnFileDetect = 0; // initialize value to 0

	CAPITempBuffer<DCHAR, 1> rgchOurPathBuf;
	if (!rgchOurPathBuf.SetSize(1024))
		return INSTALLSTATE_BADCONFIG;

	// cache converted SQUID to prevent multiple expensive temporary objects
	CACHED_CONVERTSTRING(ICHAR, szUnicodeProductSQUID, szProductSQUID);

	if (chFirst == chTokenFusionComponent || chFirst == chTokenWin32Component)
	{
#ifdef MSIUNICODE
		return GetFusionPath(rgchComponentRegValue + 1, lpPathBuf, pcchBuf, rgchOurPathBuf, iDetectMode, chFirst == chTokenFusionComponent ? iatURTAssembly : iatWin32Assembly, 0, 0);
#else
		// this is a fusion component
		CAPITempBuffer<WCHAR, 1> szBufferOverflow;
		if (!szBufferOverflow.SetSize(1024))
			return INSTALLSTATE_BADCONFIG;

		// since fusion APIs are UNICODE, we need to perform some manipulations on the outside of the GetFusionPath Fn
		DWORD dwTemp = 0;
		INSTALLSTATE is = GetFusionPath(CApiConvertString(rgchComponentRegValue + 1), 0, pcchBuf ? &dwTemp : 0, szBufferOverflow, iDetectMode, chFirst == chTokenFusionComponent ? iatURTAssembly : iatWin32Assembly, 0, 0);

		if(is != INSTALLSTATE_LOCAL && is != INSTALLSTATE_ABSENT)
			return is; // has to be local or absent, else we had an error in GetFusionPath

		// if lpPathBuf or pcchBuf, we would need to convert to ANSI
		if(!lpPathBuf && !pcchBuf)
			return is;

		int iRet = WideCharToMultiByte(CP_ACP, 0, szBufferOverflow, -1, lpPathBuf, lpPathBuf ? *pcchBuf : 0, 0, 0);
			
		if ((0 == iRet) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
		{
			// find out how much size is really required and return the same
			iRet = WideCharToMultiByte(CP_ACP, 0, szBufferOverflow, -1, 0, 0, 0, 0);
			is = INSTALLSTATE_MOREDATA;
		}
		// iRet is still 0, we have a problem
		if(!iRet)
			return INSTALLSTATE_BADCONFIG;// something bad happened
		*pcchBuf = iRet - 1;
		return is;
#endif
	}
    
	DCHAR* lpOriginalPathBuf = lpPathBuf;
	Bool fProvidedBufferTooSmall = fFalse;

	// Get component's keypath

	DWORD cchOurPathBuf = 0;

	int cchPathBuf = 0;
	if (pcchBuf)
		cchPathBuf = *pcchBuf; // save initial count for later restoration
	else
		pcchBuf = &cchOurPathBuf;

	if (!lpPathBuf) // caller doesn't care about path
	{
		cchOurPathBuf = rgchOurPathBuf.GetSize();
		lpPathBuf = rgchOurPathBuf;
	}

	unsigned int cchRegistryValue = lstrlen(rgchComponentRegValue);

	if (cchRegistryValue + 1 > *pcchBuf)
	{
		if (lpOriginalPathBuf)
			fProvidedBufferTooSmall = fTrue;

		rgchOurPathBuf.SetSize(cchRegistryValue + 1);
		lpPathBuf = rgchOurPathBuf;
	}
	
	*pcchBuf = cchRegistryValue;
	memcpy(lpPathBuf, rgchComponentRegValue, (cchRegistryValue+1)*sizeof(DCHAR));

	// Process the keypath

	if (chFirst == 0) // Not used
	{
		return INSTALLSTATE_NOTUSED;
	}
	else if (chFirst >= '0' && chFirst <= '9')
	{
		if (chSecond >= '0' && chSecond <= '9') 
		{
			if (chThird == ':' || chThird == '*') // reg key
			{
				int cchOffset = 0;
				if (chThird == '*')
				{
					// A '*' means that the keypath is a registry value name and that
					// the value name has a '\' in it. In this case we embed
					// the offset to the value name in our key path. In the example below,
					// the registry value name starts at 23 characters from the front of
					// the string (after the embedded offset is removed)

					// our value is of the form: {hive}*{offset}*\KEY\KEY\KEY\VALUENAME, e.g.
					// 01*23*\SOFTWARE\MICROSOFT\MYVALUE\NAME
					
					DCHAR* pchValueOffset = &lpPathBuf[3]; // the start of the offset
					
					// convert the offset from a string into an integer
					while (*pchValueOffset && *pchValueOffset != '*')
					{
						cchOffset *= 10;
						cchOffset += (*pchValueOffset - '0');
						pchValueOffset++; // no CharNext because it's a number
					}

					// make sure that our data isn't corrupted
					if (*pchValueOffset != '*')
					{
						DEBUGMSGE2(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_BAD_CONFIGURATION_VALUE, szProductSQUID, lpPathBuf, MSITEXT(""));
						return INSTALLSTATE_BADCONFIG;
					}

					int cDigitsInOffsetCount = (int)(pchValueOffset - &lpPathBuf[3]);
					
					// check whether our original buffer size was big enough to 
					// hold the keypath once we chop off the offset count (and the trailing '*').

					*pcchBuf = cchRegistryValue - (cDigitsInOffsetCount + 1);

					if (cchRegistryValue - (cDigitsInOffsetCount + 1) + 1 > cchPathBuf)
					{
						if (lpOriginalPathBuf)
							return INSTALLSTATE_MOREDATA;
						else
						{
							rgchOurPathBuf.SetSize(*pcchBuf + 1);
							lpPathBuf = rgchOurPathBuf;
						}
					}

					DCHAR* lpCurrentPathBuf = lpPathBuf;
					
					if (fProvidedBufferTooSmall)
					{
						fProvidedBufferTooSmall = fFalse;

						// our original buffer was big enough but we thought it
						// was too small. now that we've chopped off the offset
						// count we have enough room. we need to copy the keypath
						// from our tempbuffer back into the original buffer.
						lpPathBuf = lpOriginalPathBuf;
						

						// the rest of the copy will happen below
						lpPathBuf[0] = chFirst;  
						lpPathBuf[1] = chSecond;
					}
					//else // the original buffer was always large enough to hold our string

					DCHAR* pchDest      = &lpPathBuf[3];       // the destination is just after the ##:
					DCHAR* pchSource    = pchValueOffset + 1;  // the source is just after the '*' that ends the offset count
					DCHAR* pchBufferEnd = &lpCurrentPathBuf[cchRegistryValue];
					int    cbToMove     = ((int)((pchBufferEnd - pchSource)) + 1) * sizeof(DCHAR); // include the null in the move
					memmove(pchDest, pchSource, cbToMove);
					lpPathBuf[2] = ':'; // replace the '*' with a ':'
				}

				// At this point our keypath should no longer have any of our '*'s in it.
				
				if (fProvidedBufferTooSmall)
					return INSTALLSTATE_MOREDATA;

				// Key form: ##:\key\subkey\subsubkey\...\[value]  where (## == hive)
				// we need at least 1 char in the key
				// ##:\k0
				// ^^^^^ (size of 5)
				if (*pcchBuf < 5)  // need at least 1 char in the key
					return INSTALLSTATE_BADCONFIG;

				INT_PTR iRoot = ((chFirst - '0')*10)+(chSecond - '0');		//--merced: changed int to INT_PTR
				Bool fSource = fFalse;
				REGSAM samAddon = 0;

				if (iRoot >= iRegistryHiveSourceOffset)
				{
					iRoot   -= iRegistryHiveSourceOffset;
					fSource  = fTrue;
					lpPathBuf[0] = (DCHAR)(iRoot/10 + '0');
				}

				//
				// On IA64 machines, make sure that you go to the correct hive.

				// It's important to know that paths starting with '0' belong
				// to the 32-bit hive and paths starting with '2' belong to
				// the 64-bit hive.
				// No need to do anything to lpPathBuf for this.
				// Note: This way we will also not break legacy 32-bit apps.
				//       running on 64-bit machines which will get redirected
				//       to the 32-bit hive by the registry redirector automatically
				//       and which expect the first character to be '0'.
				//
				if (g_fWinNT64)
				{
					if (iRoot >= iRegistryHiveWin64Offset)
					{
						iRoot -= iRegistryHiveWin64Offset;
						samAddon = KEY_WOW64_64KEY;	// We need to go to the 64-bit hive

					}
					else
					{
						samAddon = KEY_WOW64_32KEY;	// We need to go to the 32-bit hive
					}
				}

				if(iDetectMode & DETECTMODE_VALIDATEPATH)
				{
					DCHAR* lpRegValue = &(lpPathBuf[*pcchBuf - 1]);
					// key or key + value?

					if (cchOffset)
					{
						// We already know our offset -- it was embedded in the keypath. 

						// We need to treat ANSI and UNICODE differently because we 
						// store the _character_ offset. These are real characters --
						// if the value name is composed of a DBCS string we 
						// treat double-byte characters as 1 character.
						
#ifdef MSIUNICODE
						lpRegValue = lpPathBuf + cchOffset - 1; // lpRegValue points to the '\' before the value name
#else
						lpRegValue = lpPathBuf;
						while (--cchOffset != 0)
							lpRegValue = CharNextA(lpRegValue);
#endif
						// Make sure that we haven't run off either end of our buffer.
						// This should only happen if we have a corrupt keypath entry
						if ( (lpRegValue > &(lpPathBuf[*pcchBuf-1])) || 
							  (lpRegValue < lpPathBuf))
						{
							Assert(0);
							return INSTALLSTATE_BADCONFIG;
						}
					}
					else 
#ifdef MSIUNICODE
					if(*lpRegValue != '\\')
#endif
					{
						// we will have to search for the last '\\'
						DCHAR* lpTmp = lpPathBuf;
#ifdef MSIUNICODE
						while(*(++lpTmp))
#else
						while(*(lpTmp = CharNextA(lpTmp)))
#endif
							if(*lpTmp == '\\')
								lpRegValue = lpTmp;
					}
					// remove the end '\\' for the key
					*lpRegValue = 0;

					CRegHandle HDetectKey;
					CRegHandle HUserKey;

					bool fSpecialChk = false; 
					DWORD lResult = ERROR_SUCCESS;

					if(!g_fWin9X && g_iMajorVersion >= 5 && RunningAsLocalSystem() && (iRoot == 0 || iRoot == 1))
					{
						// WARNING: OpenUserKey will call directly into RegOpenKeyEx API.
						lResult = OpenUserKey(&HUserKey, iRoot?false:true, samAddon);
					}

					if (ERROR_SUCCESS == lResult)
					{
						lResult = RegOpenKeyAPI(HUserKey ? HUserKey : (HKEY)((ULONG_PTR)HKEY_CLASSES_ROOT | iRoot),
														CMsInstApiConvertString(lpPathBuf + 4), 0, KEY_READ | samAddon, &HDetectKey);
						if(ERROR_SUCCESS == lResult)
						{
							// key or key + value?
							if(lpRegValue != &(lpPathBuf[*pcchBuf - 1]))
							{
								// check if the value exists
								lResult = RegQueryValueEx(HDetectKey, lpRegValue + 1, 0,
														  0, 0, 0);
							}
						}
					}
					// place the end '\\' for the key
					// do this even in the failed-to-detect case so that we can log the full registry path
					*lpRegValue = '\\';

					//!! should we be explicitly checking for certain errors?
					if (ERROR_SUCCESS != lResult)
						return INSTALLSTATE_ABSENT;
				}
				return fSource ? INSTALLSTATE_SOURCE : INSTALLSTATE_LOCAL;
			}
			else // RFS file/folder
			{
				if(iDetectMode & DETECTMODE_VALIDATESOURCE)
				{
					// the RFS source cache is always ICHAR, never DCHAR. Thus when ICHAR!=DCHAR some ANSI<->Unicode
					// conversion will have to be done when grabbing values from the cache.
					CAPITempBuffer<ICHAR, 1> rgchValidatedSource;
					if (!rgchValidatedSource.SetSize(MAX_PATH))
						return INSTALLSTATE_BADCONFIG;
					unsigned int uiDisk = ((chFirst - '0') * 10) + (chSecond - '0');
					if (!rCacheInfo.RetrieveCachedSource(szUnicodeProductSQUID, uiDisk, rgchValidatedSource))
					{
						// fSafeToGloballyCache is set to true by ValidateSource if the resulting source
						// can be safely cached across API calls. (based on CSC status, media status, etc)
						bool fSafeToGloballyCache = false;

						bool fShowUI = true;
						if (fFromDescriptor && !AllowInstallation())
							fShowUI = false;

						// ValidateSource is always DCHAR, so the result must be placed into its own buffer
						// and copied into the validated source buffer before being placed in the cache. If
						// ICHAR==DCHAR, this is just pointer games, otherwise ANSI<->Unicode conversion
						// will happen during the copy.
						CAPITempBuffer<DCHAR, 1> rgchResolvedSource;
						if (!rgchResolvedSource.SetSize(MAX_PATH))
							return INSTALLSTATE_BADCONFIG;

						if (ERROR_SUCCESS != ValidateSource(szProductSQUID, uiDisk, fShowUI, rgchResolvedSource, fSafeToGloballyCache))
						{
							return INSTALLSTATE_SOURCEABSENT;
						}

						// resize the buffer and copy. Always grab the correct buffer size from the DCHAR
						// string so DBCS will be handled correctly.
						CACHED_CONVERTSTRING(ICHAR, szUnicodeResolvedSource, rgchResolvedSource);
						int cchResolvedSource = lstrlenW(szUnicodeResolvedSource);
						if (rgchValidatedSource.GetSize() < cchResolvedSource+1)
							rgchValidatedSource.SetSize(cchResolvedSource+1);
						if (FAILED(StringCchCopyW(rgchValidatedSource, rgchValidatedSource.GetSize(), szUnicodeResolvedSource)))
							return INSTALLSTATE_BADCONFIG;

						// if we have a cache and the source was validated as safe to cache, do so.
						if (fSafeToGloballyCache)
						{
							// save this validated source in the cache info structure
							rCacheInfo.SetCachedSource(szUnicodeProductSQUID, uiDisk, szUnicodeResolvedSource);
						}
					}
					
					// by now we have a validated source; we need to replace the ## with the resolved source
					CACHED_CONVERTSTRING(DCHAR, szDValidatedSource, rgchValidatedSource);
					int cchSource = lstrlen(szDValidatedSource);
					int cchRelativePath = (*pcchBuf - 3); // relative path doesn't include leading "##\"
					*pcchBuf = cchSource + cchRelativePath;
					if (cchPathBuf < (*pcchBuf + 1))
					{
						if (lpOriginalPathBuf)
							return INSTALLSTATE_MOREDATA;
						else
						{
							rgchOurPathBuf.SetSize(*pcchBuf + 1);
							lpPathBuf = rgchOurPathBuf;
						}
					}

					// Note: the source always has a trailing backslash, and the component path has a leading backslash
						
					// Example:
					// source:    D:\source\                   (len == 10)
					// lpPathBuf: ##\foo\bar\file.exe
					//            ##\>>>>>>>foo\bar\file.exe   (memmove)
					//            D:\source\foo\bar\file.exe   (memcpy)

					memmove(lpPathBuf + cchSource, lpPathBuf + 3, (cchRelativePath + 1)*sizeof(DCHAR));
					memcpy(lpPathBuf, static_cast<const DCHAR*>(szDValidatedSource), cchSource*sizeof(DCHAR));
				}
				return INSTALLSTATE_SOURCE;
			}
		}
		else
		{
			Assert(0);
			return INSTALLSTATE_BADCONFIG;
		}
	}
	else // local key file or folder
	{
		*(lpPathBuf+1) = chFirst == '\\' ? '\\' : ':'; // replace the chSharedDllCountToken, (if present)

		if (fProvidedBufferTooSmall)
			return INSTALLSTATE_MOREDATA;

		if(iDetectMode & DETECTMODE_VALIDATEPATH)
		{
			UINT uiErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
			DWORD dwAttributes = MsiGetFileAttributes(CMsInstApiConvertString(lpPathBuf));
			if(pdwLastErrorOnFileDetect) *pdwLastErrorOnFileDetect = GetLastError();
			SetErrorMode(uiErrorMode);

			if (0xFFFFFFFF == dwAttributes)
				return INSTALLSTATE_ABSENT;
		}
		return INSTALLSTATE_LOCAL;
	}

	return INSTALLSTATE_UNKNOWN;
}


extern "C"
INSTALLSTATE __stdcall MsiGetComponentPath(LPCDSTR szProduct, LPCDSTR szComponent,
														LPDSTR  lpPathBuf, DWORD *pcchBuf)
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;
	DCHAR szProductSQUID[cchProductCodePacked + 1];
	DCHAR szComponentSQUID[cchComponentIdPacked + 1];

	if (0 == szProduct || 0 == szComponent  || cchComponentId != lstrlen(szComponent) || !PackGUID(szComponent, szComponentSQUID) ||
		 cchProductCode != lstrlen(szProduct) || !PackGUID(szProduct, szProductSQUID) || 
		(lpPathBuf && !pcchBuf))
		return INSTALLSTATE_INVALIDARG;

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{

		INSTALLSTATE is = GetComponentPath(0, 
								static_cast<const char *>(CMsInstApiConvertString(szProductSQUID)), 
								static_cast<const char *>(CMsInstApiConvertString(szComponentSQUID)), 
								(char*)CWideToAnsiOutParam(lpPathBuf, pcchBuf, (int*)&is, INSTALLSTATE_MOREDATA, (int)INSTALLSTATE_SOURCE, (int)INSTALLSTATE_LOCAL),
								pcchBuf, 
								/*fFromDescriptor=*/false, g_RFSSourceCache);
		return is;
	}
	else // g_fWin9X == false
	{
#endif // MSIUNICODE

		INSTALLSTATE is = GetComponentPath(0, 
									szProductSQUID, 
									szComponentSQUID, 
									lpPathBuf,
									pcchBuf,
									/*fFromDescriptor=*/false, g_RFSSourceCache);
		if ( is != INSTALLSTATE_UNKNOWN )
			return is;
		
		// is = INSTALLSTATE_UNKNOWN at this point, which means that either
		// the product or the component are unknown
		INSTALLSTATE isProd = MsiQueryProductState(szProduct);
		if ( isProd != INSTALLSTATE_UNKNOWN && isProd != INSTALLSTATE_ABSENT )
			// the product is visible to the user.  This means that the component is not.
			return is;

		// check if the component & product are installed for the user or for the machine.
		CAPITempBuffer<DCHAR, 1> rgchComponentRegValue;
		if (!rgchComponentRegValue.SetSize(MAX_PATH))
			return INSTALLSTATE_BADCONFIG;

		DWORD dwValueType= REG_NONE;
		int iLimit = g_fWin9X ? 1 : 2;
		for ( int i = 1; i <= iLimit; i++ )
		{
			INSTALLSTATE isSid;
			if ( g_fWin9X )
				isSid = GetComponentClientState(0, szProductSQUID,
													  szComponentSQUID,
													  rgchComponentRegValue, dwValueType, 0);
			else
			{
				ICHAR szSID[cchMaxSID] = {0};
				if ( i == 1 )
				{
					// we're doing user
					if ( GetIntegerPolicyValue(szDisableUserInstallsValueName, fTrue) )
						// the policy disables us from doing the user
						continue;
					else
					{
						// policy set to allow user installs 
						ICHAR szUserSID[cchMaxSID];
						DWORD dwResult = GetCurrentUserStringSID(szUserSID);
						if ( dwResult == ERROR_SUCCESS )
							StringCbCopyW(szSID, sizeof(szSID), szUserSID);
						else
						{
							Assert(0);
							continue;
						}
					}
				}
				else
				{
					StringCbCopyW(szSID, sizeof(szSID), szLocalSystemSID);
				}

				isSid = GetComponentClientState(CMsInstApiConvertString(szSID), szProductSQUID,
													  szComponentSQUID,
													  rgchComponentRegValue, dwValueType, 0);
			}
			if ( isSid != INSTALLSTATE_UNKNOWN )
			{
				Assert(isSid == INSTALLSTATE_NOTUSED || *rgchComponentRegValue);
				return GetComponentPath(0, 
										szProductSQUID, 
										szComponentSQUID, 
										lpPathBuf,
										pcchBuf,
										/*fFromDescriptor=*/false, g_RFSSourceCache,
										DETECTMODE_VALIDATEALL /* = default value */, 
										rgchComponentRegValue, dwValueType);
			}
		}
		return is;
#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif // MSIUNICODE
}



extern "C"
INSTALLSTATE __stdcall MsiLocateComponent(LPCDSTR szComponent,
														LPDSTR  lpPathBuf, DWORD *pcchBuf)
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;
	DCHAR szProductCode[cchProductCode+1];

	if (0 == szComponent || cchComponentId != lstrlen(szComponent) || (lpPathBuf && !pcchBuf))
		return INSTALLSTATE_INVALIDARG;

	if (ERROR_SUCCESS != MsiGetProductCode(szComponent, szProductCode))
		return INSTALLSTATE_UNKNOWN; //?? Is this the correct thing to return?

	return MsiGetComponentPath(szProductCode, szComponent, lpPathBuf, pcchBuf);
}

extern "C"
INSTALLSTATE __stdcall MsiQueryFeatureState(LPCDSTR szProduct, LPCDSTR szFeature)
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;
	
	// Validate args
	int cchFeature;
	DCHAR szProductSQUID[cchProductCodePacked + 1];

	if (0 == szProduct  || cchProductCode    != lstrlen(szProduct) || !PackGUID(szProduct, szProductSQUID) ||
		 0 == szFeature  || cchMaxFeatureName <  (cchFeature = lstrlen(szFeature)))
		return INSTALLSTATE_INVALIDARG;
	
#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		return QueryFeatureStatePacked(
						static_cast<const char*>(CApiConvertString(szProductSQUID)), 
						static_cast<const char*>(CApiConvertString(szFeature)),
						fFalse, /*fFromDescriptor=*/false, g_RFSSourceCache);
	}
	else // g_fWin9X == false
	{
#endif // MSIUNICODE

		return QueryFeatureStatePacked(szProductSQUID, szFeature, fFalse, /*fFromDescriptor=*/false, g_RFSSourceCache);
#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif // MSIUNICODE
}

DWORD IncrementFeatureUsagePacked(LPCDSTR szProductSQUID, LPCDSTR szFeature)
{
	// Update usage metrics
	DWORD lResult;
	CRegHandle HFeatureKey;
	lResult = OpenInstalledFeatureUsageKeyPacked(szProductSQUID, HFeatureKey, false, g_samRead | KEY_SET_VALUE);

	if (ERROR_SUCCESS != lResult)
		return lResult;

	DWORD dwUsage = 0;
	DWORD dwType;
	DWORD cbUsage = sizeof(dwUsage);
	lResult = RegQueryValueEx(HFeatureKey, szFeature, 0,
		&dwType, (LPBYTE)&dwUsage, &cbUsage);


	if (ERROR_SUCCESS != lResult && ERROR_FILE_NOT_FOUND != lResult)
		return lResult;

	// Set current time. Increment usage count.
	SYSTEMTIME st;
	GetLocalTime(&st);
	
	WORD wDosDate = WORD(WORD(((int)st.wYear-1980) << 9) | 
						 WORD((int)st.wMonth << 5) | 
						 st.wDay);


	
	int iCount = dwUsage & 0x0000FFFF;
	if (iCount < 0xFFFF)
		iCount++;

	Assert((iCount & 0xFFFF) == iCount);

	dwUsage = (wDosDate << 16) | iCount;

	return RegSetValueEx(HFeatureKey, szFeature, 0, REG_DWORD, (CONST BYTE*)&dwUsage, cbUsage);
}


UINT ProvideComponent(LPCDSTR szProductCode,
					  LPCDSTR szFeature,
					  LPCDSTR szComponentId,
					  DWORD dwInstallMode,
					  LPDSTR lpPathBuf,
					  DWORD *pcchPathBuf,
					  bool fFromDescriptor,
					  CRFSCachedSourceInfo& rCacheInfo)
{
	CForbidTokenChangesDuringCall impForbid;
	
	DCHAR szProductSQUID[cchProductCodePacked + 1];
	DCHAR szComponentSQUID[cchComponentIdPacked + 1];

	if (!PackGUID(szProductCode, szProductSQUID) || !szComponentId ||
		 (*szComponentId && !PackGUID(szComponentId, szComponentSQUID)) ||
		 0 == szFeature  || FAILED(StringCchLength(szFeature, cchMaxFeatureName+1, NULL)) )
		return ERROR_INVALID_PARAMETER; 

	iaaAppAssignment iaaAssignType = iaaNone;
	int iKey = -1;
	int iResult;

	for (int c=0; c<2; c++)
	{
		CRegHandle HProductKey;

		if(INSTALLMODE_EXISTING != (int)dwInstallMode && INSTALLMODE_NODETECTION != (int)dwInstallMode && INSTALLMODE_DEFAULT != dwInstallMode && dwInstallMode != INSTALLMODE_NOSOURCERESOLUTION)
		{
			// reinstall flag
//!!remove	if ((ERROR_SUCCESS != (iResult = FeatureContainsComponentPacked(szProductSQUID, szFeature, szComponentSQUID))))
//!!remove		return iResult;

			if (fFromDescriptor && !AllowInstallation())
				return ERROR_INSTALL_FAILURE;

			iResult = MsiReinstallFeature(szProductCode, szFeature, dwInstallMode);
			if (ERROR_SUCCESS != iResult)
				return iResult;
		}
		else
		{
			INSTALLSTATE isFeature = QueryFeatureStatePacked(szProductSQUID, szFeature, (dwInstallMode == INSTALLMODE_NODETECTION || dwInstallMode == INSTALLMODE_NOSOURCERESOLUTION)? fFalse : fTrue, fFromDescriptor, rCacheInfo, iKey, &iaaAssignType);
			if ( iKey == -1 && IsValidAssignmentValue(iaaAssignType) )
				iKey = (int)iaaAssignType;
			switch (isFeature)
			{
			case INSTALLSTATE_SOURCE:
				if (dwInstallMode == INSTALLMODE_NOSOURCERESOLUTION)
					return ERROR_INSTALL_SOURCE_ABSENT;
			case INSTALLSTATE_LOCAL:
				break;
			case INSTALLSTATE_SOURCEABSENT:
				return ERROR_INSTALL_SOURCE_ABSENT;
			case INSTALLSTATE_UNKNOWN:
			{
				// is it the product that is unknown or is it the feature
				DWORD lResult = OpenAdvertisedProductKeyPacked(szProductSQUID, HProductKey, false, iKey);

				if (ERROR_SUCCESS != lResult)
					return ERROR_UNKNOWN_PRODUCT;
				else 
					return ERROR_UNKNOWN_FEATURE;
			}
			case INSTALLSTATE_ABSENT:
			case INSTALLSTATE_ADVERTISED:
				if(INSTALLMODE_EXISTING == (int)dwInstallMode || INSTALLMODE_NODETECTION == (int)dwInstallMode || dwInstallMode == INSTALLMODE_NOSOURCERESOLUTION)
					return ERROR_FILE_NOT_FOUND;

				DEBUGMSGE2(EVENTLOG_WARNING_TYPE, EVENTLOG_TEMPLATE_DETECTION, szProductCode, szFeature, szComponentId);

//!!remove		// can no longer support the following check due to possible lack of component mapping in HKLM
//!!remove		if ((ERROR_SUCCESS != (iResult = FeatureContainsComponentPacked(szProductSQUID, szFeature, szComponentSQUID))))
//!!remove			return iResult;

				if (fFromDescriptor && !AllowInstallation())
					return ERROR_INSTALL_FAILURE;

				iResult = MsiConfigureFeature(szProductCode, szFeature,
														INSTALLSTATE_DEFAULT);

				if (ERROR_SUCCESS != iResult)
					return iResult;
				break;
			case INSTALLSTATE_BROKEN:
				if(INSTALLMODE_EXISTING == (int)dwInstallMode  || INSTALLMODE_NODETECTION == (int)dwInstallMode  || dwInstallMode == INSTALLMODE_NOSOURCERESOLUTION)
					return ERROR_FILE_NOT_FOUND;

				DEBUGMSGE2(EVENTLOG_WARNING_TYPE, EVENTLOG_TEMPLATE_DETECTION, szProductCode, szFeature, szComponentId);

//!!remove		if ((ERROR_SUCCESS != (iResult = FeatureContainsComponentPacked(szProductSQUID, szFeature, szComponentSQUID))))
//!!remove			return iResult;
				
				if (fFromDescriptor && !AllowInstallation())
					return ERROR_INSTALL_FAILURE;

				iResult = MsiReinstallFeature(szProductCode, szFeature,        
															REINSTALLMODE_FILEMISSING|
															REINSTALLMODE_FILEOLDERVERSION|
															REINSTALLMODE_FILEVERIFY|
															REINSTALLMODE_MACHINEDATA|
															REINSTALLMODE_USERDATA |    
															REINSTALLMODE_SHORTCUT);
				if (ERROR_SUCCESS != iResult)
					return iResult;
				break;
			case INSTALLSTATE_DEFAULT:
			case INSTALLSTATE_INVALIDARG:
			default:
				Assert(0);
				return INSTALLSTATE_UNKNOWN; 
			}
		}

		// By now the component should be installed.

		if(!*szComponentId)
		{
			// we were not passed in the component id. Implies -
			// feature has only one component.
			// we have optimised the darwin descriptor 
			// AND we have never installed to this machine
			if(OpenInstalledFeatureKeyPacked(szProductSQUID, HProductKey, true, iKey, &iaaAssignType) != ERROR_SUCCESS)
			{
				DEBUGMSGE1(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_BAD_CONFIGURATION_KEY, CMsInstApiConvertString(szProductSQUID), HProductKey.GetKey());
				return ERROR_BAD_CONFIGURATION;
			}

			// Get Feature-Component mapping
			DWORD dwType;
			CAPITempBuffer<DCHAR, 1> szComponentList;
			if (!szComponentList.SetSize(cchExpectedMaxFeatureComponentList))
				return ERROR_OUTOFMEMORY;
			bool fBadConfigData = false;

			if(MsiRegQueryValueEx(HProductKey, szFeature, 0, &dwType, szComponentList, 0) != ERROR_SUCCESS || !(DCHAR* )szComponentList) 
			{
				fBadConfigData = true;
			}

			DCHAR *pchComponentList = szComponentList;
			if (fBadConfigData || *pchComponentList == 0 || lstrlen(pchComponentList) < cchComponentIdCompressed || *pchComponentList == chFeatureIdTerminator)
			{
				fBadConfigData = true;
			}

			DCHAR szComponent[cchComponentId + 1];

			if (fBadConfigData || !UnpackGUID(pchComponentList, szComponent, ipgCompressed))
			{
				fBadConfigData = true;
			}

			if(fBadConfigData || !PackGUID(szComponent, szComponentSQUID, ipgPacked)) // we need to go from ipgCompressed to ipgPacked
			{
				fBadConfigData = true;
			}

			if (fBadConfigData)
			{
				DEBUGMSGE2(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_BAD_CONFIGURATION_VALUE, szFeature, szComponentList, CMsInstApiConvertString(HProductKey.GetKey()));
				return ERROR_BAD_CONFIGURATION; 
			}

			if ( iKey == -1 && IsValidAssignmentValue(iaaAssignType) )
				iKey = (int)iaaAssignType;
		}

		DWORD cchOriginal = 0;
		
		if (pcchPathBuf)
			cchOriginal = *pcchPathBuf;

		int iDetectMode = DETECTMODE_VALIDATEALL; // default detect mode
		if(INSTALLMODE_NOSOURCERESOLUTION == dwInstallMode)
			iDetectMode = DETECTMODE_VALIDATENONE;
		else if(INSTALLMODE_NODETECTION == dwInstallMode)
			iDetectMode = DETECTMODE_VALIDATESOURCE;


		CAPITempBuffer<ICHAR,1> rgchUserSID;
		if (!rgchUserSID.SetSize(cchMaxSID))
			return ERROR_OUTOFMEMORY;
		rgchUserSID[0] = 0;
		if ( iaaAssignType == iaaUserAssign || iaaAssignType == iaaUserAssignNonManaged )
		{
			DWORD dwError = GetCurrentUserStringSID(rgchUserSID);
			if ( ERROR_SUCCESS != dwError )
				rgchUserSID[0] = 0;
		}
		else if ( iaaAssignType == iaaMachineAssign )
		{
			if (FAILED(StringCchCopyW(rgchUserSID, rgchUserSID.GetSize(), szLocalSystemSID)))
				return ERROR_FUNCTION_FAILED;
		}
		INSTALLSTATE isComp;
		if ( rgchUserSID[0] )
			isComp = GetComponentPath(CMsInstApiConvertString(rgchUserSID), szProductSQUID, szComponentSQUID, lpPathBuf, pcchPathBuf, fFromDescriptor, rCacheInfo, iDetectMode);
		else
			isComp = GetComponentPath(0, szProductSQUID, szComponentSQUID, lpPathBuf, pcchPathBuf, fFromDescriptor, rCacheInfo, iDetectMode);
		switch (isComp)
		{
		case INSTALLSTATE_LOCAL:
		case INSTALLSTATE_SOURCE:
			break;
		case INSTALLSTATE_SOURCEABSENT:
			return ERROR_INSTALL_SOURCE_ABSENT;
		case INSTALLSTATE_ABSENT:		
		case INSTALLSTATE_UNKNOWN:
		case INSTALLSTATE_INVALIDARG:
			if (c == 0)
			{
				if (pcchPathBuf)
					*pcchPathBuf = cchOriginal;
				continue;
			}
			DEBUGMSGE2(EVENTLOG_WARNING_TYPE, EVENTLOG_TEMPLATE_DETECTION, szProductCode, szFeature, szComponentId);
			return ERROR_INSTALL_FAILURE;
		case INSTALLSTATE_MOREDATA:
			return ERROR_MORE_DATA;
		case INSTALLSTATE_NOTUSED:
			return ERROR_INSTALL_NOTUSED;
		default:
			Assert(0);
			return ERROR_INSTALL_FAILURE; 
		}

		break;
	}
	IncrementFeatureUsagePacked(szProductSQUID, szFeature);
	return ERROR_SUCCESS;
}


extern "C"
UINT __stdcall MsiProvideComponent(LPCDSTR szProduct,
											 LPCDSTR szFeature, 
											 LPCDSTR szComponent,
											 DWORD dwInstallMode,
											 LPDSTR lpPathBuf,       
											 DWORD *pcchPathBuf)    
//----------------------------------------------
{
	DEBUGMSG4(MSITEXT("Entering MsiProvideComponent. Product: %s, Feature: %s, Component: %s, Install mode: %d"),
		szProduct?szProduct:MSITEXT(""), szFeature?szFeature:MSITEXT(""), szComponent?szComponent:MSITEXT(""), 
		(const DCHAR*)(INT_PTR)dwInstallMode);
	DEBUGMSG2(MSITEXT("Path buf: 0x%X, cchBuf: 0x%X"),	lpPathBuf, (const DCHAR*)pcchPathBuf);

	UINT uiRet;
	CForbidTokenChangesDuringCall impForbid;

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X)
	{
		uiRet = MsiProvideComponentA(CApiConvertString(szProduct),
											 CApiConvertString(szFeature),
											 CApiConvertString(szComponent),
											 dwInstallMode,
											 (char*)CWideToAnsiOutParam(lpPathBuf, pcchPathBuf, (int*)&uiRet),
											 pcchPathBuf);
	}
	else
	{
#endif // MSIUNICODE

		if (0 == szProduct  || lstrlen(szProduct)   != cchProductCode    ||
			 0 == szComponent|| lstrlen(szComponent) != cchComponentId    ||
			 0 == szFeature  || lstrlen(szFeature)    > cchMaxFeatureName ||
			 (lpPathBuf && !pcchPathBuf) ||
			 ((dwInstallMode != INSTALLMODE_EXISTING) && (dwInstallMode != INSTALLMODE_NODETECTION) &&
			  (dwInstallMode != INSTALLMODE_NOSOURCERESOLUTION) && 
			 (dwInstallMode & ~(REINSTALLMODE_REPAIR |
									  REINSTALLMODE_FILEMISSING |	
	 								  REINSTALLMODE_FILEOLDERVERSION | 
 									  REINSTALLMODE_FILEEQUALVERSION |  
					 				  REINSTALLMODE_FILEEXACT |        
									  REINSTALLMODE_FILEVERIFY |       
									  REINSTALLMODE_FILEREPLACE |      
									  REINSTALLMODE_MACHINEDATA |      
									  REINSTALLMODE_USERDATA |         
									  REINSTALLMODE_SHORTCUT))))
		{
			
			uiRet = ERROR_INVALID_PARAMETER;
		}
		else
		{
			uiRet = ProvideComponent(szProduct, szFeature, szComponent, dwInstallMode, lpPathBuf, pcchPathBuf, false, g_RFSSourceCache);
		}

#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif

	DEBUGMSG1(MSITEXT("MsiProvideComponent is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}


extern "C"
UINT __stdcall MsiEnumFeatures(LPCDSTR szProduct, DWORD iFeatureIndex,
										 LPDSTR lpFeatureBuf, LPDSTR lpParentBuf)
//----------------------------------------------
{
	if (!szProduct || (lstrlen(szProduct) != cchProductCode) ||
		 !lpFeatureBuf)
		 return ERROR_INVALID_PARAMETER;

	CForbidTokenChangesDuringCall impForbid;

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		return MsiEnumFeaturesA(
			CApiConvertString(szProduct),
			iFeatureIndex, 
			CWideToAnsiOutParam(lpFeatureBuf, MAX_FEATURE_CHARS+1),
			CWideToAnsiOutParam(lpParentBuf, MAX_FEATURE_CHARS+1));
		
	}
	else // g_fWin9X == false
	{
#endif // MSIUNICODE

		DWORD lResult;
		CRegHandle HProductKey;

		lResult = OpenAdvertisedFeatureKey(szProduct, HProductKey, false);

		if (ERROR_SUCCESS != lResult)
		{
			if (ERROR_FILE_NOT_FOUND == lResult)
				return ERROR_UNKNOWN_PRODUCT;
			else 
				return lResult;
		}

		DWORD cchValueName = (cchMaxFeatureName + 1);

		lResult = RegEnumValue(HProductKey, iFeatureIndex, 
						lpFeatureBuf, &cchValueName, 0, 0, 0, 0);

		if (ERROR_SUCCESS == lResult)
		{
			if (lpParentBuf)
			{
//!!JD  keep code below in temporarily for backward compatibility? Is it possible that stuff is permananently in HKCU?
				CAPITempBuffer<DCHAR, cchExpectedMaxFeatureComponentList+1> rgchComponentList;
				DWORD dwType;
			
				lResult = MsiRegQueryValueEx(HProductKey, lpFeatureBuf, 0,
								&dwType, rgchComponentList, 0);
				
				if ((ERROR_SUCCESS != lResult) || (REG_SZ != dwType))
				{
					return lResult;
				}

				DCHAR* pchComponentList = rgchComponentList;
				while (*pchComponentList && (*pchComponentList != chFeatureIdTerminator))
					pchComponentList++;

				if (*pchComponentList != 0 ) // feature name from old-version registration
					pchComponentList++;
				else  // either new format (bare feature name) or old: no parent
				{
//!!JD end of compatibility code
					pchComponentList = rgchComponentList;
					if (*pchComponentList == chAbsentToken)
						pchComponentList++;
//!!JD  keep code below in temporarily for backward compatibility
					if (*pchComponentList != 0  //!! temporary check in case old registration with component IDs
					 &&	ERROR_SUCCESS != RegQueryValueEx(HProductKey, pchComponentList, 0, 0, 0, 0)) //!! need to distinguish between parentless component list (old) and parent name (new)
						*pchComponentList = 0;
//!!JD end of compatibility code
				}
				while ((*lpParentBuf++ = *pchComponentList++) != 0)
					;
			}
			return ERROR_SUCCESS;

		}
		else if (ERROR_NO_MORE_ITEMS == lResult)
		{
			return ERROR_NO_MORE_ITEMS;
		}
		else
		{
			return lResult;
		}

#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif // MSIUNICODE
}

extern "C"
UINT __stdcall MsiGetFeatureParent(LPCDSTR szProduct, LPCDSTR szFeature, LPDSTR lpParentBuf)
//----------------------------------------------
{
	if (!szProduct || (lstrlen(szProduct) != cchProductCode) ||
		 !szFeature || !szFeature[0] ||
		 FAILED(StringCchLength(szFeature, cchMaxFeatureName+1, NULL)))
		return ERROR_INVALID_PARAMETER;

	CForbidTokenChangesDuringCall impForbid;

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		return MsiGetFeatureParentA(
			CMsInstApiConvertString(szProduct),
			CMsInstApiConvertString(szFeature),
			CWideToAnsiOutParam(lpParentBuf, MAX_FEATURE_CHARS+1));
		
	}
	else // g_fWin9X == false
	{
#endif // MSIUNICODE

		DWORD lResult;
		CRegHandle HProductKey;

		lResult = OpenAdvertisedFeatureKey(szProduct, HProductKey, false);

		if (ERROR_SUCCESS != lResult)
		{
			if (ERROR_FILE_NOT_FOUND == lResult)
				return ERROR_UNKNOWN_PRODUCT;
			else 
				return lResult;
		}

		DWORD cchValueName = (cchMaxFeatureName + 1);

		CAPITempBuffer<DCHAR, cchExpectedMaxFeatureComponentList+1> rgchComponentList;
		DWORD dwType;
		
		lResult = MsiRegQueryValueEx(HProductKey, szFeature, 0,
							&dwType, rgchComponentList, 0);
			
		if (ERROR_FILE_NOT_FOUND == lResult)
			return ERROR_UNKNOWN_FEATURE;

		if (ERROR_SUCCESS != lResult || REG_SZ != dwType)
			return lResult;

		if (lpParentBuf)
		{
//!!JD  keep code below in temporarily for backward compatibility? Is it possible that stuff is permananently in HKCU?
			DCHAR* pchComponentList = rgchComponentList;
			while (*pchComponentList && (*pchComponentList != chFeatureIdTerminator))
				pchComponentList++;

			if (*pchComponentList == chFeatureIdTerminator)
			{
				while ((*lpParentBuf++ = *++pchComponentList) != 0)
					;
			}
			else
			{
#if 1 //!!JD
				pchComponentList = rgchComponentList;
				if (*pchComponentList == chAbsentToken)
					pchComponentList++;
				if (*pchComponentList != 0  //!! temporary check in case old registration with component IDs
				 &&	ERROR_SUCCESS == RegQueryValueEx(HProductKey, pchComponentList, 0, 0, 0, 0)) //!! need to distinguish between parentless component list (old) and parent name (new)
//!!JD end of compatibility code
				{
					while ((*lpParentBuf++ = *pchComponentList++) != 0)
						;  //!! need to limit to MAX_FEATURE_CHARS by forcing null into buffer
				} 
				else
#endif //!!JD
				*lpParentBuf = 0;
			}
		}
		return ERROR_SUCCESS;
			
#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif // MSIUNICODE
}

INSTALLSTATE UseFeaturePacked(LPCDSTR szProductSQUID, LPCDSTR szFeature, bool fDetect)
{
	// Verify that feature is present

	BOOL fLocal = TRUE;
	INSTALLSTATE is = QueryFeatureStatePacked(szProductSQUID, szFeature, fDetect, /*fFromDescriptor=*/false, g_RFSSourceCache);

	switch (is)
	{
	case INSTALLSTATE_LOCAL:
	case INSTALLSTATE_SOURCE:
	case INSTALLSTATE_ADVERTISED:
		break;
	default:
		return is;
	}

	if (ERROR_SUCCESS != IncrementFeatureUsagePacked(szProductSQUID, szFeature))
		return INSTALLSTATE_BADCONFIG;

	return is;
}

extern "C"
INSTALLSTATE __stdcall MsiUseFeature(LPCDSTR szProduct, LPCDSTR szFeature)
//----------------------------------------------
{
	return MsiUseFeatureEx(szProduct, szFeature, 0, 0);
}

extern "C"
INSTALLSTATE __stdcall MsiUseFeatureEx(LPCDSTR szProduct, LPCDSTR szFeature, DWORD dwInstallMode, DWORD dwReserved)
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;
	
	DCHAR szProductSQUID[cchProductCodePacked + 1];
	int cchFeature;
	//!! Should cache metrics client side and send to server upon DLL unload
	if (!szProduct || (lstrlen(szProduct) != cchProductCode) || !PackGUID(szProduct, szProductSQUID) ||
		 !szFeature || ((cchFeature = lstrlen(szFeature)) > cchMaxFeatureName) ||
		 (dwInstallMode != 0 && dwInstallMode != INSTALLMODE_NODETECTION) || dwReserved != 0)
		 return INSTALLSTATE_INVALIDARG;

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		return UseFeaturePacked(
			static_cast<const char*>(CMsInstApiConvertString(szProductSQUID)),
			static_cast<const char*>(CMsInstApiConvertString(szFeature)),
			dwInstallMode != INSTALLMODE_NODETECTION);
	}
	else // g_fWin9X == false
	{
#endif // MSIUNICODE

	INSTALLSTATE is = UseFeaturePacked(szProductSQUID, szFeature, dwInstallMode != INSTALLMODE_NODETECTION);
	return is;
#if !defined(UNICODE) && defined(MSIUNICODE)
	}

#endif // MSIUNICODE
}

extern "C"
UINT __stdcall MsiEnableLog(
	DWORD     dwLogMode,   // bit flags designating operations to report
	LPCDSTR   szLogFile,   // log file, NULL to disable log
	DWORD     dwLogAttributes)     // 0x1 to append to existing file, 
								   // 0x2 to flush on each line
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;
	
	if (szLogFile == 0 || *szLogFile == 0) // turning off log
	{
		g_dwLogMode = 0;
		*g_szLogFile = 0;
	}
	else  // setting the log file
	{
		if (dwLogMode == 0)  // no modes
			return ERROR_INVALID_PARAMETER;  // should use defaults instead?
		else if (FAILED(StringCchLength(szLogFile, cchMaxPath+1, NULL)))
			return ERROR_INVALID_PARAMETER;
		g_fLogAppend = (dwLogAttributes & INSTALLLOGATTRIBUTES_APPEND) ? fTrue : fFalse;    // per-process
		g_fFlushEachLine = (dwLogAttributes & INSTALLLOGATTRIBUTES_FLUSHEACHLINE) ? true : false;
		g_dwLogMode = dwLogMode;   // per-process
		StringCbCopyW(g_szLogFile, sizeof(g_szLogFile), CMsInstApiConvertString(szLogFile));
	}
	return ERROR_SUCCESS;
}

extern "C"
UINT __stdcall MsiEnumComponentQualifiers(LPCDSTR  szComponent,
	DWORD iIndex, LPDSTR lpQualifierBuf, DWORD *pcchQualifierBuf,
	LPDSTR lpApplicationDataBuf, DWORD *pcchApplicationDataBuf
)
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;
	
	if (!szComponent || (lstrlen(szComponent) != cchComponentId) ||
		 !lpQualifierBuf || !pcchQualifierBuf || 
		 (lpApplicationDataBuf && !pcchApplicationDataBuf))
	{
		return ERROR_INVALID_PARAMETER;
	}

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		UINT uiRet = MsiEnumComponentQualifiersA(
			CMsInstApiConvertString(szComponent),
			iIndex,
			CWideToAnsiOutParam(lpQualifierBuf, pcchQualifierBuf, (int*)&uiRet),
			pcchQualifierBuf,
			CWideToAnsiOutParam(lpApplicationDataBuf, pcchApplicationDataBuf, (int*)&uiRet), //!! MaxQualifier to change
			pcchApplicationDataBuf);

		return uiRet;
	}
	else // g_fWin9X == false
	{
#endif // MSIUNICODE

		unsigned int uiKey    =  0;
		unsigned int uiOffset =  0;
		int iPrevIndex        = -1;

		bool fComponentChanged = false;

#ifdef MSIUNICODE
		const WCHAR* szPreviousComponent = MSITEXT("");
		g_EnumComponentQualifiers.GetInfo(uiKey, uiOffset, iPrevIndex, 0, &szPreviousComponent);
#else
		const char* szPreviousComponent = MSITEXT("");
		g_EnumComponentQualifiers.GetInfo(uiKey, uiOffset, iPrevIndex, &szPreviousComponent, 0);
#endif
		if (0 != lstrcmp(szPreviousComponent, szComponent))
			fComponentChanged = true;
		
		if(!fComponentChanged && iPrevIndex == iIndex)
		{
			if (iPrevIndex == -1)
				return ERROR_INVALID_PARAMETER;
			else
				uiOffset--; // try previous location
		}
		else if (fComponentChanged || ++iPrevIndex != iIndex) // if we receive an unexpected index then we start afresh
		{
			// we can't handle an unexpected index other than 0

			if (iIndex != 0)
				return ERROR_INVALID_PARAMETER;

			uiKey      = 0;
			uiOffset   = 0;
			iPrevIndex = 0;
		}

		CRegHandle HComponentKey;
		
		UINT uiFinalRes = ERROR_SUCCESS;
	
		bool fContinue = true;
		while(fContinue)
		{
			// iterate through all possible product keys, starting with uiKey, until we 
			// find a key that exists or we get an error

			for (;;)
			{
				uiFinalRes = OpenAdvertisedSubKey(szGPTComponentsKey, szComponent, HComponentKey, false, uiKey);
				if (ERROR_FILE_NOT_FOUND != uiFinalRes)
					break; // from for(;;)
				
				uiKey++;
			}

			if (ERROR_SUCCESS == uiFinalRes)
			{
				CAPITempBuffer<DCHAR, 1> rgchOurApplicationDataBuf;
				CAPITempBuffer<DCHAR, 1> rgchOurQualifierBuf;
				if (!rgchOurApplicationDataBuf.SetSize(MAX_PATH) || !rgchOurQualifierBuf.SetSize(MAX_PATH))
					return ERROR_OUTOFMEMORY;

				LPDSTR lpDataBuf;
				LPDSTR lpQualBuf; 
				DWORD cchValueName;
				DWORD cbValue;

				// try the passed in qualifier first
				lpQualBuf = lpQualifierBuf;
				cchValueName = *pcchQualifierBuf;

				if (pcchApplicationDataBuf) // we need to return the application-set description or at least the size of
				{
					lpDataBuf = rgchOurApplicationDataBuf;
					cbValue = rgchOurApplicationDataBuf.GetSize() * sizeof(DCHAR);
				}
				else
				{
					lpDataBuf = 0;
					cbValue = 0;
				}

				for (int cRetry = 0 ; cRetry < 2; cRetry++)
				{

					uiFinalRes = RegEnumValue(HComponentKey, 
												  uiOffset,
												  lpQualBuf,
												  &cchValueName, 
												  0, 0, 
												  (LPBYTE)lpDataBuf, 
												  &cbValue);

					if(ERROR_SUCCESS == uiFinalRes)
					{
						// we've found the product in the current key. now we need to make sure that 
						// the product isn't in any of the higher priority keys. if it is then we
						// ignore this product, as it's effectively masked by the higher priority key

						bool fFound = false;
						for (int c = 0; c < uiKey && !fFound; c++)
						{
							CRegHandle HKey;
							UINT ui = OpenAdvertisedSubKey(szGPTComponentsKey, szComponent, HKey, false, c);
							if (ui != ERROR_SUCCESS)
								continue;

							if(ERROR_SUCCESS == RegQueryValueEx(HKey, lpQualBuf, 0, 0, 0, 0))
								fFound = true;
						}
					
						if (fFound)
						{
							// skip this entry if it was in a higher priority key
							uiOffset++;
							break; // from for(int cRetry = 0 ; cRetry < 2; cRetry++)
						}
						else
						{
							// the qualifier wasn't found in a higher priority key. we can return it.
							if (pcchApplicationDataBuf) // we need to return the application-set description ot at least the size of
							{
								// remove the Darwin descriptor from the beginning
								DWORD cchArgsOffset;
								if(FALSE == DecomposeDescriptor(lpDataBuf, 0, 0, 0, &cchArgsOffset))
								{
									// malformed qualified component entry
									OpenAdvertisedComponentKey(szComponent, HComponentKey, true);
									DEBUGMSGE2(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_BAD_CONFIGURATION_VALUE, CMsInstApiConvertString(lpQualBuf), CMsInstApiConvertString(lpDataBuf), HComponentKey.GetKey());
									uiFinalRes = ERROR_BAD_CONFIGURATION;
									fContinue = false;
									break; // from for(int cRetry = 0 ; cRetry < 2; cRetry++)
								}

								int cchDataSize = lstrlen(lpDataBuf + cchArgsOffset);
								if(lpApplicationDataBuf)// we need to return the application-set description
								{
									// do we have enough space in the input buffer
									if(*pcchApplicationDataBuf < cchDataSize + 1)
									{
										uiFinalRes = ERROR_MORE_DATA;
									}
									else
									{
										// copy the app data into the out buffer
										memmove(lpApplicationDataBuf, lpDataBuf + cchArgsOffset, (cchDataSize + 1)*sizeof(DCHAR));
									}
								}
								*pcchApplicationDataBuf = cchDataSize;
							}		

							*pcchQualifierBuf = cchValueName;
							if(lpQualBuf != lpQualifierBuf)
							{
								// we had to allocate our own buffer for the qualifier
								uiFinalRes = ERROR_MORE_DATA;
							}
							fContinue = false;
							break; // from for(int cRetry = 0 ; cRetry < 2; cRetry++)
						}
					}
					else if(ERROR_NO_MORE_ITEMS == uiFinalRes)
					{
						// we've run out of items in the current products key. time to move on to the next one.
						uiKey++;
						uiOffset = 0;
						break; // from for(int cRetry = 0 ; cRetry < 2; cRetry++)
					}
					else if(ERROR_MORE_DATA == uiFinalRes)
					{
						uiFinalRes = RegQueryInfoKey (
							HComponentKey,
							0,
							0,
							0,
							0,
							0,
							0,
							0,
							&cchValueName, // max value name
							&cbValue,// max value 
							0,
							0);

						if (ERROR_SUCCESS == uiFinalRes)
						{
							// we may have to define our own buffer for the qualifier just to get the exact qualifier size
							if(++cchValueName > *pcchQualifierBuf)
							{
								rgchOurQualifierBuf.SetSize(cchValueName);
								lpQualBuf = rgchOurQualifierBuf;
							}

							if (pcchApplicationDataBuf && cbValue/sizeof(DCHAR) > rgchOurApplicationDataBuf.GetSize())
							{
								rgchOurApplicationDataBuf.SetSize(cbValue/sizeof(DCHAR));
								lpDataBuf = rgchOurApplicationDataBuf;
							}
						}
						else
						{
							fContinue = false;
							break;
						}

					}
					else 
					{
						fContinue = false;
						break; // from for(int cRetry = 0 ; cRetry < 2; cRetry++)
					}
				} // end of for(int cRetry = 0 ; cRetry < 2; cRetry++)
			}
			else
				fContinue = false;
		}
		if (ERROR_NO_MORE_ITEMS == uiFinalRes)
		{
			if(iIndex)
				g_EnumComponentQualifiers.RemoveThreadInfo();
			else
				uiFinalRes = ERROR_UNKNOWN_COMPONENT;
		}
		else if ( !g_EnumComponentQualifiers.SetInfo(uiKey,
																	++uiOffset,
																	iPrevIndex,
																	szComponent) )
		{
			uiFinalRes = ERROR_NOT_ENOUGH_MEMORY;
		}
		
		return uiFinalRes;

#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif
}

UINT EnumAssemblies(DWORD dwAssemblyInfo,LPCDSTR  szAppCtx,
	DWORD iIndex, LPDSTR lpAssemblyNameBuf, DWORD *pcchAssemblyBuf,
	LPDSTR lpDescriptorBuf, DWORD *pcchDescriptorBuf
)
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;
	
	if (!szAppCtx || !lpAssemblyNameBuf || !pcchAssemblyBuf || (lpDescriptorBuf && !pcchDescriptorBuf) ||
		 (dwAssemblyInfo != MSIASSEMBLYINFO_WIN32ASSEMBLY && dwAssemblyInfo != MSIASSEMBLYINFO_NETASSEMBLY))
	{
		return ERROR_INVALID_PARAMETER;
	}

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		UINT uiRet = EnumAssemblies(
			dwAssemblyInfo, 
			static_cast<const char*>(CMsInstApiConvertString(szAppCtx)),
			iIndex,
			(char*)CWideToAnsiOutParam(lpAssemblyNameBuf, pcchAssemblyBuf, (int*)&uiRet),
			pcchAssemblyBuf,
			(char*)CWideToAnsiOutParam(lpDescriptorBuf, pcchDescriptorBuf, (int*)&uiRet),
			pcchDescriptorBuf);

		return uiRet;
	}
	else // g_fWin9X == false
	{
#endif // MSIUNICODE

		unsigned int uiKey    =  0;
		unsigned int uiOffset =  0;
		int iPrevIndex        = -1;

		bool fAppCtxChanged = false;

#ifdef MSIUNICODE
		const WCHAR* szPreviousfAppCtx = MSITEXT("");
		g_EnumAssemblies.GetInfo(uiKey, uiOffset, iPrevIndex, 0, &szPreviousfAppCtx);
#else
		const char* szPreviousfAppCtx = MSITEXT("");
		g_EnumAssemblies.GetInfo(uiKey, uiOffset, iPrevIndex, &szPreviousfAppCtx, 0);
#endif
		if (0 != lstrcmp(szPreviousfAppCtx, szAppCtx))
			fAppCtxChanged = true;
		
		if(!fAppCtxChanged && iPrevIndex == iIndex)
		{
			if (iPrevIndex == -1)
				return ERROR_INVALID_PARAMETER;
			else
				uiOffset--; // try previous location
		}
		else if (fAppCtxChanged || ++iPrevIndex != iIndex) // if we receive an unexpected index then we start afresh
		{
			// we can't handle an unexpected index other than 0

			if (iIndex != 0)
				return ERROR_INVALID_PARAMETER;

			uiKey      = 0;
			uiOffset   = 0;
			iPrevIndex = 0;
		}

		CRegHandle HAssemblyKey;
		
		UINT uiFinalRes = ERROR_SUCCESS;
	
		bool fContinue = true;
		
		// save passed in buffer sizes
		DWORD dwBufDescIn = 0;
		DWORD dwBufNameIn = 0;

		if(pcchDescriptorBuf)
			dwBufDescIn = *pcchDescriptorBuf;
		if(pcchAssemblyBuf)
			dwBufNameIn = *pcchAssemblyBuf;

		while(fContinue)
		{
			// set the buffer sizes back to the one that was passed in
			if(pcchDescriptorBuf)
				*pcchDescriptorBuf = dwBufDescIn;

			if(pcchAssemblyBuf)
				*pcchAssemblyBuf = dwBufNameIn;

			// iterate through all possible product keys, starting with uiKey, until we 
			// find a key that exists or we get an error

			for (;;)
			{
				uiFinalRes = OpenAdvertisedSubKeyNonGUID((dwAssemblyInfo & MSIASSEMBLYINFO_WIN32ASSEMBLY) ? szGPTWin32AssembliesKey : szGPTNetAssembliesKey, szAppCtx, HAssemblyKey, false, uiKey);
				if (ERROR_FILE_NOT_FOUND != uiFinalRes)
					break; // from for(;;)
				
				uiKey++;
			}

			if (ERROR_SUCCESS == uiFinalRes)
			{
				if(pcchDescriptorBuf)
					*pcchDescriptorBuf = (*pcchDescriptorBuf)*sizeof(DCHAR);
	

				uiFinalRes = RegEnumValue(HAssemblyKey, 
											  uiOffset,
											  lpAssemblyNameBuf,
											  pcchAssemblyBuf, 
											  0, 0, 
											  (LPBYTE)lpDescriptorBuf,
											  pcchDescriptorBuf);

				if (ERROR_MORE_DATA == uiFinalRes)
				{
					RegQueryInfoKey(HAssemblyKey, 0, 0, 0, 0, 0, 0, 0, pcchAssemblyBuf, pcchDescriptorBuf, 0, 0);
				}
				if(pcchDescriptorBuf)
					*pcchDescriptorBuf = (*pcchDescriptorBuf)/sizeof(DCHAR);


				if(ERROR_SUCCESS == uiFinalRes)
				{
					// we've found the product in the current key. now we need to make sure that 
					// the product isn't in any of the higher priority keys. if it is then we
					// ignore this product, as it's effectively masked by the higher priority key

					bool fFound = false;
					for (int c = 0; c < uiKey && !fFound; c++)
					{
						CRegHandle HKey;
						UINT ui = OpenAdvertisedSubKeyNonGUID((dwAssemblyInfo & MSIASSEMBLYINFO_WIN32ASSEMBLY) ? szGPTWin32AssembliesKey : szGPTNetAssembliesKey, szAppCtx, HKey, false, c);
						if (ui != ERROR_SUCCESS)
							continue;

						if(ERROR_SUCCESS == RegQueryValueEx(HKey, lpAssemblyNameBuf, 0, 0, 0, 0))
							fFound = true;
					}
				
					if (fFound)
					{
						// skip this entry if it was in a higher priority key
						uiOffset++;
					}
					else
					{
						fContinue = false;
						break; // from for(int cRetry = 0 ; cRetry < 2; cRetry++)
					}
				}
				else if(ERROR_NO_MORE_ITEMS == uiFinalRes)
				{
					// we've run out of items in the current products key. time to move on to the next one.
					uiKey++;
					uiOffset = 0;
				}
				else 
				{
					fContinue = false;
				}
			}
			else
				fContinue = false;
		}
		if (ERROR_NO_MORE_ITEMS == uiFinalRes)
		{
			if(iIndex)
				g_EnumAssemblies.RemoveThreadInfo();
			else
				uiFinalRes = ERROR_UNKNOWN_COMPONENT;
		}
		else if ( !g_EnumAssemblies.SetInfo(uiKey,
														++uiOffset,
														iPrevIndex,
														szAppCtx) )
		{
			uiFinalRes = ERROR_NOT_ENOUGH_MEMORY;
		}
			
		return uiFinalRes;

#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif
}

extern "C"
UINT __stdcall MsiGetQualifierDescription(LPCDSTR szComponent, LPCDSTR szQualifier,
									LPDSTR lpApplicationDataBuf, DWORD *pcchApplicationDataBuf
)
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;
	
	if (!szComponent || (lstrlen(szComponent) != cchComponentId) ||
		!pcchApplicationDataBuf)
		return ERROR_INVALID_PARAMETER;

	if (!szQualifier)
		szQualifier = MSITEXT("");

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		UINT uiRet = MsiGetQualifierDescriptionA(
			CMsInstApiConvertString(szComponent),
			CMsInstApiConvertString(szQualifier),
			CWideToAnsiOutParam(lpApplicationDataBuf, pcchApplicationDataBuf, (int*)&uiRet),
			pcchApplicationDataBuf);
		
		return uiRet;
	}
	else // g_fWin9X == false
	{
#endif // MSIUNICODE

	DWORD lResult;
	CRegHandle HComponentKey;

	lResult = OpenAdvertisedComponentKey(szComponent, HComponentKey, false);

	if (ERROR_FILE_NOT_FOUND == lResult)
		return ERROR_UNKNOWN_COMPONENT;

	if (ERROR_SUCCESS != lResult)
		return lResult;
	
	CAPITempBuffer<DCHAR, 1> rgchDescriptor;
	if (!rgchDescriptor.SetSize(cchMaxDescriptor + 1 + MAX_PATH))
		return ERROR_OUTOFMEMORY;

	DWORD dwType;
	DWORD cbValue = rgchDescriptor.GetSize() * sizeof(DCHAR);
	lResult = MsiRegQueryValueEx(HComponentKey, szQualifier, 0, &dwType, rgchDescriptor, 0);

	if (ERROR_FILE_NOT_FOUND == lResult)
		return ERROR_INDEX_ABSENT;

	if (ERROR_SUCCESS != lResult)
		return lResult;

	// remove the Darwin descriptor from the beginning
	DWORD cchArgsOffset;
	if(FALSE == DecomposeDescriptor(rgchDescriptor, 0, 0, 0, &cchArgsOffset))
	{
		// malformed qualified component entry
		OpenAdvertisedComponentKey(szComponent, HComponentKey, true);
		DEBUGMSGE2(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_BAD_CONFIGURATION_VALUE, CMsInstApiConvertString(szQualifier), CMsInstApiConvertString(rgchDescriptor), HComponentKey.GetKey());
		return ERROR_BAD_CONFIGURATION;
	}

	int cchDataSize = lstrlen((DCHAR*)rgchDescriptor + cchArgsOffset);
	if(lpApplicationDataBuf)// we need to return the application-set description
	{
		// do we have enough space in the input buffer
		if(*pcchApplicationDataBuf < cchDataSize + 1)
		{
			lResult = ERROR_MORE_DATA;
		}
		else
		{
			// copy the app data into the out buffer
			memmove(lpApplicationDataBuf, (DCHAR*)rgchDescriptor + cchArgsOffset, (cchDataSize + 1)*sizeof(DCHAR));
		}
		*pcchApplicationDataBuf = cchDataSize;
	}		
	return lResult;

#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif
}

extern "C"
UINT __stdcall MsiGetFeatureUsage(LPCDSTR szProduct, LPCDSTR szFeature,
											DWORD  *pdwUseCount, WORD *pwDateUsed)
//----------------------------------------------
{
	int cchFeature;

	if (!szProduct || (lstrlen(szProduct) != cchProductCode) ||
		 !szFeature || ((cchFeature = lstrlen(szFeature)) > cchMaxFeatureName))
		 return ERROR_INVALID_PARAMETER;

	CForbidTokenChangesDuringCall impForbid;

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		return MsiGetFeatureUsageA(
			CMsInstApiConvertString(szProduct), 
			CMsInstApiConvertString(szFeature),
			pdwUseCount, pwDateUsed);
	}
	else // g_fWin9X == false
	{
#endif
		CRegHandle HFeatureKey;
		DWORD lResult;

		lResult = OpenInstalledFeatureUsageKey(szProduct, HFeatureKey, false, g_samRead);
		if (ERROR_SUCCESS != lResult)
		{
			if (ERROR_FILE_NOT_FOUND == lResult)
				return ERROR_UNKNOWN_PRODUCT;
			else
				return lResult;
		}
		
		DWORD dwUsage = 0;
		DWORD dwType;
		DWORD cbUsage = sizeof(dwUsage);
		lResult = RegQueryValueEx(HFeatureKey, szFeature, 0,
			&dwType, (LPBYTE)&dwUsage, &cbUsage);

		if (ERROR_SUCCESS == lResult)
		{
			if (pdwUseCount)
				*pdwUseCount = 0x0000FFFF & dwUsage;

			if (pwDateUsed)
				*pwDateUsed = (WORD)((unsigned int)dwUsage >> 16);

			return ERROR_SUCCESS;
		}
		else if (ERROR_FILE_NOT_FOUND == lResult)
		{
			// feature no known
			if (pdwUseCount)
				*pdwUseCount = 0;

			if (pwDateUsed)
				*pwDateUsed = 0;
		}
		else
		{
			return lResult;
		}
#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif // MSIUNICODE
	return ERROR_SUCCESS;
}


UINT __stdcall MsiGetProductInfo(
	LPCDSTR   szProduct,      // product code, string GUID, or descriptor
	LPCDSTR   szProperty,     // property name, case-sensitive
	LPDSTR    lpValueBuf,     // returned value, NULL if not desired
	DWORD     *pcchValueBuf)  // in/out buffer character count
{
	CForbidTokenChangesDuringCall impForbid;
	
	DCHAR szProductSQUID[cchProductCodePacked + 1];

	if (0 == szProduct || 0 == szProperty ||
		 (lpValueBuf && !pcchValueBuf))
	{
		return ERROR_INVALID_PARAMETER;
	}

	DCHAR szProductCode[cchProductCode+1];

	if (cchProductCode != lstrlen(szProduct))
	{
		if (!DecomposeDescriptor(szProduct, szProductCode, 0,
										 0, 0, 0))
		{
			 return ERROR_INVALID_PARAMETER;
		}
		szProduct = szProductCode;
	}

	if (!PackGUID(szProduct, szProductSQUID))
	{
		return ERROR_INVALID_PARAMETER;
	}

	return GetInfo(szProductSQUID,ptProduct,szProperty,lpValueBuf,pcchValueBuf);
}

INSTALLSTATE __stdcall MsiQueryProductState(
	LPCDSTR  szProduct)
{
	CForbidTokenChangesDuringCall impForbid;

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
		return MsiQueryProductStateA(CMsInstApiConvertString(szProduct));
#endif // MSIUNICODE

	DCHAR szProductCode[cchProductCode+1];

	if (0 == szProduct)
	{
		return INSTALLSTATE_INVALIDARG;
	}

	if (cchProductCode != lstrlen(szProduct))
	{
		if (!DecomposeDescriptor(szProduct, szProductCode, 0,
										 0, 0, 0))
		{
			 return INSTALLSTATE_INVALIDARG;
		}
		szProduct = szProductCode;
	}
	
	//!! Need to add INSTALLSTATE_INCOMPLETE
	CRegHandle hKey;
	INSTALLSTATE is = INSTALLSTATE_UNKNOWN;

	DWORD cchWindowsInstaller = 0;
	bool fPublishedInfo    = (ERROR_SUCCESS == OpenAdvertisedProductKey(szProduct, hKey, false));
	bool fLocalMachineInfo = (ERROR_SUCCESS == MsiGetProductInfo(szProduct, MSITEXT("WindowsInstaller"), 0, &cchWindowsInstaller)) && (cchWindowsInstaller != 0);
	
	// we are registered on the machine 
	// to ensure that we dont honour previously installed per user non-managed installations for non-admins
	// when we now have a per user managed installation 
	// we check if the per user managed installation has happened on the machine
	// for this we check if the localpackage is registered on the machine
	// if not, then we will return the state of the product to be advertised as opposed to installed
	if(fLocalMachineInfo && !IsAdmin()) 
	{
		fLocalMachineInfo = (ERROR_SUCCESS == MsiGetProductInfo(szProduct, CMsInstApiConvertString(INSTALLPROPERTY_LOCALPACKAGE), 0, &cchWindowsInstaller)) && (cchWindowsInstaller != 0);
		if(!fLocalMachineInfo)
		{
			// product initially appeared as installed, but not in correct context
			DEBUGMSG1(MSITEXT("NOTE: non-managed installation of product %s exists, but will be ignored"), szProduct);
		}
	}
	
	if (fPublishedInfo)
	{
		if (fLocalMachineInfo)
			is = INSTALLSTATE_DEFAULT;
		else
			is = INSTALLSTATE_ADVERTISED;
	}
	else if (fLocalMachineInfo)
	{
		is = INSTALLSTATE_ABSENT;
	}
	if ( is != INSTALLSTATE_UNKNOWN )
		return is;

	// once we've got to this point, szProduct is not installed by/visible to
	// the current user.  We check if it had been installed by other users.
	for (UINT uiUser = 0; ; uiUser++)
	{
		CRegHandle hProperties;
		DWORD dwType = REG_NONE;
		cchWindowsInstaller = 0;
		DWORD dwResult = OpenEnumedUserInstalledProductInstallPropertiesKey(uiUser,
																							szProduct,
																							hKey);
		if ( dwResult == ERROR_SUCCESS )
		{
			dwResult = RegQueryValueEx(hKey, MSITEXT("WindowsInstaller"), NULL,
												&dwType, NULL, &cchWindowsInstaller);
		}
		if ( dwResult == ERROR_FILE_NOT_FOUND )
			continue; // okay - OpenEnumedUserInstalledProductInstallPropertiesKey should never return ERROR_FILE_NOT_FOUND if we run out of users

		else if ( dwResult != ERROR_SUCCESS )
			return INSTALLSTATE_UNKNOWN;
		
		if ( dwType == REG_DWORD && cchWindowsInstaller != 0 )
			// szProduct had been installed by another user
			return INSTALLSTATE_ABSENT;
	}

	return INSTALLSTATE_UNKNOWN;
}

bool ShouldLogCmdLine(void);

//____________________________________________________________________________
//
// API's that potentially invoke an installation
//____________________________________________________________________________

extern "C"
UINT __stdcall MsiInstallProduct(LPCDSTR szPackagePath,
	LPCDSTR   szCommandLine)
//----------------------------------------------
{
	DEBUGMSG2(MSITEXT("Entering MsiInstallProduct. Packagepath: %s, Commandline: %s"), 
					  szPackagePath?szPackagePath:MSITEXT(""), 
					  ShouldLogCmdLine() ? (szCommandLine ? szCommandLine : MSITEXT("")) : MSITEXT("**********"));

	CForbidTokenChangesDuringCall impForbid;
	
	UINT uiRet;
	if (0 == szPackagePath)
		uiRet = ERROR_INVALID_PARAMETER;
	else
	{
		ireEnum ireSpec = irePackagePath;
		if (szPackagePath[0] == '#')   // database handle passed in
		{
			szPackagePath++;
			ireSpec = ireDatabaseHandle;
		}
		uiRet = RunEngine(ireSpec, CMsInstApiConvertString(szPackagePath), 0, CMsInstApiConvertString(szCommandLine), GetStandardUILevel(), (iioEnum)iioMustAccessInstallerKey);
	}
	
	DEBUGMSG1(MSITEXT("MsiInstallProduct is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}

extern "C"
UINT __stdcall MsiReinstallProduct(
	LPCDSTR      szProduct,
	DWORD        dwReinstallMode) // one or more REINSTALLMODE flags

//----------------------------------------------
{
	DEBUGMSG2(MSITEXT("Entering MsiReinstallProduct. Product: %s, Reinstallmode: %d"),
		szProduct?szProduct:MSITEXT(""), (const DCHAR*)(INT_PTR)dwReinstallMode);

	CForbidTokenChangesDuringCall impForbid;

	UINT uiRet;

	// validate args
	if (0 == szProduct || cchProductCode != lstrlen(szProduct) || 
		 0 == dwReinstallMode)
	{
		uiRet = ERROR_INVALID_PARAMETER;
	}
	else
	{
		uiRet = ConfigureOrReinstallFeatureOrProduct(CMsInstApiConvertString(szProduct), 0, (INSTALLSTATE)0, 
													dwReinstallMode, 0, GetStandardUILevel(), 0);
	}
	
	DEBUGMSG1(MSITEXT("MsiReinstallProduct is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}

extern "C"
UINT __stdcall MsiCollectUserInfo(LPCDSTR szProduct)
//----------------------------------------------
{
	DEBUGMSG1(MSITEXT("Entering MsiCollectUserInfo. Product: %s"), szProduct ? szProduct : MSITEXT(""));
	UINT uiRet;

	CForbidTokenChangesDuringCall impForbid;

	if (0 == szProduct || cchProductCode != lstrlen(szProduct))
	{
		uiRet = ERROR_INVALID_PARAMETER;
	}
	else
	{
		uiRet = RunEngine(ireProductCode, CMsInstApiConvertString(szProduct), IACTIONNAME_COLLECTUSERINFO, 0, GetStandardUILevel(), (iioEnum)0);
	}
	
	DEBUGMSG1(MSITEXT("MsiCollectUserInfo is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}


extern "C"
UINT __stdcall MsiConfigureFeature(
	LPCDSTR  szProduct,
	LPCDSTR  szFeature,
	INSTALLSTATE eInstallState)    // local/source/default/absent
//----------------------------------------------
{
	DEBUGMSG3(MSITEXT("Entering MsiConfigureFeature. Product: %s, Feature: %s, Installstate: %d"),
		szProduct?szProduct:MSITEXT(""), szFeature?szFeature:MSITEXT(""), (const DCHAR*)eInstallState);

	CForbidTokenChangesDuringCall impForbid;

	UINT uiRet;
	int cchFeature;
	if (szProduct == 0 || lstrlen(szProduct) != cchProductCode    ||
		 szFeature == 0 || (cchFeature = lstrlen(szFeature)) >  cchMaxFeatureName)
	{
		uiRet = ERROR_INVALID_PARAMETER;
	}
	else
	{
		uiRet = ConfigureOrReinstallFeatureOrProduct(CMsInstApiConvertString(szProduct), CMsInstApiConvertString(szFeature),
					eInstallState, 0, 0, GetStandardUILevel(), 0);
	}

	DEBUGMSG1(MSITEXT("MsiConfigureFeature is returning: %d"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}


extern "C"
UINT __stdcall MsiReinstallFeature(LPCDSTR szProduct, LPCDSTR szFeature,        
											  DWORD dwReinstallMode)
//----------------------------------------------
{
#ifdef PROFILE
//	StartCAPAll();
#endif //PROFILE
	DEBUGMSG3(MSITEXT("Entering MsiReinstallFeature. Product: %s, Feature: %s, Reinstallmode: %d"),
		szProduct?szProduct:MSITEXT(""), szFeature?szFeature:MSITEXT(""), (const DCHAR*)(INT_PTR)dwReinstallMode);

	CForbidTokenChangesDuringCall impForbid;

	UINT uiRet;

	int cchFeature;
	if (0 == szProduct  || lstrlen(szProduct)   != cchProductCode   ||
		 0 == szFeature  || (cchFeature = lstrlen(szFeature)) > cchMaxFeatureName ||
		 0 == dwReinstallMode)
	{
		uiRet = ERROR_INVALID_PARAMETER;
	}
	else
	{
		uiRet = ConfigureOrReinstallFeatureOrProduct(CMsInstApiConvertString(szProduct), CMsInstApiConvertString(szFeature), (INSTALLSTATE)0, 
													dwReinstallMode, 0, GetStandardUILevel(), 0);
	}

	DEBUGMSG1(MSITEXT("MsiReinstallFeature is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
#ifdef PROFILE
//	StopCAPAll();
#endif //PROFILE
	return uiRet;
}

UINT __stdcall MsiInstallMissingFile(
	LPCDSTR      szProduct, 
	LPCDSTR      szFile)
//----------------------------------------------
{
	DEBUGMSG2(MSITEXT("Entering MsiInstallMissingFile. Product: %s, File: %s"), szProduct?szProduct:MSITEXT(""), szFile?szFile:MSITEXT(""));

	UINT uiRet;

	CForbidTokenChangesDuringCall impForbid;

	// Validate args
	if (!szProduct || cchProductCode != lstrlen(szProduct) || !szFile ||
		 FAILED(StringCchLength(szFile, cchMaxPath+1, NULL)))
		uiRet = ERROR_INVALID_PARAMETER;
	else
	{
		const int cchExpectedProperties = 1 + sizeof(IPROPNAME_FILEADDLOCAL) + 1 + cchExpectedMaxPath + 1;
		
		CAPITempBuffer<ICHAR, 1> rgchProperties;
		if (!rgchProperties.SetSize(cchExpectedProperties))
			return ERROR_OUTOFMEMORY;

		int cchFile = lstrlen(szFile);
		if (cchFile > cchExpectedMaxPath)
			rgchProperties.SetSize(cchExpectedProperties + (cchFile - cchExpectedMaxPath));
			
		StringCchCopyW(rgchProperties, rgchProperties.GetSize(), IPROPNAME_FILEADDLOCAL);
		StringCchCatW(rgchProperties, rgchProperties.GetSize(), TEXT("="));
		StringCchCatW(rgchProperties, rgchProperties.GetSize(), CMsInstApiConvertString(szFile));

		// Do the install
		uiRet = RunEngine(ireProductCode, CMsInstApiConvertString(szProduct), 0, rgchProperties, GetStandardUILevel(), (iioEnum)iioMustAccessInstallerKey);
	}
	DEBUGMSG1(MSITEXT("MsiInstallMissingFile is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}


UINT __stdcall MsiInstallMissingComponent(
	LPCDSTR      szProduct,        // product code
	LPCDSTR      szComponent,      // component Id, string GUID
	INSTALLSTATE eInstallState)    // local/source/default, absent invalid
//----------------------------------------------
{
	DEBUGMSG3(MSITEXT("Entering MsiInstallMissingComponent. Product: %s, Component: %s, Installstate: %d"),
		szProduct?szProduct:MSITEXT(""), szComponent?szComponent:MSITEXT(""), (const DCHAR*)(INT_PTR)eInstallState);

	CForbidTokenChangesDuringCall impForbid;

	UINT uiRet;

	// Validate args
	if (!szProduct || 
		 cchProductCode != lstrlen(szProduct) ||
		 !szComponent ||
		 cchComponentId != lstrlen(szComponent))
	{
		uiRet = ERROR_INVALID_PARAMETER;
	}
	else
	{
		const int cchMaxProperties = 25 + 1 + 10 + 1 +  // INSTALLLEVEL=n
											  25 + 1 + 10 + 1 +  // REINSTALLMODE=X
											  25 + 1 + cchMaxFeatureName;//ADDLOCAL=X

		ICHAR szProperties[cchMaxProperties + 1];
		szProperties[0] = '\0';

		// Set property corresponding to requested install state
		const ICHAR* szComponentProperty;
		switch (eInstallState)
		{
		case INSTALLSTATE_LOCAL:
			szComponentProperty =	IPROPNAME_COMPONENTADDLOCAL;
			break;
		case INSTALLSTATE_SOURCE:
			szComponentProperty = IPROPNAME_COMPONENTADDSOURCE;
			break;
		case INSTALLSTATE_DEFAULT:
			szComponentProperty = IPROPNAME_COMPONENTADDDEFAULT;
			break;
		default:
			return ERROR_INVALID_PARAMETER;
		}

		StringCbCatW(szProperties, sizeof(szProperties), TEXT(" "));
		StringCbCatW(szProperties, sizeof(szProperties), szComponentProperty);
		StringCbCatW(szProperties, sizeof(szProperties), TEXT("="));
		StringCbCatW(szProperties, sizeof(szProperties), CMsInstApiConvertString(szComponent));

		uiRet = RunEngine(ireProductCode, CMsInstApiConvertString(szProduct), 0, CMsInstApiConvertString(szProperties), GetStandardUILevel(), (iioEnum)iioMustAccessInstallerKey);
	}
	
	DEBUGMSG1(MSITEXT("MsiInstallMissingComponent is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}

extern "C"
UINT __stdcall MsiAdvertiseProduct(
   LPCDSTR       szPackagePath,    // location of launcher
	LPCDSTR      szScriptfilePath,  // can be ADVERTISEFLAGS_MACHINEASSIGN, ADVERTISEFLAGS_USERASSIGN if product is to be locally advertised
	LPCDSTR      szTransforms,      // list of transforms to be applied
	LANGID       lgidLanguage)      // install language
//----------------------------------------------
{
	DEBUGMSG4(MSITEXT("Entering MsiAdvertiseProduct. Package: %s, Scriptfile: %s, Transforms: %s, Langid: %d (merced: ptrs truncated to 32-bits)"),
		szPackagePath?szPackagePath:MSITEXT(""), (int)(INT_PTR)szScriptfilePath==ADVERTISEFLAGS_MACHINEASSIGN?MSITEXT("-machine-"):(int)(INT_PTR)szScriptfilePath==ADVERTISEFLAGS_USERASSIGN?MSITEXT("-user-"):szScriptfilePath?szScriptfilePath:MSITEXT(""),
		szTransforms?szTransforms:MSITEXT(""), (const DCHAR*)(INT_PTR)lgidLanguage);

	CForbidTokenChangesDuringCall impForbid;

	UINT uiRet = ERROR_SUCCESS;
	idapEnum idapAdvertisement = idapScript;

	// This API should only work on Win2K and higher platforms when generating advertise scripts.
	if (! MinimumPlatformWindows2000() && (int)(INT_PTR)szScriptfilePath != ADVERTISEFLAGS_MACHINEASSIGN && (int)(INT_PTR)szScriptfilePath != ADVERTISEFLAGS_USERASSIGN)
	{
		uiRet = ERROR_CALL_NOT_IMPLEMENTED;
		goto MsiAdvertiseProductEnd;
	}
	
	// Validate args
	if (!szPackagePath || lstrlen(szPackagePath) > cchMaxPath  ||
		((int)(INT_PTR)szScriptfilePath !=  ADVERTISEFLAGS_MACHINEASSIGN && (int)(INT_PTR)szScriptfilePath != ADVERTISEFLAGS_USERASSIGN &&		//--merced: okay to typecast
		lstrlen(szScriptfilePath) > cchMaxPath))
	{
		uiRet = ERROR_INVALID_PARAMETER;
	}
	else
	{
		// use dwPlatform = 0 to indicate use of current platform (MsiAdvertiseProduct does not support OS-simulation)
		if ((int)(INT_PTR)szScriptfilePath == ADVERTISEFLAGS_MACHINEASSIGN)
			idapAdvertisement = idapMachineLocal;
		else if ((int)(INT_PTR)szScriptfilePath == ADVERTISEFLAGS_USERASSIGN)
			idapAdvertisement = idapUserLocal;
		else
			idapAdvertisement = idapScript;
		uiRet = DoAdvertiseProduct(CMsInstApiConvertString(szPackagePath), idapAdvertisement == idapScript ? static_cast<const ICHAR*>(CMsInstApiConvertString(szScriptfilePath)) : TEXT(""),
									szTransforms ? static_cast<const ICHAR*>(CMsInstApiConvertString(szTransforms)) : TEXT(""), idapAdvertisement, lgidLanguage, /* dwPlatform = */ 0, /* dwOptions = */ 0);
	}

MsiAdvertiseProductEnd:
	DEBUGMSG1(MSITEXT("MsiAdvertiseProduct is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}

extern "C"
UINT __stdcall MsiAdvertiseProductEx(
   LPCDSTR       szPackagePath,    // location of launcher
	LPCDSTR      szScriptfilePath,  // can be ADVERTISEFLAGS_MACHINEASSIGN, ADVERTISEFLAGS_USERASSIGN if product is to be locally advertised
	LPCDSTR      szTransforms,      // list of transforms to be applied
	LANGID       lgidLanguage,      // install language
	DWORD        dwPlatform,        // MSIARCHITECTUREFLAGS that control for which platform to create the script, 0 is current platform
	DWORD        dwOptions)         // MSIADVERTISEOPTIONFLAGS for extra advertise parameters, MSIADVERTISEOPTIONFLAGS_INSTANCE indicates
	                                //  a new instance -- instance transform is specified in szTransforms
//----------------------------------------------
{
	DEBUGMSG6(MSITEXT("Entering MsiAdvertiseProductEx. Package: %s, Scriptfile: %s, Transforms: %s, Langid: %d (merced: ptrs truncated to 32-bits), Platform: %d, Options: %d"),
		szPackagePath?szPackagePath:MSITEXT(""), (int)(INT_PTR)szScriptfilePath==ADVERTISEFLAGS_MACHINEASSIGN?MSITEXT("-machine-"):(int)(INT_PTR)szScriptfilePath==ADVERTISEFLAGS_USERASSIGN?MSITEXT("-user-"):szScriptfilePath?szScriptfilePath:MSITEXT(""),
		szTransforms?szTransforms:MSITEXT(""), (const DCHAR*)(INT_PTR)lgidLanguage, (const DCHAR*)(INT_PTR)dwPlatform, (const DCHAR*)(INT_PTR)dwOptions);

	CForbidTokenChangesDuringCall impForbid;

	UINT uiRet = ERROR_SUCCESS;
	idapEnum idapAdvertisement = idapScript;

	// This API should only work on Win2K and higher platforms when generating advertise scripts.
	if (! MinimumPlatformWindows2000() && (int)(INT_PTR)szScriptfilePath != ADVERTISEFLAGS_MACHINEASSIGN && (int)(INT_PTR)szScriptfilePath != ADVERTISEFLAGS_USERASSIGN)
	{
		// not supported on Win9X or WinNT 4
		uiRet = ERROR_CALL_NOT_IMPLEMENTED;
	}
	else
	{
		DWORD dwValidArchitectureFlags = MSIARCHITECTUREFLAGS_X86 | MSIARCHITECTUREFLAGS_AMD64 | MSIARCHITECTUREFLAGS_IA64;
		DWORD dwValidAdvertiseOptions = MSIADVERTISEOPTIONFLAGS_INSTANCE;

		// Validate args
		if (!szPackagePath || lstrlen(szPackagePath) > cchMaxPath  ||
			((int)(INT_PTR)szScriptfilePath !=  ADVERTISEFLAGS_MACHINEASSIGN && (int)(INT_PTR)szScriptfilePath != ADVERTISEFLAGS_USERASSIGN &&		//--merced: okay to typecast
			lstrlen(szScriptfilePath) > cchMaxPath) ||
			(dwPlatform & (~dwValidArchitectureFlags)) ||
			(dwOptions & (~dwValidAdvertiseOptions)) ||
			((dwOptions & MSIADVERTISEOPTIONFLAGS_INSTANCE) && (!szTransform || !*szTransform)))
		{
			uiRet = ERROR_INVALID_PARAMETER;
		}
		else
		{
			if ((int)(INT_PTR)szScriptfilePath == ADVERTISEFLAGS_MACHINEASSIGN)
				idapAdvertisement = idapMachineLocal;
			else if ((int)(INT_PTR)szScriptfilePath == ADVERTISEFLAGS_USERASSIGN)
				idapAdvertisement = idapUserLocal;
			else
				idapAdvertisement = idapScript;
			uiRet = DoAdvertiseProduct(CMsInstApiConvertString(szPackagePath), idapAdvertisement == idapScript ? static_cast<const ICHAR*>(CMsInstApiConvertString(szScriptfilePath)) : TEXT(""),
										szTransforms ? static_cast<const ICHAR*>(CMsInstApiConvertString(szTransforms)) : TEXT(""), idapAdvertisement, lgidLanguage, dwPlatform, dwOptions);
		}
	}

	DEBUGMSG1(MSITEXT("MsiAdvertiseProductEx is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}

UINT ProvideComponentFromDescriptor(
	LPCDSTR     szDescriptor, // product,feature,component info
	DWORD       dwInstallMode,      // the installation mode 
	LPDSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf,   // buffer byte count, including null
	DWORD       *pcchArgsOffset,// returned offset of args in descriptor
	bool        fAppendArgs,
	bool        fFromDescriptor) // original call was from MsiPCFD
//----------------------------------------------
// The descriptor may be followed by arguments. If fAppendArgs is set then we'll
// quote the path and place the arguments after the path. (e.g.: "C:\foo\bar.exe" /doit)
//
// pcchArgsOffset is obsolete; we'll always set *pcchArgsOffset to 0.
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;

	DCHAR szProductCode[cchProductCode + 1];
	DCHAR szFeatureId[cchMaxFeatureName + 1];
	DCHAR szComponentId[cchComponentId + 1];

	DWORD cchArgsOffset;
	DWORD cchArgs;

	CRFSCachedSourceInfoNonStatic RFSLocalCache;

	bool fComClassicInteropForAssembly;

	if (!szDescriptor ||
		 !DecomposeDescriptor(szDescriptor, szProductCode, szFeatureId,
									 szComponentId, &cchArgsOffset, &cchArgs, &fComClassicInteropForAssembly))
	{
		 return ERROR_INVALID_PARAMETER;
	}
	
	if (pcchArgsOffset)
		*pcchArgsOffset = 0;

	DWORD cchPathBuf = 0;

	if (pcchPathBuf)
	{
		// save the incoming buffer size for later use.
		
		cchPathBuf = *pcchPathBuf;

		// if we need to quote the path then we'll save the first spot in the buffer for
		// the opening quote. this means that we need to tell ProvideComponent that
		// our buffer is one smaller than its real size.

		if (cchPathBuf && fAppendArgs)
			(*pcchPathBuf)--;
	}

	UINT uiRet = ERROR_SUCCESS;
	// we need to prevent CoCreate calls to oleaut32.dll from causing installations, since that
	// results in infinite recursion due to its usage by WI to perform the installs
	if(fFromDescriptor && !lstrcmp(szComponentId, g_szOLEAUT32_ComponentID))// oleaut32.dll component
	{
		DEBUGMSG1(MSITEXT("MsiProvideComponentFromDescriptor called for component %s: returning harcoded oleaut32.dll value"), szComponentId);
		
		// return oleaut32.dll
		if(pcchPathBuf)
		{
			*pcchPathBuf = lstrlen(g_szOLEAUT32);
			if(lpPathBuf)
			{
				if(*pcchPathBuf + 1 > (fAppendArgs ? cchPathBuf - 2 : cchPathBuf))
					uiRet = ERROR_MORE_DATA;
				else
				{
					if (FAILED(StringCchCopy(fAppendArgs? lpPathBuf + 1 : lpPathBuf, fAppendArgs ? cchPathBuf - 1 : cchPathBuf, g_szOLEAUT32)))
						uiRet = ERROR_FUNCTION_FAILED;
				}
			}						
		}
	}
	else
	{
		// as mentioned above, if we're quoting then we need the first character of the buffer
		// for our quote so we pass lpPathBuf+1 to ProvideComponent
		// If called from a descriptor, use a local source cache, otherwise use the process-wide cache
		uiRet = ProvideComponent(szProductCode, szFeatureId, szComponentId, dwInstallMode,
			fComClassicInteropForAssembly ? 0 : (fAppendArgs && lpPathBuf ? lpPathBuf + 1 : lpPathBuf), pcchPathBuf, fFromDescriptor, fFromDescriptor ? RFSLocalCache : g_RFSSourceCache);
	}

	if (ERROR_SUCCESS == uiRet)
	{
		if(lpPathBuf)
		{
			Assert(pcchPathBuf);
			if(fComClassicInteropForAssembly)
			{
				// for COM classic <-> COM+ interop the server is always <system32folder>\mscoree.dll
				CAPITempBuffer<ICHAR, 1> szFullPath;
				if (!szFullPath.SetSize(MAX_PATH+1))
					return ERROR_OUTOFMEMORY;
				
				AssertNonZero(::GetCOMPlusInteropDll(szFullPath, szFullPath.GetSize()));
#ifdef MSIUNICODE
				const DCHAR* szFinalFullPath = szFullPath;
#else
				CApiConvertString strFullPath(szFullPath);
				const DCHAR* szFinalFullPath = strFullPath;
#endif
				*pcchPathBuf = lstrlen(szFinalFullPath);
				if(*pcchPathBuf + 1 > (fAppendArgs ? cchPathBuf - 2 : cchPathBuf))
					uiRet = ERROR_MORE_DATA;
				else
				{
					if (FAILED(StringCchCopy(fAppendArgs ? lpPathBuf + 1 : lpPathBuf, fAppendArgs ? cchPathBuf - 1 : cchPathBuf, szFinalFullPath)))
						uiRet = ERROR_FUNCTION_FAILED;
				}
			}
			if (fAppendArgs)
			{
				// we need to append the args (if any) to the path


				// let's see whether we have room for the args plus 2 quotes
				// plus a null. cchPathBuf has our original buffer size and pcchPathBuf contains
				// the number of characters placed in the buffer by ProvideComponent

				if ((cchArgs + 2 + 1) > (cchPathBuf - *pcchPathBuf))
				{
					uiRet = ERROR_MORE_DATA;
				}
				else
				{
					lpPathBuf[0] = '\"'; // stick a quote before the path
					lpPathBuf[*pcchPathBuf+1] = '\"'; // stick a quote after the path

					// Copy in the args. The destination of the copy is just after the path (including the quotes).
					// Note that the args usually include a leading space.
					// We copy (cchArgs+1) characters to include the null terminator.

					memcpy(lpPathBuf + *pcchPathBuf + 2, &szDescriptor[cchArgsOffset], (cchArgs+1)*sizeof(DCHAR));
				}
			}
		}
	}

	if (pcchPathBuf && fAppendArgs)
	{
		*pcchPathBuf += (cchArgs + 2); // args + 2 quotes
	}
	return uiRet;
}

extern "C"
UINT __stdcall MsiProvideComponentFromDescriptor(
	LPCDSTR     szDescriptor, // product,feature,component info
	LPDSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf,   // buffer byte count, including null
	DWORD       *pcchArgsOffset) // returned offset of args in descriptor
//----------------------------------------------
{
	DEBUGMSG4(MSITEXT("Entering MsiProvideComponentFromDescriptor. Descriptor: %s, PathBuf: %X, pcchPathBuf: %X, pcchArgsOffset: %X"),
		szDescriptor ? szDescriptor : MSITEXT(""), lpPathBuf ? lpPathBuf : MSITEXT(""), (const DCHAR*)pcchPathBuf, (const DCHAR*)pcchArgsOffset);

	CForbidTokenChangesDuringCall impForbid;

	UINT uiRet;
	
#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		// call internal function with installmode = default
		uiRet = ProvideComponentFromDescriptor(static_cast<const char*>(CMsInstApiConvertString(szDescriptor)),INSTALLMODE_DEFAULT,
											  CWideToAnsiOutParam(lpPathBuf, pcchPathBuf, (int*)&uiRet), pcchPathBuf, pcchArgsOffset, true, true, true);
	
	}
	else // g_fWin9X == false
	{
#endif

		// call internal function with installmode = default
		uiRet = ProvideComponentFromDescriptor(szDescriptor,INSTALLMODE_DEFAULT,
											  lpPathBuf,pcchPathBuf, pcchArgsOffset, true, true);

#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif // MSIUNICODE

	DEBUGMSG1(MSITEXT("MsiProvideComponentFromDescriptor is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}

extern "C"
UINT __stdcall MsiConfigureFeatureFromDescriptor(
	LPCDSTR     szDescriptor,      // product and feature, component ignored
	INSTALLSTATE eInstallState)    // local/source/default/absent
//----------------------------------------------
{
	DEBUGMSG2(MSITEXT("Entering MsiConfigureFeatureFromDescriptor. Descriptor: %s, Installstate: %d"),
				 szDescriptor ? szDescriptor : MSITEXT(""), (const DCHAR*)eInstallState);

	CForbidTokenChangesDuringCall impForbid;

	UINT uiRet;
	DCHAR szProductCode[cchProductCode + 1];
	DCHAR szFeatureId[cchMaxFeatureName + 1];

	if (!szDescriptor ||
		 !DecomposeDescriptor(szDescriptor, szProductCode, szFeatureId, 0, 0))
	{
		uiRet = ERROR_INVALID_PARAMETER;
	}
	else
	{
		uiRet = MsiConfigureFeature(szProductCode, szFeatureId, eInstallState);
	}

	DEBUGMSG1(MSITEXT("MsiConfigureFeatureFromDescriptor is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}

extern "C"
INSTALLSTATE __stdcall MsiQueryFeatureStateFromDescriptor(LPCDSTR szDescriptor)
//----------------------------------------------
{
	DEBUGMSG1(MSITEXT("Entering MsiQueryFeatureStateFromDescriptor. Descriptor: %s"), szDescriptor ? szDescriptor : MSITEXT(""));

	CForbidTokenChangesDuringCall impForbid;

	DCHAR szProductCode[cchProductCode + 1];
	DCHAR szFeatureId[cchMaxFeatureName + 1];

	INSTALLSTATE isRet;

	if (!szDescriptor ||
		 !DecomposeDescriptor(szDescriptor, szProductCode, szFeatureId, 0, 0))
	{

		isRet = INSTALLSTATE_INVALIDARG;
	}
	else
	{
		isRet = MsiQueryFeatureState(szProductCode, szFeatureId);
	}

	DEBUGMSG1(MSITEXT("MsiQueryFeatureStateFromDescriptor is returning: %d"), (const DCHAR*)isRet);
	return isRet;
}

extern "C"
UINT __stdcall MsiReinstallFeatureFromDescriptor(
	LPCDSTR szDescriptor,
	DWORD dwReinstallMode)
//----------------------------------------------
{
	DEBUGMSG2(MSITEXT("Entering MsiReinstallFeatureFromDescriptor. Descriptor: %s, Reinstallmode: %d"),
				 szDescriptor ? szDescriptor : MSITEXT(""), (const DCHAR*)(INT_PTR)dwReinstallMode);

	CForbidTokenChangesDuringCall impForbid;

	UINT uiRet;
	DCHAR szProductCode[cchProductCode + 1];
	DCHAR szFeatureId[cchMaxFeatureName + 1];

	if (!szDescriptor ||
		 !DecomposeDescriptor(szDescriptor, szProductCode, szFeatureId, 0, 0))
	{
		uiRet = ERROR_INVALID_PARAMETER;
	}
	else
	{
		uiRet = MsiReinstallFeature(szProductCode, szFeatureId, dwReinstallMode);
	}

	DEBUGMSG1(MSITEXT("MsiReinstallFeatureFromDescriptor is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}

UINT __stdcall MsiDecomposeDescriptor(
	const DCHAR* szDescriptor,
	DCHAR*     szProductCode,
	DCHAR*     szFeatureId,
	DCHAR*     szComponentCode,
	DWORD*      pcchArgsOffset)
{
	CForbidTokenChangesDuringCall impForbid;

	if (szDescriptor && DecomposeDescriptor(szDescriptor, szProductCode, szFeatureId, szComponentCode, pcchArgsOffset))
		return ERROR_SUCCESS;
	else
		return ERROR_INVALID_PARAMETER;
}

extern "C"
UINT __stdcall MsiGetShortcutTarget(
	const DCHAR* szShortcutTarget,
	DCHAR*       szProductCode,
	DCHAR*       szFeatureId,
	DCHAR*       szComponentCode)
{
	DEBUGMSG1(MSITEXT("Entering MsiGetShortcutTarget. File: %s"), (szShortcutTarget) ? szShortcutTarget : MSITEXT(""));

	CForbidTokenChangesDuringCall impForbid;

	bool fOLEInitialized = false;
	HRESULT hRes = DoCoInitialize();

	if (ERROR_INSTALL_FAILURE == hRes)
		return hRes;

	if (SUCCEEDED(hRes))
	{
		fOLEInitialized = true;
	}

	CCoUninitialize coUninit(fOLEInitialized);

	UINT uiRet = 0;
	if (GetShortcutTarget(CMsInstApiConvertString(szShortcutTarget), 
		(szProductCode)   ? (ICHAR*) CFixedLengthParam<cchProductCode+1>(szProductCode) : NULL,
		(szFeatureId)     ? (ICHAR*) CFixedLengthParam<cchMaxFeatureName+1>(szFeatureId) : NULL,
		(szComponentCode) ? (ICHAR*) CFixedLengthParam<cchComponentId+1>(szComponentCode) : NULL))
		uiRet = ERROR_SUCCESS;
	else
		uiRet = ERROR_FUNCTION_FAILED;

	DEBUGMSG1(MSITEXT("MsiGetShortcutTarget is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);

	return uiRet;
}


UINT __stdcall MsiProvideQualifiedComponent(LPCDSTR szComponent,
		LPCDSTR szQualifier, DWORD dwInstallMode, 
		LPDSTR lpPathBuf, DWORD *pcchPathBuf)
//----------------------------------------------
{	
	// call the ex fn
	return MsiProvideQualifiedComponentEx(szComponent, szQualifier, dwInstallMode, 0, 0, 0, lpPathBuf, pcchPathBuf);
}

UINT __stdcall MsiProvideQualifiedComponentEx(LPCDSTR szComponent,
		LPCDSTR szQualifier, DWORD dwInstallMode, 
		LPCDSTR szProduct, DWORD, DWORD, 
		LPDSTR lpPathBuf, DWORD *pcchPathBuf)
//----------------------------------------------
{	
	DEBUGMSG4(MSITEXT("Entering MsiProvideQualifiedComponent. Component: %s, Qualifier: %s, Installmode: %d, Product: %s"),
		szComponent?szComponent:MSITEXT(""), szQualifier?szQualifier:MSITEXT(""), 
		(const DCHAR*)(INT_PTR)dwInstallMode, szProduct?szProduct:MSITEXT(""));
	DEBUGMSG2(MSITEXT("Pathbuf: %X, pcchPathBuf: %X"), lpPathBuf, (const DCHAR*)(INT_PTR)pcchPathBuf);

	CForbidTokenChangesDuringCall impForbid;

	UINT uiRet = ERROR_SUCCESS;


#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		uiRet = MsiProvideQualifiedComponentExA(
			CMsInstApiConvertString(szComponent),
			CMsInstApiConvertString(szQualifier),
			dwInstallMode,
			CMsInstApiConvertString(szProduct),
			0, // unused
			0, // unused
			CWideToAnsiOutParam(lpPathBuf, pcchPathBuf, (int*)&uiRet),
			pcchPathBuf);

	}
	else // g_fWin9X == false
	{
#endif

		// validate args
		if (!szComponent || (lstrlen(szComponent) != cchComponentId) || !szQualifier || 
			 (lpPathBuf && !pcchPathBuf))
		{
			 uiRet = ERROR_INVALID_PARAMETER;
		}
		else
		{
			// look up component in GPTComponents
			bool fComponentKnown = false;
			const int iProductLocations = NUM_PUBLISHED_INFO_LOCATIONS;
			int uiKey = 0;
			for (; uiKey < iProductLocations; uiKey++)
			{
				CRegHandle HComponentKey;
				uiRet = OpenAdvertisedSubKey(szGPTComponentsKey, szComponent, HComponentKey, false, uiKey);

				if (ERROR_FILE_NOT_FOUND == uiRet)
					continue;
				else if(ERROR_SUCCESS != uiRet)
					return uiRet;

				fComponentKnown = true;

				CAPITempBuffer<DCHAR,cchMaxDescriptor+1> rgchDescriptor;//?? maybe we increase this to accomodate AppData
				DWORD dwType;
				uiRet = MsiRegQueryValueEx(HComponentKey, szQualifier, 0,
														&dwType, rgchDescriptor, 0);
				if (ERROR_FILE_NOT_FOUND == uiRet)
					continue;
				else if(ERROR_SUCCESS != uiRet)
					return uiRet;

				DCHAR* szDescriptorList = rgchDescriptor;
				Assert(szDescriptorList); // we expect this to be nonnull
				if(szProduct) // if product has been specified, use the corr. descriptor
				{
					while(*szDescriptorList)
					{
						DCHAR szProductCodeInDesc[cchProductCode+1];
						if (!DecomposeDescriptor(szDescriptorList, szProductCodeInDesc, 0, 0, 0, 0))
						{
							// malformed qualified component entry
							OpenAdvertisedComponentKey(szComponent, HComponentKey, true);
							DEBUGMSGE2(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_BAD_CONFIGURATION_VALUE, CMsInstApiConvertString(szQualifier), CMsInstApiConvertString(szDescriptorList), HComponentKey.GetKey());
							return ERROR_BAD_CONFIGURATION;
						}
						if(!lstrcmpi(szProductCodeInDesc, szProduct)) // products match
							break;
						// continue on to the next descriptor in the list
						szDescriptorList = szDescriptorList + lstrlen(szDescriptorList) + 1;
					}
					if(!*szDescriptorList)
					{
						uiRet = ERROR_FILE_NOT_FOUND;
						continue; // search for the product in the other hives
					}
				}
				uiRet = ProvideComponentFromDescriptor(szDescriptorList, dwInstallMode,
						lpPathBuf, pcchPathBuf, 0, false, /*fFromDescriptor=*/false);
				break;
			}
			if(uiKey == iProductLocations && uiRet == ERROR_FILE_NOT_FOUND)
			{
				if(fComponentKnown)
					uiRet = ERROR_INDEX_ABSENT;
				else
					uiRet = ERROR_UNKNOWN_COMPONENT;
			}
		}
#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif // MSIUNICODE

	DEBUGMSG1(MSITEXT("MsiProvideQualifiedComponent is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}

UINT __stdcall MsiProvideAssembly(
	LPCDSTR     szAssemblyName,   // stringized assembly name
	LPCDSTR     szAppContext,  // specifies the full path to the .cfg file or the app exe to which the assembly being requested may be privatised to
	DWORD       dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags (see msi help)
	DWORD       dwAssemblyInfo, // assembly type
	LPDSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf) // in/out buffer character count
//----------------------------------------------
{
	DEBUGMSG3(MSITEXT("Entering MsiProvideAssembly. AssemblyName: %s, AppContext: %s, InstallMode: %d"),
		szAssemblyName? szAssemblyName:MSITEXT(""), szAppContext?szAppContext:MSITEXT(""), 
		(const DCHAR*)(INT_PTR)dwInstallMode);
	DEBUGMSG2(MSITEXT("Pathbuf: %X, pcchPathBuf: %X"), lpPathBuf, (const DCHAR*)(INT_PTR)pcchPathBuf);

	CForbidTokenChangesDuringCall impForbid;

	UINT uiRet = ERROR_SUCCESS;


#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		uiRet = MsiProvideAssemblyA(
			CMsInstApiConvertString(szAssemblyName),
			CMsInstApiConvertString(szAppContext),
			dwInstallMode,
			dwAssemblyInfo,
			CWideToAnsiOutParam(lpPathBuf, pcchPathBuf, (int*)&uiRet),
			pcchPathBuf);
	}
	else // g_fWin9X == false
	{
#endif
		// validate args
		if (!szAssemblyName || (lpPathBuf && !pcchPathBuf) ||
			 (szAppContext && FAILED(StringCchLength(szAppContext, cchMaxPath+1, NULL))))
		{
			 uiRet = ERROR_INVALID_PARAMETER;
		}
		else
		{
			// create an assembly object with the passed in assembly name
			PAssemblyName pAssemblyName(0);
			HRESULT hr;
			if(dwAssemblyInfo & MSIASSEMBLYINFO_WIN32ASSEMBLY) // win32 assembly
			{
				hr = SXS::CreateAssemblyNameObject(&pAssemblyName, CApiConvertString(szAssemblyName), CANOF_PARSE_DISPLAY_NAME, 0);
			}
			else
			{
				hr = FUSION::CreateAssemblyNameObject(&pAssemblyName, CApiConvertString(szAssemblyName), CANOF_PARSE_DISPLAY_NAME, 0);
			}

			if(!SUCCEEDED(hr))
				return ERROR_BAD_CONFIGURATION; //!! need to do some elaborate fault finding here

			// look up assembly in GPTAssembliesKey
			DWORD iIndex = 0;
			// replace all '\\' in the AppCtx with '|'
			CAPITempBuffer<DCHAR, 1> rgchAppCtxWOBS;
			if (!rgchAppCtxWOBS.SetSize(MAX_PATH))
				return ERROR_OUTOFMEMORY;

			if(szAppContext)
			{
				DWORD cchLen = lstrlen(szAppContext) + 1;
				rgchAppCtxWOBS.SetSize(cchLen);
				memcpy((DCHAR*)rgchAppCtxWOBS, szAppContext, cchLen*sizeof(DCHAR));
				DCHAR* lpTmp = rgchAppCtxWOBS;
				while(*lpTmp)
				{
					if(*lpTmp == '\\')
						*lpTmp = '|';
#ifdef MSIUNICODE
					lpTmp++;
#else
					lpTmp = CharNextA(lpTmp);
#endif
				}
			}

			CAPITempBuffer<DCHAR, 1> szAssemblyName2;
			CAPITempBuffer<DCHAR, 1> szDescriptorList;
			if (!szAssemblyName2.SetSize(MAX_PATH) || !szDescriptorList.SetSize(MAX_PATH))
				return ERROR_OUTOFMEMORY;

			for(;;)
			{
				DWORD cchAssemblyName2 = szAssemblyName2.GetSize();
				DWORD cchDescriptorList = szDescriptorList.GetSize();
				uiRet = EnumAssemblies(dwAssemblyInfo, szAppContext ? (const DCHAR*)rgchAppCtxWOBS : szGlobalAssembliesCtx, iIndex, szAssemblyName2, &cchAssemblyName2, szDescriptorList, &cchDescriptorList);
				if(ERROR_MORE_DATA == uiRet)
				{
					if (!szAssemblyName2.SetSize(++cchAssemblyName2) || !szDescriptorList.SetSize(++cchDescriptorList))
						return ERROR_OUTOFMEMORY;

					uiRet = EnumAssemblies(dwAssemblyInfo, szAppContext ? (const DCHAR*)rgchAppCtxWOBS : szGlobalAssembliesCtx, iIndex, szAssemblyName2, &cchAssemblyName2, szDescriptorList, &cchDescriptorList);
				}			
				iIndex++;
				if(ERROR_SUCCESS != uiRet)
					break;

				// create an assembly object with the read assembly name
				PAssemblyName pAssemblyName2(0);
				if(dwAssemblyInfo & MSIASSEMBLYINFO_WIN32ASSEMBLY) // win32 assembly
				{
					hr = SXS::CreateAssemblyNameObject(&pAssemblyName2, CApiConvertString(szAssemblyName2), CANOF_PARSE_DISPLAY_NAME, 0);
				}
				else
				{
					hr = FUSION::CreateAssemblyNameObject(&pAssemblyName2, CApiConvertString(szAssemblyName2), CANOF_PARSE_DISPLAY_NAME, 0);
				}

				if(!SUCCEEDED(hr))
					return ERROR_BAD_CONFIGURATION; //!! need to do some elaborate fault finding here


				// is the the same assembly as the one the caller cares about
				hr = pAssemblyName->IsEqual(pAssemblyName2, ASM_CMPF_DEFAULT);
				// to account for bug 454476 in XP client release, we skip over "orphaned descriptors" below by continuing furthur in the list on ERROR_UNKOWN_PRODUCT returns from the ProvideComponentFromDescriptor API
				if(S_OK == hr)
				{
					// to allow for bootstrapping of the fusion files, we unload fusion during the install
					// hence we need to destroy our assembly name pointers at this point
					// else they will be invalid by the end of the call
					pAssemblyName  = 0;
					pAssemblyName2 = 0;

					DCHAR* pszDesc = szDescriptorList; // point to the beginning of the array
					do{
						uiRet = ProvideComponentFromDescriptor(pszDesc, INSTALLMODE_NODETECTION_ANY == dwInstallMode ? INSTALLMODE_NODETECTION : dwInstallMode, lpPathBuf, pcchPathBuf, 0, false, /*fFromDescriptor=*/false);
					}while(((ERROR_UNKNOWN_PRODUCT == uiRet) || (INSTALLMODE_NODETECTION_ANY == dwInstallMode && ERROR_SUCCESS != uiRet && ERROR_MORE_DATA != uiRet)) && ((pszDesc += (lstrlen(pszDesc) + 1)), *pszDesc));
					if(	(uiRet == ERROR_FILE_NOT_FOUND) && 
						(INSTALLMODE_NODETECTION_ANY == dwInstallMode))
					{
						uiRet = ERROR_UNKNOWN_COMPONENT;
					}
					break;
				}
			}
			if(ERROR_NO_MORE_ITEMS == uiRet || ERROR_UNKNOWN_PRODUCT == uiRet)
				uiRet = ERROR_UNKNOWN_COMPONENT; // the caller does not want to know we enumerate a list of assemblies
		}
#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif // MSIUNICODE
	DEBUGMSG1(MSITEXT("MsiProvideAssembly is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}

UINT __stdcall MsiConfigureProduct(
	LPCDSTR      szProduct,
	int          iInstallLevel,
	INSTALLSTATE eInstallState)
//----------------------------------------------
{
	DEBUGMSG3(MSITEXT("Entering MsiConfigureProduct. Product: %s, Installlevel: %d, Installstate: %d"),
			 	 szProduct?szProduct:MSITEXT(""), (const DCHAR*)(INT_PTR)iInstallLevel, (const DCHAR*)(INT_PTR)eInstallState);

	UINT uiRet = MsiConfigureProductEx(szProduct, iInstallLevel, eInstallState, NULL);
	
	DEBUGMSG1(MSITEXT("MsiConfigureProduct is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}

UINT __stdcall MsiConfigureProductEx(
	LPCDSTR      szProduct,
	int          iInstallLevel,
	INSTALLSTATE eInstallState,
	LPCDSTR      szCommandLine)
//----------------------------------------------
{
	DEBUGMSG4(MSITEXT("Entering MsiConfigureProductEx. Product: %s, Installlevel: %d, Installstate: %d, Commandline: %s"),
			 	 szProduct?szProduct:MSITEXT(""), (const DCHAR*)(INT_PTR)iInstallLevel, (const DCHAR*)(INT_PTR)eInstallState,
				 ShouldLogCmdLine() ? (szCommandLine ? szCommandLine : MSITEXT("")) : MSITEXT("**********"));

	CForbidTokenChangesDuringCall impForbid;

	UINT uiRet = ERROR_SUCCESS;
	if (((0 != iInstallLevel) && 
		 ((iInstallLevel < INSTALLLEVEL_MINIMUM) || (iInstallLevel > INSTALLLEVEL_MAXIMUM))) ||
		 0 == szProduct)

	{
		uiRet = ERROR_INVALID_PARAMETER;
	}
	else
	{
		DCHAR szProductCode[cchProductCode+1];

		if (cchProductCode != lstrlen(szProduct))
		{
			if (!DecomposeDescriptor(szProduct, szProductCode, 0,
											 0, 0, 0))
			{
				 uiRet = ERROR_INVALID_PARAMETER;
			}
			else
			{
				szProduct = szProductCode;
			}
		}

		if (ERROR_SUCCESS == uiRet)
		{
			uiRet = ConfigureOrReinstallFeatureOrProduct(CMsInstApiConvertString(szProduct),
							0, eInstallState, 0, iInstallLevel, GetStandardUILevel(),
							CMsInstApiConvertString(szCommandLine));
		}
	}
	
	DEBUGMSG1(MSITEXT("MsiConfigureProductEx is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}


extern "C"
UINT __stdcall MsiApplyPatch(LPCDSTR     szPackagePath,
									  LPCDSTR     szProduct,
									  INSTALLTYPE eInstallType,
									  LPCDSTR     szCommandLine)
//----------------------------------------------
{
	DEBUGMSG4(MSITEXT("Entering MsiApplyPatch. Package: %s, Product: %s, Installtype: %d, Commandline: %s"),
			 	 szPackagePath?szPackagePath:MSITEXT(""), szProduct?szProduct:MSITEXT(""), (const DCHAR*)eInstallType, 
				 ShouldLogCmdLine() ? (szCommandLine ? szCommandLine : MSITEXT("")) : MSITEXT("**********"));

	CForbidTokenChangesDuringCall impForbid;

	UINT uiRet;

	uiRet = ApplyPatch(CMsInstApiConvertString(szPackagePath),CMsInstApiConvertString(szProduct),
						eInstallType,CMsInstApiConvertString(szCommandLine));

	DEBUGMSG1(MSITEXT("MsiApplyPatch is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}

extern "C"
UINT __stdcall MsiEnumPatches(LPCDSTR szProduct, DWORD iPatchIndex,
										LPDSTR lpPatchBuf,
										LPDSTR lpTransformsBuf, DWORD *pcchTransformsBuf)
//----------------------------------------------
{
	CForbidTokenChangesDuringCall impForbid;

#if !defined(UNICODE) && defined(MSIUNICODE)
	if (g_fWin9X == true)
	{
		UINT uiRet = MsiEnumPatchesA(
			CMsInstApiConvertString(szProduct),
			iPatchIndex, 
			CWideToAnsiOutParam(lpPatchBuf, cchPatchCode+1),
			CWideToAnsiOutParam(lpTransformsBuf, pcchTransformsBuf, (int*)&uiRet),
			pcchTransformsBuf);		

		return uiRet;
	}
	else // g_fWin9X == false
	{
#endif // MSIUNICODE

		if (!szProduct || (lstrlen(szProduct) != cchProductCode) ||
			 !lpPatchBuf || !lpTransformsBuf || !pcchTransformsBuf)
			 return ERROR_INVALID_PARAMETER;

		unsigned int cch = 0;		//--merced: changed int to unsigned int
		DWORD lResult;
		CRegHandle HProductKey;
		CRegHandle HProductPatchesKey;

		lResult = OpenAdvertisedProductKey(szProduct, HProductKey, false);
		if (ERROR_SUCCESS != lResult)
		{
			if (ERROR_FILE_NOT_FOUND == lResult)
				return ERROR_UNKNOWN_PRODUCT;
			else 
				return lResult;
		}

		lResult = MsiRegOpen64bitKey(HProductKey, CMsInstApiConvertString(szPatchesSubKey), 
								0, KEY_READ, &HProductPatchesKey);
		if (ERROR_SUCCESS != lResult)
		{
			if (ERROR_FILE_NOT_FOUND == lResult)
				return ERROR_NO_MORE_ITEMS; // no patches key, so no patches to enum
			else 
				return lResult;
		}

		CAPITempBuffer<DCHAR, cchExpectedMaxPatchList+1> rgchPatchList;
		DWORD dwType;
		lResult = MsiRegQueryValueEx(HProductPatchesKey, szPatchesValueName, 0,
						&dwType, rgchPatchList, 0);
		
		if (ERROR_SUCCESS != lResult || REG_MULTI_SZ != dwType)
		{
			return lResult;
		}
		
		DCHAR* pchPatchId = rgchPatchList;
		for(int i=0; i<iPatchIndex; i++)
		{
			if(*pchPatchId == NULL)
				return ERROR_NO_MORE_ITEMS;

			pchPatchId += lstrlen(pchPatchId) + 1;
		}

		if(*pchPatchId == NULL)
			return ERROR_NO_MORE_ITEMS;

		if(lstrlen(pchPatchId) > cchPatchCodePacked || !UnpackGUID(pchPatchId, lpPatchBuf))
		{
			// malformed patch squid
			
			OpenAdvertisedProductKey(szProduct, HProductKey, true);
			HProductPatchesKey.SetKey(HProductPatchesKey, CMsInstApiConvertString(szPatchesSubKey));
			DEBUGMSGE2(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_BAD_CONFIGURATION_VALUE, CMsInstApiConvertString(szPatchesValueName), CMsInstApiConvertString(pchPatchId), HProductPatchesKey.GetKey());
			return ERROR_BAD_CONFIGURATION;
		}
		
		// get list of transforms
		CAPITempBuffer<DCHAR, cchExpectedMaxPatchTransformList+1> rgchTransformList;

		lResult = MsiRegQueryValueEx(HProductPatchesKey, pchPatchId, 0,
						&dwType, rgchTransformList, 0);
		
		if (ERROR_SUCCESS != lResult || REG_SZ != dwType)
		{
			return lResult;
		}
		
		if((cch = lstrlen((DCHAR*)rgchTransformList)) > *pcchTransformsBuf - 1)
		{
			*pcchTransformsBuf = cch;
			return ERROR_MORE_DATA;
		}


		StringCchCopy(lpTransformsBuf, *pcchTransformsBuf, rgchTransformList);

		return ERROR_SUCCESS;
#if !defined(UNICODE) && defined(MSIUNICODE)
	}
#endif // MSIUNICODE
}

UINT __stdcall MsiGetPatchInfo(
	LPCDSTR   szPatch,        // patch code, string GUID, or descriptor
	LPCDSTR   szProperty,     // property name, case-sensitive
	LPDSTR    lpValueBuf,     // returned value, NULL if not desired
	DWORD     *pcchValueBuf)  // in/out buffer character count
{
	DCHAR szPatchSQUID[cchPatchCodePacked + 1];

	if (szPatch == 0 || szProperty == 0 || lstrlen(szPatch) != cchPatchCode || !PackGUID(szPatch, szPatchSQUID) || 
		 (lpValueBuf && !pcchValueBuf))
	{
		return ERROR_INVALID_PARAMETER;
	}

	CForbidTokenChangesDuringCall impForbid;

	return GetInfo(szPatchSQUID,ptPatch,szProperty,lpValueBuf,pcchValueBuf);
}


#ifndef MSIUNICODE // include only once
extern "C"
void MsiInvalidateFeatureCache()
{
	//
	// The feature cache is gone, but this API is present in our def file, 
	// so we do not want to get rid of it. Instead, now it is just a no-op.
	//
	return;
}

#endif
#ifndef MSIUNICODE // include only once
extern "C"
UINT __stdcall MsiCreateAndVerifyInstallerDirectory(DWORD dwReserved)
{
	DEBUGMSG1(MSITEXT("Entering MsiCreateAndVerifyInstallerDirectory. dwReserved: %d"),
			 	 (const DCHAR*)(INT_PTR)dwReserved);

	if (0 != dwReserved)
		return ERROR_INVALID_PARAMETER;

	CForbidTokenChangesDuringCall impForbid;

	// call worker function
	UINT uiRet  = CreateAndVerifyInstallerDirectory();

	DEBUGMSG1(MSITEXT("MsiCreateAndVerifyInstallerDirectory is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}
#endif

extern "C"
UINT __stdcall MsiSourceListClearAll(LPCDSTR     szProductCode,
								     LPCDSTR     szUserName,
								     DWORD       dwReserved)
//----------------------------------------------
{
	DEBUGMSG2(MSITEXT("Entering MsiSourceListClearAll. Product: %s, User: %s"),
			 	 szProductCode?szProductCode:MSITEXT(""), szUserName?szUserName:MSITEXT(""));

	CForbidTokenChangesDuringCall impForbid;

	UINT uiRet;

	//!!future map the DWORD to the isrcEnum
	if (dwReserved) 
		return ERROR_INVALID_PARAMETER;

	uiRet = SourceListClearByType(CMsInstApiConvertString(szProductCode), CMsInstApiConvertString(szUserName), isrcNet);

	DEBUGMSG1(MSITEXT("MsiSourceListClearAll is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}

extern "C"
UINT __stdcall MsiSourceListAddSource(LPCDSTR szProductCode,
									  LPCDSTR szUserName,
									  DWORD   dwReserved,
									  LPCDSTR szSource)
{
	DEBUGMSG3(MSITEXT("Entering MsiSourceListAddSource. Product: %s, User: %s, Source: %s"),
		szProductCode?szProductCode:MSITEXT(""), szUserName?szUserName:MSITEXT(""), szSource?szSource:MSITEXT(""));

	CForbidTokenChangesDuringCall impForbid;

	UINT uiRet;

	//!!future map the DWORD to the isrcEnum
	if (dwReserved) 
		return ERROR_INVALID_PARAMETER;

	uiRet = SourceListAddSource(CMsInstApiConvertString(szProductCode), CMsInstApiConvertString(szUserName), isrcNet, CMsInstApiConvertString(szSource));

	DEBUGMSG1(MSITEXT("MsiSourceListAddSource is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}

extern "C"
UINT __stdcall MsiSourceListForceResolution(LPCDSTR     szProductCode,
											LPCDSTR     szUserName,
											DWORD       dwReserved)
//----------------------------------------------
{
	DEBUGMSG2(MSITEXT("Entering MsiSourceListForceResolution. Product: %s, User: %s"),
			 	 szProductCode?szProductCode:MSITEXT(""), szUserName?szUserName:MSITEXT(""));

	CForbidTokenChangesDuringCall impForbid;

	if (dwReserved) 
		return ERROR_INVALID_PARAMETER;

	DWORD uiRet = SourceListClearLastUsed(CMsInstApiConvertString(szProductCode), CMsInstApiConvertString(szUserName));
	
	DEBUGMSG1(MSITEXT("MsiSourceListForceResolution is returning: %u"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}


extern UINT IsProductManaged(const ICHAR* szProductKey, bool &fIsProductManaged);

extern "C"
UINT __stdcall MsiIsProductElevated(LPCDSTR szProductCode, BOOL *pfElevated)
//----------------------------------------------
{
	DEBUGMSG1(MSITEXT("Entering MsiIsProductElevated. Product: %s"), szProductCode ? szProductCode : MSITEXT(""));

	CForbidTokenChangesDuringCall impForbid;
	UINT uiRet = ERROR_SUCCESS;
	IMsiServices * pServices = NULL;
	bool fManaged = false;
	
	// Allow this API to run only on Windows2000 and higher platforms
	if (! MinimumPlatformWindows2000())
	{
		uiRet = ERROR_CALL_NOT_IMPLEMENTED;
		goto MsiIsProductElevatedEnd;
	}

	if (!pfElevated || !szProductCode || !*szProductCode || cchProductCode != lstrlen(szProductCode))
	{
		uiRet = ERROR_INVALID_PARAMETER;
		goto MsiIsProductElevatedEnd;
	}

	// pack the GUID here even though its not used, because IsProductManaged just asserts and
	// then eats any error, causing strange behavior
	DCHAR szProductSQUID[cchProductCodePacked + 1];
	if (!PackGUID(szProductCode, szProductSQUID))
	{
		uiRet = ERROR_INVALID_PARAMETER;
		goto MsiIsProductElevatedEnd;
	}

	// default to safest option (non-elevated)
	
	*pfElevated = FALSE;
	// IsProductManaged() requires services
	pServices = ENG::LoadServices();
	if (!pServices)
	{
		uiRet = ERROR_FUNCTION_FAILED;
		goto MsiIsProductElevatedEnd;
	}

	uiRet = IsProductManaged(CMsInstApiConvertString(szProductCode), fManaged);
	
	// need to do some error code mapping
	switch (uiRet)
	{
	// these three get passed back as-is
	case ERROR_SUCCESS:           // fall through
		*pfElevated = fManaged ? TRUE : FALSE;
	case ERROR_UNKNOWN_PRODUCT:   // fall through
	case ERROR_INVALID_PARAMETER: // fall through
	case ERROR_BAD_CONFIGURATION:
		break;
	// couldn't find anything in the registry
	case ERROR_FILE_NOT_FOUND:
		uiRet = ERROR_UNKNOWN_PRODUCT;
		break;
	// everything else becomes the generic error code
	default:
		uiRet=ERROR_FUNCTION_FAILED;
	}
		
	ENG::FreeServices();
	
MsiIsProductElevatedEnd:
	DEBUGMSG1(MSITEXT("MsiIsProductElevated is returning: %d"), (const DCHAR*)(INT_PTR)uiRet);
	return uiRet;
}

#ifdef MSIUNICODE

#define szHKLMPrefix	__SPECIALTEXT("\\Registry\\Machine\\")

UINT ChangeSid(LPCDSTR pOldSid, LPCDSTR pNewSid, LPCDSTR pSubKey)
{
	HANDLE				hKey;
	OBJECT_ATTRIBUTES	oa;
	UNICODE_STRING		OldKeyName;
	UNICODE_STRING		NewKeyName;
	DWORD				dwError = ERROR_SUCCESS;	// returned error code
	CAPITempBuffer<DCHAR,1> rgchSidKey;

	if (!pOldSid || !pNewSid)
		return ERROR_INVALID_PARAMETER;

	if (!rgchSidKey.SetSize(1024))
		return ERROR_OUTOFMEMORY;
	
	// Generate the full old sid key name.
	if (FAILED(StringCchCopy(rgchSidKey, rgchSidKey.GetSize(), szHKLMPrefix)) ||
		FAILED(StringCchCat(rgchSidKey, rgchSidKey.GetSize(), pSubKey)) ||
		FAILED(StringCchCat(rgchSidKey, rgchSidKey.GetSize(), L"\\")) ||
		FAILED(StringCchCat(rgchSidKey, rgchSidKey.GetSize(), pOldSid)))
		return ERROR_FUNCTION_FAILED;

	NTDLL::RtlInitUnicodeString(&OldKeyName, rgchSidKey);
	DEBUGMSGV1(MSITEXT("Old Key = %s"), rgchSidKey);

	// Set up the OBJECT_ATTRIBUTES structure to pass to NtOpenKey.
	InitializeObjectAttributes(&oa,
							   &OldKeyName,
							   OBJ_CASE_INSENSITIVE,
							   NULL,
							   NULL);

	// Open the sid key.
	dwError = NTDLL::NtOpenKey(&hKey, MAXIMUM_ALLOWED, &oa);
	if(!NT_SUCCESS(dwError))
	{
		// if the original key does not exist, this is not a fatal error
		if (dwError == STATUS_OBJECT_NAME_NOT_FOUND)
		{
			DEBUGMSGL(MSITEXT("No MSI data at that location."));
			return ERROR_SUCCESS;
		}

		DEBUGMSGL2(MSITEXT("NtOpenKey failed. SubKey = %s, Error = %08x"), pSubKey, reinterpret_cast<ICHAR*>(static_cast<DWORD_PTR>(dwError)));
		goto Exit;
	}

	// Convert the new sid to UNICODE_STRING.
	DEBUGMSGV1(MSITEXT("New Key = %s"), pNewSid);
	NTDLL::RtlInitUnicodeString(&NewKeyName, pNewSid);

	// Rename the sid key.
	dwError = NTDLL::NtRenameKey(hKey, &NewKeyName);
	if(!NT_SUCCESS(dwError))
	{
		DEBUGMSGL2(MSITEXT("NtRenameKey failed. SubKey = %s, Error = %08x"), pSubKey, reinterpret_cast<ICHAR*>(static_cast<DWORD_PTR>(dwError)));
		goto Exit;
	}

Exit:

	return dwError;
}

#endif // MSIUNICODE

UINT __stdcall MsiNotifySidChange(LPCDSTR pOldSid, LPCDSTR pNewSid)
//----------------------------------------------
// This function is called by LoadUserProfile to notify us of user sid change.
{
#ifdef MSIUNICODE

	if(g_fWin9X == true)
	{
		return ERROR_CALL_NOT_IMPLEMENTED;
	}

	if(!pOldSid || !pNewSid)
	{
		return ERROR_INVALID_PARAMETER;
	}

	// Verbose logging.
	DEBUGMSGV2(MSITEXT("Entering MsiNotifySidChange<%s, %s>"), pOldSid, pNewSid);

	DWORD	dwError = ERROR_SUCCESS;
	DWORD	dwError1 = ERROR_SUCCESS;
	DWORD	dwError2 = ERROR_SUCCESS;

	dwError1 = ChangeSid(pOldSid, pNewSid, szManagedUserSubKey);
	dwError2 = ChangeSid(pOldSid, pNewSid, szMsiUserDataKey);
	if(dwError1 != ERROR_SUCCESS)
	{
		dwError = dwError1;
	}
	else
	{
		dwError = dwError2;
	}

	if(dwError != ERROR_SUCCESS)
	{
		WCHAR wzError[12] = L"";
		HRESULT hrRes = StringCchPrintfW(wzError, ARRAY_ELEMENTS(wzError), L"0x%08x", dwError);
		DEBUGMSGE2(EVENTLOG_ERROR_TYPE,
				   EVENTLOG_TEMPLATE_SID_CHANGE,
				   pOldSid,
				   pNewSid,
				   SUCCEEDED(hrRes) ? wzError : L"");
	}
	// Verbose logging.
	DEBUGMSGV(MSITEXT("Leaving MsiNotifySidChange"));
	return dwError;

#else

	return MsiNotifySidChangeW(CApiConvertString(pOldSid), CApiConvertString(pNewSid));

#endif // MSIUNICODE
}

#ifdef MSIUNICODE

typedef enum {
	DELETEDATA_NONE,
	DELETEDATA_SHAREDDLL,
	DELETEDATA_PACKAGE,
	DELETEDATA_PATCH,
	DELETEDATA_TRANSFORM
} DELETEDATA_TYPE;

typedef UINT (WINAPI * PDELETEDATAFUNC)(HKEY, LPDSTR, DWORD, DELETEDATA_TYPE);
typedef HRESULT(WINAPI *pSHGetFolderPathW)(HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath);

const	DWORD	dwNumOfSpecialFolders = 3;
// The order in which the SpecialFolders array is arranged is tricky. Certain
// paths are substrings of other paths, e.g., "d:\program files" is a
// substring of "d:\program files\common files". We have to let the
// superstring paths go in front of the substring paths. Otherwise a path
// that actually begins with "d:\program files\common files" will be
// considered to have begun with "d:\program files".
int		SpecialFoldersCSIDL[dwNumOfSpecialFolders][2] = {{CSIDL_SYSTEMX86, CSIDL_SYSTEM}, {CSIDL_PROGRAM_FILES_COMMONX86, CSIDL_PROGRAM_FILES_COMMON}, {CSIDL_PROGRAM_FILESX86, CSIDL_PROGRAM_FILES}};
CAPITempBuffer<DCHAR, cchMaxPath>	SpecialFolders[dwNumOfSpecialFolders][2];
	
UINT WINAPI LowerSharedDLLRefCount(HKEY hRoot, LPDSTR pSubKeyName, DWORD, DELETEDATA_TYPE)
{
	UINT	iRet = ERROR_SUCCESS;
	UINT	iError = ERROR_SUCCESS;
	DCHAR	szError[256];
	HKEY	hKey = NULL;
	HKEY	hSharedDLLKey = NULL;
	HKEY	hSharedDLLKey64 = NULL;
	HKEY	hSharedDLLKey32 = NULL;
	CAPITempBuffer<DCHAR, cchGUIDPacked+1>	szValueName;
	DWORD	dwType;
	CAPITempBuffer<DCHAR, 1>	szPath;
	CAPITempBuffer<DCHAR, 1>	szPathConverted;
	DWORD	dwIndex = 0;
	DWORD	dwRefCount;
	DWORD	dwSizeofDWORD = sizeof(DWORD);
	DWORD	dwSpecialFolderIndex = 0;
	HRESULT	hres = S_OK;
	BOOL	bUseConvertedPath = FALSE;
	BOOL	bDoSecondLoop = FALSE;
	
	if (!szPath.SetSize(cchMaxPath) || !szPathConverted.SetSize(cchMaxPath))
		return ERROR_OUTOFMEMORY;

	// Open the components subkey.
	iError = MsiRegOpen64bitKey(hRoot,
						  CMsInstApiConvertString(pSubKeyName),
						  0,
						  KEY_READ,
						  &hKey);
	
	if(iError != ERROR_SUCCESS)
	{
		StringCbPrintf(szError, sizeof(szError), MSITEXT("%d"), iError);
		DEBUGMSGV1(MSITEXT("LowerSharedDLLRefCount: RegOpenKeyEx returned %s."), szError);
		iRet = iError;
		goto Exit;
	}

	// Open the shared dll key(s)
	if(g_fWinNT64)
	{
		iError = MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE,
									CMsInstApiConvertString(szSharedDlls),
									0,
									KEY_ALL_ACCESS,
									&hSharedDLLKey64);
		if(iError != ERROR_SUCCESS)
		{
			StringCbPrintf(szError, sizeof(szError), MSITEXT("%08x"), iError);
			DEBUGMSGL1(MSITEXT("LowerSharedDLLRefCount: MsiRegOpen64bitKey returned %s."), szError);
			if(iRet == ERROR_SUCCESS)
			{
				iRet = iError;
			}
		}
		iError = RegOpenKeyAPI(HKEY_LOCAL_MACHINE,
							   CMsInstApiConvertString(szSharedDlls),
							   0,
							   KEY_ALL_ACCESS | KEY_WOW64_32KEY,
							   &hSharedDLLKey32);
		if(iError != ERROR_SUCCESS)
		{
			StringCbPrintf(szError, sizeof(szError), MSITEXT("%08x"), iError);
			DEBUGMSGL1(MSITEXT("LowerSharedDLLRefCount: RegOpenKeyAPI returned %s."), szError);
			if(iRet == ERROR_SUCCESS)
			{
				iRet = iError;
			}
		}
		if(!hSharedDLLKey64 && !hSharedDLLKey32)
		{
			// Neither shared dll location can be opened. Quit.
			goto Exit;
		}
	}
	else // if(g_fWinNT64)
	{
		iError = RegOpenKeyAPI(HKEY_LOCAL_MACHINE,
							   CMsInstApiConvertString(szSharedDlls),
							   0,
							   KEY_ALL_ACCESS,
							   &hSharedDLLKey);
		if(iError != ERROR_SUCCESS)
		{
			StringCbPrintf(szError, sizeof(szError), MSITEXT("%08x"), iError);
			DEBUGMSGL1(MSITEXT("LowerSharedDLLRefCount: RegOpenKeyAPI returned %s."), szError);
			if(iRet == ERROR_SUCCESS)
			{
				iRet = iError;
			}
			goto Exit;
		}
	}

	// Enumerate the values to find strings in which the first letters are
	// followed by "?". These are shared dlls.
	while((iError = MsiRegEnumValue(hKey,
									dwIndex,
									szValueName,
									NULL,
									NULL,
									&dwType,
									szPath,
									NULL)) == ERROR_SUCCESS)
	{
		if(lstrlen(szPath) >= 2 && szPath[1] == L'?')
		{
			// This is a shared DLL.
			DEBUGMSG2(MSITEXT("\nLowerSharedDLLRefCount: Found shared DLL %s in component %s"), szPath, szValueName);

			// Temparily change the '?' to ':'.
			szPath[1] = L':';

			// Initialize some control variables.
			bUseConvertedPath = FALSE;

			// On a 64 bit machine, we might have to check for both 32 bit
			// and 64 bit hives for the shared dll key location. The two loops
			// below covers both.
			bDoSecondLoop = TRUE;
			for(int i = 0; i < 2 && bDoSecondLoop; i++)
			{
				if(g_fWinNT64)
				{
					// We are on a 64 bit machine. First compare the path to
					// the 6 special folders.
					DCHAR*	pFolder = NULL;
					DWORD	dwTypeOfFolder = 0;	// 0: non-special folders, 1: special 64 bit folders, 2: special 32 bit folders
					int		j = 0, k = 0;

					for(j = 0; j < dwNumOfSpecialFolders; j++)
					{
						for(k = 0; k < 2; k++)
						{
							if(_wcsnicmp(SpecialFolders[j][k], szPath, lstrlen(SpecialFolders[j][k])) == 0)
							{
								// Yes, this is a special folder location.
								if(k == 1)
								{
									// 64 bit special folder location.
									dwTypeOfFolder = 1;
									break;
								}
								else
								{
									// 32 bit special folder location.
									dwTypeOfFolder = 2;
									dwSpecialFolderIndex = j;
									break;
								}
							}
						}
						if(dwTypeOfFolder != 0)
						{
							// This is one of the special folders.
							break;
						}
					}

					BOOL	bError = FALSE;	// To indicate if we should not exit this loop.
					switch(dwTypeOfFolder)
					{
					case 0:
						{
							DEBUGMSG(MSITEXT("Not special path"));
							if(i == 0)
							{
								// Open the shared dll key in the 32 bit hive.
								hSharedDLLKey = hSharedDLLKey32;
								if(hSharedDLLKey == NULL)
								{
									bError = TRUE;
								}	
							}
							else
							{
								// Open the shared dll key in the 64 bit hive.
								hSharedDLLKey = hSharedDLLKey64;
								if(hSharedDLLKey == NULL)
								{
									bError = TRUE;
								}
							}
							break;
						}

					case 1:
						{
							bDoSecondLoop = FALSE;

							DEBUGMSG(MSITEXT("Special 64 bit path"));
							hSharedDLLKey = hSharedDLLKey64;
							if(hSharedDLLKey == NULL)
							{
								bError = TRUE;
							}
							
							break;
						}

					case 2:
						{
							bDoSecondLoop = FALSE;
							
							DEBUGMSG(MSITEXT("Special 32 bit path"));
							// If the path is in %systemroot%\Syswow64 then
							// convert the path to a regular 64 bit one. The
							// converted path will not be longer than the path
							// before conversion so we won't overflow the
							// buffer.
							if(dwSpecialFolderIndex == 0)
							{
								// System folder.
								StringCchCopy(szPathConverted, szPathConverted.GetSize(), SpecialFolders[j][1]);
								StringCchCat(szPathConverted, szPathConverted.GetSize(), &(szPath[lstrlen(SpecialFolders[j][0])]));
								bUseConvertedPath = TRUE;
							}

							// Open the shared dll key in the 32 bit hive.
							hSharedDLLKey = hSharedDLLKey32;
							if(hSharedDLLKey == NULL)
							{
								bError = TRUE;
							}
							
							break;
						}

					default:
                        Assert(1);
						break; // will never execute
					}
					if(bError)
					{
						continue;
					}
				}
				else
				{
					// Never do the second loop on x86.
					bDoSecondLoop = FALSE;
				}
				
				// Query for the ref count.
				dwSizeofDWORD = sizeof(DWORD);
				if(bUseConvertedPath)
				{
					iError = RegQueryValueEx(hSharedDLLKey,
											 szPathConverted,
											 NULL,
											 &dwType,
											 (LPBYTE)&dwRefCount,
											 &dwSizeofDWORD);
				}
				else
				{
					iError = RegQueryValueEx(hSharedDLLKey,
											 szPath,
											 NULL,
											 &dwType,
											 (LPBYTE)&dwRefCount,
											 &dwSizeofDWORD);
				}
				if(iError != ERROR_SUCCESS)
				{
					StringCbPrintf(szError, sizeof(szError), MSITEXT("%08x"), iError);
					if(bUseConvertedPath)
					{
						DEBUGMSGL2(MSITEXT("LowerSharedDllRefCount: RegQueryValueEx: Can not decrement the ref count for shared dll %s with error %s."), szPathConverted, szError);
					}
					else
					{
						DEBUGMSGL2(MSITEXT("LowerSharedDllRefCount: RegQueryValueEx: Can not decrement the ref count for shared dll %s with error %s."), szPath, szError);
					}
					if(iRet == ERROR_SUCCESS)
					{
						iRet = iError;
					}
					continue;
				}

				// Decreasing the ref count.
				if(dwRefCount == 0)
				{
					// There's some kind of error. The ref count shouldn't be 0.
					// We'll just ignore it.
					continue;
				}
				else
				{
					dwRefCount--;
					if(bUseConvertedPath)
					{
						iError = RegSetValueEx(hSharedDLLKey,
											   szPathConverted,
											   0,
											   dwType,
											   (LPBYTE)&dwRefCount,
											   sizeof(DWORD));
					}
					else
					{
						iError = RegSetValueEx(hSharedDLLKey,
											   szPath,
											   0,
											   dwType,
											   (LPBYTE)&dwRefCount,
											   sizeof(DWORD));
					}
					if(iError != ERROR_SUCCESS)
					{
						StringCbPrintf(szError, sizeof(szError), MSITEXT("%08x"), iError);
						if(bUseConvertedPath)
						{
							DEBUGMSGL2(MSITEXT("LowerSharedDllRefCount: RegSetValueEx: Can not decrement the ref count for shared dll %s with error %s."), szPathConverted, szError);
						}
						else
						{
							DEBUGMSGL2(MSITEXT("LowerSharedDllRefCount: RegSetValueEx: Can not decrement the ref count for shared dll %s with error %s."), szPath, szError);
						}
						if(iRet == ERROR_SUCCESS)
						{
							iRet = iError;
						}
						continue;
					}
					DEBUGMSGL1(MSITEXT("LowerSharedDllRefCount: ref count for %s decremented."), szPath);
				}
			} // for(int i = 0; i < 2; i++)

		} // if(szPath[1] == L'?')
		dwIndex++;
	} // while((iError = MsiRegEnumValue(hKey,

	if(iError != ERROR_NO_MORE_ITEMS && iError != ERROR_SUCCESS)
	{
		StringCbPrintf(szError, sizeof(szError), MSITEXT("%d"), iError);
		DEBUGMSGL2(MSITEXT("LowerSharedDLLRefCount <%s>: MsiRegEnumValue returned %s."), pSubKeyName, szError);
		if(iRet == ERROR_SUCCESS)
		{
			iRet = iError;
		}
		goto Exit;
	}

Exit:

	if(hKey != NULL)
	{
		RegCloseKey(hKey);
	}

	if(g_fWinNT64)
	{
		if(hSharedDLLKey64 != NULL)
		{
			RegCloseKey(hSharedDLLKey64);
		}
		if(hSharedDLLKey32 != NULL)
		{
			RegCloseKey(hSharedDLLKey32);
		}
	}
	else
	{
		if(hSharedDLLKey != NULL)
		{
			RegCloseKey(hSharedDLLKey);
		}
	}

	return iRet;
}

// Delete cached packages, patches, and transforms. If we encounter an error
// while deleting a file, don't return, keep going. Return the first error
// code encountered.
UINT WINAPI DeleteCache(HKEY hRoot, LPDSTR pSubKeyName, DWORD cbSubKeyNameSize, DELETEDATA_TYPE iType)
{
	HKEY	hKey = NULL;
	HKEY	hSubKey = NULL;
	UINT	iRet = ERROR_SUCCESS;
	UINT	iError = ERROR_SUCCESS;
	BOOL	bError = TRUE;
	DCHAR	szError[256];

	if ( !pSubKeyName )
		return ERROR_INVALID_PARAMETER;
	
	// Package: pSubKeyName is product id. No need to be enumerated further.
	// patch: pSubKeyName is patch id. No need to be enumerated further.
	// transform: pSubKeyName is product id. Open Transforms key then enumerate
	// value.
	if(iType == DELETEDATA_PACKAGE || iType == DELETEDATA_PATCH)
	{
		DWORD	dwType = 0;
		DCHAR	szPath[cchMaxPath];
		DWORD	dwPath = cchMaxPath * sizeof(DCHAR);

		if(iType == DELETEDATA_PACKAGE)
		{
			StringCbCat(pSubKeyName, cbSubKeyNameSize, L"\\");
			StringCbCat(pSubKeyName, cbSubKeyNameSize, szMsiInstallPropertiesSubKey);
		}
		iRet = MsiRegOpen64bitKey(hRoot,
								  CMsInstApiConvertString(pSubKeyName),
								  0,
								  KEY_READ,
								  &hSubKey);
		if(iRet != ERROR_SUCCESS)
		{
			StringCbPrintf(szError, sizeof(szError), MSITEXT("%08x"), iRet);
			DEBUGMSGV1(MSITEXT("DeleteCache: RegOpenKeyEx returned %s."), szError);
			goto Exit;
		}
		iRet = RegQueryValueEx(hSubKey,
							   szLocalPackageValueName,
							   0,
							   &dwType,
							   (LPBYTE)szPath,
							   &dwPath);
		if(iRet == ERROR_FILE_NOT_FOUND)
		{
			iRet = ERROR_SUCCESS;
			goto Exit;
		}
		else if(iRet != ERROR_SUCCESS)
		{
			StringCbPrintf(szError, sizeof(szError), MSITEXT("%08x"), iRet);
			DEBUGMSGV1(MSITEXT("DeleteCache: RegQueryValueEx returned %s."), szError);
			goto Exit;
		}

		// Delete the local cache.
		bError = DeleteFileW(szPath);
		if(bError)
		{
			if(iType == DELETEDATA_PACKAGE)
			{
				DEBUGMSGV1(MSITEXT("DeleteCache: Deleted cached package %s."), szPath);
			}
			else
			{
				DEBUGMSGV1(MSITEXT("DeleteCache: Deleted cached patch %s."), szPath);
			}
		}
		else
		{
			iRet = GetLastError();
			StringCbPrintf(szError, sizeof(szError), MSITEXT("%08x"), iRet);
			DEBUGMSGL2(MSITEXT("Failed to delete file %s with error %s."), szPath, szError);
		}
	}
	else
	{
		DWORD	dwIndex = 0;
		DWORD	dwType = 0;
		CAPITempBuffer<DCHAR, 1>	szValueName;
		CAPITempBuffer<DCHAR, 1>	szPath;

		if (!szValueName.SetSize(cchMaxPath) || !szPath.SetSize(cchMaxPath))
			return ERROR_OUTOFMEMORY;

		// Open the transforms key.
		if(iType == DELETEDATA_TRANSFORM)
		{
			StringCbCat(pSubKeyName, cbSubKeyNameSize, L"\\");
			StringCbCat(pSubKeyName, cbSubKeyNameSize, szMsiTransformsSubKey);
		}
		iError = MsiRegOpen64bitKey(hRoot,
							  CMsInstApiConvertString(pSubKeyName),
							  0,
							  KEY_READ,
							  &hKey);
		if(iError != ERROR_SUCCESS && iError != ERROR_FILE_NOT_FOUND)
		{
			if(iRet == ERROR_SUCCESS)
			{
				iRet = iError;
			}
			goto Exit;
		}

		// Enumerate the transforms.
		while((iError = MsiRegEnumValue(hKey,
										dwIndex,
										szValueName,
										NULL,
										NULL,
										&dwType,
										szPath,
										NULL)) == ERROR_SUCCESS)
		{
			if(dwType != REG_SZ)
			{
				dwIndex++;
				continue;
			}

			// Delete the transform.
			bError = DeleteFileW(szPath);
			if(bError)
			{
				iError = ERROR_SUCCESS;
			}
			else
			{
				iError = GetLastError();
			}
			if(iError != ERROR_FILE_NOT_FOUND && iError != ERROR_SUCCESS)
			{
				StringCbPrintf(szError, sizeof(szError), MSITEXT("%08x"), iError);
				DEBUGMSGL2(MSITEXT("Failed to delete file %s with error %s."), szPath, szError);
				if(iRet == ERROR_SUCCESS)
				{
					iRet = iError;
				}
				dwIndex++;
				continue;
			}
			if(iError == ERROR_SUCCESS)
			{
				DEBUGMSGV1(MSITEXT("DeleteCache: Deleted cached transform %s."), szPath);
			}
			dwIndex++;
		}
	}

Exit:

	if(hKey != NULL)
	{
		RegCloseKey(hKey);
	}
	if(hSubKey != NULL)
	{
		RegCloseKey(hSubKey);
	}

	return iRet;
}

// This function will continue even if an error occurs during calling pFunc.
// But it will return the first error code it receives.
UINT EnumAndProccess(HKEY hRoot, LPCDSTR pSubKeyName, PDELETEDATAFUNC pFunc, DELETEDATA_TYPE iType)
{
	HKEY		hKey = NULL;
	UINT		iRet = ERROR_SUCCESS;
	DCHAR		szErr[256];
	UINT		iErr = ERROR_SUCCESS;
	DWORD		dwIndex = 0;
	DCHAR		szSubKeyName[256];
	DWORD		dwSubKeyName = 256;

	// Open the registry key to be enumerated.
	iRet = MsiRegOpen64bitKey(hRoot,
		 				CMsInstApiConvertString(pSubKeyName),
						0,
						KEY_ALL_ACCESS,
						&hKey);
	if(iRet == ERROR_FILE_NOT_FOUND)
	{
		iRet = ERROR_SUCCESS;
		goto Exit;
	}
	if(iRet != ERROR_SUCCESS)
	{
		StringCbPrintf(szErr, sizeof(szErr), MSITEXT("%08x"), iRet);
		DEBUGMSGV1(MSITEXT("EnumAndProccess: RegOpenKeyEx returned %s"), szErr);
		goto Exit;
	}

	// Enumerate the subkeys.
	while((iErr = RegEnumKeyEx(hKey,
							   dwIndex,
							   szSubKeyName,
							   &dwSubKeyName,
							   NULL,
							   NULL,
							   NULL,
							   NULL)) == ERROR_SUCCESS)
	{
		iErr = pFunc(hKey, szSubKeyName, sizeof(szSubKeyName), iType);
		if(iErr != ERROR_SUCCESS && iRet == ERROR_SUCCESS)
		{
			iRet = iErr;
		}
		dwSubKeyName = 256;
		dwIndex++;
	}
	if(iErr != ERROR_NO_MORE_ITEMS && iErr != ERROR_FILE_NOT_FOUND && iErr != ERROR_SUCCESS)
	{
		if(iRet == ERROR_SUCCESS)
		{
			iRet = iErr;
		}
		StringCbPrintf(szErr, sizeof(szErr), MSITEXT("%08x"), iErr);
		DEBUGMSGV1(MSITEXT("EnumAndProccess: RegEnumKeyEx returned %s"), szErr);
	}

Exit:

	if(hKey != NULL)
	{
		RegCloseKey(hKey);
	}

	return iRet;
}

//  Win64 WARNING: MakeAdminRegKeyOwner will always deal with the key in 64-bit hive (since
//  it is called only from DeleteRegTree; if this changes, please modify accordingly)

BOOL MakeAdminRegKeyOwner(HKEY hKey, LPCDSTR pSubKeyName)
{
	SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
	PSID	pAdminSID = NULL;
	HKEY	hSubKey = NULL;
	BOOL	bRet = FALSE;
	HANDLE	hToken = INVALID_HANDLE_VALUE;
	TOKEN_PRIVILEGES	tkp;
	TOKEN_PRIVILEGES	tkpOld;
	DWORD	dwOld;
	BOOL	bPrivilegeAdjusted = FALSE;
	
	// Get process token.
	if(!OpenProcessToken(GetCurrentProcess(),
						 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
						 &hToken))
	{
		// Still return access denied.
		goto Exit;
	}

	// Look up the privilege value.
	if(!LookupPrivilegeValue(NULL,
							 SE_TAKE_OWNERSHIP_NAME,
							 &tkp.Privileges[0].Luid))
	{
		goto Exit;
	}

	// Adjust the token privilege.
	tkp.PrivilegeCount = 1;
	tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	if(!AdjustTokenPrivileges(hToken,
							  FALSE,
							  &tkp,
							  sizeof(tkp),
							  &tkpOld,
							  &dwOld))
	{
		goto Exit;
	}
	bPrivilegeAdjusted = TRUE;

	// Create a SID for the BUILTIN\Administrators group.
	if(!AllocateAndInitializeSid(&SIDAuthNT,
								 2,
								 SECURITY_BUILTIN_DOMAIN_RID,
								 DOMAIN_ALIAS_RID_ADMINS,
								 0,
								 0,
								 0,
								 0,
								 0,
								 0,
								 &pAdminSID))
	{
		goto Exit;
	}

	// Open registry key with permission to change owner
	if(MsiRegOpen64bitKey(hKey, CMsInstApiConvertString(pSubKeyName), 0, WRITE_OWNER, &hSubKey) != ERROR_SUCCESS)
	{
		goto Exit;
	}

	// Attach the admin sid as the object's owner
	if(ADVAPI32::SetSecurityInfo(hSubKey,
								 SE_REGISTRY_KEY, 
								 OWNER_SECURITY_INFORMATION,
								 pAdminSID,
								 NULL,
								 NULL,
								 NULL) != ERROR_SUCCESS)
	{
		goto Exit;
	}

	bRet = TRUE;

Exit:

	if(pAdminSID != NULL)
	{
		FreeSid(pAdminSID);
	}
	if(hSubKey != NULL)
	{
		RegCloseKey(hSubKey);
	}
	if(bPrivilegeAdjusted)
	{
		AdjustTokenPrivileges(hToken,
							  FALSE,
							  &tkpOld,
							  sizeof(tkpOld),
							  NULL,
							  NULL);
	}		
	if(hToken != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hToken);
	}

	return bRet;
}

BOOL AddAdminFullControlToRegKey(HKEY hKey)
{
	PACL						pOldDACL = NULL;
	PACL						pNewDACL = NULL;
	PSECURITY_DESCRIPTOR		pSD = NULL;
	EXPLICIT_ACCESS				ea;
	PSID						pAdminSID = NULL;
	SID_IDENTIFIER_AUTHORITY	SIDAuthNT = SECURITY_NT_AUTHORITY;
	BOOL						bRet = FALSE;

	// Get a pointer to the existing DACL.
	if(ADVAPI32::GetSecurityInfo(hKey,
                                 SE_REGISTRY_KEY, 
                                 DACL_SECURITY_INFORMATION,
                                 NULL,
                                 NULL,
                                 &pOldDACL,
                                 NULL,
                                 &pSD) != ERROR_SUCCESS)
	{
		goto Exit;
	}  

	// Create a SID for the BUILTIN\Administrators group.
	if(!AllocateAndInitializeSid(&SIDAuthNT,
								 2,
								 SECURITY_BUILTIN_DOMAIN_RID,
								 DOMAIN_ALIAS_RID_ADMINS,
								 0,
								 0,
								 0,
								 0,
								 0,
								 0,
								 &pAdminSID) ) {
		goto Exit;
	}

	// Initialize an EXPLICIT_ACCESS structure for an ACE.
	// The ACE will allow the Administrators group full access to the key.
	ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
	ea.grfAccessPermissions = KEY_ALL_ACCESS;
	ea.grfAccessMode = SET_ACCESS;
	ea.grfInheritance= NO_INHERITANCE;
	ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea.Trustee.TrusteeType = TRUSTEE_IS_GROUP;
	ea.Trustee.ptstrName  = (LPTSTR) pAdminSID;

	// Create a new ACL that merges the new ACE
	// into the existing DACL.
	if(ADVAPI32::SetEntriesInAcl(1, &ea, pOldDACL, &pNewDACL) != ERROR_SUCCESS)
	{
		goto Exit;
	}  

	// Attach the new ACL as the object's DACL.
	if(ADVAPI32::SetSecurityInfo(hKey,
							     SE_REGISTRY_KEY, 
							     DACL_SECURITY_INFORMATION,
							     NULL,
							     NULL,
							     pNewDACL,
							     NULL) != ERROR_SUCCESS)
	{
		goto Exit;
	}  

	bRet = TRUE;

Exit:

	if(pSD != NULL) 
	{
		LocalFree((HLOCAL)pSD);
	}
	if(pNewDACL != NULL)
	{
		LocalFree((HLOCAL)pNewDACL);
	}

	return bRet;
}

//  Win64 WARNING: DeleteRegTree will always delete szKeyName in 64-bit hive (since
//  it is called only from MsiDeleteUserData; if this changes, please modify accordingly)

UINT DeleteRegTree(HKEY hRoot, LPCDSTR pSubKeyName)
{
    HKEY	hKey = NULL;
    UINT	iError;
	DCHAR	szError[256];
	DCHAR	szName[MAX_PATH];
    DWORD	dwName = MAX_PATH;
    
    iError = MsiRegOpen64bitKey(hRoot, CMsInstApiConvertString(pSubKeyName), 0, KEY_READ, &hKey);
	if(iError == ERROR_FILE_NOT_FOUND)
    {
		iError = ERROR_SUCCESS;
		goto Exit;
	}
	if(iError != ERROR_SUCCESS)
    {
        StringCbPrintf(szError, sizeof(szError), MSITEXT("%08x"), iError);
		DEBUGMSGV1(MSITEXT("Failed to delete registry key. RegOpenKeyEx returned %s."), szError);
		goto Exit;
    }
    
	while((iError = RegEnumKeyEx(hKey,
								 0,
								 szName,
								 &dwName,
								 NULL,
								 NULL,
								 NULL,
								 NULL)) == ERROR_SUCCESS)
    {
        if((iError = DeleteRegTree(hKey, szName)) != ERROR_SUCCESS)
		{
			StringCbPrintf(szError, sizeof(szError), MSITEXT("%08x"), iError);
			DEBUGMSGV1(MSITEXT("DeleteRegTree: returning %s."), szError);
			goto Exit;
		}
		dwName = MAX_PATH;
    }
    if(iError != ERROR_NO_MORE_ITEMS && iError != ERROR_SUCCESS)
	{
		StringCbPrintf(szError, sizeof(szError), MSITEXT("%08x"), iError);
		DEBUGMSGL1(MSITEXT("Failed to delete registry key. RegEnumKeyEx returned %s."), szError);
        goto Exit;
	}

	RegCloseKey(hKey);
	hKey = NULL;

    if((iError = RegDeleteKeyW(hRoot, pSubKeyName)) != ERROR_SUCCESS)
    {
        if(iError == ERROR_ACCESS_DENIED)
        {
			// see whether we're *really* denied access. 
            // give the admin ownership and full control of the key and try again to delete it
            
			// Take ownership of the key.

			//  Win64 WARNING: DeleteRegTree will always delete szKeyName in 64-bit hive
			if(!MakeAdminRegKeyOwner(hRoot, pSubKeyName))
			{
				goto Exit;
			}

			// Add admin full control to the key.
			if(MsiRegOpen64bitKey(hRoot,
							CMsInstApiConvertString(pSubKeyName),
							0,
							READ_CONTROL | WRITE_DAC,
							&hKey) != ERROR_SUCCESS)
			{
				goto Exit;
			}
			
			if(!AddAdminFullControlToRegKey(hKey))
			{
				goto Exit;
			}

			// Try deleting the key again.
			RegCloseKey(hKey);
			hKey = NULL;

			iError = RegDeleteKeyW(hRoot, pSubKeyName);
        }

		// So here we got ERROR_ACCESS_DENIED on first try, we try to take
		// ownership of the key and try to delete it again. And it failed
		// again.
        if (iError != ERROR_SUCCESS)
        {
			StringCbPrintf(szError, sizeof(szError), MSITEXT("%08x"), iError);
			DEBUGMSGL1(MSITEXT("Failed to delete registry key with the error %s"), szError);
            goto Exit;
        }
    }

Exit:

	if(hKey != NULL)
	{
		RegCloseKey(hKey);
	}
	
    return iError;
}

#endif // MSIUNICODE

UINT __stdcall MsiDeleteUserData(LPCDSTR pSid, LPCDSTR pComputerName, LPVOID pReserved)
//----------------------------------------------
// This function is called by DeleteProfile to clean up darwin information
// associated with a user.
{
#ifdef MSIUNICODE

	DEBUGMSGV(MSITEXT("Enter MsiDeleteUserData"));

	if(pReserved != NULL)
	{
		return ERROR_INVALID_PARAMETER;
	}

    if(pComputerName != NULL)
    {
        return ERROR_SUCCESS;
    }

	if (!pSid || FAILED(StringCchLength(pSid, cchMaxSID+1, NULL)))
	{
		return ERROR_INVALID_PARAMETER;
	}

	if(g_fWin9X == true)
	{
		return ERROR_CALL_NOT_IMPLEMENTED;
	}

	// Delete the following information Under the szMsiUserDataKey\pSid
	// key:
	// 1. Enumerate Components key. Decrement the shared DLL count.
	// 2. Enumerate the Patches key. Delete all cashed patches.
	// 3. Enumerate the Products key. Find InstallProperties key, delete
	//    LocalPackage; Enumerate Transforms key, delete all cashed transforms.
	// 4. Delete the userdata sid key.

	// Enumerator:
	// Enumerate sub keys and run pFunc(HKEY hSubKey).
	// EnumAndProccess(HKEY hRoot, LPCDSTR pSubKey, LPVOID pFunc)
	// There'll be one function for shared DLL, and one for patches,
	// transfroms, and cashed packages. Uses IMsiRegKey to enumerate keys.

	// Local variables.
	DCHAR		szKeyName[256];
	DCHAR		szError[256];
	DWORD		dwError = ERROR_SUCCESS;
	DWORD		dwRet = ERROR_SUCCESS;	// error code returned.
	DCHAR*		pEnd;
	HMODULE		hModule = NULL;
	pSHGetFolderPathW	pFunc;
	HRESULT		hres = S_OK;


	// Initialize the special folders array.
	if(g_fWinNT64)
	{
		// Get SHGetFolderPathW
		if((hModule = LoadLibraryExW(MSITEXT("shell32.dll"), NULL, 0)) == NULL)
		{
			dwError = GetLastError();
			StringCbPrintf(szError, sizeof(szError), MSITEXT("%d"), dwError);
			DEBUGMSGV1(MSITEXT("MsiDeleteUserData: LoadLibraryExW returned %s."), szError);
			return dwError;
		}
		if((pFunc = (pSHGetFolderPathW)GetProcAddress(hModule, "SHGetFolderPathW")) == NULL)
		{
			dwError = GetLastError();
			StringCbPrintf(szError, sizeof(szError), MSITEXT("%d"), dwError);
			DEBUGMSGV1(MSITEXT("MsiDeleteUserData: GetProcAddressW returned %s."), szError);
			return dwError;
		}
		
		// Initialize the special folder paths.
		for(int i = 0; i < dwNumOfSpecialFolders; i++)
		{
			for(int j = 0; j < 2; j++)
			{
				hres = pFunc(NULL,
							 SpecialFoldersCSIDL[i][j],
							 GetUserToken(),
							 SHGFP_TYPE_DEFAULT,
							 SpecialFolders[i][j]);
				if(hres != S_OK)
				{
					StringCbPrintf(szError, sizeof(szError), MSITEXT("%d"), hres);
					DEBUGMSGV1(MSITEXT("MsiDeleteUserData: SHGetFolderPath returned %s."), szError);
					FreeLibrary(hModule);
					return hres;
				}
				else
				{
					DCHAR	szI[5];
					DCHAR	szJ[5];

					StringCbPrintf(szI, sizeof(szI), MSITEXT("%d"), i);
					StringCbPrintf(szJ, sizeof(szI), MSITEXT("%d"), j);
					DEBUGMSGV3(MSITEXT("MsiDeleteUserData: SpecialFolders[%s][%s] = %s."), szI, szJ, SpecialFolders[i][j]);
				}
			}
		}

		FreeLibrary(hModule);
	}

	// Do shared DLLs.
	StringCbCopy(szKeyName, sizeof(szKeyName), szMsiUserDataKey);
	StringCbCat(szKeyName, sizeof(szKeyName), L"\\");
	StringCbCat(szKeyName, sizeof(szKeyName), pSid);
	StringCbCat(szKeyName, sizeof(szKeyName), L"\\");
	pEnd = szKeyName + lstrlen(szKeyName);
	StringCbCat(szKeyName, sizeof(szKeyName), szMsiComponentsSubKey);
	dwError = EnumAndProccess(HKEY_LOCAL_MACHINE, szKeyName, LowerSharedDLLRefCount, DELETEDATA_SHAREDDLL);
	if(dwError != ERROR_SUCCESS)
	{
		dwRet = dwError;
	}

	// Do the patches.
	StringCchCopy(pEnd, sizeof(szKeyName)/sizeof(szKeyName[0]) - (pEnd - szKeyName), szMsiPatchesSubKey);
	dwError = EnumAndProccess(HKEY_LOCAL_MACHINE, szKeyName, DeleteCache, DELETEDATA_PATCH);
	if(dwRet == ERROR_SUCCESS)
	{
		dwRet = dwError;
	}

	// Do the packages.
	StringCchCopy(pEnd, sizeof(szKeyName)/sizeof(szKeyName[0]) - (pEnd - szKeyName), szMsiProductsSubKey);
	dwError = EnumAndProccess(HKEY_LOCAL_MACHINE, szKeyName, DeleteCache, DELETEDATA_PACKAGE);
	if(dwRet == ERROR_SUCCESS)
	{
		dwRet = dwError;
	}

	// Do the transforms.
	StringCchCopy(pEnd, sizeof(szKeyName)/sizeof(szKeyName[0]) - (pEnd - szKeyName), szMsiProductsSubKey);
	dwError = EnumAndProccess(HKEY_LOCAL_MACHINE, szKeyName, DeleteCache, DELETEDATA_TRANSFORM);
	if(dwRet == ERROR_SUCCESS)
	{
		dwRet = dwError;
	}

	// Delete the userdata sid key
	*(pEnd-1) = L'\0';
	//  Win64 WARNING: DeleteRegTree will always delete szKeyName in 64-bit hive
	dwError = DeleteRegTree(HKEY_LOCAL_MACHINE, szKeyName);
	if(dwError != ERROR_SUCCESS)
	{
		StringCbPrintf(szError, sizeof(szError), MSITEXT("%08x"), dwError);
		DEBUGMSGV2(MSITEXT("MsiDeleteUserData: DeleteRegTree <%s> returned %s"), szKeyName, szError);
		if(dwRet == ERROR_SUCCESS)
		{
			dwRet = dwError;
		}		
	}
	
	StringCbPrintf(szError, sizeof(szError), MSITEXT("%08x"), dwRet);
	DEBUGMSGV1(MSITEXT("MsiDeleteUserData: returning %s"), szError);
	return dwRet;

#else

	return MsiDeleteUserDataW(CApiConvertString(pSid), CApiConvertString(pComputerName), pReserved);

#endif // MSIUNICODE
}


DWORD __stdcall Migrate10CachedPackages(LPCDSTR /*szProductCode*/,
	LPCDSTR /*szUser*/,                  
	LPCDSTR /*szAlternativePackage*/,    
	const MIGRATIONOPTIONS /*migOptions*/)
{
	DEBUGMSG(MSITEXT("Migrate10CachedPackages is not yet implemented for the Windows Installer version 2.0"));
	return ERROR_SUCCESS;
}

#ifndef MSIUNICODE
#define MSIUNICODE
#pragma message("Building MSI API UNICODE")
#include "msinst.cpp"
#endif //MSIUNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\msiquery.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       msiquery.cpp
//
//--------------------------------------------------------------------------

/* MsiQuery.cpp - External API for database and engine access
____________________________________________________________________________*/

#include "precomp.h"  // must be first for use with pre-compiled headers
#include "msiquery.h"
#include "_engine.h"
#include "version.h"
#include "_msiutil.h"

//____________________________________________________________________________
//
// These #defines allow us to have the native function (i.e. the one that's
// parameters are the same type as ICHAR) be the fast function. The non-native
// function converts its string args and calls the native one. 
//
// Msi*I are the native functions.
// Msi*X are the non-native functions.
//
// LPCXSTR is defined to be the non-native type (the opposite of ICHAR's type)
//____________________________________________________________________________

#ifdef UNICODE

#define LPCXSTR LPCSTR
#define MsiDatabaseOpenViewI            MsiDatabaseOpenViewW
#define MsiDatabaseOpenViewX            MsiDatabaseOpenViewA
#define MsiDatabaseGetPrimaryKeysI      MsiDatabaseGetPrimaryKeysW
#define MsiDatabaseGetPrimaryKeysX      MsiDatabaseGetPrimaryKeysA
#define MsiDatabaseIsTablePersistentI   MsiDatabaseIsTablePersistentW
#define MsiDatabaseIsTablePersistentX   MsiDatabaseIsTablePersistentA
#define MsiOpenDatabaseI                MsiOpenDatabaseW
#define MsiOpenDatabaseX                MsiOpenDatabaseA
#define MsiDatabaseImportI              MsiDatabaseImportW
#define MsiDatabaseImportX              MsiDatabaseImportA
#define MsiDatabaseExportI              MsiDatabaseExportW
#define MsiDatabaseExportX              MsiDatabaseExportA
#define MsiDatabaseMergeI               MsiDatabaseMergeW
#define MsiDatabaseMergeX               MsiDatabaseMergeA
#define MsiDatabaseGenerateTransformI   MsiDatabaseGenerateTransformW
#define MsiDatabaseGenerateTransformX   MsiDatabaseGenerateTransformA
#define MsiDatabaseApplyTransformI      MsiDatabaseApplyTransformW
#define MsiDatabaseApplyTransformX      MsiDatabaseApplyTransformA
#define MsiCreateTransformSummaryInfoI  MsiCreateTransformSummaryInfoW
#define MsiCreateTransformSummaryInfoX  MsiCreateTransformSummaryInfoA
#define MsiRecordSetStreamI             MsiRecordSetStreamW
#define MsiRecordSetStreamX             MsiRecordSetStreamA
#define MsiGetSummaryInformationI       MsiGetSummaryInformationW
#define MsiGetSummaryInformationX       MsiGetSummaryInformationA
#define MsiSummaryInfoSetPropertyI      MsiSummaryInfoSetPropertyW
#define MsiSummaryInfoSetPropertyX      MsiSummaryInfoSetPropertyA
#define MsiDoActionI                    MsiDoActionW
#define MsiDoActionX                    MsiDoActionA
#define MsiSequenceI                    MsiSequenceW
#define MsiSequenceX                    MsiSequenceA
#define MsiEvaluateConditionI           MsiEvaluateConditionW
#define MsiEvaluateConditionX           MsiEvaluateConditionA
#define MsiPreviewDialogI               MsiPreviewDialogW
#define MsiPreviewDialogX               MsiPreviewDialogA
#define MsiPreviewBillboardI            MsiPreviewBillboardW
#define MsiPreviewBillboardX            MsiPreviewBillboardA
#define MsiGetFeatureValidStatesI       MsiGetFeatureValidStatesW
#define MsiGetFeatureValidStatesX       MsiGetFeatureValidStatesA

#else // ANSI

#define LPCXSTR LPCWSTR
#define MsiDatabaseOpenViewI            MsiDatabaseOpenViewA
#define MsiDatabaseOpenViewX            MsiDatabaseOpenViewW
#define MsiDatabaseGetPrimaryKeysI      MsiDatabaseGetPrimaryKeysA
#define MsiDatabaseGetPrimaryKeysX      MsiDatabaseGetPrimaryKeysW
#define MsiDatabaseIsTablePersistentI   MsiDatabaseIsTablePersistentA
#define MsiDatabaseIsTablePersistentX   MsiDatabaseIsTablePersistentW
#define MsiOpenDatabaseI                MsiOpenDatabaseA
#define MsiOpenDatabaseX                MsiOpenDatabaseW
#define MsiDatabaseImportI              MsiDatabaseImportA
#define MsiDatabaseImportX              MsiDatabaseImportW
#define MsiDatabaseExportI              MsiDatabaseExportA
#define MsiDatabaseExportX              MsiDatabaseExportW 
#define MsiDatabaseMergeI               MsiDatabaseMergeA
#define MsiDatabaseMergeX               MsiDatabaseMergeW
#define MsiDatabaseGenerateTransformI   MsiDatabaseGenerateTransformA
#define MsiDatabaseGenerateTransformX   MsiDatabaseGenerateTransformW
#define MsiDatabaseApplyTransformI      MsiDatabaseApplyTransformA
#define MsiDatabaseApplyTransformX      MsiDatabaseApplyTransformW
#define MsiCreateTransformSummaryInfoI  MsiCreateTransformSummaryInfoA
#define MsiCreateTransformSummaryInfoX  MsiCreateTransformSummaryInfoW
#define MsiRecordSetStreamI             MsiRecordSetStreamA
#define MsiRecordSetStreamX             MsiRecordSetStreamW
#define MsiGetSummaryInformationI       MsiGetSummaryInformationA
#define MsiGetSummaryInformationX       MsiGetSummaryInformationW
#define MsiSummaryInfoSetPropertyI      MsiSummaryInfoSetPropertyA
#define MsiSummaryInfoSetPropertyX      MsiSummaryInfoSetPropertyW
#define MsiDoActionI                    MsiDoActionA
#define MsiDoActionX                    MsiDoActionW
#define MsiSequenceI                    MsiSequenceA
#define MsiSequenceX                    MsiSequenceW
#define MsiEvaluateConditionI           MsiEvaluateConditionA
#define MsiEvaluateConditionX           MsiEvaluateConditionW
#define MsiPreviewDialogI               MsiPreviewDialogA
#define MsiPreviewDialogX               MsiPreviewDialogW
#define MsiPreviewBillboardI            MsiPreviewBillboardA
#define MsiPreviewBillboardX            MsiPreviewBillboardW
#define MsiGetFeatureValidStatesI       MsiGetFeatureValidStatesA
#define MsiGetFeatureValidStatesX       MsiGetFeatureValidStatesW

#endif // UNICODE


#ifdef UNICODE
extern CMsiCustomAction* g_pCustomActionContext;
#endif

//____________________________________________________________________________
//
// Wrapper class for engine to force Terminate call at handle close
//____________________________________________________________________________

const int iidMsiProduct = iidMsiCursor;  // reuse IID (index only) for engine wrapper class
const int iidMsiContext = iidMsiTable;   // reuse IID (index only) for context wrapper class

class CMsiProduct : public IUnknown
{
 public:
	HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long   __stdcall AddRef();
	unsigned long   __stdcall Release();
 public:
	CMsiProduct(IMsiEngine* piEngine) : m_piEngine(piEngine), m_iesReturn(iesNoAction) {}
	IMsiEngine*   GetEngine()   { return m_piEngine; }
	IMsiEngine* m_piEngine;
	iesEnum     m_iesReturn;
};

HRESULT CMsiProduct::QueryInterface(const IID&, void**)
{
	return E_NOINTERFACE;
}

unsigned long CMsiProduct::AddRef()
{
	return 1;          
}

unsigned long CMsiProduct::Release()
{
	PMsiEngine pEngine(m_piEngine);  // must release this after delete to keep allocator alive
	pEngine->Terminate(m_iesReturn); // last return code from sequence or doaction
	delete this;
	return 0;
}

MSIHANDLE CreateMsiProductHandle(IMsiEngine* pi)
{
	return CreateMsiHandle(new CMsiProduct(pi), iidMsiProduct);
}

#ifdef UNICODE

// This class is used to create temporary WCHAR buffers used to remote from the
// custom action server across to the service. It automatically converts the
// resulting LPWSTR back to ANSI and places the results into the provided buffer.
// It also handles the case where the user passes in 0 as the buffer size. This
// causes the marshalling code to die, so the class creates a buffer of length
// 1 instead of 0, but then ignores the results.
class CAnsiToWideOutParam
{
public:

	// cchBuf is the size of the user-provided buffer
	CAnsiToWideOutParam(char* rgchBuf, DWORD *pcchBuf) : m_cwch(0) 
	{
		m_cwch = (pcchBuf) ? *pcchBuf : 0;

		if ((NULL==rgchBuf) || (m_cwch == 0)) 
		{
			m_cwch = 1;
		}

		m_rgchWide.SetSize(m_cwch);
	}
	
	// dangerous, return pointers to internal data. Safe only within scope
	// of object.
	operator WCHAR*() { return (WCHAR*)m_rgchWide; }
	operator DWORD*() { return &m_cwch; }

	DWORD BufferSize() {return m_cwch;}
	
	UINT FillReturnBuffer(UINT uiRes, char *rgchBuf, DWORD *pcchBuf)
	{
		switch (uiRes)
		{
		case ERROR_SUCCESS:
		case ERROR_MORE_DATA: 
		{
			// m_cwch is the size of the property string without NULL
			DWORD cch;
			if((cch = m_rgchWide.GetSize()) > m_cwch)
				cch = m_cwch;
			UINT uiFillRes = ::FillBufferA(m_rgchWide, cch, rgchBuf, pcchBuf);
			if (uiRes == ERROR_MORE_DATA)
			{
				if (pcchBuf)
					*pcchBuf = m_cwch * 2;
			}
			return uiFillRes;
		}
		default:
			return uiRes;
		};
	}

protected:
	DWORD m_cwch;
	CTempBuffer<WCHAR, 256> m_rgchWide;
};

// This class is the counterpart to the ANSI class above. Normally it just holds on to the 
// pointers that the user gives us, but in the case where one or both user-provided args
// is 0, it creates a temp buffer to use when marshalling across to the service so that
// the proxy/stub code doesn't die. When the result comes back from the service, it 
// translates the results back to what they would be if the empty buffer had actually been
// passed in. The one special case is that in an error case, the API would normally not
// modify the buffer, but the marshalling code is forced to put a null in the first character
// or it will crash marshalling the results across. Thus this object has to keep track of what 
// the first character is and replace it in the buffer in an error case.
class CWideOutParam
{
public:

	// cchBuf is the size of the user provided buffer
	CWideOutParam(WCHAR* szBuf, DWORD *pcchBuf) : m_cwch(0)
	{
		m_cwch = (pcchBuf) ? *pcchBuf : 0;
		if ((NULL==szBuf) || (m_cwch == 0)) 
		{
			m_cwch = 1;
		}

		m_rgchWide.SetSize(m_cwch);
	}
	
	// dangerous, return pointers to internal data. Safe only within scope
	// of object.
   	operator WCHAR*() { return (WCHAR*)m_rgchWide; }
	operator DWORD*() { return &m_cwch; }
	
    DWORD BufferSize() { return m_cwch;}
	
	UINT FillReturnBuffer(UINT uiRes, WCHAR *rgchBuf, DWORD *pcchBuf)
	{
		switch (uiRes)
		{
		case ERROR_SUCCESS:
		case ERROR_MORE_DATA: 
 			return ::FillBufferW(m_rgchWide, m_cwch, rgchBuf, pcchBuf);
    	default:
    		return uiRes;
		};
	}

protected:
	DWORD m_cwch;
	CTempBuffer<WCHAR, 1> m_rgchWide;
};
#endif

//____________________________________________________________________________
//
// Special engine proxy to provide a handle to custom actions during rollback
//____________________________________________________________________________

class CMsiCustomContext : public IUnknown
{
 public:
	HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long   __stdcall AddRef();
	unsigned long   __stdcall Release();
 public:  // non-virtual functions to emulate engine virtual functions
	const IMsiString& GetProperty(const ICHAR* szName);
	BOOL              GetMode(MSIRUNMODE eRunMode);
	LANGID            GetLanguage();
	imsEnum           Message(imtEnum imt, IMsiRecord& riRecord);
 public:
	CMsiCustomContext(int icaFlags, const IMsiString& ristrCustomActionData, const IMsiString& ristrProductCode,
									LANGID langid, IMsiMessage& riMessage);
 private:
	unsigned long m_iRefCnt;
	int           m_icaFlags;
	const IMsiString& m_ristrProductCode;
	const IMsiString& m_ristrCustomActionData;
	LANGID        m_langid;
	IMsiMessage&  m_riMessage;
};
inline LANGID  CMsiCustomContext::GetLanguage() { return m_langid; }
inline imsEnum CMsiCustomContext::Message(imtEnum imt, IMsiRecord& riRecord)
	{ return m_riMessage.Message(imt, riRecord); }

MSIHANDLE CreateCustomActionContext(int icaFlags, const IMsiString& ristrCustomActionData, const IMsiString& ristrProductCode,
												LANGID langid, IMsiMessage& riMessage)
{
	return CreateMsiHandle(new CMsiCustomContext(icaFlags, ristrCustomActionData, ristrProductCode,
									langid, riMessage), iidMsiContext);
}

//____________________________________________________________________________
//
// External handle management
//____________________________________________________________________________

static IMsiRecord*       g_pirecLastError = 0;    // cached last error record

IMsiEngine*   GetEngineFromHandle(MSIHANDLE h);
static IMsiEngine* GetEngineFromPreview(MSIHANDLE h);
int SetLastErrorRecord(IMsiRecord* pirecError);  // returns error code, 0 if none, no AddRef()

class CMsiHandle;
CMsiHandle* CreateEmptyHandle(int iid);

class CMsiHandle
{
 public:
	static int           CloseAllHandles();
	static IUnknown*     GetInterface(MSIHANDLE h); // no AddRef done
	static IMsiDirectoryManager* GetDirectoryManager(MSIHANDLE h);
	static IMsiSelectionManager* GetSelectionManager(MSIHANDLE h);
	static IMsiSummaryInfo* GetSummaryInfo(MSIHANDLE h) { return (IMsiSummaryInfo*)FindMsiHandle(h, iidMsiSummaryInfo); }
	static IMsiDatabase* GetDatabase(MSIHANDLE h) { return (IMsiDatabase*)FindMsiHandle(h, iidMsiDatabase); }
	static IMsiRecord*   GetRecord(MSIHANDLE h)   { return (IMsiRecord*)FindMsiHandle(h, iidMsiRecord); }
	static IMsiView*     GetView(MSIHANDLE h)     { return (IMsiView*)FindMsiHandle(h, iidMsiView); }
	static IMsiHandler*  GetHandler(MSIHANDLE h)  { return (IMsiHandler*)FindMsiHandle(h, iidMsiHandler); }
	static IMsiEngine*   GetEngine(MSIHANDLE h)   { return (IMsiEngine*)FindMsiHandle(h, iidMsiEngine); }
	static CMsiProduct*  GetProduct(MSIHANDLE h)  { return (CMsiProduct*)FindMsiHandle(h, iidMsiProduct); }
	static CMsiCustomContext* GetCustomContext(MSIHANDLE h) { return (CMsiCustomContext*)FindMsiHandle(h, iidMsiContext); }
	void          SetObject(IUnknown* pi) {m_piunk = pi;}  // no ref count adjustment
   void          Abandon()      {MsiCloseHandle(m_h);}  // call if error occurred before SetObject called
	MSIHANDLE     GetHandle()    {return m_h;}
	IMsiServices* GetServices()  {return m_piHandleServices;}
 private:
	CMsiHandle(int iid, DWORD dwThreadId);
 private:
	MSIHANDLE m_h;     // handle value, non-zero
	int       m_iid;   // interface type, iidXXX, as defined in msidefs.h
	IUnknown* m_piunk; // pointer to object, 1 refcnt held here
	CMsiHandle*  m_Next;  // linked list
	DWORD     m_dwThreadId; // thread ID of allocator, 0 if owned by system
	static MSIHANDLE      m_hLast; // last handle value used
   static CMsiHandle*    m_Head;
	static IMsiServices*  m_piHandleServices;  // services for handle use
	static int            m_iLock;  // lock for handle chain access

	friend CMsiHandle* CreateEmptyHandle(int iid);
	friend MSIHANDLE   CreateMsiHandle(IUnknown* pi, int iid);
	friend UINT __stdcall MsiCloseHandle(MSIHANDLE hAny);
	friend UINT __stdcall MsiCloseAllHandles();
	friend UINT __stdcall CheckAllHandlesClosed(bool fClose, DWORD dwThreadId);
	friend UINT      CloseMsiHandle(MSIHANDLE hAny, DWORD dwThreadId);
	friend IUnknown* FindMsiHandle(MSIHANDLE h, int iid);
};

MSIHANDLE     CMsiHandle::m_hLast = 0;
CMsiHandle*   CMsiHandle::m_Head = 0;
IMsiServices* CMsiHandle::m_piHandleServices = 0;
int           CMsiHandle::m_iLock = 0;

inline CMsiHandle::CMsiHandle(int iid, DWORD dwThreadId)  // call only from critical section
	: m_iid(iid), m_dwThreadId(dwThreadId), m_Next(m_Head), m_h(++m_hLast), m_piunk(0)
{
	m_Head = this;  // no AddRef, ownership transferred
}

MSIHANDLE CreateMsiHandle(IUnknown* pi, int iid)
{
	if (pi == 0)
		return 0;
	CMsiHandle* pHandle = CreateEmptyHandle(iid);
	if (pHandle == 0)  // shouldn't happen
		return 0;	
	pHandle->SetObject(pi);
	return pHandle->GetHandle();
}

CMsiHandle* CreateEmptyHandle(int iid)
{
	while (TestAndSet(&CMsiHandle::m_iLock)) // acquire lock
	{
		Sleep(10);
	}
	if (CMsiHandle::m_Head == 0)
	{
		CMsiHandle::m_piHandleServices = ENG::LoadServices();
	}
	if (CMsiHandle::m_hLast == 0xFFFFFFFFL)  // check for handle overflow
		 CMsiHandle::m_hLast++;              // skip over null handle

	DWORD dwThread = MsiGetCurrentThreadId();
	CMsiHandle* pHandle = new CMsiHandle(iid, dwThread);
	CMsiHandle::m_iLock = 0;  // release lock
	DEBUGMSGLX3(TEXT("Creating MSIHANDLE (%d) of type %d for thread %d"),pHandle ? (const ICHAR*)(INT_PTR)pHandle->m_h : 0,(const ICHAR*)(INT_PTR)iid, (const ICHAR*)(INT_PTR)dwThread);
	return pHandle;
}

UINT CloseMsiHandle(MSIHANDLE hAny, DWORD dwThreadId)
{
	if (hAny)
	{
		while (TestAndSet(&CMsiHandle::m_iLock)) // acquire lock
		{
			Sleep(10);
		}
		CMsiHandle* pHandle;
		CMsiHandle** ppPrev = &CMsiHandle::m_Head;
		for(;;)
		{
			if ((pHandle = *ppPrev) == 0)
			{
				CMsiHandle::m_iLock = 0;  // release lock
				return ERROR_INVALID_HANDLE;
			}
			if (pHandle->m_h == hAny)
				break;
			ppPrev = &pHandle->m_Next;
		}
		if (dwThreadId != pHandle->m_dwThreadId)
		{
			if (g_pActionThreadHead != 0 && FIsCustomActionThread(dwThreadId))
			{
				DEBUGMSG3(TEXT("Improper MSIHANDLE closing. Trying to close MSIHANDLE (%d) of type %d for thread %d by custom action thread %d."), (const ICHAR*)(UINT_PTR)pHandle->m_h,(const ICHAR*)(UINT_PTR)pHandle->m_iid, (const ICHAR*)(UINT_PTR)pHandle->m_dwThreadId);
				CMsiHandle::m_iLock = 0;  // release lock
				return ERROR_INVALID_THREAD_ID;
			}
		}
		DEBUGMSGLX3(TEXT("Closing MSIHANDLE (%d) of type %d for thread %d"),(const ICHAR*)(INT_PTR)pHandle->m_h,(const ICHAR*)(INT_PTR)pHandle->m_iid, (const ICHAR*)(INT_PTR)pHandle->m_dwThreadId);
		dwThreadId; //!! do we want to fail hard here? return ERROR_INVALID_HANDLE; or something different
		*ppPrev = pHandle->m_Next;
		IUnknown* piunk = pHandle->m_piunk;  // must release after handle destroyed
		delete pHandle;
		if (piunk != 0)
			piunk->Release();  // may release allocator, must come after delete
		if (CMsiHandle::m_Head == 0)
		{
			SetLastErrorRecord(0);
			ENG::FreeServices(), CMsiHandle::m_piHandleServices = 0;
		}
		CMsiHandle::m_iLock = 0;  // release lock
	}
	return ERROR_SUCCESS;
}

UINT __stdcall MsiCloseHandle(MSIHANDLE hAny)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG1(TEXT("Passing to service: MsiCloseHandle(%d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hAny)));
		return g_pCustomActionContext->CloseHandle(hAny);
	}
	else
#endif // UNICODE
		return CloseMsiHandle(hAny, MsiGetCurrentThreadId());
}

UINT __stdcall CheckAllHandlesClosed(bool fClose, DWORD dwThreadId)
{

#ifdef DEBUG
	DWORD dwCurrentThreadId = MsiGetCurrentThreadId();
#endif

	CMsiHandle** ppHandle = &CMsiHandle::m_Head;
	CMsiHandle*   pHandle;
	int cOpenHandles = 0;
	while ((pHandle = *ppHandle) != 0)
	{
		if (pHandle->m_dwThreadId != dwThreadId  // allocated by some other thread
		 || pHandle->m_iid == 0)                 // allocated by automation class factory
			ppHandle = &pHandle->m_Next;
		else
		{
			cOpenHandles++;
			DEBUGMSG3(TEXT("Leaked MSIHANDLE (%d) of type %d for thread %d"),(const ICHAR*)(INT_PTR)pHandle->m_h,(const ICHAR*)(INT_PTR)pHandle->m_iid, (const ICHAR*)(INT_PTR)pHandle->m_dwThreadId);
			if (fClose)
				CloseMsiHandle(pHandle->m_h, dwThreadId);
			else
				ppHandle = &pHandle->m_Next;
		}
	}
	return cOpenHandles;
}

UINT __stdcall MsiCloseAllHandles()  // close all handles allocated by current thread
{
	#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG(TEXT("Passing to service: MsiCloseAllHandles()"));
		return g_pCustomActionContext->CloseAllHandles();
	}
	else
	#endif // UNICODE
		return CheckAllHandlesClosed(true, MsiGetCurrentThreadId());
}

IMsiEngine* GetEngineFromHandle(MSIHANDLE h)
{
	IMsiEngine* piEngine = CMsiHandle::GetEngine(h);
	if (piEngine == 0)
	{
		CMsiProduct* piProduct = CMsiHandle::GetProduct(h);
		if (piProduct)
		{
			piEngine = piProduct->m_piEngine;
			piEngine->AddRef();
		}
	}
	return piEngine;
}

IMsiDirectoryManager* CMsiHandle::GetDirectoryManager(MSIHANDLE h)
{
	IMsiDirectoryManager* piDirectoryManager = 0;
	PMsiEngine pEngine = GetEngineFromHandle(h);
	if (pEngine)
		pEngine->QueryInterface(IID_IMsiDirectoryManager, (void**)&piDirectoryManager);
	return piDirectoryManager;
}

IMsiSelectionManager* CMsiHandle::GetSelectionManager(MSIHANDLE h)
{
	IMsiSelectionManager* piSelectionManager = 0;
	PMsiEngine pEngine = GetEngineFromHandle(h);
	if (pEngine)
		pEngine->QueryInterface(IID_IMsiSelectionManager, (void**)&piSelectionManager);
	return piSelectionManager;
}

IUnknown* FindMsiHandle(MSIHANDLE h, int iid)
{
	while (TestAndSet(&CMsiHandle::m_iLock)) // acquire lock
	{
		Sleep(10);
	}
	for (CMsiHandle* pHandle = CMsiHandle::m_Head; pHandle != 0; pHandle = pHandle->m_Next)
		if (pHandle->m_h == h && pHandle->m_iid == iid)
		{
			pHandle->m_piunk->AddRef();
			CMsiHandle::m_iLock = 0;  // release lock
			return pHandle->m_piunk;
		}
	CMsiHandle::m_iLock = 0;  // release lock
	return 0;
}

int SetLastErrorRecord(IMsiRecord* pirecError)
{
	if (g_pirecLastError)
		g_pirecLastError->Release();
	g_pirecLastError = pirecError;
	if (pirecError)
		return pirecError->GetInteger(1);
	else
		return 0;
}

//____________________________________________________________________________
//
// String handling utility functions
//____________________________________________________________________________

UINT FillBufferA(const ICHAR* psz, unsigned int cich, LPSTR szBuf, DWORD* pcchBuf)
/*----------------------------------------------------------------------------
  Fills szBuf with the text of pistr. Truncates and null-terminates if 
  szBuf is too small.

Arguments:
	pistr: The source string.
	szBuf: The buffer to fill. May be NULL if only the length of pistr
			 is desired.
	*pcchBuf: On entry contains the length of the szBuf. May be NULL only if
	          szBuf is NULL. If this is the case then nothing is done. On
				 return *pcchBuf contains the length of pistr.
Returns:
	ERROR_SUCCESS - The buffer was filled with the entire contents of pistr
	ERROR_MORE_DATA - The buffer was too small to hold the entire contents of pistr
	ERROR_INVALID_PARAMETER - szBuf was non-NULL and pcchBuf was NULL
------------------------------------------------------------------------------*/
{
	UINT iStat = ERROR_SUCCESS;

	if (pcchBuf)
	{
		unsigned int cchBuf = *pcchBuf;
#ifdef UNICODE	
		unsigned int cch = cich ? WIN::WideCharToMultiByte(CP_ACP, 0, psz, cich, 0, 0, 0, 0) 
										: 0;
#else
		unsigned int cch = cich;
#endif

		*pcchBuf = cch;
		if (szBuf != 0)
		{
			if (cchBuf <= *pcchBuf)
			{
				iStat = ERROR_MORE_DATA;
				if (cchBuf == 0)
					return iStat;
				cch = cchBuf - 1;
			}
			if (cch > 0)
#ifdef UNICODE
				WIN::WideCharToMultiByte(CP_ACP, 0, psz, cich, szBuf, cch, 0, 0);

#else
				memcpy(szBuf, psz, cch);
#endif
			szBuf[cch] = 0;
		}
	}
	else if (szBuf != 0)
	{
		iStat = ERROR_INVALID_PARAMETER;
	}

	return iStat;
}


UINT FillBufferW(const ICHAR* psz, unsigned int cich, LPWSTR szBuf, DWORD* pcchBuf)
/*----------------------------------------------------------------------------
  Fills szBuf with the text of pistr. Truncates and null-terminates if 
  szBuf is too small.

Arguments:
	pistr: The source string.
	szBuf: The buffer to fill. May be NULL if only the length of pistr
			 is desired.
	*pcchBuf: On entry contains the length of the szBuf. May be NULL only if
	          szBuf is NULL. If this is the case then nothing is done. On
				 return *pcchBuf contains the length of pistr.
Returns:
	ERROR_SUCCESS - The buffer was filled with the entire contents of pistr
	ERROR_MORE_DATA - The buffer was too small to hold the entire contents of pistr
	ERROR_INVALID_PARAMETER - szBuf was non-NULL and pcchBuf was NULL
------------------------------------------------------------------------------*/
{
	UINT iStat = ERROR_SUCCESS;

	if (pcchBuf)
	{
		unsigned int cchBuf = *pcchBuf;

#ifdef UNICODE	
		unsigned int cwch = cich;
#else
		unsigned int cwch =0 ;
		if (cich)
			cwch = WIN::MultiByteToWideChar(CP_ACP, 0, psz, cich, 0, 0);
#endif

		*pcchBuf = cwch;
		if (szBuf != 0)
		{
			if (cchBuf <= *pcchBuf)
			{
				iStat = ERROR_MORE_DATA;
				if (cchBuf == 0)
					return iStat;
				cwch = cchBuf - 1;
			}
			if (cwch > 0)
			{
#ifdef UNICODE
				memcpy(szBuf, psz, cwch * sizeof(WCHAR));
#else
				WIN::MultiByteToWideChar(CP_ACP, 0, psz, cich, szBuf, cwch);
#endif
			}
			szBuf[cwch] = 0;
		}
	}
	else if (szBuf != 0)
	{
		iStat = ERROR_INVALID_PARAMETER;
	}

	return iStat;
}

//____________________________________________________________________________
//
// CMsiConvertString class.
//____________________________________________________________________________

const IMsiString& CMsiConvertString::operator *()
{
	ENG::LoadServices();    // insure that g_piMsiStringNull exists
	fLoaded = fTrue;
	const IMsiString* pistrNull = &g_MsiStringNull;
	if (!m_piStr)
	{
		if (!m_sza)
		{
			if (m_szw == 0 || *m_szw == 0)
				m_piStr = &g_MsiStringNull;
			else
			{
				
#ifdef UNICODE
				pistrNull->SetString(m_szw, m_piStr);
#else
				unsigned int cch = lstrlenW(m_szw);
				unsigned int cb = WIN::WideCharToMultiByte(CP_ACP, 0, m_szw, cch, 0, 0, 0, 0);
				Bool fDBCS = (cb == cch ? fFalse : fTrue);

				m_piStr = 0;
				ICHAR* pch = pistrNull->AllocateString(cb, fDBCS, m_piStr);
				if ( ! pch )
					m_piStr = &g_MsiStringNull;
				else
				{
					BOOL fUsedDefault;
					WIN::WideCharToMultiByte(CP_ACP, 0, m_szw, cch, pch, cb, 0, &fUsedDefault);
				}
#endif
			}
		}
		else if (!m_szw)
		{
			if (m_sza == 0 || *m_sza == 0)
				m_piStr = &g_MsiStringNull;
			else
			{
#ifdef UNICODE
				unsigned int cch  = lstrlenA(m_sza);
				unsigned int cwch = WIN::MultiByteToWideChar(CP_ACP, 0, m_sza, cch, 0, 0);
				m_piStr = 0;
				ICHAR* pch = pistrNull->AllocateString(cwch, fFalse, m_piStr);
				if ( ! pch )
					m_piStr = &g_MsiStringNull;
				else
					WIN::MultiByteToWideChar(CP_ACP, 0, m_sza, cch, pch, cwch);
#else
				pistrNull->SetString(m_sza, m_piStr);
#endif
			}
		}
	}

	return *m_piStr;
}


UINT MapActionReturnToError(iesEnum ies, MSIHANDLE hInstall)
{
	CMsiProduct* piProduct = CMsiHandle::GetProduct(hInstall);
	if (piProduct)
		piProduct->m_iesReturn = ies;  // save for IMsiEngine::Terminate(iesEnum)
	switch (ies)
	{
	case iesNoAction:      return ERROR_FUNCTION_NOT_CALLED;
	case iesSuccess:       return ERROR_SUCCESS;
	case iesUserExit:      return ERROR_INSTALL_USEREXIT;
	case iesFailure:       return ERROR_INSTALL_FAILURE;
	case iesSuspend:       return ERROR_INSTALL_SUSPEND;
	case iesFinished:      return ERROR_MORE_DATA;
	case iesWrongState:    return ERROR_INVALID_HANDLE_STATE;
	case iesBadActionData: return ERROR_INVALID_DATA;
	case iesInstallRunning: return ERROR_INSTALL_ALREADY_RUNNING;
	default:               return ERROR_FUNCTION_FAILED;
	}
}

MSIDBERROR MapViewGetErrorReturnToError(iveEnum ive)
{
	switch (ive)
	{
	case iveNoError:           return MSIDBERROR_NOERROR;
	case iveDuplicateKey:      return MSIDBERROR_DUPLICATEKEY;
	case iveRequired:          return MSIDBERROR_REQUIRED;
	case iveBadLink:           return MSIDBERROR_BADLINK;
	case iveOverFlow:          return MSIDBERROR_OVERFLOW;
	case iveUnderFlow:         return MSIDBERROR_UNDERFLOW;
	case iveNotInSet:          return MSIDBERROR_NOTINSET;
	case iveBadVersion:        return MSIDBERROR_BADVERSION;
	case iveBadCase:           return MSIDBERROR_BADCASE;
	case iveBadGuid:           return MSIDBERROR_BADGUID;
	case iveBadWildCard:       return MSIDBERROR_BADWILDCARD;
	case iveBadIdentifier:     return MSIDBERROR_BADIDENTIFIER;
	case iveBadLanguage:       return MSIDBERROR_BADLANGUAGE;
	case iveBadFilename:       return MSIDBERROR_BADFILENAME;
	case iveBadPath:           return MSIDBERROR_BADPATH;
	case iveBadCondition:      return MSIDBERROR_BADCONDITION;
	case iveBadFormatted:      return MSIDBERROR_BADFORMATTED;
	case iveBadTemplate:       return MSIDBERROR_BADTEMPLATE;
	case iveBadDefaultDir:     return MSIDBERROR_BADDEFAULTDIR;
	case iveBadRegPath:        return MSIDBERROR_BADREGPATH;
	case iveBadCustomSource:   return MSIDBERROR_BADCUSTOMSOURCE;
	case iveBadProperty:       return MSIDBERROR_BADPROPERTY;
	case iveMissingData:       return MSIDBERROR_MISSINGDATA;
	case iveBadCategory:       return MSIDBERROR_BADCATEGORY;
	case iveBadKeyTable:       return MSIDBERROR_BADKEYTABLE;
	case iveBadMaxMinValues:   return MSIDBERROR_BADMAXMINVALUES;
	case iveBadCabinet:        return MSIDBERROR_BADCABINET;
	case iveBadShortcut:       return MSIDBERROR_BADSHORTCUT;
	case iveStringOverflow:    return MSIDBERROR_STRINGOVERFLOW;
	case iveBadLocalizeAttrib: return MSIDBERROR_BADLOCALIZEATTRIB;
	default:                   return MSIDBERROR_FUNCTIONERROR;
	};
}

//____________________________________________________________________________
//
// Database access API implementation
//____________________________________________________________________________

// Prepare a database query, creating a view object
// Result is TRUE if successful and returns the view handle
// Result is FALSE if error and returns an error record handle

UINT __stdcall MsiDatabaseOpenViewI(MSIHANDLE hDatabase,
	const ICHAR *szQuery,           // SQL query to be prepared
	MSIHANDLE*  phView)             // returned view if TRUE
{
	if (phView == 0)
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(TEXT("Passing to service: MsiDatabaseOpenView(%d, \"%s\")"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hDatabase)), szQuery ? szQuery : TEXT("NULL"));
		return g_pCustomActionContext->DatabaseOpenView(hDatabase, szQuery, phView);
	}
#endif

	IMsiView* piView;
	PMsiDatabase pDatabase = CMsiHandle::GetDatabase(hDatabase);
	if (pDatabase == 0)
		return ERROR_INVALID_HANDLE;
	//!! the following not needed any more, okay to pass intent as 0 always
	ivcEnum intent = pDatabase->GetUpdateState()==idsWrite ? ivcEnum(ivcModify | ivcFetch) : ivcFetch;  //!!temp
	int iError = SetLastErrorRecord(pDatabase->OpenView(szQuery, intent, piView));
	if (iError)
	{
		*phView = 0;
//		if (iError == imsg iError = imsgOdbcOpenView)  //!! error codes not consistent
			return ERROR_BAD_QUERY_SYNTAX;
	}
	*phView = ::CreateMsiHandle(piView, iidMsiView);
	return ERROR_SUCCESS;
}

UINT __stdcall MsiDatabaseOpenViewX(MSIHANDLE hDatabase,
	LPCXSTR     szQuery,            // SQL query to be prepared
	MSIHANDLE*  phView)             // returned view if TRUE
{
	return MsiDatabaseOpenViewI(hDatabase, CMsiConvertString(szQuery), phView);
}


// Returns the MSIDBERROR enum and name of the column corresponding to the error
// Similar to a GetLastError function, but for the view.  
// Returns errors of MsiViewModify.

MSIDBERROR __stdcall MsiViewGetErrorA(MSIHANDLE hView,
	LPSTR szColumnNameBuffer,   // buffer for column name
	DWORD* pcchBuf)				 // size of buffer
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG1("Passing to service: MsiViewGetErrorA(%d)", reinterpret_cast<const char *>(static_cast<UINT_PTR>(hView)));
		MSIDBERROR msidb;
		DWORD cwch = pcchBuf ? *pcchBuf : 0;
		CTempBuffer<WCHAR, 256> rgchWide(cwch);

		if ( ! (WCHAR *) rgchWide )
			return MSIDBERROR_INVALIDARG;
     
        if (ERROR_SUCCESS == g_pCustomActionContext->ViewGetError(hView, rgchWide, cwch, &cwch, (int*)&msidb))
		{
			UINT iStat = 0;
			if ((iStat = ::FillBufferA(rgchWide, cwch, szColumnNameBuffer, pcchBuf)) != ERROR_SUCCESS)
				return iStat == ERROR_MORE_DATA ? MSIDBERROR_MOREDATA : MSIDBERROR_INVALIDARG;
		}
		else
		{
			msidb = MSIDBERROR_FUNCTIONERROR;
		}
		return msidb;
	}
#endif

	PMsiView pView = CMsiHandle::GetView(hView);
	if (pView == 0)
		return *pcchBuf = 0, MSIDBERROR_INVALIDARG;
	MsiString strColName = (const ICHAR*)0;
	iveEnum iveReturn = pView->GetError(*&strColName);
	UINT iStat = 0;
	if ((iStat = ::FillBufferA(strColName, szColumnNameBuffer, pcchBuf)) != ERROR_SUCCESS)
		return iStat == ERROR_MORE_DATA ? MSIDBERROR_MOREDATA : MSIDBERROR_INVALIDARG;
	return MapViewGetErrorReturnToError(iveReturn);
}

MSIDBERROR __stdcall MsiViewGetErrorW(MSIHANDLE hView,
	LPWSTR szColumnNameBuffer,  // buffer for column name
	DWORD*     pcchBuf)            // size of buffer
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG1(TEXT("Passing to service: MsiViewGetErrorW(%d)"), reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(hView)));
		MSIDBERROR msidb;
		if (ERROR_SUCCESS != g_pCustomActionContext->ViewGetError(hView, szColumnNameBuffer, (pcchBuf) ? *pcchBuf : 0, pcchBuf, (int*)&msidb))
			msidb = MSIDBERROR_FUNCTIONERROR;
		return msidb;
	}
#endif

	PMsiView pView = CMsiHandle::GetView(hView);
	if (pView == 0)
		return *pcchBuf = 0, MSIDBERROR_INVALIDARG;
	MsiString strColName = (const ICHAR*)0;
	iveEnum iveReturn = pView->GetError(*&strColName);
	UINT iStat = 0;
	if ((iStat = ::FillBufferW(strColName, szColumnNameBuffer, pcchBuf)) != ERROR_SUCCESS)
		return iStat == ERROR_MORE_DATA ? MSIDBERROR_MOREDATA : MSIDBERROR_INVALIDARG;
	return MapViewGetErrorReturnToError(iveReturn);
}


// Exectute the view query, supplying parameters as required
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_HANDLE_STATE, ERROR_FUNCTION_FAILED

UINT __stdcall MsiViewExecute(MSIHANDLE hView,
	MSIHANDLE hRecord)              // optional parameter record, or 0 if none
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(TEXT("Passing to service: MsiViewExecute(%d, %d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hView)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hRecord)));
		return g_pCustomActionContext->ViewExecute(hView, hRecord);
	}
#endif

	PMsiView pView = CMsiHandle::GetView(hView);
	PMsiRecord precParams = CMsiHandle::GetRecord(hRecord);
	if (pView == 0 || (hRecord != 0 && precParams == 0))
		return ERROR_INVALID_HANDLE;
	int iError = SetLastErrorRecord(pView->Execute(precParams));
//		if (iError == imsg iError = imsgOdbcOpenView)  //!! error codes not consistent
	if (iError)
		return ERROR_FUNCTION_FAILED;
	return ERROR_SUCCESS;
}

// Fetch the next sequential record from the view
// Result is ERROR_SUCCESS if a row is found, and its handle is returned
// else ERROR_NO_MORE_ITEMS if no records remain, and a null handle is returned
// else result is error: ERROR_INVALID_HANDLE_STATE, ERROR_INVALID_HANDLE, ERROR_FUNCTION_FAILED

UINT __stdcall MsiViewFetch(MSIHANDLE hView,
	MSIHANDLE*  phRecord)           // returned data record if TRUE
{
	if (phRecord == 0)
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG1(TEXT("Passing to service: MsiViewFetch(%d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hView)));
		return g_pCustomActionContext->ViewFetch(hView, phRecord);
	}
#endif

	PMsiView pView = CMsiHandle::GetView(hView);
	if (pView == 0)
		return ERROR_INVALID_HANDLE;
	IMsiRecord* pirecFetch = pView->Fetch();
	if (pirecFetch == 0)
	{
		if(pView->GetState() == dvcsBound) // the view would be back to the bound state at the end of the result set
			return (*phRecord = 0, ERROR_NO_MORE_ITEMS);
		else // we were not in the bound or fetched state when we called Fetch()
			return (*phRecord = 0, ERROR_FUNCTION_FAILED);
	}
	*phRecord = ::CreateMsiHandle(pirecFetch, iidMsiRecord);
	return ERROR_SUCCESS;
}

// Update a fetched record, parameters must match types in query columns
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_HANDLE_STATE, ERROR_FUNCTION_FAILED, ERROR_ACCESS_DENIED

UINT __stdcall MsiViewModify(MSIHANDLE hView,
	MSIMODIFY eUpdateMode,         // update action to perform
	MSIHANDLE hRecord)             // record obtained from fetch, or new record
{
	if (eUpdateMode >= irmNextEnum || eUpdateMode <= irmPrevEnum)
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3(TEXT("Passing to service: MsiViewModify(%d, %d, %d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hView)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(eUpdateMode)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hRecord)));
		return g_pCustomActionContext->ViewModify(hView, eUpdateMode, hRecord);
	}
#endif

	PMsiView pView = CMsiHandle::GetView(hView);
	PMsiRecord precData = CMsiHandle::GetRecord(hRecord);
	if (pView == 0 || precData == 0)
		return ERROR_INVALID_HANDLE;
	int iError = SetLastErrorRecord(pView->Modify(*precData, (irmEnum)eUpdateMode));
	if (!iError)
		return ERROR_SUCCESS;
	return iError == idbgDbInvalidData ? ERROR_INVALID_DATA : ERROR_FUNCTION_FAILED;
}

// Return the column names or specifications for the current view
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_PARAMETER, or ERROR_INVALID_HANDLE_STATE

UINT __stdcall MsiViewGetColumnInfo(MSIHANDLE hView,
	MSICOLINFO eColumnInfo,        // retrieve columns names or definitions
	MSIHANDLE *phRecord)           // returned data record containing all names or definitions
{
	if (phRecord == 0)
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(TEXT("Passing to service: MsiViewGetColumnInfo(%d, %d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hView)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(eColumnInfo)));
		return g_pCustomActionContext->ViewGetColumnInfo(hView, eColumnInfo, phRecord);
	}
#endif

	PMsiView pView = CMsiHandle::GetView(hView);
	if (pView == 0)
		return ERROR_INVALID_HANDLE;
	IMsiRecord* pirecInfo;
	switch (eColumnInfo)
	{
	case MSICOLINFO_NAMES: pirecInfo = pView->GetColumnNames(); break;
	case MSICOLINFO_TYPES: pirecInfo = pView->GetColumnTypes(); break;
	default:               return ERROR_INVALID_PARAMETER;
	}
	if (pirecInfo == 0)
		return ERROR_INVALID_HANDLE_STATE;
	*phRecord = ::CreateMsiHandle(pirecInfo, iidMsiRecord);
	return ERROR_SUCCESS;
}

// Release the result set for an executed view, to allow re-execution
// Only needs to be called if not all records have been fetched
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_HANDLE_STATE

UINT __stdcall MsiViewClose(MSIHANDLE hView)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG1(TEXT("Passing to service: MsiViewClose(%d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hView)));
		return g_pCustomActionContext->ViewClose(hView);
	}
#endif

	PMsiView pView = CMsiHandle::GetView(hView);
	if (pView == 0)
		return ERROR_INVALID_HANDLE;
	int iError = SetLastErrorRecord(pView->Close());
	if (iError == 0)
		return ERROR_SUCCESS;
	if (iError == idbgDbWrongState)
		return ERROR_INVALID_HANDLE_STATE;
	else
		return ERROR_FUNCTION_FAILED;  // never generated internally
}

// Return a record containing the names of all primary key columns for a given table
// Returns an MSIHANDLE for a record containing the name of each column.
// The field count of the record corresponds to the number of primary key columns.
// Field [0] of the record contains the table name.
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_TABLE, ERROR_INVALID_PARAMETER

UINT WINAPI MsiDatabaseGetPrimaryKeysI(MSIHANDLE hDatabase,
	const ICHAR*    szTableName,       // the name of a specific table (case-sensitive)
	MSIHANDLE       *phRecord)         // returned record if ERROR_SUCCESS
{
	if (szTableName == 0 || phRecord == 0 ||
		 FAILED(StringCchLength(szTableName, cchMaxTableName+1, NULL)))
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(TEXT("Passing to service: MsiDatabaseGetPrimaryKeys(%d, \"%s\")"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hDatabase)), szTableName);
		return g_pCustomActionContext->DatabaseGetPrimaryKeys(hDatabase, szTableName, phRecord);
	}
#endif

	PMsiDatabase pDatabase = CMsiHandle::GetDatabase(hDatabase);
	if (pDatabase == 0)
		return ERROR_INVALID_HANDLE;
	IMsiRecord* pirecKeys = pDatabase->GetPrimaryKeys(szTableName);
	if (pirecKeys == 0)
		return ERROR_INVALID_TABLE;
	*phRecord = ::CreateMsiHandle(pirecKeys, iidMsiRecord);
	return ERROR_SUCCESS;
}

UINT WINAPI MsiDatabaseGetPrimaryKeysX(MSIHANDLE hDatabase,
	LPCXSTR     szTableName,      // the name of a specific table (case-sensitive)
	MSIHANDLE  *phRecord)         // returned record if ERROR_SUCCESS
{
	return MsiDatabaseGetPrimaryKeysI(hDatabase, CMsiConvertString(szTableName), phRecord);
}

// Return an enum defining the state of the table (temporary, unknown, or persistent).
// Returns MSICONDITION_ERROR, MSICONDITION_FALSE, MSICONDITION_TRUE, MSICONDITION_NONE
// MSICONDITION_ERROR (invalid handle, invalid argument)
// MSICONDITION_TRUE (persistent), MSICONDITION_FALSE (temporary),
// MSIOCNDITION_NONE (table undefined)
MSICONDITION WINAPI MsiDatabaseIsTablePersistentI(MSIHANDLE hDatabase,
	const ICHAR* szTableName)         // the name of a specific table
{
	if (szTableName == 0 ||
		 FAILED(StringCchLength(szTableName, cchMaxTableName+1, NULL)))
		return MSICONDITION_ERROR; // ERROR_INVALID_PARAMETER

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(TEXT("Passing to service: MsiDatabaseIsTablePersistent(%d, \"%s\")"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hDatabase)), szTableName);
		MSICONDITION msicond;
		if (ERROR_SUCCESS != g_pCustomActionContext->DatabaseIsTablePersistent(hDatabase, szTableName, (int*)&msicond))
			msicond = MSICONDITION_ERROR;
		return msicond;
	}
#endif

	PMsiDatabase pDatabase = CMsiHandle::GetDatabase(hDatabase);
	if (pDatabase == 0)
		return MSICONDITION_ERROR; // ERROR_INVALID_HANDLE

	MsiString istrTableName(szTableName);
	itsEnum itsState = pDatabase->FindTable(*istrTableName);
	switch (itsState)
	{
	case itsUnknown:   return MSICONDITION_NONE; break;
	case itsTemporary: return	MSICONDITION_FALSE; break;
	case itsUnloaded:  // fall through
	case itsLoaded:    // fall through
	case itsOutput:    // fall through
	case itsSaveError: // fall through
	case itsTransform: return MSICONDITION_TRUE; break;
	default:           return MSICONDITION_ERROR; break;
	}
}

MSICONDITION WINAPI MsiDatabaseIsTablePersistentX(MSIHANDLE hDatabase,
	LPCXSTR szTableName)        // the name of the specific table
{
	if (szTableName == 0)
		return MSICONDITION_ERROR; // ERROR_INVALID_PARAMETER
	return MsiDatabaseIsTablePersistentI(hDatabase, CMsiConvertString(szTableName));
}

// --------------------------------------------------------------------------
// Installer database management functions - not used by custom actions
// --------------------------------------------------------------------------

// Obtain a handle to an installer database

UINT __stdcall MsiOpenDatabaseI(
	const ICHAR* szDatabasePath,    // path to database
	const ICHAR* szPersist,         // output DB or MSIDBOPEN_READONLY | ..TRANSACT | ..DIRECT
	MSIHANDLE    *phDatabase)       // location to return database handle
{
	// Note that it is valid to pass in an empty string to MsiOpenDatabase.
	if (szDatabasePath == 0)
		return ERROR_INVALID_PARAMETER;

	if (phDatabase == 0)
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG1(TEXT("Passing to service: MsiOpenDatabase(%s)"), szDatabasePath);
		return g_pCustomActionContext->OpenDatabase(szDatabasePath, szPersist, phDatabase);
	}
#endif

	*phDatabase = 0;

	// decode open mode
	idoEnum idoPersist;
	BOOL fOutputDatabase = FALSE;
	BOOL fCreate = FALSE;
	if (szPersist >= (const ICHAR*)(1<<16))  // assume to be an address if not a predefined value
	{
		idoPersist = idoReadOnly;
		fOutputDatabase = TRUE;
	}
	else  // enum and possible flags supplied
	{
		idoPersist = idoEnum(PtrToUint(szPersist));
		idoEnum idoOpenMode = idoEnum(idoPersist & ~idoOptionFlags);
		if (idoOpenMode >= idoNextEnum)
			return ERROR_INVALID_PARAMETER;
		if (idoOpenMode == idoCreate || idoOpenMode == idoCreateDirect)
			fCreate = TRUE;
	}
	
    if (!fCreate && (!szDatabasePath || !szDatabasePath[0]))
		return ERROR_INVALID_PARAMETER;
	
	// create handle to force services to be present
	CMsiHandle* pHandle = CreateEmptyHandle(iidMsiDatabase);
	if ( ! pHandle )
		return ERROR_OUTOFMEMORY;
	
	// open database
	IMsiDatabase* piDatabase;
	if (SetLastErrorRecord(pHandle->GetServices()->CreateDatabase(szDatabasePath, idoPersist, piDatabase)))
	{
		pHandle->Abandon();
		return fCreate ? ERROR_CREATE_FAILED : ERROR_OPEN_FAILED;  //!! need to check type of error
	}
	if (fOutputDatabase)
	{
		if (SetLastErrorRecord(piDatabase->CreateOutputDatabase(szPersist, fFalse)))
		{
			piDatabase->Release();
			pHandle->Abandon();
			return ERROR_CREATE_FAILED;  //!! need to check type of error?
		}
	}
	pHandle->SetObject(piDatabase);
	*phDatabase = pHandle->GetHandle();
	return ERROR_SUCCESS;
}

UINT __stdcall MsiOpenDatabaseX(
	LPCXSTR   szDatabasePath,    // path to database or launcher
	LPCXSTR   szPersist,         // output DB or MSIDBOPEN_READONLY | ..TRANSACT | ..DIRECT
	MSIHANDLE *phDatabase)       // location to return database handle
{
	if (szDatabasePath == 0)
		return ERROR_INVALID_PARAMETER;
	if (szPersist < (LPCXSTR)(1<<16))
		return MsiOpenDatabaseI(CMsiConvertString(szDatabasePath), (const ICHAR*)szPersist, phDatabase);
	else
		return MsiOpenDatabaseI(CMsiConvertString(szDatabasePath), CMsiConvertString(szPersist), phDatabase);
}

// Write out all persistent data, ignored if database opened read-only

UINT __stdcall MsiDatabaseCommit(MSIHANDLE hDatabase)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG1(TEXT("Passing to service: MsiDatabaseCommit(%d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hDatabase)));
		return g_pCustomActionContext->DatabaseCommit(hDatabase);
	}
#endif

	PMsiDatabase pDatabase = CMsiHandle::GetDatabase(hDatabase);
	if (pDatabase == 0)
		return ERROR_INVALID_HANDLE;
	int iError = SetLastErrorRecord(pDatabase->Commit());
	if (iError == 0)
		return ERROR_SUCCESS;
	return iError == idbgDbWrongState ? ERROR_INVALID_HANDLE_STATE : ERROR_FUNCTION_FAILED;
}

// Return the update state of a database

MSIDBSTATE __stdcall MsiGetDatabaseState(MSIHANDLE hDatabase)
{
	PMsiDatabase pDatabase = CMsiHandle::GetDatabase(hDatabase);
	if (pDatabase == 0)
		return MSIDBSTATE_ERROR;
	switch (pDatabase->GetUpdateState())
	{
	case idsRead:     return MSIDBSTATE_READ; 
	case idsWrite:    return MSIDBSTATE_WRITE;
	default:          return MSIDBSTATE_ERROR; //!!??
	}
}

// Import an MSI text archive table into an open database

UINT __stdcall MsiDatabaseImportI(MSIHANDLE hDatabase,
	const ICHAR* szFolderPath,     // folder containing archive files
	const ICHAR* szFileName)       // table archive file to be imported
{
	PMsiDatabase pDatabase = CMsiHandle::GetDatabase(hDatabase);
	if (pDatabase == 0)
		return ERROR_INVALID_HANDLE;
	if (szFileName == 0 || szFolderPath == 0 ||
		 FAILED(StringCchLength(szFolderPath, cchMaxPath+1, NULL)))
		return ERROR_INVALID_PARAMETER;
	PMsiPath pPath(0);
	if (SetLastErrorRecord(PMsiServices(&pDatabase->GetServices())->CreatePath(szFolderPath, *&pPath)))
		return ERROR_BAD_PATHNAME;
	if (SetLastErrorRecord(pDatabase->ImportTable(*pPath, szFileName)))
		return ERROR_FUNCTION_FAILED;
	return ERROR_SUCCESS;
}

UINT __stdcall MsiDatabaseImportX(MSIHANDLE hDatabase,
	LPCXSTR   szFolderPath,     // folder containing archive files
	LPCXSTR   szFileName)       // table archive file to be imported
{
	return MsiDatabaseImportI(hDatabase,
				CMsiConvertString(szFolderPath),
				CMsiConvertString(szFileName));
}

// Export an MSI table from an open database to a text archive file

UINT __stdcall MsiDatabaseExportI(MSIHANDLE hDatabase,
	const ICHAR* szTableName,      // name of table in database (case-sensitive)
	const ICHAR* szFolderPath,     // folder containing archive files
	const ICHAR* szFileName)       // name of exported table archive file
{
	PMsiDatabase pDatabase = CMsiHandle::GetDatabase(hDatabase);
	if (pDatabase == 0)
		return ERROR_INVALID_HANDLE;
	if (szTableName == 0 || szFileName == 0 || szFolderPath == 0 ||
		 FAILED(StringCchLength(szTableName, cchMaxTableName+1, NULL)) ||
		 FAILED(StringCchLength(szFolderPath, cchMaxPath+1, NULL)))
		return ERROR_INVALID_PARAMETER;
	PMsiPath pPath(0);
	if (SetLastErrorRecord(PMsiServices(&pDatabase->GetServices())->CreatePath(szFolderPath, *&pPath)))
		return ERROR_BAD_PATHNAME;
	if (SetLastErrorRecord(pDatabase->ExportTable(szTableName, *pPath, szFileName)))
		return ERROR_FUNCTION_FAILED;
	return ERROR_SUCCESS;
}

UINT __stdcall MsiDatabaseExportX(MSIHANDLE hDatabase,
	LPCXSTR   szTableName,      // name of table in database (case-sensitive)
	LPCXSTR   szFolderPath,     // folder containing archive files
	LPCXSTR   szFileName)       // name of exported table archive file
{
	return MsiDatabaseExportI(hDatabase,
				CMsiConvertString(szTableName),
				CMsiConvertString(szFolderPath),
				CMsiConvertString(szFileName));
}

// Merge two database together, allowing duplicate rows

UINT __stdcall MsiDatabaseMergeI(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseMerge,    // database to be merged into hDatabase
	const ICHAR* szTableName)       // name of non-persistent table to receive errors
{
	MsiString istrTableName(szTableName); 
	PMsiDatabase pDatabase = CMsiHandle::GetDatabase(hDatabase);
	if (pDatabase == 0)
		return ERROR_INVALID_HANDLE;
	PMsiDatabase pDatabaseMerge = CMsiHandle::GetDatabase(hDatabaseMerge);
	if (pDatabaseMerge == 0)
		return ERROR_INVALID_HANDLE;
	PMsiTable pTable(0);
	if (szTableName != 0 &&
		 SUCCEEDED(StringCchLength(szTableName, cchMaxTableName+1, NULL)))
	{
		if (SetLastErrorRecord(pDatabase->LoadTable(*istrTableName, 0, *&pTable))
		 && SetLastErrorRecord(pDatabase->CreateTable(*istrTableName, 0, *&pTable)))
			return ERROR_INVALID_TABLE; //!! correct error code, need new?
	}
	switch (SetLastErrorRecord(pDatabase->MergeDatabase(*pDatabaseMerge, pTable)))
	{
	case 0:
		return ERROR_SUCCESS;
	case idbgTransMergeDifferentKeyCount:
	case idbgTransMergeDifferentColTypes:
	case idbgTransMergeDifferentColNames:
		return ERROR_DATATYPE_MISMATCH;
	default:
		return ERROR_FUNCTION_FAILED;
	}
}

UINT __stdcall MsiDatabaseMergeX(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseMerge,    // database to be merged into hDatabase
	LPCXSTR   szTableName)       // name of non-persistent table to receive errors
{
	return MsiDatabaseMergeI(hDatabase, hDatabaseMerge, CMsiConvertString(szTableName));
}

// Generate a transform file of differences between two databases

UINT __stdcall MsiDatabaseGenerateTransformI(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseReference, // base database to reference changes
	const ICHAR* szTransformFile, // name of generated transform file
	int       /*iReserved1*/,     // unused
	int       /*iReserved2*/)     // unused
{
	PMsiDatabase pDatabase = CMsiHandle::GetDatabase(hDatabase);
	if (pDatabase == 0)
		return ERROR_INVALID_HANDLE;
	PMsiDatabase pDatabaseReference = CMsiHandle::GetDatabase(hDatabaseReference);
	if (pDatabaseReference == 0)
		return ERROR_INVALID_HANDLE;
	PMsiStorage pTransform(0);

	if (szTransformFile && *szTransformFile)
	{
		if (SetLastErrorRecord(PMsiServices(&pDatabase->GetServices())->CreateStorage(szTransformFile,
																	ismCreate, *&pTransform)))
			return ERROR_CREATE_FAILED;
	}

	int iError = SetLastErrorRecord(pDatabase->GenerateTransform(*pDatabaseReference, pTransform,
						 									0, 0));
	if (iError)
	{
		if (pTransform)
			AssertNonZero(pTransform->DeleteOnRelease(false));

		if (iError == idbgTransDatabasesAreSame)
			return ERROR_NO_DATA;
		else
			return ERROR_INSTALL_TRANSFORM_FAILURE;
	}
	return ERROR_SUCCESS;
}

UINT __stdcall MsiDatabaseGenerateTransformX(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseReference, // base database to reference changes
	LPCXSTR   szTransformFile,    // name of generated transform file
	int       iReserved1,         // unused
	int       iReserved2)         // unused
{
	return MsiDatabaseGenerateTransformI(hDatabase, hDatabaseReference,
							CMsiConvertString(szTransformFile), iReserved1, iReserved2);
}

// Apply a transform file containing database difference

UINT __stdcall MsiDatabaseApplyTransformI(MSIHANDLE hDatabase,
	const ICHAR* szTransformFile,    // name of transform file
	int       iErrorConditions)   // error conditions suppressed when transform applied
{
	// validate iErrorConditions - need to do this first
	if(iErrorConditions & ~iteAllBits)
		return ERROR_INVALID_PARAMETER;
	PMsiDatabase pDatabase = CMsiHandle::GetDatabase(hDatabase);
	if (pDatabase == 0)
		return ERROR_INVALID_HANDLE;
	if (szTransformFile == 0)
		return ERROR_INVALID_PARAMETER;
	PMsiStorage pTransform(0);
	if (*szTransformFile == STORAGE_TOKEN) // child storage
	{
		PMsiStorage pDbStorage = pDatabase->GetStorage(1);
		if (SetLastErrorRecord(pDbStorage->OpenStorage(szTransformFile+1, ismReadOnly, *&pTransform)))
			return ERROR_OPEN_FAILED;
	}
	else
	{
		if (SetLastErrorRecord(PMsiServices(&pDatabase->GetServices())->CreateStorage(szTransformFile,
																ismReadOnly, *&pTransform)))
			return ERROR_OPEN_FAILED;
	}
	if (SetLastErrorRecord(pDatabase->SetTransform(*pTransform, iErrorConditions)))
		return ERROR_INSTALL_TRANSFORM_FAILURE;
	return ERROR_SUCCESS;
}

UINT __stdcall MsiDatabaseApplyTransformX(MSIHANDLE hDatabase,
	LPCXSTR   szTransformFile,    // name of transform file
	int       iErrorConditions)   // existing row conditions treated as errors
{
	return MsiDatabaseApplyTransformI(hDatabase, CMsiConvertString(szTransformFile), iErrorConditions);
}

// Write validation properties to transform summary information stream

const ICHAR szPropertyTable[] = TEXT("Property");  // assumes 1st column is property name, 2nd is value

const IMsiString& GetProperty(IMsiCursor& riCursor, const IMsiString& ristrName)
{
	MsiString strPropValue;
	AssertNonZero(riCursor.PutString(1,ristrName));
	if(riCursor.Next())
		strPropValue = riCursor.GetString(2);
	riCursor.Reset();
	return strPropValue.Return();
}

const int iVersionOpBits = MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION         |
									MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION    |
									MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION        |
									MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION |
									MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION;

const int iVersionTypeBits =  MSITRANSFORM_VALIDATE_MAJORVERSION               |
										MSITRANSFORM_VALIDATE_MINORVERSION               |
										MSITRANSFORM_VALIDATE_UPDATEVERSION;
										
bool OnlyOneBitSet(int iBits)
{
	int iBit;
	
	do
	{
		iBit = iBits & 0x1;
		iBits >>= 1;
		if (iBit)
			break;
	}
	while (iBits);

	return (iBits == 0);
}

UINT __stdcall MsiCreateTransformSummaryInfoI(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseReference, // base database to reference changes
	const ICHAR* szTransformFile, // name of transform file
	int       iErrorConditions,   // error conditions suppressed when transform applied
	int       iValidation)        // properties to be validated when transform applied
{
	//!! REVIEW: setting last error when appropriate

	if((iErrorConditions != (iErrorConditions & 0xFFFF)) || (iValidation != (iValidation & 0xFFFF)))
		return ERROR_INVALID_PARAMETER;

	// ensure that at most one version op bit of each kind is set

	if (!OnlyOneBitSet(iValidation & iVersionOpBits) ||
		 !OnlyOneBitSet(iValidation & iVersionTypeBits))
		return ERROR_INVALID_PARAMETER;

	PMsiDatabase pOldDatabase(0), pNewDatabase(0);
	PMsiStorage pOldDbStorage(0), pNewDbStorage(0);
	PMsiSummaryInfo pOldDbSumInfo(0), pNewDbSumInfo(0), pTransSumInfo(0);
	PMsiTable pPropertyTable(0);
	PMsiCursor pPropertyCursor(0);
	MsiString strOldProductCode, strOldProductVersion, strNewProductCode, strNewProductVersion,
				 strOldUpgradeCode, strProperty;
	MsiDate idProperty = MsiDate(0);
	int iProperty = 0;

	// open transform summary info
	PMSIHANDLE hTransformSummaryInfo;
	UINT uiRes = MsiGetSummaryInformation(0,szTransformFile,21,&hTransformSummaryInfo);
	if(uiRes != ERROR_SUCCESS)
		return uiRes;
	pTransSumInfo = CMsiHandle::GetSummaryInfo(hTransformSummaryInfo);

	// open old database
	pOldDatabase = CMsiHandle::GetDatabase(hDatabaseReference);
	if(pOldDatabase == 0)
		return ERROR_INVALID_HANDLE;

	// load old database storage and summary information
	pOldDbStorage = pOldDatabase->GetStorage(1);
	if(!pOldDbStorage)
		return ERROR_INSTALL_PACKAGE_INVALID;
	if(SetLastErrorRecord(pOldDbStorage->CreateSummaryInfo(0,*&pOldDbSumInfo)))
		return ERROR_INSTALL_PACKAGE_INVALID;

	// load old property table
	bool fOldPropertyTable = pOldDatabase->GetTableState(szPropertyTable, itsTableExists);
	if (fOldPropertyTable)
	{
		if(SetLastErrorRecord(pOldDatabase->LoadTable(*MsiString(*szPropertyTable),0,*&pPropertyTable)))
			return ERROR_INSTALL_PACKAGE_INVALID;

		pPropertyCursor = pPropertyTable->CreateCursor(fFalse);
		pPropertyCursor->SetFilter(1);

		// get old product code, product version
		strOldProductCode = GetProperty(*pPropertyCursor,*MsiString(*IPROPNAME_PRODUCTCODE));
		if(strOldProductCode.TextSize() != cchGUID)
			return ERROR_INSTALL_PACKAGE_INVALID;

		strOldProductVersion = GetProperty(*pPropertyCursor,*MsiString(*IPROPNAME_PRODUCTVERSION));
		if(strOldProductVersion.TextSize() == 0)
			return ERROR_INSTALL_PACKAGE_INVALID;

		strOldUpgradeCode = GetProperty(*pPropertyCursor,*MsiString(*IPROPNAME_UPGRADECODE));
		if ((iValidation & MSITRANSFORM_VALIDATE_UPGRADECODE) && (strOldUpgradeCode.TextSize() == 0))
			return ERROR_INSTALL_PACKAGE_INVALID;
	}

	// open new database
	pNewDatabase = CMsiHandle::GetDatabase(hDatabase);
	if(pNewDatabase == 0)
		return ERROR_INVALID_HANDLE;

	// load new database storage and summary information
	pNewDbStorage = pNewDatabase->GetStorage(1);
	if(!pNewDbStorage)
		return ERROR_INSTALL_PACKAGE_INVALID;
	if(SetLastErrorRecord(pNewDbStorage->CreateSummaryInfo(0,*&pNewDbSumInfo)))
		return ERROR_INSTALL_PACKAGE_INVALID;
	
	// load new property table
	bool fNewPropertyTable = pNewDatabase->GetTableState(szPropertyTable, itsTableExists);
	if (fNewPropertyTable)
	{
		if(SetLastErrorRecord(pNewDatabase->LoadTable(*MsiString(*szPropertyTable),0,*&pPropertyTable)))
			return ERROR_INSTALL_PACKAGE_INVALID;

		pPropertyCursor = pPropertyTable->CreateCursor(fFalse);
		pPropertyCursor->SetFilter(1);

		// get new product code, product version
		strNewProductCode = GetProperty(*pPropertyCursor,*MsiString(*IPROPNAME_PRODUCTCODE));
		if(strNewProductCode.TextSize() != cchGUID)
			return ERROR_INSTALL_PACKAGE_INVALID;

		strNewProductVersion = GetProperty(*pPropertyCursor,*MsiString(*IPROPNAME_PRODUCTVERSION));
		if(strNewProductVersion.TextSize() == 0)
			return ERROR_INSTALL_PACKAGE_INVALID;
	}

	// minimum Darwin version to process transform is greater of minimum versions of the 2 dbs
	int iOldMinVer, iNewMinVer, iTransMinVer;
	if((pOldDbSumInfo->GetIntegerProperty(PID_PAGECOUNT, iOldMinVer) == fFalse) ||
		(pNewDbSumInfo->GetIntegerProperty(PID_PAGECOUNT, iNewMinVer) == fFalse))
	{
		iTransMinVer = (rmj*100)+rmm; // if either db is missing a version, just use current installer version (1.0 behaviour)
	}
	else
	{
		iTransMinVer = (iOldMinVer > iNewMinVer) ? iOldMinVer : iNewMinVer;
	}

	// fill in transform summary information
	if (pNewDbSumInfo->GetIntegerProperty(PID_CODEPAGE, iProperty))
		pTransSumInfo->SetIntegerProperty(PID_CODEPAGE, iProperty);

	strProperty = pNewDbSumInfo->GetStringProperty(PID_TITLE);
	pTransSumInfo->SetStringProperty(PID_TITLE, *strProperty);

	strProperty = pNewDbSumInfo->GetStringProperty(PID_SUBJECT);
	pTransSumInfo->SetStringProperty(PID_SUBJECT, *strProperty);

	strProperty = pNewDbSumInfo->GetStringProperty(PID_AUTHOR);
	pTransSumInfo->SetStringProperty(PID_AUTHOR, *strProperty);
	
	strProperty = pNewDbSumInfo->GetStringProperty(PID_KEYWORDS);
	pTransSumInfo->SetStringProperty(PID_KEYWORDS, *strProperty);
	
	strProperty = pNewDbSumInfo->GetStringProperty(PID_COMMENTS);
	pTransSumInfo->SetStringProperty(PID_COMMENTS, *strProperty);

	if (pNewDbSumInfo->GetTimeProperty(PID_CREATE_DTM, idProperty))
		pTransSumInfo->SetTimeProperty(PID_CREATE_DTM, idProperty);

	strProperty = pNewDbSumInfo->GetStringProperty(PID_APPNAME);
	pTransSumInfo->SetStringProperty(PID_APPNAME, *strProperty);

	if (pNewDbSumInfo->GetIntegerProperty(PID_SECURITY, iProperty))
		pTransSumInfo->SetIntegerProperty(PID_SECURITY, iProperty);

	// save base's PID_TEMPLATE in transform's PID_TEMPLATE
	strProperty = pOldDbSumInfo->GetStringProperty(PID_TEMPLATE);
	pTransSumInfo->SetStringProperty(PID_TEMPLATE, *strProperty);

	// save ref's PID_TEMPLATE in transform's LAST_AUTHOR
	strProperty = pNewDbSumInfo->GetStringProperty(PID_TEMPLATE);
	pTransSumInfo->SetStringProperty(PID_LASTAUTHOR, *strProperty);

	// for PID_REVNUMBER from old and new product codes, product versions
	if (fNewPropertyTable && fOldPropertyTable)
	{
		strProperty =  strOldProductCode;
		strProperty += strOldProductVersion;
		strProperty += MsiChar(ISUMMARY_DELIMITER);
		strProperty += strNewProductCode;
		strProperty += strNewProductVersion;
		if (strOldUpgradeCode.TextSize())
		{
			strProperty += MsiChar(ISUMMARY_DELIMITER);
			strProperty += strOldUpgradeCode;
		}
		pTransSumInfo->SetStringProperty(PID_REVNUMBER, *strProperty);
	}

	// minimum engine version to process this transform
	pTransSumInfo->SetIntegerProperty(PID_PAGECOUNT, iTransMinVer);

	// save validation and error codes	
	pTransSumInfo->SetIntegerProperty(PID_CHARCOUNT,  (iValidation << 16) + iErrorConditions);
	
	uiRes = MsiSummaryInfoPersist(hTransformSummaryInfo);
	return uiRes;
}

UINT __stdcall MsiCreateTransformSummaryInfoX(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseReference, // base database to reference changes
	LPCXSTR   szTransformFile,    // name of transform file
	int       iErrorConditions,   // error conditions suppressed when transform applied
	int       iValidation)        // properties to be validated when transform applied
{
	return MsiCreateTransformSummaryInfoI(hDatabase, hDatabaseReference,
							CMsiConvertString(szTransformFile), iErrorConditions, iValidation);
}

// --------------------------------------------------------------------------
// Record object functions
// --------------------------------------------------------------------------

// Create a new record object with the requested number of fields
// Field 0, not included in count, is used for format strings and op codes
// All fields are initialized to null

MSIHANDLE __stdcall MsiCreateRecord(unsigned int cParams) // the number of data fields
{
	if (cParams > MSIRECORD_MAXFIELDS)
		return 0;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG1(TEXT("Passing to service: MsiCreateRecord(%d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(cParams)));
		MSIHANDLE hRecord;
		if (ERROR_SUCCESS != g_pCustomActionContext->CreateRecord(cParams, &hRecord))
			hRecord = 0;
		return hRecord;
	}

#endif
	CMsiHandle* pHandle = CreateEmptyHandle(iidMsiRecord); // create handle to force services to be present
	if ( ! pHandle )
		return 0;
	pHandle->SetObject(&ENG::CreateRecord(cParams));
	return pHandle->GetHandle();
}

// Copy an integer into the designated field
// Returns FALSE if the field is greater than the record field count

// Reports whether a record field is NULL

BOOL __stdcall MsiRecordIsNull(MSIHANDLE hRecord,
	unsigned int iField)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(TEXT("Passing to service: MsiRecordIsNull(%d, %d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hRecord)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(iField)));
		boolean fIsNull;
		if (ERROR_SUCCESS != g_pCustomActionContext->RecordIsNull(hRecord, iField, &fIsNull))
			fIsNull = FALSE;

		return fIsNull;
	}
#endif

	PMsiRecord prec = CMsiHandle::GetRecord(hRecord);
	if (prec == 0)
		return FALSE;
	return prec->IsNull(iField);
}

// Return the length of a record field
// Returns 0 if field is NULL or non-existent or is internal object pointer
// Returns 0 if handle is not a valid record handle
// Returns sizeof(int) if integer data
// Returns character count if string data (not counting null terminator)
// Returns bytes count if stream data

unsigned int __stdcall MsiRecordDataSize(MSIHANDLE hRecord,
	unsigned int iField)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		unsigned int uiDataSize;
		if (ERROR_SUCCESS != g_pCustomActionContext->RecordDataSize(hRecord, iField, &uiDataSize))
			uiDataSize = 0;
		return uiDataSize;
	}
#endif

	PMsiRecord prec = CMsiHandle::GetRecord(hRecord);
	if (prec == 0)
		return 0;
	if (prec->IsNull(iField))
		return 0;
	if (prec->IsInteger(iField))
		return sizeof(int);
	PMsiData pData = prec->GetMsiData(iField);
	//Assert(pData != 0);
	IMsiString* pistr;
	if (pData->QueryInterface(IID_IMsiString, (void**)&pistr) == NOERROR)
	{
		unsigned int cch = pistr->TextSize();
		pistr->Release();
		return cch;
	}
	IMsiStream* piStream;
	if (pData->QueryInterface(IID_IMsiStream, (void**)&piStream) == NOERROR)
	{
		unsigned int cch = piStream->GetIntegerValue();
		piStream->Release();
		return cch;
	}
	return 0; // must be an object
}

// Set a record field to an integer value
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_FIELD

UINT __stdcall MsiRecordSetInteger(MSIHANDLE hRecord,
	unsigned int iField,
	int iValue)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3(TEXT("Passing to service: MsiRecordSetInteger(%d, %d, %d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hRecord)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(iField)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(iValue)));
		return g_pCustomActionContext->RecordSetInteger(hRecord, iField, iValue);
	}
#endif

	PMsiRecord prec = CMsiHandle::GetRecord(hRecord);
	if (prec == 0)
		return ERROR_INVALID_HANDLE;
	return (prec->SetInteger(iField, iValue) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER);
}

// Copy a string into the designated field
// A null string pointer and an empty string both set the field to null
// Returns FALSE if the field is greater than the record field count

UINT __stdcall MsiRecordSetStringA(MSIHANDLE hRecord,
	unsigned int iField,
	LPCSTR       szValue)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3("Passing to service: MsiRecordSetString(%d, %d, \"%s\")", reinterpret_cast<const char *>(static_cast<UINT_PTR>(hRecord)), reinterpret_cast<const char *>(static_cast<UINT_PTR>(iField)), szValue);
		return g_pCustomActionContext->RecordSetString(hRecord, iField, CMsiConvertString(szValue));
	}
#endif

	PMsiRecord prec = CMsiHandle::GetRecord(hRecord);
	if (prec == 0)
		return ERROR_INVALID_HANDLE;
	return prec->SetString(iField, CMsiConvertString(szValue)) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
}

UINT __stdcall MsiRecordSetStringW(MSIHANDLE hRecord,
	unsigned int iField,
	LPCWSTR      szValue)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3(L"Passing to service: MsiRecordSetString(%d, %d, \"%s\")", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(hRecord)), reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(iField)), szValue);
		return g_pCustomActionContext->RecordSetString(hRecord, iField, CMsiConvertString(szValue));
	}
#endif

	PMsiRecord prec = CMsiHandle::GetRecord(hRecord);
	if (prec == 0)
		return ERROR_INVALID_HANDLE;
	return prec->SetString(iField, CMsiConvertString(szValue)) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
}

// Return the integer value from a record field
// Returns the value MSI_NULL_INTEGER if the field is null
// or if the field is a string that cannot be converted to an integer

int __stdcall MsiRecordGetInteger(MSIHANDLE hRecord,
	unsigned int iField)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		int iValue;
		if (ERROR_SUCCESS != g_pCustomActionContext->RecordGetInteger(hRecord, iField, &iValue))
			iValue = 0;
		return iValue;
	}
#endif

	PMsiRecord prec = CMsiHandle::GetRecord(hRecord);
	if (prec == 0)
		return MSI_NULL_INTEGER;
	return prec->GetInteger(iField);
}

// Return the string value of a record field
// Integer fields will be converted to a string
// Null and non-existent fields will report a value of 0
// Fields containing stream data will return ERROR_INVALID_DATATYPE

UINT __stdcall MsiRecordGetStringA(MSIHANDLE hRecord,
	unsigned int iField,
	LPSTR   szValueBuf,       // buffer for returned value
	DWORD   *pcchValueBuf)    // in/out buffer character count
{
	if (pcchValueBuf == 0)
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2("Passing to service: MsiRecordGetString(%d, %d)", reinterpret_cast<const char *>(static_cast<UINT_PTR>(hRecord)), reinterpret_cast<const char *>(static_cast<UINT_PTR>(iField)));
		CAnsiToWideOutParam buf(szValueBuf, pcchValueBuf);
		HRESULT hRes = g_pCustomActionContext->RecordGetString(hRecord, iField, static_cast<WCHAR*>(buf), buf.BufferSize(), static_cast<DWORD *>(buf));
		return buf.FillReturnBuffer(hRes, szValueBuf, pcchValueBuf);
	}
#endif

	PMsiRecord prec = CMsiHandle::GetRecord(hRecord);
	if (prec == 0)
		return ERROR_INVALID_HANDLE;
	const IMsiString* pistr;
	IUnknown* piunk;
	PMsiData pData = prec->GetMsiData(iField);
	if (pData == 0)
		pistr = 0;
	else if (pData->QueryInterface(IID_IMsiStream, (void**)&piunk) == NOERROR)
	{
		piunk->Release();
		return (*pcchValueBuf = 0, ERROR_INVALID_DATATYPE);
	}
	else
		pistr = &(prec->GetMsiString(iField));
	UINT uiReturn = ::FillBufferA(pistr, szValueBuf, pcchValueBuf);
	if (pistr != 0)
		pistr->Release();

	return uiReturn;

	//return ::FillBufferA(MsiString(*pistr), szValueBuf, pcchValueBuf);
}

UINT __stdcall MsiRecordGetStringW(MSIHANDLE hRecord,
	unsigned int iField,
	LPWSTR  szValueBuf,       // buffer for returned value
	DWORD   *pcchValueBuf)    // in/out buffer character count
{
	if (pcchValueBuf == 0)
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(L"Passing to service: MsiRecordGetString(%d, %d)", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(hRecord)), reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(iField)));
		CWideOutParam buf(szValueBuf, pcchValueBuf);
		if ( ! (WCHAR *) buf )
			return ERROR_OUTOFMEMORY;
		HRESULT hRes = g_pCustomActionContext->RecordGetString(hRecord, iField, static_cast<WCHAR *>(buf), buf.BufferSize(), static_cast<DWORD *>(buf));
		return buf.FillReturnBuffer(hRes, szValueBuf, pcchValueBuf);
	}
#endif

	PMsiRecord prec = CMsiHandle::GetRecord(hRecord);
	if (prec == 0)
		return ERROR_INVALID_HANDLE;
	const IMsiString* pistr;
	IUnknown* piunk;
	PMsiData pData = prec->GetMsiData(iField);
	if (pData == 0)
		pistr = 0;
	else if (pData->QueryInterface(IID_IMsiStream, (void**)&piunk) == NOERROR)
	{
		piunk->Release();
		return (*pcchValueBuf = 0, ERROR_INVALID_DATATYPE);
	}
	else
		pistr = &(prec->GetMsiString(iField));
	
	UINT uiReturn = ::FillBufferW(pistr, szValueBuf, pcchValueBuf);
	if (pistr != 0)
		pistr->Release();

	return uiReturn;
	//return ::FillBufferW(MsiString(*pistr), szValueBuf, pcchValueBuf);
}

// Returns the number of fields allocated in the record
// Does not count field 0, used for formatting and op codes

unsigned int __stdcall MsiRecordGetFieldCount(MSIHANDLE hRecord)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG1(TEXT("Passing to service: MsiRecordGetFieldCount(%d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hRecord)));
		unsigned int uiGetFieldCount;
		if (ERROR_SUCCESS != g_pCustomActionContext->RecordGetFieldCount(hRecord, &uiGetFieldCount))
			uiGetFieldCount = -1;
		return uiGetFieldCount;
	}
#endif

	PMsiRecord prec = CMsiHandle::GetRecord(hRecord);
	if (prec == 0)
		return (unsigned int)(-1);
	return prec->GetFieldCount();
}

IMsiStream* CreateStreamOnMemory(const char* pbReadOnly, unsigned int cbSize);

// Set a record stream field from a file
// The contents of the specified file will be read into a stream object
// The stream will be persisted if the record is inserted into the database
// If a null file path is passed in, AND the record contains a stream, it will be reset

UINT __stdcall MsiRecordSetStreamI(MSIHANDLE hRecord,
	unsigned int iField,
	const ICHAR* szFilePath)    // path to file containing stream data
{
	if ( szFilePath &&
		  FAILED(StringCchLength(szFilePath, cchMaxPath+1, NULL)) )
		// szFilePath is too long
		return ERROR_INVALID_PARAMETER;
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		return g_pCustomActionContext->RecordSetStream(hRecord, iField, szFilePath);
	}
#endif

	PMsiRecord prec = CMsiHandle::GetRecord(hRecord);
	if (prec == 0)
		return ERROR_INVALID_HANDLE;
	if (iField == 0 || iField >  prec->GetFieldCount())
		return ERROR_INVALID_PARAMETER;
	if (szFilePath == 0)  // request to reset stream
	{
		PMsiData pData = prec->GetMsiData(iField);
		if (pData == 0)
			return ERROR_INVALID_DATA;
		PMsiStream pStream(0);
		if (pData->QueryInterface(IID_IMsiStream, (void**)&pStream) != NOERROR)
			return ERROR_INVALID_DATATYPE;
		pStream->Reset();
		return ERROR_SUCCESS;
	}
	PMsiStream pStream(0);
	if (*szFilePath == 0)  // null file path string, create empty stream object
		pStream = CreateStreamOnMemory((const char*)0, 0);
	else if (SetLastErrorRecord(ENG::CreateFileStream(szFilePath, fFalse, *&pStream)))
		return ERROR_BAD_PATHNAME;
	prec->SetMsiData(iField, pStream);  // can't fail, iField already validated
	return ERROR_SUCCESS;
}

UINT __stdcall MsiRecordSetStreamX(MSIHANDLE hRecord,
	unsigned int iField,
	LPCXSTR      szFilePath)    // path to file containing stream data
{
	return MsiRecordSetStreamI(hRecord, iField, CMsiConvertString(szFilePath));
}

// Read bytes from a record stream field into a buffer
// Must set the in/out argument to the requested byte count to read
// The number of bytes transferred is returned through the argument
// If no more bytes are available, ERROR_SUCCESS is still returned

UINT __stdcall MsiRecordReadStream(MSIHANDLE hRecord,
	unsigned int iField,
	char    *szDataBuf,     // buffer to receive bytes from stream
	DWORD   *pcbDataBuf)    // in/out buffer byte count
{
	if (pcbDataBuf == 0)
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3(TEXT("Passing to service: MsiRecordReadStream(%d, %d, %s)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hRecord)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(iField)), szDataBuf ? TEXT("<Buffer>") : TEXT("NULL"));

		// the docs say that this API supports szDataBuf being NULL to get the remaining
		// size of the buffer. To handle this when remote-ing, the interface has an extra
		// bool which, when true, tells the stub to not pass the real szDataBuf to the API.
		// it ain't pretty, but [unique] and [ptr] can't be used on [out] values in an interface
		// so to support this using native IDL marshalling, we would have change the buffer to 
		// [in, out], which marshalls both ways. This would kill performance and has its own
		// issues.
		if (szDataBuf)
		{
			return g_pCustomActionContext->RecordReadStream(hRecord, iField, false, szDataBuf, pcbDataBuf);
		}
		else
		{
			char rgchDummy[1] = "";
			DWORD cchDummy;
			UINT uiRes = g_pCustomActionContext->RecordReadStream(hRecord, iField, true, rgchDummy, &cchDummy);
			if (uiRes == ERROR_SUCCESS)
				*pcbDataBuf = cchDummy;
			return uiRes;
		}
	}
#endif

	PMsiRecord prec = CMsiHandle::GetRecord(hRecord);
	if (prec == 0)
		return ERROR_INVALID_HANDLE;
	PMsiData pData = prec->GetMsiData(iField);
	if (pData == 0)
		return (*pcbDataBuf = 0, ERROR_INVALID_DATA);
	PMsiStream pStream(0);
	if (pData->QueryInterface(IID_IMsiStream, (void**)&pStream) != NOERROR)
		return ERROR_INVALID_DATATYPE;
	*pcbDataBuf = szDataBuf == 0 ? pStream->Remaining()
										  : pStream->GetData(szDataBuf, *pcbDataBuf);
	return ERROR_SUCCESS;
}

// Clears all data fields in a record to NULL

UINT __stdcall MsiRecordClearData(MSIHANDLE hRecord)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		return g_pCustomActionContext->RecordClearData(hRecord);
	}
#endif

	PMsiRecord prec = CMsiHandle::GetRecord(hRecord);
	if (prec == 0)
		return ERROR_INVALID_HANDLE;
	prec->ClearData();
	return ERROR_SUCCESS;
}

MSIHANDLE __stdcall MsiGetLastErrorRecord()
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG(TEXT("Passing to service: MsiGetLastErrorRecord()"));
		MSIHANDLE hRecord;
		if (ERROR_SUCCESS != g_pCustomActionContext->GetLastErrorRecord(&hRecord))
			hRecord = 0;
		return hRecord;
	}
#endif

	if (g_pirecLastError == 0)
		return 0;

	MSIHANDLE hRecord = ::CreateMsiHandle(g_pirecLastError, iidMsiRecord);
	g_pirecLastError = 0;  // ref count transferred to handle
	return hRecord;
}

//____________________________________________________________________________
//
// Summary Information API Implementation
//____________________________________________________________________________

// Valid property types

const unsigned int iMaxSummaryPID = 19;
unsigned char rgVT[iMaxSummaryPID + 1] = {
/* PID_DICTIONARY    0 */  VT_EMPTY, /* not supported */
/* PID_CODEPAGE      1 */  VT_I4, /* VT_I2 as stored */
/* PID_TITLE         2 */  VT_LPSTR,
/* PID_SUBJECT       3 */  VT_LPSTR,
/* PID_AUTHOR        4 */  VT_LPSTR,
/* PID_KEYWORDS      5 */  VT_LPSTR,
/* PID_COMMENTS      6 */  VT_LPSTR,
/* PID_TEMPLATE      7 */  VT_LPSTR,
/* PID_LASTAUTHOR    8 */  VT_LPSTR,
/* PID_REVNUMBER     9 */  VT_LPSTR,
/* PID_EDITTIME     10 */  VT_FILETIME,
/* PID_LASTPRINTED  11 */  VT_FILETIME,
/* PID_CREATE_DTM   12 */  VT_FILETIME,
/* PID_LASTSAVE_DTM 13 */  VT_FILETIME,
/* PID_PAGECOUNT    14 */  VT_I4,
/* PID_WORDCOUNT    15 */  VT_I4,
/* PID_CHARCOUNT    16 */  VT_I4,
/* PID_THUMBNAIL    17 */  VT_EMPTY, /* VT_CF not supported */
/* PID_APPNAME      18 */  VT_LPSTR,
/* PID_SECURITY     19 */  VT_I4
};

// Obtain a handle for the _SummaryInformation stream for an MSI database     

UINT __stdcall MsiGetSummaryInformationI(MSIHANDLE hDatabase, // 0 if database not open
	const ICHAR* szDatabasePath,  // path to database, 0 if database handle supplied
	UINT      uiUpdateCount,   // maximium number of updated values, 0 to open read-only
	MSIHANDLE *phSummaryInfo)  // location to return summary information handle
{
	if (phSummaryInfo == 0)
		return ERROR_INVALID_PARAMETER;

	*phSummaryInfo = 0;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3(TEXT("Passing to service: MsiGetSummaryInformation(%d, \"%s\", %d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hDatabase)), szDatabasePath ? szDatabasePath : TEXT("NULL"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(uiUpdateCount)));
		return g_pCustomActionContext->GetSummaryInformation(hDatabase, szDatabasePath, uiUpdateCount, phSummaryInfo);
	}
#endif

	PMsiStorage pStorage(0);
	CMsiHandle* pHandle = CreateEmptyHandle(iidMsiSummaryInfo); // create handle to force services to be present
	if ( ! pHandle )
		return ERROR_OUTOFMEMORY;

	if (hDatabase == 0)
	{
		if (szDatabasePath == 0)
		{
			pHandle->Abandon();
			return ERROR_INVALID_PARAMETER;
		}
		if (SetLastErrorRecord(pHandle->GetServices()->CreateStorage(szDatabasePath,
										uiUpdateCount ? ismTransact : ismReadOnly, *&pStorage)))
		{
			pHandle->Abandon();
			return ERROR_INSTALL_PACKAGE_INVALID;  //!!, need to check type of error
		}
	}
	else
	{
		PMsiDatabase pDatabase = CMsiHandle::GetDatabase(hDatabase);
		if (pDatabase == 0)
		{
			pHandle->Abandon();
			return ERROR_INVALID_HANDLE;
		}
	 	pStorage = pDatabase->GetStorage(1);
		if (pStorage == 0)
		{
			pHandle->Abandon();
			IMsiTable* piTable;
			SetLastErrorRecord(pDatabase->LoadTable(*MsiString(*TEXT("\005SummaryInformation")),0,piTable)); // force error
			return ERROR_INSTALL_PACKAGE_INVALID;
		}
	}
	IMsiSummaryInfo* piSummaryInfo;
	if (SetLastErrorRecord(pStorage->CreateSummaryInfo(uiUpdateCount, piSummaryInfo)))
	{
		pHandle->Abandon();
		return ERROR_INSTALL_PACKAGE_INVALID;
	}
	pHandle->SetObject(piSummaryInfo);
	*phSummaryInfo = pHandle->GetHandle();
	return ERROR_SUCCESS;
}

UINT __stdcall MsiGetSummaryInformationX(MSIHANDLE hDatabase, // 0 if database not open
	LPCXSTR szDatabasePath,   // path to database, 0 if database handle supplied
	UINT    uiUpdateCount,    // maximium number of updated values, 0 to open read-only
	MSIHANDLE *phSummaryInfo) // location to return summary information handle
{
	return MsiGetSummaryInformationI(hDatabase, CMsiConvertString(szDatabasePath), uiUpdateCount, phSummaryInfo);
}

// Obtain the number of existing properties in the SummaryInformation stream

UINT __stdcall MsiSummaryInfoGetPropertyCount(MSIHANDLE hSummaryInfo,
	UINT *puiPropertyCount)  // pointer to location to return total property count
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG1(TEXT("Passing to service: MsiSummaryInfoGetPropertyCount(%d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hSummaryInfo)));
		return g_pCustomActionContext->SummaryInfoGetPropertyCount(hSummaryInfo, puiPropertyCount);
	}
#endif

	PMsiSummaryInfo pSummaryInfo = CMsiHandle::GetSummaryInfo(hSummaryInfo);
	if (pSummaryInfo == 0)
		return ERROR_INVALID_HANDLE;
	if (puiPropertyCount)
		*puiPropertyCount = pSummaryInfo->GetPropertyCount();
	return ERROR_SUCCESS;
}

// Set a single summary information property
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_UNKNOWN_PROPERTY

UINT __stdcall MsiSummaryInfoSetPropertyI(MSIHANDLE hSummaryInfo,
	UINT     uiProperty,     // property ID, one of allowed values for summary information
	UINT     uiDataType,     // VT_I4, VT_LPSTR, VT_FILETIME, or VT_EMPTY
	INT      iValue,         // integer value, used only if integer property
	FILETIME *pftValue,      // pointer to filetime value, used only if datetime property
	const ICHAR* szValue)        // text value, used only if string property
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3(TEXT("Passing to service: MsiSummaryInfoSetProperty(%d, %d, %d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hSummaryInfo)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(uiProperty)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(uiDataType)));
		return g_pCustomActionContext->SummaryInfoSetProperty(hSummaryInfo, uiProperty, uiDataType, iValue, pftValue, uiDataType == VT_LPSTR ? szValue : NULL);
	}
#endif

	PMsiSummaryInfo pSummaryInfo = CMsiHandle::GetSummaryInfo(hSummaryInfo);
	if (pSummaryInfo == 0)
		return ERROR_INVALID_HANDLE;
	if (uiProperty > iMaxSummaryPID)
		return ERROR_UNKNOWN_PROPERTY;
	unsigned int iVT = rgVT[uiProperty];
	if (uiDataType == VT_I2)
		uiDataType = VT_I4;
	if (uiDataType == VT_EMPTY)
		return pSummaryInfo->RemoveProperty(uiProperty) ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
	if (iVT != uiDataType)
		return ERROR_DATATYPE_MISMATCH;
	int iStat;
	switch (uiDataType)
	{
	case VT_I4:
		iStat = pSummaryInfo->SetIntegerProperty(uiProperty, iValue);
		break;
	case VT_LPSTR:
		if (!szValue)
			return ERROR_INVALID_PARAMETER;
		iStat = pSummaryInfo->SetStringProperty(uiProperty, *MsiString(szValue));
		break;
	case VT_FILETIME:
		if (!pftValue)
			return ERROR_INVALID_PARAMETER;
		iStat = pSummaryInfo->SetFileTimeProperty(uiProperty, *pftValue);
		break;
	default:  // VT_EMPTY in table
		return ERROR_UNSUPPORTED_TYPE;
	}
	return iStat ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
}

UINT __stdcall MsiSummaryInfoSetPropertyX(MSIHANDLE hSummaryInfo,
	UINT     uiProperty,     // property ID, one of allowed values for summary information
	UINT     uiDataType,     // VT_I4, VT_LPSTR, VT_FILETIME, or VT_EMPTY
	INT      iValue,         // integer value, used only if integer property
	FILETIME *pftValue,      // pointer to filetime value, used only if datetime property
	LPCXSTR  szValue)        // text value, used only if string property
{
	return MsiSummaryInfoSetPropertyI(hSummaryInfo, uiProperty, uiDataType, iValue,
												 pftValue, uiDataType == VT_LPSTR ? (const ICHAR*)CMsiConvertString(szValue) : (const ICHAR*)0);
}

// Get a single property from the summary information
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_UNKNOWN_PROPERTY

static UINT _SummaryInfoGetProperty(MSIHANDLE hSummaryInfo, UINT uiProperty,
	UINT *puiDataType, INT *piValue, FILETIME *pftValue, const IMsiString*& rpistrValue)
{
	PMsiSummaryInfo pSummaryInfo = CMsiHandle::GetSummaryInfo(hSummaryInfo);
	if (pSummaryInfo == 0)
		return ERROR_INVALID_HANDLE;
	if (uiProperty > iMaxSummaryPID)
		return ERROR_UNKNOWN_PROPERTY;

	unsigned int uiVT = uiProperty == PID_DICTIONARY
									  ? VT_EMPTY : pSummaryInfo->GetPropertyType(uiProperty);
	if (puiDataType)
		*puiDataType = uiVT;
	Bool fStat;
	switch (uiVT)
	{
	case VT_I2:
	case VT_I4:
		int iValue;
		if (!piValue)
			piValue = &iValue;
		fStat = pSummaryInfo->GetIntegerProperty(uiProperty, *piValue);
		break;
	case VT_FILETIME:
		FILETIME ft;
		if (!pftValue)
			pftValue = &ft;
		fStat = pSummaryInfo->GetFileTimeProperty(uiProperty, *pftValue);
		break;
	case VT_LPSTR:
		rpistrValue = &pSummaryInfo->GetStringProperty(uiProperty);
		return ERROR_MORE_DATA;
	case VT_EMPTY:
	case VT_CF:
		return ERROR_SUCCESS;
	default:
		return ERROR_UNSUPPORTED_TYPE;
	};
	return fStat ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
}

UINT __stdcall MsiSummaryInfoGetPropertyA(MSIHANDLE hSummaryInfo,
	UINT     uiProperty,     // property ID, one of allowed values for summary information
	UINT     *puiDataType,   // returned type: VT_I4, VT_LPSTR, VT_FILETIME, VT_EMPTY
	INT      *piValue,       // returned integer property data
	FILETIME *pftValue,      // returned datetime property data
	LPSTR    szValueBuf,     // buffer to return string property data
	DWORD    *pcchValueBuf)  // in/out buffer character count
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2("Passing to service: MsiSummaryInfoGetProperty(%d, %d)", reinterpret_cast<const char *>(static_cast<UINT_PTR>(hSummaryInfo)), reinterpret_cast<const char *>(static_cast<UINT_PTR>(uiProperty)));
		CAnsiToWideOutParam buf(szValueBuf, pcchValueBuf);

		// need some special handling here, because we could pass in NULL fo puiDataType,
		// which gives the marshalling code problems. Even if that problem is eventually
		// fixed, we need the type to determine if szValueBuf was written to on success. If
		// the property is some other type, the provided buffer shouldn't be touched because
		// its not a string return value
		UINT uiType;
		UINT iStat = g_pCustomActionContext->SummaryInfoGetProperty(hSummaryInfo, uiProperty, &uiType, piValue, pftValue, 
				static_cast<WCHAR *>(buf), buf.BufferSize(), static_cast<DWORD *>(buf));
		if (puiDataType) 
			*puiDataType = uiType;
		if (iStat == ERROR_SUCCESS && uiType != VT_LPSTR)
			return iStat;
		else
			return buf.FillReturnBuffer(iStat, szValueBuf, pcchValueBuf);
	}
#endif

	const IMsiString* pistrValue;
	UINT iStat = _SummaryInfoGetProperty(hSummaryInfo, uiProperty, puiDataType, piValue, pftValue, pistrValue);
	return iStat == ERROR_MORE_DATA ? ::FillBufferA(MsiString(*pistrValue), szValueBuf, pcchValueBuf) : iStat;
}

UINT __stdcall MsiSummaryInfoGetPropertyW(MSIHANDLE hSummaryInfo,
	UINT     uiProperty,     // property ID, one of allowed values for summary information
	UINT     *puiDataType,   // returned type: VT_I4, VT_LPSTR, VT_FILETIME, VT_EMPTY
	INT      *piValue,       // returned integer property data
	FILETIME *pftValue,      // returned datetime property data
	LPWSTR   szValueBuf,     // buffer to return string property data
	DWORD    *pcchValueBuf)  // in/out buffer character count
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(L"Passing to service: MsiSummaryInfoSetProperty(%d, %d)", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(hSummaryInfo)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(uiProperty)));
		CWideOutParam buf(szValueBuf, pcchValueBuf);
		if ( ! (WCHAR *) buf )
			return ERROR_OUTOFMEMORY;

		// need some special handling here, because we could pass in NULL fo puiDataType,
		// which gives the marshalling code problems. Even if that problem is eventually
		// fixed, we need the type to determine if szValueBuf was written to on success. If
		// the property is some other type, the provided buffer shouldn't be touched because
		// its not a string return value
		UINT uiType;
		UINT iStat = g_pCustomActionContext->SummaryInfoGetProperty(hSummaryInfo, uiProperty, &uiType, piValue, pftValue, 
			static_cast<WCHAR *>(buf), buf.BufferSize(), static_cast<DWORD *>(buf));
		if (puiDataType) 
			*puiDataType = uiType;
		if (iStat == ERROR_SUCCESS && uiType != VT_LPSTR)
		{
			// we must call this with failure to restore the users buffer which may have been
			// modified during marshalling and should not contain a valid value
			buf.FillReturnBuffer(ERROR_FUNCTION_FAILED, szValueBuf, pcchValueBuf);
			return iStat;
		}
		else
			return buf.FillReturnBuffer(iStat, szValueBuf, pcchValueBuf);
	}
#endif

	const IMsiString* pistrValue;
	UINT iStat = _SummaryInfoGetProperty(hSummaryInfo, uiProperty, puiDataType, piValue, pftValue, pistrValue);
	return iStat == ERROR_MORE_DATA ? ::FillBufferW(MsiString(*pistrValue), szValueBuf, pcchValueBuf) : iStat;
}

// Write back changed information to summary information stream

UINT __stdcall MsiSummaryInfoPersist(MSIHANDLE hSummaryInfo)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG1(TEXT("Passing to service: MsiSummaryInfoPersist(%d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hSummaryInfo)));
		return g_pCustomActionContext->SummaryInfoPersist(hSummaryInfo);
	}
#endif

	PMsiSummaryInfo pSummaryInfo = CMsiHandle::GetSummaryInfo(hSummaryInfo);
	if (pSummaryInfo == 0)
		return ERROR_INVALID_HANDLE;
	return pSummaryInfo->WritePropertyStream() ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
}

//____________________________________________________________________________
//
// Engine access API implementation
//____________________________________________________________________________

// Return a handle to the database currently in use by this installer instance

MSIHANDLE __stdcall MsiGetActiveDatabase(MSIHANDLE hInstall)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG1(TEXT("Passing to service: MsiGetActiveDatabase(%d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hInstall)));
		MSIHANDLE hDatabase;
		if (ERROR_SUCCESS != g_pCustomActionContext->GetActiveDatabase(hInstall, &hDatabase))
			hDatabase = 0;
		return hDatabase;
	}
#endif

	PMsiEngine pEngine = GetEngineFromHandle(hInstall);
	if (pEngine == 0)
		return 0;
	IMsiDatabase* piDatabase = pEngine->GetDatabase();
	return ::CreateMsiHandle(piDatabase, iidMsiDatabase);
}

// Get the value for an installer property
// If the property is not defined, it is equivalent to a 0-length value, not error
// Returns ERROR_SUCCESS, ERROR_MORE_DATA, ERROR_INVALID_HANDLE, ERROR_INVALID_PARAMETER

UINT  __stdcall MsiGetPropertyA(MSIHANDLE hInstall,
	LPCSTR  szName,            // property identifier, case-sensitive
	LPSTR   szValueBuf,        // buffer for returned property value
	DWORD   *pcchValueBuf)     // in/out buffer character count
{
	if (szName == 0)
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2("Passing to service: MsiGetPropertyA(%d, \"%s\")", reinterpret_cast<const char *>(static_cast<UINT_PTR>(hInstall)), szName ? szName : "NULL");
		CAnsiToWideOutParam buf(szValueBuf, pcchValueBuf);
		HRESULT hRes = g_pCustomActionContext->GetProperty(hInstall, CMsiConvertString(szName), buf, buf.BufferSize(), buf);
		return buf.FillReturnBuffer(hRes, szValueBuf, pcchValueBuf);
		
	}
#endif

	MsiString istr;
	PMsiEngine pEngine = GetEngineFromHandle(hInstall);
	
	if (pEngine == 0)
	{
		pEngine = GetEngineFromPreview(hInstall);
	}
	if (pEngine == 0)
	{
		CComPointer<CMsiCustomContext> pContext = CMsiHandle::GetCustomContext(hInstall);
		if (pContext == 0)
			return ERROR_INVALID_HANDLE;
		istr = pContext->GetProperty(CMsiConvertString(szName));
	}
	else
		istr = pEngine->SafeGetProperty(*CMsiConvertString(szName));

	return ::FillBufferA(istr, szValueBuf, pcchValueBuf);
}

UINT  __stdcall MsiGetPropertyW(MSIHANDLE hInstall,
	LPCWSTR szName,            // property identifier, case-sensitive
	LPWSTR  szValueBuf,        // buffer for returned property value
	DWORD   *pcchValueBuf)     // in/out buffer character count
{
	if (szName == 0)
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(L"Passing to service: MsiGetPropertyW(%d, \"%s\")", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(hInstall)), szName ? szName : L"NULL");
		CWideOutParam buf(szValueBuf, pcchValueBuf);
		if ( ! (WCHAR *) buf )
			return ERROR_OUTOFMEMORY;
		HRESULT hRes = g_pCustomActionContext->GetProperty(hInstall, szName, static_cast<WCHAR *>(buf), buf.BufferSize(), static_cast<DWORD *>(buf));
		return buf.FillReturnBuffer(hRes, szValueBuf, pcchValueBuf);
	}
#endif

	MsiString istr;
	
	PMsiEngine pEngine = GetEngineFromHandle(hInstall);

	if (pEngine == 0)
	{
		pEngine = GetEngineFromPreview(hInstall);
	}
	if (pEngine == 0)
	{
		CComPointer<CMsiCustomContext> pContext = CMsiHandle::GetCustomContext(hInstall);
		if (pContext == 0)
			return ERROR_INVALID_HANDLE;
		istr = pContext->GetProperty(CMsiConvertString(szName));
	}
	else
		istr = pEngine->SafeGetProperty(*CMsiConvertString(szName));
	
	return ::FillBufferW(istr, szValueBuf, pcchValueBuf);
}

// Set the value for an installer property
// If the property is not defined, it will be created
// If the value is null or an empty string, the property will be removed
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_PARAMETER, ERROR_FUNCTION_FAILED

UINT __stdcall MsiSetPropertyA(MSIHANDLE hInstall,
	LPCSTR    szName,       // property identifier, case-sensitive
	LPCSTR    szValue)      // property value, null to undefine property
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3("Passing to service: MsiSetPropertyA(%d, \"%s\", \"%s\")", reinterpret_cast<const char *>(static_cast<UINT_PTR>(hInstall)), szName ? szName : "NULL", szValue ? szValue : "NULL");
		return g_pCustomActionContext->SetProperty(hInstall, CMsiConvertString(szName), CMsiConvertString(szValue));
	}
#endif

	PMsiEngine pEngine = GetEngineFromHandle(hInstall);
	if (pEngine == 0)
	{
		pEngine = GetEngineFromPreview(hInstall);
		if (pEngine == 0)
			return ERROR_INVALID_HANDLE;
	}
	if (szName == 0)
		return ERROR_INVALID_PARAMETER;
	return pEngine->SafeSetProperty(*CMsiConvertString(szName), *CMsiConvertString(szValue))
										? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
}

UINT __stdcall MsiSetPropertyW(MSIHANDLE hInstall,
	LPCWSTR   szName,       // property identifier, case-sensitive
	LPCWSTR   szValue)      // property value, null to undefine property
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3(L"Passing to service: MsiSetPropertyW(%d, \"%s\", \"%s\")", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(hInstall)), szName ? szName : L"NULL", szValue ? szValue : L"NULL");
		return g_pCustomActionContext->SetProperty(hInstall, szName, szValue);
	}
#endif

	PMsiEngine pEngine = GetEngineFromHandle(hInstall);
	if (pEngine == 0)
	{
		pEngine = GetEngineFromPreview(hInstall);
		if (pEngine == 0)
			return ERROR_INVALID_HANDLE;
	}
	if (szName == 0)
		return ERROR_INVALID_PARAMETER;
	return pEngine->SafeSetProperty(*CMsiConvertString(szName),
										 *CMsiConvertString(szValue))
										? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
}

// Return the numeric language for the currently running install
// Returns 0 if an install not running

LANGID __stdcall MsiGetLanguage(MSIHANDLE hInstall)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		LANGID langid;
		if (ERROR_SUCCESS != g_pCustomActionContext->GetLanguage(hInstall, &langid))
			langid = 0;
		return langid;
	}
#endif

	PMsiEngine pEngine = GetEngineFromHandle(hInstall);
	if (pEngine == 0)
	{
		CComPointer<CMsiCustomContext> pContext = CMsiHandle::GetCustomContext(hInstall);
		if (pContext == 0)
			return ERROR_INVALID_HANDLE;
		return pContext->GetLanguage();
	}
	return pEngine->GetLanguage();
}

// Return one of the boolean internal installer states
// Returns FALSE if the handle is not active or if the mode is unknown

const int cModeBits = 16 + 3;  // standard flags + custom action context modes
const int iSettableModes = iefReboot + iefRebootNow;
static unsigned short rgiModeMap[cModeBits] = 
{
/* MSIRUNMODE_ADMIN           =  0 */ iefAdmin,
/* MSIRUNMODE_ADVERTISE       =  1 */ iefAdvertise,
/* MSIRUNMODE_MAINTENANCE     =  2 */ iefMaintenance,
/* MSIRUNMODE_ROLLBACKENABLED =  3 */ iefRollbackEnabled,
/* MSIRUNMODE_LOGENABLED      =  4 */ iefLogEnabled,
/* MSIRUNMODE_OPERATIONS      =  5 */ iefOperations,
/* MSIRUNMODE_REBOOTATEND     =  6 */ iefReboot,
/* MSIRUNMODE_REBOOTNOW       =  7 */ iefRebootNow,
/* MSIRUNMODE_CABINET         =  8 */ iefCabinet,
/* MSIRUNMODE_SOURCESHORTNAMES=  9 */ iefNoSourceLFN,
/* MSIRUNMODE_TARGETSHORTNAMES= 10 */ iefSuppressLFN,
/* MSIRUNMODE_RESERVED11      = 11 */ 0,
/* MSIRUNMODE_WINDOWS9X       = 12 */ iefWindows,
/* MSIRUNMODE_ZAWENABLED      = 13 */ iefGPTSupport,
/* MSIRUNMODE_RESERVED14      = 14 */ 0,
/* MSIRUNMODE_RESERVED15      = 15 */ 0,
/* MSIRUNMODE_SCHEDULED       = 16 */ 0, // set by CMsiCustomContext object
/* MSIRUNMODE_ROLLBACK        = 17 */ 0, // set by CMsiCustomContext object
/* MSIRUNMODE_COMMIT          = 18 */ 0, // set by CMsiCustomContext object
};

BOOL __stdcall MsiGetMode(MSIHANDLE hInstall, MSIRUNMODE eRunMode) 
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(TEXT("Passing to service: MsiGetMode(%d, %d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hInstall)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(eRunMode)));
		boolean fMode;
		if (ERROR_SUCCESS != g_pCustomActionContext->GetMode(hInstall, eRunMode, &fMode))
			fMode = FALSE;
		return fMode;
	}
#endif

	PMsiEngine pEngine = GetEngineFromHandle(hInstall);
	if (pEngine == 0)
	{
		CComPointer<CMsiCustomContext> pContext = CMsiHandle::GetCustomContext(hInstall);
		if (pContext == 0)
			return FALSE;
		return pContext->GetMode(eRunMode);
	}
	if ((unsigned)eRunMode >= cModeBits)
		return FALSE;
	return (pEngine->GetMode() & rgiModeMap[eRunMode]) == 0 ? FALSE : TRUE;
}

// Set an internal engine boolean state
// Returns ERROR_SUCCESS if the mode can be set to the desired state
// Returns ERROR_ACCESS_DENIED if the mode is not settable
// Returns ERROR_INVALID_HANDLE if the handle is not an active install session

UINT __stdcall MsiSetMode(MSIHANDLE hInstall, MSIRUNMODE eRunMode, BOOL fState)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3(TEXT("Passing to service: MsiSetMode(%d, %d, %d"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hInstall)),
			reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(eRunMode)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(fState)));
		return g_pCustomActionContext->SetMode(hInstall, eRunMode, (boolean)fState);
	}
#endif

	PMsiEngine pEngine = GetEngineFromHandle(hInstall);
	if (pEngine == 0)
		return ERROR_INVALID_HANDLE;
	unsigned int iMode = (unsigned)eRunMode < cModeBits ? rgiModeMap[eRunMode] : 0;
	if ((iMode & iSettableModes) == 0)
		return ERROR_ACCESS_DENIED;
	pEngine->SetMode(iMode, fState ? fTrue : fFalse);
		return ERROR_SUCCESS;
}

// Format record data using a format string containing field markers and/or properties
// Record field 0 must contain the format string
// Other fields must contain data that may be referenced by the format string.

static UINT _FormatRecord(MSIHANDLE hInstall, MSIHANDLE hRecord, const IMsiString*& rpistrValue)
{
	PMsiRecord prec = CMsiHandle::GetRecord(hRecord);
	if (prec == 0)
		return ERROR_INVALID_HANDLE;
	if (prec->IsInteger(0))
		return ERROR_INVALID_PARAMETER;
	MsiString istr = prec->FormatText(fFalse);
	if (hInstall == 0)   // no engine, simple format record data
		istr.ReturnArg(rpistrValue);
	else
	{
		PMsiEngine pEngine = GetEngineFromHandle(hInstall);
		if (pEngine == 0)
			return ERROR_INVALID_HANDLE;
		rpistrValue = &pEngine->FormatText(*istr);  //!! can we check for syntax errors?
	}
	return ERROR_SUCCESS;
}

UINT __stdcall MsiFormatRecordA(MSIHANDLE hInstall,
	MSIHANDLE hRecord,       // handle to record, field 0 contains format string
	LPSTR    szResultBuf,     // buffer to return formatted string
	DWORD    *pcchResultBuf)  // in/out buffer character count
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(TEXT("Passing to service: MsiFormatRecordA(%d, %d))"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hInstall)),
			reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hRecord)));
		CAnsiToWideOutParam buf(szResultBuf, pcchResultBuf);
		HRESULT hRes = g_pCustomActionContext->FormatRecord(hInstall, hRecord, buf, buf.BufferSize(), buf);
		return buf.FillReturnBuffer(hRes, szResultBuf, pcchResultBuf);
	}
#endif

	const IMsiString* pistrValue;
	UINT iStat = _FormatRecord(hInstall, hRecord, pistrValue);
	return iStat == ERROR_SUCCESS ? ::FillBufferA(MsiString(*pistrValue), szResultBuf, pcchResultBuf) : iStat;
}	

UINT __stdcall MsiFormatRecordW(MSIHANDLE hInstall,
	MSIHANDLE hRecord,       // handle to record, field 0 contains format string
	LPWSTR    szResultBuf,   // buffer to return formatted string
	DWORD    *pcchResultBuf) // in/out buffer character count
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(TEXT("Passing to service: MsiFormatRecordW(%d, %d))"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hInstall)),
			reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hRecord)));
		CWideOutParam buf(szResultBuf, pcchResultBuf);
		if ( ! (WCHAR *) buf )
			return ERROR_OUTOFMEMORY;
		HRESULT hRes = g_pCustomActionContext->FormatRecord(hInstall, hRecord, static_cast<WCHAR *>(buf), buf.BufferSize(), static_cast<DWORD *>(buf));
		return buf.FillReturnBuffer(hRes, szResultBuf, pcchResultBuf);
	}
#endif

	const IMsiString* pistrValue;
	UINT iStat = _FormatRecord(hInstall, hRecord, pistrValue);
	return iStat == ERROR_SUCCESS ? ::FillBufferW(MsiString(*pistrValue), szResultBuf, pcchResultBuf) : iStat;
}	

// Execute another action, either built-in, custom, or UI wizard

UINT __stdcall MsiDoActionI(MSIHANDLE hInstall,
	const ICHAR* szAction)
{
	if (szAction == 0)
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(TEXT("Passing to service: MsiDoAction(%d, \"%s\"))"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hInstall)), szAction ? szAction : TEXT("NULL"));
		return g_pCustomActionContext->DoAction(hInstall, szAction);
	}
#endif

	PMsiEngine pEngine = GetEngineFromHandle(hInstall);
	if (pEngine == 0)
		return ERROR_INVALID_HANDLE;
	return MapActionReturnToError(pEngine->DoAction(szAction), hInstall);
}

UINT __stdcall MsiDoActionX(MSIHANDLE hInstall,
	LPCXSTR  szAction)
{
	return MsiDoActionI(hInstall, CMsiConvertString(szAction));
}

// Execute another action sequence, as descibed in the specified table

UINT __stdcall MsiSequenceI(MSIHANDLE hInstall,
	const ICHAR* szTable,        // name of table containing action sequence
	INT iSequenceMode)      // processing option
{
	if (szTable == 0 ||
		 FAILED(StringCchLength(szTable, cchMaxTableName+1, NULL)))
		return ERROR_INVALID_PARAMETER;
	if (iSequenceMode != 0)  //!! need to implement MSISEQUENCEMODE_INITIALIZE/RESUME
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3(TEXT("Passing to service: MsiSequence(%d, \"%s\", %d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hInstall)),
			szTable ? szTable : TEXT("NULL"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(iSequenceMode)));
		return g_pCustomActionContext->Sequence(hInstall, szTable, iSequenceMode);
	}
#endif

	PMsiEngine pEngine = GetEngineFromHandle(hInstall);
	if (pEngine == 0)
		return ERROR_INVALID_HANDLE;
	return MapActionReturnToError(pEngine->Sequence(szTable), hInstall);
}

UINT __stdcall MsiSequenceX(MSIHANDLE hInstall,
	LPCXSTR  szTable,       // name of table containing action sequence
	INT iSequenceMode)      // processing option
{
	return MsiSequenceI(hInstall, CMsiConvertString(szTable), iSequenceMode);
}

// Send an error record to the installer for processing.
// If field 0 (template) is not set, field 1 must be set to the error code,
//   corresponding the the error message in the Error database table,
//   and the message will be formatted using the template from the Error table
//   before passing it to the UI handler for display.
// Returns Win32 button codes: IDOK IDCANCEL IDABORT IDRETRY IDIGNORE IDYES IDNO
//   or 0 if no action taken, or -1 if invalid argument or handle

int __stdcall MsiProcessMessage(MSIHANDLE hInstall,
	INSTALLMESSAGE eMessageType,// type of message
	MSIHANDLE hRecord)          // record containing message format and data
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3(TEXT("Passing to service: MsiProcessMessage(%d, %d, %d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hInstall)), 
			reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(eMessageType)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hRecord)));

		int iRes;
		if (ERROR_SUCCESS != g_pCustomActionContext->ProcessMessage(hInstall, eMessageType, hRecord, &iRes))
			iRes = -1;
		return iRes;
	}
#endif

	PMsiEngine pEngine = GetEngineFromHandle(hInstall);
	PMsiRecord prec = CMsiHandle::GetRecord(hRecord);
	// INSTALLMESSAGES up to PROGRESS, and COMMONDATA messages that show/hide the Cancel button are allowed
	if (prec == 0 || (unsigned)eMessageType > INSTALLMESSAGE_COMMONDATA ||
		(((unsigned)eMessageType == INSTALLMESSAGE_COMMONDATA) && (prec->GetInteger(1) != icmtCancelShow)))
		return -1;
	if (pEngine == 0)
	{
		CComPointer<CMsiCustomContext> pContext = CMsiHandle::GetCustomContext(hInstall);
		if (pContext == 0)
			return -1;
		return pContext->Message((imtEnum)eMessageType, *prec);
	}
	return pEngine->Message((imtEnum)eMessageType, *prec);
}

// Evaluate a conditional expression containing property names and values

MSICONDITION __stdcall MsiEvaluateConditionI(MSIHANDLE hInstall,
	const ICHAR* szCondition)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(TEXT("Passing to service: MsiEvaluateCondition(%d, \"%s\")"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hInstall)), szCondition ? szCondition : TEXT("NULL"));
		MSICONDITION msicond;
		if (ERROR_SUCCESS != g_pCustomActionContext->EvaluateCondition(hInstall, szCondition, (int*)&msicond))
			msicond = MSICONDITION_ERROR;
		return msicond;
	}
#endif

	PMsiEngine pEngine = GetEngineFromHandle(hInstall);
	if (pEngine == 0)
		return MSICONDITION_ERROR;
	return (MSICONDITION)pEngine->EvaluateCondition(szCondition);
}

MSICONDITION __stdcall MsiEvaluateConditionX(MSIHANDLE hInstall,
	LPCXSTR   szCondition)
{
	return MsiEvaluateConditionI(hInstall, CMsiConvertString(szCondition));
}

//____________________________________________________________________________
//
// Directory manager API implementation
//____________________________________________________________________________

// Return the full source path for a folder in the Directory table

UINT __stdcall MsiGetSourcePathA(MSIHANDLE hInstall,
	LPCSTR      szFolder,       // folder identifier, primary key into Directory table
	LPSTR       szPathBuf,      // buffer to return full path
	DWORD       *pcchPathBuf)   // in/out buffer character count
{
	if (szFolder == 0)
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2("Passing to service: MsiGetSourcePathA(%d, \"%s\")", reinterpret_cast<const char *>(static_cast<UINT_PTR>(hInstall)), szFolder);
		CAnsiToWideOutParam buf(szPathBuf, pcchPathBuf);
		HRESULT hRes = g_pCustomActionContext->GetSourcePath(hInstall, CMsiConvertString(szFolder), buf, buf.BufferSize(), buf);
		return buf.FillReturnBuffer(hRes, szPathBuf, pcchPathBuf);
	}
#endif

	PMsiDirectoryManager pDirMgr = CMsiHandle::GetDirectoryManager(hInstall);
	if (pDirMgr == 0)
		return ERROR_INVALID_HANDLE;
	PMsiPath pPath(0);
	if (SetLastErrorRecord(pDirMgr->GetSourcePath(*CMsiConvertString(szFolder), *&pPath)))
		return ERROR_DIRECTORY;

	return ::FillBufferA(MsiString(pPath->GetPath()), szPathBuf, pcchPathBuf);
}

UINT __stdcall MsiGetSourcePathW(MSIHANDLE hInstall,
	LPCWSTR     szFolder,       // folder identifier, primary key into Directory table
	LPWSTR      szPathBuf,      // buffer to return full path
	DWORD       *pcchPathBuf)   // in/out buffer character count
{
	if (szFolder == 0)
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(L"Passing to service: MsiGetSourcePathW(%d, \"%s\")", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(hInstall)), szFolder);
		CWideOutParam buf(szPathBuf, pcchPathBuf);
		if ( ! (WCHAR *) buf )
			return ERROR_OUTOFMEMORY;
		HRESULT hRes = g_pCustomActionContext->GetSourcePath(hInstall, szFolder, static_cast<WCHAR *>(buf), buf.BufferSize(), static_cast<DWORD *>(buf));
		return buf.FillReturnBuffer(hRes, szPathBuf, pcchPathBuf);
	}
#endif

	PMsiDirectoryManager pDirMgr = CMsiHandle::GetDirectoryManager(hInstall);
	if (pDirMgr == 0)
		return ERROR_INVALID_HANDLE;
	PMsiPath pPath(0);
	if (SetLastErrorRecord(pDirMgr->GetSourcePath(*CMsiConvertString(szFolder), *&pPath)))
		return ERROR_DIRECTORY;
	return ::FillBufferW(MsiString(pPath->GetPath()), szPathBuf, pcchPathBuf);
}

// Return the full target path for a folder in the Directory table

UINT __stdcall MsiGetTargetPathA(MSIHANDLE hInstall,
	LPCSTR      szFolder,       // folder identifier, primary key into Directory table
	LPSTR       szPathBuf,      // buffer to return full path
	DWORD       *pcchPathBuf)   // in/out buffer character count
{
	if (szFolder == 0)
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2("Passing to service: MsiGetTargetPathA(%d, \"%s\")", reinterpret_cast<const char *>(static_cast<UINT_PTR>(hInstall)), szFolder);
		CAnsiToWideOutParam buf(szPathBuf, pcchPathBuf);
		HRESULT hRes = g_pCustomActionContext->GetTargetPath(hInstall, CMsiConvertString(szFolder), buf, buf.BufferSize(), buf);
		return buf.FillReturnBuffer(hRes, szPathBuf, pcchPathBuf);
	}
#endif

	PMsiDirectoryManager pDirMgr = CMsiHandle::GetDirectoryManager(hInstall);
	if (pDirMgr == 0)
		return ERROR_INVALID_HANDLE;
	PMsiPath pPath(0);
	if (SetLastErrorRecord(pDirMgr->GetTargetPath(*CMsiConvertString(szFolder), *&pPath)))
		return ERROR_DIRECTORY;
	return ::FillBufferA(MsiString(pPath->GetPath()), szPathBuf, pcchPathBuf);
}

UINT __stdcall MsiGetTargetPathW(MSIHANDLE hInstall,
	LPCWSTR     szFolder,       // folder identifier, primary key into Directory table
	LPWSTR      szPathBuf,      // buffer to return full path
	DWORD       *pcchPathBuf)   // in/out buffer character count
{
	if (szFolder == 0)
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(L"Passing to service: MsiGetTargetPathW(%d, \"%s\")", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(hInstall)), szFolder);
		CWideOutParam buf(szPathBuf, pcchPathBuf);
		if ( ! (WCHAR *) buf )
			return ERROR_OUTOFMEMORY;
		HRESULT hRes = g_pCustomActionContext->GetTargetPath(hInstall, szFolder, static_cast<WCHAR *>(buf), buf.BufferSize(), static_cast<DWORD *>(buf));
		return buf.FillReturnBuffer(hRes, szPathBuf, pcchPathBuf);
	}
#endif

	PMsiDirectoryManager pDirMgr = CMsiHandle::GetDirectoryManager(hInstall);
	if (pDirMgr == 0)
		return ERROR_INVALID_HANDLE;
	PMsiPath pPath(0);
	if (SetLastErrorRecord(pDirMgr->GetTargetPath(*CMsiConvertString(szFolder), *&pPath)))
		return ERROR_DIRECTORY;
	return ::FillBufferW(MsiString(pPath->GetPath()), szPathBuf, pcchPathBuf);
}

// Set the full target path for a folder in the Directory table

UINT __stdcall MsiSetTargetPathA(MSIHANDLE hInstall,
	LPCSTR      szFolder,       // folder identifier, primary key into Directory table
	LPCSTR      szFolderPath)   // full path for folder, ending in directory separator
{
	if (szFolder == 0 || szFolderPath == 0 ||
		 FAILED(StringCchLengthA(szFolderPath, cchMaxPath+1, NULL)))
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3("Passing to service: MsiSetTargetPathA(%d, \"%s\")", reinterpret_cast<const char *>(static_cast<UINT_PTR>(hInstall)), szFolder, szFolderPath);
		return g_pCustomActionContext->SetTargetPath(hInstall, CMsiConvertString(szFolder), CMsiConvertString(szFolderPath));
	}
#endif

	PMsiDirectoryManager pDirMgr = CMsiHandle::GetDirectoryManager(hInstall);
	if (pDirMgr == 0)
		return ERROR_INVALID_HANDLE;
	if (SetLastErrorRecord(pDirMgr->SetTargetPath(*CMsiConvertString(szFolder), CMsiConvertString(szFolderPath), fTrue)))
		return ERROR_DIRECTORY;
	return ERROR_SUCCESS;
}

UINT __stdcall MsiSetTargetPathW(MSIHANDLE hInstall,
	LPCWSTR     szFolder,       // folder identifier, primary key into Directory table
	LPCWSTR     szFolderPath)   // full path for folder, ending in directory separator
{
	if (szFolder == 0 || szFolderPath == 0 ||
		 FAILED(StringCchLengthW(szFolderPath, cchMaxPath+1, NULL)))
		return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3(L"Passing to service: MsiSetTargetPathW(%d, \"%s\")", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(hInstall)), szFolder, szFolderPath);
		return g_pCustomActionContext->SetTargetPath(hInstall, szFolder, szFolderPath);
	}
#endif
	
	PMsiDirectoryManager pDirMgr = CMsiHandle::GetDirectoryManager(hInstall);
	if (pDirMgr == 0)
		return ERROR_INVALID_HANDLE;
	if (SetLastErrorRecord(pDirMgr->SetTargetPath(*CMsiConvertString(szFolder), CMsiConvertString(szFolderPath), fTrue)))
		return ERROR_DIRECTORY;
	return ERROR_SUCCESS;
}

//____________________________________________________________________________
//
// Selection manager API implementation
//____________________________________________________________________________

INSTALLSTATE MapInternalInstallState(iisEnum iis)
{
	switch (iis)
	{
	case iisAdvertise:      return INSTALLSTATE_ADVERTISED; // features only
	case iisHKCRFileAbsent: return INSTALLSTATE_REMOVED;    // components only
	case iisFileAbsent:     return INSTALLSTATE_REMOVED;    // components only
	case iisAbsent:         return INSTALLSTATE_ABSENT;
	case iisLocal:          return INSTALLSTATE_LOCAL;
	case iisSource:         return INSTALLSTATE_SOURCE;
	case iisReinstall:      return INSTALLSTATE_DEFAULT;    //!! need to examine installed state
	case iisCurrent:        return INSTALLSTATE_DEFAULT;
	case iisHKCRAbsent:     // return should be same as iMsinullInteger
	default:                return INSTALLSTATE_UNKNOWN;
	}
}

// Get the requested state of a feature

static UINT _GetFeatureState(MSIHANDLE hInstall,
	const IMsiString&  ristrFeature, INSTALLSTATE *piInstalled, INSTALLSTATE *piAction)
{
	PMsiSelectionManager pSelMgr = CMsiHandle::GetSelectionManager(hInstall);
	if (pSelMgr == 0)
		return ERROR_INVALID_HANDLE;
	iisEnum iisInstalled;
	iisEnum iisAction;
	if (SetLastErrorRecord(pSelMgr->GetFeatureStates(ristrFeature, &iisInstalled, &iisAction)))
		return ERROR_UNKNOWN_FEATURE;
	if (piInstalled)
		*piInstalled = MapInternalInstallState(iisInstalled);
	if (piAction)
		*piAction = MapInternalInstallState(iisAction);
	return ERROR_SUCCESS;
}

UINT __stdcall MsiGetFeatureStateA(MSIHANDLE hInstall,
	LPCSTR       szFeature,     // feature name within product
	INSTALLSTATE *piInstalled,  // returned current install state
	INSTALLSTATE *piAction)     // action taken during install session
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2("Passing to service: MsiGetFeatureStateA(%d, \"%s\")", reinterpret_cast<const char *>(static_cast<UINT_PTR>(hInstall)), szFeature);
		return g_pCustomActionContext->GetFeatureState(hInstall, CMsiConvertString(szFeature), (long*)piInstalled, (long*)piAction);
	}
#endif

	return _GetFeatureState(hInstall, *CMsiConvertString(szFeature), piInstalled, piAction);
}	

UINT __stdcall MsiGetFeatureStateW(MSIHANDLE hInstall,
	LPCWSTR      szFeature,     // feature name within product
	INSTALLSTATE *piInstalled,  // returned current install state
	INSTALLSTATE *piAction)     // action taken during install session
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		return g_pCustomActionContext->GetFeatureState(hInstall, szFeature, (long*)piInstalled, (long*)piAction);
	}
#endif

	return _GetFeatureState(hInstall, *CMsiConvertString(szFeature), piInstalled, piAction);
}

// Request a feature to be set to a specified state

static UINT _SetFeatureState(MSIHANDLE hInstall,
	 const IMsiString& ristrFeature, INSTALLSTATE iState)
{
	iisEnum iisAction;
	switch (iState)
	{
	case INSTALLSTATE_ADVERTISED:iisAction = iisAdvertise; break;
	case INSTALLSTATE_ABSENT:    iisAction = iisAbsent; break;
	case INSTALLSTATE_LOCAL:     iisAction = iisLocal;  break;
	case INSTALLSTATE_SOURCE:    iisAction = iisSource; break;
	default: return ERROR_INVALID_PARAMETER;
	};
	PMsiSelectionManager pSelMgr = CMsiHandle::GetSelectionManager(hInstall);
	if (pSelMgr == 0)
		return ERROR_INVALID_HANDLE;
	int iError = SetLastErrorRecord(pSelMgr->ConfigureFeature(ristrFeature, iisAction));
	if (iError)
		return iError == idbgBadFeature ? ERROR_UNKNOWN_FEATURE : ERROR_FUNCTION_FAILED;
	return ERROR_SUCCESS;
}

UINT __stdcall MsiSetFeatureStateA(MSIHANDLE hInstall,
	LPCSTR   szFeature,
	INSTALLSTATE iState)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3("Passing to service: MsiSetFeatureStateA(%d, \"%s\", %d)", reinterpret_cast<const char *>(static_cast<UINT_PTR>(hInstall)), szFeature ? szFeature : "NULL", reinterpret_cast<const char *>(static_cast<UINT_PTR>(iState)));
		return g_pCustomActionContext->SetFeatureState(hInstall, CMsiConvertString(szFeature), iState);
	}
#endif

	return _SetFeatureState(hInstall, *CMsiConvertString(szFeature), iState);
}

UINT __stdcall MsiSetFeatureStateW(MSIHANDLE hInstall,
	LPCWSTR  szFeature,
	INSTALLSTATE iState)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3(L"Passing to service: MsiSetFeatureStateW(%d, \"%s\", %d)", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(hInstall)), szFeature ? szFeature : L"NULL", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(iState)));
		return g_pCustomActionContext->SetFeatureState(hInstall, CMsiConvertString(szFeature), iState);
	}
#endif

	return _SetFeatureState(hInstall, *CMsiConvertString(szFeature), iState);
}



static UINT _SetFeatureAttributes(MSIHANDLE hInstall, const IMsiString& ristrFeature, DWORD dwAttributes)
{
	PMsiSelectionManager pSelMgr = CMsiHandle::GetSelectionManager(hInstall);
	if (pSelMgr == 0)
		return ERROR_INVALID_HANDLE;
	int iError = SetLastErrorRecord(pSelMgr->SetFeatureAttributes(ristrFeature, dwAttributes));
	if (iError)
		return iError == idbgBadFeature ? ERROR_UNKNOWN_FEATURE : ERROR_FUNCTION_FAILED;
	return ERROR_SUCCESS;
}

UINT __stdcall MsiSetFeatureAttributesA(MSIHANDLE hInstall, LPCSTR szFeature, DWORD dwAttributes)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3("Passing to service: MsiSetFeatureStateA(%d, \"%s\", %d)", reinterpret_cast<const char *>(static_cast<UINT_PTR>(hInstall)), szFeature ? szFeature : "NULL", reinterpret_cast<const char *>(static_cast<UINT_PTR>(dwAttributes)));
		return g_pCustomActionContext->SetFeatureAttributes(hInstall, CMsiConvertString(szFeature), dwAttributes);
	}
#endif

	return _SetFeatureAttributes(hInstall, *CMsiConvertString(szFeature), dwAttributes);
}

UINT __stdcall MsiSetFeatureAttributesW(MSIHANDLE hInstall, LPCWSTR szFeature, DWORD dwAttributes)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3(L"Passing to service: MsiSetFeatureAttributesW(%d, \"%s\", %d)", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(hInstall)), szFeature ? szFeature : L"NULL", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(dwAttributes)));
		return g_pCustomActionContext->SetFeatureAttributes(hInstall, CMsiConvertString(szFeature), dwAttributes);
	}
#endif

	return _SetFeatureAttributes(hInstall, *CMsiConvertString(szFeature), dwAttributes);
}



// Get the requested state of a component

static UINT _GetComponentState(MSIHANDLE hInstall,
	const IMsiString&  ristrComponent, INSTALLSTATE *piInstalled, INSTALLSTATE *piAction)
{
	PMsiSelectionManager pSelMgr = CMsiHandle::GetSelectionManager(hInstall);
	if (pSelMgr == 0)
		return ERROR_INVALID_HANDLE;
	iisEnum iisInstalled;
	iisEnum iisAction;
	if (SetLastErrorRecord(pSelMgr->GetComponentStates(ristrComponent, &iisInstalled, &iisAction)))
		return ERROR_UNKNOWN_COMPONENT;
	if (piInstalled)
		*piInstalled = MapInternalInstallState(iisInstalled);
	if (piAction)
		*piAction = MapInternalInstallState(iisAction);
	return ERROR_SUCCESS;
}

UINT __stdcall MsiGetComponentStateA(MSIHANDLE hInstall,
	LPCSTR       szComponent,   // component name within product
	INSTALLSTATE *piInstalled,  // returned current install state
	INSTALLSTATE *piAction)     // action taken during install session
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2("Passing to service: MsiGetComponentState(%d, \"%s\")", reinterpret_cast<const char *>(static_cast<UINT_PTR>(hInstall)), szComponent ? szComponent : "NULL");
		return g_pCustomActionContext->GetComponentState(hInstall, CMsiConvertString(szComponent), (long*)piInstalled, (long*)piAction);
	}
#endif

	return _GetComponentState(hInstall, *CMsiConvertString(szComponent), piInstalled, piAction);
}

UINT __stdcall MsiGetComponentStateW(MSIHANDLE hInstall,
	LPCWSTR      szComponent,   // component name within product
	INSTALLSTATE *piInstalled,  // returned current install state
	INSTALLSTATE *piAction)     // action taken during install session
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(L"Passing to service: MsiGetComponentState(%d, \"%s\")", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(hInstall)), szComponent ? szComponent : L"NULL");
		return g_pCustomActionContext->GetComponentState(hInstall, szComponent, (long*)piInstalled, (long*)piAction);
	}
#endif

	return _GetComponentState(hInstall, *CMsiConvertString(szComponent), piInstalled, piAction);
}

// Request a component to be set to a specified state

static UINT _SetComponentState(MSIHANDLE hInstall,
	 const IMsiString& ristrComponent, INSTALLSTATE iState)
{
	iisEnum iisAction;
	switch (iState)
	{
	case INSTALLSTATE_ABSENT: iisAction = iisAbsent; break;
	case INSTALLSTATE_LOCAL:  iisAction = iisLocal;  break;
	case INSTALLSTATE_SOURCE: iisAction = iisSource; break;
	default: return ERROR_INVALID_PARAMETER;
	};
	PMsiSelectionManager pSelMgr = CMsiHandle::GetSelectionManager(hInstall);
	if (pSelMgr == 0)
		return ERROR_INVALID_HANDLE;
	int iError = SetLastErrorRecord(pSelMgr->SetComponentSz(ristrComponent.GetString(), iisAction));
	if (iError)
	{
		switch (iError)
		{
		case idbgBadComponent:	return ERROR_UNKNOWN_COMPONENT;
		case imsgUser:				return ERROR_INSTALL_USEREXIT;
		default:						return ERROR_FUNCTION_FAILED;
		}
	}
	return ERROR_SUCCESS;
}

UINT __stdcall MsiSetComponentStateA(MSIHANDLE hInstall,
	LPCSTR   szComponent,
	INSTALLSTATE iState)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3("Passing to service: MsiSetComponentStateA(%d, \"%s\", %d)", reinterpret_cast<const char *>(static_cast<UINT_PTR>(hInstall)), szComponent ? szComponent : "NULL", reinterpret_cast<const char *>(static_cast<UINT_PTR>(iState)));
		return g_pCustomActionContext->SetComponentState(hInstall, CMsiConvertString(szComponent), iState);
	}
#endif

	return _SetComponentState(hInstall, *CMsiConvertString(szComponent), iState);
}

UINT __stdcall MsiSetComponentStateW(MSIHANDLE hInstall,
	LPCWSTR  szComponent,
	INSTALLSTATE iState)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG3(L"Passing to service: MsiSetComponentStateW(%d, \"%s\", %d)", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(hInstall)), szComponent ? szComponent : L"NULL", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(iState)));
		return g_pCustomActionContext->SetComponentState(hInstall, szComponent, iState);
	}
#endif

	return _SetComponentState(hInstall, *CMsiConvertString(szComponent), iState);
}

// Set the install level for a full product installation (not a feature request)

UINT  __stdcall MsiSetInstallLevel(MSIHANDLE hInstall,
	int iInstallLevel)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(TEXT("Passing to service: MsiSetInstallLevel(%d, %d)"), 
			reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hInstall)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(iInstallLevel)));
		return g_pCustomActionContext->SetInstallLevel(hInstall, iInstallLevel);
	}
#endif

	PMsiSelectionManager pSelMgr = CMsiHandle::GetSelectionManager(hInstall);
	if (pSelMgr == 0)
		return ERROR_INVALID_HANDLE;
	if (SetLastErrorRecord(pSelMgr->SetInstallLevel(iInstallLevel)))
		return ERROR_FUNCTION_FAILED;  //!! specific errors?
	return ERROR_SUCCESS;
}

// Return the disk cost for a feature and all of its selected children

static UINT _GetFeatureCost(MSIHANDLE hInstall, const IMsiString& ristrFeature,
							MSICOSTTREE iCostTree, INSTALLSTATE iState, INT *piCost)
{
	PMsiSelectionManager pSelMgr = CMsiHandle::GetSelectionManager(hInstall);
	if (pSelMgr == 0)
		return ERROR_INVALID_HANDLE;
	if (piCost == 0)
		return ERROR_INVALID_PARAMETER; // could set piCost to a local variable?
	if (ristrFeature.TextSize() == 0)
		return ERROR_INVALID_PARAMETER;
	iisEnum iisAction;
	switch (iState)
	{
	case INSTALLSTATE_ABSENT:  iisAction = iisAbsent; break;
	case INSTALLSTATE_LOCAL:   iisAction = iisLocal;  break;
	case INSTALLSTATE_SOURCE:  iisAction = iisSource; break;
	case INSTALLSTATE_DEFAULT: iisAction = iisReinstall; break; //!!s.b.iisDefault
	case INSTALLSTATE_UNKNOWN: iisAction = (iisEnum)iMsiNullInteger; break;
	default: return ERROR_INVALID_PARAMETER;
	};
	IMsiRecord* pirecError;
	switch (iCostTree)
	{
	case MSICOSTTREE_SELFONLY:
		pirecError = pSelMgr->GetFeatureCost(ristrFeature, iisAction, *piCost); break;
	case MSICOSTTREE_CHILDREN:
		pirecError = pSelMgr->GetDescendentFeatureCost(ristrFeature, iisAction, *piCost); break;
	case MSICOSTTREE_PARENTS:
		pirecError = pSelMgr->GetAncestryFeatureCost(ristrFeature, iisAction, *piCost); break;
	case MSICOSTTREE_RESERVED:
		return ERROR_INVALID_PARAMETER; //!! new error? ERROR_UNSUPPORTED_TYPE
	default:
		return ERROR_INVALID_PARAMETER;
	};
	int imsg = SetLastErrorRecord(pirecError);
	if (imsg)
	{
		if (imsg == idbgSelMgrNotInitialized)
			return ERROR_INVALID_HANDLE_STATE;
		else if (imsg == idbgBadFeature)
			return ERROR_UNKNOWN_FEATURE;
		else
			return ERROR_FUNCTION_FAILED;
	}
	return ERROR_SUCCESS;
}

UINT  __stdcall MsiGetFeatureCostA(MSIHANDLE hInstall,
	LPCSTR       szFeature,     // name of feature
	MSICOSTTREE  iCostTree,     // portion of tree to cost
	INSTALLSTATE iState,        // requested state, or INSTALLSTATE_UNKNOWN
	INT          *piCost)       // returned cost, in units of 512 bytes
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG4("Passing to service: MsiGetFeatureCostA(%d, \"%s\")", reinterpret_cast<const char *>(static_cast<UINT_PTR>(hInstall)), 
			szFeature ? szFeature : "NULL", reinterpret_cast<const char *>(static_cast<UINT_PTR>(iCostTree)), reinterpret_cast<const char *>(static_cast<UINT_PTR>(iState)));
		return g_pCustomActionContext->GetFeatureCost(hInstall, CMsiConvertString(szFeature), iCostTree, iState, piCost);
	}
#endif

	return _GetFeatureCost(hInstall, *CMsiConvertString(szFeature), iCostTree, iState, piCost);
}


UINT  __stdcall MsiGetFeatureCostW(MSIHANDLE hInstall,
	LPCWSTR      szFeature,     // name of feature
	MSICOSTTREE  iCostTree,     // portion of tree to cost
	INSTALLSTATE iState,        // requested state, or INSTALLSTATE_UNKNOWN
	INT          *piCost)       // returned cost, in units of 512 bytes
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG4(L"Passing to service: MsiGetFeatureCostA(%d, \"%s\", %d, %d)", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(hInstall)), 
			szFeature ? szFeature : L"NULL", reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(iCostTree)), reinterpret_cast<const WCHAR *>(static_cast<UINT_PTR>(iState)));
		return g_pCustomActionContext->GetFeatureCost(hInstall, CMsiConvertString(szFeature), iCostTree, iState, piCost);
	}
#endif

	return _GetFeatureCost(hInstall, *CMsiConvertString(szFeature), iCostTree, iState, piCost);
}


// enumerates the costs per drives of ristrComponent or of the Windows Installer

static UINT _EnumComponentCosts(MSIHANDLE hInstall, const IMsiString& ristrComponent,
										  DWORD dwIndex, INSTALLSTATE iState,
										  IMsiVolume*& rpiVolume,
										  INT *piCost, INT *piTempCost)
{
	PMsiSelectionManager pSelMgr = CMsiHandle::GetSelectionManager(hInstall);
	int iCost, iTempCost;
	if (pSelMgr == 0)
		return ERROR_INVALID_HANDLE;

	IMsiRecord* piError;
	if ( ristrComponent.TextSize() )
	{
		iisEnum iisAction;
		switch (iState)
		{
		case INSTALLSTATE_ABSENT:  iisAction = iisAbsent; break;
		case INSTALLSTATE_LOCAL:   iisAction = iisLocal;  break;
		case INSTALLSTATE_SOURCE:  iisAction = iisSource; break;
		case INSTALLSTATE_DEFAULT: iisAction = iisCurrent; break;
		case INSTALLSTATE_UNKNOWN: iisAction = (iisEnum)iMsiNullInteger; break;
		default: return ERROR_INVALID_PARAMETER;
		};
		piError = pSelMgr->EnumComponentCosts(ristrComponent, iisAction, dwIndex,
														  *&rpiVolume, iCost, iTempCost);
	}
	else
		piError = pSelMgr->EnumEngineCostsPerVolume(dwIndex, *&rpiVolume, iCost, iTempCost);

	int imsg = SetLastErrorRecord(piError);
	if (imsg)
	{
		if (imsg == idbgSelMgrNotInitialized)
			return ERROR_INVALID_HANDLE_STATE;
		else if (imsg == idbgBadComponent)
			return ERROR_UNKNOWN_COMPONENT;
		else if (imsg == idbgNoMoreData)
			return ERROR_NO_MORE_ITEMS;
		else if (imsg == idbgOpOutOfSequence)
			return ERROR_FUNCTION_NOT_CALLED;
		else
			return ERROR_FUNCTION_FAILED;
	}
	else
	{
		*piCost = iCost;
		*piTempCost = iTempCost;
		return ERROR_SUCCESS;
	}
}

UINT  __stdcall MsiEnumComponentCostsA(MSIHANDLE hInstall,
	LPCSTR       szComponent,     // name of component
	DWORD        dwIndex,         // index into the list of drives
	INSTALLSTATE iState,          // requested state, or INSTALLSTATE_UNKNOWN
	LPSTR        szDriveBuf,      // buffer for returned value
	DWORD        *pcchDriveBuf,   // in/out buffer character count
	INT          *piCost,         // returned cost, in units of 512 bytes
	INT          *piTempCost)     // returned temporary cost, in units of 512 bytes
{
	if ( !szDriveBuf || !pcchDriveBuf || !piCost || !piTempCost )
		return ERROR_INVALID_PARAMETER;

	PMsiVolume pVolume(0);
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG4("Passing to service: MsiEnumComponentCosts(%d, \"%s\", %d, %d)",
					 reinterpret_cast<const char *>(static_cast<UINT_PTR>(hInstall)), 
					 szComponent ? szComponent : "NULL",
					 reinterpret_cast<const char *>(static_cast<UINT_PTR>(dwIndex)),
					 reinterpret_cast<const char *>(static_cast<UINT_PTR>(iState)));
		CAnsiToWideOutParam buf(szDriveBuf, pcchDriveBuf);
		HRESULT hRes =
			g_pCustomActionContext->EnumComponentCosts(hInstall, CMsiConvertString(szComponent),
																	 dwIndex, iState, buf, buf.BufferSize(),
																	 buf, piCost, piTempCost);
		return buf.FillReturnBuffer(hRes, szDriveBuf, pcchDriveBuf);
	}
#endif

	UINT uRet = _EnumComponentCosts(hInstall, *CMsiConvertString(szComponent), dwIndex,
											  iState, *&pVolume, piCost, piTempCost);
	if ( uRet != ERROR_SUCCESS )
		return uRet;
	else
		return ::FillBufferA(MsiString(pVolume->GetPath()), szDriveBuf, pcchDriveBuf);
}

UINT  __stdcall MsiEnumComponentCostsW(MSIHANDLE hInstall,
	LPCWSTR      szComponent,     // name of component
	DWORD        dwIndex,         // index into the list of drives
	INSTALLSTATE iState,          // requested state, or INSTALLSTATE_UNKNOWN
	LPWSTR       szDriveBuf,      // buffer for returned value
	DWORD        *pcchDriveBuf,   // in/out buffer character count
	INT          *piCost,         // returned cost, in units of 512 bytes
	INT          *piTempCost)     // returned temporary cost, in units of 512 bytes
{
	if ( !szDriveBuf || !pcchDriveBuf || !piCost || !piTempCost )
		return ERROR_INVALID_PARAMETER;

	PMsiVolume pVolume(0);
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG4(TEXT("Passing to service: MsiEnumComponentCosts(%d, \"%s\", %d, %d)"),
					 reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hInstall)), 
					 szComponent ? szComponent : TEXT("NULL"),
					 reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(dwIndex)),
					 reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(iState)));
		CWideOutParam buf(szDriveBuf, pcchDriveBuf);
		if ( ! (WCHAR *) buf )
			return ERROR_OUTOFMEMORY;
		HRESULT hRes =
			g_pCustomActionContext->EnumComponentCosts(hInstall, szComponent, dwIndex, iState,
																	 static_cast<WCHAR *>(buf), buf.BufferSize(),
																	 static_cast<DWORD *>(buf), piCost, piTempCost);
		return buf.FillReturnBuffer(hRes, szDriveBuf, pcchDriveBuf);
	}
#endif

	UINT uRet = _EnumComponentCosts(hInstall, *CMsiConvertString(szComponent), dwIndex,
											  iState, *&pVolume, piCost, piTempCost);
	if ( uRet != ERROR_SUCCESS )
		return uRet;
	else
		return ::FillBufferW(MsiString(pVolume->GetPath()), szDriveBuf, pcchDriveBuf);
}


UINT  __stdcall MsiGetFeatureValidStatesI(MSIHANDLE hInstall,
	const ICHAR*  szFeature,
	DWORD  *dwInstallStates)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG2(TEXT("Passing to service: MsiGetFeatureValidStates(%d, \"%s\")"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hInstall)), szFeature ? szFeature : TEXT("NULL"));
		return g_pCustomActionContext->GetFeatureValidStates(hInstall, szFeature, dwInstallStates);
	}
#endif

	PMsiSelectionManager pSelMgr = CMsiHandle::GetSelectionManager(hInstall);
	if (pSelMgr == 0)
		return ERROR_INVALID_HANDLE;
	if (szFeature == 0 || dwInstallStates == 0)
		return ERROR_INVALID_PARAMETER;
	int iValidStates;
	int imsg = SetLastErrorRecord(pSelMgr->GetFeatureValidStatesSz(szFeature, iValidStates));
	if (imsg)
	{
		if (imsg == idbgSelMgrNotInitialized)
			return ERROR_INVALID_HANDLE_STATE;
		else if (imsg == idbgBadFeature)
			return ERROR_UNKNOWN_FEATURE;
		else
			return ERROR_FUNCTION_FAILED;
	}
	DWORD dwStates = 0;
	if (iValidStates & icaBitSource)    dwStates |= (1 << INSTALLSTATE_SOURCE);
	if (iValidStates & icaBitLocal)     dwStates |= (1 << INSTALLSTATE_LOCAL);
	if (iValidStates & icaBitAdvertise) dwStates |= (1 << INSTALLSTATE_ADVERTISED);
	if (iValidStates & icaBitAbsent)    dwStates |= (1 << INSTALLSTATE_ABSENT);
	*dwInstallStates = dwStates;
	return ERROR_SUCCESS;
}

UINT  __stdcall MsiGetFeatureValidStatesX(MSIHANDLE hInstall,
	LPCXSTR  szFeature,
	DWORD  *dwInstallStates)
{
	return MsiGetFeatureValidStatesI(hInstall, CMsiConvertString(szFeature), dwInstallStates);
}

// Check to see if sufficent disk space is present for the current installation

UINT __stdcall MsiVerifyDiskSpace(MSIHANDLE hInstall)
{
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		DEBUGMSG1(TEXT("Passing to service: MsiVerifyDiskSpace(%d)"), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(hInstall)));
		return g_pCustomActionContext->VerifyDiskSpace(hInstall);
	}
#endif

	PMsiSelectionManager pSelMgr = CMsiHandle::GetSelectionManager(hInstall);
	if (pSelMgr == 0)
		return ERROR_INVALID_HANDLE;
	if (pSelMgr->DetermineOutOfDiskSpace(NULL, NULL))
		return ERROR_DISK_FULL;
	//!! check for ERROR_INVALID_HANDLE_STATE
	return ERROR_SUCCESS;
}

//____________________________________________________________________________
//
// UI preview API implementation
//____________________________________________________________________________

// temporary until handler can get fixed to release properly
class CMsiPreview : public IMsiHandler
{
 public:
	HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long   __stdcall AddRef();
	unsigned long   __stdcall Release();
	virtual Bool    __stdcall Initialize(IMsiEngine& riEngine, iuiEnum iuiLevel, HWND hwndParent, bool& fMissingTables);
	virtual imsEnum __stdcall Message(imtEnum imt, IMsiRecord& riRecord);
	virtual iesEnum __stdcall DoAction(const ICHAR* szAction);
	virtual Bool    __stdcall Break();
	virtual void    __stdcall Terminate(bool fFatalExit=false);
	virtual HWND    __stdcall GetTopWindow();
	CMsiPreview(IMsiEngine& riEngine, IMsiHandler& riHandler);
	IMsiEngine& GetEngine() {m_riEngine.AddRef(); return m_riEngine;}
 private:
	IMsiHandler& m_riHandler;
	IMsiEngine& m_riEngine;
	unsigned long m_iRefCnt;
};

IMsiEngine* GetEngineFromPreview(MSIHANDLE h)
{
	CComPointer<CMsiPreview> pPreview = (CMsiPreview*)FindMsiHandle(h, iidMsiHandler);
	return pPreview == 0 ? 0 : &pPreview->GetEngine();
}

#ifdef DEBUG
const GUID IID_IMsiHandlerDebug = GUID_IID_IMsiHandlerDebug;
#endif

HRESULT  CMsiPreview::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown)
#ifdef DEBUG
	 || MsGuidEqual(riid, IID_IMsiHandlerDebug)
#endif
	 || MsGuidEqual(riid, IID_IMsiHandler))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CMsiPreview::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiPreview::Release()
{
	if (--m_iRefCnt == 0)
	{
		m_riHandler.Release();
		m_riEngine.Terminate(iesSuccess);
//!!doesn't work-> m_riHandler.Terminate();
		IMsiEngine& riEngine = m_riEngine;
		delete this;
		riEngine.Release();
		return 0;
	}
	return m_iRefCnt;
}

Bool CMsiPreview::Initialize(IMsiEngine& riEngine, iuiEnum iuiLevel, HWND hwndParent, bool& fMissingTables)
{
	return m_riHandler.Initialize(riEngine, iuiLevel, hwndParent, fMissingTables);
}

imsEnum CMsiPreview::Message(imtEnum imt, IMsiRecord& riRecord)
{
	return m_riHandler.Message(imt, riRecord);
}

iesEnum CMsiPreview::DoAction(const ICHAR* szAction)
{
	return m_riHandler.DoAction(szAction);
}

Bool CMsiPreview::Break()
{
	return m_riHandler.Break();
}

void CMsiPreview::Terminate(bool fFatalExit)
{
	m_riHandler.Terminate(fFatalExit);
}

HWND CMsiPreview::GetTopWindow()
{
	return m_riHandler.GetTopWindow();
}

CMsiPreview::CMsiPreview(IMsiEngine& riEngine, IMsiHandler& riHandler)
	: m_riHandler(riHandler)
	, m_riEngine(riEngine)
	, m_iRefCnt(1)
{
	m_riEngine.AddRef();
}

// Enable UI in preview mode to facilitate authoring of UI dialogs.
// The preview mode will end when the handle is closed.

UINT WINAPI MsiEnableUIPreview(MSIHANDLE hDatabase,
	MSIHANDLE* phPreview)        // returned handle for UI preview capability
{
	if (phPreview == 0)
		return ERROR_INVALID_PARAMETER;
	*phPreview = 0;
	PMsiDatabase pDatabase = CMsiHandle::GetDatabase(hDatabase);
	if (pDatabase == 0)
		return ERROR_INVALID_HANDLE;
	PMsiEngine pEngine = CreateEngine(*pDatabase);
	if (pEngine == 0)
		return ERROR_OUTOFMEMORY;   
	ieiEnum ieiStat = pEngine->Initialize(0, iuiNextEnum, 0, 0, iioEnum(0));
	if (ieiStat != ieiSuccess)
	{
		pEngine->Release();
		return ENG::MapInitializeReturnToUINT(ieiStat);
	}
	IMsiHandler* piHandler = pEngine->GetHandler();  // cannot be null if ieiSuccess
	g_MessageContext.m_szAction = TEXT("!");
	g_MessageContext.Invoke(imtShowDialog, 0);
	*phPreview = ::CreateMsiHandle(new CMsiPreview(*pEngine, *piHandler), iidMsiHandler);
	return ERROR_SUCCESS;
}

// Display any UI dialog as modeless and inactive.
// Supplying a null name will remove any current dialog.

UINT WINAPI MsiPreviewDialogI(MSIHANDLE hPreview,
	const ICHAR* szDialogName)       // dialog to display, Dialog table key
{
	PMsiHandler pHandler = CMsiHandle::GetHandler(hPreview);
	if (pHandler == 0)
		return ERROR_INVALID_HANDLE;
	g_MessageContext.m_szAction = szDialogName;
	return ::MapActionReturnToError((iesEnum)g_MessageContext.Invoke(imtShowDialog, 0), hPreview);
}

UINT WINAPI MsiPreviewDialogX(MSIHANDLE hPreview,
	LPCXSTR  szDialogName)       // dialog to display, Dialog table key
{
	return MsiPreviewDialogI(hPreview, CMsiConvertString(szDialogName));
}

// Display a billboard within a host control in the displayed dialog.
// Supplying a null billboard name will remove any billboard displayed.

UINT WINAPI MsiPreviewBillboardI(MSIHANDLE hPreview,
	const ICHAR* szControlName,      // name of control that accepts billboards
	const ICHAR* szBillboard)        // name of billboard to display
{
	PMsiHandler pHandler = CMsiHandle::GetHandler(hPreview);
	if (pHandler == 0)
		return ERROR_INVALID_HANDLE;
	if (szControlName == 0)
		return ERROR_INVALID_PARAMETER;
	PMsiRecord precMessage = &ENG::CreateRecord(2);
	precMessage->SetString(0, szControlName); // anything, to keep from suppressing output
	precMessage->SetString(1, szControlName);
	precMessage->SetString(2, szBillboard);
	imsEnum ims = g_MessageContext.Invoke(imtActionData, precMessage);
	return (ims == imsOk || ims == imsCancel) ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
}

UINT WINAPI MsiPreviewBillboardX(MSIHANDLE hPreview,
	LPCXSTR  szControlName,     // name of control that accepts billboards
	LPCXSTR  szBillboard)       // name of billboard to display
{
	return MsiPreviewBillboardI(hPreview, CMsiConvertString(szControlName), CMsiConvertString(szBillboard));
}

//____________________________________________________________________________
//
// Special engine proxy to provide a handle to custom actions during rollback
//____________________________________________________________________________

CMsiCustomContext::CMsiCustomContext(int icaFlags, const IMsiString& ristrCustomActionData, const IMsiString& ristrProductCode,
																LANGID langid, IMsiMessage& riMessage)
	: m_ristrCustomActionData(ristrCustomActionData)
	, m_ristrProductCode(ristrProductCode)
	, m_icaFlags(icaFlags), m_langid(langid)
	, m_riMessage(riMessage), m_iRefCnt(1)
{
	m_riMessage.AddRef();
	m_ristrCustomActionData.AddRef();
	m_ristrProductCode.AddRef();
}

BOOL CMsiCustomContext::GetMode(MSIRUNMODE eRunMode)
{
	if (eRunMode == MSIRUNMODE_SCHEDULED && !(m_icaFlags & (icaRollback | icaCommit))
	 || eRunMode == MSIRUNMODE_ROLLBACK  && (m_icaFlags & icaRollback)
	 || eRunMode == MSIRUNMODE_COMMIT    && (m_icaFlags & icaCommit))
		return TRUE;
	else
		return FALSE;
}

const IMsiString& CMsiCustomContext::GetProperty(const ICHAR* szName)
{
	if (IStrComp(szName, IPROPNAME_CUSTOMACTIONDATA) == 0)
		return (m_ristrCustomActionData.AddRef(), m_ristrCustomActionData);
	if (IStrComp(szName, IPROPNAME_PRODUCTCODE) == 0)
		return (m_ristrProductCode.AddRef(), m_ristrProductCode);
	if (IStrComp(szName, IPROPNAME_USERSID) == 0)
	{
		MsiString strUserSID;
		if(!g_fWin9X)
		{
			AssertNonZero(GetCurrentUserStringSID(*&strUserSID) == ERROR_SUCCESS);
		}
		return strUserSID.Return();
	}
		
	return g_MsiStringNull;
}

HRESULT CMsiCustomContext::QueryInterface(const IID&, void**)
{
	return E_NOINTERFACE;
}

unsigned long CMsiCustomContext::AddRef()
{
	return ++m_iRefCnt;          
}

unsigned long CMsiCustomContext::Release()
{
	if (--m_iRefCnt == 0)
	{
		m_ristrCustomActionData.Release();
		m_ristrProductCode.Release();
		m_riMessage.Release();
		delete this;
		return 0;
	}
	return m_iRefCnt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\patch.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       patch.cpp
//
//--------------------------------------------------------------------------

/*  patch.cpp - IMsiFilePatch implementation

	IMsiFilePatch: object used to test and apply patches to files

	ApplyPatch:    begin a patch application, may return before patch has been
					   completely applied

	ContinuePatch: continue patch application started with ApplyPatch()

	CanPatchFile:  test patch against file (without applying patch),
						return status
____________________________________________________________________________*/

#include "precomp.h" 
#include "services.h"
#include "_service.h"
#include "path.h"

#include "patchapi.h"

#define Ensure(function) {	\
						IMsiRecord* piEnsureReturn = function;	\
						if (piEnsureReturn) \
							return piEnsureReturn; \
						}

//____________________________________________________________________________
//
// CMsiFilePatch definition
//____________________________________________________________________________

class CMsiFilePatch : public IMsiFilePatch  // class private to this module
{
 public:   // implemented virtual functions
	virtual HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	virtual unsigned long __stdcall AddRef();
	virtual unsigned long __stdcall Release();
	virtual IMsiRecord*   __stdcall ApplyPatch(IMsiPath& riTargetPath, const ICHAR* szTargetName,
															 IMsiPath& riOutputPath, const ICHAR* szOutputName,
															 IMsiPath& riPatchPath, const ICHAR* szPatchFileName,
															 int cbPerTick);

	virtual IMsiRecord*   __stdcall ContinuePatch();
	virtual IMsiRecord*   __stdcall CancelPatch();

	virtual IMsiRecord*   __stdcall CanPatchFile(IMsiPath& riTargetPath, const ICHAR* szTargetFileName,
																IMsiPath& riPatchPath, const ICHAR* szPatchFileName,
																icpEnum& ipc);

 public:  // constructor
	CMsiFilePatch(IMsiServices *piServices);
	~CMsiFilePatch();
 protected: // local state

	IMsiRecord*    PostPatchError(int iError);
	IMsiRecord*    CreateFileHandles(Bool fCreateOutput);
	void           CloseFileHandles(void);
	static DWORD WINAPI PatchThreadStart(LPVOID pbCmdLine);
	IMsiRecord*    WaitForEvent(void);
	static BOOL __stdcall ApplyPatchCallback(PVOID CallbackContext,
															 ULONG CurrentPosition,
															 ULONG MaximumPosition);

 protected:
	int            m_iRefCnt;
	IMsiServices*  m_piServices;
	MsiString      m_strEntry;
	PMsiPath       m_pUpdateDir;
	unsigned int   m_cbPerTick;
	unsigned int   m_cbPatchedSoFar;
	unsigned int   m_cbSignalEvent;
	Bool           m_fPatchInProgress;
	Bool           m_fCancelPatch; // set by CancelPatch()

	PMsiPath       m_pPatchPath;
	PMsiPath       m_pTargetPath;
	PMsiPath       m_pOutputPath;
	MsiString      m_strTargetFullPath;
	MsiString      m_strTargetFileName;
	MsiString      m_strPatchFullPath;
	MsiString      m_strOutputFullPath;
	MsiString      m_strOutputFileName;

	CHandle        m_hPatchFile;
	CHandle        m_hTargetFile;
	CHandle        m_hOutputFile;

	HANDLE         m_hPatchApplyThread;
	HANDLE         m_hEvent;
	HANDLE         m_rghWaitObjects[2];

};

IMsiRecord* CreateMsiFilePatch(IMsiServices* piServices, IMsiFilePatch*& rpiFilePatch)
{
	CMsiFilePatch* pFilePatch = new CMsiFilePatch(piServices);
	rpiFilePatch = pFilePatch;
	return 0;
}

//____________________________________________________________________________
//
// CMsiFilePatch implementation
//____________________________________________________________________________

CMsiFilePatch::CMsiFilePatch(IMsiServices *piServices)
 : m_piServices(piServices), m_fPatchInProgress(fFalse),
   m_pUpdateDir(0), m_pTargetPath(0), m_pOutputPath(0), m_pPatchPath(0),
	m_fCancelPatch(fFalse), m_hEvent(0)
{
	Assert(piServices);
	m_iRefCnt = 1;
	m_piServices->AddRef();
}

CMsiFilePatch::~CMsiFilePatch()
{
	if(m_hEvent)
		WIN::CloseHandle(m_hEvent);
}

HRESULT CMsiFilePatch::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IMsiFilePatch)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CMsiFilePatch::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiFilePatch::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;

	IMsiServices* piServices = m_piServices;
	delete this;
	piServices->Release();
	return 0;
}

IMsiRecord* CMsiFilePatch::CanPatchFile(IMsiPath& riTargetPath, const ICHAR* szTargetFileName,
													 IMsiPath& riPatchPath, const ICHAR* szPatchFileName,
													 icpEnum& icpResult)
{
	IMsiRecord* piError = 0;

	m_pPatchPath = &riPatchPath, riPatchPath.AddRef();
	m_pTargetPath = &riTargetPath, riTargetPath.AddRef();

	Ensure(riPatchPath.GetFullFilePath(szPatchFileName, *&m_strPatchFullPath));
	Ensure(riTargetPath.GetFullFilePath(szTargetFileName, *&m_strTargetFullPath));

	Ensure(CreateFileHandles(fFalse));

	DWORD dwLastErr = 0;
	BOOL fRes = MSPATCHA::TestApplyPatchToFileByHandles(m_hPatchFile,m_hTargetFile,
																		APPLY_OPTION_FAIL_IF_EXACT);
	if(!fRes)
		dwLastErr = GetLastError();

	CloseFileHandles();

	if(fRes == TRUE)
	{
		icpResult = icpCanPatch;
		return 0;
	}
	else
	{
		switch(dwLastErr)
		{
		case ERROR_PATCH_NOT_NECESSARY:
			icpResult = icpUpToDate;
			return 0;
		case ERROR_PATCH_WRONG_FILE:
			icpResult = icpCannotPatch;
			return 0;
		case ERROR_INVALID_FUNCTION:
			// could load lib or getprocaddress
			return PostError(Imsg(idbgMissingProcAddr),TEXT("MSPATCHA"),TEXT("TestApplyPatchToFileByHandles"));
		default:
			return PostPatchError(dwLastErr);
		};
	}
}

IMsiRecord* CMsiFilePatch::ApplyPatch(IMsiPath& riTargetPath, const ICHAR* szTargetName,
												  IMsiPath& riOutputPath, const ICHAR* szOutputName,
												  IMsiPath& riPatchPath, const ICHAR* szPatchFileName,
												  int cbPerTick)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
	if(m_fPatchInProgress == fFalse)
	{  
		// start new patch apply

		// check parameters
		Bool fExists;

		Ensure(riTargetPath.GetFullFilePath(szTargetName, *&m_strTargetFullPath));
		
		Ensure(riTargetPath.FileExists(szTargetName, fExists));
		if(!fExists)
			return PostError(Imsg(idbgFileDoesNotExist), (const ICHAR*)m_strTargetFullPath);

		m_cbPatchedSoFar = 0;
		m_cbPerTick = cbPerTick;

		m_pPatchPath = &riPatchPath, riPatchPath.AddRef();
		m_pTargetPath = &riTargetPath, riTargetPath.AddRef();
		m_pOutputPath = &riOutputPath, riOutputPath.AddRef();
		m_strTargetFileName = szTargetName;
		m_strOutputFileName = szOutputName;

		Ensure(riOutputPath.GetFullFilePath(szOutputName, *&m_strOutputFullPath));
		Ensure(riPatchPath.GetFullFilePath(szPatchFileName, *&m_strPatchFullPath));

		// NOTE: this function uses m_p*Path and m_str*FullPath - need to set these before calling
		Ensure(CreateFileHandles(fTrue));

		// create Event to be signaled when appropriate # of bytes have been patched
		if(m_hEvent)
			WIN::CloseHandle(m_hEvent);
		m_hEvent = WIN::CreateEvent(NULL, TRUE, FALSE, NULL);
		Assert((INT_PTR)m_hEvent);		//--merced: changed int to INT_PTR

		DWORD dwThreadId = 0;
		m_hPatchApplyThread = WIN::CreateThread(NULL, 0, PatchThreadStart, this,
															 0, &dwThreadId);
		if(m_hPatchApplyThread == NULL)
			return PostError(Imsg(idbgCreatePatchThread), GetLastError());

		m_fPatchInProgress = fTrue;
		return WaitForEvent();
	}
	else
	{
		return PostError(Imsg(idbgPatchInProgress), szTargetName);
	}
}

IMsiRecord* CMsiFilePatch::ContinuePatch()
{
	if(m_fPatchInProgress == fTrue)
		return WaitForEvent();
	else
		return PostError(Imsg(idbgNoPatchInProgress));
}

IMsiRecord* CMsiFilePatch::CancelPatch()
{
	if(m_fPatchInProgress == fTrue)
	{
		m_fCancelPatch = fTrue; // trigger callback fn to cancel patch by returning FALSE
		return WaitForEvent();
	}
	else
		return PostError(Imsg(idbgNoPatchInProgress));
}

IMsiRecord* CreateFileHandle(IMsiPath& riPath, const ICHAR* szFullPath,
									  bool fWrite, CHandle& h)
{
	bool fImpersonate = (g_scServerContext == scService) &&
							  FVolumeRequiresImpersonation(*PMsiVolume(&riPath.GetVolume()));

	if(fImpersonate)
		StartImpersonating();
	
	h = WIN::CreateFile(szFullPath,
							  GENERIC_READ | (fWrite ? GENERIC_WRITE : 0),
							  FILE_SHARE_READ,
							  NULL,
							  fWrite ? CREATE_ALWAYS : OPEN_EXISTING,
							  (FILE_ATTRIBUTE_NORMAL | (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)),
							  0);

    if (h != INVALID_HANDLE_VALUE)
	{
		DWORD dwType = GetFileType(h);
		if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
		{
			DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), szFullPath);
			h= INVALID_HANDLE_VALUE;
			SetLastError(ERROR_OPEN_FAILED);
		}
	}


	DWORD dwLastErr = GetLastError();

	if(fImpersonate)
		StopImpersonating();

	if(h == INVALID_HANDLE_VALUE)
		return PostError(fWrite ? Imsg(idbgErrorOpeningFileForWrite) : Imsg(idbgErrorOpeningFileForRead),
							  dwLastErr, szFullPath);

	return 0;
}

IMsiRecord* CMsiFilePatch::CreateFileHandles(Bool fCreateOutput)
{
	Assert(m_pPatchPath);
	Assert(m_strPatchFullPath.TextSize());
	IMsiRecord* piError = CreateFileHandle(*m_pPatchPath, m_strPatchFullPath, false, m_hPatchFile);

	if(!piError)
	{
		Assert(m_pTargetPath);
		Assert(m_strTargetFullPath.TextSize());
		piError = CreateFileHandle(*m_pTargetPath, m_strTargetFullPath, false, m_hTargetFile);
	}

	if(!piError && fCreateOutput)
	{
		Assert(m_pOutputPath);
		Assert(m_strOutputFullPath.TextSize());
		piError = CreateFileHandle(*m_pOutputPath, m_strOutputFullPath, true, m_hOutputFile);
	}

	if(piError)
		CloseFileHandles();

	return piError;
}

DWORD WINAPI CMsiFilePatch::PatchThreadStart(void* pFilePatch)
{
	BOOL fRes = MSPATCHA::ApplyPatchToFileByHandlesEx(((CMsiFilePatch*)pFilePatch)->m_hPatchFile,
																	 ((CMsiFilePatch*)pFilePatch)->m_hTargetFile,
																	 ((CMsiFilePatch*)pFilePatch)->m_hOutputFile,
																	 0, // options
																	 (CMsiFilePatch::ApplyPatchCallback),
																	 (void*)pFilePatch /* context pointer */);
	if(fRes)
		return 0;
	else
		return GetLastError();

}

IMsiRecord* CMsiFilePatch::WaitForEvent(void)
{
	m_cbSignalEvent = m_cbPatchedSoFar + m_cbPerTick;

	AssertNonZero(WIN::ResetEvent(m_hEvent)); // callback will SetEvent when m_cbSignalEvent <= m_cbPatchedSoFar
	m_rghWaitObjects[0] = m_hPatchApplyThread;
	m_rghWaitObjects[1] = m_hEvent;

	int cObjects = m_fCancelPatch ? 1 : 2; // if we are trying to cancel patch, wait for thread only
	
	DWORD dw = WaitForMultipleObjects(cObjects,m_rghWaitObjects,FALSE,INFINITE);
	switch(dw)
	{
	case(WAIT_OBJECT_0):
		// patch thread finished
		DWORD dwExitCode;
		AssertNonZero(WIN::GetExitCodeThread(m_hPatchApplyThread,&dwExitCode));
		Assert(dwExitCode != STILL_ACTIVE);
		
		Bool fCancelPatch;
		fCancelPatch = m_fCancelPatch; // to test below
		CloseHandle(m_hPatchApplyThread);
		m_hPatchApplyThread = NULL;
		m_fPatchInProgress = fFalse;
		m_fCancelPatch = fFalse;
		CloseFileHandles();
		if(dwExitCode == 0)
		{
			// set the file attributes on the output file to match the target file
			PMsiRecord pError(0);
			int iFileAttributes = 0;
			if((pError = m_pTargetPath->GetAllFileAttributes(m_strTargetFileName,iFileAttributes)) == 0)
			{
				// turn on archive bit for all patched files
				pError = m_pOutputPath->SetAllFileAttributes(m_strOutputFileName,
																			iFileAttributes | FILE_ATTRIBUTE_ARCHIVE);
			}
#ifdef DEBUG
			if(pError)
			{
				AssertRecordNR(pError);
			}
#endif //DEBUG
			return 0;
		}
		else if(dwExitCode == ERROR_INVALID_FUNCTION)
		{
			// could load lib or getprocaddress
			return PostError(Imsg(idbgMissingProcAddr),TEXT("MSPATCHA"),TEXT("ApplyPatchToFileByHandlesEx"));
		}
		else if(dwExitCode == ERROR_CANCELLED && fCancelPatch)
		{
			// we cancelled the patch
			return 0;
		}
		else
			return PostPatchError(dwExitCode);
	case(WAIT_OBJECT_0 + 1):
		// patch thread not done yet
		Assert(!m_fCancelPatch); // shouldn't have waited for this object
		return PostError(Imsg(idbgPatchNotify), m_cbPatchedSoFar);
	case(WAIT_FAILED):
	default:
		m_fPatchInProgress = fFalse;
		m_fCancelPatch = fFalse;
		return PostError(Imsg(idbgWaitForPatchThread), GetLastError());
	};
}

BOOL __stdcall CMsiFilePatch::ApplyPatchCallback(PVOID CallbackContext,
																 ULONG CurrentPosition,
																 ULONG /*MaximumPosition*/)

{
	CMsiFilePatch* pFilePatch = (CMsiFilePatch*)CallbackContext;
	Assert(pFilePatch);

	if(pFilePatch->m_fCancelPatch)
	{
		SetLastError(ERROR_CANCELLED);
		return FALSE;
	}

	pFilePatch->m_cbPatchedSoFar = CurrentPosition;
	if(pFilePatch->m_cbPatchedSoFar >= pFilePatch->m_cbSignalEvent)
		SetEvent(pFilePatch->m_hEvent);
	return TRUE;
}

void CMsiFilePatch::CloseFileHandles(void)
{
	m_hPatchFile = INVALID_HANDLE_VALUE;
	m_hTargetFile = INVALID_HANDLE_VALUE;
	m_hOutputFile = INVALID_HANDLE_VALUE;
}

IMsiRecord* CMsiFilePatch::PostPatchError(int iError)
{
	switch(iError)
	{
	case 0:
		return 0;
	case ERROR_PATCH_NOT_NECESSARY:
		Assert(0); // shouldn't get this since we didn't use APPLY_OPTION_FAIL_IF_EXACT
		return 0;
	case ERROR_PATCH_CORRUPT:
	case ERROR_PATCH_NEWER_FORMAT:
	case ERROR_PATCH_DECODE_FAILURE:
		// patch file is currupt or different format
	case ERROR_PATCH_WRONG_FILE:
	default:
		return PostError(Imsg(imsgApplyPatchError),*m_strTargetFullPath,iError);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\path.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       path.cpp
//
//--------------------------------------------------------------------------

/*-------------------------------------------------------------------------
File: path.cpp
Purpose: Volume and path object implementation
Notes:

CMsiVolume:
---------------------------------------------------------------------------*/

#include "precomp.h"
#include "path.h"
#include "services.h"
#include "_service.h"  // local factories

#include <stdlib.h> // _MAX_PATH definition
#define _IMAGEHLP_SOURCE_  // prevent import def error
#include "imagehlp.h"
#include "md5.h"
#include <wow64t.h>

extern void MsiDisableTimeout();
extern void MsiEnableTimeout();

// Used by Volume and Path factories to determine the validity of a 
// constructed object
// ----------------------------------------------------------------
enum VolumeStatus { vsInvalid, vsValid };
enum PathStatus   { psInvalid, psValid };


// Used to indicate writable state
// -------------------------------
enum iwsEnum
{
    iwsFalse = 0,  // expression evaluates to False
    iwsTrue  = 1,  // expression evaluates to True
    iwsNone  = 2,  // no expression present
};


// Constants
// ---------
const int iMaxRetries = 5;
const int cchMaxShare = 128;
const int cchMaxComputer = 128;
const int cchMaxFileSys = 64;
const int iFileSystems = 3;

class CMsiVolume;

// Structures used for the static volume list and drive array
// ----------------------------------------------------------
struct vleVolListElem
{
    CMsiVolume* pVolume;
    vleVolListElem* pvleNext;
};

struct daeDriveArrayElem
{
    idtEnum idt;
    CMsiVolume* pVolume;
};


// Win utility functions & macros
// ------------------------------
static ICHAR vrgchDirSep[] = TEXT("\\");
static ICHAR vrgchURLSep[] = TEXT("/");

const int iDriveArraySize  = 26;
const int iServerCacheSize = 30;
#define DRIVE_INDEX(i) (i-'A')

// For dealing with URLs
Bool ExtractURLServer(const ICHAR *szPath, const IMsiString*& rpistrURL, const IMsiString*& rpistrFileSysPart);

ICHAR ExtractDriveLetter(const ICHAR *szPath);
IMsiRecord* ExtractServerInformation(const ICHAR* szPath, const IMsiString*& rpistrServer, const IMsiString*& rpistrFileSysPart);
Bool ParseVersionString(const ICHAR* szVer, DWORD& dwMS, DWORD& dwLS);
idtEnum MsiGetDriveType(const ICHAR* szPath);
idtEnum AdtFromSysDriveType(int iDriveType);

typedef unsigned short uint16;
typedef long            int32;
typedef unsigned long  uint32;

Bool FGetTTFVersion(const ICHAR* szFile, DWORD& rdwMSVer, DWORD& rdwLSVer);
Bool FGetTTFTitle(const ICHAR* szFile, const IMsiString*& rpiTitle);
HANDLE OpenFontFile(const ICHAR* szFile, bool& rfTTCFonts, int& iNumFonts);
bool FTTCSeek(HANDLE hFile, int iFile);
unsigned long GetTTFFieldFromFile(CHandle& hFile, uint16 platformID, uint16 languageID, uint16 nameID, bool fTTCFonts, int cTTFile, CAPITempBufferRef<ICHAR>& rgchNameBuf);
unsigned long UlExtractTTFVersionFromSz( const ICHAR* szBuf );
uint16 GetFontDefaultLangID();

// import file defines

#define SIZE_OF_NT_SIGNATURE    sizeof (DWORD)

// global macros to define header offsets into file
// offset to PE file signature
#define NTSIGNATURE(a) ((void* )((char* )a           +  \
            ((PIMAGE_DOS_HEADER)a)->e_lfanew))

// DOS header identifies the NT PEFile signature dword
// the PEFILE header exists just after that dword
#define PEFHDROFFSET(a) ((void* )((char* )a          +  \
             ((PIMAGE_DOS_HEADER)a)->e_lfanew    +  \
             SIZE_OF_NT_SIGNATURE))

// PE optional header is immediately after PEFile header
#define OPTHDROFFSET(a) ((void* )((char* )a          +  \
             ((PIMAGE_DOS_HEADER)a)->e_lfanew    +  \
             SIZE_OF_NT_SIGNATURE            +  \
             sizeof (IMAGE_FILE_HEADER)))

// section headers are immediately after PE optional header
#define SECHDROFFSET(a) ((void* )((char* )a          +  \
             ((PIMAGE_DOS_HEADER)a)->e_lfanew    +  \
             SIZE_OF_NT_SIGNATURE            +  \
             sizeof (IMAGE_FILE_HEADER)      +  \
             sizeof (IMAGE_OPTIONAL_HEADER)))

inline int NUMOFSECTIONS (void* pFile)
{
    // number os sections is indicated in file header
    return ((int)((PIMAGE_FILE_HEADER)PEFHDROFFSET (pFile))->NumberOfSections);
}

// the import table in the file
typedef struct tagImportDirectory
    {
    DWORD    dwRVAFunctionNameList;
    DWORD    dwUseless1;
    DWORD    dwUseless2;
    DWORD    dwRVAModuleName;
    DWORD    dwRVAFunctionAddressList;
    }IMAGE_IMPORT_MODULE_DIRECTORY, * PIMAGE_IMPORT_MODULE_DIRECTORY;


DWORD MsiForceLastError(DWORD dwAlternative)
{
    // returns GetLastError(), or alternative if GetLastError returns ERROR_SUCCESS
    DWORD dw = GetLastError();
    if(dw == ERROR_SUCCESS)
        dw = dwAlternative;

    return dw;
}


//____________________________________________________________________________
//
// CMsiVolume definition, implementation class for IMsiVolume
//____________________________________________________________________________
 
class CMsiVolume : public IMsiVolume  // class private to this module
{
 public:   // implemented virtual functions
    HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();
    const IMsiString& __stdcall GetMsiStringValue() const;
    int           __stdcall GetIntegerValue() const;
#ifdef USE_OBJECT_POOL
    unsigned int  __stdcall GetUniqueId() const;
    void          __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
    IMsiRecord*   __stdcall InitVolume(const ICHAR* szPath, ICHAR chDrive);
    idtEnum       __stdcall DriveType();
    Bool          __stdcall DiskNotInDrive();
    Bool          __stdcall SupportsLFN();
    UINT64        __stdcall FreeSpace();
    UINT64        __stdcall TotalSpace();
    unsigned int  __stdcall ClusterSize();
    int           __stdcall VolumeID();
    const IMsiString&   __stdcall FileSystem();
    const DWORD         __stdcall FileSystemFlags();
    const IMsiString&   __stdcall VolumeLabel();
    Bool          __stdcall IsUNCServer();
    const IMsiString&   __stdcall UNCServer();
    Bool          __stdcall IsURLServer();
    const IMsiString&   __stdcall URLServer();
    int           __stdcall SerialNum();
    const IMsiString&   __stdcall GetPath();

 public:  // constructor
    CMsiVolume(IMsiServices *piServices);
 protected:
  ~CMsiVolume();  // protected to prevent creation on stack
 public:
    static daeDriveArrayElem s_rgDrive[iDriveArraySize];
    static vleVolListElem*   s_pvleHead;
    static IMsiRecord*       InitDriveList(IMsiServices *piServices);
    static IMsiRecord*       ReInitDriveList();
    static Bool              IsDriveListInit();
    static void              SetDriveListInit(Bool fValue);
    static ICHAR*            s_szServerCache[iServerCacheSize];
    static int               s_iscNext;
    static int               s_iNoDrives;

 protected: 
    IMsiRecord*    SetDriveType();
    IMsiRecord*    SetLFNAndFileSys();
    IMsiRecord*    SetFreeSpaceAndClusterSize();
    IMsiRecord*    SetVolCharacteristics();
    void           SetUNCServer( void );
    VolumeStatus    m_vsStatus;
    Bool            m_fVolCharacteristicsSet;
    Bool            m_fUNCServerSet;
    static Bool     s_fDriveListInit;
    int             m_iRefCnt;  
    int             m_iVolumeID;         // alphabetic volume: A=1, 0 if not mapped
    const IMsiString*     m_pistrUNC;         // UNC server name if applicable 
    const IMsiString*     m_pistrURL;         // URL server name, if applicable. //!!REVIEW:  safe to overload UNCServer?
    MsiString       m_istrVolume;      // current full path  
    IMsiServices*   m_piServices;
    Bool            m_fSupportsLFN;
    UINT64          m_iFreeSpace;
    UINT64          m_iTotalSpace;
    unsigned int    m_iClusterSize;
    idtEnum         m_idtDriveType;
    const IMsiString*     m_pistrFileSystem;
    const IMsiString*     m_pistrVolumeLabel;
    int             m_iSerialNum;
    Bool            m_fNoDiskInDrive;
    Bool            m_fImpersonate;
    DWORD           m_dwFileSystemFlags;

    friend class CEnumAVolume;
 private:
#ifdef USE_OBJECT_POOL
    unsigned int  m_iCacheId;
#endif //USE_OBJECT_POOL
};

//____________________________________________________________________________
//
// CMsiVolume implementation
//____________________________________________________________________________


// static object declarations 
daeDriveArrayElem  CMsiVolume::s_rgDrive[iDriveArraySize];
ICHAR*             CMsiVolume::s_szServerCache[iServerCacheSize];

vleVolListElem*    CMsiVolume::s_pvleHead = 0;
int                CMsiVolume::s_iscNext = 0;
Bool CMsiVolume::s_fDriveListInit = fFalse;
int                CMsiVolume::s_iNoDrives = 0;


void CMsiVolume::SetDriveListInit(Bool fValue)
{
    s_fDriveListInit = fValue;
}

Bool CMsiVolume::IsDriveListInit()
{
    return s_fDriveListInit;
}

const IMsiString& CMsiVolume::GetPath()
{
    return m_istrVolume.Return();
}


Bool CreateMsiVolumeFromLabel(const ICHAR* szLabel, idtEnum idtVolType, IMsiServices* piServices, 
                                     IMsiVolume*& rpiVol)
/*-------------------------------------------------------------------------

---------------------------------------------------------------------------*/
{
    IMsiRecord* pError = 0;
    IMsiVolume* piVolume;
    IEnumMsiVolume& riEnum = piServices->EnumDriveType(idtVolType);
    Bool fLabelMatch = fFalse;
    for (int iMax = 0; fLabelMatch == fFalse && riEnum.Next(1, &piVolume, 0) == S_OK; )
    {
        if (!piVolume->DiskNotInDrive())
        {
            MsiString strCurrLabel(piVolume->VolumeLabel());
            if (strCurrLabel.Compare(iscExactI,szLabel))
            {
                piVolume->AddRef();
                rpiVol = piVolume;
                fLabelMatch = fTrue;
            }
        }
        piVolume->Release();
    }
    riEnum.Release();
    return fLabelMatch;
}


unsigned int HashServerString(const ICHAR* sz)
{
    const int cHashBins = 10;
    ICHAR ch;
    unsigned int iHash = 0;
    int iHashBins = cHashBins;
    int iHashMask = iHashBins - 1;
    while ((ch = *sz++) != 0)
    {
        iHash <<= 1;
        if (iHash & iHashBins)
            iHash -= iHashMask;
        iHash ^= ch;
    }
    return iHash;
}

IMsiRecord* CreateMsiVolume(const ICHAR* szPath, const IMsiString*& rpistrFileSysPart, IMsiServices* piServices, IMsiVolume*& rpiVol)
/*-------------------------------------------------------------------------
 Purpose: This is the volume factory. The drive list is initialized if 
 necessary.If a volume already exists for the supplied path, then rpiVol is 
 set to the existing volume. Otherwise, a new volume is created.
---------------------------------------------------------------------------*/
{
    if (!CMsiVolume::IsDriveListInit())
        CMsiVolume::InitDriveList(piServices);

    MsiString strVolume;
    ICHAR chDrive;
    if ((chDrive = ExtractDriveLetter(szPath)) == 0)
    {   // A non-drive letter path.  See if we've got this path in our cache
        int iHash = HashServerString(szPath);
        for (int x = 0; x < CMsiVolume::s_iscNext  && strVolume.TextSize() == 0; x++)
        {
            int* piCachedHash = (int*) CMsiVolume::s_szServerCache[x];
            ICHAR* szCachedServer = CMsiVolume::s_szServerCache[x] + sizeof(int);
            if (iHash == *piCachedHash && IStrComp(szCachedServer,szPath) == 0)
            {
                ICHAR* szVolumePart = szCachedServer + IStrLen(szCachedServer) + 1;
                ICHAR* szDirPart = szVolumePart + IStrLen(szVolumePart) + 1;
                strVolume = szVolumePart;
                rpistrFileSysPart->SetString(szDirPart,rpistrFileSysPart);
            }
        }

        if (strVolume.TextSize() == 0)
        {
            // Not in the cache.  Break out the server\share (volume) part, and the file system part.  Also, if
            // the server\share is already mapped to a local drive letter, we'll get that letter back in chDrive.
            IMsiRecord* piRec = ExtractServerInformation(szPath, *&strVolume, rpistrFileSysPart);
            if (piRec)
                return piRec;

            // If the server\share wasn't mapped to a drive, throw the volume path into the cache for next time.
            if (chDrive == 0 && CMsiVolume::s_iscNext < iServerCacheSize)
            {
                int iServerLen = sizeof(int) + IStrLen(szPath) + 1 + strVolume.TextSize() + 1 + rpistrFileSysPart->TextSize() + 1;
                CMsiVolume::s_szServerCache[CMsiVolume::s_iscNext] = new ICHAR[iServerLen];
                if ( CMsiVolume::s_szServerCache[CMsiVolume::s_iscNext] )
                {
                    int* piCachedHash = (int*) CMsiVolume::s_szServerCache[CMsiVolume::s_iscNext];
                    *piCachedHash = iHash;
                    ICHAR* sz = CMsiVolume::s_szServerCache[CMsiVolume::s_iscNext] + sizeof(int);
                    ICHAR* szEnd = CMsiVolume::s_szServerCache[CMsiVolume::s_iscNext] + iServerLen;
                    StringCchCopy(sz, (szEnd - sz), szPath);
                    sz += IStrLen(szPath) + 1;
                    StringCchCopy(sz, (szEnd - sz), strVolume);
                    sz += strVolume.TextSize() + 1;
                    StringCchCopy(sz, (szEnd - sz), rpistrFileSysPart->GetString());
                    CMsiVolume::s_iscNext++;
                }
            }
        }

        // If we didn't locate a drive already mapped for this path, look in the unmapped volume object
        // cache to see if a volume object has already been created for this path.
        if (chDrive == 0)
        {
            for (vleVolListElem* pvle = CMsiVolume::s_pvleHead; pvle; pvle = pvle->pvleNext)
            {
                if (pvle->pVolume->IsUNCServer())
                {
                    MsiString strUNCServer = pvle->pVolume->UNCServer();
                    if (strVolume.Compare(iscExactI, strUNCServer)) 
                    {
                        pvle->pVolume->AddRef();
                        rpiVol = pvle->pVolume;
                        return 0;
                    }
                }
            }
        }
    }

    if (chDrive != 0)
    {
        if (strVolume.TextSize() == 0)
        {
            Assert(rpistrFileSysPart->TextSize() == 0);
            rpistrFileSysPart = &CreateString();
            rpistrFileSysPart->SetString(szPath,rpistrFileSysPart);
            strVolume = rpistrFileSysPart->Extract(iseFirst,2);
            rpistrFileSysPart->Remove(iseFirst,2,rpistrFileSysPart);
        }
        if (CMsiVolume::s_rgDrive[DRIVE_INDEX(chDrive)].pVolume)     //Check for existing volume with given drive letter
        {
            CMsiVolume::s_rgDrive[DRIVE_INDEX(chDrive)].pVolume->AddRef();
            rpiVol = CMsiVolume::s_rgDrive[DRIVE_INDEX(chDrive)].pVolume;
            return 0;
        }
    }

    CMsiVolume* pVolume = new CMsiVolume(piServices);                //we need a new volume
    IMsiRecord* piError = 0;
    if ( ! pVolume )
        piError = PostError(Imsg(idbgErrorOutOfMemory));
    else
        piError = pVolume->InitVolume(strVolume, chDrive);
    
    if (piError)
    {
        pVolume->Release();
        return piError; 
    }
    else
    {
        if (chDrive > 0)
        {
            CMsiVolume::s_rgDrive[chDrive-'A'].pVolume = pVolume;  
            CMsiVolume::s_rgDrive[chDrive-'A'].idt = pVolume->DriveType();
            CMsiVolume::s_rgDrive[chDrive-'A'].pVolume->AddRef();
            rpiVol = pVolume;
        }
        else
        {
            vleVolListElem* pvle = new vleVolListElem;
            if ( ! pvle ) 
                return PostError(Imsg(idbgErrorOutOfMemory));
            pvle->pVolume = pVolume;
            pvle->pvleNext = CMsiVolume::s_pvleHead;
            CMsiVolume::s_pvleHead = pvle;
            pVolume->AddRef();  // the list owns a ref count to lock down its volume pointer
            rpiVol =  pVolume;
        }
        return 0;
    }

}

IMsiRecord* CreateMsiVolume(const ICHAR* szPath, IMsiServices* piServices, IMsiVolume*& rpiVol)
/*-------------------------------------------------------------------------
 Purpose: This is the volume factory. The drive list is initialized if 
 necessary.If a volume already exists for the supplied path, then rpiVol is 
 set to the existing volume. Otherwise, a new volume is created.
---------------------------------------------------------------------------*/
{
    MsiString strFileSysPart;
    return CreateMsiVolume(szPath, *&strFileSysPart, piServices, rpiVol);
}


IMsiRecord* CMsiVolume::InitDriveList(IMsiServices* piServices)
/*-------------------------------------------------------------------------
Purpose: Initialize the static drive list with the drive type of each 
    available drive.
---------------------------------------------------------------------------*/
{
    // PERF: we may end up calling MsiGetDriveType for many unmapped drives
    //       we could call GetLogicalDrives first, but both APIs are just as quick to do
    //       nothing for unmapped drives.  there isn't a big perf win there.

    if (s_fDriveListInit)
        return 0;
    s_fDriveListInit = fTrue;
    ICHAR szDriveLetter[5];

    for (int iDrive = 0; iDrive < iDriveArraySize; iDrive++)
    {
        s_rgDrive[iDrive].pVolume = 0;
        StringCchPrintf(szDriveLetter, (sizeof(szDriveLetter)/sizeof(ICHAR)), TEXT("%c:%c"), iDrive+'A', chDirSep);

        s_rgDrive[iDrive].idt = MsiGetDriveType(szDriveLetter);
    }

    // Cache the "NoDrives" System Policy (an integer, of which the low 26 bits
    // represent drives A-Z.  For any bit that's set, that drive is disabled and
    // should be made invisible to the user).
    PMsiRegKey pCurrentUser = &piServices->GetRootKey(rrkCurrentUser, ibtCommon);//same location 32/64 bit arch
    PMsiRegKey pPolicyKey = &pCurrentUser->CreateChild(MsiString(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer")));
    MsiString strNoDrives;
    PMsiRecord(pPolicyKey->GetValue(TEXT("NoDrives"),*&strNoDrives));
    if (strNoDrives.TextSize() && strNoDrives.Compare(iscStart,TEXT("#")))
    {
        strNoDrives.Remove(iseFirst,1);
        s_iNoDrives = strNoDrives;
    }
    return 0;
}


IMsiRecord* CMsiVolume::ReInitDriveList()
/*-------------------------------------------------------------------------
Purpose: Re-initialize the static drive list with the drive type of each 
    available drive, to pick up any drives that have been connected since
    the drive list was last initialized.
---------------------------------------------------------------------------*/
{
    ICHAR szDriveLetter[5];

    idtEnum idtDriveType;
    for (int iDrive = 0; iDrive < iDriveArraySize; iDrive++)
    {
        StringCchPrintf(szDriveLetter, (sizeof(szDriveLetter)/sizeof(ICHAR)), TEXT("%c:%c"), iDrive+'A', chDirSep);
        idtDriveType = MsiGetDriveType(szDriveLetter);
        if (idtDriveType == idtUnknown)
        {
            s_rgDrive[iDrive].idt = idtUnknown;
            if (s_rgDrive[iDrive].pVolume != 0)
            {
                s_rgDrive[iDrive].pVolume->Release();
                s_rgDrive[iDrive].pVolume = 0;
            }
        }
        else
            s_rgDrive[iDrive].idt = idtDriveType;
    }
    return 0;
}


void DestroyMsiVolumeList(bool fFatal)
/*-------------------------------------------------------------------------
Purpose: Release any volumes remaining in the drive list.

  Note: since the services object's destructor makes a call to us, we
  have to make sure that we do not allow ourselves to be reentrant. 
  Otherwise we will try to release pVolume a second time before we
  set it to zero and we will die.

  Note also that this should have been a static function of the volume
  object. It isn't, apparently because the services just knows about 
  the IMsiVolume interface, so this was presumably made a global function 
  instead of a static member to get around our interface scheme.
---------------------------------------------------------------------------*/
{
    static Bool fDeathAndDestruction = fFalse;

    if (fDeathAndDestruction)
        return;
    
    if (!CMsiVolume::IsDriveListInit())
        return;
    
    fDeathAndDestruction = fTrue;

    for (int iDrive = 0; iDrive < iDriveArraySize; iDrive++)
    {
        if (CMsiVolume::s_rgDrive[iDrive].pVolume)
        {
            if (!fFatal)
                CMsiVolume::s_rgDrive[iDrive].pVolume->Release();
            CMsiVolume::s_rgDrive[iDrive].pVolume = 0;
        }
    }

    if (!fFatal)
    {
        for (int x = 0; x < CMsiVolume::s_iscNext; x++)
        {
            delete CMsiVolume::s_szServerCache[x];
        }
    }
    CMsiVolume::s_iscNext = 0;

    if (fFatal)
        CMsiVolume::s_pvleHead = 0;
    else
    {
        vleVolListElem* pVolLink;
        while ((pVolLink = CMsiVolume::s_pvleHead) != 0)
        {
            vleVolListElem* pvleNext = pVolLink->pvleNext;
            pVolLink->pVolume->Release();
            CMsiVolume::s_pvleHead = pvleNext;
            delete pVolLink;
        }
    }
    
    CMsiVolume::SetDriveListInit(fFalse);

    fDeathAndDestruction = fFalse;

    return;
}

CMsiVolume::CMsiVolume(IMsiServices* piServices)
    :  m_pistrUNC(0), m_pistrURL(0), m_iVolumeID(0), m_piServices(piServices), m_vsStatus(vsInvalid), 
    m_pistrFileSystem(0), m_fVolCharacteristicsSet(fFalse), m_fUNCServerSet(fFalse), m_iSerialNum(0),
    m_pistrVolumeLabel(0)
/*-------------------------------------------------------------------------
Construct a CMsiVolume. Note that InitVolume must be called to put the 
Volume into a valid state.
---------------------------------------------------------------------------*/
{
    m_iRefCnt = 1;     // we're returning an interface, passing ownership
    Assert(piServices);
    piServices->AddRef();
    m_fImpersonate = fFalse;
    m_pistrUNC = &CreateString();
    m_pistrURL = &CreateString();
#ifdef USE_OBJECT_POOL
    m_iCacheId = 0;
#endif // USE_OBJECT_POOL

}

CMsiVolume::~CMsiVolume()
{
    if (m_pistrUNC)
        m_pistrUNC->Release();
    if (m_pistrURL)
        m_pistrURL->Release();
    if (m_pistrFileSystem)
        m_pistrFileSystem->Release();
    if (m_pistrVolumeLabel)
        m_pistrVolumeLabel->Release();
    RemoveObjectData(m_iCacheId);
}

extern bool RunningAsLocalSystem();
    
IMsiRecord* CMsiVolume::InitVolume(const ICHAR* szPath, ICHAR chDrive)
/*-------------------------------------------------------------------------
Purpose: Initializes a volume. A volume is not in a valid state until this
function is successfully completed. Sets the volumes's UNC, path, and drive
type.  The iVolumeID parameter represents the drive letter of the volume. 
If iVolumeID is 0, szPath represents a UNC (non-drive-letter) path, or a URL
---------------------------------------------------------------------------*/
{
    IMsiRecord *piRec;
    m_fNoDiskInDrive = fFalse;
    m_fImpersonate = (RunningAsLocalSystem()) ? fTrue : fFalse;
    m_istrVolume = szPath;
    
    m_fSupportsLFN = fFalse;
    m_iFreeSpace = 0;
    m_iTotalSpace = 0;
    m_iClusterSize = 1;
    m_dwFileSystemFlags = 0;

	bool fFileUrl = false;
    
    if (chDrive == 0)
    {
        if (IsURL(szPath, fFileUrl))
        {
            m_pistrURL->SetString(szPath, m_pistrURL);
        }
        else
        {
            m_pistrUNC->SetString(szPath,m_pistrUNC);
        }
        m_idtDriveType = idtRemote;

    }
    else
    {
        m_iVolumeID = chDrive - 'A' + 1;
        if((piRec = SetDriveType()) != 0)
        {
            m_vsStatus = vsInvalid;
            return piRec;
        }
    }

    m_vsStatus = vsValid;
    return 0;
}



IMsiRecord* CMsiVolume::SetVolCharacteristics()
/*-------------------------------------------------------------------------
Purpose: Sets the volume's long file name status, file system type, 
free space, and cluster size.
---------------------------------------------------------------------------*/
{
    IMsiRecord* piRec;
    
    if((piRec = SetLFNAndFileSys()) != 0)
        return piRec;

    if (!m_fNoDiskInDrive)
    {
        if ((piRec = SetFreeSpaceAndClusterSize()) != 0)
            return piRec;
        m_fVolCharacteristicsSet = fTrue;
    }
    return 0;
}

int CMsiVolume::SerialNum()
{
    if (!m_fVolCharacteristicsSet)
        PMsiRecord pRec(SetVolCharacteristics());
    return m_iSerialNum;    
}

idtEnum CMsiVolume::DriveType() 
{
    return m_idtDriveType;
}

Bool CMsiVolume::DiskNotInDrive()
{
    // Need to check characteristics again
    // to see if the disk is still in the drive
    m_fVolCharacteristicsSet = fFalse;
    PMsiRecord pRec(SetVolCharacteristics());
    return m_fNoDiskInDrive;
}

void CMsiVolume::SetUNCServer( void )
{
    m_fUNCServerSet = fTrue;
    if (m_pistrUNC->TextSize() == 0 && m_idtDriveType == idtRemote)
    {
        if (g_scServerContext == scService)
            AssertNonZero(StartImpersonating());
    
        ICHAR szRemotePath[MAX_PATH+1];
        DWORD cchRemotePath = sizeof(szRemotePath)/sizeof(ICHAR);

        if (MPR::WNetGetConnection(m_istrVolume, szRemotePath, &cchRemotePath) == NO_ERROR)
        {
            m_pistrUNC->SetString(szRemotePath, m_pistrUNC);
        }

        if (g_scServerContext == scService)
            StopImpersonating();
    }
}

const IMsiString& CMsiVolume::UNCServer()
{
    if (!m_fUNCServerSet)
        SetUNCServer();

    m_pistrUNC->AddRef();
    return *m_pistrUNC;
}

Bool CMsiVolume::IsUNCServer()
{
    if (!m_fUNCServerSet)
        SetUNCServer();

    return m_pistrUNC->TextSize() > 0 ? fTrue : fFalse;
}

const IMsiString& CMsiVolume::URLServer()
{
    m_pistrURL->AddRef();
    return *m_pistrURL;
}

Bool CMsiVolume::IsURLServer()
{
    return m_pistrURL->TextSize() > 0 ? fTrue : fFalse;
}

Bool CMsiVolume::SupportsLFN() 
{
    if (!m_fVolCharacteristicsSet)
        PMsiRecord pRec(SetVolCharacteristics());

    return m_fSupportsLFN;
}

UINT64 CMsiVolume::FreeSpace()  
{
    PMsiRecord pRec = SetFreeSpaceAndClusterSize();
    //if (!m_fVolCharacteristicsSet)
    //  PMsiRecord pRec(SetVolCharacteristics());
    return m_iFreeSpace;
}

UINT64 CMsiVolume::TotalSpace()  
{
    if (!m_fVolCharacteristicsSet)
        PMsiRecord pRec(SetVolCharacteristics());
    return m_iTotalSpace;
}

unsigned int  CMsiVolume::ClusterSize() 
{
    if (!m_fVolCharacteristicsSet)
        PMsiRecord pRec(SetVolCharacteristics());
    return m_iClusterSize;
}

int CMsiVolume::VolumeID() 
{
    return m_iVolumeID;
}

const IMsiString& CMsiVolume::FileSystem() 
{
    if (!m_fVolCharacteristicsSet)
        PMsiRecord pRec(SetVolCharacteristics());
    m_pistrFileSystem->AddRef();
    return *m_pistrFileSystem;
}

const IMsiString& CMsiVolume::VolumeLabel()
{
    if (!m_fVolCharacteristicsSet)
        PMsiRecord pRec(SetVolCharacteristics());
    m_pistrVolumeLabel->AddRef();
    return *m_pistrVolumeLabel;
}

const DWORD CMsiVolume::FileSystemFlags()
{
    if (!m_fVolCharacteristicsSet)
        PMsiRecord pRec(SetVolCharacteristics());
    return m_dwFileSystemFlags;
}

ICHAR ExtractDriveLetter(const ICHAR *szPath)
/*-------------------------------------------------------------------------
Given a path returns the valid drive letter if one exists in the path, 
otherwise returns 0.
---------------------------------------------------------------------------*/
{
    ICHAR *pchColon, chDrive;

    pchColon = ICharNext(szPath);
    if (*pchColon != ':')
        return 0;

    chDrive = *szPath;
    if ( (chDrive >= 'A') && (chDrive <= 'Z') )
        0;
    else if ( (chDrive >= 'a') && (chDrive <= 'z'))
        chDrive = char(chDrive + ('A' - 'a'));
    else
        chDrive = 0;
    
    return chDrive;
}


Bool ExtractURLServer(const ICHAR *szPath, const IMsiString*& rpistrURL, const IMsiString*& rpistrFileSysPart)
{
    Assert(szPath);
    ICHAR* pchPath = (ICHAR*) szPath;

    // guaranteed to contain at least 2 separators, based on the strings
    // in starts.  http://
    // Extract to the end of string, or just before the 3rd separator.
    //  Input:   http://www.microsoft.com/foo
    // Input:   http://www.microsoft.com
    // Results: http://www.microsoft.com
    int cSeparators = 0;
    do
    {
        pchPath = ICharNext(pchPath);
        if (*pchPath == chURLSep)
            cSeparators++;
    }while (*pchPath && cSeparators < 3);

    if (cSeparators < 2)
        return fFalse;

    Assert((cSeparators == 2) || (cSeparators == 3));
    rpistrURL = &CreateString();
    rpistrFileSysPart = &CreateString();
    rpistrURL->SetString(szPath, rpistrURL);
    if (cSeparators == 3)
    {
        MsiString strPath(pchPath);
        int iFileSysPartLen = strPath.CharacterCount();
        rpistrURL->Remove(iseLast,iFileSysPartLen, rpistrURL);
        rpistrFileSysPart->SetString(pchPath, rpistrFileSysPart);
    }
    return fTrue;
}


IMsiRecord* ExtractServerInformation(const ICHAR* szPath, const IMsiString*& rpistrServer, const IMsiString*& rpistrFileSysPart)
/*-------------------------------------------------------------------------
Purpose: Given a non-drive-letter path, return a network server\share name
in the rpistrServer parameter, and the remaining file system (directory)
part in the rpistrFileSysPart parameter.  The network type identifier
(one of WNNC_NET_* enum values) will be returned in the pdwNetType parameter.
---------------------------------------------------------------------------*/
{
    // A bug in Win95 causes WNetGetResourceInformation to return the
    // wrong required buffer size back if the buffer passed in is too
    // small.  Workaround is to make our initial buffer size large
    // Win95 developers tell us this won't be fixed, so we'll stick
    // with the workaround.
    #define WNGRI_BUF_SIZE  1024
    MsiString strPath = szPath;
    if (strPath.Compare(iscEnd,vrgchDirSep))
        strPath.Remove(iseLast,1);
    if (strPath.Compare(iscEnd, vrgchURLSep))
        strPath.Remove(iseLast,1);

    rpistrServer = &CreateString();

	bool fFileUrl = false;
    if (IsURL(szPath, fFileUrl))
    {
        if (!ExtractURLServer(szPath, rpistrServer, rpistrFileSysPart))
            return PostError(Imsg(imsgPathNotAccessible), szPath);
        return 0;
    }

    rpistrServer->SetString(strPath, rpistrServer);

    // Call WNetGetResourceInformation to split the path into a \\server\share
    // part, and the directory part (if any).
    NETRESOURCE netResource;
    netResource.dwScope = RESOURCE_GLOBALNET;
    netResource.lpRemoteName = (ICHAR*) rpistrServer->GetString();
    netResource.lpProvider = 0;
    netResource.dwType = RESOURCETYPE_DISK;
    netResource.dwDisplayType = NULL;
    netResource.dwUsage = RESOURCEUSAGE_CONNECTABLE;
    unsigned long iBufSize = WNGRI_BUF_SIZE;
    CTempBuffer<ICHAR,1> rgNetBuffer(WNGRI_BUF_SIZE);
    LPTSTR lpFileSysPart;

    if (g_scServerContext == scService)
        AssertNonZero(StartImpersonating());
    MsiDisableTimeout();
    DWORD dwErr = MPR::WNetGetResourceInformation(&netResource, rgNetBuffer, &iBufSize, &lpFileSysPart);
    if (dwErr == ERROR_MORE_DATA)
    {
        rgNetBuffer.SetSize(iBufSize);
        dwErr = MPR::WNetGetResourceInformation(&netResource, rgNetBuffer, &iBufSize, &lpFileSysPart);      
        Assert(dwErr != ERROR_MORE_DATA);
    }
    MsiEnableTimeout();
    if (g_scServerContext == scService)
        StopImpersonating();
    if (dwErr != NO_ERROR)
        return PostError(Imsg(imsgPathNotAccessible), szPath);

    NETRESOURCE* pNewNetResource = (NETRESOURCE*) (ICHAR*) rgNetBuffer;
    rpistrFileSysPart = &CreateString();

    // On Banyan Vines (and possibly others), if the file system part of the UNC path is empty,
    // WNetGetResourceInformation forgets to initialize lpFileSysPart (it's supposed to point to
    // a location somewhere within the returned rgNetBuffer, but instead points to random memory).
    bool fValidFileSysPart = false;
    if (lpFileSysPart >= (ICHAR*) pNewNetResource && (lpFileSysPart <= (ICHAR*) pNewNetResource + iBufSize))
        fValidFileSysPart = true;

    // If file system part isn't empty, we've got a Win9x NetWare bug to work around (bug 6481). On
    // that platform, the NetWare client mangles the UNC path, and WNetGetResourceInformation returns the
    // mangled part in pNewNetResource->lpRemoteName, and the unmangled UNC pathname in lpFileSysPart - it
    // never succeeds in actually splitting the path.  Below, we'll check lpFileSysPart - if it begins
    // with two backslashes, below we'll do the split ourselves at the 4th backslash (if we find it), or at
    // the end of the path if there's only 3 slashes.
    if (fValidFileSysPart)
    {
        ICHAR* pchPath = (ICHAR*) lpFileSysPart;
        if (*pchPath == chDirSep)
        {
            pchPath = ICharNext(pchPath);
            if (*pchPath == chDirSep)
            {
                fValidFileSysPart = false;
            }
        }
    }

    // Another Banyan Vines bug (6837) - On Vines, WNetGetResourceInformation succeeds, validating the
    // path, but doesn't split the path, and never returns anything in lpFileSysPart (argh!).  In
    // this case, we'll pull the same trick as for NetWare - split the path ourselves if it contains
    // more than 3 backslashes.
    if (!fValidFileSysPart)
    {
        int cSeparators = 1;
        ICHAR* pchPath = pNewNetResource->lpRemoteName;
        Assert(*pchPath == chDirSep);
        do
        {
            pchPath = ICharNext(pchPath);
            if (*pchPath == chDirSep)
                cSeparators++;
        }while (*pchPath && cSeparators < 4);
        if (cSeparators >= 3)
        {
            rpistrFileSysPart->SetString(pchPath, rpistrFileSysPart);
            *pchPath = NULL;
            rpistrServer->SetString(pNewNetResource->lpRemoteName, rpistrServer);
            return 0;
        }
    }

    rpistrServer->SetString(pNewNetResource->lpRemoteName, rpistrServer);
    if (fValidFileSysPart)
        rpistrFileSysPart->SetString(lpFileSysPart,rpistrFileSysPart);

    return 0;
}



HRESULT CMsiVolume::QueryInterface(const IID& riid, void** ppvObj)
{
    if (MsGuidEqual(riid, IID_IUnknown) || MsGuidEqual(riid, IID_IMsiVolume))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    *ppvObj = 0;
    return E_NOINTERFACE;
}

unsigned long CMsiVolume::AddRef()
{
    return ++m_iRefCnt;
}

unsigned long CMsiVolume::Release()
{
    if (--m_iRefCnt != 0)
        return m_iRefCnt;

    IMsiServices* piServices = m_piServices;
    delete this;
    piServices->Release();
    return 0;
}

const IMsiString& CMsiVolume::GetMsiStringValue() const
{
    return g_MsiStringNull;
}

int CMsiVolume::GetIntegerValue() const
{
    return 0;
}

#ifdef USE_OBJECT_POOL
unsigned int CMsiVolume::GetUniqueId() const
{
    return m_iCacheId;
}

void CMsiVolume::SetUniqueId(unsigned int id)
{
    Assert(m_iCacheId == 0);
    m_iCacheId = id;
}
#endif //USE_OBJECT_POOL

idtEnum AdtFromSysDriveType(int iDriveType)
/*-------------------------------------------------------------------------
Given a Windows API drive type, return a corresponding idtEnum
--------------------------------------------------------------------------*/
{
    switch (iDriveType)
    {
        case DRIVE_REMOVABLE:
            return idtRemovable;
            break;
        case DRIVE_FIXED:
            return idtFixed;
            break;
        case DRIVE_REMOTE:
            return idtRemote;
            break;
        case DRIVE_CDROM:
            return idtCDROM;
            break;
        case DRIVE_RAMDISK:
            return idtRAMDisk;
            break;
        default:
            return idtUnknown;
    }
}


IMsiRecord* CMsiVolume::SetDriveType()
//----------------------------------
{   
    //Create a string pointing to the root directory of the volume  
    MsiString istrRoot = m_istrVolume;
    if (!IsURLServer())
        istrRoot += vrgchDirSep;
    else
        istrRoot += vrgchURLSep;

    idtEnum idtDriveType = MsiGetDriveType(istrRoot);
    if (idtDriveType == idtUnknown)
    {
        m_vsStatus = vsInvalid;
        return PostError(Imsg(imsgInvalidDrive), *istrRoot);
    }
    else
    {
        m_idtDriveType = idtDriveType;
        return 0;
    }
}


idtEnum MsiGetDriveType(const ICHAR* szPath)
/*---------------------------------------------------------------
Internal version of WIN::GetDriveType that tries to get the drive
type without impersonation, and if that fails, impersonates and
tries again.  If that still fails, it gives up and returns
DRIVE_UNKNOWN or DRIVE_NO_ROOT_DIR.
-----------------------------------------------------------------*/
{
    unsigned int uiResult;

	bool fFileUrl = false;
    
    // we'll pretend to be a remote/read-only drive.
    if (IsURL(szPath, fFileUrl))
        return idtRemote;

    // first, try without impersonating
    uiResult = WIN::GetDriveType(szPath);
    if (uiResult == DRIVE_UNKNOWN || uiResult == DRIVE_NO_ROOT_DIR)
    {
        // now, try with impersonating
        AssertNonZero(StartImpersonating());
        uiResult = WIN::GetDriveType(szPath);
        StopImpersonating();
    }

    // Temp: test only
    //if (szPath[0] == 'd' || szPath[0] == 'D')
    //  uiResult = DRIVE_REMOVABLE;

    return AdtFromSysDriveType(uiResult);
}

bool FDriveTypeRequiresImpersonation(idtEnum idt)
{
    switch (idt)
    {
    case idtCDROM:
    case idtRemote:
    case idtRemovable:
        return true;
    default:
        return false;
    }
}


idtEnum MsiGetPathDriveType(const ICHAR *szPath, bool fReturnUnknownAsNetwork)
// Given a full path, returns the drive type.  If fReturnUnknownAsNetwork is true,
// an unknown drive type will be treated as a network volume.
{
    ICHAR chDrive;
    unsigned int uiResult;
    
    if ((chDrive = ExtractDriveLetter(szPath)) != 0)    // Check for istrVolPath == DRIVE:[\PATH]
    {
        ICHAR szPath[] = TEXT("A:\\");

        szPath[0] = chDrive;
        
        // first, try without impersonating
        uiResult = WIN::GetDriveType(szPath);
        if (fReturnUnknownAsNetwork && (uiResult == DRIVE_UNKNOWN || uiResult == DRIVE_NO_ROOT_DIR))
        {
            // Generally we'd try with impersonation here, but since we might
            // not have the message context initialized, and the cases this would
            // happen and not be from a network drive is rare, we're just going
            // to assume 
            return idtRemote;
        }

        return AdtFromSysDriveType(uiResult);
    }

    return idtRemote;

}

bool FVolumeRequiresImpersonation(IMsiVolume& riVolume)
{
    return FDriveTypeRequiresImpersonation(riVolume.DriveType());
}

bool GetImpersonationFromPath(const ICHAR* szPath)
{
    return FDriveTypeRequiresImpersonation(MsiGetPathDriveType(szPath, true));
}


IMsiRecord* CMsiVolume::SetLFNAndFileSys()
/*-------------------------------------------------------------------------
Sets the volume's long file name status and file system type. These two
characteristics are grouped together for efficiency. Both use the same
API call.
--------------------------------------------------------------------------*/
{
    ICHAR szVolumeLabel[256];
    m_fNoDiskInDrive = fFalse;
    if (m_pistrVolumeLabel)
        m_pistrVolumeLabel->Release();
    m_pistrVolumeLabel = &CreateString();

    //Create a string pointing to the root directory of the volume  
    MsiString istrRoot;
    Bool fIsUNC = IsUNCServer();
    BOOL fResult = FALSE;
    DWORD maxFileComponentLen = 0;
    ICHAR szFileSys[cchMaxFileSys+1];
    DWORD dwLastError = ERROR_SUCCESS;

    // First, call GetVolumeInformation with the drive letter (to avoid problems with 3rd party
    // networks that don't like UNC paths here - bug 6913).  If that fails, try again with the UNC
    // path (if any), to handle problems with disconnected mapped drives (bug 3977).
    for (int i = 0; i <= 1; i++)
    {
        if (i > 0)
        {
            Assert(fIsUNC);
            istrRoot = m_pistrUNC->GetString();
            istrRoot += vrgchDirSep;
        }
        else
            istrRoot = m_istrVolume + vrgchDirSep;
        
        // current error mode should include SEM_FAILCRITICALERRORS at this point to
        // prevent unnecessary pop-ups from the OS
        if (m_fImpersonate)
            AssertNonZero(StartImpersonating());
        fResult = WIN::GetVolumeInformation((const ICHAR*)(istrRoot),szVolumeLabel,255,(DWORD*)&m_iSerialNum,
         (DWORD*)&maxFileComponentLen,&m_dwFileSystemFlags,szFileSys,cchMaxFileSys);
        if ( !fResult )
            dwLastError = WIN::GetLastError();
        if (m_fImpersonate)
            StopImpersonating();

        if (fResult || (!fResult && !fIsUNC))
            break;      
    }

    //  Only for testing of bug 5382
    //  if (istrRoot.Compare(iscStartI,TEXT("D")))
    //      maxFileComponentLen = 12;

    idtEnum idtDriveType = DriveType();
    if (fResult == FALSE && (idtDriveType == idtRemovable || idtDriveType == idtCDROM)
        && dwLastError == ERROR_NOT_READY)
    {
        m_fNoDiskInDrive = fTrue;
        return 0;
    }
    else if (fResult == FALSE)
    {
        m_vsStatus = vsInvalid;
        return PostError(Imsg(idbgErrorGettingVolInfo), dwLastError, istrRoot);
    }

    // If the system says long filenames aren't supported, OR the volume itself
    // doesn't support them, then we won't use them.
    if (g_fShortFileNames || maxFileComponentLen <= 12)
        m_fSupportsLFN = fFalse;
    else
        m_fSupportsLFN = fTrue;
    

    if (m_pistrFileSystem)
        m_pistrFileSystem->Release();
    m_pistrFileSystem = &CreateString();
    m_pistrFileSystem->SetString(szFileSys, m_pistrFileSystem);
    m_pistrVolumeLabel->SetString(szVolumeLabel,m_pistrVolumeLabel);

    return 0;
}

Bool RunningWin95Release2()
{
    OSVERSIONINFO osVersionInfo;
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    BOOL fResult = GetVersionEx(&osVersionInfo);
    if (fResult)
    {
        if (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS &&
            LOWORD(osVersionInfo.dwBuildNumber) > 1000)
        {
            return fTrue;
        }
    }
    return fFalse;
}


bool MsiGetDiskFreeSpace(const ICHAR* szRoot,
                         UINT64& uiFreeSpace,
                         UINT64& uiTotalSpace,
                         unsigned int& uiClusterSize,
                         idtEnum idtDriveType,
                         Bool fImpersonate)
/*-------------------------------------------------------------------------------------------
Internal routine that calls either GetDiskFreeSpace or GetDiskFreeSpaceEx, based on platform.
---------------------------------------------------------------------------------------------*/
{
    BOOL fResult;
    bool fValidFreeSpace = false, fValidClusterSize = false, fHaveValidClusterSize = false;

    if (uiClusterSize > 1)
        fHaveValidClusterSize = true;
        
    uiFreeSpace = 0;
    uiTotalSpace = 0;
    // If we are running Win95 Service Release 2 or better, then we must call GetDiskFreeSpaceEx in
    // order to get accurate disk space values.  Unfortunately, GetDiskFreeSpaceEx doesn't give
    // us the disk cluster size, so we still need to call GetDiskFreeSpace as well to get that info!
    if (!g_fWin9X || RunningWin95Release2())
    {
#ifdef UNICODE
        const char* szGetDiskFreeSpaceEx = "GetDiskFreeSpaceExW";
#else
        const char* szGetDiskFreeSpaceEx = "GetDiskFreeSpaceExA";
#endif
        typedef BOOL (__stdcall *PFnGetDiskFreeSpaceEx)(LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);
        HINSTANCE hLib = WIN::LoadLibrary(TEXT("KERNEL32.DLL"));
        if (hLib)
        {
            PFnGetDiskFreeSpaceEx pfnGetDiskFreeSpaceEx;
            pfnGetDiskFreeSpaceEx = (PFnGetDiskFreeSpaceEx) GetProcAddress(hLib,szGetDiskFreeSpaceEx);
            if (pfnGetDiskFreeSpaceEx)
            {
                // current error mode should include SEM_FAILCRITICALERRORS at this point to
                // prevent unnecessary pop-ups from the OS
                ULARGE_INTEGER liFreeBytesAvailableToCaller,liTotalNumberOfBytes,liTotalNumberOfFreeBytes;
                if (fImpersonate)
                    AssertNonZero(StartImpersonating());
                BOOL fResult = pfnGetDiskFreeSpaceEx(szRoot,&liFreeBytesAvailableToCaller,&liTotalNumberOfBytes,
                                            &liTotalNumberOfFreeBytes);
                if (fImpersonate)
                    StopImpersonating();

                if (!fResult) return false;
                if(!g_fWin9X && idtDriveType != idtRemote && g_fRunScriptElevated)
                {
                    uiFreeSpace = (UINT64)(liTotalNumberOfFreeBytes.QuadPart / iMsiMinClusterSize);
                }
                else
                {
                    uiFreeSpace = (UINT64)(liFreeBytesAvailableToCaller.QuadPart / iMsiMinClusterSize);
                }
                uiTotalSpace = (UINT64)(liTotalNumberOfBytes.QuadPart / iMsiMinClusterSize);
                fValidFreeSpace = true;
            }
            else
            {
                WIN::FreeLibrary(hLib);
                return false;
            }
            WIN::FreeLibrary(hLib);
        }
        else 
            return false;
    }

    DWORD dwFreeClusters, dwSectorsPerCluster, dwBytesPerSector, dwTotalClusters;
    if (fImpersonate)
        AssertNonZero(StartImpersonating());
    // current error mode should include SEM_FAILCRITICALERRORS at this point to
    // prevent unnecessary pop-ups from the OS
    fResult = WIN::GetDiskFreeSpace(szRoot,(DWORD*)&dwSectorsPerCluster,
        (DWORD*)&dwBytesPerSector, (DWORD*)&dwFreeClusters, (DWORD*)&dwTotalClusters);
    if (fImpersonate)
        StopImpersonating();
    if (fResult == fTrue)
    {
        fValidFreeSpace = true;
        fValidClusterSize = true;
    }
    else if (!fValidFreeSpace || (!fValidClusterSize && !fHaveValidClusterSize))
    {
        // A bug in GetDiskFreeSpace under Windows 95 (PSS ID Number: Q137230) causes
        // failure when UNC pathnames are used.  In this case, we need to temporarily
        // map that remote volume to an unused local drive letter, then call 
        // GetDiskFreeSpace again.
        if (WIN::GetLastError() == ERROR_NOT_SUPPORTED && idtDriveType == idtRemote)
        {
            ICHAR rgchDrive[5];
            ICHAR rgchNetDrive[5];
            ICHAR rgchRemoteUNCName[_MAX_PATH];
            *rgchDrive = 0;
            *rgchNetDrive = 0;
            *rgchRemoteUNCName = 0;
            for (int iDrive = 25; iDrive >= 0 && *rgchDrive == 0;iDrive--)
            {
                StringCchPrintf(rgchDrive,(sizeof(rgchDrive)/sizeof(ICHAR)), TEXT("%c:%c"),iDrive + 'A',chDirSep);
                idtEnum idtDriveType = MsiGetDriveType(rgchDrive);
                if (*rgchNetDrive == 0 && idtDriveType == idtRemote)
                    StringCchCopy(rgchNetDrive, sizeof(rgchNetDrive)/sizeof(ICHAR), rgchDrive);
                if (idtDriveType != idtUnknown)
                    *rgchDrive = 0;
            }
            if (!rgchDrive[0] && rgchNetDrive[0])
            {
                // No unmapped drive letters available!  We need to temporarily
                // unmap one of the user's network drives.
                rgchNetDrive[2] = 0;
                DWORD dwBufSize = _MAX_PATH;
                do
                {
                    // If we can't break connection on a network drive (probably because the user has
                    // open files or an active process accessing the network), keep trying with
                    // other network drives
                    if (MPR::WNetGetConnection(rgchNetDrive,rgchRemoteUNCName,&dwBufSize) == NO_ERROR)
                        if (MPR::WNetCancelConnection2(rgchNetDrive,0,fFalse) == NO_ERROR)
                            StringCchCopy(rgchDrive,(sizeof(rgchDrive)/sizeof(ICHAR)),rgchNetDrive);
                        else
                            rgchNetDrive[0]--;
                }while(!rgchDrive[0] && rgchNetDrive[0] >= 'A');
                if (!rgchDrive[0])
                    return false;
            }

            if (rgchDrive[0])
            {
                // WNetAddConnection2 doesn't accept a backslash on the end of
                // either lpLocalName or lpRemoteName
                rgchDrive[2] = 0;
                MsiString istrRoot(szRoot);
                if (istrRoot.Compare(iscEnd, vrgchDirSep))
                    istrRoot.Remove(iseLast,1); 
                NETRESOURCE netResource;
                netResource.dwType       = RESOURCETYPE_DISK;
                netResource.lpLocalName  = rgchDrive;
                netResource.lpRemoteName = (ICHAR*) (const ICHAR*) istrRoot; 
                netResource.lpProvider   = 0;
                // note: we DO NOT impersonate here, since we are in W95.
                MsiDisableTimeout();
                DWORD dwRes = MPR::WNetAddConnection2((LPNETRESOURCE) &netResource, 0, 0, 0);
                MsiEnableTimeout();
                if (dwRes == NO_ERROR)
                {
                    rgchDrive[2] = chDirSep; // Weeeee! GetDiskFreeSpace needs the trailing backslash
                    UINT iCurrMode = WIN::SetErrorMode( SEM_FAILCRITICALERRORS );
                    fResult = WIN::GetDiskFreeSpace((const ICHAR*)(rgchDrive),(DWORD*)&dwSectorsPerCluster,
                        (DWORD*)&dwBytesPerSector, (DWORD*)&dwFreeClusters, (DWORD*)&dwTotalClusters);
                    WIN::SetErrorMode(iCurrMode);
                    rgchDrive[2] = 0; // And again WNet can't use it
                    dwRes = MPR::WNetCancelConnection2(rgchDrive,CONNECT_UPDATE_PROFILE,fTrue);
                    if (fResult == fTrue && dwRes == NO_ERROR)
                    {
                        fValidFreeSpace = true;
                        fValidClusterSize = true;
                    }
                }
                // If we had to unmap a connected drive earlier, we must now reconnect it
                if (rgchRemoteUNCName[0])
                {
                    rgchDrive[2] = 0;
                    NETRESOURCE netResource;
                    netResource.dwType       = RESOURCETYPE_DISK;
                    netResource.lpLocalName  = rgchDrive;
                    netResource.lpRemoteName = rgchRemoteUNCName; 
                    netResource.lpProvider   = 0;
                    // note: we do NOT impersonate here; we are in W95.
                    MsiDisableTimeout();
                    dwRes = MPR::WNetAddConnection2((LPNETRESOURCE) &netResource, 0, 0, 0);
                    MsiEnableTimeout();
                    Assert (dwRes == NO_ERROR);
                }
            }
        }
    }

    if (fValidClusterSize)
    {
        uiClusterSize = dwSectorsPerCluster * dwBytesPerSector;

        // Bug 6466 - Novell Intranet Client can return bogus cluster size
        // values (i.e. >= 256k when the actual size is <= 64k), which means
        // we overestimate disk space requirements.  To avoid blocking users
        // from installing to these machines, we put an upper limit on
        // cluster size for network volumes.
        if (uiClusterSize > 65536 && FIsNetworkVolume(szRoot))
            uiClusterSize = 65536;
        fHaveValidClusterSize = true;
    }

    if (fValidFreeSpace)
    {
        if (uiFreeSpace == 0) // If not already set by a call to GetDiskFreeSpaceEx
        {
            uiFreeSpace = (((UINT64) dwFreeClusters * dwSectorsPerCluster * 
                dwBytesPerSector) / iMsiMinClusterSize);

            uiTotalSpace = (((UINT64) dwTotalClusters * dwSectorsPerCluster * 
                dwBytesPerSector) / iMsiMinClusterSize);
        }
    }

    return fHaveValidClusterSize && fValidFreeSpace;
}

IMsiRecord* CMsiVolume::SetFreeSpaceAndClusterSize()
/*-------------------------------------------------------------------------
Sets the volume's free space and cluster size. These two characteristics 
are grouped together for efficiency. Both use the same API call.
--------------------------------------------------------------------------*/
{

    //Create a string pointing to the root directory of the volume  
    MsiString istrRoot = m_istrVolume + vrgchDirSep;

    bool fResult = MsiGetDiskFreeSpace(istrRoot,m_iFreeSpace,m_iTotalSpace,m_iClusterSize,DriveType(), m_fImpersonate);
    if (fResult)
        return 0;

    return (m_vsStatus = vsInvalid, PostError(Imsg(idbgErrorGettingDiskFreeSpace), 
        WIN::GetLastError(), istrRoot));
}

Bool FFileExists(const ICHAR* szFullFilePath, DWORD* pdwError, Bool fImpersonate);

//____________________________________________________________________________
//
// CMsiPath definition, implementation class for IMsiPath
//____________________________________________________________________________

class CMsiPath : public IMsiPath  // class private to this module
{
 public:   // implemented virtual functions
    HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();
    const IMsiString&   __stdcall GetPath();
    const IMsiString&   __stdcall GetRelativePath();
    const IMsiString& __stdcall GetMsiStringValue() const;
    int          __stdcall GetIntegerValue() const;
#ifdef USE_OBJECT_POOL
    unsigned int  __stdcall GetUniqueId() const;
    void          __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
    IMsiVolume&  __stdcall GetVolume();
    IMsiRecord*  __stdcall SetPath(const ICHAR* szPath);
    IMsiRecord*  __stdcall ClonePath(IMsiPath*&riPath);
    IMsiRecord*  __stdcall SetPathToPath(IMsiPath& riPath);
    IMsiRecord*  __stdcall AppendPiece(const IMsiString& strSubDir);
    IMsiRecord*  __stdcall ChopPiece();
    IMsiRecord*  __stdcall FileExists(const ICHAR* szFile, Bool& fExists, DWORD * pdwLastError = NULL);
    IMsiRecord*  __stdcall FileCanBeOpened(const ICHAR* szFile, DWORD dwDesiredAccess, bool& fCanBeOpened);
    IMsiRecord*  __stdcall GetFullFilePath(const ICHAR* szFile, const IMsiString*& ristr);
    IMsiRecord*  __stdcall GetAllFileAttributes(const ICHAR* szFileName, int& iAttrib);
    IMsiRecord*  __stdcall SetAllFileAttributes(const ICHAR* szFileName, int iAttrib);
    IMsiRecord*  __stdcall GetFileAttribute(const ICHAR* szFile,ifaEnum fa, Bool& fAttrib);
    IMsiRecord*  __stdcall SetFileAttribute(const ICHAR* szFile,ifaEnum fa, Bool fAttrib);
    IMsiRecord*  __stdcall Exists(Bool& fExists);
    IMsiRecord*  __stdcall FileSize(const ICHAR* szFile, unsigned int& uiFileSize);
    IMsiRecord*  __stdcall FileDate(const ICHAR* szFile, MsiDate& iFileData);
    IMsiRecord*  __stdcall RemoveFile(const ICHAR* szFile);
    IMsiRecord*  __stdcall EnsureExists(int* cCreatedFolders);
    IMsiRecord*  __stdcall EnsureOverwrite(const ICHAR* szFile, int* piOldAttributes);
    IMsiRecord*  __stdcall Remove(bool* pfRemoved);
    IMsiRecord*  __stdcall Writable(Bool& fWritable);
    IMsiRecord*  __stdcall FileWritable(const ICHAR *szFile, Bool& fWritable);
    IMsiRecord*  __stdcall FileInUse(const ICHAR *szFile, Bool& fInUse);
    IMsiRecord*  __stdcall ClusteredFileSize(unsigned int uiFileSize, unsigned int& uiClusteredSize);
    IMsiRecord*  __stdcall GetFileVersionString(const ICHAR* szFile, const IMsiString*& rpiVersion);
    IMsiRecord*  __stdcall CheckFileVersion(const ICHAR* szFile, const ICHAR* szVersion, const ICHAR* szLang, MD5Hash* pHash, icfvEnum& icfvResult, int* pfVersioning);
    IMsiRecord*  __stdcall GetLangIDStringFromFile(const ICHAR* szFileName, const IMsiString*& rpiLangIds);
    IMsiRecord*  __stdcall CheckLanguageIDs(const ICHAR* szFile, const ICHAR* szIds, iclEnum& riclResult);
    IMsiRecord*  __stdcall CheckFileHash(const ICHAR* szFileName, MD5Hash& hHash, icfhEnum& icfhResult);
    IMsiRecord*  __stdcall Compare(IMsiPath& riPath, ipcEnum& ipc);
    IMsiRecord*  __stdcall Child(IMsiPath& riParent, const IMsiString*& rpiChild);
    IMsiRecord*  __stdcall TempFileName(const ICHAR* szPrefix, const ICHAR* szExtension,
                                                    Bool fFileNameOnly, const IMsiString*& rpiFileName, CSecurityDescription* pSecurity); 
    IMsiRecord*  __stdcall FindFile(IMsiRecord& riFilter,int iDepth, Bool& fFound);
    IMsiRecord*  __stdcall GetSubFolderEnumerator(IEnumMsiString*& rpaEnumStr, Bool fExcludeHidden);
    const IMsiString&  __stdcall GetEndSubPath();
    IMsiRecord*  __stdcall GetImportModulesEnum(const IMsiString& strFile, IEnumMsiString*& rpiEnumStr);
    IMsiRecord*  __stdcall SetVolume(IMsiVolume& riVol);
    IMsiRecord*  __stdcall VerifyFileChecksum(const ICHAR* szFileName, Bool& rfChecksumValid);
    IMsiRecord*  __stdcall GetFileChecksum(const ICHAR* szFileName,DWORD* pdwHeaderSum, DWORD* pdwComputedSum);
    IMsiRecord*  __stdcall GetFileInstallState(const IMsiString& riFileNameString,
                                                             const IMsiString& riFileVersionString,
                                                             const IMsiString& riFileLanguageString,
                                                             MD5Hash* pHash,
                                                      ifsEnum& rifsExistingFileState,
                                                      Bool& fShouldInstall,
                                                      unsigned int* puiExistingFileSize,
                                                      Bool* fInUse,
                                                      int fInstallModeFlags,
                                                      int* pfVersioning);
    IMsiRecord*  __stdcall GetCompanionFileInstallState(const IMsiString& riParentFileNameString,
                                                                         const IMsiString& riParentFileVersionString,
                                                                         const IMsiString& riParentFileLanguageString,
                                                                         IMsiPath& riCompanionPath,
                                                                         const IMsiString& riCompanionFileNameString,
                                                                         MD5Hash* pCompanionHash,
                                                                         ifsEnum& rifsExistingFileState,
                                                                         Bool& fShouldInstall,
                                                                         unsigned int* puiExistingFileSize,
                                                                         Bool* fInUse,
                                                                         int fInstallModeFlags,
                                                                         int* pfVersioning);
    IMsiRecord*  __stdcall BindImage(const IMsiString& riFile, const IMsiString& riDllPath);
    IMsiRecord*  __stdcall IsFileModified(const ICHAR* szFile, Bool& fModified);
    Bool         __stdcall SupportsLFN();
    IMsiRecord*  __stdcall GetFullUNCFilePath(const ICHAR* szFileName, const IMsiString *&rpistr);
    IMsiRecord*  __stdcall GetSelfRelativeSD(IMsiStream*& rpiSD);
    bool         __stdcall IsRootPath();
    IMsiRecord*  __stdcall IsPE64Bit(const ICHAR* szFileName, bool &f64Bit);
    IMsiRecord*  __stdcall CreateTempFolder(const ICHAR* szPrefix, const ICHAR* szExtension,
                                              Bool fFolderNameOnly, LPSECURITY_ATTRIBUTES pSecurityAttributes,
                                              const IMsiString*& rpiFolderName);

 public:  // constructor
    CMsiPath(IMsiServices* piServices);
 protected:
  ~CMsiPath();  // protected to prevent creation on stack
 protected: 
    HRESULT          StartNetImpersonating();
    void             StopNetImpersonating();
    IMsiRecord*      ValidatePathSyntax(const IMsiString& riPath, const IMsiString*& rpistrNormalizedPath);
    IMsiRecord*      ValidateSubPathSyntax(const IMsiString& riSubDir);
    const IMsiString& NormalizePath(const ICHAR* szPath, Bool fLeadingSep);
    IMsiRecord*      FitFileFilter(IMsiRecord& riFilter, Bool& fFound);

    IMsiRecord*      GetVerFileInfo(const char* szFileName, VS_FIXEDFILEINFO*& rpvsfi);

    ifiEnum          GetFileVersion(const ICHAR* szFullPath, DWORD& pdwMS, DWORD& pdwLS);
    static Bool      GetImgDirSectnAndOffset(void* pFile,DWORD dwIMAGE_DIRECTORY, PIMAGE_SECTION_HEADER& psh, DWORD& dwOffset);
    static DWORD     GetImageFileType(void* pFile);
    static void*     ConvertRVAToVA(void* pFile, DWORD dwVA, PIMAGE_SECTION_HEADER psh);
    IMsiRecord*      GetFullFilePath(const ICHAR* szFileName, Bool fPreferUNC, const IMsiString *&rpistr);
    //IMsiRecord*      ResolveTokens(MsiString& istrPath);
    Bool             FFileExists(const ICHAR* szFullFilePath, DWORD* pdwError)
                            { return ::FFileExists(szFullFilePath, pdwError, m_fImpersonate); };
    Bool             FFolderExists(const ICHAR* szFullFolderPath);
    ifiEnum          GetLangIDArrayFromFile(const ICHAR* szFullPath, unsigned short rgw[],
                                                         int iSize, int& riLangCount);
    IMsiRecord*      GetChecksums(const ICHAR* szFile, void* pbFileStart, int cbFileSize,
                                            DWORD* pdwHeaderSum, DWORD* pdwComputedSum);
    IMsiRecord*      RecomputeChecksum(const ICHAR* szFile, void* pbFileStart, int cbFileSize);
    Bool             CreateFileMap(HANDLE hFile, Bool fReadOnly, LPVOID& pbFileStart);

    IMsiRecord*      TempFolderOrFile(Bool fFolder, const ICHAR* szPrefix, const ICHAR* szExtension,
                                                    Bool fNameOnly, LPSECURITY_ATTRIBUTES pSecurityAttributes,
                                                    const IMsiString*& rpiName);

    void             ResetCachedStatus( void );
    IMsiRecord*      CheckLanguageIDs(const ICHAR* szFile, const ICHAR* szIds, iclEnum& riclResult, unsigned short rgw[], int iLangCount);
    IMsiRecord*      PathExists(const IMsiString& piPathString, Bool& fExists);
protected: // local state
    int              m_iRefCnt;
    IMsiVolume*      m_piVolume; // cannot be null after creation
    MsiString        m_istrPath; // current path (w/trailing backslash)
    IMsiServices*    m_piServices;
    PathStatus       m_psStatus;
    iwsEnum          m_iwsWritable;
    Bool             m_fImpersonate;
    CTempBuffer<ICHAR, 20>     m_szLastFile;      // Last file a full path was asked for
    MsiString        m_istrLastFullPath;  // The full path to that file
    bool             m_fUsedUNC;
 private:
#ifdef USE_OBJECT_POOL
    unsigned int  m_iCacheId;
#endif //USE_OBJECT_POOL
};


BOOL CALLBACK EnumVersionResNameProc(HMODULE, LPCTSTR, LPTSTR, LONG_PTR);
BOOL CALLBACK EnumVersionResLangProc(HMODULE, LPCTSTR, LPCTSTR, WORD, LONG_PTR);

struct FileLanguageSet
{
	unsigned short* rgwLang; // pointer to array to hold language list
	unsigned int    uiSize;  // size of rgwLang array
	unsigned int    cLang; // number of languages stored in rgwLang array
	FileLanguageSet() : rgwLang(0), uiSize(0), cLang(0) {}
};

bool GetLangIDArrayFromBuffer(CAPITempBufferRef<BYTE>& objBuf,unsigned short rgw[], int iSize, int& riLangCount);
bool GetLangIDArrayFromActualFile(CAPITempBufferRef<BYTE>& objBuf,const ICHAR* szFullFilePath, unsigned short rgw[], int iSize, int& riLangCount);
Bool FFileExists(const ICHAR* szFullFilePath, DWORD* pdwError, Bool fImpersonate);

//
// Routine to split a path into file and directory name
// Does not create a path object
//
IMsiRecord* SplitPath(const ICHAR* szInboundPath, const IMsiString** ppistrPathName, const IMsiString** ppistrFileName)
{
    Assert(ppistrPathName != 0);
	bool fFileUrl = false;
	bool fUrl = IsURL(szInboundPath, fFileUrl);
    ICHAR chSep = chDirSep;
    ICHAR szURL[MAX_PATH+1] = TEXT("");
	DWORD cchURL = MAX_PATH;

    MsiString strPath;
    if (fUrl)
    {
        // could be forward or backslashes, and while backslashes are technically illegal,
        // let's handle them politely.  The path object will canonicalize, and then
        // do the right thing from then on.

		if (fFileUrl)
		{
			if (!MsiConvertFileUrlToFilePath(szInboundPath, szURL, &cchURL, dwMsiInternetNoEncode))
			{
				strPath = szInboundPath + 7; // revert to old behavior
			}
			else
			{
				strPath = szURL;
			}
		}
		else
		{
			MsiCanonicalizeUrl(szInboundPath, szURL, &cchURL, dwMsiInternetNoEncode);

			strPath = szURL;
			chSep = chURLSep;
		}
    }
    else
	{
		strPath = szInboundPath;
	}

    if (ppistrFileName != 0)
    {
        MsiString strFileName = strPath.Extract(iseAfter, chSep);
        strFileName.ReturnArg(*ppistrFileName);
    }
    strPath.Remove(iseFrom,chSep);
    strPath.ReturnArg(*ppistrPathName);

    return 0;
}


//____________________________________________________________________________
//
// CMsiPath implementation
//____________________________________________________________________________


IMsiRecord* CreateMsiPath(const ICHAR* szPath, IMsiServices* piServices, IMsiPath* &rpiPath)
{
    rpiPath = new CMsiPath(piServices);
    IMsiRecord* piError = rpiPath->SetPath(szPath);
    if (piError)
    {
        rpiPath->Release();
        rpiPath = 0;
        return piError;
    }
    else
        return 0;
}

IMsiRecord* CreateMsiFilePath(const ICHAR* szInboundPath, IMsiServices* piServices, IMsiPath* &rpiPath, const IMsiString*& rpistrFileName)
{
    IMsiRecord *piError;

    MsiString strPath;
    
    if ((piError = SplitPath(szInboundPath, &strPath, &rpistrFileName)) != 0)
        return piError;
        
    return CreateMsiPath(strPath, piServices, rpiPath);
}


CMsiPath::CMsiPath(IMsiServices *piServices)
    : m_piServices(piServices), m_psStatus(psInvalid), m_piVolume(0)
{
    m_iRefCnt = 1;     // we're returning an interface, passing ownership
    Assert(piServices);
    piServices->AddRef();
    m_iwsWritable = iwsNone;
    m_fImpersonate = fFalse;
    m_szLastFile[0] = 0;
    m_fUsedUNC = false;
#ifdef USE_OBJECT_POOL
    m_iCacheId = 0;
#endif //USE_OBJECT_POOL
}


CMsiPath::~CMsiPath()
{
    RemoveObjectData(m_iCacheId);
    if (m_piVolume)
        m_piVolume->Release();
}


HRESULT CMsiPath::QueryInterface(const IID& riid, void** ppvObj)
{
    if (MsGuidEqual(riid, IID_IUnknown) || MsGuidEqual(riid, IID_IMsiPath))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    *ppvObj = 0;
    return E_NOINTERFACE;
}

unsigned long CMsiPath::AddRef()
{
    return ++m_iRefCnt;
}

unsigned long CMsiPath::Release()
{
    if (--m_iRefCnt != 0)
        return m_iRefCnt;

    IMsiServices* piServices = m_piServices;
    delete this;
    piServices->Release();
    return 0;
}

const IMsiString& CMsiPath::GetMsiStringValue() const
{
    return g_MsiStringNull;
}

int CMsiPath::GetIntegerValue() const
{
    return 0;
}

#ifdef USE_OBJECT_POOL
unsigned int CMsiPath::GetUniqueId() const
{
    return m_iCacheId;
}

void CMsiPath::SetUniqueId(unsigned int id)
{
    Assert(m_iCacheId == 0);
    m_iCacheId = id;
}
#endif //USE_OBJECT_POOL

const IMsiString& CMsiPath::GetPath()
{
    MsiString strVolPath = m_piVolume->GetPath();
    MsiString strFullPath = strVolPath + m_istrPath;
    return strFullPath.Return();
}

const IMsiString& CMsiPath::GetRelativePath()
{
    return m_istrPath.Return();
}


bool CMsiPath::IsRootPath()
// returns true if path object represents the root of a volume
{
    return m_istrPath.TextSize() > 1 ? false : true;
}


IMsiVolume& CMsiPath::GetVolume()
{
    Assert(m_piVolume);
    m_piVolume->AddRef();
    return *m_piVolume;
}


#if 0  
HRESULT CMsiPath::StartNetImpersonating()
/*------------------------------------------------------------------
Start impersonation only if our full path references a network drive
and we're an NT service
--------------------------------------------------------------------*/
{
    if (m_fImpersonate)
        return StartImpersonating();
    else
        return S_OK;
}

void CMsiPath::StopNetImpersonating()
/*------------------------------------------------------------------
Stop impersonation started by a call to StartNetImpersonating.
--------------------------------------------------------------------*/
{
    if (m_fImpersonate)
        StopImpersonating();
}
#endif

void CMsiPath::ResetCachedStatus( void )
/*-------------------------------------------------------------------------
Resets the cached status of all path status flags, forcing recalculation.
---------------------------------------------------------------------------*/
{
    m_iwsWritable = iwsNone;
    m_szLastFile[0] = 0;
}

IMsiRecord* CMsiPath::SetPath(const ICHAR* szInboundPath)
/*-------------------------------------------------------------------------
Associates the volume and path information given in szPath with this
CMsiPath object.
---------------------------------------------------------------------------*/
{
    ICHAR* szPath = (ICHAR*) szInboundPath;
    ICHAR szNormalizedUrl[MAX_PATH+1] = TEXT("");
	DWORD cchBuffer = MAX_PATH;
	bool fFileUrl = false;
    if (IsURL(szPath, fFileUrl))
    {
		if (fFileUrl)
		{
			if (MsiConvertFileUrlToFilePath(szInboundPath, szNormalizedUrl, &cchBuffer, 0))
				szPath = szNormalizedUrl;
			else
				szPath = szPath + 7;
		}
		else
		{
			if (MsiCanonicalizeUrl(szInboundPath, szNormalizedUrl, &cchBuffer, 0))
				szPath = szNormalizedUrl;
		}
    }

    IMsiVolume *piOldVolume = m_piVolume;
    IMsiRecord* piError;
    if (szPath == 0 || *szPath == 0)
        return PostError(Imsg(idbgErrorEmptyPath));
    
    ResetCachedStatus();
    MsiString strFileSysPart;
    piError = CreateMsiVolume(szPath, *&strFileSysPart, m_piServices, m_piVolume);
    if (piError)
    {
        m_piVolume = piOldVolume;
        return piError; 
    }

    MsiString strNormalizedPath;
    if (strFileSysPart.TextSize() > 0)
    {
        piError = ValidatePathSyntax(*strFileSysPart,*&strNormalizedPath);
        if (piError)
        {
            m_piVolume->Release();
            m_piVolume = piOldVolume;
            return piError;
        }
    }

    if (piOldVolume)
        piOldVolume->Release();

    m_psStatus = psValid;

    ICHAR* rgchSeparator = (m_piVolume->IsURLServer()) ? vrgchURLSep : vrgchDirSep;
    if (strNormalizedPath.Compare(iscEnd, rgchSeparator) == 0)
        strNormalizedPath += rgchSeparator; 

    m_fImpersonate = FDriveTypeRequiresImpersonation(m_piVolume->DriveType()) && (RunningAsLocalSystem()) ? fTrue : fFalse;
    m_istrPath = strNormalizedPath;
    return 0;
}

IMsiRecord* CMsiPath::ClonePath(IMsiPath*&rpiPath)
{
    rpiPath = new CMsiPath(this->m_piServices);
    IMsiRecord* piError = rpiPath->SetPathToPath(*this);
    if (piError)
    {
        rpiPath->Release();
        rpiPath = 0;
        return piError;
    }
    
    return 0;
}

IMsiRecord* CMsiPath::SetPathToPath(IMsiPath& riPath)
{
    
    SetVolume(*PMsiVolume(&riPath.GetVolume()));
    m_istrPath = riPath.GetRelativePath();
    m_psStatus = psValid;
    ResetCachedStatus();
    return 0;
}

Bool CMsiPath::SupportsLFN()
{
    return m_piVolume->SupportsLFN();
}


IMsiRecord* CMsiPath::AppendPiece(const IMsiString& strSubDir)
//-------------------------------
{
    ICHAR* pchDirSep = (m_piVolume->IsURLServer()) ? vrgchURLSep : vrgchDirSep;
    strSubDir.AddRef();
    MsiString istrSubDir(strSubDir);
    IMsiRecord* piError;

    // appending a null subpath equals the same path - chetanp
    if (istrSubDir.TextSize() == 0)
        return 0;
    
    if (!m_piVolume->IsURLServer())
    {
        ICHAR rgDoubleSeps[3];
        rgDoubleSeps[0] = rgDoubleSeps[1] = chDirSep;
        rgDoubleSeps[2] = 0;
        if(istrSubDir.Compare(iscStart,szDirSep) || istrSubDir.Compare(iscWithin,rgDoubleSeps))
            istrSubDir = NormalizePath(istrSubDir,fFalse);

        piError = ValidateSubPathSyntax(*istrSubDir);
        if (piError)
            return piError; 

        if (istrSubDir.Compare(iscEnd, vrgchURLSep))
            istrSubDir.Remove(iseLast, 1);
    }
    else
    {
        // add further validation if necessary
        // this also normalizes the path passed in
        CTempBuffer<ICHAR, cchMaxUrlLength + 1> rgchResultantURL;
        DWORD cbResultantURL = cchMaxUrlLength;

		// CombineUrl doesn't always give you the currentpath + subdir - it chops pieces of the currentpath
        // so we pass in just the server path, and the current path

        if (!MsiCombineUrl(MsiString(m_piVolume->URLServer()), strSubDir.GetString(), rgchResultantURL, &cbResultantURL, dwMsiInternetBrowserMode))
        {
            DWORD dwLastError = WIN::GetLastError();
            Assert(ERROR_INSUFFICIENT_BUFFER != dwLastError);
            MsiString strURL = m_piVolume->URLServer();
            strURL += strSubDir;
            return PostError(Imsg(imsgPathNotAccessible), *strURL);
        }

        MsiString strRoot;
        // extracting out the sub-path beneath the server should give us a normalized version of the
        // sub-path we want to append
        if(!ExtractURLServer(rgchResultantURL, *&strRoot, *&istrSubDir))
            return PostError(Imsg(imsgPathNotAccessible), rgchResultantURL);

        if(istrSubDir.Compare(iscStart, vrgchURLSep))
            istrSubDir.Remove(iseFirst, 1);
    }

    ResetCachedStatus();

    m_istrPath += istrSubDir;
    
    if (m_istrPath.Compare(iscEnd, pchDirSep) == 0)
        m_istrPath += pchDirSep;

    return 0;
}

const IMsiString& CMsiPath::GetEndSubPath()
/*-------------------------------------------------------------------------
returns the last path segment of the path. If there are no path segments, 
then empty string is returned.
 ---------------------------------------------------------------------------*/
{
    Assert(m_piVolume);
    MsiString strNoBS = m_istrPath.Extract(iseFirst, m_istrPath.CharacterCount()-1);  

    // check if we have reached the root
    if (strNoBS.TextSize() == 0)
        return CreateString();

    MsiString strChopped = strNoBS.Extract(iseAfter, (m_piVolume->IsURLServer()) ? chURLSep : chDirSep);                                                    
    return strChopped.Return();
}

IMsiRecord* CMsiPath::ChopPiece()
/*-------------------------------------------------------------------------
Removes the last path segment of the path. If there are no path segments, 
then no action is taken, and false will be returned in the buffer pointed
to by pfChopped.  The caller may pass NULL for pfChopped.
 ---------------------------------------------------------------------------*/
{
    Assert(m_piVolume);
    ICHAR chSeparator = (m_piVolume->IsURLServer()) ? chURLSep : chDirSep;
    if (m_istrPath.TextSize() > 1)
    {
        m_istrPath.Remove(iseFrom,chSeparator);
        m_istrPath.Remove(iseAfter,chSeparator);
    }
    ResetCachedStatus();
    return 0;
}

Bool CMsiPath::FFolderExists(const ICHAR* szFullFolderPath)
/*-------------------------------------------------------------------------
Local function that accepts a full path to a folder, and returns fTrue as
the function result if the folder exists. The folder must be a subfolder
of the this path object's path.
---------------------------------------------------------------------------*/
{
    Bool fExists = fTrue;
    // In case our path refers to a floppy drive, disable the "insert disk in drive" dialog
    if(m_fImpersonate)
        StartImpersonating();
    // current error mode should include SEM_FAILCRITICALERRORS at this point to
    // prevent unnecessary pop-ups from the OS
    int iAttrib = MsiGetFileAttributes(szFullFolderPath);
    
    if (iAttrib == 0xFFFFFFFF  || !(iAttrib & FILE_ATTRIBUTE_DIRECTORY))
        fExists = fFalse;
    if(m_fImpersonate)
        StopImpersonating();
    return fExists;
}


Bool FFileExists(const ICHAR* szFullFilePath, DWORD* pdwError, Bool fImpersonate)
/*-------------------------------------------------------------------------
Local function that accepts a full path to a file, and returns fTrue as
the function result if the file exists in the specified directory.

If an error occurs, the error code will be returned in the pdwError param.
---------------------------------------------------------------------------*/
{
    if (pdwError) *pdwError = 0;
    Bool fExists = fTrue;
    // In case our path refers to a floppy drive, disable the "insert disk in drive" dialog
    if(fImpersonate)
        StartImpersonating();
    // current error mode should include SEM_FAILCRITICALERRORS at this point to
    // prevent unnecessary pop-ups from the OS
    DWORD iAttribs = MsiGetFileAttributes(szFullFilePath);
    if ((iAttribs == 0xFFFFFFFF) && pdwError)
        *pdwError = WIN::GetLastError();

    if (iAttribs & FILE_ATTRIBUTE_DIRECTORY)
        fExists = fFalse;              //either a dir or doesn't exist
    if(fImpersonate)
        StopImpersonating();
    return fExists;
}


IMsiRecord* CMsiPath::FileCanBeOpened(const ICHAR* szFileName, DWORD dwDesiredAccess, bool& fCanBeOpened)
{
    fCanBeOpened = false;
    MsiString istrFileName;
    IMsiRecord* piError = GetFullFilePath(szFileName, *&istrFileName);
    if (piError)               
        return piError;

    bool fOpenAlways = (dwDesiredAccess & (GENERIC_WRITE | FILE_GENERIC_WRITE)) ? true : false;
    
    CImpersonate impersonate(m_fImpersonate ? fTrue : fFalse);

    // If write access has been requested then if the ReadOnly bit is set for a file, 
    // take it off temporarily
    Bool fReadOnly = fFalse;

    if (dwDesiredAccess & (GENERIC_WRITE | DELETE | FILE_GENERIC_WRITE))
    {
        piError = GetFileAttribute(szFileName, ifaReadOnly,fReadOnly);
        if (piError)
        {
            // probably failed because file didn't exist - if fOpenAlways ignore error
            if(fOpenAlways)
            {
                piError->Release();
                piError = 0;
            }
            else
                return piError;
        }

        if (fReadOnly)
        {
            piError = SetFileAttribute(szFileName,ifaReadOnly,fFalse);
            if (piError)
            {   // If we couldn't turn off the read-only bit (e.g. file
                // on a read-only share) then the file can't be opened for rwite
                // in-use status.  Bail now.
                piError->Release();
                return 0;
            }
        }
    }

    DWORD dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
    if (!g_fWin9X)
        dwShareMode |= FILE_SHARE_DELETE;
        
    HANDLE hFile = WIN::CreateFile(istrFileName, dwDesiredAccess, dwShareMode, 0, OPEN_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        DWORD dwLastError = GetLastError();

        if(fOpenAlways && dwLastError == ERROR_FILE_NOT_FOUND)
        {
            // try again with CREATE_NEW
            hFile = WIN::CreateFile(istrFileName, dwDesiredAccess, dwShareMode, 0, CREATE_NEW,
                        (FILE_FLAG_DELETE_ON_CLOSE | (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)), 0);

            if (hFile == INVALID_HANDLE_VALUE)
                dwLastError = GetLastError();

            //!! temporary hack for 195517.
            if (dwLastError == ERROR_GEN_FAILURE)
            {
                // try again with CREATE_NEW
                hFile = WIN::CreateFile(istrFileName, dwDesiredAccess, dwShareMode, 0, CREATE_NEW,
                    (FILE_FLAG_DELETE_ON_CLOSE | (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)), 0);

                if (hFile == INVALID_HANDLE_VALUE)
                    dwLastError = GetLastError();
            }
        }
        
        if (hFile == INVALID_HANDLE_VALUE && dwLastError == ERROR_SHARING_VIOLATION)    
        {
            // The access check in CreateFile comes before the sharing check so we can be sure at this point
            // that the user has rights to open the file
			fCanBeOpened = fTrue;
        }
    }

    if (hFile != INVALID_HANDLE_VALUE)  
    {       
		DWORD dwType = GetFileType(hFile);
		fCanBeOpened = ((FILE_TYPE_PIPE != dwType) && (FILE_TYPE_CHAR != dwType));
#ifdef DEBUG
		if(!fCanBeOpened)
			DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), istrFileName);
#endif
        AssertNonZero(MsiCloseUnregisteredSysHandle(hFile));
		
		if(!fCanBeOpened)
			SetLastError(ERROR_OPEN_FAILED);
			
    }

    if (fReadOnly)
    {
        piError = SetFileAttribute(szFileName,ifaReadOnly,fTrue);
        if (piError)
            return piError;
    }

    return 0;
}

IMsiRecord* CMsiPath::FileExists(const ICHAR* szFile, Bool& fExists, DWORD * pdwLastError /* = NULL */)
//------------------------------
{
    if (pdwLastError)
        *pdwLastError = 0;

    MsiString strFullFilePath;
    IMsiRecord* piError = GetFullFilePath(szFile, *&strFullFilePath);
    if (piError)
        return piError;

    DWORD dwLastError;
    fExists = FFileExists(strFullFilePath, &dwLastError);
    if (pdwLastError)
        *pdwLastError = dwLastError;
    if (NET_ERROR(dwLastError))
        return PostError(Imsg(imsgNetErrorReadingFromFile), *strFullFilePath);
    return 0;
}


IMsiRecord* CMsiPath::GetFullFilePath(const ICHAR* szFileName, const IMsiString *&rpistr)
//-----------------------------------
{
    return GetFullFilePath(szFileName,/* fPreferUNC = */ fFalse, rpistr);
}


IMsiRecord* CMsiPath::GetFullUNCFilePath(const ICHAR* szFileName, const IMsiString *&rpistr)
//-----------------------------------
{
    Assert(!m_piVolume->IsURLServer());
    return GetFullFilePath(szFileName,/* fPreferUNC = */ fTrue, rpistr);
}


IMsiRecord* CMsiPath::GetFullFilePath(const ICHAR* szFileName, Bool fPreferUNC, const IMsiString *&rpistr)
//-----------------------------------
{
    bool fUsedUNC = true;
    
    MsiString strVolumePath;
    if (fPreferUNC && m_piVolume->IsUNCServer())
        strVolumePath = m_piVolume->UNCServer();
    else
    {
        fUsedUNC = false;
        strVolumePath = m_piVolume->GetPath();
    }

    MsiString strFullPath;
    int cch = 0;
    if (szFileName)
        cch = IStrLen(szFileName);

    if (!m_piVolume->IsURLServer())
    {
        // An empty file name means the caller just needs the path.
        if (cch > 0)
        {
#ifdef DEBUG
            //!! Future: Fix this assert - IStrChr doesn't work with DBCS characters (bug 7790)
            //!! AssertSz(IStrChr(szFileName,TEXT('|')) == 0, "Short|Long syntax passed to Path object");
#endif //DEBUG
            if (fUsedUNC == m_fUsedUNC && (IStrLen(m_szLastFile) == cch) && (!memcmp(szFileName, m_szLastFile, (sizeof ICHAR)*(cch + 1))))
            {
                // Same call as previously
                strFullPath = m_istrLastFullPath;
            }
            else
            {
                IMsiRecord* piError = m_piServices->ValidateFileName(szFileName, SupportsLFN());
                if (piError)
                    return piError; 
                    
                strFullPath = strVolumePath + m_istrPath;

                strFullPath += szFileName;
                m_szLastFile.SetSize(cch + 1);
                if ( ! (ICHAR *) m_szLastFile )
                    return PostError(Imsg(idbgErrorOutOfMemory));
                memcpy(m_szLastFile, szFileName, (sizeof ICHAR)*(cch + 1));
                m_istrLastFullPath = strFullPath;
                m_fUsedUNC = fUsedUNC;
            }
        }
        else
            strFullPath = strVolumePath + m_istrPath;
        
    }
    else 
    {
        strFullPath = strVolumePath + m_istrPath;

        if (cch > 0)
            strFullPath += szFileName;
    }

    strFullPath.ReturnArg(rpistr);
    return 0;
}

IMsiRecord* CMsiPath::GetSelfRelativeSD(IMsiStream*& rpiSD)
{
    if (g_fWin9X)
        return 0;

    rpiSD = 0;

    DWORD cbSD = 1024;
    DWORD cbSDNeeded = 0;
    CTempBuffer<BYTE, 1> rgchSD(1024);

    Bool fExists;
    PMsiRecord pError = Exists(fExists);
    if (!fExists)
        return 0;

    MsiString strPath(GetPath());

    if (m_fImpersonate)
        AssertNonZero(StartImpersonating());
    int iRet = WIN::GetFileSecurity((const ICHAR*) strPath, 
        // all possible information retrieved
        OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | 
        DACL_SECURITY_INFORMATION /*| SACL_SECURITY_INFORMATION*/,
        rgchSD, cbSD, &cbSDNeeded);
    if (m_fImpersonate)
        StopImpersonating();

    if (!iRet)
    {
        DWORD dwLastError = WIN::GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER == dwLastError)
        {
            cbSD = cbSDNeeded;
            rgchSD.SetSize(cbSD);

            if (m_fImpersonate)
                AssertNonZero(StartImpersonating());            
            iRet = WIN::GetFileSecurity((const ICHAR*) strPath, 
                // all possible information retrieved
                OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | 
                DACL_SECURITY_INFORMATION /*| SACL_SECURITY_INFORMATION*/,
                rgchSD, cbSD, &cbSDNeeded);
            if (m_fImpersonate)
                StopImpersonating();

            if(!iRet)
            {
                dwLastError = WIN::GetLastError();
                return PostError(Imsg(imsgGetFileSecurity), dwLastError, (const ICHAR*)strPath);
            }
        }
        else
        {
            return PostError(Imsg(imsgGetFileSecurity), dwLastError, (const ICHAR*)strPath);
        }

    }

    if (!cbSDNeeded) 
        cbSDNeeded = GetSecurityDescriptorLength(rgchSD);
    Assert(SECURITY_DESCRIPTOR_MIN_LENGTH <= cbSDNeeded);

    char* pchstrmSD = AllocateMemoryStream(cbSDNeeded, rpiSD);
    if ( ! pchstrmSD )
    {
        Assert(pchstrmSD);
        return PostError(Imsg(idbgErrorOutOfMemory));
    }
    memcpy(pchstrmSD, rgchSD, cbSDNeeded);

    return 0;
}


const IMsiString& TrimPath(const ICHAR* szPath)
/*-----------------------------------------------------------
Accepts a directory path, and trims spaces and periods from
the beginning and end of each path segment.  The trimmed
string is returned as the function result.
------------------------------------------------------------*/
{
    MsiString strRet;
    if(!szPath || !*szPath)
        return strRet.Return();
    CTempBuffer<ICHAR,MAX_PATH> rgBuffer;
    int cch = 0;
    if((cch = IStrLen(szPath)) >= MAX_PATH)
    {
        rgBuffer.SetSize(cch + 1);
        if ( ! (ICHAR *) rgBuffer )
            return strRet.Return();
    }
    rgBuffer[0] = 0;
    const ICHAR* pchIn = szPath;
    ICHAR* pchOut = rgBuffer;
    Bool fWithin = fFalse;
    Bool fEnd = fFalse;
    while(*pchIn)
    {
        if (*pchIn == chDirSep)
        {
            fWithin = fFalse;
            fEnd = fFalse;
        }

        if (fWithin && (*pchIn == TEXT(' ') || *pchIn == TEXT('.')))
        {
            const ICHAR* pchLookAhead = pchIn;
            while (*pchLookAhead == TEXT(' ') || *pchLookAhead == TEXT('.'))
                pchLookAhead = ICharNext(pchLookAhead);
            fWithin = ((*pchLookAhead == chDirSep) || (*pchLookAhead == '\0')) ? fFalse : fTrue;

        }

        if (!fWithin)
        {
            while (*pchIn == TEXT(' ') || (fEnd && *pchIn == TEXT('.')))
                pchIn = ICharNext(pchIn);
            
            fWithin = ((*pchIn == chDirSep) || (*pchIn == '\0')) ? fFalse : fTrue;
            fEnd = fWithin;
        }
        if (*pchIn)
        {
#ifdef UNICODE
            *pchOut++ = *pchIn++;  // can't use CharNext on output buffer
#else
            const ICHAR* pchTemp = pchIn;
            *pchOut++ = *pchIn;
            pchIn = ICharNext(pchIn);
            if(pchIn == pchTemp + 2)
            {
                // double-byte char - need to copy another byte
                *pchOut++ = *(pchIn-1);
            }
#endif
        }
    }
    *pchOut = 0;
    strRet = (const ICHAR*)rgBuffer;
    return strRet.Return();

}



IMsiRecord* CMsiPath::ValidatePathSyntax(const IMsiString& riPath,
                                         const IMsiString*& rpistrNormalizedPath)
/*-------------------------------------------------------------------------
Validates that the path is of the form: 
\\COMPUTER\\SHARE[\DIRCOMP[\[DIRCOMP...]]]   
    OR 
D:[\[DIRCOMP[\[DIRCOMP....]]]]
   OR
http://www.server.com[/DIRCOMP[/[DIRCOMP]]]

Assumes szPath begins with chDirSep
---------------------------------------------------------------------------*/
{
    MsiString strPath = riPath;
    riPath.AddRef();

    ICHAR rgDoubleSeps[3];
    rgDoubleSeps[0] = rgDoubleSeps[1] = chDirSep;
    rgDoubleSeps[2] = 0;

    IMsiRecord* piResult = 0;
    if (m_piVolume->IsURLServer())
    {
        // add further validation if necessary.
        CTempBuffer<ICHAR, cchMaxUrlLength + 1> rgchResultantURL;
        DWORD cbResultantURL = cchMaxUrlLength;
        if (!MsiCombineUrl(MsiString(m_piVolume->URLServer()), riPath.GetString(), rgchResultantURL, &cbResultantURL, dwMsiInternetBrowserMode))
        {
            DWORD dwLastError = WIN::GetLastError();
            MsiString strURL = m_piVolume->URLServer();
            strURL += riPath;
            return PostError(Imsg(imsgPathNotAccessible), *strURL);
        }

    }
    else
    {
        if(strPath.TextSize() && !strPath.Compare(iscStart,szDirSep))
            return PostError(Imsg(imsgPathNotAccessible), *strPath);

        if (strPath.Compare(iscWithin,rgDoubleSeps))
            strPath = NormalizePath(strPath,fTrue);

        piResult = ValidateSubPathSyntax(*strPath);
    }
    // Remove leading, trailing spaces, periods...
    strPath = TrimPath(strPath);

    strPath.ReturnArg(rpistrNormalizedPath);
    return piResult;
}

IMsiRecord* CMsiPath::ValidateSubPathSyntax(const IMsiString& riSubPath)
/*-------------------------------------------------------------------------
Validates that subpath is of the form: \DIRCOMP[\[DIRCOMP[\[DIRCOMP...]]]]
---------------------------------------------------------------------------*/
{
    Assert(!m_piVolume->IsURLServer());

    IMsiRecord* piError;

    CTempBuffer <ICHAR, MAX_PATH> rgchSubPath;
    int cch;
    
    rgchSubPath.SetSize(cch = (riSubPath.TextSize() + 1));
    if ( ! (ICHAR *) rgchSubPath )
        return PostError(Imsg(idbgErrorOutOfMemory));
    riSubPath.CopyToBuf((ICHAR *)rgchSubPath, cch - 1);

    ICHAR* pch = rgchSubPath;
    ICHAR* pchStart;

    if (*pch == chDirSep)
        pch++;

    pchStart = pch;
    while (*pch)
    {
        if (*pch == chDirSep)
        {
            // Add a null where the chDirSep is, and validate from the start
            *pch = 0;
            if ((piError = m_piServices->ValidateFileName(pchStart, SupportsLFN())) != 0)
                return piError; 
            pch++;
            pchStart = pch;
            continue;
        }
        pch = INextChar(pch);
    }

    if (*pchStart != 0)
        if ((piError = m_piServices->ValidateFileName(pchStart, SupportsLFN())) != 0)
            return piError; 
        
            
    return 0;
}

IMsiRecord* CMsiPath::SetVolume(IMsiVolume& riVol)
{
    if (m_piVolume != &riVol)
    {
        if (m_piVolume)
            m_piVolume->Release();
        m_piVolume = &riVol;
        riVol.AddRef();
        ResetCachedStatus();
        m_fImpersonate = (m_piVolume->DriveType() == idtRemote) && (RunningAsLocalSystem()) ? fTrue : fFalse;
    }
    return 0;
}


IMsiRecord* CMsiPath::GetAllFileAttributes(const ICHAR* szFileName, int& iAttrib)
//----------------------------------------
{
    if (m_piVolume->IsURLServer())
    {
        // Getting file attributes from a file from a URL
        // isn't useful.  They're likely to be stripped
        // or completely wrong.  Archiving on the server
        // may require drastically different security than
        // desired in the install image.
        iAttrib = 0;
        return 0;
    }

    MsiString strFileName;
    IMsiRecord* piRec = GetFullFilePath(szFileName, *&strFileName);
    if (piRec)               
        return piRec;

    // In case our path refers to a floppy drive, disable the "insert disk in drive" dialog
    // current error mode should include SEM_FAILCRITICALERRORS at this point to
    // prevent unnecessary pop-ups from the OS
    if (m_fImpersonate)
        AssertNonZero(StartImpersonating());
    DWORD dwAttr = MsiGetFileAttributes(strFileName);
    if (m_fImpersonate)
        StopImpersonating();

    if (dwAttr == 0xFFFFFFFF) 
        return PostError(Imsg(idbgFileDoesNotExist), *strFileName);
    iAttrib = dwAttr;
    return 0;
}



IMsiRecord* CMsiPath::GetFileAttribute(const ICHAR* szFileName, ifaEnum fa, Bool& fAttrib)
//------------------------------------
{
    Assert(!m_piVolume->IsURLServer());

    int iAttrib;
    IMsiRecord* piErrRec = GetAllFileAttributes(szFileName,iAttrib);
    if (piErrRec)
        return piErrRec;

    long lValue;
    switch (fa)
    {
        case ifaArchive:
            lValue = iAttrib & FILE_ATTRIBUTE_ARCHIVE;
            break;
        case ifaDirectory:
            lValue = iAttrib & FILE_ATTRIBUTE_DIRECTORY;
            break;
        case ifaHidden:
            lValue = iAttrib & FILE_ATTRIBUTE_HIDDEN;
            break;
        case ifaNormal:
            lValue = iAttrib & FILE_ATTRIBUTE_NORMAL;
            break;
        case ifaReadOnly:
            lValue = iAttrib & FILE_ATTRIBUTE_READONLY;
            break;
        case ifaSystem:
            lValue = iAttrib & FILE_ATTRIBUTE_SYSTEM;
            break;
        case ifaTemp:
            lValue = iAttrib & FILE_ATTRIBUTE_TEMPORARY;
            break;
        case ifaCompressed:
            lValue = iAttrib & FILE_ATTRIBUTE_COMPRESSED;
            break;
        default:
            return PostError(Imsg(idbgInvalidFileAttribute));
    }
    fAttrib = lValue == 0 ? fFalse : fTrue;
    return 0;
}


IMsiRecord* CMsiPath::SetAllFileAttributes(const ICHAR* szFileName, int iAttrib)
//----------------------------------------
{

    Assert(!m_piVolume->IsURLServer());

    MsiString strFileName;
    IMsiRecord* piRec = GetFullFilePath(szFileName, *&strFileName);
    if (piRec)               
        return piRec;

    int cRetry=0;   
    HRESULT hRes;
    if (m_fImpersonate)
        AssertNonZero(StartImpersonating());

    while (!WIN::SetFileAttributes(strFileName, iAttrib))
    {
        if (m_fImpersonate)
            StopImpersonating();

        hRes = WIN::GetLastError();
        if (hRes != ERROR_SHARING_VIOLATION)
        {
            if (hRes == ERROR_ACCESS_DENIED)
                return PostError(Imsg(imsgAccessToFileDenied), (const ICHAR*) strFileName);
            else
                return PostError(Imsg(idbgErrorSettingFileAttributes), hRes, (const ICHAR*) strFileName);
        }
        else if (cRetry > iMaxRetries)
            return PostError(Imsg(idbgErrorSettingFileAttributes), hRes, (const ICHAR*) strFileName);
        else
        {
            cRetry++;
            if (m_fImpersonate)
                AssertNonZero(StartImpersonating());
        }
    }
    if (m_fImpersonate)
        StopImpersonating();

    return 0;

}

IMsiRecord* CMsiPath::SetFileAttribute(const ICHAR* szFileName, ifaEnum fa, Bool fAttrib)
//------------------------------------
{
    Assert(!m_piVolume->IsURLServer());

    int iOldAttr;
    IMsiRecord* piErrRec = GetAllFileAttributes(szFileName,iOldAttr);
    if (piErrRec)
        return piErrRec;

    int iAttribBit;
    switch (fa)
    {
        case ifaArchive:
            iAttribBit = FILE_ATTRIBUTE_ARCHIVE;
            break;
        case ifaHidden:
            iAttribBit = FILE_ATTRIBUTE_HIDDEN;
            break;
        case ifaReadOnly:
            iAttribBit = FILE_ATTRIBUTE_READONLY;
            break;
        case ifaSystem:
            iAttribBit = FILE_ATTRIBUTE_SYSTEM;
            break;
        case ifaTemp:
            iAttribBit = FILE_ATTRIBUTE_TEMPORARY;
            break;
            // Setting the 'Compressed' attribute is not allowable
        case ifaCompressed:
        default:
            return PostError(Imsg(idbgInvalidFileAttribute));
        
    }
    
    // If parameter "l" is zero, clear the attribute bit; otherwise
    // set it.
    int iNewAttr = fAttrib == fFalse ? iOldAttr & (~iAttribBit) : iOldAttr | iAttribBit;
    return SetAllFileAttributes(szFileName,iNewAttr);
}


IMsiRecord* CMsiPath::PathExists(const IMsiString& riPathString, Bool& fExists)
//------------------------------
{
    IMsiRecord* piError = 0;
    MsiString strPathNoBS = riPathString.GetString();   
    if (strPathNoBS.Compare(iscEnd,vrgchDirSep) > 0)
        strPathNoBS.Remove(iseLast, 1); //remove trailing '\'

    // In case our path refers to a floppy drive, disable the "insert disk in drive" dialog
    // current error mode should include SEM_FAILCRITICALERRORS at this point to
    // prevent unnecessary pop-ups from the OS
    if (m_fImpersonate)
        AssertNonZero(StartImpersonating());

    DWORD dwAttr = MsiGetFileAttributes(strPathNoBS);
    
    if (0xFFFFFFFF == dwAttr)
    {
        DWORD dwErr = WIN::GetLastError();
        // we get this error if the directory
        // has been deleted, another process is still trying to access it!
        // (like a DOS prompt, or the Explorer).
        if (dwErr == ERROR_ACCESS_DENIED)
            dwErr = ERROR_PATH_NOT_FOUND;

        // if directory has been deleted but another process is still trying to access it,
        // we can get this error -- treat it as gone
        if (dwErr == ERROR_DELETE_PENDING)
            dwErr = ERROR_PATH_NOT_FOUND;

        if (dwErr == ERROR_FILE_NOT_FOUND ||
            dwErr == ERROR_PATH_NOT_FOUND ||
            dwErr == ERROR_NOT_READY)
            fExists = fFalse;
        else if (m_piVolume->IsURLServer())
            fExists = fFalse;
        else
            piError = PostError(Imsg(idbgErrorGettingFileAttrib), dwErr, strPathNoBS);
    }
    else if (dwAttr & FILE_ATTRIBUTE_DIRECTORY) 
        fExists = fTrue;
    else
        fExists = fFalse;

    if (m_fImpersonate)
        StopImpersonating();

    return piError;
}




IMsiRecord* CMsiPath::Exists(Bool& fExists)
//--------------------------
{
    return PathExists(*MsiString(GetPath()), fExists);
}


IMsiRecord* CMsiPath::FileSize(const ICHAR* szFile, unsigned int& uiFileSize)
//----------------------------
{

    uiFileSize = 0;
    MsiString istrFullPath;
    IMsiRecord* piError = GetFullFilePath(szFile, *&istrFullPath);
    if (piError)
        return piError;

    if (m_piVolume->IsURLServer())
    {
        // fake size, and not particularly useful for determining if the file is available.
        // should really use another way of getting this if you've already downloaded the file.
        uiFileSize = 1;
        return 0;
    }

    if (!FFileExists(istrFullPath,0))
        return PostError(Imsg(idbgFileDoesNotExist), *istrFullPath);
        
    if (m_fImpersonate)
        AssertNonZero(StartImpersonating());

    HANDLE hFile = WIN::CreateFile(istrFullPath, GENERIC_READ, FILE_SHARE_READ, 
     0, OPEN_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);

    if (hFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwType = GetFileType(hFile);
		if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
		{
			DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), istrFullPath);
			AssertNonZero(MsiCloseUnregisteredSysHandle(hFile));
			hFile = INVALID_HANDLE_VALUE;
			SetLastError(ERROR_OPEN_FAILED);
		}
	}

    if (m_fImpersonate)
        StopImpersonating();
			
		
    if (hFile != INVALID_HANDLE_VALUE)
    {
        MsiRegisterSysHandle(hFile);
        if (m_fImpersonate)
            AssertNonZero(StartImpersonating());

        DWORD dwSize = WIN::GetFileSize(hFile, 0);
        AssertNonZero(MsiCloseSysHandle(hFile));
        if (m_fImpersonate)
            StopImpersonating();
        if(dwSize != 0xFFFFFFFF)
        {
            uiFileSize = dwSize;
            return 0;
        }
    }

    //!! should we always do FindFirstFile and not bother with CreateFile/GetFileSize ?
    // CreateFile/GetFileSize didn't work
    // try FindFirstFile in case we don't have sharing access to file
    WIN32_FIND_DATA fdFileData;
    if (m_fImpersonate)
        AssertNonZero(StartImpersonating()); //!! should this be an error?
    HANDLE hFind = FindFirstFile(istrFullPath, &fdFileData);
    if (m_fImpersonate)
        StopImpersonating();
    if(hFind != INVALID_HANDLE_VALUE)
    {
        FindClose(hFind);
        uiFileSize = fdFileData.nFileSizeLow; //!! what about the high dword?
        return 0;
    }

    return 0;
}


IMsiRecord* CMsiPath::FileDate(const ICHAR* szFile, MsiDate& rMsiDate)
//----------------------------
{
    MsiString istrFullPath;
    IMsiRecord* piError = GetFullFilePath(szFile, *&istrFullPath);
    if (piError)
        return piError;
   
    if (!FFileExists(istrFullPath, 0))
        return PostError(Imsg(idbgFileDoesNotExist), *istrFullPath);
    
    if (m_fImpersonate)
        AssertNonZero(StartImpersonating());

    HANDLE hFile = WIN::CreateFile(istrFullPath, GENERIC_READ, FILE_SHARE_READ, 
        0, OPEN_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);

    if (hFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwType = GetFileType(hFile);
		if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
		{
			DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), istrFullPath);
			AssertNonZero(MsiCloseUnregisteredSysHandle(hFile));
			hFile = INVALID_HANDLE_VALUE;
			SetLastError(ERROR_OPEN_FAILED);
		}
	}

    if (m_fImpersonate)
        StopImpersonating();

    if (hFile != INVALID_HANDLE_VALUE)
    {
        MsiRegisterSysHandle(hFile);
        FILETIME ftLastWrite;
        if (m_fImpersonate)
            AssertNonZero(StartImpersonating());

        Bool fSuccess = ToBool(WIN::GetFileTime(hFile, 0, 0, &ftLastWrite));
        if (m_fImpersonate)
            StopImpersonating();

        if (!fSuccess)
        {
            AssertNonZero(MsiCloseSysHandle(hFile));
            return PostError(Imsg(idbgErrorGettingFileTime), WIN::GetLastError(), istrFullPath);
        }

        AssertNonZero(MsiCloseSysHandle(hFile));

        // Round down to the nearest even second to avoid the 2-sec roundup problem
        // that sometimes occurs when translating between FileTime and DosDateTime
        // (the ftLastWrite struct represents time in 100 nanosecond intervals) 
        //if ((ftLastWrite.dwLowDateTime / 10000000) % 2)
        //  ftLastWrite.dwLowDateTime -= 10000000;

        //ftLastWrite.dwLowDateTime = (ftLastWrite.dwLowDateTime / 10000000) * 10000000;
        FILETIME ftLocalLastWrite;
        if (!WIN::FileTimeToLocalFileTime(&ftLastWrite, &ftLocalLastWrite))
            return PostError(Imsg(idbgErrorConvertFileTimeToLocalTime), WIN::GetLastError(), istrFullPath);

        WORD wDosDate=0, wDosTime=0;
        if (!WIN::FileTimeToDosDateTime(&ftLocalLastWrite, &wDosDate, &wDosTime))
            return PostError(Imsg(idbgErrorInFileToDosDateTime));

        int iDosDateTime = wDosDate;
        (iDosDateTime <<= 16) |= wDosTime;
        rMsiDate = (MsiDate)iDosDateTime;
        return 0;
    }
    else
    {
        return PostError(Imsg(idbgErrorOpeningFile),WIN::GetLastError(), istrFullPath);
    }
}


IMsiRecord* CMsiPath::IsFileModified(const ICHAR* szFile, Bool& fModified)
//-------------------------------------------------------------------------
// Internal function that returns fTrue in fModified if the creation date
// of the given file is different from the last modified date of that file.
//-------------------------------------------------------------------------
{
    MsiString istrFullPath;
    IMsiRecord* piError = GetFullFilePath(szFile, *&istrFullPath);
    if (piError)
        return piError;
   
    if (!FFileExists(istrFullPath, 0))
        return PostError(Imsg(idbgFileDoesNotExist), *istrFullPath);

    if (m_fImpersonate)
        AssertNonZero(StartImpersonating());

    HANDLE hFile = WIN::CreateFile(istrFullPath, GENERIC_READ, FILE_SHARE_READ, 
        0, OPEN_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);

    if (hFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwType = GetFileType(hFile);
		if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
		{
			DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), istrFullPath);
			AssertNonZero(MsiCloseUnregisteredSysHandle(hFile));
			hFile = INVALID_HANDLE_VALUE;
			SetLastError(ERROR_OPEN_FAILED);
		}
	}
			
    if (m_fImpersonate)
        StopImpersonating();

    if (hFile != INVALID_HANDLE_VALUE)
    {
        MsiRegisterSysHandle(hFile);
        FILETIME ftCreation;
        FILETIME ftLastAccess;
        FILETIME ftLastWrite;
        if (m_fImpersonate)
            AssertNonZero(StartImpersonating());

		if(!WIN::GetFileTime(hFile, &ftCreation, &ftLastAccess, &ftLastWrite))
		{
			DWORD	LastError = WIN::GetLastError();
			if (m_fImpersonate)
				StopImpersonating();

			AssertNonZero(MsiCloseSysHandle(hFile));
			return PostError(Imsg(idbgErrorGettingFileTime), LastError, istrFullPath);
		}
		if (m_fImpersonate)
			StopImpersonating();

        // Times must match to within 2 seconds for the file to be considered unmodified
        AssertNonZero(MsiCloseSysHandle(hFile));
        if ((ftLastWrite.dwHighDateTime == ftCreation.dwHighDateTime && ftLastWrite.dwLowDateTime < ftCreation.dwLowDateTime) ||
            ftLastWrite.dwHighDateTime < ftCreation.dwHighDateTime)
            fModified = fFalse;
        else if (abs(ftCreation.dwLowDateTime - ftLastWrite.dwLowDateTime) <= 20000000 && 
            ftCreation.dwHighDateTime == ftLastWrite.dwHighDateTime)
            fModified = fFalse;
        else
            fModified = fTrue;
    }
    else
    {
        int iLastError = WIN::GetLastError();
        if (iLastError == ERROR_SHARING_VIOLATION)
            return PostError(Imsg(imsgSharingViolation), (const ICHAR*) istrFullPath);
        else if (iLastError == ERROR_ACCESS_DENIED)
            return PostError(Imsg(imsgAccessToFileDenied), (const ICHAR*) istrFullPath);
        else
            return PostError(Imsg(idbgErrorOpeningFile), iLastError, istrFullPath);
    }
    return 0;
}



IMsiRecord* CMsiPath::EnsureExists(int* pcCreatedFolders)
/*-------------------------------------------------------------------------
Ensures that the complete directory path associated with this CMsiPath
obj exists.  If any subdirectory along the path is missing, it will be
created.
---------------------------------------------------------------------------*/
{

    Assert(!m_piVolume->IsURLServer());

    if(pcCreatedFolders) *pcCreatedFolders = 0;
    
    MsiString istrChopPath = m_istrPath;
    istrChopPath.Remove(iseFirst, 1); //Remove leading '\'

    MsiString istrNewPath = m_piVolume->GetPath();
    MsiString istrPathPart = istrChopPath.Extract(iseUpto, chDirSep);                       
    while (istrPathPart.TextSize() != 0)
    {
        istrChopPath.Remove(iseFirst, istrPathPart.CharacterCount() + 1);
        istrNewPath += vrgchDirSep;
        istrNewPath += istrPathPart;                                             

        Bool fExists;
        IMsiRecord* piRec = PathExists(*istrNewPath, fExists);
        if (piRec)
        {
            DWORD dwLastError = WIN::GetLastError();
            piRec->Release();
            if (dwLastError == ERROR_UNEXP_NET_ERR || dwLastError == ERROR_BAD_NETPATH || dwLastError == ERROR_NETWORK_BUSY)
                return PostError(Imsg(imsgNetErrorCreatingDir), *istrNewPath);
            else
                return PostError(Imsg(imsgErrorCreatingDir), *istrNewPath);
        }

        if (fExists == fFalse)
        {
            if (m_fImpersonate)
                AssertNonZero(StartImpersonating());

            // current error mode should include SEM_FAILCRITICALERRORS at this point to
            // prevent unnecessary pop-ups from the OS
            Bool fDirStatus = ToBool(WIN::CreateDirectory(istrNewPath, 0));
            DWORD dwLastError = WIN::GetLastError();
            if (m_fImpersonate)
                StopImpersonating();

            if (!fDirStatus)
            {
                if (dwLastError == ERROR_ACCESS_DENIED)
                    return PostError(Imsg(imsgSystemDeniedAccess), *istrNewPath);
                else if (dwLastError == ERROR_ALREADY_EXISTS)
                {
                    if (m_fImpersonate) AssertNonZero(StartImpersonating());
                    DWORD dwAttr = MsiGetFileAttributes(istrNewPath);
                    if (m_fImpersonate) StopImpersonating();
                    if(dwAttr == 0xFFFFFFFF)
                    {
                        return PostError(Imsg(imsgErrorCreatingDir), *istrNewPath);
                    }
                    else if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
                    {
                        return PostError(Imsg(imsgFileErrorCreatingDir), *istrNewPath);
                    }
                }
                else if (dwLastError == ERROR_UNEXP_NET_ERR || dwLastError == ERROR_BAD_NETPATH || dwLastError == ERROR_NETWORK_BUSY)
                    return PostError(Imsg(imsgNetErrorCreatingDir), *istrNewPath);
                else if (dwLastError == ERROR_FILENAME_EXCED_RANGE || dwLastError == ERROR_PATH_NOT_FOUND)
                    return PostError(Imsg(imsgPathNameTooLong), *istrNewPath);
                else
                    return PostError(Imsg(imsgErrorCreatingDir), *istrNewPath);
            }
            else
                if(pcCreatedFolders) (*pcCreatedFolders)++;
        }
    
        istrPathPart = istrChopPath.Extract(iseUpto, chDirSep);                      
    }
    return 0;
}


IMsiRecord* CMsiPath::Remove(bool* pfRemoved)
//--------------------------
{

    if (pfRemoved)
        *pfRemoved = false;
    Assert(!m_piVolume->IsURLServer());

    MsiString strNoBS = GetPath();
    strNoBS.Remove(iseLast, 1);

    if (m_fImpersonate)
        AssertNonZero(StartImpersonating());

    Bool fRes = ToBool(WIN::RemoveDirectory(strNoBS));
    if (fRes && pfRemoved)
        *pfRemoved = true;

    DWORD dwLastErr = WIN::GetLastError();
    if (m_fImpersonate)
        StopImpersonating();

    if(fRes == fFalse && dwLastErr == ERROR_ACCESS_DENIED)
    {
        // remove system and readonly bits and try again
        int iAttribs = 0;
        IMsiRecord* piError = 0;
        if((piError = GetAllFileAttributes(0,iAttribs)) != 0)
            return piError;

        if((piError = SetAllFileAttributes(0,0)) != 0) // clear all attributes
            return piError;

        if (m_fImpersonate)
            AssertNonZero(StartImpersonating());

        fRes = ToBool(WIN::RemoveDirectory(strNoBS));
        dwLastErr = WIN::GetLastError();

        if (m_fImpersonate)
            StopImpersonating();

        // put old attributes back if we failed to delete directory
        if(fRes == fFalse && (piError = SetAllFileAttributes(0,iAttribs)) != 0)
            return piError;
    }

    if(fRes == fTrue || dwLastErr == ERROR_DIR_NOT_EMPTY || dwLastErr == ERROR_FILE_NOT_FOUND ||
        dwLastErr == ERROR_PATH_NOT_FOUND || dwLastErr == ERROR_DELETE_PENDING)
    {
        return 0;
    }
    else
    {
        // could not delete folder - if folder is empty we have an error
        MsiString strSearchPath = GetPath();
        strSearchPath += MsiString(*TEXT("*.*"));
        // current error mode should include SEM_FAILCRITICALERRORS at this point to
        // prevent unnecessary pop-ups from the OS
        WIN32_FIND_DATA fdFindData;
        HANDLE hFile = WIN::FindFirstFile(strSearchPath, &fdFindData);

        Bool fError = fTrue; // true if folder empty or some other error
        if(hFile != INVALID_HANDLE_VALUE)
        {
            // may still only contain "." and ".."
            do
            {
                if((IStrComp(fdFindData.cFileName, TEXT("."))) &&
                    (IStrComp(fdFindData.cFileName, TEXT(".."))))
                {
                    fError = fFalse;
                    break;
                }
            }
            while(WIN::FindNextFile(hFile, &fdFindData) == TRUE);
        }
        // else empty folder or some other error

        WIN::FindClose(hFile);

        if(fError)
            return PostError(Imsg(idbgErrorRemovingDir), dwLastErr, MsiString(GetPath()));
        else
            return 0;
    }
}


IMsiRecord* CMsiPath::Writable(Bool& fWritable)
//----------------------------
{
    // If the writable status is already cached, return it now
    if (m_iwsWritable == iwsFalse || m_iwsWritable == iwsTrue)
    {
        fWritable = m_iwsWritable == iwsFalse ? fFalse : fTrue;
        return 0;
    }

    fWritable = fFalse;

    int cCreatedFolders = 0;
    IMsiRecord* piErrRec = EnsureExists(&cCreatedFolders);
    if (piErrRec == 0)
    {
        m_iwsWritable = iwsFalse;
        MsiString strNoBS = GetPath();
        strNoBS.Remove(iseLast, 1);
        ICHAR szTempFile[MAX_PATH+1];
        // current error mode should include SEM_FAILCRITICALERRORS at this point to
        // prevent unnecessary pop-ups from the OS
        if (m_fImpersonate)
            AssertNonZero(StartImpersonating());

        UINT iTempNum = WIN::GetTempFileName(strNoBS, TEXT("MSI"), 0, szTempFile );
        if (m_fImpersonate)
            StopImpersonating();

        if (iTempNum == 0)
        {
            if (WIN::GetLastError() == ERROR_DIRECTORY)
                return PostError(Imsg(idbgDirDoesNotExist),*MsiString(GetPath()));
        }
        else
        {
            if (m_fImpersonate)
                AssertNonZero(StartImpersonating());
            Bool fSuccess = ToBool(WIN::DeleteFile(szTempFile));
            DWORD dwLastErr = WIN::GetLastError();
            if (m_fImpersonate)
                StopImpersonating();

            if (!fSuccess)
                return PostError(Imsg(idbgErrorDeletingFile), dwLastErr,szTempFile);

            fWritable = fTrue;
            m_iwsWritable = iwsTrue;
        }
    }

    if(cCreatedFolders)
    {
        PMsiPath pTempPath(0);
        IMsiRecord* piRemoveErrRec;
        if ((piRemoveErrRec = ClonePath(*&pTempPath)) != 0)
        {
            if (piErrRec)
            {
                piRemoveErrRec->Release();
                return piErrRec;
            }
            else
                return piRemoveErrRec;
        }
        
        while (cCreatedFolders && !pTempPath->IsRootPath())
        {
            bool fRemoved;
            if ((piRemoveErrRec = pTempPath->Remove(&fRemoved)) != 0)
            {
                if (piErrRec)
                {
                    piRemoveErrRec->Release();
                    return piErrRec;
                }
                else
                    return piRemoveErrRec;
            }
            if (fRemoved)
                cCreatedFolders--;
            AssertZero(pTempPath->ChopPiece());
        }
    }

    return piErrRec;
}


IMsiRecord* CMsiPath::FileWritable(const ICHAR *szFileName, Bool& fWritable)
/*---------------------------------------------------------------------
FileWritable returns fTrue in fWritable only if a file with the name 
given in the szFile parameter exists in the directory associated with 
the CMsiPath object, AND that file can be opened for write-access.
-----------------------------------------------------------------------*/
{
    IMsiRecord* piRec;
    Bool fExists;
    fWritable = fFalse;
    if ((piRec = FileExists(szFileName, fExists)) != 0)
        return piRec;
    else if (!fExists)
        return 0;

    MsiString istrFileName;
    piRec = GetFullFilePath(szFileName, *&istrFileName);
    if (piRec)               
        return piRec;

    if (m_fImpersonate)
        AssertNonZero(StartImpersonating());

    HANDLE hFile = WIN::CreateFile(istrFileName, GENERIC_WRITE, 0, 0, OPEN_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);

    if (hFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwType = GetFileType(hFile);
		if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
		{
			DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), istrFileName);
			AssertNonZero(MsiCloseUnregisteredSysHandle(hFile));
			hFile = INVALID_HANDLE_VALUE;
			SetLastError(ERROR_OPEN_FAILED);
		}
	}
			
    if (hFile != INVALID_HANDLE_VALUE)
    {
        AssertNonZero(MsiCloseUnregisteredSysHandle(hFile));
        fWritable = fTrue;
    }
    if (m_fImpersonate)
        StopImpersonating();

    if (hFile != INVALID_HANDLE_VALUE)
        fWritable = fTrue;

    return 0;
}

IMsiRecord* CMsiPath::ClusteredFileSize(unsigned int uiFileSize, unsigned int& uiClusteredSize)
//-------------------------------------
{
    int iVolClusterSize = m_piVolume->ClusterSize();
    uiClusteredSize = ((uiFileSize + iVolClusterSize - 1) / iVolClusterSize) * iVolClusterSize;
    uiClusteredSize /= iMsiMinClusterSize;
    return 0;
}


IMsiRecord* CMsiPath::GetFileInstallState(const IMsiString& riFileNameString,
                                                        const IMsiString& riFileVersionString,
                                                        const IMsiString& riFileLanguageString,
                                                        MD5Hash* pHash,
                                                        ifsEnum& rifsExistingFileState,
                                                        Bool& fShouldInstall,
                                                        unsigned int* puiExistingFileSize,
                                                        Bool* pfInUse,
                                                        int fInstallModeFlags,
                                                        int* pfVersioning)
/*----------------------------------------------------------------------------
Determines the specified file's installation state, based on specifications 
supplied by the flag bits specified in fInstallModeFlags.

The riFileNameString and riFileVersionString parameters define the file name and
version of the file to be checked (which is assumed to reside in the directory
associated with the CMsiPath object).

The installation state of the currently installed version of this file (if any)
is returned as an enum in the rifsExistingFileState parameter.  The enumerated
values are define in path.h as ifs* constants.

Based on fInstallModeFlags (and the installation state of any currently
installed version), GetFileInstallState determines whether the specified file
actually needs to be copied.  If so, fTrue will be returned in fShouldInstall.
The allowable bit values for fInstallModeFlags are specified by icm* constants,
defined in engine.h.

If there is a currently installed version of the file, the clustered size of
that file is returned in puiExistingFileSize (whether fShouldInstall is
returned as fTrue or not). If there is no existing version present, 0 will be
returned. This parameter can be passed as NULL if this value is not needed.

If an existing version of the file is in use by another process, 
GetFileInstallState will return fTrue in the pfInUse parameter.  This
parameter can be passed as NULL if this value is not needed.
----------------------------------------------------------------------------*/
{
    if (puiExistingFileSize) *puiExistingFileSize = 0;
    if (pfInUse) *pfInUse = fFalse;

    ifsEnum ifsState = ifsAbsent;
    Bool fVerificationFailed = fFalse;
    fShouldInstall = fFalse;

#ifdef DEBUG
    ICHAR rgchFileName[256];
    ICHAR rgchVersion[256];
    riFileNameString.CopyToBuf(rgchFileName,255);
    riFileVersionString.CopyToBuf(rgchVersion,255);
#endif

    icfvEnum icfvResult;
    IMsiRecord* piErrRec;
    piErrRec = CheckFileVersion(riFileNameString.GetString(),riFileVersionString.GetString(),
                                riFileLanguageString.GetString(), pHash, icfvResult, pfVersioning);
    if (piErrRec)
        return piErrRec;

    if (icfvResult == icfvNoExistingFile)
        ifsState = ifsAbsent;
    else if (icfvResult == icfvExistingLower)
        ifsState = ifsExistingLowerVersion;
    else if (icfvResult == icfvExistingEqual)
        ifsState = ifsExistingEqualVersion;
    else if (icfvResult == icfvExistingHigher)
        ifsState = ifsExistingNewerVersion;
    else if (icfvResult == icfvFileInUseError)
        ifsState = ifsExistingFileInUse;
    else if (icfvResult == icfvAccessToFileDenied)
        ifsState = ifsAccessToFileDenied;
    else if (icfvResult == icfvVersStringError)
    {
        // The version field might contain a Companion filekey reference - 
        // don't throw an error
        ifsState = ifsCompanionSyntax;
        Bool fExists;
        piErrRec = FileExists(riFileNameString.GetString(),fExists);
        if (piErrRec)
            return piErrRec;
        if (fExists)
            ifsState = ifsCompanionExistsSyntax;
    }
    else
    {
        Assert(fFalse);
        ifsState = ifsAbsent;
    }

    Bool fLocalInUse = (ifsState == ifsExistingFileInUse) ? fTrue : fFalse;
    Bool fCheckedFileInUse = fLocalInUse;

    // icmOverwriteAllFiles
    if (fInstallModeFlags & icmOverwriteAllFiles)
    {
        fVerificationFailed = fTrue;
        if (ifsState & ifsBitExisting)
            ifsState = ifsExistingAlwaysOverwrite;
    }
    else
    {
        // icmOverwriteNone - write only if file is missing altogether
        if ((fInstallModeFlags & icmOverwriteNone) && !(ifsState & ifsBitExisting))
            fVerificationFailed = fTrue;
        
        // icmOverwriteDifferingVersions
        if (fInstallModeFlags & icmOverwriteDifferingVersions)
        {
            if (ifsState != ifsExistingEqualVersion)
                fVerificationFailed = fTrue;
        }
        
        // icmOverwriteOlderVersions
        if (fInstallModeFlags & icmOverwriteOlderVersions)
        {
            // The only difference in version checking between normal files
            // and companion files is summarized right here.
            if (fInstallModeFlags & icmCompanionParent)
            {
                if (ifsState != ifsExistingNewerVersion)
                    fVerificationFailed = fTrue;
            }
            else
            {
                if (ifsState != ifsExistingEqualVersion && ifsState != ifsExistingNewerVersion)
                    fVerificationFailed = fTrue;
            }
        }

        // icmOverwriteEqualVersions
        if (fInstallModeFlags & icmOverwriteEqualVersions)
        {
            if (ifsState != ifsExistingNewerVersion)
                fVerificationFailed = fTrue;
        }

        // icmVerifyFileChecksum
        // If verification hasn't failed already, compare the stored and computed
        // checksums to detect a corrupted file.
        if (!fVerificationFailed && (fInstallModeFlags  & icmOverwriteCorruptedFiles))
        {
            // If file doesn't exist, verification fails right away.
            if (ifsState & ifsBitExisting)
            {
                Bool fChecksumValid;
                piErrRec = VerifyFileChecksum(riFileNameString.GetString(),fChecksumValid);
                if (piErrRec)
                {
                    if (piErrRec->GetInteger(1) == idbgErrorNoChecksum)
                    {
                        piErrRec->Release();
                        fChecksumValid = fFalse;
                    }
                    else
                    {
                        return piErrRec;
                    }
                }
                if (!fChecksumValid)
                {
                    bool fAcceptChecksumFailure = true;
                    if (g_fWin9X)
                    {
                        if (!fCheckedFileInUse)
                        {
                            piErrRec = FileInUse(riFileNameString.GetString(), fLocalInUse);
                            if (piErrRec)
                                return piErrRec;
                            fCheckedFileInUse = fTrue;
                        }

                        if (fLocalInUse)
                            fAcceptChecksumFailure = false;
                    }
                    if (fAcceptChecksumFailure)
                    {
                        ifsState = ifsExistingCorrupt;
                        fVerificationFailed = fTrue;
                    }
                }
            }
            else
                fVerificationFailed = fTrue;
        }
    }   

    rifsExistingFileState = ifsState;
    if (fVerificationFailed == fTrue)
        fShouldInstall = fTrue;

    if (ifsState & ifsBitExisting)
    {
        if (pfInUse)
        {
            if(!fCheckedFileInUse)
            {
                piErrRec = FileInUse(riFileNameString.GetString(), fLocalInUse);
                if (piErrRec)
                    return piErrRec;
            }

            if (fLocalInUse == fTrue)
                *pfInUse = fTrue;
        }

        if (puiExistingFileSize)
        {
            unsigned int uiFileSize;
            piErrRec = FileSize(riFileNameString.GetString(),uiFileSize);
            if (piErrRec)
                return piErrRec;
            piErrRec = ClusteredFileSize(uiFileSize,*puiExistingFileSize);
            if (piErrRec)
                return piErrRec;
        }

    }
    return 0;
}

IMsiRecord* CMsiPath::GetCompanionFileInstallState(const IMsiString& riParentFileNameString,
                                                                     const IMsiString& riParentFileVersionString,
                                                                     const IMsiString& riParentFileLanguageString,
                                                                     IMsiPath& riCompanionPath,
                                                                     const IMsiString& riCompanionFileNameString,
                                                                     MD5Hash* pCompanionHash,
                                                                     ifsEnum& rifsExistingFileState,
                                                                     Bool& fShouldInstall,
                                                                     unsigned int* puiExistingFileSize,
                                                                     Bool* fInUse,
                                                                     int fInstallModeFlags,
                                                                     int* pfVersioning)
/*----------------------------------------------------------------------------
Just like GetFileInstallState, but performs an extra hash check on the
Companion file if the version check on the Parent file said to install the file.

This function should be used instead of GetFileInstallState when checking
companion files
----------------------------------------------------------------------------*/
{
    IMsiRecord* piError = GetFileInstallState(riParentFileNameString,
                                                                        riParentFileVersionString,
                                                                        riParentFileLanguageString,
                                                                        0 /* pHash */,
                                                                        rifsExistingFileState,
                                                                        fShouldInstall,
                                                                        puiExistingFileSize,
                                                                        fInUse,
                                                                        fInstallModeFlags|icmCompanionParent,
                                                                        pfVersioning);


    if(piError == 0 && fShouldInstall && pCompanionHash)
    {
        icfhEnum icfhResult = (icfhEnum)0;
        piError = riCompanionPath.CheckFileHash(riCompanionFileNameString.GetString(), *pCompanionHash, icfhResult);

        if(piError == 0 && icfhResult == icfhMatch)
        {
            // existing file already matches source file - no reason to install
            fShouldInstall = fFalse;
        }
    }
    return piError;


}

IMsiRecord* CMsiPath::VerifyFileChecksum(const ICHAR* szFileName,Bool& rfChecksumValid)
//--------------------------------------
{
    DWORD dwHeaderSum,dwComputedSum;
    IMsiRecord* piError = GetFileChecksum(szFileName,&dwHeaderSum,&dwComputedSum);
    rfChecksumValid = dwHeaderSum == dwComputedSum ? fTrue : fFalse;
    return piError;
}

IMsiRecord* CMsiPath::GetFileChecksum(const ICHAR* szFileName,DWORD* pdwHeaderSum, DWORD* pdwComputedSum)
//-----------------------------------
{
    MsiString istrFullFilePath;
    IMsiRecord* piError = GetFullFilePath(szFileName, *&istrFullFilePath);
    if (piError)
        return piError;

    if (m_fImpersonate)
        AssertNonZero(StartImpersonating());

    CHandle hFile = WIN::CreateFile(istrFullFilePath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);


    if (hFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwType = GetFileType(hFile);
		if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
		{
			DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), istrFullFilePath);
			hFile = INVALID_HANDLE_VALUE;
			SetLastError(ERROR_OPEN_FAILED);
		}
	}
			
    if(hFile == INVALID_HANDLE_VALUE)
    {
        if (m_fImpersonate)
            StopImpersonating();
        return PostError(Imsg(idbgErrorOpeningFile), WIN::GetLastError(), istrFullFilePath);
    }
    
    CHandle hFileMapping = WIN::CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);
    if(hFileMapping == INVALID_HANDLE_VALUE)
    {
        if (m_fImpersonate)
            StopImpersonating();
        return PostError(Imsg(idbgErrorOpeningFile), WIN::GetLastError(), istrFullFilePath);
    }

    void* pFile = WIN::MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
    if (pFile == 0)
    {
        if (m_fImpersonate)
            StopImpersonating();
        return PostError(Imsg(idbgErrorOpeningFile), WIN::GetLastError(), istrFullFilePath);
    }

    piError = GetChecksums(istrFullFilePath,pFile,GetFileSize(hFile,0),
                                  pdwHeaderSum,pdwComputedSum);

    WIN::UnmapViewOfFile(pFile);
    
    if (m_fImpersonate)
        StopImpersonating();

    return piError;
}

IMsiRecord* CMsiPath::GetChecksums(const ICHAR* szFile, void* pbFileStart, int cbFileSize, DWORD* pdwHeaderSum, DWORD* pdwComputedSum)
// szFile is for error messages only
{
    Assert(szFile);
    DWORD dwHeaderSum,dwComputedSum;
    typedef PIMAGE_NT_HEADERS (IMAGEAPI* pfnCheckSumMappedFile)(LPVOID BaseAddress, DWORD FileLength, LPDWORD HeaderSum, LPDWORD CheckSum);
    const char* CHECKSUM_PROC   = "CheckSumMappedFile";
    const ICHAR* IMAGEHELP_DLL    = TEXT("imagehlp.dll");

    HINSTANCE hinstImageHlp = 0;
    pfnCheckSumMappedFile pfnCheckSum=0;

    if(((hinstImageHlp = LoadLibrary(IMAGEHELP_DLL)) == 0) ||
        ((pfnCheckSum = (pfnCheckSumMappedFile)GetProcAddress(hinstImageHlp, CHECKSUM_PROC)) == 0))
        // cannot checksum, error 
        return PostError(Imsg(idbgErrorImageFileAbsent), szFile);


    PIMAGE_NT_HEADERS pImageHeader = (*pfnCheckSum)(pbFileStart,cbFileSize,&dwHeaderSum,&dwComputedSum);
    FreeLibrary(hinstImageHlp);

    if (pImageHeader == NULL)
    {
        return PostError(Imsg(idbgErrorNoChecksum),szFile);
    }

    if (pdwHeaderSum)
        *pdwHeaderSum = dwHeaderSum;
    if (pdwComputedSum)
        *pdwComputedSum = dwComputedSum;

    return 0;
}

IMsiRecord* CMsiPath::RecomputeChecksum(const ICHAR* szFile, void* pbFileStart, int cbFileSize)
{
    Assert(szFile);
    DWORD dwHeaderSum,dwComputedSum;

    IMsiRecord* piError = 0;
    if((piError = GetChecksums(szFile,pbFileStart,cbFileSize,
                                        &dwHeaderSum,&dwComputedSum)) != 0)
        return piError;

    if(dwHeaderSum == dwComputedSum)
    {
        // checksums already match
        return 0;
    }

    PIMAGE_NT_HEADERS pNTHeader = (PIMAGE_NT_HEADERS)((INT_PTR) pbFileStart +           //--merced: changed int to INT_PTR
                    (INT_PTR)(((PIMAGE_DOS_HEADER)(LPVOID)pbFileStart)->e_lfanew));     //--merced: changed int to INT_PTR

    // set checksum
    pNTHeader->OptionalHeader.CheckSum = dwComputedSum;
    return 0;
}

const IMsiString& CreateVersionString(DWORD dwMSVer, DWORD dwLSVer)
{
    ICHAR rgchVersion[256];
    StringCchPrintf(rgchVersion,(sizeof(rgchVersion)/sizeof(ICHAR)),TEXT("%i.%i.%i.%i"),HIWORD(dwMSVer),LOWORD(dwMSVer),
        HIWORD(dwLSVer),LOWORD(dwLSVer));

    MsiString strVersion(rgchVersion);
    return strVersion.Return();
}

IMsiRecord* CMsiPath::GetFileVersionString(const ICHAR* szFile, const IMsiString*& rpiVersion)
//----------------------------------------
{
    MsiString istrFullFilePath;
    IMsiRecord* piError = GetFullFilePath(szFile, *&istrFullFilePath);
    if (piError)
        return piError;

    DWORD dwMSVer, dwLSVer;
    ifiEnum ifiResult = GetFileVersion(istrFullFilePath,dwMSVer, dwLSVer);
    if (ifiResult != ifiNoError)
    {
        if (ifiResult == ifiNoFile || ifiResult == ifiNoFileInfo)
        {
            rpiVersion = &CreateString();
            return 0;
        }
        else if (ifiResult == ifiFileInUseError)
        {
            return PostError(Imsg(imsgSharingViolation), *istrFullFilePath);
        }
        else
        {
            Assert(ifiResult == ifiFileInfoError);
            return PostError(Imsg(idbgErrorGettingFileVerInfo), *istrFullFilePath);
        }
    }
    
    rpiVersion = &CreateVersionString(dwMSVer, dwLSVer);
    return 0;
}


icfvEnum CompareVersions(DWORD dwExistMS, DWORD dwExistLS, DWORD dwNewMS, DWORD dwNewLS)
{
    icfvEnum icfvResult;
    if (dwExistMS > dwNewMS)
        icfvResult = icfvExistingHigher;
    else if (dwExistMS == dwNewMS)
    {
        if (dwExistLS > dwNewLS)
            icfvResult = icfvExistingHigher;
        else if (dwExistLS == dwNewLS)
            icfvResult = icfvExistingEqual;
        else 
            icfvResult = icfvExistingLower;
    }
    else
    {
        icfvResult = icfvExistingLower;
    }
    return icfvResult;
}

Bool FVersioned(DWORD dwMSVer, DWORD dwLSVer)
{
    if (dwMSVer == 0 && dwLSVer == 0)
        return fFalse;
    else
        return fTrue;
}

IMsiRecord* CMsiPath::CheckFileVersion(const ICHAR* szFile,
                                                    const ICHAR* szVersion,
                                                    const ICHAR* szLang,
                                                    MD5Hash* pHash,
                                                    icfvEnum& icfvResult,
                                                    int* pfVersioning)
//------------------------------------
{
    // Is the file to be installed versioned?  If so, get the numerical version
    // from the given version string.
    DWORD dwNewMS, dwNewLS;
    if (ParseVersionString(szVersion,dwNewMS, dwNewLS) == fFalse)
        return (icfvResult = icfvVersStringError,0);

    Bool fNewVersioned = FVersioned(dwNewMS, dwNewLS);
    if (pfVersioning)
        *pfVersioning = fNewVersioned ? ifBitNewVersioned : 0;

    // Get the version (if any) of the existing file (if any)
    MsiString strFullFilePath;
    IMsiRecord* piErrRec = GetFullFilePath(szFile, *&strFullFilePath);
    if (piErrRec)
        return piErrRec;

    unsigned short rgwExistLangID[cLangArrSize];
    int iExistLangCount;

    DWORD dwExistMS, dwExistLS;
    ifiEnum ifiResult = GetAllFileVersionInfo(strFullFilePath, &dwExistMS, &dwExistLS, 
        rgwExistLangID, cLangArrSize, &iExistLangCount, m_fImpersonate);
    if (ifiResult == ifiNoFile)
    {
        return (icfvResult = icfvNoExistingFile, 0);
    }
    else if (ifiResult == ifiFileInUseError)
    {
        // Existing file is opened with exclusive access.  If the
        // corresponding file on the source media is unversioned,
        // we assume that the existing file is a data file that has
        // been, or will be, modified.  We therefore won't replace it.
        if (fNewVersioned == fFalse)
            return (icfvResult = icfvExistingHigher, 0);
        else
            return (icfvResult = icfvFileInUseError, 0);
    }
    else if (ifiResult == ifiFileInfoError)
    {
        return PostError(Imsg(idbgErrorGettingFileVerInfo), *strFullFilePath);
    }
    else if (ifiResult == ifiAccessDenied)
    {
        return (icfvResult = icfvAccessToFileDenied, 0);
    }
    else
    {
        Assert(ifiResult == ifiNoError || ifiResult == ifiNoFileInfo);
    }

    Bool fExistingVersioned = FVersioned(dwExistMS, dwExistLS);
    if (pfVersioning && fExistingVersioned)
        *pfVersioning |= ifBitExistingVersioned;

    // If both files are unversioned, we'll compare the existing file's
    // 'modified' and 'create' dates
    if (fExistingVersioned == fFalse && fNewVersioned == fFalse)
    {
        Bool fModified;
        piErrRec = IsFileModified(szFile,fModified);
        if (piErrRec)
        {
            // Again, if existing file is in-use, and the corresponding
            // source file is unversioned, assume existing file is being,
            // or will be, modified.
            int iError = piErrRec->GetInteger(1);
            if (iError == imsgSharingViolation && fNewVersioned == fFalse)
            {
                piErrRec->Release();
                return (icfvResult = icfvExistingHigher, 0);
            }
            else
                return piErrRec;
        }
        if(fModified)
        {
            icfvResult = icfvExistingHigher;
        }
        else
        {
            // unversioned, unmodified file.  in lieu of a version check check the file hash instead
            if(pHash)
            {
                icfhEnum icfhResult;
                piErrRec = CheckFileHash(szFile, *pHash, icfhResult);

                // should only fail if something really catastrophic happens
                if(piErrRec)
                    return piErrRec;

                switch(icfhResult)
                {
                case icfhNoExistingFile:
                    Assert(0); // should have been caught above
                    icfvResult = icfvNoExistingFile;
                    break;

                case icfhMatch:
                    // hash match - don't return, continue function
                    icfvResult = icfvExistingEqual;
                    break;
                
                case icfhMismatch:
                case icfhFileInUseError:
                case icfhHashError:
                case icfhAccessDenied:
                default:
                    // hashes don't match, or
                    // could not determine hash for whatever reason
                    // since the hash check is only for optimization,
                    // it isn't a big deal if the hash can't be determined
                    // just assume the hash doesn't match
                    icfvResult = icfvExistingLower;
                    if (pfVersioning)
                        *pfVersioning |= ifBitUnversionedHashMismatch;
                    break;
                };
            }
            else
            {
                // can't check version or hash, so assume existing file is lower
                icfvResult = icfvExistingLower;
            }
        }

        if (pfVersioning && fModified)
            *pfVersioning |= ifBitExistingModified;

        return 0;
    }
    else
    {
        // Else, if versions are equal, we'll compare languages
        icfvResult = CompareVersions(dwExistMS, dwExistLS, dwNewMS, dwNewLS);
        if (icfvResult == icfvExistingEqual)
        {
            iclEnum iclResult;
            piErrRec = CheckLanguageIDs(szFile, szLang,iclResult, rgwExistLangID, iExistLangCount);
            if (piErrRec)
                return piErrRec;
            if (iclResult == iclLangStringError)
                return PostError(Imsg(idbgErrorGettingFileVerInfo), *strFullFilePath);
            else if (iclResult == iclExistEqual || (iclResult == iclExistNoLang && IStrLen(szLang) == 0))
                icfvResult = icfvExistingEqual;
            else if (iclResult == iclExistSuperset)
                icfvResult = icfvExistingHigher;
            else
            {
                icfvResult = icfvExistingLower;
                if (pfVersioning)
                    *pfVersioning |= ifBitExistingLangSubset;
            }
        }

    }
    
    return 0;
}

IMsiRecord* CMsiPath::EnsureOverwrite(const ICHAR* szFile, int* piOldAttributes)
/*----------------------------------------------------------------------
If an existing file is in our way, make sure it doesn't have read-only,
hidden, or system attributes.
------------------------------------------------------------------------*/
{
    if(piOldAttributes)
        *piOldAttributes = -1;
    
    Bool fExists;
    IMsiRecord* piRec;
    if ((piRec = FileExists(szFile,fExists)) != 0)
        return piRec;
    if (fExists)
    {
        int iExistingAttribs;
        if ((piRec = GetAllFileAttributes(szFile,iExistingAttribs)) != 0)
            return piRec;
        int iAttribsToSet = iExistingAttribs;
        iAttribsToSet &= (~FILE_ATTRIBUTE_HIDDEN);
        iAttribsToSet &= (~FILE_ATTRIBUTE_SYSTEM);
        iAttribsToSet &= (~FILE_ATTRIBUTE_READONLY);
        if (iAttribsToSet != iExistingAttribs)
        {
            if ((piRec = SetAllFileAttributes(szFile,iAttribsToSet)) != 0)
                return piRec;
        }
        if(piOldAttributes)
            *piOldAttributes = iExistingAttribs;
    }
    return 0;
}



IMsiRecord* CMsiPath::RemoveFile(const ICHAR* szFile)
//------------------------------
{
    Bool fExists;
    IMsiRecord* piErrRec = FileExists(szFile, fExists);
    if (piErrRec)
        return piErrRec;

    if (!fExists)
        return 0;

    IMsiRecord* piError = EnsureOverwrite(szFile, 0);
    if (piError)
        return piError;

    MsiString istrFullFilePath;
    piError = GetFullFilePath(szFile, *&istrFullFilePath);
    if (piError)
        return piError;

    if (m_fImpersonate)
        AssertNonZero(StartImpersonating());

    Bool fDeleted = WIN::DeleteFile(istrFullFilePath) ? fTrue : fFalse;

    DWORD dwLastErr = WIN::GetLastError();
    if (m_fImpersonate)
        StopImpersonating();

    if (!fDeleted)
    {
        // Win9x has no security and Access Denied is returned instead of sharing violation
        if (dwLastErr == ERROR_ACCESS_DENIED && !g_fWin9X)
            return PostError(Imsg(imsgAccessToFileDenied), (const ICHAR*) istrFullFilePath);
        else
            return PostError(Imsg(idbgErrorDeletingFile),dwLastErr, istrFullFilePath);
    }
    return 0;
}


IMsiRecord* CMsiPath::FileInUse(const ICHAR* szFileName, Bool& fInUse)
/*----------------------------------------------------------------------------
FileInUse returns fTrue in fInUse only if a file with the name given by
szFileName exists in the directory associated with the CMsiPath object, AND 
that file is 'in use' by another process.
Returns: an error record if the specified file doesn't exist.

Note: FileInUse doesn't work for read-only files that reside on a read-only
server share.  In this case, fFalse is always returned, with no error.
------------------------------------------------------------------------------*/
{
    fInUse = fFalse;

    MsiString istrFullFilePath;
    IMsiRecord* piError = GetFullFilePath(szFileName, *&istrFullFilePath);
    if (piError)
        return piError;

    // If ReadOnly bit is set for a file, take it off temporarily so we don't 
    // miss a file that is both read-only and in-use.
    Bool fReadOnly;
    piError = GetFileAttribute(szFileName, ifaReadOnly,fReadOnly);
    if (piError)
        return piError;

    if (fReadOnly)
    {
        piError = SetFileAttribute(szFileName,ifaReadOnly,fFalse);
        if (piError)
        {   // If we couldn't turn off the read-only bit (e.g. file
            // on a read-only share), we won't be able to determine
            // in-use status.  Bail now.
            piError->Release();
            return 0;
        }
    }

    if (m_fImpersonate)
        AssertNonZero(StartImpersonating());

    HANDLE hFile = WIN::CreateFile(istrFullFilePath, GENERIC_WRITE, 0,
               (LPSECURITY_ATTRIBUTES)0, OPEN_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), (HANDLE)0);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        DWORD dwErr = WIN::GetLastError();
        if (dwErr == ERROR_SHARING_VIOLATION || dwErr == ERROR_LOCK_VIOLATION)
            fInUse = fTrue;
    }
    else
        AssertNonZero(MsiCloseUnregisteredSysHandle(hFile));

    if (m_fImpersonate)
        StopImpersonating();

    if (fReadOnly)
    {
        piError = SetFileAttribute(szFileName,ifaReadOnly,fTrue);
        if (piError)
            return piError;
    }
    return 0;
}


IMsiRecord* CMsiPath::GetLangIDStringFromFile(const ICHAR* szFileName, const IMsiString*& rpiLangIds)
//-------------------------------------------
{
    MsiString istrFullFilePath;
    IMsiRecord* piError = GetFullFilePath(szFileName, *&istrFullFilePath);
    if (piError)
        return piError;

    unsigned short rgwLangID[cLangArrSize];
    int iExistLangCount;
    ifiEnum ifiLang = GetLangIDArrayFromFile(istrFullFilePath, rgwLangID,cLangArrSize,iExistLangCount);

    if (ifiLang == ifiNoFile)
        return PostError(Imsg(idbgFileDoesNotExist), *istrFullFilePath);
    else if(ifiLang == ifiFileInfoError)
        return PostError(Imsg(idbgErrorGettingFileVerInfo), *istrFullFilePath);
    // if ifiLang == ifiNoFileInfo, return an empty string below

    rpiLangIds = &CreateString();
    for (int iRec = 1; iRec <= iExistLangCount; iRec++)
    {
        ICHAR rgch[18];
#ifdef UNICODE
        rpiLangIds->AppendString(_itow(rgwLangID[iRec - 1],rgch,10),rpiLangIds);
#else
        rpiLangIds->AppendString(_itoa(rgwLangID[iRec - 1],rgch,10),rpiLangIds);
#endif
        if (iRec < iExistLangCount)
            rpiLangIds->AppendString(TEXT(", "),rpiLangIds);
    }
    return 0;
}

IMsiRecord* CMsiPath::CheckLanguageIDs(const ICHAR* szFileName, const ICHAR* szIds, iclEnum& riclResult)
{

    return CheckLanguageIDs(szFileName, szIds, riclResult, 0, 0);

}

IMsiRecord* CMsiPath::CheckLanguageIDs(const ICHAR* szFileName, const ICHAR* szIds, iclEnum& riclResult, unsigned short rgw[], int iExistLangCount)
//------------------------------------
{

    unsigned short *prgwIDs;
    
    unsigned short rgwExistLangID[cLangArrSize];

    if (rgw == 0)   
    {
        MsiString istrFullFilePath;
        IMsiRecord* piError = GetFullFilePath(szFileName, *&istrFullFilePath);
        if (piError)
            return piError;
            
        ifiEnum ifiLang = GetLangIDArrayFromFile(istrFullFilePath, rgwExistLangID,cLangArrSize,iExistLangCount);

        if (ifiLang == ifiNoFile)
            return (riclResult = iclExistNoFile,0);
        else if (ifiLang == ifiNoFileInfo)
            return (riclResult = iclExistNoLang,0);
        else if (ifiLang == ifiFileInfoError)
            return PostError(Imsg(idbgErrorGettingFileVerInfo), *istrFullFilePath);

        prgwIDs = rgwExistLangID;
    }
    else if (iExistLangCount == -1)
    {
        // A -1 was filled in when the data was gathered if there was no language information
        return (riclResult = iclExistNoLang,0);
    }
    else
        prgwIDs = rgw;
        
    unsigned short rgwNewLangID[cLangArrSize];
    int iNewLangCount;
    if (!GetLangIDArrayFromIDString(szIds, rgwNewLangID, cLangArrSize, iNewLangCount))
        return (riclResult = iclLangStringError,0);

    int iMatch = 0;

	// neutral is not treated differently from any other language
	// in all cases, favor language carried with product
    for (int iExist = 0;iExist < iExistLangCount;iExist++)
    {
        for (int iNew = 0;iNew < iNewLangCount;iNew++)
        {
            if (rgwNewLangID[iNew] == prgwIDs[iExist])
                iMatch++;
        }
    }

    if (iMatch == 0)
        return (riclResult = iclExistNullSet,0);
    else if (iExistLangCount == iNewLangCount)
    {
        if (iMatch == iExistLangCount)
            return (riclResult = iclExistEqual,0);
        else
            return (riclResult = iclExistIntersect,0);
    }
    else if (iExistLangCount > iNewLangCount)
    {
        if (iMatch == iNewLangCount)
            return (riclResult = iclExistSuperset,0);
        else
            return (riclResult = iclExistIntersect,0);
    }
    else
    {
        if (iMatch == iExistLangCount)
            return (riclResult = iclExistSubset,0);
        else
            return (riclResult = iclExistIntersect,0);
    }
}


IMsiRecord* CMsiPath::Compare(IMsiPath& riPath, ipcEnum& ipc)
//---------------------------
{
    PMsiVolume pVol = &riPath.GetVolume();

    if (pVol != m_piVolume)
    {
        MsiString strVolPath = pVol->GetPath();
        MsiString strOurVol = m_piVolume->GetPath();

        if (!strVolPath.Compare(iscExactI, strOurVol))
        {
            ipc = ipcNoRelation;
            return 0;
        }
    }
    
    MsiString strPath = riPath.GetRelativePath();
    
    if (m_istrPath.Compare(iscExactI, strPath))
        ipc = ipcEqual;
    else if (m_istrPath.Compare(iscStartI, strPath))
        ipc = ipcParent;
    else if (strPath.Compare(iscStartI, m_istrPath))
        ipc = ipcChild;
    else 
        ipc = ipcNoRelation;

    return 0;
}

IMsiRecord*  CMsiPath::Child(IMsiPath& riParent, const IMsiString*& rpiChild)
//--------------------------
{
    ipcEnum ipc;

    IMsiRecord *pRec = Compare(riParent, ipc);
    if (pRec)
        return pRec;
    switch(ipc)
    {
        case ipcParent:
            {
                // If one is the parent, the volume part should be identical
                MsiString strOurPath = GetRelativePath();
                MsiString strParent = riParent.GetRelativePath();
                rpiChild = &strOurPath.Extract(iseLast, strOurPath.CharacterCount() - strParent.CharacterCount());        
                break;
            }
        case ipcEqual:
            rpiChild = &CreateString();
            break;
        default:
            {
                MsiString strOurPath = GetPath();
                MsiString strParent = riParent.GetPath();
                return PostError(Imsg(idbgNotParent), *strParent, *strOurPath);
            }
    }
    return 0;
}


IMsiRecord* CMsiPath::CreateTempFolder(const ICHAR* szPrefix, const ICHAR* szExtension,
                                              Bool fFolderNameOnly, LPSECURITY_ATTRIBUTES pSecurityAttributes, 
                                              const IMsiString*& rpiFolderName)
//--------------------------------
{
    return TempFolderOrFile(fTrue, szPrefix, szExtension, fFolderNameOnly, pSecurityAttributes, rpiFolderName);
}

IMsiRecord* CMsiPath::TempFolderOrFile(Bool fFolder, const ICHAR* szPrefix, const ICHAR* szExtension,
                                                    Bool fNameOnly, LPSECURITY_ATTRIBUTES pSecurityAttributes,
                                                    const IMsiString*& rpiName)
//--------------------------------
{
    ICHAR rgchBuffer[_MAX_PATH];
    MsiString strPath = GetPath();
    Bool fCreatedFile = fFalse;
    Bool fFileUnwritable = fFalse;
    Bool fError = fFalse;
    int iError = 0;
    int cchPrefix = (szPrefix) ? IStrLen(szPrefix) : 0;

    if(!fFolder && cchPrefix < 4 && (szExtension == 0 || *szExtension == 0))
    {
        // using default extension, use GetTempFileName
        if (m_fImpersonate)
            AssertNonZero(StartImpersonating());

        // Win95 doesn't like a NULL szPrefix passed to GetTempFileName
        if(!szPrefix)
            szPrefix = TEXT("");
        BOOL fRes = WIN::GetTempFileName(strPath, szPrefix, 0 , rgchBuffer);

        if(fRes == fFalse)
        {
            iError = GetLastError();
            fError = fTrue;
        }


        if (!fError && pSecurityAttributes && pSecurityAttributes->lpSecurityDescriptor)
        {
            // secure and zero the file out.
            // elevate for local files when we can get privileges.
            bool fSecurityElevate = RunningAsLocalSystem() && !m_fImpersonate;
            CElevate elevate(fSecurityElevate);
            CRefCountedTokenPrivileges cPrivs(itkpSD_WRITE, fSecurityElevate);

            if (!WIN::SetFileSecurity(rgchBuffer, GetSecurityInformation(pSecurityAttributes->lpSecurityDescriptor), pSecurityAttributes->lpSecurityDescriptor))
            {
                fError = fTrue;
                iError = GetLastError();
            }
            else
            {
				HANDLE hFile = WIN::CreateFile(rgchBuffer, GENERIC_WRITE, 0, NULL, TRUNCATE_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);

				if (hFile != INVALID_HANDLE_VALUE)
				{
					DWORD dwType = GetFileType(hFile);
					if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
					{
						DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), rgchBuffer);
						CloseHandle(hFile);
						hFile = INVALID_HANDLE_VALUE;
						SetLastError(ERROR_OPEN_FAILED);
					}
				}
						
                if (INVALID_HANDLE_VALUE == hFile)
                {
                    fFileUnwritable = fTrue;
                    fError = fTrue;
                    iError = WIN::GetLastError();
                }
                else
                    CloseHandle(hFile);
            }
        }

        if (m_fImpersonate)
            StopImpersonating();

        if (!fError)
            fCreatedFile = fTrue;
    }
    else
    {
        // need a different extension - create our own name
        ICHAR rgchExtension[10] = {TEXT(".tmp")};

        if(szExtension && *szExtension)
            StringCchCopyN(rgchExtension+1, (sizeof(rgchExtension)/sizeof(ICHAR))-1, szExtension, 3);

        if(cchPrefix > 8)
            cchPrefix = 8; // use only first 8 chars of prefix
        
        int cDigits = 8-cchPrefix; // number of hex digits to use in file name

        static bool fInitialized = false;
        static unsigned int uiUniqueStart;

        // Might be a chance for two threads to get in here, we're not going to be worried
        // about that. It would get intialized twice
        if (!fInitialized)
        {
            uiUniqueStart = GetTickCount();
            fInitialized = true;
        }
        unsigned int uiUniqueId = uiUniqueStart++;
        
        if(cchPrefix)
            uiUniqueId &= ((1 << 4*cDigits) - 1);
        
        unsigned int cPerms = cDigits == 8 ? ~0 : (1 << 4*cDigits) -1; // number of possible file names to try ( minus 1 )
        
        for(int i = 0; i <= cPerms; i++)
        {
            ICHAR rgchFileName [9];
            if(szPrefix)
                StringCchCopyN(rgchFileName, (sizeof(rgchFileName)/sizeof(ICHAR)), szPrefix, cchPrefix);
            if(cDigits)
                StringCchPrintf(rgchFileName+cchPrefix, (sizeof(rgchFileName)/sizeof(ICHAR)) - cchPrefix, TEXT("%x"),uiUniqueId);

            StringCchCopy(rgchBuffer, (sizeof(rgchBuffer)/sizeof(ICHAR)), (const ICHAR*)strPath);
            StringCchCat(rgchBuffer, (sizeof(rgchBuffer)/sizeof(ICHAR)), rgchFileName);
            StringCchCat(rgchBuffer, (sizeof(rgchBuffer)/sizeof(ICHAR)), rgchExtension);

            if( (fFolder  && (FFolderExists(rgchBuffer) == fFalse)) ||
                 (!fFolder && (FFileExists(rgchBuffer, 0) == fFalse)))
            {
                // found a name that isn't already taken - create file as a placeholder for name
                if (m_fImpersonate)
                    AssertNonZero(StartImpersonating());

                
                if (fFolder)
                {
                    if (!WIN::CreateDirectory(rgchBuffer, pSecurityAttributes))
                        iError = GetLastError();
                    else
                    {
                        iError = 0;
                        fCreatedFile = fTrue;
                    }
                }
                else
                {
                    CHandle hFile = WIN::CreateFile(rgchBuffer, GENERIC_WRITE, FILE_SHARE_READ, pSecurityAttributes,
                        CREATE_NEW, (FILE_ATTRIBUTE_NORMAL | (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)), 0);

					if (hFile != INVALID_HANDLE_VALUE)
					{
						DWORD dwType = GetFileType(hFile);
						if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
						{
							DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), rgchBuffer);
							hFile = INVALID_HANDLE_VALUE;
							SetLastError(ERROR_OPEN_FAILED);
						}
					}
							
                    if(hFile == INVALID_HANDLE_VALUE)
                        iError = GetLastError();
                    else
                    {
                        iError = 0;
                        fCreatedFile = fTrue;
                    }
                }

                if (m_fImpersonate)
                    StopImpersonating();

                if(iError == ERROR_ALREADY_EXISTS)
                    iError = ERROR_FILE_EXISTS;
                
                if(iError != ERROR_FILE_EXISTS) // could have failed because file was created under us
                    break; // if file creation failed for any other reason,
                             // assume we can't create any file in this folder
            }

            // increment number portion of name - if it currently equals cPerms, it is time to
            // wrap number around to 0
            uiUniqueStart++;
            if(uiUniqueId == cPerms)
                uiUniqueId = 0;
            else
                uiUniqueId++;
        }
    }
        
    if(fCreatedFile == fFalse)
    {
        if(iError == 0)
            iError = ERROR_FILE_EXISTS; // default error - only used if we exhausted all file names
                                                 // and looped to the end

        if (fFileUnwritable && (ERROR_ACCESS_DENIED == iError))
        {
            // everything else okay, but we couldn't write to the created file,
            // because of security.
            return PostError(Imsg(imsgErrorWritingToFile), *MsiString(rgchBuffer));
        }

        return PostError(Imsg(imsgErrorCreatingTempFileName), iError, strPath);
    }
    
    Assert((fFolder && FFolderExists(rgchBuffer)) || (!fFolder && FFileExists(rgchBuffer, 0)));
    
    MsiString strFilePath = rgchBuffer;
    if(fNameOnly)
        strFilePath = strFilePath.Extract(iseAfter,chDirSep);
    
    strFilePath.ReturnArg(rpiName);
    return 0;
}

IMsiRecord* CMsiPath::TempFileName(const ICHAR* szPrefix, const ICHAR* szExtension,
                                              Bool fFileNameOnly, const IMsiString*& rpiFileName, CSecurityDescription* pSecurity)
//--------------------------------
{   
    return TempFolderOrFile(fFalse, szPrefix, szExtension, fFileNameOnly, (pSecurity) ? (LPSECURITY_ATTRIBUTES) *pSecurity : NULL, rpiFileName);
}


//____________________________________________________________________________
//
// CEnumAVolume definition, implementation class for IEnumMsiVolume
//____________________________________________________________________________

class CEnumAVolume : public IEnumMsiVolume
{
 public:
    HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();
    HRESULT    __stdcall Next(unsigned long cFetch, IMsiVolume** rgpi, unsigned long* pcFetched);
    HRESULT    __stdcall Skip(unsigned long cSkip);
    HRESULT    __stdcall Reset();
    HRESULT    __stdcall Clone(IEnumMsiVolume** ppiEnum);

    CEnumAVolume(idtEnum idt, IMsiServices& riServices);
protected:
    ~CEnumAVolume();
    int            m_iRefCnt;      // reference count
    int            m_iDrive;       // current drive entry, 0-based
    idtEnum   m_idt;          // drive type to enumerate
    IMsiServices& m_riServices;   // services interface
private:
    operator= (const CEnumAVolume&);
};

CEnumAVolume::CEnumAVolume(idtEnum idt, IMsiServices& riServices)
 : m_iDrive(0), m_idt(idt), m_iRefCnt(1), m_riServices(riServices)
{
    m_riServices.AddRef();
}

CEnumAVolume::~CEnumAVolume()
{
    m_riServices.Release();
}

HRESULT CEnumAVolume::QueryInterface(const IID& riid, void** ppvObj)
{
    if (MsGuidEqual(riid, IID_IUnknown) || MsGuidEqual(riid, IID_IEnumMsiVolume))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    *ppvObj = 0;
    return E_NOINTERFACE;
}

unsigned long CEnumAVolume::AddRef()
{
    return ++m_iRefCnt;
}


unsigned long CEnumAVolume::Release()
{
    if (--m_iRefCnt != 0)
        return m_iRefCnt;
    delete this;
    return 0;
}

HRESULT CEnumAVolume::Next(unsigned long cFetch, IMsiVolume** rgpi, unsigned long* pcFetched)
{
    if (pcFetched)
        *pcFetched = 0;

    if (!rgpi)
        return S_FALSE;

    //!! NOTE: we are not scanning UNC volumes. We need to for at least remote.
    while (m_iDrive < iDriveArraySize && cFetch > 0)
    {   // Check for and skip drives that have been disabled via the "NoDrives" System Policy
        if (!(CMsiVolume::s_iNoDrives & (1 << m_iDrive)) && (m_idt == idtAllDrives || m_idt == CMsiVolume::s_rgDrive[m_iDrive].idt))
        {
            IMsiVolume* piVolume = CMsiVolume::s_rgDrive[m_iDrive].pVolume;
            if (piVolume)
                piVolume->AddRef();
            else
            {
                ICHAR szPath[4] = TEXT("?:\\");
                szPath[0] = (ICHAR)(m_iDrive + 'A');
                IMsiRecord* piError = CreateMsiVolume(szPath, &m_riServices, piVolume);
                if (piError)
                {
                    piError->Release();
                    m_iDrive++;
                    continue;
                }
            }
            *rgpi++ = piVolume;
            cFetch--;
            if (pcFetched)
                (*pcFetched)++;
        }
        m_iDrive++;
    }
    return cFetch ? S_FALSE : NOERROR;
}

HRESULT CEnumAVolume::Skip(unsigned long cSkip)
{
    m_iDrive += cSkip;
    return NOERROR;
}

HRESULT CEnumAVolume::Reset(void)
{
    m_iDrive = 0;
    return NOERROR;
}

HRESULT CEnumAVolume::Clone(IEnumMsiVolume** ppiEnum)
{
    IEnumMsiVolume* piEnum = new CEnumAVolume(m_idt, m_riServices);
    *ppiEnum = piEnum;
    piEnum->Skip(m_iDrive);
    return NOERROR;
}

IEnumMsiVolume& EnumDriveType(idtEnum idt, IMsiServices& riServices)
{
    if (!CMsiVolume::IsDriveListInit())
        CMsiVolume::InitDriveList(&riServices);
    else
        CMsiVolume::ReInitDriveList();
    return *new CEnumAVolume(idt, riServices);
}



DWORD MsiGetFileVersionInfoSize(ICHAR* szFullPath, LPDWORD lpdwHandle)
{
    DWORD cbBuf;
    
    __try
    {
        cbBuf = VERSION::GetFileVersionInfoSize(const_cast<ICHAR*>(szFullPath), lpdwHandle);
    }
    __except (1)
    {
        cbBuf = 0;
    }

    return cbBuf;
}


ifiEnum CMsiPath::GetFileVersion(const ICHAR* szFullPath, DWORD& dwMS, DWORD& dwLS )
/*------------------------------------------------------------------------------
Gets the file version values from the given file and sets the given pdwMS & 
pdwLS variables.

Arguments:
    szFullPath: a zero terminated character string containing the fully
        qualified path (including disk drive) to the file.
    dwMS: Most significant 32 bits of source file version stamp.
    dwLS: Least significant 32 bits of source file version stamp.
Returns:
    ifiNoError-       Version retrieved successfully 
    ifiNoFile-        Specified file does not exist
    ifiNoFileInfo-    Specified file has no version info
    ifiFileInfoError- An error occurred while trying to retrieve the version

If the file has no version information, dwMS and dwLS will both be returned as 0.
--------------------------------------------------------------------------------*/
{
    return GetAllFileVersionInfo(szFullPath, &dwMS, &dwLS, 0, 0, 0, m_fImpersonate);
}

Bool ParseVersionString(const ICHAR* szVer, DWORD& dwMS, DWORD& dwLS )
/*----------------------------------------------------------------------------
Parses a string representation of a version into two unsigned long values - 
the most significant and the least significant.

Arguments:
    szVer: non-Null SZ of the form "a.b.c.d" where each field is
        an unsigned word.  Omitted fields are assumed to be the least
        significant (eg d then c then b then a) and are parsed as zeros.
        So "a.b" is equivalent to "a.b.0.0".  If szVer is NULL, or is an
        empty string, zero will be return for dwMS and dwLS, and fTrue
        will be returned as the function result.
    dwMS: non-Null location to store the Most Significant long value
        built from a.b
    dwLS: non-Null location to store the Least Significant long value
        built from c.d
Returns:
    fFalse if szVer is of a bad format.
    fTrue otherwise.
------------------------------------------------------------------------------*/
{
    unsigned short rgw[4];
    unsigned int ius;

    dwMS = 0L;
    dwLS = 0L;
    if (szVer == 0 || IStrLen(szVer) == 0)
        return fTrue;

    for (ius = 0; ius < 4; ius++)
    {
        if (*szVer == '.')
            return fFalse;

#ifdef UNICODE
        // Convert to MultiByte and use strtol
        CTempBuffer<char, 20> sz; /* Buffer for unicode string */
        sz.SetSize((lstrlen(szVer) * sizeof(ICHAR))+ 1);
        if ( ! (char *) sz )
            return fFalse;
        if(!WideCharToMultiByte(CP_ACP, 0, szVer, -1, sz, sz.GetSize(), NULL, NULL))
            return fFalse;
        
        long lVer = strtol(sz);
#else // !UNICODE
        long lVer = strtol(szVer);
#endif //UNICODE
        if (lVer > 65535)
            return fFalse;
        rgw[ius] = (unsigned short) lVer;
        while (*szVer != 0 && *szVer != '.')
        {
            if (!FIsdigit(*szVer))
                return (fFalse);
            szVer = ICharNext(szVer);
        }
        if (*szVer == '.')
            szVer = ICharNext(szVer);
    }

    dwMS = ((DWORD)rgw[0] << 16) + rgw[1];
    dwLS = ((DWORD)rgw[2] << 16) + rgw[3];
    return (fTrue);
}

// Local typedefs for TTF file version checking
// -------------------------------------------- 
#ifdef WIN
#define wLangIdUS      0x0409

#define SWAPW(a)  (unsigned short)(((unsigned char)((a) >> 8))              \
                                   | ((unsigned char)(a) << 8))
#define SWAPL(a)  ((((a)&0xff) << 24) | (((a)&0xff00) << 8)                 \
                   | (((a)&0xff0000) >> 8) | ((a) >> 24))

typedef long sfnt_TableTag;
#define tag_NamingTable         0x656d616e        /* 'name' */

typedef long sfht_TableTag;

#define tag_TTCFont         0x66637474            /* 'ttcf' */

typedef struct
{
    sfht_TableTag   tag;
    uint32          version;
    uint32          tableDirectoryCount;
//  uint32          tableDirectoryOffset[0]; // variable length array of offsets to the individual Directory tables of the fonts
}sfht_HeaderTable;


typedef struct
{
    sfnt_TableTag   tag;
    uint32          checkSum;
    uint32          offset;
    uint32          length;
} sfnt_DirectoryEntry;

typedef struct
{
    int32  version;                 /* 0x10000 (1.0) */
    uint16 numOffsets;              /* number of tables */
    uint16 searchRange;             /* (max2 <= numOffsets)*16 */
    uint16 entrySelector;           /* log2 (max2 <= numOffsets) */
    uint16 rangeShift;              /* numOffsets*16-searchRange*/
    sfnt_DirectoryEntry table[1];   /* table[numOffsets] */
} sfnt_OffsetTable;

typedef struct
{
    uint16 platformID;
    uint16 specificID;
    uint16 languageID;
    uint16 nameID;
    uint16 length;
    uint16 offset;
} sfnt_NameRecord;

typedef struct
{
    uint16 format;
    uint16 count;
    uint16 stringOffset;
} sfnt_NamingTable;
#endif // WIN


#ifdef WIN
Bool FGetTTFVersion (const ICHAR* szFile, DWORD& rdwMSVer, DWORD& rdwLSVer)
/*----------------------------------------------------------------------------
Digs into a TrueType font file and pulls out the MS and LS version number.

Note: The dwLSVer is not defined for TTF files, and is returned as zero.
Arguments:
    szFile: a zero terminated character string containing the fully
        qualified path (including disk drive) to the file.
    pdwMS: returns the most significant 32 bits of source file version stamp.
    pdwLS: returns the least significant 32 bits of source file version stamp.
Returns:
    fFalse if szFile is not a TTF file, or doesn't exist.
    fTrue if valid version information is being returned.
------------------------------------------------------------------------------*/
{
    CAPITempBuffer<ICHAR, MAX_PATH> rgchNameBuf;// use the API temp buffer, since this function path is exposed via the api
    CHandle hFile;
    bool fTTCFonts = false;
    int iNumFonts;

    hFile = OpenFontFile(szFile, fTTCFonts, iNumFonts);
    if(INVALID_HANDLE_VALUE == hFile)
        return fFalse;

    unsigned long cbRead = GetTTFFieldFromFile(hFile, 3, wLangIdUS, 5, fTTCFonts, 1, rgchNameBuf);
    
    if (cbRead > 0)
    {
        Assert(cbRead <= _MAX_PATH);
        rdwMSVer = UlExtractTTFVersionFromSz(rgchNameBuf);
        rdwLSVer = 0;
        return fTrue;
    }

    return fFalse;
}
#endif // WIN



Bool FGetTTFTitle(const ICHAR* szFile, const IMsiString*& rpiTitle)
//-----------------------
{
    CAPITempBuffer<ICHAR, MAX_PATH> rgchNameBuf;

    MsiString strTitle;
    CHandle hFile;
    bool fTTCFonts = false;
    int iNumFonts;

    hFile = OpenFontFile(szFile, fTTCFonts, iNumFonts);
    if(INVALID_HANDLE_VALUE == hFile)
        return fFalse;

    for(int cCount = 1; cCount <= iNumFonts;cCount++)
    {
        unsigned long cbRead = GetTTFFieldFromFile(hFile, 3, GetFontDefaultLangID(), 4, fTTCFonts, cCount, rgchNameBuf);
        if(cbRead <= 0  && GetFontDefaultLangID() != wLangIdUS) // try again with US
        {
            cbRead = GetTTFFieldFromFile(hFile, 3, wLangIdUS, 4, fTTCFonts, cCount, rgchNameBuf);
        }
        if(cbRead <= 0)
            break;
        if(strTitle.TextSize())
            strTitle += TEXT(" & ");
        strTitle += (const ICHAR*)rgchNameBuf;
    }
    if(cCount > iNumFonts) // success ?
    {
        strTitle += TEXT(" (TrueType)");
        strTitle.ReturnArg(rpiTitle);
        return fTrue;
    }
    // else failure
    rpiTitle = &g_MsiStringNull;
    rpiTitle->AddRef();
    return fFalse;
}

HANDLE OpenFontFile(const ICHAR* szFile, bool& rfTTCFonts, int& iNumFonts)
{
    rfTTCFonts = false;
    iNumFonts = 1;
    if (szFile == NULL)
        return INVALID_HANDLE_VALUE;

    HANDLE hFile =  WIN::CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, 
        0, OPEN_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);

    if (hFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwType = GetFileType(hFile);
		if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
		{
			DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), szFile);
			WIN::CloseHandle(hFile);
			hFile = INVALID_HANDLE_VALUE;
			SetLastError(ERROR_OPEN_FAILED);
		}
	}
    if(hFile == INVALID_HANDLE_VALUE)
        return hFile;

    // get the number of ttfs in the ttc
    sfht_HeaderTable    HeaderTable;
    unsigned long cbRead = sizeof(HeaderTable);

    DWORD dwNumberOfBytesRead;
    if (!WIN::ReadFile(hFile,(LPVOID)&HeaderTable,cbRead,&dwNumberOfBytesRead,0) ||
        cbRead != dwNumberOfBytesRead)
    {
        WIN::CloseHandle(hFile);
        return INVALID_HANDLE_VALUE;
    }

    // check if we indeed have a ttc font
    if(HeaderTable.tag !=  tag_TTCFont)
        return hFile; // its a ttf font

    rfTTCFonts = true;

        // check if we have the number of files as requested
    iNumFonts = SWAPL(HeaderTable.tableDirectoryCount);
    return hFile;
}

bool FTTCSeek(HANDLE hFile, int iFile)
{
    if (WIN::SetFilePointer(hFile, 0, 0, FILE_BEGIN) != 0)
        return false;

    // TTC fonts contain a bunch of ttf fonts. So go to the first ttf font info.
    unsigned long cbRead;
    unsigned long libSeek;
    sfht_HeaderTable    HeaderTable;
    cbRead = sizeof(HeaderTable);

    DWORD dwNumberOfBytesRead;
    if (!WIN::ReadFile(hFile,(LPVOID)&HeaderTable,cbRead,&dwNumberOfBytesRead,0) ||
        cbRead != dwNumberOfBytesRead)
        return false;

    // check if we have the number of files as requested
    if(iFile > SWAPL(HeaderTable.tableDirectoryCount))
        return false;

    // go to the iFile th TTF TableDirectory
    if (WIN::SetFilePointer(hFile, (iFile - 1) * sizeof(uint32), 0, FILE_CURRENT) == 0xFFFFFFFF)
        return false;

    uint32 tableDirectoryOffset;
    cbRead = sizeof(tableDirectoryOffset);
    if (!WIN::ReadFile(hFile,(LPVOID)&tableDirectoryOffset,cbRead,&dwNumberOfBytesRead,0) ||
        cbRead != dwNumberOfBytesRead)
        return false;

    libSeek = (unsigned long)SWAPL(tableDirectoryOffset);
    if (WIN::SetFilePointer(hFile, libSeek, 0, FILE_BEGIN) != libSeek)
        return 0;

    return true;
}

// use the API temp buffer, since this function path is exposed via the api
#ifdef WIN
unsigned long GetTTFFieldFromFile(CHandle& hFile, uint16 platformID, uint16 languageID, uint16 nameID, bool fTTCFonts, int cTTFile, CAPITempBufferRef<ICHAR>& rgchNameBuf)
//-----------------------
{
    unsigned int  i;
    unsigned long cbRead;
    unsigned int  numNames;
    long          libSeek;
    unsigned int  cTables;
    sfnt_OffsetTable    OffsetTable;
    sfnt_DirectoryEntry Table;
    sfnt_NamingTable    NamingTable;
    sfnt_NameRecord     NameRecord;


    if(fTTCFonts)
    {
        if(!FTTCSeek(hFile, cTTFile))
            return false;
    }
    else if (WIN::SetFilePointer(hFile, 0, 0, FILE_BEGIN) != 0)
        return false;


    cbRead = sizeof (OffsetTable) - sizeof (sfnt_DirectoryEntry);

    DWORD dwNumberOfBytesRead;
    if (!WIN::ReadFile(hFile,(LPVOID)&OffsetTable,cbRead,&dwNumberOfBytesRead,0) ||
        cbRead != dwNumberOfBytesRead)
        return 0;

    cTables = (unsigned int)SWAPW(OffsetTable.numOffsets);

    for (i = 0; i < cTables && i < 40; i++)
    {
        if (!WIN::ReadFile(hFile,(LPVOID)&Table,sizeof (Table),&dwNumberOfBytesRead,0) ||
            dwNumberOfBytesRead != sizeof (Table))
                return 0;

        if (Table.tag == tag_NamingTable)
        {
            libSeek = (long)SWAPL(Table.offset);
            cbRead = sizeof (NamingTable);
            if (WIN::SetFilePointer(hFile, libSeek, 0, FILE_BEGIN) != libSeek ||
                (!WIN::ReadFile(hFile,(LPVOID)&NamingTable,cbRead,&dwNumberOfBytesRead,0) ||
                cbRead != dwNumberOfBytesRead))
                    return 0;

            numNames = (UINT)SWAPW(NamingTable.count);
            while (numNames--)
            {
                cbRead = sizeof (NameRecord);
                if (!WIN::ReadFile(hFile,(LPVOID)&NameRecord,cbRead,&dwNumberOfBytesRead,0) ||
                    cbRead != dwNumberOfBytesRead)
                        return 0;

                if( SWAPW(NameRecord.platformID) == platformID
                    && SWAPW(NameRecord.languageID) == languageID
                    && SWAPW(NameRecord.nameID)     == nameID)
                {
                    LONG libNew = SWAPW(NameRecord.offset)
                                    + SWAPW(NamingTable.stringOffset)
                                    + SWAPL(Table.offset);

                    cbRead = SWAPW(NameRecord.length);

                    WCHAR* pszBuf;
#ifndef UNICODE
                    CAPITempBuffer<WCHAR, _MAX_PATH> wszBuf;
                    wszBuf.SetSize(cbRead/sizeof(WCHAR) + 1);
                    pszBuf = (WCHAR* )wszBuf;
#else
                    rgchNameBuf.SetSize(cbRead/sizeof(ICHAR) + 1);
                    pszBuf = (ICHAR* )rgchNameBuf;
#endif
                    if (WIN::SetFilePointer(hFile, libNew, 0, FILE_BEGIN) != libNew ||
                        (!ReadFile(hFile,pszBuf,cbRead,&dwNumberOfBytesRead,0) || cbRead != dwNumberOfBytesRead))
                            return 0;
                    // we need to swap the byte order
                    for(int cchCount = 0; cchCount < cbRead/sizeof(WCHAR); cchCount++)
                        pszBuf[cchCount] = SWAPW(pszBuf[cchCount]);

                    *((WCHAR*)pszBuf + cbRead/sizeof(WCHAR)) = 0;

#ifndef UNICODE
                    // convert to DBCS
                    rgchNameBuf.SetSize(wszBuf.GetSize()*2); // max possibility for a conversion from uni to dbcs
                    WIN::WideCharToMultiByte(CP_ACP, 0, wszBuf, -1, rgchNameBuf, rgchNameBuf.GetSize(), 0, 0);
#endif
                    return (cbRead + 1);
                }
            }
            return 0;
        }
    }
    return 0;
}
#endif //WIN


#ifdef WIN
unsigned long UlExtractTTFVersionFromSz ( const ICHAR* pszBuf)
//-------------------------------------
{
    // Font version string assumed to be of form [text]n[<dot> OR colon>]n[<semicolon> OR <comma> OR <space> OR <tab>][text]

    const char* szBuf;
#ifndef UNICODE
        szBuf = pszBuf;
#else
        CAPITempBuffer<char, 50> sz; // use the API temp buffer, since this function path is exposed via the api
        sz.SetSize((lstrlen(pszBuf)*2 + 1)); // max possibility for a conversion from uni to dbcs
        WIN::WideCharToMultiByte(CP_ACP, 0, pszBuf, -1, sz, sz.GetSize(), 0, 0);
        szBuf = (char* )sz;
#endif

    unsigned long ulRet = 0;

    if (!szBuf)
        return 0;

    for(;;)
    {
        // get to the first digit
        while (*szBuf && !FIsdigit(*szBuf))
            szBuf = WIN::CharNextA(szBuf);

        if(!*szBuf)
            return 0;

        // get the major number
        int iVer = strtol(szBuf);

        // skip the major number
        while (FIsdigit(*szBuf))
            szBuf++;

        if(iVer > 0xffff) // the major number must be less than equal to 0xffff
            continue;

        ulRet = iVer << 16;

        if(*szBuf != '.' && *szBuf != ':') //some version strings have ':' in place of '.' - different from font version testing by font group
            continue;// we must have the . or : separating the major and the minor number

        // skip the . or :
        szBuf++;


        if (!FIsdigit(*szBuf))
            continue;// no minor number found

        // get the minor number
        iVer = strtol(szBuf);

        // skip the minor number
        while (FIsdigit(*szBuf))
            szBuf++;

        if(iVer > 0xffff) // the minor number must be less than equal to 0xffff
            continue;
        ulRet += iVer;

        if (*szBuf && *szBuf != ' ' && *szBuf != '\t' && *szBuf != ',' && *szBuf != ';') // check for '\t'from acme, ',' and ';' to handle certain known fonts - all extra than font version testing by font group
        continue; // invalid text after the minor number

        return ulRet;
    }
    return 0;
}

#endif //WIN

ifiEnum IfiFromError(DWORD dwErr)
{

    if (dwErr == ERROR_SHARING_VIOLATION)
    {
        return ifiFileInUseError;
    }
    else if (dwErr == ERROR_ACCESS_DENIED)
    {
        return ifiAccessDenied;
    }

    return ifiFileInfoError;


}

DWORD GetMD5HashFromData(BYTE* pb, DWORD dwSize, ULONG rgHash[4])
{
    Assert(dwSize > 0);
    
    MD5_CTX Hash;
    MD5Init(&Hash);
    MD5Update(&Hash, pb, dwSize);
    MD5Final(&Hash);

    memcpy(rgHash, Hash.digest, 16);

    return 0;
}

DWORD GetMD5HashFromFileHandle(HANDLE hFile, DWORD dwSize, ULONG rgHash[4])
{
    Assert(dwSize != 0);

    BYTE* pbFile = 0;
    
    DWORD dwError = CreateROFileMapView(hFile, pbFile);
    if(dwError != ERROR_SUCCESS)
        return dwError;

    dwError = GetMD5HashFromData(pbFile, dwSize, rgHash);

    AssertNonZero(UnmapViewOfFile(pbFile));

    return dwError;
}

DWORD GetMD5HashFromFile(const ICHAR* szFileFullPath, ULONG rgHash[4], Bool fImpersonate,
                                 DWORD* piMatchSize)
{
    // if piMatchSize is set, only hash file is size matches
    // if the sizes don't match, piMatchSize will be set to the existing file's size

    if(fImpersonate)
        AssertNonZero(StartImpersonating());

    CHandle hFile = WIN::CreateFile(szFileFullPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);

    if (hFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwType = GetFileType(hFile);
		if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
		{
			DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), szFileFullPath);
			hFile = INVALID_HANDLE_VALUE;
			SetLastError(ERROR_OPEN_FAILED);
		}
	}
    if (fImpersonate)
        StopImpersonating();

    if(hFile == INVALID_HANDLE_VALUE)
    {
        return MsiForceLastError(ERROR_FUNCTION_FAILED);
    }

    DWORD dwFileSize = GetFileSize(hFile, 0);

    if(dwFileSize == -1)
    {
        return MsiForceLastError(ERROR_FUNCTION_FAILED);
    }

    if(piMatchSize && (*piMatchSize != dwFileSize))
    {
        *piMatchSize = dwFileSize;
        return ERROR_SUCCESS;
    }

    if(dwFileSize == 0)
    {
        rgHash[0] = 0;
        rgHash[1] = 0;
        rgHash[2] = 0;
        rgHash[3] = 0;
        return ERROR_SUCCESS;
    }
    
    return(GetMD5HashFromFileHandle(hFile, dwFileSize, rgHash));
}

IMsiRecord* CMsiPath::CheckFileHash(const ICHAR* szFileName, MD5Hash& hHash, icfhEnum& icfhResult)
{
    MsiString strFullFilePath;
    IMsiRecord* piError = GetFullFilePath(szFileName, *&strFullFilePath);
    if (piError)
        return piError;

    DWORD dwExistingSize = hHash.dwFileSize;
    ULONG rgExistingHash[4];

    DWORD dwError = GetMD5HashFromFile(strFullFilePath, rgExistingHash, m_fImpersonate, &dwExistingSize);
    
    if(dwError != ERROR_SUCCESS)
    {
        DEBUGMSG2(TEXT("Failed to generate hash for file '%s'. Error: 0x%X"), (const ICHAR*)strFullFilePath,
                   (const ICHAR*)ULongToPtr(dwError));
    }
    
    if(dwError == ERROR_SHARING_VIOLATION)
    {
        icfhResult = icfhFileInUseError;
        return 0;
    }
    else if(dwError == ERROR_ACCESS_DENIED)
    {
        icfhResult = icfhAccessDenied;
        return 0;
    }
    else if(dwError != ERROR_SUCCESS)
    {
        icfhResult = icfhHashError;
        return 0;
    }

    if(hHash.dwFileSize != dwExistingSize)
    {
        // sizes don't match, so files don't match
        icfhResult = icfhMismatch;
        return 0;
    }

    // compare hashes
    if(hHash.dwPart1 != rgExistingHash[0] ||
        hHash.dwPart2 != rgExistingHash[1] ||
        hHash.dwPart3 != rgExistingHash[2] ||
        hHash.dwPart4 != rgExistingHash[3])
    {
        return (icfhResult = icfhMismatch, 0);
    }
    else
    {
        return (icfhResult = icfhMatch, 0);
    }
}


ifiEnum GetAllFileVersionInfo(const ICHAR* szFullPath, DWORD* pdwMS, DWORD* pdwLS, 
                                    unsigned short rgw[], int iSize, int* piLangCount, Bool fImpersonate)
/*----------------------------------------------------------------------------
Gets both the File Version and the language ID information from a file.

Arguments:
    szFullPath: a zero terminated character string containing the fully
        qualified path (including disk drive) to the file.
    pdwMS: Most significant 32 bits of source file version stamp. 0 if version
        info not needed
    pdwLS: Least significant 32 bits of source file version stamp.
    rgw: pointer to an existed array in which the language ID values are to be
        returned. 0 if no language ID values wanted
    iSize: the declared size of the array passed by the caller. 
    piLangCount: a pointer to the location in which GetLangIDArrayFromFile will
        store a count of the actual number of valid language ID values returned in
        the array. If set to -1, it means that there was no language ID information

Returns:
    ifiNoError-       Version retrieved successfully 
    ifiNoFile-        Specified file does not exist
    ifiNoFileInfo-    Specified file has no version info. 
    ifiFileInfoError- An error occurred while trying to retrieve the version

If the file has no version information, dwMS and dwLS will both be returned as 0.

------------------------------------------------------------------------------*/
{
    int iRetries = 2;

Retry:
    if (pdwMS)
    {
        Assert(pdwLS);
        *pdwMS = 0;
        *pdwLS = 0;
    }
    if (rgw)
    {
        Assert(piLangCount);
        *piLangCount = 0;
    }
    
    Assert(szFullPath);
    if (!szFullPath || !FFileExists(szFullPath, 0, fImpersonate))
        return ifiNoFile;

    if (fImpersonate)
        AssertNonZero(StartImpersonating());
        
    // current error mode should include SEM_FAILCRITICALERRORS at this point to
    // prevent unnecessary pop-ups from the OS

    DWORD     dwHandle;
    ifiEnum    ifiRet = ifiNoError;

    DWORD cbBuf = MsiGetFileVersionInfoSize(const_cast<ICHAR*>(szFullPath), &dwHandle);

    DWORD dwLastErr = 0;
    if(!cbBuf)
        dwLastErr = GetLastError();

    if (cbBuf)
    {
        CAPITempBuffer<BYTE,2048> pVersionBuffer; // use the API temp buffer, since this function path is exposed via the api
        // APPCOMPAT: need to initialize first 2 DWORDs of buffer to magic numbers for Windows bug 385303       
        // see filever.c and bug 385303 for details of why these numbers are the way they are

        *(DWORD*)(BYTE*)pVersionBuffer = 0x74450101; // initialize
        *(((DWORD*)(BYTE*)pVersionBuffer) + 1) = 0x006B7559; // initialize
        

        pVersionBuffer.SetSize(cbBuf);

        if (VERSION::GetFileVersionInfo(const_cast<ICHAR*>(szFullPath), dwHandle, cbBuf, pVersionBuffer))
        {
            if (pdwMS)
            {
                UINT cbLen;
                VS_FIXEDFILEINFO * pvsfi;
                if (VERSION::VerQueryValue(pVersionBuffer, TEXT("\\"),(void * *)&pvsfi, (UINT *)&cbLen))
                {
                    if (cbLen > 0)
                    {
                        *pdwMS = pvsfi->dwFileVersionMS;
                        *pdwLS = pvsfi->dwFileVersionLS;
                    }
                    else { ifiRet = ifiNoFileInfo; }
                }
                else { ifiRet = ifiFileInfoError; }
            }           
            //
            // We assume if there's no version number, there's no language ID info either
            //
            if (rgw && ifiRet == ifiNoError)
            {
				if (!GetLangIDArrayFromActualFile(pVersionBuffer, szFullPath, rgw, iSize, *piLangCount))
                {
                    *piLangCount = -1;
                    // If we found version information, but no language information,
                    // We're going to return ifiNoError. Otherwise, ifiNoFileInfo
                    if (!pdwMS)
                        ifiRet = ifiNoFileInfo;
                }
            }
        }
        else 
        { 
            ifiRet = IfiFromError(GetLastError()); 
        }
    }
    else if (pdwMS && FGetTTFVersion(szFullPath, *pdwMS, *pdwLS))
    {
        if(piLangCount)
            *piLangCount = -1;
        ifiRet = ifiNoError;
    }
    else if (dwLastErr == ERROR_SHARING_VIOLATION)
    {
        ifiRet = ifiFileInUseError;
    }
    else if (dwLastErr == ERROR_ACCESS_DENIED)
    {
        ifiRet = ifiAccessDenied;
    }
    else 
    {
        ifiRet = ifiNoFileInfo;
    }

    if (fImpersonate)
        StopImpersonating();

    if (ifiRet == ifiFileInfoError && iRetries > 0)
    {
        // In case another process (such as QuarterDeck Cleansweep: Bug 7914) was accessing the file
        // at the same time we were, give it another try
        iRetries--;
        Sleep(500);
        goto Retry;
    }

    return (ifiRet);
}

BOOL CALLBACK EnumVersionResNameProc(HMODULE hModule, LPCTSTR lpszType, LPTSTR lpszName, LONG_PTR lParam)
{
	return EnumResourceLanguages(hModule, lpszType, lpszName, EnumVersionResLangProc, lParam);
}

BOOL CALLBACK EnumVersionResLangProc(HMODULE hModule, LPCTSTR lpszType, LPCTSTR lpszName, WORD wLang, LONG_PTR lParam)
{
	HRSRC   hRsrc     = 0;
	DWORD   cbVersion = 0;
	HGLOBAL hGlobal   = 0;
	LPVOID  lpVersion = NULL;

	FileLanguageSet* lpLangSet = (FileLanguageSet*)lParam;

	if ( lpLangSet // required because this is the struct that we are filling in
		&& (hRsrc = FindResourceEx(hModule, lpszType, lpszName, wLang)) != 0 // find specific version resource
		&& (hGlobal = LoadResource(hModule, hRsrc)) != 0 // load version resource
		&& (lpVersion = LockResource(hGlobal)) != 0 ) // lock resource
	{
		cbVersion = SizeofResource(hModule, hRsrc);
		if (cbVersion > 0)
		{
			CAPITempBuffer<BYTE, 1> pbVersion;
			if (pbVersion.SetSize(cbVersion))
			{
				// copy resource data into buffer for manipulation
				memcpy(pbVersion, lpVersion, cbVersion);

				unsigned int cbValue = 0;
				unsigned short* pwValue = 0;

				// extract language translation array from version resource
				if (VERSION::VerQueryValue(pbVersion, TEXT("\\VarFileInfo\\Translation"), (void * *) &pwValue, &cbValue))
				{
					unsigned int uiIndex = lpLangSet->cLang;
					while (cbValue > 0 && uiIndex < lpLangSet->uiSize)
					{
						short wLangId = pwValue[0];

						// see if wLang is already listed in our language array
						bool fFound = false;
						for (int j = 0; j < uiIndex; j++)
						{
							if (lpLangSet->rgwLang[j] == wLangId)
								fFound = true;
						}

						// add wLang if not already in list
						if (!fFound)
						{
							lpLangSet->rgwLang[uiIndex++] = wLangId;
						}

						// move through rest of translation array (it's in lang, codepage pairs)
						if (cbValue <= (sizeof (unsigned short) * 2))
				            break;
						cbValue -= (sizeof (unsigned short) * 2);
						pwValue = &(pwValue[2]);
					}

					lpLangSet->cLang = uiIndex;

					return TRUE;
				}

				return FALSE;
			}
		}
	}

	return FALSE;
}

// use the API temp buffer, since this function path is exposed via the api
bool GetLangIDArrayFromBuffer(CAPITempBufferRef<BYTE>& objBuf,unsigned short rgw[], int iSize, int& riLangCount )
{
	BOOL fRes = FALSE;

	unsigned int	cbValue;
	unsigned short* pwValue;
	fRes = VERSION::VerQueryValue(objBuf,TEXT("\\VarFileInfo\\Translation"), 
		(VOID * *)&pwValue,&cbValue);
	if(!fRes)
	{
		return (riLangCount = 0, false);
	}

	int iIndex = 0;
	while (cbValue > 0 && iIndex < iSize)
	{
		rgw[iIndex++] = pwValue[0];
		if (cbValue <= (sizeof (unsigned short) * 2))
			return (riLangCount = iIndex, true);
		cbValue -= (sizeof (unsigned short) * 2);
		pwValue = &(pwValue[2]);
	}
	
	return (riLangCount = iIndex, true);

}

bool GetLangIDArrayFromActualFile(CAPITempBufferRef<BYTE>& objBuf, const ICHAR* szFullFilePath, unsigned short rgw[], int iSize, int& riLangCount)
{
	// load file as module so we can enumerate all of the RT_VERSION resources
	HMODULE hModule = LoadLibraryEx(szFullFilePath, NULL, LOAD_LIBRARY_AS_DATAFILE);
	if (hModule)
	{
		FileLanguageSet sLangSet;
		sLangSet.rgwLang = rgw;
		sLangSet.uiSize = iSize;
		sLangSet.cLang = 0;

		if (!EnumResourceNames(hModule, RT_VERSION, EnumVersionResNameProc, /*lParam = */(LONG_PTR)&sLangSet))
		{
			FreeLibrary(hModule);
			riLangCount = 0;
			return false;
		}

		FreeLibrary(hModule);

		riLangCount = sLangSet.cLang;

		return true;
	}

	// use old way
	return GetLangIDArrayFromBuffer(objBuf, rgw, iSize, riLangCount);
}

ifiEnum CMsiPath::GetLangIDArrayFromFile(const ICHAR* szFullPath, unsigned short rgw[], int iSize, int& riLangCount)
/*----------------------------------------------------------------------------
Extracts an array of words from the Language ID resource in a file.

Arguments:
- szFullPath: full pathname to the file
- rgw: pointer to an existed array in which the language ID values are to be
    returned.
- iSize: the declared size of the array passed by the caller. 
- riLangCount: a reference to the location in which GetLangIDArrayFromFile will
    store a count of the actual number of valid language ID values returned in
    the array.

Returns:
- ifiNoError
- ifiNoFile
- ifiNoFileInfo
- ifiFileInfoError

------------------------------------------------------------------------------*/
{
    return GetAllFileVersionInfo(szFullPath, 0, 0, rgw, iSize, &riLangCount, m_fImpersonate);
}


IMsiRecord*  CMsiPath::FindFile(IMsiRecord& riFilter,int iDepth, Bool& fFound)
//-----------------------------
{
    fFound = fFalse;

    IMsiRecord* piError;

    MsiSuppressTimeout(); // takes a long time
    
    Bool fPathExists;
    if (((piError = Exists(fPathExists)) != 0) || (fPathExists == fFalse))
        return piError;

    if (((piError = FitFileFilter(riFilter, fFound)) != 0) || (fFound == fTrue) || (iDepth-- == 0))
        return piError;

    PEnumMsiString piEnumStr(0);

    if((piError = GetSubFolderEnumerator(*&piEnumStr, /* fExcludeHidden = */ fFalse)) != 0)
        return piError;

    MsiString strSubPath;
    unsigned long iRet;
    while((piEnumStr->Next(1, &strSubPath, &iRet)==S_OK) && (iRet))
    {       
        if((piError = AppendPiece(*strSubPath)) != 0)
            return piError;
        if((piError = FindFile(riFilter, iDepth, fFound)) != 0)
        {
            DEBUGMSG1(TEXT("Error while attempting to search in/ below folder: %s"), strSubPath);
            piError->Release();
            piError = 0;
        }
        else if(fFound == fTrue)
            return 0;

        if((piError = ChopPiece()) != 0)
            return piError;
    }
    return (0);
}

IMsiRecord*  CMsiPath::FitFileFilter(IMsiRecord& riFilter, Bool& fFound)
//----------------------------------
{
    fFound = fFalse;
    // check the various filters

    // first check if file exists
    Bool fRet;
    IMsiRecord* piError;
    MsiString strFileName = riFilter.GetString(iffFileName);
    MsiString strSFNPath, strLFNPath;
    PMsiRecord pError = m_piServices->ExtractFileName(strFileName, fFalse, *&strSFNPath);
    if(SupportsLFN())
    {
        pError = m_piServices->ExtractFileName(strFileName, fTrue,  *&strLFNPath);
        if(strLFNPath.Compare(iscExactI, strSFNPath))
            strLFNPath = g_MsiStringNull; // not really a LFN
    }

    for(int i = 0; i < 2; i++)
    {
        const ICHAR* pFileName = i ? (const ICHAR*)strLFNPath : (const ICHAR*)strSFNPath;
        if(!pFileName || !*pFileName)
            continue;

        if((piError = FileExists(pFileName, fRet)) != 0)
            return piError;

        if(!fRet)
            continue;

        icfvEnum icfvResult;
        // min version
        if(riFilter.IsNull(iffMinFileVersion) == fFalse)
        {
            if(((piError = CheckFileVersion(pFileName, riFilter.GetString(iffMinFileVersion), riFilter.GetString(iffFileLangs),
                0, icfvResult, NULL)) != 0)
                || ((icfvResult != icfvExistingEqual) && (icfvResult != icfvExistingHigher)))
                return piError;

        }

        // max version
        if(riFilter.IsNull(iffMaxFileVersion) == fFalse)
        {
            if(((piError = CheckFileVersion(pFileName, riFilter.GetString(iffMaxFileVersion), riFilter.GetString(iffFileLangs),
                0, icfvResult, NULL)) != 0)
                || ((icfvResult != icfvExistingEqual) && (icfvResult != icfvExistingLower)))
                return piError;
        }

        unsigned int uiFileSize;


        // min file size
        if(riFilter.IsNull(iffMinFileSize) == fFalse)
        {
            if(((piError = FileSize(pFileName, uiFileSize)) != 0) ||
                (uiFileSize < riFilter.GetInteger(iffMinFileSize)))
                return piError;
        }

        // max file size
        if(riFilter.IsNull(iffMaxFileSize) == fFalse)
        {
            if(((piError = FileSize(pFileName, uiFileSize)) != 0) ||
                (uiFileSize > riFilter.GetInteger(iffMaxFileSize)))
                return piError;
        }

        MsiDate aDate;
        // min date
        if(riFilter.IsNull(iffMinFileDate) == fFalse)
        {
            if(((piError = FileDate(pFileName, aDate)) != 0) ||
                (aDate < riFilter.GetInteger(iffMinFileDate)))
                return piError;
        }

        // max date
        if(riFilter.IsNull(iffMaxFileDate) == fFalse)
        {
            if(((piError = FileDate(pFileName, aDate)) != 0) ||
                (aDate > riFilter.GetInteger(iffMaxFileDate)))
                return piError;
        }

        fFound = fTrue;
        riFilter.SetString(iffFileName, pFileName);// set the exact file name we found
        return 0;
    }
    // not found
    return 0;
}

IMsiRecord* CMsiPath::GetSubFolderEnumerator(IEnumMsiString*& rpaEnumStr, Bool fExcludeHidden)
//------------------------------------------
{
    const IMsiString** ppstr = 0;
    unsigned int iSize = 0;
    MsiString strPath = GetPath();
    MsiString strOrigPath = strPath;
    Bool fRoot = fFalse;

    if (m_istrPath.Compare(iscExact, vrgchDirSep))
        fRoot = fTrue;

    if (strPath.Compare(iscEnd, vrgchDirSep) == 0)
        strPath += vrgchDirSep; 

    ICHAR* TEXT_WILDCARD = TEXT("*.*");
    strPath += TEXT_WILDCARD;

    if (m_fImpersonate)
        AssertNonZero(StartImpersonating());

    // current error mode should include SEM_FAILCRITICALERRORS at this point to
    // prevent unnecessary pop-ups from the OS
    WIN32_FIND_DATA fdFindData;

    MsiDisableTimeout();
    HANDLE hFile = WIN::FindFirstFile(strPath, &fdFindData);
    DWORD dwLastErr = GetLastError();
    MsiEnableTimeout();

    if (hFile ==  INVALID_HANDLE_VALUE)
    {
        switch(dwLastErr)
        {
        case ERROR_FILE_NOT_FOUND:
            // no error
            break;
        case ERROR_PATH_NOT_FOUND:
            // path deleted by user from outside?
            if (m_fImpersonate)
                StopImpersonating();

            return PostError(Imsg(idbgInvalidPath), *strOrigPath);
        case ERROR_NOT_READY:
            // device not ready
            if (m_fImpersonate)
                StopImpersonating();

            return PostError(Imsg(idbgDriveNotReady), *strOrigPath);
        default:
            if (m_fImpersonate)
                StopImpersonating();

            return PostError(Imsg(idbgErrorEnumSubPaths), *strOrigPath);
        }

    }
    else
    {
        do
        {
            MsiString strSubDir = fdFindData.cFileName;

            // - only select actual directories
            // - exclude hidden directories if fExcludeHidden is set
            // - exclude the RECYCLE bin. (this check is unnecessary if we're excluding hidden files)
            if ((fdFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && 
                (!strSubDir.Compare(iscExact, TEXT("."))) && 
                (!strSubDir.Compare(iscExact, TEXT(".."))) &&
                (!fExcludeHidden || !(fdFindData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)) &&
                (fExcludeHidden || !(fRoot && strSubDir.Compare(iscExact, TEXT("RECYCLED")))))
            {
                iSize++;
                if((iSize % 10) == 1)     // need to allocate more memory (10 units at a time)
                {
                    const IMsiString** ppstrOld = ppstr;
                    ppstr = new const IMsiString* [iSize + 9];
                    WIN::CopyMemory((PVOID)ppstr, (CONST VOID* )ppstrOld, (iSize - 1)* sizeof(const IMsiString*));
                    delete [] ppstrOld;
                }
                ppstr[iSize - 1] = &CreateString();
                ppstr[iSize - 1]->SetString(fdFindData.cFileName, ppstr[iSize - 1]);
            }
        }while(WIN::FindNextFile(hFile, &fdFindData) == TRUE);
        WIN::FindClose(hFile);
    }
    if (m_fImpersonate)
        StopImpersonating();

    CreateStringEnumerator(ppstr, iSize, rpaEnumStr);
    for (unsigned int iTmp = 0;iTmp < iSize;iTmp ++)
        ppstr[iTmp]->Release();
    delete [] ppstr;
    return 0;
}

IMsiRecord* CMsiPath::GetImportModulesEnum(const IMsiString& strFile, IEnumMsiString*& rpiEnumStr)
{
    int iSize = 0;
    int iTmp;
    bool fSuccess = true;
    CTempBuffer<const IMsiString*, 10> ppStr;
    void* pFile;

    MsiString istrFullPath;
    IMsiRecord* piError = GetFullFilePath(strFile.GetString(), *&istrFullPath);
    if (piError)
        return piError;


    if (m_fImpersonate)
        AssertNonZero(StartImpersonating());

    CHandle hFile = WIN::CreateFile(istrFullPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);

    if (hFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwType = GetFileType(hFile);
		if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
		{
			DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), istrFullPath);
			hFile = INVALID_HANDLE_VALUE;
			SetLastError(ERROR_OPEN_FAILED);
		}
	}
    if(hFile == INVALID_HANDLE_VALUE)
    {
        if (m_fImpersonate)
            StopImpersonating();

        return PostError(Imsg(idbgErrorOpeningFile), WIN::GetLastError(), strFile.GetString());
    }
    
    CHandle hFileMapping = WIN::CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);
    if(hFileMapping == INVALID_HANDLE_VALUE)
    {
        if (m_fImpersonate)
            StopImpersonating();

        return PostError(Imsg(idbgErrorOpeningFile), WIN::GetLastError(), strFile.GetString());
   }

    pFile = WIN::MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
    if (pFile == 0)
    {
        if (m_fImpersonate)
            StopImpersonating();

        return PostError(Imsg(idbgErrorOpeningFile), WIN::GetLastError(), strFile.GetString());
    }

    
    __try
    {
        if(GetImageFileType(pFile) == IMAGE_NT_SIGNATURE)
        {
            IMAGE_SECTION_HEADER* psh;
            PIMAGE_IMPORT_DESCRIPTOR pid, pidBegin;
            DWORD dwRVA;
    
            // get section header and pointer to data directory for .idata section
            if(GetImgDirSectnAndOffset(pFile, IMAGE_DIRECTORY_ENTRY_IMPORT, psh, dwRVA) == fTrue)
            {
                pidBegin = (PIMAGE_IMPORT_DESCRIPTOR)ConvertRVAToVA(pFile, dwRVA, psh);
    
                // extract num of import modules
                pid = pidBegin;
                while (pid->Name)
                {
                    iSize++;
                    pid++;
                }
    
                // copy the imports 
                pid = pidBegin;
                ppStr.SetSize(iSize);
                for (iTmp = 0; iTmp < iSize; iTmp++)
                {
                    ppStr[iTmp] = &CreateString();
                    ppStr[iTmp]->SetString((ICHAR* )ConvertRVAToVA(pFile, pid->Name, psh), ppStr[iTmp]);
                    pid++;
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fSuccess = false;
    }

    if(fSuccess)
        CreateStringEnumerator(ppStr, iSize, rpiEnumStr);

    WIN::UnmapViewOfFile(pFile);
    for(iTmp = 0; iTmp < iSize; iTmp ++)
    {
        if(ppStr[iTmp] != 0)
            ppStr[iTmp]->Release();       
    }
    if (m_fImpersonate)
        StopImpersonating();

    if(!fSuccess)
        return PostError(Imsg(idbgErrorOpeningFile), WIN::GetLastError(), strFile.GetString());
    return 0;
}

#ifdef WIN

// convert relative virtual address to virtual address
void* CMsiPath::ConvertRVAToVA(void* pFile, DWORD dwRVA, PIMAGE_SECTION_HEADER psh)
{
    return (void* )((char* )pFile + (psh->PointerToRawData + dwRVA - psh->VirtualAddress));
}

// return offset to specified IMAGE_DIRECTORY entry
Bool CMsiPath::GetImgDirSectnAndOffset(void* pFile, DWORD dwIMAGE_DIRECTORY, PIMAGE_SECTION_HEADER&  pish, DWORD& dwRVA)
{
    PIMAGE_OPTIONAL_HEADER poh = (PIMAGE_OPTIONAL_HEADER)OPTHDROFFSET(pFile);
    PIMAGE_SECTION_HEADER  psh = (PIMAGE_SECTION_HEADER)SECHDROFFSET(pFile);
    int iSections = NUMOFSECTIONS(pFile);
    int iTmp = 0;

    // must be 0 thru (NumberOfRvaAndSizes-1)
    if (dwIMAGE_DIRECTORY >= poh->NumberOfRvaAndSizes)
        return fFalse;

    // locate specific image directory's relative virtual address
    dwRVA = poh->DataDirectory[dwIMAGE_DIRECTORY].VirtualAddress;

    // locate section containing image directory
    while (iTmp++ < iSections)
    {
        if (psh->VirtualAddress <= dwRVA &&
            psh->VirtualAddress + psh->SizeOfRawData > dwRVA)
            break;
        psh++;
    }

    pish = psh;
    return (iTmp > iSections) ? fFalse : fTrue;
}

DWORD CMsiPath::GetImageFileType(void* pFile)
{
    PIMAGE_DOS_HEADER pdh = (PIMAGE_DOS_HEADER)pFile;
    if((((PIMAGE_DOS_HEADER)pFile)->e_magic != IMAGE_DOS_SIGNATURE) &&
    (((PIMAGE_DOS_HEADER)pFile)->e_magic != IMAGE_NT_SIGNATURE))
        return 0;
    
    if((((PIMAGE_DOS_HEADER)pFile)->e_magic == IMAGE_DOS_SIGNATURE) &&
    (((PIMAGE_DOS_HEADER)pFile)->e_lfanew == 0))
        return IMAGE_DOS_SIGNATURE;

    __try
    {
    if (LOWORD (*(DWORD *)NTSIGNATURE (pFile)) == IMAGE_OS2_SIGNATURE ||
        LOWORD (*(DWORD *)NTSIGNATURE (pFile)) == IMAGE_OS2_SIGNATURE_LE)
        return (DWORD)LOWORD(*(DWORD *)NTSIGNATURE (pFile));

    else if (*(DWORD *)NTSIGNATURE (pFile) == IMAGE_NT_SIGNATURE)
        return IMAGE_NT_SIGNATURE;

    else
        return IMAGE_DOS_SIGNATURE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return IMAGE_DOS_SIGNATURE;
    }
}
#endif
typedef BOOL (WINAPI* pfnBindImage)(LPSTR ImageName, LPSTR DllPath, LPSTR SymbolPath);
typedef BOOL (WINAPI* pfnBindImageEx)(DWORD Flags, LPSTR ImageName, LPSTR DllPath, LPSTR SymbolPath, PIMAGEHLP_STATUS_ROUTINE StatusRoutine);



const char  rgchBindImageProc[]   = "BindImage";
const char  rgchBindImageExProc[] = "BindImageEx";
const ICHAR rgchImageHelpDll[]    = TEXT("imagehlp.dll");

extern "C" BOOL WINAPI BindImage(LPSTR ImageName, LPSTR DllPath,LPSTR SymbolPath); // from bindimg.c

IMsiRecord* CMsiPath::BindImage(const IMsiString& riFile, const IMsiString& riDllPath)
{
    // If file doesn't exist, no need to try to bind it.
    Bool fExists;
    IMsiRecord* piError = FileExists(riFile.GetString(),fExists);
    if (piError || !fExists)
        return piError;

    Bool fUseImageHlp = fTrue;  
    HINSTANCE hinstBind = 0;
    pfnBindImageEx pfnBindEx=0;
    pfnBindImage pfnBind=0;

    if((hinstBind = LoadLibrary(rgchImageHelpDll)) == 0)
    {
        // we may be running shared windows (ie the image help file maybe on a network share
        AssertNonZero(StartImpersonating());
        hinstBind = LoadLibrary(rgchImageHelpDll);
        StopImpersonating();
        if(hinstBind == 0)
            return PostError(Imsg(idbgErrorBindImage), (const ICHAR* )riFile.GetString());// cannot bindimage
    }

    // attempt to follow logic as outlined by Bryan Tuttle
    if((g_fWin9X == false) && (g_iMajorVersion == 3) && (g_iMinorVersion == 51) && (g_iWindowsBuild <= 1057))
    {
        // for the "special" NT builds - 
        if((((pfnBindEx = (pfnBindImageEx)GetProcAddress(hinstBind, rgchBindImageExProc)) == 0) &&
            ((pfnBind = (pfnBindImage)GetProcAddress(hinstBind, rgchBindImageProc)) == 0)))
        {
            WIN::FreeLibrary(hinstBind);
            return PostError(Imsg(idbgErrorBindImage), (const ICHAR* )riFile.GetString());// cannot bindimage
        }
    }
    else 
    {
        // else for Windows 95 and all other NT builds
        if(((pfnBind = (pfnBindImage)GetProcAddress(hinstBind, rgchBindImageProc)) == 0))
        {
            WIN::FreeLibrary(hinstBind);
            return PostError(Imsg(idbgErrorBindImage), (const ICHAR* )riFile.GetString());// cannot bindimage
        }
    }

    // first get the exe file path
    MsiString strAppendedPath = GetPath();
    strAppendedPath += TEXT(";"); // path separator
    strAppendedPath += riDllPath;
    strAppendedPath += TEXT(";"); // path separator
    //?? append the system directory, should this be a calculated just once
    ICHAR rgchPath[MAX_PATH];
    AssertNonZero(WIN::GetSystemDirectory(rgchPath, sizeof(rgchPath)/sizeof(ICHAR)));
    strAppendedPath += rgchPath;
    MsiString strFullFilePath;
    if((piError = GetFullFilePath(riFile.GetString(), *&strFullFilePath)) != 0)
    {
        WIN::FreeLibrary(hinstBind);
        return piError;
    }

    if (m_fImpersonate)
        AssertNonZero(StartImpersonating());

    FILETIME ftSave;        
    DWORD dwAttrib = MsiGetFileAttributes( strFullFilePath );
    
    if (dwAttrib & FILE_ATTRIBUTE_READONLY)
        SetFileAttributes( strFullFilePath, dwAttrib & (~FILE_ATTRIBUTE_READONLY) );
    
    HANDLE hFile = WIN::CreateFile( strFullFilePath, GENERIC_READ, 
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    0, OPEN_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);
                                    
    if (hFile == INVALID_HANDLE_VALUE)
    {
        // ignore if failure - as done in ACME
        AssertSz(0, "Could not open exe file for BindImaging");
    }
    else
    {
        MsiRegisterSysHandle(hFile);
        WIN::GetFileTime(hFile, 0, 0, &ftSave);
        AssertNonZero(MsiCloseSysHandle(hFile));
    }
    BOOL fRet;
    if(pfnBindEx)
    {
        fRet = (*pfnBindEx)(BIND_NO_BOUND_IMPORTS, const_cast <char*> ((const char*) CConvertString(strFullFilePath)), const_cast <char*> ((const char*) CConvertString(strAppendedPath)), 0, 0);
    }
    else
    {
        fRet = (*pfnBind)(const_cast <char*> ((const char*) CConvertString(strFullFilePath)), const_cast <char*> ((const char*) CConvertString(strAppendedPath)), 0);
    }
    if(fRet == FALSE)
    {
        WIN::FreeLibrary(hinstBind);
        if (dwAttrib & FILE_ATTRIBUTE_READONLY)  // Don't leave changed state on error....
            SetFileAttributes( strFullFilePath, dwAttrib );

        if (m_fImpersonate)
            StopImpersonating();
        
        return PostError(Imsg(idbgErrorBindImage), (const ICHAR* )strFullFilePath);
    }
    if ((hFile != INVALID_HANDLE_VALUE) &&
        ((hFile = CreateFile(strFullFilePath, GENERIC_WRITE, 
                            FILE_SHARE_WRITE,
                            0, OPEN_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0)) != INVALID_HANDLE_VALUE))
    {
        MsiRegisterSysHandle(hFile);
        WIN::SetFileTime(hFile, 0, 0, &ftSave);  // ignore if failure - as done in ACME
        AssertNonZero(MsiCloseSysHandle(hFile));            
    }           

    if (dwAttrib & FILE_ATTRIBUTE_READONLY)      // reset to original state
        SetFileAttributes( strFullFilePath, dwAttrib );
        
    if (m_fImpersonate)
        StopImpersonating();

    WIN::FreeLibrary(hinstBind);
    return 0;
}


const IMsiString& CMsiPath::NormalizePath(const ICHAR* szPath, Bool fLeadingSep)
/*----------------------------------------------------------------------
    Removes extra directory separators from the given path.
    fLeadingSep : if set, ensure a leading separator, if not set, remove
    any leading separator.
------------------------------------------------------------------------*/
{
    MsiString strRet;
    if(!szPath || !*szPath)
        return strRet.Return();

    CTempBuffer<ICHAR,MAX_PATH> rgBuffer;
    int cch = 0;
    if((cch = IStrLen(szPath) + 2) >= MAX_PATH)
    {
        rgBuffer.SetSize(cch);
        if ( ! (ICHAR *) rgBuffer )
            return strRet.Return();
    }
    ICHAR* pch1 = rgBuffer;
    ICHAR* pch1End = pch1 + rgBuffer.GetSize();
    const ICHAR* pch2 = szPath;
    if(fLeadingSep && *pch2 != chDirSep)
        *(pch1++) = chDirSep;
    else if (!fLeadingSep && *pch2 == chDirSep)
        pch2++;
    
    StringCchCopy(pch1, (pch1End-pch1), pch2);
    while(*pch1)
    {
        if(*pch1 == chDirSep)
        {
            pch1++;
            pch2 = pch1;
            while (*pch2 == chDirSep)
                pch2++;
            if (pch2 != pch1)
                StringCchCopy(pch1, (pch1End-pch1), pch2);
        }
        if (*pch1)
            pch1 = ICharNext(pch1);
    }
    strRet = (const ICHAR*)rgBuffer;
    return strRet.Return();
}


DWORD CreateROFileMapView(HANDLE hFile, BYTE*& pbFileStart)
//----------------------------------------------------------------------------
// Caller must call UnmapViewOfFile on pbFileStart
//----------------------------------------------------------------------------
{
    // hFileMapping will close when returning from this function
    // it is ok to close that handle and still use pbFileStart
    
    CHandle hFileMapping = WIN::CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);
    if(hFileMapping != INVALID_HANDLE_VALUE)
    {
        pbFileStart = (BYTE*)WIN::MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
        if (pbFileStart != 0)
        {
            return ERROR_SUCCESS;
        }
    }

    // if we got here, something bad happened
    return MsiForceLastError(ERROR_FUNCTION_FAILED);
}


bool FIsNetworkVolume(const ICHAR *szPath)
{
    return MsiGetPathDriveType(szPath, true) == idtRemote;
}



// function to get the system language for fonts
uint16 GetFontDefaultLangID()
{
    //  set it initally to illegal value
    static uint16 iLangID = 0xffff;

    if(iLangID == 0xffff)
    {
        //  Default to English
        uint16 iTemp = 0x0409;
        DWORD dwSize, dwHandle;
        
        ICHAR rgchPath[MAX_PATH];
		rgchPath[0] = 0;
        AssertNonZero(WIN::GetSystemDirectory(rgchPath, sizeof(rgchPath)/sizeof(ICHAR)));
        if(*rgchPath && (rgchPath[lstrlen(rgchPath)-1] != '\\'))
            StringCchCat(rgchPath, sizeof(rgchPath)/sizeof(ICHAR), TEXT("\\"));
        StringCchCat(rgchPath,  sizeof(rgchPath)/sizeof(ICHAR), TEXT("fontext.dll"));

        if((dwSize = MsiGetFileVersionInfoSize(rgchPath, &dwHandle)) != 0)
        {
            CTempBuffer<BYTE, 100> lpBuf;

            lpBuf.SetSize(dwSize);

            if(VERSION::GetFileVersionInfo(rgchPath, dwHandle, dwSize, lpBuf))
            {
                struct
                {
                    WORD wLang;
                    WORD wCodePage;
                } *lpTrans;
                
                UINT uSize;
                if(VERSION::VerQueryValue( lpBuf,
                                    TEXT("\\VarFileInfo\\Translation"),
                                    (LPVOID* ) &lpTrans,
                                    &uSize)
                                    && uSize >= sizeof(*lpTrans))
                {
                    iTemp = lpTrans->wLang;
                }
            }
        }
        //  Use dwTemp so this is re-entrant (if not efficient)
        iLangID = (uint16)iTemp;
    }
    return(iLangID);
}


/****************************************************************************

  Performance optimization: GetFileAttributesEx is faster, so that we use it
  on OS-es that support it - basically all but Windows 95.  Latebind sets
  LastError to ERROR_PROC_NOT_FOUND if it cannot find GetFileAttributesEx, so
  that we know that we should call GetFileAttributes instead.

****************************************************************************/

DWORD __stdcall MsiGetFileAttributes(const ICHAR* szFileName)
{
    static bool fGoWithEx = true;
#if defined(UNICODE) && !defined(_WIN64)
    bool fRedirDisabled = false;
    if ( g_fWinNT64 )
    {
        // 32-bit executable running on Win64 issue only
        static WCHAR rgchSystemDir[MAX_PATH+1] = {0};
        static int iSystemDirLen = 0;

        if ( !rgchSystemDir[0] )
        {
            iSystemDirLen = WIN::GetSystemDirectoryW(rgchSystemDir,
                                                    sizeof(rgchSystemDir)/sizeof(WCHAR));
            Assert(iSystemDirLen && iSystemDirLen+1 <= sizeof(rgchSystemDir)/sizeof(WCHAR));
            if ( iSystemDirLen + IStrLen(rgchSystemDir) + 2 <= sizeof(rgchSystemDir)/sizeof(WCHAR) )
            {
                // makes searches more accurate: directories like %windir%\System32abc
                // will not pass for %windir%\System32.
                StringCbCat(rgchSystemDir, sizeof(rgchSystemDir), szDirSep);
                iSystemDirLen = IStrLen(rgchSystemDir);
            }
        }

        if ( !IStrNCompI(szFileName, rgchSystemDir, iSystemDirLen) )
        {
            // szFileName is in the 64-bit system directory.  If we do
            // not disable the filesystem redirector, GetFileAttributes[Ex]
            // will end up looking for the same file in the 32-bit
            // %windir%\Syswow64 directory and will return erroneous data.
            fRedirDisabled = true;
            Wow64DisableFilesystemRedirector(szFileName);
        }
    }
#endif // UNICODE && !_WIN64

    DWORD dwRetValue;
    if ( fGoWithEx )
    {
        WIN32_FILE_ATTRIBUTE_DATA strData;
        if ( KERNEL32::GetFileAttributesEx(szFileName,
                                                      GetFileExInfoStandard,
                                                      (LPVOID)&strData) )
            dwRetValue = strData.dwFileAttributes;
        else
        {
            if ( WIN::GetLastError() == ERROR_PROC_NOT_FOUND )
            {
                fGoWithEx = false;
                dwRetValue = WIN::GetFileAttributes(szFileName);
            }
            else
                dwRetValue = 0xFFFFFFFF;
        }
    }
    else
        dwRetValue = WIN::GetFileAttributes(szFileName);

#if defined(UNICODE) && !defined(_WIN64)
    if ( fRedirDisabled )
    {
        DWORD dwLastError = WIN::GetLastError();
        Wow64EnableFilesystemRedirector();
        WIN::SetLastError(dwLastError);
    }
#endif // UNICODE && !_WIN64

    return dwRetValue;
}


IMsiRecord* CMsiPath::IsPE64Bit(const ICHAR* szFileName, bool &f64Bit)
{
    f64Bit = false;
    MsiString strFullFilePath;
    void* pFile;
    
    IMsiRecord* piError = GetFullFilePath(szFileName, *&strFullFilePath);
    if (piError)
        return piError;


    if (m_fImpersonate)
        AssertNonZero(StartImpersonating());

    CHandle hFile = WIN::CreateFile(strFullFilePath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);
    if (hFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwType = GetFileType(hFile);
		if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
		{
			DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), strFullFilePath);
			hFile = INVALID_HANDLE_VALUE;
			SetLastError(ERROR_OPEN_FAILED);
		}
	}
    if(hFile == INVALID_HANDLE_VALUE)
    {
        if (m_fImpersonate)
            StopImpersonating();

        return PostError(Imsg(idbgErrorOpeningFile), WIN::GetLastError(), strFullFilePath);
    }
    
    CHandle hFileMapping = WIN::CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);
    if(hFileMapping == INVALID_HANDLE_VALUE)
    {
        if (m_fImpersonate)
            StopImpersonating();

        return PostError(Imsg(idbgErrorOpeningFile), WIN::GetLastError(), strFullFilePath);
   }

    pFile = WIN::MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
    if (pFile == 0)
    {
        if (m_fImpersonate)
            StopImpersonating();

        return PostError(Imsg(idbgErrorOpeningFile), WIN::GetLastError(), strFullFilePath);
    }

    IMAGE_NT_HEADERS* pHeaders = IMAGEHLP::ImageNtHeader(pFile);
    if (pHeaders == 0)
    {
        if (m_fImpersonate)
            StopImpersonating();

        return PostError(Imsg(idbgErrorOpeningFile), WIN::GetLastError(), strFullFilePath);
    }
    
    // look at IMAGE_NT_HEADERS.OptionalHeader.Magic. If it is IMAGE_NT_OPTIONAL_HDR64_MAGIC then the 
    // image is 64-bit and IMAGE_NT_HEADERS is the right struct to lay ontop of the image.  If it is 
    // IMAGE_NT_OPTIONAL_HDR32_MAGIC then the image is 32-bit. We don't need the extra structures,
    // just the MAGIC number.
    f64Bit = (pHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC);

    WIN::UnmapViewOfFile(pFile);
    
    if (m_fImpersonate)
        StopImpersonating();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\msiutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation.  All rights reserved.
//
//  File:       msiutil.cpp
//
//--------------------------------------------------------------------------

#include "precomp.h"
#include "_msiutil.h"
#include "_msinst.h"
#include "_srcmgmt.h"
#include "_execute.h"
#include "_dgtlsig.h"
#include "resource.h"
#include "eventlog.h"

#include "wintrust.h"
#include "winsafer.h"
#include "winsaferp.h" // for SaferiChangeRegistryScope
#include "wincrypt.h"
#include "softpub.h"

const int MAX_NET_RETRIES = 1;

extern IMsiServices* g_piSharedServices;

extern int GetPackageFullPath(
						  LPCWSTR szProduct, CAPITempBufferRef<WCHAR>& rgchPackagePath,
						  plEnum &plPackageLocation, Bool fShowSourceUI);

extern int GetPackageFullPath(
						  LPCSTR szProduct, CAPITempBufferRef<char>& rgchPackagePath,
						  plEnum &plPackageLocation, Bool fShowSourceUI);


extern int ResolveSourceCore(const char* szProduct, unsigned int uiDisk, CAPITempBufferRef<char>& rgchSource);
extern int ResolveSourceCore(const WCHAR* szProduct, unsigned int uiDisk, CAPITempBufferRef<WCHAR>& rgchSource);
extern bool IsProductManaged(const ICHAR* szProductKey);
extern Bool IsTerminalServerInstalled();
extern bool RunningOnTerminalServerConsole();
Bool AppendMsiExtension(const ICHAR* szPath, CAPITempBufferRef<ICHAR>& rgchAppendedPath);

const GUID IID_IServerSecurity     = GUID_IID_IServerSecurity;
const GUID IID_IBindStatusCallback = {0x79eac9c1L,0xbaf9,0x11ce,{0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b}};
const GUID IID_IInternetSecurityManager = {0x79eac9eeL,0xbaf9,0x11ce,{0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b}};// {79eac9ee-baf9-11ce-8c82-00aa004ba90b}
const GUID CLSID_InternetSecurityManager = {0x7b8a2d94L,0x0ac9,0x11d1,{0x89,0x6c,0x00,0xc0,0x4f,0xb6,0xbf,0xc4}};// {7b8a2d94-0ac9-11d1-896c-00c04Fb6bfc4}

// Opens a specific users product key in write mode. NULL as the User SID means the current user. 
// attempting to open a per-user non-managed product for a user other than the current user will cause
// an assert. (The HKCU for that user may be roamed away, we can't guarantee that it is valid)
DWORD OpenSpecificUsersWritableAdvertisedProductKey(enum iaaAppAssignment iaaAsgnType, const ICHAR* szUserSID, const ICHAR* szProductSQUID, CRegHandle &riHandle, bool fSetKeyString)
{
	HKEY hKey;
	HKEY hOLEKey;
	DWORD dwResult;
	MsiString strPublishSubKey;
	MsiString strPublishOLESubKey;
	dwResult = GetPublishKeyByUser(szUserSID, iaaAsgnType, hKey, hOLEKey, *&strPublishSubKey, *&strPublishOLESubKey);
	if (ERROR_SUCCESS != dwResult)
		return dwResult;

	strPublishSubKey += TEXT("\\");
	strPublishSubKey += _szGPTProductsKey;
	strPublishSubKey += TEXT("\\");

	strPublishSubKey += szProductSQUID;

	REGSAM sam = KEY_READ | KEY_WRITE;
#ifndef _WIN64
	if ( g_fWinNT64 )
		sam |= KEY_WOW64_64KEY;
#endif
	dwResult = MsiRegOpen64bitKey(hKey, strPublishSubKey, 0, sam, &riHandle);
	if(ERROR_SUCCESS == dwResult)
	{
		if (fSetKeyString)
			riHandle.SetKey(hKey, strPublishSubKey);
	}
	return dwResult;
}

DWORD OpenWritableAdvertisedProductKey(const ICHAR* szProductSQUID, CRegHandle &riHandle, bool fSetKeyString)
{
	if(!szProductSQUID || lstrlen(szProductSQUID) != cchProductCodePacked)
		return ERROR_INVALID_PARAMETER;

	CProductContextCache cpc(szProductSQUID);

	// get the cached product context, if any
	iaaAppAssignment iKey = (iaaAppAssignment)-1;
	bool fCached = cpc.GetProductContext(iKey);	
	iaaAppAssignment iaaAssignType = (int)iKey == -1 ? iaaBegin : iKey;
	DWORD dwResult = ERROR_FUNCTION_FAILED;
	for (; iaaAssignType < iaaEnd; iaaAssignType = (iaaAppAssignment)(iaaAssignType + 1))
	{
		dwResult = OpenSpecificUsersWritableAdvertisedProductKey(iaaAssignType, NULL, szProductSQUID, riHandle, fSetKeyString);
		if (ERROR_SUCCESS == dwResult || iKey != -1) 
			break;
	}
	// cache the product context, if found and not previously cached
	if(!fCached && ERROR_SUCCESS == dwResult)
		cpc.SetProductContext(iaaAssignType);

	return dwResult;
}

UINT ModeBitsToString(DWORD dwMode, const ICHAR* rgchModes, ICHAR* rgchBuffer)
/*----------------------------------------------------------------------------
Converts a DWORD of mode bits into its equivalent string form.

Arguments:
	dwMode: The mode.
	rgchMode: A null-terminated array of possible mode ICHARacters. 
				 {rgchMode[n]} == {bit (n-1)}

	rgchBuffer: A buffer that, upon success, will contain the string version
					of dwMode. The buffer should be large enough to contain
					the maximum number of mode ICHARacters, plus 1 for the NULL 
					terminator.
Returns:
	ERROR_SUCCESS - The conversion was successful.
	ERROR_INVALID_PARAMETER - An invalid mode bit was specified
------------------------------------------------------------------------------*/
{
	Assert(rgchModes);
	Assert(rgchBuffer);

	const ICHAR* pchMode = rgchModes;
	int cModes = 0;

	for (int iBit = 1; *pchMode && dwMode; iBit <<= 1, pchMode++)
	{
		if (dwMode & iBit)
		{
			rgchBuffer[cModes++] = *pchMode;		
			dwMode &= ~iBit;
		}
	}
	rgchBuffer[cModes] = 0;
	if (dwMode)
	{
		rgchBuffer[0] = 0;
		return ERROR_INVALID_PARAMETER;
	}
	else
	{
		return ERROR_SUCCESS;
	}
}


UINT StringToModeBits(const ICHAR* szMode, const ICHAR* rgchPossibleModes, DWORD &dwMode)
{
	Assert(szMode);
	Assert(rgchPossibleModes);

	dwMode = 0;
	for (const ICHAR* pchMode = szMode; *pchMode; pchMode++)
	{
		const ICHAR* pchPossibleMode = rgchPossibleModes;
		for (int iBit = 1; *pchPossibleMode; iBit <<= 1, pchPossibleMode++)
		{
			if (*pchPossibleMode == (*pchMode | 0x20)) // modes are lower-case
			{
				dwMode |= iBit;
				break;
			}
		}
		if (*pchPossibleMode == 0)
			return ERROR_INVALID_PARAMETER;
	}
	return ERROR_SUCCESS;
}

//---------------------------------------------------------------------------
// StringConcatenate
//    concatenates strings into buffer
//    replacement for StringCchPrintf when complete string is longer than 1024
//
//    return value is the number of characters stored in the output buffer,
//    not counting the terminating null character (just like StringCchPrintf)
//---------------------------------------------------------------------------
int StringConcatenate(CAPITempBufferRef<ICHAR>& rgchBuffer, const ICHAR* sz1, const ICHAR* sz2, const ICHAR* sz3, const ICHAR* sz4)
{
	// get string sizes
	int cch1             = sz1 ? IStrLen(sz1) : 0;
	int cch12   = cch1   + (sz2 ? IStrLen(sz2) : 0);
	int cch123  = cch12  + (sz3 ? IStrLen(sz3) : 0);
	int cch1234 = cch123 + (sz4 ? IStrLen(sz4) : 0);

	// ensure buffer is correct size (+1 for NULL terminator)
	rgchBuffer.SetSize(cch1234 + 1);
	cch1234 = rgchBuffer.GetSize();

	// copy strings
	if (sz1)
   		StringCchCopy((ICHAR*)rgchBuffer,			cch1234, 			sz1);
	if (sz2)
		StringCchCopy((ICHAR*)rgchBuffer  + cch1,	cch1234 - cch1,		sz2);
	if (sz3)
		StringCchCopy((ICHAR*)rgchBuffer  + cch12,	cch1234 - cch12,	sz3);
	if (sz4)
		StringCchCopy((ICHAR*)rgchBuffer  + cch123, cch1234 - cch123,	sz4);

	return (cch1234 - 1);
}

CMsiAPIMessage g_message;

//____________________________________________________________________________
//
// CMsiAPIMessage implementation - simple UI handler
//     Note: cannot use MsiString wrapper objects or Asserts - no MsiServices
//____________________________________________________________________________

const int cLocalAPIMessageContexts = 8;
CMsiExternalUI rgLocalAPIMessageContexts[cLocalAPIMessageContexts];

CMsiAPIMessage::CMsiAPIMessage()
{
	m_pfnHandlerA = 0;
	m_pfnHandlerW = 0;
	m_iMessageFilter = 0;
	m_cLocalContexts = 0;
	m_cAllocatedContexts = 0;
	m_rgAllocatedContexts = 0;
	m_fEndDialog = false;
	m_fNoModalDialogs = false;
	m_fHideCancel = false;
	FSetInternalHandlerValue(INSTALLUILEVEL_DEFAULT);
}

void CMsiAPIMessage::Destroy()
{
	if (m_rgAllocatedContexts)
		WIN::GlobalFree(m_rgAllocatedContexts);
	m_rgAllocatedContexts = 0;
}

CMsiExternalUI* CMsiAPIMessage::FindOldHandler(INSTALLUI_HANDLERW pfnHandler)
{
	CMsiExternalUI* pContext = rgLocalAPIMessageContexts;
	for (int cLocal = m_cLocalContexts; cLocal--; pContext++)
		if (pfnHandler == pContext->m_pfnHandlerW || pfnHandler == (INSTALLUI_HANDLERW)pContext->m_pfnHandlerA)
			return pContext;
	pContext = m_rgAllocatedContexts;
	for (int cAllocated = m_cAllocatedContexts; cAllocated--; pContext++)
		if (pfnHandler == pContext->m_pfnHandlerW || pfnHandler == (INSTALLUI_HANDLERW)pContext->m_pfnHandlerA)
			return pContext;
	return 0;
}

INSTALLUI_HANDLERW CMsiAPIMessage::SetExternalHandler(INSTALLUI_HANDLERW pfnHandlerW, INSTALLUI_HANDLERA pfnHandlerA, DWORD dwMessageFilter, LPVOID pvContext)
{
	INSTALLUI_HANDLERW pfnOldHandler = m_pfnHandlerW ? m_pfnHandlerW : (INSTALLUI_HANDLERW)m_pfnHandlerA;
	INSTALLUI_HANDLERW pfnNewHandler =   pfnHandlerW ?   pfnHandlerW : (INSTALLUI_HANDLERW)  pfnHandlerA;
	CMsiExternalUI* pSaveContext = 0;

	if (pfnNewHandler == 0)   // if no handler, then reset
		dwMessageFilter = 0, pvContext = 0;
	else if (dwMessageFilter == 0) // if handler but no filter, then requesting old handler
	{
		if (pfnNewHandler == pfnOldHandler)  // no change
			return pfnOldHandler;
		if ((pSaveContext = FindOldHandler(pfnNewHandler)) != 0)
		{
			pfnHandlerW     = pSaveContext->m_pfnHandlerW;
			pfnHandlerA     = pSaveContext->m_pfnHandlerA;
			dwMessageFilter = pSaveContext->m_iMessageFilter;
			pvContext       = pSaveContext->m_pvContext;
		}
		else  // can't find old context, reset instead
		{
			pfnHandlerW = 0;
			pfnHandlerA = 0;
			pvContext = 0;
		}
	}

	if (pfnOldHandler != 0 && pfnOldHandler != pfnNewHandler) // changed handler, save current context
	{
		if ((pSaveContext = FindOldHandler(pfnOldHandler)) == 0)  // handler not previously saved
		{
			if (m_cLocalContexts < cLocalAPIMessageContexts)
				pSaveContext = &rgLocalAPIMessageContexts[m_cLocalContexts++];
			else
			{
				void* pDelete = m_rgAllocatedContexts;
				m_rgAllocatedContexts = (CMsiExternalUI*)WIN::GlobalAlloc(GMEM_FIXED, sizeof(CMsiExternalUI) * (m_cAllocatedContexts + 1)); 
				if ( ! m_rgAllocatedContexts )
					return pfnOldHandler;
				if (pDelete)
				{
					memcpy(m_rgAllocatedContexts, pDelete, sizeof(CMsiExternalUI) * m_cAllocatedContexts);
					WIN::GlobalFree(pDelete);
				}
				pSaveContext = &m_rgAllocatedContexts[m_cAllocatedContexts++];
			}
		}
		memcpy(pSaveContext, (CMsiExternalUI*)this, sizeof(CMsiExternalUI));
	}

	m_pfnHandlerW    = pfnHandlerW;
	m_pfnHandlerA    = pfnHandlerA;
	m_pvContext      = pvContext;
	m_iMessageFilter = dwMessageFilter;
	return pfnOldHandler;
}

INSTALLUILEVEL CMsiAPIMessage::SetInternalHandler(UINT dwUILevel, HWND *phWnd)
{
	INSTALLUILEVEL dwOldUILevel;
	switch(m_iuiLevel)
	{
	case iuiFull:    dwOldUILevel = INSTALLUILEVEL_FULL;    break;
	case iuiReduced: dwOldUILevel = INSTALLUILEVEL_REDUCED; break;
	case iuiBasic:   dwOldUILevel = INSTALLUILEVEL_BASIC;   break;
	case iuiNone:    dwOldUILevel = INSTALLUILEVEL_NONE;    break;
	default:         AssertSz(0, "Invalid UI level in SetInternalHandler");		// fall through
	case iuiDefault: dwOldUILevel = INSTALLUILEVEL_DEFAULT;
	}

	if (m_fEndDialog)
		dwOldUILevel = (INSTALLUILEVEL)((int)dwOldUILevel | (int)INSTALLUILEVEL_ENDDIALOG);

	if (m_fNoModalDialogs)
		dwOldUILevel = (INSTALLUILEVEL)((int)dwOldUILevel | (int)INSTALLUILEVEL_PROGRESSONLY);
	
	if (m_fHideCancel)
		dwOldUILevel = (INSTALLUILEVEL)((int)dwOldUILevel | (int)INSTALLUILEVEL_HIDECANCEL);

	if (m_fSourceResolutionOnly)
		dwOldUILevel = (INSTALLUILEVEL)((int)dwOldUILevel | (int)INSTALLUILEVEL_SOURCERESONLY);

	if (!FSetInternalHandlerValue(dwUILevel))
		return INSTALLUILEVEL_NOCHANGE;

	if (phWnd)
	{
		HWND hOldHwnd = m_hwnd;
		m_hwnd = *phWnd;
		*phWnd = hOldHwnd;
	}

	return dwOldUILevel;
}

//
// Split off as a separate routine from SetInternalHandler so we can initialize at
// compile time.
Bool CMsiAPIMessage::FSetInternalHandlerValue(UINT dwUILevel)
{
	m_fEndDialog      = (dwUILevel & INSTALLUILEVEL_ENDDIALOG) != 0;
	m_fNoModalDialogs = (dwUILevel & INSTALLUILEVEL_PROGRESSONLY) != 0;
	m_fHideCancel     = (dwUILevel & INSTALLUILEVEL_HIDECANCEL) != 0;
	m_fSourceResolutionOnly = (dwUILevel & INSTALLUILEVEL_SOURCERESONLY) != 0;

	switch(dwUILevel & ~(INSTALLUILEVEL_ENDDIALOG|INSTALLUILEVEL_PROGRESSONLY|INSTALLUILEVEL_HIDECANCEL|INSTALLUILEVEL_SOURCERESONLY))
	{
	case INSTALLUILEVEL_NOCHANGE:                                   break;
	case INSTALLUILEVEL_FULL:     m_iuiLevel = iuiFull;             break;
	case INSTALLUILEVEL_REDUCED:  m_iuiLevel = iuiReduced;          break;
	case INSTALLUILEVEL_BASIC:    m_iuiLevel = iuiBasic;            break;
	case INSTALLUILEVEL_NONE:     m_iuiLevel = iuiNone;             break;
	case INSTALLUILEVEL_DEFAULT:  m_iuiLevel = (iuiEnum)iuiDefault; break;
	default:                      return fFalse;
	}

	return fTrue;
}

imsEnum CMsiAPIMessage::Message(imtEnum imt, const ICHAR* szMessage) const
{
	imsEnum imsRet;

	Assert(m_pfnHandlerA || m_pfnHandlerW);
	if (m_pfnHandlerA)
	{
		imsRet = (imsEnum) (*m_pfnHandlerA)(m_pvContext, (int)imt, CApiConvertString(szMessage));
	}
	else // m_pfnHandlerW
	{
		imsRet = (imsEnum) (*m_pfnHandlerW)(m_pvContext, (int)imt, CApiConvertString(szMessage));
	}

	return imsRet;
}

imsEnum CMsiAPIMessage::Message(imtEnum imt, IMsiRecord& riRecord)
{
	if (m_pfnHandlerW || m_pfnHandlerA)
	{
		const IMsiString* pistr = &riRecord.FormatText(fFalse);

		imsEnum imsRet = Message(imt, pistr->GetString());

		pistr->Release();
		return imsRet;
	}
	return imsNone;
}

UINT MapInstallActionReturnToError(iesEnum ies)
/*----------------------------------------------------------------------------
Maps an install action return value to the appropriate API error

Arguments:
	iesRes: The return value from an action
				
Returns:
	see below.
------------------------------------------------------------------------------*/
{
	switch(ies)
	{
		case iesFinished:      return ERROR_SUCCESS;
		case iesSuccess:       return ERROR_SUCCESS;
		case iesSuspend:       return ERROR_INSTALL_SUSPEND;
		case iesUserExit:      return ERROR_INSTALL_USEREXIT;
		case iesNoAction:      return ERROR_INSTALL_FAILURE;
		case iesBadActionData: return ERROR_INSTALL_FAILURE;
		case iesFailure:       return ERROR_INSTALL_FAILURE;
		case iesReboot:        return ERROR_INSTALL_REBOOT;
		case iesRebootNow:     return ERROR_INSTALL_REBOOT_NOW;
		case iesInstallRunning: return ERROR_INSTALL_ALREADY_RUNNING;
		case iesWrongState:    Assert(0); return ERROR_INSTALL_FAILURE;
		case iesCallerReboot:  return ERROR_SUCCESS_REBOOT_INITIATED;
		case iesRebootRejected:return ERROR_SUCCESS_REBOOT_REQUIRED;
		default:               Assert(0); return ERROR_INSTALL_FAILURE;
	}

}

bool UpdateSaferLevelInMessageContext(SAFER_LEVEL_HANDLE hNewSaferLevel)
/*---------------------------------------------------------------
UpdateSaferLevelInMessageContext updates the safer level handle
 stored in the message context if the message context is
 initialized.  The current safer level handle is closed.  This
 is required because each call to VerifyMsiObjectAgainstSAFER will
 invalidate the current safer level handle because we must reload
 the cached safer policy when impersonating the user (so that we
 don't use the local_system user). The safer level will be the
 same in all cases since we only allow install at the fully-trusted
 safer level
-----------------------------------------------------------------*/
{
	// only applicable on Whistler & greater
	if (MinimumPlatformWindowsNT51())
	{
		AssertSz(hNewSaferLevel, TEXT("Expected a non-zero safer level!"));
		if (g_MessageContext.IsInitialized())
		{
			// close current safer level
			ADVAPI32::SaferCloseLevel(g_MessageContext.m_hSaferLevel);

			// update safer level to new level handle
			g_MessageContext.m_hSaferLevel = hNewSaferLevel;
		}
		else
		{
			// can't save this authz level so just close it
			ADVAPI32::SaferCloseLevel(hNewSaferLevel);
		}
	}

	return true;
}

bool VerifyMsiObjectAgainstSAFER(IMsiServices& riServices, IMsiStorage* piStorage, const ICHAR* szMsiObject, const ICHAR* szFriendlyName, stEnum stType, SAFER_LEVEL_HANDLE *phSaferLevel)
/*----------------------------------------------------------------------------------------------------------------------------------------------------------
Validates the MSI storage object based upon WinSAiFER policy on Whistler (and above)
WinSAiFER makes trust verification based upon:
	1. Hash
	2. Publisher (i.e. signer certificate)
	3. Path
	4. Internet Zone

Arguments:
	riServices: [IN] reference to IMsiServices object
	piStorage: [IN] [OPTIONAL] storage pointer to prevent us from opening it again (perf)
	szMsiObject: [IN] full path to the MSI object (either MSI, MST, or MSP) -- always a path on local disk
	stType: [IN] type of object (database, transform, or patch)
	szFriendlyName: [IN] friendly name for eventlog message, if NULL, uses szMsiObject
	phSaferLevel: [OUT] receives the handle to the SAFER authorization level object
	
Returns:
	true -->> MSI object is trusted; phSaferLevel is set to SAFER level handle; install can proceed
	false -->> MSI object is not trusted; install should fail
 -----------------------------------------------------------------------------------------------------------------------------------------------------------*/
{

#ifdef UNICODE

	//
	// SAFER policy only enforced on Whistler
	//  - On other downlevel platforms, "true" is assumed
	//  - If SAFER is made available to downlevel, this can be changed
	//

	if (!MinimumPlatformWindowsNT51())
		return true; // only Whistler and above

	//
	// set up szObjectToEvaluate. Use szFriendlyName if present as this represents the
	// actual original path whereas szMsiObject typically represents the new temp copy
	// we want SAFER policy applied to the original location and not the copied temp location
	//

	const ICHAR* szObjectToEvaluate = szFriendlyName ? szFriendlyName : szMsiObject;

	//
	// determine object type (used for error messages)
	//

	const ICHAR* szObjectType = NULL;
	switch (stType)
	{
	case stDatabase:
		szObjectType = szDatabase;
		break;
	case stTransform:
		szObjectType = szTransform;
		break;
	case stPatch:
		szObjectType = szPatch;
		break;
	case stIgnore:
		szObjectType = szObject;
		break;
	default:
		AssertSz(0, "invalid object type passed in to VerifyMsiObjectAgainstSAFER");
		DEBUGMSGE(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_SAFER_UNTRUSTED, szObjectToEvaluate);
		return false;
	}

	Assert(szObjectType);

	DEBUGMSG2(TEXT("SOFTWARE RESTRICTION POLICY: Verifying %s --> '%s' against software restriction policy"), szObjectType, szObjectToEvaluate);

	//
	// If the MSI object is unsigned, we won't specify the SAFER_CRITERIA_AUTHENTICODE value.  This allows
	// us to work in the case of databases opened read-write like in Validation and MsiFiler
	// where we must create an engine in order to do work.  Both of these occur when making changes to
	// the MSI file so the database should not be signed at this time (otherwise you would be invalidating
	// the digital signature). A WVT call will fail on a storage opened read-write since the MSI SIP must
	// open the storage with DENY_WRITE access (for security reasons).
	//
	// WinSAiFER does not have a specific policy of "only allow signed packages" but it can be almost completely
	// accomplished with a WinSAiFER policy that has a Default Level of disallowed and only enables trust of
	// the signers that are wanted to be run
	//

	//
	// Determine if the storage object is signed
	//

	bool fReleaseStorage = false; // assume a storage was passed in to us via the piStorage parameter
	if (!piStorage)
	{
		// NOTE: can NEVER pass true for fCallSAFER here, else we'll end up continuing forever as OpenAndValidateMsiStorageRec
		// will call VerifyMsiObjectAgainstSAFER (us) if fCallSAFER is true
		PMsiRecord pError = OpenAndValidateMsiStorageRec(szMsiObject, stType, riServices, *&piStorage, /*fCallSAFER = */false, /*szFriendlyName =*/NULL, /*phSaferLevel = */NULL);
		if (pError == 0)
			fReleaseStorage = true;
		else // error opening storage file
		{
			pError = 0;
			DEBUGMSGE(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_SAFER_UNTRUSTED, szObjectToEvaluate);
			return false;
		}
	}

	bool fObjectIsSigned = false; // initialize to unsigned object

	// attempt to open \005DigitalSignature stream which is the stream containing the digital signature
	PMsiStream pDgtlSig(0);
	PMsiRecord	pRecErr = piStorage->OpenStream(szDigitalSignature, /* fWrite = */fFalse, *&pDgtlSig);
	// force release of digital signature stream
	pDgtlSig = 0;
	// release storage if opened in this function
	if (fReleaseStorage && piStorage)
	{
		piStorage->Release();
		piStorage = NULL;
	}

	if (pRecErr)
	{
		if (idbgStgStreamMissing == pRecErr->GetInteger(1))
		{
			// object does not have a digital signature, so release error
			DEBUGMSG1(TEXT("SOFTWARE RESTRICTION POLICY: %s is not digitally signed"), szObjectToEvaluate);
			pRecErr = 0;
		}
		else
		{
			pRecErr = 0;
			DEBUGMSGE(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_SAFER_UNTRUSTED, szObjectToEvaluate);
			return false; // some other error, so we default to untrusted
		}
	}
	else
	{
		// \005DigitalSignature stream is present, so object has a digital signature
		DEBUGMSG1(TEXT("SOFTWARE RESTRICTION POLICY: %s has a digital signature"), szObjectToEvaluate);
		fObjectIsSigned = true;
	}

	//
	// Verify the object using WinSAiFER. The dwCheckFlags member of the SAFER_CODE_PROPERTIES identifies
	// which WinSAiFER checks we wish to make.  By default, we always want SAFER_CRITERIA_IMAGEPATH and
	// SAFER_CRITERIA_IMAGEHASH.  If the object is signed, we want SAFER_CRITERIA_AUTHENTICODE as well.
	// If the object is from a URL (first check szFriendlyName since in the typical URL case, szMsiObject
	// represents the downloaded location on the local diks), then include SAFER_CRITERIA_URLZONE.
	//

	SAFER_CODE_PROPERTIES sCodeProperties;
	
	memset((void*)&sCodeProperties, 0x00, sizeof(SAFER_CODE_PROPERTIES));
	sCodeProperties.cbSize = sizeof(SAFER_CODE_PROPERTIES);
	sCodeProperties.dwCheckFlags = SAFER_CRITERIA_IMAGEPATH | SAFER_CRITERIA_IMAGEHASH;
	if (fObjectIsSigned)
	{
		sCodeProperties.dwCheckFlags |= SAFER_CRITERIA_AUTHENTICODE;
		sCodeProperties.hWndParent = (HWND)INVALID_HANDLE_VALUE; // we don't want any WVT UI at all
		sCodeProperties.dwWVTUIChoice = WTD_UI_NONE;       // again, no WVT UI
	}

	sCodeProperties.ImagePath =  szObjectToEvaluate;

	bool fFileUrl = false;
	if (IsURL(szObjectToEvaluate, fFileUrl))
	{
		// include SAFER_CRITERIA_URLZONE
		sCodeProperties.dwCheckFlags |= SAFER_CRITERIA_URLZONE;

		DWORD dwZone = URLZONE_UNTRUSTED;
		// must determine URL zone of URL
		IInternetSecurityManager* pISM = NULL;
		if (SUCCEEDED(OLE32::CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER, IID_IInternetSecurityManager, (LPVOID *)&pISM)) && pISM)
		{
			if (SUCCEEDED(pISM->MapUrlToZone(CConvertString(szObjectToEvaluate), &dwZone, 0)))
			{
				switch (dwZone)
				{
				case URLZONE_LOCAL_MACHINE:
					DEBUGMSG3(TEXT("SOFTWARE RESTRICTION POLICY: %s is a URL that maps to URL security zone %d (%s)"), szObjectToEvaluate, (const ICHAR*)(INT_PTR)dwZone, TEXT("URLZONE_LOCAL_MACHINE"));
					break;
				case URLZONE_INTRANET:
					DEBUGMSG3(TEXT("SOFTWARE RESTRICTION POLICY: %s is a URL that maps to URL security zone %d (%s)"), szObjectToEvaluate, (const ICHAR*)(INT_PTR)dwZone, TEXT("URLZONE_INTRANET"));
					break;
				case URLZONE_TRUSTED:
					DEBUGMSG3(TEXT("SOFTWARE RESTRICTION POLICY: %s is a URL that maps to URL security zone %d (%s)"), szObjectToEvaluate, (const ICHAR*)(INT_PTR)dwZone, TEXT("URLZONE_TRUSTED"));
					break;
				case URLZONE_INTERNET:
					DEBUGMSG3(TEXT("SOFTWARE RESTRICTION POLICY: %s is a URL that maps to URL security zone %d (%s)"), szObjectToEvaluate, (const ICHAR*)(INT_PTR)dwZone, TEXT("URLZONE_INTERNET"));
					break;
				case URLZONE_UNTRUSTED:
					DEBUGMSG3(TEXT("SOFTWARE RESTRICTION POLICY: %s is a URL that maps to URL security zone %d (%s)"), szObjectToEvaluate, (const ICHAR*)(INT_PTR)dwZone, TEXT("URLZONE_UNTRUSTED"));
					break;
				default:
					DEBUGMSG3(TEXT("SOFTWARE RESTRICTION POLICY: %s is a URL that maps to URL security zone %d (%s)"), szObjectToEvaluate, (const ICHAR*)(INT_PTR)dwZone, TEXT("unknown / user-defined"));
					break;
				}
			}
			pISM->Release();
			pISM = 0;
		}
		sCodeProperties.UrlZoneId = dwZone;
		// must use the local path location (cached from URL) for this to work correctly with WinTrust and hash verification
		sCodeProperties.ImagePath = szMsiObject;


		// do not include Image Path as criteria
		sCodeProperties.dwCheckFlags &= ~SAFER_CRITERIA_IMAGEPATH;
	}

	// must start impersonating to ensure that we use the user in the trust determination
	CImpersonate Impersonate(true);
	
	// force reload of SAFER policy to ensure it uses the impersonated user
	if (0 == ADVAPI32::SaferiChangeRegistryScope(NULL, REG_OPTION_NON_VOLATILE))
	{
		// we have to fail in this case since this means that we are running on cached policy for either
		// the local_system token or perhaps even some other user (who initiated last install) and not based upon
		// the policies set for this new user
		DEBUGMSG2(TEXT("SOFTWARE RESTRICTION POLICY: Unable to reload software restriction policy. %s is not considered to be trusted. GetLastError = %d"), szObjectToEvaluate, (const ICHAR*)(INT_PTR)GetLastError());
		DEBUGMSGE(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_SAFER_UNTRUSTED, szObjectToEvaluate);
		return false;
	}

	SAFER_LEVEL_HANDLE hSaferLevel = 0; // WinSAiFER authorization level handle
	
	// determine authorization level
	if (!ADVAPI32::SaferIdentifyLevel(/* num SAFER_CODE_PROPERTIES structs = */ 1, &sCodeProperties, &hSaferLevel, /* lpReserved = */ 0))
	{
		// SaferIdentifyLevel should never return false, but if it does, we are to assume untrusted
		DEBUGMSG1(TEXT("SOFTWARE RESTRICTION POLICY: SaferIdentifyLevel reported failure.  Assuming untrusted. . . (GetLastError returned %d)"), (const ICHAR*)(INT_PTR)GetLastError());
		DEBUGMSGE(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_SAFER_UNTRUSTED, szObjectToEvaluate);
		return false;
	}

	//
	// Check SAFER_LEVEL and see if MSI object is trusted to run
	// The table below identifies the Windows Installer trust level mapped to the WinSAiFER level
	//
	//	SAFER_LEVELID		  WI TRUST
	//---------------------------------------------------------
	//   FULLYTRUSTED		  trusted to install
	//   NORMALUSER                   not trusted to install
	//   CONSTRAINED                  not trusted to install
	//   UNTRUSTED (aka "restricted") not trusted to install
	//   DISALLOWED                   not trusted to install
	//

	DWORD dwSaferLevelId = SAFER_LEVELID_DISALLOWED; // initialize to SAFER_LEVELID_DISALLOWED
    DWORD dwBufferSize = 0;
	AssertNonZero(ADVAPI32::SaferGetLevelInformation(hSaferLevel, SaferObjectLevelId, (void*)&dwSaferLevelId, sizeof(DWORD), &dwBufferSize));

	if (SAFER_LEVELID_FULLYTRUSTED == dwSaferLevelId)
	{
		// object can be "installed"
		DEBUGMSG1(TEXT("SOFTWARE RESTRICTION POLICY: %s is permitted to run at the 'unrestricted' authorization level."), szObjectToEvaluate);
		if (phSaferLevel)
			*phSaferLevel = hSaferLevel;
		else // safer level object not wanted, so close
			AssertNonZero(ADVAPI32::SaferCloseLevel(hSaferLevel));
		return true;
	}
	else
	{
		// object CANNOT be "installed"
		DEBUGMSG1(TEXT("SOFTWARE RESTRICTION POLICY: %s is not permitted to run at the 'unrestricted' authorization level."), szObjectToEvaluate);
	}

	//
	// object was not trusted -->> gather extra information for logging purposes such as
	//  (1) Was it per-user or per-machine policy?
	//  (2) Was it configured or out-of-box policy?
	//  (3) Was it the default policy setting?  (i.e. disallow everything but these things)
	//  (4) Was the failed policy criteria path, hash, publisher (certificate), or zone?
	//  (5) Was there any extra status information
	//  (6) Which level are we authorized for execution?  
	//

	DWORD   dwSaferDefault  = 0;
	DWORD   dwSaferScope    = 0;
	DWORD   dwStatus        = 0;
    WCHAR   wszId[MAX_PATH] = {0};
	BOOL    fVerbose        = TRUE;

	BYTE* pbSaferIdent = (BYTE*) new BYTE[sizeof(SAFER_IDENTIFICATION_HEADER)];
	if (!pbSaferIdent)
	{
		DEBUGMSG(TEXT("SOFTWARE RESTRICTION POLICY: Memory allocation failed."));
		AssertNonZero(ADVAPI32::SaferCloseLevel(hSaferLevel));
		return false;
	}
	DWORD cbSaferIdent = sizeof(SAFER_IDENTIFICATION_HEADER);
	ZeroMemory((void*)pbSaferIdent, cbSaferIdent);
	PSAFER_IDENTIFICATION_HEADER pSaferIdentHeader = (PSAFER_IDENTIFICATION_HEADER)pbSaferIdent;
	pSaferIdentHeader->cbStructSize = cbSaferIdent;

	AssertNonZero(ADVAPI32::SaferGetLevelInformation(hSaferLevel, SaferObjectBuiltin, (void*)&dwSaferDefault, sizeof(DWORD), &dwBufferSize));
	AssertNonZero(ADVAPI32::SaferGetLevelInformation(hSaferLevel, SaferObjectScopeId, (void*)&dwSaferScope, sizeof(DWORD), &dwBufferSize));
	AssertNonZero(ADVAPI32::SaferGetLevelInformation(hSaferLevel, SaferObjectExtendedError, (void*)&dwStatus, sizeof(DWORD), &dwBufferSize));

	if (!ADVAPI32::SaferGetLevelInformation(hSaferLevel, SaferObjectSingleIdentification, (void*)pbSaferIdent, cbSaferIdent, &cbSaferIdent))
	{
		DWORD dwLastError = GetLastError();
		if (ERROR_INSUFFICIENT_BUFFER == dwLastError)
		{
			delete [] pbSaferIdent;
			pbSaferIdent = (BYTE*) new BYTE[cbSaferIdent];
			if (!pbSaferIdent)
			{
				DEBUGMSG(TEXT("SOFTWARE RESTRICTION POLICY: Memory allocation failed."));
				AssertNonZero(ADVAPI32::SaferCloseLevel(hSaferLevel));
				return false;
			}
			ZeroMemory((void*)pbSaferIdent, cbSaferIdent);
			pSaferIdentHeader = (PSAFER_IDENTIFICATION_HEADER)pbSaferIdent;
			pSaferIdentHeader->cbStructSize = cbSaferIdent;
			if (!ADVAPI32::SaferGetLevelInformation(hSaferLevel, SaferObjectSingleIdentification, (void*)pbSaferIdent, cbSaferIdent, &cbSaferIdent))
			{
				fVerbose = FALSE;
			}
		}
		else
		{
			fVerbose = FALSE;
		}
	}

	if (fVerbose)
	{
		const GUID guidCertRule = SAFER_GUID_RESULT_TRUSTED_CERT;
		const GUID guidDefaultRule = SAFER_GUID_RESULT_DEFAULT_LEVEL;

		AssertNonZero(OLE32::StringFromGUID2(pSaferIdentHeader->IdentificationGuid, wszId, MAX_PATH));

		// dwIdentificationType is not set for CertRules and Default security level
		// instead, you must compare the IdentificationGuid to the pre-defined guid used for these rules
		if (IsEqualGUID(pSaferIdentHeader->IdentificationGuid, guidDefaultRule))
		{
			// matched default Safer security level
			DEBUGMSG3(TEXT("SOFTWARE RESTRICTION POLICY: The %s software restriction %s policy default security level disallows execution. The returned execution level was %d"),
				dwSaferDefault == 0 ? TEXT("Configured") : TEXT("Default"),
				dwSaferScope == SAFER_SCOPEID_MACHINE ? TEXT("machine") : TEXT("user"),
				(const ICHAR*)(INT_PTR)dwSaferLevelId);
		}
		else if (IsEqualGUID(pSaferIdentHeader->IdentificationGuid, guidCertRule))
		{
			// matched publisher certificate rule

			// For certificates, this rule might apply even when no rules have been set since WVT handles this policy and Safer merely calls
			// into WVT.  To track this, the dwStatus value is saved off so that we can query it and place an appropriate message in the
			// log indicating that the failure wasn't due to policy, but rather due to an invalid digital signature (or corrupted file)
			switch (dwStatus)
			{
			case TRUST_E_BAD_DIGEST:
				{
					// problem with the digital signature hash of the object
					DEBUGMSG3(TEXT("SOFTWARE RESTRICTION POLICY: %s was disallowed because its current contents do not match its digital signature (status = 0x%X). The returned execution level was %d"),
						szObjectToEvaluate,
						(const ICHAR*)(INT_PTR)dwStatus,
						(const ICHAR*)(INT_PTR)dwSaferLevelId);

					break;
				}
			case TRUST_E_NO_SIGNER_CERT:
			case CERT_E_MALFORMED:
			case TRUST_E_COUNTER_SIGNER:
			case TRUST_E_CERT_SIGNATURE:
				{
					// problem with the certificate in the digital signature of the object
					DEBUGMSG3(TEXT("SOFTWARE RESTRICTION POLICY: %s was disallowed because its digital signature is invalid (status = 0x%X). The returned execution level was %d"),
						szObjectToEvaluate,
						(const ICHAR*)(INT_PTR)dwStatus,
						(const ICHAR*)(INT_PTR)dwSaferLevelId);

					break;
				}
			case TRUST_E_NOSIGNATURE:
			case TRUST_E_SUBJECT_FORM_UNKNOWN:
			case TRUST_E_PROVIDER_UNKNOWN:
				{
					// signed file is unrecognized
					DEBUGMSG3(TEXT("SOFTWARE RESTRICTION POLICY: %s was disallowed because its digital signature is unrecognized (status = 0x%X). The returned execution level was %d"),
						szObjectToEvaluate,
						(const ICHAR*)(INT_PTR)dwStatus,
						(const ICHAR*)(INT_PTR)dwSaferLevelId);

					break;
				}
			case CERT_E_EXPIRED:
				{
					// certificate has expired
					DEBUGMSG3(TEXT("SOFTWARE RESTRICTION POLICY: %s was disallowed because a required certificate in its digital signature has expired (status = 0x%X). The returned execution level was %d"),
						szObjectToEvaluate,
						(const ICHAR*)(INT_PTR)dwStatus,
						(const ICHAR*)(INT_PTR)dwSaferLevelId);

					break;
				}
			case CERT_E_REVOKED:
				{
					// certificate has been revoked by its issuer
					DEBUGMSG3(TEXT("SOFTWARE RESTRICTION POLICY: %s was disallowed because a required certificate in its digital signature has been revoked by its issuer (status = 0x%X). The returned execution level was %d"),
						szObjectToEvaluate,
						(const ICHAR*)(INT_PTR)dwStatus,
						(const ICHAR*)(INT_PTR)dwSaferLevelId);

					break;
				}
			default:
				{
					// certificate software restriction policy forced revocation
					DEBUGMSG5(TEXT("SOFTWARE RESTRICTION POLICY: A publisher (certificate) rule in the %s software restriction %s policy disallows execution of %s (status = 0x%X). The returned execution level was %d"),
						dwSaferDefault == 0 ? TEXT("configured") : TEXT("default"),
						dwSaferScope == SAFER_SCOPEID_MACHINE ? TEXT("machine") : TEXT("user"),
						szObjectToEvaluate,
						(const ICHAR*)(INT_PTR)dwStatus,
						(const ICHAR*)(INT_PTR)dwSaferLevelId);

					break;
				}
			}
		}
		else
		{
			// check for specific Safer Identification Type
			switch (pSaferIdentHeader->dwIdentificationType)
			{
			case SaferIdentityDefault:
				{
					// default Safer security level
					// handled above by IsEqualGUID comparison to guidDefaultRule

					break;
				}
			case SaferIdentityTypeImageName:
				{
					// path software restriction policy forced revocation
					Assert(pSaferIdentHeader->cbStructSize == sizeof(SAFER_PATHNAME_IDENTIFICATION));
					PSAFER_PATHNAME_IDENTIFICATION pSaferIdentPath = (PSAFER_PATHNAME_IDENTIFICATION) pbSaferIdent;
					DEBUGMSG5(TEXT("SOFTWARE RESTRICTION POLICY: The path rule '%s' with image name '%s' in the %s software restriction %s policy disallows execution. The returned execution level was %d"),
						wszId,
						pSaferIdentPath->ImageName,
						dwSaferDefault == 0 ? TEXT("configured") : TEXT("default"),
						dwSaferScope == SAFER_SCOPEID_MACHINE ? TEXT("machine") : TEXT("user"),
						(const ICHAR*)(INT_PTR)dwSaferLevelId);

					break;
				}
			case SaferIdentityTypeImageHash:
				{
					// hash software restriction policy forced revocation
					Assert(pSaferIdentHeader->cbStructSize == sizeof(SAFER_HASH_IDENTIFICATION));
					PSAFER_HASH_IDENTIFICATION pSaferIdentHash = (PSAFER_HASH_IDENTIFICATION) pbSaferIdent;
					DEBUGMSG4(TEXT("SOFTWARE RESTRICTION POLICY: The hash rule '%s' in the %s software restriction %s policy disallows execution. The returned execution level was %d"),
						wszId,
						dwSaferDefault == 0 ? TEXT("configured") : TEXT("default"),
						dwSaferScope == SAFER_SCOPEID_MACHINE ? TEXT("machine") : TEXT("user"),
						(const ICHAR*)(INT_PTR)dwSaferLevelId);

					break;
				}
			case SaferIdentityTypeUrlZone:
				{
					// UrlZone software restriction policy forced revocation
					Assert(pSaferIdentHeader->cbStructSize == sizeof(SAFER_URLZONE_IDENTIFICATION));
					PSAFER_URLZONE_IDENTIFICATION pSaferIdentZone = (PSAFER_URLZONE_IDENTIFICATION) pbSaferIdent;
					DEBUGMSG4(TEXT("SOFTWARE RESTRICTION POLICY: A UrlZone rule for zone '%d' in the %s software restriction %s policy disallows execution. The returned execution level was %d"),
						(const ICHAR*)(INT_PTR)pSaferIdentZone->UrlZoneId,
						dwSaferDefault == 0 ? TEXT("configured") : TEXT("default"),
						dwSaferScope == SAFER_SCOPEID_MACHINE ? TEXT("machine") : TEXT("user"),
						(const ICHAR*)(INT_PTR)dwSaferLevelId);

					break;
				}
			case SaferIdentityTypeCertificate:
				{
					// certificate/publisher rule
					// handled above by IsEqualGUID comparison to guidCertRule

					break;
				}
			default:
				{
					// uknown!
					AssertSz(0, "Uknown software restriction policy identification type was returned");
					break;
				}
			}
		}
	}// end verbose software restriction policy information logging

	if (pbSaferIdent)
	{
		delete [] pbSaferIdent;
		pbSaferIdent = NULL;
	}

	AssertNonZero(ADVAPI32::SaferCloseLevel(hSaferLevel));

	// object is not trusted, indicate in Application EventLog
	ICHAR szSaferLevel[100];
	StringCchPrintf(szSaferLevel, (sizeof(szSaferLevel)/sizeof(ICHAR)), TEXT("0x%x"), dwSaferLevelId);
	ICHAR szSaferStatus[100];
	StringCchPrintf(szSaferStatus, (sizeof(szSaferStatus)/sizeof(ICHAR)), TEXT("0x%x"), dwStatus); // generally, status will be zero unless a failed WinVerifyTrust call
	DEBUGMSGE2(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_SAFER_POLICY_UNTRUSTED, szObjectToEvaluate, szSaferLevel, szSaferStatus);

	return false;
#else
        UNREFERENCED_PARAMETER(phSaferLevel);
        UNREFERENCED_PARAMETER(stType);
        UNREFERENCED_PARAMETER(szFriendlyName);
        UNREFERENCED_PARAMETER(szMsiObject);
        UNREFERENCED_PARAMETER(piStorage);
        UNREFERENCED_PARAMETER(riServices);


        return true; // no SAFER support on Win9X systems or ANSI

#endif // UNICODE

}

IMsiRecord* OpenAndValidateMsiStorageRec(const ICHAR* szFile, stEnum stType, IMsiServices& riServices, IMsiStorage*& rpiStorage, bool fCallSAFER, const ICHAR* szFriendlyName, SAFER_LEVEL_HANDLE *phSaferLevel)
/*----------------------------------------------------------------------------
Creates an MSI storage object on the given file. Verifies that it's actually
an MSI package.

  fCallSAFER = perform a SAFER policy check
  szFriendlyName = can be NULL, used when fCallSAFER is true
  phSaferLevel = can be NULL, used when fCallSAFER is true; on return can point to a SAFER authorization level object
 ------------------------------------------------------------------------------*/
{
	Assert(szFile);
	PMsiStorage pStorage(0);

	ivscEnum ivsc = ivscDatabase;
	switch (stType)
	{
	case stDatabase:  ivsc = ivscDatabase;  break;
	case stPatch:     ivsc = ivscPatch;     break;
	case stTransform: ivsc = ivscTransform; break;
	case stIgnore: break;
	default: 
		AssertSz(0, "Invalid storage type passed to OpenAndValidateMsiStorageRec");
		break;
	}

	IMsiRecord* piError = 0;
	bool fNet = false;

	MsiString strActualFile(szFile);

	if ((fNet = FIsNetworkVolume(szFile)) == true)
		MsiDisableTimeout();

	bool fFileUrl = false;
	bool fUrl = IsURL(szFile, fFileUrl);
	DWORD dwRet = ERROR_SUCCESS;

	if (fFileUrl)
	{
		Assert(fUrl);

		// canonicalize file url path (file://)

		CTempBuffer<ICHAR, 1>rgchFilePath(cchExpectedMaxPath+1);
		DWORD cchFilePath = rgchFilePath.GetSize();
		
		if (MsiConvertFileUrlToFilePath(szFile, rgchFilePath, &cchFilePath, 0))
		{
			strActualFile = static_cast<const ICHAR*>(rgchFilePath);
		}

		// if the conversion fails, we'll simply let this fall through to riServices.CreateStorage
		// it will create an appropriate error
	}
	else if (fUrl)
	{
		DEBUGMSGV1(TEXT("Opening database from URL: %s"), szFile);
		MsiString strCache;
		
		dwRet = DownloadUrlFile(szFile, *&strCache, fUrl);

		// if the file isn't found, we'll simply let this fall through to the riServices.CreateStorage.
		// it will create an appropriate error.

		//!! what if the user wants to cancel?
		if (fUrl && (ERROR_SUCCESS == dwRet))
			strActualFile = strCache;
	}
	
	piError = riServices.CreateStorage(strActualFile, ismReadOnly, *&pStorage);

	if (fNet)
		MsiEnableTimeout();

	if (piError)
	{
		if (fUrl && !fFileUrl && ERROR_SUCCESS == dwRet)
		{
			// clean up downloaded file
			CDeleteUrlLocalFileOnClose cDeleteUrlLocalFileOnClose(*strActualFile, /* fDeleteFromIECache = */ false);
		}

		return piError;
	}

	// make sure this storage is an MSI storage
	if (stType != stIgnore && !pStorage->ValidateStorageClass(ivsc))
	{
		pStorage = 0; // force release to allow file deletion

		if (fUrl && !fFileUrl && ERROR_SUCCESS == dwRet)
		{
			// clean up downloaded file
			CDeleteUrlLocalFileOnClose cDeleteUrlLocalFileOnClose(*strActualFile, /* fDeleteFromIECache = */ false);
		}

		return PostError(Imsg(idbgInvalidMsiStorage), szFile);
	}

	// perform SAFER policy check
	if (fCallSAFER && !VerifyMsiObjectAgainstSAFER(riServices, pStorage, (const ICHAR*)strActualFile, szFriendlyName, stType, phSaferLevel))
	{
		pStorage = 0; // force release to allow file deletion

		if (fUrl && !fFileUrl && ERROR_SUCCESS == dwRet)
		{
			// clean up downloaded file
			CDeleteUrlLocalFileOnClose cDeleteUrlLocalFileOnClose(*strActualFile, /* fDeleteFromIECache = */ false);
		}

		return PostError(Imsg(imsgMsiFileRejected), szFile);
	}

	if (fCallSAFER && phSaferLevel)
	{
		AssertNonZero(UpdateSaferLevelInMessageContext(*phSaferLevel));
	}

	// successful
	rpiStorage = pStorage;
	rpiStorage->AddRef();

	return 0;
}

UINT OpenAndValidateMsiStorage(const ICHAR* szPackage, stEnum stType, IMsiServices& riServices,
							  IMsiStorage*& rpiStorage, bool fCallSAFER, const ICHAR* szFriendlyName, SAFER_LEVEL_HANDLE *phSaferLevel)
/*----------------------------------------------------------------------------
Creates an MSI storage object on the given file. Verifies that it's actually
an MSI package.

Arguments:
	szPackage: The package on which to create the storage
	fCallSAFER:  whether or not to check SAFER policy on the package (futher restricted to NT >= 5.1)
	szFriendlyName: can be NULL, used when fCallSAFER is true
	phSaferLevel: can be NULL, used when fCallSAFER is true

Returns:
	ERROR_SUCCESS
	ERROR_INSTALL_PACKAGE_OPEN_FAILED
	ERROR_INSTALL_PACKAGE_INVALID
	ERROR_PATCH_PACKAGE_OPEN_FAILED
	ERROR_PATCH_PACKAGE_INVALID
	ERROR_FILE_NOT_FOUND
	ERROR_INSTALL_PACKAGE_REJECTED
 ------------------------------------------------------------------------------*/
{
	Assert(szPackage);

	UINT uiStat = ERROR_SUCCESS;

	PMsiRecord pError = OpenAndValidateMsiStorageRec(szPackage, stType, riServices, rpiStorage, fCallSAFER, szFriendlyName, phSaferLevel);

	if (pError)
	{
		if (pError->GetInteger(1) == idbgInvalidMsiStorage)
		{
			// different error depending on package type
			if (stDatabase == stType)
				uiStat = ERROR_INSTALL_PACKAGE_INVALID;
			else if (stPatch == stType)
				uiStat = ERROR_PATCH_PACKAGE_INVALID;
			else // stTransform == stType
				uiStat = ERROR_INSTALL_TRANSFORM_FAILURE;
		}
		else if (pError->GetInteger(1) == imsgMsiFileRejected)
		{
			// different error depending on package type
			if (stDatabase == stType)
				uiStat = ERROR_INSTALL_PACKAGE_REJECTED;
			else if (stPatch == stType)
				uiStat = ERROR_PATCH_PACKAGE_REJECTED;
			else // stTransform == stType
				uiStat = ERROR_INSTALL_TRANSFORM_REJECTED;
		}
		else
		{
			switch (pError->GetInteger(3))
			{
			case STG_E_FILENOTFOUND:
				uiStat = ERROR_FILE_NOT_FOUND;
				break;
			case STG_E_PATHNOTFOUND:
				uiStat = ERROR_PATH_NOT_FOUND;
				break;
			case STG_E_ACCESSDENIED:
			case STG_E_SHAREVIOLATION:
				{
					// different error depending on package type
					if (stDatabase == stType)
						uiStat = ERROR_INSTALL_PACKAGE_OPEN_FAILED;
					else if (stPatch == stType)
						uiStat = ERROR_PATCH_PACKAGE_OPEN_FAILED;
					else // stTransform == stType
						uiStat = ERROR_INSTALL_TRANSFORM_FAILURE;
					break;
				}
			case STG_E_INVALIDNAME:
				uiStat = ERROR_INVALID_NAME;
				break;
			default:
				{
					// different error depending on package type
					if (stDatabase == stType)
						uiStat = ERROR_INSTALL_PACKAGE_INVALID;
					else if (stPatch == stType)
						uiStat = ERROR_PATCH_PACKAGE_INVALID;
					else // stTransform == stType
						uiStat = ERROR_INSTALL_TRANSFORM_FAILURE;
					break;
				}
			}
		}
		pError = 0;
	}

	return uiStat;
}

DWORD CopyTempDatabase(const ICHAR* szDatabasePath, 
														const IMsiString*& ristrNewDatabasePath, 
														Bool& fRemovable,
														const IMsiString*& rpiVolumeLabel,
														IMsiServices& riServices,
														stEnum stType)
/*----------------------------------------------------------------------------
Copy database to temp tempdir.

Arguments:
	riDatabasePath:		 The path to the database.
	ristrNewDatabasePath: The new path to the database, if it was copied;
								 A null string otherwise.

Returns:	fTrue if successful; fFalse otherwise
------------------------------------------------------------------------------*/
{
	CElevate elevate; // elevate so we can access the MSI directory if necessary. //?? Do we need to elevate this entire function?
	PMsiPath pDatabasePath(0);
	PMsiRecord pError = 0;
	MsiString strDatabaseName;
	DWORD iReturn = ERROR_SUCCESS;

	if ((pError = riServices.CreateFilePath(szDatabasePath, *&pDatabasePath, *&strDatabaseName)) != 0)
		return ERROR_FILE_NOT_FOUND;

	PMsiVolume pVolume = &pDatabasePath->GetVolume();

	MsiString(pVolume->VolumeLabel()).ReturnArg(rpiVolumeLabel);

	idtEnum idtDatabase = pVolume->DriveType();
	fRemovable = (idtCDROM == idtDatabase) || (idtFloppy == idtDatabase) || (idtRemovable == idtDatabase) ? fTrue : fFalse;

	PMsiPath pTempPath(0);
	MsiString strTempFolder = ENG::GetTempDirectory();
	MsiString strTempFileName;

	const ICHAR* szExtension = szDatabaseExtension;
	switch (stType)
	{
	case stDatabase:
		szExtension = szDatabaseExtension;
		break;
	case stTransform:
		szExtension = szTransformExtension;
		break;
	case stPatch:
		szExtension = szPatchExtension;
		break;
	default:
		AssertSz(0, "Invalid storage type passed to CopyTempDatabase!");
		break;
	}

	// temp database will be secured by copy operation.
	if (((pError = riServices.CreatePath(strTempFolder, *&pTempPath)) != 0) ||
		 ((pError = pTempPath->TempFileName(0, szExtension, fTrue, *&strTempFileName, 0)) != 0))
		return ERROR_INSTALL_TEMP_UNWRITABLE;

	PMsiFileCopy pCopier(0);
	unsigned int cbFileSize;
	if (((pError = riServices.CreateCopier(ictFileCopier,  0, *&pCopier)) != 0) ||
		 ((pError = pDatabasePath->FileSize(strDatabaseName, cbFileSize)) != 0))
		return ERROR_INSTALL_FAILURE;

	// We don't actually initialize and display the progress bar
	// We've decided to only use a wait cursor 
	unsigned int cProgressTicks = 1024*2;
	unsigned int cbPerTick;
	do
	{
		cProgressTicks >>= 1;
		cbPerTick = cbFileSize/cProgressTicks;
	} while (cbPerTick < (1<<16) && cProgressTicks > 16);

	PMsiRecord pProgress = &CreateRecord(ProgressData::imdNextEnum);
	pCopier->SetNotification(cbPerTick, 0);
	PMsiRecord pCopyParams = &CreateRecord(IxoFileCopyCore::Args);
	AssertNonZero(pCopyParams->SetMsiString(IxoFileCopyCore::SourceName, *strDatabaseName));
	AssertNonZero(pCopyParams->SetMsiString(IxoFileCopyCore::DestName, *strTempFileName));
	AssertNonZero(pCopyParams->SetInteger(IxoFileCopyCore::Attributes, 0));
	AssertNonZero(pCopyParams->SetInteger(IxoFileCopyCore::FileSize, cbFileSize));
	
	// SECURITY NOTES:
	// This function can be run twice, once on the client side in a full UI mode, and 
	// also from the Service to securely re-cache the database.
	// 
	// When called from the client side, we assume the data to be suspect, and do not apply
	// additional security to the database.  We assume that the temp directory will prevent
	// other users from tampering with the data, but that the current user *is* able to 
	// contaminate the database.
	//
	// When the service starts, we re-cache the database from the source to a secure location.
	// This copy is the one from which we generate the scripts and begin modification to the
	// machine.  The users described by the SecureSecurityDescriptor should be the only ones
	// able to modify the cached copy.
	if (g_scServerContext == scService)
	{
		PMsiStream pSD(0);
		pError = GetSecureSecurityDescriptor(riServices, *&pSD);
		if (pError)
			return ERROR_INSTALL_FAILURE;
		if (!pCopyParams->SetMsiData(IxoFileCopyCore::SecurityDescriptor, pSD))
			return ERROR_INSTALL_FAILURE;
	}

	// we re-cache the database from the service before generating the script.

	int iNetRetries = 0;

	if(g_MessageContext.Invoke(imtProgress, pProgress) == imsCancel)
	{
		iReturn = ERROR_INSTALL_USEREXIT;
	}
	else
	{
		unsigned int cbFileSoFar = 0;

		for (;;)
		{
			pError = pCopier->CopyTo(*pDatabasePath, *pTempPath, *pCopyParams);
			if (pError)
			{
				int iError = pError->GetInteger(1);

				// If the copier reported that it needs the next cabinet,
				// we've got to wait until a media change operation
				// executes before continuing with file copying.
				if (iError == idbgCopyNotify)
				{
					cbFileSoFar += cbPerTick;
					//?? We could set these 2 record fields once up front, but the Message function feels
					//?? free to muck with the record pass to it, so we can't.
					AssertNonZero(pProgress->SetInteger(ProgressData::imdSubclass, ProgressData::iscProgressReport));
					AssertNonZero(pProgress->SetInteger(ProgressData::imdIncrement, cbPerTick));
					if(g_MessageContext.Invoke(imtProgress, pProgress) == imsCancel)
					{
						iReturn = ERROR_INSTALL_USEREXIT;
						break;
					}
				}
				else if (iError == idbgErrorSettingFileTime ||
							iError == idbgCannotSetAttributes)
				{
					// non-critical error - ignore
					break;
				}
				else if (iError == idbgUserAbort)
				{
					iReturn = ERROR_INSTALL_USEREXIT;
					break;
				}
				else if (iError == idbgUserIgnore)
				{
					break;
				}
				else if (iError == idbgUserFailure)
				{
					break;
				}
				else  
				{
					if (iError == imsgErrorOpeningFileForRead ||
						 iError == imsgErrorOpeningFileForWrite)
					{
						iReturn = ERROR_OPEN_FAILED;
					}
					else if (iError == idbgDriveNotReady)
					{
						iReturn = ERROR_NOT_READY;
					}
					else if (iError == imsgDiskFull)
					{
						iReturn = ERROR_DISK_FULL;
					}
					else if (iError == imsgErrorReadingFromFile)
					{
						iReturn = ERROR_READ_FAULT;
					}
					else if (iError == imsgNetErrorReadingFromFile)
					{
						 if (iNetRetries < MAX_NET_RETRIES)
						 {
							iNetRetries++;
							pCopyParams->SetInteger(IxoFileCopyCore::Attributes, ictfaRestart);
							continue;
						 }

						 iReturn = ERROR_UNEXP_NET_ERR;
					}
					else 
					{
						iReturn = STG_E_UNKNOWN;
					}

					pError->SetMsiString(0, *MsiString(GetInstallerMessage(iReturn)));

					switch(g_MessageContext.Invoke(imtEnum(imtRetryCancel|imtError), pError)) 
					{
					case imsIgnore:
						pCopyParams->SetInteger(IxoFileCopyCore::Attributes, ictfaIgnore);
					case imsRetry:
						if (iError == imsgNetErrorReadingFromFile)
						{
							pCopyParams->SetInteger(IxoFileCopyCore::Attributes, ictfaRestart);
						}
						continue;
					default: // imsCancel or failure
						pCopyParams->SetInteger(IxoFileCopyCore::Attributes, ictfaFailure);
						continue;
					};
				}
			}
			else
			{
				// Dispatch remaining progress for this file
				AssertNonZero(pProgress->SetInteger(ProgressData::imdIncrement, cbFileSize - cbFileSoFar));
				if(g_MessageContext.Invoke(imtProgress, pProgress) == imsCancel)
				{
					iReturn = ERROR_INSTALL_USEREXIT;
					break;
				}
				break;
			}
		}
	}

	if (ERROR_SUCCESS == iReturn)
		pTempPath->GetFullFilePath(strTempFileName, ristrNewDatabasePath);

	return iReturn;
}

UINT GetPackageCodeAndLanguageFromStorage(IMsiStorage& riStorage, ICHAR* szPackageCode, LANGID* piLangId)
/*----------------------------------------------------------------------------
Retrieves the product code from the summary info stream of a package
Arguments:
	szPackage: The package from which to retrieve the product code
	szPackageCode: A buffer of size 39 to receive the product code
	
Returns:
	ERROR_SUCCESS
	ERROR_INSTALL_PACKAGE_INVALID
 ------------------------------------------------------------------------------*/
{
	Assert(szPackageCode);
	PMsiStorage pStorage(0);
	PMsiSummaryInfo pSumInfo(0);
	UINT uiStat = ERROR_INSTALL_PACKAGE_INVALID; // may need to return ERROR_PATCH_PACKAGE_INVALID
																// in future if caller ever cares

	PMsiRecord pError = riStorage.CreateSummaryInfo(0, *&pSumInfo);
	if (pError == 0)
	{
		const IMsiString* piRevNumber = &(pSumInfo->GetStringProperty(PID_REVNUMBER));
		DWORD cchBuf = 39;
			
#ifdef UNICODE
		FillBufferW(piRevNumber, szPackageCode, &cchBuf);
#else
		FillBufferA(piRevNumber, szPackageCode, &cchBuf);
#endif
		piRevNumber->Release();

		if (0 != szPackageCode[0])
			uiStat = ERROR_SUCCESS;

		if (ERROR_SUCCESS == uiStat)
		{
			if (piLangId)
			{
				MsiString strTemplate = pSumInfo->GetStringProperty(PID_TEMPLATE);
				strTemplate.Remove(iseIncluding, ISUMMARY_DELIMITER);
				MsiString strLanguage = strTemplate.Extract(iseUpto, ILANGUAGE_DELIMITER);
				*piLangId = (LANGID)(int)strLanguage;
			}
		}
	}
	
	return uiStat;
}

UINT GetProductCodeFromPackage(const ICHAR* szPackage, ICHAR* szProductCode)
/*----------------------------------------------------------------------------
Retrieves the product code from a package.
Arguments:
	szPackage: The path name of the package.
	szProductCode: A buffer of size 39 to receive the product code.

Returns:
	ERROR_SUCCESS
	ERROR_INSTALL_PACKAGE_INVALID
------------------------------------------------------------------------------*/
{
	UINT		iStat = ERROR_INSTALL_PACKAGE_INVALID;
	PMSIHANDLE	hDatabase;
	PMSIHANDLE	hView;
	PMSIHANDLE	hRec;
	DWORD		dwBuf = 39;

	Assert(szPackage);
	Assert(szProductCode);

	iStat = MsiOpenDatabase(szPackage, MSIDBOPEN_READONLY, &hDatabase);
	if(iStat != ERROR_SUCCESS)
	{
		goto Exit;
	}

	iStat = MsiDatabaseOpenViewW(hDatabase, L"SELECT `Value` FROM `Property` WHERE `Property` = 'ProductCode'", &hView);
	if(iStat != ERROR_SUCCESS)
	{
		goto Exit;
	}

	iStat = MsiViewExecute(hView, 0);
	if(iStat != ERROR_SUCCESS)
	{
		goto Exit;
	}

	iStat = MsiViewFetch(hView, &hRec);
	if(iStat != ERROR_SUCCESS)
	{
		goto Exit;
	}

	iStat = MsiRecordGetString(hRec, 1, szProductCode, &dwBuf);
	if(iStat != ERROR_SUCCESS)
	{
		goto Exit;
	}

	return ERROR_SUCCESS;

Exit:

	return ERROR_INSTALL_PACKAGE_INVALID;
}

apEnum AcceptProduct(const ICHAR* szProductCode, bool fAdvertised, bool fMachine)
{
	int iDisableMsi        = GetIntegerPolicyValue(szDisableMsiValueName,    fTrue);
	int iMachineElevate    = GetIntegerPolicyValue(szAlwaysElevateValueName, fTrue);
	int iUserElevate       = GetIntegerPolicyValue(szAlwaysElevateValueName, fFalse);
	bool fAppIsAssigned = false;
	bool fIsAdmin = false;

#ifdef DEBUG
	{
	HKEY hKey;
	if ((g_scServerContext == scService) && (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer\\DEBUGPromptForAcceptProduct"), &hKey)))
	{
		RegCloseKey(hKey);
		switch (MessageBox(0, TEXT("Yes\t== Elevate\r\nNo\t== Impersonate\r\nCancel\t== Reject"), TEXT("DEBUG: Shall I elevate?"), MB_YESNOCANCEL | ((g_scServerContext == scService) ? MB_SERVICE_NOTIFICATION : 0)))
		{
		case IDYES:
			return apElevate;
		case IDNO:
			return apImpersonate;
		default:
			return apReject;
		}
	}
	}
#endif

	fIsAdmin = IsAdmin();

	if(fAdvertised)
	{
		fAppIsAssigned = IsProductManaged(szProductCode);
	}
	else if (fMachine && fIsAdmin)
	{
		fAppIsAssigned = true;
		DEBUGMSG(TEXT("Product installation will be elevated because user is admin and product is being installed per-machine."));
	}

	if (iDisableMsi == 2)
	{
		DEBUGMSG1(TEXT("Rejecting product '%s': Msi is completely disabled."), szProductCode && *szProductCode ? szProductCode : TEXT("first-run"));
		return apReject;
	}
	else if (fAppIsAssigned)
	{
		DEBUGMSG1(TEXT("Running product '%s' with elevated privileges: Product is assigned."), szProductCode && *szProductCode ? szProductCode : TEXT("first-run"));
		return apElevate;
	}
	else
	{
		if (iDisableMsi == 1 && !fIsAdmin)
		{
			DEBUGMSG1(TEXT("Rejecting product '%s': Non-assigned apps are disabled for non-admin users."), szProductCode && *szProductCode ? szProductCode : TEXT("first-run"));
			return apReject;
		}
		else if ((iUserElevate == 1) && (iMachineElevate == 1))
		{
			DEBUGMSG1(TEXT("Running product '%s' with elevated privileges: All apps run elevated."), szProductCode && *szProductCode ? szProductCode : TEXT("first-run"));
			return apElevate;
		}
		else
		{
			DEBUGMSG1(TEXT("Running product '%s' with user privileges: It's not assigned."), szProductCode && *szProductCode ? szProductCode : TEXT("first-run"));
			return apImpersonate;
		}
	}
}


/*----------------------------------------------------------------------------
Returns true if the user is an Admin OR the package is not elevated. Used
to determine if potentially dangerous source operations (source browse, patch, 
media browse) can be performed. Equivalent to checking the m_fRunScriptElevated 
flag but can be run without an engine or before the flag is set.
 ------------------------------------------------------------------------------*/
bool SafeForDangerousSourceActions(const ICHAR* szProductKey)
{
	if (IsAdmin()) 
		return true;

	// AcceptProduct() takes bools, not Bools.
	bool fAdvertised = false;
	bool fAllUsers = false;

	INSTALLSTATE is = INSTALLSTATE_UNKNOWN;
	is = MSI::MsiQueryProductState(szProductKey);
	if ((is == INSTALLSTATE_DEFAULT) || (is == INSTALLSTATE_ADVERTISED))
	{
		fAdvertised = true;
	}

	// this buffer should be big enough for all valid cases. 
	ICHAR rgchBuffer[5];
	DWORD cchBuffer = sizeof(rgchBuffer)/sizeof(ICHAR);
	if (ERROR_SUCCESS == MSI::MsiGetProductInfo(szProductKey, INSTALLPROPERTY_ASSIGNMENTTYPE, rgchBuffer, &cchBuffer))
	{
		// the product is already known
		fAllUsers = GetIntegerValue(rgchBuffer, NULL)==1;
	}

	return apElevate !=AcceptProduct(szProductKey, fAdvertised, fAllUsers);
}

//+--------------------------------------------------------------------------
//
//  Function:	SetMinProxyBlanketIfAnonymousImpLevel
//
//  Synopsis:	Sets a proxy blanket on an interface if the current impersonation
//              level is Anonymous.	
//
//  Arguments:  [in] piUnknown : The IUnknown interface on which the proxy blanket
//                               might need to get set.
//
//  Returns:    S_OK : If the proxy blanket was successfully set.
//              S_FALSE : If the existing impersonation level on the interfaces
//                        was higher than Anonymous
//              an error code otherwise.
//
//  History:	5/5/2002  RahulTh  created
//
//  Notes:      This function is called on interfaces that a client obtains
//              which could end up using the default machinewide DCOM settings
//              because an explicit proxy blanket was not set. This can cause
//              ACCESS_DENIED failures if the default machine-wide impersonation
//              level is set to Anonymous.
//
//              This function only sets the default impersonation levels to
//              IDENTIFY and authentication level to CONNECT. No cloaking is
//              used. Any interfaces requiring other settings should directly
//              call CoSetProxyBlanket directly.
//
//---------------------------------------------------------------------------
HRESULT SetMinProxyBlanketIfAnonymousImpLevel (IN IUnknown * piUnknown)
{
	HRESULT hRes = S_OK;
	DWORD dwImpLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
	DWORD dwAuthnSvc = RPC_C_AUTHN_DEFAULT;
	
	if (!piUnknown)
	{
		Assert (0);
		return E_INVALIDARG;
	}
	
	//
	// We don't really need to know the the authentication service here, but
	// ole32 on WindowsXP doesn't like it if we pass in a NULL for pAuthnSvc
	//
	hRes = OLE32::CoQueryProxyBlanket (piUnknown,
									   &dwAuthnSvc, /* authentication service */
									   NULL, /* authorization service */
									   NULL, /* principal name */
									   NULL, /* authentication level */
									   &dwImpLevel, /* impersonation level */
									   NULL, /* client identity */
									   NULL  /* capabilities of the proxy */
									   );
	if (SUCCEEDED(hRes))
	{
		//
		// Don't set the proxy blanket if impersonation level already better
		// than anonymous.
		//
		if (dwImpLevel > RPC_C_IMP_LEVEL_ANONYMOUS)
			return S_FALSE;
		
		hRes = OLE32::CoSetProxyBlanket (piUnknown,
										 RPC_C_AUTHN_DEFAULT,
										 RPC_C_AUTHZ_DEFAULT,
										 NULL, /* principal name */
										 RPC_C_AUTHN_LEVEL_CONNECT,
										 RPC_C_IMP_LEVEL_IDENTIFY,
										 NULL, /* client identity */
										 EOAC_NONE
										 );
	}
	
	return hRes;
}

// REVIEW davidmck - probably should be combined with a similar function in engine.cpp
static IMsiServer* CreateServerProxy() 
{
	if (g_scServerContext != scService && g_scServerContext != scServer)
	{
		return ENG::CreateMsiServerProxy();
	}
	return 0;
}

int RunServerSideInstall(ireEnum ireProductSpec,   // type of string specifying product
			   const ICHAR* szProduct,      // required, matches ireProductSpec 
			   const ICHAR* szAction,       // optional, engine defaults to "INSTALL"
			   const ICHAR* szCommandLine,  // optional command line
				iioEnum iioOptions,
				IMsiServices& riServices)
{
	DWORD dwRet = ERROR_SUCCESS;
	PMsiServer pServer = CreateServerProxy();
	if (!pServer)
	{
		DEBUGMSG("Failed to connect to server.");
		return ERROR_INSTALL_SERVICE_FAILURE;
	}

	PMsiMessage pMessage = new CMsiClientMessage();

	riServices.SetNoOSInterruptions();
	
	Assert((iioOptions & iioClientEngine) == 0); // we shouldn't have a client engine here; we're doing a basic UI install
	dwRet = pServer->DoInstall(ireProductSpec, szProduct, szAction, szCommandLine,
									  g_szLogFile, g_dwLogMode, g_fFlushEachLine, *pMessage, iioOptions, 0);

	riServices.ClearNoOSInterruptions();
	
	if (ERROR_SUCCESS_REBOOT_INITIATED == dwRet)
	{
		Assert(!FTestNoPowerdown()); // if we're blocking powerdown then it'll block our reboot
		pServer->Reboot();
	}

	return dwRet;
}


//+--------------------------------------------------------------------------
//
//  Function:	DownloadUrlFile
//
//  Synopsis:	Initiates download of URL file using either WinHttp or UrlMon
//
//  Arguments:	
//				szPotentialURL    - [in] URL path for file to download
//              rpistrPackagePath - [out] path to downloaded file on local disk
//              fURL              - [out] bool for whether szPotentialURL was
//                                        an actual URL
//              cTicks            - [in] count of ticks to use for progress bar 
//              pfUsedWinHttp     - [out] optional, true if WinHttp used for download,
//                                                  false if UrlMon used for download
//
//  Returns:	DWORD value indicating success of failure
//                    ERROR_SUCCESS          -- successful download
//                    ERROR_OUTOFMEMORY      -- memory allocations failed
//                    ERROR_INSTALL_USEREXIT -- user aborted download
//                    ERROR_FILE_NOT_FOUND   -- invalid file path
//
//  Notes:
//        WinHttp is used on Server and above platforms. Otherwise UrlMon
//        is used.  Given the possibility of WinHttp 5.1 support added to Win2K SP3
//        and XP SP1, this code could be modified to use WinHttp when available
//        as it is preferable to UrlMon
//
//---------------------------------------------------------------------------
DWORD DownloadUrlFile(const ICHAR* szPotentialURL, const IMsiString *&rpistrPackagePath, bool& fURL, int cTicks, bool* pfUsedWinHttp)
{
	DWORD iStat = ERROR_SUCCESS;
	CTempBuffer<ICHAR, cchExpectedMaxPath + 1> rgchURL;
	DWORD cchURL = cchExpectedMaxPath + 1;
	fURL = true;

	if (!MsiCanonicalizeUrl(szPotentialURL, rgchURL, &cchURL, 0))
	{
		iStat = WIN::GetLastError();
		fURL = false;
		if (ERROR_INSUFFICIENT_BUFFER == iStat)
		{
			cchURL++; // documentation on shlwapi behavior unclear, so being safe
			rgchURL.SetSize(cchURL);
			if (! (ICHAR*) rgchURL)
				iStat = ERROR_OUTOFMEMORY;

			if (MsiCanonicalizeUrl(szPotentialURL, rgchURL, &cchURL, 0))
			{
				fURL = true;
				iStat = ERROR_SUCCESS;
			}
			else
			{
				iStat = WIN::GetLastError();
			}
		}
	}

	if (fURL)
	{
		//
		// FUTURE: given that WinHttp 5.1 will be redist, if this code base is used for platforms
		//         other than server and greater, we can add new checks to use WinHttp on
		//         those platforms as well (eg. Win2K SP3, XP SP1) since it is preferable over UrlMon
		//

		if (MinimumPlatformWindowsDotNETServer())
		{
			// always use WinHttp on Windows Server and greater
			if (pfUsedWinHttp)
				*pfUsedWinHttp = true;
			return WinHttpDownloadUrlFile(rgchURL, rpistrPackagePath, cTicks);
		}
		else
		{
			// use UrlMon for downlevel
			if (pfUsedWinHttp)
				*pfUsedWinHttp = false;
			return UrlMonDownloadUrlFile(rgchURL, rpistrPackagePath, cTicks);
		}
	}

	return iStat;
}

bool ShouldLogCmdLine(void)
{
	return dpLogCommandLine == (GetIntegerPolicyValue(szDebugValueName, fTrue) & dpLogCommandLine);
}

const ICHAR* LoggedCommandLine(const ICHAR* szCommand)
{
	static const ICHAR szNull[] = TEXT("");

	if ( ShouldLogCmdLine() )
		return szCommand ? szCommand : szNull;
	else
		return IPROPVALUE_HIDDEN_PROPERTY;
}

bool IsInstallingFromTSClient(const ICHAR* szDatabasePath)
{
	bool fReturn = true; // init to secure safe default (note: could get false positives as a result)
	if ( szDatabasePath && *szDatabasePath )
	{
		int cchTSClient = IStrLen(TSCLIENT_DRIVE);
		if (IStrLen(szDatabasePath) < cchTSClient)
			fReturn = false;
		else if (CSTR_EQUAL != CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT),
												NORM_IGNORECASE, szDatabasePath, cchTSClient, TSCLIENT_DRIVE, cchTSClient))
		{
			fReturn = false;
		}
	}
	else
		Assert(0);

	return fReturn;
}

int CreateAndRunEngine(ireEnum ireProductSpec,   // type of string specifying product
			   const ICHAR* szProduct,      // required, matches ireProductSpec 
			   const ICHAR* szAction,       // optional, engine defaults to "INSTALL"
			   const ICHAR* szCommandLine,  // optional command line
			   CMsiEngine*  piParentEngine, // parent engine object for nested call only
				iioEnum      iioOptions)     // installation options
/*----------------------------------------------------------------------------
Note: Cannot be called directly. This is runs in its own thread.
Creates an engine and executes an action. The product may be specified by
a product code, a package path. a child storage (only for nested installs),
or a database handle in text form (for running from authoring tools).
If the product code is specified then we hunt down the package.
If the package path is specified then we'll use it unless we find
a local cached package (unless we're advertising or doing an admin install,
in which case we always use the specified package).

Arguments:
	ireProductSpec: The type of text string used to identify the product
	szProduct:      Product code, package path, substorage name, handle, depending upon above
	szAction:       The action to be executed, or 0 to execute the default action
	szCommandLine:  The command-line to initialize the engine.
	
Returns:
	ERROR_SUCCESS -               Action completed successfully
	ERROR_UNKNOWN_PRODUCT -       Product code is unrecognized
	ERROR_INSTALL_FAILURE -       Install failed or no usable launcher
	ERROR_BAD_CONFIGURATION -     Corrupt config info
	ERROR_INSTALL_SOURCE_ABSENT - The source was unavailable
	ERROR_INSTALL_SUSPEND -       The install was suspended
	ERROR_INSTALL_USEREXIT -      The user exited the install
	ERROR_INSTALL_REMOTE_PROHIBITED - An installation from a TS client machine was
	                                  attempted outside of a restricted engine.
 ------------------------------------------------------------------------------*/
{
	bool fOLEInitialized = false;
	DISPLAYACCOUNTNAME(TEXT("At the beginning of CreateAndRunEngine"));


	HRESULT hRes = OLE32::CoInitialize(0);
	if (SUCCEEDED(hRes))
	{
		fOLEInitialized = true;
	}
	else if (RPC_E_CHANGED_MODE == hRes) //?? Is this OK to ignore? 
	{
		// ignore -- OLE has been initialized with COINIT_MULTITHREADED
	}
	else
	{
		return ERROR_INSTALL_FAILURE;
	}

	CCoUninitialize coUninit(fOLEInitialized);
	ResetCachedPolicyValues();
	CImpersonate Impersonate(fTrue); // Always start impersonated; if we're allowed to elevate we'll do so below
	DISPLAYACCOUNTNAME(TEXT("After Impersonating in CreateAndRunEngine"));
	DEBUGMSG3(TEXT("******* RunEngine:\r\n           ******* Product: %s\r\n           ******* Action: %s\r\n           ******* CommandLine: %s"), szProduct ? szProduct : TEXT(""), szAction ? szAction : TEXT(""), LoggedCommandLine(szCommandLine));
	Assert(szProduct);
	CTempBuffer<ICHAR, 1> rgchOriginalPackagePath(szProduct ? IStrLen(szProduct)+1 : cchExpectedMaxPath + 1);
	CAPITempBuffer<ICHAR, 1> rgchPackagePath;
	CTempBuffer<ICHAR, 1> rgchSourceDir(cchExpectedMaxPath + 1);
	CTempBuffer<ICHAR, cchProductCode + 1> rgchProductCode;

	if (!rgchPackagePath.SetSize(cchExpectedMaxPath + 1))
		return ERROR_OUTOFMEMORY;

	rgchPackagePath[0] = 0;
	rgchProductCode[0] = 0;
	bool fUrl = false;	// Package path is a Url
	bool fFileUrl = false; // package path is file Url
	bool fUsedWinHttp = true;
	CDeleteUrlLocalFileOnClose cDeleteUrlLocalFileOnClose; // will set filename if file is URL and downloaded

	int iStat = ERROR_SUCCESS;
	IMsiEngine* piEngine;
	PMsiStorage pStorage(0);
	PMsiDatabase pDatabase(0);
	plEnum plPackageLocation = plAny;

	IMsiServices* piServices = g_piSharedServices;
	Assert(piServices);   // loaded by parent thread

	LANGID iLangId = 0;
	MsiString strCommandLine = szCommandLine;
	MsiString strAction;
	MsiString strDatabase;
	MsiString strPatch;
	MsiString strReinstallMode;
	MsiString strRunOnceEntry;
	MsiString strTransforms;
	MsiString strInstanceGUID;
	MsiString strNewInstance;
	MsiString strTransformsSecure;
	MsiString strTransformsAtSource;
	MsiString strPackageDownloadLocalCopy;
	MsiString strPatchDownloadLocalCopy;

	ProcessCommandLine(strCommandLine, 0, &strTransforms, &strPatch, &strAction, &strDatabase, MsiString(*IPROPNAME_REINSTALLMODE), &strReinstallMode, fTrue, 0, 0);
	ProcessCommandLine(strCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_RUNONCEENTRY), &strRunOnceEntry, fTrue, 0, 0);
	ProcessCommandLine(strCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_MSINEWINSTANCE), &strNewInstance, fTrue, 0, 0);
	ProcessCommandLine(strCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_MSIINSTANCEGUID), &strInstanceGUID, fTrue, 0, 0);
	ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_TRANSFORMSSECURE),   &strTransformsSecure, fTrue, 0,0);
	ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_TRANSFORMSATSOURCE), &strTransformsAtSource, fTrue, 0,0);
	ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_MSIPACKAGEDOWNLOADLOCALCOPY), &strPackageDownloadLocalCopy, fTrue, 0, 0);
	ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_MSIPATCHDOWNLOADLOCALCOPY), &strPatchDownloadLocalCopy, fTrue, 0, 0);

	AssertSz(strDatabase.TextSize() == 0, "Cannot specify database on the command line.");

	if (szAction && *szAction)
		strAction = szAction;
	
	Bool fAdmin = strAction.Compare(iscExact, IACTIONNAME_ADMIN) ? fTrue : fFalse;
	BOOL fAdminOrAdvertise = (fAdmin || strAction.Compare(iscExact, IACTIONNAME_ADVERTISE));

	// special case which needs to be handled here
	BOOL fAdminPatch = fAdmin && strPatch.TextSize();

	int iIndex = 0;
	Assert(REINSTALLMODE_PACKAGE);
	for(int i = REINSTALLMODE_PACKAGE; !(i & 1); i >>= 1, iIndex++);
	
	bool fReinstallModePackage = false;
	if(strReinstallMode.Compare(iscWithinI, &(szReinstallMode[iIndex])))
	{
		// recache package flag included
		fReinstallModePackage = true;
	}

	// MSIDOWNLOADLOCALPATCHCOPY only accepted on command line if patch property is present,
	//  user is admin, and property was set by MsiApplyPatch API
	if (strPatchDownloadLocalCopy.TextSize())
	{
		if (0 == strPatch.TextSize() || !(iioOptions & iioPatchApplication) || !IsAdmin())
			return ERROR_INVALID_COMMAND_LINE;
	}

	//
	// MULTIPLE INSTANCE SUPPORT:
	//  (1) detect whether or not this is a multiple instance installation via presence of MSINEWINSTANCE on the cmd line
	//  (2) perform basic multiple instance cmd line validation
	//			- MSINEWINSTANCE + MSIINSTANCEGUID cannot both be present on the cmd line 
	//          - force package path invocation for MSINEWINSTANCE
	//          - MSIINSTANCEGUID must be for product with InstanceType = 1
	//          - MSIINSTANCEGUID must be for installed/advertised product
	//

	bool fNewInstance = false;
	if (strNewInstance.TextSize())
	{
		if (0 == strTransforms.TextSize() || strInstanceGUID.TextSize())
		{
			// use of MSINEWINSTANCE on command line requires including instance transform in TRANSFORMS property
			// and precludes use of MSIINSTANCEGUID since this is not known yet
			DEBUGMSGV(TEXT("Invalid use of MSINEWINSTANCE property."));
			return ERROR_INVALID_COMMAND_LINE;
		}

		// force ireProductSpec == irePackagePath
		if (ireProductSpec != irePackagePath)
		{
			DEBUGMSGV(TEXT("Invalid use of MSINEWINSTANCE property. Use of property requires package path invocation."));
			return ERROR_INVALID_COMMAND_LINE;
		}

		// do not allow for nested installs
		if (piParentEngine)
		{
			DEBUGMSGV(TEXT("Invalid use of MSINEWINSTANCE property. Multiple instance is not supported with nested installs."));
			return ERROR_INVALID_COMMAND_LINE;
		}

		fNewInstance = true;
	}

	if (strInstanceGUID.TextSize() != 0)
	{
		// multi-instance install via transform
		INSTALLSTATE isInstance = INSTALLSTATE_UNKNOWN;
		isInstance = MsiQueryProductState(strInstanceGUID);
		if (isInstance != INSTALLSTATE_DEFAULT && isInstance != INSTALLSTATE_ADVERTISED)
		{
			// the instance is not installed in this context
			DEBUGMSG1(TEXT("Specified instance %s is not installed. MSIINSTANCEGUID must reference an installed instance."), (const ICHAR*)strInstanceGUID);
			return ERROR_INVALID_COMMAND_LINE;
		}


		int iInstanceType = 0;
		CTempBuffer<ICHAR, 100> szBuffer;
		if (ENG::GetProductInfo(strInstanceGUID, INSTALLPROPERTY_INSTANCETYPE, szBuffer))
			iInstanceType = strtol(CConvertString((const ICHAR*)szBuffer));

		if (1 != iInstanceType)
		{
			// not a multi-instance install
			DEBUGMSGV(TEXT("Invalid use of MSIINSTANCEGUID property. This can only be used for a multiple instance install."));
			return ERROR_INVALID_COMMAND_LINE;
		}
	}

	// remove RunOnce entry if necessary - want to do this as early as possible
	if((g_scServerContext == scClient || g_scServerContext == scCustomActionServer) && strRunOnceEntry.TextSize())
	{
		PMsiServer pServer = CreateMsiServer();
		if(pServer)
		{
			DEBUGMSG1(TEXT("Removing RunOnce entry: %s"), (const ICHAR*)strRunOnceEntry);
			AssertRecord(pServer->RemoveRunOnceEntry(strRunOnceEntry));
		}
		else
		{
			DEBUGMSG1(TEXT("Cannot remove RunOnce entry: %s.  Couldn't connect to service"), (const ICHAR*)strRunOnceEntry);
		}
	}
	
	if (ireProductSpec == irePackagePath) // we need to expand the path before we go to the server
	{
		StringCchCopy(rgchOriginalPackagePath, rgchOriginalPackagePath.GetSize(), szProduct);
		if (ExpandPath(rgchOriginalPackagePath, rgchPackagePath))
		{
			rgchOriginalPackagePath.SetSize(rgchPackagePath.GetSize());
			StringCchCopy(rgchOriginalPackagePath, rgchOriginalPackagePath.GetSize(), rgchPackagePath);
		}
		else
		{
			return ERROR_INVALID_PARAMETER;
		}
	}
	
	MsiSuppressTimeout();
	
	Assert(g_scServerContext == scClient  ||
			 g_scServerContext == scCustomActionServer ||
			 g_MessageContext.IsServiceInstalling());

	CMutex hExecuteMutex; // will release when out of scope

	CTempBuffer<ICHAR, 1> rgchCurDir(cchExpectedMaxPath);

	if (g_scServerContext == scClient || g_scServerContext == scCustomActionServer)
	{
		// Get the current directory 

		rgchCurDir[0] = 0;
		DWORD dwRes = WIN::GetCurrentDirectory(rgchCurDir.GetSize(), rgchCurDir);

		if (dwRes > rgchCurDir.GetSize())
		{
			rgchCurDir.SetSize(dwRes);
			rgchCurDir[0] = 0;
			dwRes = GetCurrentDirectory(rgchCurDir.GetSize(), rgchCurDir);
		}

		strCommandLine += TEXT(" ") IPROPNAME_CURRENTDIRECTORY TEXT("=\"");
		strCommandLine += (const ICHAR*)rgchCurDir;
		strCommandLine += TEXT("\"");

		ICHAR buf[12];
		iuiEnum iui = iuiDefaultUILevel;
		if (iuiDefault != g_message.m_iuiLevel)
			iui = g_message.m_iuiLevel;

		ltostr(buf, (int)iui);

		strCommandLine += TEXT(" ") IPROPNAME_CLIENTUILEVEL TEXT("=");
		strCommandLine += buf;
		strCommandLine += TEXT(" ");

		// need to add CLIENTPROCESSID= to command line
		strCommandLine += TEXT(" ") IPROPNAME_CLIENTPROCESSID TEXT("=");
		strCommandLine += MsiString((int)WIN::GetCurrentProcessId());
		strCommandLine += TEXT(" ");

		MsiString strHomeVars;
		GetHomeEnvironmentVariables(*&strHomeVars);

		strCommandLine += strHomeVars;

		// we need to acquire the following privileges in case we need to reboot OR increase the registry quota
		// the token's privileges are static so we need to do this before we connect
		// to the server
		if (!g_fWin9X)
		{
			AcquireTokenPrivilege(SE_SHUTDOWN_NAME);       
			AcquireTokenPrivilege(SE_INCREASE_QUOTA_NAME);
		}

	}

	if (g_message.m_fEndDialog)
		iioOptions = (iioEnum)(iioOptions | iioEndDialog);


	Assert((iuiDefaultUILevel == iuiNone) || (iuiDefaultUILevel == iuiBasic));
	if (!piParentEngine && (g_scServerContext == scClient  || g_scServerContext == scCustomActionServer) && // running on client side or triggering an install from custom action
		(g_message.m_iuiLevel == iuiNone    ||
		 g_message.m_iuiLevel == iuiBasic   ||
		 g_message.m_iuiLevel == iuiDefault) &&
		(!g_fWin9X))		// RunServerSideInstall tries to connect to the service. On Win9x we do everything in-proc.
	{
		if ( g_scServerContext == scClient &&
			  ireProductSpec == irePackagePath &&
			  !(iioOptions & iioRestrictedEngine) && // restricted engine is allowed to open packages on TS client machines
			  IsInstallingFromTSClient(rgchOriginalPackagePath) )
			return ERROR_INSTALL_REMOTE_PROHIBITED;
		
		if ( g_scServerContext == scClient && strPackageDownloadLocalCopy.TextSize() )
		{
			// not allowed to pass MSIDOWNLOADLOCALCOPY on the command line of the client
			return ERROR_INVALID_COMMAND_LINE;
		}

		DEBUGMSG("Client-side and UI is none or basic: Running entire install on the server.");

		GrabExecuteMutex(hExecuteMutex);

		iStat = RunServerSideInstall(ireProductSpec, ireProductSpec == irePackagePath ? rgchOriginalPackagePath : szProduct, szAction, strCommandLine, iioOptions, *piServices);
		
		return iStat;
	}

	if(szAction)
	{
		// need to add ACTION= to command line
		strCommandLine += TEXT(" ") IPROPNAME_ACTION TEXT("=");
		strCommandLine += szAction;
	}

	//---------------------------------------------------------------------------------------------------------------
	// SAFER
	//
	//               + SAFER policy check determination requirements +
	//
	// 1.  SAFER check should not occur until AFTER we have made the determination at to whether or not the
	//      the product is known.  Cracking open the package to extract the package code and/or product code
	//      is not malicious.
	// 2.  SAFER must be called on a package recache (iioOptions & iioReinstallModePackage)
	// 3.  SAFER must be called if the product is installed or registered but the local cached package is missing
	// 4.  SAFER must be called if the product is not a known product (package will be at the source location) 
	// 5.  SAFER is NOT called on a nested install (trust determined by toplevel package)
	// 6.  SAFER is NOT called when invocation is ireSubStorage (package is embedded - covered by toplevel package)
	// 7.  SAFER is NOT called when we are opening the local cached MSI (secured and trusted)
	//
	// NOTE: MsiOpenPackage / ireProductSpec == ireDatabaseHandle are taken care of in CreateInitializedEngine
	//--------------------------------------------------------------------------------------------------------------

	bool fNestedInstallOrSubStoragePackage = (piParentEngine || ireProductSpec == ireSubStorage) ? true : false;
	SAFER_LEVEL_HANDLE hSaferLevel = 0;

	MsiString strSubStorageName;

	if (ireProductSpec == irePackagePath)
	{
		fUrl = IsURL(szProduct, fFileUrl);
		if (!fUrl)
		{
			//
			// SAFER: initial opening of package is not malicious.  We want to first crack it open and grab its
			//          package code so we can determine if the product is a known product.  We prefer to use the
			//          local cached package whenever possible.  Therefore fCallSAFER = false and phSaferLevel = NULL.
			//

			iStat = OpenAndValidateMsiStorage(szProduct, stDatabase, *piServices, *&pStorage, /* fCallSAFER = */ false, /* szFriendlyName = */ NULL, /* phSaferLevel = */ NULL);
		}
		else if (fFileUrl)
		{
			if (!rgchPackagePath.SetSize(cchExpectedMaxPath + 1))
				return ERROR_OUTOFMEMORY;
			DWORD cchBuf = rgchPackagePath.GetSize();
			if (!MsiConvertFileUrlToFilePath(rgchOriginalPackagePath, rgchPackagePath, &cchBuf, 0))
				iStat = ERROR_INVALID_PARAMETER;

			if (ERROR_SUCCESS == iStat)
			{
				//
				// SAFER: initial opening of package is not malicious.  We want to first crack it open and grab its
				//          package code so we can determine if the product is a known product.  We prefer to use the
				//          local cached package whenever possible.  Therefore fCallSAFER = false and phSaferLevel = NULL.
				//

				iStat = OpenAndValidateMsiStorage(rgchPackagePath, stDatabase, *piServices, *&pStorage, /* fCallSAFER = */ false, /* szFriendlyName = */ NULL, /* phSaferLevel = */ NULL);
			}
		}
		else
		{
			// internet download
			MsiString strPackagePath;

			// FUTURE: Use a smart cache manager to manage downloads to prevent hit of multiple downloads
			//         across client and service sessions and across accesses in service.  Until then,
			//         optimize for admin by using a command line property sent by the client
			//

			// MSIPACKAGEDOWNLOADLOCALCOPY property only accepted if:
			//	in the service, user is admin, file exists; otherwise download occurs again

			bool fDownloadUrlFile = true;

			if (strPackageDownloadLocalCopy.TextSize() // property provided
				&& scService == g_scServerContext // in the service
				&& IsAdmin()) // user is admin
			{
				if (0xFFFFFFFF != MsiGetFileAttributes((const ICHAR*)strPackageDownloadLocalCopy))
				{
					// file exists, so we'll use it
					fDownloadUrlFile = false;
				}
			}
			else if (strPackageDownloadLocalCopy.TextSize())
			{
				// MSIDOWNLOADLOCALCOPY illegally provided on command line
				return ERROR_INVALID_COMMAND_LINE;
			}

			if (fDownloadUrlFile)
			{
                iStat = DownloadUrlFile(rgchOriginalPackagePath, *&strPackagePath, fUrl, /* cTicks = */ 0, &fUsedWinHttp);

				if (fUrl && ERROR_SUCCESS == iStat)
				{
					MsiString strOriginalPackagePath((const ICHAR*)rgchOriginalPackagePath);
					cDeleteUrlLocalFileOnClose.SetFileName(fUsedWinHttp ? *strPackagePath : *strOriginalPackagePath, /* fDeleteFromIECache = */ !fUsedWinHttp);
					if (IsAdmin() || scService == g_scServerContext)
					{
						// set up MSIPACKAGEDOWNLOADLOCALCOPY property on command line
						DEBUGMSG(TEXT("Adding MSIPACKAGEDOWNLOADLOCALCOPY to command line."));
						strCommandLine += TEXT(" ") IPROPNAME_MSIPACKAGEDOWNLOADLOCALCOPY TEXT("=\"");
						strCommandLine += strPackagePath;
						strCommandLine += TEXT("\" ");
					}
				}
			}
			else
			{
				DEBUGMSG1(TEXT("Using previously downloaded file %s"), (const ICHAR*)strPackageDownloadLocalCopy);

				strPackagePath = strPackageDownloadLocalCopy;
				fUrl = true;
			}

			if(fUrl == false)
				iStat = ERROR_INVALID_PARAMETER;
			
			if (ERROR_SUCCESS == iStat)
			{
				//
				// SAFER: initial opening of package is not malicious.  We want to first crack it open and grab its
				//          package code so we can determine if the product is a known product.  We prefer to use the
				//          local cached package whenever possible.  Therefore fCallSAFER = false and phSaferLevel = NULL.
				//

				iStat = OpenAndValidateMsiStorage(strPackagePath, stDatabase, *piServices, *&pStorage, /* fCallSAFER = */ false, /* szFriendlyName = */ NULL, /* phSaferLevel = */ NULL);
				rgchPackagePath.SetSize(strPackagePath.TextSize()+1);
				int cchCopied = strPackagePath.CopyToBuf(rgchPackagePath, rgchPackagePath.GetSize() - 1);
				Assert(cchCopied == strPackagePath.TextSize());
			}
		}

		//
		// MULTIPLE INSTANCE SUPPORT: 
		//   (1) grovel the transforms_list looking for the instance transform (the product code changing transform)
		//   (2) validate instance transform
		//          - only one product code changing transform is allowed
		//          - new product code must not match a product that is already installed in the current context
		//          - a product code changing transform must be present
		//   (3) instance transform must be first transform in the list as the order of application is enforced such
		//       that an instance transform is always applied prior to any other transforms
		//

		if (ERROR_SUCCESS == iStat && fNewInstance)
		{
			bool fFoundInstanceMst = false;
			bool fFirstRun = true;
			bool fTransformsRemain = true;

			tpEnum tpLocation = tpUnknown;

			//
			// transform can be in one of three locations
			//   1. file transform (located at source of .msi package)
			//   2. embedded transform (stored within .msi package as a substorage)
			//   3. path transform (full path to .mst was provided)
			// NOTE: file and path transforms cannot be mixed, secure and unsecure cannot be mixed
			//

			if (*(const ICHAR*)strTransforms == SECURE_RELATIVE_TOKEN)
			{
				tpLocation = tpRelativeSecure;
				strTransforms.Remove(iseFirst, 1); // remove token
			}
			else if (*(const ICHAR*)strTransforms == SECURE_ABSOLUTE_TOKEN)
			{
				tpLocation = tpAbsolute;
				strTransforms.Remove(iseFirst, 1); // remove token
			}

			if ((strTransformsSecure   == 1) ||
				(strTransformsAtSource == 1) ||
				(GetIntegerPolicyValue(szTransformsSecureValueName, fTrue)) ||
				(GetIntegerPolicyValue(szTransformsAtSourceValueName, fFalse)))
			{
				tpLocation = tpUnknownSecure;
			}


			PMsiStorage pTransformStg(0);
			PMsiRecord pError(0);
			PMsiSummaryInfo pTransSummary(0);

			MsiString strCurrentDir;
			if (g_scServerContext == scClient || g_scServerContext == scCustomActionServer)
			{
				strCurrentDir = (const ICHAR*)rgchCurDir;
			}
			else
			{
				// current directory is provided to service via command line
				ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_CURRENTDIRECTORY), &strCurrentDir, fTrue, 0,0);
			}

			MsiString strPackageSource;
			MsiString strDummyFile;
			if ((pError = SplitPath(rgchOriginalPackagePath, /* path = */&strPackageSource, /* filename = */&strDummyFile)))
			{
				// SplitPath should never return an error record, but if it does, we'll return an error
				
				// force release of database storage so if MSI was from URL, local copy can be cleaned up without
				// relying upon smart destructor ordering. If file is in-use, DeleteFile will fail
				pStorage = 0;

				return ERROR_INSTALL_TRANSFORM_FAILURE;
			}
			ICHAR chTransformPathSep = fUrl ? chURLSep : chDirSep;

			while (fTransformsRemain && strTransforms.TextSize() != 0)
			{
				// transforms delimiter is ; and is not to be used in the transform filename or path
				MsiString strInstanceMst = strTransforms.Extract(iseUpto, ';');
				unsigned int cch = strTransforms.TextSize();
				strTransforms.Remove(iseIncluding, ';');
				if (strTransforms.TextSize() == cch)
				{
					// no more transforms in the list
					fTransformsRemain = false;
				}

				if (*(const ICHAR*)strInstanceMst == STORAGE_TOKEN) // child storage of package
				{
					// remove token
					strInstanceMst.Remove(iseFirst, 1);

					if((pError = pStorage->OpenStorage(strInstanceMst, ismReadOnly, *&pTransformStg)))
					{
						// unable to open transform

						// force release of database storage so if MSI was from URL, local copy can be cleaned up without
						// relying upon smart destructor ordering. If file is in-use, DeleteFile will fail
						pStorage = 0;

						return ERROR_INSTALL_TRANSFORM_FAILURE;
					}
				}
				else // source path included
				{
					if (tpUnknown == tpLocation || tpUnknownSecure == tpLocation)
					{
						// we have yet to determine whether these are file (relative) or path (absolute)
						// transforms.
						iptEnum iptTransform = PathType(strInstanceMst);
						if (iptFull == iptTransform)
							tpLocation = tpAbsolute;
						else
						{
							if (tpUnknown == tpLocation)
								tpLocation = tpRelative;
							else 
								tpLocation = tpRelativeSecure;
						}
					}
                    
					MsiString strTransformFilename;
					
					if (tpRelative == tpLocation || tpRelativeSecure == tpLocation)
					{
						// we have some work to do here.
						//  For secure transforms, the transform path is the path relative to the .msi file
						//   transform_path = [msi_path]\transform_filename
						//  For unsecure transforms, the path could be as above, but the first chance is
						//   transform_path = [current directory]\transform_filename
						//  In both cases, we need to prepend the path to the msi to the transform filename
						strTransformFilename = strInstanceMst;

						if (tpRelative == tpLocation)
						{
							// try current directory first
							strInstanceMst = strCurrentDir;
							strInstanceMst += MsiString(MsiChar(chDirSep));
							strInstanceMst += strTransformFilename;
						}
						else // tpRelativeSecure == tpLocation
						{
							// transform is at package source location
							strInstanceMst = strPackageSource;
							strInstanceMst += MsiString(MsiChar(chTransformPathSep));
							strInstanceMst += strTransformFilename;
						}
					}

					//
					// SAFER: no SAFER check is necessary since we aren't attempting any modification with
					//        the transform.  We simply want to look at its summary information stream.  The
					//        SAFER check WILL occur when the transform is actually applied
					//

					iStat = OpenAndValidateMsiStorage(strInstanceMst, stTransform, *piServices, *&pTransformStg, /* fCallSAFER = */ false, /* szFriendlyName = */ NULL, /* phSaferLevel = */ NULL);
					if (ERROR_SUCCESS != iStat && tpRelative == tpLocation)
					{
						// try again, but this time use the package source location
						strInstanceMst = strPackageSource;
						strInstanceMst += MsiString(MsiChar(chTransformPathSep));
						strInstanceMst += strTransformFilename;
						iStat = OpenAndValidateMsiStorage(strInstanceMst, stTransform, *piServices, *&pTransformStg, /* fCallSAFER = */ false, /* szFriendlyName = */ NULL, /* phSaferLevel = */ NULL);
					}

					if (ERROR_SUCCESS != iStat)
					{
						// unable to open transform

						// force release of database storage so if MSI was from URL, local copy can be cleaned up without
						// relying upon smart destructor ordering. If file is in-use, DeleteFile will fail
						pStorage = 0;

						return ERROR_INSTALL_TRANSFORM_FAILURE;
					}

				}

				if ((pError = pTransformStg->CreateSummaryInfo(0, *&pTransSummary)))
				{
					// unable to view summary information for transform

					// force release of database storage so if MSI was from URL, local copy can be cleaned up without
					// relying upon smart destructor ordering. If file is in-use, DeleteFile will fail
					pStorage = 0;

					return ERROR_INSTALL_TRANSFORM_FAILURE;
				}

				// product code for original and reference database are stored in PID_REVNUMBER summary info property (upgrade-code is optional)
				//  Format: [{orig-product-code}][orig-product-version];[{ref-product-code}][ref-product-version];[{upgrade-code}]
				MsiString istrTransRevNumber(pTransSummary->GetStringProperty(PID_REVNUMBER));
				MsiString istrTransOrigProductCode(istrTransRevNumber.Extract(iseFirst, cchProductCode));
				istrTransRevNumber.Remove(iseIncluding, ';'); // remove original product code & version
				MsiString istrTransRefProductCode(istrTransRevNumber.Extract(iseFirst, cchProductCode));

				// is this the instance transform? (one that changes the product code)
				if (istrTransOrigProductCode.Compare(iscExactI, istrTransRefProductCode) == fFalse)
				{
					if (fFoundInstanceMst)
					{
						// already found instance transform -- only support one product code changing transform on command line
						DEBUGMSGV(TEXT("Only one product code changing transform is allowed in multiple instance support.  More than one product code changing transform has been supplied."));

						// force release of database storage so if MSI was from URL, local copy can be cleaned up without
						// relying upon smart destructor ordering. If file is in-use, DeleteFile will fail
						pStorage = 0;

						return ERROR_INVALID_COMMAND_LINE;
					}

					if (!fFirstRun)
					{
						// instance mst is not the first transform in the list -- potential problem here with
						// customization transforms, so enforce rule
						DEBUGMSGV(TEXT("The instance transform must be the first transform in the transforms list of the TRANSFORMS property"));

						// force release of database storage so if MSI was from URL, local copy can be cleaned up without
						// relying upon smart destructor ordering. If file is in-use, DeleteFile will fail
						pStorage = 0;

						return ERROR_INVALID_COMMAND_LINE;
					}

					// found the instance transform since the product code changes
					fFoundInstanceMst = true;

					// is this instance installed?
					//   - if creating advertise script, assume no since we don't look at the machine state
					INSTALLSTATE isInstance = INSTALLSTATE_UNKNOWN;
					if (!(iioOptions & iioCreatingAdvertiseScript))
					{
						isInstance = MsiQueryProductState(istrTransRefProductCode);
						if (isInstance == INSTALLSTATE_DEFAULT || isInstance == INSTALLSTATE_ADVERTISED)
						{
							// the instance is already installed in this context
							// INSTALLSTATE_ABSENT is fine as it means that the product is installed in another context (some other user)
							DEBUGMSGV2(TEXT("Specified instance %s via transform %s is already installed. MSINEWINSTANCE requires a new instance that is not installed."), (const ICHAR*)istrTransRefProductCode, (const ICHAR*)strTransforms);

							// force release of database storage so if MSI was from URL, local copy can be cleaned up without
							// relying upon smart destructor ordering. If file is in-use, DeleteFile will fail
							pStorage = 0;

							return ERROR_INVALID_COMMAND_LINE;
						}
					}

					AssertSz(isInstance != INSTALLSTATE_INVALIDARG, "Invalid argument passed to MsiQueryProductState.");
				}

				fFirstRun = false;
			}

			if (!fFoundInstanceMst)
			{
				DEBUGMSGV(TEXT("Product code changing transform not found in transforms list. MSINEWINSTANCE property requires existance of instance transform."));

				// force release of database storage so if MSI was from URL, local copy can be cleaned up without
				// relying upon smart destructor ordering. If file is in-use, DeleteFile will fail
				pStorage = 0;

				return ERROR_INVALID_COMMAND_LINE;
			}

			// mimic as below for MsiGetProductCodeFromPackageCode -- in this case we already know that the product
			// is not installed, so our product code is unknown within this context
			iStat = ERROR_UNKNOWN_PRODUCT;
			plPackageLocation = plEnum(plLocalCache|plSource);
		}
		else
		{
			ICHAR szExtractedPackageCode[cchProductCode+1];
			if (ERROR_SUCCESS == iStat)
			{
				iStat = GetPackageCodeAndLanguageFromStorage(*pStorage, szExtractedPackageCode, &iLangId);
			}

			if (ERROR_SUCCESS == iStat)
			{
				if (strInstanceGUID.TextSize())
				{
					// obtain package code from registry
					ICHAR rgchRegisteredPackageCode[cchProductCode+1] = {0};
					DWORD cchRegisteredPackageCode = sizeof(rgchRegisteredPackageCode)/sizeof(ICHAR);
					if (ERROR_SUCCESS != MsiGetProductInfo(strInstanceGUID, TEXT("PackageCode"), rgchRegisteredPackageCode, &cchRegisteredPackageCode))
					{
						DEBUGMSG1(TEXT("Unable to obtain registered PackageCode for instance install %s"), strInstanceGUID);

						// force release of database storage so if MSI was from URL, local copy can be cleaned up without
						// relying upon smart destructor ordering. If file is in-use, DeleteFile will fail
						pStorage = 0;

						return ERROR_INVALID_COMMAND_LINE;
					}

					if (fReinstallModePackage || 0 == lstrcmpi(rgchRegisteredPackageCode, szExtractedPackageCode))
					{
						// if match, set rgchProductCode to be strInstanceGUID
						StringCchCopy(rgchProductCode, rgchProductCode.GetSize(), strInstanceGUID);
					}
				}
				else
				{
					iStat = MsiGetProductCodeFromPackageCode(szExtractedPackageCode, rgchProductCode);
				}

				plPackageLocation = plEnum(plLocalCache|plSource);
			}
		}
	}
	else if (fAdminOrAdvertise)
	{
		iStat = ERROR_INVALID_PARAMETER;  // must use source path
	}
	else if (ireProductSpec == ireProductCode)
	{
		INSTALLSTATE is = MsiQueryProductState(szProduct);
		if (INSTALLSTATE_ADVERTISED != is && INSTALLSTATE_DEFAULT != is)
			return ERROR_UNKNOWN_PRODUCT;

		CTempBuffer<ICHAR, 100> szBuffer;
		if (ENG::GetProductInfo(szProduct, INSTALLPROPERTY_LANGUAGE, szBuffer))
			iLangId = (LANGID)strtol(CConvertString((const ICHAR*)szBuffer));

		int iInstanceType = 0;
		if (ENG::GetProductInfo(szProduct, INSTALLPROPERTY_INSTANCETYPE, szBuffer))
			iInstanceType = strtol(CConvertString((const ICHAR*)szBuffer));

		if (1 == iInstanceType)
		{
			// multiple instance install, set MSIINSTANCEGUID on command line to product code
			DEBUGMSG(TEXT("Adding MSIINSTANCEGUID to command line."));
			strCommandLine += TEXT(" ") IPROPNAME_MSIINSTANCEGUID TEXT("=");
			strCommandLine += szProduct;
		}

		if ((iioOptions & iioChild) != 0)
		{
			// get client value

			CTempBuffer<ICHAR, 100> rgchInfo;
			if (!GetProductInfo(szProduct, TEXT("Clients"), rgchInfo))
			{
				return ERROR_UNKNOWN_PRODUCT;
			}

			// look for parent product code

			MsiString strParentProductCode = piParentEngine->GetProductKey();
			MsiString strInfo = (const ICHAR*)rgchInfo;
			MsiString strClientProductCode = strInfo.Extract(iseFirst, cchProductCode);
			strInfo.Remove(iseFirst, cchProductCode+1); // product code + ';'

			if (*(const ICHAR*)strInfo == ':')
			{
				if (!strClientProductCode.Compare(iscStartI, strParentProductCode))
				{
					return ERROR_UNKNOWN_PRODUCT;
				}

				ireProductSpec = ireSubStorage;
	
				strInfo.Remove(iseFirst, 1); // ':'
				strInfo.Remove(iseLast, 1); // ';'
				strSubStorageName = strInfo;
				szProduct = strSubStorageName;
			}
			else // not a substorage install
			{
				StringCchCopy(rgchProductCode,rgchProductCode.GetSize(),szProduct);
				plPackageLocation = plAny;
			}
		}
		else
		{
			StringCchCopy(rgchProductCode,rgchProductCode.GetSize(),szProduct);
			plPackageLocation = plAny;
		}
		iStat = ERROR_SUCCESS;
	}

	PMsiRecord pLangId = &CreateRecord(3);
	pLangId->SetInteger(1, icmtLangId);
	pLangId->SetInteger(2, iLangId);
	pLangId->SetInteger(3, ::MsiGetCodepage(iLangId));
	g_MessageContext.Invoke(imtCommonData, pLangId); // iLangId is an OK guess at this point; engine::Initialize will choose a better language

	//FUTURE: the engine::Initialize logic for selecting a language should be moved up into this function
	
	if (!fAdminOrAdvertise)
	{
		if (ireProductSpec == ireSubStorage)
		{
			//
			// SAFER: trust of a substorage is determined by trust of the toplevel object containing
			//          the substorage.  Therefore no SAFER check is required
			//

			Assert(piParentEngine);
			PMsiStorage pRootStorage = PMsiDatabase(piParentEngine->GetDatabase())->GetStorage(1); // source database
			if (!pRootStorage)
				return ERROR_CREATE_FAILED;  // should never happen
			else
			{
				PMsiRecord pError = pRootStorage->OpenStorage(szProduct, ismReadOnly, *&pStorage);
				if (pError)
					return ERROR_CREATE_FAILED;  // forces a FatalError message
				else
				{
					plPackageLocation = plEnum(0); // follows parent database
					//!! more to do here?
					iStat = ERROR_SUCCESS;
				}
			}
		}
		else if (ireProductSpec == ireDatabaseHandle)
		{
			//
			// SAFER: a SAFER policy check is needed, but is handled in CreateInitializedEngine
			//

			int ch;
			MSIHANDLE hDatabase = 0;
			while ((ch = *szProduct++) != 0)
			{
				if (ch < '0' || ch > '9')
				{
					hDatabase = 0;
					break;
				}
				hDatabase = hDatabase * 10 + (ch - '0');
			}
			pDatabase = (IMsiDatabase*)FindMsiHandle(hDatabase, iidMsiDatabase);
			if (pDatabase == 0)
				iStat = ERROR_INVALID_HANDLE;
			else
				iStat = ERROR_SUCCESS;
		}
	}

	if (ERROR_SUCCESS != iStat && ERROR_UNKNOWN_PRODUCT != iStat)
	{
		// force release of database storage so if MSI was from URL, local copy can be cleaned up without
		// relying upon smart destructor ordering. If file is in-use, DeleteFile will fail
		pStorage = 0;

		return iStat;
	}

	if (fReinstallModePackage)
	{
		//
		// SAFER: because we are forcing a recache and will be using the source package
		//          a SAFER check will be required.  This is handled further below when we look
		//          at plPackageLocation
		//

		plPackageLocation = plSource; // always use the source package and re-cache
		iioOptions = (iioEnum)(iioOptions | iioReinstallModePackage);
	}

	if (fAdminOrAdvertise || ireProductSpec == ireDatabaseHandle)
	{
		iStat = ERROR_UNKNOWN_PRODUCT;
	}
	else if (ireProductSpec == ireSubStorage)
	{
		rgchPackagePath[0] = ':';   // prefix substorage name for future identificaion
		StringCchCopy(&rgchPackagePath[1], (rgchPackagePath.GetSize() - 1), szProduct);
	}
	else if (rgchProductCode[0])
	{
		if (iioOptions & iioReinstallModePackage) 
		{
			if (ireProductSpec == ireProductCode)
			{
				// Bug 9166. when given a product code and told to recache, we ignore anything we may already
				// have leared about the source and fall back on the sourcelist for the product. We ignore the
				// lastused source and bump media entries down the search order. This covers reinstall on
				// intellimirror where the user last used a CD
				MsiString strSource;
				MsiString strUnusedProduct;
				PMsiRecord hError = 0;
				DEBUGMSG("Attempting to recache package via ProductCode. Beginning source resolution.");
				CResolveSource source(piServices, true /*fRecachePackage*/);
				hError = source.ResolveSource(rgchProductCode, fFalse /*fPatch*/, 1 /*uiDisk*/, *&strSource, *&strUnusedProduct, 
					fTrue /*fSetLastUsed*/, 0 /*hWnd, not used*/, fFalse /*AllowDisconnectedCSC*/);
				if (hError)
				{
					// If couldn't open the sourcelist key, the product isn't installed, otherwise no source
					// error will be returned below.
					iStat = (hError->GetInteger(1) == idbgSrcOpenSourceListKey) ? ERROR_UNKNOWN_PRODUCT : ERROR_INSTALL_SOURCE_ABSENT;
				}
				else
				{
					CRegHandle HProductKey;
					if (ERROR_SUCCESS == OpenSourceListKey(rgchProductCode, fFalse, HProductKey, fFalse, false))
					{	
						DWORD dwType = 0;
						CAPITempBuffer<ICHAR, 100> rgchPackage;
						DWORD lResult = MsiRegQueryValueEx(HProductKey, szPackageNameValueName, 0,
							&dwType, rgchPackage, 0);

						int cchSource = strSource.TextSize()+IStrLen(rgchPackage);
						if (rgchPackagePath.GetSize() < cchSource+1)
							if (!rgchPackagePath.SetSize(cchSource+1))
								return ERROR_OUTOFMEMORY;
						StringCchCopy(rgchPackagePath, rgchPackagePath.GetSize(), strSource);
						StringCchCat(rgchPackagePath, rgchPackagePath.GetSize(), rgchPackage);
					}
					else
						iStat = ERROR_UNKNOWN_PRODUCT;
				}
			}
			else
			{
				// force us to use the current package path as the source for this product
				iStat = ERROR_UNKNOWN_PRODUCT; 
			}
		}	
		else 
		{
			Bool fShowSourceUI = (g_message.m_iuiLevel == iuiNone || (g_message.m_iuiLevel == iuiDefault && iuiDefaultUILevel == iuiNone)) ? fFalse : fTrue;
			iStat = GetPackageFullPath(rgchProductCode, rgchPackagePath, plPackageLocation, fShowSourceUI);
		}

		if (ERROR_SUCCESS == iStat)
		{
			// Possibly an internet download
			// from the source list.  If fURL is already set,
			// we've already downloaded it once and cached.
			if (!fUrl)
			{
				MsiString strPackagePath;

				if (IsURL(rgchPackagePath, fFileUrl))
				{
					if (fFileUrl)
					{
						// canonicalize and convert to DOS path
						DWORD cchPackagePath = rgchPackagePath.GetSize();
						rgchOriginalPackagePath.SetSize(rgchPackagePath.GetSize());
						StringCchCopy(rgchOriginalPackagePath, rgchOriginalPackagePath.GetSize(), rgchPackagePath);
						if (!MsiConvertFileUrlToFilePath(rgchOriginalPackagePath, rgchPackagePath, &cchPackagePath, 0))
						{
							iStat = WIN::GetLastError();
						}
						else
						{
							iStat = OpenAndValidateMsiStorage(rgchPackagePath, stDatabase, *piServices, *&pStorage, /* fCallSAFER = */ false, /* szFriendlyName = */ NULL, /* phSaferLevel = */ NULL);
						}
					}
					else
					{
						// MSIPACKAGEDOWNLOADLOCALCOPY property only accepted if:
						//	in the service, user is admin, file exists; otherwise download occurs again

						bool fDownloadUrlFile = true;

						if (strPackageDownloadLocalCopy.TextSize() // property provided
							&& scService == g_scServerContext // in the service
							&& IsAdmin()) // user is admin
						{
							if (0xFFFFFFFF != MsiGetFileAttributes((const ICHAR*)strPackageDownloadLocalCopy))
							{
								// file exists, so we'll use it
								fDownloadUrlFile = false;
							}
						}
						else if (strPackageDownloadLocalCopy.TextSize())
						{
							// MSIPACKAGEDOWNLOADLOCALCOPY illegally provided on command line
							iStat = ERROR_INVALID_COMMAND_LINE;
						}

						if (ERROR_SUCCESS == iStat)
						{
							if (fDownloadUrlFile)
							{
								iStat = DownloadUrlFile(rgchPackagePath, *&strPackagePath, fUrl, /* cTicks = */ 0, &fUsedWinHttp);

								if (fUrl && ERROR_SUCCESS == iStat)
								{
									MsiString strOriginalPath((const ICHAR*)rgchPackagePath);
									cDeleteUrlLocalFileOnClose.SetFileName(fUsedWinHttp ? *strPackagePath : *strOriginalPath, /* fDeleteFromIECache = */ !fUsedWinHttp);
								
									if (IsAdmin() || scService == g_scServerContext)
									{
										// set up MSIPACKAGEDOWNLOADLOCALCOPY property on command line
										DEBUGMSG(TEXT("Adding MSIPACKAGEDOWNLOADLOCALCOPY to command line."));
										strCommandLine += TEXT(" ") IPROPNAME_MSIPACKAGEDOWNLOADLOCALCOPY TEXT("=\"");
										strCommandLine += strPackagePath;
										strCommandLine += TEXT("\" ");
									}
								}
							}
							else
							{
								// use provided property to avoid re-download

								DEBUGMSG1(TEXT("Using previously downloaded file %s"), (const ICHAR*)strPackageDownloadLocalCopy);

								strPackagePath = strPackageDownloadLocalCopy;
								fUrl = fTrue;
							}
						}
					}
				}

				if (fUrl && (ERROR_SUCCESS == iStat))
				{
					//
					// SAFER: initial opening of package is not malicious.  We want to first crack it open and grab its
					//          package code so we can determine if the product is a known product.  We prefer to use the
					//          local cached package whenever possible.  Therefore fCallSAFER = false and phSaferLevel = NULL.
					//

					iStat = OpenAndValidateMsiStorage(strPackagePath, stDatabase, *piServices, *&pStorage, /* fCallSAFER = */ false, /* szFriendlyName = */ NULL, /* phSaferLevel = */ NULL);
					rgchOriginalPackagePath.SetSize(rgchPackagePath.GetSize());
					StringCchCopy(rgchOriginalPackagePath, rgchOriginalPackagePath.GetSize(), rgchPackagePath);
					rgchPackagePath.SetSize(strPackagePath.TextSize()+1);
					int cchCopied = strPackagePath.CopyToBuf(rgchPackagePath, rgchPackagePath.GetSize() - 1);
					Assert(cchCopied == strPackagePath.TextSize());
				}
			}
		}
	}

	if (iStat == ERROR_UNKNOWN_PRODUCT && ireProductSpec != ireProductCode) 
	{
		// If we couldn't find the product in the registry and we have
		// a package then the product is unknown and
		// we'll use the package that was passed in

		//
		// SAFER: we will be using the package at the source.  Therefore a SAFER check is required.
		//          Check is handled further below
		//

		plPackageLocation = plSource;
	}
	else if (ERROR_SUCCESS != iStat)
	{
		// force release of database storage so if MSI was from URL, local copy can be cleaned up without
		// relying upon smart destructor ordering. If file is in-use, DeleteFile will fail
		pStorage = 0;

		return iStat;
	}

	MsiString strNewDatabasePath;
	Bool fRemovable = fFalse;
	Bool fDatabaseCopied = fFalse;

#ifdef DEBUG
	if(fUrl)
		Assert(pStorage);
#endif //DEBUG
	
	if (plPackageLocation == plSource && ireProductSpec != ireDatabaseHandle && ireProductSpec != ireSubStorage && !fUrl) 
	{
		// If the package is on the source and it's removable media then we need 
		// to copy the package to the TEMP dir and create the storage on the copied
		// package, releasing the storage on the source package

		// if the package was at a URL, we've already cached it in either a secure location or 
		// a temporary location in the user's profile so there's no reason to re-cache it.

		//
		// SAFER: now we are officially opening the database, after determining that we need to use the database
		//          at the source.  We do not call SAFER on a nested install package, so we need to check for that
		//          below.  (We can't add it above because we might still need to open the nested install package
		//          that is at the source).  fCallSAFER = !fNestedInstallOrSubStoragePackage.  For a nested install,
		//          !fNestedInstallOrSubStoragePackage is false.  In the nested install case, phSaferLevel = NULL
		//

		MsiString strVolumeLabel;
		iStat = CopyTempDatabase(rgchPackagePath, *&strNewDatabasePath, 
										 fRemovable, *&strVolumeLabel, *piServices, stDatabase);
		if (ERROR_SUCCESS == iStat)
		{
			fDatabaseCopied = fTrue;
			iStat = OpenAndValidateMsiStorage(strNewDatabasePath, stDatabase, *piServices, *&pStorage, 
												/* fCallSAFER = */ (!fNestedInstallOrSubStoragePackage),
												/* szFriendlyName = */ (ireProductSpec == irePackagePath) ? static_cast<ICHAR*>(rgchOriginalPackagePath) : static_cast<ICHAR*>(rgchPackagePath),
												/* phSaferLevel = */ fNestedInstallOrSubStoragePackage ? NULL : &hSaferLevel);
		}

		if (ERROR_SUCCESS != iStat)
		{
			pStorage = 0; // ensure storage has been released

			if (fDatabaseCopied)
			{
				if (g_scServerContext == scService)
				{	
					CElevate elevate;
					AssertNonZero(WIN::DeleteFile(strNewDatabasePath));
				}
				else
				{
					AssertNonZero(WIN::DeleteFile(strNewDatabasePath));
				}
			}
			return iStat;
		}

		if (fRemovable)
		{
			strCommandLine += TEXT(" ") IPROPNAME_CURRENTMEDIAVOLUMELABEL TEXT("=\"");
			if (strVolumeLabel.TextSize())
				strCommandLine += strVolumeLabel;
			else
				strCommandLine += szBlankVolumeLabelToken;
			strCommandLine += TEXT("\"");
		}
	}
	else if ((ireProductSpec == irePackagePath) && (plPackageLocation == plLocalCache))
	{
		// We were given a package path, but we're going to use the cached database. We need
		// to open the cached database.

		//
		// SAFER: No SAFER check is required because we are opening the secured, cached copy
		//          of the database.  Our local cached copy is always trusted.  Therefore, fCallSAFER = false
		//          and phSaferLevel = NULL.  However, we will need to create a handle to a fully trusted SAFER
		//          level here for use in CreateInitializedEngine (and later on with custom actions), but only
		//          if this is not a nested install package
		//


		if (ERROR_SUCCESS != (iStat = OpenAndValidateMsiStorage(rgchPackagePath, stDatabase, *piServices, *&pStorage, /* fCallSAFER = */ false, /* szFriendlyName = */ NULL, /* phSaferLevel = */ NULL)))
			return iStat;

		if (MinimumPlatformWindowsNT51() && !fNestedInstallOrSubStoragePackage)
		{
			if (!ADVAPI32::SaferCreateLevel(SAFER_SCOPEID_MACHINE, SAFER_LEVELID_FULLYTRUSTED, SAFER_LEVEL_OPEN, &hSaferLevel, 0))
			{
				DEBUGMSG1(TEXT("SAFER: Unable to create a fully trusted authorization level.  GetLastError returned %d"), (const ICHAR*)(INT_PTR)GetLastError());
				return ERROR_INSTALL_PACKAGE_REJECTED;
			}
		}

		// copy the given package path back into rgchPackagePath so we pass the original path to the engine
		if (rgchPackagePath.GetSize() < rgchOriginalPackagePath.GetSize())
			rgchPackagePath.SetSize(rgchOriginalPackagePath.GetSize());

		StringCchCopy(rgchPackagePath, rgchPackagePath.GetSize(), rgchOriginalPackagePath);
	}
	else if (fUrl && plPackageLocation == plSource && !fNestedInstallOrSubStoragePackage)
	{
		//
		// SAFER: a SAFER check is required because we are using the package at the source. We
		//          did not catch this earlier because we didn't check SAFER when we performed
		//          the initial URL download and we don't re-copy the database again because we already put it
		//          in a temporary location on the URL download
		//

		if (!VerifyMsiObjectAgainstSAFER(*piServices, pStorage, rgchPackagePath, rgchOriginalPackagePath, stDatabase, &hSaferLevel))
		{
			// force release of database storage so if MSI was from URL, local copy can be cleaned up without
			// relying upon smart destructor ordering. If file is in-use, DeleteFile will fail
			pStorage = 0;

			return ERROR_INSTALL_PACKAGE_REJECTED;
		}
	}
	else if (ireProductSpec == ireProductCode && plPackageLocation == plLocalCache)
	{
		//
		// SAFER: No SAFER check is required because we are using the secured cache copy.  
		//        However, a handle to a fully trusted SAFER level is required for custom actions
		//

		if (MinimumPlatformWindowsNT51() && !fNestedInstallOrSubStoragePackage)
		{
			if (!ADVAPI32::SaferCreateLevel(SAFER_SCOPEID_MACHINE, SAFER_LEVELID_FULLYTRUSTED, SAFER_LEVEL_OPEN, &hSaferLevel, 0))
			{
				DEBUGMSG1(TEXT("SAFER: Unable to create a fully trusted authorization level.  GetLastError returned %d"), (const ICHAR*)(INT_PTR)GetLastError());
				return ERROR_INSTALL_PACKAGE_REJECTED;
			}
		}
	}
	else
	{
		//
		// SAFER: remaining cases that we expect.  These cases are not subject to SAFER
		//          ireProductSpec == ireDatabaseHandle is special and handled by CreateInitializedEngine
		//

		if ((ireProductSpec == ireSubStorage) || (ireProductSpec == ireDatabaseHandle)
			|| (fNestedInstallOrSubStoragePackage))
		{
			//
			// SAFER: a SAFER check is not required.  Note that ireProductSpec == ireDatabaseHandle is handled
			//        by CreateInitializedEngine
			//

		}
		else
		{
			//
			// SAFER: this is a case we didn't expect.  A SAFER check may be required
			//

			AssertSz(0, TEXT("Unexpected SAFER case!  A SAFER check may be required!"));
			return ERROR_INSTALL_PACKAGE_REJECTED;
		}

	}

	if (fUrl)
	{
		// copy the *real* package path back into rgchPackagePath so we pass the original path to the engine

		// FILE:// type is equivalent to path without the file:// qualifier.  
		if (fFileUrl)
			StringCchCopy(rgchPackagePath, rgchPackagePath.GetSize(), ((ICHAR*)rgchOriginalPackagePath) + 7);
		else
		{
			DWORD cchURL = rgchPackagePath.GetSize();
			if (!MsiCanonicalizeUrl(rgchOriginalPackagePath, rgchPackagePath, &cchURL, dwMsiInternetNoEncode))
            {
                DWORD dwLastError = WIN::GetLastError();
                if (ERROR_INSUFFICIENT_BUFFER == dwLastError)
                {
                    rgchPackagePath.SetSize(cchURL);
                    if (MsiCanonicalizeUrl(rgchOriginalPackagePath, rgchPackagePath, &cchURL, dwMsiInternetNoEncode))
                        dwLastError = 0;
                }
                if (dwLastError)
				{
					// force release of database storage so if MSI was from URL, local copy can be cleaned up without
					// relying upon smart destructor ordering. If file is in-use, DeleteFile will fail
					pStorage = 0;

					return dwLastError;
				}
            }
		}
	}

	// we should've started impersonated, but if in the client launched as LocalSystem, there won't be
	// a stored impersonation token.
	Assert(IsImpersonating() || (g_scServerContext == scClient  && !GetUserToken() && RunningAsLocalSystem()));

	MsiSuppressTimeout();

	PMsiServer pServer(0);
	bool fReboot = false;

	//
	// SAFER: all SAFER policy check determinations must be made prior to the CreateInitializedEngine
	//          call, unless ireProductSpec == ireDatabaseHandle.  CreateInitializedEngine specifically handles
	//          the case where ireProductSpec == ireDatabaseHandle.  In general, a SAFER check was
	//          performed if at least one of the following three cases was true.
	//
	//                1.  Product is unknown (not installed or advertised)
	//                2.  Local cached Msi is missing
	//                3.  Recache of package requested in REINSTALLMODE property
	//
	//

	iStat = CreateInitializedEngine(rgchPackagePath, rgchProductCode, strCommandLine, TRUE, iuiDefaultUILevel,
									pStorage, pDatabase, piParentEngine, iioOptions, piEngine, hSaferLevel);


	pStorage = 0; // release the storage so we can delete the file

	if (iStat == ERROR_SUCCESS)
	{
		pServer = piEngine->GetConfigurationServer(); // used to invoke reboot if necessary
		Assert(pServer);

		iesEnum iesRes = piEngine->DoAction(szAction);
		iesRes = piEngine->Terminate(iesRes);

		// only the client should be rebooting. the server should always
		// propagate the reboot request to the client.
		if((g_scServerContext == scClient) && (iesRes == iesCallerReboot))
		{
			fReboot = true;
		}
		iStat = MapInstallActionReturnToError(iesRes);
		piEngine->Release();
	}

	MsiSuppressTimeout();

	if (fDatabaseCopied)
	{
		if (g_scServerContext == scService)
		{	
			CElevate elevate;
			if(FALSE == WIN::DeleteFile(strNewDatabasePath))
			{
				DWORD dwError = GetLastError();
				int cRetries = 10;
				while(dwError == ERROR_SHARING_VIOLATION && cRetries > 0)
				{
					if(WIN::DeleteFile(strNewDatabasePath))
					{
						dwError = ERROR_SUCCESS;
					}
					else
					{
						dwError = GetLastError();
						cRetries--;
						Sleep(200);
					}
				}
#ifdef DEBUG
				if(dwError != ERROR_SUCCESS)
				{
					ICHAR rgchAssert[MAX_PATH+60];
					StringCchPrintf(rgchAssert, (sizeof(rgchAssert)/sizeof(ICHAR)), TEXT("Failed to delete temp package '%s'.  Error: '%d'"), (const ICHAR*)strNewDatabasePath, dwError);
					AssertSz(0, rgchAssert);
				}
#endif
			}
		}
		else
		{
			AssertNonZero(WIN::DeleteFile(strNewDatabasePath));
		}
	}

	// if there is no client engine, there should be no one holding onto
	// installer packages that may need to be cleaned up
	if(pServer && ((iioOptions & (iioClientEngine|iioChild|iioUpgrade)) == 0))
	{
		CMutex hExecuteMutexForCleanup;
		
		// don't need to grab mutex if already in service
		bool fCheckAndSetServiceBusy = true;
		if(g_scServerContext == scService)
		{
			if ( pServer->IsServiceInstalling() )
				fCheckAndSetServiceBusy = false;
		}
		else
			GrabExecuteMutex(hExecuteMutexForCleanup);

		DEBUGMSG(TEXT("Cleaning up uninstalled install packages, if any exist"));
		PMsiMessage pMessage = new CMsiClientMessage();
		pServer->CleanupTempPackages(*pMessage, fCheckAndSetServiceBusy);
	}


	Assert(!fReboot || pServer); // if we need a reboot, we should have a server interface to call

	if(fReboot && pServer)
	{
		// we shouldn't have a client engine here; if there was a client engine then
		// it should be the one rebooting. the scClient check above should prevent
		// fReboot from being set if we're not in the client.
		Assert((iioOptions & iioClientEngine) == 0); 

		Assert(!FTestNoPowerdown()); // if we're blocking powerdown then it'll block our reboot
		pServer->Reboot();
	}
	
	pServer = 0; // release before CoUninitialize()
	return iStat;
}

int CreateInitializedEngine(
			const ICHAR* szDatabasePath, 
			const ICHAR* szProductCode,
			const ICHAR* szCommandLine,
			BOOL		 fServiceRequired,
			iuiEnum iuiLevel,
			IMsiStorage* piStorage,      // optional, else uses szDatabasePath
			IMsiDatabase* piDatabase,    // optional, else uses piStorage or szDatabasePath
			CMsiEngine* piParentEngine,  // optional, only if nested install
			iioEnum      iioOptions,     // install options
			IMsiEngine *& rpiEngine,
			SAFER_LEVEL_HANDLE  hSaferLevel)

/*----------------------------------------------------------------------------
Creates an initialized engine.

Arguments:
	szDatabasePath: full path to database
    szProductCode: optional, product code if already determined.
    szCommandLine: commandline or property settings
    fServiceRequired : if TRUE, then we must be either running as a service or we must connect to it.
	iuiEnum: UI level, used ONLY if no global level (=iuiDefault)
	piStorage:       optional, else uses szDatabasePath
	piDatabase:      optional, else uses piStorage or szDatabasePath (means database handle was specified)
	piParentEngine:  optional, only if nested install
	rpiEngine: returned engine pointer upon successs
	SAFER_LEVEL_HANDLE: handle to SAFER authorization level (0 if ireProductSpec == ireDatabaseHandle, or nested install)
Returns:
	ERROR_INSTALL_SERVICE_FAILURE - Could not create or initialize an engine
	ERROR_INVALID_PARAMETER   - Could not convert command-line to ANSI
	ERROR_SUCCESS         - An engine was successfully created and initialized
	ERROR_INSTALL_PACKAGE_VERSION - The database version was incorrect
	ERROR_INSTALL_REMOTE_PROHIBITED - An installation from a TS client machine was
	                                  attempted outside of a restricted engine.
------------------------------------------------------------------------------*/
{
	if (iuiDefault != g_message.m_iuiLevel)
		iuiLevel = g_message.m_iuiLevel;
	// handler doesn't support dialogs from more than one database
	if (piParentEngine && iuiFull == iuiLevel)
		iuiLevel = iuiReduced;

	//
	// we could have gotten here from MsiOpenPackage or from having
	// a database handle passed in.  We therefore need to verify
	// that the database handle points to an accepted package
	//  -- NOTE: requires services
	//

	int iRet = ERROR_SUCCESS;
	if (!piParentEngine && piDatabase)
	{
		// passed in database handle (from MsiOpenPackage, etc.)
		rpiEngine = 0;

		IMsiServices* piServices = ENG::LoadServices();
		if (!piServices)
			return ERROR_FUNCTION_FAILED;

		{
			// scope MsiString object
			PMsiStorage pStorage = piDatabase->GetStorage(1);
			Assert(pStorage);
			MsiString strDatabasePath;
			AssertRecord(pStorage->GetName(*&strDatabasePath));
			Assert(!hSaferLevel);

			// restricted engine does not incur a SAFER check
			// restricted engine is allowed to open packages on TS client machines
			if (!(iioOptions & iioRestrictedEngine))
			{
				if ( IsInstallingFromTSClient(strDatabasePath) )
					iRet = ERROR_INSTALL_REMOTE_PROHIBITED;
				else if ( !VerifyMsiObjectAgainstSAFER(*piServices, pStorage, strDatabasePath, /* szFriendlyName = */ strDatabasePath, stDatabase, &hSaferLevel) )
					iRet = ERROR_INSTALL_PACKAGE_REJECTED;
			}
		}

		ENG::FreeServices();
	}
	// restricted engine is allowed to open packages on TS client machines.
	else if ( !(iioOptions & iioRestrictedEngine) &&
				 szDatabasePath && *szDatabasePath &&
				 IsInstallingFromTSClient(szDatabasePath) )
		iRet = ERROR_INSTALL_REMOTE_PROHIBITED;

	if ( iRet != ERROR_SUCCESS )
		return iRet;

	// 
	// SAFER: cache authz level object handle in the global message context, only if this is the parent install
	// 

	if (!piParentEngine)
	{
		// assert <Assert(!g_MessageContext.m_hSaferLevel)> is no longer necessary since this level could be set if OpenAndValidateMsiStorage* was called prior to this, as
		// is the case in CreateAndRunEngine
		g_MessageContext.m_hSaferLevel = hSaferLevel;
	}

	rpiEngine = CreateEngine(piStorage, piDatabase, piParentEngine, fServiceRequired);
	if(rpiEngine == 0)
		return ERROR_INSTALL_SERVICE_FAILURE;

	ieiEnum ieiStat = rpiEngine->Initialize(
				szDatabasePath,
				iuiLevel, szCommandLine,
				szProductCode,
				iioOptions);

	if (ieiStat == ieiSuccess)
		return ERROR_SUCCESS;

	rpiEngine->Release(), rpiEngine = 0;
	return ENG::MapInitializeReturnToUINT(ieiStat);

}


int ConfigureOrReinstallFeatureOrProduct(
	const ICHAR* szProduct,
	const ICHAR* szFeature,
	INSTALLSTATE eInstallState,
	DWORD dwReinstallMode, 
	int iInstallLevel,
	iuiEnum iuiLevel,
	const ICHAR* szCommandLine)
/*----------------------------------------------------------------------------
Configures or reinstalls the given product or feature.

Arguments:
	szProduct: The product code of the product or the feature to be
				  configured or reinstalled.
	szFeature: The feature to be configured or reinstalled, or null if the
				  product is to be configured or reinstalled
	eInstallState: The feature or product's desired install state
	riMessage: Used to display UI during the install or location of launcher.
	szReinstallMode: Null if configuring a product or feature, otherwise a
						  string of reinstallmode characters.
	iInstallLevel: If configuring a product, the desired install level.
				
Returns:
	ERROR_INSTALL_INVALIDARG -    The INSTALLSTATE was incorrect.
	ERROR_SUCCESS -               The configure/reinstall completed successfully
	ERROR_UNKNOWN_PRODUCT -       Product code is unrecognized
	ERROR_INSTALL_FAILURE -       Install failed or no usable launcher
	ERROR_BAD_CONFIGURATION -     Corrupt config info
	ERROR_INSTALL_SOURCE_ABSENT - The source was unavailable
	ERROR_INSTALL_SUSPEND -       The install was suspended
	ERROR_INSTALL_USEREXIT -      The user exited the install
------------------------------------------------------------------------------*/
{

	//!! Need to VerifyFeatureState to not bother configuring if we're 
	//!! already is the correct state.

	Assert(szProduct);
	Bool fProduct = fFalse;


	const int cchConfigureProperties = 25 + 1 + 10 + 1 +  // INSTALLLEVEL=n
												  25 + 1 + 10 + 1 +  // REINSTALLMODE=X
												  25 + 1 + cchMaxFeatureName;//ADDLOCAL=X

	CAPITempBuffer<ICHAR, 1> szProperties;
	if (! szProperties.SetSize(cchMaxCommandLine))
		return ERROR_OUTOFMEMORY;
	szProperties[0] = 0;

	if(szCommandLine && *szCommandLine)
	{
		size_t cchLen = IStrLen(szCommandLine) + 1 + cchConfigureProperties + 1;
		if (szProperties.GetSize() < cchLen)
		{
			if (! szProperties.SetSize(cchLen))
				return ERROR_OUTOFMEMORY;
		}
	
		StringCchCopy(szProperties, szProperties.GetSize(), szCommandLine);
		StringCchCat(szProperties, szProperties.GetSize(), TEXT(" "));
	}

	if (!szFeature) // we're configuring/reinstalling a product
	{
		// configure/reinstall of all features == configure/reinstall of product
		fProduct = fTrue;
		szFeature = IPROPVALUE_FEATURE_ALL;

		if (!dwReinstallMode) // we're configuring a product
		{
			if (iInstallLevel)
			{
				// set install level 
				StringCchCat(szProperties, szProperties.GetSize(), IPROPNAME_INSTALLLEVEL TEXT("="));
				ICHAR rgchBuf[11];
				StringCchPrintf(rgchBuf, (sizeof(rgchBuf)/sizeof(ICHAR)), TEXT("%d"), iInstallLevel); //?? best way to do this?
				StringCchCat(szProperties, szProperties.GetSize(), rgchBuf);
			}
		}
	}

	if (dwReinstallMode) // we're reinstalling
	{
		ICHAR szSelectedMode[33];
		UINT iStat;

		iStat = ModeBitsToString(dwReinstallMode, szReinstallMode, szSelectedMode);

		if (ERROR_SUCCESS != iStat)
			return iStat;

		StringCchCat(szProperties, szProperties.GetSize(), TEXT(" ") IPROPNAME_REINSTALL TEXT("="));
		StringCchCat(szProperties, szProperties.GetSize(), szFeature);

		StringCchCat(szProperties, szProperties.GetSize(), TEXT(" ") IPROPNAME_REINSTALLMODE TEXT("="));
		StringCchCat(szProperties, szProperties.GetSize(), szSelectedMode);
	}
	else // we're configuring
	{
		// if we're configuring a product default then don't set a feature property
		if (!fProduct || (fProduct && (INSTALLSTATE_DEFAULT != eInstallState)))
		{
			const ICHAR* szFeatureProperty;
			switch (eInstallState)
			{
				case INSTALLSTATE_ABSENT: 
					szFeatureProperty = IPROPNAME_FEATUREREMOVE;
					break;
				case INSTALLSTATE_LOCAL:
					szFeatureProperty = IPROPNAME_FEATUREADDLOCAL;
					break;
				case INSTALLSTATE_SOURCE:
					szFeatureProperty = IPROPNAME_FEATUREADDSOURCE;
					break;
				case INSTALLSTATE_DEFAULT:
					szFeatureProperty = IPROPNAME_FEATUREADDDEFAULT;
					break;
				case INSTALLSTATE_ADVERTISED:
					szFeatureProperty = IPROPNAME_FEATUREADVERTISE;
					break;
				default:
					return ERROR_INVALID_PARAMETER;
			}
			StringCchCat(szProperties, szProperties.GetSize(), TEXT(" "));
			StringCchCat(szProperties, szProperties.GetSize(), szFeatureProperty);
			StringCchCat(szProperties, szProperties.GetSize(), TEXT("="));
			StringCchCat(szProperties, szProperties.GetSize(), szFeature);
		}
	}
	return RunEngine(ireProductCode, szProduct, 0, szProperties, iuiLevel, (iioEnum)iioMustAccessInstallerKey);
}

UINT GetProductListFromPatch(IMsiServices& riServices, const ICHAR* szPackagePath, const IMsiString*& rpistrProductList, const IMsiString*& rpistrDownloadLocalCopy)
{
	PMsiStorage pStorage(0);
	PMsiSummaryInfo pSumInfo(0);

	PMsiRecord pError(0);
	UINT uiStat = 0;

	CDeleteUrlLocalFileOnClose cDeleteUrlLocalFileOnClose; // set later

	MsiString strDownloadLocalCopy;

	bool fFileUrl = false;
	bool fUrl = IsURL(szPackagePath, fFileUrl);
	
	// we are cracking open a patch -- need to call SAFER on the patch to verify it
	// no SAFER check occurs if the patch is cached
	if((uiStat = OpenAndValidateMsiStorage(szPackagePath, stPatch, riServices, *&pStorage, /* fCallSafer*/ false, /* szFriendlyName = */ 0, /* phSaferLevel = */ 0)) != ERROR_SUCCESS)
	{
		return uiStat;
	}

	if (fUrl && !fFileUrl && MinimumPlatformWindowsDotNETServer())
	{
		AssertRecord(pStorage->GetName(*&strDownloadLocalCopy));
	}


	if((pError = pStorage->CreateSummaryInfo(0, *&pSumInfo)) != 0)
	{
		pStorage = 0; // force release so file can be deleted
		if (fUrl)
			cDeleteUrlLocalFileOnClose.SetFileName(*strDownloadLocalCopy, /* fDeleteFromIECache = */ false);
		return ERROR_PATCH_PACKAGE_INVALID;
	}

	pStorage = 0; // force release so file can be deleted

	MsiString strProductList = pSumInfo->GetStringProperty(PID_TEMPLATE);
	strProductList.ReturnArg(rpistrProductList);
	strDownloadLocalCopy.ReturnArg(rpistrDownloadLocalCopy);

	return ERROR_SUCCESS;
}


// worker fn for MsiApplyPatch
int ApplyPatch(
	const ICHAR* szPackagePath,
	const ICHAR* szProduct,
	INSTALLTYPE  eInstallType,
	const ICHAR* szCommandLine)
{
	// NOTE: patches are verified against SAFER in CMsiEngine::InitializePatch

	// check arguments
	if(!szPackagePath || !*szPackagePath ||                                               // no package path supplied
		(eInstallType == INSTALLTYPE_DEFAULT && szProduct && *szProduct) ||               // product supplied when asked to search for products
		(eInstallType == INSTALLTYPE_NETWORK_IMAGE && (!szProduct || !*szProduct)) ||     // network image path not supplied
		(eInstallType == INSTALLTYPE_SINGLE_INSTANCE && (!szProduct || !*szProduct)) ||   // instance product code not supplied
		(eInstallType < INSTALLTYPE_DEFAULT || eInstallType > INSTALLTYPE_SINGLE_INSTANCE)) // install type out of range
	{
		return ERROR_INVALID_PARAMETER;
	}
	
	CAPITempBuffer<ICHAR, 1> szExpandedPackagePath;
	if (!szExpandedPackagePath.SetSize(cchExpectedMaxPath+1))
		return ERROR_OUTOFMEMORY;

	if (!ExpandPath(szPackagePath, szExpandedPackagePath))
		return ERROR_INVALID_PARAMETER;

	// create new command line: [old command line] PATCH="[path to patch]"
	CAPITempBuffer<ICHAR, cchMaxCommandLine+1> szNewCommandLine;
	StringConcatenate(szNewCommandLine, szCommandLine, TEXT(" ") IPROPNAME_PATCH TEXT("=\""),
							szExpandedPackagePath, TEXT("\""));
		
	UINT uiStat = ERROR_PATCH_PACKAGE_INVALID;

	IMsiServices* piServices = ENG::LoadServices();
	if (!piServices)
		return ERROR_FUNCTION_FAILED;
	
	// for INSTALLTYPE_DEFAULT, we search the machine for patchable products
	// for INSTALLTYPE_SINGLE_INSTANCE, we only patch the provided target
	if(eInstallType == INSTALLTYPE_DEFAULT || eInstallType == INSTALLTYPE_SINGLE_INSTANCE)
	{
		MsiString strProductList;
		MsiString strPatchDownloadLocalCopy;
		CDeleteUrlLocalFileOnClose cDeleteUrlLocalFileOnClose; // set later to cleanup

		ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_MSIPATCHDOWNLOADLOCALCOPY), &strPatchDownloadLocalCopy, fTrue, 0, 0);
		if (strPatchDownloadLocalCopy.TextSize())
		{
			// invalid use of MSIPATCHDOWNLOADLOCALCOPY property
			return ERROR_INVALID_COMMAND_LINE;
		}

		if((uiStat = GetProductListFromPatch(*piServices, szExpandedPackagePath, *&strProductList, *&strPatchDownloadLocalCopy)) == ERROR_SUCCESS)
		{
			if (strPatchDownloadLocalCopy.TextSize())
			{
				cDeleteUrlLocalFileOnClose.SetFileName(*strPatchDownloadLocalCopy, /* fDeleteFromIECache = */ false);

				// add MSIPATCHDOWNLOADLOCALCOPY to command line if admin
				if (IsAdmin())
				{
					DEBUGMSGV(TEXT("Adding MSIPATCHDOWNLOADLOCALCOPY to command line"));

					DWORD cchTotal = lstrlen(szNewCommandLine) + lstrlen(TEXT(" ")) + lstrlen(IPROPNAME_MSIPATCHDOWNLOADLOCALCOPY)
										+ lstrlen(TEXT("=\"")) + lstrlen((const ICHAR*)strPatchDownloadLocalCopy)
										+ lstrlen(TEXT("\"")) + 1;

					if (cchTotal > szNewCommandLine.GetSize())
					{
						if (!szNewCommandLine.Resize(cchTotal))
							return ERROR_OUTOFMEMORY;
					}

					if (FAILED(StringCchCat(szNewCommandLine, szNewCommandLine.GetSize(), TEXT(" ")))
						|| FAILED(StringCchCat(szNewCommandLine, szNewCommandLine.GetSize(), IPROPNAME_MSIPATCHDOWNLOADLOCALCOPY))
						|| FAILED(StringCchCat(szNewCommandLine, szNewCommandLine.GetSize(), TEXT("=\"")))
						|| FAILED(StringCchCat(szNewCommandLine, szNewCommandLine.GetSize(), (const ICHAR*)strPatchDownloadLocalCopy))
						|| FAILED(StringCchCat(szNewCommandLine, szNewCommandLine.GetSize(), TEXT("\""))))
					{
						DEBUGMSGV(TEXT("Patch: Unable to optimize patch download. . ."));
						return ERROR_FUNCTION_FAILED;
					}

				}
			}

			Bool fProductFound = fFalse;
			uiStat = ERROR_SUCCESS;
			while(uiStat == ERROR_SUCCESS && strProductList.TextSize())
			{
				// if INSTALLTYPE_SINGLE_INSTANCE and fProductFound, we have no more work to do
				if (eInstallType == INSTALLTYPE_SINGLE_INSTANCE
					&& fProductFound)
				{
					break;
				}

				MsiString strProductCode = strProductList.Extract(iseUpto, ';');
				if(strProductCode.TextSize() != strProductList.TextSize())
					strProductList.Remove(iseIncluding, ';');
				else
					strProductList = TEXT("");

				// for INSTALLTYPE_SINGLE_INSTANCE, we ignore all other targets except the provided target
				if (eInstallType == INSTALLTYPE_SINGLE_INSTANCE
					&& 0 != lstrcmpi(strProductCode, szProduct))
				{
					continue;
				}

				// check current state of this product
				INSTALLSTATE iState = MsiQueryProductState(strProductCode);
				if(iState == INSTALLSTATE_DEFAULT)
				{
					// product is installed
					fProductFound = fTrue;
					uiStat = RunEngine(ireProductCode, strProductCode, 0, szNewCommandLine, GetStandardUILevel(), (iioEnum)(iioMustAccessInstallerKey|iioPatchApplication));
				}
				else if(iState == INSTALLSTATE_ADVERTISED)
				{
					// product is advertised but not installed - need to get install package path ourselves
					fProductFound = fTrue;
					CAPITempBuffer<ICHAR, 1> rgchPackagePath;
					if (!rgchPackagePath.SetSize(cchExpectedMaxPath + 1))
						return ERROR_OUTOFMEMORY;
					rgchPackagePath[0] = 0;
					plEnum pl = plSource;
					uiStat = GetPackageFullPath(strProductCode, rgchPackagePath, pl, fTrue);

					if(uiStat == ERROR_SUCCESS)
					{
						uiStat = RunEngine(irePackagePath, rgchPackagePath,
												 IACTIONNAME_ADVERTISE, // if product only registered, just call ADVERTISE action
												 szNewCommandLine, GetStandardUILevel(), (iioEnum)(iioPatchApplication));
					}
				}
				//!! how to handle uiStat?  Do we continue on failure?
			}
			if(fProductFound == fFalse && uiStat == ERROR_SUCCESS)
				uiStat = ERROR_PATCH_TARGET_NOT_FOUND;
		}
		else
		{
			uiStat = (ERROR_PATCH_PACKAGE_REJECTED == uiStat) ? ERROR_PATCH_PACKAGE_REJECTED : ERROR_PATCH_PACKAGE_INVALID;
		}
	}
	else if(eInstallType == INSTALLTYPE_NETWORK_IMAGE)
	{
		Assert(szProduct && *szProduct);
		uiStat = RunEngine(irePackagePath,szProduct,IACTIONNAME_ADMIN,szNewCommandLine,GetStandardUILevel(), (iioEnum)0);
	}
	else
	{
		AssertSz(0,	"invalid INSTALLTYPE passed to ApplyPatch()");
	}

	ENG::FreeServices();

	if (eInstallType == INSTALLTYPE_SINGLE_INSTANCE && uiStat == ERROR_PATCH_TARGET_NOT_FOUND)
	{
		// ? error msg
		DEBUGMSG(TEXT("The specified instance does not exist as an installed or advertised product on the machine or the specified instance is not a valid target of the patch."));
	}
	
	return uiStat;
}

//+--------------------------------------------------------------------------
//
//  Function:	GetLoggedOnUserCountXP
//
//  Synopsis:	Counts the number of users logged on to a WindowsXP or
//				higher system.
//
//  Arguments:	none.
//
//  Returns:	The number of users logged on to the system. 0 if it fails or
//				if it is not a WindowsNT 5.1 or higher system.
//
//  History:	1/29/2002  RahulTh  created
//
//  Notes:		We cannot use the WTSEnumerateSessions API on WinXP and higher
//				since it does not work very well with FUS and non-admin users
//				may not get the correct count of users logged on to the system.
//				Therefore, we must use the WinStationGetTermSrvCountersValue
//				API which was introduced in WindowsXP and works well with
//				Fast User-Switching (FUS).
//
//---------------------------------------------------------------------------
UINT GetLoggedOnUserCountXP (void)
{
    UINT iCount = 0;
    TS_COUNTER TSCountersDyn[2];
	
	if (MinimumPlatformWindowsNT51())
	{
		TSCountersDyn[0].counterHead.dwCounterID = TERMSRV_CURRENT_DISC_SESSIONS;
		TSCountersDyn[1].counterHead.dwCounterID = TERMSRV_CURRENT_ACTIVE_SESSIONS;

		// access the termsrv counters to find out how many users are logged onto the system
		if (WINSTA::WinStationGetTermSrvCountersValue(SERVERNAME_CURRENT, 2, TSCountersDyn))
		{
			if (TSCountersDyn[0].counterHead.bResult)
				iCount += TSCountersDyn[0].dwValue;

			if (TSCountersDyn[1].counterHead.bResult)
				iCount += TSCountersDyn[1].dwValue;
		}
	}

    return iCount;
}

//+--------------------------------------------------------------------------
//
//  Function:	GetLoggedOnUserCountWin2K
//
//  Synopsis:	Counts the number of users logged on to a Win2K box.
//
//  Arguments:	none
//
//  Returns:	The number of users logged on to the computer. 0 if it fails
//				or if we are not running on a Win2K box.
//
//  History:	1/29/2002  RahulTh  created
//
//  Notes:		This uses the WTSEnumerateSessions API because it cannot
//				use the WinStationGetTermSrvCountersValue which was not
//				available on Win2K.
//
//---------------------------------------------------------------------------
UINT GetLoggedOnUserCountWin2K (void)
{
    UINT iCount = 0;
    DWORD i = 0;
    PWTS_SESSION_INFO pSessionInfo = NULL;
    DWORD dwSessionCount = 0;

	if (!g_fWin9X && 5 == g_iMajorVersion && 0 == g_iMinorVersion)
	{
		if(WTSAPI32::WTSEnumerateSessions (WTS_CURRENT_SERVER, 0, 1, &pSessionInfo, &dwSessionCount))
		{
			//
			// Logged on users will either be in the WTSActive or WTSDisconnected
			// state, so those are the only two states we are interested in.
			//
			for (i = 0; i < dwSessionCount; i++)
			{
				if (WTSActive == pSessionInfo[i].State ||
					WTSDisconnected == pSessionInfo[i].State)
				{
					iCount++;
				}
			}
			WTSAPI32::WTSFreeMemory (pSessionInfo);
		} 
	}
    
	return iCount;
}

//+--------------------------------------------------------------------------
//
//  Function:	GetLoggedOnUserCount
//
//  Synopsis:	Counts the number of users logged on to the machine.
//
//  Arguments:	none
//
//  Returns:	The number of users logged on to the computer. 0 if it fails.
//
//  History:	1/29/2002  RahulTh  created
//
//  Notes:		see notes for GetLoggedOnUserCountWin2K and 
//				GetLoggedOnUserCountXP
//
//---------------------------------------------------------------------------
UINT GetLoggedOnUserCount (void)
{
	UINT iCount = 0;
	
	if (!g_fWin9X && 5 == g_iMajorVersion && 0 == g_iMinorVersion)
	{
		iCount = GetLoggedOnUserCountWin2K();		
	}
	else if (MinimumPlatformWindowsNT51())
	{
		iCount = GetLoggedOnUserCountXP();
	}
	
	return iCount;
}

// worker fn for MsiGetFileSignatureInformation
HRESULT GetFileSignatureInformation(const ICHAR* szFile, DWORD dwFlags, PCCERT_CONTEXT* ppCertContext, BYTE* pbHash, DWORD* pcbHash)
{
	// arguments checked in MsiGetFileSignatureInformation

	*ppCertContext = 0;

	HRESULT hrRet = S_OK; // initialize to fine

	CRYPT_PROVIDER_DATA const *psProvData    = NULL;
	CRYPT_PROVIDER_SGNR       *psProvSigner  = NULL;
	CRYPT_PROVIDER_CERT       *psProvCert    = NULL;
	CMSG_SIGNER_INFO          *psSigner      = NULL;
	PCCERT_CONTEXT             psCertContext = NULL;

	//
	// specify Authenticode policy provider (should be on machine)
	//
	
	GUID guidAction = WINTRUST_ACTION_GENERIC_VERIFY_V2;

	//
	// set up WinVerifyTrust structures
	//
	
	WINTRUST_FILE_INFO sWintrustFileInfo;
	memset((void*)&sWintrustFileInfo, 0x00, sizeof(WINTRUST_FILE_INFO)); // zero out
	sWintrustFileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);
	sWintrustFileInfo.pcwszFilePath = CApiConvertString(szFile);
	sWintrustFileInfo.hFile = NULL;

	WINTRUST_DATA sWintrustData;
	memset((void*)&sWintrustData, 0x00, sizeof(WINTRUST_DATA)); // zero out
	sWintrustData.cbStruct = sizeof(WINTRUST_DATA);
	sWintrustData.dwUIChoice = WTD_UI_NONE; // no UI
	sWintrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
	sWintrustData.dwUnionChoice = WTD_CHOICE_FILE;
	sWintrustData.pFile = &sWintrustFileInfo;
	sWintrustData.dwStateAction = WTD_STATEACTION_VERIFY; // hold state data

	// WinVerifyTrust policy DWORD value is HKCU
	CImpersonate Impersonate(true);

	//
	// 1st of two calls to WinVerifyTrust
	// specify dwStateAction = WTD_STATEACTION_VERIFY to save the state data for us to access
	// ABSOLUTELY NO UI!
	//

	HRESULT hrWVT = WINTRUST::WinVerifyTrust(/*UI Window Handle*/(HWND)INVALID_HANDLE_VALUE, &guidAction, &sWintrustData);

	//
	// determine which errors are fatal -- fatal errors are only those that corrupt the data that is to be returned
	//  - certs building to untrusted roots or that are expired are okay.
	//  - an invalid hash is okay unless pbHash is _NOT_ NULL
	//

	switch (hrWVT)
	{
	case S_OK:                         // a-okay
		{
			// ERROR_SUCCESS
			break;
		}
	case TRUST_E_BAD_DIGEST:           // hash does not verify
		{
			// only care about this one if they cared about the hash of the file
			// or dwFlags has MSI_INVALID_HASH_IS_FATAL set
			if (pbHash || (dwFlags & MSI_INVALID_HASH_IS_FATAL))
			{
				hrRet = hrWVT;
				goto Error;
			}
			break;
		}
	case CERT_E_EXPIRED:               // fall thru (okay)
	case CERT_E_UNTRUSTEDROOT:         // fall thru (okay)
	case CERT_E_UNTRUSTEDTESTROOT:     // fall thru (okay)
	case CERT_E_UNTRUSTEDCA:           // fall thru (okay)
	case TRUST_E_EXPLICIT_DISTRUST:    // fall thru (okay)
		{
			// we are not making a trust decision here, so these are ignorable
			break;
		}
	case TRUST_E_PROVIDER_UNKNOWN:      // no WVT; crypto unavailable (or broken)
	case TRUST_E_ACTION_UNKNOWN:        // ...
	case TRUST_E_SUBJECT_FORM_UNKNOWN : // ...
	case TYPE_E_DLLFUNCTIONNOTFOUND:    // ...
		{
			// no state data to release
			return HRESULT_FROM_WIN32(ERROR_FUNCTION_FAILED);
		}
	case TRUST_E_NOSIGNATURE:          // fall thru (subject is not signed, no signature info available for extraction)
	case TRUST_E_NO_SIGNER_CERT:       // fall thru (signature is corrupted)
	case CERT_E_MALFORMED:             // fall thru (signature is corrupted)
	case CERT_E_REVOKED:               // fall thru (signature compromised)
	default:
		{
			// fatal error
			hrRet = hrWVT;
			goto Error;
		}
	}

	//
	// now extract information from the stored Wintrust state data
	//

	psProvData = WINTRUST::WTHelperProvDataFromStateData(sWintrustData.hWVTStateData);
	if (psProvData)
	{
		psProvSigner = WINTRUST::WTHelperGetProvSignerFromChain((PCRYPT_PROVIDER_DATA)psProvData, 0 /*first signer*/, FALSE /* not a counter signer */, 0);
		if (psProvSigner)
		{
			psProvCert = WINTRUST::WTHelperGetProvCertFromChain(psProvSigner, 0); // (pos 0 = signer cert, pos csCertChain-1 = root cert)
			if (psProvCert)
			{
				psCertContext = psProvCert->pCert;
			}
		}
	}

	if (!psProvData || !psProvSigner || !psProvCert || !psCertContext)
	{
		hrRet = HRESULT_FROM_WIN32(ERROR_FUNCTION_FAILED);
		goto Error;
	}

	//
	// extract hash information if requested
	//
	if (pbHash)
	{
		psSigner = psProvSigner->psSigner;
		if (!psSigner)
		{
			hrRet = HRESULT_FROM_WIN32(ERROR_FUNCTION_FAILED);
			goto Error;
		}

		// see if pbHash buffer is big enough for hash data
		if (*pcbHash < psSigner->EncryptedHash.cbData)
		{
			// set pcbHash to needed buffer size
			*pcbHash = psSigner->EncryptedHash.cbData;

			hrRet = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
			goto Error;
		}

		// pbHash buffer sufficient -- set to size of data to copy
		*pcbHash = psSigner->EncryptedHash.cbData;

		// copy hash information into pbHash buffer
		memcpy((void*)pbHash, (void*)psSigner->EncryptedHash.pbData, *pcbHash);
	}

	//
	// provide copy of certificate context, callee must call CertFreeCertificateContext
	//

	*ppCertContext = CRYPT32::CertDuplicateCertificateContext(psCertContext);
	if (NULL == *ppCertContext)
	{
		// call to CertDuplicateCertificateContext failed
		*ppCertContext = 0;
		hrRet = HRESULT_FROM_WIN32(ERROR_FUNCTION_FAILED);
		goto Error;
	}

	//
	// 2nd of 2 calls to WinVerifyTrust
	// specify dwStateAction = WTD_STATEACTION_CLOSE to release the state data
	//

	ReleaseWintrustStateData(&guidAction, sWintrustData);
	return S_OK;

Error:
	ReleaseWintrustStateData(&guidAction, sWintrustData);
	return hrRet;
}

// worker fn for MsiAdvertiseProduct and MsiAdvertiseProductEx
UINT DoAdvertiseProduct(const ICHAR* szPackagePath, const ICHAR* szScriptfilePath, const ICHAR* szTransforms, idapEnum idapAdvertisement, LANGID lgidLanguage, DWORD dwPlatform, DWORD dwOptions)
{
	UINT uiRet = ERROR_SUCCESS;

	int cchPackagePath = lstrlen(szPackagePath);
	int cchScriptfilePath = 0;
	if ((int)(INT_PTR)szScriptfilePath !=  ADVERTISEFLAGS_MACHINEASSIGN && (int)(INT_PTR)szScriptfilePath != ADVERTISEFLAGS_USERASSIGN)
		cchScriptfilePath = lstrlen(szScriptfilePath);
	int cchTransforms = 0;

	if (szTransforms && *szTransforms) //!! should we restrict length of szTransforms?
	{
		cchTransforms = lstrlen(szTransforms);
	}

	iioEnum iioOptions = (iioEnum)0;
	CAPITempBuffer<ICHAR, 1> szExpandedScriptfilePath;
	CAPITempBuffer<ICHAR, 1> szCommandLine;
	if (!szExpandedScriptfilePath.SetSize(cchExpectedMaxPath) || !szCommandLine.SetSize(cchMaxCommandLine+1))
		return ERROR_OUTOFMEMORY;

	szCommandLine[0] = '\0';

	DWORD dwValidArchitectureFlags = MSIARCHITECTUREFLAGS_X86 | MSIARCHITECTUREFLAGS_AMD64 | MSIARCHITECTUREFLAGS_IA64;

	if(idapMachineLocal == idapAdvertisement)		
	{
		if (dwPlatform & dwValidArchitectureFlags)
		{
			// platform simulation not allowed in "local machine" machine advertisement
			uiRet = ERROR_INVALID_PARAMETER;
		}
		else
		{
			const ICHAR szAllUsers[] = TEXT(" ") IPROPNAME_ALLUSERS TEXT("=") TEXT("1");
			AppendStringToTempBuffer(szCommandLine, szAllUsers, sizeof(szAllUsers)/sizeof(ICHAR) - 1);
		}
	}
	else if(idapUserLocal == idapAdvertisement)
	{
		if (dwPlatform & dwValidArchitectureFlags)
		{
			// platform simulation not allowed in "local machine" user advertisement
			uiRet = ERROR_INVALID_PARAMETER;
		}
		else
		{
			// explictly set ALLUSERS = "" to override any potential define of the same in the property table
			const ICHAR szAllUsers[] = TEXT(" ") IPROPNAME_ALLUSERS TEXT("=") TEXT("\"\"");
			AppendStringToTempBuffer(szCommandLine, szAllUsers, sizeof(szAllUsers)/sizeof(ICHAR) - 1);
		}
	}
	else // idapScript == idapAdvertisement
	{
		if (!ExpandPath(szScriptfilePath, szExpandedScriptfilePath))
		{
			uiRet = ERROR_INVALID_PARAMETER;
		}
		else if (*szExpandedScriptfilePath)
		{				
			const ICHAR szScriptFileProp[] = TEXT(" ") IPROPNAME_SCRIPTFILE TEXT("=") TEXT("\"");
			AppendStringToTempBuffer(szCommandLine, szScriptFileProp, sizeof(szScriptFileProp)/sizeof(ICHAR) - 1);
			AppendStringToTempBuffer(szCommandLine, szExpandedScriptfilePath);
			AppendStringToTempBuffer(szCommandLine, TEXT("\""));

			const ICHAR szExecuteMode[] = TEXT(" ") IPROPNAME_EXECUTEMODE TEXT("=") IPROPVALUE_EXECUTEMODE_NONE;
			AppendStringToTempBuffer(szCommandLine, szExecuteMode, sizeof(szExecuteMode)/sizeof(ICHAR) - 1);

			iioOptions = iioEnum(iioDisablePlatformValidation | iioCreatingAdvertiseScript);

			//
			// determine architecture to simulate; dwPlatform == 0 indicates use current platform
			//

			if (((dwPlatform & MSIARCHITECTUREFLAGS_X86) && (dwPlatform & MSIARCHITECTUREFLAGS_IA64)) ||
			    ((dwPlatform & MSIARCHITECTUREFLAGS_X86) && (dwPlatform & MSIARCHITECTUREFLAGS_AMD64)) ||
			    ((dwPlatform & MSIARCHITECTUREFLAGS_AMD64) && (dwPlatform & MSIARCHITECTUREFLAGS_IA64)))
			{
				// both architectures cannot be specified
				uiRet = ERROR_INVALID_PARAMETER;
			}
			else if (dwPlatform & MSIARCHITECTUREFLAGS_X86)
			{
				iioOptions = iioEnum(iioOptions | iioSimulateX86);
				DEBUGMSG1(TEXT("Simulating X86 architecture for advertise script creation on %s platform"), g_fWinNT64 ? TEXT("IA64") : TEXT("X86"));
			}
			else if (dwPlatform & MSIARCHITECTUREFLAGS_AMD64)
			{
				iioOptions = iioEnum(iioOptions | iioSimulateAMD64);
				DEBUGMSG1(TEXT("Simulating AMD64 architecture for advertise script creation on %s platform"), g_fWinNT64 ? TEXT("AMD64") : TEXT("X86"));                  
                                                        }
			else if (dwPlatform & MSIARCHITECTUREFLAGS_IA64)
			{
				iioOptions = iioEnum(iioOptions | iioSimulateIA64);
				DEBUGMSG1(TEXT("Simulating IA64 architecture for advertise script creation on %s platform"), g_fWinNT64 ? TEXT("IA64") : TEXT("X86"));
			}
			else
			{
				// use current platform
				DEBUGMSG1(TEXT("Using current %s platform for advertise script creation"), g_fWinNT64 ? TEXT("IA64") : TEXT("X86"));
			}
		}
	}

	if (ERROR_SUCCESS == uiRet)
	{
		ICHAR rgchBuf[11];
		StringCchPrintf(rgchBuf, (sizeof(rgchBuf)/sizeof(ICHAR)), TEXT("%d"), lgidLanguage); //?? best way to do this?
		const ICHAR szLanguageProp[] = TEXT(" ") IPROPNAME_PRODUCTLANGUAGE TEXT("=");
		AppendStringToTempBuffer(szCommandLine, szLanguageProp, sizeof(szLanguageProp)/sizeof(ICHAR) - 1);
		AppendStringToTempBuffer(szCommandLine, rgchBuf);

		if (dwOptions & MSIADVERTISEOPTIONFLAGS_INSTANCE)
		{
			const ICHAR szInstanceProp[] = TEXT(" ") IPROPNAME_MSINEWINSTANCE TEXT("=1");
			AppendStringToTempBuffer(szCommandLine, szInstanceProp, sizeof(szInstanceProp)/sizeof(ICHAR) -1);
		}
			
		if (szTransforms && *szTransforms)
		{
			const ICHAR szTransformsProp[] = TEXT(" ") IPROPNAME_TRANSFORMS TEXT("=") TEXT("\"");
			AppendStringToTempBuffer(szCommandLine, szTransformsProp, sizeof(szTransformsProp)/sizeof(ICHAR) - 1);
			AppendStringToTempBuffer(szCommandLine, CApiConvertString(szTransforms));
			AppendStringToTempBuffer(szCommandLine, TEXT("\""));
		}

		uiRet = RunEngine(irePackagePath, szPackagePath, IACTIONNAME_ADVERTISE, szCommandLine, GetStandardUILevel(), iioOptions); 
	}

	return uiRet;
}


//--------------------------------------------------
// FDeleteFolder: delete folder + files + subfolders
//
bool FDeleteFolder(ICHAR* szFolder)
{
	CAPITempBuffer<ICHAR, 1> szSearchPath;
	CAPITempBuffer<ICHAR, 1> szFilePath;
	if (!szSearchPath.Resize(MAX_PATH*3) || !szFilePath.Resize(MAX_PATH*3))
		return false;
	StringCchCopy(szSearchPath, szSearchPath.GetSize(), szFolder);
	StringCchCat(szSearchPath, szSearchPath.GetSize(), TEXT("\\*.*"));

	WIN32_FIND_DATA fdFindData;
	HANDLE hFile = WIN::FindFirstFile(szSearchPath, &fdFindData);

	if ((hFile == INVALID_HANDLE_VALUE) && (ERROR_ACCESS_DENIED == GetLastError()))
		return false;

	if(hFile != INVALID_HANDLE_VALUE)
	{
		// may still only contain "." and ".."
		do
		{
			if((0 != lstrcmp(fdFindData.cFileName, TEXT("."))) &&
				(0 != lstrcmp(fdFindData.cFileName, TEXT(".."))))
			{
				StringCchCopy(szFilePath, szFilePath.GetSize(), szFolder);
				StringCchCat(szFilePath, szFilePath.GetSize(), TEXT("\\"));
				StringCchCat(szFilePath, szFilePath.GetSize(), fdFindData.cFileName);
				if (fdFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					DEBUGMSGV1(TEXT("FDeleteFolder: Deleting folder '%s'"), szFilePath);

					// if failed again, ignore and keep deleting things in this
					// directory. Errors will be handled below when we try
					// to delete the directory itself
					FDeleteFolder(szFilePath);
				}
				else
				{
					DEBUGMSGV1(TEXT("FDeleteFolder: Deleting file '%s'"), szFilePath);
					if (!WIN::DeleteFile(szFilePath))
					{
						// failed to delete the folder, grab ownership, explicitly overwrite the ACLs, and try 
						// again.
						LockdownPath(szFilePath, false);
						WIN::SetFileAttributes(szFilePath, 0);
						
						// if failed again, ignore and keep deleting things in this
						// directory. Errors will be handled below when we try
						// to delete the directory itself
						WIN::DeleteFile(szFilePath);
					}
				}
			}

		}
		while(WIN::FindNextFile(hFile, &fdFindData) == TRUE);
	}
	else if (ERROR_FILE_NOT_FOUND != WIN::GetLastError())
		return false;
	else
		return true;

	WIN::FindClose(hFile);

	// if anything is left in the direcotry (due to failures above)
	// this will fail regardless of the ACLs.
	if (!WIN::RemoveDirectory(szFolder))
	{
		// try to set the ACLs to ensure that we have delete rights
		LockdownPath(szFolder, false);
		SetFileAttributes(szFolder, 0);

		if (!WIN::RemoveDirectory(szFolder))
		{
			return false;
		}
	}

	return true;
}

// worker fn for MsiCreateAndVerifyInstallerDirectory
UINT CreateAndVerifyInstallerDirectory()
{
	// the %systemroot%\Installer directory is securely ACL'd and must be owned by system or admin (well-known sids)
	// if not owned by system or admin, directory is deleted and recreated

	UINT uiStat = ERROR_SUCCESS;

	// must be admin or local system
	if (!IsAdmin() && !RunningAsLocalSystem())
	{
		DEBUGMSGV(TEXT("CreateAndVerifyInstallerDirectory: Must be admin or local system"));
		return ERROR_FUNCTION_FAILED;
	}

	// load services, required for MsiString use
	IMsiServices* piServices = ENG::LoadServices();
	if (!piServices)
	{
		DEBUGMSGV(TEXT("CreateAndVerifyInstallerDirectory: Unable to load services"));
		return ERROR_FUNCTION_FAILED;
	}

	if (g_fWin9X)
	{
		// scope MsiString
		{
			// retrieve name of %systemroot%\Installer directory
			MsiString strInstallerFolder = GetMsiDirectory();

			// no security on Win9x, so we just attempt to create the directory (no security verification)
			if (!CreateDirectory(strInstallerFolder, 0))
			{
				uiStat = GetLastError();
				if (ERROR_FILE_EXISTS == uiStat || ERROR_ALREADY_EXISTS == uiStat)
					uiStat = ERROR_SUCCESS; // already created
				else
					DEBUGMSG1(TEXT("CreateAndVerifyInstallerDirectory: Failed to create the Installer directory. LastError = %d"), (const ICHAR*)(INT_PTR)uiStat);
			}
		}

		// free services
		ENG::FreeServices();

		return uiStat;
	}

	// -------------- Running on NT --------------------------------

	Assert(!g_fWin9X);

	// obtain our secure security descriptor, but only if not on Win9X
	DWORD dwError = 0;
	char* rgchSD;
	if (ERROR_SUCCESS != (dwError = GetSecureSecurityDescriptor(&rgchSD)))
	{
		ENG::FreeServices();
		return ERROR_FUNCTION_FAILED; //?? should we create an event log entry
	}


	// scope MsiString
	{
		// retrieve name of %systemroot%\Installer directory
		MsiString strInstallerFolder = GetMsiDirectory();

		// set up security attributes
		SECURITY_ATTRIBUTES sa;
		memset((void*)&sa, 0x00, sizeof(SECURITY_ATTRIBUTES));
		sa.nLength        = sizeof(sa);
		sa.bInheritHandle = FALSE;
		sa.lpSecurityDescriptor = rgchSD;

		// determine if volume persists ACLs
		DWORD dwSystemFlags, dwMaxCompLen;
		CTempBuffer<ICHAR, 4>szRoot;
		StringCchCopy(szRoot, szRoot.GetSize(), strInstallerFolder);
		if (!WIN::GetVolumeInformation(szRoot, NULL, 0, NULL, &dwMaxCompLen, &dwSystemFlags, NULL, 0))
			uiStat = ERROR_FUNCTION_FAILED;
		else
		{
			bool fCreateDirectory = false;

			// determine the security on the folder
			CTempBuffer<char, 64> rgchFileSD;
			DWORD cbFileSD = 64;
			DWORD dwRet = ERROR_SUCCESS;

			if (!WIN::GetFileSecurity(strInstallerFolder, OWNER_SECURITY_INFORMATION, (PSECURITY_DESCRIPTOR)rgchFileSD, cbFileSD, &cbFileSD))
			{
				dwRet = WIN::GetLastError();
				if (ERROR_INSUFFICIENT_BUFFER == dwRet)
				{
					rgchFileSD.SetSize(cbFileSD);
					if (!WIN::GetFileSecurity(strInstallerFolder, OWNER_SECURITY_INFORMATION, (PSECURITY_DESCRIPTOR) rgchFileSD, cbFileSD, &cbFileSD))
						dwRet = GetLastError();
					else
						dwRet = ERROR_SUCCESS; // reset to success
				}

				if (ERROR_FILE_NOT_FOUND == dwRet)
					fCreateDirectory = true;
				else if (ERROR_SUCCESS != dwRet)
					uiStat = ERROR_FUNCTION_FAILED;
			}

			bool fDelete = false;
			if (!fCreateDirectory && (dwSystemFlags & FS_PERSISTENT_ACLS))
			{
				if (uiStat == ERROR_FUNCTION_FAILED && dwRet == ERROR_ACCESS_DENIED)
				{
					DEBUGMSGV(TEXT("Installer directory not accessible by system. Deleting . . ."));
					fDelete = true;
					uiStat = ERROR_SUCCESS;
				} 
				else if (uiStat == ERROR_SUCCESS)
				{
					// must be admin or system owned
					if (!FIsSecurityDescriptorSystemOrAdminOwned(rgchFileSD))
					{
						DEBUGMSGV(TEXT("Installer directory is not owned by the system or admin. Deleting . . ."));
						fDelete = true;
					}
				}
			}
			
			if (fDelete)
			{
				// overwrite the DACL first (or at least try) in case it is munged to the point that we don't 
				// have access
				AcquireTokenPrivilege(SE_TAKE_OWNERSHIP_NAME);
				LockdownPath(static_cast<const ICHAR*>(strInstallerFolder), false);

				if (!FDeleteFolder(const_cast <ICHAR*> ((const ICHAR*)strInstallerFolder)))
					uiStat = ERROR_FUNCTION_FAILED;

				// this is not ideal, need to use the new stack-based system when available
				DisableTokenPrivilege(SE_TAKE_OWNERSHIP_NAME);

				fCreateDirectory = true;
			}


			// create directory if it doesn't exist
			if (uiStat == ERROR_SUCCESS && fCreateDirectory)
			{
				if (!WIN::CreateDirectory(strInstallerFolder, &sa))
				{
					if (ERROR_INVALID_OWNER == GetLastError())
					{
						// we weren't running as local system when this was called
						// try it with a different owner
						DEBUGMSGV(TEXT("CreateAndVerifyInstallerDirectory: Unable to create the Installer directory as LocalSystem owner"));

						char rgchSD[256];
						DWORD cbSD = sizeof(rgchSD);

						DWORD cbAbsoluteSD = cbSD;
						DWORD cbDacl       = cbSD;
						DWORD cbSacl       = cbSD;
						DWORD cbOwner      = cbSD;
						DWORD cbGroup      = cbSD;

						const int cbDefaultBuf = 256;

						Assert(cbSD <= cbDefaultBuf); // we're using temp buffers here to be safe, but we'd like the default size to be big enough

						CTempBuffer<char, cbDefaultBuf> rgchAbsoluteSD(cbAbsoluteSD);
						CTempBuffer<char, cbDefaultBuf> rgchDacl(cbDacl);
						CTempBuffer<char, cbDefaultBuf> rgchSacl(cbSacl);
						CTempBuffer<char, cbDefaultBuf> rgchOwner(cbOwner);
						CTempBuffer<char, cbDefaultBuf> rgchGroup(cbGroup);

						// in order to change the owner of the security descriptor, we must have the absolute SID
						// GetSecureSecurityDescriptor only provides us with the relative SID
						if (!WIN::MakeAbsoluteSD(sa.lpSecurityDescriptor, rgchAbsoluteSD, &cbAbsoluteSD, (PACL)(char*)rgchDacl, &cbDacl, (PACL)(char*)rgchSacl, &cbSacl, rgchOwner, &cbOwner, rgchGroup, &cbGroup))
						{
							uiStat = ERROR_FUNCTION_FAILED;
						}
						else if (SetSecurityDescriptorOwner(rgchAbsoluteSD, (PSID)NULL, TRUE))
						{
							cbSD = WIN::GetSecurityDescriptorLength(rgchAbsoluteSD);
							if (!WIN::MakeSelfRelativeSD(rgchAbsoluteSD, (char*)rgchSD, &cbSD))
							{
								uiStat = ERROR_FUNCTION_FAILED;
							}
							else
							{
								sa.lpSecurityDescriptor = rgchSD;
								if (!WIN::CreateDirectory(strInstallerFolder, &sa))
								{
									DEBUGMSGV1(TEXT("CreateAndVerifyInstallerDirectory: Unable to create the Installer directory as default owner. LastError = %d"), (const ICHAR*)(INT_PTR)GetLastError());
									uiStat = ERROR_FUNCTION_FAILED;
								}
							}
						}
						else // could not update owner of security descriptor
						{
							uiStat = ERROR_FUNCTION_FAILED;
						}
					}
					else // some error other than ERROR_INVALID_OWNER
					{
						DEBUGMSGV1(TEXT("CreateAndVerifyInstallerDirectory: Failed to create the Installer directory. LastError = %d"), (const ICHAR*)(INT_PTR)GetLastError());
						uiStat = ERROR_FUNCTION_FAILED;
					}
				}// end if (!WIN::CreateDirectory(strInstallerFolder, &sa))

			}// end if (uiStat == ERROR_SUCCESS && fCreateDirectory)
		}
	}// end force MsiString scope

	// free services
	ENG::FreeServices();

	return uiStat;
}

//?? Do we need to handle quotes?
Bool ExpandPath(
				const ICHAR* szPath, 
				CAPITempBufferRef<ICHAR>& rgchExpandedPath,
				const ICHAR* szCurrentDirectory)
/*----------------------------------------------------------------------------
Expands szPath if necessary to be relative to the current director. If 
szPath begins with a single "\" then the current drive is prepended.
Otherwise, if szPath doesn't begin with "X:" or "\\" then the 
current drive and directory are prepended.

rguments:
	szPath: The path to be expanded
	rgchExpandedPath: The buffer for the expanded path

Returns:
	fTrue -   Success
	fFalse -  Error getting the current directory
------------------------------------------------------------------------------*/
{
	if (0 == szPath)
	{
		rgchExpandedPath[0] = '\0';
		return fTrue;
	}

	unsigned int cchPath = IStrLen(szPath) + 1;

	if(PathType(szPath) == iptFull)
	{
		if (!rgchExpandedPath.SetSize(cchPath))
			return fFalse;
		rgchExpandedPath[0] = '\0';
	}
	else // we need to prepend something
	{
		// Get the current directory
		
		CAPITempBuffer<ICHAR, cchExpectedMaxPath> rgchCurDir;
		DWORD dwRes = 0;
		if (!szCurrentDirectory || !*szCurrentDirectory)
		{
			dwRes = WIN::GetCurrentDirectory(rgchCurDir.GetSize(), rgchCurDir);

			if (dwRes == 0)
				return fFalse;

			else if (dwRes > rgchCurDir.GetSize())
			{
				if ( !rgchCurDir.SetSize(dwRes) )
					return fFalse;
				dwRes = GetCurrentDirectory(rgchCurDir.GetSize(), rgchCurDir);
				if (dwRes == 0)
					return fFalse;
			}
			szCurrentDirectory = rgchCurDir;
		}
		else
		{
			dwRes = IStrLen(szCurrentDirectory);
		}
			
		if (*szPath == '\\') // we need to prepend the current drive
		{
			if ( !rgchExpandedPath.SetSize(2 + cchPath) )
				return fFalse;
			rgchExpandedPath[0] = szCurrentDirectory[0];
			rgchExpandedPath[1] = szCurrentDirectory[1];
			rgchExpandedPath[2] = '\0';
		}
		else // we need to prepend the current path
		{
			if ( !rgchExpandedPath.SetSize(IStrLen(szCurrentDirectory) + 1 + cchPath) ) // 1 for possible '\'
				return fFalse;
			StringCchCopy(rgchExpandedPath, rgchExpandedPath.GetSize(), szCurrentDirectory);
			Assert(dwRes);
			if (dwRes && szCurrentDirectory[(int)(dwRes-1)] != '\\')
				StringCchCat(rgchExpandedPath, rgchExpandedPath.GetSize(), TEXT("\\"));
		}
	}
	
	StringCchCat(rgchExpandedPath, rgchExpandedPath.GetSize(), szPath);
	return fTrue;
}

IMsiRecord* ResolveSource(IMsiServices* piServices, const ICHAR* szProduct, unsigned int uiDisk, const IMsiString*& rpiSource, const IMsiString*& rpiProduct, Bool fSetLastUsedSource, HWND hwnd, bool fPatch) 
{	
	CResolveSource source(piServices, false /*fPackageRecache*/);
	return source.ResolveSource(CApiConvertString(szProduct), fPatch ? fTrue : fFalse, uiDisk, rpiSource, rpiProduct, fSetLastUsedSource, hwnd, false/*bool fAllowDisconnectedCSCSource*/);
}

int GrabMutex(const ICHAR* szName, DWORD dwWait, HANDLE& rh)
{
	ICHAR rgchTSName[MAX_PATH];

	// if NT5 or above, or TS installed on a lower platform, need to use mutex prefix
	if ((!g_fWin9X && g_iMajorVersion >= 5) || IsTerminalServerInstalled())
	{
		StringCchCopy(rgchTSName, (sizeof(rgchTSName)/sizeof(ICHAR)), TEXT("Global\\"));
		StringCchCat(rgchTSName, (sizeof(rgchTSName)/sizeof(ICHAR)), szName);
		szName = rgchTSName;
	}

	if (!g_fWin9X)
	{
		SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
		SID_IDENTIFIER_AUTHORITY siaWorld   = SECURITY_WORLD_SID_AUTHORITY;

		CSIDAccess SIDAccess[3];

		// set up the SIDs for Local System, Everyone, and Administrators
		if ((!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(SIDAccess[0].pSID))) ||
			(!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(SIDAccess[1].pSID))) ||
			(!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(SIDAccess[2].pSID))))
		{
			return GetLastError();
		}
		SIDAccess[0].dwAccessMask = GENERIC_ALL;  /* Local System   */ 
		SIDAccess[1].dwAccessMask = GENERIC_ALL;  /* Everyone       */ // Must use All for app-compat, 
			// we'd rather use: GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, and 
			// manage the mutex through an API for locking and unlocking the server.
		SIDAccess[2].dwAccessMask = GENERIC_ALL;  /* Administrators */

		CSecurityDescription secdesc(NULL, (PSID) NULL, SIDAccess, 3);
		Assert(secdesc.isValid());

		rh = CreateMutex(secdesc.SecurityAttributes(),FALSE,szName);
	}
	else
	{
		rh = CreateMutex(NULL, FALSE, szName);
	}

	if(rh)
	{
		DWORD dw = WaitForSingleObject(rh,dwWait);
		if(dw == WAIT_FAILED || dw == WAIT_TIMEOUT)
		{
			CloseHandle(rh);
			rh = 0;
			return dw;
		}
		else
		{
			return ERROR_SUCCESS;
		}
	}
	else
		return GetLastError();
}

// Please don't base any decisions on the success of opening the execution
// mutex, but use IMsiServer/MsiUIMessageContext->IsServiceInstalling instead.

bool FMutexExists(const ICHAR* szName, HANDLE& rh)
{
	ICHAR rgchTSName[MAX_PATH+1];

	// if NT5 or above, or TS installed on a lower platform, need to use mutex prefix
	if ((!g_fWin9X && g_iMajorVersion >= 5) || IsTerminalServerInstalled())
	{
		StringCchCopy(rgchTSName, (sizeof(rgchTSName)/sizeof(ICHAR)), TEXT("Global\\"));
		StringCchCat(rgchTSName, (sizeof(rgchTSName)/sizeof(ICHAR)), szName);
		szName = rgchTSName;
	}

	rh = WIN::OpenMutex(MUTEX_ALL_ACCESS,FALSE,szName);
	if(rh == NULL)
	{
		DWORD dw = GetLastError();
		return false;
	}
	else
		return true;
}

int CMutex::Grab(const ICHAR* szName, DWORD dwWait)
{
	if(m_h)
		Release();
	return GrabMutex(szName,dwWait,m_h);
}

void CMutex::Release()
{
	if(m_h)
	{
		AssertNonZero(ReleaseMutex(m_h));
		AssertNonZero(CloseHandle(m_h));
		m_h = NULL;
	}
}

int GrabExecuteMutex(CMutex& mutex)
{
	int iError = mutex.Grab(szMsiExecuteMutex,3000);

	if(iError == ERROR_SUCCESS)
		DEBUGMSG(TEXT("Grabbed execution mutex."));
	else
		DEBUGMSG1(TEXT("Failed to grab execution mutex. System error %d."), (const ICHAR*)(INT_PTR)iError);
	// Please don't base any decisions on the success of grabbing the execution
	// mutex, but use IMsiServer/MsiUIMessageContext->IsServiceInstalling instead.
	return ERROR_SUCCESS;
}

//  Private copy of GetWindowsDirectory(). Calls either GetWindowsDirectory
//  or GetSystemWindowsDirectory based on OS and TS state. Ensures that 
//  the client and server on TS are always in-sync regardless of whether
//  the client is marked TSAWARE or not.
UINT MsiGetWindowsDirectory(LPTSTR lpBuffer, UINT cchBuffer)
{
	if (IsTerminalServerInstalled() && g_iMajorVersion >= 5)
		// NT5 TS specific API. Also on NT4 SP4, but don't want different 
		// behavior on NT4 solely based on service pack level
		return KERNEL32::GetSystemWindowsDirectory(lpBuffer, cchBuffer);
	else
		return GetWindowsDirectory(lpBuffer, cchBuffer);
}


// Private copy of GetCurrentThreadId(). Often API calls are made from a custom
// action running in the CA server. In those cases, the actual thread id is that 
// of the RPC handler thread, which is not relevant. We want to act as if we were
// effectively called directly by the custom action. For remote APIs, the effective
// thread is stored in thread local storage by the CMsiRemoteAPI stub class. 
extern DWORD g_dwThreadImpersonationSlot;
extern int   g_fThreadImpersonationLock;
extern bool  g_fThreadImpersonationArray;
extern CAPITempBuffer<ThreadIdImpersonate, 5>  g_rgThreadIdImpersonate;

DWORD MsiGetCurrentThreadId()
{
	// handles are created with the current thread Id for tracking. Remote API calls
	// might be impersonating a client thread!
	DWORD dwThreadId = 0;
	while (TestAndSet(&g_fThreadImpersonationLock)) // acquire lock
	{
		Sleep(10);
	}

	// first attempt is using the TLS slot. This could happen in the service or in the client
	if (g_dwThreadImpersonationSlot == INVALID_TLS_SLOT || 
	   (0 == (dwThreadId = static_cast<DWORD>((ULONG_PTR)TlsGetValue(g_dwThreadImpersonationSlot)))))
	{	
		// assume no thread id impersonation, so current id is real id.
		dwThreadId = WIN::GetCurrentThreadId();
		
		// service can only use TLS, but client can use the array as well.
		if (g_scServerContext != scService && g_fThreadImpersonationArray)
		{
			unsigned int c = 0;
			unsigned int cThreadImpersonate = g_rgThreadIdImpersonate.GetSize();

			// search for this ThreadId in the array.
			for (c=0; c < cThreadImpersonate; c++)
			{
				if (g_rgThreadIdImpersonate[c].m_dwThreadId == dwThreadId)
				{
					dwThreadId = g_rgThreadIdImpersonate[c].m_dwClientThreadId;
					break;
				}
			}
		}
	}
	
	g_fThreadImpersonationLock = 0;
	return dwThreadId;
}

const unsigned int iDefaultDisableBrowsePolicy      =  0;      // default: browsing is allowed
const unsigned int iDefaultDisablePatchPolicy       =  0;      // default: patching is allowed
const unsigned int iDefaultDisableMediaPolicy       =  0;      // default: media is allowed
const unsigned int iDefaultTransformsAtSourcePolicy =  0;      // default: locally cached transforms
const unsigned int iDefaultTransformsSecurePolicy   =  1;      // default: cache transforms securely
const unsigned int iDefaultAlwaysElevatePolicy      =  0;      // default: don't always elevate
const unsigned int iDefaultDisableMsiPolicy         =  1;      // default: only allow managed app installations by non-admins
const unsigned int iDefaultDisableUserInstallsPolicy=  0;
#ifdef DEBUG
const unsigned int iDefaultWaitTimeoutPolicy        = 10*60;   // default: wait timeout for UI thread (in seconds)
#else
const unsigned int iDefaultWaitTimeoutPolicy        = 30*60;   // ship default: wait timeout for UI thread (in seconds)
#endif //DEBUG

const unsigned int iDefaultDisableRollbackPolicy    =  0;      // default: rollback enabled
const unsigned int iDefaultDebugPolicy              =  0;      // default: no debug output

const unsigned int iDefaultResolveIODPolicy         =  0;      // default: restrict PCFD calls
const unsigned int iDefaultAllowAllPublicProperties =  0;      // default: restrict public properties
const unsigned int iDefaultSafeForScripting         =  0;      // default: restrict scripting
const unsigned int iDefaultEnableAdminTSRemote      =  0;      // default: disallow remote installation on TS

const unsigned int iDefaultAllowLockdownBrowsePolicy =  0;      // default: non-admin browsing disallowed
const unsigned int iDefaultAllowLockdownPatchPolicy  =  0;      // default: non-admin patching disallowed
const unsigned int iDefaultAllowLockdownMediaPolicy  =  0;      // default: non-admin media disallowed

const unsigned int iDefaultInstallKnownOnlyPolicy    =  0;      // default: unsigned and unknown allowed

const unsigned int iDefaultLimitSystemRestoreCheckpoint =  0;   // default: full checkpointing allowed

const ICHAR szDefaultSearchOrderPolicy[] = {chNetSource, chMediaSource, chURLSource, 0}; 
const ICHAR szLegalSearchOrderPolicy[] = {chNetSource, chMediaSource, chURLSource, 0};

DWORD OpenPolicyKey(HKEY *phKey, BOOL fMachine)
//----------------------------------------------------------------------------
{
	CAPITempBuffer<ICHAR, 1> rgchItemKey;
	if (!rgchItemKey.SetSize(cchMaxSID + 1 + sizeof(szPolicyKey)/sizeof(ICHAR) + 1))
		return ERROR_OUTOFMEMORY;
	rgchItemKey[0] = 0;

	HKEY hRootKey;
	DWORD dwResult = ERROR_SUCCESS;

	if (fMachine)
		hRootKey = HKEY_LOCAL_MACHINE;
	else
	{
		if (g_fWin9X)
		{
			hRootKey = HKEY_CURRENT_USER;
			rgchItemKey[0] = 0;
		}
		else
		{
			hRootKey = HKEY_USERS;

			DWORD dwError = GetCurrentUserStringSID(rgchItemKey);
			if (ERROR_SUCCESS != dwError)
				return dwError;

			if (FAILED(StringCchCat(rgchItemKey, rgchItemKey.GetSize(), TEXT("\\"))))
				return ERROR_FUNCTION_FAILED;
		}
	}

	if (FAILED(StringCchCat(rgchItemKey, rgchItemKey.GetSize(), szPolicyKey)))
		return ERROR_FUNCTION_FAILED;
	REGSAM sam = KEY_READ;
#ifndef _WIN64
	if ( g_fWinNT64 )
		sam |= KEY_WOW64_64KEY;
#endif
	dwResult = RegOpenKeyAPI(hRootKey, rgchItemKey, 0, sam, phKey);
	return dwResult;
}

struct PolicyEntry
{
	const ICHAR* szName;
//union
//{
	const ICHAR* szDefaultValue;       
// int iPolicyType;                 // 0, 1, or 2 if policy value is an integer. 1 means that iCachedValue is set to the machine value, 2 means user value. 0 means it's not set.
//}

//union
//{
	const ICHAR* szLegalCharacters;  // case insensitive
// int iCachedValue;
//}
	int iDefaultValue;               // -1 if policy value is a string
	int iLegalMin;
	int iLegalMax;
};


PolicyEntry g_PolicyTable[] =
{
// Name                           default value               legal characters           default value                            min,max
//                                (string policy)             (string policy)            (integer policy)                        (integer policy)
	szDisableUserInstallsValueName,0,                          0,                         iDefaultDisableUserInstallsPolicy,    0, 1,
	szSearchOrderValueName,        szDefaultSearchOrderPolicy, szLegalSearchOrderPolicy , -1,                                   0, 0,
	szDisableBrowseValueName,      0,                          0,                         iDefaultDisableBrowsePolicy,          0, 1,
	szTransformsSecureValueName,   0,                          0,                         iDefaultTransformsSecurePolicy,       0, 1,
	szTransformsAtSourceValueName, 0,                          0,                         iDefaultTransformsAtSourcePolicy,     0, 1,
	szAlwaysElevateValueName,      0,                          0,                         iDefaultAlwaysElevatePolicy,          0, 1,
	szDisableMsiValueName,         0,                          0,                         iDefaultDisableMsiPolicy,             0, 2,
	szWaitTimeoutValueName,        0,                          0,                         iDefaultWaitTimeoutPolicy,            1, 2147483647,
	szDisableRollbackValueName,    0,                          0,                         iDefaultDisableRollbackPolicy,        0, 1,
	szLoggingValueName,            TEXT(""),                   szLogChars,                -1,                                   0, 0,
	szDebugValueName,              0,                          0,                         iDefaultDebugPolicy,                  0, 7,
	szResolveIODValueName,         0,                          0,                         iDefaultResolveIODPolicy,             0, 1,
	szDisablePatchValueName,       0,                          0,                         iDefaultDisablePatchPolicy,           0, 1,
	szAllowAllPublicProperties,    0,                          0,                         iDefaultAllowAllPublicProperties,     0, 1,
	szSafeForScripting,            0,                          0,                         iDefaultSafeForScripting,             0, 1,
	szEnableAdminTSRemote,         0,                          0,                         iDefaultEnableAdminTSRemote,          0, 1,
	szDisableMediaValueName,       0,                          0,                         iDefaultDisableMediaPolicy,           0, 1,
	szAllowLockdownBrowseValueName,0,                          0,                         iDefaultAllowLockdownBrowsePolicy,    0, 1,
	szAllowLockdownPatchValueName, 0,                          0,                         iDefaultAllowLockdownPatchPolicy,     0, 1,
	szAllowLockdownMediaValueName, 0,                          0,                         iDefaultAllowLockdownMediaPolicy,     0, 1,
	szInstallKnownOnlyValueName,   0,                          0,                         iDefaultInstallKnownOnlyPolicy,       0, 1,
	szLimitSystemRestoreCheckpoint,0,                          0,                         iDefaultLimitSystemRestoreCheckpoint, 0, 1,
	0, 0, 0,
};

void ResetCachedPolicyValues() // we only cache integer policy values
{
	DEBUGMSG(TEXT("Resetting cached policy values"));
	for (PolicyEntry* ppe = g_PolicyTable; ppe->szName; ppe++)
	{
		if (ppe->iDefaultValue != -1) // this is an integer value
		{
			ppe->szDefaultValue = (ICHAR*)0;
		}
	}

}

unsigned int GetIntegerPolicyValue(const ICHAR* szName, Bool fMachine, Bool* pfUsedDefault)
{
	PolicyEntry* ppe = g_PolicyTable;
	for (; ppe->szName && (0 != lstrcmp(ppe->szName, szName)); ppe++)
		;

	if (! ppe->szName || ppe->iDefaultValue == -1) // unknown value or value is not an integer
	{
		Assert(0);
		return 0;
	}

	if ((INT_PTR)(ppe->szDefaultValue) == (fMachine ? 1 : 2)) // we have a cached value	//--merced: changed (int) to (INT_PTR)
	{
		return (unsigned int)(UINT_PTR)(ppe->szLegalCharacters);		//--merced: okay to typecast. checked with malcolmh.
	}

	if (pfUsedDefault)
		*pfUsedDefault = fTrue;
	unsigned int uiValue = ppe->iDefaultValue;

	CRegHandle HPolicyKey;
	DWORD dwRes = OpenPolicyKey(&HPolicyKey, fMachine);
	if (ERROR_SUCCESS == dwRes)
	{
		CAPITempBuffer<ICHAR, 40> rgchValue;
		dwRes = MsiRegQueryValueEx(HPolicyKey, szName, 0, 0, rgchValue, 0);
		if (ERROR_SUCCESS == dwRes)
		{
			unsigned int uiRegValue = *(int*)(const ICHAR*)rgchValue;
			AssertSz(uiRegValue >= ppe->iLegalMin && uiRegValue <= ppe->iLegalMax, "Policy value not in legal range");
			if (uiRegValue >= ppe->iLegalMin && uiRegValue <= ppe->iLegalMax)
			{
				if (pfUsedDefault)
					*pfUsedDefault = fFalse;

				uiValue = uiRegValue;
			}
			//else use default value
		}
	}
	Assert (dwRes == ERROR_SUCCESS || dwRes == ERROR_FILE_NOT_FOUND);

	DEBUGMSG3(TEXT("%s policy value '%s' is %u"), fMachine ? TEXT("Machine") : TEXT("User"), szName, (const ICHAR*)(INT_PTR)uiValue);

	ppe->szLegalCharacters = (ICHAR*)(INT_PTR)uiValue; // cache the value	//--merced: added (INT_PTR). okay to typecast.
	ppe->szDefaultValue    = (ICHAR*)(INT_PTR)(fMachine ? 1 : 2);       // indicate that we have a cached value //--merced: added (INT_PTR). okay to typecast.
	return uiValue;
}


void GetStringPolicyValue(const ICHAR* szName, Bool fMachine, CAPITempBufferRef<ICHAR>& rgchValue)
{
	const PolicyEntry* ppe = g_PolicyTable;
	for (; ppe->szName && (0 != lstrcmp(ppe->szName, szName)); ppe++)
		;

	if (! ppe->szName || ppe->iDefaultValue != -1) // unknown value or value is not an integer
	{
		Assert(0);
		rgchValue[0] = 0;
		return;
	}

	CRegHandle HPolicyKey;
	DWORD dwRes = OpenPolicyKey(&HPolicyKey, fMachine);
	if (ERROR_SUCCESS == dwRes)
	{
		dwRes = MsiRegQueryValueEx(HPolicyKey, szName, 0, 0, rgchValue, 0);
		if (ERROR_SUCCESS == dwRes)
		{
			if (ppe->szLegalCharacters)
			{
				const ICHAR* pchValue = rgchValue;
				const ICHAR* pchLegal;
				while (*pchValue)
				{
					for (pchLegal = ppe->szLegalCharacters; *pchLegal && (*pchLegal != (*pchValue | 0x20)); pchLegal++)
						;
					AssertSz(*pchLegal, "Illegal character in policy value");
					if (!*pchLegal)
						break; // illegal character -- use default

					pchValue = INextChar(pchValue);
				}
			}
			DEBUGMSG2(TEXT("Policy value '%s' is '%s'"), szName, rgchValue);
			return;
		}
	}
	Assert (dwRes == ERROR_SUCCESS || dwRes == ERROR_FILE_NOT_FOUND);
	if (rgchValue.GetSize() < lstrlen(ppe->szDefaultValue) + 1)
		rgchValue.SetSize(lstrlen(ppe->szDefaultValue) + 1);

	StringCchCopy(rgchValue, rgchValue.GetSize(), ppe->szDefaultValue);

	DEBUGMSG3(TEXT("%s policy value '%s' is '%s'"), fMachine ? TEXT("Machine") : TEXT("User"), szName, rgchValue);
}

//______________________________________________________________________________
//
// Global data maintained by CMsiMessageBox - Button name cache
//______________________________________________________________________________

const int cchButtonName = 24;  // maximum length of any button name (beyond 18 chars may not fit on button)
static const int g_rgButtonIDs[] = {IDS_BROWSE, IDS_OK,IDS_CANCEL,IDS_CANCEL,IDS_RETRY,IDS_IGNORE,IDS_YES,IDS_NO};
// NOTE: above must track winuser.h defs:   IDOK   IDCANCEL   IDABORT    IDRETRY   IDIGNORE   IDYES   IDNO 
const int cButtonCount = sizeof(g_rgButtonIDs)/sizeof(*g_rgButtonIDs);
static ICHAR g_rgszButtonName[cButtonCount][cchButtonName];
static int g_iLangIdButtons = -1;  // language for which above strings are cached
static int g_iButtonCodepage;      // codepage for cached button names

/*inline*/ const ICHAR* GetButtonName(unsigned int id) { return id < cButtonCount ? &g_rgszButtonName[id][0] : TEXT(""); }

//______________________________________________________________________________
//
// UI helper functions
//______________________________________________________________________________

int g_iACP = 0;   // cached return of GetACP()

LANGID MsiGetDefaultUILangID()  // can't cache the result when running in the service, as multiple users may access same process
{
#ifdef DEBUG // override user language for testing UI
	static bool fCheckedEnvir = false;
	static int iDebugLangId = 0;
	if (!fCheckedEnvir)
	{
		int iLangId;
		char rgchBuf[20];
		if (WIN::GetEnvironmentVariableA("_MSI_UILANGID", rgchBuf, sizeof(rgchBuf)/sizeof(*rgchBuf))
		 && (iLangId = strtol(rgchBuf)) > 0)
			iDebugLangId = iLangId;
		fCheckedEnvir = true;
	}
	if (iDebugLangId != 0)
		return (LANGID)iDebugLangId;
#endif
#ifdef UNICODE
	return KERNEL32::GetUserDefaultUILanguage();  // latebind default is WIN::GetUserDefaultLangID()
#else
	return WIN::GetUserDefaultLangID();
#endif
}

unsigned int MsiGetCodepage(int iLangId)
{
	if (g_iACP == 0)
		g_iACP = WIN::GetACP();
	static unsigned int iLastLangInfo = 0xFFFF;  // invalidate cache,  high word = Codepage, low word = LangId
	if (iLangId == 0)
		return g_iACP;  // use system codepage for neutral strings
	if ((short)iLangId == (short)iLastLangInfo)  // check cache first
		return iLastLangInfo >> 16;
	ICHAR rgchBuf[10];
	if (0 == WIN::GetLocaleInfo(iLangId, LOCALE_IDEFAULTANSICODEPAGE, rgchBuf, sizeof(rgchBuf)/sizeof(*rgchBuf)))
		return 0;  // unsupported language, 0 == CP_ACP
	int iCodepage = ::GetIntegerValue(rgchBuf, 0);
	iLastLangInfo = (iCodepage << 16) | (short) iLangId;
	return iCodepage;
}

int CALLBACK EnumFontProc(ENUMLOGFONTEX *pelfe, NEWTEXTMETRICEX* /*pntme*/, int /*iFontType*/, LPARAM lParam)
{
	LOGFONT* pLogFont = (LOGFONT*)lParam;
	if (pLogFont->lfCharSet != pelfe->elfLogFont.lfCharSet)
	{
		//  wrong character set
		return 1;
	}
	else
	{
		StringCchCopy(pLogFont->lfFaceName, (sizeof(pLogFont->lfFaceName)/sizeof(ICHAR)), (const ICHAR*)pelfe->elfFullName);  // return font name
		return 0;   // stop after the first match
	}
}

#ifdef UNICODE
//  English name = MS PGothic
static const WCHAR rgchDefaultJPNName[] = L"\xFF2D\xFF33\x0020\xFF30\x30B4\x30B7\x30C3\x30AF";
//  English name = SimSun
static const WCHAR rgchDefaultCHSName[] = L"\x5B8B\x4F53";
//  English name = Gulim
static const WCHAR rgchDefaultKORName[] = L"\xAD74\xB9BC";
//  English name = PMingLiU
static const WCHAR rgchDefaultCHTName[] = L"\x65B0\x7D30\x660E\x9AD4";
#else
//  English name = MS PGothic
static const char rgchDefaultJPNName[] = "\x82\x6c\x82\x72\x20\x82\x6f\x83\x53\x83\x56\x83\x62\x83\x4E";
//  English name = SimSun
static const char rgchDefaultCHSName[] = "\xcb\xce\xcc\xe5";
//  English name = Gulim
static const char rgchDefaultKORName[] = "\xb1\xbc\xb8\xb2";
//  English name = PMingLiU
static const char rgchDefaultCHTName[] = "\xb7\x73\xb2\xd3\xa9\xfa\xc5\xe9";
#endif
static const ICHAR rgchDefaultJPNNameEnglish[] = TEXT("MS PGothic");
static const ICHAR rgchDefaultCHSNameEnglish[] = TEXT("SimSun");
static const ICHAR rgchDefaultKORNameEnglish[] = TEXT("Gulim");
static const ICHAR rgchDefaultCHTNameEnglish[] = TEXT("PMingLiU");

static const ICHAR rgchDefaultUIFont[] = TEXT("MS Shell Dlg");

HFONT MsiCreateFont(UINT iCodepage)
{
	if (g_iACP == 0)
		g_iACP = WIN::GetACP();

	DWORD dwCharSet = 0;
	HFONT hFont = 0;

	// set font size
	int dyPointsMin = 8; // minimum 9 required for FE languages, set in cases below
	const ICHAR* szTypeface = (iCodepage == g_iACP ? rgchDefaultUIFont : TEXT(""));
	switch (iCodepage)
	{
	case 874:  dwCharSet = THAI_CHARSET;        break;
	case 932:  dwCharSet = SHIFTJIS_CHARSET; 
				szTypeface = (iCodepage == g_iACP) ? rgchDefaultJPNName : rgchDefaultJPNNameEnglish;
				dyPointsMin = 9;
				break;
	case 936:  dwCharSet = GB2312_CHARSET;      
				szTypeface = (iCodepage == g_iACP) ? rgchDefaultCHSName : rgchDefaultCHSNameEnglish;
				dyPointsMin = 9;
				break;
	case 949:  dwCharSet = HANGEUL_CHARSET;    
				szTypeface = (iCodepage == g_iACP) ? rgchDefaultKORName : rgchDefaultKORNameEnglish;
				dyPointsMin = 9;
				break; // Korean
	case 950:  dwCharSet = CHINESEBIG5_CHARSET; 
				szTypeface = (iCodepage == g_iACP) ? rgchDefaultCHTName : rgchDefaultCHTNameEnglish;
				dyPointsMin = 9;
				break;
	case 1250: dwCharSet = EASTEUROPE_CHARSET;  break;
	case 1251: dwCharSet = RUSSIAN_CHARSET;     break;
	case 1252: dwCharSet = ANSI_CHARSET;        break;
	case 1253: dwCharSet = GREEK_CHARSET;       break;
	case 1254: dwCharSet = TURKISH_CHARSET;     break;
	case 1255: dwCharSet = HEBREW_CHARSET;      break;
	case 1256: dwCharSet = ARABIC_CHARSET;      break;
	case 1257: dwCharSet = BALTIC_CHARSET;      break;
	case 1258: dwCharSet = VIETNAMESE_CHARSET;  break;
	default:   dwCharSet = DEFAULT_CHARSET;     break;
	}
	ICHAR rgchFaceName[LF_FACESIZE];
	TEXTMETRIC tm;
	LOGFONT lf;
	memset(&lf, 0, sizeof(lf));
	HDC hdc = GetDC(0);
	int dpi = 0;
	if ( hdc )
	{
		dpi = GetDeviceCaps(hdc, LOGPIXELSY);
		ReleaseDC(NULL, hdc);
	}
	int dyPixelsMin = (dyPointsMin * max(dpi, 96) + 72/2) / 72;
	do
	{
		DWORD iFontFamily = (*szTypeface==0 ? FF_SWISS : DEFAULT_PITCH);
		hFont = WIN::CreateFont(-dyPixelsMin,       // logical height of font 
 								0,                  // logical average character width 
 								0,                  // angle of escapement 
 								0,                  // base-line orientation angle 
 								FW_NORMAL,          // FW_DONTCARE??, font weight 
 								0,                  // italic attribute flag 
 								0,                  // underline attribute flag 
	 							0,                  // strikeout attribute flag 
 								dwCharSet,          // character set identifier
 								OUT_DEFAULT_PRECIS, // output precision
 								0x40,               // clipping precision (force Font Association off)
 								DEFAULT_QUALITY,    // output quality
 								iFontFamily,        // pitch and family
								szTypeface);        // pointer to typeface name string

		if (hFont == 0)
		{
			DEBUGMSG2(TEXT("CreateFont failed, codepage: %i  CharSet: %i"), (const ICHAR*)(UINT_PTR)iCodepage, (const ICHAR*)(UINT_PTR)dwCharSet);
			return 0;
		}
		HDC hdc = GetDC(0);
		HFONT hfontOld = (HFONT)SelectObject(hdc, hFont);
		if (GetTextMetrics(hdc, &tm) == 0)  // most likely a bad font installation
		{
			DEBUGMSG1(TEXT("GetTextMetrics failed: GetLastError = %i"), (const ICHAR*)(UINT_PTR)WIN::GetLastError());
		}
		GetTextFace(hdc, sizeof(rgchFaceName)/sizeof(rgchFaceName[0]), rgchFaceName);
		SelectObject(hdc, hfontOld);
		DEBUGMSG4(TEXT("Font created.  Charset: Req=%i, Ret=%i, Font: Req=%s, Ret=%s\n"),
			(const ICHAR*)(UINT_PTR)dwCharSet, (const ICHAR*)(UINT_PTR)tm.tmCharSet, szTypeface, rgchFaceName);
		// Caution: On NT4, the character set returned will often lie to us, perhaps only when using a null font name
		if (tm.tmCharSet != dwCharSet)  // didn't get what we wanted, either none available or mapping failed
		{
			if (lf.lfFaceName[0] != 0)  // 2nd pass with font returned from enumeration
				lf.lfFaceName[0] = 0;  // break out of loop
			else  // font mapping failed or no font available
			{
				lf.lfCharSet = (BYTE)dwCharSet;
				lf.lfPitchAndFamily = 0;
				EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)EnumFontProc, (LPARAM)&lf, 0);
				szTypeface = lf.lfFaceName;  // possible new font name for retry
			}
			if (lf.lfFaceName[0] != 0)   // going to try to create another font
				WIN::DeleteObject(hFont), hFont = 0;
			else
				DEBUGMSG2(TEXT("Font enumeration failed to select charset, codepage: %i  CharSet: %i\n"), (const ICHAR*)(UINT_PTR)iCodepage, (const ICHAR*)(UINT_PTR)dwCharSet);
		}
		else
			lf.lfFaceName[0] = 0;  // success, break out of loop
		ReleaseDC(0, hdc);
	} while (lf.lfFaceName[0] != 0);  // retry with enumerated font
	return hFont;
}

void MsiDestroyFont(HFONT& rhfont)
{
	if (rhfont != 0)
	{
		WIN::DeleteObject((HGDIOBJ)rhfont);
		rhfont = 0;
	}
}

//______________________________________________________________________________
//
//  CMsiMessageBox implementation
//______________________________________________________________________________

// virtual implementation specific to message box initialization
bool CMsiMessageBox::InitSpecial()  // default extended WM_INITDIALOG handler
{
	if (m_idIcon)
		ShowWindow(GetDlgItem(m_hDlg, m_idIcon), SW_SHOW);
	if (m_szText != 0)
		SetMsgBoxSize();
	AdjustButtons();
	return true;
}

// virtual implementation for default dialog commmand handling
BOOL CMsiMessageBox::HandleCommand(UINT idControl)  // default WM_COMMAND handler
{
	switch (idControl)
	{
	case IDC_MSGBTN1:
	case IDC_MSGBTN2:
	case IDC_MSGBTN3:
		WIN::EndDialog(m_hDlg, m_rgidBtn[idControl - IDC_MSGBTN1]);
		return TRUE;
	}
	return FALSE;
}

// Insure that button names are loaded from string resources
int CMsiMessageBox::SetButtonNames()
{
	if (m_iLangId == g_iLangIdButtons)  // check cache first
		return 0;
	int cFail = 0;
	UINT iCodepage;
	g_iButtonCodepage = 0;
	for (int iButton = 0; iButton < cButtonCount; iButton++)
	{
		iCodepage = MsiLoadString(g_hInstance, g_rgButtonIDs[iButton], g_rgszButtonName[iButton], cchButtonName, (WORD)m_iLangId);
		Assert(iCodepage == 0 || g_rgszButtonName[iButton][0] != 0);  // catch button overflow on Win9X
		if (iCodepage == 0)
			cFail++;
		else if (iCodepage != g_iACP)
			g_iButtonCodepage = iCodepage;
	}
	if (g_iButtonCodepage == 0)
		g_iButtonCodepage = g_iACP;
	g_iLangIdButtons = m_iLangId;
	// DBGLOG:printf(TEXT("Button language: %i   Button codepage: %i   Missing strings = %i\n"), m_iLangId, g_iButtonCodepage, cFail);
	return cFail;
}

CMsiMessageBox::~CMsiMessageBox()
{
	MsiDestroyFont(m_hfontText);
	MsiDestroyFont(m_hfontButton);
}

//	Initialize message box data struct according to type.
CMsiMessageBox::CMsiMessageBox(const ICHAR* szText, const ICHAR* szCaption,
							   int iBtnDef, int iBtnEsc, int idBtn1, int idBtn2, int idBtn3,
							   UINT iCodepage, WORD iLangId)
{
	m_szText = szText;
	m_szCaption = (szCaption && *szCaption) ? szCaption : g_MessageContext.GetWindowCaption();
	m_iLangId = iLangId;
	m_iCodepage = iCodepage ? iCodepage : ::MsiGetCodepage(iLangId); // handle neutral codepage
	m_hfontButton = 0;
	m_hfontText = 0;
	m_hwndFocus = 0;

	// MIRRORED DLG
	//  Mirroring is supported on Windows2000 and above. When a dialog is mirrored, the origin
	//  is no longer the top left corner, but instead the top right corner. Reading order of
	//  the text is RTL. Mirroring is used for the Hebrew and Arabic languages 
	m_fMirrored = (MinimumPlatformWindows2000() && (m_iCodepage == 1255 || m_iCodepage == 1256)) ? true: false;

	m_rgidBtn[0] = idBtn1; Assert(idBtn1 >= 0); m_cButtons = 1;
	m_rgidBtn[1] = idBtn2;    if (idBtn2 >= 0)  m_cButtons = 2;
	m_rgidBtn[2] = idBtn3;    if (idBtn3 >= 0)  m_cButtons = 3;
	m_iBtnDef    = iBtnDef;
	m_iBtnEsc    = iBtnEsc;
	Assert(m_iBtnDef <= m_cButtons);
}

int CMsiMessageBox::Execute(HWND hwnd, int idDlg, int idIcon)
{
	if (hwnd == 0)
		hwnd = g_MessageContext.GetCurrentWindow();
	int cFail = SetButtonNames();
	m_idIcon = idIcon;
	int iRet = (int)DialogBoxParam(g_hInstance, MAKEINTRESOURCE(idDlg), hwnd, CMsiMessageBox::MsgBoxDlgProc, (LPARAM)this);
	return iRet;
}

void CMsiMessageBox::SetControlText(int idControl, HFONT hfont, const ICHAR* szText)
{
	if (hfont)
		WIN::SendDlgItemMessage(m_hDlg, idControl, WM_SETFONT, (WPARAM)hfont, MAKELPARAM(TRUE, 0));
	if (szText != 0)
	{
		int iCodepage = (hfont == m_hfontButton ? g_iButtonCodepage : m_iCodepage);
		if (iCodepage == 1256 || iCodepage == 1255)  // Arabic or Hebrew
		{
			LONG iStyle = WIN::GetWindowLong(GetDlgItem(m_hDlg, idControl) ,GWL_STYLE);
			LONG iExStyle = WIN::GetWindowLong(GetDlgItem(m_hDlg, idControl) ,GWL_EXSTYLE);

			// for a non-mirrored dialog, we need to move the control so that it is now right-justified and set the reading order to RTL
			// on a mirrored dialog, this is done automatically for us
			if (!m_fMirrored)
			{
				if ((iStyle & (WS_TABSTOP | SS_CENTER | SS_RIGHT)) == 0)  // left-justified static control
				{
					iExStyle |= WS_EX_RIGHT; // appears not to be needed in this case, as style is set below
					WIN::SetWindowLong(GetDlgItem(m_hDlg, idControl) ,GWL_STYLE, iStyle | SS_RIGHT);
				}
				if ((iStyle & CBS_HASSTRINGS) == 0) // no R to L reading order for List/Combo boxes (same as BS_RIGHT, which is not used)
					WIN::SetWindowLong(GetDlgItem(m_hDlg, idControl) ,GWL_EXSTYLE, iExStyle | WS_EX_RTLREADING);
			}
		}
		WIN::SetDlgItemText(m_hDlg, idControl, szText);
	}
}

// Set intial state and postion of message dialog and controls, including setting the focus.
void CMsiMessageBox::InitializeDialog()
{
	Assert(m_hDlg != 0);
	if (m_szCaption != 0)
		SetWindowText(m_hDlg, m_szCaption);

	m_hfontText = MsiCreateFont(m_iCodepage);
	HFONT hfontButton = 0;
	if (m_iCodepage == g_iButtonCodepage)
		hfontButton = m_hfontText;
	else
		hfontButton = m_hfontButton = MsiCreateFont(g_iButtonCodepage);

//	if (m_hfontText)  // doesn't seem necessary or effective to set font on dialog window
//		SendMessage(m_hDlg, WM_SETFONT, (WPARAM)m_hfontText, MAKELPARAM(TRUE, 0));
	SetControlText(IDC_MSGTEXT, m_hfontText, m_szText);

	for (UINT iid = 0; iid < 3; ++iid)
	{
		int idc = IDC_MSGBTN1 + iid;
		if (iid < m_cButtons)
		{
			SetControlText(idc, hfontButton, GetButtonName(m_rgidBtn[iid]));
			if (iid + 1 == m_iBtnDef)
			{
				PostMessage(m_hDlg, DM_SETDEFID, idc, 0);
				m_hwndFocus = GetDlgItem(m_hDlg, idc);
				PostMessage(m_hDlg, WM_NEXTDLGCTL, (WPARAM)m_hwndFocus, 1L);
			}
		}
		else
			ShowWindow(GetDlgItem(m_hDlg, idc), SW_HIDE);
	}
	
	// Some styles (YESNO, ABORTRETRYIGNORE) do not allow the user to cancel the dialog box.
	if (m_iBtnEsc == 0)
	{
		HMENU hmenu = GetSystemMenu(m_hDlg, FALSE);
		if (hmenu != 0)
			RemoveMenu(hmenu, SC_CLOSE, MF_BYCOMMAND);
	}

	// Call dialog-specific initialization
	InitSpecial();

	CenterMsgBox();
}

// Expand size of message box to fit the given message.
void CMsiMessageBox::SetMsgBoxSize()
{
	HWND hwnd = GetDlgItem(m_hDlg, IDC_MSGTEXT);
	Assert(hwnd != 0);
	RECT  rc, rcSav;
	GetWindowRect(hwnd, &rc);
	CopyRect(&rcSav, &rc);

	// Get rect size needed
	HDC hdc = GetDC(hwnd);
	/* dc block */
	if ( hdc )
	{
		// Select font into DC so correct size is used
		HFONT hfont = m_hfontText;
		HFONT hfontOld = 0;
		if (hfont == 0)
			hfont = (HFONT)SendMessage(m_hDlg, WM_GETFONT, 0, 0L);
		if (hfont)
			hfontOld = (HFONT)SelectObject(hdc, hfont);
		DrawText(hdc, m_szText, -1, &rc, DT_CALCRECT | DT_NOCLIP | DT_NOPREFIX | DT_WORDBREAK | DT_EXPANDTABS);
#ifdef DEBUG
			ICHAR szFacename[LF_FACESIZE];
			TEXTMETRIC tmTmp;
			GetTextMetrics(hdc, &tmTmp);
			GetTextFace(hdc, sizeof(szFacename)/sizeof(szFacename[0]), szFacename);
			// DBGLOG:printf(TEXT("Font used: %s  Charset: %i\n"), szFacename, tmTmp.tmCharSet);
#endif
		if (hfont)
			SelectObject(hdc, hfontOld);

		ReleaseDC(hwnd, hdc);
	}

	Assert(rc.top  == rcSav.top);
	Assert(rc.left == rcSav.left);

	int   dxRect, dyRect, dx, dy;
	dxRect = rc.right  - rcSav.right;
	dyRect = rc.bottom - rcSav.bottom;

	// Dialog Rect
	POINT pt;
	GetWindowRect(m_hDlg, &rcSav);
	dx = rcSav.right - rcSav.left + ((dxRect > 0) ? dxRect : 0);
	dy = rcSav.bottom - rcSav.top + ((dyRect > 0) ? dyRect : 0);
	pt.x = rcSav.left;
	pt.y = rcSav.top;

	// KLUDGE: Check against screen size (ctl3d.dll limit?)
	{
		int dxScr = GetSystemMetrics(SM_CXSCREEN);
		int dyScr = GetSystemMetrics(SM_CYSCREEN);
		if (dx > dxScr)
		{
			int ddx = dx - dxScr;
			rc.right -= ddx;
			dxRect -= ddx;
			dx = dxScr;
		}
		if (dy > dyScr)
		{
			int ddy = dy - dyScr;
			rc.bottom -= ddy;
			dyRect -= ddy;
			dy = dyScr;
		}
	}
	SetWindowPos(m_hDlg, NULL, pt.x, pt.y, dx, dy, SWP_NOZORDER);

	// Text Control
	MapWindowPoints(NULL, m_hDlg, (LPPOINT) &rc, 2); // convert dialog screen coordinates to client coordinates, careful of mirroring
	pt.x = rc.left;
	pt.y = rc.top + ((dyRect < 0) ? (0 - dyRect) >> 1 : 0);
	if (dxRect < 0)
	{
		GetClientRect(m_hDlg, &rcSav);
		MapWindowPoints(NULL, m_hDlg, (LPPOINT) &rcSav, 2); // convert dialog screen coordinates to client coordinates, careful of mirroring
		dx = ((rcSav.right - rcSav.left) >> 1) - ((rc.right - rc.left) >> 1);
		if (dx > pt.x)
			pt.x = dx;
	}
	SetWindowPos(GetDlgItem(m_hDlg, IDC_MSGTEXT), NULL, pt.x, pt.y,
		rc.right - rc.left, rc.bottom - rc.top, SWP_NOZORDER);

	// Button Controls
	dx = (dxRect > 0) ? dxRect >> 1 : 0;
	dy = (dyRect > 0) ? dyRect : 0;
	for (int idc = IDC_MSGBTN1; idc <= IDC_MSGBTN3; ++idc)
	{
		HWND hwnd = GetDlgItem(m_hDlg, idc);
		Assert(hwnd != 0);
		GetWindowRect(hwnd, &rc);
		MapWindowPoints(NULL, m_hDlg, (LPPOINT) &rc, 2); // convert screen coordinates to client coordinates, careful of mirroring
		pt.x = rc.left + dx;
		pt.y = rc.top  + dy;
		SetWindowPos(hwnd, NULL, pt.x, pt.y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
	}
}

void MoveButton(HWND /*hDlg*/, HWND hBtn, LONG x, LONG y)
{
	POINT pt = {x, y};
	WIN::SetWindowPos(hBtn, NULL, pt.x, pt.y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}

// Fix horizontal position of message box push-buttons
void CMsiMessageBox::AdjustButtons()
{
	HWND  hwndBtn1 = GetDlgItem(m_hDlg, IDC_MSGBTN1);
	HWND  hwndBtn2 = GetDlgItem(m_hDlg, IDC_MSGBTN2);
	HWND  hwndBtn3 = GetDlgItem(m_hDlg, IDC_MSGBTN3);
	RECT  rcBtn1;
	RECT  rcBtn2;
	RECT  rcBtn3;
	// on a mirrored dialog, the buttons have already been switched for us so we don't need to swap them
	// mirroring is only supported on Win2K and above
	bool fBiDi = (!MinimumPlatformWindows2000() && (g_iButtonCodepage == 1256 || g_iButtonCodepage == 1255));

	if (m_cButtons == 1)
	{
		WIN::GetWindowRect(hwndBtn2, &rcBtn2);
		WIN::MapWindowPoints(NULL, m_hDlg, (LPPOINT) &rcBtn2, 2); 
		MoveButton(m_hDlg, hwndBtn1, rcBtn2.left, rcBtn2.top);
	}
	else if (m_cButtons == 2)
	{
		WIN::GetWindowRect(hwndBtn1, &rcBtn1);
		WIN::MapWindowPoints(NULL, m_hDlg, (LPPOINT) &rcBtn1, 2);
		WIN::GetWindowRect(hwndBtn2, &rcBtn2);
		WIN::MapWindowPoints(NULL, m_hDlg, (LPPOINT) &rcBtn2, 2);
		Assert(rcBtn1.left < rcBtn2.left);
		int dx = (rcBtn2.left - rcBtn1.left) >> 1;
		if (fBiDi)  // if right-to-left, swap buttons 1 & 2
		{
			hwndBtn3 = hwndBtn1;
			hwndBtn1 = hwndBtn2;
			hwndBtn2 = hwndBtn3;
		}
		MoveButton(m_hDlg, hwndBtn1, rcBtn1.left + dx, rcBtn1.top);
		MoveButton(m_hDlg, hwndBtn2, rcBtn2.left + dx, rcBtn2.top);
	}
	else if (fBiDi) // m_cButtons == 3
	{
		WIN::GetWindowRect(hwndBtn1, &rcBtn1);
		WIN::MapWindowPoints(NULL, m_hDlg, (LPPOINT) &rcBtn1, 2);
		WIN::GetWindowRect(hwndBtn3, &rcBtn3);
		WIN::MapWindowPoints(NULL, m_hDlg, (LPPOINT) &rcBtn3, 2);
		MoveButton(m_hDlg, hwndBtn1, rcBtn3.left, rcBtn3.top);
		MoveButton(m_hDlg, hwndBtn3, rcBtn1.left, rcBtn1.top);
 	}
}

// Message box dialog proc, returns TRUE if message used, generally
INT_PTR CALLBACK CMsiMessageBox::MsgBoxDlgProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
	UINT idControl;
	CMsiMessageBox* pMsgBox = 0;
	static unsigned int uQueryCancelAutoPlay = 0;

	switch (uiMsg)
	{
	case WM_INITDIALOG:
		if (!uQueryCancelAutoPlay)
			uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));

		pMsgBox = (CMsiMessageBox*)lParam;
#ifdef _WIN64
		SetWindowLongPtr(hdlg, DWLP_USER, lParam);
#else			//!!merced: win-32. This should be removed with the 64-bit windows.h is #included.
		SetWindowLong(hdlg, DWL_USER, lParam);
#endif
		pMsgBox->m_hDlg = hdlg;
		pMsgBox->InitializeDialog();
		return FALSE;	// focus was set

	case WM_ACTIVATE:
#ifdef _WIN64
		pMsgBox = (CMsiMessageBox*)GetWindowLongPtr(hdlg, DWLP_USER);
#else			//!!merced: win-32. This should be removed with the 64-bit windows.h is #included.
		pMsgBox = (CMsiMessageBox*)GetWindowLong(hdlg, DWL_USER);
#endif // _WIN64
		if (LOWORD(wParam) == WA_INACTIVE)
			pMsgBox->m_hwndFocus = GetFocus();
		else
		{
			if (pMsgBox->m_hwndFocus != 0)
				SetFocus(pMsgBox->m_hwndFocus);
		}
		return FALSE;	/* focus was set */

	case WM_COMMAND:
#ifdef _WIN64
		pMsgBox = (CMsiMessageBox*)GetWindowLongPtr(hdlg, DWLP_USER);
#else			//!!merced: win-32. This should be removed with the 64-bit windows.h is #included.
		pMsgBox = (CMsiMessageBox*)GetWindowLong(hdlg, DWL_USER);
#endif
		idControl = (WORD)wParam;
		if (idControl == IDCANCEL)   // handle escape key here (not cancel button)
		{
			if (pMsgBox->m_iBtnEsc == 0)  // if escape not allowed (YESNO, ABORTRETRYIGNORE)
				return FALSE;
			idControl = (WORD)(pMsgBox->m_iBtnEsc + IDC_MSGBTN1 - 1);
		}
		return pMsgBox->HandleCommand(idControl);
	}

	if (uiMsg && (uiMsg == uQueryCancelAutoPlay))
	{
		DEBUGMSGD("Cancelling AutoPlay");
#ifdef _WIN64
		SetWindowLongPtr(hdlg, DWLP_MSGRESULT, 1);
#else
		SetWindowLong(hdlg, DWL_MSGRESULT, 1);
#endif // _WIN64
		return TRUE;
	}

	return FALSE;
}

// Centers the given dialog on the screen
void CMsiMessageBox::CenterMsgBox()
{
	RECT rcScreen;
	if (!WIN::SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, 0))
	{
		rcScreen.left   = 0;
		rcScreen.top    = 0;
		rcScreen.right  = WIN::GetSystemMetrics(SM_CXSCREEN);
		rcScreen.bottom = WIN::GetSystemMetrics(SM_CYSCREEN);
	}
	RECT rcDialog;
	AssertNonZero(WIN::GetWindowRect(m_hDlg, &rcDialog));
	int iDialogWidth = rcDialog.right - rcDialog.left;
	int iDialogHeight = rcDialog.bottom - rcDialog.top;
	AssertNonZero(WIN::MoveWindow(m_hDlg, rcScreen.left + (rcScreen.right - rcScreen.left - iDialogWidth)/2, rcScreen.top + (rcScreen.bottom - rcScreen.top - iDialogHeight)/2, iDialogWidth, iDialogHeight, TRUE));
}


// classes used in engine.cpp and execute.cpp to enumerate, globally, component clients

CEnumUsers::CEnumUsers(cetEnumType cetArg): m_iUser(0), m_cetEnumType(cetArg) // simply initialize the enumeration type
{
}

DWORD CEnumUsers::Next(const IMsiString*& ristrUserId)
{
	DWORD dwResult = ERROR_SUCCESS;

	if(g_fWin9X)
	{
		// we have single global location for Win9x
		if(!m_iUser)
			ristrUserId = &g_MsiStringNull;
		else
			dwResult = ERROR_NO_MORE_ITEMS; // end of enumeration
	}
	else
	{
		if(m_cetEnumType == cetAll)
		{
			if(m_hUserDataKey == 0)// key not opened as yet
			{
				Assert(m_iUser == 0);
				dwResult = MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE, szMsiUserDataKey, 0, g_samRead, &m_hUserDataKey);
				if (ERROR_SUCCESS != dwResult)
					return dwResult;
			}
			ICHAR szUserId[cchMaxSID + 1];
			DWORD cchKey = cchMaxSID + 1;
			dwResult = RegEnumKeyEx(m_hUserDataKey, m_iUser, szUserId, &cchKey, 0, 0, 0, 0);
			if(dwResult == ERROR_SUCCESS)
				ristrUserId->SetString(szUserId, ristrUserId);
		}
		else if(m_cetEnumType == cetVisibleToUser)
		{
			// we enumerate the user and the machine hives
			if(!m_iUser)
				dwResult = GetCurrentUserStringSID(ristrUserId);
			else if(m_iUser == 1)
				ristrUserId->SetString(szLocalSystemSID, ristrUserId);
			else
				dwResult = ERROR_NO_MORE_ITEMS; // end of enumeration

		}
		else if(m_cetEnumType == cetAssignmentTypeUser)
		{
			// we enumerate only that hive that corresponds to the user assignemt type
			if(!m_iUser)
				dwResult = GetCurrentUserStringSID(ristrUserId);
			else
				dwResult = ERROR_NO_MORE_ITEMS; // end of enumeration
		}
		else
		{
			// we enumerate only that hive that corresponds to the machine assignemt type
			Assert(m_cetEnumType == cetAssignmentTypeMachine);
			if(!m_iUser)
				ristrUserId->SetString(szLocalSystemSID, ristrUserId);
			else
				dwResult = ERROR_NO_MORE_ITEMS; // end of enumeration
		}
	}
	m_iUser++;
	return dwResult;
}


CEnumComponentClients::CEnumComponentClients(const IMsiString& ristrUserId, const IMsiString& ristrComponent):m_iClient(0)
{
	ristrUserId.AddRef();
	m_strUserId = ristrUserId;
	ristrComponent.AddRef();
	m_strComponent = ristrComponent;

}

DWORD CEnumComponentClients::Next(const IMsiString*& ristrProductKey)
{
	DWORD dwResult = ERROR_SUCCESS;
	if(m_hComponentKey == 0) // key not opened as yet
	{
		CRegHandle hUserDataKey;
		ICHAR szUserDataKey[cchMaxSID + sizeof(szMsiUserDataKey)/sizeof(ICHAR) + 2];
		if(g_fWin9X)
		{
			// open the global Installer key
			StringCchCopy(szUserDataKey, (sizeof(szUserDataKey)/sizeof(ICHAR)), szMsiLocalInstallerKey);
		}
		else
			StringCchPrintf(szUserDataKey, (sizeof(szUserDataKey)/sizeof(ICHAR)), TEXT("%s\\%s"), szMsiUserDataKey, (const ICHAR*)m_strUserId);
		dwResult = MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE, szUserDataKey, 0, g_samRead, &hUserDataKey);
		if (ERROR_SUCCESS != dwResult)
			return dwResult;

		// check for the specific component key 
		// generate the appr, components subkey
		CAPITempBuffer<ICHAR, 1> rgchSubKey;
		if (!rgchSubKey.SetSize(MAX_PATH))
			return ERROR_OUTOFMEMORY;
		ICHAR szComponentSQUID[cchGUIDPacked + 1];
		AssertNonZero(PackGUID(m_strComponent, szComponentSQUID));
		if (FAILED(StringCchPrintf(rgchSubKey, rgchSubKey.GetSize(), TEXT("%s\\%s"), szMsiComponentsSubKey, szComponentSQUID)))
			return ERROR_FUNCTION_FAILED;
		dwResult = MsiRegOpen64bitKey(hUserDataKey, rgchSubKey, 0, g_samRead, &m_hComponentKey);
		if (ERROR_SUCCESS != dwResult)
			return dwResult;
	}

	// now get the next enumeration
	ICHAR szProductSQUID[cchGUIDPacked + 1];
	ICHAR szProduct[cchGUID + 1];
	DWORD cchName = cchGUIDPacked + 1;
	dwResult = RegEnumValue(m_hComponentKey, m_iClient++, szProductSQUID, &cchName, 0, 0, 0, 0);
	if (ERROR_SUCCESS != dwResult) // end of products
		return dwResult;
	AssertNonZero(UnpackGUID(szProductSQUID,szProduct));
	ristrProductKey->SetString(szProduct, ristrProductKey);
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\ptchmgmt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 2000
//
//  File:       ptchmgmt.cpp
//
//--------------------------------------------------------------------------

/* ptchmgmt.cpp - Patch management implementation
____________________________________________________________________________*/

#include "precomp.h"
#include "_msiutil.h"
#include "_msinst.h"
#include "_engine.h"
#include "tables.h"


// the starting DiskID and Sequence values for patches - used during post-transform fixup
const int iMinPatchDiskID   =   100;
const int iMinPatchSequence = 10000;


// Error return macros
#define RETURN_ERROR_RECORD(function)   \
{							                   \
	IMsiRecord* piError;	                \
	piError = function;		             \
	if(piError) return piError;          \
}

#define ERROR_IF_NULL(x)                                  \
{                                                         \
	if(x == iMsiNullInteger)                               \
	{                                                      \
		return PostError(Imsg(idbgInvalidPatchTransform));  \
	}                                                      \
}

#define ERROR_IF_NULL_OR_ZERO(x)                          \
{                                                         \
	int i = x;                                            \
	if(i == iMsiStringBadInteger || i == 0)                \
	{                                                      \
		return PostError(Imsg(idbgInvalidPatchTransform));  \
	}                                                      \
}

#define ERROR_IF_FALSE(x)                                 \
{                                                         \
	if(false == (x))                                       \
	{                                                      \
		return PostError(Imsg(idbgInvalidPatchTransform));  \
	}                                                      \
}


// prefix for patch source properties (from Media.Source column)
const ICHAR szMspSrcPrefix[] = TEXT("MSPSRC");
const int cchPrefix = 6;

// PatchIDToSourceProp: converts a PatchID guid to a property name
const IMsiString& PatchIDToSourceProp(const ICHAR* szPatchID)
{
	MsiString strSourceProp;
	if(szPatchID && *szPatchID)
	{
		ICHAR rgchBuffer[cchGUIDPacked+cchPrefix+1] = {0};
		StringCchCopy(rgchBuffer, sizeof(rgchBuffer)/sizeof(ICHAR), szMspSrcPrefix);
		if(PackGUID(szPatchID, rgchBuffer+cchPrefix, ipgTrimmed))
		{
			rgchBuffer[cchGUIDPacked+cchPrefix] = 0;
			strSourceProp = rgchBuffer;
		}
	}

	return strSourceProp.Return();
}


// LoadTableAndCursor: helper function to load a table and get column indicies
IMsiRecord* LoadTableAndCursor(IMsiDatabase& riDatabase, const ICHAR* szTable,
										 bool fFailIfTableMissing, bool fUpdatableCursor,
										 IMsiTable*& rpiTable, IMsiCursor*& rpiCursor,
										 const ICHAR* szColumn1, int* piColumn1,
										 const ICHAR* szColumn2, int* piColumn2)
{
	Assert(szTable && *szTable);

	rpiTable = 0;
	rpiCursor = 0;
	if(piColumn1)
		*piColumn1 = 0;
	if(piColumn2)
		*piColumn2 = 0;

	IMsiRecord* piError = 0;
	
	if ((piError = riDatabase.LoadTable(*MsiString(szTable),0,rpiTable)))
	{
		if(!fFailIfTableMissing && (piError->GetInteger(1) == idbgDbTableUndefined))
		{
			piError->Release();
			return 0; // missing table will be indicated by NULL table and cursor pointers
		}
		else
		{
			return piError;
		}
	}

	bool fColumnError = false;
	
	if(szColumn1 && *szColumn1 && piColumn1)
	{
		*piColumn1 = rpiTable->GetColumnIndex(riDatabase.EncodeStringSz(szColumn1));

		if(!(*piColumn1))
			fColumnError = true;
	}

	if(szColumn2 && *szColumn2 && piColumn2)
	{
		*piColumn2 = rpiTable->GetColumnIndex(riDatabase.EncodeStringSz(szColumn2));

		if(!(*piColumn2))
			fColumnError = true;
	}

	if(fColumnError)
		return PostError(Imsg(idbgTableDefinition), szTable);
		
	rpiCursor = rpiTable->CreateCursor(fUpdatableCursor ? ictUpdatable : fFalse);

	return 0;
}

//____________________________________________________________________________
//
// CGenericTable, CMediaTable, CFileTable, CPatchTable, CPatchPackageTable
//
// these classes abstract Cursor access to the tables used by transform fixup
//____________________________________________________________________________

class CGenericTable
{
public:
	CGenericTable(const ICHAR* szTableName) : m_piCursor(0), m_fUpdatedTable(false), m_szTableName(szTableName) {}
	~CGenericTable() { Release(); }
	void Release();
	bool Next()      { Assert(m_piCursor); return m_piCursor->Next() ? true : false; }

	unsigned int RowCount();
	void ResetFilter();
	void SetFilter(int col);
	void FilterOnIntColumn(int col, int iData);
	void FilterOnStringColumn(int col, const IMsiString& ristrData);
	bool UpdateIntegerColumn(int col, int iData, bool fPrimaryKeyUpdate);
	bool UpdateStringColumn(int col, const IMsiString& ristrData, bool fPrimaryKeyUpdate);

protected:
	IMsiCursor* m_piCursor;
	bool m_fUpdatedTable;
	const ICHAR* m_szTableName;
};

void CGenericTable::Release()
{
	if(m_piCursor && m_szTableName && *m_szTableName && m_fUpdatedTable)
	{
		AssertNonZero((PMsiDatabase(&(PMsiTable(&m_piCursor->GetTable())->GetDatabase()))->LockTable(*MsiString(m_szTableName), fTrue)));
	}

	if(m_piCursor)
	{
		m_piCursor->Release();
		m_piCursor = 0;
	}

	m_fUpdatedTable = false;
}

unsigned int CGenericTable::RowCount()
{
	if(m_piCursor)
		return PMsiTable(&m_piCursor->GetTable())->GetRowCount();
	else
		return 0;
}

void CGenericTable::ResetFilter()
{
	Assert(m_piCursor);
	m_piCursor->Reset();
	m_piCursor->SetFilter(0);
}

void CGenericTable::SetFilter(int col)
{
	Assert(m_piCursor);
	m_piCursor->Reset();
	m_piCursor->SetFilter(iColumnBit(col));
}

void CGenericTable::FilterOnIntColumn(int col, int iData)
{
	Assert(m_piCursor);
	SetFilter(col);
	AssertNonZero(m_piCursor->PutInteger(col, iData));
}

bool CGenericTable::UpdateIntegerColumn(int col, int iData, bool fPrimaryKeyUpdate)
{
	Assert(m_piCursor);
	AssertNonZero(m_piCursor->PutInteger(col, iData));
	if(fPrimaryKeyUpdate ? m_piCursor->Replace() : m_piCursor->Update())
		return m_fUpdatedTable = true, true;
	else
		return false;
}

void CGenericTable::FilterOnStringColumn(int col, const IMsiString& ristrData)
{
	Assert(m_piCursor);
	SetFilter(col);
	AssertNonZero(m_piCursor->PutString(col, ristrData));
}

bool CGenericTable::UpdateStringColumn(int col, const IMsiString& ristrData, bool fPrimaryKeyUpdate)
{
	Assert(m_piCursor);
	AssertNonZero(m_piCursor->PutString(col, ristrData));
	if(fPrimaryKeyUpdate ? m_piCursor->Replace() : m_piCursor->Update())
		return m_fUpdatedTable = true, true;
	else
		return false;
}


class CMediaTable : public CGenericTable
{
public:
	CMediaTable()
		: CGenericTable(sztblMedia), colDiskID(0), colLastSequence(0), colSourceProp(0), colOldSourceProp(0) {}
	IMsiRecord* Initialize(IMsiDatabase& riDatabase, bool fFailIfTableMissing);
	int GetDiskID()       { Assert(m_piCursor); return m_piCursor->GetInteger(colDiskID); }
	int GetLastSequence() { Assert(m_piCursor); return m_piCursor->GetInteger(colLastSequence); }
	const IMsiString& GetSourceProp();
	void FilterOnDiskID(int iDiskID) { FilterOnIntColumn(colDiskID, iDiskID); }
	bool UpdateDiskID(int iDiskID) { return UpdateIntegerColumn(colDiskID, iDiskID, true); }
	bool UpdateDiskIDAndLastSequence(int iDiskID, int iLastSequence);
	bool UpdateSourceProp(const IMsiString& ristrNewSourceProp, const IMsiString& ristrOldSourceProp);

private:
	int colDiskID;
	int colLastSequence;
	int colSourceProp;
	int colOldSourceProp;
};

IMsiRecord* CMediaTable::Initialize(IMsiDatabase& riDatabase, bool fFailIfTableMissing)
{
	PMsiTable pTable(0);
	IMsiRecord* piError = LoadTableAndCursor(riDatabase, sztblMedia,
										  fFailIfTableMissing, true,
										  *&pTable, m_piCursor,
										  sztblMedia_colDiskID, &colDiskID,
										  sztblMedia_colLastSequence, &colLastSequence);
	if(piError)
		return piError;

	if(pTable)
	{
		// non-required columns
		colSourceProp = pTable->GetColumnIndex(riDatabase.EncodeStringSz(sztblMedia_colSource));
		
		// added columns
		if(colSourceProp)
		{
			colOldSourceProp = pTable->GetColumnIndex(riDatabase.EncodeStringSz(sztblMedia_colOldSource));
			if(!colOldSourceProp)
			{
				colOldSourceProp = pTable->CreateColumn(icdString + icdNullable, *MsiString(*sztblMedia_colOldSource));
				Assert(colOldSourceProp);
			}
		}
	}

	return 0;
}

const IMsiString& CMediaTable::GetSourceProp()
{
	Assert(m_piCursor);
	MsiString strTemp;
	if(colSourceProp)
		strTemp = m_piCursor->GetString(colSourceProp);
	return strTemp.Return();
}
	
bool CMediaTable::UpdateDiskIDAndLastSequence(int iDiskID, int iLastSequence)
{
	Assert(m_piCursor);
	m_fUpdatedTable = true;
	AssertNonZero(m_piCursor->PutInteger(colDiskID, iDiskID));
	AssertNonZero(m_piCursor->PutInteger(colLastSequence, iLastSequence));
	if(m_piCursor->Replace())
		return m_fUpdatedTable = true, true;
	else
		return false;
}

bool CMediaTable::UpdateSourceProp(const IMsiString& ristrNewSourceProp, const IMsiString& ristrOldSourceProp)
{
	Assert(m_piCursor);
	
	if(!colSourceProp || !colOldSourceProp)
		return false;
	
	AssertNonZero(m_piCursor->PutString(colSourceProp,    ristrNewSourceProp));
	AssertNonZero(m_piCursor->PutString(colOldSourceProp, ristrOldSourceProp));

	if(m_piCursor->Update())
		return m_fUpdatedTable = true, true;
	else
		return false;
}


class CFileTable : public CGenericTable
{
public:
	CFileTable()
		: CGenericTable(sztblFile), colKey(0), colSequence(0) {}
	IMsiRecord* Initialize(IMsiDatabase& riDatabase, bool fFailIfTableMissing);
	const IMsiString& GetKey() { return m_piCursor->GetString(colKey); }
	int GetSequence() { return m_piCursor->GetInteger(colSequence); }

	void FilterOnKey(const IMsiString& ristrKey) { FilterOnStringColumn(colKey, ristrKey); }
	bool UpdateSequence(int iSequence) { return UpdateIntegerColumn(colSequence, iSequence, false); }

private:
	int colKey;
	int colSequence;
};

IMsiRecord* CFileTable::Initialize(IMsiDatabase& riDatabase, bool fFailIfTableMissing)
{
	PMsiTable pTable(0);
	return LoadTableAndCursor(riDatabase, sztblFile,
										  fFailIfTableMissing, true,
										  *&pTable, m_piCursor,
										  sztblFile_colFile, &colKey,
										  sztblFile_colSequence, &colSequence);
}


class CPatchTable : public CGenericTable
{
public:
	CPatchTable()
		: CGenericTable(sztblPatch), colFileKey(0), colSequence(0) {}
	IMsiRecord* Initialize(IMsiDatabase& riDatabase, bool fFailIfTableMissing);

	void FilterOnSequence(int iSequence) { FilterOnIntColumn(colSequence, iSequence); };
	void FilterOnKeyAndSequence(const IMsiString& ristrKey, int iSequence);

	int GetKey() { return m_piCursor->GetInteger(colFileKey); }
	int GetSequence() { return m_piCursor->GetInteger(colSequence); }
	bool UpdateFileKey(const IMsiString& ristrFileKey) { return UpdateStringColumn(colFileKey, ristrFileKey, true); }
	bool UpdateSequence(int iSequence) { return UpdateIntegerColumn(colSequence, iSequence, true); }

private:
	int colFileKey;
	int colSequence;
};

IMsiRecord* CPatchTable::Initialize(IMsiDatabase& riDatabase, bool fFailIfTableMissing)
{
	PMsiTable pTable(0);
	return LoadTableAndCursor(riDatabase, sztblPatch,
										  fFailIfTableMissing, true,
										  *&pTable, m_piCursor,
										  sztblPatch_colFile, &colFileKey,
										  sztblPatch_colSequence, &colSequence);
}

void CPatchTable::FilterOnKeyAndSequence(const IMsiString& ristrKey, int iSequence)
{
	Assert(m_piCursor);
	m_piCursor->Reset();
	m_piCursor->SetFilter(iColumnBit(colFileKey) | iColumnBit(colSequence));
	AssertNonZero(m_piCursor->PutString(colFileKey, ristrKey));
	AssertNonZero(m_piCursor->PutInteger(colSequence, iSequence));
}


class CPatchPackageTable : public CGenericTable
{
public:
	CPatchPackageTable()
		: CGenericTable(sztblPatchPackage), colPatchID(0), colDiskID(0) {}
	IMsiRecord* Initialize(IMsiDatabase& riDatabase, bool fFailIfTableMissing);

	const IMsiString& GetPatchID() { return m_piCursor->GetString(colPatchID); }
	int GetDiskID() { return m_piCursor->GetInteger(colDiskID); }
	void FilterOnDiskID(int iDiskID) { FilterOnIntColumn(colDiskID, iDiskID); }
	bool UpdateDiskID(int iDiskID) { return UpdateIntegerColumn(colDiskID, iDiskID, false); }

private:
	int colPatchID;
	int colDiskID;
};

IMsiRecord* CPatchPackageTable::Initialize(IMsiDatabase& riDatabase, bool fFailIfTableMissing)
{
	PMsiTable pTable(0);
	return LoadTableAndCursor(riDatabase, sztblPatchPackage,
										  fFailIfTableMissing, true,
										  *&pTable, m_piCursor,
										  sztblPatchPackage_colMedia, &colDiskID,
										  sztblPatchPackage_colPatchId, &colPatchID);
}

	
bool ReleaseTransformViewTable(IMsiDatabase& riDatabase)
{
	// first check if table exists
	if(riDatabase.GetTableState(sztblTransformViewPatch, itsTableExists))
	{
		return riDatabase.LockTable(*MsiString(sztblTransformViewPatch), fFalse) ? true : false;
	}
	else
	{
		return true;
	}
}
	
IMsiRecord* LoadTransformViewTable(IMsiDatabase& riDatabase, IMsiStorage& riTransform,
													 int iErrorConditions, IMsiCursor*& rpiTransViewCursor)
{
	// first, release table if its already there
	if(false == ReleaseTransformViewTable(riDatabase))
	{
		// will not recieve predictable results if a table by this name already exists
		return PostError(Imsg(idbgDbTableDefined), sztblTransformViewPatch);
	}
	
	Assert(riDatabase.GetTableState(sztblTransformViewPatch, itsTableExists) == fFalse);
	
	PMsiRecord pTheseTablesOnlyRec = &(::CreateRecord(4));
	Assert(pTheseTablesOnlyRec);
	AssertNonZero(pTheseTablesOnlyRec->SetString(1, sztblMedia));
	AssertNonZero(pTheseTablesOnlyRec->SetString(2, sztblFile));
	AssertNonZero(pTheseTablesOnlyRec->SetString(3, sztblPatchPackage));
	AssertNonZero(pTheseTablesOnlyRec->SetString(4, sztblPatch));

	IMsiRecord* piError = riDatabase.SetTransformEx(riTransform, iErrorConditions|iteViewTransform,
														sztblTransformViewPatch, pTheseTablesOnlyRec);
	if(piError == 0)
	{
		PMsiTable pTransViewTable(0);
		piError = LoadTableAndCursor(riDatabase, sztblTransformViewPatch,
											  true, false,
											  *&pTransViewTable, rpiTransViewCursor,
											  0, 0, 0, 0);
	}

	if(piError)
		AssertNonZero(ReleaseTransformViewTable(riDatabase)); // don't need to fail here

	return piError;
}


IMsiRecord* GetCurrentMinAndMaxPatchDiskID(CMediaTable& tblMediaTable, CPatchPackageTable& tblPatchPackageTable,
														 int& iCurrentMinPatchDiskID, int& iCurrentMaxPatchDiskID)
{
	if(iCurrentMinPatchDiskID && iCurrentMaxPatchDiskID)
	{
		// already set - nothing to do
		return 0;
	}
		
	if(0 == tblMediaTable.RowCount())
	{
		iCurrentMinPatchDiskID = iMinPatchDiskID;
		iCurrentMaxPatchDiskID = iMinPatchDiskID - 1;
		return 0;
	}

	// if one value is set while the other isn't, we'll go ahead and recalculate both
	iCurrentMinPatchDiskID = INT_MAX;
	iCurrentMaxPatchDiskID = 0;
	
	if(tblPatchPackageTable.RowCount())
	{
		// can determine min and max values from PatchPackage table alone
		
		tblPatchPackageTable.ResetFilter();
		while(tblPatchPackageTable.Next())
		{
			int iTemp = tblPatchPackageTable.GetDiskID();
			ERROR_IF_NULL_OR_ZERO(iTemp);

			if(iTemp < iMinPatchDiskID)
				return PostError(Imsg(idbgInvalidPatchTransform));

			if(iCurrentMinPatchDiskID > iTemp)
				iCurrentMinPatchDiskID = iTemp;

			if(iCurrentMaxPatchDiskID < iTemp)
				iCurrentMaxPatchDiskID = iTemp;
		}

		return 0;
	}

	// need to determine from Media table

	// min Patch DiskID is the maximum of
	//  a) the maximum non-patch DiskID + 1
	//  b) iMinPatchDiskID
	
	iCurrentMinPatchDiskID = iMinPatchDiskID;
	tblMediaTable.ResetFilter();
	while(tblMediaTable.Next())
	{
		int iTemp = tblMediaTable.GetDiskID();
		ERROR_IF_NULL_OR_ZERO(iTemp);

		if(iCurrentMinPatchDiskID <= iTemp)
			iCurrentMinPatchDiskID = iTemp + 1;
	}

	// max Patch DiskID is the min value -1
	iCurrentMaxPatchDiskID = iCurrentMinPatchDiskID - 1;

	return 0;
}

IMsiRecord* GetCurrentMinAndMaxPatchSequence(CMediaTable& tblMediaTable, int iCurrentMinPatchDiskID,
															int& iCurrentMinPatchSequence, int& iCurrentMaxPatchSequence)
{
	if(iCurrentMinPatchSequence && iCurrentMaxPatchSequence)
	{
		// already set - nothing to do
		return 0;
	}
		
	if(0 == tblMediaTable.RowCount())
	{
		iCurrentMinPatchSequence = iMinPatchSequence;
		iCurrentMaxPatchSequence = iMinPatchSequence - 1;
		return 0;
	}

	iCurrentMinPatchSequence = iMinPatchSequence;
	iCurrentMaxPatchSequence = iMinPatchSequence - 1;

	
	tblMediaTable.ResetFilter();
	while(tblMediaTable.Next())
	{
		int iTempDiskID       = tblMediaTable.GetDiskID();
		ERROR_IF_NULL_OR_ZERO(iTempDiskID);
		int iTempLastSequence = tblMediaTable.GetLastSequence();
		ERROR_IF_NULL(iTempLastSequence);

		if(iTempDiskID < iCurrentMinPatchDiskID) // non-patch Media entry
		{
			if(iTempLastSequence+1 > iCurrentMinPatchSequence)
			{
				iCurrentMinPatchSequence = iTempLastSequence+1;
			}
			if(iTempLastSequence+1 > iCurrentMaxPatchSequence)
			{
				iCurrentMaxPatchSequence = iTempLastSequence+1;
			}
		}
		else                                     // patch Media entry
		{
			if(iTempLastSequence > iCurrentMaxPatchSequence)
			{
				iCurrentMaxPatchSequence = iTempLastSequence;
			}
		}
	}

	return 0;
}

IMsiRecord* GetMinMaxPatchValues(CMediaTable& tblMediaTable, CPatchPackageTable& tblPatchPackageTable,
											int& iCurrentMinPatchDiskID, int& iCurrentMaxPatchDiskID,
											int& iCurrentMinPatchSequence, int& iCurrentMaxPatchSequence)
{
	if(iCurrentMinPatchDiskID == 0 || iCurrentMaxPatchDiskID == 0)
	{
		RETURN_ERROR_RECORD(GetCurrentMinAndMaxPatchDiskID(tblMediaTable, tblPatchPackageTable,
																			iCurrentMinPatchDiskID, iCurrentMaxPatchDiskID));
		
	}

	Assert(iCurrentMinPatchDiskID >= iMinPatchDiskID);
	Assert(iCurrentMaxPatchDiskID >= (iCurrentMinPatchDiskID - 1));

	DEBUGMSG3(TEXT("TRANSFORM: The minimum '%s.%s' value inserted by a patch transform is %d"),
				 sztblMedia, sztblMedia_colDiskID, (const ICHAR*)(INT_PTR)iCurrentMinPatchDiskID);

	DEBUGMSG3(TEXT("TRANSFORM: The maximum '%s.%s' value inserted by a patch transform is %d"),
				 sztblMedia, sztblMedia_colDiskID, (const ICHAR*)(INT_PTR)iCurrentMaxPatchDiskID);

	if(iCurrentMinPatchSequence == 0 || iCurrentMaxPatchSequence == 0)
	{
		RETURN_ERROR_RECORD(GetCurrentMinAndMaxPatchSequence(tblMediaTable, iCurrentMinPatchDiskID,
																			  iCurrentMinPatchSequence, iCurrentMaxPatchSequence));
	}

	Assert(iCurrentMinPatchSequence >= iMinPatchSequence);
	Assert(iCurrentMaxPatchSequence >= (iCurrentMinPatchSequence - 1));

	DEBUGMSG5(TEXT("TRANSFORM: The minimum '%s.%s' or '%s.%s' value inserted by a patch transform is %d"),
				 sztblFile, sztblFile_colSequence, sztblPatch, sztblPatch_colSequence,
				 (const ICHAR*)(INT_PTR)iCurrentMinPatchSequence);

	DEBUGMSG5(TEXT("TRANSFORM: The maximum '%s.%s' or '%s.%s' value inserted by a patch transform is %d."),
				 sztblFile, sztblFile_colSequence, sztblPatch, sztblPatch_colSequence,
				 (const ICHAR*)(INT_PTR)iCurrentMaxPatchSequence);

	return 0;
}


//____________________________________________________________________________
//
// PrePackageTransformFixup: this fn called before applying a "normal" transform
//                           (any transform other than a '#' transform from a .msp)
//
//  The following steps are taken in this fn:
//
//    Step 0:  if PatchPackage table not here, there's nothing to do
//
//    Step 1:  verify that the transform is not adding any data to the Patch
//             or PatchPackage tables (remainder of the processing assumes this much)
//
//    Step 2:  determine if Media and File table modifications by this transform
//             will conflict with any existing Media and File entries added by
//             a patch transform
//
//         2a: determine maximum Media.DiskID added by this transform
//
//         2b: determine maximum Media.LastSequence added/updated by this transform
//             (should be the same as the max File.Sequence value)
//
//         2c: if not passed in, determine minimum Media.DiskID value added by a
//             patch transform
//
//         2d: if not passed in, determine minimum File.Sequence/Patch.Sequence value
//             added/updated by a patch transform
//
//    Step 3:  if max values from 2a/b > min values from 2c/d, modify DiskID and
//             Sequence values added by patch transforms so they are no colliding
//             with the ranges set by this transform
//____________________________________________________________________________

IMsiRecord* PrePackageTransformFixup(IMsiCursor& riTransViewCursor,
												 CMediaTable& tblMediaTable, CFileTable& tblFileTable,
												 CPatchTable& tblPatchTable, CPatchPackageTable& tblPatchPackageTable,
												 int& iCurrentMinPatchDiskID, int& iCurrentMaxPatchDiskID,
												 int& iCurrentMinPatchSequence, int& iCurrentMaxPatchSequence)
{
	// for non-patch Media entries, we won't modify the DiskID value added by the transform
	// but we do need to make sure the DiskID doesn't conflict with any existing DiskID belonging
	// to a patch Media entry

	IMsiRecord* piError = 0;
	
	//
	// STEP 0 - if PatchPackage table not here, there's nothing to do
	//

	if(0 == tblPatchPackageTable.RowCount())
	{
		DEBUGMSG1(TEXT("TRANSFORM: '%s' table is missing or empty.  No pre-transform fixup necessary."),
					 sztblPatchPackage);
		return 0;
	}

	//
	// STEP 1 - catch Patch or PatchPackage changes
	//

	riTransViewCursor.Reset();
	riTransViewCursor.SetFilter(iColumnBit(ctvTable) | iColumnBit(ctvColumn));
	AssertNonZero(riTransViewCursor.PutString(ctvTable,  *MsiString(*sztblPatch)));
	AssertNonZero(riTransViewCursor.PutString(ctvColumn, *MsiString(*sztvopInsert)));

	if(riTransViewCursor.Next())
	{
		DEBUGMSG1(TEXT("TRANSFORM: transform is invalid - regular transforms may not add rows to the '%s' table."), sztblPatch);
		return PostError(Imsg(idbgInvalidPatchTransform));
	}

	riTransViewCursor.Reset();
	AssertNonZero(riTransViewCursor.PutString(ctvTable,  *MsiString(*sztblPatchPackage)));
	AssertNonZero(riTransViewCursor.PutString(ctvColumn, *MsiString(*sztvopInsert)));

	if(riTransViewCursor.Next())
	{
		DEBUGMSG1(TEXT("TRANSFORM: transform is invalid - regular transforms may not add rows to the '%s' table."), sztblPatchPackage);
		return PostError(Imsg(idbgInvalidPatchTransform));
	}
	
	
	//
	// STEP 2a - determine max DiskID and File.Sequence added by this transform
	//

	int iMaxTransformDiskID       = -1;
	int iMaxTransformFileSequence = -1;
	
	riTransViewCursor.Reset();
	riTransViewCursor.SetFilter(iColumnBit(ctvTable) | iColumnBit(ctvColumn));
	AssertNonZero(riTransViewCursor.PutString(ctvTable,  *MsiString(*sztblMedia)));
	AssertNonZero(riTransViewCursor.PutString(ctvColumn, *MsiString(*sztvopInsert)));

	while(riTransViewCursor.Next())
	{
		int iTemp = MsiString(riTransViewCursor.GetString(ctvRow));
		ERROR_IF_NULL_OR_ZERO(iTemp);

		if(iMaxTransformDiskID < iTemp)
		{
			iMaxTransformDiskID = iTemp;
		}
	}

	for(int iPass=1; iPass <= 2; iPass++)
	{
		// first pass - look for Media.LastSequence values
		//              if there is one that's the max (or the authoring is screwed up)
		// second pass -look for File.Sequence values
		
		riTransViewCursor.Reset();
		if(iPass == 1)
		{
			AssertNonZero(riTransViewCursor.PutString(ctvTable,  *MsiString(*sztblMedia)));
			AssertNonZero(riTransViewCursor.PutString(ctvColumn, *MsiString(*sztblMedia_colLastSequence)));
		}
		else
		{
			AssertNonZero(riTransViewCursor.PutString(ctvTable,  *MsiString(*sztblFile)));
			AssertNonZero(riTransViewCursor.PutString(ctvColumn, *MsiString(*sztblFile_colSequence)));
		}

		while(riTransViewCursor.Next())
		{
			int iTemp = MsiString(riTransViewCursor.GetString(ctvData));
			ERROR_IF_NULL(iTemp);

			if(iMaxTransformFileSequence < iTemp)
			{
				iMaxTransformFileSequence = iTemp;
			}
		}

		if(iMaxTransformFileSequence >= 0)
			break;
	}

	if(iMaxTransformDiskID >= 0)
	{
		DEBUGMSG3(TEXT("TRANSFORM: The maximum '%s.%s' value inserted by this transform is %d."),
					 sztblMedia, sztblMedia_colDiskID, (const ICHAR*)(INT_PTR)iMaxTransformDiskID);
	}
	else
	{
		DEBUGMSG2(TEXT("TRANSFORM: This transform is not changing the '%s.%s' column.  No pre-transform fixup of this column is necessary."),
					 sztblMedia, sztblMedia_colDiskID);
	}

	if(iMaxTransformFileSequence>= 0)
	{
		DEBUGMSG5(TEXT("TRANSFORM: The maximum '%s.%s' or '%s.%s' value inserted by this transform is %d"),
					 sztblMedia, sztblMedia_colLastSequence, sztblFile, sztblFile_colSequence,
					 (const ICHAR*)(INT_PTR)iMaxTransformFileSequence);
	}
	else
	{
		DEBUGMSG4(TEXT("TRANSFORM: This transform not changing the '%s.%s' or '%s.%s' columns.  No pre-transform fixup of these columns is necessary."),
					 sztblMedia, sztblMedia_colLastSequence, sztblFile, sztblFile_colSequence);
	}

	if(iMaxTransformDiskID < 0 && iMaxTransformFileSequence < 0)
		return 0;


	//
	// STEP 2c - determine min/max patch values
	//

	RETURN_ERROR_RECORD(GetMinMaxPatchValues(tblMediaTable, tblPatchPackageTable,
											iCurrentMinPatchDiskID, iCurrentMaxPatchDiskID,
											iCurrentMinPatchSequence, iCurrentMaxPatchSequence));

	//
	// STEP 3 - determine offsets if any needed for patch DiskID and Sequence values
	//

	int iDiskIDOffset = 0, iSequenceOffset = 0;
	if(iCurrentMinPatchDiskID < iMaxTransformDiskID)
	{
		iDiskIDOffset = iMaxTransformDiskID - iCurrentMinPatchDiskID + 1;

		DEBUGMSG5(TEXT("TRANSFORM: To avoid collisions with this transform, modifying existing '%s' and '%s' table rows starting with '%s' value %d by offset %d"),
					 sztblMedia, sztblPatchPackage, sztblMedia_colDiskID,
					 (const ICHAR*)(INT_PTR)iCurrentMinPatchDiskID, (const ICHAR*)(INT_PTR)iDiskIDOffset);
	}

	if(iCurrentMinPatchSequence < iMaxTransformFileSequence)
	{
		iSequenceOffset = iMaxTransformFileSequence - iCurrentMinPatchSequence + 1;

		DEBUGMSG5(TEXT("TRANSFORM: To avoid collisions with this transform, modifying existing '%s' and '%s' table rows starting with '%s' value %d by offset %d"),
					 sztblFile, sztblPatch, sztblFile_colSequence,
					 (const ICHAR*)(INT_PTR)iCurrentMinPatchSequence, (const ICHAR*)(INT_PTR)iSequenceOffset);
	}
	
	if(0 == iDiskIDOffset && 0 == iSequenceOffset)
	{
		DEBUGMSG(TEXT("TRANSFORM: No collisions detected between this transform and existing data added by patch transforms.  No pre-transform fixup is necessary."));
		return 0;
	}

	// fix up Media table
	if(tblMediaTable.RowCount())
	{
		tblMediaTable.ResetFilter();
		
		// since we are updating the primary key, we will go through the update window from
		// largest to smallest DiskID.  this ensures that there won't be any conflicting rows
		// when adding a new DiskID
		for(int iTempDiskID = iCurrentMaxPatchDiskID; iTempDiskID >= iCurrentMinPatchDiskID; iTempDiskID--)
		{
			tblMediaTable.FilterOnDiskID(iTempDiskID);
			if(tblMediaTable.Next())
			{
				int iTempLastSequence = tblMediaTable.GetLastSequence();
				ERROR_IF_NULL(iTempLastSequence);

				ERROR_IF_FALSE(tblMediaTable.UpdateDiskIDAndLastSequence(iTempDiskID + iDiskIDOffset,
																							iTempLastSequence + iSequenceOffset));
			}
		}
	}

	// fix up PatchPackageTable
	if(iDiskIDOffset && tblPatchPackageTable.RowCount())
	{
		tblPatchPackageTable.ResetFilter();

		while(tblPatchPackageTable.Next())
		{
			int iTempDiskID = tblPatchPackageTable.GetDiskID();
			ERROR_IF_NULL_OR_ZERO(iTempDiskID);

			if(iTempDiskID < iCurrentMinPatchDiskID)
				return PostError(Imsg(idbgInvalidPatchTransform));

			ERROR_IF_FALSE(tblPatchPackageTable.UpdateDiskID(iTempDiskID + iDiskIDOffset));
		}
	}

	// fix up File table
	if(iSequenceOffset && tblFileTable.RowCount())
	{
		tblFileTable.ResetFilter();

		while(tblFileTable.Next())
		{
			int iTempSequence = tblFileTable.GetSequence();
			ERROR_IF_NULL(iTempSequence);

			if(iTempSequence >= iCurrentMinPatchSequence)
			{
				ERROR_IF_FALSE(tblFileTable.UpdateSequence(iTempSequence + iSequenceOffset));
			}
		}
	}

	// fix up Patch table
	if(iSequenceOffset && tblPatchTable.RowCount())
	{
		for(int iTempSequence = iCurrentMaxPatchSequence;
				  iTempSequence >= iCurrentMinPatchSequence;
				  iTempSequence--)
		{
			tblPatchTable.FilterOnSequence(iTempSequence);
			
			if(tblPatchTable.Next())
			{
				ERROR_IF_FALSE(tblPatchTable.UpdateSequence(iTempSequence + iSequenceOffset));
			}
		}
	}

	iCurrentMinPatchDiskID   += iDiskIDOffset;
	iCurrentMinPatchSequence += iSequenceOffset;

	iCurrentMaxPatchDiskID   += iDiskIDOffset;
	iCurrentMaxPatchSequence += iSequenceOffset;

	return 0;
}

//____________________________________________________________________________
//
// PrePatchTransformFixup: this fn called before applying a "patch" transform
//                           (a '#' transform from a .msp)
//
//  The following steps are taken in this fn:
//
//      Step 1a: for use by post-transform fixup, determine the max DiskID used
//               by a patch before applying this transform
//
//      Step 1b: for use by post-transform fixup, determine the max File/Patch Sequence
//               used by a patch before applying this transform
//
//      Step 2a: determine if this transform is adding a Media table entry using an existing
//               DiskID value.  if no fixup is done, this transfrom will overwrite that row,
//               which is not desired.  to avoid this, change the existing entry to a different
//               DiskID (the row will be put back during post-transform fixup)
//
//      Step 2b: if this transform wants to add any conflicting Patch table rows
//               then we need to change the existing entries to have non-conflicting
//               primary keys (those rows will be put back in the post-transform fixup)
//____________________________________________________________________________

IMsiRecord* PrePatchTransformFixup(IMsiCursor& riTransViewCursor,
											  CMediaTable& tblMediaTable,
											  CPatchTable& tblPatchTable,
											  CPatchPackageTable& tblPatchPackageTable,
											  int& iTransformDiskID,
											  int& iCurrentMinPatchDiskID, int& iCurrentMaxPatchDiskID,
											  int& iCurrentMinPatchSequence, int& iCurrentMaxPatchSequence)
{
	IMsiRecord* piError = 0;
	
	riTransViewCursor.Reset();
	riTransViewCursor.SetFilter(iColumnBit(ctvTable) | iColumnBit(ctvColumn));
	AssertNonZero(riTransViewCursor.PutString(ctvTable,  *MsiString(*sztblMedia)));
	AssertNonZero(riTransViewCursor.PutString(ctvColumn, *MsiString(*sztvopInsert)));
	if(riTransViewCursor.Next())
	{
		iTransformDiskID = MsiString(riTransViewCursor.GetString(ctvRow));
		ERROR_IF_NULL_OR_ZERO(iTransformDiskID);
	}
	else
	{
		// transform didn't add any Media table entries
		return PostError(Imsg(idbgInvalidPatchTransform));
	}
	
	if(riTransViewCursor.Next())
	{
		// transform adding more than one Media table entries
		return PostError(Imsg(idbgInvalidPatchTransform));
	}
	
	//
	// STEP 1a - determine min/max patch values
	//

	RETURN_ERROR_RECORD(GetMinMaxPatchValues(tblMediaTable, tblPatchPackageTable,
											iCurrentMinPatchDiskID, iCurrentMaxPatchDiskID,
											iCurrentMinPatchSequence, iCurrentMaxPatchSequence));

	//
	// STEP 2a: move any conflicting existing Media row to avoid being overwritten by a transform
	//

	if(tblMediaTable.RowCount())
	{
		tblMediaTable.FilterOnDiskID(iTransformDiskID);

		if(tblMediaTable.Next())
		{
			// have a conflict - the only way to resolve the conflict is the change the DiskID
			// of the existing conflicting row, apply the transform, then change both values
			// appropriately
			
			DEBUGMSG3(TEXT("TRANSFORM: Temporarily moving '%s' table row with '%s' value %d to avoid conflict with this transform."),
						 sztblMedia, sztblMedia_colDiskID, (const ICHAR*)(INT_PTR)iTransformDiskID);
			
			Assert(iTransformDiskID == tblMediaTable.GetDiskID());
			// if this fails it means there is an existing entry with DiskID 0 - this is not allowed
			ERROR_IF_FALSE(tblMediaTable.UpdateDiskID(0));

			if(tblPatchPackageTable.RowCount())
			{
				tblPatchPackageTable.FilterOnDiskID(iTransformDiskID);
				if(tblPatchPackageTable.Next())
				{
					DEBUGMSG3(TEXT("TRANSFORM: Temporarily moving '%s' table row with '%s' value %d to avoid conflict with this transform"),
								 sztblPatchPackage, sztblPatchPackage_colMedia, (const ICHAR*)(INT_PTR)iTransformDiskID);

					ERROR_IF_FALSE(tblPatchPackageTable.UpdateDiskID(0));
				}
			}
		}
	}
	
	//
	// STEP 2b: move any conflicting Patch table rows to avoid being overwritten by the transform
	//
	
	riTransViewCursor.Reset();
	riTransViewCursor.SetFilter(iColumnBit(ctvTable) | iColumnBit(ctvColumn));
	AssertNonZero(riTransViewCursor.PutString(ctvTable,  *MsiString(*sztblPatch)));
	AssertNonZero(riTransViewCursor.PutString(ctvColumn, *MsiString(*sztvopInsert)));

	while(riTransViewCursor.Next())
	{
		// Patch table has 2 primary keys - File_, and Sequence
		// these are stored in the Transform View table as a single string, with the two values tab-delimited
		MsiString strPrimaryKey = riTransViewCursor.GetString(ctvRow); 

		MsiString strFileKey = strPrimaryKey.Extract(iseUpto, '\t');
		int iPatchSequence   = MsiString(strPrimaryKey.Extract(iseAfter, '\t'));

		if(strFileKey.TextSize() == 0 || iPatchSequence == iMsiNullInteger)
		{
			return PostError(Imsg(idbgInvalidPatchTransform));
		}

		if(tblPatchTable.RowCount())
		{
			tblPatchTable.FilterOnKeyAndSequence(*strFileKey, iPatchSequence);

			if(tblPatchTable.Next())
			{
				// have a conflicting existing row
				// we will "move" the existing row by adding a special character sequence to the File key
				// this sequence isn't allowed in a file key, so there should be no conflict
				DEBUGMSG5(TEXT("TRANSFORM: Temporarily moving '%s' row with '%s' and '%s' values %s and %d to avoid conflict with this transform"),
							 sztblPatch, sztblPatch_colFile, sztblPatch_colSequence,
							 strFileKey, (const ICHAR*)(INT_PTR)iPatchSequence);

				strFileKey += TEXT("~*~*~*~");
				ERROR_IF_FALSE(tblPatchTable.UpdateFileKey(*strFileKey));
			}
		}
	}

	return 0;
}


//____________________________________________________________________________
//
// PostPatchTransformFixup: this fn called after applying a "patch" transform
//                          (a '#' transform from a .msp)
//
//  The following steps are taken in this fn:
//
//     NOTE: this function assumes the max patch DiskID and Sequence values were
//           determined in the pre-transform step and are passed into this fn
//
//     Step 1:  determine minimum sequence number added/modified by this transform
//
//     Step 2:  determine offset needed to update File/Patch sequence values appropriately
//
//     Step 3a: offset Sequence values for modified File table rows
//
//     Step 3b: offset Sequence values for modified Patch table rows
//              at the same time, fix any Patch table rows that were "moved" in
//              the pre-transform step
//
//     Step 4:  fix up the Media and PatchPackage rows added by this transform
//              to have appropriate DiskID and Source values
//
//     Step 5:  if there were conflicting Media entries that were "moved" in the
//              pre-transform step, put those entries back
//____________________________________________________________________________

IMsiRecord* PostPatchTransformFixup(IMsiCursor& riTransViewCursor,
												CMediaTable& tblMediaTable, CFileTable& tblFileTable,
												CPatchTable& tblPatchTable, CPatchPackageTable& tblPatchPackageTable,
												int iTransformDiskID,
												int& iCurrentMaxPatchDiskID, int& iCurrentMaxPatchSequence)
{
	IMsiRecord* piError = 0;
	
	if(!iTransformDiskID || !tblMediaTable.RowCount() || !tblPatchPackageTable.RowCount())
	{
		// transform didn't add any Media entries - no fixup needed
		AssertSz(0, "Patch transform didn't add any Media table entries");
		return 0;
	}
	
	//
	// STEP 1: determine minimum sequence number used in the File or Patch table
	//

	bool fUpdatedSequences = false;

	riTransViewCursor.Reset();
	riTransViewCursor.SetFilter(iColumnBit(ctvTable) | iColumnBit(ctvColumn));
	AssertNonZero(riTransViewCursor.PutString(ctvTable,  *MsiString(*sztblFile)));
	AssertNonZero(riTransViewCursor.PutString(ctvColumn, *MsiString(*sztblFile_colSequence)));

	int iTransformMinSequence = INT_MAX;
	
	while(riTransViewCursor.Next())
	{
		int iSequence = MsiString(riTransViewCursor.GetString(ctvData));
		ERROR_IF_NULL(iSequence);

		if(iTransformMinSequence > iSequence)
		{
			iTransformMinSequence = iSequence;
			fUpdatedSequences = true;
		}
	}

	riTransViewCursor.Reset();
	riTransViewCursor.SetFilter(iColumnBit(ctvTable) | iColumnBit(ctvColumn));
	AssertNonZero(riTransViewCursor.PutString(ctvTable,  *MsiString(*sztblPatch)));
	AssertNonZero(riTransViewCursor.PutString(ctvColumn, *MsiString(*sztvopInsert)));

	while(riTransViewCursor.Next())
	{
		// Patch table has 2 primary keys - File_, and Sequence
		// these are stored in the Transform View table as a single string, with the two values tab-delimited
		MsiString strPrimaryKey = riTransViewCursor.GetString(ctvRow); 

		int iSequence   = MsiString(strPrimaryKey.Extract(iseAfter, '\t'));

		ERROR_IF_NULL(iSequence)

		if(iTransformMinSequence > iSequence)
		{
			iTransformMinSequence = iSequence;
			fUpdatedSequences = true;
		}
	}

	//
	// STEP 2: determine offset needed to update File/Patch sequence values appropriately
	//

	// these values should have at least been given default values in the pre-patch step
	Assert(iCurrentMaxPatchDiskID);
	Assert(iCurrentMaxPatchSequence);

	int iSequenceOffset = 0;
	if(false == fUpdatedSequences)
	{
		DEBUGMSG4(TEXT("TRANSFORM: This transform is not modifying the '%s.%s' or '%s.%s' columns."),
					 sztblFile, sztblFile_colSequence, sztblPatch, sztblPatch_colSequence);

		iCurrentMaxPatchSequence++; // if transform didn't change any sequence values, need to bump by one anyway
											 // so last sequence doesn't collide with previous patch Media entry
	}
	else
	{
		iSequenceOffset = iCurrentMaxPatchSequence + 1 - iTransformMinSequence;

		DEBUGMSG4(TEXT("TRANSFORM: Modifying '%s' and '%s' rows added by this patch transform to have appropriate '%s' values.  Offsetting values by %d"),
					 sztblFile, sztblPatch, sztblFile_colSequence, (const ICHAR*)(INT_PTR)iSequenceOffset);

		//
		// STEP 3a: offset Sequence values for modified File table rows
		//

		riTransViewCursor.Reset();
		riTransViewCursor.SetFilter(iColumnBit(ctvTable) | iColumnBit(ctvColumn));
		AssertNonZero(riTransViewCursor.PutString(ctvTable,  *MsiString(*sztblFile)));
		AssertNonZero(riTransViewCursor.PutString(ctvColumn, *MsiString(*sztblFile_colSequence)));

		while(riTransViewCursor.Next())
		{
			MsiString strFileKey = riTransViewCursor.GetString(ctvRow);
			if(!strFileKey.TextSize())
			{
				return PostError(Imsg(idbgInvalidPatchTransform));
			}

			tblFileTable.FilterOnKey(*strFileKey);

			//
			// patch transforms suppress the following errors: ADDEXISTINGROW, DELMISSINGROW, UPDATEMISSINGROW, ADDEXISTINGTABLE
			//  If we fail to find the file table entry, then we are hitting the UPDATEMISSINGROW condition and we shouldn't
			//  fail because of that.  Instead we'll just ignore and continue the processing.
			//

			if(tblFileTable.Next())
			{
				int iSequence = tblFileTable.GetSequence();
				ERROR_IF_NULL(iSequence);

				iSequence += iSequenceOffset;

				ERROR_IF_FALSE(tblFileTable.UpdateSequence(iSequence));

				if(iCurrentMaxPatchSequence < iSequence)
					iCurrentMaxPatchSequence = iSequence;
			}
		}
			
		//
		// STEP 3b: offset Sequence values for modified Patch table rows
		//          at the same time, fix any Patch table rows that were "moved" in
		//          the pre-transform step
		//
		
		riTransViewCursor.Reset();
		riTransViewCursor.SetFilter(iColumnBit(ctvTable) | iColumnBit(ctvColumn));
		AssertNonZero(riTransViewCursor.PutString(ctvTable,  *MsiString(*sztblPatch)));
		AssertNonZero(riTransViewCursor.PutString(ctvColumn, *MsiString(*sztvopInsert)));

		while(riTransViewCursor.Next())
		{
			// Patch table has 2 primary keys - File_, and Sequence
			// these are stored in the Transform View table as a single string, with the two values tab-delimited
			MsiString strPrimaryKey = riTransViewCursor.GetString(ctvRow); 

			MsiString strFileKey = strPrimaryKey.Extract(iseUpto, '\t');
			int iPatchSequence   = MsiString(strPrimaryKey.Extract(iseAfter, '\t'));

			if(strFileKey.TextSize() == 0 || iPatchSequence == iMsiNullInteger)
			{
				return PostError(Imsg(idbgInvalidPatchTransform));
			}

			tblPatchTable.FilterOnKeyAndSequence(*strFileKey, iPatchSequence);

			if(tblPatchTable.Next())
			{
				// 1) change sequence number of the row added by the transform
				iPatchSequence += iSequenceOffset;

				ERROR_IF_FALSE(tblPatchTable.UpdateSequence(iPatchSequence));

				// 2) find and fix any row with this filekey (appended with special sequence)
				MsiString strTemp = strFileKey + TEXT("~*~*~*~");
				tblPatchTable.FilterOnKeyAndSequence(*strTemp, iPatchSequence);
				
				if(tblPatchTable.Next())
				{
					ERROR_IF_FALSE(tblPatchTable.UpdateFileKey(*strFileKey));
				}

				if(iCurrentMaxPatchSequence < iPatchSequence)
					iCurrentMaxPatchSequence = iPatchSequence;
			}
			else
			{
				return PostError(Imsg(idbgInvalidPatchTransform)); // row should be there since we have already
																					// applied the transform
			}
		}
	}
	
	//
	// STEP 4a: fix up PatchPackage row added by this transform
	//          to have appropriate DiskID and Source values
	//

	iCurrentMaxPatchDiskID += 1;

	MsiString strPatchCode;
	tblPatchPackageTable.FilterOnDiskID(iTransformDiskID);
	ERROR_IF_FALSE(tblPatchPackageTable.Next());

	strPatchCode = tblPatchPackageTable.GetPatchID();
	if(!strPatchCode.TextSize())
		return PostError(Imsg(idbgInvalidPatchTransform));

	DEBUGMSG3(TEXT("TRANSFORM: Modifying '%s' table row added by this patch transform to use '%s' value %d."),
				 sztblPatchPackage, sztblPatchPackage_colMedia,
				 (const ICHAR*)(INT_PTR)iCurrentMaxPatchDiskID);

	ERROR_IF_FALSE(tblPatchPackageTable.UpdateDiskID(iCurrentMaxPatchDiskID));

	//
	// STEP 4b: fix up the Media row added by this transform
	//          to have appropriate DiskID value
	//

	tblMediaTable.FilterOnDiskID(iTransformDiskID);
	if(false == tblMediaTable.Next())
		return PostError(Imsg(idbgInvalidPatchTransform));

	MsiString strOldSourceProp = tblMediaTable.GetSourceProp();
	MsiString strNewSourceProp = PatchIDToSourceProp(strPatchCode);

	if(0 == strNewSourceProp.TextSize() || 0 == strNewSourceProp.TextSize())
		return PostError(Imsg(idbgInvalidPatchTransform));

	DEBUGMSG5(TEXT("TRANSFORM: Modifying '%s' table row added by this patch transform to use '%s' value %d and '%s' values %s."),
				 sztblMedia, sztblMedia_colDiskID, (const ICHAR*)(INT_PTR)iCurrentMaxPatchDiskID,
				 sztblMedia_colSource, strNewSourceProp);

	ERROR_IF_FALSE(tblMediaTable.UpdateSourceProp(*strNewSourceProp, *strOldSourceProp));

	ERROR_IF_FALSE(tblMediaTable.UpdateDiskIDAndLastSequence(iCurrentMaxPatchDiskID,
																			  iCurrentMaxPatchSequence));

	//
	// STEP 5: if there were conflicting Media entries that were "moved" in the
	//         pre-transform step, put those entries back
	//

	tblMediaTable.FilterOnDiskID(0);
	if(tblMediaTable.Next())
	{
		DEBUGMSG3(TEXT("TRANSFORM: Moving '%s' table row back to use correct '%s' value %d"),
					 sztblMedia, sztblMedia_colDiskID, (const ICHAR*)(INT_PTR)iTransformDiskID);
		
		if(false == tblMediaTable.UpdateDiskID(iTransformDiskID))
			return PostError(Imsg(idbgInvalidPatchTransform));
	}

	tblPatchPackageTable.FilterOnDiskID(0);
	if(tblPatchPackageTable.Next())
	{
		DEBUGMSG3(TEXT("TRANSFORM: Moving '%s' table row back to use correct '%s' value %d"),
					 sztblPatchPackage, sztblPatchPackage_colMedia, (const ICHAR*)(INT_PTR)iTransformDiskID);

		if(false == tblPatchPackageTable.UpdateDiskID(iTransformDiskID))
			return PostError(Imsg(idbgInvalidPatchTransform));
	}

	return 0;
}


//____________________________________________________________________________
//
// ApplyTransform
//
//    this function should be called to apply any transforms to the .msi used
//    to perform an installation.
//
//    this function catches and resolves conflicts in the following tables
//
//	        Media, File, Patch, PatchPackage
//
//    between different patches, and patches vs. standalone transforms
//
//____________________________________________________________________________

IMsiRecord* ApplyTransform(IMsiDatabase& riDatabase,
										  IMsiStorage& riTransform,
										  int iErrorConditions,
										  bool fPatchOnlyTransform,
										  PatchTransformState* piState)
{
	// special handling is required to apply patch transforms
	// because transforms from different patches may conflict with each other

	// this function assumes these transforms have already been validated
	// with ValidateTransforms

	IMsiRecord* piError = 0;
	
	int iCurrentMinPatchDiskID   = piState ? piState->iMinDiskID   : 0;
	int iCurrentMaxPatchDiskID   = piState ? piState->iMaxDiskID   : 0;
	int iCurrentMinPatchSequence = piState ? piState->iMinSequence : 0;
	int iCurrentMaxPatchSequence = piState ? piState->iMaxSequence : 0;

	// load the tables that will be used during transform processing
	CMediaTable tblMediaTable;
	RETURN_ERROR_RECORD(tblMediaTable.Initialize(riDatabase, false));

	CFileTable tblFileTable;
	RETURN_ERROR_RECORD(tblFileTable.Initialize(riDatabase, false));

	CPatchTable tblPatchTable;
	RETURN_ERROR_RECORD(tblPatchTable.Initialize(riDatabase, false));

	CPatchPackageTable tblPatchPackageTable;
	RETURN_ERROR_RECORD(tblPatchPackageTable.Initialize(riDatabase, false));


	PMsiCursor pTransViewCursor(0);
	piError = LoadTransformViewTable(riDatabase, riTransform, iErrorConditions, *&pTransViewCursor);
	if(piError)
		return piError;

	if(fPatchOnlyTransform == fFalse)
	{
		piError = PrePackageTransformFixup(*pTransViewCursor,
															tblMediaTable, tblFileTable,
															tblPatchTable, tblPatchPackageTable,
															iCurrentMinPatchDiskID, iCurrentMaxPatchDiskID,
															iCurrentMinPatchSequence, iCurrentMaxPatchSequence);

		if(0 == piError)
		{
			// transforms do not always work against loaded tables, so release these tables now
			tblMediaTable.Release();
			tblFileTable.Release();
			tblPatchTable.Release();
			tblPatchPackageTable.Release();

			DEBUGMSG(TEXT("TRANSFORM: Applying regular transform to database."));
			piError = riDatabase.SetTransform(riTransform, iErrorConditions);
		}
	}
	else
	{
		int iTransformDiskID = 0;

		piError = PrePatchTransformFixup(*pTransViewCursor,
														 tblMediaTable, tblPatchTable, tblPatchPackageTable,
														 iTransformDiskID,
														 iCurrentMinPatchDiskID, iCurrentMaxPatchDiskID,
														 iCurrentMinPatchSequence, iCurrentMaxPatchSequence);

		if(0 == piError)
		{
			// transforms do not always work against loaded tables, so release these tables now
			tblMediaTable.Release();
			tblFileTable.Release();
			tblPatchTable.Release();
			tblPatchPackageTable.Release();

			DEBUGMSG(TEXT("TRANSFORM: Applying special patch transform to database."));
			piError = riDatabase.SetTransform(riTransform, iErrorConditions);

			if(0 == piError)
			{
				RETURN_ERROR_RECORD(tblMediaTable.Initialize(riDatabase, false));
				RETURN_ERROR_RECORD(tblFileTable.Initialize(riDatabase, false));
				RETURN_ERROR_RECORD(tblPatchTable.Initialize(riDatabase, false));
				RETURN_ERROR_RECORD(tblPatchPackageTable.Initialize(riDatabase, false));

				piError = PostPatchTransformFixup(*pTransViewCursor,
																  tblMediaTable, tblFileTable,
																  tblPatchTable, tblPatchPackageTable,
																  iTransformDiskID,
																  iCurrentMaxPatchDiskID, iCurrentMaxPatchSequence);
			}
		}
	}

	// release transform view table objects to the table can be released from the database
	pTransViewCursor = 0; // release

	AssertNonZero(ReleaseTransformViewTable(riDatabase));
	
	if(piState)
	{
		piState->iMinDiskID   = iCurrentMinPatchDiskID;
		piState->iMaxDiskID   = iCurrentMaxPatchDiskID;
		piState->iMinSequence = iCurrentMinPatchSequence;
		piState->iMaxSequence = iCurrentMaxPatchSequence;
	}

	return piError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\record.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       record.cpp
//
//--------------------------------------------------------------------------

/* record.cpp - IMsiRecord implementation

A record object is composed of a field count, reference count, and field array.
The fields are simple objects holding data pointers to common class IMsiData.
The field object data is accessed only through its inline accessor functions.
An extra pointer is kept in the field to detect changes in the field value.
This extra pointer is not for integer values; the space is used for the integer.
A private class CFieldInteger holds an integer to be polymorphic with IMsiData.
A private class CMsiInteger is used to return an integer via a IMsiData pointer.
____________________________________________________________________________*/

#include "precomp.h" 
#include "services.h"
#include "_diagnos.h"

extern const IMsiString& g_riMsiStringNull;

//____________________________________________________________________________
//
// CFieldInteger - private class used to hold integer in record
//____________________________________________________________________________

class CFieldInteger : public IMsiData {
 public:  // implemented virtual functions
    HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();
    int           __stdcall TextSize();
#ifdef USE_OBJECT_POOL
    unsigned int  __stdcall GetUniqueId() const;
    void          __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
    const IMsiString& __stdcall GetMsiStringValue() const;
    int           __stdcall GetIntegerValue() const;
    INT_PTR       __stdcall GetIntPtrValue() const;
 public: // local to this module
    void* operator new(size_t iBase, void* pField);
    void* operator new(size_t iBase);
    void  operator delete(void* pv);
    CFieldInteger();  // for static instance only
    CFieldInteger(int i);
#if _WIN64
    CFieldInteger(INT_PTR i);
#endif
 protected:
    INT_PTR       m_iData;
};

//____________________________________________________________________________
//
// CMsiInteger - class used to return integer field data as IMsiData
//____________________________________________________________________________

class CMsiInteger : public CFieldInteger {
 public:  // overridden virtual functions
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();
 public:  // local constructor
    CMsiInteger(CFieldInteger& riCopy);
 private:
    int     m_iRefCnt;
};

//____________________________________________________________________________
//
// Record FieldData definition, private for CMsiRecord, all functions inline
//____________________________________________________________________________

struct FieldData
{
    static CFieldInteger s_Integer; // in order to check Vtable pointer
    Bool           IsInteger() const;
    Bool           IsNull() const;
    const IMsiData* GetDataPtr() const;
    const IMsiData* GetMsiData() const;    // adds a ref count
    const IMsiString& GetMsiString() const;  // adds a ref count
    Bool           IsChanged() const;
    void           SetMsiData(const IMsiData* piData);
    void           SetMsiString(const IMsiString& riStr);
    void           Free();
    void           SetInteger(int i);
    void           RemoveRef();
    void           ClearChanged();
    INT_PTR        GetIntPtrValue() const;
    void           SetIntPtrValue(INT_PTR i);
 private:  // This data is overlaid with CFieldInteger for integer data
    const IMsiData* m_piData;  // normal data pointer
    const IMsiData* m_piCopy;  // data with copy for dirty check
};

inline Bool FieldData::IsInteger() const
{
    return m_piData == *(IMsiData**)&s_Integer ? fTrue : fFalse;
}

inline Bool FieldData::IsNull() const
{
    return m_piData == 0 ? fTrue : fFalse;
}

inline const IMsiData* FieldData::GetDataPtr() const
{
    return m_piData == *(IMsiData**)&s_Integer ? (IMsiData*)this : m_piData;
}

inline const IMsiData* FieldData::GetMsiData() const
{
    if (m_piData != *(IMsiData**)&s_Integer)
    {
        if (m_piData != 0)
            m_piData->AddRef();
        return m_piData;
    }
    return new CMsiInteger(*(CFieldInteger*)this);
}

inline const IMsiString& FieldData::GetMsiString() const
{
    if (m_piData == *(IMsiData**)&s_Integer)
        return ((CFieldInteger*)this)->GetMsiStringValue();
    return m_piData == 0 ? g_riMsiStringNull : m_piData->GetMsiStringValue();
}

inline void FieldData::Free()
{
    if (m_piData == 0)
        return;
    if (m_piData == *(IMsiData**)&s_Integer)
        m_piCopy = m_piData; // force IsChanged mismatch
    else
        m_piData->Release();
    m_piData = 0;
}

inline Bool FieldData::IsChanged() const
{
    return (m_piData != m_piCopy || m_piData == *(IMsiData**)&s_Integer)
                ? fTrue : fFalse;
}

inline void FieldData::SetMsiData(const IMsiData* piData)
{
    if (m_piData == *(IMsiData**)&s_Integer)
        m_piCopy = m_piData; // force IsChanged mismatch
    else if (m_piData != 0)
        m_piData->Release();
    m_piData = piData;
    if (piData)
        piData->AddRef();
}

inline void FieldData::SetMsiString(const IMsiString& riStr)
{
    if (m_piData == *(IMsiData**)&s_Integer)
        m_piCopy = m_piData; // force IsChanged mismatch
    else if (m_piData != 0)
        m_piData->Release();
    if (&riStr == &g_riMsiStringNull)
        m_piData = 0;
    else
    {
        m_piData = &riStr;
        riStr.AddRef();
    }
}

inline void FieldData::SetInteger(int i)
{
    if (m_piData != 0 && m_piData != *(IMsiData**)&s_Integer)
        m_piData->Release();
    new(this) CFieldInteger(i);
}

inline void FieldData::SetIntPtrValue(INT_PTR i)
{
    if (m_piData != 0 && m_piData != *(IMsiData**)&s_Integer)
        m_piData->Release();
    new(this) CFieldInteger(i);
}

inline INT_PTR FieldData::GetIntPtrValue() const
{
    if (!m_piData)
        return (INT_PTR)iMsiStringBadInteger;
    if (m_piData == *(IMsiData**)&s_Integer)
    {
        const CFieldInteger *pInteger = (CFieldInteger *)this;

        return pInteger->GetIntPtrValue();
    }
    return m_piData == 0 ? iMsiStringBadInteger : m_piData->GetIntegerValue();

}

inline void FieldData::RemoveRef()
{
    if (m_piData == 0 || m_piData == *(IMsiData**)&s_Integer)
        return;
    const IMsiString* piStr = &m_piData->GetMsiStringValue();
    if (piStr == m_piData)
        piStr->RemoveRef((const IMsiString*&)m_piData);
    piStr->Release();
}

inline void FieldData::ClearChanged()
{
    if (m_piData != *(IMsiData**)&s_Integer)
        m_piCopy = m_piData;
}

//____________________________________________________________________________
//
// CMsiRecord definition, implementation class for IMsiRecord
//____________________________________________________________________________

class CMsiRecord : public IMsiRecord  // class private to this module
{
 public:   // implemented virtual functions
    HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();
    int           __stdcall GetFieldCount() const;
    Bool          __stdcall IsNull(unsigned int iParam) const;
    Bool          __stdcall IsInteger(unsigned int iParam) const;
    Bool          __stdcall IsChanged(unsigned int iParam) const;
    int           __stdcall GetInteger(unsigned int iParam) const;
    const IMsiData*   __stdcall GetMsiData(unsigned int iParam) const;
    const IMsiString& __stdcall GetMsiString(unsigned int iParam) const; // must Release()
    const ICHAR*  __stdcall GetString(unsigned int iParam) const;
    int           __stdcall GetTextSize(unsigned int iParam) const;
    Bool          __stdcall SetNull(unsigned int iParam);
    Bool          __stdcall SetInteger(unsigned int iParam, int iData);
    Bool          __stdcall SetMsiData(unsigned int iParam, const IMsiData* piData);
    Bool          __stdcall SetMsiString(unsigned int iParam, const IMsiString& riStr);
    Bool          __stdcall SetString(unsigned int iParam, const ICHAR* sz);
    Bool          __stdcall RefString(unsigned int iParam, const ICHAR* sz);
    const IMsiString& __stdcall FormatText(Bool fComments);
    void          __stdcall RemoveReferences();
    Bool          __stdcall ClearData();
    void          __stdcall ClearUpdate();
    int __stdcall FormatRecordParam(CTempBufferRef<ICHAR>&rgchOut,int iField, Bool& fPropMissing);
    static        void InitializeRecordCache();
    static        void KillRecordCache(boolean fFatal);
    static IMsiRecord *NewRecordFromCache(unsigned int cParam);
    const HANDLE      __stdcall GetHandle(unsigned int iParam) const;
    Bool          __stdcall SetHandle(unsigned int iParam, const HANDLE hData);
 public:  // constructor
    void* operator new(size_t iBase, unsigned int cParam);
    void  operator delete(void* pv);
    CMsiRecord(unsigned int cParam);
 protected:
  ~CMsiRecord();  // protected to prevent creation on stack
 protected: // local functions
    static int __stdcall FormatTextCallback(const ICHAR *pch, int cch, CTempBufferRef<ICHAR>&,
                                                     Bool& fPropMissing,
                                                     Bool& fPropUnresolved,
                                                     Bool&, // unused
                                                     IUnknown* piContext);
 protected: // local state
    CMsiRef<iidMsiRecord>                m_Ref;
    const unsigned int m_cParam;   // number of parameters
    FieldData          m_Field[1]; // field[0] = formatting string
    // array of FieldData[m_cParam] follows, allocated by new operator
    static  CRITICAL_SECTION    m_RecCacheCrs;
    static  long            m_cCacheRef;
 private:
     void operator=(const CMsiRecord&);
};

//____________________________________________________________________________
//
// CMsiRecordNull definition, implementation class for IMsiRecord
//____________________________________________________________________________

class CMsiRecordNull : public IMsiRecord  // class private to this module
{
 public:   // implemented virtual functions
    HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();
    int           __stdcall GetFieldCount() const;
    Bool          __stdcall IsNull(unsigned int iParam) const;
    Bool          __stdcall IsInteger(unsigned int iParam) const;
    Bool          __stdcall IsChanged(unsigned int iParam) const;
    int           __stdcall GetInteger(unsigned int iParam) const;
    const IMsiData*   __stdcall GetMsiData(unsigned int iParam) const;
    const IMsiString& __stdcall GetMsiString(unsigned int iParam) const; // must Release()
    const ICHAR*  __stdcall GetString(unsigned int iParam) const;
    int           __stdcall GetTextSize(unsigned int iParam) const;
    Bool          __stdcall SetNull(unsigned int iParam);
    Bool          __stdcall SetInteger(unsigned int iParam, int iData);
    Bool          __stdcall SetMsiData(unsigned int iParam, const IMsiData* piData);
    Bool          __stdcall SetMsiString(unsigned int iParam, const IMsiString& riStr);
    Bool          __stdcall SetString(unsigned int iParam, const ICHAR* sz);
    Bool          __stdcall RefString(unsigned int iParam, const ICHAR* sz);
    const IMsiString& __stdcall FormatText(Bool fComments);
    void          __stdcall RemoveReferences();
    Bool          __stdcall ClearData();
    void          __stdcall ClearUpdate();
    const HANDLE      __stdcall GetHandle(unsigned int iParam) const;
    Bool          __stdcall SetHandle(unsigned int iParam, const HANDLE hData);
};

//____________________________________________________________________________
//
// CFieldInteger implementation
//____________________________________________________________________________

CFieldInteger FieldData::s_Integer;  // static pointer to Vtable

inline void* CFieldInteger::operator new(size_t, void* pField)
{
    return pField;
}
inline void* CFieldInteger::operator new(size_t iBase)
{
    return ::AllocObject(iBase);
}
inline void CFieldInteger:: operator delete(void* pv) {::FreeObject(pv);}
inline CFieldInteger::CFieldInteger()      {m_iData = 0;}
inline CFieldInteger::CFieldInteger(int i) {m_iData = i;}
#if _WIN64
inline CFieldInteger::CFieldInteger(INT_PTR i) {m_iData = i;}
#endif

HRESULT CFieldInteger::QueryInterface(const IID& riid, void** ppvObj)
{
    if (riid == IID_IUnknown || riid == IID_IMsiData)
    {
        *ppvObj = this;
        AddRef();
        return S_OK;
    }
    *ppvObj = 0;
    return E_NOINTERFACE;
}
unsigned long CFieldInteger::AddRef()
{
    return 1;
}
unsigned long CFieldInteger::Release()
{
    return 1;
}

int CFieldInteger::TextSize()
{
    int cch = 0;
    int i = (int)m_iData;
    if (i <= 0)  // allow room for - sign or 0
    {
        i = -i;
        cch++;
        if (i < 0) // special case for 0x80000000
            i = ~i;
    }
    while (i)
    {
        cch++;
        i = i/10;
    }
    return cch;
}

int CFieldInteger::GetIntegerValue() const
{
    return (int)m_iData;    // CFieldInteger in this case should be storing an int sized value
}

INT_PTR CFieldInteger::GetIntPtrValue() const
{
    return m_iData;
}

const IMsiString& CFieldInteger::GetMsiStringValue() const
{
    ICHAR buf[16];
    ltostr(buf, m_iData);
    const IMsiString* pi = &g_riMsiStringNull;
    pi->SetString(buf, pi);
    return *pi;
}

#ifdef USE_OBJECT_POOL
unsigned int CFieldInteger::GetUniqueId() const
{
    Assert(fFalse);
    return 0;
}

void CFieldInteger::SetUniqueId(unsigned int /* id */)
{
    Assert(fFalse);
}
#endif //USE_OBJECT_POOL

//____________________________________________________________________________
//
// CMsiInteger implementation
//____________________________________________________________________________

unsigned long CMsiInteger::AddRef()
{
    return ++m_iRefCnt;
}

unsigned long CMsiInteger::Release()
{
    if (--m_iRefCnt != 0)
        return m_iRefCnt;
    delete this;
    return 0;
}

inline CMsiInteger::CMsiInteger(CFieldInteger& riCopy)
{
    m_iRefCnt = 1;
    m_iData = riCopy.GetIntegerValue();
}

//____________________________________________________________________________
//
// CMsiRecord implementation
//____________________________________________________________________________


// Record cache information

#define crecCache0      1
#define crecCache1      3
#define crecCache2      2
#define crecCache3      2
#define crecCache4      2
#define crecCache5      1
#define crecCache6      1
#define crecCache7      1
#define crecCacheMax    (crecCache0 + crecCache1 + crecCache2 + crecCache3 + crecCache4 + crecCache5 + crecCache6 + crecCache7)

struct RCCI         // ReCord Cache Information
{
    int             cRecsMax;
    int             cRecs;
    CMsiRecord**    ppCacheStart;
#ifdef DEBUG
    int             cHits;
    int             cMisses;
    int             cHitsOneLarger;     // How many misses would have been hits with one more objects
    int             cObjectsOneLarger;
    int             cMissesOneSmaller;  // How many hits would have been misses with one fewer
    int             cObjectsOneSmaller;
#endif //DEBUG
};

#ifdef DEBUG
static int      iLargestRecDropped;
#endif //DEBUG

CMsiRecord *rgRecordCache[crecCacheMax];

RCCI    mpCparamRcci[] =
{
    {crecCache0, 0, &rgRecordCache[0]},
    {crecCache1, 0, &rgRecordCache[crecCache0]},
    {crecCache2, 0, &rgRecordCache[crecCache0 + crecCache1]},
    {crecCache3, 0, &rgRecordCache[crecCache0 + crecCache1+crecCache2]},
    {crecCache4, 0, &rgRecordCache[crecCache0 + crecCache1+crecCache2+crecCache3]},
    {crecCache5, 0, &rgRecordCache[crecCache0 + crecCache1+crecCache2+crecCache3 + crecCache4]},
    {crecCache6, 0, &rgRecordCache[crecCache0 + crecCache1+crecCache2+crecCache3 + crecCache4 + crecCache5]},
    {crecCache7, 0, &rgRecordCache[crecCache0 + crecCache1+crecCache2+crecCache3 + crecCache4 + crecCache5 + crecCache6]},
};

#define cparamCacheMax      (sizeof(mpCparamRcci)/sizeof(RCCI))

inline void* CMsiRecord::operator new(size_t iBase, unsigned int cParam)
{
    return ::AllocObject(iBase + cParam * sizeof FieldData);
}
inline void CMsiRecord::operator delete(void* pv) {::FreeObject(pv);}

static CMsiRecordNull NullRecord;
IMsiRecord* g_piNullRecord = &NullRecord;

CRITICAL_SECTION    CMsiRecord::m_RecCacheCrs;
long            CMsiRecord::m_cCacheRef = 0;

void KillRecordCache(boolean fFatal)
{
    CMsiRecord::KillRecordCache(fFatal);
}

void CMsiRecord::KillRecordCache(boolean fFatal)
{

    if (!m_cCacheRef)
        return;
        
    if (fFatal || InterlockedDecrement(&m_cCacheRef) <= 0)
    {   
        m_cCacheRef = 0;
        DeleteCriticalSection(&m_RecCacheCrs);
        int iRec = 0;

        while (iRec < crecCacheMax)
        {
            if (rgRecordCache[iRec] != 0 && !fFatal)
                delete rgRecordCache[iRec];
            rgRecordCache[iRec] = 0;
            iRec++;
        }

        int iParam;

        for (iParam = 0; iParam < cparamCacheMax ; iParam++)
        {
            if (!fFatal)
            {
                DEBUGMSGVD2(TEXT("For %d parameters, cache size:[%d]"), (const ICHAR *)(INT_PTR)iParam, (const ICHAR *)(INT_PTR)mpCparamRcci[iParam].cRecsMax);
                DEBUGMSGVD2(TEXT("%d hits, %d misses"), (const ICHAR *)(INT_PTR)mpCparamRcci[iParam].cHits, (const ICHAR *)(INT_PTR)mpCparamRcci[iParam].cMisses);
                DEBUGMSGVD2(TEXT("With one more would have gotten %d more. One less %d less."), (const ICHAR *)(INT_PTR)mpCparamRcci[iParam].cHitsOneLarger, (const ICHAR *)(INT_PTR)mpCparamRcci[iParam].cMissesOneSmaller);
            }
            mpCparamRcci[iParam].cRecs = 0;
        }

        if (!fFatal)
        {
            DEBUGMSGVD1(TEXT("Largest record dropped %d"), (const ICHAR *)(INT_PTR)iLargestRecDropped);
        }
    }   
}

void InitializeRecordCache()
{
    CMsiRecord::InitializeRecordCache();
}

void CMsiRecord::InitializeRecordCache()
{
    if (!m_cCacheRef)
    {
        InitializeCriticalSection(&m_RecCacheCrs);
    }

    m_cCacheRef++;
}

IMsiRecord& CreateRecord(unsigned int cParam)
{
    IMsiRecord* piMsg = 0;
    
    if ((piMsg = CMsiRecord::NewRecordFromCache(cParam)) != 0)
        return *piMsg;
        
    piMsg = new (cParam) CMsiRecord(cParam);
    if (piMsg == 0)
        return NullRecord;
        
    return *piMsg;  //FUTURE needed? this could happen with external API if no memory
}

IMsiRecord *CMsiRecord::NewRecordFromCache(unsigned int cParam)
{
    IMsiRecord* piMsg = 0;

    if (m_cCacheRef <= 0)
    {
        AssertSz(fFalse, "Record Cache not initialized");
        return 0;
    }
    
    // Check our cache first
    if (cParam < cparamCacheMax)
    {
        CMsiRecord **ppcMsg;

        if (mpCparamRcci[cParam].cRecs != 0)
        {

            // Now we enter the critical section, it's possible that the number has changed
            // so we have to check again
            EnterCriticalSection(&m_RecCacheCrs);
            if (mpCparamRcci[cParam].cRecs > 0)
            {
                // We want to take off the end
                mpCparamRcci[cParam].cRecs--;
                ppcMsg = mpCparamRcci[cParam].ppCacheStart + mpCparamRcci[cParam].cRecs;
                Assert(*ppcMsg != 0);

                // Clear out the field data
                memset((*ppcMsg)->m_Field, 0, (cParam+1)*sizeof FieldData);
                (*ppcMsg)->m_Ref.m_iRefCnt = 1;
                piMsg = *ppcMsg;
                *ppcMsg = 0;
#ifdef DEBUG
                mpCparamRcci[cParam].cHits++;
#endif //DEBUG
            }
            LeaveCriticalSection(&m_RecCacheCrs);
        }       
#ifdef DEBUG
        // Keep our statistics
        if (piMsg == 0)
        {
            mpCparamRcci[cParam].cMisses++;
            if (mpCparamRcci[cParam].cObjectsOneLarger > 0)
                mpCparamRcci[cParam].cHitsOneLarger++;
        }
        else
        {
            if (mpCparamRcci[cParam].cObjectsOneSmaller <= 0)
                mpCparamRcci[cParam].cMissesOneSmaller++;
        }

        if (mpCparamRcci[cParam].cObjectsOneLarger > 0)
            mpCparamRcci[cParam].cObjectsOneLarger--;
        if (mpCparamRcci[cParam].cObjectsOneSmaller > 0)
            mpCparamRcci[cParam].cObjectsOneSmaller--;
    
#endif //DEBUG
    }

    return piMsg;
}

CMsiRecord::CMsiRecord(unsigned int cParam)
                : m_cParam(cParam)
{
    // We don't believe a record should have more than this many elements
    Assert(cParam <=  MSIRECORD_MAXFIELDS);
    Debug(m_Ref.m_pobj = this);     // we're returning an interface, passing ownership
    memset(m_Field, 0, (cParam+1)*sizeof FieldData);
}

CMsiRecord::~CMsiRecord()
{
    for (int iParam = 0; iParam <= m_cParam; iParam++)
        m_Field[iParam].Free();
}

HRESULT CMsiRecord::QueryInterface(const IID& riid, void** ppvObj)
{
    if (riid == IID_IUnknown || riid == IID_IMsiRecord)
    {
        *ppvObj = this;
        AddRef();
        return S_OK;
    }
    *ppvObj = 0;
    return E_NOINTERFACE;
}
unsigned long CMsiRecord::AddRef()
{
    AddRefTrack();
    return ++m_Ref.m_iRefCnt;
}
unsigned long CMsiRecord::Release()
{
    Bool fCached = fFalse;
    
    ReleaseTrack();
    if (--m_Ref.m_iRefCnt != 0)
        return m_Ref.m_iRefCnt;

    // See about caching this before deleting it
    if (this->m_cParam < cparamCacheMax)
    {
        int cParam = this->m_cParam;
        if (mpCparamRcci[cParam].cRecs < mpCparamRcci[cParam].cRecsMax)
        {
            // Again, wait until we know there's a chance to add it before
            // entering the critical section
            EnterCriticalSection(&m_RecCacheCrs);
            if (mpCparamRcci[cParam].cRecs < mpCparamRcci[cParam].cRecsMax)
            {
                CMsiRecord **ppcMsg;

                ppcMsg = mpCparamRcci[cParam].ppCacheStart + mpCparamRcci[cParam].cRecs;
                mpCparamRcci[cParam].cRecs++;

                // REVIEW davidmck - we should be able to do this outside the critical section
                for (int iParam = 0; iParam <= m_cParam; iParam++)
                    m_Field[iParam].Free();
                *ppcMsg = this;
#ifdef DEBUG
                if (mpCparamRcci[cParam].cObjectsOneSmaller < mpCparamRcci[cParam].cRecsMax - 1)
                    mpCparamRcci[cParam].cObjectsOneSmaller++;          
#endif //DEBUG
                fCached = fTrue;                
            }
            LeaveCriticalSection(&m_RecCacheCrs);
            if (fCached)
                return 0;
        }
#ifdef DEBUG
        if (mpCparamRcci[cParam].cObjectsOneLarger < mpCparamRcci[cParam].cRecsMax + 1)
            mpCparamRcci[cParam].cObjectsOneLarger++;           
#endif
    }

#ifdef DEBUG
    if (this->m_cParam > iLargestRecDropped)
        iLargestRecDropped = this->m_cParam;
#endif //DEBUG
    delete this;
    return 0;
}

int CMsiRecord::GetFieldCount() const
{
    return m_cParam;
}

Bool CMsiRecord::IsInteger(unsigned int iParam) const
{
    return (iParam > m_cParam) ? fFalse : m_Field[iParam].IsInteger();
}

Bool CMsiRecord::IsNull(unsigned int iParam) const
{
    return (iParam > m_cParam) ? fTrue : m_Field[iParam].IsNull();
}

const IMsiString& CMsiRecord::GetMsiString(unsigned int iParam) const
{
    if (iParam > m_cParam)
        return g_riMsiStringNull;
    return m_Field[iParam].GetMsiString();
}

const ICHAR* CMsiRecord::GetString(unsigned int iParam) const
{
    if (iParam > m_cParam || m_Field[iParam].IsInteger())
        return 0;
    const IMsiData* piData = m_Field[iParam].GetDataPtr();
    if (!piData)
        return 0;
    const IMsiString& riString = piData->GetMsiStringValue();
    const ICHAR* sz = riString.GetString();
    riString.Release();
    return sz;
}

int CMsiRecord::GetInteger(unsigned int iParam) const
{
    if (iParam > m_cParam)
        return iMsiStringBadInteger;
    const IMsiData* piData = m_Field[iParam].GetDataPtr();
    if (!piData)
        return iMsiStringBadInteger;
    return piData->GetIntegerValue();
}

const IMsiData* CMsiRecord::GetMsiData(unsigned int iParam) const
{
    if (iParam > m_cParam)
        return 0;
    return m_Field[iParam].GetMsiData();
}

Bool CMsiRecord::SetMsiData(unsigned int iParam, const IMsiData* piData)
{
    if (iParam > m_cParam)
        return fFalse;
    m_Field[iParam].SetMsiData(piData);
    return fTrue;
}

const HANDLE CMsiRecord::GetHandle(unsigned int iParam) const
{
    if (iParam > m_cParam)
        return 0;
    return (HANDLE)(m_Field[iParam].GetIntPtrValue());
}

Bool CMsiRecord::SetHandle(unsigned int iParam, const HANDLE hData)
{
    if (iParam > m_cParam)
        return fFalse;
    m_Field[iParam].SetIntPtrValue((INT_PTR)hData);
    return fTrue;
}

Bool CMsiRecord::SetMsiString(unsigned int iParam, const IMsiString& riStr)
{
    if (iParam > m_cParam)
        return fFalse;
    m_Field[iParam].SetMsiString(riStr);
    return fTrue;
}

Bool CMsiRecord::SetString(unsigned int iParam, const ICHAR* sz) 
{
    if (iParam > m_cParam)
        return fFalse;
    const IMsiString* piStr = &g_riMsiStringNull;
    piStr->SetString(sz, piStr);
    m_Field[iParam].SetMsiString(*piStr);
    piStr->Release();
    return fTrue;
}

Bool CMsiRecord::RefString(unsigned int iParam, const ICHAR* sz) 
{
    if (iParam > m_cParam)
        return fFalse;
    const IMsiString* piStr = &g_riMsiStringNull;
    piStr->RefString(sz, piStr);
    m_Field[iParam].SetMsiString(*piStr);
    piStr->Release();
    return fTrue;
}

Bool CMsiRecord::SetInteger(unsigned int iParam, int iData)
{
    if (iParam > m_cParam)
        return fFalse;
    m_Field[iParam].SetInteger(iData);
    return fTrue;
}

Bool CMsiRecord::SetNull(unsigned int iParam)
{
    if (iParam > m_cParam)
        return fFalse;
    m_Field[iParam].Free();
    return fTrue;
}

int CMsiRecord::GetTextSize(unsigned int iParam) const
{
    if (iParam > m_cParam)
        return 0;
    const IMsiData* piData = m_Field[iParam].GetDataPtr();
    if (!piData)
        return 0;
    return MsiString(piData->GetMsiStringValue()).TextSize();
}

void CMsiRecord::RemoveReferences()
{
    for (int iParam = 0; iParam <= m_cParam; iParam++)
        m_Field[iParam].RemoveRef();
}

Bool CMsiRecord::ClearData()
{
    for (int iParam = 0; iParam <= m_cParam; iParam++)
        m_Field[iParam].Free();
    return fTrue;
}

Bool CMsiRecord::IsChanged(unsigned int iParam) const
{
    if (iParam > m_cParam)
        return fFalse;
    return m_Field[iParam].IsChanged();
}

void CMsiRecord::ClearUpdate()
{
    for (int iParam = 0; iParam <= m_cParam; iParam++)
        m_Field[iParam].ClearChanged();
    return;
}

inline void ShiftSFNIndexes(int (*prgiSFNPos)[2], int* piSFNPos, int iSFNPosBefore, int iShift)
{
    if(prgiSFNPos)
    {
        Assert(piSFNPos);
        while(iSFNPosBefore < *piSFNPos)
        {
            prgiSFNPos[iSFNPosBefore][0] += iShift;
            iSFNPosBefore++;
        }
    }
}


const IMsiString& CMsiRecord::FormatText(Bool fComments)
{
    if (IsNull(0) || IsInteger(0))
    {
        //
        // We know exactly what we want the string to look like, thus
        // we will just create it here and return it
        //
        int cch = 0;
        Bool fPropMissing;
        
        CTempBuffer<ICHAR, 1> rgchBuf(1024);
        CTempBuffer<ICHAR, 100>rgchParam;
        int cchParam;

        for (int i = 1; i <= m_cParam; i++)
        {
            // ensure that we have 5 characters for number (largest possible)
            // and 2 chars for ": "
            ResizeTempBuffer(rgchBuf, cch + 7);         
            if ( ! (ICHAR *) rgchBuf )
                return g_riMsiStringNull;
            cch += ltostr(&rgchBuf[cch], i);
            rgchBuf[cch++] = TEXT(':');
            rgchBuf[cch++] = TEXT(' ');
            fPropMissing = fFalse;
            cchParam = FormatRecordParam(rgchParam, i, fPropMissing);
            if (!fPropMissing)
                ResizeTempBuffer(rgchBuf, cch + cchParam + 1);
            else
                ResizeTempBuffer(rgchBuf, cch + 1);
            if ( ! (ICHAR *) rgchBuf )
                return g_riMsiStringNull;

            if (!fPropMissing)
            {
                memcpy(&rgchBuf[cch], (const ICHAR *)rgchParam, cchParam * sizeof(ICHAR));
                cch += cchParam;
            }
            rgchBuf[cch++] = TEXT(' ');
        }
        MsiString istrOut;
        // we take the perf hit on Win9X for DBCS possibility, on UNICODE, fDBCS arg is ignored
        memcpy(istrOut.AllocateString(cch, /*fDBCS=*/fTrue), (ICHAR*) rgchBuf, cch * sizeof(ICHAR));
        return istrOut.Return();
            
    }

    MsiString istrIn = GetMsiString(0);

    return ::FormatText(*istrIn,fTrue,fComments,CMsiRecord::FormatTextCallback,(IUnknown*)(IMsiRecord*)this);
}

int CMsiRecord::FormatRecordParam(CTempBufferRef<ICHAR>& rgchOut, int iField, Bool& fPropMissing)
{
    int cch;
    
    rgchOut[0] = 0;
    if (IsNull(iField))
    {
        fPropMissing = fTrue; // eliminate segment
        return 0;
    }
    else if (IsInteger(iField))
    {
        rgchOut.SetSize(cchMaxIntLength);
        if ( ! (ICHAR *) rgchOut )
            return 0;
        cch = ltostr(rgchOut, GetInteger(iField));
        return cch;
    }
        
    IMsiString* piString;

    PMsiData pData = GetMsiData(iField);
    
    if (pData && pData->QueryInterface(IID_IMsiString, (void**)&piString) == NOERROR)
    {
        cch = piString->TextSize();
        rgchOut.SetSize(cch + 1);
        piString->CopyToBuf(rgchOut, cch);
        piString->Release();
        return cch;
    }
    
    // Should only appear only for debugging information so not localized
    const ICHAR szBinary[] = TEXT("BinaryData");
    // Remember that sizeof() will include the null
    cch = sizeof(szBinary)/sizeof(ICHAR);
    rgchOut.SetSize(cch);
    if ( ! (ICHAR *) rgchOut )
        return 0;
    memcpy(rgchOut, szBinary, cch*sizeof(ICHAR));
    return cch - 1;

}

int CMsiRecord::FormatTextCallback(const ICHAR *pch, int cch, CTempBufferRef<ICHAR>&rgchOut,
                                                                 Bool& fPropMissing,
                                                                 Bool& fPropUnresolved,
                                                                 Bool&, // unused
                                                                 IUnknown* piContext)
{
    CTempBuffer<ICHAR, 20> rgchString;
    rgchString.SetSize(cch+1);
    if ( ! (ICHAR *) rgchString )
        return 0;
    memcpy(rgchString, pch, cch * sizeof(ICHAR));
    rgchString[cch] = 0;
    
    CMsiRecord* piRecord = (CMsiRecord*)piContext;

    int iField = GetIntegerValue(rgchString, 0);
    fPropUnresolved = fFalse;
    if (iField >= 0)  // positive integer
    {
        return piRecord->FormatRecordParam(rgchOut, iField, fPropMissing);
    }
    
    // assumed to be property, to be expanded by engine
    rgchOut.SetSize(cch + 3);
    memcpy(&rgchOut[1], &rgchString[0], cch * sizeof(ICHAR));
    rgchOut[0] = TEXT('[');
    rgchOut[cch + 1] = TEXT(']');
    rgchOut[cch + 2] = 0;
    fPropUnresolved = fTrue;
    return cch + 2;
}


//____________________________________________________________________________
//
// Global FormatText, called by MsiRecord and MsiEngine
//____________________________________________________________________________

void FormatSegment(const ICHAR *pchStart, const ICHAR *pchEnd, CTempBufferRef<ICHAR>& rgchOut, int& cchOut, Bool fInside, Bool& fPropFound, Bool& fPropMissing,
                                          Bool& fPropUnresolved, FORMAT_TEXT_CALLBACK lpfnResolveValue, IUnknown* piContext, int (*prgiSFNPos)[2], int* piSFNPos);

extern Bool g_fDBCSEnabled;  // DBCS enabled OS

inline bool FFindNextChar(const ICHAR*& pchIn, const ICHAR* pchEnd, ICHAR ch)
{

#ifndef UNICODE
    if (g_fDBCSEnabled)
    {
        while (pchIn < pchEnd)
        {
            if (*pchIn == ch)
                return true;
            pchIn = CharNext(pchIn);
        }
    
    }
    else
#endif //UNICODE
    {
        while (pchIn < pchEnd)
        {
            if (*pchIn == ch)
                return true;
            pchIn++;
        }
    }

    return false;

}

//
// Find the next character or square bracket. Used by FormatText
// faster on non-DBCS machines
//
inline bool FFindNextCharOrSquare(const ICHAR*& pchIn, ICHAR ch)
{

#ifndef UNICODE
    if (g_fDBCSEnabled)
    {
        while (*pchIn)
        {
            if (*pchIn == ch || *pchIn == TEXT('['))
                return true;
            pchIn = CharNext(pchIn);
        }
    }
    else
#endif //UNICODE
    {
        while (*pchIn)
        {
            if (*pchIn == ch || *pchIn == TEXT('['))
                return true;
            pchIn++;
        }
    }

    return false;
    
}


const IMsiString& FormatText(const IMsiString& riTextString, Bool fProcessComments, Bool fKeepComments, FORMAT_TEXT_CALLBACK lpfnResolveValue,
                                      IUnknown* piContext, int (*prgiSFNPos)[2], int* piSFNPos)
{
    const ICHAR *pchIn;
    const ICHAR *pchStartBefore = NULL, *pchEndBefore = NULL;
    const ICHAR *pchStartInside = NULL, *pchEndInside = NULL;
    CTempBuffer<ICHAR, 1> rgchOut(512);
    int cch = 0;

    pchIn = riTextString.GetString();
    // divide the string into 3 parts: the text before the first pair of {}, the text inside and the text after (this third one remains in istrIn)
    while (*pchIn)
    {
        bool fCommentFound = false;
        pchStartBefore = pchIn;
        pchEndBefore = pchIn;
        while (*pchIn)
        {
            if (FFindNextCharOrSquare(pchIn, TEXT('{')))
            {
                if (*pchIn == TEXT('{'))
                {
                    pchEndBefore = pchIn;       // Note that pchEndBefore can be == pchStartBefore
                    // See if we have a comment
                    if (*(pchIn + 1) == TEXT('{'))
                    {
                        pchIn++;
                        fCommentFound = true;
                    }
                    pchIn++;
                    break;
                }
                else if (*pchIn == TEXT('['))
                {
                    // If this is an escaped {, skip over
                    if (*(pchIn + 1) == chFormatEscape && *(pchIn + 2) == TEXT('{'))
                    {
                        pchIn += 2;
                    }
                }
                pchIn = ICharNext(pchIn);
            }
        }
        pchStartInside = pchIn;
        bool fFound = false;
        while (*pchIn)
        {
            if (FFindNextCharOrSquare(pchIn, TEXT('}')))
            {
                if (*pchIn == TEXT('['))
                {
                    // Possibly escaped, skip over characters
                    if (*(pchIn + 1) == chFormatEscape && (*pchIn + 2) == TEXT('}'))
                    {
                        if (fCommentFound)
                        {
                            if (*(pchIn + 3) == TEXT('}'))
                                pchIn += 3;
                        }
                        else
                            pchIn += 2;
                    }
                }
                else if (*pchIn == TEXT('}'))
                {
                    if (!fCommentFound)
                    {
                        pchEndInside = pchIn;
                        fFound = true;
                        pchIn++;
                        break;
                    }
                    if (*(pchIn + 1) == TEXT('}'))
                    {
                        pchEndInside = pchIn;
                        pchIn += 2;
                        fFound = true;
                        break;
                    }
                }
                pchIn = ICharNext(pchIn);
            }
        }
        if (!fFound)
        {
            fCommentFound = fFalse;
            pchEndBefore = pchIn;
            pchEndInside = pchStartInside;
            Assert(!*pchIn);
        }
        Bool fPropFound; // property found in segment
        Bool fPropMissing; // there was at least one missing property
        Bool fPropUnresolved; // property was found but couldn't be resolved (so leave '{' and '}' if necessary)
        if (pchEndBefore - pchStartBefore > 0)
            FormatSegment(pchStartBefore, pchEndBefore, rgchOut, cch, fFalse, 
                                                fPropFound, fPropMissing, fPropUnresolved, lpfnResolveValue, piContext, prgiSFNPos, piSFNPos);
        if (pchEndInside - pchStartInside > 0)
        {
            if(fCommentFound && fProcessComments && !fKeepComments)
                continue;  // this is a comment, but we don't care about it

            CTempBuffer<ICHAR, 1> rgchSegment(512);
            int cchSegment = 0;
            int iSFNPosBefore = 0;
            if(piSFNPos)
                iSFNPosBefore = *piSFNPos;
            FormatSegment(pchStartInside, pchEndInside, rgchSegment, cchSegment, fFalse,
                                                fPropFound, fPropMissing,fPropUnresolved, lpfnResolveValue, piContext, prgiSFNPos, piSFNPos);

            if(fCommentFound)
            {
                if(!fProcessComments)
                {
                    ShiftSFNIndexes(prgiSFNPos, piSFNPos, iSFNPosBefore, cch+2);
                    ResizeTempBuffer(rgchOut, cch+2+cchSegment+2);
                    if ( ! (ICHAR *) rgchOut )
                        return g_riMsiStringNull;
                    rgchOut[cch++] = TEXT('{');
                    rgchOut[cch++] = TEXT('{');
                    memcpy(&rgchOut[cch], rgchSegment, cchSegment * sizeof(ICHAR));
                    cch += cchSegment;
                    rgchOut[cch++] = TEXT('}');
                    rgchOut[cch++] = TEXT('}');
                }
                else if(fKeepComments)
                {
                    ShiftSFNIndexes(prgiSFNPos, piSFNPos, iSFNPosBefore, cch);
                    ResizeTempBuffer(rgchOut, cch+cchSegment);
                    if ( ! (ICHAR *) rgchOut )
                        return g_riMsiStringNull;
                    memcpy(&rgchOut[cch], rgchSegment, cchSegment * sizeof(ICHAR));
                    cch += cchSegment;
                }
#ifdef DEBUG
                else
                    Assert(0); // should have been handled above
#endif //DEBUG
            }
            else if (!fPropFound || fPropUnresolved) // there were no properties in the segment, we have to put back the {} in the string
            {
                ShiftSFNIndexes(prgiSFNPos, piSFNPos, iSFNPosBefore, cch+1);
                ResizeTempBuffer(rgchOut, cch+1+cchSegment+1);
                if ( ! (ICHAR *) rgchOut )
                    return g_riMsiStringNull;
                rgchOut[cch++] = TEXT('{');
                memcpy(&rgchOut[cch], rgchSegment, cchSegment * sizeof(ICHAR));
                cch += cchSegment;
                rgchOut[cch++] = TEXT('}');
            }
            else if (!fPropMissing) // all properties were resolved or there were no properties to resolve
            {
                // If no property is missing append the segment. If some property is missing, lose the whole segment
                ShiftSFNIndexes(prgiSFNPos, piSFNPos, iSFNPosBefore, cch);
                ResizeTempBuffer(rgchOut, cch+cchSegment);
                if ( ! (ICHAR *) rgchOut )
                    return g_riMsiStringNull;
                memcpy(&rgchOut[cch], rgchSegment, cchSegment * sizeof(ICHAR));
                cch += cchSegment;
            }
        }
    }
    MsiString istrOut;
    if ( ! (ICHAR *) rgchOut )
        return g_riMsiStringNull;
    // we take the perf hit on Win9X for DBCS possibility, on UNICODE, fDBCS arg is ignored
    memcpy(istrOut.AllocateString(cch, /*fDBCS=*/fTrue), (ICHAR*) rgchOut, cch * sizeof(ICHAR));
    return istrOut.Return();
}


void FormatSegment(const ICHAR *pchStart, const ICHAR *pchEnd, CTempBufferRef<ICHAR>& rgchOut, int& cchOut, Bool fInside, Bool& fPropFound, Bool& fPropMissing,
                                          Bool& fPropUnresolved, FORMAT_TEXT_CALLBACK lpfnResolveValue, IUnknown* piContext, int (*prgiSFNPos)[2], int* piSFNPos)
{
    // fInside indicates whether the string is originaly inside []
    fPropFound = fFalse;
    fPropMissing = fFalse;
    fPropUnresolved = fFalse;

    const ICHAR *pchIn;
    pchIn = pchStart;
    const ICHAR *pchP1Start = pchIn;
    int cchStart = cchOut;
    
    // divide the string into 3 parts: the text before the first pair of matching (outermost) [], the text inside and the text after (this third one remains in istrIn)
    while (pchIn < pchEnd)
    {
        if (FFindNextChar(pchIn, pchEnd, TEXT('[')))
        {
            int cchNew;

//          Assert(pchIn - pchP1Start <= INT_MAX);  //--merced: 64-bit ptr subtraction may lead to values too big for cchNew
            if ((cchNew = (int)(pchIn - pchP1Start)) > 0)
            {
                ResizeTempBuffer(rgchOut, cchOut + (int)(pchIn - pchP1Start));
                memcpy(&rgchOut[cchOut], pchP1Start, cchNew * sizeof(ICHAR));
                cchOut += cchNew;
                pchP1Start = pchIn;
            }

            // Don't increment pchIn, it will contain the first [
            int iCount =  1; // the count of brackets, [ = +1, ] = -1. We have found one [ already.
            const ICHAR* pch = pchIn+1;
            Bool fEscape = fFalse;
            Bool fSkipChar = fFalse;
            for (int cch = 1; pch < pchEnd; pch = ICharNext(pch), cch++)
            {
                if(fSkipChar)
                {
                    fSkipChar = fFalse;
                    continue;
                }
                else if(*pch == chFormatEscape)
                {
                    fEscape = fTrue;
                    fSkipChar = fTrue;
                    continue;
                }
                else if(!fEscape && *pch == TEXT('['))
                    iCount++;
                else if (*pch == TEXT(']'))
                {
                    iCount--;
                    fEscape = fFalse;
                }
                if (iCount == 0)
                    break;
            }
            if (iCount == 0) // we found a matching pair of []
            {
                const ICHAR *pchP2End = pch;
                
                Bool fSubPropFound;
                Bool fSubPropMissing;
                Bool fSubPropUnresolved;
                FormatSegment(pchIn + 1, pchP2End, rgchOut, cchOut, fTrue, *&fSubPropFound, *&fSubPropMissing,
                                            *&fSubPropUnresolved,lpfnResolveValue,piContext,prgiSFNPos,piSFNPos);
                pchIn = pch;
                if (fSubPropFound)
                    fPropFound = fTrue;
                if (fSubPropMissing)
                    fPropMissing = fTrue;
                if (fSubPropUnresolved)
                    fPropUnresolved = fTrue;
                pchP1Start = ICharNext(pch);
            }
            else // we did not find a matching pair, put back the [ and finish the string
            {
                int cchNew;
//              Assert(pchEnd - pchIn <= INT_MAX);  //--merced: 64-bit ptr subtraction may lead to values too big for cchNew

                // Since pchIn was not incremented above, it contains the starting [
                ResizeTempBuffer(rgchOut, cchOut + (cchNew = (int)(INT_PTR)(pchEnd - pchIn)));
                memcpy(&rgchOut[cchOut], pchIn, cchNew * sizeof(ICHAR));
                pchIn = pchEnd;
                cchOut += cchNew;
                pchP1Start = pchEnd;
            }
            pchIn = ICharNext(pchIn);
        }
    }
    if (pchP1Start < pchEnd)
    {
        int cchNew;
        Assert(pchEnd - pchP1Start <= INT_MAX); //--merced: 64-bit ptr subtraction may lead to values too big for cchNew

        ResizeTempBuffer(rgchOut, cchOut + (cchNew = (int)(INT_PTR)(pchEnd - pchP1Start)));
        memcpy(&rgchOut[cchOut], pchP1Start, cchNew * sizeof(ICHAR));
        cchOut += cchNew;
    }

    if (fInside)  // this whole string is in []
    {
        // use callback fn to resolve value
        fPropFound = fTrue;
        CTempBuffer<ICHAR, 100> rgchValueOut;
        int cch;
        Bool fSFN = fFalse;
        cch = lpfnResolveValue(&rgchOut[cchStart], cchOut - cchStart,rgchValueOut, fPropMissing,fPropUnresolved,fSFN,piContext);
        ResizeTempBuffer(rgchOut, cchOut = cchStart + cch);
        memcpy(&rgchOut[cchStart], (const ICHAR *)rgchValueOut, cch * sizeof(ICHAR));
        if(fSFN && prgiSFNPos)
        {
            Assert(piSFNPos && *piSFNPos < MAX_SFNS_IN_STRING);
            if(*piSFNPos < MAX_SFNS_IN_STRING)
            {
                prgiSFNPos[*piSFNPos][0] = cchStart;
                prgiSFNPos[*piSFNPos][1] = cch;
                *piSFNPos = *piSFNPos + 1;
            }
        }
    }
    return;
}


//____________________________________________________________________________
//
// CMsiRecordNull implementation
//____________________________________________________________________________


//
// Once we decide on an Out of memory solution we may want to change how
// this operates

HRESULT CMsiRecordNull::QueryInterface(const IID& riid, void** ppvObj)
{
    if (riid == IID_IUnknown || riid == IID_IMsiRecord)
    {
        *ppvObj = this;
        AddRef();
        return S_OK;
    }
    *ppvObj = 0;
    return E_NOINTERFACE;
}
unsigned long CMsiRecordNull::AddRef()
{

    return 1;           // Static Object

}

unsigned long CMsiRecordNull::Release()
{
    return 1;           // Static Object
}

int CMsiRecordNull::GetFieldCount() const
{
    return 0;
}

Bool CMsiRecordNull::IsInteger(unsigned int /* iParam */) const
{
    return fFalse;
}

Bool CMsiRecordNull::IsNull(unsigned int /* iParam */) const
{
    return fTrue;
}

const IMsiString& CMsiRecordNull::GetMsiString(unsigned int /* iParam */) const
{
    return g_riMsiStringNull;
}

const ICHAR* CMsiRecordNull::GetString(unsigned int /* iParam */) const
{
    return 0;
}

int CMsiRecordNull::GetInteger(unsigned int /* iParam */) const
{
    return iMsiStringBadInteger;
}

const IMsiData* CMsiRecordNull::GetMsiData(unsigned int /* iParam */) const
{
    return 0;
}

Bool CMsiRecordNull::SetMsiData(unsigned int /* iParam */, const IMsiData* /* piData */)
{
    return fFalse;
}

const HANDLE CMsiRecordNull::GetHandle(unsigned int /* iParam */) const
{
    return 0;
}

Bool CMsiRecordNull::SetHandle(unsigned int /* iParam */, const HANDLE /* hData */)
{
    return fFalse;
}

Bool CMsiRecordNull::SetMsiString(unsigned int /* iParam */, const IMsiString& /* riStr */)
{
    return fFalse;
}

Bool CMsiRecordNull::SetString(unsigned int /* iParam */, const ICHAR* /* sz */) 
{
    return fFalse;
}

Bool CMsiRecordNull::RefString(unsigned int /* iParam */, const ICHAR* /* sz */) 
{
    return fFalse;
}

Bool CMsiRecordNull::SetInteger(unsigned int /* iParam */, int /* iData */)
{
    return fFalse;
}

Bool CMsiRecordNull::SetNull(unsigned int /* iParam */)
{
    return fFalse;
}

int CMsiRecordNull::GetTextSize(unsigned int /* iParam */) const
{
    return 0;
}

void CMsiRecordNull::RemoveReferences()
{
}

Bool CMsiRecordNull::ClearData()
{
    return fFalse;
}

Bool CMsiRecordNull::IsChanged(unsigned int /* iParam */) const
{
    return fFalse;
}

void CMsiRecordNull::ClearUpdate()
{
}

const IMsiString& CMsiRecordNull::FormatText(Bool /*fComments*/)
{
    return g_riMsiStringNull;
}


//____________________________________________________________________________
//
// CEnumMsiRecord definition, implementation class for IEnumMsiRecord
//____________________________________________________________________________

class CEnumMsiRecord : public IEnumMsiRecord
{
 public:
    HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();

    HRESULT __stdcall Next(unsigned long cFetch, IMsiRecord** rgpi, unsigned long* pcFetched);
    HRESULT __stdcall Skip(unsigned long cSkip);
    HRESULT __stdcall Reset();
    HRESULT __stdcall Clone(IEnumMsiRecord** ppiEnum);

    CEnumMsiRecord(IMsiRecord** ppRecord, unsigned long i_Size);

 protected:
    virtual ~CEnumMsiRecord(void);  // protected to prevent creation on stack
    unsigned long    m_iRefCnt;      // reference count
    unsigned long    m_iCur;         // current enum position
    IMsiRecord**     m_ppRecord;     // Records we enumerate
    unsigned long    m_iSize;        // size of Record array
};

HRESULT CreateRecordEnumerator(IMsiRecord **ppRecord, unsigned long iSize, IEnumMsiRecord* &rpaEnumRec)
{
    rpaEnumRec = new CEnumMsiRecord(ppRecord, iSize);
    return S_OK;
}

CEnumMsiRecord::CEnumMsiRecord(IMsiRecord **ppRecord, unsigned long iSize):
        m_iCur(0), m_iSize(iSize), m_iRefCnt(1), m_ppRecord(0)
{
    if(m_iSize > 0)
    {
        m_ppRecord = new IMsiRecord* [m_iSize];
        if ( ! m_ppRecord )
        {
            m_iSize = 0;
            return;
        }

        for(unsigned long itmp = 0; itmp < m_iSize; itmp++)
        {
            // just share the interface
            m_ppRecord[itmp] = ppRecord[itmp];
            
            // therefore bump up the reference
            m_ppRecord[itmp]->AddRef();
        }
    }
}

CEnumMsiRecord::~CEnumMsiRecord()
{
    if(m_iSize > 0)
    {
        for(unsigned long itmp = 0; itmp < m_iSize; itmp++)
        {
            if(m_ppRecord[itmp])
                m_ppRecord[itmp]->Release();       
        }
        delete [] m_ppRecord;
    }
}

unsigned long CEnumMsiRecord::AddRef()
{
    return ++m_iRefCnt;
}

unsigned long CEnumMsiRecord::Release()
{
    if (--m_iRefCnt != 0)
        return m_iRefCnt;
    delete this;
    return 0;
}

HRESULT CEnumMsiRecord::Next(unsigned long cFetch, IMsiRecord** rgpi, unsigned long* pcFetched)
{
    unsigned long cFetched = 0;
    unsigned long cRequested = cFetch;

    if (rgpi)
    {
        while (m_iCur < m_iSize && cFetch > 0)
        {
            *rgpi = m_ppRecord[m_iCur];
            m_ppRecord[m_iCur]->AddRef();
            rgpi++;
            cFetched++;
            m_iCur ++;
            cFetch--;
        }
    }
    if (pcFetched)
        *pcFetched = cFetched;
    return (cFetched == cRequested ? S_OK : S_FALSE);
}

HRESULT CEnumMsiRecord::Skip(unsigned long cSkip)
{
    if ((m_iCur+cSkip) > m_iSize)
    return S_FALSE;

    m_iCur+= cSkip;
    return S_OK;
}

HRESULT CEnumMsiRecord::Reset()
{
    m_iCur=0;
    return S_OK;
}

HRESULT CEnumMsiRecord::Clone(IEnumMsiRecord** ppiEnum)
{
    *ppiEnum = new CEnumMsiRecord(m_ppRecord, m_iSize);
    if ( ! *ppiEnum )
        return E_OUTOFMEMORY;
    ((CEnumMsiRecord* )*ppiEnum)->m_iCur = m_iCur;
    return S_OK;
}

HRESULT CEnumMsiRecord::QueryInterface(const IID& riid, void** ppvObj)
{
    if (riid == IID_IUnknown || riid == IID_IEnumMsiRecord)
    {
        *ppvObj = this;
        AddRef();
        return S_OK;
    }
    *ppvObj = 0;
    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\script.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       script.cpp
//
//--------------------------------------------------------------------------

/* script.cpp - CScriptGenerate implementation
____________________________________________________________________________*/

#include "precomp.h"
#include "version.h"
#include "engine.h"
#include "_engine.h"


CScriptGenerate::CScriptGenerate(IMsiStream& riScriptOut, int iLangId, int iTimeStamp, istEnum istScriptType,
											isaEnum isaScriptAttributes, IMsiServices& riServices)
	: m_riScriptOut(riScriptOut)
	, m_riServices(riServices)
	, m_iProgressTotal(0)
	, m_iTimeStamp(iTimeStamp)
	, m_iLangId(iLangId)
	, m_istScriptType(istScriptType)
	, m_isaScriptAttributes(isaScriptAttributes)
	, m_ixoPrev(ixoNoop)
{
	riScriptOut.AddRef();
	riServices.AddRef();
	if (istScriptType != istRollback)
		m_piPrevRecord = &riServices.CreateRecord(cRecordParamsStored);
	else
		m_piPrevRecord = 0;
}


CScriptGenerate::~CScriptGenerate()
{
	using namespace IxoEnd;
	// Output script trailer
	PMsiRecord pRecord(&m_riServices.CreateRecord(Args));
	pRecord->SetInteger(Checksum, 0) ; //!! JDELO... what's the checksum supposed to be? JDELO: whatever we can easily compute.
	pRecord->SetInteger(ProgressTotal, m_iProgressTotal);
	WriteRecord(ixoEnd, *pRecord, true);
	if (m_piPrevRecord != 0)
	{
		m_piPrevRecord->Release();
		m_piPrevRecord = 0;
	}
	m_riScriptOut.Release();
	m_riServices.Release();
	
}

void CScriptGenerate::SetProgressTotal(int iProgressTotal)
{
	m_iProgressTotal = iProgressTotal;
}

bool PostScriptWriteError(IMsiMessage& riMessage)
/* -----------------------------------------------------------
 Posts a "script write" error, and allows user to retry/cancel.
 If user cancels, false is returned.
------------------------------------------------------------*/
{
	PMsiRecord pError = PostError(Imsg(imsgScriptWriteError));
	imsEnum ims = riMessage.Message(imtEnum(imtError+imtRetryCancel+imtDefault1),*pError);
	if (ims == imsCancel || ims == imsNone)
		return false;
	else
		return true;
}

bool WriteScriptRecord(CScriptGenerate* pScript, ixoEnum ixoOpCode, IMsiRecord& riParams,
							  bool fForceFlush, IMsiMessage& riMessage)
{
	while (pScript->WriteRecord(ixoOpCode, riParams, fForceFlush) == false)
	{
		if (PostScriptWriteError(riMessage) == fFalse)
			return false;
	}
	return true;
}

bool CScriptGenerate::WriteRecord(ixoEnum ixoOpCode, IMsiRecord& riParams, bool fForceFlush)
{
	IMsiRecord* piRecord = m_piPrevRecord;	
	if (ixoOpCode != m_ixoPrev)
		piRecord = 0;
	bool fRet = m_riServices.FWriteScriptRecord(ixoOpCode, m_riScriptOut, riParams, piRecord, fForceFlush);
	m_ixoPrev = ixoOpCode;
	if (m_piPrevRecord)
		CopyRecordStringsToRecord(riParams, *m_piPrevRecord);
	return fRet;
}

bool CScriptGenerate::InitializeScript(WORD wTargetProcessorArchitecture)
{
	DWORD dwPlatform;
	// Platform: low word is processor script was created on - high word is "package platform"
	//           will only be different in case of x86 script generated on amd64 machine

	if ((wTargetProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) ||
	    (wTargetProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) ||
	    (wTargetProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 ))
		dwPlatform = MAKELONG(/*low*/PROCESSOR_ARCHITECTURE_INTEL,/*high*/wTargetProcessorArchitecture);
	else
		return false;

	// Output script header
	using namespace IxoHeader;
	PMsiRecord pScriptHeader(&m_riServices.CreateRecord(Args));
	pScriptHeader->SetInteger(Signature, iScriptSignature);
	pScriptHeader->SetInteger(Version, rmj * 100 + rmm);  // version of MsiExecute
	pScriptHeader->SetInteger(Timestamp, m_iTimeStamp);
	pScriptHeader->SetInteger(LangId, m_iLangId);
	pScriptHeader->SetInteger(Platform,dwPlatform);
	pScriptHeader->SetInteger(ScriptType, (int)m_istScriptType);
	pScriptHeader->SetInteger(ScriptMajorVersion, iScriptCurrentMajorVersion);
	pScriptHeader->SetInteger(ScriptMinorVersion, iScriptCurrentMinorVersion);
	pScriptHeader->SetInteger(ScriptAttributes, (int)m_isaScriptAttributes);

	return WriteRecord(ixoHeader, *pScriptHeader, false);
}

void CopyRecordStringsToRecord(IMsiRecord& riRecordFrom, IMsiRecord& riRecordTo)
{
	int iParam = min(riRecordFrom.GetFieldCount(), riRecordTo.GetFieldCount());

	riRecordTo.ClearData();
	
	while (iParam >= 0)
	{
		if (!riRecordFrom.IsNull(iParam) && !riRecordFrom.IsInteger(iParam))
		{
			IMsiString* piString;

			PMsiData pData = riRecordFrom.GetMsiData(iParam);
			
			if (pData && pData->QueryInterface(IID_IMsiString, (void**)&piString) == NOERROR)
			{
				riRecordTo.SetMsiString(iParam, *piString);
				piString->Release();
			}
		}
		iParam--;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\regkey.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       regkey.cpp
//
//--------------------------------------------------------------------------

/* regkey.cpp - IMsiRegKey implementation

Registry access object
____________________________________________________________________________*/


#include "precomp.h"
#include "services.h"
#include "regkey.h"
#include "_service.h"

#include <aclapi.h>


// root key strings
const ICHAR* szHCR = TEXT("HKEY_CLASSES_ROOT");
const ICHAR* szHCU = TEXT("HKEY_CURRENT_USER");
const ICHAR* szHLM = TEXT("HKEY_LOCAL_MACHINE");
const ICHAR* szHU  = TEXT("HKEY_USERS");

// special case - don't delete
const ICHAR* rgszHKLMNeverRemoveKeys[] = {
	TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce"),
	TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx"),
	TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run")};
// local functions

// function to increase the max registry size
bool IncreaseRegistryQuota(int iIncrementKB)
{
    if(g_fWin9X)
        return false; // not supported on Win95

    SYSTEM_REGISTRY_QUOTA_INFORMATION RegistryQuotaInfo;
    if(NTDLL::NtQuerySystemInformation(SystemRegistryQuotaInformation,
                                       &RegistryQuotaInfo,
                                       sizeof(SYSTEM_REGISTRY_QUOTA_INFORMATION),
                                       0) == S_OK)
    {
        int iOriginalQuota = RegistryQuotaInfo.RegistryQuotaAllowed;
        // default attempt to increase registry quota
        // first attempt to increase quota by 8mb, then by 1 mb
        static const int rgiQuotaIncrement[] = {0x800000, 0x100000, 0}; 
        int cTries = sizeof(rgiQuotaIncrement) / sizeof(int);
        const int* pQuotaIncrement = rgiQuotaIncrement;
        int iQuotaIncrement;
        if(iIncrementKB)
        {
            int iQuotaRequired = iIncrementKB*1024; // if exact requirement specified try only that
            if(iOriginalQuota - RegistryQuotaInfo.RegistryQuotaUsed >= iQuotaRequired)
                return true; // we have enough space
            else
            {
                iQuotaIncrement = iQuotaRequired - (iOriginalQuota - RegistryQuotaInfo.RegistryQuotaUsed);
                pQuotaIncrement = &iQuotaIncrement;
                cTries = 1;
            }
        }

        if(!IsImpersonating() || IsClientPrivileged(SE_INCREASE_QUOTA_NAME))
        {
            CElevate elevate;
            
            if(AcquireTokenPrivilege(SE_INCREASE_QUOTA_NAME))
            {
                for (;cTries; pQuotaIncrement++, cTries--)
                {
                    RegistryQuotaInfo.RegistryQuotaAllowed = iOriginalQuota + *pQuotaIncrement; 
                    if(NTDLL::NtSetSystemInformation(SystemRegistryQuotaInformation,
                                                     &RegistryQuotaInfo,
                                                    sizeof(SYSTEM_REGISTRY_QUOTA_INFORMATION)) == S_OK)
                    {
                        // write the value to HKLM\System\CurrentControlSet\Control:RegistrySizeLimit persist it
                        HKEY hKey;
                        LONG dwResult = MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE,  
                                        TEXT("System\\CurrentControlSet\\Control"),  
                                        0,       // reserved 
                                        KEY_SET_VALUE,
                                        &hKey);
                        if(dwResult == ERROR_SUCCESS)
                        {
                            dwResult = RegSetValueEx(   hKey,
                                            TEXT("RegistrySizeLimit"),
                                            0,
                                            REG_DWORD,
                                            (CONST BYTE*)&RegistryQuotaInfo.RegistryQuotaAllowed, 
                                            sizeof(DWORD));
                            if(dwResult != ERROR_SUCCESS)
                            {
                                DEBUGMSG1(TEXT("Could not persist registry quota increase, RegSetValueEx returned: %d"), (const ICHAR*)(UINT_PTR)dwResult);
                            }
                            RegCloseKey(hKey);
                        }
                        else
                        {
                            DEBUGMSG1(TEXT("Could not persist registry quota increase, RegOpenKeyEx returned: %d"), (const ICHAR*)(UINT_PTR)dwResult);
                        }
                        return true;
                    }
                }
            }
        }
    }
    DEBUGMSG(TEXT("Could not increase registry quota"));
    return false;
}

void BuildFullRegKey(const HKEY hRoot, const ICHAR* rgchSubKey, 
                            const ibtBinaryType iType, const IMsiString*& rpistrFullKey)
{
    const ICHAR *pch;

    if(hRoot == HKEY_USERS)
        pch = szHU;
    else if(hRoot == HKEY_CURRENT_USER)
        pch = szHCU;
    else if(hRoot == HKEY_CLASSES_ROOT)
        pch = szHCR;
    else if(hRoot == HKEY_LOCAL_MACHINE)
        pch = szHLM;
    else
        pch = TEXT("UNKNOWN");
    rpistrFullKey = &CreateString();
    rpistrFullKey->SetString(pch, rpistrFullKey);

    if ( g_fWinNT64 && iType == ibt32bit )
        rpistrFullKey->AppendString(TEXT("32"), rpistrFullKey);

    if( rgchSubKey && *rgchSubKey )
    {
        rpistrFullKey->AppendString(szRegSep, rpistrFullKey);
        rpistrFullKey->AppendString(rgchSubKey, rpistrFullKey);
    }
}

inline bool IsRootKey(HKEY hKey) { return hKey != (HKEY)rrkClassesRoot && 
                                                        hKey != (HKEY)rrkCurrentUser &&
                                                        hKey != (HKEY)rrkLocalMachine &&
                                                        hKey != (HKEY)rrkUsers ? false : true; }

//  checks if ristrQuestioned is a subkey of rgchKey and returns true if so.
//
//  For example, it return true if
//    ristrQuestioned is "Software\\Classes\\.cpp" and rgchKey is "Software\\Classes".

bool IsSubkeyOf(const IMsiString& ristrQuestioned, const ICHAR* rgchKey)
{
    if ( !*rgchKey )
        //  any key is a subkey of an empty key
        return true;

    if ( !ristrQuestioned.Compare(iscStartI, rgchKey) )
        //  rgchKey string and the first IStrLen(rgchKey) characters in
        //  rpistrQuestioned are different.
        return false;

    //  checking the first character in rpistrQuestioned that's past rgchKey.
    //  If it is either '\0' or '\\', return true.
    ICHAR* pszQ = (ICHAR*)ristrQuestioned.GetString();
    int iKLen = IStrLen(rgchKey);
    pszQ += iKLen;

    if ( !*pszQ )
        return true;
    else if ( *pszQ == chRegSep
/* (not necessary for the usages we have at this point)
#ifndef UNICODE
                 && !WIN::IsDBCSLeadByte(*(pszQ-1))
#endif
*/
              )
        return true;
    else
        return false;
}

void ClearEmptyTree(HKEY hkeyR, const ICHAR* pszFullKey, const int iT)
{
    ibtBinaryType iType = (ibtBinaryType)iT;

    DWORD dwNumValues = 0;
    DWORD dwNumKeys = 0;

    MsiString strKey = pszFullKey;
    MsiString strSubkey;
    HKEY hkeyT;
    HRESULT lResult;
    REGSAM samDesired = KEY_READ;
    if ( g_fWinNT64 )
        samDesired |= (iType == ibt64bit ? KEY_WOW64_64KEY : KEY_WOW64_32KEY);
    for(;;)
    {
        // Open the key
        lResult = RegOpenKeyAPI(hkeyR,  
                                strKey,  
                                (DWORD)0,       // reserved 
                                samDesired,
                                &hkeyT);
        if(ERROR_SUCCESS == lResult)
        {
            // delete the subkey, if set
            if(strSubkey.TextSize())
                WIN::RegDeleteKey(hkeyT, strSubkey); //?? ignore return
            lResult = RegQueryInfoKey(  hkeyT, 
                                        0,        
                                        0,        
                                        0,      // reserved 
                                        &dwNumKeys,
                                        0,
                                        0,
                                        &dwNumValues,
                                        0,
                                        0,
                                        0,
                                        0);
        }
        // removed the last node
        if(!strKey.TextSize())
        {
            WIN::RegCloseKey(hkeyT);
            return ;
        }
        if(ERROR_SUCCESS != lResult)
            strSubkey = TEXT("");// empty subkey. since we cannot delete if we had an error
        else
        {
            bool fIsEmpty = false;
            if ( dwNumKeys == 0 )
            {
                if ( dwNumValues == 0 )
                {
                    fIsEmpty = true;
                    // special-case: never delete any of these system keys.
                    if ( !g_fWin9X && (hkeyR == HKEY_LOCAL_MACHINE) )
                    {
                        for (int i = 0;
                             i < sizeof(rgszHKLMNeverRemoveKeys)/sizeof(rgszHKLMNeverRemoveKeys[0]);
                             i++)
                        {
                            if ( 0 == IStrCompI(strKey, rgszHKLMNeverRemoveKeys[i]) )
                            {
                                fIsEmpty = false;
                                break;
                            }
                        }
                    }
                }
                else if ( g_fWinNT64 && dwNumValues == 1 && ERROR_SUCCESS == 
                             WIN::RegQueryValueEx(hkeyT, TEXT("Wow6432KeyValue"), 0, 0, 0, 0) )
                    //!! eugend:
                    // the Wow6432KeyValue value belongs to the OS and if it is the only thing left
                    // in the key we consider it empty.  Wow6432KeyValue is planned to go away post
                    // NT 5.1 RC1 all these tests should become "dwNumKeys || dwNumValues" again by then.
                    fIsEmpty = true;
            }
            if ( !fIsEmpty )
            {
                WIN::RegCloseKey(hkeyT);
                return;// we cannot clean up any further
            }
            strSubkey = strKey.Extract(iseAfter, chRegSep);
        }
        WIN::RegCloseKey(hkeyT);
        if(strKey.Remove(iseFrom, chRegSep) == fFalse)
            strKey = TEXT(""); // reached end
    }
}

class CMsiRegKey : public IMsiRegKey {
 public:
    HRESULT                 __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long   __stdcall AddRef();
    unsigned long   __stdcall Release();
    IMsiRecord*    __stdcall RemoveValue(const ICHAR* szValueName, const IMsiString* pistrValue); 
    IMsiRecord*    __stdcall RemoveSubTree(const ICHAR* szSubKey);
    IMsiRecord*    __stdcall GetValue(const ICHAR* szValueName, const IMsiString*& pstr);     
    IMsiRecord*    __stdcall SetValue(const ICHAR* szValueName, const IMsiString& ristrValue);
    IMsiRecord*    __stdcall GetValueEnumerator(IEnumMsiString*& rpiEnumString);
    IMsiRecord*    __stdcall GetSubKeyEnumerator(IEnumMsiString*& rpiEnumString);
    IMsiRecord*     __stdcall GetSelfRelativeSD(IMsiStream*& rpiSD);
    IMsiRecord*    __stdcall Exists(Bool& fExists);
    IMsiRecord*    __stdcall Create();
    IMsiRecord*    __stdcall Remove();
    IMsiRegKey&    __stdcall CreateChild(const ICHAR* szSubKey, IMsiStream* pSD = NULL);
    const IMsiString&    __stdcall GetKey();
    IMsiRecord*    __stdcall ValueExists(const ICHAR* szValueName, Bool& fExists);

 public:  // constructor
    CMsiRegKey(IMsiRegKey& riaParent, HKEY Root, const IMsiString & riKey, IMsiStream* pSD, IMsiServices*  piAsvc, const ibtBinaryType iType);

    CMsiRegKey(HKEY hkeyRoot, IMsiServices*  piAsvc, const ibtBinaryType iType);

    virtual ~CMsiRegKey(void);
    void* operator new(size_t cb);
    void  operator delete(void * pv);
 private:
    int  m_iRefCnt;
    IMsiServices*  m_piAsvc;                         
    HKEY m_hkey;
    Bool m_bOpen;
    Bool m_bIsRoot;
    MsiString m_strSubKey;  // key below root (e.g. Software\Microsoft)
    MsiString m_strFullKey;  // key including root (e.g. HKEY_LOCAL_MACHINE\Software\Microsoft)
    IMsiRegKey* m_piaParent;
    HKEY m_Root;
    rrwEnum m_ergRWVal;

    IMsiStream* m_pSD; // Holder for current security descriptor.  
                     // Used by CreateChild to hold prospective SD
                     // for key that *may* be created.

    IMsiRecord* InitMsiRegKey(rrwEnum ergVal, Bool fCreate);
    IMsiRecord* SetRawValue(const ICHAR* szValueName, CTempBufferRef<char>& rgchInBuffer, DWORD dwType);
    IMsiRecord* GetRawValue(const ICHAR* szValueName, CTempBufferRef<char>& rgchOutBuffer, DWORD&rdwType);

    void SetFullKey(); //sets m_strFullKey
    ibtBinaryType m_iBinaryType;
};

inline void* CMsiRegKey::operator new(size_t cb) {return AllocObject(cb);}
inline void  CMsiRegKey::operator delete(void * pv) { FreeObject(pv); }

// Root keys container
class CRootKeyHolder{
public:
    CRootKeyHolder(IMsiServices*  piAsvc);
    ~CRootKeyHolder(void);
    IMsiRegKey& GetRootKey(rrkEnum rrkRoot, const ibtBinaryType iType);
private:
    // "global" open 8 root keys
    CMsiRegKey*    m_pregUsers;
    CMsiRegKey*    m_pregUser;
    CMsiRegKey*    m_pregClasses;
    CMsiRegKey*    m_pregMc;
    CMsiRegKey*    m_pregUsers64;
    CMsiRegKey*    m_pregUser64;
    CMsiRegKey*    m_pregClasses64;
    CMsiRegKey*    m_pregMc64;

    // pointer to services // unref'd
    IMsiServices* m_piAsvc;
};

CRootKeyHolder* CreateMsiRegRootKeyHolder(IMsiServices*  piAsvc )
{
    return new  CRootKeyHolder(piAsvc);
}

void DeleteRootKeyHolder(CRootKeyHolder* aRootKeyH)
{
    delete  aRootKeyH;
}

IMsiRegKey& GetRootKey(CRootKeyHolder* aRootKeyH, rrkEnum rrkRoot, const ibtBinaryType iType)
{
    return aRootKeyH->GetRootKey(rrkRoot, iType);
}

CRootKeyHolder::CRootKeyHolder(IMsiServices*  piAsvc ) : m_piAsvc(piAsvc)
{
    m_pregUsers = new CMsiRegKey(HKEY_USERS, piAsvc, ibt32bit);
    m_pregUser = new CMsiRegKey(HKEY_CURRENT_USER, piAsvc, ibt32bit);
    m_pregClasses = new CMsiRegKey(HKEY_CLASSES_ROOT, piAsvc, ibt32bit);
    m_pregMc = new CMsiRegKey(HKEY_LOCAL_MACHINE, piAsvc, ibt32bit);
    if ( g_fWinNT64 )
    {
        m_pregUsers64 = new CMsiRegKey(HKEY_USERS, piAsvc, ibt64bit);
        m_pregUser64 = new CMsiRegKey(HKEY_CURRENT_USER, piAsvc, ibt64bit);
        m_pregClasses64 = new CMsiRegKey(HKEY_CLASSES_ROOT, piAsvc, ibt64bit);
        m_pregMc64 = new CMsiRegKey(HKEY_LOCAL_MACHINE, piAsvc, ibt64bit);
    }
    else
        m_pregUsers64 = m_pregUser64 = m_pregClasses64 = m_pregMc64 = 0;
}

CRootKeyHolder::~CRootKeyHolder(void)
{
    delete m_pregUsers;
    delete m_pregUser;
    delete m_pregClasses;
    delete m_pregMc;
    if ( g_fWinNT64 )
    {
        delete m_pregUsers64;
        delete m_pregUser64;
        delete m_pregClasses64;
        delete m_pregMc64;
    }
}


// Purpose: The MsiRegKey factory

IMsiRegKey& CRootKeyHolder::GetRootKey(rrkEnum rrkRoot, const ibtBinaryType iT)
{
    ibtBinaryType iType;
    if ( iT == ibtUndefined || iT == ibtCommon )
        iType = g_fWinNT64 ? ibt64bit : ibt32bit;
    else
        iType = iT;

    if ( iType == ibt64bit )
    {
        if ( g_fWinNT64 )
        {
            switch((INT_PTR)(HKEY)rrkRoot)          //--merced: changed int to INT_PTR
            {
            case (INT_PTR)HKEY_USERS:               //--merced: changed int to INT_PTR
                m_pregUsers64->AddRef();
                return *m_pregUsers64;
            case (INT_PTR)HKEY_CURRENT_USER:        //--merced: changed int to INT_PTR
                m_pregUser64->AddRef();
                return *m_pregUser64;
            case (INT_PTR)HKEY_CLASSES_ROOT:        //--merced: changed int to INT_PTR
                m_pregClasses64->AddRef();
                return *m_pregClasses64;
            case (INT_PTR)HKEY_LOCAL_MACHINE:       //--merced: changed int to INT_PTR
                m_pregMc64->AddRef();
                return *m_pregMc64;
            default:    // we have not cached the key
                return *new CMsiRegKey((HKEY)rrkRoot, m_piAsvc, ibt64bit);
             }
        }
        else
            AssertSz(0, TEXT("ibt32bit value expected on non-64 bit OS (eugend)"));
    }

    switch((INT_PTR)(HKEY)rrkRoot)          //--merced: changed int to INT_PTR
    {
    case (INT_PTR)HKEY_USERS:               //--merced: changed int to INT_PTR
        m_pregUsers->AddRef();
        return *m_pregUsers;
    case (INT_PTR)HKEY_CURRENT_USER:        //--merced: changed int to INT_PTR
        m_pregUser->AddRef();
        return *m_pregUser;
    case (INT_PTR)HKEY_CLASSES_ROOT:        //--merced: changed int to INT_PTR
        m_pregClasses->AddRef();
        return *m_pregClasses;
    case (INT_PTR)HKEY_LOCAL_MACHINE:       //--merced: changed int to INT_PTR
        m_pregMc->AddRef();
        return *m_pregMc;
    default:    // we have not cached the key
        return *new CMsiRegKey((HKEY)rrkRoot, m_piAsvc, ibt32bit);
    }
}

CMsiRegKey::CMsiRegKey(HKEY hkeyRoot,IMsiServices*  piAsvc, const ibtBinaryType iType/*=ibt32bit*/):
    m_piAsvc(piAsvc), m_bOpen(fTrue), m_bIsRoot(fTrue), m_iBinaryType(iType)
{
    // note: we do not add ref cnt. for services for the cached regkey objects since we expect
    // services to contain us.
    m_hkey = m_Root = hkeyRoot;
    m_piaParent = 0;
    m_pSD = 0;
#ifdef DEBUG
    m_iRefCnt = 0;
#endif //DEBUG
    switch((INT_PTR)m_Root)             //--merced: changed int to INT_PTR
    {
    case (INT_PTR)HKEY_USERS:               //--merced: changed int to INT_PTR
    case (INT_PTR)HKEY_CURRENT_USER:        //--merced: changed int to INT_PTR
    case (INT_PTR)HKEY_CLASSES_ROOT:        //--merced: changed int to INT_PTR
    case (INT_PTR)HKEY_LOCAL_MACHINE:       //--merced: changed int to INT_PTR
        break;
    default :
        // assume that an HKEY has been passed in, other than the cached keys
        m_iRefCnt = 1;     // we're returning an interface, passing ownership
        m_piAsvc->AddRef();
        break;
    }
    m_strFullKey = 0;
}


CMsiRegKey::CMsiRegKey(IMsiRegKey& riaParent, HKEY Root, const IMsiString & riKey, IMsiStream* pSD, IMsiServices*  piAsvc, const ibtBinaryType iType/*=ibt32bit*/):
m_piAsvc(piAsvc), m_bOpen(fFalse), m_bIsRoot(fFalse), m_Root(Root), m_pSD(0), m_iBinaryType(iType)
{
    m_hkey = NULL;
    m_piaParent = &riaParent;
    // this ensures that IF the parent key is open we keep it that way!!
    // meant for speeding up reg key stuff
    riaParent.AddRef();

    if (pSD)
    {
        // hold a prospective security descriptor
        pSD->AddRef();
        m_pSD = pSD;
    }

    m_iRefCnt = 1;     // we're returning an interface, passing ownership
    m_piAsvc->AddRef();
    m_strSubKey = riKey;
    riKey.AddRef();
    m_strFullKey = 0;
}

CMsiRegKey::~CMsiRegKey(void)
{
    if((fFalse == m_bIsRoot) && (fTrue == m_bOpen))
        WIN::RegCloseKey(m_hkey);

    if (m_pSD)
        m_pSD->Release();

    if(m_piaParent)
        m_piaParent->Release();
}


IMsiRegKey& CMsiRegKey::CreateChild(const ICHAR* szSubKey, IMsiStream* pSD)
{
    MsiString astr = m_strSubKey;
    if(astr.TextSize() != 0)
        astr += szRegSep;
    astr += szSubKey;

    // Note that reg keys do *not* inherit their parent
    // security descriptor.

    return *(new CMsiRegKey(*this, m_Root, *astr, pSD, m_piAsvc, m_iBinaryType));
}

IMsiRecord*    CMsiRegKey::Exists(Bool& fExists)
{
    if ( !g_fWinNT64 && m_iBinaryType == ibt64bit )
        return PostError(Imsg(idbg64bitRegOpOn32bit), *MsiString(GetKey()));

    long lResult; 
    if(fTrue == m_bIsRoot)
    {
        // root is always open
        m_bOpen = fTrue;
        fExists = fTrue;
        return 0;
    }

    REGSAM samDesired = KEY_READ;
    if ( g_fWinNT64 )
        samDesired |= (m_iBinaryType == ibt64bit ? KEY_WOW64_64KEY : KEY_WOW64_32KEY);

    if(fTrue != m_bOpen)
    {
        // if not already opened
        lResult = RegOpenKeyAPI(m_Root, 
                                m_strSubKey,   
                                0, // reserved 
                                samDesired,
                                &m_hkey);
        if(lResult == ERROR_SUCCESS)
        {
            m_bOpen = fTrue;
            fExists = fTrue;
            m_ergRWVal = rrwRead;
            return 0;
        }
        else if(ERROR_FILE_NOT_FOUND == lResult)
        {
            //ok, key does not exist
            m_bOpen = fExists = fFalse;
            return 0;
        }
        else
        {
            // error
            return PostError(Imsg(imsgOpenKeyFailed), *MsiString(GetKey()), lResult);
        }
    }
    else
    {
        // ensure key is not deleted externally
        // Open the duplicate key
        HKEY hkeyT;
        lResult = RegOpenKeyAPI(m_hkey,  
                                0,  
                                0,       // reserved 
                                samDesired,
                                &hkeyT);
        if(lResult == ERROR_SUCCESS)
        {
            // close temp key
            WIN::RegCloseKey(hkeyT);
            fExists = fTrue;
            return 0;
        }
        else if((ERROR_FILE_NOT_FOUND == lResult) || (ERROR_KEY_DELETED == lResult))
        {
            // key was deleted from outside
            fExists = fFalse;
            return 0;
        }
        else // error
        {
            // error
            return PostError(Imsg(imsgOpenKeyFailed), *MsiString(GetKey()), lResult);
        }
    }
}

IMsiRecord*    CMsiRegKey::Create()
{
    Bool fExists;
    IMsiRecord* piError = Exists(fExists);
    if(piError)
        return piError;
    if(fExists == fFalse)
        return InitMsiRegKey(rrwWrite,fTrue);                  
    else
    {
        // Set a security descriptor on a key
        // that already exists.

        if (!m_pSD)
            return 0;

        if (rrwWrite != m_ergRWVal)
            piError = InitMsiRegKey(rrwWrite, fTrue);
        if (piError)
            return piError;

        return 0;
    }
    
}


IMsiRecord*    CMsiRegKey::Remove()
{
    return RemoveSubTree(0);
}

const IMsiString& CMsiRegKey::GetKey()
{
    if (m_strFullKey == 0)
        SetFullKey();
    return m_strFullKey.Return();
}

// SetFullKey fn - called to set m_strFullKey, must be called after
//  m_strSubKey and m_Root are set.
void CMsiRegKey::SetFullKey()
{
    BuildFullRegKey(m_Root, m_strSubKey, m_iBinaryType, *&m_strFullKey);
}

HRESULT CMsiRegKey::QueryInterface(const IID& riid, void** ppvObj)
{
    if (riid == IID_IUnknown || riid == IID_IMsiRegKey)
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    *ppvObj = 0;
    return E_NOINTERFACE;
}

unsigned long CMsiRegKey::AddRef()
{
    if(fTrue == m_bIsRoot)
    {
        switch((INT_PTR)m_Root)             //--merced: changed int to INT_PTR
        {
        case (INT_PTR)HKEY_USERS:               //--merced: changed int to INT_PTR
        case (INT_PTR)HKEY_CURRENT_USER:                //--merced: changed int to INT_PTR
        case (INT_PTR)HKEY_CLASSES_ROOT:                //--merced: changed int to INT_PTR
        case (INT_PTR)HKEY_LOCAL_MACHINE:               //--merced: changed int to INT_PTR
            return m_piAsvc->AddRef();// we share ref cnt with services.
        default:
            return ++m_iRefCnt;
        }
    }
    else
    {
        return ++m_iRefCnt;
    }
}

unsigned long CMsiRegKey::Release()
{
    if(fTrue != m_bIsRoot)
    {
        if (--m_iRefCnt != 0)
            return m_iRefCnt;
        IMsiServices* piServices = m_piAsvc;
        delete this;
        piServices->Release();
        return 0;
    }
    else
    {
        // NOTE: never called be the CRootKeyHolder class
        // release services (ref cnt relects the cnt for this obj. too)
        switch((INT_PTR)m_Root)             //--merced: changed int to INT_PTR
        {
        case (INT_PTR)HKEY_USERS:               //--merced: changed int to INT_PTR
        case (INT_PTR)HKEY_CURRENT_USER:                //--merced: changed int to INT_PTR
        case (INT_PTR)HKEY_CLASSES_ROOT:                //--merced: changed int to INT_PTR
        case (INT_PTR)HKEY_LOCAL_MACHINE:               //--merced: changed int to INT_PTR
            m_piAsvc->Release();
            return 1;
        default:
        {
            if (--m_iRefCnt != 0)
                return m_iRefCnt;
            IMsiServices* piServices = m_piAsvc;
            delete this;
            piServices->Release();
            return 0;
        }
        }
    }
}


IMsiRecord* CMsiRegKey::InitMsiRegKey(rrwEnum ergVal, Bool fCreate)
{
    if ( !g_fWinNT64 && m_iBinaryType == ibt64bit )
        return PostError(Imsg(idbg64bitRegOpOn32bit), *MsiString(GetKey()));

    long lResult = ERROR_FUNCTION_FAILED; 
    if(fTrue == m_bIsRoot)
    {
        // root is always open
        m_bOpen = fTrue;
        return 0;
    }

    // set default read & write access. we need to be careful here not to ask
    // for too much access or we'll fail in certain cases. for example,
    // non-Admins don't usually have WRITE_DAC or WRITE_OWNER access so 
    // we only request these if we're writing a security descriptor.

    REGSAM RegSamReadRequested  = KEY_READ /*| ACCESS_SYSTEM_SECURITY*/;
    REGSAM RegSamWriteRequested = KEY_WRITE | KEY_READ/*| ACCESS_SYSTEM_SECURITY*/;
    if ( g_fWinNT64 )
    {
        RegSamReadRequested  |= (m_iBinaryType == ibt64bit ? KEY_WOW64_64KEY : KEY_WOW64_32KEY);
        RegSamWriteRequested |= (m_iBinaryType == ibt64bit ? KEY_WOW64_64KEY : KEY_WOW64_32KEY);
    }

    if(fTrue == m_bOpen)
    {
        if((rrwRead == m_ergRWVal) && (rrwWrite == ergVal))
        {
            // will have to reopen 
            WIN::RegCloseKey(m_hkey);
            m_bOpen = fFalse;
        }
        else
            return 0;
    }
    // if not already opened
    for(int iContinueRetry = 3; iContinueRetry--;)// try thrice, prevent possibly endless recursion
    {       
        if(fTrue == fCreate)
        {
            CTempBuffer<char, cbDefaultSD> pchSD;
            SECURITY_ATTRIBUTES sa;
            SECURITY_INFORMATION siAvailable = 0;
            
            if (m_pSD)
            {
                // we need permission to write the DAC and potentially the owner so we'll ask for both //?? should we always be asking for owner access?
                RegSamWriteRequested |= (WRITE_DAC | WRITE_OWNER);

                // set security on the key
                m_pSD->Reset();

                int cbSD = m_pSD->GetIntegerValue();
                if (cbDefaultSD < cbSD)
                    pchSD.SetSize(cbSD);
                    
                // Self Relative Security Descriptor
                m_pSD->GetData(pchSD, cbSD);
                AssertNonZero(WIN::IsValidSecurityDescriptor(pchSD));

                // Add the security descriptor to the sa structure
                sa.nLength = sizeof(SECURITY_ATTRIBUTES);
                sa.lpSecurityDescriptor = pchSD;
                sa.bInheritHandle = TRUE;

                siAvailable = GetSecurityInformation(pchSD);
            }
            DWORD dwStat;
            bool fOwnerSecurity = OWNER_SECURITY_INFORMATION & siAvailable;

            // we need to elevate to set the owner security, on the first open we may skip 
            // the security, and then try later.
            lResult = RegCreateKeyAPI(m_Root,
                                        m_strSubKey,
                                        0,
                                        TEXT(""),       // address of class string 
                                        REG_OPTION_NON_VOLATILE,
                                        (rrwWrite == ergVal) ? RegSamWriteRequested : RegSamReadRequested,
                                        (m_pSD && !fOwnerSecurity) ? &sa : NULL,
                                        &m_hkey,
                                        &dwStat);
                        
            if (m_pSD && (ERROR_SUCCESS == lResult) && ((REG_OPENED_EXISTING_KEY == dwStat) || fOwnerSecurity))
            {
                if (fOwnerSecurity)
                {
                    //!! This is our guess about being in rollback, and it's okay
                    //!! to elevate for simply setting permissions since we grabbed
                    //!! current permissions, and now we're just putting them back.

                    //!! Malcolm and MattWe agree this works for the moment, 
                    //!! but if we add functionality into the LockPermissions, this should
                    //!! be revisited.

                    CElevate elevate;
                    CRefCountedTokenPrivileges cPrivs(itkpSD_WRITE);

                    lResult = RegSetKeySecurity(m_hkey, siAvailable, (char*)pchSD);
                }
                else if (ERROR_SUCCESS != (lResult = RegSetKeySecurity(m_hkey, siAvailable, (char*)pchSD)))
                {
                    DWORD dwLastError = WIN::GetLastError();
                }
            }
        }
        else
        {
            lResult = RegOpenKeyAPI(m_Root, 
                                m_strSubKey,   
                                0,       // reserved 
                                (rrwWrite == ergVal) ? RegSamWriteRequested : RegSamReadRequested,
                                &m_hkey);
        }
        if (ERROR_NO_SYSTEM_RESOURCES == lResult && !g_fWin9X)
        {
            // we have run out of registry space, we should attempt to increase the registry quote and redo the operation
            if(!IncreaseRegistryQuota())
                break;// no point retrying
        }
        else
            break; // either success or unhandled error
    }
    if(lResult == ERROR_SUCCESS)
    {
        m_bOpen = fTrue;
        m_ergRWVal = ergVal;
        return 0;
    }
    else
        return PostError(fCreate ? Imsg(imsgCreateKeyFailed) : Imsg(imsgOpenKeyFailed), *MsiString(GetKey()), lResult);
}

IMsiRecord* CMsiRegKey::RemoveValue(const ICHAR* szValueName, const IMsiString* pistrValue)
{
    IMsiRecord* piRecord;
    long lResult = 0;
    if((piRecord  = InitMsiRegKey(rrwWrite, fFalse)) != 0)
    {
        
        if(ERROR_FILE_NOT_FOUND == piRecord->GetInteger(3))
        {
            //ok, key does not exist
            piRecord->Release();
            piRecord = 0;
        }
        return piRecord;
    }
    if(pistrValue)
    {
        // check if we have a multi_sz that was appended or prepended
        CTempBuffer<char, 1>  rgchBuffer(256);
        aeConvertTypes aeType;

        if(ConvertValueFromString(*pistrValue, rgchBuffer, aeType) == fFalse)
        {
            // error
            return PostError(Imsg(imsgSetValueFailed), szValueName, (const ICHAR*)m_strSubKey);
        }
        if((aeType == aeCnvMultiTxtAppend) || (aeType == aeCnvMultiTxtPrepend))
        {
            // get the current value
            CTempBuffer<char, 1>  rgchBuffer1(256);
            DWORD dwType;

            if((piRecord  = GetRawValue(szValueName, rgchBuffer1, dwType)) != 0)
                return piRecord;
            if(dwType == REG_MULTI_SZ)
            {
                // remove strings from passed in string from the existing string
                CTempBuffer<char, 1>  rgchBuffer2(256);
                rgchBuffer2.SetSize(1*sizeof(ICHAR));
                *((ICHAR*)(char*)rgchBuffer2) = 0;// the extra end null
                const ICHAR* pszSubString1 = (ICHAR*)(char* )rgchBuffer1;

                while(*pszSubString1)
                {
                    // does the pszSubString substring exist in rgchBuffer
                    const ICHAR* pszSubString = (ICHAR*)(char* )rgchBuffer;
                    while(*pszSubString)
                    {
                        if(!IStrCompI(pszSubString, pszSubString1))
                            break;
                        pszSubString += (IStrLen(pszSubString) + 1);
                    }
                    if(!*pszSubString)
                    {
                        // not a duplicate
                        int iSize = rgchBuffer2.GetSize();
                        int iStrSize = (IStrLen(pszSubString1) + 1)*sizeof(ICHAR);
                        rgchBuffer2.Resize(iSize + iStrSize);
                        memmove((char*)rgchBuffer2 + iSize - 1*sizeof(ICHAR), pszSubString1, iStrSize);
                        *((ICHAR*)((char*)rgchBuffer2 + rgchBuffer2.GetSize()) - 1) = 0;// the extra end null
                    }
                    pszSubString1 += (IStrLen(pszSubString1) + 1);
                }
                if(*((ICHAR*)(char*)rgchBuffer2) != 0)
                {
                    // set value to remaining strings
                    return SetRawValue(szValueName, rgchBuffer2, REG_MULTI_SZ);
                }
            }
        }
    }
    lResult = WIN::RegDeleteValue(m_hkey, 
                                (ICHAR* )szValueName);

    if((ERROR_SUCCESS == lResult ) ||
        (ERROR_FILE_NOT_FOUND == lResult) || 
        (ERROR_KEY_DELETED == lResult))
    {
        if(fFalse == m_bIsRoot)
        {
            WIN::RegCloseKey(m_hkey);
            m_bOpen = fFalse;
            ClearEmptyTree(m_Root, m_strSubKey, m_iBinaryType);
        }
        return 0;               
    }
    else
    {
        //!! error
        return PostError(Imsg(imsgRemoveValueFailed), szValueName, m_strSubKey, lResult);
    }
}


IMsiRecord* CMsiRegKey::RemoveSubTree(const ICHAR* szSubKey)
{
    IMsiRecord*  piRecord = 0;
    if((piRecord  = InitMsiRegKey(rrwWrite, fFalse)) != 0)
    {
        
        if(ERROR_FILE_NOT_FOUND == piRecord->GetInteger(3))
        {
            //ok, key does not exist
            piRecord->Release();
            piRecord = 0;
        }
        return piRecord;
    }
    MsiString astr = m_strSubKey;
    if((astr.TextSize() != 0) && (szSubKey != 0) && (*szSubKey != 0))
        astr += szRegSep;
    astr += szSubKey;

#ifdef  WIN
    //!! RegDelKey deletes entire subtree in Win95. 
    if(true != g_fWin9X)
#endif
    { 
        CMsiRegKey* pCRegKey;

        pCRegKey = new CMsiRegKey(*this, m_Root, *astr, NULL, m_piAsvc, m_iBinaryType);

        if((piRecord  = pCRegKey->InitMsiRegKey(rrwWrite, fFalse)) != 0)
        {
            if(ERROR_FILE_NOT_FOUND == piRecord->GetInteger(3))
            {
                //ok, key does not exist
                piRecord->Release();
                piRecord = 0;
            }
            pCRegKey->Release();
            return piRecord;
        }
        IEnumMsiString* pienumStr;
        if((piRecord  = pCRegKey->GetSubKeyEnumerator(pienumStr)) != 0)
        {
            pCRegKey->Release();
            return piRecord;
        }
        unsigned long cFetch = 1;
        do{
            const IMsiString* piastr;
            pienumStr->Next(cFetch, &piastr, &cFetch);
            if(cFetch)
            {
                piRecord = pCRegKey->RemoveSubTree(piastr->GetString());
                piastr->Release();
            }
        }while((cFetch) && (!piRecord));
        pCRegKey->Release();
        pienumStr->Release();
    }

    if(!piRecord)
    {
        long lResult = ERROR_SUCCESS;
#ifdef _WIN64
        if ( m_iBinaryType == ibt32bit )
        {
            // in this case we need to explicitly open the parent key in the 32-bit hive.
            
            // MSDN says that the second argument to RegDeleteKey cannot
            // be NULL, so that we cannot do RegDeleteKey(m_hkey, "");
            MsiString strKey;
            if ( astr.Compare(iscWithin, szRegSep) )
            {
                strKey = astr.Extract(iseAfter, chRegSep);
                astr.Remove(iseFrom, chRegSep);
            }
            else
            {
                // root key
                strKey = astr;
                astr = TEXT("");
            }
            HKEY hKey;
            lResult = RegOpenKeyAPI(m_Root, astr, 0, KEY_WRITE | KEY_WOW64_32KEY, &hKey);
            if ( lResult == ERROR_SUCCESS )
            {
                lResult = WIN::RegDeleteKey(hKey, strKey);
                WIN::RegCloseKey(hKey);
            }
        }
        else
#endif // _WIN64
            lResult = WIN::RegDeleteKey(m_Root, astr);
        if((ERROR_SUCCESS == lResult) || 
            (ERROR_FILE_NOT_FOUND == lResult) || 
            (ERROR_KEY_DELETED == lResult))
        {
            WIN::RegCloseKey(m_hkey);
            m_bOpen = fFalse;
            ClearEmptyTree(m_Root, m_strSubKey, m_iBinaryType);
            return piRecord;                 
        }
        else
        {
            //!! error
            return PostError(Imsg(imsgRemoveKeyFailed), szSubKey, lResult);
        }
    }
    return piRecord;
}

IMsiRecord* CMsiRegKey::ValueExists(const ICHAR* szValueName, Bool& fExists)
{
    fExists = fFalse;
    IMsiRecord* piError = 0;
    long lResult = 0;
    if((piError = InitMsiRegKey(rrwRead, fFalse)) != 0)
    {
        
        if(ERROR_FILE_NOT_FOUND == piError->GetInteger(3))
        {
            piError->Release();
            return 0;
        }
        else
            return piError;
    }

    lResult = WIN::RegQueryValueEx(m_hkey,
                                (ICHAR* )szValueName,
                                0,// reserved 
                                0,
                                0,
                                0);

    if(lResult == ERROR_SUCCESS)
        fExists = fTrue;

    return 0;
}

IMsiRecord* CMsiRegKey::GetValue(const ICHAR* szValueName, const IMsiString*& rpiReturn)
{
    IMsiRecord* piRecord;
    CTempBuffer<char, 256> rgchBuffer;
    DWORD dwType;

    if((piRecord = GetRawValue(szValueName, rgchBuffer, dwType)) != 0)
        return piRecord;
    if(rgchBuffer.GetSize() == 0) 
    {
        //value not present, return empty string
        rpiReturn = &CreateString();
        return 0;
    }
    aeConvertTypes aeType;
    switch(dwType)
    {
    case REG_BINARY:
        aeType = aeCnvBin;
        break;

    case REG_DWORD:
        aeType = aeCnvInt;
        break;

    case REG_EXPAND_SZ:
        aeType = aeCnvExTxt;
        break;          

    case REG_MULTI_SZ:
        aeType = aeCnvMultiTxt;
        break;          

    default:
        aeType = aeCnvTxt;
        break;          
    }
    if(ConvertValueToString(rgchBuffer, rpiReturn, aeType) == fFalse)
        return PostError(Imsg(imsgGetValueFailed), szValueName, 0, 0);
    return 0;
}


IMsiRecord* CMsiRegKey::GetRawValue(const ICHAR* szValueName, CTempBufferRef<char>& rgchOutBuffer, DWORD&rdwType)
{
    IMsiRecord* piRecord;
    long lResult = 0;
    if((piRecord  = InitMsiRegKey(rrwRead, fFalse)) != 0)
    {
        
        if(ERROR_FILE_NOT_FOUND == piRecord->GetInteger(3))
        {
            //ok, key does not exist
            piRecord->Release();
            rdwType = REG_SZ;
            rgchOutBuffer.SetSize(0);// empty
            return 0;
        }
        else
            return piRecord;
    }

    DWORD dwSize = rgchOutBuffer.GetSize();
    lResult = WIN::RegQueryValueEx(m_hkey,
                                (ICHAR* )szValueName,
                                0,// reserved 
                                &rdwType,
                                (unsigned char* )(char* )rgchOutBuffer,
                                &dwSize);

    if(lResult != ERROR_SUCCESS)
    {
        
        if(ERROR_KEY_DELETED == lResult)
        {
            //ok, key does not exist
            WIN::RegCloseKey(m_hkey);
            m_bOpen = fFalse;
            rdwType = REG_SZ;
            rgchOutBuffer.SetSize(0);// empty
            return 0;                       
        }
        else if(ERROR_FILE_NOT_FOUND == lResult)
        {
            // ok
            rdwType = REG_SZ;
            rgchOutBuffer.SetSize(0);// empty
            return 0;                       
        }
        else if(ERROR_MORE_DATA == lResult && dwSize != rgchOutBuffer.GetSize()) // RegQueryValueExA on WinNT returns ERROR_MORE_DATA if "valuename" > 256 (but does not update dwSize)
        {
            // try again
            rgchOutBuffer.SetSize(dwSize);
            if ( ! (char *) rgchOutBuffer )
            {
                rgchOutBuffer.SetSize(0);
                return PostError(Imsg(idbgOutOfMemory));
            }
            return GetRawValue(szValueName, rgchOutBuffer, rdwType);
        }
        else
        {
            //!! error
            return PostError(Imsg(imsgGetValueFailed), szValueName, 0, lResult);
        }
    }
    else
    {
        // set the buffer size correctly
        // Also make sure that REG_MULTI_SZ's are dual null terminated.
        if (REG_MULTI_SZ == rdwType)
        {
            int iSize = dwSize;
            rgchOutBuffer.Resize(iSize + 2);
            rgchOutBuffer[iSize] = '\0';
            rgchOutBuffer[iSize + 1] = '\0';
        }
        else
        {
            rgchOutBuffer.Resize(dwSize);
        }
    }
    return 0;

}

IMsiRecord* CMsiRegKey::SetValue(const ICHAR* szValueName, const IMsiString& ristrValue)
{
    IMsiRecord* piRecord;
    CTempBuffer<char, 30> rgchBuffer;
    aeConvertTypes aeType;

    if(ConvertValueFromString(ristrValue, rgchBuffer, aeType) == fFalse)
        // error
        return PostError(Imsg(imsgSetValueFailed), szValueName, (const ICHAR*)m_strSubKey);

    DWORD dwType;
    MsiString strCount;
    switch(aeType)
    {
    case aeCnvIntInc:
        dwType = REG_DWORD;
        if((piRecord = GetValue(szValueName, *&strCount)) != 0)
            return piRecord;
        strCount.Remove(iseFirst, 1);
        if(strCount == iMsiStringBadInteger) 
            strCount = *(int* )(char* )rgchBuffer;
        else
            strCount = (int)strCount + *(int* )(char* )rgchBuffer;
        rgchBuffer.SetSize(sizeof(int));
        *(int* )(char* )rgchBuffer = (int)strCount;
        break;
    case aeCnvIntDec:
        dwType = REG_DWORD;
        if((piRecord = GetValue(szValueName, *&strCount)) != 0)
            return piRecord;
        strCount.Remove(iseFirst, 1);
        if(strCount != iMsiStringBadInteger && strCount!= 0)
            strCount = (int)strCount - *(int* )(char* )rgchBuffer;
        else
            strCount = 0;
        if(strCount == 0)
            return RemoveValue(szValueName, 0);

        rgchBuffer.SetSize(sizeof(int));
        *(int* )(char* )rgchBuffer = (int)strCount;
        break;
    case aeCnvInt:
        dwType = REG_DWORD;
        break;
    case aeCnvBin:
        dwType = REG_BINARY;
        break;
    case aeCnvExTxt:
        dwType = REG_EXPAND_SZ;
        break;
    case aeCnvMultiTxt:
    case aeCnvMultiTxtAppend:
    case aeCnvMultiTxtPrepend:
        dwType = REG_MULTI_SZ;
        break;
    default:
        dwType = REG_SZ;
        break;
    }

    if((aeType == aeCnvMultiTxtAppend) || (aeType == aeCnvMultiTxtPrepend))
    {
        // we need to read the previous value
        CTempBuffer<char, 255> rgchBuffer1;
        DWORD dwType1;
        if((piRecord = GetRawValue(szValueName, rgchBuffer1, dwType1)) != 0)
            return piRecord;
        if(dwType1 == REG_MULTI_SZ)
        {
            // remove any duplicates from the existing string
            MsiString strExist;
            const ICHAR* pszSubString1 = (ICHAR*)(char*)rgchBuffer1;

            while(*pszSubString1)
            {
                // does the pszSubString substring exist in rgchBuffer
                const ICHAR* pszSubString = (ICHAR*)(char*)rgchBuffer;
                while(*pszSubString)
                {
                    if(!IStrCompI(pszSubString, pszSubString1))
                        break;
                    pszSubString += (IStrLen(pszSubString) + 1);
                }
                if(!*pszSubString)
                {
                    // not a duplicate
                    strExist += pszSubString1;
                    strExist += MsiString(MsiChar(0));
                }
                pszSubString1 += (IStrLen(pszSubString1) + 1);
            }
            if(strExist.TextSize())
            {
                // add the existing string appropriately to the passed in value
                CTempBuffer<char, 30> rgchBuffer1;
                rgchBuffer1.SetSize(rgchBuffer.GetSize() +strExist.TextSize() * sizeof(ICHAR));
                if(aeType == aeCnvMultiTxtAppend)
                {
                    strExist.CopyToBuf((ICHAR*)(char*)rgchBuffer1, strExist.TextSize());
                    memmove((char*)rgchBuffer1 + strExist.TextSize()*sizeof(ICHAR), rgchBuffer, rgchBuffer.GetSize());
                }
                else
                {
                    memmove(rgchBuffer1, rgchBuffer, rgchBuffer.GetSize());
                    strExist.CopyToBuf((ICHAR*)((char*)rgchBuffer1 + rgchBuffer.GetSize()) - 1, strExist.TextSize());
                }
                return SetRawValue(szValueName, rgchBuffer1, dwType);
            }
        }
    }
    return SetRawValue(szValueName, rgchBuffer, dwType);
}

IMsiRecord* CMsiRegKey::SetRawValue(const ICHAR* szValueName, CTempBufferRef<char>& rgchInBuffer, DWORD dwType)
{
    long lResult = ERROR_FUNCTION_FAILED;
    for(int iContinueRetry = 3; iContinueRetry--;)// try thrice, prevent possibly endless recursion
    {
        IMsiRecord* piRecord;
        if((piRecord  = InitMsiRegKey(rrwWrite, fTrue)) != 0)
        {
            return piRecord;
        }

        lResult = WIN::RegSetValueEx(m_hkey, 
                                    szValueName,    
                                    (DWORD) 0,      // reserved 
                                    dwType,
                                    (const unsigned char*)(const char*)rgchInBuffer, // address of value data 
                                    rgchInBuffer.GetSize());
        if(ERROR_KEY_DELETED == lResult)
        {
            // key deleted externally, redo!
            m_bOpen = fFalse;
        }
        else if(ERROR_NO_SYSTEM_RESOURCES == lResult && !g_fWin9X)
        {
            // we have run out of registry space, we should attempt to increase the registry quote and redo the operation
            if(!IncreaseRegistryQuota())
                break;// no point retrying
        }
        else
            break; // either success or unhandled error
    }
    if(lResult == ERROR_SUCCESS)
        return 0;
    else // error
        return PostError(Imsg(imsgSetValueFailed), szValueName, m_strSubKey, lResult);
}


IMsiRecord* CMsiRegKey::GetValueEnumerator(IEnumMsiString*&  rpiEnumStr)
{
    const IMsiString** ppstr = 0;
    int iCount;
    long lResult = 0;
    IMsiRecord* piError = InitMsiRegKey(rrwRead, fFalse);

    CTempBuffer<ICHAR, 256> pTmp;

    DWORD dwNumValues = 0;
    DWORD dwMaxValueName = 0;
    if(piError)
    {
        if(ERROR_FILE_NOT_FOUND == piError->GetInteger(3))
        {
            //ok, key does not exist
            piError->Release();
            piError = 0;
        }
        else
            return piError;
    }

    if(fTrue == m_bOpen)
    {
        // if not open assume num values = 0
        lResult = RegQueryInfoKey(  m_hkey, 
                                    0,        
                                    0,        
                                    0,      // reserved 
                                    0,
                                    0,
                                    0,
                                    &dwNumValues,
                                    &dwMaxValueName,
                                    0,
                                    0,
                                    0);

        if(lResult != ERROR_SUCCESS)
        {
            if((ERROR_FILE_NOT_FOUND == lResult) || 
            (ERROR_KEY_DELETED == lResult))
            {
                WIN::RegCloseKey(m_hkey);
                m_bOpen = fFalse;
                dwNumValues = 0;
            }
            else
            {
                //!! error
                return PostError(Imsg(imsgGetValueEnumeratorFailed), *m_strSubKey, lResult);
            }
        }
    }

    if(dwNumValues)
    {
        ppstr = new const IMsiString* [dwNumValues];
        if ( ! ppstr )
            return PostError(Imsg(idbgOutOfMemory));
        dwMaxValueName++;
        pTmp.SetSize(dwMaxValueName);

        for(iCount = 0; iCount < dwNumValues; iCount ++)
            ppstr[iCount] = 0;


        for(iCount = 0; iCount < dwNumValues; iCount ++)
        {
            DWORD dwVS = dwMaxValueName;

            lResult = WIN::RegEnumValue(m_hkey, 
                                    iCount, 
                                    pTmp,   
                                    &dwVS,  
                                    0,      // reserved 
                                    0,
                                    0,      
                                    0); 
            if(lResult != ERROR_SUCCESS)
            {
                piError = PostError(Imsg(imsgGetValueEnumeratorFailed), *m_strSubKey, lResult);
                break;
            }
            ppstr[iCount] = &CreateString();
            ppstr[iCount]->SetString(pTmp, ppstr[iCount]);
        }
    }

    if(!piError)
        CreateStringEnumerator(ppstr, dwNumValues, rpiEnumStr);
    for(iCount = 0; iCount < dwNumValues; iCount ++)
    {
        if(ppstr[iCount])
            ppstr[iCount]->Release();       
    }
    delete [] ppstr;
    return piError;
}

IMsiRecord* CMsiRegKey::GetSubKeyEnumerator(IEnumMsiString*&  rpiEnumStr)
{
    const IMsiString **ppstr = 0;
    int iCount;
    long lResult = 0;
    IMsiRecord* piError = InitMsiRegKey(rrwRead, fFalse);

    CTempBuffer<ICHAR, 256> pTmp;

    DWORD dwNumKeys = 0;
    DWORD dwMaxKeyName = 0;

    if(piError)
    {
        if(ERROR_FILE_NOT_FOUND == piError->GetInteger(3))
        {
            //ok, key does not exist
            piError->Release();
            piError = 0;
        }
        else
            return piError;
    }

    if(fTrue == m_bOpen)
    {
        // if not open assume num keys = 0
        lResult = RegQueryInfoKey(  m_hkey, 
                                    0,        
                                    0,        
                                    0,      // reserved 
                                    &dwNumKeys,
                                    &dwMaxKeyName,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0);

        if(lResult != ERROR_SUCCESS)
        {
            if((ERROR_FILE_NOT_FOUND == lResult) || 
            (ERROR_KEY_DELETED == lResult))
            {
                WIN::RegCloseKey(m_hkey);
                m_bOpen = fFalse;
                dwNumKeys = 0;
            }
            else
            {
                //!! error
                return PostError(Imsg(imsgGetSubKeyEnumeratorFailed), *m_strSubKey, lResult);
            }
        }
    }
    
    if(dwNumKeys)
    {
        ppstr = new const IMsiString* [dwNumKeys];
        if ( ! ppstr )
            return PostError(Imsg(idbgOutOfMemory));
        dwMaxKeyName++;
        pTmp.SetSize(dwMaxKeyName);

        for(iCount = 0; iCount < dwNumKeys; iCount ++)
            ppstr[iCount] = 0;

        for(iCount = 0; iCount < dwNumKeys; iCount ++)
        {
            DWORD dwVS = dwMaxKeyName;

            WIN::RegEnumKeyEx(m_hkey, 
                            iCount, 
                            pTmp,   
                            &dwVS,  
                            0,      // reserved 
                            0,
                            0,      
                            0);

            if(lResult != ERROR_SUCCESS)
            {
                piError = PostError(Imsg(imsgGetValueEnumeratorFailed), *m_strSubKey, lResult);
                break;
            }
            ppstr[iCount] = &CreateString();
            ppstr[iCount]->SetString(pTmp, ppstr[iCount]);
        }
    }

    if(!piError)
        CreateStringEnumerator(ppstr, dwNumKeys, rpiEnumStr);
    for(iCount = 0; iCount < dwNumKeys; iCount ++)
    {
        if(ppstr[iCount])
            ppstr[iCount]->Release();       
    }
    delete [] ppstr;
    return piError;
}

IMsiRecord* CMsiRegKey::GetSelfRelativeSD(IMsiStream*& rpiSD)
{
    // if the key was opened with a security descriptor, 
    // they should be one and the same.
    if (m_pSD)
    {
        m_pSD->AddRef();
        rpiSD = m_pSD;
    }
    else
    {
        IMsiRecord* pErr = InitMsiRegKey(rrwRead, fFalse);
        if (pErr) 
            return pErr;

        DWORD cbSD = 1024;
        CTempBuffer<BYTE, 1024> rgchSD;
        LONG lResult = ERROR_SUCCESS;
        if (ERROR_SUCCESS != (lResult = WIN::RegGetKeySecurity(m_hkey, 
            // all possible information retrieved
            OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | 
            DACL_SECURITY_INFORMATION /*| SACL_SECURITY_INFORMATION*/,
            rgchSD, &cbSD)))
        {
            DWORD dwLastError = WIN::GetLastError();
            if (ERROR_INSUFFICIENT_BUFFER == dwLastError)
            {
                rgchSD.SetSize(cbSD);
                lResult = WIN::RegGetKeySecurity(m_hkey, 
                    // all possible information retrieved
                    OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | 
                    DACL_SECURITY_INFORMATION /*| SACL_SECURITY_INFORMATION*/,
                    rgchSD, &cbSD);
            }

            if (ERROR_SUCCESS != lResult)
                return PostError(Imsg(imsgSecurityFailed), *m_strSubKey, dwLastError);
        }

        cbSD = WIN::GetSecurityDescriptorLength(rgchSD);
        char* pchstrmSD = AllocateMemoryStream(cbSD, rpiSD);
        if ( ! pchstrmSD )
        {
            Assert(pchstrmSD);
            return PostError(Imsg(idbgOutOfMemory));
        }
        memcpy(pchstrmSD, rgchSD, cbSD);

        rpiSD->AddRef();
        m_pSD = rpiSD;
    
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\runapps.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       runapps.cpp
//
//--------------------------------------------------------------------------

//
// File: runnapps.cpp
// Purpose: Search system for loaded modules
// Notes:		different strategies, one for Win NT, one for Win 95
// To Do:       1. ??Remove "009" dependancy (Performance data for english only)
//____________________________________________________________________________

#include "precomp.h" 
#ifndef MAC // This file is not to be compiled at all for MAC, even though
			// for DevStudio purposes, the file needs to be included in proj
#include <tlhelp32.h> // needed for tool help declarations 
#include <winperf.h>

#include "services.h"
#include "_service.h"

#define ENSURE(function) {	\
							IMsiRecord* piError;\
							piError = function;	\
							if (piError) \
								return piError; \
						 }


CDetectApps::CDetectApps(IMsiServices& riServices) : m_piServices(&riServices)
{
	// add ref for m_piServices
	riServices.AddRef();
}

HWND CDetectApps::GetMainWindow(DWORD dwProcessId)
{
	idaProcessInfo processInfo;
	processInfo.dwProcessId = dwProcessId;
	processInfo.hwndRet = 0;
	EnumWindows((WNDENUMPROC)  EnumWindowsProc, (LPARAM) &processInfo);
	return processInfo.hwndRet;
}

BOOL CALLBACK CDetectApps::EnumWindowsProc(HWND  hwnd, LPARAM  lParam)
{
	if(!GetWindow(hwnd, GW_OWNER))
	{
		idaProcessInfo* pProcessInfo = (idaProcessInfo*)lParam;
		DWORD dwCurrentProcess;
		GetWindowThreadProcessId(hwnd, &dwCurrentProcess);
		if(dwCurrentProcess == pProcessInfo->dwProcessId)
		{
			// Ignore invisible windows, and/or windows
			// that have no caption.
			if (IsWindowVisible(hwnd))
			{
				if (GetWindowTextLength(hwnd) > 0)
				{
					pProcessInfo->hwndRet = hwnd;
					return FALSE;
				}
			}
		}
	}
	return TRUE;
}

const ICHAR* KERNEL   = TEXT("KERNEL32.DLL");
const char* SNAPSHOT = "CreateToolhelp32Snapshot";
const char* MODLFRST = "Module32First";
const char* MODLNEXT = "Module32Next";
const char* PROCFRST = "Process32First";
const char* PROCNEXT = "Process32Next";
const char* THRDFRST = "Thread32First";
const char* THRDNEXT = "Thread32Next";


typedef BOOL (WINAPI* MODULEWALK)(HANDLE hSnapshot, 
    LPMODULEENTRY32 lpme); 
typedef BOOL (WINAPI* PROCESSWALK)(HANDLE hSnapshot, 
    LPPROCESSENTRY32 lppe); 
typedef HANDLE (WINAPI* THREADWALK)(HANDLE hSnapshot, 
    LPTHREADENTRY32 lpte); 
typedef HANDLE (WINAPI* CREATESNAPSHOT)(unsigned dwFlags, 
    unsigned th32ProcessID); 

class CDetectApps95 : public CDetectApps
{
public:
	CDetectApps95(IMsiServices& riServices);
	~CDetectApps95();
	IMsiRecord* GetFileUsage(const IMsiString& strFile, IEnumMsiRecord*& rpiEnumRecord);
	IMsiRecord* Refresh();
protected:
	// pointers to call tool help functions. 
	CREATESNAPSHOT m_pfnCreateToolhelp32Snapshot;
	MODULEWALK  m_pfnModule32First;
	MODULEWALK  m_pfnModule32Next;
	PROCESSWALK m_pfnProcess32First;
	PROCESSWALK m_pfnProcess32Next;
	Bool m_bInitialised;
};



CDetectApps95::CDetectApps95(IMsiServices& riServices) : CDetectApps(riServices)
{  
	m_bInitialised = fFalse;
    // Obtain the module handle of the kernel to retrieve addresses of 
    // the tool helper functions. 
    HMODULE hKernel = GetModuleHandle(KERNEL); 
 
    if (hKernel)
	{ 
		m_pfnCreateToolhelp32Snapshot = (CREATESNAPSHOT)GetProcAddress(hKernel, SNAPSHOT); 
 
		m_pfnModule32First  = (MODULEWALK)GetProcAddress(hKernel, MODLFRST); 
		m_pfnModule32Next   = (MODULEWALK)GetProcAddress(hKernel, MODLNEXT); 
 
		m_pfnProcess32First = (PROCESSWALK)GetProcAddress(hKernel, PROCFRST); 
		m_pfnProcess32Next  = (PROCESSWALK)GetProcAddress(hKernel, PROCNEXT); 
 
		// All addresses must be non-NULL to be successful. 
		// If one of these addresses is NULL, one of 
		// the needed lists cannot be walked. 
		m_bInitialised =  (m_pfnModule32First && m_pfnModule32Next  && m_pfnProcess32First && 
						m_pfnProcess32Next && m_pfnCreateToolhelp32Snapshot) ? fTrue : fFalse; 
	} 
} 

CDetectApps95::~CDetectApps95()
{
}

IMsiRecord* CDetectApps95::GetFileUsage(const IMsiString& istrFile, IEnumMsiRecord*& rpiEnumRecord)
{
	IMsiRecord* piError = 0;
	IMsiRecord** ppRec = 0;
	unsigned iSize = 0;

	istrFile.AddRef();
	MsiString strFile = istrFile;

	AssertSz(m_bInitialised, TEXT("CDetectApps object not initialized before use"));
	if(!m_bInitialised)
		return PostError(Imsg(idbgGetFileUsageFailed));

	// we do this over and over again for Win95 as the cost is low and we get the latest snapshot
	CHandle hProcessSnap = m_pfnCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); 
	if (hProcessSnap == (HANDLE)-1) 
		return PostError(Imsg(idbgGetFileUsageFailed));


	//  Fill in the size of the structure before using it. 
	PROCESSENTRY32 pe32 = {0}; 
	pe32.dwSize = sizeof(PROCESSENTRY32); 

	//  Walk the snapshot of the processes, and for each process, get 
	//  information about modules. 

	// NOTE: the toolhelp information is all ANSI, hence must be converted to UNICODE, if required (done by CConvertString)
	if (m_pfnProcess32First(hProcessSnap, &pe32)) 
	{ 

		do { 
				// Get the modules

				// Fill the size of the structure before using it.
				MODULEENTRY32 me32 = {0};
				me32.dwSize = sizeof(MODULEENTRY32); 

				// Walk the module list of the process, and find the module of 
				// interest. Then copy the information to the buffer pointed 
				// to by lpMe32 so that it can be returned to the caller. 
				CHandle hModuleSnap = m_pfnCreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pe32.th32ProcessID); 
				if (hModuleSnap == (HANDLE)-1) 
					return PostError(Imsg(idbgGetFileUsageFailed));

				if (m_pfnModule32First(hModuleSnap, &me32)) 
				{ 
					do { 
							if(strFile.Compare(iscExactI, CConvertString(me32.szModule))) 
							{
								// add process to list.
								iSize ++;
								if((iSize%10) == 1) // need to allocate more memory (10 units at a time)
								{
									IMsiRecord** ppOld = ppRec;
									ppRec = new IMsiRecord*[iSize + 9];
									for(unsigned int iTmp = 0; iTmp < (iSize - 1); iTmp++)
										ppRec[iTmp] = ppOld[iTmp];
									delete [] ppOld;
								}

								ppRec[iSize - 1] = &m_piServices->CreateRecord(3);
								ppRec[iSize - 1]->SetString(1, CConvertString(pe32.szExeFile));
								ppRec[iSize - 1]->SetInteger(2, pe32.th32ProcessID);

								// get the top level window associated with the process
#ifdef _WIN64	// !merced
								ppRec[iSize - 1]->SetHandle(3, (HANDLE)GetMainWindow(pe32.th32ProcessID));
								if(ppRec[iSize - 1]->GetHandle(3) == 0)
#else
								ppRec[iSize - 1]->SetInteger(3, (int)GetMainWindow(pe32.th32ProcessID));
								if(ppRec[iSize - 1]->GetInteger(3) == 0)
#endif
									ppRec[iSize - 1]->SetNull(3);
							}
					} while (m_pfnModule32Next(hModuleSnap, &me32)); 
				}
		} while (m_pfnProcess32Next(hProcessSnap, &pe32)); 
	}  
	CreateRecordEnumerator(ppRec, iSize, rpiEnumRecord);
	for(unsigned int iTmp = 0; iTmp < iSize; iTmp++)
		ppRec[iTmp]->Release();
	delete [] ppRec;
	return 0;
}

IMsiRecord* CDetectApps95::Refresh()
{
	// no-op on Win95
	return 0;
}


typedef PERF_DATA_BLOCK             PERF_DATA,      *PPERF_DATA;
typedef PERF_OBJECT_TYPE            PERF_OBJECT,    *PPERF_OBJECT;
typedef PERF_INSTANCE_DEFINITION    PERF_INSTANCE,  *PPERF_INSTANCE;
typedef PERF_COUNTER_DEFINITION     PERF_COUNTER,   *PPERF_COUNTER;

const ICHAR PN_PROCESS[] = TEXT("Process");
const ICHAR PN_IMAGE[] = TEXT("Image");
const ICHAR PN_PROCESS_ID[] = TEXT("ID Process");

const unsigned int PERF_DATASIZE = 50*1024;
const unsigned int MAX_OBJECTS_SIZE = 30;

HKEY hKeyPerf = HKEY_PERFORMANCE_DATA;  // get perf data from this key
HKEY hKeyMachine = HKEY_LOCAL_MACHINE;  // get title index from this key

const ICHAR szVersion[] =  TEXT("Version");
const ICHAR szCounters[] =	TEXT("Counters");

const ICHAR PERF_KEY[] =	TEXT("software\\microsoft\\windows nt\\currentversion\\perflib");

class CDetectAppsNT : public CDetectApps
{
public:
	CDetectAppsNT(IMsiServices& riServices);
	~CDetectAppsNT();
	IMsiRecord* GetFileUsage(const IMsiString& strFile, IEnumMsiRecord*& rpiEnumRecord);
	IMsiRecord* Refresh();
protected:
	IMsiRecord* GetPerfIdxs();
	IMsiRecord* GetPerfData();
	static PPERF_COUNTER FirstCounter(PPERF_OBJECT pObject);
	static PPERF_COUNTER NextCounter(PPERF_COUNTER pCounter);
	static PPERF_COUNTER FindCounter(PPERF_OBJECT pObject, unsigned uiTitleIndex);
	static void* CounterData(PPERF_INSTANCE pInst, PPERF_COUNTER pCount);
	static PPERF_INSTANCE FirstInstance(PPERF_OBJECT pObject);
	static PPERF_INSTANCE NextInstance(PPERF_INSTANCE pInst);
	static PPERF_INSTANCE FindInstanceN(PPERF_OBJECT pObject, unsigned uiIndex);
	static PPERF_OBJECT FindObjectParent(PPERF_INSTANCE pInst, PPERF_DATA pData);
	static PPERF_INSTANCE FindInstanceParent(PPERF_INSTANCE pInst, PPERF_DATA pData);
	static ICHAR* InstanceName(PPERF_INSTANCE pInst);
	static PPERF_OBJECT FirstObject(PPERF_DATA pData);
	static PPERF_OBJECT NextObject(PPERF_OBJECT pObject);
	static PPERF_OBJECT FindObject(PPERF_DATA pData, unsigned uiTitleIndex);
	static PPERF_OBJECT FindObjectN(PPERF_DATA pData, unsigned uiIndex);
	unsigned m_uiPerfDataSize;
	CTempBuffer<BYTE, 10> m_pPerfData;
	Bool m_bInitialised;
	ICHAR m_strIndex[MAX_OBJECTS_SIZE];
	unsigned int m_uiImageIdx;
	unsigned int m_uiProcessIdx;
	unsigned int m_uiProcessIDIdx;	
};

CDetectAppsNT::CDetectAppsNT(IMsiServices& riServices) : CDetectApps(riServices), m_uiPerfDataSize(PERF_DATASIZE)
{
	// need to call Refresh()
	m_pPerfData.SetSize(0);
}

CDetectAppsNT::~CDetectAppsNT()
{
}

IMsiRecord* CDetectAppsNT::Refresh()
{
	return GetPerfData();
}

IMsiRecord* CDetectAppsNT::GetPerfIdxs()
{
	struct regkeys{
		regkeys():hKey(0), hKey1(0){}
		~regkeys(){ if (hKey && hKey != hKeyPerf) RegCloseKey (hKey); if (hKey1) RegCloseKey (hKey1);}
		HKEY hKey;
		HKEY hKey1;
	};

	regkeys Regkeys;

	DWORD dwType;
	DWORD dwIndex;
	DWORD dwDataSize;
	DWORD dwReturn;
	int	iLen;
	Bool bNT10;
	MsiString strCounterValueName;
	ICHAR* pTitle;
    CTempBuffer<ICHAR, 10>  pTitleBuffer;
    // Initialize
    //

	//!! get the language
	MsiString strLanguage = TEXT("009");

    // Open the perflib key to find out the last counter's index and system version.
    //
	CElevate elevate;

	dwReturn = MsiRegOpen64bitKey(	hKeyMachine,
								PERF_KEY,
								0,
								KEY_READ,
								&(Regkeys.hKey1));

	if (dwReturn != ERROR_SUCCESS)
		return PostError(Imsg(idbgGetPerfIdxs), dwReturn);

    // Find system version, for system earlier than 1.0a, there's no version value.
    // !! maybe we get the version from the propert

    dwReturn = RegQueryValueEx (Regkeys.hKey1, szVersion, 0, &dwType, 0, &dwDataSize);
    if (dwReturn != ERROR_SUCCESS)
		// unable to read the value, assume NT 1.0
		bNT10 = fTrue;
    else
		// found the value, so, NT 1.0a or later
		bNT10 = fFalse;

    // Now, get ready for the counter names and indexes.
    //

    if (bNT10)
	{
		// NT 1.0, so make hKey2 point to ...\perflib\<language> and get
		//  the counters from value "Counters"
		//

		MsiString aStrKey = PERF_KEY;
		aStrKey += szRegSep; 
		aStrKey += strLanguage;
		strCounterValueName = szCounters;
		dwReturn = RegOpenKeyAPI (	hKeyMachine,
									aStrKey,
									0,
									KEY_READ,
									&(Regkeys.hKey));
		if (dwReturn != ERROR_SUCCESS)
			return PostError(Imsg(idbgGetPerfIdxs), dwReturn);
	}
    else
	{
		// NT 1.0a or later.  Get the counters in key HKEY_PERFORMANCE_KEY
		//  and from value "Counter <language>"
		strCounterValueName = TEXT("Counter ");
		strCounterValueName += strLanguage;
		Regkeys.hKey = hKeyPerf;
	}

    // Find out the size of the data.
    //
    dwReturn = RegQueryValueEx (Regkeys.hKey, (ICHAR *)(const ICHAR *)strCounterValueName, 0, &dwType, 0, &dwDataSize);
    if (dwReturn != ERROR_SUCCESS)
		return PostError(Imsg(idbgGetPerfIdxs), dwReturn);

    // Allocate memory
    pTitleBuffer.SetSize(dwDataSize);
	if ( ! (ICHAR *) pTitleBuffer )
		return PostError(Imsg(idbgGetPerfIdxs), ERROR_OUTOFMEMORY);
    
    // Query the data
    //
    dwReturn = RegQueryValueEx (Regkeys.hKey, (ICHAR *)(const ICHAR *)strCounterValueName, 0, &dwType, (BYTE *)(const ICHAR* )pTitleBuffer, &dwDataSize);
    if (dwReturn != ERROR_SUCCESS)
		return PostError(Imsg(idbgGetPerfIdxs), dwReturn);

    pTitle = pTitleBuffer;

    while ((iLen = IStrLen (pTitle)) != 0)
	{
		dwIndex = MsiString(pTitle);

		pTitle = pTitle + iLen +1;
		if(!IStrCompI(pTitle, PN_IMAGE))
			m_uiImageIdx = dwIndex;
		else if(!IStrCompI(pTitle, PN_PROCESS))
			m_uiProcessIdx = dwIndex;
		else if(!IStrCompI(pTitle, PN_PROCESS_ID))
			m_uiProcessIDIdx = dwIndex;
		pTitle = pTitle + IStrLen (pTitle) +1;
	}

	StringCchPrintf (m_strIndex, (sizeof(m_strIndex)/sizeof(ICHAR)), TEXT("%ld"),
				m_uiImageIdx);
    return 0;
}

IMsiRecord* CDetectAppsNT::GetPerfData()
{
	unsigned uiReturn;

	CElevate elevate;

	ENSURE(GetPerfIdxs());
	m_pPerfData.SetSize(m_uiPerfDataSize);
    do{
		DWORD dwType;
		DWORD dwDataSize = m_uiPerfDataSize;
		uiReturn = RegQueryValueEx (hKeyPerf,
									m_strIndex,
									0,
									&dwType,
									(BYTE *)m_pPerfData,
									&dwDataSize);

		if (uiReturn == ERROR_MORE_DATA)
		{
			m_uiPerfDataSize += PERF_DATASIZE;
			m_pPerfData.SetSize(m_uiPerfDataSize);
		}
	} while (uiReturn == ERROR_MORE_DATA);
	if(uiReturn != ERROR_SUCCESS)
		return PostError(Imsg(idbgGetPerfDataFailed), uiReturn);
    return 0;
}


IMsiRecord* CDetectAppsNT::GetFileUsage(const IMsiString& strFile, IEnumMsiRecord*& rpiEnumRecord)
{
	IMsiRecord* piError = 0;
	IMsiRecord** ppRec = 0;
	unsigned iSize = 0;

	if(m_pPerfData.GetSize() == 0)
		ENSURE(Refresh());

	PPERF_INSTANCE  pImageInst;
	PPERF_INSTANCE  pProcessInst;
	int iInstIndex = 0;

	rpiEnumRecord = 0;

	PPERF_OBJECT pImageObject   = FindObject((PPERF_DATA)(BYTE* )m_pPerfData, m_uiImageIdx);

	if (pImageObject)
	{
		pImageInst = FirstInstance(pImageObject);

		while (pImageInst && iInstIndex < pImageObject->NumInstances)
		{

			CTempBuffer<ICHAR, 20> szBuf;
#ifndef UNICODE
// convert info to multibyte
			int iLen = WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)InstanceName(pImageInst), -1, 0, 0, 0, 0);
			szBuf.SetSize(iLen + 1);
			BOOL bUsedDefault;
			WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)InstanceName(pImageInst), -1, szBuf, iLen, 0, &bUsedDefault);
			szBuf[iLen] = 0; // API function does not null terminate
#else
			szBuf.SetSize(IStrLen(InstanceName(pImageInst)) + 1);
			StringCchCopy(szBuf, szBuf.GetSize(), InstanceName(pImageInst));
#endif                                          
			if(strFile.Compare(iscExactI, szBuf))
			{
				// add process to list.							
				CTempBuffer<ICHAR, 20> szBuf1;
				PPERF_OBJECT pProcessObject = FindObjectParent(pImageInst, (PPERF_DATA)(BYTE* )m_pPerfData);
				pProcessInst = FindInstanceParent(pImageInst, (PPERF_DATA)(BYTE* )m_pPerfData);
				if ( ! pProcessInst )
					return PostError(Imsg(idbgGetFileUsageFailed));
#ifndef UNICODE
				iLen = WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)InstanceName(pProcessInst), -1, 0, 0, 0, 0);
				szBuf1.SetSize(iLen + 1);
				WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)InstanceName(pProcessInst), -1, szBuf1, iLen, 0, &bUsedDefault);
				szBuf1[iLen] = 0; // API function does not null terminate			
#else
				szBuf1.SetSize(IStrLen(InstanceName(pProcessInst)) + 1);
				StringCchCopy(szBuf1, szBuf1.GetSize(), InstanceName(pProcessInst));
#endif                                                  
				// add process to list.
				iSize ++;
				if((iSize%10) == 1) // need to allocate more memory (10 units at a time)
				{
					IMsiRecord** ppOld = ppRec;
					ppRec = new IMsiRecord*[iSize + 9];
					for(unsigned int iTmp = 0; iTmp < (iSize - 1); iTmp++)
						ppRec[iTmp] = ppOld[iTmp];
					delete [] ppOld;
				}

				ppRec[iSize - 1] = &m_piServices->CreateRecord(2);
				ppRec[iSize - 1]->SetString(1, szBuf1);
				PPERF_COUNTER pCountID;
				DWORD dwProcessID = 0;
			    if ((pCountID = FindCounter(pProcessObject, m_uiProcessIDIdx)) != 0)
					dwProcessID = *(DWORD* )CounterData(pProcessInst, pCountID);
				else
				{
					//?? error
					AssertSz(0, "Detect Running apps: process id counter missing");
				}

				ppRec[iSize - 1]->SetInteger(2, dwProcessID);

			}
			pImageInst = NextInstance(pImageInst);
			iInstIndex++;
		}

	}
	CreateRecordEnumerator(ppRec, iSize, rpiEnumRecord);
	for(unsigned int iTmp = 0; iTmp < iSize; iTmp++)
		ppRec[iTmp]->Release();
	delete [] ppRec;
	return 0;
}

//      Find the first counter in pObject.
//      Returns a pointer to the first counter.  If pObject is 0
//      then 0 is returned.
PPERF_COUNTER CDetectAppsNT::FirstCounter (PPERF_OBJECT pObject)
{
    if (pObject)
		return (PPERF_COUNTER)((PCHAR) pObject + pObject->HeaderLength);
    else
		return 0;
}

// Find the next counter of pCounter.
// If pCounter is the last counter of an object type, bogus data
// maybe returned.  The caller should do the checking.
// Returns a pointer to a counter.  If pCounter is 0 then
// 0 is returned.
PPERF_COUNTER CDetectAppsNT::NextCounter (PPERF_COUNTER pCounter)
{
    if (pCounter)
		return (PPERF_COUNTER)((PCHAR) pCounter + pCounter->ByteLength);
	else
		return 0;
}

// Find a counter specified by TitleIndex.
// Returns a pointer to the counter.  If counter is not found
// then 0 is returned.
PPERF_COUNTER CDetectAppsNT::FindCounter(PPERF_OBJECT pObject, unsigned uiTitleIndex)
{
	PPERF_COUNTER pCounter;
	unsigned uiCnt = 0;

    if ((pCounter = FirstCounter(pObject)) != 0)
	{
		while (uiCnt++ < pObject->NumCounters)
		{
			if (pCounter->CounterNameTitleIndex == uiTitleIndex)
				return pCounter;

			pCounter = NextCounter (pCounter);
		}
	}
    return 0;
}

// Returns counter data for an object instance.  If pInst or pCount
// is 0 then 0 is returned.
void* CDetectAppsNT::CounterData (PPERF_INSTANCE pInst, PPERF_COUNTER pCount)
{
	PPERF_COUNTER_BLOCK pCounterBlock;

    if (pCount && pInst)
	{
		pCounterBlock = (PPERF_COUNTER_BLOCK)((PCHAR)pInst + pInst->ByteLength);
		return (void*)((char* )pCounterBlock + pCount->CounterOffset);
	}
    else
		return 0;
}

// Returns pointer to the first instance of pObject type.
// If pObject is 0 then 0 is returned.
PPERF_INSTANCE CDetectAppsNT::FirstInstance(PPERF_OBJECT pObject)
{
    if (pObject)
		return (PPERF_INSTANCE)((PCHAR) pObject + pObject->DefinitionLength);
    else
		return 0;
}

// Returns pointer to the next instance following pInst.
// If pInst is the last instance, bogus data maybe returned.
// The caller should do the checking.
// If pInst is 0, then 0 is returned.
PPERF_INSTANCE CDetectAppsNT::NextInstance(PPERF_INSTANCE pInst)
{
	PERF_COUNTER_BLOCK *pCounterBlock;
    if (pInst)
	{
		pCounterBlock = (PERF_COUNTER_BLOCK *)((PCHAR) pInst + pInst->ByteLength);
		return (PPERF_INSTANCE)((PCHAR) pCounterBlock + pCounterBlock->ByteLength);
	}
    else
		return 0;
}

// Returns the Nth instance of pObject type.  If not found, 0 is
// returned.  0 <= N <= NumInstances.
PPERF_INSTANCE CDetectAppsNT::FindInstanceN(PPERF_OBJECT pObject, unsigned uiIndex)
{
	PPERF_INSTANCE pInst;
	unsigned uiCnt = 0;

    if ((!pObject) || (uiIndex >= pObject->NumInstances))
		return 0;
    else
	{
		pInst = FirstInstance (pObject);

		while (uiCnt++ != uiIndex)
			pInst = NextInstance(pInst);

		return pInst;
	}
}

// Returns the pointer to an instance that is the parent of pInst.
// If pInst is 0 or the parent object is not found then 0 is
// returned.
PPERF_INSTANCE CDetectAppsNT::FindInstanceParent(PPERF_INSTANCE pInst, PPERF_DATA pData)
{
	PPERF_OBJECT    pObject;

    if (!pInst)
		return 0;
    else if ((pObject = FindObject(pData, pInst->ParentObjectTitleIndex)) == 0)
		return 0;
    else
		return FindInstanceN(pObject, pInst->ParentObjectInstance);
}

// Returns the pointer to an object that is the parent of pInst.
// If pInst is 0 or the parent object is not found then 0 is
// returned.
PPERF_OBJECT  CDetectAppsNT::FindObjectParent(PPERF_INSTANCE pInst, PPERF_DATA pData)
{
    if (!pInst)
		return 0;
    return FindObject(pData, pInst->ParentObjectTitleIndex);
}


// Returns the name of the pInst.
// If pInst is 0 then 0 is returned.
ICHAR* CDetectAppsNT::InstanceName(PPERF_INSTANCE pInst)
{
    if (pInst)
		return (ICHAR *) ((PCHAR) pInst + pInst->NameOffset);
    else
		return 0;
}

// Returns pointer to the first object in pData.
// If pData is 0 then 0 is returned.
PPERF_OBJECT CDetectAppsNT::FirstObject(PPERF_DATA pData)
{
    if (pData)
		return ((PPERF_OBJECT) ((PBYTE) pData + pData->HeaderLength));
    else
		return 0;
}

// Returns pointer to the next object following pObject.
// If pObject is the last object, bogus data maybe returned.
// The caller should do the checking.
// If pObject is 0, then 0 is returned.
PPERF_OBJECT CDetectAppsNT::NextObject(PPERF_OBJECT pObject)
{
    if (pObject)
		return ((PPERF_OBJECT) ((PBYTE) pObject + pObject->TotalByteLength));
    else
		return 0;
}

// Returns pointer to object with TitleIndex.  If not found, 0
// is returned.
PPERF_OBJECT CDetectAppsNT::FindObject(PPERF_DATA pData, unsigned uiTitleIndex)
{
	PPERF_OBJECT pObject;
	unsigned uiCnt = 0;
    if((pObject = FirstObject(pData)) != 0)
	{
		while (uiCnt++ < pData->NumObjectTypes)
		{
			if (pObject->ObjectNameTitleIndex == uiTitleIndex)
				return pObject;

			pObject = NextObject(pObject);
		}
	}
    return 0;
}

// Find the Nth object in pData.  If not found, NULL is returned.
// 0 <= N < NumObjectTypes.
PPERF_OBJECT CDetectAppsNT::FindObjectN(PPERF_DATA pData, unsigned uiIndex)
{
	PPERF_OBJECT pObject;
	unsigned uiCnt = 0;

	if ((!pData) || (uiIndex >= pData->NumObjectTypes))
		return 0;

	pObject = FirstObject(pData);

	while (uiCnt++ != uiIndex)
		pObject = NextObject(pObject);

	return pObject;
}


IMsiRecord* ::GetModuleUsage(const IMsiString& strFile, IEnumMsiRecord*& rpiEnumRecord, IMsiServices& riServices, CDetectApps*& rpDetectApps)
{
	rpiEnumRecord = 0;

	if(!strFile.TextSize())  // perf hack to allow holding on to the CDetect object on the outside and dropping it when not required
	{
		delete rpDetectApps;// delete object
		rpDetectApps = 0;
		return 0;
	}

	if(!rpDetectApps)
	{
		if(g_fWin9X == false)
		{
			// WinNT
			rpDetectApps = new CDetectAppsNT(riServices);
		}
		else
		{
			// Windows 95
			rpDetectApps = new CDetectApps95(riServices);
		}
	}

	return rpDetectApps->GetFileUsage(strFile, rpiEnumRecord);
}

#endif // MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\shared.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       shared.cpp
//
//--------------------------------------------------------------------------

/* shared.cpp - Darwin actions

  Actions provided by the file

  RegisterFonts
  UnregisterFonts
  WriteRegistryValues
  RemoveRegistryValues
  WriteIniValues
  RemoveIniValues
  CreateShortcuts
  RemoveShortcuts
  AppSearch
  CCPSearch
  RMCCPSearch
  PISearch
  SelfRegModules
  SelfUnregModules
  PrepareSharedSelections
  ProcessSharedSelections
  ProcessComponentProperty
  SetUniqueComponentDirectory
  StartService
  StopService
  InstallODBC
  RemoveODBC
  InstallSFPCatalogFile
____________________________________________________________________________*/

// #includes
#include "precomp.h"
#include "engine.h"
#include "_assert.h"
#include "_engine.h"
#include "_msinst.h"
#include <shlobj.h>  // ShellLink definitions
#include "_camgr.h"

// macro wrapper for IMsiRecord* errors
#define RETURN_ERROR_RECORD(function){							\
							IMsiRecord* piError;	\
							piError = function;		\
							if(piError)				\
								return piError;		\
						}

// macro wrapper for IMsiRecord* errors that returns Engine.FatalError(piError)
#define RETURN_FATAL_ERROR(function){							\
							PMsiRecord pError(0);	\
							pError = function;		\
							if(pError)				\
								return riEngine.FatalError(*pError);		\
						}

// macro wrapper for IMsiRecord* errors that need to be logged but otherwise ignored
#define DO_INFO_RECORD(function){							\
							PMsiRecord pError(0);	\
							pError = function;		\
							if(pError)				\
								riEngine.Message(imtInfo, *pError);		\
						}

// typedefs, consts used in the file

// properties required by CCP actions
const ICHAR* IPROPNAME_CCPSUCCESS =  TEXT("CCP_Success");
const ICHAR* IPROPNAME_CCPDRIVE = TEXT("CCP_DRIVE");

// Fn - PerformAction
// Provides the common stub for all actions
typedef iesEnum (*PFNACTIONCORE)(IMsiRecord& riRecord, IMsiRecord& riPrevRecord, IMsiEngine& riEngine,
												 int fMode,IMsiServices& riServices,IMsiDirectoryManager& riDirectoryMgr,
												 int iActionMode);

static iesEnum PerformAction(IMsiEngine& riEngine,const ICHAR* szActionsql, PFNACTIONCORE pfnActionCore,
									  int iActionMode, int iByteEquivalent, IMsiRecord* piParams = 0, 
									  ttblEnum iTempTable = ttblNone)
{
	iesEnum iesRet;
	PMsiRecord pError(0);
	PMsiServices piServices(riEngine.GetServices());
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	Assert(piDirectoryMgr);
	int fMode = riEngine.GetMode();

	if (iTempTable != 0)
	{
		pError = riEngine.CreateTempActionTable(iTempTable);
		if (pError != 0)
			return riEngine.FatalError(*pError);
	}
		
	PMsiView piView(0);
	pError = riEngine.OpenView(szActionsql, ivcFetch, *&piView);	
	if (pError != 0)
	{
		if(pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesSuccess; // missing table so no data to process
		else
			return riEngine.FatalError(*pError);  // may want to reformat error message
	}
	pError = piView->Execute(piParams);
	if (pError != 0)
		return riEngine.FatalError(*pError);  // may want to reformat error message

	long cRows;
	AssertZero(piView->GetRowCount(cRows));
	if(cRows)
	{
		PMsiRecord pProgressTotalRec = &piServices->CreateRecord(3);
		AssertNonZero(pProgressTotalRec->SetInteger(IxoProgressTotal::Total, cRows));
		AssertNonZero(pProgressTotalRec->SetInteger(IxoProgressTotal::Type, 1)); // 1: use ActionData for progress
		AssertNonZero(pProgressTotalRec->SetInteger(IxoProgressTotal::ByteEquivalent, iByteEquivalent));
		if((iesRet = riEngine.ExecuteRecord(ixoProgressTotal, *pProgressTotalRec)) != iesSuccess)
			return iesRet;
	}
	PMsiRecord piRecord(0);
	PMsiRecord piPrevRecord = &piServices->CreateRecord(0); // previous record - create initially to always
																			  // have a valid record
	while ((piRecord = piView->Fetch()) != 0)
	{
		if((iesRet = (*pfnActionCore)(*piRecord, *piPrevRecord, riEngine, fMode,
												*piServices, *piDirectoryMgr, iActionMode)) != iesSuccess)
			return iesRet;
		piPrevRecord = piRecord;
	}
	AssertRecord(piView->Close()); // need to close view if planning to reexecute existing view
	return iesSuccess;
}

enum {
// 2 sqls to be executed.
	iamWrite,
	iamRemove,
};

/*----------------------------------------------------------------------------
	RegisterFonts, UnregisterFonts actions
----------------------------------------------------------------------------*/

static iesEnum RegisterOrUnregisterFontsCore(IMsiRecord& riRecord,IMsiRecord& riPrevRecord,
											IMsiEngine& riEngine,int /*fMode*/,IMsiServices& riServices,
											IMsiDirectoryManager& riDirectoryMgr, int iActionMode)
{
	enum {
		irfFontTitle=1,
		irfFontFile,
		irfFontPath,
		irfState,
	};
	PMsiPath piPath(0);
	int iefLFNMode;

	if(riRecord.GetInteger(irfState) == iisSource)
	{
		PMsiRecord pErrRec = riDirectoryMgr.GetSourcePath(*MsiString(riRecord.GetMsiString(irfFontPath)),*&piPath);
		if (pErrRec)
		{
			if (pErrRec->GetInteger(1) == imsgUser)
				return iesUserExit;
			else
				return riEngine.FatalError(*pErrRec);
		}
		iefLFNMode = iefNoSourceLFN;
	}
	else
	{
		RETURN_FATAL_ERROR(riDirectoryMgr.GetTargetPath(*MsiString(riRecord.GetMsiString(irfFontPath)),*&piPath));
		iefLFNMode = iefSuppressLFN;
	}

	PMsiRecord pParams2 = &riServices.CreateRecord(2); 
	if(riPrevRecord.GetFieldCount() == 0 ||
		!MsiString(riRecord.GetMsiString(irfFontPath)).Compare(iscExact,
																				 MsiString(riPrevRecord.GetMsiString(irfFontPath))) ||
		riRecord.GetInteger(irfState) != riPrevRecord.GetInteger(irfState))
	{
		using namespace IxoSetTargetFolder;
		AssertNonZero(pParams2->SetMsiString(IxoSetTargetFolder::Folder, *MsiString(piPath->GetPath())));
		iesEnum iesRet;
		if((iesRet = riEngine.ExecuteRecord(ixoSetTargetFolder, *pParams2)) != iesSuccess)
			return iesRet;
	}
	using namespace IxoFontRegister;
	Assert(piPath);
	Bool fLFN = (riEngine.GetMode() & iefLFNMode) == 0 && piPath->SupportsLFN() ? fTrue : fFalse;
	MsiString strFileName;
	RETURN_FATAL_ERROR(riServices.ExtractFileName(riRecord.GetString(irfFontFile),
																 fLFN,*&strFileName));
	AssertNonZero(pParams2->SetMsiString(Title, *MsiString(riRecord.GetMsiString(irfFontTitle))));
	AssertNonZero(pParams2->SetMsiString(File, *strFileName));
	return riEngine.ExecuteRecord(iActionMode == iamRemove ? ixoFontUnregister : ixoFontRegister, *pParams2);
}

iesEnum RegisterFonts(IMsiEngine& riEngine)
{
	//?? is this okay
	static const ICHAR* szRegisterFontsSQL=	TEXT("SELECT `FontTitle`, `FileName`, `Directory_`, `Action`")
									TEXT(" From `Font`, `FileAction`")
									TEXT(" Where `Font`.`File_` = `FileAction`.`File`")
									TEXT(" And (`FileAction`.`Action` = 1 Or `FileAction`.`Action` = 2) ORDER BY `FileAction`.`Directory_`");
//	ICHAR* szRegisterFontsText	=  "Installing font: [1]";

	return PerformAction(riEngine,szRegisterFontsSQL, RegisterOrUnregisterFontsCore,iamWrite, /* ByteEquivalent = */ ibeRegisterFonts, 0, ttblFile);
}


iesEnum UnregisterFonts(IMsiEngine& riEngine)
{
	//?? is this okay
//	ICHAR* szUnregisterFontsText	=  "Installing font: [1]";
	static const ICHAR* szUnregisterFontsSQL	=  TEXT("SELECT `FontTitle`, `FileName`, `Directory_`, `Installed`")
									TEXT("From `Font`, `FileAction`")
									TEXT(" Where `Font`.`File_` = `FileAction`.`File` ")
									TEXT(" And `FileAction`.`Action` = 0 ORDER BY `FileAction`.`Directory_`");

	return PerformAction(riEngine,szUnregisterFontsSQL, RegisterOrUnregisterFontsCore,iamRemove, /* ByteEquivalent = */ ibeUnregisterFonts, 0, ttblFile);
}



/*---------------------------------------------------------------------------
	WriteRegistryValues and RemoveRegistryValues core fns - defers exectution
---------------------------------------------------------------------------*/
const ICHAR* REGKEY_CREATE = TEXT("+");
const ICHAR* REGKEY_DELETE = TEXT("-");
const ICHAR* REGKEY_CREATEDELETE = TEXT("*");

static TRI g_tLockPermTableExists = tUnknown;
static IMsiView *g_pViewLockPermTable = 0;

static iesEnum WriteOrRemoveRegistryValuesCore(IMsiRecord& riRecord,IMsiRecord& riPrevRecord,
														 IMsiEngine& riEngine,int fMode,IMsiServices& riServices,
														 IMsiDirectoryManager& /*riDirectoryMgr*/, int iActionMode)
{
	enum {
		iwrBinaryType=1,
		iwrRoot,
		iwrKey,
		iwrName,
		iwrValue,
		iwrComponent,
		iwrPrimaryKey,
		iwrAction,
		iwrAttributes,
	};

	iesEnum iesRet = iesSuccess;

	int iRoot = riRecord.GetInteger(iwrRoot);
	if((((iRoot == 1) || (iRoot == 3)) && (!(fMode & iefInstallUserData))) || (((iRoot == 0) || (iRoot == 2)) && (!(fMode & iefInstallMachineData))))
		return iesRet;

	// skip the entry if corr. component is a Win32 assembly AND SXS support is present on the machine AND the entry is an HKCR entry
	// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
	// Win32 assemblies, hence there is no need to separately check the SXS support here
	iatAssemblyType iatAT;
	RETURN_FATAL_ERROR(riEngine.GetAssemblyInfo(*MsiString(riRecord.GetMsiString(iwrComponent)), iatAT, 0, 0));

	if((iatWin32Assembly == iatAT || iatWin32AssemblyPvt == iatAT) && iRoot == 0)
	{
		DEBUGMSG1(TEXT("skipping HKCR registration for component %s as it is a Win32 assembly."), riRecord.GetString(iwrComponent));
		return iesSuccess;// skip processing this entry
	}

	// skip the entry if action is null and the keypath of the component is a registry or ODBC key path
	if(iActionMode == (int)iamWrite && riRecord.GetInteger(iwrAction) == iMsiNullInteger && (riRecord.GetInteger(iwrAttributes) & (icaODBCDataSource | icaRegistryKeyPath)))
	{
		DEBUGMSG1(TEXT("skipping registration for component %s as its action column is null and component has registry keypath"), riRecord.GetString(iwrComponent));
		return iesSuccess;// skip processing this entry
	}
		


	PMsiRecord pParams = &riServices.CreateRecord(IxoRegOpenKey::Args); // big enough record
	rrkEnum rrkCurrentRootKey;
	switch(riRecord.GetInteger(iwrRoot))
	{
	case 0:
		rrkCurrentRootKey =  (rrkEnum)rrkClassesRoot;
		break;
	case 1:
		rrkCurrentRootKey =  (rrkEnum)rrkCurrentUser;
		break;
	case 2:
		rrkCurrentRootKey =  (rrkEnum)rrkLocalMachine;
		break;
	case 3:
		rrkCurrentRootKey =  (rrkEnum)rrkUsers;
		break;
	case -1:
		rrkCurrentRootKey =  (rrkEnum)rrkUserOrMachineRoot; // do HKLM or HKCU based on ALLUSERS
		break;
	default:
		rrkCurrentRootKey =  (rrkEnum)(riRecord.GetInteger(iwrRoot) + (int)rrkClassesRoot);
		break;
	}
	MsiString strCurrentKey = ::FormatTextEx(*MsiString(riRecord.GetMsiString(iwrKey)),riEngine, true);
	int iT = riRecord.GetInteger(iwrBinaryType);

	if(riPrevRecord.GetFieldCount() == 0 ||
		iT != riPrevRecord.GetInteger(iwrBinaryType) ||
		riRecord.GetInteger(iwrRoot) != riPrevRecord.GetInteger(iwrRoot) ||
		!strCurrentKey.Compare(iscExactI, MsiString(::FormatTextEx(*MsiString(riPrevRecord.GetMsiString(iwrKey)),riEngine, true))))
	{
		// root or key change
		AssertNonZero(pParams->SetInteger(IxoRegOpenKey::BinaryType, iT));
		AssertNonZero(pParams->SetInteger(IxoRegOpenKey::Root, rrkCurrentRootKey));
		AssertNonZero(pParams->SetMsiString(IxoRegOpenKey::Key, *strCurrentKey));

		PMsiView pviewLockObjects(0);
		PMsiRecord precLockExecute(0);
		PMsiStream pSD(0);
		PMsiRecord pError(0);

		if ( !g_fWin9X && 
				!(riEngine.GetMode() & iefAdmin)) // Don't ACL during admin installs.   Could potentially
																// give a user part of a server.
		{
			if (g_tLockPermTableExists == tUnknown)
			{
				if (PMsiDatabase(riEngine.GetDatabase())->GetTableState(TEXT("LockPermissions"), itsTableExists))
				{
					pError = riEngine.OpenView(sqlLockPermissions, ivcFetch, *&g_pViewLockPermTable);
					if (pError)
						return iesFailure;
					g_tLockPermTableExists = tTrue;
				}
				else
					g_tLockPermTableExists = tFalse;
			}
			if (g_tLockPermTableExists == tTrue)
			{
				AssertSz(g_pViewLockPermTable != 0, "LockPermissions table exists, but no view created.");
				precLockExecute = &riServices.CreateRecord(2);
				AssertNonZero(precLockExecute->SetMsiString(1, *MsiString(*TEXT("Registry"))));
				AssertNonZero(precLockExecute->SetMsiString(2, *MsiString(riRecord.GetMsiString(iwrPrimaryKey))));
				pError = g_pViewLockPermTable->Execute(precLockExecute);
				if (pError)
				{
					AssertZero(PMsiRecord(g_pViewLockPermTable->Close()));
					return riEngine.FatalError(*pError);
				}

				pError = GenerateSD(riEngine, *g_pViewLockPermTable, precLockExecute, *&pSD);
				if (pError)
				{
					AssertZero(PMsiRecord(g_pViewLockPermTable->Close()));
					return riEngine.FatalError(*pError);
				}

				AssertZero(PMsiRecord(g_pViewLockPermTable->Close()));
				
				AssertNonZero(pParams->SetMsiData(IxoRegOpenKey::SecurityDescriptor, pSD));
			}
		}	
		
		if((iesRet = riEngine.ExecuteRecord(ixoRegOpenKey, *pParams)) != iesSuccess)
			return iesRet;
	}
	MsiString strName = ::FormatTextEx(*MsiString(riRecord.GetMsiString(iwrName)),riEngine, true);
	int rgiSFNPos[MAX_SFNS_IN_STRING][2];
	int iSFNPos;

	//YACC!!!
	MsiString istrValue = ::FormatTextSFN(*MsiString(riRecord.GetMsiString(iwrValue)),riEngine, rgiSFNPos, iSFNPos, true);
	if(!istrValue.TextSize())
	{
		// could be a special key creation/deletion request
		if(iActionMode == (int)iamWrite)
		{
			if((strName.Compare(iscExact, REGKEY_CREATE)) || (strName.Compare(iscExact, REGKEY_CREATEDELETE)))
			{
				AssertNonZero(pParams->ClearData());

		
				return riEngine.ExecuteRecord(ixoRegCreateKey, *pParams);
			}
			else if(strName.Compare(iscExact, REGKEY_DELETE))
				return iesSuccess;
		}
		else // if (iActionMode == (int)iamRemove)
		{
			if((strName.Compare(iscExact, REGKEY_DELETE)) || (strName.Compare(iscExact, REGKEY_CREATEDELETE)))
			{
				AssertNonZero(pParams->ClearData());
				return riEngine.ExecuteRecord(ixoRegRemoveKey, *pParams);
			}
			else if(strName.Compare(iscExact, REGKEY_CREATE))
				return iesSuccess;
		}
	}
	if(iSFNPos)
	{
		// there are SFNs in the value
		pParams = &riServices.CreateRecord(IxoRegAddValue::Args + iSFNPos*2); 
	}
	else
	{
		pParams->ClearData();
	}

	AssertNonZero(pParams->SetMsiString(IxoRegAddValue::Name, *strName));
	AssertNonZero(pParams->SetMsiString(IxoRegAddValue::Value, *istrValue));
	for(int cIndex = 0; cIndex < iSFNPos; cIndex++)
	{
		AssertNonZero(pParams->SetInteger(IxoRegAddValue::Args + 1 + cIndex*2, rgiSFNPos[cIndex][0]));
		AssertNonZero(pParams->SetInteger(IxoRegAddValue::Args + 1 + cIndex*2 + 1, rgiSFNPos[cIndex][1]));
	}
	if(iActionMode == (int)iamWrite)
	{
		// we might be installing the HKCR regkeys for a "lesser" component
		if(riRecord.GetInteger(iwrAction) == iMsiNullInteger)
			AssertNonZero(pParams->SetInteger(IxoRegAddValue::Attributes, rwWriteOnAbsent));
		return riEngine.ExecuteRecord(ixoRegAddValue, *pParams);
	}
	else
		return riEngine.ExecuteRecord(ixoRegRemoveValue, *pParams);
}


static const ICHAR* szWriteRegistrySQL	=  TEXT("SELECT `BinaryType`,`Root`,`Key`,`Name`,`Value`, `Component_`, `Registry`, `Action`, `Attributes` FROM `RegAction` WHERE (`Action`=1 OR `Action`=2) ORDER BY `BinaryType`, `Root`, `Key`");
static const ICHAR* szWriteRegistrySQLEX=  TEXT("SELECT `BinaryType`,`Root`,`Key`,`Name`,`Value`, `Component_`, `Registry`, `Action`, `Attributes` FROM `RegAction` WHERE ((`Action`=1 OR `Action`=2) OR (`Root` = 0 AND `Action` = null AND `ActionRequest` = 1)) ORDER BY `BinaryType`, `Root`, `Key`");
/*----------------------------------------------------------------------------
	WriteRegistryValues action - defers execution
----------------------------------------------------------------------------*/
iesEnum WriteRegistryValues(IMsiEngine& riEngine)
{
	iesEnum iesRet;

	// Ensure that our cache is empty
	Assert(g_tLockPermTableExists == tUnknown);
	Assert(g_pViewLockPermTable == 0);
	const ICHAR* szSQL = IsDarwinDescriptorSupported(iddOLE) ? szWriteRegistrySQLEX : szWriteRegistrySQL;
	iesRet = PerformAction(riEngine,szSQL, WriteOrRemoveRegistryValuesCore,iamWrite, /* ByteEquivalent = */ ibeWriteRegistryValues, 0, ttblRegistry);
	// Clear out the cache for the lockpermissions table
	if (g_tLockPermTableExists == tTrue)
	{
		if (g_pViewLockPermTable)
		{
			g_pViewLockPermTable->Release();
			g_pViewLockPermTable = 0;
		}
	}
	g_tLockPermTableExists = tUnknown;
	return iesRet;
}

static const ICHAR* szUnwriteRegistrySQL	=  TEXT("SELECT `BinaryType`,`Root`,`Key`,`Name`,`Value`, `Component_` FROM `RegAction` WHERE (`Action`=0 OR (`Root` = 0 AND (`Action` = 11 OR `Action` = 12))) ORDER BY `BinaryType`, `Root`, `Key`");
static const ICHAR* szRemoveRegistrySQL	=  TEXT("SELECT `BinaryType`,`Root`,`Key`,`Name`, null, `Component_` FROM `RemoveRegistry`,`Component` WHERE `Component`=`Component_` AND (`Action`=1 OR `Action`=2) ORDER BY `BinaryType`, `Root`, `Key`");

/*----------------------------------------------------------------------------
	RemoveRegistryValues action - defers execution
----------------------------------------------------------------------------*/
iesEnum RemoveRegistryValues(IMsiEngine& riEngine)
{

	// Ensure that our cache is empty
	Assert(g_tLockPermTableExists == tUnknown);
	Assert(g_pViewLockPermTable == 0);
	PMsiDatabase piDatabase = riEngine.GetDatabase();
	Assert(piDatabase);
	itsEnum itsTable = piDatabase->FindTable(*MsiString(*TEXT("RemoveRegistry")));

	iesEnum iesRet = PerformAction(riEngine,szUnwriteRegistrySQL, WriteOrRemoveRegistryValuesCore,iamRemove, /* ByteEquivalent = */ ibeRemoveRegistryValues,0, ttblRegistry);
	if((iesRet == iesSuccess) && (itsTable != itsUnknown))
		iesRet = PerformAction(riEngine,szRemoveRegistrySQL, WriteOrRemoveRegistryValuesCore,iamRemove, /* ByteEquivalent = */ ibeRemoveRegistryValues);
		
	// Clear out the cache for the lockpermissions table
	if (g_tLockPermTableExists == tTrue)
	{
		if (g_pViewLockPermTable)
		{
			g_pViewLockPermTable->Release();
			g_pViewLockPermTable = 0;
		}
	}
	g_tLockPermTableExists = tUnknown;
	return iesRet;
}

/*----------------------------------------------------------------------------
	WriteIniValues RemoveIniValues action
----------------------------------------------------------------------------*/
#ifdef WIN    
static iesEnum WriteOrRemoveIniValuesCore(IMsiRecord& riRecord,IMsiRecord& riPrevRecord,
													   IMsiEngine& riEngine,int /*fMode*/,IMsiServices& riServices,
													   IMsiDirectoryManager& /*riDirectoryMgr*/, int iActionMode)
{
	enum {
		iwiFile=1,
		iwiPath,
		iwiSection,
		iwiKey,
		iwiValue,
		iwiMode,
	};

	iifIniMode iifMode = (iifIniMode)riRecord.GetInteger(iwiMode);
	if(iActionMode == (int)iamRemove)
	{
		switch(iifMode)
		{
		case iifIniRemoveLine:
		case iifIniRemoveTag:
			// do nothing
			return iesSuccess;

		case iifIniAddLine:
		case iifIniCreateLine:
			iifMode = iifIniRemoveLine;
			break;
		case iifIniAddTag:
			iifMode = iifIniRemoveTag;
		};
	}

	PMsiRecord pParams2 = &riServices.CreateRecord(2);
	iesEnum iesRet;
	if(riPrevRecord.GetFieldCount() == 0 ||
		! MsiString(riRecord.GetMsiString(iwiPath)).Compare(iscExact,
																			 MsiString(riPrevRecord.GetMsiString(iwiPath))) ||
		! MsiString(riRecord.GetMsiString(iwiFile)).Compare(iscExactI,
																			 MsiString(riPrevRecord.GetMsiString(iwiFile))))
	{
		MsiString strPath = riRecord.GetMsiString(iwiPath);
		MsiString strFile = riRecord.GetMsiString(iwiFile);
		PMsiPath pPath(0);
		if(strPath.TextSize())
		{
			strPath = riEngine.GetProperty(*strPath);
			RETURN_FATAL_ERROR(riServices.CreatePath(strPath, *&pPath));
		}
		else
		{
			// the ini file will be created in the windows directory
			RETURN_FATAL_ERROR(riServices.CreatePath(MsiString(riEngine.GetPropertyFromSz(IPROPNAME_WINDOWS_FOLDER)), *&pPath));
		}

		Bool fLFN = (riEngine.GetMode() & iefSuppressLFN) == 0 && pPath->SupportsLFN() ? fTrue : fFalse;
		MsiString strFileName;
		RETURN_FATAL_ERROR(riServices.ExtractFileName(strFile, fLFN,*&strFileName));

		AssertNonZero(pParams2->SetMsiString(1, *strFileName));
		AssertNonZero(pParams2->SetMsiString(2, *strPath));
		if((iesRet = riEngine.ExecuteRecord(ixoIniFilePath, *pParams2)) != iesSuccess)
			return iesRet;
	}

	int rgiSFNPos[MAX_SFNS_IN_STRING][2];
	int iSFNPos;
	//YACC!!!
	MsiString strValue = ::FormatTextSFN(*MsiString(riRecord.GetMsiString(iwiValue)), riEngine, rgiSFNPos, iSFNPos, false);

	PMsiRecord pParams4 = &riServices.CreateRecord(IxoIniWriteRemoveValue::Args + iSFNPos*2);
	AssertNonZero(pParams4->SetMsiString(1, *MsiString(riEngine.FormatText(*MsiString(riRecord.GetMsiString(iwiSection))))));
	AssertNonZero(pParams4->SetMsiString(2, *MsiString(riEngine.FormatText(*MsiString(riRecord.GetMsiString(iwiKey))))));
	AssertNonZero(pParams4->SetMsiString(3, *strValue));
	AssertNonZero(pParams4->SetInteger(4, iifMode));
	for(int cIndex = 0; cIndex < iSFNPos; cIndex++)
	{
		AssertNonZero(pParams4->SetInteger(IxoIniWriteRemoveValue::Args + 1 + cIndex*2, rgiSFNPos[cIndex][0]));
		AssertNonZero(pParams4->SetInteger(IxoIniWriteRemoveValue::Args + 1 + cIndex*2 + 1, rgiSFNPos[cIndex][1]));
	}
	return riEngine.ExecuteRecord(ixoIniWriteRemoveValue, *pParams4);
}

const ICHAR* szWriteIniValuesSQL	=  TEXT("SELECT `FileName`,`IniFile`.`DirProperty`,`Section`,`IniFile`.`Key`,`IniFile`.`Value`,`IniFile`.`Action` FROM `IniFile`, `Component` WHERE `Component`=`Component_` AND (`Component`.`Action`=1 OR `Component`.`Action`=2) ORDER BY `FileName`,`Section`");

iesEnum WriteIniValues(IMsiEngine& riEngine)
{
	return PerformAction(riEngine, szWriteIniValuesSQL, WriteOrRemoveIniValuesCore,iamWrite, /* ByteEquivalent = */ ibeWriteIniValues);
}

const ICHAR* szUnWriteIniValuesSQL	= TEXT("SELECT `FileName`,`IniFile`.`DirProperty`,`Section`,`IniFile`.`Key`,`IniFile`.`Value`,`IniFile`.`Action` FROM `IniFile`, `Component` WHERE `Component`=`Component_` AND `Component`.`Action`=0 ORDER BY `FileName`,`Section`");
const ICHAR* szRemoveIniValuesSQL		= TEXT("SELECT `FileName`,`RemoveIniFile`.`DirProperty`,`Section`,`RemoveIniFile`.`Key`,`RemoveIniFile`.`Value`,`RemoveIniFile`.`Action` FROM `RemoveIniFile`, `Component` WHERE `Component`=`Component_` AND (`Component`.`Action`=1 OR `Component`.`Action`=2) ORDER BY `FileName`,`Section`");

iesEnum RemoveIniValues(IMsiEngine& riEngine)
{
	PMsiDatabase piDatabase = riEngine.GetDatabase();
	Assert(piDatabase);
	itsEnum itsTable = piDatabase->FindTable(*MsiString(*TEXT("RemoveIniFile")));
	iesEnum iesReturn = PerformAction(riEngine,szUnWriteIniValuesSQL,WriteOrRemoveIniValuesCore,iamRemove, /* ByteEquivalent = */ ibeRemoveIniValues);
	if((iesReturn == iesSuccess) && (itsTable != itsUnknown))
		iesReturn = PerformAction(riEngine,szRemoveIniValuesSQL,WriteOrRemoveIniValuesCore,iamWrite, /* ByteEquivalent = */ ibeWriteIniValues);
	return iesReturn;
}
#endif //WIN    

// forward declarations
static IMsiRecord* FindSigFromComponentId(IMsiEngine& riEngine,MsiString& rstrSig, MsiString& rstrPath, IMsiRecord* piFilter);
static IMsiRecord* FindSigFromReg(IMsiEngine& riEngine,MsiString& rstrSig, MsiString& rstrPath, IMsiRecord* piFilter);
static IMsiRecord* FindSigFromIni(IMsiEngine& riEngine,MsiString& rstrSig, MsiString& rstrPath, IMsiRecord* piFilter);
static IMsiRecord* FindSigFromHD(IMsiEngine& riEngine,MsiString& rstrSig, MsiString& rstrPath, IMsiRecord* piFilter, const ICHAR* pszParent);


enum atType{
	atFolderPath = 0, // the value is a full file path
	atFilePath   = 1, // the value is a folder
	atLiteral    = 2, // the value is not to be interpreted, set the signature to the value as is (RegLocator, IniLocator table only)
};

// Fn - FindSignature
// Fn used by CCP, PI, AppSearch actions
#ifdef WIN    
static IMsiRecord* FindSignature(IMsiEngine& riEngine, MsiString& rstrSig, MsiString& rstrPath, const ICHAR* pszParent)
{
	ICHAR* szGetSignatureInfoSQL = TEXT("SELECT `FileName`, `MinVersion`, `MaxVersion`, `MinSize` , `MaxSize`, `MinDate`, `MaxDate`, `Languages` FROM  `Signature` WHERE `Signature` = ?");
	ICHAR* szGetSignatureSQL = TEXT("SELECT `Signature_`,`Path` FROM `SignatureSearch` WHERE `Signature_` = ?");
	enum {
		igsSignature=1,
		igsPath,
	};


	PMsiServices piServices(riEngine.GetServices());
	Assert(piServices);
	PMsiView piViewSig(0);
	PMsiDatabase piDatabase = riEngine.GetDatabase();
	Assert(piDatabase);
	MsiString strComponentLocator = TEXT("CompLocator");
	MsiString strRegLocator = TEXT("RegLocator");
	MsiString strIniLocator = TEXT("IniLocator");
	MsiString strDrLocator = TEXT("DrLocator");
	Bool bCmpSearch = fTrue;
	Bool bRegSearch = fTrue;
	Bool bIniSearch = fTrue;
	Bool bDrSearch  = fTrue;
	itsEnum itsTable = piDatabase->FindTable(*strComponentLocator);
	if(itsTable == itsUnknown)
		bCmpSearch = fFalse;
	itsTable = piDatabase->FindTable(*strRegLocator);
	if(itsTable == itsUnknown)
		bRegSearch = fFalse;
	itsTable = piDatabase->FindTable(*strIniLocator);
	if(itsTable == itsUnknown)
		bIniSearch = fFalse;
	itsTable = piDatabase->FindTable(*strDrLocator);
	if(itsTable == itsUnknown)
		bDrSearch = fFalse;
	PMsiRecord piParam = &piServices->CreateRecord(1);
	piParam->SetMsiString(1, *rstrSig);
	RETURN_ERROR_RECORD(riEngine.OpenView(szGetSignatureSQL, ivcEnum(ivcFetch|ivcModify), *&piViewSig));
	RETURN_ERROR_RECORD(piViewSig->Execute(piParam));
	PMsiRecord piRecord(0);
	// we have not found the path (as yet)
	rstrPath = TEXT("");
	piRecord = piViewSig->Fetch();
	if(piRecord != 0)
	{
		// file has already been found
		rstrPath = piRecord->GetMsiString(igsPath);
		if((pszParent == 0) || (rstrPath.TextSize() != 0))
		{
			AssertRecord(piViewSig->Close());
			return 0;
		}
	}
	PMsiView piViewSigInfo(0);
	RETURN_ERROR_RECORD(riEngine.OpenView(szGetSignatureInfoSQL, ivcFetch, *&piViewSigInfo));
	RETURN_ERROR_RECORD(piViewSigInfo->Execute(piParam));
	PMsiRecord piFilter(0);
	piFilter = piViewSigInfo->Fetch();
	AssertRecord(piViewSigInfo->Close());
	if(pszParent == 0)
	{
		// check the component locator
		if(bCmpSearch != fFalse)
			DO_INFO_RECORD(FindSigFromComponentId(riEngine, rstrSig, rstrPath, piFilter));
		// check reglocator table
		if((rstrPath.TextSize() == 0) && (bRegSearch != fFalse))
			DO_INFO_RECORD(FindSigFromReg(riEngine, rstrSig, rstrPath, piFilter));
		if((rstrPath.TextSize() == 0) && (bIniSearch != fFalse))
			// test inilocator table
			DO_INFO_RECORD(FindSigFromIni(riEngine, rstrSig, rstrPath, piFilter));
		if((rstrPath.TextSize() == 0) && (bDrSearch != fFalse))
			// test hdlocator table
			DO_INFO_RECORD(FindSigFromHD(riEngine, rstrSig, rstrPath, piFilter,0));
	}
	else
	{
		// root path set
		if(bDrSearch != fFalse)
			DO_INFO_RECORD(FindSigFromHD(riEngine, rstrSig, rstrPath, piFilter, pszParent));
	}
	if(piRecord != 0)
	{
		piRecord->SetMsiString(igsPath, *rstrPath);
		RETURN_ERROR_RECORD(piViewSig->Modify(*piRecord, irmUpdate));
	}
	else
	{
		piRecord = &piServices->CreateRecord(2);
		piRecord->SetMsiString(igsSignature, *rstrSig);
		piRecord->SetMsiString(igsPath, *rstrPath);
		RETURN_ERROR_RECORD(piViewSig->Modify(*piRecord, irmInsert));
	}
	AssertRecord(piViewSig->Close());
	return 0;
}

// Fn - FindSigFromComponentId
// fn to get search the darwin components for a Signature
static IMsiRecord* FindSigFromComponentId(IMsiEngine& riEngine,MsiString& rstrSig, MsiString& rstrPath, IMsiRecord* piFilter)
{
	ICHAR* szGetSigFromCmpSQL = TEXT("SELECT `ComponentId`, `Type` FROM `CompLocator` WHERE `Signature_` = ?");
	enum{
		igrComponentId=1,
		igrType,
	};

	PMsiServices piServices(riEngine.GetServices());
	Assert(piServices);
	PMsiView piView(0);
	RETURN_ERROR_RECORD(riEngine.OpenView(szGetSigFromCmpSQL, ivcFetch, *&piView));
	PMsiRecord piParam = &piServices->CreateRecord(1);
	piParam->SetMsiString(1, *rstrSig);
	RETURN_ERROR_RECORD(piView->Execute(piParam));
	PMsiRecord piRecord = piView->Fetch();
	AssertRecord(piView->Close());
	if(piRecord == 0)
		// no component search for this signature
		return 0;
	CTempBuffer<ICHAR,  MAX_PATH> szBuffer;
	DWORD iSize = MAX_PATH;
	INSTALLSTATE isState = MsiLocateComponent(piRecord->GetString(igrComponentId),
											  szBuffer, &iSize);
	if(isState == ERROR_MORE_DATA)
	{
		szBuffer.SetSize(iSize);
		isState = MsiLocateComponent(piRecord->GetString(igrComponentId),
									 szBuffer, &iSize);
	}

	if((isState != INSTALLSTATE_LOCAL) && (isState != INSTALLSTATE_SOURCE) && (isState != INSTALLSTATE_DEFAULT))
		return 0;
	
	// create path object
	PMsiPath piPath(0);
	RETURN_ERROR_RECORD(piServices->CreatePath(szBuffer, *&piPath));
	if(piRecord->GetInteger(igrType))
	{
		MsiString strFName;
		strFName = piPath->GetEndSubPath();
		piPath->ChopPiece();
		if(piFilter)
		{
			// overwrite the filename 
			piFilter->SetMsiString(1, *strFName);
		}
	}
	Bool fFound;
	if(piFilter)
	{
		// file
		RETURN_ERROR_RECORD(piPath->FindFile(*piFilter, 0, fFound));
		if(fFound == fTrue)
			RETURN_ERROR_RECORD(piPath->GetFullFilePath(piFilter->GetString(1), *&rstrPath));
	}
	else
	{
		// just the path
		RETURN_ERROR_RECORD(piPath->Exists(fFound));
		if(fFound == fTrue)
			rstrPath = piPath->GetPath();
	}
	return 0;
}

// Fn - FindSigFromReg
// fn to get search the registry for a Signature
static IMsiRecord* FindSigFromReg(IMsiEngine& riEngine,MsiString& rstrSig, MsiString& rstrPath, IMsiRecord* piFilter)
{
	ICHAR* szGetSigFromRegSQL = TEXT("SELECT `Root`, `Key`, `Name`, `Type` FROM `RegLocator` WHERE `Signature_` = ?");
	enum{
		igrRoot=1,
		igrKey,
		igrName,
		igrType,
	};

	PMsiServices piServices(riEngine.GetServices());
	Assert(piServices);
	PMsiView piView(0);
	RETURN_ERROR_RECORD(riEngine.OpenView(szGetSigFromRegSQL, ivcFetch, *&piView));
	PMsiRecord piParam = &piServices->CreateRecord(1);
	piParam->SetMsiString(1, *rstrSig);
	RETURN_ERROR_RECORD(piView->Execute(piParam));
	PMsiRecord piRecord = piView->Fetch();
	AssertRecord(piView->Close());
	if(piRecord == 0)
		// no registry search for this signature
		return 0;
	rrkEnum rrkCurrentRootKey;
	switch(piRecord->GetInteger(igrRoot))
	{
	case 0:
		rrkCurrentRootKey =  (rrkEnum)rrkClassesRoot;
		break;
	case 1:
		rrkCurrentRootKey =  (rrkEnum)rrkCurrentUser;
		break;
	case 2:
		rrkCurrentRootKey =  (rrkEnum)rrkLocalMachine;
		break;
	case 3:
		rrkCurrentRootKey =  (rrkEnum)rrkUsers;
		break;
	default:
		rrkCurrentRootKey =  (rrkEnum)(piRecord->GetInteger(igrRoot) + (int)rrkClassesRoot);
		break;
	}
	ibtBinaryType iType = ibt32bit;
	if ( (piRecord->GetInteger(igrType) & msidbLocatorType64bit) == msidbLocatorType64bit )
		iType = ibt64bit;
	PMsiRegKey piRootKey = &piServices->GetRootKey(rrkCurrentRootKey, iType);
	PMsiRegKey piKey = &piRootKey->CreateChild(MsiString(riEngine.FormatText(*MsiString(piRecord->GetMsiString(igrKey)))));
	MsiString strValue;
	MsiString strName = riEngine.FormatText(*MsiString(piRecord->GetMsiString(igrName)));
	RETURN_ERROR_RECORD(piKey->GetValue(strName, *&strValue));
	if(strValue.TextSize() == 0)
		return 0;
	PMsiPath piPath(0);
	// check for environment variables
	if(strValue.Compare(iscStart,TEXT("#%"))) // REG_EXPAND_SZ
	{
		MsiString strUnexpandedValue = strValue.Extract(iseLast, strValue.CharacterCount() - 2);
		ENG::ExpandEnvironmentStrings(strUnexpandedValue, *&strValue);
	}
	if ( g_fWinNT64 && g_Win64DualFolders.ShouldCheckFolders() )
	{
		ICHAR rgchSubstitute[MAX_PATH+1] = {0};
		ieSwappedFolder iRes;
		iRes = g_Win64DualFolders.SwapFolder(ie64to32,
														 strValue,
														 rgchSubstitute,
														 ARRAY_ELEMENTS(rgchSubstitute));
		if ( iRes == iesrSwapped )
			strValue = rgchSubstitute;
		else
			Assert(iRes != iesrError && iRes != iesrNotInitialized);
	}

	// do we try to interpret the read value?
	if((piRecord->GetInteger(igrType) & atLiteral) == atLiteral)
	{
		// set the path to the value read, as is
		rstrPath = strValue;
		return 0;
	}

	int iNumTries = 1; // number of tries to interpret the read value

	MsiString strValue2; // 
	if(*(const ICHAR*)strValue == '"') // we have a quoted path
	{
		strValue.Remove(iseFirst, 1);
		MsiString strTemp = strValue.Extract(iseUpto, '"');
		if(strTemp.Compare(iscExact, strValue)) // there is no ending quote, bogus entry
			return 0;
		strValue = strTemp;
	}
	else
	{
		strValue2 = strValue.Extract(iseUpto, ' ');
		if(!strValue2.Compare(iscExact, strValue)) // there is a space, try twice, once with spaces then w/o
		{
			iNumTries = 2;

		}

	}
	for(int i = 0; i < iNumTries; i++)
	{
		const ICHAR* pszPath = i ? (const ICHAR*)strValue2 : (const ICHAR*)strValue;

		// create path object
		DO_INFO_RECORD(piServices->CreatePath(pszPath, *&piPath));
		if(!piPath)
			continue;

		if((piRecord->GetInteger(igrType) & atFilePath) == atFilePath)
		{
			MsiString strFName;
			strFName = piPath->GetEndSubPath();
			piPath->ChopPiece();
			if(piFilter)
			{
				// overwrite the filename 
				piFilter->SetMsiString(1, *strFName);
			}
		}

		Bool fFound = fFalse;
		if(piFilter)
		{
			// file
			DO_INFO_RECORD(piPath->FindFile(*piFilter, 0, fFound));
			if(fFound == fTrue)
				DO_INFO_RECORD(piPath->GetFullFilePath(piFilter->GetString(1), *&rstrPath));
		}
		else
		{
			// just the path
			DO_INFO_RECORD(piPath->Exists(fFound));
			if(fFound == fTrue)
				rstrPath = piPath->GetPath();
		}
		if(fFound == fTrue)
			break;
	}
	return 0;
}


const ICHAR* szGetSigFromIniSQL = TEXT("SELECT `FileName`, `Section`, `IniLocator`.`Key`, `Field`, `Type` FROM `IniLocator` WHERE `Signature_` = ?");

// Fn - FindSigFromIni
// fn to get search the INI files for a Signature
static IMsiRecord* FindSigFromIni(IMsiEngine& riEngine,MsiString& rstrSig, MsiString& rstrPath, IMsiRecord* piFilter)
{
	enum{
		igiFileName=1,
		igiSection,
		igiKey,
		igiField,
		igiType,
	};


	PMsiServices piServices(riEngine.GetServices());
	Assert(piServices);
	PMsiView piView(0);
	RETURN_ERROR_RECORD(riEngine.OpenView(szGetSigFromIniSQL, ivcFetch, *&piView));
	PMsiRecord piParam = &piServices->CreateRecord(1);
	piParam->SetMsiString(1, *rstrSig);
	RETURN_ERROR_RECORD(piView->Execute(piParam));
	PMsiRecord piRecord = piView->Fetch();
	AssertRecord(piView->Close());
	if(piRecord == 0)
		// no ini search for this signature
		return 0;
	//!! currently we support .INI files in default directories only
	PMsiPath piPath(0);
	MsiString strValue;
	int iField = piRecord->IsNull(igiField) ? 0:piRecord->GetInteger(igiField);

	if (iField < 0)
	{
		// invalid data value, must be non-negative
		IMsiRecord* piErrorRec = PostError(Imsg(idbgDbInvalidData));
		return piErrorRec;
	}

	MsiString strFileName = piRecord->GetString(igiFileName);
	MsiString strSFNPath, strLFNPath;
	PMsiRecord pError = piServices->ExtractFileName(strFileName, fFalse, *&strSFNPath);
	pError = piServices->ExtractFileName(strFileName, fTrue,  *&strLFNPath);
	if(strLFNPath.Compare(iscExactI, strSFNPath))
		strLFNPath = g_MsiStringNull; // not really a LFN

	for(int i = 0; i < 2; i++)
	{
		const ICHAR* pFileName = i ? (const ICHAR*)strLFNPath : (const ICHAR*)strSFNPath;
		if(!pFileName || !*pFileName)
			continue;

		DO_INFO_RECORD(piServices->ReadIniFile(	0, 
												pFileName, 
												MsiString(riEngine.FormatText(*MsiString(piRecord->GetMsiString(igiSection)))),
												MsiString(riEngine.FormatText(*MsiString(piRecord->GetMsiString(igiKey)))),
												iField, 
												*&strValue));
		if (strValue.TextSize() == 0)
			continue;

		// check for environment variables
		MsiString strExpandedValue;
		ENG::ExpandEnvironmentStrings(strValue, *&strExpandedValue);
		if ( g_fWinNT64 && g_Win64DualFolders.ShouldCheckFolders() )
		{
			ICHAR rgchSubstitute[MAX_PATH+1] = {0};
			ieSwappedFolder iRes;
			iRes = g_Win64DualFolders.SwapFolder(ie64to32,
															 strExpandedValue,
															 rgchSubstitute,
															 ARRAY_ELEMENTS(rgchSubstitute));
			if ( iRes == iesrSwapped )
				strExpandedValue = rgchSubstitute;
			else
				Assert(iRes != iesrError && iRes != iesrNotInitialized);
		}
		
		// do we try to interpret the read value?
		if(piRecord->GetInteger(igiType) == atLiteral)
		{
			// set the path to the value read, as is
			rstrPath = strValue;
			return 0;
		}

	// create path object
		DO_INFO_RECORD(piServices->CreatePath(strExpandedValue, *&piPath));
		if(!piPath)
			continue;

		if(piRecord->GetInteger(igiType))
		{
			MsiString strFName;
			strFName = piPath->GetEndSubPath();
			piPath->ChopPiece();
			if(piFilter)
			{
				// overwrite the filename 
				piFilter->SetMsiString(1, *strFName);
			}
		}
		Bool fFound = fFalse;
		if(piFilter)
		{
			// file
			DO_INFO_RECORD(piPath->FindFile(*piFilter, 0, fFound));
			if(fFound == fTrue)
				DO_INFO_RECORD(piPath->GetFullFilePath(piFilter->GetString(1), *&rstrPath));
		}
		else
		{
			// just the path
			DO_INFO_RECORD(piPath->Exists(fFound));
			if(fFound == fTrue)
				rstrPath = piPath->GetPath();
		}
		if(fFound == fTrue)
			break;
	}
	return 0;
}

// Fn - FindPath
// fn to search fo a directory below a path
static IMsiRecord* FindPath(IMsiPath& riPath, MsiString& strPath, int iDepth, Bool& fFound)
{
	fFound = fFalse;

	Bool fPathExists;
	RETURN_ERROR_RECORD(riPath.Exists(fPathExists));
	if(fPathExists == fFalse)
		return 0;

	RETURN_ERROR_RECORD(riPath.AppendPiece(*strPath));
	RETURN_ERROR_RECORD(riPath.Exists(fPathExists));
	if(fPathExists )
	{
		fFound = fTrue;
		return 0;
	}

	RETURN_ERROR_RECORD(riPath.ChopPiece());

	if(iDepth--)
	{
		// enumerate the subfolders
		PEnumMsiString piEnumStr(0);
		RETURN_ERROR_RECORD(riPath.GetSubFolderEnumerator(*&piEnumStr, /* fExcludeHidden = */ fFalse));
		MsiString strSubPath;
		while(piEnumStr->Next(1, &strSubPath, 0)==S_OK)
		{
			RETURN_ERROR_RECORD(riPath.AppendPiece(*strSubPath));
			RETURN_ERROR_RECORD(FindPath(riPath,strPath,iDepth, fFound));
			if(fFound == fTrue)
				return 0;
			RETURN_ERROR_RECORD(riPath.ChopPiece());
		}
	}
	return 0;
}


static IMsiRecord* FindSigHelper(IMsiPath& riPath, MsiString& rstrPath, int iDepth, Bool& fFound, IMsiRecord* piFilter)
{
	if(piFilter)
	{
		// file
		RETURN_ERROR_RECORD(riPath.FindFile(*piFilter, iDepth, fFound));
		if(fFound == fTrue)
			RETURN_ERROR_RECORD(riPath.GetFullFilePath(piFilter->GetString(1), *&rstrPath));
	}
	else
	{
		// just the path
		MsiString strEndPath = riPath.GetEndSubPath();
		RETURN_ERROR_RECORD(riPath.ChopPiece());
		RETURN_ERROR_RECORD(FindPath(riPath, strEndPath, iDepth, fFound));
		if(fFound == fTrue)
			rstrPath = riPath.GetPath();
	}
	return 0;
}


// Fn - FindSigFromHD
// fn to get search the fixed drives for a Signature
static IMsiRecord* FindSigFromHD(IMsiEngine& riEngine,MsiString& rstrSig, MsiString& rstrPath, IMsiRecord* piFilter, const ICHAR* pszParent)
{
	ICHAR* szGetSigFromHDSQL = TEXT("SELECT `Parent`, `Path`, `Depth` FROM `DrLocator` WHERE `Signature_` = ? ORDER BY `Depth`");
	ICHAR* szGetSigFromHDKnownParentSQL = TEXT("SELECT `Parent`, `Path`, `Depth` FROM `DrLocator` WHERE `Signature_` = ? And `Parent` = ? ORDER BY `Depth`");
	ICHAR* szHDQuerySQL;
	enum{
		igfParent=1,
		igfPath,
		igfDepth,
	};
	PMsiServices piServices(riEngine.GetServices());
	Assert(piServices);
	PMsiView piView(0);
	if(pszParent)
		szHDQuerySQL = szGetSigFromHDKnownParentSQL;
	else
		szHDQuerySQL = szGetSigFromHDSQL;
	RETURN_ERROR_RECORD(riEngine.OpenView(szHDQuerySQL, ivcFetch, *&piView));
	PMsiRecord piParam = &piServices->CreateRecord(2);
	piParam->SetMsiString(1, *rstrSig);
	piParam->SetString(2, pszParent);
	RETURN_ERROR_RECORD(piView->Execute(piParam));
	PMsiPath piPath(0);
	Bool fFound = fFalse;
	PMsiRecord piRecord(0);
	while((piRecord = piView->Fetch()) && (fFound == fFalse))
	{
		MsiString strParent = piRecord->GetMsiString(igfParent);
		MsiString strPath = riEngine.FormatText(*MsiString(piRecord->GetMsiString(igfPath)));
		int iDepth = 0;
		if(piRecord->IsNull(igfDepth) == fFalse)
			iDepth = piRecord->GetInteger(igfDepth);

		MsiString strSFNPath, strLFNPath;
		bool fUseSFN = false; 
		bool fUseLFN = false;

		if(strParent.TextSize() || PathType(strPath) != iptFull)
		{
			// need to check if long| short path names specified
			PMsiRecord(piServices->ExtractFileName(strPath, fFalse, *&strSFNPath));
			PMsiRecord(piServices->ExtractFileName(strPath, fTrue,  *&strLFNPath));
			if(!strSFNPath.TextSize() && !strLFNPath.TextSize())
				strSFNPath = strPath; // try using the provided path instead
			fUseSFN = strSFNPath.TextSize() || !strLFNPath.TextSize();
			fUseLFN = strLFNPath.TextSize() && !strLFNPath.Compare(iscExactI, strSFNPath);

		}

		if(!strParent.TextSize())
		{
			PMsiRecord pError(0);
			// do we have a fully defined path?
			if(PathType(strPath) != iptFull)
			{
				// no full path
				// root, enumerate through all HDs
				PMsiVolume piVolume(0);
				PEnumMsiVolume piEnum = &piServices->EnumDriveType(idtFixed);
				bool fToggle = false;
				for (; (fFound == fFalse && (fToggle || piEnum->Next(1, &piVolume, 0)==S_OK)); fToggle = !fToggle)
				{
					DO_INFO_RECORD(piServices->CreatePath(MsiString(piVolume->GetPath()),
																			 *&piPath));
					if(!fToggle)
					{
						if(!fUseSFN)
							continue;
						RETURN_ERROR_RECORD(piPath->AppendPiece(*strSFNPath));
					}
					else
					{
						if(!fUseLFN)
							continue;
						RETURN_ERROR_RECORD(piPath->AppendPiece(*strLFNPath));
					}
					DO_INFO_RECORD(FindSigHelper(*piPath, rstrPath, iDepth, fFound, piFilter));
				}
			}
			else
			{
				// full path
				RETURN_ERROR_RECORD(piServices->CreatePath(strPath,*&piPath));
				RETURN_ERROR_RECORD(FindSigHelper(*piPath, rstrPath, iDepth, fFound, piFilter));
			}
		}
		else
		{
			MsiString strParentPath;
			RETURN_ERROR_RECORD(FindSignature(riEngine, strParent, strParentPath,0));
			if(strParentPath.TextSize() == 0)
				continue;
			if(!strParentPath.Compare(iscEnd, szDirSep))
			{
				// file signature
				MsiString strFileName;
				RETURN_ERROR_RECORD(piServices->CreateFilePath(strParentPath, *&piPath, *&strFileName));
			}
			else
			{
				// folder signature
				RETURN_ERROR_RECORD(piServices->CreatePath(strParentPath, *&piPath));
			}
			for (int cCount = 0; cCount < 2; cCount++)
			{
				if(!cCount)
				{
					if(!fUseSFN)
						continue;
					RETURN_ERROR_RECORD(piPath->AppendPiece(*strSFNPath));
				}
				else
				{
					if(!fUseLFN)
						continue;
					RETURN_ERROR_RECORD(piPath->AppendPiece(*strLFNPath));
				}
				RETURN_ERROR_RECORD(FindSigHelper(*piPath, rstrPath, iDepth, fFound, piFilter));
				if(fFound)
					return 0;
				RETURN_ERROR_RECORD(piPath->ChopPiece());
			}
		}
	}
	AssertRecord(piView->Close());
	return 0;
}

// Fn - EnsureSearchTable
// Ensures that the in memory search table is present
static IMsiRecord* EnsureSearchTable(IMsiEngine& riEngine)
{
	PMsiRecord pError(0);
	PMsiDatabase piDatabase(riEngine.GetDatabase());
	Assert(piDatabase);
	MsiString strSearchTbl = TEXT("SignatureSearch");
	itsEnum itsSearchTable = piDatabase->FindTable(*strSearchTbl);
	switch(itsSearchTable)
	{
	case itsUnknown:
	{
		// table not yet created
		PMsiTable piSearchTbl(0);
		RETURN_ERROR_RECORD(piDatabase->CreateTable(*strSearchTbl, 0, *&piSearchTbl));
		MsiString strSignature = TEXT("Signature_");
		MsiString strPath = TEXT("Path");
		AssertNonZero(piSearchTbl->CreateColumn(icdString + icdPrimaryKey, *strSignature) == 1);
		AssertNonZero(piSearchTbl->CreateColumn(icdString + icdNullable, *strPath) == 2);
		//!! extremely unefficient if LockTable is not honoured
		piDatabase->LockTable(*strSearchTbl, fTrue);
		return 0;
	}
	case itsTemporary:
		// table present
		return 0;
	default:
		return PostError(Imsg(idbgDuplicateTableName), *strSearchTbl);
	}
}


// Fn - AppSearch action, searches the user hd for existing installs
iesEnum AppSearch(IMsiEngine& riEngine)
{
	if(riEngine.GetMode() & iefSecondSequence)
	{
		DEBUGMSG(TEXT("Skipping AppSearch action: already done on client side"));
		return iesNoAction;
	}

	static const ICHAR* szAppSearchSQL = TEXT("SELECT `Property`, `Signature_` FROM `AppSearch`");
	enum{
		iasProperty=1,
		iasSignature,
	};

	PMsiRecord pError(0);
	//?? what action needs to be taken if the "AppSearch" property is already set
	PMsiView piView(0);
	pError= riEngine.OpenView(szAppSearchSQL, ivcFetch, *&piView);
	if (pError != 0)
	{
		if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pError);
		else
			return iesNoAction;
	}
	pError = piView->Execute(0);  
	if (pError != 0)        
		return riEngine.FatalError(*pError);  
	PMsiRecord piRecord(0);
	pError = EnsureSearchTable(riEngine);
	while ((pError == 0) && ((piRecord = piView->Fetch()) != 0))
	{
		if (riEngine.Message(imtActionData, *piRecord) == imsCancel)
			return iesUserExit;
		MsiString strSignature = piRecord->GetMsiString(iasSignature);
		MsiString strPath;
		if(((pError = FindSignature(riEngine, strSignature, strPath,0)) == 0) && 
			(strPath.TextSize() != 0))
		{
			// write if found only (so as not to overwrite previous finds)
			MsiString strProperty = piRecord->GetMsiString(iasProperty);
			riEngine.SetProperty(*strProperty, *strPath);
		}
	}
	AssertRecord(piView->Close()); // need to close view if planning to reexecute existing view

	//!! send completion message to UI
	if(pError != 0)
		return riEngine.FatalError(*pError);
	else
		return iesSuccess;
}




// Fn - CCPSearch action, searches the user hd for complying installs
iesEnum CCPSearch(IMsiEngine& riEngine)
{
	if(riEngine.GetMode() & iefSecondSequence)
	{
		DEBUGMSG(TEXT("Skipping CCPSearch action: already done on client side"));
		return iesNoAction;
	}

	if(MsiString(riEngine.GetPropertyFromSz(IPROPNAME_CCPSUCCESS)).TextSize()) 
		return iesSuccess;// already found

	static const ICHAR* szCCPSearchSQL = TEXT("SELECT `Signature_` FROM `CCPSearch`");
	enum{
		icsSignature=1,
	};

	PMsiRecord pError(0);
	//?? what action needs to be taken if the "CCPSearch" property is already set
	PMsiView piView(0);
	pError = riEngine.OpenView(szCCPSearchSQL, ivcFetch, *&piView);
	if (pError != 0)        // if view query can't be located
	{
		if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pError);
		else
			return iesNoAction;
	}
	pError = piView->Execute(0);  // may want to pass a parameter record here
	if (pError != 0)        // view execution failed, maybe missing parameters
		return riEngine.FatalError(*pError);  // may want to reformat error message
	PMsiRecord piRecord(0);
	MsiString strPath;
	pError = EnsureSearchTable(riEngine);
	while ((pError == 0) && ((piRecord = piView->Fetch()) != 0) && (strPath.TextSize() == 0))
	{
		if (riEngine.Message(imtActionData, *piRecord) == imsCancel) // notify log and UI
			return iesUserExit;  
		pError = FindSignature(riEngine, MsiString(piRecord->GetMsiString(icsSignature)), strPath,0);
	}
	AssertRecord(piView->Close()); // need to close view if planning to reexecute existing view
	if(pError != 0)
		return riEngine.FatalError(*pError);
	if(strPath.TextSize() != 0)
		riEngine.SetPropertyInt(*MsiString(*IPROPNAME_CCPSUCCESS), 1);
	return iesSuccess;
}



// Fn - RMCCPSearch action, searches the removable media for complying installs
iesEnum RMCCPSearch(IMsiEngine& riEngine)
{
	if(riEngine.GetMode() & iefSecondSequence)
	{
		DEBUGMSG(TEXT("Skipping RMCCPSearch action: already done on client side"));
		return iesNoAction;
	}

	if(MsiString(riEngine.GetPropertyFromSz(IPROPNAME_CCPSUCCESS)).TextSize()) 
		return iesSuccess;// already found

	// check if we really have a non-empty CCPSearch table, if no 
	// we assume we dont really want to do any CCPSearch and return no action
	static const ICHAR* szCCPSearchSQL = TEXT("SELECT `Signature_` FROM `CCPSearch`");
	enum{
		icsSignature=1,
	};
	PMsiView piView(0);
	PMsiRecord pError(0);
	pError = riEngine.OpenView(szCCPSearchSQL, ivcFetch, *&piView);
	if (pError != 0)
	{
		if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pError);
		else
			return iesNoAction;
	}
	pError = piView->Execute(0);
	if(pError != 0)
		return riEngine.FatalError(*pError);

	long cRows = 0;
	pError = piView->GetRowCount(cRows);
	if(pError != 0)
		return riEngine.FatalError(*pError);
	if(!cRows)
		return iesNoAction;

	// check if IPROPNAME_CCPDRIVE Property not set
	MsiString strPath = riEngine.GetPropertyFromSz(IPROPNAME_CCPDRIVE);
	if(!strPath.TextSize())
	{
		RETURN_FATAL_ERROR(PostError(Imsg(imsgCCPSearchFailed)));
	}

	// AppSearch action, searches the user hd for existing installs
	static const ICHAR* szGetSignatureSQL = TEXT("SELECT `Signature_`,`Path` FROM `SignatureSearch` WHERE `Signature_` = ?");
	enum {
		igsSignature=1,
		igsPath,
	};

	static const ICHAR* szCCPText = TEXT("Searching for compliant products");

	PMsiServices piServices(riEngine.GetServices());

	pError = EnsureSearchTable(riEngine);
	if (pError != 0)
		return riEngine.FatalError(*pError);
	PMsiView piView1(0);
	PMsiRecord piRecord(0);
	PMsiRecord piParam = &piServices->CreateRecord(1);
	piParam->SetString(1, IPROPNAME_CCPDRIVE);
	if(((pError = riEngine.OpenView(szGetSignatureSQL, ivcEnum(ivcFetch|ivcModify), *&piView1)) != 0) ||
		((pError = piView1->Execute(piParam)) != 0))
		return riEngine.FatalError(*pError);
	if(piRecord = piView1->Fetch())
	{
		// update
		piRecord->SetMsiString(igsPath, *strPath);
		if((pError = piView1->Modify(*piRecord, irmUpdate)) != 0)
			return riEngine.FatalError(*pError);
	}
	else
	{
		// insert
		piRecord = &piServices->CreateRecord(2);
		piRecord->SetString(igsSignature, IPROPNAME_CCPDRIVE);
		piRecord->SetMsiString(igsPath, *strPath);
		if((pError = piView1->Modify(*piRecord, irmInsert)) != 0)
			return riEngine.FatalError(*pError);
	}
	AssertRecord(piView1->Close());
	piView1 = 0;

	strPath = TEXT("");

	while (((piRecord = piView->Fetch()) != 0) && (strPath.TextSize() == 0))
	{
		piRecord->SetString(0, szCCPText);       // provide log format string
		if (riEngine.Message(imtActionData, *piRecord) == imsCancel)  // notify log and UI
			return iesUserExit;
		pError = FindSignature(riEngine, MsiString(piRecord->GetMsiString(icsSignature)), strPath, IPROPNAME_CCPDRIVE);
		if(pError != 0)
			return riEngine.FatalError(*pError);
	}
	AssertRecord(piView->Close()); // need to close view if planning to reexecute existing view
	if(strPath.TextSize() != 0)
		riEngine.SetPropertyInt(*MsiString(*IPROPNAME_CCPSUCCESS), 1);
	else
	{
		RETURN_FATAL_ERROR(PostError(Imsg(imsgCCPSearchFailed)));
	}
	return iesSuccess;
}

#if 0
//!! to be removed - we no longer expect Product Inventory to be a part of Darwin

// Fn - PISearch action, searches the user hd for previous installs
static iesEnum PISearch(IMsiEngine& riEngine)
{
	// PISearch action, searches the user hd for existing installs
	static const ICHAR* szPISearchSQL = TEXT("SELECT `Signature_` FROM `PISearch`");
	enum{
		ipsSignature=1,
	};
	static const ICHAR* szPIText = TEXT("Searching for installed applications");
	PMsiRecord pError(0);
	PMsiView piView(0);
	pError = riEngine.OpenView(szPISearchSQL, ivcFetch, *&piView);
	if (pError != 0)
		return riEngine.FatalError(*pError);
	pError = piView->Execute(0);
	if (pError != 0)
		return riEngine.FatalError(*pError);
	PMsiRecord piRecord(0);
	MsiString strPath;
	pError = EnsureSearchTable(riEngine);
	while ((pError == 0) && ((piRecord = piView->Fetch()) != 0))
	{
		piRecord->SetString(0, szPIText);       // provide log format string
		if (riEngine.Message(imtActionData, *piRecord) == imsCancel)  // notify log and UI
			return iesUserExit;
		pError = FindSignature(riEngine, MsiString(piRecord->GetMsiString(ipsSignature)), strPath,0);
	}
	AssertRecord(piView->Close()); // need to close view if planning to reexecute existing view
	//!! send completion message to UI
	if(pError != 0)
		return riEngine.FatalError(*pError);
	else
		return iesSuccess;
}
static CActionEntry aePISearch(TEXT("PISearch"), PISearch);
#endif

#endif //WIN    


/*----------------------------------------------------------------------------
	SelfRegModules, SelfUnregModules actions
----------------------------------------------------------------------------*/

#ifdef WIN    
static iesEnum SelfRegOrUnregModulesCore(IMsiRecord& riRecord,IMsiRecord& riPrevRecord,
												  IMsiEngine& riEngine,int /*fMode*/,IMsiServices& riServices,
												  IMsiDirectoryManager& riDirectoryMgr, int iActionMode)
{
	IMsiRecord* piError = 0;
	enum {
		irmFile=1,
		irmPath,
		irmAction,
		irmComponent,
		irmFileID,
	};

	enum {
		iamReg,
		iamUnreg,
	};

	Bool fSuppressLFN = riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;
	PMsiPath piPath(0);
	PMsiRecord pParams2 = &riServices.CreateRecord(2);
	iesEnum iesRet;
	
	int iefLFNMode;

	// skip the entry if corr. component is a Win32 assembly AND SXS support is present on the machine
	// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
	// Win32 assemblies, hence there is no need to separately check the SXS support here
	iatAssemblyType iatAT;
	RETURN_FATAL_ERROR(riEngine.GetAssemblyInfo(*MsiString(riRecord.GetMsiString(irmComponent)), iatAT, 0, 0));

	if(iatWin32Assembly == iatAT || iatWin32AssemblyPvt == iatAT)
	{
		DEBUGMSG1(TEXT("skipping self-registration for file %s as it belongs to a Win32 assembly."), riRecord.GetString(irmFile));
		return iesSuccess;// skip processing this file
	}


	if(riRecord.GetInteger(irmAction) == iisSource)
	{
		if(iActionMode == (int)iamReg || riEngine.GetPropertyInt(*MsiString(*IPROPNAME_UNREG_SOURCERESFAILED)) == iMsiNullInteger) // dont try to resolve source twice
		{
			PMsiRecord pErrRec = riDirectoryMgr.GetSourcePath(*MsiString(riRecord.GetMsiString(irmPath)),*&piPath);
			if (pErrRec)
			{
				if (pErrRec->GetInteger(1) == imsgUser)
					return iesUserExit;
				else if(iActionMode == (int)iamUnreg && (pErrRec->GetInteger(1) == imsgSourceResolutionFailed || pErrRec->GetInteger(1) == imsgSourceResolutionFailedCSOS))
				{
					// simply set the IPROPNAME_UNREG_SOURCERESFAILED property, log the failure, and continue
					riEngine.SetPropertyInt(*MsiString(*IPROPNAME_UNREG_SOURCERESFAILED), 1);
					DO_INFO_RECORD(PMsiRecord(PostError(Imsg(idbgOpRegSelfUnregFailed), (const ICHAR*)riRecord.GetString(irmFile))));
					return iesSuccess;
				}

					return riEngine.FatalError(*pErrRec);
			}
			iefLFNMode = iefNoSourceLFN;
		}
		else
		{
			// simply log the failure, and continue
			DO_INFO_RECORD(PMsiRecord(PostError(Imsg(idbgOpRegSelfUnregFailed), (const ICHAR*)riRecord.GetString(irmFile))));
			return iesSuccess;
		}
		
	}
	else
	{
		RETURN_FATAL_ERROR(riDirectoryMgr.GetTargetPath(*MsiString(riRecord.GetMsiString(irmPath)),*&piPath));
		iefLFNMode = iefSuppressLFN;
	}

	if(riPrevRecord.GetFieldCount() == 0 ||
		! MsiString(riRecord.GetMsiString(irmPath)).Compare(iscExact,
																			 MsiString(riPrevRecord.GetMsiString(irmPath))) ||
		riRecord.GetInteger(irmAction) != riPrevRecord.GetInteger(irmAction))
	{
		AssertNonZero(pParams2->SetMsiString(IxoSetTargetFolder::Folder, *MsiString(piPath->GetPath())));
		if((iesRet = riEngine.ExecuteRecord(ixoSetTargetFolder, *pParams2)) != iesSuccess)
			return iesRet;
	}

	Bool fLFN = (riEngine.GetMode() & iefLFNMode) == 0 && piPath->SupportsLFN() ? fTrue : fFalse;
	MsiString strFile;
	RETURN_FATAL_ERROR(riServices.ExtractFileName(riRecord.GetString(irmFile),fLFN,*&strFile));

	using namespace IxoRegSelfReg; // same as IxoRegSelfUnreg
	AssertNonZero(pParams2->SetMsiString(File, *strFile));
	AssertNonZero(pParams2->SetMsiString(FileID, *MsiString(riRecord.GetMsiString(irmFileID))));
	ixoEnum ixoOp;
	if(iActionMode == (int)iamReg)
		ixoOp = ixoRegSelfReg;
	else
		ixoOp = ixoRegSelfUnreg;
	
	return riEngine.ExecuteRecord(ixoOp, *pParams2);
}

iesEnum SelfRegModules(IMsiEngine& riEngine)
{
	static const ICHAR* szSelfRegModulesSQL	=	TEXT("Select `FileAction`.`FileName`,`FileAction`.`Directory_`,`FileAction`.`Action`, `FileAction`.`Component_`,`SelfReg`.`File_` From `SelfReg`, `FileAction`")
									TEXT(" Where `SelfReg`.`File_` = `FileAction`.`File` ")
									TEXT(" And (`FileAction`.`Action` = 1 OR `FileAction`.`Action` = 2)");
	enum {
		iamReg,
		iamUnreg,
	};

	return PerformAction(riEngine,szSelfRegModulesSQL, SelfRegOrUnregModulesCore,iamReg, /* ByteEquivalent = */ ibeSelfRegModules, 0, ttblFile);
}


iesEnum SelfUnregModules(IMsiEngine& riEngine)
{
	static const ICHAR* szSelfUnregModulesSQL	=	TEXT("Select `File`.`FileName`,`Component`.`Directory_`,`Component`.`Installed`, `File`.`Component_`,`SelfReg`.`File_`  From `SelfReg`, `File`, `Component`")
										TEXT(" Where `SelfReg`.`File_` = `File`.`File` And `File`.`Component_` = `Component`.`Component`")
										TEXT(" And `Component`.`Action` = 0");

	enum {
		iamReg,
		iamUnreg,
	};

	return PerformAction(riEngine,szSelfUnregModulesSQL, SelfRegOrUnregModulesCore,iamUnreg, /* ByteEquivalent = */ ibeSelfUnregModules);
}


/*----------------------------------------------------------------------------
	BindImage action
----------------------------------------------------------------------------*/
static iesEnum BindImageCore(	IMsiRecord& riRecord,
								IMsiRecord& riPrevRecord,
								IMsiEngine& riEngine,
								int /*fMode*/,
								IMsiServices& riServices,
								IMsiDirectoryManager& riDirectoryMgr, 
								int /*iActionMode*/)
{
	IMsiRecord* piError = 0;
	enum {
		ibiFile=1,
		ibiPath,
		ibiDllPath,
		ibiBinaryType,
		ibiFileAttributes,
		ibiComponent,
	};

	Debug(const ICHAR* szFile = riRecord.GetString(ibiFile));

	if ( g_fWinNT64 && (ibtBinaryType)riRecord.GetInteger(ibiBinaryType) == ibt32bit )
		//  there is no point in binding 32-bit binaries on 64-bit OS-es.
		return iesSuccess;

	// skip the entry if corr. component is a Win32 assembly AND SXS support is present on the machine
	// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
	// Win32 assemblies, hence there is no need to separately check the SXS support here
	iatAssemblyType iatAT;
	RETURN_FATAL_ERROR(riEngine.GetAssemblyInfo(*MsiString(riRecord.GetMsiString(ibiComponent)), iatAT, 0, 0));

	if(iatWin32Assembly == iatAT || iatWin32AssemblyPvt == iatAT)
	{
		DEBUGMSG1(TEXT("skipping bindimage for file %s as it belongs to a Win32 assembly."), riRecord.GetString(ibiFile));
		return iesSuccess;// skip processing this file
	}

	PMsiPath piPath(0);
	using namespace IxoFileBindImage;
	PMsiRecord pParams = &riServices.CreateRecord(Args);
	iesEnum iesRet;
	RETURN_FATAL_ERROR(riDirectoryMgr.GetTargetPath(*MsiString(riRecord.GetMsiString(ibiPath)),*&piPath));
	if(riPrevRecord.GetFieldCount() == 0 ||
		! MsiString(riRecord.GetMsiString(ibiPath)).Compare(iscExact,
				MsiString(riPrevRecord.GetMsiString(ibiPath))))
	{
		AssertNonZero(pParams->SetMsiString(IxoSetTargetFolder::Folder, *MsiString(piPath->GetPath())));
		if((iesRet = riEngine.ExecuteRecord(ixoSetTargetFolder, *pParams)) != iesSuccess)
			return iesRet;
	}
	MsiString strFileName;
	Bool fLFN = ((riEngine.GetMode() & iefSuppressLFN) == 0 && piPath->SupportsLFN()) ? fTrue : fFalse;
	RETURN_FATAL_ERROR(riServices.ExtractFileName(riRecord.GetString(ibiFile),
																 fLFN,*&strFileName));
	MsiString strDllPath = riEngine.FormatText(*MsiString(riRecord.GetMsiString(ibiDllPath)));

	AssertNonZero(pParams->SetMsiString(File, *strFileName));
	AssertNonZero(pParams->SetMsiString(Folders, *strDllPath));
	AssertNonZero(pParams->SetInteger(FileAttributes, riRecord.GetInteger(ibiFileAttributes)));
	
	return riEngine.ExecuteRecord(ixoFileBindImage, *pParams);
}

iesEnum BindImage(IMsiEngine& riEngine)
{
	static const ICHAR* szBindImageSQL	=	TEXT("Select `FileAction`.`FileName`, `Directory_`, `Path`, `BinaryType`, `Attributes`, `FileAction`.`Component_`")
								TEXT(" From `BindImage`, `FileAction`, `File`")
								TEXT(" Where `BindImage`.`File_` = `FileAction`.`File` And `BindImage`.`File_` = `File`.`File`")
								TEXT(" And `FileAction`.`Action` = 1 Order By `Directory_`");

	// allow BindImage table to be missing
	PMsiDatabase piDatabase = riEngine.GetDatabase();
	Assert(piDatabase);
	itsEnum itsTable = piDatabase->FindTable(*MsiString(*TEXT("BindImage")));
	if(itsTable == itsUnknown)
		return iesSuccess;

	return PerformAction(riEngine,szBindImageSQL, BindImageCore, 0, /* ByteEquivalent = */ ibeBindImage, 0, ttblFile);
}
#endif //WIN    


// Fn - to strip the source off for RFS components //!! should use dirmgr function when bench writes it
inline IMsiRecord* GetRelativeSourcePath(IMsiDirectoryManager& riDirectoryMgr, MsiString& rstrPath)
{
	PMsiPath pSourceDir(0);
	RETURN_ERROR_RECORD(GetSourcedir(riDirectoryMgr, *&pSourceDir));
	MsiString strSourceDir;
	RETURN_ERROR_RECORD(pSourceDir->GetFullFilePath(0,*&strSourceDir));
	Assert((strSourceDir.Compare(iscEnd, MsiString(MsiChar(chDirSep))) ||
				strSourceDir.Compare(iscEnd, MsiString(MsiChar(chURLSep)))));
	rstrPath.Remove(iseFirst, strSourceDir.CharacterCount() - 1); // leave the final backslash
	return 0;
}

// Fn - registers a component as installed

//!! the following query has a redundant join to the component table - should remove
static const ICHAR* szKeyRegistrySQL	=   TEXT(" SELECT `Root`,`Key`,`Name`, `Value`")
											TEXT(" FROM `Registry`,`Component`")
											TEXT(" WHERE `Registry`=? AND `Registry`.`Component_` = `Component`.`Component`");
static const ICHAR* szKeyFileDirectorySQL =	TEXT("SELECT `Component`.`Directory_`, `FileName`, `Sequence`")
											TEXT(" From `File`, `Component`")
											TEXT(" Where `File` =? And `File`.`Component_` = `Component`.`Component`");
static const ICHAR* szKeyDataSourceSQL	=   TEXT(" SELECT `Description`, `Registration`")
											TEXT(" FROM `ODBCDataSource`,`Component`")
											TEXT(" WHERE `DataSource`=? AND `ODBCDataSource`.`Component_` = `Component`.`Component`");

static const ICHAR* szMediaFromSequenceSQL = TEXT("SELECT `DiskId`")
												  TEXT(" FROM `Media`")
												  TEXT(" WHERE `LastSequence` >= ?")
												  TEXT(" ORDER BY `LastSequence`");

static const ICHAR* szODBCKey = TEXT("\\Software\\ODBC\\ODBC.INI\\");

static IMsiView* g_pViewRegKey = 0;
static IMsiView* g_pViewKeyFile = 0;
static IMsiView* g_pViewDataSource = 0;
static IMsiView* g_pViewMedia = 0;

const IMsiString& GetRegistryKeyPath(IMsiEngine& riEngine, const IMsiRecord& riRec, Bool fSource, ibtBinaryType iType)
{
	enum {
		irrRoot=1,
		irrKey,
		irrName,
		irrValue
	};

	MsiString strKeyPath;
	int iRoot = riRec.GetInteger(irrRoot);

	if(-1 == iRoot) // HKCU or HKLM based upon ALLUSERS
	{
		bool fAllUsers = MsiString(riEngine.GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? true : false;
		if (fAllUsers)
			iRoot = 2; // HKLM
		else
			iRoot = 1; // HKCU
	}

	MsiString strKey = riEngine.FormatText(*MsiString(riRec.GetMsiString(irrKey)));
	if(!strKey.Compare(iscEnd,szRegSep))
		strKey += szRegSep;
	MsiString strName = riEngine.FormatText(*MsiString(riRec.GetMsiString(irrName)));

	MsiString strValue = riEngine.FormatText(*MsiString(riRec.GetMsiString(irrValue)));
	if((strValue.TextSize() == 0) &&
		(strName.Compare(iscExact, REGKEY_CREATE) || strName.Compare(iscExact, REGKEY_CREATEDELETE) || strName.Compare(iscExact, REGKEY_DELETE)))
	{
		// special key creation/deletion request
		strName = g_MsiStringNull;
	}
	
	if (fSource)
		iRoot += iRegistryHiveSourceOffset;

	if (g_fWinNT64 && ibt32bit != iType)
		iRoot += iRegistryHiveWin64Offset;

	if (iRoot <= 9) // ensure a 2 digit registry hive
		strKeyPath = TEXT("0");
	else
		strKeyPath = g_MsiStringNull;

	strKeyPath += iRoot;


	if (strName.Compare(iscWithin, TEXT("\\")))
	{
		strKeyPath += TEXT("*");
		int cValueNameOffset = strKeyPath.TextSize() + IStrLen(szRegSep) + strKey.CharacterCount();
		strKeyPath += cValueNameOffset;
		strKeyPath += TEXT("*");
	}
	else
	{
		strKeyPath += TEXT(":");
	}

	strKeyPath += szRegSep;
	strKeyPath += strKey;
	strKeyPath += strName;

	return strKeyPath.Return();
}


static iesEnum RegisterComponentsCore(IMsiRecord& riRecord,IMsiRecord& /*riPrevRecord*/,
														IMsiEngine& riEngine,int /*fMode*/,IMsiServices& riServices,
														IMsiDirectoryManager& riDirectoryMgr, int /*iActionMode*/)


{
	using namespace IxoComponentRegister;
	enum {
		ircComponent=1,
		ircComponentId,
		ircRuntimeFlags,
		ircKeyPath,
		ircActionRequested,
		ircAction,
		ircDirectory,
		ircAttributes,
		ircLegacyFileExisted,
		ircBinaryType,
		ircSystemFolder,
		ircSystemFolder64,
	};

	enum{
	irfDirectory=1,
	irfFileName,
	irfSequence,
	irfAttributes,
	};

	ibtBinaryType iType = (ibtBinaryType)riRecord.GetInteger(ircBinaryType);

	int fPermanent = riRecord.GetInteger(ircAttributes) & icaPermanent;
	MsiString strKeyPath;
	int fDisabled  = riRecord.GetInteger(ircRuntimeFlags) & bfComponentDisabled;
	int iActionStateColumn = (riRecord.GetInteger(ircActionRequested) == iMsiNullInteger) ? ircAction : ircActionRequested;
	int iState = fDisabled ? INSTALLSTATE_NOTUSED : (riRecord.GetInteger(iActionStateColumn) == iisSource) ? INSTALLSTATE_SOURCE: INSTALLSTATE_LOCAL;
	Bool fSource = (iState == INSTALLSTATE_SOURCE) ? fTrue : fFalse;
	int iDisk = 1;
	int iSharedDllRefCount = 0;
	int iLegacyFileExisted = 0;
	if(!riRecord.IsNull(ircLegacyFileExisted) && riRecord.GetInteger(ircLegacyFileExisted))
		iLegacyFileExisted = ircenumLegacyFileExisted;

	MsiString strComponentId = riRecord.GetMsiString(ircComponentId);
	if(!fDisabled)
	{
		strKeyPath = riRecord.GetMsiString(ircKeyPath);
		if(strKeyPath.TextSize())
		{
			int fIsRegistryKeyPath   = riRecord.GetInteger(ircAttributes) & icaRegistryKeyPath;
			int fIsDataSourceKeyPath = riRecord.GetInteger(ircAttributes) & icaODBCDataSource;

			// Is component an assembly
			iatAssemblyType iatAT = iatNone;
			MsiString strComponent = riRecord.GetMsiString(ircComponent);
			MsiString strAssemblyName;
			MsiString strManifest;
			RETURN_FATAL_ERROR(riEngine.GetAssemblyInfo(*strComponent, iatAT, &strAssemblyName, &strManifest));

			IMsiView *pView;
			
			if (fIsRegistryKeyPath)
			{
				if (g_pViewRegKey != 0)
					g_pViewRegKey->Close();
				else
				{
					RETURN_FATAL_ERROR(riEngine.OpenView(szKeyRegistrySQL, 
									ivcFetch, g_pViewRegKey));

				}
				pView = g_pViewRegKey;
			}
			else if (fIsDataSourceKeyPath)
			{
				if (g_pViewDataSource != 0)
					g_pViewDataSource->Close();
				else
				{
					RETURN_FATAL_ERROR(riEngine.OpenView(szKeyDataSourceSQL, 
									ivcFetch, g_pViewDataSource));

				}
				pView = g_pViewDataSource;
			}
			else
			{
				if (g_pViewKeyFile != 0)
					g_pViewKeyFile->Close();
				else
				{
					RETURN_FATAL_ERROR(riEngine.OpenView(szKeyFileDirectorySQL, 
										ivcFetch, g_pViewKeyFile));
				}
				pView = g_pViewKeyFile;
			}
			
			PMsiRecord piRec = &riServices.CreateRecord(1);
			piRec->SetMsiString(1, *strKeyPath);
			RETURN_FATAL_ERROR(pView->Execute(piRec));
			piRec = pView->Fetch();
			if(!piRec)
			{
#if DEBUG
				ICHAR szError[256];
				StringCchPrintf(szError, (sizeof(szError)/sizeof(ICHAR)), TEXT("Error registering component %s. Possible cause: Component.KeyPath may not be valid"), (const ICHAR*)strComponentId);
				AssertSz(0, szError);
#endif
				RETURN_FATAL_ERROR(PostError(Imsg(idbgBadFile),(const ICHAR*)strKeyPath));
			}
			if(fIsRegistryKeyPath ) // registry key as key path
			{
				strKeyPath = GetRegistryKeyPath(riEngine, *piRec, fSource, iType);
			}
			else if (fIsDataSourceKeyPath)
			{
				enum {
					irfsDataSource=1,
					irfsRegistration,
				};
				
				MsiString strDataSource = piRec->GetString(irfsDataSource);
				bool fMachine = (piRec->GetInteger(irfsRegistration) == 0) ? true : false;

				if (fMachine)
					strKeyPath = TEXT("02:"); // HKLM
				else
					strKeyPath = TEXT("01:"); // HKCU


				strKeyPath += szODBCKey;
				strKeyPath += strDataSource;
				strKeyPath += szRegSep;
			}
			else if (iatURTAssembly == iatAT || iatWin32Assembly == iatAT)
			{
				// simply mark the key path as a Assembly, with the key file being the manifest
				//!! should check for COM+ drive for support of LFN

				ICHAR chAssemblyToken = (ICHAR)(iatAT == iatURTAssembly ? chTokenFusionComponent : chTokenWin32Component);
				bool fUseDifferentKeyPath = false;
				if(!strKeyPath.Compare(iscExact, strManifest))
					fUseDifferentKeyPath = true; // remember keypath different from manifest

				strKeyPath = MsiString(MsiChar(chAssemblyToken));

				if(fUseDifferentKeyPath == true)
				{
					// add the key file
					MsiString strKeyFile;
					RETURN_FATAL_ERROR(riServices.ExtractFileName(piRec->GetString(irfFileName),
						((riEngine.GetMode() & iefSuppressLFN) == 0) ? fTrue : fFalse,
						*&strKeyFile));
					strKeyPath += strKeyFile;
				}
				//add the strong assembly name for key path
				strKeyPath += MsiString(MsiChar('\\'));
				strKeyPath += strAssemblyName;
			}
			else // file as key path
			{

				PMsiPath piPath(0);
				int iefLFNMode;
				if(fSource)
				{
					PMsiRecord pErrRec = riDirectoryMgr.GetSourcePath(*MsiString(piRec->GetMsiString(irfDirectory)),*&piPath);
					if (pErrRec)
					{
						if (pErrRec->GetInteger(1) == imsgUser)
							return iesUserExit;
						else
							return riEngine.FatalError(*pErrRec);
					}

					iefLFNMode = iefNoSourceLFN;
				}
				else
				{
					RETURN_FATAL_ERROR(riDirectoryMgr.GetTargetPath(*MsiString(piRec->GetMsiString(irfDirectory)),*&piPath));
					iefLFNMode = iefSuppressLFN;
					MsiString strPath = piPath->GetPath();
					iSharedDllRefCount = 0;
					if((riRecord.GetInteger(ircAttributes) & icaSharedDllRefCount) ||
						 strPath.Compare(iscExactI, riRecord.GetString(ircSystemFolder)) ||
						 strPath.Compare(iscExactI, riRecord.GetString(ircSystemFolder64)) )
					{
						iSharedDllRefCount =  ircenumRefCountDll; // force shared dll ref counting -  either authored or we are installing into the system folder
					}
#ifdef _WIN64
					//!!eugend the if below is only a temp. fix till bug # 324211 gets fixed.  Please remove afterwards.
					if ( !iSharedDllRefCount )
					{
						MsiString strSystemFolder = riEngine.GetProperty(*MsiString(*IPROPNAME_SYSTEM64_FOLDER));
						if ( strPath.Compare(iscExactI, strSystemFolder) )
							iSharedDllRefCount =  ircenumRefCountDll; // force shared dll ref counting -  either authored or we are installing into the system folder
					}
#endif
				}
				Bool fLFN = ((riEngine.GetMode() & iefLFNMode) == 0 && piPath->SupportsLFN()) ? fTrue : fFalse;
				MsiString strFileName;
				RETURN_FATAL_ERROR(riServices.ExtractFileName(piRec->GetString(irfFileName),fLFN,*&strFileName));
				RETURN_FATAL_ERROR(piPath->GetFullFilePath(strFileName, *&strKeyPath));

				if(fSource) 
				{
					if (g_pViewMedia != 0)
						g_pViewMedia->Close();
					else
						RETURN_FATAL_ERROR(riEngine.OpenView(szMediaFromSequenceSQL, ivcFetch, g_pViewMedia));
						
					PMsiRecord pMediaRec = &riServices.CreateRecord(1);
					pMediaRec->SetInteger(1, piRec->GetInteger(irfSequence));
					RETURN_FATAL_ERROR(g_pViewMedia->Execute(pMediaRec));
					
					
					pMediaRec = g_pViewMedia->Fetch();
					Assert(pMediaRec);
					iDisk = pMediaRec->GetInteger(1);

					RETURN_FATAL_ERROR(GetRelativeSourcePath(riDirectoryMgr, strKeyPath));
				}
			}
		}
		else // folder as key path
		{
			//?? How do we determine the correct disk id for a directory?

			PMsiPath piPath(0);
			if(fSource)
			{
				PMsiRecord pErrRec = riDirectoryMgr.GetSourcePath(*MsiString(riRecord.GetMsiString(ircDirectory)),*&piPath);
				if (pErrRec)
				{
					if (pErrRec->GetInteger(1) == imsgUser)
						return iesUserExit;
					else
						return riEngine.FatalError(*pErrRec);
				}
			}
			else
			{
				RETURN_FATAL_ERROR(riDirectoryMgr.GetTargetPath(*MsiString(riRecord.GetMsiString(ircDirectory)),*&piPath));
			}
			RETURN_FATAL_ERROR(piPath->GetFullFilePath(MsiString(*TEXT("")),*&strKeyPath));
			if(fSource)
			{
				RETURN_FATAL_ERROR(GetRelativeSourcePath(riDirectoryMgr, strKeyPath));

			}

		}
	}

	PMsiRecord piRecOut = &riServices.CreateRecord(Args);
	piRecOut->SetMsiString(ComponentId, *strComponentId);
	piRecOut->SetMsiString(KeyPath, *strKeyPath);
	piRecOut->SetInteger(State, iState);
	piRecOut->SetInteger(Disk, iDisk);
	piRecOut->SetInteger(SharedDllRefCount, iSharedDllRefCount | iLegacyFileExisted);
	piRecOut->SetInteger(BinaryType, iType);
	iesEnum iesRet = riEngine.ExecuteRecord(ixoComponentRegister, *piRecOut);
	
	if(iesRet != iesSuccess || iState!= INSTALLSTATE_LOCAL || !fPermanent)
		return iesRet;


	// we need to register the system as a client
	piRecOut->SetString(ProductKey, szSystemProductKey);
	return riEngine.ExecuteRecord(ixoComponentRegister, *piRecOut);	
}


// Fn - registers a component as uninstalled
static iesEnum UnregisterComponentsCore(IMsiRecord& riRecord,IMsiRecord& /*riPrevRecord*/,
														  IMsiEngine& riEngine,int /*fMode*/,IMsiServices& riServices,
														  IMsiDirectoryManager& /*riDirectoryMgr*/, int /*iActionMode*/)
{
	using namespace IxoComponentUnregister;
	enum {
		iucComponentId=1,
		iucBinaryType,
		iucAction,
	};

	MsiString strComponentId = riRecord.GetMsiString(iucComponentId);
	PMsiRecord piRecOut = &riServices.CreateRecord(Args);

	piRecOut->SetMsiString(ComponentId, *strComponentId);
	piRecOut->SetInteger(BinaryType, riRecord.GetInteger(iucBinaryType));

	// we set the previously pinned bit for assemblies that we know have other MSI refcounts for the 
	// component id corr. to the assembly
	// this will prevent code in execute.cpp from uninstalling these assemblies.
	// This is required for Windows bug 599621 for details
	if(riRecord.GetInteger(iucAction) == iMsiNullInteger)
		piRecOut->SetInteger(PreviouslyPinned, 1);

	return riEngine.ExecuteRecord(ixoComponentUnregister, *piRecOut);
}


// Fn - manages the refcounts for non-key files for system components
// skip key files,
// skip components set to rfs
static iesEnum ProcessSystemFilesCore(IMsiRecord& riRecord,IMsiRecord& riPrevRecord,
												   IMsiEngine& riEngine,int /*fMode*/,IMsiServices& riServices,
										           IMsiDirectoryManager& riDirectoryMgr, int /*iActionMode*/)
{
	enum {
		irsFile=1,
		irsFileName,
		irsDirectory,
		irsAttributes,
		irsKeyPath,
		irsAction,
		irsBinaryType,
	};


	iesEnum iesRet;
	PMsiRecord pParams = &riServices.CreateRecord(IxoRegOpenKey::Args); 
	static ibtBinaryType iType = ibtUndefined;

	if(riPrevRecord.GetFieldCount() == 0 ||
	   iType != riRecord.GetInteger(irsBinaryType))
	{
		// key not opened previously
		iType = (ibtBinaryType)riRecord.GetInteger(irsBinaryType);
		AssertNonZero(pParams->SetInteger(IxoRegOpenKey::Root, rrkLocalMachine));
		AssertNonZero(pParams->SetString(IxoRegOpenKey::Key, szSharedDlls));
		AssertNonZero(pParams->SetInteger(IxoRegOpenKey::BinaryType, iType));
		if((iesRet = riEngine.ExecuteRecord(ixoRegOpenKey, *pParams)) != iesSuccess)
			return iesRet;
	}

	int fIsRegistryKeyPath = riRecord.GetInteger(irsAttributes) & icaRegistryKeyPath;
	int fODBCDataSource = riRecord.GetInteger(irsAttributes) & icaODBCDataSource;
	if(!fIsRegistryKeyPath && !fODBCDataSource && MsiString(riRecord.GetMsiString(irsFile)).Compare(iscExact, riRecord.GetString(irsKeyPath)))
	{
		// skip the key file, since it will be refcounted by RegisterComponent
		// we need to account for the progress
		//!! we may want to shift entire shared dll registration logic here from the Configuration manager
		//!! as this is very inefficient
		return riEngine.ExecuteRecord(ixoProgressTick, *pParams);
	}

	PMsiPath pPath(0);
	RETURN_FATAL_ERROR(riDirectoryMgr.GetTargetPath(*MsiString(riRecord.GetMsiString(irsDirectory)),*&pPath));
	Bool fLFN = ((riEngine.GetMode() & iefSuppressLFN) == 0 && pPath->SupportsLFN()) ? fTrue : fFalse;
	MsiString strFileName;
	MsiString strFullFilePath;
	RETURN_FATAL_ERROR(riServices.ExtractFileName(riRecord.GetString(irsFileName),fLFN,*&strFileName));
	RETURN_FATAL_ERROR(pPath->GetFullFilePath(strFileName, *&strFullFilePath));
#ifdef _WIN64
	if ( iType == ibt32bit )
	{
		ICHAR szSubstitutePath[MAX_PATH+1];
		ieSwappedFolder iRes;
		iRes = g_Win64DualFolders.SwapFolder(ie32to64,
														 strFullFilePath,
														 szSubstitutePath,
														 ARRAY_ELEMENTS(szSubstitutePath),
														 ieSwapForSharedDll);
#ifdef DEBUG
		MsiString strSystem64Folder = riEngine.GetPropertyFromSz(IPROPNAME_SYSTEM64_FOLDER);
		MsiString strSystemFolder = riEngine.GetPropertyFromSz(IPROPNAME_SYSTEM_FOLDER);
		if ( iRes == iesrSwapped )
		{
			if (!g_Win64DualFolders.ShouldCheckFolders())
			{
				Assert(!IStrNCompI(szSubstitutePath, strSystem64Folder,
						 strSystem64Folder.TextSize()));
				Assert(strFullFilePath.Compare(iscStartI, strSystemFolder));
			}
		}
		else
			Assert(strFullFilePath.Compare(iscStartI, strSystem64Folder));
#endif // DEBUG
		if ( iRes == iesrSwapped )
			strFullFilePath = szSubstitutePath;
		else
			Assert(iRes != iesrError && iRes != iesrNotInitialized);
	}
#endif // _WIN64

	pParams = &riServices.CreateRecord(IxoRegAddValue::Args);

	if(riRecord.GetInteger(irsAction) == iisLocal)
	{
		// we are installing
		// check if the file exists w/o a refcount. If so we need to doubly increment the refcount
		// we are installing
		MsiString strValue;
		RETURN_FATAL_ERROR(GetSharedDLLCount(riServices, strFullFilePath, iType, *&strValue));

		strValue.Remove(iseFirst, 1);
		if(strValue == iMsiStringBadInteger || strValue == 0)
		{
			// may need to doubly refcount
			Bool fExists;
			RETURN_FATAL_ERROR(pPath->FileExists(strFileName, fExists));
			if(fExists)
			{
				// bump up refcount
				AssertNonZero(pParams->SetMsiString(IxoRegAddValue::Name, *strFullFilePath));
				AssertNonZero(pParams->SetString(IxoRegAddValue::Value, szIncrementValue));
				AssertNonZero(pParams->SetInteger(IxoRegAddValue::Attributes, rwNonVital));
				if((iesRet = riEngine.ExecuteRecord(ixoRegAddValue, *pParams)) != iesSuccess)
					return iesRet;
			}
		}
	}

	// need to bump up/down the ref count
	// check the registry for shared dll count
	const ICHAR* pValue = (riRecord.GetInteger(irsAction) == iisLocal) ? szIncrementValue : szDecrementValue;
	AssertNonZero(pParams->SetMsiString(IxoRegAddValue::Name, *strFullFilePath));
	AssertNonZero(pParams->SetString(IxoRegAddValue::Value, pValue));
	AssertNonZero(pParams->SetInteger(IxoRegAddValue::Attributes, rwNonVital));
	return riEngine.ExecuteRecord(ixoRegAddValue, *pParams);
}


/*----------------------------------------------------------------------------
	ProcessComponents action
----------------------------------------------------------------------------*/
iesEnum ProcessComponents(IMsiEngine& riEngine)
{									
	//works on the ActionRequest column rather than the Action column
	static const ICHAR* const szUnregisterComponentSQL =		TEXT(" SELECT  `ComponentId`, `BinaryType`, `Action` ")
											TEXT(" From `Component` WHERE (`Component_Parent` = null OR `Component_Parent` = `Component`)")
											TEXT(" AND `ComponentId` <> null")
											TEXT(" AND (`ActionRequest` = 0)");
	static const ICHAR* const szRegisterComponentSQL =			TEXT(" SELECT  `Component`, `ComponentId`, `RuntimeFlags`, `KeyPath`, `ActionRequest`, `Action`, `Directory_`, `Attributes`, `LegacyFileExisted`, `BinaryType`, ?, ?")
											TEXT(" From `Component` WHERE (`Component_Parent` = null OR `Component_Parent` = `Component`)")
											TEXT(" AND `ComponentId` <> null")
											TEXT(" AND (`ActionRequest` = 1 OR `ActionRequest` = 2 OR (`ActionRequest` = null AND (`Action`= 1 OR `Action`= 2))) ");
	static const ICHAR* const szGetComponentsSQL = TEXT(" SELECT `Component`, `Directory_`, `RuntimeFlags` FROM `Component` WHERE")
											TEXT(" (`Component`.`ActionRequest` = 1 AND (`Component`.`Installed` = 0 OR `Component`.`Installed` = 2)) OR")
											TEXT(" (`Component`.`Installed` = 1 AND (`Component`.`ActionRequest` = 2 OR `Component`.`ActionRequest` = 0))")
											TEXT(" ORDER BY `BinaryType`");
	//  please update iBinaryTypeCol below if you modify szProcessSystemFilesSQL
	static const ICHAR* const szProcessSystemFilesSQL = TEXT(" SELECT `File`.`File`, `File`.`FileName`, `Component`.`Directory_`, `Component`.`Attributes`, `Component`.`KeyPath`, `Component`.`ActionRequest`, `BinaryType`")
												 TEXT(" FROM `File`, `Component`")
												 TEXT(" WHERE `File`.`Component_` = `Component`.`Component` AND ")
												 TEXT(" `Component`.`Component` = ?");
	static const ICHAR* const szUnregisterComponentFirstRunSQL = TEXT(" SELECT  `ComponentId`, `BinaryType`, `Action` ")
											TEXT(" From `Component` WHERE (`Component_Parent` = null OR `Component_Parent` = `Component`)")
											TEXT(" AND `ComponentId` <> null")
											TEXT(" AND `ActionRequest` = null")
											TEXT(" AND `Action`= null");

	const int iBinaryTypeCol = 7;  // the position of `BinaryType` column in szProcessSystemFilesSQL

	iesEnum iesReturn = iesSuccess;

	// if this is first run, then first unregister any possilbe left over registeration for 
	// all components that are not being installed during this installation
	// this prevents any security breach caused by left over registration influencing where
	// future installations point to viz. a viz. component locations.
	if(!(riEngine.GetMode() & iefMaintenance) && FFeaturesInstalled(riEngine)) // first run
	{
		iesReturn = PerformAction(riEngine,szUnregisterComponentFirstRunSQL , UnregisterComponentsCore,0, /* ByteEquivalent = */ ibeUnregisterComponents);
		if(iesReturn != iesSuccess)
			return iesReturn;
	}

	iesReturn = PerformAction(riEngine,szUnregisterComponentSQL, UnregisterComponentsCore,0, /* ByteEquivalent = */ ibeUnregisterComponents);
	if(iesReturn != iesSuccess)
		return iesReturn;
	PMsiServices piServices(riEngine.GetServices());
	PMsiRecord piParam = &piServices->CreateRecord(2);
	MsiString strSystemfolder = riEngine.GetProperty(*MsiString(*IPROPNAME_SYSTEM_FOLDER));
	MsiString strSystemfolder64;
#ifdef _WIN64
	strSystemfolder64 = riEngine.GetProperty(*MsiString(*IPROPNAME_SYSTEM64_FOLDER));
#endif
	piParam->SetMsiString(1, *strSystemfolder);
	piParam->SetMsiString(2, *strSystemfolder64);
	
	Assert(g_pViewRegKey == 0);
	Assert(g_pViewKeyFile == 0);
	Assert(g_pViewMedia == 0);
	Assert(g_pViewDataSource == 0);

	iesReturn = PerformAction(riEngine,szRegisterComponentSQL,RegisterComponentsCore,0, /* ByteEquivalent = */ ibeRegisterComponents, piParam);

	if (g_pViewRegKey != 0)
	{
		g_pViewRegKey->Release();
		g_pViewRegKey = 0;
	}
	if (g_pViewKeyFile != 0)
	{
		g_pViewKeyFile->Release();
		g_pViewKeyFile = 0;
	}
	if (g_pViewMedia != 0)
	{
		g_pViewMedia->Release();
		g_pViewMedia = 0;
	}
	if (g_pViewDataSource != 0)
	{
		g_pViewDataSource->Release();
		g_pViewDataSource = 0;
	}

	if(iesReturn != iesSuccess)
		return iesReturn;

	// go through all the components
	enum {
		gscComponent = 1,
		gscDirectory,
		gscRunTimeFlags,
	};


	PMsiRecord pError(0);
	int fMode = riEngine.GetMode();
	PMsiView pView(0);
	pError = riEngine.OpenView(szGetComponentsSQL, ivcFetch, *&pView);	
	if (pError != 0)
	{
		if(pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesSuccess; // missing table so no data to process
		else
			return riEngine.FatalError(*pError);  // may want to reformat error message
	}
	pError = pView->Execute(0);
	if (pError != 0)
		return riEngine.FatalError(*pError);  // may want to reformat error message
	PMsiRecord pRec(0);
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	Assert(piDirectoryMgr);
	while(pRec = pView->Fetch())
	{
		// skip disabled components
		if(pRec->GetInteger(gscRunTimeFlags) & bfComponentDisabled)
			continue;
		
		PMsiPath pPath(0);
		RETURN_FATAL_ERROR(piDirectoryMgr->GetTargetPath(*MsiString(pRec->GetMsiString(gscDirectory)),*&pPath));
		// dont skip components in the system folder
		if(!MsiString(pPath->GetPath()).Compare(iscExactI, strSystemfolder)
#ifdef _WIN64
			&& !MsiString(pPath->GetPath()).Compare(iscExactI, strSystemfolder64)
#endif
		  )
			continue;

		iesEnum iesReturn = PerformAction(riEngine,szProcessSystemFilesSQL,ProcessSystemFilesCore,0, /* ByteEquivalent = */ ibeWriteRegistryValues, pRec);
		if(iesReturn != iesSuccess)
			return iesReturn;
	}

	return iesSuccess;
}



/*----------------------------------------------------------------------------
	<Start,Stop,Delete>Services action
----------------------------------------------------------------------------*/
static iesEnum ServiceControlCore(	IMsiRecord& riRecord,IMsiRecord& /*riPrevRecord*/,
											IMsiEngine& riEngine, int /*fMode*/, IMsiServices& riServices,
											IMsiDirectoryManager& /*riDirectoryMgr*/, int iActionMode)
{

	enum {
		issName = 1,
		issWait,
		issArguments,
		issEvent,
		issAction,
	};

	using namespace IxoServiceControl;

	int iTableActionMode = iActionMode;
	int iAction = riRecord.GetInteger(issAction);
	int iEvent = riRecord.GetInteger(issEvent);

	if (iisAbsent == iAction)
		iTableActionMode = iTableActionMode << isoUninstallShift;

	// Don't install services to the admin machine.
	if (!(riEngine.GetMode() & iefAdmin) && (iTableActionMode & iEvent))
	{

		PMsiRecord pParams = &riServices.CreateRecord(Args); 

		AssertNonZero(pParams->SetMsiString(MachineName, *MsiString(riEngine.GetPropertyFromSz(TEXT("MachineName")))));
		AssertNonZero(pParams->SetMsiString(Name, *MsiString(riEngine.FormatText(*MsiString(riRecord.GetMsiString(issName))))));
		AssertNonZero(pParams->SetInteger(Action, iActionMode));
		AssertNonZero(pParams->SetInteger(Wait, riRecord.GetInteger(issWait)));

		MsiString strArguments(riEngine.FormatText(*MsiString(riRecord.GetMsiString(issArguments))));
		AssertNonZero(pParams->SetMsiString(StartupArguments, *strArguments));

		return riEngine.ExecuteRecord(ixoServiceControl, *pParams);	
	}
	else 
		return iesSuccess;
		//	return iesNoAction;

}

static iesEnum ServiceActionCore(IMsiEngine& riEngine, isoEnum isoAction)
{
	static const ICHAR* szServiceSQL		=	TEXT("SELECT `Name`,`Wait`,`Arguments`,`Event`, `Action`")
								TEXT(" FROM `ServiceControl`, `Component`")
								TEXT(" WHERE `Component_` = `Component`")
								TEXT(" AND (`Action` = 0 OR `Action` = 1 OR `Action` = 2)");
	
	//!! REVIEW:  services running from source seem like a *bad* idea...  MattWe to RCollie 04/23/98
	return PerformAction(riEngine, szServiceSQL, ServiceControlCore, isoAction, /* ByteEquivalent = */ ibeServiceControl);
}

/*----------------------------------------------------------------------------
	StartServices action
----------------------------------------------------------------------------*/

iesEnum StartServices(IMsiEngine& riEngine)
{
	return ServiceActionCore(riEngine,isoStart);
}

/*----------------------------------------------------------------------------
	StopServices action
----------------------------------------------------------------------------*/

iesEnum StopServices(IMsiEngine& riEngine)
{
	return ServiceActionCore(riEngine, isoStop);
}

/*----------------------------------------------------------------------------
	DeleteServices action
----------------------------------------------------------------------------*/

iesEnum DeleteServices(IMsiEngine& riEngine)
{
	return ServiceActionCore(riEngine, isoDelete);
}

/*----------------------------------------------------------------------------
	ServiceInstall action
----------------------------------------------------------------------------*/
static iesEnum ServiceInstallCore(IMsiRecord& riRecord, IMsiRecord& /*riPrevRecord*/,
											IMsiEngine& riEngine, int /*fMode*/, IMsiServices& riServices,
											IMsiDirectoryManager& riDirectoryMgr,int /*iActionMode*/)
{
	using namespace IxoServiceInstall;

	enum {
		isiName = 1,
		isiDisplayName,
		isiServiceType,
		isiStartType,
		isiErrorControl,
		isiLoadOrderGroup,
		isiDependencies,
		isiStartName,
		isiPassword,
		isiDirectory,
		isiFile,
		isiArguments,
		isiDescription,
	};

	PMsiRecord pParams = &riServices.CreateRecord(Args); 
	MsiString strName = riEngine.FormatText(*MsiString(riRecord.GetMsiString(isiName)));

	AssertNonZero(pParams->SetMsiString(Name, *strName));
	if (riRecord.IsNull(isiDisplayName))
		AssertNonZero(pParams->SetMsiString(DisplayName, *strName));
	else
		AssertNonZero(pParams->SetMsiString(DisplayName, *MsiString(riEngine.FormatText(*MsiString(riRecord.GetMsiString(isiDisplayName))))));


	PMsiPath piPath(0);
	RETURN_FATAL_ERROR(riDirectoryMgr.GetTargetPath(*MsiString(riRecord.GetMsiString(isiDirectory)),*&piPath));
	Bool fLFN = (riEngine.GetMode() & iefSuppressLFN) == 0 && piPath->SupportsLFN() ? fTrue : fFalse;
	MsiString strFile;
	RETURN_FATAL_ERROR(riServices.ExtractFileName(riRecord.GetString(isiFile),fLFN,*&strFile));
	MsiString strFileName;
	RETURN_FATAL_ERROR(piPath->GetFullFilePath(strFile, *&strFileName));

	// oddly enough, the arguments to ServiceMain are placed at the end of the image path.  Go figure.
	MsiString strArguments(riRecord.GetMsiString(isiArguments));
	if (strArguments.TextSize())
	{
		strFileName+=TEXT(" ");
		strArguments = riEngine.FormatText(*strArguments);
		strFileName += strArguments;
	}
	AssertNonZero(pParams->SetMsiString(ImagePath, *strFileName));

	AssertNonZero(pParams->SetInteger(ServiceType, riRecord.GetInteger(isiServiceType)));
	AssertNonZero(pParams->SetInteger(StartType, riRecord.GetInteger(isiStartType)));

	DWORD dwErrorControl = riRecord.GetInteger(isiErrorControl);

	AssertNonZero(pParams->SetInteger(ErrorControl, riRecord.GetInteger(isiErrorControl)));
	AssertNonZero(pParams->SetMsiString(LoadOrderGroup, *MsiString(riEngine.FormatText(*MsiString(riRecord.GetMsiString(isiLoadOrderGroup))))));
	AssertNonZero(pParams->SetMsiString(Dependencies, *MsiString(riEngine.FormatText(*MsiString(riRecord.GetMsiString(isiDependencies))))));

	AssertNonZero(pParams->SetMsiString(StartName, *MsiString(riEngine.FormatText(*MsiString(riRecord.GetMsiString(isiStartName))))));
	AssertNonZero(pParams->SetMsiString(Password, *MsiString(riEngine.FormatText(*MsiString(riRecord.GetMsiString(isiPassword))))));
	AssertNonZero(pParams->SetMsiString(Description, *MsiString(riEngine.FormatText(*MsiString(riRecord.GetMsiString(isiDescription))))));

	return riEngine.ExecuteRecord(ixoServiceInstall, *pParams);	
}
/*----------------------------------------------------------------------------
	InstallServices action
----------------------------------------------------------------------------*/

iesEnum ServiceInstall(IMsiEngine& riEngine)
{
	static const ICHAR* szServiceSQLOld = TEXT("SELECT `Name`,`DisplayName`,`ServiceType`,`StartType`,")
							TEXT("`ErrorControl`,`LoadOrderGroup`,`Dependencies`,`StartName`,`Password`,`Directory_`,`FileName`,`Arguments`")
							TEXT(" FROM `ServiceInstall`, `Component`, `File`")
							TEXT(" WHERE `ServiceInstall`.`Component_` = `Component`.`Component`")
							TEXT(" AND (`Component`.`KeyPath` = `File`.`File`)")
							TEXT(" AND (`Action` = 1 OR `Action` = 2)");

	static const ICHAR* szServiceSQL = TEXT("SELECT `Name`,`DisplayName`,`ServiceType`,`StartType`,")
							TEXT("`ErrorControl`,`LoadOrderGroup`,`Dependencies`,`StartName`,`Password`,`Directory_`,`FileName`,`Arguments`,`Description`")
							TEXT(" FROM `ServiceInstall`, `Component`, `File`")
							TEXT(" WHERE `ServiceInstall`.`Component_` = `Component`.`Component`")
							TEXT(" AND (`Component`.`KeyPath` = `File`.`File`)")
							TEXT(" AND (`Action` = 1 OR `Action` = 2)");

	const ICHAR* sql = szServiceSQL;

	// check if the `Description` column exists for the `ServiceInstall` table
	static const ICHAR* szAttributesSQL = TEXT("SELECT `Name` FROM `_Columns` WHERE `Table` = 'ServiceInstall' AND `Name` = 'Description'");
	PMsiView pView(0);
	PMsiRecord pError = riEngine.OpenView(szAttributesSQL, ivcFetch, *&pView);
	if (pError || ((pError = pView->Execute(0)) != 0))
		return riEngine.FatalError(*pError);

	if(!PMsiRecord(pView->Fetch())) // the `Description` column does not exist
	{
		// matches old schema
		DEBUGMSG(TEXT("Detected older ServiceInstall table schema"));
		sql = szServiceSQLOld;
	}

	return PerformAction(riEngine, sql, ServiceInstallCore, 0, ibeServiceControl);
}

/*----------------------------------------------------------------------------
	SetODBCFolders action, queries ODBC to determine existing directories
----------------------------------------------------------------------------*/

typedef BOOL (*T_SQLInstallDriverOrTranslator)(int cDrvLen, LPCTSTR szDriver, LPCTSTR szPathIn, LPTSTR szPathOut, WORD cbPathOutMax, WORD* pcbPathOut, WORD fRequest, DWORD* pdwUsageCount, ibtBinaryType);

BOOL LocalSQLInstallDriverEx(int cDrvLen, LPCTSTR szDriver, LPCTSTR szPathIn, LPTSTR szPathOut,
									  WORD cbPathOutMax, WORD* pcbPathOut, WORD fRequest,
									  DWORD* pdwUsageCount, ibtBinaryType iType);

BOOL LocalSQLInstallTranslatorEx(int cTranLen, LPCTSTR szTranslator, LPCTSTR szPathIn, LPTSTR szPathOut,
											WORD cbPathOutMax, WORD* pcbPathOut, WORD fRequest,
											DWORD* pdwUsageCount, ibtBinaryType iType);

short LocalSQLInstallerError(WORD iError, DWORD* pfErrorCode, LPTSTR szErrorMsg, WORD cbErrorMsgMax,
									  WORD* pcbErrorMsg, ibtBinaryType iType);

#define ODBC_INSTALL_INQUIRY     1
#define SQL_MAX_MESSAGE_LENGTH 512

// ODBC 3.0 wants byte counts for buffer sizes, ODBC 3.5 and newer wants character counts
//   so we double the sizes of the buffers and pass the character count, 3.0 will use 1/2 the buffer on Unicode
#ifdef UNICODE
#define SQL_FIX 2
#else
#define SQL_FIX 1
#endif

static const ICHAR sqlQueryODBCDriver[] =
TEXT("SELECT `ComponentId`,`Description`,`Directory_`, `ActionRequest`, `Installed`, `Attributes`")
TEXT(" FROM `ODBCDriver`, `Component`")
TEXT(" WHERE `ODBCDriver`.`Component_` = `Component`")
TEXT(" AND (`ActionRequest` = 1 OR `ActionRequest` = 2)");
enum ioqEnum {ioqComponent=1, ioqDescription, ioqDirectory, ioqActionRequest, ioqInstalled, ioqAttributes};

static const ICHAR sqlQueryODBCTranslator[] =
TEXT("SELECT `ComponentId`,`Description`,`Directory_`, `ActionRequest`, `Installed`, `Attributes`")
TEXT(" FROM `ODBCTranslator`, `Component`")
TEXT(" WHERE `ODBCTranslator`.`Component_` = `Component`")
TEXT(" AND (`ActionRequest` = 1 OR `ActionRequest` = 2)");

static const ICHAR szODBCFolderTemplate[] = TEXT("ODBC driver [1] forcing folder [2] to [3]");  // can be replaced by ActionText table entry

iesEnum DoODBCFolders(IMsiEngine& riEngine, const ICHAR* szQuery, const ICHAR* szKeyword, T_SQLInstallDriverOrTranslator fpInstall, const IMsiString*& rpiReinstall)
{
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiView pTableView(0);
	PMsiRecord precFetch(0);
	PMsiRecord precError = riEngine.OpenView(szQuery, ivcFetch, *&pTableView);
	if (precError == 0)
		precError = pTableView->Execute(0);
	if (precError)
	{
		if (precError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction;
		return riEngine.FatalError(*precError);
	}
	PMsiRecord pLogRecord = &ENG::CreateRecord(3);
	MsiString istrReinstall;
	while ((precFetch = pTableView->Fetch()) != 0)
	{
		MsiString istrDriver(precFetch->GetMsiString(ioqDescription));
		MsiString istrFolder(precFetch->GetMsiString(ioqDirectory));
		ibtBinaryType iType = 
			(precFetch->GetInteger(ioqAttributes) & msidbComponentAttributes64bit) == msidbComponentAttributes64bit ? ibt64bit : ibt32bit;
		ICHAR rgchDriver[128];
		// As the length passed in *fpinstall call will be the entire buffer
		// zero the buffer, to help marshaller
		ZeroMemory(rgchDriver, sizeof(rgchDriver));
		StringCchPrintf(rgchDriver, (sizeof(rgchDriver)/sizeof(ICHAR)), TEXT("%s%c%s=dummy.dll%c"), (const ICHAR*)istrDriver, 0, szKeyword, 0);  // double null at end
		DWORD dwOldUsage = 0;
		CTempBuffer<ICHAR,1> rgchPathOut(MAX_PATH * SQL_FIX);  // we should have checked this already and set directory
		WORD cbPath = 0;
		BOOL fStat = (*fpInstall)((sizeof(rgchDriver)/sizeof(ICHAR)), rgchDriver, 0, rgchPathOut, static_cast<WORD>(rgchPathOut.GetSize()), &cbPath, ODBC_INSTALL_INQUIRY, &dwOldUsage, iType);
		if ( g_fWinNT64 )
			DEBUGMSG5(TEXT("For %s-bit '%s' the ODBC API returned %d.  rgchPathOut = '%s', dwOldUsage = %d"),
						 iType == ibt64bit ? TEXT("64") : TEXT("32"),
						 istrDriver, (const ICHAR*)(INT_PTR)fStat, rgchPathOut,
						 (const ICHAR*)(INT_PTR)dwOldUsage);
		if (fStat == TYPE_E_DLLFUNCTIONNOTFOUND)
			return iesSuccess;
		else if (fStat == ERROR_INSTALL_SERVICE_FAILURE)
			return iesFailure;
		if (fStat == FALSE)  // should not fail, even if driver not present - we should determine what can cause failure
		{
			DWORD iErrorCode = 0;
			CTempBuffer<ICHAR,1> rgchMessage(SQL_MAX_MESSAGE_LENGTH * SQL_FIX);
			rgchMessage[0] = 0;
			WORD cbMessage;
			PMsiRecord pError = &ENG::CreateRecord(4);
			int iStat = LocalSQLInstallerError(1, &iErrorCode, rgchMessage, static_cast<WORD>(rgchMessage.GetSize()-SQL_FIX), &cbMessage, iType);
			ISetErrorCode(pError, Imsg(imsgODBCInstallDriver));
			pError->SetInteger(2, iErrorCode);
			pError->SetString(3, rgchMessage);
			pError->SetMsiString(4, *istrDriver);
			return riEngine.FatalError(*pError);
		}

		if (rpiReinstall && precFetch->GetInteger(ioqActionRequest) == precFetch->GetInteger(ioqInstalled))  // reinstall, can't bump ref count
			rpiReinstall->AppendMsiString(*MsiString(precFetch->GetMsiString(ioqComponent)), rpiReinstall);
		if (dwOldUsage > 0)  // existing driver, must reconfigure directory to force new to same
		{
			MsiString istrPath(static_cast<ICHAR*>(rgchPathOut));
			pLogRecord->SetMsiString(1, *istrDriver);
			pLogRecord->SetMsiString(2, *istrFolder);
			pLogRecord->SetMsiString(3, *istrPath);
			pLogRecord->SetString(0, szODBCFolderTemplate);
			if (riEngine.Message(imtActionData, *pLogRecord) == imsCancel)
				return iesUserExit;  

			PMsiRecord pError = pDirectoryMgr->SetTargetPath(*istrFolder, rgchPathOut, fFalse);
			if (pError)
			{
				if (pError->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return riEngine.FatalError(*pError);
			}
			riEngine.SetProperty(*istrFolder, *istrPath);
			DEBUGMSG2(TEXT("%s folder has been set to '%s'"), istrFolder, istrPath);
		}
		else
			DEBUGMSG1(TEXT("%s folder has not been set."), istrFolder);
	}
	return iesSuccess;
}


iesEnum SetODBCFolders(IMsiEngine& riEngine)
{
	const IMsiString* piReinstall = (MsiString(riEngine.GetPropertyFromSz(IPROPNAME_AFTERREBOOT)).TextSize()) ? 0 : &g_MsiStringNull;
	iesEnum iesStat = DoODBCFolders(riEngine, sqlQueryODBCDriver, TEXT("Driver"), LocalSQLInstallDriverEx, piReinstall);
	if (iesStat == iesSuccess || iesStat == iesNoAction)
		iesEnum iesStat = DoODBCFolders(riEngine, sqlQueryODBCTranslator, TEXT("Translator"), LocalSQLInstallTranslatorEx, piReinstall);
	if (piReinstall)
	{
		riEngine.SetProperty(*MsiString(*IPROPNAME_ODBCREINSTALL), *piReinstall);
		piReinstall->Release();
	}
	return iesStat;
}

/*----------------------------------------------------------------------------
	Common ODBC action data and helper functions
----------------------------------------------------------------------------*/

#define ODBC_ADD_DSN              1
#define ODBC_REMOVE_DSN           3
#define ODBC_ADD_SYS_DSN          4
#define ODBC_REMOVE_SYS_DSN       6

// ODBC table queries - NOTE: all queries must match in the first three columns: primary key, Component_, Description
static const ICHAR sqlInstallODBCDriver[] =
TEXT("SELECT `Driver`,`ComponentId`,`Description`,`RuntimeFlags`,`Directory_`,`FileName`,`File_Setup`,`Action` FROM `ODBCDriver`, `File`, `Component`")
TEXT(" WHERE `File_` = `File` AND `ODBCDriver`.`Component_` = `Component`")
TEXT(" AND (`Component`.`ActionRequest` = 1 OR `Component`.`ActionRequest` = 2)")
TEXT(" AND `BinaryType` = ?");
static const ICHAR sqlRemoveODBCDriver[] =
TEXT("SELECT `Driver`,`ComponentId`,`Description`, `RuntimeFlags`, `Component`.`Attributes` FROM `ODBCDriver`, `Component`")
TEXT(" WHERE `Component_` = `Component` AND `Component`.`ActionRequest` = 0")
TEXT(" AND `BinaryType` = ?");
enum iodEnum {iodDriver=1, iodComponent, iodDescription, iodRuntimeFlags, iodDirectory, iodFile, iodSetup, iodAction, rodAttributes=iodDirectory};

static const ICHAR sqlInstallODBCTranslator[] =
TEXT("SELECT `Translator`,`ComponentId`,`Description`,`RuntimeFlags`,`Directory_`,`FileName`,`File_Setup`,`Action` FROM `ODBCTranslator`, `File`, `Component`")
TEXT(" WHERE `File_` = `File` AND `ODBCTranslator`.`Component_` = `Component`")
TEXT(" AND (`Component`.`ActionRequest` = 1 OR `Component`.`ActionRequest` = 2)")
TEXT(" AND `BinaryType` = ?");
static const ICHAR sqlRemoveODBCTranslator[] =
TEXT("SELECT `Translator`,`ComponentId`,`Description`, `RuntimeFlags`, `Component`.`Attributes` FROM `ODBCTranslator`, `Component`")
TEXT(" WHERE `Component_` = `Component` AND `Component`.`ActionRequest` = 0")
TEXT(" AND `BinaryType` = ?");
enum iotEnum {iotTranslator=1, iotComponent, iotDescription, iotRuntimeFlags, iotDirectory, iotFile, iotSetup, iotAction, rotAttributes=iotDirectory};

static const ICHAR sqlODBCSetupDll[] =
TEXT("SELECT `FileName` FROM `File` WHERE `File` = ?");

static const ICHAR sqlInstallODBCDataSource[] =
TEXT("SELECT `DataSource`,`ComponentId`,`DriverDescription`,`Description`,`Registration` FROM `ODBCDataSource`, `Component`")
TEXT(" WHERE `Component_` = `Component` AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2)")
TEXT(" AND `BinaryType` = ?");
static const ICHAR sqlRemoveODBCDataSource[] =
TEXT("SELECT `DataSource`,`ComponentId`,`DriverDescription`,`Description`,`Registration` FROM `ODBCDataSource`, `Component`")
TEXT(" WHERE `Component_` = `Component` AND `Component`.`Action` = 0")
TEXT(" AND `BinaryType` = ?");
enum iosEnum {iosDataSource=1, iosComponent, iosDriverDescription, iosDescription, iosRegistration};

static const ICHAR sqlODBCDriverAttributes[] =
TEXT("SELECT `Attribute`,`Value` FROM `ODBCAttribute` WHERE `Driver_` = ?");
static const ICHAR sqlODBCDataSourceAttributes[] =
TEXT("SELECT `Attribute`,`Value` FROM `ODBCSourceAttribute` WHERE `DataSource_` = ?");
enum ioaEnum {ioaAttribute=1, ioaValue};


static iesEnum DoODBCDriverManager(IMsiEngine& riEngine, iesEnum iesStat, Bool fInstall)
{
	if (iesStat != iesNoAction && iesStat != iesSuccess)
		return iesStat;

	static struct
	{
		const ICHAR*          szComponent;
		ibtBinaryType         ibtType;
	} rgstDriverManagers[] = {TEXT("ODBCDriverManager"), ibt32bit,
									  TEXT("ODBCDriverManager64"), ibt64bit};

	PMsiRecord precError(0);
	PMsiSelectionManager pSelectionMgr(riEngine, IID_IMsiSelectionManager);
	for (int i=0; i < sizeof(rgstDriverManagers)/sizeof(rgstDriverManagers[0]); i++)
	{
		MsiString istrDriverManagerComponent(*rgstDriverManagers[i].szComponent);
		iisEnum iisDriverManagerInstalled;
		iisEnum iisDriverManagerAction = (iisEnum)iMsiNullInteger;
		int cbComponent = 0;
		do
		{
			precError = pSelectionMgr->GetComponentStates(*istrDriverManagerComponent, &iisDriverManagerInstalled, &iisDriverManagerAction);
			if (precError && cbComponent == 0)
			{
			// if no driver manager component of that name, try for property of that name (indirection)
				istrDriverManagerComponent = riEngine.GetProperty(*istrDriverManagerComponent);
				cbComponent = istrDriverManagerComponent.TextSize();
			}
			else
				cbComponent = 0;
		} while (cbComponent);
		PMsiRecord precDriverManager(0);
		if ((fInstall && (iisDriverManagerAction == iisLocal || iisDriverManagerAction == iisSource))
		|| !fInstall)  // always generate opcode on RemoveODBC to force DLL unbind
		{
			using namespace IxoODBCDriverManager;

			precDriverManager = &ENG::CreateRecord(Args);
			if (fInstall || iisDriverManagerAction == iisAbsent) // null ODBC action if not uninstall
				precDriverManager->SetInteger(State, fInstall);
			precDriverManager->SetInteger(BinaryType, rgstDriverManagers[i].ibtType);
			if ((iesStat = riEngine.ExecuteRecord(ixoODBCDriverManager, *precDriverManager)) != iesSuccess)
				return iesStat;
			iesStat = iesSuccess;
		}
	}
	return iesStat;
}

static iesEnum DoODBCTable(IMsiEngine& riEngine, iesEnum iesStat, const ICHAR* szTableQuery, const ICHAR* szAttrQuery,
									ixoEnum ixoOp, int cOpArgs, ibtBinaryType iType)
{
	if (iesStat != iesNoAction && iesStat != iesSuccess)
		return iesStat;
	int fMode = riEngine.GetMode();
	PMsiView pTableView(0);
	PMsiRecord precFetch(0);
	PMsiRecord precError = riEngine.OpenView(szTableQuery, ivcFetch, *&pTableView);
	if (precError == 0)
	{
		PMsiRecord precArg = &ENG::CreateRecord(1);
		precArg->SetInteger(1, (int)iType);
		precError = pTableView->Execute(precArg);
	}
	if (precError)
	{
		if (precError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction;
		return riEngine.FatalError(*precError);
	}
	// check if we have attributes
	PMsiView pAttrView(0);
	MsiString istrODBCReinstall = riEngine.GetPropertyFromSz(IPROPNAME_ODBCREINSTALL);
	if (szAttrQuery)
	{
		precError = riEngine.OpenView(szAttrQuery, ivcFetch, *&pAttrView);
		if (precError && precError->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*precError);
	}
	// fetch each component to be installed
	while ((precFetch = pTableView->Fetch()) != 0)
	{
		int cTotalArgs = cOpArgs;
		PMsiRecord precAttr(0);
		if (pAttrView)
		{
			// count attributes and get total string length
			precError = pAttrView->Execute(precFetch);
			if (precError)
				return riEngine.FatalError(*precError);
			while ((precAttr = pAttrView->Fetch()) != 0)
				cTotalArgs += 2;
			AssertRecord(pAttrView->Close());
		}
		if ((ixoOp == ixoODBCInstallDriver || ixoOp == ixoODBCInstallTranslator ||
			  ixoOp == ixoODBCInstallDriver64 || ixoOp == ixoODBCInstallTranslator64) && 
			 !precFetch->IsNull(iodSetup))
			cTotalArgs += 2;
		PMsiRecord precOp = &ENG::CreateRecord(cTotalArgs);
		precOp->SetMsiString(IxoODBCInstallDriver::DriverKey, *MsiString(precFetch->GetMsiString(iodDescription)));
		int iField = cOpArgs;  // count passed as argument does not include attributes or setup
		if (ixoOp == ixoODBCDataSource || ixoOp == ixoODBCDataSource64)
		{
			int fUserReg = precFetch->GetInteger(iosRegistration) & 1;  // 1 = user, 0 = machine
			int iRegistration;
			if (szAttrQuery) // add data source
			{
				if (!((fMode & iefInstallMachineData) && !fUserReg) && !((fMode & iefInstallUserData) && fUserReg))
					continue;
				iRegistration = fUserReg ? ODBC_ADD_DSN : ODBC_ADD_SYS_DSN;
			}
			else
				iRegistration = fUserReg ? ODBC_REMOVE_DSN : ODBC_REMOVE_SYS_DSN;
			precOp->SetInteger(IxoODBCDataSource::Registration, iRegistration);
			if (!precFetch->IsNull(iosDescription))
			{
				precOp->SetString(IxoODBCDataSource::Attribute_, TEXT("DSN"));
				precOp->SetMsiString(IxoODBCDataSource::Value_, *MsiString(precFetch->GetMsiString(iosDescription)));
			}
			else
				iField -= 2;  // only happens when no DSN name
		}
		else if (ixoOp == ixoODBCInstallDriver || ixoOp == ixoODBCInstallTranslator ||
					ixoOp == ixoODBCInstallDriver64 || ixoOp == ixoODBCInstallTranslator64)
		{
			if (precFetch->GetInteger(iodRuntimeFlags) & bfComponentDisabled)
				continue;
			precOp->SetMsiString(IxoODBCInstallDriver::Folder, *MsiString(riEngine.GetProperty(*MsiString(precFetch->GetMsiString(iodDirectory)))));
			precOp->SetString(IxoODBCInstallDriver::Attribute_, ixoOp == ixoODBCInstallTranslator ? TEXT("Translator") : TEXT("Driver"));
			precOp->SetMsiString(IxoODBCInstallDriver::Value_, *MsiString(precFetch->GetMsiString(iodFile)));
			MsiString istrComponent = precFetch->GetMsiString(iodComponent);
			if (istrODBCReinstall.Compare(iscWithin, istrComponent) == 0)  // only can bump ODBC ref count if not reinstall
				precOp->SetMsiString(IxoODBCInstallDriver::Component, *istrComponent);  // if new component client, bump ref count
			if (precFetch->IsNull(iotAction))  // component not to be installed, must be existing higher version key file
				pAttrView = 0;   // don't add old attributes to newer driver
			if (!precFetch->IsNull(iodSetup))
			{
				MsiString istrSetup = precFetch->GetMsiString(iodSetup);
				PMsiRecord precSetup = &ENG::CreateRecord(1);
				precSetup->SetMsiString(1, *istrSetup);
				PMsiView pSetupView(0);
				if ((precError = riEngine.OpenView(sqlODBCSetupDll, ivcFetch, *&pSetupView)) != 0
				 || (precError = pSetupView->Execute(precSetup)) != 0)
					return riEngine.FatalError(*precError);
				if ((precSetup = pSetupView->Fetch()) == 0)
					RETURN_FATAL_ERROR(PostError(Imsg(idbgBadFile),(const ICHAR*)istrSetup));
				precOp->SetString(IxoODBCInstallDriver::Attribute_+2, TEXT("Setup"));
				precOp->SetMsiString(IxoODBCInstallDriver::Value_+2, *MsiString(precSetup->GetMsiString(1)));
				iField += 2;
			}
		}
		else if ((ixoOp == ixoODBCRemoveDriver || ixoOp == ixoODBCRemoveTranslator ||
					 ixoOp == ixoODBCRemoveDriver64 || ixoOp == ixoODBCRemoveTranslator64)
			  && ((precFetch->GetInteger(rodAttributes) & msidbComponentAttributesPermanent)
			   || (precFetch->GetInteger(iodRuntimeFlags) & bfComponentDisabled)))
			continue;  // don't unregister permanent components, orphaned refcount will prevent future unregistration
		if (pAttrView)
		{
			AssertRecord(pAttrView->Execute(precFetch));
			while ((precAttr = pAttrView->Fetch()) != 0)
			{
				precOp->SetMsiString(++iField, *MsiString(precAttr->GetMsiString(ioaAttribute)));
				precOp->SetMsiString(++iField, *MsiString(riEngine.FormatText(*MsiString(precAttr->GetMsiString(ioaValue)))));
			}
		}
		if ((iesStat = riEngine.ExecuteRecord(ixoOp, *precOp)) != iesSuccess)
			break;
	}  // end while Fetch
	return iesStat;
}

/*----------------------------------------------------------------------------
	InstallODBC action, installs manager, drivers, translators, data sources
---------------------------------------------------------------------------*/
iesEnum InstallODBC(IMsiEngine& riEngine)
{
	// assumptions made when using common code - generates only a single, constant test
	Assert(iodDriver == iotTranslator && iodDriver == iosDataSource
		 && iodComponent == iotComponent && iodComponent == iosComponent
		 && iodDescription == iotDescription && iodDescription == iosDriverDescription
		 && IxoODBCInstallDriver::DriverKey     == IxoODBCRemoveDriver::DriverKey
		 && IxoODBCInstallDriver::DriverKey     == IxoODBCDataSource::DriverKey
		 && IxoODBCInstallDriver::DriverKey     == IxoODBCInstallTranslator::TranslatorKey
		 && IxoODBCInstallDriver::DriverKey     == IxoODBCRemoveTranslator::TranslatorKey
		 && IxoODBCInstallDriver::Component     == IxoODBCRemoveDriver::Component
		 && IxoODBCInstallDriver::Component     == IxoODBCDataSource::Component
		 && IxoODBCInstallDriver::Component     == IxoODBCInstallTranslator::Component
		 && IxoODBCInstallDriver::Component     == IxoODBCRemoveTranslator::Component);

	int fMode = riEngine.GetMode();
	iesEnum iesStat = iesNoAction;
	if (fMode & iefInstallMachineData)
	{
		iesStat = DoODBCDriverManager(riEngine, iesNoAction, fTrue);
		iesStat = DoODBCTable(riEngine, iesStat, sqlInstallODBCDriver, sqlODBCDriverAttributes,
								 ixoODBCInstallDriver, IxoODBCInstallDriver::Args, ibt32bit); // driver, not setup
		iesStat = DoODBCTable(riEngine, iesStat, sqlInstallODBCDriver, sqlODBCDriverAttributes,
								 ixoODBCInstallDriver64, IxoODBCInstallDriver64::Args, ibt64bit); // driver, not setup
		iesStat = DoODBCTable(riEngine, iesStat, sqlInstallODBCTranslator, 0,
								 ixoODBCInstallTranslator, IxoODBCInstallTranslator::Args, ibt32bit); // driver, not setup
		iesStat = DoODBCTable(riEngine, iesStat, sqlInstallODBCTranslator, 0,
								 ixoODBCInstallTranslator64, IxoODBCInstallTranslator64::Args, ibt64bit); // driver, not setup
	}
	iesStat = DoODBCTable(riEngine, iesStat, sqlInstallODBCDataSource, sqlODBCDataSourceAttributes,
								 ixoODBCDataSource, IxoODBCDataSource::Args, ibt32bit); // 1st attr is DSN
	return DoODBCTable(riEngine, iesStat, sqlInstallODBCDataSource, sqlODBCDataSourceAttributes,
								 ixoODBCDataSource64, IxoODBCDataSource64::Args, ibt64bit); // 1st attr is DSN
}

/*----------------------------------------------------------------------------
	RemoveODBC action, removes data sources, then drivers, then manager
----------------------------------------------------------------------------*/

iesEnum RemoveODBC(IMsiEngine& riEngine)
{
	iesEnum iesStat = DoODBCTable(riEngine, iesNoAction, sqlRemoveODBCDataSource, 0,
								 ixoODBCDataSource, IxoODBCDataSource::Args, ibt32bit);  // 1st attr is DSN
	iesStat = DoODBCTable(riEngine, iesNoAction, sqlRemoveODBCDataSource, 0,
								 ixoODBCDataSource64, IxoODBCDataSource64::Args, ibt64bit);  // 1st attr is DSN
	iesStat = DoODBCTable(riEngine, iesStat, sqlRemoveODBCTranslator, 0,
								 ixoODBCRemoveTranslator, IxoODBCRemoveTranslator::Args, ibt32bit);
	iesStat = DoODBCTable(riEngine, iesStat, sqlRemoveODBCTranslator, 0,
								 ixoODBCRemoveTranslator64, IxoODBCRemoveTranslator64::Args, ibt64bit);
	iesStat = DoODBCTable(riEngine, iesStat, sqlRemoveODBCDriver, 0,
								 ixoODBCRemoveDriver, IxoODBCRemoveDriver::Args, ibt32bit);
	iesStat = DoODBCTable(riEngine, iesStat, sqlRemoveODBCDriver, 0,
								 ixoODBCRemoveDriver64, IxoODBCRemoveDriver64::Args, ibt64bit);
	return DoODBCDriverManager(riEngine, iesStat, fFalse);
}




/*----------------------------------------------------------------------------
	UpdateEnvironment action
----------------------------------------------------------------------------*/
static iesEnum UpdateEnvironmentStringsCore(	IMsiRecord& riRecord,
								IMsiRecord& /*riPrevRecord*/,
								IMsiEngine& riEngine,
								int /*fMode*/,
								IMsiServices& riServices,
								IMsiDirectoryManager& /*riDirectoryMgr*/, 
								int iActionMode)
{
	using namespace IxoUpdateEnvironmentStrings;


	struct _ActionTranslation{
		ICHAR chAction;
		iueEnum eInstall;
		iueEnum eRemove;
		Bool fAction;
	} ActionTranslation[] =
		{ 
			//           Install  Uninstall  Action (true = action, false = modifier)
			// Default.  The name is non-nullable, so the first should never match.
			{TEXT('\0'), iueSet, iueRemove, fTrue},
			// possible settings
			{TEXT('='), iueSet, iueNoAction, fTrue},
			{TEXT('+'), iueSetIfAbsent, iueNoAction, fTrue},
			{TEXT('-'), iueNoAction, iueRemove, fTrue},
			{TEXT('!'), iueRemove, iueNoAction, fTrue},
			{TEXT('*'), iueMachine, iueMachine, fFalse},
			/* Obsolete modes.
			Use: =- 
			{TEXT('%'), iueSet, iueRemove},

			Use: +-
			{TEXT('*'), iueSetIfAbsent, iueRemove},
			*/
		};

	MsiString strName(riRecord.GetMsiString(1));
	MsiString strValue(riEngine.FormatText(*MsiString(riRecord.GetMsiString(2))));
	iueEnum iueAction = iueNoAction;
	ICHAR chDelimiter = TEXT('\0');
	Bool fActionSet = fFalse;


	// skip the default translation
	for (int cAction = 1; cAction < sizeof(ActionTranslation)/sizeof(struct _ActionTranslation); cAction++)
	{
		if (ActionTranslation[cAction].chAction == *(const ICHAR*)strName)
		{
			if (iActionMode)
				iueAction = iueEnum(iueAction | ActionTranslation[cAction].eInstall);
			else
				iueAction = iueEnum(iueAction | ActionTranslation[cAction].eRemove);
			
			// modifiers aren't considered an action.
			if (!fActionSet) 
				fActionSet = ActionTranslation[cAction].fAction;

			strName.Remove(iseFirst, 1);
			cAction = 0;
			continue;
		}
	}
	if (!fActionSet && !(iueAction & iueActionModes))
	{
		iueAction = iueEnum(iueAction | ((iActionMode) ? ActionTranslation[0].eInstall : ActionTranslation[0].eRemove));
		fActionSet = ActionTranslation[0].fAction;
	}	

	if (!(iueActionModes & iueAction))
		return iesSuccess;

	if (1 < strValue.TextSize())
	{
		if (TEXT('\0') == *((const ICHAR*) strValue))
			iueAction = iueEnum(iueAction | iueAppend);
		if (TEXT('\0') == ((const ICHAR*) strValue)[strValue.TextSize()-1])
			iueAction = iueEnum(iueAction | iuePrepend);

		if ((iuePrepend & iueAction) && (iueAppend & iueAction))
		{
			AssertSz(0, "Prepend and Append specified for environment value.");
			iueAction = iueEnum(iueAction - iuePrepend - iueAppend);
		}

		if (iueAppend & iueAction)
		{
			chDelimiter = *((const ICHAR*) strValue+1);
			strValue.Remove(iseIncluding, chDelimiter);
		}
		else if (iuePrepend & iueAction)
		{
			chDelimiter = *CharPrev((const ICHAR*) strValue, (const ICHAR*) strValue + strValue.TextSize()-1);
			strValue.Remove(iseFrom, chDelimiter);
		}
	}

	PMsiRecord pParams(&riServices.CreateRecord(Args));
	Assert(pParams);
	AssertNonZero(pParams->SetMsiString(Name, *strName));
	AssertNonZero(pParams->SetMsiString(Value, *strValue));
	AssertNonZero(pParams->SetMsiString(Delimiter, *MsiString(MsiChar(chDelimiter))));
	AssertNonZero(pParams->SetInteger(Action, iueAction));
	// where we should find the autoexec.bat if necessary.

	MsiString strEnvironmentTest = riEngine.GetPropertyFromSz(TEXT("WIN95_ENVIRONMENT_TEST"));

	// allow the property test to override any saved value.
	if (strEnvironmentTest.TextSize())
		AssertNonZero(pParams->SetMsiString(AutoExecPath, *strEnvironmentTest));
	else if (g_fWin9X)
	{
		// cache the detected value for the future.
		MsiString strBootDrive;

		if (strBootDrive.TextSize())
			AssertNonZero(pParams->SetMsiString(AutoExecPath, *strBootDrive));
		else
		{
			const ICHAR szBootFile[] = TEXT("config.sys");
			Bool fExists = fFalse;
			PMsiPath pBootPath(0);
			PMsiRecord pErr(0);
		
			// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup
			// BootDir
			PMsiRegKey piRootKey = &riServices.GetRootKey(rrkLocalMachine, ibtCommon);
			PMsiRegKey piKey(0);
			if (piRootKey)
				piKey = &piRootKey->CreateChild(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup"));
			MsiString strValue(0);
			if (piKey)
				pErr = piKey->GetValue(TEXT("BootDir"), *&strValue);

			if (!pErr && (strValue.TextSize()))
			{
				strBootDrive = strValue;
				AssertNonZero(pParams->SetMsiString(AutoExecPath, *strBootDrive));
			}
			else
			{
				// first, try our windows volume

				strBootDrive = riEngine.GetPropertyFromSz(IPROPNAME_WINDOWS_VOLUME);
				pErr = riServices.CreatePath(strBootDrive, *&pBootPath);
				pErr = pBootPath->FileExists(szBootFile, fExists);
				if (fExists)
					AssertNonZero(pParams->SetMsiString(AutoExecPath, *strBootDrive));
				else
				{
					PMsiVolume pBootVolume(0);
					ICHAR szVolume[] = TEXT("?:\\");
					// if it's not there, check all of the hard disks for config.sys
					for (ICHAR chDrive = TEXT('A'); chDrive <= TEXT('Z'); chDrive++)
					{
						szVolume[0] = chDrive;
						pErr = riServices.CreateVolume(szVolume, *&pBootVolume);
						if (pBootVolume && (idtFixed == pBootVolume->DriveType()))
						{
							pBootPath->SetVolume(*pBootVolume);
							pErr = pBootPath->FileExists(szBootFile, fExists);
							if (fExists)
							{
								strBootDrive = szVolume;
								AssertNonZero(pParams->SetMsiString(AutoExecPath, *strBootDrive));
								break;
							}
						}
					}
					// if all else fails, use the windows volume
					if (!fExists)
					{
						AssertNonZero(pParams->SetMsiString(AutoExecPath, *strBootDrive));
					}
				}
			}
		}		
	}

	return riEngine.ExecuteRecord(ixoUpdateEnvironmentStrings, *pParams);
}

 


iesEnum WriteEnvironmentStrings(IMsiEngine& riEngine)
{
	static const ICHAR sqlWriteEnvironmentStrings[] =
		TEXT("SELECT `Name`,`Value` FROM `Environment`,`Component`")
		TEXT(" WHERE `Component_`=`Component` AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2)");

	return PerformAction(riEngine, sqlWriteEnvironmentStrings, UpdateEnvironmentStringsCore, 1, ibeWriteRegistryValues);
}

iesEnum RemoveEnvironmentStrings(IMsiEngine& riEngine)
{
	static const ICHAR sqlRemoveEnvironmentStrings[] =
		TEXT("SELECT `Name`,`Value` FROM `Environment`,`Component`")
		TEXT(" WHERE `Component_`=`Component` AND (`Component`.`Action` = 0)");

	return PerformAction(riEngine, sqlRemoveEnvironmentStrings, UpdateEnvironmentStringsCore, 0, ibeWriteRegistryValues);
}

iesEnum InstallSFPCatalogFile(IMsiEngine& riEngine)
{
	static const ICHAR sqlInstallSFPCatalogFile[] = 
		TEXT("SELECT DISTINCT `SFPCatalog`, `Catalog`, `Dependency` FROM `SFPCatalog`,`File`,`FileSFPCatalog`,`Component`")
		TEXT(" WHERE `Component`.`Action`=1 AND `Component_`=`Component` AND `File`=`File_` AND `SFPCatalog`=`SFPCatalog_`");

	// Windows Millennium and later only.
	if (!MinimumPlatform(true, 4, 90))
	{
		DEBUGMSGV("Skipping InstallSFPCatalogFile.  Only valid on Windows 9x platform, beginning with Millennium Edition.");
		return iesNoAction;
	}

	PMsiView piView(0);
	PMsiRecord pError(0);
	pError = riEngine.OpenView(sqlInstallSFPCatalogFile, ivcFetch, *&piView);	
	if (pError != 0)
	{
		if(pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesSuccess; // missing table so no data to process
		else
			return riEngine.FatalError(*pError);  // may want to reformat error message
	}
	pError = piView->Execute(0);
	if (pError != 0)
		return riEngine.FatalError(*pError);  // may want to reformat error message

	PMsiRecord pFetch(0);
	
	using namespace IxoInstallSFPCatalogFile;
	PMsiServices piServices(riEngine.GetServices());
	PMsiRecord pParams(&piServices->CreateRecord(Args));

	iesEnum iesStatus = iesSuccess;
	while((iesStatus == iesSuccess) && (pFetch = piView->Fetch()) != 0)
	{
		MsiString strSFPCatalog = pFetch->GetMsiString(1);

		AssertNonZero(pParams->SetMsiString(Name, *strSFPCatalog));
		AssertNonZero(pParams->SetMsiData(Catalog, PMsiData(pFetch->GetMsiData(2))));
		AssertNonZero(pParams->SetMsiString(Dependency, *MsiString(riEngine.FormatText(*MsiString(pFetch->GetMsiString(3))))));
		iesStatus = riEngine.ExecuteRecord(ixoInstallSFPCatalogFile, *pParams);
	}

	return iesStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\sources.inc ===
TARGETNAME=msilib

!INCLUDE ..\..\MsiMake.inc

!if "$(MSI_BROWSER_INFO)"=="1"
BROWSER_INFO=1
!endif

TARGETTYPE=LIBRARY
TARGETLIBS=\
!if "$(MSI_BUILD_UNICODE)"=="1"
        $(SDK_LIB_PATH)\ntdll.lib \
        $(SDK_LIB_PATH)\advapip.lib \
!else
        $(SDK_LIB_PATH)\advapi32.lib \
!endif
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\gdi32.lib \
        $(SDK_LIB_PATH)\rpcrt4.lib \
        $(IDL_OBJDIR)\icust_p.obj \
	$(IDL_OBJDIR)\messag_p.obj \
	$(IDL_OBJDIR)\server_p.obj \
	$(IDL_OBJDIR)\remapi_p.obj \
	$(IDL_OBJDIR)\dlldata.obj \
	$(RES_OBJDIR)\msiall.res \
	$(DS_LIB_PATH)\rsa32.lib \
        $(SDK_LIB_PATH)\strsafe.lib


C_DEFINES=$(C_DEFINES) \
	-DINTERNAL -D_MSI_DLL

USE_LIBCMT=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\msi.def

INCLUDES=\
        $(INCLUDES);\
        ..;\
        $(INC_DIR);\
        $(BASE_INC_PATH);\
        $(IDL_OBJDIR);\
        $(BUILD_COMMONDIR);\
        $(TOOLS_INC_DIR);\
        $(RES_OBJDIR);\
	$(DS_INC_PATH);\
        $(DS_INC_PATH)\crypto;\
        $(ADMIN_INC_PATH)

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_CXX=1

SOURCES=..\istring.cpp \
	..\record.cpp  \
        ..\services.cpp  \
        ..\msidbg.cpp  \
        ..\database.cpp \
	..\transfrm.cpp \
	..\dbview.cpp \
	..\dbfile.cpp \
	..\path.cpp \
	..\copy.cpp \
	..\patch.cpp \
	..\intrface.cpp \
	..\imemory.cpp \
	..\runapps.cpp \
	..\fdisvr.cpp \
	..\callback.cpp \
	..\fdidll.c \
	..\regkey.cpp \
	..\engine.cpp \
	..\execute.cpp \
	..\iconfig.cpp \
	..\coreactn.cpp \
	..\shared.cpp \
	..\except.cpp \
	..\client.cpp \
	..\vertrust.cpp \
	..\latebind.cpp \
	..\msinst.cpp \
	..\msiquery.cpp \
	..\action.cpp \
	..\msiutil.cpp \
	..\msiprops.cpp \
	..\srcmgmt.cpp \
	..\srclist.cpp \
	..\fileactn.cpp \
	..\complus.cpp \
	..\script.cpp \
	..\diagnose.cpp \
	..\icust.cpp \
	..\autoapi.cpp \
	..\camgr.cpp \
	..\dgtlsig.cpp \
	..\ptchmgmt.cpp \
	..\appcompat.cpp \
	..\urlfunc.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\services.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       services.cpp
//
//--------------------------------------------------------------------------

/* services.cpp - IMsiServices implementation

 class CMsiServices implementation and class factory for services
 implements services not related to other service classes
____________________________________________________________________________*/

#include "precomp.h" 
#include <wow64t.h>
#include "icust.h"
#include "_camgr.h"

// definitions required for module.h, for entry points and registration
#if !defined(SERVICES_DLL)
#define SERVICES_CLSID_MULTIPLE 0
#elif defined(DEBUG)
#define SERVICES_CLSID_MULTIPLE 2
#else
#define SERVICES_CLSID_MULTIPLE 1
#endif
#define  SERVICES_CLSID_COUNT 2  // IMsiServices + IMsiServicesAsService
#define CLSID_COUNT (SERVICES_CLSID_COUNT * SERVICES_CLSID_MULTIPLE)
#define IN_SERVICES
#if defined(SERVICES_DLL)
#define PROFILE_OUTPUT      "msisrvd.mea";
#define MODULE_CLSIDS       rgCLSID         // array of CLSIDs for module objects
#define MODULE_PROGIDS      rgszProgId      // ProgId array for this module
#define MODULE_DESCRIPTIONS rgszDescription // Registry description of objects
#define MODULE_FACTORIES    rgFactory       // factory functions for each CLSID
#define MODULE_INITIALIZE InitializeModule
#define cmitObjects         8
#define MEM_SERVICES
#include "module.h"   // self-reg and assert functions
#define ASSERT_HANDLING  // instantiate assert services once per module
#else
#include "version.h"  // rmj, rmm, rup, rin
extern long g_cInstances;
#endif // SERVICES_DLL, else engine.cpp contains factories

#include "imsimem.h"

#include "_service.h" // local factories, general includes including _assert.h

// MAINTAIN: compatibility with versions used to create database
const int iVersionServicesMinimum = 12;            // 0.12
const int iVersionServicesMaximum = rmj*100 + rmm; // MAJOR.minor

// functions exposed from g_MessageContext object
bool   CreateLog(const ICHAR* szFile, bool fAppend);
bool   LoggingEnabled();
bool   WriteLog(const ICHAR* szText);
HANDLE GetUserToken();

#ifdef UNICODE
#define MsiRegQueryValueEx MsiRegQueryValueExW
LONG MsiRegQueryValueExW(
#else
#define MsiRegQueryValueEx MsiRegQueryValueExA
LONG MsiRegQueryValueExA(
#endif
            HKEY hKey, const ICHAR* lpValueName, LPDWORD lpReserved, LPDWORD lpType, CAPITempBufferRef<ICHAR>& rgchBuf, LPDWORD lpcbBuf);

#include <imagehlp.h> // image help definitions
#include "handler.h"  // idbgCreatedFont definition
#include "path.h"

#undef  DEFINE_GUID  // allow selective GUID initialization
#define DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const GUID name = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

// borrowed from NT private header shlobjp.h : needed to muge thru Darwin shortcut
DEFINE_GUID(IID_IShellLinkDataList,     0x45e2b4ae, 0xb1c3, 0x11d0, 0xb9, 0x2f, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1); //
// {95CE8410-7027-11D1-B879-006008059382}


// borrowed from NT private header shlwapip.h : needed to muge thru Darwin shortcut on Win98
// The stream format is a SHELL_LINK_DATA followed by
//   if SLDF_HAS_ID_LIST an ILSaveToStream followed by
//   if SLDF_HAS_LINK_INFO a LINKINFO followed by
//   if SLDF_HAS_NAME a STREAMSTRING followed by
//   if SLDF_RELPATH a STREAMSTRING followed by
//   if SLDF_WORKINGDIR a STREAMSTRING followed by
//   if SLDF_HAS_ARGS a STREAMSTRING followed by
//   if SLDF_HAS_ICON_LOCATION a STREAMSTRING followed by
//   SHWriteDataBlockList list of signature blocks
//
// Where a STREAMSTRING is a USHORT count of characters
// followed by that many (SLDF_UNICODE ? WIDE : ANSI) characters.
//
typedef struct {        // sld
    DWORD       cbSize;                 // signature for this data structure
    CLSID       clsid;                  // our GUID
    DWORD       dwFlags;                // SHELL_LINK_DATA_FLAGS enumeration

    DWORD       dwFileAttributes;
    FILETIME    ftCreationTime;
    FILETIME    ftLastAccessTime;
    FILETIME    ftLastWriteTime;
    DWORD       nFileSizeLow;

    int         iIcon;
    int         iShowCmd;
    WORD        wHotkey;
    WORD        wUnused;
    DWORD       dwRes1;
    DWORD       dwRes2;
} SHELL_LINK_DATA, *LPSHELL_LINK_DATA;

#undef  DEFINE_GUID  // allow selective GUID initialization
#define DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) const int i_##name = l;
#undef _SHLGUID_H_
#include <shlguid.h>  // GUID_IID_IShell*
const GUID CLSID_ShellLink    = MSGUID(i_CLSID_ShellLink);
#ifdef UNICODE
const GUID IID_IShellLinkW    = MSGUID(i_IID_IShellLinkW);
#else
const GUID IID_IShellLinkA    = MSGUID(i_IID_IShellLinkA);
#endif

const int iidPersistFile = 0x0010BL;
#define GUID_IID_IPersistFile MSGUID(iidPersistFile)

const GUID IID_IPersistFile   = GUID_IID_IPersistFile;
const GUID IID_IMalloc        = GUID_IID_IMalloc;
const GUID IID_IMsiData       = GUID_IID_IMsiData;
const GUID IID_IMsiString     = GUID_IID_IMsiString;
const GUID IID_IMsiRecord     = GUID_IID_IMsiRecord;
const GUID IID_IEnumMsiRecord = GUID_IID_IEnumMsiRecord;
const GUID IID_IMsiVolume     = GUID_IID_IMsiVolume;
const GUID IID_IEnumMsiVolume = GUID_IID_IEnumMsiVolume;
const GUID IID_IMsiPath       = GUID_IID_IMsiPath;
const GUID IID_IMsiFileCopy   = GUID_IID_IMsiFileCopy;
const GUID IID_IMsiFilePatch  = GUID_IID_IMsiFilePatch;
const GUID IID_IMsiRegKey     = GUID_IID_IMsiRegKey;
const GUID IID_IMsiMalloc     = GUID_IID_IMsiMalloc;
const GUID IID_IMsiDebugMalloc= GUID_IID_IMsiDebugMalloc;

#ifdef SERVICES_DLL
const GUID IID_IUnknown      = GUID_IID_IUnknown;
const GUID IID_IClassFactory = GUID_IID_IClassFactory;
#endif


// CComPointers for Shortcut interfaces
typedef CComPointer<IPersistFile> PMsiPersistFile;
typedef CComPointer<IShellLink> PMsiShellLink;
typedef CComPointer<IShellLinkDataList> PMsiShellLinkDataList;

// CComPointer to encapsulate ITypeLib*
typedef CComPointer<ITypeLib> PTypeLib;

// for Get/Write IniFile stuff
const ICHAR* WIN_INI = TEXT("WIN.INI");

// for fonts registration
const ICHAR* REGKEY_WIN_95_FONTS = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Fonts");
const ICHAR* REGKEY_WIN_NT_FONTS = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts");
const ICHAR* REGKEY_SHELLFOLDERS = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
const ICHAR* REGKEY_USERSHELLFOLDERS = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders");

//____________________________________________________________________________
//
// COM objects produced by this module's class factories
//____________________________________________________________________________

#ifdef SERVICES_DLL
const GUID rgCLSID[CLSID_COUNT] =
{  GUID_IID_IMsiServices
 , GUID_IID_IMsiServicesAsService
#ifdef DEBUG
 , GUID_IID_IMsiServicesDebug
 , GUID_IID_IMsiServicesAsServiceDebug
#endif
};

const ICHAR* rgszProgId[CLSID_COUNT] =
{  SZ_PROGID_IMsiServices
 , SZ_PROGID_IMsiServices
#ifdef DEBUG
 , SZ_PROGID_IMsiServicesDebug
 , SZ_PROGID_IMsiServicesDebug
#endif
};

const ICHAR* rgszDescription[CLSID_COUNT] =
{  SZ_DESC_IMsiServices
 , SZ_DESC_IMsiServices
#ifdef DEBUG
 , SZ_DESC_IMsiServicesDebug
 , SZ_DESC_IMsiServicesDebug
#endif
};

IMsiServices* CreateServices();
IUnknown* CreateServicesAsService();

ModuleFactory rgFactory[CLSID_COUNT] =
{  (ModuleFactory)CreateServices
 , CreateServicesAsService
#ifdef DEBUG
 , (ModuleFactory)CreateServices
 , CreateServicesAsService
#endif
};
#else // engine.cpp contains combined CLSID arrays
extern const GUID rgCLSID[];
#endif // SERVICES_DLL

const GUID& IID_IMsiServicesShip          = rgCLSID[0];
const GUID& IID_IMsiServicesAsService     = rgCLSID[1];
#ifdef DEBUG
const GUID& IID_IMsiServicesDebug         = rgCLSID[SERVICES_CLSID_COUNT];
const GUID& IID_IMsiServicesAsServiceDebug= rgCLSID[SERVICES_CLSID_COUNT+1];
#endif

//____________________________________________________________________________
//
// Windows special folder locations with corresponding property names
//____________________________________________________________________________

#define CSIDL_FLAG_CREATE               0x8000      // new for NT5, shfolder. or this in to force creation of folder

extern const ShellFolder rgShellFolders[] =
{
    CSIDL_APPDATA,          -1, IPROPNAME_APPDATA_FOLDER,      TEXT("AppData"),         false,
    CSIDL_FAVORITES,        -1, IPROPNAME_FAVORITES_FOLDER,    TEXT("Favorites"),       false,
    CSIDL_NETHOOD,          -1, IPROPNAME_NETHOOD_FOLDER,      TEXT("NetHood"),         false,
    CSIDL_PERSONAL,         -1, IPROPNAME_PERSONAL_FOLDER,     TEXT("Personal"),        false,
    CSIDL_PRINTHOOD,        -1, IPROPNAME_PRINTHOOD_FOLDER,    TEXT("PrintHood"),       false,
    CSIDL_RECENT,           -1, IPROPNAME_RECENT_FOLDER,       TEXT("Recent"),          false,
    CSIDL_SENDTO,           -1, IPROPNAME_SENDTO_FOLDER,       TEXT("SendTo"),          false,
    CSIDL_TEMPLATES,        -1, IPROPNAME_TEMPLATE_FOLDER,     TEXT("Templates"),       false,
    CSIDL_COMMON_APPDATA,   -1, IPROPNAME_COMMONAPPDATA_FOLDER,TEXT("Common AppData"),  false,
    CSIDL_LOCAL_APPDATA,    -1, IPROPNAME_LOCALAPPDATA_FOLDER, TEXT("Local AppData"),   false,
    CSIDL_MYPICTURES,       -1, IPROPNAME_MYPICTURES_FOLDER,   TEXT("My Pictures"),     true,
    -1,                     -1, 0,                             0,                       false,
    // font folder set by GetFontFolderPath
};

// properties must be listed in same order in following two arrays
// also the order of listing should be from the "deepest" folder to the shallowest, for shortcut advertisement (and script deployment on another m/c) to work correctly
extern const ShellFolder rgAllUsersProfileShellFolders[] =
{
    CSIDL_COMMON_ADMINTOOLS,       CSIDL_ADMINTOOLS,       IPROPNAME_ADMINTOOLS_FOLDER,      TEXT("Common Administrative Tools"), true,
    CSIDL_COMMON_STARTUP,          CSIDL_STARTUP,          IPROPNAME_STARTUP_FOLDER,         TEXT("Common Startup"),              false,
    CSIDL_COMMON_PROGRAMS,         CSIDL_PROGRAMS,         IPROPNAME_PROGRAMMENU_FOLDER,     TEXT("Common Programs"),             false,
    CSIDL_COMMON_STARTMENU,        CSIDL_STARTMENU,        IPROPNAME_STARTMENU_FOLDER,       TEXT("Common Start Menu"),           false,
    CSIDL_COMMON_DESKTOPDIRECTORY, CSIDL_DESKTOPDIRECTORY, IPROPNAME_DESKTOP_FOLDER,         TEXT("Common Desktop"),              false,
    -1,                            -1,                     0,                                0,                                   false,
};

extern const ShellFolder rgPersonalProfileShellFolders[] =
{
    CSIDL_ADMINTOOLS,       CSIDL_COMMON_ADMINTOOLS,       IPROPNAME_ADMINTOOLS_FOLDER,      TEXT("Administrative Tools"),        true,
    CSIDL_STARTUP,          CSIDL_COMMON_STARTUP,          IPROPNAME_STARTUP_FOLDER,         TEXT("Startup"),                     false,
    CSIDL_PROGRAMS,         CSIDL_COMMON_PROGRAMS,         IPROPNAME_PROGRAMMENU_FOLDER,     TEXT("Programs"),                    false,
    CSIDL_STARTMENU,        CSIDL_COMMON_STARTMENU,        IPROPNAME_STARTMENU_FOLDER,       TEXT("Start Menu"),                  false,
    CSIDL_DESKTOPDIRECTORY, CSIDL_COMMON_DESKTOPDIRECTORY, IPROPNAME_DESKTOP_FOLDER,         TEXT("Desktop"),                     false,
    -1,                     -1,                            0,                                0,                                   false,
};

//____________________________________________________________________________
//
// CMsiServices definitions
//____________________________________________________________________________

// return values for HandleSquare, HandleCurl and HandleClean
enum ihscEnum
{
    ihscNotFound = 0,
    ihscFound,
    ihscError,
    ihscNone,
};


class CMsiServices : public IMsiServices
{
 public:   // implemented virtual functions
    HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long   __stdcall AddRef();
    unsigned long   __stdcall Release();
    Bool            __stdcall CheckMsiVersion(unsigned int iVersion);
    IMsiMalloc&     __stdcall GetAllocator();
    const IMsiString& __stdcall GetNullString();
    IMsiRecord&     __stdcall CreateRecord(unsigned int cParam);
    Bool            __stdcall SetPlatformProperties(IMsiTable& riTable, Bool fAllUsers, isppEnum isppArchitecture, IMsiTable* piFolderCacheTable);
    isliEnum        __stdcall SupportLanguageId(int iLangId, Bool fSystem);
    Bool            __stdcall CreateLog(const ICHAR* szFile, Bool fAppend);
    Bool            __stdcall WriteLog(const ICHAR* szText);
    IMsiRecord*     __stdcall CreateDatabase(const ICHAR* szDataBase, idoEnum idoOpenMode, IMsiDatabase*& rpi);
    IMsiRecord*     __stdcall CreateDatabaseFromStorage(IMsiStorage& riStorage,
                                                            Bool fReadOnly, IMsiDatabase*& rpi);
    IMsiRecord*     __stdcall CreatePath(const ICHAR* astrPath, IMsiPath*& rpi);
    IMsiRecord*     __stdcall CreateVolume(const ICHAR* astrPath, IMsiVolume*& rpi);
    Bool            __stdcall CreateVolumeFromLabel(const ICHAR* szLabel, idtEnum idtVolType, IMsiVolume*& rpi);
    IMsiRecord*     __stdcall CreateCopier(ictEnum ictCopierType, IMsiStorage* piStorage, IMsiFileCopy*& racopy);
    IMsiRecord*     __stdcall CreatePatcher(IMsiFilePatch*& rapatch);
    void            __stdcall ClearAllCaches();
    IEnumMsiVolume& __stdcall EnumDriveType(idtEnum);
    IMsiRecord*     __stdcall GetModuleUsage(const IMsiString& strFile, IEnumMsiRecord*& rpaEnumRecord);
    const IMsiString&     __stdcall GetLocalPath(const ICHAR* szFile);
    IMsiRegKey&     __stdcall GetRootKey(rrkEnum erkRoot, const ibtBinaryType iType=ibtCommon);
    IMsiRecord*     __stdcall RegisterFont(const ICHAR* szFontTitle, const ICHAR* szFontFile, IMsiPath* piPath, bool fInUse);
    IMsiRecord*     __stdcall UnRegisterFont(const ICHAR* szFontTitle);
    Bool            __stdcall LoggingEnabled();
    IMsiRecord*     __stdcall WriteIniFile(IMsiPath* piPath,const ICHAR* pszFile,const ICHAR* pszSection,const ICHAR* pszKey,const ICHAR* pszValue, iifIniMode iifMode);
    IMsiRecord*     __stdcall ReadIniFile(IMsiPath* piPath,const ICHAR* pszFile,const ICHAR* pszSection,const ICHAR* pszKey, unsigned int iField, const IMsiString*& rpiValue);
    int             __stdcall GetLangNamesFromLangIDString(const ICHAR* szLangIDs, IMsiRecord& riLangRec, int iFieldStart);
    IMsiRecord*     __stdcall CreateStorage(const ICHAR* szPath, ismEnum ismOpenMode,
                                                         IMsiStorage*& rpiStorage);
    IMsiRecord*     __stdcall CreateStorageFromMemory(const char* pchMem, unsigned int iSize,
                                                         IMsiStorage*& rpiStorage);
    IMsiRecord*     __stdcall GetUnhandledError();
    IMsiRecord*     __stdcall CreateShortcut(IMsiPath& riShortcutPath, const IMsiString& riShortcutName,
                                                IMsiPath* piTargetPath,const ICHAR* pchTargetName,
                                                IMsiRecord* piShortcutInfoRec,
                                                LPSECURITY_ATTRIBUTES pSecurityAttributes);
    IMsiRecord*     __stdcall RemoveShortcut(IMsiPath& riShortcutPath,const IMsiString& riShortcutName,
                                                IMsiPath* piTargetPath, const ICHAR* pchTargetName);
    char*           __stdcall AllocateMemoryStream(unsigned int cbSize, IMsiStream*& rpiStream);
    IMsiStream*     __stdcall CreateStreamOnMemory(const char* pbReadOnly, unsigned int cbSize);
    IMsiRecord*     __stdcall CreateFileStream(const ICHAR* szFile, Bool fWrite, IMsiStream*& rpiStream);
    IMsiRecord*     __stdcall ExtractFileName(const ICHAR* szFileName, Bool fLFN, const IMsiString*& rpistrExtractedFileName);
    IMsiRecord*     __stdcall ValidateFileName(const ICHAR *szFileName, Bool fLFN);
    IMsiRecord*     __stdcall RegisterTypeLibrary(const ICHAR* szLibID, LCID lcidLocale, const ICHAR* szTypeLib, const ICHAR* szHelpPath, ibtBinaryType);
    IMsiRecord*     __stdcall UnregisterTypeLibrary(const ICHAR* szLibID, LCID lcidLocale, const ICHAR* szTypeLib, ibtBinaryType);
    IMsiRecord*     __stdcall GetShellFolderPath(int iFolder, const ICHAR* szRegValue,
                                                                const IMsiString*& rpistrPath, bool bAvoidFolderCreation = false);
    const IMsiString& __stdcall GetUserProfilePath();
    IMsiRecord*     __stdcall CreateFilePath(const ICHAR* astrPath, IMsiPath*& rpi, const IMsiString*& rpistrFileName);
    bool            __stdcall FWriteScriptRecord(ixoEnum ixoOpCode, IMsiStream& riStream, IMsiRecord& riRecord, IMsiRecord* piPrevRecord, bool fForceFlush);
    IMsiRecord*     __stdcall ReadScriptRecord(IMsiStream& riStream, IMsiRecord*& rpiPrevRecord, int iScriptVersion);
    void            __stdcall SetSecurityID(HANDLE hPipe);
    IMsiRecord* __stdcall GetShellFolderPath(int iFolder, bool fAllUsers, const IMsiString*& rpistrPath, bool bAvoidFolderCreation = false);
    void            __stdcall SetNoPowerdown();
    void            __stdcall ClearNoPowerdown();
    Bool            __stdcall FTestNoPowerdown();
    IMsiRecord*     __stdcall ReadScriptRecordMsg(IMsiStream& riStream);
    bool            __stdcall FWriteScriptRecordMsg(ixoEnum ixoOpCode, IMsiStream& riStream, IMsiRecord& riRecord);
    void            __stdcall SetNoOSInterruptions();
    void            __stdcall ClearNoOSInterruptions();

 public:     // factory
    static void *operator new(size_t cb) { return AllocSpc(cb); }
    static void operator delete(void * pv) { FreeSpc(pv); }
    CMsiServices();
 protected:  // constructor/destructor and local methods
  ~CMsiServices();
    IMsiRecord* WriteLineToIni(IMsiPath* pMsiPath,const ICHAR* pFile,const ICHAR* pSection,const ICHAR* pKey,const ICHAR* pBuffer);
    IMsiRecord* ReadLineFromIni(IMsiPath* pMsiPath,const ICHAR* pFile,const ICHAR* pSection,const ICHAR* pKey, unsigned int iField, CTempBufferRef<ICHAR>& pszBuffer);
    BOOL ReadLineFromFile(HANDLE hFile, ICHAR* szBuffer, int cchBufSize, int* iBytesRead);
    ihscEnum HandleSquare(MsiString& ristrIn, MsiString& ristrOut, IMsiRecord& riRecord);
    ihscEnum HandleCurl(MsiString& ristrIn, MsiString& ristrOut, IMsiRecord& riRecord);
    ihscEnum HandleClean(MsiString& ristrIn, MsiString& ristrOut);
    ihscEnum CheckPropertyName(MsiString& ristrIn, MsiString& ristrOut);
    IMsiRecord* ProcessTypeLibrary(const ICHAR* szLibID, LCID lcidLocale, const ICHAR* szTypeLib, const ICHAR* szHelpPath, Bool fRemove, ibtBinaryType);
    void GetFontFolderPath(const IMsiString*& rpistrFolderPath);

 protected: //  state data
    CMsiRef<iidMsiServices> m_Ref;
//      LANGID         m_wLang;
    CRootKeyHolder* m_rootkH;
    Bool            m_fCoInitialized;
    IMsiTable*      m_piPropertyTable;
    IMsiCursor*     m_piPropertyCursor;
    UINT            m_errSaved;         // The saved state of SetErrorMode
    CDetectApps*    m_pDetectApps;
    IMsiRecord*     m_piRecordPrev;
    ixoEnum         m_ixoOpCodePrev;
};

//____________________________________________________________________________
//
// Global data
//____________________________________________________________________________

// externally visible within this DLL
bool g_fWin9X = false;           // true if Windows 95 or 98, else false
bool g_fWinNT64 = false;         // true if 64-bit Windows NT, else false
Bool g_fShortFileNames = fFalse;  // fTrue if long file names not supported, or suppressed by system
int  g_iMajorVersion = 0;
int  g_iMinorVersion = 0;
int  g_iWindowsBuild = 0;
LONG g_cNoPowerdown = -1;   // Counts how many times we've set the no-system powerdown flag
LONG g_cNoSystemAgent = -1; // Counts how many times we've disabled the System Agent
LONG g_cNoScreenSaver = -1; // Counts how many times we've disabled the screen saver.
HANDLE g_hDisableLowDiskEvent = 0;

const HANDLE iFileNotOpen = 0;

// internal within this source module
IMsiRecord* g_piUnhandledError = 0;

// short|long file name extraction and validation constants
const int cchMaxShortFileName = 12;
const int cchMaxLongFileName = 255;
const int cchMaxSFNPreDotLength = 8;
const int cchMaxSFNPostDotLength = 3;

// global functions
// Win specific private helper functions required for creation and deletion of shortcuts
#define SZCHICAGOLINK   TEXT(".lnk")    // the default link extension
#define SZLINKVALUE     TEXT("IsShortcut") // value that determines a registered shortcut extension

// Fn - HasShortcutExtension
// Determines if a filename has a shortcut extension
IMsiRecord* HasShortcutExtension(MsiString& rstrShortcutPath, IMsiServices& riServices, Bool& rfResult)
{
    rfResult = fFalse;
    MsiString strExtension = rstrShortcutPath.Extract(iseFrom, '.');
    if(strExtension.TextSize() != rstrShortcutPath.TextSize())
    {
        if(strExtension.Compare(iscExactI, SZCHICAGOLINK))
        {
            rfResult = fTrue;
            return 0;
        }
        // check if the extension is registered as a valid link extension
        PMsiRegKey piRootKey = &riServices.GetRootKey(rrkClassesRoot, ibtCommon); //??
        PMsiRegKey piKey = &piRootKey->CreateChild(strExtension);
        // get the default value
        MsiString strVal;
        IMsiRecord* piError = piKey->GetValue(0, *&strVal);
        if(piError != 0)
            return piError;
        if(strVal.TextSize() != 0)
        {
            piKey = &piRootKey->CreateChild(strVal);
            PEnumMsiString piEnumStr(0);
            piError = piKey->GetValueEnumerator(*&piEnumStr);
            if(piError != 0)
                return piError;
            while(((piEnumStr->Next(1, &strVal, 0)==S_OK)) && (rfResult == fFalse))
                if(strVal.Compare(iscExactI, SZLINKVALUE)) // registered shortcut extension
                    rfResult = fTrue;
        }
    }
    return 0;
}

// Fn - EnsureShortcutExtension
// Appends the default link extension to the file, if not present
IMsiRecord* EnsureShortcutExtension(MsiString& rstrShortcutPath, IMsiServices& riServices)
{
    MsiString strDefExtension = SZCHICAGOLINK;
    Bool fResult;
    IMsiRecord* piError = HasShortcutExtension(rstrShortcutPath, riServices, fResult);
    if(piError != 0)
        return piError;
    if(fResult == fFalse)
        rstrShortcutPath += strDefExtension;
    return 0;
}

//____________________________________________________________________________
//
// Internal error processing functions
//____________________________________________________________________________

void SetUnhandledError(IMsiRecord* piError)
{
    if (piError && g_piUnhandledError)
    {
        piError->Release(); // too bad, only room for the first
        return;
    }
    if (g_piUnhandledError)
        g_piUnhandledError->Release();
    g_piUnhandledError = piError;
}

IMsiRecord* CMsiServices::GetUnhandledError()
{
    IMsiRecord* piError = g_piUnhandledError;
    g_piUnhandledError = 0;
    return piError;
}

//____________________________________________________________________________
//
// CMsiServices implementation
//____________________________________________________________________________

#if defined(SERVICES_DLL)
CMsiStringNullCopy MsiString::s_NullString;  // initialized by InitializeClass below
void InitializeModule()
{
    MsiString::InitializeClass(g_MsiStringNull);
}
#endif // SERVICES_DLL

IMsiServices* CreateServices()
{
    if (!g_fWin9X)// Long file name suppression chck - NT only
    {
        HKEY hSubKey;
        DWORD dwValue = 0;
        DWORD cbValue = sizeof(dwValue);
        cbValue = 4;
        // Win64: I've checked and it's in 64-bit location.
        if (MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Control\\FileSystem"), 0, KEY_READ, &hSubKey)
                    == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hSubKey, TEXT("Win31FileSystem"), 0, 0, (BYTE*)&dwValue, &cbValue)
                    == ERROR_SUCCESS && dwValue != 0)
                g_fShortFileNames = fTrue;
            RegCloseKey(hSubKey);
        }
    }
    g_fDBCSEnabled = (Bool)::GetSystemMetrics(SM_DBCSENABLED);
    return (IMsiServices*)new CMsiServices();
}

//!! Is this still used?
IUnknown* CreateServicesAsService()
{
    IMsiServices* piServices = CreateServices();
    if (piServices)
        g_scServerContext = scService;
    return (IUnknown*)piServices;
}

CMsiServices::CMsiServices()
: m_fCoInitialized(fFalse), m_pDetectApps(0)
 , m_piRecordPrev(0)
{

    // factory does not do QueryInterface, no aggregation
    Debug(m_Ref.m_pobj = this);
   g_cInstances++;
//      m_wLang = WIN::GetUserDefaultLangID();
    InitializeMsiMalloc();
    InitializeAssert(this);  // debug macro to set Assert service pointer
    InitializeRecordCache();
    m_rootkH = CreateMsiRegRootKeyHolder(this);

    // Set once here and the old value remembered. Reset when we are destroyed
    m_errSaved = WIN::SetErrorMode( SEM_FAILCRITICALERRORS );

}

CMsiServices::~CMsiServices()
{

    if (m_piRecordPrev != 0)
    {
        m_piRecordPrev->Release();
        m_piRecordPrev = 0;
    }
    DeleteRootKeyHolder(m_rootkH);

    delete m_pDetectApps;

    DestroyMsiVolumeList(fFalse);//!! how can we ever get here if Volumes present??
    SetUnhandledError(0);  // too bad if nobody ever asked for it
    WIN::SetErrorMode(m_errSaved);

    /*
    if (m_piSecureTempFolder)
    {
        Assert(WIN::RemoveDirectory(m_piSecureTempFolder->GetString()));
        m_piSecureTempFolder->Release();
    }
*/
    if(fTrue == m_fCoInitialized)
        OLE32::CoUninitialize();

    KillRecordCache(fFalse);
    FreeMsiMalloc(fFalse);
    InitializeAssert(0);
   g_cInstances--;
}

extern IMsiDebug* CreateMsiDebug();
extern bool IsProductManaged(const ICHAR* szProductKey);

HRESULT CMsiServices::QueryInterface(const IID& riid, void** ppvObj)
{
    if (riid == IID_IUnknown
#ifdef DEBUG
     || MsGuidEqual(riid, IID_IMsiServicesDebug)
     || ((g_scServerContext == scService) && MsGuidEqual(riid, IID_IMsiServicesAsServiceDebug))
#endif
     || MsGuidEqual(riid, IID_IMsiServicesShip)
     || ((g_scServerContext == scService) && MsGuidEqual(riid, IID_IMsiServicesAsService)))
        *ppvObj = this;
#ifdef DEBUG
    else if (riid == IID_IMsiDebug)
    {
        // The debug object for services is a global rather than
        // part of services so we don't do an addref here
        *ppvObj = (IMsiDebug *)CreateMsiDebug();
        return NOERROR;
    }
#endif //DEBUG
    else
    {
        *ppvObj = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;

}
unsigned long CMsiServices::AddRef()
{
    AddRefTrack();
    return ++m_Ref.m_iRefCnt;
}
unsigned long CMsiServices::Release()
{
    ReleaseTrack();
    if (--m_Ref.m_iRefCnt != 0)
        return m_Ref.m_iRefCnt;
    delete this;
    return 0;
}

Bool CMsiServices::CheckMsiVersion(unsigned int iVersion)
{
    return (iVersion < iVersionServicesMinimum || iVersion > iVersionServicesMaximum)
            ? fFalse : fTrue;
}

IMsiMalloc& CMsiServices::GetAllocator()
{
    piMalloc->AddRef();
    return (*piMalloc);
}

const IMsiString& CMsiServices::GetNullString()
{
    return g_MsiStringNull;
}

IMsiRecord* CMsiServices::CreateDatabase(const ICHAR* szDataBase, idoEnum idoOpenMode, IMsiDatabase*& rpi)
{
    return ::CreateDatabase(szDataBase, idoOpenMode, *this, rpi);
}

IMsiRecord* CMsiServices::CreateDatabaseFromStorage(IMsiStorage& riStorage,
                                                     Bool fReadOnly, IMsiDatabase*& rpi)
{
    return ::CreateDatabase(riStorage, fReadOnly, *this, rpi);
}

IMsiRecord* CMsiServices::CreatePath(const ICHAR* szPath, IMsiPath*& rpi)
{
    return CreateMsiPath(szPath, this, rpi);
}


IMsiRecord* CMsiServices::CreateFilePath(const ICHAR* szPath, IMsiPath*& rpi, const IMsiString*& rpistrFileName)
{
    return CreateMsiFilePath(szPath, this, rpi, rpistrFileName);
}


IMsiRecord* CMsiServices::CreateVolume(const ICHAR* szPath, IMsiVolume*& rpi)
{
    IMsiRecord* piRec = CreateMsiVolume(szPath, this, rpi);
    if (piRec)
        return piRec;
    else
        return NULL;
}

Bool CMsiServices::CreateVolumeFromLabel(const ICHAR* szLabel, idtEnum idtVolType, IMsiVolume*& rpi)
{
    return CreateMsiVolumeFromLabel(szLabel, idtVolType, this, rpi);
}

IMsiRecord* CMsiServices::CreateCopier(ictEnum ictCopierType, IMsiStorage* piStorage, IMsiFileCopy*& riCopy)
{
    return CreateMsiFileCopy(ictCopierType, this, piStorage, riCopy);
}

IMsiRecord* CMsiServices::CreatePatcher(IMsiFilePatch*& riPatch)
{
    return CreateMsiFilePatch(this, riPatch);
}

void CMsiServices::ClearAllCaches()
{
    DestroyMsiVolumeList(fFalse);
}

IEnumMsiVolume& CMsiServices::EnumDriveType(idtEnum idt)
{
    return ::EnumDriveType(idt, *this);
}


IMsiRecord& CMsiServices::CreateRecord(unsigned int cParam)
{
    return ::CreateRecord(cParam);
}

IMsiRecord* CMsiServices::CreateStorage(const ICHAR* szPath, ismEnum ismOpenMode,
                                                         IMsiStorage*& rpiStorage)
{
    return ::CreateMsiStorage(szPath, ismOpenMode, rpiStorage);
}

IMsiRecord* CMsiServices::CreateStorageFromMemory(const char* pchMem, unsigned int iSize,
                                                        IMsiStorage*& rpiStorage)
{
    return ::CreateMsiStorage(pchMem, iSize, rpiStorage);
}

char* CMsiServices::AllocateMemoryStream(unsigned int cbSize, IMsiStream*& rpiStream)
{
    return ::AllocateMemoryStream(cbSize, rpiStream);
}

IMsiStream* CMsiServices::CreateStreamOnMemory(const char* pbReadOnly, unsigned int cbSize)
{
    return ::CreateStreamOnMemory(pbReadOnly, cbSize);
}

IMsiRecord* CMsiServices::CreateFileStream(const ICHAR* szFile, Bool fWrite, IMsiStream*& rpiStream)
{
    return ::CreateFileStream(szFile, fWrite, rpiStream);
}

//____________________________________________________________________________
//
// Platform property handling
//____________________________________________________________________________

// internal functions to set properties in propery table

static Bool SetProperty(IMsiCursor& riCursor, const IMsiString& riProperty, const IMsiString& riData)
{
    Bool fStat;
    riCursor.PutString(1, riProperty);
    if (riData.TextSize() == 0)
    {
        if (riCursor.Next())
            fStat = riCursor.Delete();
        else
            fStat = fTrue;
    }
    else
    {
        riCursor.PutString(2, riData);
        fStat = riCursor.Assign();  // either updates or inserts
    }
    riCursor.Reset();
    return fStat;
}

static Bool SetPropertyInt(IMsiCursor& riCursor, const IMsiString& ristrProperty, int iData)
{
    ICHAR buf[12];
    StringCchPrintf(buf,(sizeof(buf)/sizeof(ICHAR)), TEXT("%i"),iData);
    return SetProperty(riCursor, ristrProperty, *MsiString(buf));
}

static Bool CacheFolderProperty(IMsiCursor& riCursor, int iFolderId, ICHAR* rgchPathBuf, DWORD cchPathBuf)
{
    // force directory delimiter at end of path
    DWORD cchPathLength = IStrLen(rgchPathBuf);
    if(cchPathLength && rgchPathBuf[cchPathLength-1] != chDirSep)
    {
        if (cchPathLength + 2 <= cchPathBuf)
        {
            rgchPathBuf[cchPathLength] = chDirSep;
            rgchPathBuf[cchPathLength+1] = 0;
        }
    }

    Bool fStat = fFalse;    
    AssertNonZero(riCursor.PutInteger(1, iFolderId));
    AssertNonZero(riCursor.PutString(2, *MsiString(rgchPathBuf)));
    fStat = riCursor.Assign(); // either updates or inserts
    riCursor.Reset();

    return fStat;
}

// internal routine to force directory delimiter at end of path
// assumed to have space in buffer to append delimiter
static void SetDirectoryProperty(IMsiCursor& riCursor, const ICHAR* szPropName, ICHAR* rgchPathBuf, DWORD cchPathBuf)
{
    DWORD cchPathLength = IStrLen(rgchPathBuf);
    if(cchPathLength && rgchPathBuf[cchPathLength-1] != chDirSep)
    {
        if (cchPathLength + 2 <= cchPathBuf)
        {
            rgchPathBuf[cchPathLength] = chDirSep;
            rgchPathBuf[cchPathLength+1] = 0;
        }
    }
    AssertNonZero(SetProperty(riCursor, *MsiString(*szPropName), *MsiString(rgchPathBuf)));
}

void SetProcessorProperty(IMsiCursor& riCursor, bool fWinNT64)
{
    SYSTEM_INFO si;
    memset(&si,0,sizeof(si));
    GetSystemInfo(&si);
    int iProcessorLevel = si.wProcessorLevel;

    // per bug 1935, the below #ifdef _X86_ code fixes
    // problems on Win95 machines.  No such problems
    // should occur on NT machines and therefore the values for
    // Intel and Intel64 should be the same for the 32-bit service
    // and 64-bit service on an IA64 machine

#ifdef _X86_ // INTEL
    Assert(si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL);
    if(!iProcessorLevel)
    {
        // Windows95, Intel.  Need to determine processorlevel
        // try si.dwProcessorType - correctly indicates 386 or 486.
        switch (si.dwProcessorType)
        {
            case PROCESSOR_INTEL_386:
                iProcessorLevel=3;
                break;

            case PROCESSOR_INTEL_486:
                iProcessorLevel=4;
                break;

            default:
                iProcessorLevel=0;
                break;
        }
    }
    if(!iProcessorLevel)
    {
        // 586 or above
        int flags,family = 0;
        __try
        {
            _asm
            {
                mov     eax,1
                _emit   00Fh     ;; CPUID
                _emit   0A2h
                mov     flags,edx
                mov     family,eax
            }
        }
        __except(1)
        {
            family = 0;
        }

        iProcessorLevel = family ? (family& 0x0F00) >> 8 : 5; // default to level 5
    }
#endif //_X86_

    Assert(iProcessorLevel);
    int x86ProcessorLevel = iProcessorLevel;
    if ( g_fWinNT64 )
    {
        SYSTEM_PROCESSOR_INFORMATION spi;
        memset(&spi,0,sizeof(SYSTEM_PROCESSOR_INFORMATION));
        NTSTATUS nRet = NTDLL::NtQuerySystemInformation(
                                            SystemEmulationProcessorInformation,
                                            &spi,
                                            sizeof(SYSTEM_PROCESSOR_INFORMATION),
                                            0);
        if ( NT_SUCCESS(nRet) )
            x86ProcessorLevel = spi.ProcessorLevel;
        else
            Assert(0);
    }

    if ( fWinNT64 )
    {
        if ( g_fWinNT64 )
            AssertNonZero(::SetPropertyInt(riCursor, *MsiString(*IPROPNAME_INTEL64), iProcessorLevel));
        else
            AssertNonZero(::SetPropertyInt(riCursor, *MsiString(*IPROPNAME_INTEL64), 1));
    }
    AssertNonZero(::SetPropertyInt(riCursor, *MsiString(*IPROPNAME_INTEL), x86ProcessorLevel));
}

// Are Darwin Descriptors supported?
Bool IsDarwinDescriptorSupported(iddSupport iddType)
{
    static Bool fRetDD    = (Bool) -1;
    static Bool fRetShell = (Bool) -1;
    if(iddType == iddOLE)
    {
        if(fRetDD == -1) // we have not evaluated as yet
        {
            fRetDD = fFalse; // initialize to false
            // the logic to determine if we can create Darwin Descriptor shortcuts
            if((g_fWin9X == false) && (g_iMajorVersion >= 5))
            {
                // we are on NT 5.0 or greater, we have GPT support
                fRetDD = fTrue;
            }
            else
            {
                // check for the correct entry point that indicates that we have DD support
                HINSTANCE hLib;
                FARPROC pEntry;
                const ICHAR rgchGPTSupportEntryDll[] = TEXT("OLE32.DLL");
                const char rgchGPTSupportEntry[] = "CoGetClassInfo";
                if((hLib = LoadLibraryEx(rgchGPTSupportEntryDll, 0, DONT_RESOLVE_DLL_REFERENCES)) != 0)
                {
                    if((pEntry = GetProcAddress(hLib, rgchGPTSupportEntry)) != 0)
                    {
                        // we have detected the magic entry point, we have GPT support
                        fRetDD = fTrue;
                    }
                    FreeLibrary(hLib);
                }
            }
        }
        return fRetDD;
    }
    else if(iddType == iddShell)
    {
        if(fRetShell == -1) // we have not evaluated as yet
        {
            DLLVERSIONINFO g_verinfoShell;
            g_verinfoShell.dwMajorVersion = 0;  // initialize to unknown
            g_verinfoShell.cbSize = sizeof(DLLVERSIONINFO);
            if (SHELL32::DllGetVersion(&g_verinfoShell) == NOERROR &&
                 ((g_verinfoShell.dwMajorVersion > 4) ||
                  (g_verinfoShell.dwMajorVersion == 4 && g_verinfoShell.dwMinorVersion > 72) ||
                  (g_verinfoShell.dwMajorVersion == 4 && g_verinfoShell.dwMinorVersion == 72 && g_verinfoShell.dwBuildNumber >= 3110)))
            {
                fRetShell = fTrue;
            }
            else
            {
                fRetShell = fFalse;
            }
        }
        return fRetShell;
    }
    else
    {
        Assert(0);// this should never happen
        return fFalse;
    }
}

// searches a REG_MULTI_SZ type for a specified string. Compare is not localized.
const ICHAR *FindSzInMultiSz(const ICHAR *mszMultiSz, const ICHAR *szSearch)
{
    DWORD       dwMultiLen;                             // Length of current member
    DWORD       dwSrchLen   = IStrLen(szSearch);      // Constant during search
    const ICHAR *szSubString = mszMultiSz;                  // pointer to current substring

    while (*szSubString)                                // Break on consecutive zero bytes
    {
        dwMultiLen = IStrLen(szSubString);
        if (dwMultiLen == dwSrchLen &&
            !IStrComp(szSearch, szSubString))
            return szSubString;

        // substing does not match, skip forward the length of the substring
        // plus 1 for the terminating null.
        szSubString += (dwMultiLen + 1);
    }

    return NULL;
}

bool IsTokenOnTerminalServerConsole(HANDLE hToken)
{
    DWORD dwSessionId = 0;
    DWORD cbResult;

    if (GetTokenInformation(hToken, (TOKEN_INFORMATION_CLASS)TokenSessionId, &dwSessionId, sizeof(DWORD), &cbResult))
    {
        return (dwSessionId == 0);
    }
    else
    {
        // If the TokenSessionID parameter isn't recognized then we'll just
        // presume that we're on the console.
        Assert(ERROR_INVALID_PARAMETER == GetLastError());
        return true;
    }
}

bool IsRemoteAdminTSInstalled(void)
{
    static BOOL fIsSingleUserTS = -1;

    if (g_fWin9X || g_iMajorVersion < 5)
        return false;

    if (fIsSingleUserTS != -1)
        return fIsSingleUserTS ? true : false;

    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;

    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    fIsSingleUserTS = GetVersionEx((OSVERSIONINFO *)&osVersionInfo) &&
        osVersionInfo.wSuiteMask & VER_SUITE_SINGLEUSERTS;

    return fIsSingleUserTS ? true : false;
}

Bool IsTerminalServerInstalled(void)
{
    const ICHAR szSearchStr[]   = TEXT("Terminal Server");          // Not localized
    const ICHAR szKey[]         = TEXT("System\\CurrentControlSet\\Control\\ProductOptions");
    const ICHAR szValue[]       = TEXT("ProductSuite");

    static BOOL     fIsWTS          = -1;
    DWORD           dwSize          = 0;
    HKEY            hkey;
    DWORD           dwType;

    // Win9X is not terminal server
    if (g_fWin9X)
        return fFalse;

    if (fIsWTS != -1)
        return fIsWTS ? fTrue : fFalse;

    fIsWTS = FALSE;

    // On NTS5, the ProductSuite "Terminal Server" value will always be present.
    // Need to call NT5-specific API to get the right answer.
    if (g_iMajorVersion > 4)
    {
        OSVERSIONINFOEX osVersionInfo;
        DWORDLONG dwlConditionMask = 0;

        osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        fIsWTS = GetVersionEx((OSVERSIONINFO *)&osVersionInfo) &&
                 (osVersionInfo.wSuiteMask & VER_SUITE_TERMINAL) &&
                 !(osVersionInfo.wSuiteMask & VER_SUITE_SINGLEUSERTS);
    }
    else
    {
        // Other NT versions, check the registry key
        // If the value we want exists and has a non-zero size...

        // Win64: whatever, since it won't run on Win64 anyway.
        if (RegOpenKeyAPI(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hkey, szValue, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS &&
                dwSize > 0)
            {
                Assert(dwType == REG_MULTI_SZ);
    
                if (dwType == REG_MULTI_SZ)
                {
                    CAPITempBuffer<ICHAR, 1> rgchSuiteList(dwSize);
                    if (RegQueryValueEx(hkey, szValue, NULL, &dwType, (unsigned char *)((ICHAR *)rgchSuiteList), &dwSize) == ERROR_SUCCESS)
                    {
                        fIsWTS = FindSzInMultiSz(rgchSuiteList, szSearchStr) != NULL;
                    }
                }
            }

            RegCloseKey(hkey);
        }
    }

    return fIsWTS ? fTrue : fFalse ;
}

extern UINT MsiGetWindowsDirectory(LPTSTR lpBuffer, UINT cchBuffer);

Bool CMsiServices::SetPlatformProperties(IMsiTable& riTable, Bool fAllUsers, isppEnum isppArchitecture, IMsiTable* piFolderCacheTable)
{
    // assume fWin9X always set properly since advertise script platform simulation never called on Win9X platform

    bool fWinNT64 = false; // init to not running on WIN64

    // determine architecture to use based on supplied isppArchitecture parameter
    // this allows us to simulate a particular architecture for architecture properties
    switch (isppArchitecture)
    {
    case isppDefault: // no simulation, use current architecture
        {
            fWinNT64 = g_fWinNT64;
            break;
        }
    case isppX86: // simulate X86 architecture
        {
            AssertSz(!g_fWin9X, TEXT("Architecture simulation is not allowed on Win9X")); 
            fWinNT64 = false;
            break;
        }
    case isppIA64: // simulate IA64 architecture
        {
            AssertSz(!g_fWin9X, TEXT("Architecture simulation is not allowed on Win9X"));
            fWinNT64 = true;
            break;
        }
    case isppAMD64: // simulate AMD64 architecture
        {
            AssertSz(!g_fWin9X, TEXT("Architecture simulation is not allowed on Win9X"));
            fWinNT64 = true;
            break;
        }
    default: // unknown architecture
        {
            Assert(0);
            return fFalse;
        }
    }

    // determine whether or not we want to cache profile shell folders
    PMsiCursor pFolderCacheCursor(0); // if this remains 0, then we aren't interested in caching profile shell folders
    if (piFolderCacheTable)
        pFolderCacheCursor = piFolderCacheTable->CreateCursor(fFalse);


    PMsiCursor pCursor(riTable.CreateCursor(fFalse));
    if (!pCursor)
        return fFalse;
    pCursor->SetFilter(1);
    CTempBuffer<ICHAR,1> rgchPath(MAX_PATH+1);
    MsiString strWindowsFolder, strUserProfileFolder, strCommonProfileFolder;

    //IPROPNAME_VERSIONSERVICES
    if (FAILED(StringCchPrintf(rgchPath, rgchPath.GetSize(), MSI_VERSION_TEMPLATE, rmj, rmm, rup, rin)))
		return fFalse;
    if (!::SetProperty(*pCursor, *MsiString(*IPROPNAME_VERSIONMSI), *MsiString(static_cast<ICHAR*>(rgchPath))))
        return fFalse;  // check one set property to insure that table is updatable

    CTempBuffer<ICHAR,1> rgchTemp(MAX_PATH+1);

    //IPROPNAME_VERSION9X : IPROPNAME_VERSIONNT
    int iOSVersion = g_iMajorVersion * 100 + g_iMinorVersion;
    if(g_fWin9X)
    {
        AssertNonZero(::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_VERSION95),iOSVersion));
        AssertNonZero(::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_VERSION9X),iOSVersion));
    }
    else
        AssertNonZero(::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_VERSIONNT),iOSVersion));
    if ( fWinNT64 )
        AssertNonZero(::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_VERSIONNT64),iOSVersion));

    //IPROPNAME_WINDOWSBUILD
    ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_WINDOWSBUILD), g_iWindowsBuild);

    HKEY hSubKey = 0;
    DWORD dwValue;
    DWORD cbValue = sizeof(dwValue);

    if (!g_fWin9X && (iOSVersion >= 500)) // NT5+
    {
        // set properties we can get from the OSVERSIONINFOEX struct - only available on NT5
        
        OSVERSIONINFOEX VersionInfoEx;
        VersionInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        AssertNonZero(GetVersionEx((LPOSVERSIONINFO) &VersionInfoEx));

        //IPROPNAME_SERVICEPACKLEVEL
        ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_SERVICEPACKLEVEL), VersionInfoEx.wServicePackMajor);
        //IPROPNAME_SERVICEPACKLEVELMINOR
        ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_SERVICEPACKLEVELMINOR), VersionInfoEx.wServicePackMinor);

        //IPROPNAME_NTPRODUCTTYPE
        ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_NTPRODUCTTYPE), VersionInfoEx.wProductType);

        //IPROPNAME_NTSUITEBACKOFFICE
        if(VersionInfoEx.wSuiteMask & VER_SUITE_BACKOFFICE)
            ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_NTSUITEBACKOFFICE), 1);

        //IPROPNAME_NTSUITEDATACENTER
        if(VersionInfoEx.wSuiteMask & VER_SUITE_DATACENTER)
            ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_NTSUITEDATACENTER), 1);

        //IPROPNAME_NTSUITEENTERPRISE
        if(VersionInfoEx.wSuiteMask & VER_SUITE_ENTERPRISE)
            ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_NTSUITEENTERPRISE), 1);

        //IPROPNAME_NTSUITESMALLBUSINESS
        if(VersionInfoEx.wSuiteMask & VER_SUITE_SMALLBUSINESS)
            ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_NTSUITESMALLBUSINESS), 1);

        //IPROPNAME_NTSUITESMALLBUSINESSRESTRICTED
        if(VersionInfoEx.wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED)
            ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_NTSUITESMALLBUSINESSRESTRICTED), 1);

        //IPROPNAME_NTSUITEPERSONAL
        if(VersionInfoEx.wSuiteMask & VER_SUITE_PERSONAL)
            ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_NTSUITEPERSONAL), 1);

        // IPROPNAME_NTSUITEWEBSERVER
        if(VersionInfoEx.wSuiteMask & VER_SUITE_BLADE)
            ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_NTSUITEWEBSERVER), 1);
    }
    else
    {
        // set the ServicePack properties on Win9X and NT4
        if (RegOpenKeyAPI(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Control\\Windows"), 0, KEY_READ, &hSubKey)
                == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hSubKey, TEXT("CSDVersion"), 0, 0, (BYTE*)&dwValue, &cbValue) == ERROR_SUCCESS &&
                 dwValue != 0)
            {
                ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_SERVICEPACKLEVEL), (dwValue & 0xFF00) >> 8);
            }
            RegCloseKey(hSubKey);
            hSubKey = 0;
        }

        // set the NTProductType property on NT4
        if(!g_fWin9X)
        {
            const ICHAR* szProductOptionsKey = TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions");
            const ICHAR* szProductTypeValue  = TEXT("ProductType");
            const ICHAR* szProductSuiteValue = TEXT("ProductSuite");
    
            DWORD dwType = 0;
            if (RegOpenKeyAPI(HKEY_LOCAL_MACHINE, szProductOptionsKey, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS)
            {
                
                cbValue = 32;
                CAPITempBuffer<ICHAR, 32> rgchProductInfoBuf;

                //IPROPNAME_NTPRODUCTTYPE
                if(MsiRegQueryValueEx(hSubKey, szProductTypeValue, NULL, &dwType, rgchProductInfoBuf, &cbValue) == ERROR_SUCCESS &&
                    dwType == REG_SZ &&
                    cbValue > 0)
                {
                    int iProductType = 0;

                    if(0 == IStrCompI(rgchProductInfoBuf, TEXT("WinNT")))
                    {
                        iProductType = VER_NT_WORKSTATION;
                    }
                    else if(0 == IStrCompI(rgchProductInfoBuf, TEXT("ServerNT")))
                    {
                        iProductType = VER_NT_SERVER;
                    }
                    else if(0 == IStrCompI(rgchProductInfoBuf, TEXT("LanmanNT")))
                    {
                        iProductType = VER_NT_DOMAIN_CONTROLLER;
                    }

                    if(iProductType)
                        ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_NTPRODUCTTYPE), iProductType);
                }

                //IPROPNAME_NTSUITEENTERPRISE
                cbValue = 32;
                if(MsiRegQueryValueEx(hSubKey, szProductSuiteValue, NULL, &dwType, rgchProductInfoBuf, &cbValue) == ERROR_SUCCESS &&
                    dwType == REG_MULTI_SZ &&
                    cbValue > 0)
                {
                    if(FindSzInMultiSz(rgchProductInfoBuf, TEXT("Enterprise")) != NULL)
                    {
                        ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_NTSUITEENTERPRISE), 1);
                    }
                }
                
                RegCloseKey(hSubKey);
                hSubKey = 0;
            }
        }
    }

    //
    // no OS simulation (during advertise script creation) occurs w.r.t. Folders (SystemFolder, System64Folder, System16Folder, etc.)
    //

    //IPROPNAME_WINDOWSDIR
    UINT windirStatus;
    AssertNonZero(windirStatus = MsiGetWindowsDirectory(rgchTemp, rgchTemp.GetSize()));
    if ( 0 == windirStatus )
        return fFalse;
    ::SetDirectoryProperty(*pCursor, IPROPNAME_WINDOWS_FOLDER, rgchTemp, rgchTemp.GetSize());
    strWindowsFolder = static_cast<ICHAR*>(rgchTemp); // hold for future use

    //IPROPNAME_WINDOWS_VOLUME
    PMsiVolume pWinVolume(0);
    PMsiRecord pErrRec(CreateVolume(rgchTemp, *&pWinVolume));
    if (pWinVolume)
    {
        MsiString strWinVolume = pWinVolume->GetPath();
        if (FAILED(StringCchCopy(rgchPath, rgchPath.GetSize(), (const ICHAR*)strWinVolume)))
			return fFalse;
        ::SetDirectoryProperty(*pCursor, IPROPNAME_WINDOWS_VOLUME, rgchPath, rgchPath.GetSize() );
    }

    // IPROPNAME_SYSTEM[64]_FOLDER
    AssertNonZero(WIN::GetSystemDirectoryW(rgchPath, rgchPath.GetSize()));
    if ( g_fWinNT64 )
    {
        ::SetDirectoryProperty(*pCursor, IPROPNAME_SYSTEM64_FOLDER, rgchPath, rgchPath.GetSize());
        StringCchCopy(rgchTemp, rgchTemp.GetSize(), rgchPath);
        PMsiPath pWowDir(0);
        if( (pErrRec = CreatePath(rgchTemp, *&pWowDir)) == 0 &&
             (pErrRec = pWowDir->ChopPiece()) == 0 &&
             (pErrRec = pWowDir->AppendPiece(*MsiString(WOW64_SYSTEM_DIRECTORY_U))) == 0)
        {
            MsiString strWowPath(pWowDir->GetPath());
            strWowPath.CopyToBuf(rgchPath, rgchPath.GetSize() - 1);
            ::SetDirectoryProperty(*pCursor, IPROPNAME_SYSTEM_FOLDER, rgchPath, rgchPath.GetSize());
        }
    }
    else
        ::SetDirectoryProperty(*pCursor, IPROPNAME_SYSTEM_FOLDER, rgchPath, rgchPath.GetSize());

    //IPROPNAME_SYSTEM16DIR
    if ( !g_fWinNT64 )
    {
        if (!g_fWin9X) // NT
        {
            //get the system directory again the last call could have been sys32x86 if WX86
            AssertNonZero(WIN::GetSystemDirectory(rgchPath, rgchPath.GetSize()));
            ICHAR* pchPath = static_cast<ICHAR*>(rgchPath) + IStrLen(rgchPath);
            Assert(pchPath[-2] == '3');
            pchPath[-2] = 0;            //"system32" less 2 chars == "system"
        }
        ::SetDirectoryProperty(*pCursor, IPROPNAME_SYSTEM16_FOLDER, rgchPath, rgchPath.GetSize());
    }

    //IPROPNAME_SHAREDWINDOWS
    if (g_fWin9X) // Win95
    {
        rgchPath[IStrLen(rgchTemp)] = 0; // make SYSTEM same length as WINDOWS
        if (IStrComp(rgchPath, rgchTemp) != 0)
            ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_SHAREDWINDOWS), 1);
    }

    //IPROPNAME_TERMSERV
    if (IsTerminalServerInstalled())
        ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_TERMSERVER), 1);

    //IPROPNAME_SINGLEUSERTS
    if (IsRemoteAdminTSInstalled())
        ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_REMOTEADMINTS), 1);

    //IPROPNAME_TEMP_FOLDER
    AssertNonZero(WIN::GetTempPathW(rgchPath.GetSize(), rgchPath));
    ::SetDirectoryProperty(*pCursor, IPROPNAME_TEMP_FOLDER, rgchPath, rgchPath.GetSize());

    if (g_fShortFileNames)
        AssertNonZero(::SetProperty(*pCursor, *MsiString(*IPROPNAME_SHORTFILENAMES), *MsiString(*TEXT("1"))));

    struct
    {
        const ICHAR*   szRegistryName;
        const ICHAR*   szFolderName;
        const ICHAR*   szPropertyName;
        /*const*/ ibtBinaryType  iBinaryType;  //?? eugend: can't explain why I cannot get it to compile w/ "const"
    } rgData32[] = {TEXT("ProgramFilesDir"), TEXT("Program Files"), IPROPNAME_PROGRAMFILES_FOLDER, ibt32bit,
                         TEXT("CommonFilesDir"),  TEXT("Common Files"),  IPROPNAME_COMMONFILES_FOLDER,  ibt32bit},
        //?? eugend: will need to fix up directory names in rgData64.  Bug # 10614 is tracking this.
      rgData64[] = {TEXT("ProgramFilesDir (x86)"), TEXT("Program Files (x86)"), IPROPNAME_PROGRAMFILES_FOLDER,   ibt32bit,
                         TEXT("CommonFilesDir (x86)"),  TEXT("Common Files (x86)"),  IPROPNAME_COMMONFILES_FOLDER,    ibt32bit,
                         TEXT("ProgramFilesDir"),   TEXT("Program Files"),    IPROPNAME_PROGRAMFILES64_FOLDER, ibt64bit,
                         TEXT("CommonFilesDir"),    TEXT("Common Files"),     IPROPNAME_COMMONFILES64_FOLDER,  ibt64bit},
      *prgData;
    int cData;
    if ( g_fWinNT64 )
    {
        prgData = rgData64;
        cData = sizeof(rgData64)/sizeof(prgData[0]);
    }
    else
    {
        prgData = rgData32;
        cData = sizeof(rgData32)/sizeof(prgData[0]);
    }

    if ( hSubKey )
    {
        Assert(0);
        hSubKey = 0;
    }
    *rgchTemp = 0;
    ibtBinaryType iCurrType = prgData[0].iBinaryType;
    for (int i=0; i < cData; i++)
    {
        LONG lResult = ERROR_FUNCTION_FAILED;
        const ICHAR rgchSubKey[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion");
        CTempBuffer<ICHAR,1> rgchFullKey(MAX_PATH);

        if ( iCurrType != prgData[i].iBinaryType )
        {
            iCurrType = prgData[i].iBinaryType;
            if ( hSubKey )
                AssertNonZero(WIN::RegCloseKey(hSubKey) == ERROR_SUCCESS), hSubKey = 0;
        }
        *rgchPath = 0;
        if ( !hSubKey )
        {
            StringCchCopy(rgchFullKey, rgchFullKey.GetSize(), TEXT("HKEY_LOCAL_MACHINE"));
			if ( g_fWinNT64 )
				StringCchCat(rgchFullKey, rgchFullKey.GetSize(), iCurrType == ibt64bit ? TEXT("64") : TEXT("32"));
				
			StringCchCat(rgchFullKey, rgchFullKey.GetSize(), szRegSep);
			StringCchCat(rgchFullKey, rgchFullKey.GetSize(), rgchSubKey);
			if ( g_fWinNT64 )
				lResult = RegOpenKeyAPI(HKEY_LOCAL_MACHINE,
										rgchSubKey, 0,
										KEY_READ | (iCurrType == ibt64bit ? KEY_WOW64_64KEY : KEY_WOW64_32KEY),
										&hSubKey);
			else
				lResult = RegOpenKeyAPI(HKEY_LOCAL_MACHINE,
										rgchSubKey, 0, KEY_READ, &hSubKey);
			if ( lResult != ERROR_SUCCESS )
				pErrRec = PostError(Imsg(imsgOpenKeyFailed), rgchFullKey, lResult);
        }

        if ( hSubKey )
        {
            cbValue = rgchPath.GetSize()*sizeof(ICHAR);
            lResult = WIN::RegQueryValueEx(hSubKey, prgData[i].szRegistryName, 0, 0, (BYTE*)static_cast<ICHAR*>(rgchPath), &cbValue);
            if ( lResult != ERROR_SUCCESS )
                pErrRec = PostError(Imsg(imsgGetValueFailed), prgData[i].szRegistryName, rgchFullKey, lResult);
        }
        if ( lResult != ERROR_SUCCESS || rgchPath[0] == 0 )
        {
            if ( !*rgchTemp )
            {
                MsiGetWindowsDirectory(rgchTemp, rgchTemp.GetSize());
                
                int cchTemp = IStrLen(rgchTemp);
                ICHAR* pchBuf = static_cast<ICHAR*>(rgchTemp) + cchTemp;
                if (pchBuf[-1] != chDirSep)
                {
                    pchBuf[0] = chDirSep;
                    if (cchTemp < rgchTemp.GetSize()-1)
                        pchBuf[1] = 0;
                    else
                        pchBuf[0] = 0;
                }
            }
            StringCchPrintf(rgchPath, rgchPath.GetSize(), TEXT("%s%s"), static_cast<const ICHAR*>(rgchTemp), prgData[i].szFolderName);
        }
        ::SetDirectoryProperty(*pCursor, prgData[i].szPropertyName, rgchPath, rgchPath.GetSize());
    }
    if ( hSubKey )
        AssertNonZero(WIN::RegCloseKey(hSubKey) == ERROR_SUCCESS), hSubKey = 0;

    // shell folders
    PMsiRecord pError(0);
    MsiString strFolder;
    const ShellFolder* pShellFolder = 0;

    for(i=0;i<3;i++)
    {
        if(i == 0)
        {
            pShellFolder = rgShellFolders;
        }
        else if (i == 1)
        {
            if(fAllUsers)
            {
                pShellFolder = rgAllUsersProfileShellFolders;
            }
            else
            {
                pShellFolder = rgPersonalProfileShellFolders;
            }
        }
        else if (i == 2)
        {
            // the purpose of this is to update the FolderCache table with all of the profile shell folders
            // for use when ALLUSERS is changed in the UI sequence (per bug 169494).  does not apply to Win9X

            if (!pFolderCacheCursor || g_fWin9X)
                continue; // nothing to do, we aren't concerned with this case

            if (fAllUsers)
            {
                // choose opposite of previous
                pShellFolder = rgPersonalProfileShellFolders;
            }
            else
            {
                // choose opposite of previous
                pShellFolder = rgAllUsersProfileShellFolders;
            }
        }
        Assert(pShellFolder);
        for (; pShellFolder->iFolderId >= 0; pShellFolder++)
        {
            pError = GetShellFolderPath(pShellFolder->iFolderId,pShellFolder->szRegValue,*&strFolder, true);
            if(!pError && strFolder.TextSize())
            {
                strFolder.CopyToBuf(rgchPath, rgchPath.GetSize() - 1);
                if (i != 2)
                {
                    ::SetDirectoryProperty(*pCursor, pShellFolder->szPropName, rgchPath, rgchPath.GetSize());
                }

                if (pFolderCacheCursor)
                {
                    ::CacheFolderProperty(*pFolderCacheCursor, pShellFolder->iFolderId, rgchPath, rgchPath.GetSize());
                }

                // this may create the folder if it didn't already exist.  This can get rather
                // ugly, so we'll nuke it.

                // RemoveDirectory only removes it if the directory is EMPTY and we have
                // delete access.

                // if it fails, might not be empty, in any event, we don't care 
                // - but we need to notify the shell of all shell folder removals
                if(pShellFolder->fDeleteIfEmpty && WIN::RemoveDirectory(rgchPath))
                {
                    //
                    // Notify the shell of folder removal/ creation
                    // Use the SHCNF_FLUSHNOWAIT flag because the SHCNF_FLUSH flag
                    // is synchronous and can result in hangs (bug 424877)
                    //
                    DEBUGMSGVD1(TEXT("SHChangeNotify SHCNE_RMDIR: %s"), rgchPath);
                    SHELL32::SHChangeNotify(SHCNE_RMDIR,SHCNF_PATH|SHCNF_FLUSHNOWAIT,rgchPath,0);
                }
            }
        }
    }

    // IPROPNAME_TEMPLATE_FOLDER
    // if AllUsers is true, TemplateFolder should point to Common Templates. This is only true on Win2000, so
    // can't use the array above.
    if (fAllUsers && !g_fWin9X && g_iMajorVersion >= 5)
    {
        pError = GetShellFolderPath(CSIDL_COMMON_TEMPLATES, TEXT("Common Templates"), *&strFolder);
        if(!pError && strFolder.TextSize())
        {
            strFolder.CopyToBuf(rgchPath, rgchPath.GetSize() - 1);
            ::SetDirectoryProperty(*pCursor, IPROPNAME_TEMPLATE_FOLDER, rgchPath, rgchPath.GetSize());
        }
    }
    // IPROPNAME_FONTS_FOLDER
    GetFontFolderPath(*&strFolder);
    if(strFolder.TextSize())
    {
        strFolder.CopyToBuf(rgchPath, rgchPath.GetSize() - 1);
        ::SetDirectoryProperty(*pCursor, IPROPNAME_FONTS_FOLDER, rgchPath, rgchPath.GetSize());
    }

    // set properties for advertising support

    if(IsDarwinDescriptorSupported(iddOLE))
    {
        AssertNonZero(::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_GPT_SUPPORT), 1)); // obsolete: for legacy support only
        AssertNonZero(::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_OLEADVTSUPPORT), 1));
    }

    if(IsDarwinDescriptorSupported(iddShell))
        AssertNonZero(::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_SHELLADVTSUPPORT), 1));

    ::SetProcessorProperty(*pCursor, fWinNT64); // some ugly code in here

    // try GlobalMemoryStatusEx first (only supported on Win2K and above)
    // then GlobalMemoryStatus if that fails
    MEMORYSTATUSEX memorystatusex;
    memset(&memorystatusex, 0, sizeof(MEMORYSTATUSEX));
    memorystatusex.dwLength = sizeof(MEMORYSTATUSEX);
    if(KERNEL32::GlobalMemoryStatusEx(&memorystatusex))
    {
        AssertNonZero(::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_PHYSICALMEMORY), (int)(INT_PTR)((memorystatusex.ullTotalPhys+650000)>>20)));  //!!merced: Converting arg 3 from PTR to INT
        AssertNonZero(::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_VIRTUALMEMORY), (int)(INT_PTR)(memorystatusex.ullAvailPageFile>>20)));        //!!merced: Converting arg 3 from PTR to INT
    }
    else
    {
        MEMORYSTATUS memorystatus;
        memset(&memorystatus, 0, sizeof(MEMORYSTATUS));
        memorystatus.dwLength = sizeof(MEMORYSTATUS);
        ::GlobalMemoryStatus((MEMORYSTATUS*)&memorystatus);

        AssertNonZero(::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_PHYSICALMEMORY), (int)(INT_PTR)((memorystatus.dwTotalPhys+650000)>>20)));  //!!merced: Converting arg 3 from PTR to INT
        AssertNonZero(::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_VIRTUALMEMORY), (int)(INT_PTR)(memorystatus.dwAvailPageFile>>20)));        //!!merced: Converting arg 3 from PTR to INT
    }

    // User info

    if (IsAdmin())
        ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_ADMINUSER), 1);

    DWORD dwLength = rgchPath.GetSize();

    // impersonate for user properties
    AssertNonZero(StartImpersonating());
    dwLength = rgchPath.GetSize();

    if (WIN::GetUserName(rgchPath, &dwLength))
        ::SetProperty(*pCursor, *MsiString(*IPROPNAME_LOGONUSER), *MsiString(static_cast<ICHAR*>(rgchPath)));

    if(!g_fWin9X)
    {
        MsiString strUserSID;
        AssertNonZero(GetCurrentUserStringSID(*&strUserSID) == ERROR_SUCCESS);
        ::SetProperty(*pCursor, *MsiString(*IPROPNAME_USERSID), *strUserSID);
    }

    ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_USERLANGUAGEID), WIN::GetUserDefaultLangID());

    StopImpersonating();

    dwLength = rgchPath.GetSize();
    if (WIN::GetComputerName(rgchPath, &dwLength))
        ::SetProperty(*pCursor, *MsiString(*IPROPNAME_COMPUTERNAME), *MsiString(static_cast<ICHAR*>(rgchPath)));

    ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_SYSTEMLANGUAGEID), WIN::GetSystemDefaultLangID());
    ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_SCREENX), GetSystemMetrics(SM_CXSCREEN));
    ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_SCREENY), GetSystemMetrics(SM_CYSCREEN));
    ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_CAPTIONHEIGHT), GetSystemMetrics(SM_CYCAPTION));
    ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_BORDERTOP), GetSystemMetrics(SM_CXBORDER));
    ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_BORDERSIDE), GetSystemMetrics(SM_CYBORDER));

    HDC hDC = GetDC(NULL);
    if (hDC)
    {
        TEXTMETRIC tm;
        ICHAR rgchFaceName[LF_FACESIZE];
        static const ICHAR szReferenceFont[] = TEXT("MS Sans Serif");
#ifdef DEBUG
        AssertNonZero(WIN::GetTextFace(hDC, sizeof(rgchFaceName)/sizeof(rgchFaceName[0]), rgchFaceName));
        int iFontDPI = WIN::GetDeviceCaps(hDC, LOGPIXELSY);
#endif
        LOGFONT lf;
        memset(&lf, 0, sizeof(lf));
        lf.lfHeight = -MulDiv(10, WIN::GetDeviceCaps(hDC, LOGPIXELSY), 72);
        Assert(lf.lfHeight != 1);
        lf.lfWeight = FW_NORMAL;
        StringCchCopy(lf.lfFaceName,  (sizeof(lf.lfFaceName)/sizeof(ICHAR)), szReferenceFont);
        HFONT hFont = WIN::CreateFontIndirect(&lf);
        Assert(hFont);
        HFONT hOldFont = (HFONT)WIN::SelectObject(hDC, hFont);
        AssertNonZero(WIN::GetTextFace(hDC, sizeof(rgchFaceName)/sizeof(rgchFaceName[0]), rgchFaceName));
        WIN::GetTextMetrics(hDC, &tm);
        pError = PostError(Imsg(idbgCreatedFont), *MsiString(szReferenceFont),
                                 *MsiString(rgchFaceName), lf.lfCharSet, tm.tmHeight);
#ifdef DEBUG
        DEBUGMSGV((const ICHAR*)MsiString(pError->FormatText(fTrue)));
#endif

        WIN::SelectObject(hDC, hOldFont);
        if ( hFont )
            WIN::DeleteObject(hFont);
        ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_TEXTHEIGHT), tm.tmHeight);
        ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_COLORBITS), ::GetDeviceCaps(hDC, BITSPIXEL));
    }
    ReleaseDC(NULL, hDC);

    // TTC Support
    bool fTTCSupport = (g_fWin9X == false) && (g_iMajorVersion >= 5);

    if (!fTTCSupport)
    {
        int iCodePage = WIN::GetACP();
        switch (iCodePage)
        {
        case 932: // JPN
        case 950: // Taiwan
        case 936: // China
        case 949: // Korea
            fTTCSupport = true;
        }
    }

    if (fTTCSupport)
    {
        AssertNonZero(::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_TTCSUPPORT), 1));
    }


    // set the IPROPNAME_NETASSEMBLYSUPPORT, IPROPNAME_WIN32ASSEMBLYSUPPORT

    extern bool MakeFusionPath(const ICHAR* szFile, ICHAR* szFullPath, size_t cchFullPath);

    CTempBuffer<ICHAR,1> rgchVersion(MAX_PATH+1);
    DWORD dwVersionSize = rgchVersion.GetSize();
    CTempBuffer<ICHAR,1> rgchFullPath(MAX_PATH+1);
    
    if (MakeFusionPath(TEXT("fusion.dll"), rgchFullPath, rgchFullPath.GetSize()) && 
        (ERROR_SUCCESS == MsiGetFileVersion(rgchFullPath, rgchVersion, &dwVersionSize, 0, 0)))
        ::SetProperty(*pCursor, *MsiString(*IPROPNAME_NETASSEMBLYSUPPORT), *MsiString(static_cast<ICHAR*>(rgchVersion)));

    dwVersionSize = rgchVersion.GetSize();
    if (MakeFullSystemPath(TEXT("sxs"), rgchFullPath, rgchFullPath.GetSize()) && 
        (ERROR_SUCCESS == MsiGetFileVersion(rgchFullPath, rgchVersion, &dwVersionSize, 0, 0)))
    {
        ::SetProperty(*pCursor, *MsiString(*IPROPNAME_WIN32ASSEMBLYSUPPORT), *MsiString(static_cast<ICHAR*>(rgchVersion)));
        ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_REDIRECTEDDLLSUPPORT), 2); // super isolated components support
    }
    else if(MinimumPlatform(true, 4, 1) || MinimumPlatform(false, 5, 0)) // >= Win98 or Win2K, Redirected DLL loader support
    {
        ::SetPropertyInt(*pCursor, *MsiString(*IPROPNAME_REDIRECTEDDLLSUPPORT), 1); // .local based isolated components support
    }

    // time and date dynamic properties
    ::SetProperty(*pCursor, *MsiString(*IPROPNAME_TIME), g_MsiStringTime);
    ::SetProperty(*pCursor, *MsiString(*IPROPNAME_DATE), g_MsiStringDate);
    return fTrue;
}

extern bool RunningAsLocalSystem();
IMsiRecord* CMsiServices::GetShellFolderPath(int iFolder, bool fAllUsers, const IMsiString*& rpistrPath, bool bAvoidFolderCreation /* = false*/)
{
    const ShellFolder* pShellFolder = 0;
    bool fFound = false;

    // find correct ShellFolder
    for(int i=0;i<2 && !fFound;i++)
    {
        if(i == 0)
        {
            pShellFolder = rgShellFolders;
        }
        else
        {
            if(fAllUsers)
            {
                pShellFolder = rgAllUsersProfileShellFolders;
            }
            else
            {
                pShellFolder = rgPersonalProfileShellFolders;
            }
        }
        Assert(pShellFolder);
        for (; pShellFolder->iFolderId >= 0; pShellFolder++)
        {
            if(iFolder == pShellFolder->iFolderId)
            {
                fFound = true;
                break;
            }
        }
    }
    if(pShellFolder->iFolderId < 0) // we do not know this id
    {
        return PostError(Imsg(idbgMissingShellFolder), iFolder);
    }
    return GetShellFolderPath(iFolder, pShellFolder->szRegValue, rpistrPath, bAvoidFolderCreation);
}

IMsiRecord* CMsiServices::GetShellFolderPath(int iFolder, const ICHAR* szRegValue,
                                                            const IMsiString*& rpistrPath, bool bAvoidFolderCreation /* = false */)
{
    PMsiRegKey pHKLM(0), pHKCU(0), pLMUserShellFolders(0), pLMShellFolders(0), pCUUserShellFolders(0),
                  pCUShellFolders(0);

    CTempBuffer<ICHAR,MAX_PATH> rgchPath;
    PMsiRecord pError(0); // used to catch errors - don't return
    MsiString strPath;
    UINT csidl_flags;

    // First try SHELL32::SHGetFolderPath. It became available in NT5.
    // Next try SHFOLDER::SHGetFolderPath. It is installed by Darwin on non-NT5 machines.
    
    //
    // Also, if bAvoidFolderCreation is set, then we should try to get the path to the shell special
    // folder without creating it if possible. This is only possible on Win2K and higher since we can
    // pass in the CSIDL_FLAG_DONT_VERIFY flag (which is only defined on Win2K and higher) and not 
    // pass in the CSIDL_FLAG_CREATE flag. Note that SHGetFolderPath from shfolder.dll does not recognize
    // the CSIDL_FLAG_DONT_VERIFY flag, so we cannot use it in that case. But we never should have to
    // use that flag on Win2K and higher since we already have shell32.dll on those platforms.
    //
    if (bAvoidFolderCreation && (MinimumPlatformWindows2000()))
        csidl_flags = CSIDL_FLAG_DONT_VERIFY;
    else
        csidl_flags = CSIDL_FLAG_CREATE;

    for(int i = 0; i < 2; i++)
    {
        AssertNonZero(StartImpersonating());
        MsiDisableTimeout(); // these APIs sometimes take an inordinant amount of time
        HRESULT hRes;

        // the hToken argument to SHGetFolderPath must be 0 on non-NT5 machines.
        if(!i)
            hRes = SHELL32::SHGetFolderPath(0, iFolder | csidl_flags, (!g_fWin9X && g_iMajorVersion >= 5) ? GetUserToken() : 0, 0, rgchPath);
        else
            hRes = SHFOLDER::SHGetFolderPath(0, iFolder | CSIDL_FLAG_CREATE, (!g_fWin9X && g_iMajorVersion >= 5) ? GetUserToken() : 0, 0, rgchPath);

        MsiEnableTimeout();
        if (ERROR_SUCCESS == hRes)
        {
            DEBUGMSGV1(!i?TEXT("SHELL32::SHGetFolderPath returned: %s") : TEXT("SHFOLDER::SHGetFolderPath returned: %s"), rgchPath);
            strPath = (ICHAR*)rgchPath;
        }
        StopImpersonating();

        if(strPath.TextSize())
            break;
    }

    // Next try SHGetSpecialFolderLocation. This API doesn't handle multiple users gracefully
    // so we can't use this when we're running as a service (the service remains running
    // across user logins). This is true both when we're in the Darwin service and when
    // we're loaded in-proc by WinLogon

    if (!strPath.TextSize() && !RunningAsLocalSystem())
    {
        LPITEMIDLIST pidlFolder; // NOT ITEMIDLIST*, LPITEMIDLIST is UNALIGNED ITEMIDLIST*
        CComPointer<IMalloc> pMalloc(0);
        if (SHELL32::SHGetMalloc(&pMalloc) == NOERROR)
        {
            MsiDisableTimeout(); // these APIs sometimes take an inordinant amount of time
            if(SHELL32::SHGetSpecialFolderLocation(0, iFolder, &pidlFolder) == NOERROR)
            {
                if (SHELL32::SHGetPathFromIDList(pidlFolder, rgchPath))
                {
                    DEBUGMSGV1(TEXT("SHGetSpecialFolderLocation returned: %s"), rgchPath);
                    strPath = (ICHAR*)rgchPath;
                }
                pMalloc->Free(pidlFolder);
            }
            MsiEnableTimeout();
        }
    }

    // If we *still* haven't been able to get the special folder location
    // then we'll have to spelunk through the registry and find it ourselves

    if(!strPath.TextSize() && szRegValue && *szRegValue)
    {
        Bool fAllUsersFolder = fFalse;
        int cAllUsersFolders = sizeof(rgAllUsersProfileShellFolders)/sizeof(ShellFolder);
        for(int i = 0; i < cAllUsersFolders; i++)
        {
            if(iFolder == rgAllUsersProfileShellFolders[i].iFolderId)
            {
                fAllUsersFolder = fTrue;
                break;
            }
        }
        if(fAllUsersFolder)
        {
            // set HKLM
            pHKLM = &GetRootKey(rrkLocalMachine);
            if(((pLMUserShellFolders = &pHKLM->CreateChild(REGKEY_USERSHELLFOLDERS)) != 0) &&
                ((pError = pLMUserShellFolders->GetValue(szRegValue,*&strPath)) == 0) &&
                strPath.TextSize())
            {
                // found it
            }
            else if(((pLMShellFolders = &pHKLM->CreateChild(REGKEY_SHELLFOLDERS)) != 0) &&
                      ((pError = pLMShellFolders->GetValue(szRegValue,*&strPath)) == 0) &&
                      strPath.TextSize())
            {
                // found it
            }
        }
        else
        {
            // looking for personal folder
            // set HKCU
            if(RunningAsLocalSystem())
            {
                PMsiRegKey pHKU = &GetRootKey(rrkUsers);
                MsiString strSID;
                AssertNonZero(StartImpersonating());
                if(ERROR_SUCCESS == ::GetCurrentUserStringSID(*&strSID))
                {
                    pHKCU = &pHKU->CreateChild(strSID);
                }
                StopImpersonating();
            }
            else
                pHKCU = &GetRootKey(rrkCurrentUser);

            if(pHKCU)
            {
                if(((pCUUserShellFolders = &pHKCU->CreateChild(REGKEY_USERSHELLFOLDERS)) != 0) &&
                    ((pError = pCUUserShellFolders->GetValue(szRegValue,*&strPath)) == 0) &&
                    strPath.TextSize())
                {
                    // found it
                }
                else if(((pCUShellFolders = &pHKCU->CreateChild(REGKEY_SHELLFOLDERS)) != 0) &&
                          ((pError = pCUShellFolders->GetValue(szRegValue,*&strPath)) == 0) &&
                          strPath.TextSize())
                {
                    // found it
                }
            }
        }

        DEBUGMSGV1(TEXT("Found shell folder %s by spelunking through the registry."), strPath);
    }

    if(strPath.Compare(iscStart,TEXT("#%"))) // REG_EXPAND_SZ
    {
        strPath.Remove(iseFirst,2);
        if(RunningAsLocalSystem())
        {
            // service and clients running from WinLogon cannot expand the USERPROFILE environment
            // variable to the correct folder.
            // we need to call GetUserProfilePath instead
            if((strPath.Compare(iscStart,TEXT("%USERPROFILE%"))) != 0)
            {
                MsiString strEndPath = strPath.Extract(iseLast,strPath.CharacterCount() - 13 /* length of "%USERPROFILE%"*/);
                if(strEndPath.Compare(iscStart,szDirSep))
                    strEndPath.Remove(iseFirst,1);
                strPath = GetUserProfilePath();
                if(strPath.TextSize())
                {
                    Assert(strPath.Compare(iscEnd,szDirSep));
                    strPath += strEndPath;
                }
            }
        }
        GetEnvironmentStrings(strPath,rgchPath);
        strPath = (ICHAR*)rgchPath;
    }

    if(strPath.TextSize() == 0)
        return PostError(Imsg(idbgMissingShellFolder),iFolder);

    if(strPath.Compare(iscEnd,szDirSep) == 0)
        strPath += szDirSep;
    strPath.ReturnArg(rpistrPath);
    return 0;
}

const IMsiString& CMsiServices::GetUserProfilePath()
{
    typedef BOOL (WINAPI *pfnGetUserProfileDirectory)(HANDLE hToken, TCHAR* szProfilePath, LPDWORD lpdwSize);
    pfnGetUserProfileDirectory pGetUserDir;
    HINSTANCE hInstUserEnv;
    BOOL fSuccess = FALSE;
    CTempBuffer<ICHAR,MAX_PATH> rgchBuffer;
    rgchBuffer[0] = 0;
    if(!RunningAsLocalSystem())
    {
        // try expanding the USERPROFILE env variable
        const ICHAR* szUserProfile = TEXT("%USERPROFILE%");
        GetEnvironmentStrings(szUserProfile,rgchBuffer);
        if((ICHAR *)rgchBuffer && rgchBuffer[0] && IStrComp(szUserProfile,rgchBuffer) != 0)
            fSuccess = TRUE;
    }
    if(fSuccess == FALSE && (hInstUserEnv = WIN::LoadLibrary(TEXT("USERENV.DLL"))) != 0)
    {
        // try GetUserProfile, which returns the correct profile even when called from the service
#ifdef UNICODE
#define GETUSERPROFILEDIRECTORY "GetUserProfileDirectoryW"
#else
#define GETUSERPROFILEDIRECTORY "GetUserProfileDirectoryA"
#endif
        HANDLE hUserToken;

        if (g_scServerContext == scService)
            StartImpersonating();
        if (((hUserToken = GetUserToken()) != 0)
        && (pGetUserDir = (pfnGetUserProfileDirectory)WIN::GetProcAddress(hInstUserEnv, GETUSERPROFILEDIRECTORY)) != 0)
        {
            DWORD dwSize = rgchBuffer.GetSize();
            fSuccess = (*pGetUserDir)(hUserToken, (ICHAR*)rgchBuffer, &dwSize);
        }
        WIN::FreeLibrary(hInstUserEnv);
        if (g_scServerContext == scService)
            StopImpersonating();

    }
    MsiString strPath;
    if(fSuccess)
    {
        Assert(rgchBuffer[0]);
        strPath = (const ICHAR*)rgchBuffer;
        if(rgchBuffer[strPath.TextSize()-1] != chDirSep)
        {
            strPath += szDirSep;
        }
    }
    return strPath.Return();
}

//____________________________________________________________________________
//
// Language handling
//____________________________________________________________________________

isliEnum CMsiServices::SupportLanguageId(int iLangId, Bool fSystem)
{
    int iSysLang = fSystem ? WIN::GetSystemDefaultLangID() : WIN::GetUserDefaultLangID();
    if (iSysLang == iLangId)
        return isliExactMatch;
    if (PRIMARYLANGID(iSysLang) == iLangId)
        return isliLanguageOnlyMatch;
    if (PRIMARYLANGID(iSysLang) == PRIMARYLANGID(iLangId))
        return isliDialectMismatch;
    if (WIN::GetLocaleInfo(iLangId, LOCALE_SABBREVLANGNAME, 0, 0) != 0)
        return isliLanguageMismatch;
    return isliNotSupported;
}

//____________________________________________________________________________
//
// Log handling
//____________________________________________________________________________

Bool CMsiServices::CreateLog(const ICHAR* szFile, Bool fAppend)
{
    return SRV::CreateLog(szFile, fAppend != 0) ? fTrue : fFalse;
}

Bool CMsiServices::LoggingEnabled()
{
    return SRV::LoggingEnabled() ? fTrue : fFalse;
}

Bool CMsiServices::WriteLog(const ICHAR* szText) // cannot allocate memory
{
    return SRV::WriteLog(szText) ? fTrue : fFalse;
}


//!! This routine should really be in path.cpp

const IMsiString& CMsiServices::GetLocalPath(const ICHAR* szFile)
{
    const IMsiString* piStr = &CreateString();
    if (!szFile || !((szFile[0]=='\\' && szFile[1]=='\\') || szFile[1]==':'))
    {
        ICHAR rgchBuf[MAX_PATH];
        int cchName = GetModuleFileName(g_hInstance, rgchBuf, (sizeof(rgchBuf)/sizeof(ICHAR))-1);
        rgchBuf[(sizeof(rgchBuf)/sizeof(ICHAR))-1] = 0;
        ICHAR* pch = rgchBuf + cchName;
        if (cchName)
        {
            while (*(--pch) != chDirSep)
                ;
        }
        if (szFile)
            StringCchCopy(pch+1, (rgchBuf+(sizeof(rgchBuf)/sizeof(ICHAR))-pch-1), szFile);
        else
            *pch = 0;
        szFile = rgchBuf;
    }
    piStr->SetString(szFile, piStr);
    return *piStr;
}

IMsiRecord* CMsiServices::ExtractFileName(const ICHAR *szFileName, Bool fLFN,
                                                        const IMsiString*& rpistrExtractedFileName)
/*----------------------------------------------------------------------------
Extracts a short or long file name, based on fLFN, from szFileName. szFileName
is of the form-> shortFileName OR longFileName OR shortFileName|longFileName.
The file name is validated for proper syntax
----------------------------------------------------------------------------*/
{
    IMsiRecord* piError = 0;
    MsiString strCombinedFileName(szFileName);
    MsiString strFileName = strCombinedFileName.Extract(fLFN ? iseAfter : iseUpto,
                                                                         chFileNameSeparator);
    if((piError = ValidateFileName(strFileName,fLFN)) != 0)
        return piError;
    strFileName.ReturnArg(rpistrExtractedFileName);
    return NOERROR;
}

IMsiRecord* CMsiServices::ValidateFileName(const ICHAR *szFileName, Bool fLFN)

// ------------------------------------
// Might be a DBCS string
{
    ifvsEnum ifvs = CheckFilename(szFileName, fLFN);
    switch (ifvs)
    {
    case ifvsValid: return 0;
    case ifvsReservedChar: return PostError(Imsg(imsgFileNameHasReservedChars), szFileName, 1);
    case ifvsReservedWords: return PostError(Imsg(imsgFileNameHasReservedWords), szFileName);
    case ifvsInvalidLength: return PostError(Imsg(imsgErrorFileNameLength), szFileName);
    case ifvsSFNFormat: return PostError(Imsg(imsgInvalidShortFileNameFormat), szFileName);
    case ifvsLFNFormat: return PostError(Imsg(imsgFileNameHasReservedChars), szFileName, 1);
    default: Assert(0); return PostError(Imsg(imsgErrorFileNameLength), szFileName);
    }
}

IMsiRecord* CMsiServices::GetModuleUsage(const IMsiString& strFile, IEnumMsiRecord*& rpaEnumRecord)
{
    return ::GetModuleUsage(strFile, rpaEnumRecord, *this, m_pDetectApps);
}

BOOL CMsiServices::ReadLineFromFile(HANDLE hFile, ICHAR* szBuffer, int cchBufSize, int* iBytesRead)
{
    DWORD dwBytesRead;
    int cch=0;
    ICHAR ch;

    if (!hFile)
        return FALSE;

    *iBytesRead = 0;
    while ( ReadFile(hFile, &ch, sizeof(ICHAR), &dwBytesRead, NULL) && dwBytesRead && (cch < cchBufSize))
    {
        if (dwBytesRead == 0)
        {
            szBuffer[cch] = '\0';
            return TRUE;
        }

        if (ch == '\n')
        {
            szBuffer[cch] = '\0';
            return TRUE;
        }
        else if (ch == '\r')
        {
            continue;
        }
        else
        {
            *iBytesRead += dwBytesRead;
            szBuffer[cch] = ch;
            cch++;
        }
    }
    return FALSE;
}


//____________________________________________________________________________
//
// Font handling
//____________________________________________________________________________

void CMsiServices::GetFontFolderPath(const IMsiString*& rpistrFolder)
{
    const ICHAR FONTDIR[] = TEXT("Fonts");
    MsiString strPath;
    PMsiRecord pError = GetShellFolderPath(CSIDL_FONTS, FONTDIR, *&strPath);
    if(pError || !strPath.TextSize())
    {
        CTempBuffer<ICHAR,MAX_PATH> rgchPath;
        if (MsiGetWindowsDirectory(rgchPath, rgchPath.GetSize()))
        {
            unsigned int cchDirLength =IStrLen(rgchPath);
            strPath = (ICHAR*)rgchPath;
            if ((cchDirLength > 0) && (rgchPath[cchDirLength-1] != chDirSep))
            {
                strPath += szDirSep;
            }
            strPath += FONTDIR;
        }
    }
    strPath.ReturnArg(rpistrFolder);
}

IMsiRecord* CMsiServices::RegisterFont(const ICHAR* szFontTitle, const ICHAR* szFontFile,
                                                    IMsiPath* piPath, bool fInUse)
{
    IMsiRecord* piError = 0;
    Assert((szFontTitle) && (*szFontTitle) && (szFontFile) && (*szFontFile));

    // get default font folder path
    PMsiPath pFontFolder(0);
    MsiString strFolder;
    GetFontFolderPath(*&strFolder);
    if((piError = CreatePath(strFolder,*&pFontFolder)) != 0)
        return piError;

    MsiString strFile = szFontFile;
    if(piPath)
    {
        ipcEnum aCompare;
        if(((piError = pFontFolder->Compare(*piPath, aCompare)) == 0) && aCompare != ipcEqual)
        {
            // register font with full file path
            Assert(piError == 0);
            if((piError = piPath->GetFullFilePath(szFontFile,*&strFile)) != 0)
                return piError;
        }
        if(piError)
        {
            piError->Release();
            piError = 0;
        }
    }

    const ICHAR* szKey = g_fWin9X ? REGKEY_WIN_95_FONTS : REGKEY_WIN_NT_FONTS;

    PMsiRegKey piRegKeyRoot = &GetRootKey(rrkLocalMachine);
    PMsiRegKey piRegKey = &(piRegKeyRoot->CreateChild(szKey));

    MsiString strCurrentFont;
    piError =  piRegKey->GetValue(szFontTitle, *&strCurrentFont);
    if(piError)
        return piError;

    // previous font exists ?
    if(!fInUse && 0 != strCurrentFont.TextSize())
    {
		PMsiRecord pRecError = UnRegisterFont(szFontTitle);
    }
    piError =  piRegKey->SetValue(szFontTitle, *strFile);
    if(piError)
        return piError;
    // update Windows font table entry and inform other apps.
    if(!fInUse)
    {
		WIN::AddFontResource(strFile);
    }
    return piError;
}

IMsiRecord* CMsiServices::UnRegisterFont(const ICHAR* pFontTitle)
{
    Assert((pFontTitle) && (*pFontTitle));

    const ICHAR* szKey = g_fWin9X ? REGKEY_WIN_95_FONTS : REGKEY_WIN_NT_FONTS;

    PMsiRegKey piRegKeyRoot(0);
    piRegKeyRoot = &GetRootKey(rrkLocalMachine);

    PMsiRegKey piRegKey(0);
    IMsiRecord* piError;

    piRegKey = &(piRegKeyRoot->CreateChild(szKey));
    MsiString astrReturn;
    piError =  piRegKey->GetValue(pFontTitle, *&astrReturn);
    if(piError)
        return piError;

    // font previously exists ?
    if(0 != astrReturn.TextSize())
    {
        piError = piRegKey->RemoveValue(pFontTitle, 0);
        if(piError)
            return piError;

		WIN::RemoveFontResource(astrReturn);
    }
    return piError;
}

IMsiRegKey& CMsiServices::GetRootKey(rrkEnum erkRoot, const ibtBinaryType iType/*=ibtCommon*/)
{
    return ::GetRootKey(m_rootkH, erkRoot, iType);
}

IUnknown* CreateCOMInterface(const CLSID& clsId)
{
    HRESULT hres;
    IUnknown* piunk;

    //!! currently assumes static linking, later change to "LoadLibrary"

/*
    if(fFalse == m_fCoInitialized)
    {
        hres = OLE32::CoInitialize(0);
        if(FAILED(hres))
        {
            return 0;
        }
        m_fCoInitialized = fTrue;
    }
*/
    hres = OLE32::CoCreateInstance(clsId,
                            0,
                            CLSCTX_INPROC_SERVER,
                            IID_IUnknown,
                            (void**)&piunk);
    if (SUCCEEDED(hres))
        return piunk;
    else
        return 0;
}


// WIN specific private functions to read/ write to .INI file
IMsiRecord* CMsiServices::ReadLineFromIni(  IMsiPath* piPath,
                                            const ICHAR* pszFile,
                                            const ICHAR* pszSection,
                                            const ICHAR* pszKey,
                                            unsigned int iField,
                                            CTempBufferRef<ICHAR>& pszBuffer)
{
    int cchErrorMoreDataIndicator = (!pszSection || !pszKey) ? 2 : 1;
    int icurrLen = 100;
    IMsiRecord* piError = 0;
    MsiString astrFile = pszFile;
    ICHAR* pszDefault = TEXT("");
    Bool fWinIni;
    if((!IStrCompI(pszFile, WIN_INI)) && (piPath == 0))
    {
        // WIN.INI
        fWinIni = fTrue;
    }
    else
    {
        // not WIN.INI
        fWinIni = fFalse;
        if(piPath != 0)
        {
            piError = piPath->GetFullFilePath(pszFile, *&astrFile);
            if(piError != 0)
                return piError;
        }
    }
    
    // if the .INI file is on a network drive, we need to impersonate before calling
    // GetPrivateProfileString API.
    bool fToImpersonate = false;
    if ( RunningAsLocalSystem() &&
          (piPath != 0 && (GetImpersonationFromPath(astrFile) == fTrue)) )
        fToImpersonate = true;

    for(;;)
    {
        pszBuffer.SetSize(icurrLen); // add space to append new value
        if ( ! (ICHAR *)pszBuffer )
            return PostError(Imsg(idbgErrorOutOfMemory));
        int iret;
        if(fWinIni)
        {
            iret = GetProfileString(pszSection,       // address of section name
                                    pszKey,   // address of key name
                                    pszDefault,       // address of default string
                                    pszBuffer,        // address of destination buffer
                                    icurrLen); // size of destination buffer
        }
        else
        {
            CImpersonate(fToImpersonate);
            iret = GetPrivateProfileString( pszSection,       // address of section name
                                            pszKey,   // address of key name
                                            pszDefault,       // address of default string
                                            pszBuffer,        // address of destination buffer
                                            icurrLen, // size of destination buffer
                                            astrFile); // .INI file
        }
        if((icurrLen - cchErrorMoreDataIndicator) != iret)
            // sufficient memory
            break;
        icurrLen += 100;
    }

    MsiString astrIniLine((ICHAR* )pszBuffer);
    MsiString astrRet = astrIniLine;
    while(iField-- > 0)
    {
        astrRet = astrIniLine.Extract(iseUpto, ICHAR(','));
        if(astrIniLine.Remove(iseIncluding, ICHAR(',')) == fFalse)
            astrIniLine = TEXT("");
    }
    StringCchCopy(pszBuffer, pszBuffer.GetSize(), astrRet);
    return 0;
}

IMsiRecord* CMsiServices::WriteLineToIni(   IMsiPath* piPath,
                                            const ICHAR* pszFile,
                                            const ICHAR* pszSection,
                                            const ICHAR* pszKey,
                                            const ICHAR* pszBuffer)
{
    Bool fWinIni = fFalse;
    BOOL iret;
    IMsiRecord* piError = 0;
    MsiString astrFile = pszFile;
    if((!IStrCompI(pszFile, WIN_INI)) && (piPath == 0))
    {
        // WIN.INI
        fWinIni = fTrue;
    }

    PMsiPath pFilePath = piPath;
    if(pFilePath == 0)
    {
        CTempBuffer<ICHAR,1> rgchTemp(MAX_PATH);

        //IPROPNAME_WINDOWSDIR
        AssertNonZero(MsiGetWindowsDirectory(rgchTemp, rgchTemp.GetSize()));
        piError = CreatePath(rgchTemp, *&pFilePath);
        if(piError != 0)
            return piError;
    }
    else
    {
        pFilePath->AddRef();
        piError = pFilePath->GetFullFilePath(pszFile, *&astrFile);
        if(piError != 0)
            return piError;
    }

    Bool fExists;
    Bool fDirExists;
    piError = pFilePath->Exists(fDirExists);
    if(piError != 0)
        return piError;
    piError = pFilePath->FileExists(pszFile, fExists);
    if(piError != 0)
        return piError;
    if(pszBuffer)
    {
        if(!fDirExists)
            return PostError(Imsg(idbgDirDoesNotExist),
                                  (const ICHAR*)MsiString(pFilePath->GetPath()));
    }
    else if(fExists == fFalse)
    {
        return 0; // we are attempting to remove stuff from a file that does not exist
    }

    // if the .INI file is on a network drive, we need to impersonate before calling
    // WritePrivateProfileString API.
    bool fToImpersonate = false;
    if ( RunningAsLocalSystem() &&
          (piPath != 0 && (GetImpersonationFromPath(astrFile) == fTrue)) )
        fToImpersonate = true;

    if(fTrue == fWinIni)
    {
        // win.ini
        iret = WriteProfileString(  pszSection,
                                    pszKey,
                                    pszBuffer);
    }
    else
    {
        CImpersonate impersonate(fToImpersonate);
        iret = WritePrivateProfileString(   pszSection,
                                            pszKey,
                                            pszBuffer,
                                            astrFile);
    }
    if(FALSE == iret)
        return PostError(Imsg(idbgErrorWritingIniFile), GetLastError(), pszFile);

    if(fTrue == fWinIni) // send notification message
        WIN::PostMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0);

    if(0 == pszBuffer)
    {
        // deleted entry, therefore cleanup
        CTempBuffer<ICHAR, 100> pszTemp;
        piError = ReadLineFromIni(piPath, pszFile, pszSection, 0, 0, pszTemp);
        ICHAR cTmp = pszTemp[0];
        if(piError != 0)
            return piError;

        if(0 == cTmp)
        {
            // no keys in that section, delete section
            if(fTrue == fWinIni)
            {
                // win.ini
                iret = WriteProfileString(  pszSection,
                                            0,
                                            0);
            }
            else
            {
                CImpersonate impersonate(fToImpersonate);
                iret = WritePrivateProfileString(pszSection,
                                                    0,
                                                    0,
                                                    astrFile);
            }
            if(FALSE == iret)
                return PostError(Imsg(idbgErrorWritingIniFile), GetLastError(), pszFile);

            if(fTrue == fWinIni) // send notification message
                WIN::PostMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0);

            // now check if there are no sections in the
            piError = ReadLineFromIni(piPath, pszFile, 0, 0, 0,pszTemp);
            cTmp = pszTemp[0];
            if(piError != 0)
                return piError;
            if(0 == cTmp)
            {
                // no sections in that file, delete file

                // flush file to disk so we can delete it
                CImpersonate impersonate(fToImpersonate);
                WritePrivateProfileString(0, 0, 0, astrFile);

                return pFilePath->RemoveFile(pszFile);
            }
        }
    }
    return 0;
}

/*_____________________________________________________________________

  Method WriteIniFile: Adds value = 'pValue' to the .INI file = 'pFile'
  which may be WIN.INI in section = 'pSection' and Key = 'pKey'. The
  exact method of addition to the .INI file is determined by the value
  of 'iifMode'.
_____________________________________________________________________*/
IMsiRecord* CMsiServices::WriteIniFile( IMsiPath* piPath,
                                        const ICHAR* pszFile,
                                        const ICHAR* pszSection,
                                        const ICHAR* pszKey,
                                        const ICHAR* pszValue,
                                        iifIniMode iifMode)
{
    IMsiRecord* piError = 0;
    Assert(pszSection);

    if(!pszFile || !*pszFile)
    {
        return PostError(Imsg(imsgErrorFileNameLength));
    }

    if(!pszSection || !*pszSection)
    {
        return PostError(Imsg(idbgErrorSectionMissing));
    }

    if(!pszKey || !*pszKey)
    {
        return PostError(Imsg(idbgErrorKeyMissing));
    }

    if((!pszValue) && ((iifMode == iifIniCreateLine) || (iifMode == iifIniAddLine)))
        pszValue = TEXT("");
    if((!pszValue) && (iifMode != iifIniRemoveLine))
        pszValue = TEXT("");

    switch(iifMode)
    {
    {
    case iifIniAddLine:
        piError = WriteLineToIni(   piPath,
                                    pszFile,
                                    pszSection,
                                    pszKey,
                                    pszValue);
        break;
    }
    case iifIniCreateLine:
    {
        CTempBuffer<ICHAR, 100> pszBuffer;
        piError = ReadLineFromIni(piPath, pszFile, pszSection, pszKey, 0, pszBuffer);
        if((0 == piError)&& (0 == *pszBuffer))
        {
            // no entry
            piError = WriteLineToIni(   piPath,
                                        pszFile,
                                        pszSection,
                                        pszKey,
                                        pszValue);
        }
        break;
    }

    case iifIniRemoveLine:
    {
        // delete .INI entry
        piError = WriteLineToIni(   piPath,
                                    pszFile,
                                    pszSection,
                                    pszKey,
                                    0);
        break;
    }
    case iifIniAddTag:
    {
        CTempBuffer<ICHAR, 100> pszBuffer;
        piError = ReadLineFromIni(piPath, pszFile, pszSection, pszKey, 0, pszBuffer);
        MsiString strIniLine((ICHAR* )pszBuffer);
        MsiString strNewIniLine;
        if(0 == piError)
        {
            if(*pszBuffer != 0)
            {
                // some value(s) exist
                do{
                    MsiString strRet(strIniLine.Extract(iseUpto, ICHAR(',')));
                    // extract upto next "," (or eos)
#if 0 // we allow the same value to be re-written - bug 1234, chetanp 06/13/97
                    if(astrRet.Compare(iscExactI, pszValue))
                    {
                        // value already exists, do nothing
                        return 0;
                    }
                    else
#endif
                    {
                        // else keep in new line
                        strNewIniLine += TEXT(",");
                        strNewIniLine += strRet;
                    }
                }while(strIniLine.Remove(iseIncluding, ICHAR(',')) == fTrue);
            }
            // value not already in buffer
            // add new value
            strNewIniLine += TEXT(",");
            strNewIniLine += pszValue;

            // remove leading comma
            strNewIniLine.Remove(iseIncluding, ICHAR(','));


            piError = WriteLineToIni(   piPath,
                                        pszFile,
                                        pszSection,
                                        pszKey,
                                        strNewIniLine);
        }
        break;
    }

    case iifIniRemoveTag:
    {
        CTempBuffer<ICHAR, 100> pszBuffer;
        piError = ReadLineFromIni(piPath, pszFile, pszSection, pszKey, 0, pszBuffer);
        MsiString strIniLine((ICHAR* )pszBuffer);
        MsiString strNewIniLine;
        if(0 == piError)
        {
            do{
                MsiString strRet = strIniLine.Extract(iseUpto, ICHAR(','));
                // extract upto next "," (or eos)
                if(strRet.Compare(iscExactI, pszValue) == 0)
                {
                    // not value to be deleted
                    strNewIniLine += TEXT(",");
                    strNewIniLine += *strRet;
                }
                // else skip value
            }while(strIniLine.Remove(iseIncluding, ICHAR(',')) == fTrue);

            strNewIniLine.Remove(iseIncluding, ICHAR(','));

            //?? following (ugly) check needed because empty strings
            // keep the key tag (eg. entries as - key=<nothing>))
            // must clean up - chetanp
            if(strNewIniLine.TextSize() == 0)
            {
                piError = WriteLineToIni(piPath,
                                            pszFile,
                                            pszSection,
                                            pszKey,
                                            0);
            }
            else
            {
                piError = WriteLineToIni(piPath,
                                            pszFile,
                                            pszSection,
                                            pszKey,
                                            strNewIniLine);
            }
        }
        break;
    }
    default:
        return PostError(Imsg(idbgInvalidIniAction), iifMode);

    }
    return piError;
}


/*_____________________________________________________________________

  Method ReadIniFile: reads value = 'pMsiValue' from the .INI file = 'pFile'
  which may be WIN.INI in section = 'pSection' and Key = 'pKey'.
  pPath may be 0 where it is assumed to be the default windows directory
_____________________________________________________________________*/
IMsiRecord* CMsiServices::ReadIniFile(  IMsiPath* piPath,
                                        const ICHAR* pszFile,
                                        const ICHAR* pszSection,
                                        const ICHAR* pszKey,
                                        unsigned int iField,
                                        const IMsiString*& rpiValue)
{
    IMsiRecord* piError = 0;
    if(!pszFile || !*pszFile)
    {
        return PostError(Imsg(imsgErrorFileNameLength));
    }

    if(!pszSection || !*pszSection)
    {
        return PostError(Imsg(idbgErrorSectionMissing));
    }

    if(!pszKey || !*pszKey)
    {
        return PostError(Imsg(idbgErrorKeyMissing));
    }

    CTempBuffer<ICHAR, 100> pszBuffer;
    piError = ReadLineFromIni(piPath, pszFile, pszSection, pszKey, iField, pszBuffer);
    if(0 == piError)
    {
        rpiValue = &CreateString();
        rpiValue->SetString(pszBuffer, rpiValue);
    }
    return piError;
}

/*_____________________________________________________________________

  Method CreateShortcut: creates a shortcut on Windows systems
  ___________________________________________________________________*/
IMsiRecord* CMsiServices::CreateShortcut(   IMsiPath& riShortcutPath,
                                            const IMsiString& riShortcutName,
                                            IMsiPath* piTargetPath,
                                            const ICHAR* pchTargetName,
                                            IMsiRecord* piShortcutInfoRec,
                                            LPSECURITY_ATTRIBUTES pSecurityAttributes)
{
    HRESULT hres;
    PMsiShellLink psl=0;
    PMsiPersistFile ppf=0;
    IMsiRecord* piError=0;

    struct CSetErrorModeWrapper{
        inline CSetErrorModeWrapper(UINT dwMode)
        {
            m_dwModeOld = WIN::SetErrorMode(dwMode);
        }
        inline ~CSetErrorModeWrapper()
        {
            WIN::SetErrorMode(m_dwModeOld);
        }
    private:
        UINT m_dwModeOld;
    };

    // set error mode to suppress system dialogs
    CSetErrorModeWrapper CErr(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    MsiString strShortcutName = riShortcutName; riShortcutName.AddRef();

    if((piError = EnsureShortcutExtension(strShortcutName, *this)) != 0)
        return piError;
    IUnknown* piunk = CreateCOMInterface(CLSID_ShellLink);
    if(0 == piunk)// no com interface available to support links
        return PostError(Imsg(idbgErrorShortCutUnsupported));
    hres = piunk->QueryInterface(IID_IShellLink, (void** )&psl);
    piunk->Release();
    if((FAILED(hres)) || (psl == 0))// no com interface available to support links
        return PostError(Imsg(idbgErrorShortCutUnsupported));
    // get the full file names for the shortcut
    MsiString strShortcutFullName;
    if((piError = riShortcutPath.GetFullFilePath(strShortcutName, *&strShortcutFullName)) != 0)
        return piError;
    
    MsiString strTargetFullName;
    if(piTargetPath == 0)
    {
        strTargetFullName = pchTargetName;
    }
    else
    {
        if(pchTargetName && *pchTargetName)
        {
            // shortcut to file
            if((piError = piTargetPath->GetFullFilePath(pchTargetName, *&strTargetFullName)) != 0)
                return PostError(Imsg(idbgErrorCreatingShortCut), 0, (const ICHAR* )strShortcutName);
        }
        else
        {
            // shortcut to folder
            strTargetFullName = piTargetPath->GetPath();
        }
    }
    // impersonate if target path is network path and we are a service
    Bool fImpersonate = (RunningAsLocalSystem()) && (GetImpersonationFromPath(strTargetFullName) == fTrue) ? fTrue : fFalse;
    if(fImpersonate)
        AssertNonZero(StartImpersonating());

    hres = psl->SetPath(strTargetFullName);

    if(fImpersonate)
        StopImpersonating();

    if(FAILED(hres)) // error
        return PostError(Imsg(idbgErrorCreatingShortCut), hres, (const ICHAR* )strShortcutName);
    if(piShortcutInfoRec)
    {
        // if we have auxiliary info
        if(piShortcutInfoRec->IsNull(icsArguments) == fFalse)
        {
            hres = psl->SetArguments(MsiString(piShortcutInfoRec->GetMsiString(icsArguments)));
            if(FAILED(hres)) // error
                return PostError(Imsg(idbgErrorCreatingShortCut), hres, (const ICHAR* )strShortcutName);
        }
        if(piShortcutInfoRec->IsNull(icsDescription) == fFalse)
        {
            hres = psl->SetDescription(MsiString(piShortcutInfoRec->GetMsiString(icsDescription)));
            if(FAILED(hres)) // error
                return PostError(Imsg(idbgErrorCreatingShortCut), hres, (const ICHAR* )strShortcutName);
        }
        if(piShortcutInfoRec->IsNull(icsHotKey) == fFalse)
        {
            hres = psl->SetHotkey((unsigned short)piShortcutInfoRec->GetInteger(icsHotKey));
            if(FAILED(hres)) // error
                return PostError(Imsg(idbgErrorCreatingShortCut), hres, (const ICHAR* )strShortcutName);
        }
        int iIconId = 0;
        MsiString strIconLocation;
        if(piShortcutInfoRec->IsNull(icsIconID) == fFalse)
            iIconId = piShortcutInfoRec->GetInteger(icsIconID);
        if(piShortcutInfoRec->IsNull(icsIconFullPath) == fFalse)
            strIconLocation = piShortcutInfoRec->GetMsiString(icsIconFullPath);
        if(iIconId || strIconLocation.TextSize())
        {
            AssertNonZero(StartImpersonating());
            // #9197: we impersonate to allow NT 5's to remap from absolute paths
            // to relative paths suitable for roaming.  Contact:  Chris Guzak.
            hres = psl->SetIconLocation(strIconLocation, iIconId);
            StopImpersonating();
            if(FAILED(hres)) // error
                return PostError(Imsg(idbgErrorCreatingShortCut), hres, (const ICHAR* )strShortcutName);
        }
        if(piShortcutInfoRec->IsNull(icsShowCmd) == fFalse)
        {
            hres = psl->SetShowCmd(piShortcutInfoRec->GetInteger(icsShowCmd));
            if(FAILED(hres)) // error
                return PostError(Imsg(idbgErrorCreatingShortCut), hres, (const ICHAR* )strShortcutName);
        }
        if(piShortcutInfoRec->IsNull(icsWorkingDirectory) == fFalse)
        {
            hres = psl->SetWorkingDirectory(MsiString(piShortcutInfoRec->GetMsiString(icsWorkingDirectory)));
            if(FAILED(hres)) // error
                return PostError(Imsg(idbgErrorCreatingShortCut), hres, (const ICHAR* )strShortcutName);
        }
    }
    hres = psl->QueryInterface(IID_IPersistFile, (void** )&ppf);
    if((FAILED(hres))  || (ppf == 0)) // error
        return PostError(Imsg(idbgErrorCreatingShortCut), hres, (const ICHAR* )strShortcutName);

    // impersonate if shortcut is being created on a network path and we are a service
    fImpersonate = (RunningAsLocalSystem()) && (GetImpersonationFromPath(strShortcutFullName) == fTrue) ? fTrue : fFalse;
    if(fImpersonate)
        AssertNonZero(StartImpersonating());

#ifndef UNICODE
    CTempBuffer<WCHAR, MAX_PATH> wsz; /* Buffer for unicode string */
    wsz.SetSize(strShortcutFullName.TextSize()  + 1);
    MultiByteToWideChar(CP_ACP, 0, strShortcutFullName, -1, wsz, wsz.GetSize());
    hres = ppf->Save(wsz, TRUE);
#else
    hres = ppf->Save(strShortcutFullName, TRUE);
#endif

	if(pSecurityAttributes && pSecurityAttributes->lpSecurityDescriptor)
    {
		CElevate elevate(!fImpersonate);
			
        CRefCountedTokenPrivileges cPrivs(itkpSD_WRITE);
        if (!WIN::SetFileSecurity(strShortcutFullName,
                                    GetSecurityInformation(pSecurityAttributes->lpSecurityDescriptor),
                                    pSecurityAttributes->lpSecurityDescriptor))
        {
            piError = PostError(Imsg(idbgErrorCreatingShortCut), GetLastError(), (const ICHAR*)strShortcutName);
        }
    }
    
    if(fImpersonate)
        StopImpersonating();
    
    if(FAILED(hres)) // error
        return PostError(Imsg(idbgErrorCreatingShortCut), hres, (const ICHAR* )strShortcutName);
    else if (piError)
        return piError;
    else
        return 0;
}


/*_____________________________________________________________________

  Method RemoveShortcut: deletes a shortcut on Windows systems
  ___________________________________________________________________*/
IMsiRecord* CMsiServices::RemoveShortcut(   IMsiPath& riShortcutPath,
                                            const IMsiString& riShortcutName,
                                            IMsiPath* piTargetPath,
                                            const ICHAR* pchTargetName)
{
    Bool bExists;
    IMsiRecord* piError = riShortcutPath.Exists(bExists);
    if(piError != 0)
        return piError;
    if(bExists == fFalse)
        return 0;
    MsiString strShortcutName = riShortcutName; riShortcutName.AddRef();
    piError = EnsureShortcutExtension(strShortcutName, *this);
    if(piError != 0)
        return piError;
    piError = riShortcutPath.FileExists(strShortcutName, bExists);
    if(piError != 0)
        return piError;
    if(bExists != fFalse)
    {
        MsiString strShortcutFullName;
        piError = riShortcutPath.GetFullFilePath(strShortcutName, *&strShortcutFullName);
        if(piError != 0)
            return piError;
        piError = riShortcutPath.RemoveFile(strShortcutName);
        if(piError != 0)
            return piError;
    }
    else if(piTargetPath != 0)
    {
        // user may have renamed the shortcut
        // clean up all shortcuts to the file in the current directory
        IUnknown *piunk = CreateCOMInterface(CLSID_ShellLink);
        if(piunk == 0)
            return PostError(Imsg(idbgErrorShortCutUnsupported));
        PMsiShellLink psl=0;
        PMsiPersistFile ppf=0;
        HRESULT hres = piunk->QueryInterface(IID_IShellLink, (void **) &psl);
        piunk->Release();
        if ((FAILED(hres)) || (psl == 0))
            return PostError(Imsg(idbgErrorShortCutUnsupported));
        hres = psl->QueryInterface(IID_IPersistFile, (void **) &ppf);
        if ((FAILED(hres)) || (ppf == 0))
            return PostError(Imsg(idbgErrorDeletingShortCut), hres, (const ICHAR* )strShortcutName);
        MsiString strPath = riShortcutPath.GetPath();
        if(strPath.Compare(iscEnd, szDirSep) == 0)
            strPath += szDirSep;
        ICHAR *TEXT_WILDCARD = TEXT("*.*");
        strPath += TEXT_WILDCARD;
        UINT iCurrMode = SetErrorMode(SEM_FAILCRITICALERRORS);
        WIN32_FIND_DATA fdFindData;
        HANDLE hFile = FindFirstFile(strPath, &fdFindData);
        SetErrorMode(iCurrMode);
        if(hFile == INVALID_HANDLE_VALUE)
            return PostError(Imsg(idbgErrorDeletingShortCut), hres, (const ICHAR* )strShortcutName);
        do
        {
            MsiString strFile = fdFindData.cFileName;
            if(!(fdFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                Bool fResult;
                piError = HasShortcutExtension(strFile, *this, fResult);
                if(piError != 0)
                    return piError;
                if(fResult == fFalse)
                    continue;
                MsiString strShortcutFullName;
                piError = riShortcutPath.GetFullFilePath(strFile, *&strShortcutFullName);
                if(piError != 0)
                    return piError;
                HRESULT hres = ppf->Load(strShortcutFullName, STGM_READ);
                if(!SUCCEEDED(hres))
                    // broken link
                    continue;
                if(!SUCCEEDED(hres = psl->Resolve(0, SLR_ANY_MATCH | SLR_NO_UI)))
                    // broken link
                    continue;
                WIN32_FIND_DATA wfd;
                CTempBuffer<ICHAR,1> rgchPath(MAX_PATH);
                if(!SUCCEEDED(hres = psl->GetPath(  rgchPath, rgchPath.GetSize(),
                                                    (WIN32_FIND_DATA*)&wfd,
                                                    0)))
                    // broken link
                    continue;
                //!! need CreatePathFromFullFileName fn
                PMsiPath piExistPath=0;
                if((piError = CreatePath(rgchPath, *&piExistPath)) != 0)
                    return piError;
                if(pchTargetName && *pchTargetName)
                {
                    // shortcut to a file
                    MsiString strExistFile;
                    strExistFile = piExistPath->GetEndSubPath();
                    piError = piExistPath->ChopPiece();
                    if(piError != 0)
                        return piError;
                    ipcEnum ipc;
                    piError = piTargetPath->Compare(*piExistPath, ipc);
                    if(piError != 0)
                        return piError;
                    if((ipc == ipcEqual) && strExistFile.Compare(iscExactI, pchTargetName))
                    {
                        piError = riShortcutPath.RemoveFile(strFile);
                        if(piError != 0)
                            return piError;
                    }
                }
                else
                {
                    // shortcut to a folder
                    ipcEnum ipc;
                    piError = piTargetPath->Compare(*piExistPath, ipc);
                    if(piError != 0)
                        return piError;
                    if(ipc == ipcEqual)
                    {
                        piError = riShortcutPath.RemoveFile(strFile);
                        if(piError != 0)
                            return piError;
                    }
                }
            }
        } while(FindNextFile(hFile, &fdFindData));
        FindClose(hFile);
    }
    return 0;
}


/*_____________________________________________________________________

 GetShortcutTarget: gets the target DD for a DD shortcut
  ___________________________________________________________________*/

extern BOOL DecomposeDescriptor(const ICHAR* szDescriptor, ICHAR* szProductCode, ICHAR* szFeatureId, ICHAR* szComponentCode, DWORD* pcchArgsOffset, DWORD* pcchArgs, bool* pfComClassicInteropForAssembly);

// NOTE: The following CODE has been provided by Reiner Fink, Lou Amadio from the Shell team
// It has been further been lightly modified to remove services dependencies by Matthew Wetmore (MattWe)
Bool GetShortcutTarget(const ICHAR* szShortcutTarget,
                                                ICHAR* szProductCode,
                                                ICHAR* szFeatureId,
                                                ICHAR* szComponentCode)
{
    if(!IsDarwinDescriptorSupported(iddOLE) && !IsDarwinDescriptorSupported(iddShell))
        return fFalse;

    if ( ! szShortcutTarget )
        return fFalse;

    // impersonate if shortcut is on a network path and we are a service
    Bool fImpersonate = (g_scServerContext == scService) && (GetImpersonationFromPath(szShortcutTarget) == fTrue) ? fTrue : fFalse;

    IUnknown *piunk = CreateCOMInterface(CLSID_ShellLink);
    if(piunk == 0)
        return fFalse;

    PMsiShellLinkDataList psdl=0;
    PMsiPersistFile ppf=0;
    HRESULT hres = piunk->QueryInterface(IID_IShellLinkDataList, (void **) &psdl);
    piunk->Release();
    if ((FAILED(hres)) || (psdl == 0))
    {
        // IID_IShellLinkDataList not supported try munging through the file itself
        // Try to open the file

        if(fImpersonate)
            AssertNonZero(StartImpersonating());
        CHandle hFile = CreateFile(szShortcutTarget,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       (FILE_ATTRIBUTE_NORMAL | 
							(SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)),
                       NULL);

		if (hFile != INVALID_HANDLE_VALUE)
		{
			DWORD dwType = GetFileType(hFile);
			if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
			{
				DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), szShortcutTarget);
				hFile = INVALID_HANDLE_VALUE;
				SetLastError(ERROR_OPEN_FAILED);
			}
		}

        DWORD dwLastError = GetLastError();
        if(fImpersonate)
            StopImpersonating();

        if(hFile == INVALID_HANDLE_VALUE) // unable to open the link file
            return fFalse;

        SHELL_LINK_DATA sld;
        memset(&sld, 0, sizeof(sld));
        DWORD cbSize=0;

        // Now, read out data...
        DWORD dwNumberOfBytesRead;
        if(!WIN::ReadFile(hFile,(LPVOID)&sld,sizeof(sld),&dwNumberOfBytesRead,0) ||
            sizeof(sld) != dwNumberOfBytesRead) // could not read the shortcut info
            return fFalse;

        // check to see if the link has a pidl
        if(sld.dwFlags & SLDF_HAS_ID_LIST)
        {
            // Read the size of the IDLIST
            USHORT cbSize1;
            if (!WIN::ReadFile(hFile, (LPVOID)&cbSize1, sizeof(cbSize1), &dwNumberOfBytesRead, 0) ||
                sizeof(cbSize1) != dwNumberOfBytesRead)// could not read the shortcut info
                return fFalse;

            WIN::SetFilePointer(hFile, cbSize1, 0, FILE_CURRENT);
        }

        // check to see if we have a linkinfo pointer
        if(sld.dwFlags & SLDF_HAS_LINK_INFO)
        {
            // the linkinfo pointer is just a DWORD
            if(!WIN::ReadFile(hFile,(LPVOID)&cbSize,sizeof(cbSize),&dwNumberOfBytesRead,0) ||
                sizeof(cbSize) != dwNumberOfBytesRead) // could not read the shortcut info
                return fFalse;

            // do we need to advance any further than just a dword?
            if (cbSize >= sizeof(DWORD))
            {
                cbSize -= sizeof(DWORD);
                WIN::SetFilePointer(hFile, cbSize, 0, FILE_CURRENT);
            }
        }

        // is this a unicode link?
        int bUnicode = (sld.dwFlags & SLDF_UNICODE);

        // skip all the string info in the links
        static const unsigned int rgdwFlags[] = {SLDF_HAS_NAME, SLDF_HAS_RELPATH, SLDF_HAS_WORKINGDIR, SLDF_HAS_ARGS, SLDF_HAS_ICONLOCATION, 0/* end loop*/};
        for(int cchIndex = 0; rgdwFlags[cchIndex]; cchIndex++)
        {
            if(sld.dwFlags & rgdwFlags[cchIndex])
            {
                USHORT cch;

                // get the size
                if(!WIN::ReadFile(hFile, (LPVOID)&cch, sizeof(cch), &dwNumberOfBytesRead,0) ||
                    sizeof(cch) != dwNumberOfBytesRead) // could not read the shortcut info
                    return fFalse;

                // skip over the string
                WIN::SetFilePointer(hFile, cch * (bUnicode ? sizeof(WCHAR) : sizeof(char)), 0, FILE_CURRENT);
            }
        }

        // Read in extra data sections
        EXP_DARWIN_LINK expDarwin;
        for(;;)
        {
            DATABLOCK_HEADER dbh;
            memset(&dbh, 0, sizeof(dbh));

            // read in the datablock header
            if(!WIN::ReadFile(hFile, (LPVOID)&dbh, sizeof(dbh), &dwNumberOfBytesRead,0) ||
                sizeof(dbh) != dwNumberOfBytesRead) // could not read the shortcut info
                return fFalse;

            // check to see if we have DARWIN extra data
            if (dbh.dwSignature == EXP_DARWIN_ID_SIG)
            {
                // we do, so read the rest of the darwin info
                if(!WIN::ReadFile(hFile, (LPVOID)((char*)&expDarwin + sizeof(dbh)), sizeof(expDarwin) - sizeof(dbh), &dwNumberOfBytesRead, 0) ||
                sizeof(expDarwin) - sizeof(dbh) != dwNumberOfBytesRead)// could not read the shortcut info
                    return fFalse;
                break;// we found the darwin descriptor

            }
            else
            {
                //
                // this is some other extra-data blob, skip it and go on
                // However, note that it need not necessarily be a DATABLOCK_HEADER
                // (Windows bug 585101). So we must at least make sure that as we
                // jump ahead in the file to look for the extra DARWIN data, we do
                // not accidentally move backwards, i.e., dbh.cbSize > sizeof(dbh)
                //
                if (dbh.cbSize > sizeof(dbh))
                {
                    if (INVALID_SET_FILE_POINTER == WIN::SetFilePointer(hFile, dbh.cbSize - sizeof(dbh), 0, FILE_CURRENT))
                        return fFalse;
                }
                else
                {
                    //
                    // At this point, we don't really know where to look for the extra
                    // DARWIN data. So we bail out.
                    //
                    return fFalse;
                }
            }
        }
        return DecomposeDescriptor(
#ifdef UNICODE
                            expDarwin.szwDarwinID,
#else
                            expDarwin.szDarwinID,
#endif
                            szProductCode,
                            szFeatureId,
                            szComponentCode,
                            0,
                            0,
                            0) ? fTrue:fFalse;
    }

    hres = psdl->QueryInterface(IID_IPersistFile, (void **) &ppf);
    if ((FAILED(hres)) || (ppf == 0))
        return fFalse;

    if(fImpersonate)
        AssertNonZero(StartImpersonating());
#ifndef UNICODE

    // called from MsiGetShortcutTarget -- cannot use CTempBuffer.
    CAPITempBuffer<WCHAR, MAX_PATH> wsz; /* Buffer for unicode string */
    wsz.SetSize(lstrlen(szShortcutTarget) + 1);
    MultiByteToWideChar(CP_ACP, 0, szShortcutTarget, -1, wsz, wsz.GetSize());
    hres = ppf->Load(wsz, STGM_READ);
#else
    hres = ppf->Load(szShortcutTarget, STGM_READ);
#endif
    if(fImpersonate)
        StopImpersonating();
    if (FAILED(hres))
        return fFalse;

    EXP_DARWIN_LINK* pexpDarwin = 0;

    hres = psdl->CopyDataBlock(EXP_DARWIN_ID_SIG, (void**)&pexpDarwin);
    if (FAILED(hres) || (pexpDarwin == 0))
        return fFalse;

    Bool fSuccess = DecomposeDescriptor(
#ifdef UNICODE
                            pexpDarwin->szwDarwinID,
#else
                            pexpDarwin->szDarwinID,
#endif
                            szProductCode,
                            szFeatureId,
                            szComponentCode,
                            0,
                            0,
                            0) ? fTrue: fFalse;

    LocalFree(pexpDarwin);
    return fSuccess;
}

int CMsiServices::GetLangNamesFromLangIDString(const ICHAR* szLangIDs, IMsiRecord& riLangRec,
                                                int iFieldStart)
// --------------------------------------------
{
    const int cchLangNameBuffer = 256;
    unsigned short rgwLangID[cLangArrSize];
    int iLangCount;
    GetLangIDArrayFromIDString(szLangIDs, rgwLangID, cLangArrSize, iLangCount);

    int iConvertCount = 0;
    for (int iLang = 1;iLang <= iLangCount;iLang++)
    {
        ICHAR rgchLang[cchLangNameBuffer];  //!! change to CTempBuffer if possible to overflow
        if (!LangIDToLangName(rgwLangID[iLang - 1], rgchLang, cchLangNameBuffer))
            return iConvertCount;
        if (riLangRec.SetString(iFieldStart++,rgchLang) == fFalse)
            return iConvertCount;
        iConvertCount++;
    }
    return iConvertCount;
}


Bool LangIDToLangName(unsigned short wLangID, ICHAR* szLangName, int iBufSize)
// -------------------
{
    return (Bool) GetLocaleInfo(MAKELCID(wLangID,SORT_DEFAULT),LOCALE_SLANGUAGE,szLangName,iBufSize);
}


// class to encapsulate TLIBATTR*
class CLibAttr
{
public:
    CLibAttr(): m_piTypeLib(0), m_pTlibAttr(0)
    {
    }
    ~CLibAttr()
    {
        Release();
    }
    HRESULT Init(PTypeLib& piTypeLib)
    {
        HRESULT hres = S_OK;
        Release();
        m_piTypeLib = piTypeLib;
        if(m_piTypeLib)
            hres = m_piTypeLib->GetLibAttr(&m_pTlibAttr);
        else
            hres = S_FALSE;
        return hres;
    }
    TLIBATTR* operator->()
    {
        Assert(m_pTlibAttr);
        return m_pTlibAttr;
    }
    void Release()
    {
        if(m_pTlibAttr)
        {
            Assert(m_piTypeLib);
            m_piTypeLib->ReleaseTLibAttr(m_pTlibAttr);
            m_pTlibAttr = 0;
        }
    }
protected:
    TLIBATTR* m_pTlibAttr;
    PTypeLib m_piTypeLib;
};

IMsiRecord* CMsiServices::RegisterTypeLibrary(const ICHAR* szLibID, LCID lcidLocale, const ICHAR* szTypeLib, const ICHAR* szHelpPath, ibtBinaryType iType)
{
    return ProcessTypeLibrary(szLibID, lcidLocale, szTypeLib, szHelpPath, fFalse, iType);
}

IMsiRecord* CMsiServices::UnregisterTypeLibrary(const ICHAR* szLibID, LCID lcidLocale, const ICHAR* szTypeLib, ibtBinaryType iType)
{
    return ProcessTypeLibrary(szLibID, lcidLocale, szTypeLib, 0, fTrue, iType);
}

HRESULT ProcessTypeLibraryCore(const OLECHAR* szLibID, LCID lcidLocale, 
                               const OLECHAR* szTypeLib, const OLECHAR* szHelpPath, 
                               const bool fRemove, int *fInfoMismatch)
{
    int iResource = 2;//next resouce number to check
    const ICHAR * szTypeLibConvert = CConvertString(szTypeLib);
    MsiString strFinalPath = szTypeLibConvert;
    PTypeLib piTypeLib = 0;
    CLibAttr libAttr;
    IID iidLib;
    Bool fImpersonate = ((g_scServerContext == scService || g_scServerContext == scCustomActionServer) && 
                         (GetImpersonationFromPath(szTypeLibConvert) == fTrue)) ? fTrue : fFalse;

    HRESULT hres = OLE32::IIDFromString(const_cast <OLECHAR*>(szLibID), &iidLib);
    *fInfoMismatch = (int)false;
    for (;hres == S_OK;)// loop to get the correct resource
    {
        if(fImpersonate)
            AssertNonZero(StartImpersonating());
        hres = OLEAUT32::LoadTypeLib(CConvertString(strFinalPath), &piTypeLib);
        if(fImpersonate)
            StopImpersonating();
#ifdef DEBUG
        DEBUGMSG3(TEXT("LoadTypeLib on '%s' file returned: %d. LibId = %s"),
                  strFinalPath, (const ICHAR*)(INT_PTR)hres, CConvertString(szLibID));
#endif // DEBUG
        if(hres != S_OK)
            break; //error.
        // is this the type lib we are interested in?
        hres = libAttr.Init(piTypeLib);
        if(hres != S_OK)
            break; //error.
        if(IsEqualGUID(libAttr->guid, iidLib) && (libAttr->lcid == lcidLocale))
        {
            *fInfoMismatch = (int)false;// reset the fInfoMismatch flag
            if(fRemove == false)
            {
                MsiDisableTimeout();
                hres = OLEAUT32::RegisterTypeLib(piTypeLib, 
                                                 const_cast <WCHAR*> ((const WCHAR*) CConvertString(strFinalPath)),
                                                 const_cast <OLECHAR*> (szHelpPath));
                MsiEnableTimeout();
#ifdef DEBUG
                if ( szHelpPath && *szHelpPath )
                    DEBUGMSG4(TEXT("RegisterTypeLib on '%s' file returned: %d. HelpPath = '%s'. LibId = %s"),
                              strFinalPath, (const ICHAR*)(INT_PTR)hres, CConvertString(szHelpPath), CConvertString(szLibID));
                else
                    DEBUGMSG3(TEXT("RegisterTypeLib on '%s' file returned: %d. LibId = %s"),
                              strFinalPath, (const ICHAR*)(INT_PTR)hres, CConvertString(szLibID));
#endif // DEBUG
            }
            else
            {
                hres = OLEAUT32::UnRegisterTypeLib(libAttr->guid, libAttr->wMajorVerNum, libAttr->wMinorVerNum, libAttr->lcid, SYS_WIN32);
#ifdef DEBUG
                DEBUGMSG3(TEXT("UnRegisterTypeLib on '%s' file returned: %d. LibId = %s"),
                          strFinalPath, (const ICHAR*)(INT_PTR)hres, CConvertString(szLibID));
#endif // DEBUG
            }
            break;
        }
        else
            *fInfoMismatch = (int)true; // did not find the authored LIBID and/ or locale in the type library
        MsiString istrAdd = MsiChar(chDirSep);
        istrAdd += MsiString(iResource++);
        strFinalPath = szTypeLibConvert;
        strFinalPath += istrAdd;
    }

    DEBUGMSG1(TEXT("ProcessTypeLibraryCore returns: %d. (0 means OK)"), (const ICHAR*)(INT_PTR)hres);
    return hres;
}

CMsiCustomActionManager *GetCustomActionManager(const ibtBinaryType iType, const bool fRemoteIfImpersonating, bool& fSuccess);

//!! added disabling of timeout during type library registration due to suspected 
//!! scenarios in Office where certain type library registrations (VBEEXT1.OLB)
//!! sometimes take more than the timeout period

//!! have not been able to confirm this myself -chetanp
IMsiRecord* CMsiServices::ProcessTypeLibrary(const ICHAR* szLibID, LCID lcidLocale, const ICHAR* szTypeLib, const ICHAR* szHelpPath, Bool fRemove, ibtBinaryType iType)
{
    bool fSuccess;
    CMsiCustomActionManager* pManager = GetCustomActionManager(iType, false /*fRemoteIfImpersonating*/, fSuccess);
    if ( !fSuccess )
        return PostError(fRemove? Imsg(idbgRegisterTypeLibrary) : Imsg(idbgUnregisterTypeLibrary), szTypeLib, 0);

    DEBUGMSG2(TEXT("CMsiServices::ProcessTypeLibrary runs in %s context, %simpersonated."), 
              pManager ? TEXT("remote") : TEXT("local"),
              IsImpersonating(false) ? TEXT("") : TEXT("not "));

    int fInfoMismatch = (int)false;
    HRESULT hres;
    hres = !pManager ? ProcessTypeLibraryCore(CConvertString(szLibID), lcidLocale,
                                              CConvertString(szTypeLib), CConvertString(szHelpPath),
                                              Tobool(fRemove), &fInfoMismatch)
                          : pManager->ProcessTypeLibrary(CConvertString(szLibID), lcidLocale,
                                              CConvertString(szTypeLib), CConvertString(szHelpPath),
                                              fRemove, &fInfoMismatch);
    if(hres != S_OK)
    {
        if(fInfoMismatch)
        {
            DEBUGMSG3(TEXT("could not find the authored LIBID %s and/or the locale %d in the type library %s"), szLibID, (const ICHAR*)(INT_PTR)lcidLocale, szTypeLib);
        }
        return PostError(fRemove? Imsg(idbgRegisterTypeLibrary) : Imsg(idbgUnregisterTypeLibrary), szTypeLib, (int)hres);
    }
    else
        return 0;
}


Bool GetLangIDArrayFromIDString(const ICHAR* szLangIDs, unsigned short rgw[], int iSize,
                                int& riLangCount)
/*----------------------------------------------------------------------------
Extracts an array of Language ID values from the comma-separated list given
in the szLangID string.

Arguments:
- szLangIDs: comma-separated list of language IDs.
- rgw: pointer to an existed array in which the language ID values are to be
    returned.
- iSize: the declared size of the array passed by the caller.
- riLangCount: a reference to the location in which GetLangIDArrayFromIDString
    will store a count of the actual number of valid language ID values returned
    in the array.

Returns:
- fFalse if a syntax error is detected in szLangIDs
------------------------------------------------------------------------------*/
{
    MsiString astrLangIDs(szLangIDs);
    riLangCount = 0;
    while (astrLangIDs.TextSize() > 0 && riLangCount < iSize)
    {
        int iLangID;
        if ((iLangID = MsiString(astrLangIDs.Extract(iseUptoTrim,','))) == iMsiStringBadInteger || iLangID > 65535)
            return fFalse;
        rgw[riLangCount++] = unsigned short(iLangID);
        if (!astrLangIDs.Remove(iseIncluding,','))
            break;
    }
    return fTrue;
}


Bool ConvertValueFromString(const IMsiString& ristrValue, CTempBufferRef<char>& rgchOutBuffer, aeConvertTypes& raeType)
{
    //!! This function will return a TRUE value, and the bad integer (0x8000 0000) when
    // the number passed in is actually 0x8000 0000.
    // the caller must realize that the return may actually match the bad integer, without
    // being bad.

    int iBufferSize;
    ristrValue.AddRef();
    MsiString strStr = ristrValue; // copy over the input string
    raeType = aeCnvTxt;
    const ICHAR* pchCur = strStr;
    if(*pchCur == '#')
    {
        strStr.Remove(iseFirst, 1);
        pchCur = strStr;
        switch(*pchCur)
        {
        case '#':
            // string
            break;
        case '%':
        {
            // unexpanded string
            raeType = aeCnvExTxt;
            strStr.Remove(iseFirst, 1);
            break;
        }
        case 'x':
        case 'X':
        {
            // binary
            raeType = aeCnvBin;
            strStr.Remove(iseFirst, 1);
            pchCur = strStr;
            iBufferSize = (IStrLen(pchCur) + 1)/2;

            rgchOutBuffer.SetSize(iBufferSize);

            char* pBin = rgchOutBuffer;
            if ( ! pBin ) 
                return fFalse;
            int iFlags = (iBufferSize*2 == IStrLen(pchCur))?0: (*pBin = 0, ~0);
            while(*pchCur)
            {
                unsigned char cTmp;
                cTmp = unsigned char(*pchCur | 0x20);
                int iBinary;
                if((iBinary = (cTmp - '0')) > 9)
                    iBinary = cTmp - 'a' + 0xa;

                if((iBinary < 0) || (iBinary > 15))
                    return fFalse;

                *pBin = (char) (iBinary | ((*pBin << 4) & iFlags));
                pchCur++;
                if(iFlags)
                    pBin++;
                iFlags = ~iFlags;
            }
            return fTrue;
        }
        default:
            // int
            if(strStr.Compare(iscStart, TEXT("+")))
            {
                raeType = aeCnvIntInc;
                strStr.Remove(iseFirst, 1);
                if(!strStr.TextSize())
                    strStr = 1;

            }
            else if(strStr.Compare(iscExact, TEXT("-"))) // #-XXXX converts to -XXXX
                                                                        // #- by itself means decrement the existing value by one
                                                                        // #+-XXXX decrements by XXXX
            {
                raeType = aeCnvIntDec;
                strStr.Remove(iseFirst, 1);
                if(!strStr.TextSize())
                    strStr = 1;
            }
            else
                raeType = aeCnvInt;
            iBufferSize = sizeof(int);
            rgchOutBuffer.SetSize(iBufferSize);
            if ( ! (char *)rgchOutBuffer )
                return fFalse;
            Bool fValid = fTrue;
            *(int*) (char*)rgchOutBuffer = GetIntegerValue(strStr, &fValid);
            return fValid;
        }
    }

    // can only be a string if we are here
    int cchBufferSize = strStr.TextSize();
    // REG_SZ or REG_MULTI_SZ?
    if(IStrLen((const ICHAR*)strStr) != cchBufferSize)
    {
        // REG_MULTI_SZ
        raeType = aeCnvMultiTxt;
        if(!*pchCur)
        {
            // null in the beginning, implies append to the existing
            strStr.Remove(iseFirst, 1);
            cchBufferSize = strStr.TextSize();
            raeType = aeCnvMultiTxtAppend;
        }
        // do we have an extra null at the end?
        const ICHAR* pchBegin = strStr;
        const ICHAR* pchEnd = pchBegin + cchBufferSize;
        while(pchBegin < pchEnd)
        {
            pchBegin += IStrLen(pchBegin) + 1;
        }
        if(pchBegin > pchEnd)
        {
            // no extra null, add extra null
            strStr += MsiString (MsiChar(0));
            cchBufferSize = strStr.TextSize();
        }
        else
        {
            // null in the end, implies prepend to the existing
            if(raeType == aeCnvMultiTxtAppend)
            {
                // unless there was a null at the beginning
                raeType = aeCnvMultiTxt;
            }
            else
            {
                raeType = aeCnvMultiTxtPrepend;
            }
        }
    }
    cchBufferSize++; // for the end null
    rgchOutBuffer.SetSize((cchBufferSize) * sizeof(ICHAR));
    strStr.CopyToBuf((ICHAR* )(char*)rgchOutBuffer, cchBufferSize - 1);
    return fTrue;
}


Bool ConvertValueToString(CTempBufferRef<char>& rgchInBuffer, const IMsiString*& rpistrValue, aeConvertTypes aeType)
{
    char* pBuffer = rgchInBuffer;
    int iBufferSize = rgchInBuffer.GetSize();
    rpistrValue = &CreateString();
    switch(aeType)
    {
    case aeCnvExTxt:
    {
        rpistrValue->SetString(TEXT("#"), rpistrValue);
        rpistrValue->AppendString(TEXT("%"), rpistrValue);
        rpistrValue->AppendString((const ICHAR* )pBuffer, rpistrValue);
        break;
    }
    case aeCnvTxt:
    {
        if(iBufferSize)
        {
            if(*(ICHAR*)pBuffer == '#')
            {
                rpistrValue->SetString(TEXT("#"), rpistrValue);
            }
            rpistrValue->AppendString((ICHAR*)pBuffer, rpistrValue);
        }
        break;
    }
    case aeCnvMultiTxt:
    {
        // begin with a null and end with a null - this helps rollback
        rpistrValue->AppendMsiString(*MsiString(MsiChar(0)), rpistrValue);
        if(iBufferSize)
        {
            while(*pBuffer)
            {
                rpistrValue->AppendString((ICHAR*)pBuffer, rpistrValue);
                rpistrValue->AppendMsiString(*MsiString(MsiChar(0)), rpistrValue);
                pBuffer = (char*)((ICHAR* )pBuffer + (IStrLen((ICHAR* )pBuffer) + 1));
            }
        }
        break;
    }

    case aeCnvInt:
    {
        CTempBuffer<ICHAR, 30> rgchTmp;
        rgchTmp.SetSize(iBufferSize*3 + 1 + 1);// 1 for "#", 1 for termination
        if ( ! (ICHAR *)rgchTmp )
            return fFalse;
        StringCchCopy(rgchTmp, rgchTmp.GetSize(), TEXT("#"));
        StringCchPrintf(((ICHAR* )rgchTmp + 1), rgchTmp.GetSize()-1, TEXT("%i"),*(int* )pBuffer);
        rpistrValue->SetString(rgchTmp, rpistrValue);
        break;
    }
    case aeCnvBin:
    {
        ICHAR* pchCur = ::AllocateString(iBufferSize*2 + 2, fFalse, rpistrValue); // "#x" + 2ICHARs/byte
        if (!pchCur)
        {
            rpistrValue->Release();
            return fFalse;
        }
        *pchCur++ = '#';
        *pchCur++ = 'x';
        while (iBufferSize--)
        {
            if ((*pchCur = (ICHAR)((*pBuffer >> 4) + '0')) > '9')
                *pchCur += ('A' - ('0' + 10));
            pchCur++;
            if ((*pchCur = (ICHAR)((*pBuffer & 15) + '0')) > '9')
                *pchCur += ('A' - ('0' + 10));
            pchCur++;
            pBuffer++;
        }
    }
    }
    return fTrue;
}

unsigned int SerializeStringIntoRecordStream(ICHAR* szString, ICHAR* rgchBuf, int cchBuf)
{
    const int cchHeader = sizeof(short)/sizeof(ICHAR);
    const int cchMaxHeaderPlusArgs = cchHeader + ((sizeof(short)+sizeof(int))/sizeof(ICHAR));
    if(cchBuf <= cchMaxHeaderPlusArgs)
        return 0;

    const int cParams = 0;
    *(short*)rgchBuf = short((cParams << 8) + ixoFullRecord);
    rgchBuf += cchHeader;
    cchBuf  -= cchHeader;

    unsigned cchLen = IStrLen(szString);
#ifdef UNICODE
    unsigned iType = iScriptUnicodeString;
#else
    unsigned iType = iScriptSBCSString;
#endif
    if (cchLen == 0)
    {
        *(short*)rgchBuf = short(iScriptNullString);
        return cchHeader + sizeof(short)/sizeof(ICHAR);
    }
    else
    {
        unsigned int cchArgLen;
        if (cchLen <= cScriptMaxArgLen)
        {
            cchArgLen = sizeof(short)/sizeof(ICHAR);
            if (cchLen + cchArgLen > cchBuf)
                cchLen = cchBuf - cchArgLen;

            *(short*)rgchBuf = short(cchLen + iType);
        }
        else  // need to use extended arg
        {
            cchArgLen = (sizeof(short)+sizeof(int))/sizeof(ICHAR);
            if (cchLen + cchArgLen > cchBuf)
                cchLen = cchBuf - cchArgLen;

            *(short*)rgchBuf = short(iScriptExtendedSize);
            *(int*)rgchBuf   = cchLen + (iType<<16);
        }
        memcpy(rgchBuf+cchArgLen, szString, cchLen*sizeof(ICHAR));
        return cchHeader + cchArgLen + cchLen;
    }
}

const int iScriptVersionCompressParams = 21;

bool CMsiServices::FWriteScriptRecordMsg(ixoEnum ixoOpCode, IMsiStream& riStream, IMsiRecord& riRecord)
{
    IMsiRecord* piRecord = m_piRecordPrev;

    if (ixoOpCode != m_ixoOpCodePrev && piRecord != 0)
    {
        piRecord = 0;
    }
    m_ixoOpCodePrev = ixoOpCode;
    if (FWriteScriptRecord(ixoOpCode, riStream, riRecord, piRecord, false))
    {
        if (m_piRecordPrev == 0)
            m_piRecordPrev = &CreateRecord(cRecordParamsStored);

        CopyRecordStringsToRecord(riRecord, *m_piRecordPrev);

        return true;
    }

    return false;

}

bool CMsiServices::FWriteScriptRecord(ixoEnum ixoOpCode, IMsiStream& riStream, IMsiRecord& riRecord, IMsiRecord* piPrevRecord, bool fForceFlush)
{
    bool fReadError = false;
    // serialize record, truncating trailing null fields
    int cParams = riRecord.GetFieldCount();
    // Remember where the initial seek position is, in
    // case an error occurs.
    int iRecStartPosition = riStream.GetIntegerValue();
    int iStart = 1;
    while (cParams && riRecord.IsNull(cParams))
        cParams--;

    if(cParams >> 8) // we can have atmost 255 parameters to the opcode
    {
        AssertSz(0, TEXT("Number of params in script record greater than stipulated limit of 255"));
        //!! this function should change to return exact error encountered
        //!! since the caller suggests an out of disk space error upon return=false
        //!! this may lead to pointless retry.
        return false;
    }

    Assert(!(ixoOpCode >> 8)); // number of opcodes limited to 255

    riStream.PutInt16(short((cParams << 8) + ixoOpCode));
    if (ixoOpCode == ixoFullRecord)
        iStart = 0;

    for (int iParam = iStart; iParam <= cParams; iParam++)
    {
        if (riRecord.IsNull(iParam))
            riStream.PutInt16(short(iScriptNullArg));
        else if (riRecord.IsInteger(iParam))
        {
            riStream.PutInt16(short(iScriptIntegerArg));
            riStream.PutInt32(riRecord.GetInteger(iParam));
        }
        else  // string or stream or object, cannot be null
        {
            PMsiData pData(riRecord.GetMsiData(iParam));
            IMsiStream* piStream;
            if (pData->QueryInterface(IID_IMsiStream, (void**)&piStream) == NOERROR)
            {
                unsigned cLen = pData->GetIntegerValue();
                if (cLen <= cScriptMaxArgLen)
                {
                    riStream.PutInt16(short(cLen + iScriptBinaryStream));
                }
                else  // need to use extended arg
                {
                    riStream.PutInt16(short(iScriptExtendedSize));
                    riStream.PutInt32(cLen + (iScriptBinaryStream<<16));
                }
                char rgchBuf[512];
                piStream->Reset();
                while ((cLen = piStream->Remaining()) != 0)
                {
                    if (cLen > sizeof(rgchBuf))
                        cLen = sizeof(rgchBuf);
                    piStream->GetData(rgchBuf, cLen);
                    if (piStream->Error())
                    {
                        fReadError = true;
                        piStream->Release();
                        goto ReadError;
                    }
                    riStream.PutData(rgchBuf, cLen);
                }
                piStream->Release();
            }
            else // string or other object
            {
                MsiString istrArg(pData->GetMsiStringValue());
                // Compress only if the argument string is NOT MultiSZ, AND the value matches the previous value exactly.
                if (piPrevRecord && IStrLen(istrArg) == istrArg.TextSize() && istrArg.Compare(iscExact, piPrevRecord->GetString(iParam)))
                {
                    riStream.PutInt16(short(iScriptNullString));
                }
                else
                {
                    unsigned cLen = istrArg.TextSize();
#ifdef UNICODE
                    CTempBuffer<char, 256>szAnsi;
                    szAnsi.SetSize(cLen);
                    const ICHAR* pch = istrArg;

                    //
                    // See if this is an ansi only string, if so, we save some space
                    // in the script
                    int i;
                    for (i = 0 ; i < cLen ; )
                    {
                        if (*pch >= 0x80)
                            break;
                        szAnsi[i++] = (char)*pch++;
                    }

                    unsigned iType = iScriptUnicodeString;
                    if (i >= cLen)
                        iType = iScriptSBCSString;
#else
                    unsigned iType = istrArg.IsDBCS() ? iScriptDBCSString : iScriptSBCSString;
#endif
                    if (cLen == 0)
                        riStream.PutInt16(short(iScriptNullArg));
                    else
                    {
                        if (cLen <= cScriptMaxArgLen)
                            riStream.PutInt16(short(cLen + iType));
                        else  // need to use extended arg
                        {
                            riStream.PutInt16(short(iScriptExtendedSize));
                            riStream.PutInt32(cLen + (iType<<16));
                        }
#ifdef UNICODE
                        if (iType == iScriptSBCSString)
                            riStream.PutData(szAnsi, cLen * sizeof(char));
                        else
#endif //UNICODE
                            riStream.PutData((const ICHAR*)istrArg, cLen * sizeof(ICHAR));
                    }
                }
            }
        }
    }

ReadError:
    if (riStream.Error() || fReadError)
    {
        // If a read or write error occurred, reset the write seek position back
        // where it was originally, to allow the caller to try again.
        riStream.Reset();
        riStream.Seek(iRecStartPosition);
        return false;
    }
    else if(fForceFlush)
        riStream.Flush();

    return true;
}



//____________________________________________________________________________
//
// Serialization functions
//____________________________________________________________________________

IMsiRecord* CMsiServices::ReadScriptRecordMsg(IMsiStream& riStream)
{
    return ReadScriptRecord(riStream, *&m_piRecordPrev, 0x7fffffff);
}

IMsiRecord* CMsiServices::ReadScriptRecord(IMsiStream& riStream, IMsiRecord*& rpiPrevRecord, int iScriptVersion)
{
    unsigned int iType = (unsigned short)riStream.GetInt16();
    IMsiRecord* piPrevRecord = rpiPrevRecord;
    Debug(bool fSameOpcode = true);
    int iStart = 1;
    if (riStream.Error())
        return 0;  // error or end of file

    ixoEnum ixoOpCode = ixoEnum(iType & cScriptOpCodeMask);
    if ((unsigned)ixoOpCode >= ixoOpCodeCount)
        ixoOpCode = ixoNoop;  // don't know what this opcode is, so replace it with NOOP - we will skip it
    unsigned int cArgs = iType >> cScriptOpCodeBits;
    if (ixoOpCode == ixoFail)
    {
        cArgs = 0;
        riStream.PutData(0,2); // force stream to error state
    }
    PMsiRecord pParams = &CreateRecord(cArgs);
    if (ixoOpCode == ixoFullRecord)
        iStart = 0;
    else
    {
        pParams->SetInteger(0, ixoOpCode);
#ifdef DEBUG
        if (piPrevRecord != 0 && ixoOpCode != piPrevRecord->GetInteger(0))
            fSameOpcode = false;
#endif //DEBUG
    }
    for (int iArg = iStart; iArg <= cArgs; iArg++)
    {
        unsigned int cLenType = (unsigned short)riStream.GetInt16();
        if (riStream.Error())
            return 0;  // error or end of file
        unsigned int cLen = cLenType & cScriptMaxArgLen;
        if (cLenType == iScriptExtendedSize) // use next 32 bits instead
        {
            cLenType = (unsigned int)riStream.GetInt32();
            if (riStream.Error())
                return 0;  // error or end of file
            cLen = cLenType & ((cScriptMaxArgLen << 16) + 0xFFFF);
            cLenType >>= 16;  // shift type bits to match normal case
        }
        if (cLen == 0)  // not serial data
        {
            switch (cLenType & iScriptTypeMask)
            {
                case iScriptIntegerArg:
                    pParams->SetInteger(iArg, riStream.GetInt32());
                    if (riStream.Error())
                        return 0;  // error or end of file
                    continue;
                case iScriptNullString:
                    if (iScriptVersion >= iScriptVersionCompressParams)
                    {
                        Assert(piPrevRecord != 0);
                        Assert(fSameOpcode);
                        if (piPrevRecord)
                            pParams->SetMsiString(iArg, *MsiString(piPrevRecord->GetMsiString(iArg)));
                    }
                    continue;
                case iScriptNullArg:
                    continue;
                default:
                    Assert(0);
                    continue;
            };
        }
        Bool fDBCS = fFalse;
        switch (cLenType & iScriptTypeMask)
        {
            case iScriptDBCSString:
                fDBCS = fTrue;
            case iScriptSBCSString:
            {
                MsiString istrValue;
                CTempBuffer<char, 1> rgchBuf(cLen); // no null terminator needed
                riStream.GetData(rgchBuf, cLen);
                if (riStream.Error())
                    return 0;  // error or end of file
                int cch = cLen;
                // optimization - if not DBCS by avoid the extra conversion call
                if (fDBCS)
                    cch = WIN::MultiByteToWideChar(CP_ACP, 0, rgchBuf, cLen, 0, 0);
                ICHAR* pch = istrValue.AllocateString(cch, fFalse);
                WIN::MultiByteToWideChar(CP_ACP, 0, rgchBuf, cLen, pch, cch);
                pParams->SetMsiString(iArg, *istrValue);
                continue;
            }
            case iScriptBinaryStream:
            {
                PMsiStream pStream(0);
                char* pb = AllocateMemoryStream(cLen, *&pStream);
                riStream.GetData(pb, cLen);
                if (riStream.Error())
                    return 0;  // error or end of file
                pParams->SetMsiData(iArg, pStream);
                continue;
            }
            case iScriptUnicodeString:
            {
                MsiString istrValue;
                ICHAR* pch = istrValue.AllocateString(cLen, fFalse);
                riStream.GetData(pch, cLen * 2);
                if (riStream.Error())
                    return 0;  // error or end of file
                pParams->SetMsiString(iArg, *istrValue);
                continue;
            }
        };
    } // end arg processing loop
    pParams->AddRef();
    if (rpiPrevRecord == 0)
    {
        rpiPrevRecord = &CreateRecord(cRecordParamsStored);
    }
    CopyRecordStringsToRecord(*pParams, *rpiPrevRecord);
#ifdef DEBUG
    // Remember op code
    if (pParams->IsInteger(0))
        rpiPrevRecord->SetInteger(0, pParams->GetInteger(0));
#endif //DEBUG
    return pParams;
}

HANDLE g_hSecurity = 0;

void CMsiServices::SetSecurityID(HANDLE hPipe)
{
    g_hSecurity = hPipe;

}

void EnableSystemAgent(bool fEnable)
{
    #define ENABLE_AGENT 1      //  Enables System Agent scheduling
    #define DISABLE_AGENT 2     //  Disables System Agent scheduling
    #define GET_AGENT_STATUS 3  //  Returns the status of the System Agent without affecting the current state.
    #define AGENT_STOPPED -15  //  Return from GET_AGENT_STATUS if the system agent is completely stopped.
                                  //  Setting the status to ENABLE_AGENT does *not* restart.

    static int iSystemAgent = false;
    if (fEnable)
    {
        if (g_cNoSystemAgent <= -1)
        {
            AssertSz(fFalse, "Extra call to EnableSystemAgent(true)");
            return;
        }
        else
        {
            if (InterlockedDecrement(&g_cNoSystemAgent) >= 0)
                return;
        }

        if (g_hDisableLowDiskEvent)
        {
            // re-enables the low disk warning.
            AssertNonZero(MsiCloseSysHandle(g_hDisableLowDiskEvent));
            g_hDisableLowDiskEvent = 0;
        }
    }
    else
    {
        if (InterlockedIncrement(&g_cNoSystemAgent) != 0)
            return;

        // Disable the system from responding to the "low disk space" broadcast generated by VFAT
        g_hDisableLowDiskEvent = CreateEvent(NULL, FALSE, FALSE, TEXT("DisableLowDiskWarning"));
        if (g_hDisableLowDiskEvent)
            MsiRegisterSysHandle(g_hDisableLowDiskEvent);

    }

    typedef int (__stdcall *PFnSystemAgentEnable)(int enablefunc);
    HINSTANCE hLib = LoadSystemLibrary(TEXT("SAGE"));
    if (hLib)
    {
        PFnSystemAgentEnable pfnSystemAgentEnable;
        pfnSystemAgentEnable = (PFnSystemAgentEnable) WIN::GetProcAddress(hLib,"System_Agent_Enable");
        if (pfnSystemAgentEnable)
        {
            if (!fEnable)
            {
                // save the initial value
                iSystemAgent = pfnSystemAgentEnable(GET_AGENT_STATUS);
            }
            else
            {
                int iSystemAgentCurrent = pfnSystemAgentEnable(GET_AGENT_STATUS);
                if (ENABLE_AGENT == iSystemAgentCurrent)
                {
                    // if we're currently turned on,
                    // the user must have done it in the middle of the install.
                    // don't mess with it.
                    fEnable = true;
                }
                else if (DISABLE_AGENT == iSystemAgent)
                {
                    // we're done with the install, but if it was
                    // off to being with, don't turn it back on.
                    fEnable = false;
                }
            }

            if (AGENT_STOPPED != iSystemAgent)
                pfnSystemAgentEnable(fEnable ? ENABLE_AGENT : DISABLE_AGENT);

        }
		FreeLibrary( hLib );
    }
}

void EnableScreenSaver(bool fRequest)
{
    static BOOL bScreenSaver = false;
    if (!fRequest)
    {
        if (InterlockedIncrement(&g_cNoScreenSaver) == 0)
        {
            // save off the old value - in secure cases, even though we don't disable
            // the screen saver, this allows us to put it back to where it was at the beginning of the
            // install.  If a custom action mucks with the setting, we'll make sure to put it back
            // to the original value.
            WIN::SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, FALSE, &bScreenSaver,  0);

            // check to see whether the screen saver is password protected - if so, don't mess with it.
            bool fSecure = true;  // when in doubt, fail to secure.

            HKEY hKey;
            // Win64: I've checked and it's in 64-bit location.
            LONG lResult = MsiRegOpen64bitKey(HKEY_CURRENT_USER, TEXT("Control Panel\\Desktop"), 0, KEY_READ, &hKey);
            if (ERROR_SUCCESS == lResult)
            {
                DWORD dwType = 0;

                if (g_fWin9X)
                {
                    const ICHAR *szValueName = TEXT("ScreenSaveUsePassword");
                    DWORD dwValue = 0;
                    DWORD cbValue = sizeof(DWORD);

                    lResult = WIN::RegQueryValueEx(hKey, szValueName, 0, &dwType, (byte*) &dwValue, &cbValue);
                    if ((ERROR_SUCCESS == lResult) && (REG_DWORD == dwType) && (0 == dwValue))
                        fSecure = false;
                }
                else
                {
                    const ICHAR *szValueName = TEXT("ScreenSaverIsSecure");
                    ICHAR szValue[4+1] = TEXT(""); // basically just a small buffer.  4 characters is randomly small.
                    DWORD cbValue = 4*sizeof(ICHAR);

                    lResult = WIN::RegQueryValueEx(hKey, szValueName, 0, &dwType, (byte*)szValue, &cbValue);
                    if ((ERROR_SUCCESS == lResult) && (REG_SZ == dwType) && (0 == lstrcmp(szValue, TEXT("0"))))
                        fSecure = false;
                }
                
                RegCloseKey(hKey);
            }

            // disable the screen saver in non-secure settings.
            if (!fSecure)
                WIN::SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, FALSE, NULL, 0);
        }
    }
    else
    {
        AssertSz(g_cNoScreenSaver >= 0, "Extra call to EnableScreenSaver(false)");
        if (InterlockedDecrement(&g_cNoScreenSaver) < 0)
        {
            BOOL bScreenSaverCurrent = false;

            // check the current status.
            WIN::SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, FALSE, &bScreenSaverCurrent,  0);

            // set the screen saver back to normal.
            // We turned it off initially, but if it's on now, we don't want to muck with it.

            if (bScreenSaverCurrent == false)
            {
                WIN::SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, bScreenSaver, NULL,  0);
            }
        }
    }
}

void CMsiServices::SetNoOSInterruptions()
{
    ::SetNoPowerdown();

    // Disable the System agent from kicking off scanDisk, defrag, or compression
    EnableSystemAgent(false);
    EnableScreenSaver(false);

}

void CMsiServices::ClearNoOSInterruptions()
{
    ::ClearNoPowerdown();
    EnableSystemAgent(true);
    EnableScreenSaver(true);
}

void CMsiServices::SetNoPowerdown()
{
    ::SetNoPowerdown();
}

void CMsiServices::ClearNoPowerdown()
{
    ::ClearNoPowerdown();
}


Bool CMsiServices::FTestNoPowerdown()
{
    return ::FTestNoPowerdown();
}



void SetNoPowerdown()
{
    if (InterlockedIncrement(&g_cNoPowerdown) == 0)
        KERNEL32::SetThreadExecutionState(ES_CONTINUOUS | ES_SYSTEM_REQUIRED);

    DEBUGMSG1(TEXT("Incrementing counter to disable shutdown. Counter after increment: %d"), (const ICHAR*)(INT_PTR)g_cNoPowerdown);
}

void ClearNoPowerdown()
{

    if (g_cNoPowerdown <= -1)
    {
        AssertSz(fFalse, "Extra call to ClearNoPowerdown");
        DEBUGMSG(TEXT("Extra call to decrement shutdown counter - shouldn't happen"));
    }
    else
    {
        if (InterlockedDecrement(&g_cNoPowerdown) < 0)
            KERNEL32::SetThreadExecutionState(ES_CONTINUOUS);

        DEBUGMSG1(TEXT("Decrementing counter to disable shutdown. If counter >= 0, shutdown will be denied.  Counter after decrement: %d"), (const ICHAR*)(INT_PTR)g_cNoPowerdown);
    }


}

Bool FTestNoPowerdown()
{
    if(g_cNoPowerdown >= 0)
    {
        DEBUGMSG1(TEXT("Disallowing shutdown.  Shutdown counter: %d"), (const ICHAR*)(INT_PTR)g_cNoPowerdown);
        return fTrue;
    }
    else
    {
        DEBUGMSG(TEXT("Allowing shutdown"));
        return fFalse;
    }
}

#if defined(TRACK_OBJECTS) && defined(SERVICES_DLL)
//____________________________________________________________________________
//
// Array of mappings for tracking objects
//____________________________________________________________________________

Bool CMsiRef<iidMsiServices>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiDatabase>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiCursor>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiTable>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiView>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiRecord>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiStream>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiStorage>::m_fTrackClass = fFalse;

#ifdef cmitObjects

extern const MIT rgmit[cmitObjects];

const MIT   rgmit[cmitObjects] =
{
    iidMsiServices, &(CMsiRef<iidMsiServices>::m_fTrackClass),
    iidMsiDatabase, &(CMsiRef<iidMsiDatabase>::m_fTrackClass),
    iidMsiCursor,   &(CMsiRef<iidMsiCursor>::m_fTrackClass),
    iidMsiTable,    &(CMsiRef<iidMsiTable>::m_fTrackClass),
    iidMsiView,     &(CMsiRef<iidMsiView>::m_fTrackClass),
    iidMsiRecord,   &(CMsiRef<iidMsiRecord>::m_fTrackClass),
    iidMsiStream,       &(CMsiRef<iidMsiStream>::m_fTrackClass),
    iidMsiStorage,  &(CMsiRef<iidMsiStorage>::m_fTrackClass),

};
#endif // cmitObjects


#endif //TRACK_OBJECTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\srclist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       srclist.cpp
//
//--------------------------------------------------------------------------

// srclist.cpp - Source list modification implementation
// __________________________________________________________________________

#include "precomp.h"
#include "_msiutil.h"
#include "_msinst.h"
#include "_srcmgmt.h"
#include "_execute.h"

extern DWORD OpenSpecificUsersSourceListKeyPacked(enum iaaAppAssignment iaaAsgnType, LPCTSTR szUserSID, LPCTSTR szProductOrPatchCodeSQUID, CRegHandle &riHandle, Bool fWrite, bool &fOpenedProductKey, bool &fProductIsSystemOwned);
extern DWORD OpenUserToken(HANDLE &hToken, bool* pfThreadToken=0);
extern apEnum AcceptProduct(const ICHAR* szProductCode, bool fAdvertised, bool fMachine, bool fAppisAssigned); 

CMsiSourceList::CMsiSourceList() : m_pSourceListKey(0), m_fAllowedToModify(false), m_fCurrentUsersProduct(false), m_fReadOnly(true)
{
	m_piServices = ENG::LoadServices();
}

CMsiSourceList::~CMsiSourceList() 
{
	ENG::FreeServices();
}

UINT CMsiSourceList::OpenSourceList(bool fVerifyOnly, bool fMachine, const ICHAR *szProductCode, const ICHAR *szUserName) 
{
	ICHAR szProductSQUID[cchProductCodePacked + 1];
	ICHAR rgchTargetUserStringSID[cchMaxSID];

	// check for invalid args
	size_t cchLen = 0;
	if (szProductCode == 0 ||
		 FAILED(StringCchLength(szProductCode, cchProductCode+1, &cchLen)) ||
		 cchLen != cchProductCode || !PackGUID(szProductCode, szProductSQUID))
	{
		return ERROR_INVALID_PARAMETER;
	}
	if ( !(!fMachine || (!szUserName || !*szUserName)) )
	{
		Assert(0);
		return ERROR_INVALID_PARAMETER;
	}

	m_fReadOnly = fVerifyOnly;
	if (m_fReadOnly)
		DEBUGMSG("Checking registry for verification purposes only.");
	
	// if a username is not provided, the request is to modify the current user or per-machine.
	if (!szUserName || !*szUserName)
	{ 
		// note for 1.1- this is equivalent to =false, as we'll never get fMachine fales and no user via 
		// the SourceList API
		m_fCurrentUsersProduct = !fMachine;
	}
	else
	{
		if (!g_fWin9X)
		{
			DWORD cbSID = cbMaxSID;
			DWORD cchDomain = 0;
			SID_NAME_USE snuTarget;

			char rgchCurrentUserSID[cbMaxSID];
			CAPITempBuffer<char, cbMaxSID> rgchTargetUserSID;
			CAPITempBuffer<ICHAR, 1> rgchTargetUserDomain;
			
			// get the SID from the current thread. If we can't even figure out who we are, all is
			// lost. 
			HANDLE hToken = 0;
			if (!OpenUserToken(hToken, NULL))
			{
				bool bOK = (ERROR_SUCCESS == GetUserSID(hToken, rgchCurrentUserSID));
				CloseHandle(hToken);
				if (!bOK)
					return ERROR_FUNCTION_FAILED;
			}
			else
				return ERROR_FUNCTION_FAILED;			

			// look up the target user of the modification. First call fails, but gets sizes
			LookupAccountName(/*SystemName=*/NULL, szUserName, rgchTargetUserSID, &cbSID, rgchTargetUserDomain, &cchDomain, &snuTarget);
			if ( !rgchTargetUserDomain.Resize(cchDomain) ||
				  !rgchTargetUserSID.Resize(cbSID) )
			{
				// couldn't even get the current threads username. Thats bad.
				DEBUGMSG("Could not retrieve UserName of calling thread.");
				return ERROR_FUNCTION_FAILED;
			}


			// now try and 
			if (!LookupAccountName(/*SystemName=*/NULL, szUserName, rgchTargetUserSID, &cbSID, rgchTargetUserDomain, &cchDomain, &snuTarget))
			{
				// if we couldn't look up the provided users SID, we don't know enough 
				// to modify any managed install, but we can modify our own non-managed if the usernames match.
				DWORD cchThreadUserName=0;
				GetUserName(NULL, &cchThreadUserName);
				CAPITempBuffer<ICHAR, 1> rgchThreadUserName;
				if (!rgchThreadUserName.Resize(cchThreadUserName+1) ||
					 !GetUserName(rgchThreadUserName, &cchThreadUserName))
				{
					// couldn't even get the current threads username. Thats bad.
					DEBUGMSG("Could not retrieve UserName of calling thread.");
					return ERROR_FUNCTION_FAILED;
				}
				
				if (IStrCompI(rgchThreadUserName, szUserName))
				{
					// if the username and current threads username don't match, its definitely not the caller.
					// Admins can know its a bad user, but non-admins can never be told BAD_USERNAME
					return IsAdmin() ? ERROR_BAD_USERNAME : ERROR_ACCESS_DENIED;
				}
				m_fCurrentUsersProduct = true;
			}
			else
			{
				// we were able to get everybody's SID, so we can determine who we are trying to play with.
				m_fCurrentUsersProduct = (EqualSid(rgchTargetUserSID, rgchCurrentUserSID)) ? true : false;
				
				if (!m_fCurrentUsersProduct)
					GetStringSID((PISID)(char *)rgchTargetUserSID, rgchTargetUserStringSID);
			}
		}
		else
		{
			// win9x
			DWORD cchThreadUserName=15;
			CAPITempBuffer<ICHAR, 15> rgchThreadUserName;
			BOOL fSuccess = GetUserName(rgchThreadUserName, &cchThreadUserName);
			if (!fSuccess)
			{
				if ( rgchThreadUserName.Resize(cchThreadUserName+1) )
					fSuccess = GetUserName(rgchThreadUserName, &cchThreadUserName);
			}
			if (!fSuccess)
			{
				// couldn't even get the current threads username. Thats bad.
				DEBUGMSG("Could not retrieve UserName of calling thread.");
				return ERROR_FUNCTION_FAILED;
			}
				
			m_fCurrentUsersProduct = !IStrCompI(rgchThreadUserName, szUserName);
		}

		if (m_fCurrentUsersProduct)
		{
			DEBUGMSG("Product to be modified belongs to current user.");
		}
		else
		{
			if (g_fWin9X)
			{
				DEBUGMSG(TEXT("Attempting to modify per-user managed install for another user on Win9X."));
				return ERROR_BAD_USERNAME;
			}
			DEBUGMSG1(TEXT("Attempting to modify per-user managed install for user %s."), (ICHAR *)rgchTargetUserStringSID);
		}
	}
	
	// if we're trying to open somebody else's product, we must be an admin
	if (!fMachine && !m_fCurrentUsersProduct && !IsAdmin())
	{
		DEBUGMSG("Non-Admin attempting to open another users per-user product. Access denied.");
		return ERROR_ACCESS_DENIED;
	}	

	// open the root sourcelist key
	DWORD dwResult=0;
	bool fOpenedProductKey = false;
	bool fSystemOwned = false;
	
	DEBUGMSG1("Opening per-%s SourceList.", fMachine ? "machine managed" : (g_fWin9X ? "user" : "user managed"));
	{
		CElevate elevate;
		dwResult = OpenSpecificUsersSourceListKeyPacked(fMachine ? iaaMachineAssign : (g_fWin9X ? iaaUserAssignNonManaged : iaaUserAssign), 
			(fMachine || m_fCurrentUsersProduct) ? NULL : rgchTargetUserStringSID, szProductSQUID, m_hProductKey, m_fReadOnly ? fFalse : fTrue, fOpenedProductKey, fSystemOwned);
	}

	if (ERROR_SUCCESS != dwResult && fOpenedProductKey)
	{
		// we weren't able to open the sourcelist, but could the product key was there. This means that
		// the sourcelist is hosed. (Possibly the SourceList has different ACLs than it should and is denying
		// us access. But if thats true it might as well be greek.)
		DEBUGMSG("Couldn't open SourceList key, but could open product key. Corrupt SourceList?");
		return ERROR_BAD_CONFIGURATION;
	}
	
	// if opening per user for the current user, try non-managed on failure
	if (!g_fWin9X && (ERROR_SUCCESS != dwResult) && m_fCurrentUsersProduct)
	{
		// note that we don't pass fSystemOwned. For managed installs, fSystemOwned is "really managed, not spoofed.". 
		// for user installs, its never managed, even if the system owns the key. 
		bool fDontCareSystemOwned = false;
		Assert(!fMachine);
		DEBUGMSG("Managed install not found. Attempting to open per-user non managed SourceList.");
		CElevate elevate;
		dwResult = OpenSpecificUsersSourceListKeyPacked(iaaUserAssignNonManaged, 
			(fMachine || m_fCurrentUsersProduct) ? NULL : rgchTargetUserStringSID, szProductSQUID, m_hProductKey, m_fReadOnly ? fFalse : fTrue, fOpenedProductKey, fDontCareSystemOwned);

		// same check for bad sourcelist as above
		if (ERROR_SUCCESS != dwResult)
		{
			if (fOpenedProductKey)
			{
				// same check as above
				DEBUGMSG("Couldn't open SourceList key, but could open product key. Corrupt SourceList?");
				return ERROR_BAD_CONFIGURATION;
			}
		}
	}

	if (ERROR_SUCCESS != dwResult)
	{
		DEBUGMSG1(TEXT("SourceList for product %s not found."), szProductCode);
		return ERROR_UNKNOWN_PRODUCT;
	}

	m_pSourceListKey = &m_piServices->GetRootKey((rrkEnum)(int)m_hProductKey, ibtCommon); // x86 and ia64 same
	// what in the world could happen here?
	if (!m_pSourceListKey)
		return ERROR_FUNCTION_FAILED;
	
	// if we are not an admin the ability to modify the sourcelist depends on policy, the product 
	// elevation state, and our user rights. If we are an admin, we can do anything. Note that we
	// can't call SafeForDangerousSourceActions(), because it does a search for the product and could
	// find a different product than the one we are modifying. Since we know the product is installed
	// and in what form, and know if the user is an Admin,
	// fSystemOwned==Elevated
	if (!IsAdmin())
	{
		m_fAllowedToModify = NonAdminAllowedToModifyByPolicy(fSystemOwned);
	}
	else 
		m_fAllowedToModify = true;

	DEBUGMSG2(TEXT("User %s %sbe allowed to modify contents of SourceList."), 
		m_fReadOnly ? TEXT("would") : TEXT("will"), m_fAllowedToModify ? TEXT("") : TEXT("not "));

	return ERROR_SUCCESS;
}
	

// wipes the last used source listed for the product. Anybody who can open a specific sourcelist
// is capable of wiping the last used source, as this is not a dangerous operation for elevated
// products
UINT CMsiSourceList::ClearLastUsed()
{
	if ( !m_pSourceListKey )
	{
		AssertSz(0, TEXT("Called AddSource without initializing SourceList object.")); 
		return ERROR_FUNCTION_FAILED;
	}
	if ( m_fReadOnly )
	{
		AssertSz(0, TEXT("Called AddSource with read-only SourceList object.")); 
		return ERROR_ACCESS_DENIED;
	}

	CElevate elevate;
	PMsiRecord pError(0);
	pError = m_pSourceListKey->RemoveValue(szLastUsedSourceValueName, NULL);
	return (pError == 0) ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
}

// returns the type of the last used source as one of isfEnum.
bool CMsiSourceList::GetLastUsedType(isfEnum &isf)
{
	if ( !m_pSourceListKey )
	{
		AssertSz(0, TEXT("Called AddSource without initializing SourceList object.")); 
		return false;
	}

	PMsiRecord pError = 0;
	MsiString strLastUsedSource;

	if ((pError = m_pSourceListKey->GetValue(szLastUsedSourceValueName, *&strLastUsedSource)) != 0)
		return false;

	 // remove REG_EXPAND_SZ token if it exists
	if (strLastUsedSource.Compare(iscStart, TEXT("#%"))) 
		strLastUsedSource.Remove(iseFirst, 2);
	if (!MapSourceCharToIsf(*(const ICHAR*)strLastUsedSource, isf))
		return false;

	return true;
}

// removes all sources of the specific type. This is a dangerous action for secure products
// so the operation must be allowed by policy. If your last used source is of the same type
// that you are trying to clear, it will be cleared as well, otherwise it will be left behind
UINT CMsiSourceList::ClearListByType(isfEnum isfType) 
{
	if ( !m_pSourceListKey )
	{
		AssertSz(0, TEXT("Called AddSource without initializing SourceList object.")); 
		return ERROR_FUNCTION_FAILED;
	}
	if ( m_fReadOnly )
	{
		AssertSz(0, TEXT("Called AddSource with read-only SourceList object.")); 
		return ERROR_ACCESS_DENIED;
	}

	// check that the user is authorized to clear list for this product. 
	if (!m_fAllowedToModify)
		return ERROR_ACCESS_DENIED;

	// open the appropriate subkey
	PMsiRecord piError = 0;
	const ICHAR* szSubKey = 0;
	switch (isfType)
	{
	case isfNet:              szSubKey = szSourceListNetSubKey;   break;
	case isfMedia:            //!!future szSubKey = szSourceListMediaSubKey; break;
	case isfURL:              //!!future szSubKey = szSourceListURLSubKey;   break;
	case isfFullPath:
	case isfFullPathWithFile:
	default:
		AssertSz(0, TEXT("Unsupported type in ClearListByType"));
		return ERROR_INVALID_PARAMETER;
	}
	PMsiRegKey pFormatKey = &m_pSourceListKey->CreateChild(szSubKey, 0);

	PEnumMsiString pEnum(0);
	// GetValueEnum handles case if key is missing.
	if ((piError = pFormatKey->GetValueEnumerator(*&pEnum)) != 0)
		return ERROR_FUNCTION_FAILED;

	const IMsiString* piValueName = 0;
	while ((pEnum == 0) || (pEnum->Next(1, &piValueName, 0) == S_OK))
	{
		CElevate elevate;
		//!! future. if we ever do media, make sure not to delete disk prompt
		if ((piError = pFormatKey->RemoveValue(piValueName->GetString(), NULL)) != 0)
			return ERROR_FUNCTION_FAILED;
		piValueName->Release();
	}

	// clear the last used source if its type matches our type
	isfEnum isfLastUsed;
	if (GetLastUsedType(isfLastUsed) && (isfLastUsed == isfType))
	{
		DEBUGMSG("Last used type is network. Clearing LastUsedSource.");
		return ClearLastUsed();
	}

	return ERROR_SUCCESS;
}


bool CMsiSourceList::NonAdminAllowedToModifyByPolicy(bool fElevated)
{
	// disable browse always disables
	if (GetIntegerPolicyValue(szDisableBrowseValueName, fTrue) == 1)
		return false;
	// allow lockdown brose always enables
	if (GetIntegerPolicyValue(szAllowLockdownBrowseValueName, fTrue) == 1)
		return true;
	// otherwise only modify non-elevated
	if ((GetIntegerPolicyValue(szAlwaysElevateValueName, fTrue) == 1) &&
		(GetIntegerPolicyValue(szAlwaysElevateValueName, fFalse) == 1))
		return false;
	return !fElevated;
}
		
isfEnum CMsiSourceList::MapIsrcToIsf(isrcEnum isrcSource)
{
	switch (isrcSource)
	{
	case isrcNet : return isfNet;
	case isrcURL : return isfURL;
	case isrcMedia : return isfMedia;
	default: Assert(0);
	}
	return isfNet;
}

UINT CMsiSourceList::AddSource(isfEnum isfType, const ICHAR* szSource)
{
	if ( !m_pSourceListKey )
	{
		AssertSz(0, TEXT("Called AddSource without initializing SourceList object.")); 
		return ERROR_FUNCTION_FAILED;
	}
	if ( m_fReadOnly )
	{
		AssertSz(0, TEXT("Called AddSource with read-only SourceList object.")); 
		return ERROR_ACCESS_DENIED;
	}

	// check that the user is authorized to clear for this product. 
	if (!m_fAllowedToModify)
		return ERROR_ACCESS_DENIED;

	// open the appropriate subkey
	PMsiRecord piError = 0;
	const ICHAR* szSubKey = 0;
	switch (isfType)
	{
	case isfNet:              szSubKey = szSourceListNetSubKey;   break;
	case isfMedia:            //!!future szSubKey = szSourceListMediaSubKey; break;
	case isfURL:              //!!future szSubKey = szSourceListURLSubKey;   break;
	case isfFullPath:
	case isfFullPathWithFile:
	default:
		AssertSz(0, TEXT("Unsupported type in ClearListByType"));
		return ERROR_INVALID_PARAMETER;
	}
	PMsiRegKey pFormatKey = &m_pSourceListKey->CreateChild(szSubKey, 0);

	// add the separator if not present
	MsiString strNewSource = szSource;
	if(!strNewSource.Compare(iscEnd, szDirSep))
		strNewSource += szDirSep; 

	PEnumMsiString pEnumString(0);
	// GetValueEnum handles missing key OK.
	if ((piError = pFormatKey->GetValueEnumerator(*&pEnumString)) != 0)
		return ERROR_FUNCTION_FAILED;

	MsiString strSource;
	Bool fSourceIsInList = fFalse;
	unsigned int iMaxIndex = 0;
	MsiString strIndex;
	while (S_OK == pEnumString->Next(1, &strIndex, 0))
	{
		MsiString strUnexpandedSource;
		if ((piError = pFormatKey->GetValue(strIndex, *&strUnexpandedSource)) != 0)
			return ERROR_FUNCTION_FAILED;

		if (strUnexpandedSource.Compare(iscStart, TEXT("#%"))) 
		{
			strUnexpandedSource.Remove(iseFirst, 2); // remove REG_EXPAND_SZ token
			ENG::ExpandEnvironmentStrings(strUnexpandedSource, *&strSource);
		}
		else
			strSource = strUnexpandedSource;

		int iIndex = strIndex;
		// if we get a bad integer, we got some weird stuff going on in our sourcelist
		// but we should be able to ignore it and add the new source anyway
		if (iIndex == iMsiStringBadInteger)
			continue;

		if (iIndex > iMaxIndex)
			iMaxIndex = iIndex;

		// strNewSource comes from GetPath(), so always ends in a sep char. If the value
		// from the registry doesn't, remove the sep char from a copy of our new path
		// so the comparison will work
		MsiString strNewSourceCopy;
		const IMsiString *pstrNewSource = strNewSource;
		if (!strSource.Compare(iscEnd, szRegSep))
		{
			strNewSourceCopy = strNewSource;
			strNewSourceCopy.Remove(iseLast, 1);
			pstrNewSource = strNewSourceCopy;
		}

		// if the value matches our new source, the new source is already in the 
		// sourcelist for this product
		if (pstrNewSource->Compare(iscExactI, strSource))
		{
			DEBUGMSG(TEXT("Specifed source is already in a list."));
			return ERROR_SUCCESS;
		}
	}

	// construct an index and value for the new source
	MsiString strValue = TEXT("#%"); // REG_EXPAND_SZ
	MsiString strNewIndex((int)(iMaxIndex+1));
	strValue += strNewSource;
	{
		CElevate elevate;
		// elevate for the write
		piError = pFormatKey->SetValue(strNewIndex, *strValue);
		if (piError != 0) 
			return ERROR_FUNCTION_FAILED;
	}
	DEBUGMSG2(TEXT("Added new source '%s' with index '%s'"), (const ICHAR*)strNewSource, (const ICHAR*)strNewIndex);

	return ERROR_SUCCESS;
}
	

//
// SourceList API
//

DWORD SourceListClearByType(const ICHAR *szProductCode, const ICHAR* szUserName, isrcEnum isrcSource)
{
	// check for invalid args. Most args will be checked in OpenSourceList()
	//!! future support more than just isrcNet
	if (isrcSource != isrcNet)
	{
		return ERROR_INVALID_PARAMETER;
	}

	// validate as much as possible before connecting to service
	DWORD dwResult;
	CMsiSourceList SourceList;
	bool fMachine = (!szUserName || !*szUserName);
	if (ERROR_SUCCESS != (dwResult = SourceList.OpenSourceList(/*fVerifyOnly=*/true, fMachine, szProductCode, szUserName)))
		return dwResult;

	// init COM. Need store whether or not to release.
	bool fOLEInitialized = false;
	HRESULT hRes = OLE32::CoInitialize(0);
	if (SUCCEEDED(hRes))
		fOLEInitialized = true;
	else if (RPC_E_CHANGED_MODE != hRes)
		return ERROR_FUNCTION_FAILED;

	// create a connection to the service
	IMsiServer* piServer = CreateMsiServer(); 
	if (!piServer)
		return ERROR_INSTALL_SERVICE_FAILURE;
	else
		DEBUGMSG("Connected to service.");
			
	// call across to the service to clear the source list
	dwResult = piServer->SourceListClearByType(szProductCode, szUserName, isrcSource);

	// release objects
	piServer->Release();
	if (fOLEInitialized)
		OLE32::CoUninitialize();
			
	return dwResult;
}

DWORD SourceListAddSource(const ICHAR *szProductCode, const ICHAR* szUserName, isrcEnum isrcSource, const ICHAR* szSource)
{
	// check for invalid args. Most args will be checked in OpenSourceList()
	//!! future support more than just isrcNet
	if (isrcSource != isrcNet)
	{
		return ERROR_INVALID_PARAMETER;
	}

	if (!szSource || !*szSource)
	{
		return ERROR_INVALID_PARAMETER;
	}

	// validate as much as possible before calling across to service
	DWORD dwResult;
	CMsiSourceList SourceList;
	bool fMachine = (!szUserName || !*szUserName);
	if (ERROR_SUCCESS != (dwResult = SourceList.OpenSourceList(/*fVerifyOnly=*/true, fMachine, szProductCode, szUserName)))
		return dwResult;

	// Init COM. Need to keep track of whether or not we need to call CoUnInit
	bool fOLEInitialized = false;
	HRESULT hRes = OLE32::CoInitialize(0);
	if (SUCCEEDED(hRes))
		fOLEInitialized = true;
	else if (RPC_E_CHANGED_MODE != hRes)
		return ERROR_FUNCTION_FAILED;

	// create a connection to the service
	IMsiServer* piServer = ENG::CreateMsiServer(); 
	if (!piServer)
		return ERROR_INSTALL_SERVICE_FAILURE;
	else
		DEBUGMSG("Connected to service.");
	
	// call across to the service to add the source
	dwResult = piServer->SourceListAddSource(szProductCode, szUserName, isrcSource, szSource);

	// release objects
	piServer->Release();
	if (fOLEInitialized)
		OLE32::CoUninitialize();
			
	return dwResult;
}

DWORD SourceListClearLastUsed(const ICHAR *szProductCode, const ICHAR* szUserName)
{	
	// validate as much as possible before connecting to service
	DWORD dwResult;
	CMsiSourceList SourceList;
	bool fMachine = (!szUserName || !*szUserName);
	if (ERROR_SUCCESS != (dwResult = SourceList.OpenSourceList(/*fVerifyOnly=*/true, fMachine, szProductCode, szUserName)))
		return dwResult;

	// init COM and store whether or not to free.
	bool fOLEInitialized = false;
	HRESULT hRes = OLE32::CoInitialize(0);
	if (SUCCEEDED(hRes))
		fOLEInitialized = true;
	else if (RPC_E_CHANGED_MODE != hRes)
		return ERROR_FUNCTION_FAILED;

	// create connection to service
	IMsiServer* piServer = ENG::CreateMsiServer(); 
	if (!piServer)
		return ERROR_INSTALL_SERVICE_FAILURE;
	else
		DEBUGMSG("Connected to service.");
		
	// call across to service to free last used
	dwResult = piServer->SourceListClearLastUsed(szProductCode, szUserName);

	// release objects
	piServer->Release();
	if (fOLEInitialized)
		OLE32::CoUninitialize();
			
	return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\_autoapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       _autoapi.h
//
//--------------------------------------------------------------------------

#ifndef __AUTOAPI_H_
#define __AUTOAPI_H_

#include <objsafe.h>

#define STRING_GUID_CHARS 38  // for sizing buffers

//____________________________________________________________________________
//
// CVariant definition, VARIANT with access functions
//____________________________________________________________________________

typedef HRESULT DISPERR;  // return value from wrapper functions, HRESULT or UINT
const MSIHANDLE MSI_INVALID_HANDLE = (MSIHANDLE)0xFFFFFFFFL;
const MSIHANDLE MSI_NULL_HANDLE    = (MSIHANDLE)0;

class CVariant : public tagVARIANT {
 public:
	DISPERR GetString(const wchar_t*& rsz);
	DISPERR GetInt(int& ri);
	DISPERR GetInt(unsigned int& ri);
	DISPERR GetInt(unsigned long& ri);
	DISPERR GetBool(Bool& rf);
	DISPERR GetDispatch(IDispatch*& rpiDispatch);
	int  GetType();
	Bool IsRef();
	Bool IsNull();
	Bool IsString();
	Bool IsNumeric();
	MSIHANDLE GetHandle(const IID& riid);
 private:
	void ConvRef(int type);

 friend class CAutoArgs;
};

//____________________________________________________________________________
//
// CAutoArgs definition, access to automation variant arguments
// operator[] returns CVariant& argument 1 to n, 0 for property value
//____________________________________________________________________________

enum varVoid {fVoid};

class CAutoArgs
{
 public:
	CAutoArgs(DISPPARAMS* pdispparams, VARIANT* pvarResult, WORD wFlags);
	CVariant& operator[](unsigned int iArg); // 1-based, 0 for property value
	Bool Present(unsigned int iArg);
	Bool PropertySet();
	unsigned int GetLastArg();
	CVariant* ResultVariant();
	DISPERR ReturnBSTR(BSTR bstr);
	DISPERR Assign(const wchar_t* wsz);
	DISPERR Assign(int             i);
	DISPERR Assign(unsigned int    i);
	DISPERR Assign(long            i);
	DISPERR Assign(unsigned long   i);
	DISPERR Assign(short           i);
	DISPERR Assign(unsigned short  i);
	DISPERR Assign(Bool            f);
	DISPERR Assign(FILETIME&     rft);
	DISPERR Assign(IDispatch*     pi);
	DISPERR Assign(varVoid         v);
	DISPERR Assign(void*          pv);
	DISPERR Assign(const char*    sz);
	DISPERR Assign(IEnumVARIANT&  ri);
	DISPERR Assign(DATE&       rdate);
//  DISPERR Assign(const wchar_t& wrsz);
	
 protected:
	int       m_cArgs;
	int       m_cNamed;
	long*     m_rgiNamed;
	CVariant* m_rgvArgs;
	CVariant* m_pvResult;
	int       m_wFlags;
	int       m_iLastArg;
};

class CAutoBase;

enum aafType
{
	 aafMethod=DISPATCH_METHOD,
	 aafPropRW=DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT,
	 aafPropRO=DISPATCH_PROPERTYGET,
	 aafPropWO=DISPATCH_PROPERTYPUT
};

template<class T> struct DispatchEntry
{
	short          dispid;
	unsigned short helpid;
	aafType        aaf;
	DISPERR (T::*  pmf)(CAutoArgs& args);
	wchar_t*       sz;
	operator DispatchEntry<CAutoBase>*()
	{return (DispatchEntry<CAutoBase>*)this;}
}; // assumption made that CAutoBase is the first or only base class of T

//____________________________________________________________________________
//
// CEnumVARIANTBSTR definition
//____________________________________________________________________________

struct CEnumBuffer
{
	int iRefCnt;
	int cItems;   // number of strings
	int cbSize;   // size of allocation
}; // followed by repeating units of 16-bit length followed by Unicode string, no null terminator

class IMsiCollection : public IEnumVARIANT
{
 public:
	virtual HRESULT       __stdcall Item(unsigned long iIndex, VARIANT* pvarRet)=0;
	virtual unsigned long __stdcall Count()=0;
};

class CEnumVARIANTBSTR : public IMsiCollection
{
 public:
	HRESULT       __stdcall QueryInterface(const GUID& riid, void** ppi);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT       __stdcall Next(unsigned long cItem, VARIANT* rgvarRet,
										  unsigned long* cItemRet);
	HRESULT       __stdcall Skip(unsigned long cItem);
	HRESULT       __stdcall Reset();
	HRESULT       __stdcall Clone(IEnumVARIANT** ppiRet);
	unsigned long __stdcall Count();
	HRESULT       __stdcall Item(unsigned long iIndex, VARIANT* pvarRet);
 public:
   CEnumVARIANTBSTR(CEnumBuffer& rBuffer);
 protected:
  ~CEnumVARIANTBSTR();  // protected to prevent creation on stack
	int    m_iRefCnt;
	int    m_cItems;
	int    m_iItem;
	WCHAR* m_pchNext;
	int    m_iLastItem;
	WCHAR* m_pchLastItem;
	CEnumBuffer& m_rBuffer;
};  

//
//____________________________________________________________________________
//
// CEnumVARIANTRECORD definition
//____________________________________________________________________________
//

struct VolumeCost
{
	WCHAR*   m_szDrive;
	int      m_iCost;
	int      m_iTempCost;
	VolumeCost(WCHAR* szDrive, const size_t cchDrive, int iCost, int iTempCost) : 
				  m_szDrive(NULL), m_iCost(iCost), m_iTempCost(iTempCost)
	{
		if (szDrive && *szDrive)
		{
			m_szDrive = new WCHAR[cchDrive];
			if ( m_szDrive )
				StringCchCopyW(m_szDrive, cchDrive, szDrive);
		}
	}
	~VolumeCost() { if ( m_szDrive ) delete [] m_szDrive; }
};

class CEnumVARIANTRECORD : public IMsiCollection
{
 public:
	HRESULT       __stdcall QueryInterface(const GUID& riid, void** ppi);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT       __stdcall Next(unsigned long cItem, VARIANT* rgvarRet,
										  unsigned long* cItemRet);
	HRESULT       __stdcall Skip(unsigned long cItem);
	HRESULT       __stdcall Reset();
	HRESULT       __stdcall Clone(IEnumVARIANT** ppiRet);
	unsigned long __stdcall Count();
	HRESULT       __stdcall Item(unsigned long iIndex, VARIANT* pvarRet);
 public:
	CEnumVARIANTRECORD(CEnumBuffer& rBuffer);
 protected:
	~CEnumVARIANTRECORD();  // protected to prevent creation on stack
	HRESULT       __stdcall ReturnItem(int iItem, VARIANT* pItemp);
	int    m_iRefCnt;
	int    m_cItems;
	int    m_iItem;
	CEnumBuffer& m_rBuffer;
};  


//____________________________________________________________________________
//
// CAutoBase definition, common implementation class for IDispatch
//____________________________________________________________________________

class CAutoBase : public IDispatch  // class private to this module
{
 public:   // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT       __stdcall GetTypeInfoCount(unsigned int *pcTinfo);
	HRESULT       __stdcall GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo** ppi);
	HRESULT       __stdcall GetIDsOfNames(const IID& riid, OLECHAR** rgszNames,
													unsigned int cNames, LCID lcid, DISPID* rgDispId);
	HRESULT       __stdcall Invoke(DISPID dispid, const IID&, LCID lcid, WORD wFlags,
											DISPPARAMS* pdispparams, VARIANT* pvarResult,
											EXCEPINFO* pexcepinfo, unsigned int* puArgErr);
 public:  // method to access underlying handle, non-virtual
	MSIHANDLE     __stdcall GetHandle();
 protected: // constructor, no destructor - use Release to obtain correct order of destruction
	CAutoBase(DispatchEntry<CAutoBase>* pTable, int cDispId, const IID& riid, MSIHANDLE hMsi);
 protected:
	int         m_iRefCnt;
	DispatchEntry<CAutoBase>* m_pTable;
	int         m_cDispId;
	const IID&  m_riid;
	MSIHANDLE   m_hMsi;
 private:
};

typedef DispatchEntry<CAutoBase> DispatchEntryBase;


//____________________________________________________________________________
//
// Automation wrapper class definitions
//____________________________________________________________________________

class CObjectSafety : public IObjectSafety
{
 public: // implementation of IObjectSafety
	HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT __stdcall GetInterfaceSafetyOptions(const IID& riid, DWORD* pdwSupportedOptions, DWORD* pdwEnabledOptions);
	HRESULT __stdcall SetInterfaceSafetyOptions(const IID& riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);
	IUnknown* This;  // parent object
};

class CAutoInstall : public CAutoBase
{
 public:
	CAutoInstall(MSIHANDLE hBase);
	DISPERR OpenProduct    (CAutoArgs& args);
	DISPERR OpenPackage    (CAutoArgs& args);
	DISPERR OpenDatabase   (CAutoArgs& args);
	DISPERR CreateRecord   (CAutoArgs& args);
	DISPERR SummaryInformation(CAutoArgs& args);
	DISPERR UILevel        (CAutoArgs& args);
	DISPERR EnableLog      (CAutoArgs& args);
	DISPERR ExternalUI     (CAutoArgs& args);
	DISPERR InstallProduct (CAutoArgs& args);
	DISPERR Version        (CAutoArgs& args);
	DISPERR LastErrorRecord(CAutoArgs& args);
	DISPERR RegistryValue  (CAutoArgs& args);
	DISPERR FileAttributes (CAutoArgs& args);
	DISPERR FileSize       (CAutoArgs& args);
	DISPERR FileVersion    (CAutoArgs& args);
	DISPERR Environment    (CAutoArgs& args);
	DISPERR ProductState      (CAutoArgs& args);
	DISPERR ProductInfo       (CAutoArgs& args);
	DISPERR ConfigureProduct  (CAutoArgs& args);
	DISPERR ReinstallProduct  (CAutoArgs& args);
	DISPERR CollectUserInfo   (CAutoArgs& args);
	DISPERR ApplyPatch        (CAutoArgs& args);
	DISPERR FeatureParent     (CAutoArgs& args);
	DISPERR FeatureState      (CAutoArgs& args);
	DISPERR UseFeature        (CAutoArgs& args);
	DISPERR FeatureUsageCount (CAutoArgs& args);
	DISPERR FeatureUsageDate  (CAutoArgs& args);
	DISPERR ConfigureFeature  (CAutoArgs& args);
	DISPERR ReinstallFeature  (CAutoArgs& args);
	DISPERR ProvideComponent  (CAutoArgs& args);
	DISPERR ComponentPath     (CAutoArgs& args);
	DISPERR ProvideQualifiedComponent (CAutoArgs& args);
	DISPERR QualifierDescription(CAutoArgs& args);
	DISPERR ComponentQualifiers(CAutoArgs& args);
	DISPERR Products       (CAutoArgs& args);
	DISPERR Features       (CAutoArgs& args);
	DISPERR Components     (CAutoArgs& args);
	DISPERR ComponentClients(CAutoArgs& args);
	DISPERR Patches        (CAutoArgs& args);
	DISPERR RelatedProducts(CAutoArgs& args);
	DISPERR PatchInfo      (CAutoArgs& args);
	DISPERR PatchTransforms(CAutoArgs& args);
	DISPERR AddSource      (CAutoArgs& args);
	DISPERR ClearSourceList(CAutoArgs& args);
	DISPERR ForceSourceListResolution(CAutoArgs& args);
	DISPERR GetShortcutTarget(CAutoArgs& args);
	DISPERR FileHash       (CAutoArgs& args);
	DISPERR FileSignatureInfo(CAutoArgs& args);
 private:
	HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj);
	CObjectSafety m_ObjectSafety;
};

class CAutoRecord : public CAutoBase
{
 public:
	CAutoRecord(MSIHANDLE hRecord);
	DISPERR FieldCount (CAutoArgs& args);
	DISPERR StringData (CAutoArgs& args);
	DISPERR IntegerData(CAutoArgs& args);
	DISPERR SetStream  (CAutoArgs& args);
	DISPERR ReadStream (CAutoArgs& args);
	DISPERR DataSize   (CAutoArgs& args);
	DISPERR IsNull     (CAutoArgs& args);
	DISPERR ClearData  (CAutoArgs& args);
	DISPERR FormatText (CAutoArgs& args);
	DISPERR GetHandle  (CAutoArgs& args);
};

class CAutoDatabase : public CAutoBase
{
 public:
	CAutoDatabase(MSIHANDLE hDatabase);
	DISPERR OpenView            (CAutoArgs& args);
	DISPERR PrimaryKeys         (CAutoArgs& args);
	DISPERR Import              (CAutoArgs& args);
	DISPERR Export              (CAutoArgs& args);
	DISPERR Merge               (CAutoArgs& args);
	DISPERR GenerateTransform   (CAutoArgs& args);
	DISPERR ApplyTransform      (CAutoArgs& args);
	DISPERR Commit              (CAutoArgs& args);
	DISPERR DatabaseState       (CAutoArgs& args);
	DISPERR SummaryInformation  (CAutoArgs& args);
	DISPERR EnableUIPreview     (CAutoArgs& args);
	DISPERR TablePersistent     (CAutoArgs& args);
	DISPERR CreateTransformSummaryInfo (CAutoArgs& args);
	DISPERR GetHandle           (CAutoArgs& args);
};

class CAutoView : public CAutoBase
{
 public:
	CAutoView(MSIHANDLE hView);
	DISPERR Execute       (CAutoArgs& args);
	DISPERR Fetch         (CAutoArgs& args);
	DISPERR Modify        (CAutoArgs& args);
	DISPERR Close         (CAutoArgs& args);
	DISPERR ColumnInfo    (CAutoArgs& args);
	DISPERR GetError      (CAutoArgs& args);
};

class CAutoSummaryInfo : public CAutoBase
{
 public:
	CAutoSummaryInfo(MSIHANDLE hSummaryInfo);
	DISPERR Property           (CAutoArgs& args);
	DISPERR PropertyCount      (CAutoArgs& args);
	DISPERR Persist            (CAutoArgs& args);
};

class CAutoEngine : public CAutoBase
{
 public:
	CAutoEngine(MSIHANDLE hEngine, CAutoInstall* piInstaller, DWORD dwThreadId);
	unsigned long __stdcall Release();
	DISPERR Application          (CAutoArgs& args);
	DISPERR Property             (CAutoArgs& args);
	DISPERR Language             (CAutoArgs& args);
	DISPERR Mode                 (CAutoArgs& args);
	DISPERR Database             (CAutoArgs& args);
	DISPERR SourcePath           (CAutoArgs& args);
	DISPERR TargetPath           (CAutoArgs& args);
	DISPERR DoAction             (CAutoArgs& args);
	DISPERR Sequence             (CAutoArgs& args);
	DISPERR EvaluateCondition    (CAutoArgs& args);
	DISPERR FormatRecord         (CAutoArgs& args);
	DISPERR Message              (CAutoArgs& args);
	DISPERR FeatureCurrentState  (CAutoArgs& args);
	DISPERR FeatureRequestState  (CAutoArgs& args);
	DISPERR FeatureValidStates   (CAutoArgs& args);
	DISPERR FeatureCost          (CAutoArgs& args);
	DISPERR ComponentCosts       (CAutoArgs& args);
	DISPERR ComponentCurrentState(CAutoArgs& args);
	DISPERR ComponentRequestState(CAutoArgs& args);
	DISPERR SetInstallLevel      (CAutoArgs& args);
	DISPERR VerifyDiskSpace      (CAutoArgs& args);
	DISPERR ProductProperty      (CAutoArgs& args);
	DISPERR FeatureInfo          (CAutoArgs& args);

	DWORD m_dwThreadId;
 private:
	CAutoInstall* m_piInstaller;
};

class CAutoUIPreview : public CAutoBase
{
 public:
	CAutoUIPreview(MSIHANDLE hPreview);
	DISPERR Property        (CAutoArgs& args);
	DISPERR ViewDialog      (CAutoArgs& args);
	DISPERR ViewBillboard   (CAutoArgs& args);
};

class CAutoFeatureInfo : public CAutoBase
{
 public:
	CAutoFeatureInfo();
	bool Initialize(MSIHANDLE hProduct, const WCHAR* szFeature);
	DISPERR Title        (CAutoArgs& args);
	DISPERR Description  (CAutoArgs& args);
	DISPERR Attributes   (CAutoArgs& args);
 private:
	ULONG m_iAttributes;
	WCHAR m_szTitle[100];
	WCHAR m_szDescription[256];
	WCHAR m_szFeature[STRING_GUID_CHARS+1];
	MSIHANDLE m_hProduct;
};

class CAutoCollection : public CAutoBase
{
 public:
	CAutoCollection(IMsiCollection& riEnum, const IID& riid);
	unsigned long __stdcall Release();
	DISPERR _NewEnum(CAutoArgs& args);
	DISPERR Count   (CAutoArgs& args);
	DISPERR Item    (CAutoArgs& args);
 private:
	IMsiCollection& m_riEnum;
};



#endif // __AUTOAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\transfrm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       transfrm.cpp
//
//--------------------------------------------------------------------------

/* tramsfrm.cpp - database transform and merge implementation

____________________________________________________________________________*/

#include "precomp.h" 
#include "_databas.h"// CMsiTable, CMsiCursor, CMsiDatabase, CreateString() factory
#include "tables.h" // table and column name definitions

const GUID STGID_MsiTransform1= GUID_STGID_MsiTransform1;
const GUID STGID_MsiTransform2= GUID_STGID_MsiTransform2;

const int fTransformAdd    = 1;  // + persistent columns count << 2
const int fTransformSpecial= 3;  // special operation, determined by other bits
const int fTransformDelete = 0;
const int fTransformUpdate = 0;  // + bit masks for changed columns
const int fTransformForceOpen = -1;
const int iTransformThreeByteStrings = 3;
const int iTransformFourByteMasks = 7;
const int iTransformColumnCountShift = 8; // for use with fTransformAdd

MsiStringId MapString(IMsiDatabase &db1, IMsiDatabase &db2, MsiStringId strId1)
/*------------------------------------------------------------------------------
Given a string ID from database1, returns the ID for the identical string
in database2, or -1 if the string doesn't exist in database2.
------------------------------------------------------------------------------*/
{
	const IMsiString* pistr1 = &db1.DecodeString(strId1);
	const IMsiString* pistr2 = &db2.DecodeString(strId1);
	MsiStringId id = 0;

	if (pistr1->Compare(iscExact, pistr2->GetString()))
	{
		id = strId1;
	}
	else
	{
		id = db2.EncodeStringSz(pistr1->GetString());
		id = id ? id : -1;
	}

	pistr1->Release();
	pistr2->Release();
	return id;
}

//____________________________________________________________________________
//
// CMsiDatabase merge implementation
//____________________________________________________________________________

IMsiRecord* CMsiDatabase::MergeDatabase(IMsiDatabase& riRefDb, IMsiTable* pMergeErrorTable)
{
	IMsiRecord* piError;

	int cTableMergeFailures = 0;
	int cRowMergeFailures = 0;

	// check that the refDb is not the reference to the baseDb
	// can open up several instances of the database, but if base is passed in as ref as
	// well, then return error
	if (this == &riRefDb)
		return PostError(Imsg(idbgMergeRefDbSameAsBaseDb));

	// check that base database is open for read/write
	// if not, notify user that no changes will occur
	if (GetUpdateState() == idsRead)
		return PostError(Imsg(idbgMergeBaseDatabaseNotWritable));

	Bool fSetupMergeErrorTable = fFalse;
	if (pMergeErrorTable != NULL)
		fSetupMergeErrorTable = fTrue;
	
	// Insure that there is no codepage conflict between databases
	int iCodepageMerge = riRefDb.GetANSICodePage();
	if (iCodepageMerge != m_iCodePage)
	{
		if (m_iCodePage == LANG_NEUTRAL)
			m_iCodePage = iCodepageMerge;  
		else if ((iCodepageMerge != LANG_NEUTRAL) && (iCodepageMerge != m_iCodePage))
			return PostError(Imsg(idbgTransCodepageConflict), iCodepageMerge, m_iCodePage);
	}

	// Open reference database's table catalog and create cursor for it
	PMsiTable pRefTableCatalog(riRefDb.GetCatalogTable(0));
	Assert(pRefTableCatalog);
	PMsiCursor pRefTableCatalogCursor(pRefTableCatalog->CreateCursor(fFalse));
	if (pRefTableCatalogCursor == 0)
		return PostOutOfMemory();
	((CMsiCursor*)(IMsiCursor*)pRefTableCatalogCursor)->m_idsUpdate = idsRead; //!!FIX allow temp column updates

	// Create a cursor for base database's table catalog
	PMsiCursor pBaseCatalogCursor(m_piCatalogTables->CreateCursor(fFalse));
	if (pBaseCatalogCursor == 0)
		return PostOutOfMemory();

	// Prepare ref catalog table for marking
	int iTempCol;
	AddMarkingColumn(*pRefTableCatalog, *pRefTableCatalogCursor, iTempCol);
	
	// Check tables in base catalog against those in reference catalog
	pRefTableCatalogCursor->Reset();
	pRefTableCatalogCursor->SetFilter(iColumnBit(ctcName));

	// loop through all the tables that exist in both databases, checking for
	// mismatched types
	PMsiTable pRefTable(0);
	PMsiTable pBaseTable(0);
	while (pBaseCatalogCursor->Next())
	{
		MsiString strTableName(pBaseCatalogCursor->GetString(ctcName));
		pRefTableCatalogCursor->Reset();
		AssertNonZero(pRefTableCatalogCursor->PutString(ctcName, *strTableName));
		if (CompareTableName(*pRefTableCatalogCursor, iTempCol))
		{	
			// these are not used.
			int cExtraColumn = 0;
			int cBaseColumn  = 0;
			int cPrimaryKey  = 0;

			// Load both tables
			if ((piError = riRefDb.LoadTable(*strTableName, 0, *&pRefTable)) != 0)
				return piError;			
			if ((piError = LoadTable(*strTableName, 0, *&pBaseTable)) != 0)
				return piError;

			piError = CheckTableProperties(cExtraColumn, cBaseColumn, cPrimaryKey,
				*pBaseTable, *pRefTable, *strTableName, *this, riRefDb);
			if (piError)
				return piError;
		}
	}

	// reset and loop through all tables again, actually performing merge.
	pRefTableCatalogCursor->Reset();	
	pRefTableCatalogCursor->SetFilter(iColumnBit(iTempCol));
	pRefTableCatalogCursor->PutInteger(iTempCol, (int)fTrue);
	while (pRefTableCatalogCursor->Next())
	{
		MsiString strTableName(pRefTableCatalogCursor->GetString(ctcName));
		piError = MergeCompareTables(*strTableName, *this, riRefDb, cRowMergeFailures, fSetupMergeErrorTable, 
									 pMergeErrorTable);
		if (piError)
			return piError;
		if (cRowMergeFailures)
			cTableMergeFailures++;
	}

	// Add the new tables in the reference catalog to the base database
	pRefTableCatalogCursor->Reset();
	pRefTableCatalogCursor->PutInteger(iTempCol, (int)fFalse);
	while (pRefTableCatalogCursor->Next()) // For every unprocessed table in ref catalog
	{
		// Load unprocessed table
		PMsiTable pUnprocTable(0);
		MsiString strTableName(pRefTableCatalogCursor->GetString(ctcName));
		if ((piError = riRefDb.LoadTable(*strTableName, 0, *&pUnprocTable)) != 0)
			return piError;

		// Create cursor for unprocessed table
		PMsiCursor pUnprocTableCursor(pUnprocTable->CreateCursor(fFalse));
		Assert(pUnprocTableCursor);

		// Create & copy table into base database
		int cRow = pUnprocTable->GetRowCount();
		PMsiTable pNewTable(0);
		piError = CreateTable(*strTableName, cRow, *&pNewTable);
		if (piError)
			return piError;

		// Create & copy columns of unprocessed table into new table
		int cColumn = pUnprocTable->GetPersistentColumnCount();
		for (int iCol = 1; iCol <= cColumn; iCol++)
		{
			int iColType = pUnprocTable->GetColumnType(iCol);
			int iNewCol = pNewTable->CreateColumn(iColType, *MsiString(riRefDb.DecodeString(pUnprocTable->GetColumnName(iCol))));
			Assert(iNewCol == iCol);
		}

		// Create cursor for new table
		PMsiCursor pNewTableCursor(pNewTable->CreateCursor(fFalse));
		Assert(pNewTableCursor);

		// Perform merge operation of rows of table
		MergeOperation(*pNewTableCursor, *pUnprocTableCursor, *pUnprocTable, cColumn, cRowMergeFailures);
		if (cRowMergeFailures != 0)
		{
			cTableMergeFailures++;
			if (fSetupMergeErrorTable) // set up columns of error table
			{
				MergeErrorTableSetup(*pMergeErrorTable);
				fSetupMergeErrorTable = fFalse; // set up complete
			}
			if (pMergeErrorTable != NULL)
			{
				if (!UpdateMergeErrorTable(*pMergeErrorTable, *strTableName, cRowMergeFailures, *pNewTable))
					return PostError(Imsg(idbgMergeUnableReportFailures), 0);
			}
		}
	}

	if (cTableMergeFailures != 0)
		return PostError(Imsg(idbgMergeFailuresReported), cTableMergeFailures);

	return 0;
}



IMsiRecord* CMsiDatabase::AddMarkingColumn(IMsiTable& riTable, 
											IMsiCursor& riTableCursor, int& iTempCol)
/*-----------------------------------------------------------------------------
CMsiDatabase::AddMarkingColumn adds a temporary column to the ref table 
catalog so that the column can be marked as processed.

This is used by both GenerateTransform and MergeDatabase
-----------------------------------------------------------------------------*/
{
	// Make temp col in ref tbl catalog for marking processed tables
	iTempCol = riTable.CreateColumn(icdShort|icdTemporary|icdNullable, g_MsiStringNull);
	Assert(iTempCol > 0);

	// Initialize temp marking col to fFalse
	riTableCursor.Reset();
	while (riTableCursor.Next())
	{
		AssertNonZero(riTableCursor.PutInteger(iTempCol, (int)fFalse));
		AssertNonZero(riTableCursor.Update());
	}

	return 0;
}



void CMsiDatabase::MergeErrorTableSetup(IMsiTable& riErrorTable)
/*-------------------------------------------------------------------------------
CMsiDatabase::MergeErrorTableSetup  sets up that table object that was passed in
to record errors.

  Col.1. Primary Key -- name of table, type string
  Col.2.             -- number of rows with merge failures, type integer
  Col.3.             -- pointer to table w/ errors, type object
-------------------------------------------------------------------------------*/
{
	int iTempCol;

	iTempCol = riErrorTable.CreateColumn(icdString + icdPersistent + icdPrimaryKey + 255, *MsiString(*TEXT("Table")));
	Assert(iTempCol != 0);
	if ( iTempCol < 0 )
		iTempCol =  iTempCol * -1;
	m_rgiMergeErrorCol[0] = iTempCol;
	
	iTempCol = riErrorTable.CreateColumn(icdShort + icdPersistent + 2, *MsiString(*TEXT("NumRowMergeConflicts")));
	Assert(iTempCol != 0);
	if ( iTempCol < 0 )
		iTempCol = iTempCol * -1;
	m_rgiMergeErrorCol[1] = iTempCol;
	
	iTempCol = riErrorTable.CreateColumn(icdObject + icdTemporary, g_MsiStringNull);
	Assert(iTempCol != 0);
	if ( iTempCol < 0 )
		iTempCol = iTempCol * -1;
	m_rgiMergeErrorCol[2] = iTempCol;
}



Bool CMsiDatabase::UpdateMergeErrorTable(IMsiTable& riErrorTable, const IMsiString& riTableName,
										 int cRowMergeFailures, IMsiTable& riTableWithError)
/*-------------------------------------------------------------------------------
CMsiDatabase::UpdateMergeErrorTable adds the information into the error table
-------------------------------------------------------------------------------*/
{
	PMsiCursor pMergeErrorTableCursor(riErrorTable.CreateCursor(fFalse));
	//LockTable(riTableName, fTrue);
	Assert(pMergeErrorTableCursor);
	pMergeErrorTableCursor->Reset();
	int iFilter = 1 << (m_rgiMergeErrorCol[0] -1);
	pMergeErrorTableCursor->SetFilter(iFilter);
	pMergeErrorTableCursor->PutString(m_rgiMergeErrorCol[0], riTableName);
	if (!pMergeErrorTableCursor->Next())
		pMergeErrorTableCursor->PutString(m_rgiMergeErrorCol[0], riTableName);
	int iNumFailures = pMergeErrorTableCursor->GetInteger(m_rgiMergeErrorCol[1]);
	if ( iNumFailures != iMsiNullInteger )
		cRowMergeFailures += iNumFailures;
	pMergeErrorTableCursor->PutInteger(m_rgiMergeErrorCol[1], cRowMergeFailures);
	pMergeErrorTableCursor->PutMsiData(m_rgiMergeErrorCol[2], &riTableWithError);
	Bool fStat = pMergeErrorTableCursor->Assign();
	return fStat;
}
	


Bool CMsiDatabase::CompareTableName(IMsiCursor& riCursor, int iTempCol)
/*-------------------------------------------------------------------------------
CMsiDatabase::CompareTableName checks to see that the ref catalog contains the 
particular table found in the base catalog.  If that table is found, the temporary
column is marked true to indicate it has been processed.

  Results:
For Merge database operation
True -- the table can be compared
False -- nothing needs to be done...we are only adding to the base database

For GenerateTransform database operation
True -- the table can be compared
False -- delete table from catalog
---------------------------------------------------------------------------------*/
{
	if (riCursor.Next()) // table in base catalog also in ref catalog
	{
		// mark as done
		riCursor.PutInteger(iTempCol, (int)fTrue); 
		riCursor.Update();
		return fTrue;
	}
	return fFalse;
}



IMsiRecord*  CMsiDatabase::MergeCompareTables(const IMsiString& riTableName, CMsiDatabase& riBaseDB,
											   IMsiDatabase& riRefDb, int& cRowMergeFailures,
											   Bool& fSetupMergeErrorTable, IMsiTable* pErrorTable)
/*----------------------------------------------------------------------------------
CMsiDatabase::MergeCompareTables compares the two tables in the base and reference
database with the same name. Table properties should be the same before attempting
a merge. This method also keeps track of the number of rows in that particular 
table that failed the merge procedure.  This data is output to the error table if
it was provided.
-----------------------------------------------------------------------------------*/
{
	IMsiRecord* piError;
	cRowMergeFailures = 0;

	// Load both tables and Create cursors
	PMsiTable pRefTable(0);
	if ((piError = riRefDb.LoadTable(riTableName, 0, *&pRefTable)) != 0)
		return piError;
	PMsiCursor pRefCursor(pRefTable->CreateCursor(fFalse));
	Assert(pRefCursor);
	
	CComPointer<CMsiTable> piBaseTable(0);
	if ((piError = riBaseDB.LoadTable(riTableName, 0, (IMsiTable *&)*&piBaseTable)) != 0)
		return piError;
	PMsiCursor pBaseCursor(piBaseTable->CreateCursor(fFalse));
	Assert(pBaseCursor);
	
	// table defs should have been checked already via CheckTableProperties().
	// string limits could still be different. If the ref db column has a greater
	// length (or 0, unlimited), modify the base db to accept any longer strings.
	int cBaseColumn = piBaseTable->GetPersistentColumnCount();
	IMsiCursor* pBaseColumnCatalogCursor = NULL; // no ref count when created
	for (int iCol = 1; iCol <= cBaseColumn; iCol++)
	{
		MsiColumnDef iBaseColType = (MsiColumnDef)piBaseTable->GetColumnType(iCol);
		MsiColumnDef iRefColType = (MsiColumnDef)pRefTable->GetColumnType(iCol);
		if (iBaseColType & icdString)
		{
			Assert(iRefColType & icdString);

			if ((!(iRefColType & icdSizeMask) && (iBaseColType & icdSizeMask)) ||
				(iRefColType & icdSizeMask) > (iBaseColType & icdSizeMask))
			{
				// if there is no cursor on the column catalog yet, retrieve one
				if (!pBaseColumnCatalogCursor)
				{
					// only one catalog cursor. no ref count added.
					pBaseColumnCatalogCursor = riBaseDB.GetColumnCursor();
					pBaseColumnCatalogCursor->Reset(); 
					pBaseColumnCatalogCursor->SetFilter(cccTable | cccColumn);
					pBaseColumnCatalogCursor->PutString(cccTable, riTableName);
				}
				// modify the column catalog to reflect the new length
				pBaseColumnCatalogCursor->PutInteger(cccColumn, iCol);
				if (pBaseColumnCatalogCursor->Next())
				{
					pBaseColumnCatalogCursor->PutInteger(cccType, iRefColType);
					pBaseColumnCatalogCursor->Update();
				}
				// modify the internal column definition
				piBaseTable->SetColumnDef(iCol, iRefColType);
			}
		}
	}

	MergeOperation(*pBaseCursor, *pRefCursor, *pRefTable, cBaseColumn, 
										cRowMergeFailures);

	if (cRowMergeFailures)
	{
		if (fSetupMergeErrorTable)
		{
			MergeErrorTableSetup(*pErrorTable);
			fSetupMergeErrorTable = fFalse;
		}
		if (pErrorTable != NULL)
		{
			if (!UpdateMergeErrorTable(*pErrorTable, riTableName, cRowMergeFailures, *piBaseTable))
				return PostError(Imsg(idbgMergeUnableReportFailures), 0);
		}
	}

	return 0;
}

const int iSchemaCheckMask = icdShort | icdObject | icdPrimaryKey | icdNullable; // ignore localize and SQL width
IMsiRecord* CMsiDatabase::CheckTableProperties(int& cExtraColumns, int& cBaseColumn, 
											   int& cPrimaryKey, IMsiTable& riBaseTable, 
											   IMsiTable& riRefTable, const IMsiString& riTableName,
											   IMsiDatabase& riBaseDb, IMsiDatabase& riRefDb)
/*-------------------------------------------------------------------------------------
CMsiDatabase::CheckTableProperties ensures that the tables have the same characterisitcs.
It checks that the number of primary keys are the same and that the column types are the same.
It also checks that the column names are the same.  It also returns the difference in
the number of columns as this is a special case that is confronted differently by the
merge and transform operations.
-------------------------------------------------------------------------------------*/
{
	// Verify # of primary keys is the same
	if (riBaseTable.GetPrimaryKeyCount() != riRefTable.GetPrimaryKeyCount())
		return PostError(Imsg(idbgTransMergeDifferentKeyCount), riTableName);
	else
		cPrimaryKey = riBaseTable.GetPrimaryKeyCount();

	// Check # of columns
	cBaseColumn = riBaseTable.GetPersistentColumnCount();
	cExtraColumns = riRefTable.GetPersistentColumnCount() - cBaseColumn;
	
	// To make sure column type check succeeds if ref table has fewer cols than base
	// This also ensures that the merge error will be for differing col count and not
	// different col types
	if (cExtraColumns < 0)
		cBaseColumn = riRefTable.GetPersistentColumnCount();

	// Verify column types
	for (int iCol = 1; iCol <= cBaseColumn; iCol++)
	{
		if ((riBaseTable.GetColumnType(iCol) & iSchemaCheckMask)
		  != (riRefTable.GetColumnType(iCol) & iSchemaCheckMask))
			return PostError(Imsg(idbgTransMergeDifferentColTypes), riTableName, iCol);
	}

	// Verify column names
	for (iCol = 1; iCol <= cBaseColumn; iCol++)
	{
		MsiString istrBaseColName(riBaseDb.DecodeString(riBaseTable.GetColumnName(iCol)));
		MsiString istrRefColName(riRefDb.DecodeString(riRefTable.GetColumnName(iCol)));
		if (!istrBaseColName.Compare(iscExact, istrRefColName))
			return PostError(Imsg(idbgTransMergeDifferentColNames), riTableName, iCol);
	}

	// Reset base column count to that of base db table.  Shouldn't have to because
	// error message would occur, but just in case
	cBaseColumn = riBaseTable.GetPersistentColumnCount();

	return 0;
}

void CMsiDatabase::MergeOperation(IMsiCursor& riBaseCursor, IMsiCursor& riRefCursor,
										 IMsiTable& riRefTable, int cColumn, int& cRowMergeErrors) 
/*--------------------------------------------------------------------------------------
CMsiDatabase::MergeOperation copies the ref cursor data into the base cursor so that it
can then merge the data into the base database.  If the merge of this row fails, the 
error count is tallied for helpful information if the error table was provided in the
ole automation call.
-------------------------------------------------------------------------------------*/
{
	// Record row merge failures
	cRowMergeErrors = 0;

	// Reset data in ref cursor
	riRefCursor.Reset();
	riBaseCursor.Reset();

	// Cycle through the table
	while (riRefCursor.Next())
	{
		for (int iCol = 1; iCol <= cColumn; iCol++)
		{
			// Get data from ref cursor and put it into base cursor
			int iColumnDef = riRefTable.GetColumnType(iCol);
			if ((iColumnDef & icdString) == icdString) // string
			{
				riBaseCursor.PutString(iCol, *MsiString(riRefCursor.GetString(iCol)));
			}
			else if ((iColumnDef & (icdObject + icdPersistent)) == (icdObject + icdPersistent)) // stream
			{
				riBaseCursor.PutStream(iCol, PMsiStream(riRefCursor.GetStream(iCol)));
			}
			else if (!(iColumnDef & icdObject)) // int
			{
				riBaseCursor.PutInteger(iCol, riRefCursor.GetInteger(iCol));
			}
		}
		if (!riBaseCursor.Merge())
		{
				cRowMergeErrors++;
		}

		// Clear data in base cursor
		riBaseCursor.Reset();

	}
}

//____________________________________________________________________________
//
// CMsiDatabase transform implementation (Generation)
//____________________________________________________________________________

class CTransformStreamWrite  // constructor args not ref counted, assume valid during life of this object
{
 public:
	CTransformStreamWrite(CMsiDatabase& riTransformDatabase, IMsiStorage* piStorage, IMsiTable& riTable, const IMsiString& riTableName);
  ~CTransformStreamWrite() {if (m_piStream) m_piStream->Release();}
	IMsiRecord* WriteTransformRow(const int iOperationMask, IMsiCursor& riCursor);
	IMsiRecord* CopyStream(IMsiStream& riSourceStream, IMsiCursor& riTableCursor);
	int         GetPersistentColumnCount() {return m_cColumns;}
 private:
	int           m_cColumns;
	int           m_cbStringIndex;
	int           m_cbMask;
	IMsiStream*   m_piStream;
	IMsiStorage*  m_piStorage;
	CMsiDatabase& m_riTransformDb;
	CMsiDatabase& m_riCurrentDb;
	IMsiTable&    m_riTable;
	const IMsiString& m_riTableName;
};

CTransformStreamWrite::CTransformStreamWrite(CMsiDatabase& riTransformDatabase, IMsiStorage* piStorage, IMsiTable& riTable, const IMsiString& riTableName)
	: m_riTransformDb(riTransformDatabase), m_piStorage(piStorage), m_riTable(riTable), m_riTableName(riTableName)
	, m_piStream(0), m_riCurrentDb((CMsiDatabase&)riTable.GetDatabase()), m_cbStringIndex(2), m_cbMask(2)
{
	m_riCurrentDb.Release(); // don't hold ref count
	m_cColumns = riTable.GetPersistentColumnCount();
	if (m_cColumns > 16)
		m_cbMask = 4;
}

/*------------------------------------------------------------------------------
CMsiDatabase::GenerateTransform - Generates a transform using the current 
database as a base.
 
The changes for each table are saved in a stream of the same name
as the table. The tables catalog and columns catalog each have their 
own streams. Additionally, streams are created for the string cache 
and for any streams that are stored within tables.

For each of the following operations, the indicated data is
saved in the transform file.

Add/Update a row: mask key [colData [colData...]]
Delete a row:     mask key
Add a column:     same as add row, but uses columns catalog
Delete a column:  not supported
Add a table:      same as add row, but uses tables catalog
Delete a table:   same as delete row, but uses tables catalog

If (mask == 0x0) then a delete is to be done
else if (mask == 0x1) then an add is to be done.
else if (mask == 0x3) then the rest of the strings in the table have 3-byte indicies
else if (mask&0x1 == 0) then an update is to be done
else error.
 
If an update is to be done then the bits of the mask indicate which
rows are to be updated. The low-order bit is column 1. Column data for 
columns that are being updated or added are saved starting with the 
lowest numbered columns.

The mask defaults to a 16-bit int; if, however, there are more than
16 columns in the table then a 32-bit int is used.
------------------------------------------------------------------------------*/
IMsiRecord* CMsiDatabase::GenerateTransform(IMsiDatabase& riOrigDb, 
														  IMsiStorage* piTransStorage,
														  int /*iErrorConditions*/,
														  int /*iValidation*/)
{
	//!! need to have transform save summary info stream, incl. error conditions and validation
	IMsiRecord* piError;

	CComPointer<CMsiDatabase> pTransDb = new CMsiDatabase(m_riServices);

	if ( ! pTransDb )
		return PostOutOfMemory();

	CDatabaseBlock dbBlk(*this);
	if ((piError = pTransDb->InitStringCache(0)) != 0) 
		return piError;

	const GUID* pguidClass = &STGID_MsiTransform2;
	if (m_fRawStreamNames)  // database running in compatibility mode, no stream name compression
	{
		IMsiStorage* piDummy;
		pguidClass = &STGID_MsiTransform1;
		if (piTransStorage)
			piTransStorage->OpenStorage(0, ismRawStreamNames, piDummy);
	}
	MsiString strTableCatalog (*szTableCatalog);  // need to keep in scope as long as following objects
	MsiString strColumnCatalog(*szColumnCatalog); // as they don't ref count the table names themselves
	CTransformStreamWrite tswTables (*pTransDb, piTransStorage, *m_piCatalogTables, *strTableCatalog);
	CTransformStreamWrite tswColumns(*pTransDb, piTransStorage, *m_piCatalogColumns,*strColumnCatalog);

	// Open original database's table catalog and create a cursor for it
	PMsiTable pOrigTableCatalog = riOrigDb.GetCatalogTable(0);
	Assert(pOrigTableCatalog);
	PMsiCursor pOrigTableCatalogCursor = pOrigTableCatalog->CreateCursor(fFalse);
	Assert(pOrigTableCatalogCursor);
	((CMsiCursor*)(IMsiCursor*)pOrigTableCatalogCursor)->m_idsUpdate = idsRead; //!!FIX allow temp column updates

	// Create a cursor for current (new) database's catalog
	PMsiCursor pNewTableCatalogCursor = m_piCatalogTables->CreateCursor(fFalse);
	Assert(pNewTableCatalogCursor);
	PMsiCursor pNewColumnCatalogCursor = m_piCatalogColumns->CreateCursor(fFalse);
	Assert(pNewColumnCatalogCursor);

	// Open reference database's column catalog and create a cursor for it
	PMsiTable pOrigColumnCatalog = riOrigDb.GetCatalogTable(1);
	Assert(pOrigColumnCatalog);
	PMsiCursor pOrigColumnCatalogCursor = pOrigColumnCatalog->CreateCursor(fFalse);
	Assert(pOrigColumnCatalogCursor);

	// Prepare original catalog table for marking
	int iTempCol;
	AddMarkingColumn(*pOrigTableCatalog, *pOrigTableCatalogCursor, iTempCol);

	// Check tables in current catalog against those in original catalog
	pOrigTableCatalogCursor->Reset();
	pOrigTableCatalogCursor->SetFilter(iColumnBit(ctcName));

	int cbTableCatalogStringIndex = 2;
	int cbColumnCatalogStringIndex = 2;
	Bool fDatabasesAreDifferent = fFalse;
	Bool fTablesAreDifferent;
	while (pNewTableCatalogCursor->Next()) 
	{
		MsiString strTableName = pNewTableCatalogCursor->GetString(ctcName);
		pOrigTableCatalogCursor->Reset(); 
		AssertNonZero(pOrigTableCatalogCursor->PutString(ctcName, *strTableName));
		if (CompareTableName(*pOrigTableCatalogCursor, iTempCol))
		{
			if((piError = TransformCompareTables(*strTableName, *this, 
							riOrigDb, *pTransDb, piTransStorage, tswColumns, 
							fTablesAreDifferent)) != 0)
			{
				return piError;
			}

			if (fTablesAreDifferent)
			{
				fDatabasesAreDifferent = fTrue;
				if (!piTransStorage)
					break;
			}
		}
		else // table in current catalog is not in original catalog
		{
			fDatabasesAreDifferent = fTrue;
			if (!piTransStorage)
				break;

			// Obtain table
			PMsiTable pTable(0);
			if ((piError = LoadTable(*strTableName, 0, *&pTable)) != 0)
				return piError;

			// Add table to catalog
			if ((piError = tswTables.WriteTransformRow(fTransformAdd, *pNewTableCatalogCursor)) != 0)
				return piError;

			// Add columns to catalog
			int iColumnsMask = iColumnBit(cccTable) | iColumnBit(cccName) | iColumnBit(cccType);
			int iColType;
			for (int c = 1; (iColType = pTable->GetColumnType(c)) != -1 && (iColType & icdPersistent); c++)
			{
				pNewColumnCatalogCursor->Reset();
				pNewColumnCatalogCursor->PutString(cccTable, *strTableName);
				pNewColumnCatalogCursor->PutInteger(cccName, pTable->GetColumnName(c));
				pNewColumnCatalogCursor->PutInteger(cccType, iColType);
				if ((piError = tswColumns.WriteTransformRow(fTransformAdd, *pNewColumnCatalogCursor)) != 0)
					return piError;
			}

			// Add rows
			PMsiCursor pCursor(pTable->CreateCursor(fFalse));
			Assert(pCursor);

			CTransformStreamWrite tswNewRows(*pTransDb, piTransStorage, *pTable, *strTableName);
			while (pCursor->Next()) // for every row in this table
			{
				if ((piError = tswNewRows.WriteTransformRow(fTransformAdd, *pCursor)) != 0)
					return piError;
			}
		}

		if (piError)
			return piError;
	}

	if (!(fDatabasesAreDifferent && !piTransStorage)) // skip this if we already know the databases are different and we're not generating a transform
	{
		// Delete tables missing current catalog to transform file
		// Add new tables in current catalog to transform file
		pOrigTableCatalogCursor->Reset();
		pOrigTableCatalogCursor->SetFilter(iColumnBit(iTempCol));
		pOrigTableCatalogCursor->PutInteger(iTempCol, (int)fFalse);

		while (pOrigTableCatalogCursor->Next()) // for every unprocessed table in original catalog
		{
			fDatabasesAreDifferent = fTrue;
			if (!piTransStorage)
				break;
			// delete table from catalog (implicit delete columns)
			if ((piError = tswTables.WriteTransformRow(fTransformDelete, *pOrigTableCatalogCursor)) != 0)
				return piError;
		}
	}

	if (fDatabasesAreDifferent)
	{
		if (piTransStorage)
		{
			pTransDb->m_iCodePage = m_iCodePage; // transform acquires the code page of the current (i.e. new) db

			if ((piError = pTransDb->StoreStringCache(*piTransStorage, 0, 0)) != 0)
				return piError;

			if ((piError = piTransStorage->SetClass(*pguidClass)) != 0)
				return piError;
		}
		return 0;
	}
	
	return PostError(Imsg(idbgTransDatabasesAreSame));
}

IMsiRecord* CMsiDatabase::TransformCompareTables(const IMsiString& riTableName, IMsiDatabase& riNewDb,
													 IMsiDatabase& riOrigDb, CMsiDatabase& riTransDb, IMsiStorage *piTransform,
													 CTransformStreamWrite& tswColumns, Bool& fTablesAreDifferent)
/*------------------------------------------------------------------------------
CMsiDatabase::TransformCompareTables - Compares the table in riNewDb named 
riTableName to the one in riOrigDb, writing the differences to a stream named 
riTableName in the riTransform storage. Updates to the table's schema a written 
to riColumnCatalogStream.
------------------------------------------------------------------------------*/
{
	fTablesAreDifferent = fFalse;

	// Load both tables
	IMsiRecord* piError;
				
	PMsiTable pNewTable(0);	
	if ((piError = riNewDb.LoadTable(riTableName, 0, *&pNewTable)) != 0)
		return piError;
				
	PMsiTable pOrigTable(0);
	if ((piError = riOrigDb.LoadTable(riTableName, 0, *&pOrigTable)) != 0)
		return piError;

	int cPrimaryKey;
	int cNewColumn;
	int cExtraColumns;

	piError = CheckTableProperties(cExtraColumns, cNewColumn, cPrimaryKey, *pOrigTable,
										*pNewTable, riTableName, riOrigDb, riNewDb);
	if (piError)
		return piError;

	if (cExtraColumns < 0)  // more base cols than ref cols (cols deleted)
		return PostError(Imsg(idbgTransExcessBaseCols), riTableName);

	if (pOrigTable->GetColumnCount() > 31)
		return PostError(Imsg(idbgTransformTooManyBaseColumns), riTableName);
		
	CTransformStreamWrite tswTable(riTransDb, piTransform, *pNewTable, riTableName);
	PMsiCursor pNewCursor(pNewTable->CreateCursor(fFalse));

	if (cExtraColumns > 0)
	{
		fTablesAreDifferent = fTrue;
		if (piTransform)
		{
			// Add extra cols from new table to column catalog
			IMsiCursor* piColumnCursor = m_piCatalogColumns->CreateCursor(fFalse);
			piColumnCursor->SetFilter((iColumnBit(cccTable)|iColumnBit(cccColumn)));

			piColumnCursor->PutString(cccTable, riTableName);
			for (int iCol = cNewColumn+1; iCol <= cNewColumn+cExtraColumns; iCol++)
			{
				piColumnCursor->PutInteger(cccColumn, iCol);
				if (!piColumnCursor->Next())
				{
					// extra column is not listed in the catalog
					return PostError(Imsg(idbgDbCorrupt), riTableName);
				}

				int iColumnsMask = iColumnBit(cccTable)|iColumnBit(cccName)|iColumnBit(cccType);
				if ((piError = tswColumns.WriteTransformRow(fTransformAdd, *piColumnCursor)) != 0)
					return piError;
			}
			piColumnCursor->Release();
			tswTable.WriteTransformRow(fTransformForceOpen, *pNewCursor); // force stream to exist
		}
	}

	Bool fLongMask = fFalse;
	if (cNewColumn+cExtraColumns > 16)
		fLongMask = fTrue;

	PMsiCursor pOrigCursor(pOrigTable->CreateCursor(fFalse));

	// make temp col in original table for marking processsed rows
	int iTempCol;
	AddMarkingColumn(*pOrigTable, *pOrigCursor, iTempCol);

	// Set filter to only search by primary key
	pOrigCursor->SetFilter((1 << cPrimaryKey) - 1); 

	Bool fRowChanged;

	// Check each row in new table
	while (pNewCursor->Next() && !(fTablesAreDifferent && !piTransform))
	{
		pOrigCursor->Reset(); 
			
		// Copy key from new cursor to original cursor
		Bool fKeyMatchPossible = fTrue;
		int cPrimaryKey = pNewTable->GetPrimaryKeyCount();
		for (int iCol=1; iCol <= cPrimaryKey; iCol++)
		{
			if ((pNewTable->GetColumnType(iCol) & icdString) == icdString) 
			{
				MsiStringId iOrigId = MapString(*this, riOrigDb,
				 pNewCursor->GetInteger(iCol));
				
				if (iOrigId == -1)	
					fKeyMatchPossible = fFalse;
				else
					pOrigCursor->PutInteger(iCol, iOrigId);
			}
			else // not string (assume primary key can only be string or int)
			{
				pOrigCursor->PutInteger(iCol, pNewCursor->GetInteger(iCol));
			}
		}

		IMsiRecord* piError;
		fRowChanged = fFalse;

		// Attempt to find new key in original table

		Bool fRowExists = fFalse;
		int iMask = 0;

		if (fKeyMatchPossible && ((fRowExists = (Bool)(pOrigCursor->Next() != 0))) == fTrue) //row exists in orig tbl
		{
			piError = CompareRows(tswTable, *pNewCursor, *pOrigCursor,  
									    riOrigDb, iMask, piTransform);
			if (piError)
				return piError;
		}

		if ((fRowExists && (iMask || cExtraColumns)) || !fRowExists)
			fTablesAreDifferent = fTrue;

		if (fRowExists)
		{
			if (piTransform && iMask)
			{
				if ((piError = tswTable.WriteTransformRow(iMask, *pNewCursor)) != 0) // no primary keys in mask, therefore update
					return piError;
			}
			pOrigCursor->PutInteger(iTempCol, (int)fTrue); // mark as done
			AssertNonZero(pOrigCursor->Update() == fTrue);
		}
		else // add row
		{
			if (piTransform)
			{
				if ((piError = tswTable.WriteTransformRow(fTransformAdd, *pNewCursor)) != 0)
					return piError;
			}
		}
	} //while

	// all unprocessed rows in orig table must be deleted

	pOrigCursor->Reset();
	pOrigCursor->SetFilter(iColumnBit(iTempCol)); 
	pOrigCursor->PutInteger(iTempCol, (int)fFalse); // uprocessed row
	while (!(fTablesAreDifferent && !piTransform) && pOrigCursor->Next())	
	{
		fTablesAreDifferent = fTrue;
		if (piTransform)
		{
			if ((piError = tswTable.WriteTransformRow(fTransformDelete, *pOrigCursor)) != 0)
				return piError;
		}
	}
	return 0;
}

IMsiRecord* CTransformStreamWrite::CopyStream(IMsiStream& riSourceStream, IMsiCursor& riTableCursor)
{
	const int cbStreamBuffer = 2048;
	CTempBuffer<char,1> rgbOrigStream(cbStreamBuffer);
	IMsiRecord* piError = 0;

	MsiString strStreamName(riTableCursor.GetMoniker());

	IMsiStream* piOutStream;
	if ((piError = m_piStorage->OpenStream(strStreamName, fTrue, piOutStream)) != 0)
		return piError;

	// copy ref stream to transform file if stream
	riSourceStream.Reset();
	int cbInput = riSourceStream.GetIntegerValue();
	while (cbInput)
	{
		int cb = rgbOrigStream.GetSize();
		if (cb > cbInput)
			cb = cbInput;
		riSourceStream.GetData(rgbOrigStream, cb);
		piOutStream->PutData(rgbOrigStream, cb);
		cbInput -= cb;
	}
	int iError = riSourceStream.Error() | piOutStream->Error();
	piOutStream->Release();

	if (iError)
		return m_riCurrentDb.PostError(Imsg(idbgTransStreamError));

	return 0;
}

IMsiRecord* CMsiDatabase::CompareRows(CTransformStreamWrite& tswTable, 
												  IMsiCursor& riNewCursor, 
												  IMsiCursor& riOrigCursor, 
												  IMsiDatabase& riOrigDb, 
												  int& iMask, 
												  IMsiStorage* piTransform)
/*------------------------------------------------------------------------------
CMsiDatabase::CompareRows - Compares the two cursors and sets iMask to indicate 
which columns, if any, are different. If a stream column is different, then the 
reference stream is copied to a stream of the same name in the transform storage.
------------------------------------------------------------------------------*/
{

	// determine whether any data in this row has changed
	int iColumnType;
	Bool fColChanged;
	PMsiTable pOrigTable = &riOrigCursor.GetTable();
	PMsiTable pNewTable  = &riNewCursor.GetTable();

	int cPrimaryKey = pNewTable->GetPrimaryKeyCount();
	int cColumn     = pNewTable->GetPersistentColumnCount();
	int cColumnOrig = pOrigTable->GetPersistentColumnCount();
	IMsiRecord* piError;

	iMask = 0;
	for (int iCol = cPrimaryKey + 1; iCol <= cColumn; iCol++)
	{
		fColChanged = fFalse;
		iColumnType = pNewTable->GetColumnType(iCol);
		int iData1 = riNewCursor.GetInteger(iCol);
		int iData2 = riOrigCursor.GetInteger(iCol);
		Assert((iColumnType & icdPrimaryKey) == 0);

		if ((iColumnType & icdObject) == icdObject)
		{
			if ((iColumnType & icdString) == icdString)  // string
			{
				if (!DecodeStringNoRef(iData1).Compare(iscExact, MsiString(riOrigDb.DecodeString(iData2))))
					fColChanged = fTrue;
			}
			else // stream
			{
				Assert(iColumnType & icdPersistent);
				
				Bool fDifferentStreams   = fFalse;
				PMsiStream pNewStream  = riNewCursor.GetStream(iCol);
				PMsiStream pOrigStream = riOrigCursor.GetStream(iCol);
				const int cbStreamBuffer = 2048;
				CTempBuffer<char,1> rgbNewStream(cbStreamBuffer);
				CTempBuffer<char,1> rgbOrigStream(cbStreamBuffer);

				if (pNewStream && pOrigStream)
				{
					if (pNewStream->Remaining() != pOrigStream->Remaining())
					{
						fDifferentStreams = fTrue;
					}
					else // streams are same length; could be the same
					{
						int cbNew = pNewStream->GetIntegerValue();
					
						while (cbNew && !fDifferentStreams)
						{
							int cb = rgbNewStream.GetSize();
							if (cb > cbNew)
								cb = cbNew;
							pNewStream->GetData(rgbNewStream, cb);
							pOrigStream->GetData(rgbOrigStream, cb);
							cbNew -= cb;
							if (memcmp(rgbNewStream, rgbOrigStream, cb) != 0)
								fDifferentStreams = fTrue;
						}
					
						if (pOrigStream->Error() | pNewStream->Error())
							return PostError(Imsg(idbgTransStreamError));
					}
				}
				else if (!((pNewStream == 0) && (pOrigStream == 0))) // one stream is null but other is not
				{
					fDifferentStreams = fTrue;
				}

				if (fDifferentStreams) // need to write the stream
				{
					if (piTransform)
					{
						piError = tswTable.CopyStream(*pNewStream, riNewCursor);
						if (piError)
							return piError;
					}
					// Record that an update will be needed
					fColChanged = fTrue;
				}
			}
		}
		else // not icdObject
		{
			if (iData1 != iData2 && (iData1 != iMsiNullInteger || iCol <= cColumnOrig))
				fColChanged = fTrue;
		}

		if (fColChanged)
		{
			iMask |= fTransformUpdate;
			iMask |= iColumnBit(iCol);
		}
	} // foreach column
	return 0;
}

IMsiRecord* CMsiDatabase::CreateTransformStringPool(IMsiStorage& riTransform, CMsiDatabase*& pDatabase)
{
	IMsiRecord* piError = 0;
	CMsiDatabase* piTransDb = new CMsiDatabase(m_riServices);

	if ( ! piTransDb )
		return PostOutOfMemory();

	if ((piError = piTransDb->InitStringCache(&riTransform)) == 0)
	{
		pDatabase = piTransDb;
	}
	else
	{
		piTransDb->Release();
	}

	return piError;
}

//____________________________________________________________________________
//
// CMsiDatabase transform implementation (Application)
//____________________________________________________________________________

const int iteNoSystemStreamNames  = 4096;  //!! temp compatibility, remove for 1.0 ship

class CTransformStreamRead
{
 public:
	CTransformStreamRead(CMsiDatabase& riDatabase, CMsiDatabase& riTransformDatabase,
								int iErrors,  //!! temp to pass iteNoSystemStreamNames, remove for 1.0 ship
								CMsiTable* piTable = 0, int iCurTransId = 0);
  ~CTransformStreamRead() {if (m_piStream) m_piStream->Release();}
	bool        OpenStream(IMsiStorage& riStorage, const ICHAR* szStream, IMsiRecord*& rpiError);
	bool        StreamError() {return m_piStream && m_piStream->Error() ? true : false;}
	bool        GetNextOp();
	bool        GetValue(int iCol, IMsiCursor& riCursor);
	bool        IsDelete() {return m_iMask == 0;}
	bool        IsAdd()    {return m_iMask & 1;}
	int         GetCursorFilter()    {return m_iFilter;}
	int         GetColumnMask()      {return m_iMask;}
	int         GetPrimaryKeyCount() {return m_cPrimaryKey;}
	MsiStringId ReadStringId();
	int         ReadShortInt()   {return m_piStream->GetInt16() + 0x8000;}
	const IMsiString& GetStringValue(int iColDef, const IMsiString& riStreamName);  // for ViewTransform
 private: // note: members are not ref counted
	int           m_iMask;
	CMsiDatabase& m_riDatabase;
	CMsiDatabase& m_riTransformDb;
	IMsiStream*   m_piStream;
	CMsiTable*    m_piTable;
	int           m_iCurTransId;
	int           m_cPrimaryKey;
	int           m_cColumns;  //!! temp for backward compatibility
	int           m_iFilter;
	int           m_cbStringIndex;
	int           m_cbMask;
	int           m_iErrors;  //!! temp for iteNoSystemStreamNames test, remove for 1.0 ship
};

CTransformStreamRead::CTransformStreamRead(CMsiDatabase& riDatabase, CMsiDatabase& riTransformDatabase,
										   int iErrors,  //!! temp to pass iteNoSystemStreamNames, remove for 1.0 ship
														 CMsiTable* piTable, int iCurTransId)
	: m_riDatabase(riDatabase), m_riTransformDb(riTransformDatabase), m_piTable(piTable)
	, m_iCurTransId(iCurTransId), m_piStream(0), m_cbStringIndex(2), m_cbMask(2), m_iMask(0)
	, m_iErrors(iErrors)  //!! temp to pass iteNoSystemStreamNames, remove for 1.0 ship

{
	if (piTable)
	{
		m_cPrimaryKey = piTable->GetPrimaryKeyCount();
		m_cColumns = piTable->GetPersistentColumnCount();//!! temporarily save column count for use with old transforms
		m_iFilter = (1 << m_cPrimaryKey) -1;
	}
	else
	{
		m_cColumns = 1;  //!! temp. to insure (iMask & 1) true for Add
	}
}

bool CTransformStreamRead::OpenStream(IMsiStorage& riStorage, const ICHAR* szStream, IMsiRecord*& rpiError)
{
	if ((rpiError = riStorage.OpenStream(szStream, (m_iErrors & iteNoSystemStreamNames) ? fFalse : Bool(iCatalogStreamFlag), *&m_piStream)) == 0) //!! temp test, remove for 1.0 ship
		return true;
	if (rpiError->GetInteger(1) == idbgStgStreamMissing)
		rpiError->Release(), rpiError = 0;
	return false;
}

bool CTransformStreamRead::GetNextOp()
{
	Assert(m_piStream);
	if (m_piStream->Remaining() == 0 
	 || m_piStream->GetData(&m_iMask, m_cbMask) !=  m_cbMask)
		return false;
	if (m_iMask & fTransformAdd)   // insert or special op
	{
		if (m_iMask & 2)  // special op
		{
			if (m_iMask == iTransformThreeByteStrings)
			{
				m_cbStringIndex = 3;
				return GetNextOp();
			}
			if (m_iMask == iTransformFourByteMasks)
			{
				m_cbMask = 4;
				return GetNextOp();
			}
			AssertSz(0, "Invalid transform mask");
		}
		else  // insert, form actual mask
		{
			m_iMask = (1 << (m_iMask >> iTransformColumnCountShift)) - 1;
			if (m_iMask == 0) m_iMask = (1 << m_cColumns) - 1; //!! temp for backward compatibility
		}
	}
	return true;
}

MsiStringId CTransformStreamRead::ReadStringId()
{
	MsiStringId iString = 0;
	m_piStream->GetData(&iString, m_cbStringIndex);
	return iString;
}

/*------------------------------------------------------------------------------
CMsiDatabase - SetTranform will apply all changes specified in the 
given transform to this database. Updating the table and column catalogs, as
well as transforming loaded tables will be done immediately. The transforming of 
unloaded tables will be delayed until the tables are loaded. These tables
are changed to the "itsTransform" state to indicate that they need
to be transformed.

SetTransform also adds the given transform to the transform catalog.

SetTransformEx takes 2 extra optional arguments used to view a transform.

   szViewTable   - the table to populate with transform info.  if not set, the
						 default name is used
	piViewTheseTablesOnlyRecord - if specified, only information about transformations to
						 these table are included
------------------------------------------------------------------------------*/
IMsiRecord* CMsiDatabase::SetTransform(IMsiStorage& riTransform, int iErrors)
{
	return SetTransformEx(riTransform, iErrors, 0, 0);
}

IMsiRecord* CMsiDatabase::SetTransformEx(IMsiStorage& riTransform, int iErrors,
													  const ICHAR* szViewTable,
													  IMsiRecord* piViewTheseTablesOnlyRecord)
{
	if (!riTransform.ValidateStorageClass(ivscTransform2))
	{
		IMsiStorage* piDummy;
		if (riTransform.ValidateStorageClass(ivscTransform1))  // compatibility with old transforms
			riTransform.OpenStorage(0, ismRawStreamNames, piDummy);
		else if (riTransform.ValidateStorageClass(ivscTransformTemp))  //!! remove at 1.0 ship
			iErrors |= iteNoSystemStreamNames;                          //!! remove at 1.0 ship
		else
			return PostError(Imsg(idbgTransInvalidFormat));
	}

	CDatabaseBlock dbBlock(*this);

	if (iErrors & iteViewTransform)
	{
		return ViewTransform(riTransform, iErrors,
									szViewTable, piViewTheseTablesOnlyRecord);
	}

	// Add the transform to the catalog table
	m_iLastTransId++;

	IMsiCursor* piCursor = m_piTransformCatalog->CreateCursor(fFalse);
	if (!piCursor)
		return PostOutOfMemory();

	piCursor->PutInteger(tccID,        m_iLastTransId);
	piCursor->PutMsiData(tccTransform, &riTransform); // Does an AddRef
	piCursor->PutInteger(tccErrors,    iErrors);
	AssertNonZero(piCursor->Insert());
	piCursor->Release();

	CComPointer<CMsiDatabase> pTransDb(0);

	IMsiRecord* piError = 0;
	if (((piError = CreateTransformStringPool(riTransform, *&pTransDb)) != 0) ||
		 ((piError = SetCodePageFromTransform(pTransDb->m_iCodePage, iErrors)) != 0) ||
		 ((piError = TransformTableCatalog(riTransform, *pTransDb, iErrors)) != 0) ||
		 ((piError = TransformColumnCatalog(riTransform, *pTransDb, iErrors)) != 0))
	{
		return piError;
	}

	// Transform all tables that require transforming (i.e. have a stream)
	m_piTableCursor->SetFilter(0); // erase any previous filters that were set
	m_piTableCursor->Reset();
	while (m_piTableCursor->Next())
	{
		if (piError)  // force loop to finish to leave cursor reset
			continue;
		IMsiStream* piStream;
		int iName = m_piTableCursor->GetInteger(ctcName);
		const IMsiString& riTableName = DecodeStringNoRef(iName); // not ref counted
		piError = riTransform.OpenStream(riTableName.GetString(), (iErrors & iteNoSystemStreamNames) ? fFalse : Bool(iCatalogStreamFlag), piStream); //!! remove test for 1.0 ship

		if (piError) 
		{
			if (piError->GetInteger(1) == idbgStgStreamMissing)
				piError->Release(), piError = 0; // no transform required for this table
			continue;
		}
		else // transform required
		{
			piStream->Release();
			int iState = m_piTableCursor->GetInteger(~iTreeLinkMask);
			if (iState & (iRowTemporaryBit))
				return PostError(Imsg(idbgDbTransformTempTable), riTableName.GetString());
			if (!(iState & iRowTableTransformBit))
				m_piCatalogTables->SetTableState(iName, ictsTransform);  // cleared on SaveToStorage
			if (m_piTableCursor->GetInteger(ctcTable) != 0)  // table loaded, transform now
			{
				CMsiTable* piTable = 
					(CMsiTable*)m_piTableCursor->GetMsiData(ctcTable);
				Assert(piTable);
				piError = TransformTable(iName, *piTable, riTransform, *pTransDb, m_iLastTransId, iErrors); 
				piTable->Release();
				if (piError)
					continue;
			}
		}
	} // while

	return piError;
}

IMsiRecord* CTransformStreamWrite::WriteTransformRow(const int iOperationMask, IMsiCursor& riCursor)
{
	char rgData[sizeof(int)*(1 + 32 + 2)]; // mask + 32 columns + possible 3-byte strings and >16 col markers
	const char* pData;
	IMsiRecord* piError = 0;
		
	if (!m_piStream && m_piStorage)  // open stream at first write
	{
		if ((piError = m_piStorage->OpenStream(m_riTableName.GetString(), Bool(fTrue + iCatalogStreamFlag), m_piStream)) != 0)
			return piError;
		if (m_cbMask == 4)
			m_piStream->PutInt16((short)iTransformFourByteMasks);// from now on masks are 4 bytes in stream
	}

	if (iOperationMask == fTransformForceOpen)
		return 0;

	int cData = 0;
	pData = rgData;

	if (m_riTransformDb.m_cbStringIndex == 3 && m_cbStringIndex == 2)
	{
		m_cbStringIndex = 3;
		*(int UNALIGNED*)pData = iTransformThreeByteStrings;
		pData += m_cbMask;
	}       

	int iColMask;
	if (iOperationMask & fTransformAdd)
	{
		*(int UNALIGNED*)pData = fTransformAdd | (m_cColumns << iTransformColumnCountShift);  // save column count for application
		iColMask = (1 << m_cColumns) - 1;  // output all persistent columns for added rows
	}
	else
	{
		*(int UNALIGNED*)pData = iOperationMask;  // output update mask or delete op
		iColMask = iOperationMask | (1 << m_riTable.GetPrimaryKeyCount())-1;  // force primary key columns
	}
	pData += m_cbMask;

	MsiStringId rgiData[32];  // keep track of IDs in case need to unbind
	for (int iCol=1; iColMask; iCol++, iColMask >>= 1)
	{
		rgiData[iCol-1] = 0;  // clear undo element
		if (iColMask & 0x1)
		{
			int iColumnDef = m_riTable.GetColumnType(iCol);
			switch (iColumnDef & icdTypeMask)
			{
			case icdShort:
				{
					int iData = riCursor.GetInteger(iCol);
					if (iData != iMsiNullInteger)
						iData += 0x8000;
					*(short UNALIGNED*)pData = (short)iData;
					pData += sizeof(short);
					break;
				}

			case icdLong:
				{
					*(int UNALIGNED*)pData = riCursor.GetInteger(iCol) + iIntegerDataOffset;
					pData += sizeof(int);
					break;
				}
			case icdString:
				{
					MsiString str(riCursor.GetString(iCol));
					*(MsiStringId UNALIGNED*)pData = rgiData[iCol-1] = m_riTransformDb.BindString(*str);
					pData += m_cbStringIndex;
					if (m_riTransformDb.m_cbStringIndex != m_cbStringIndex) // oops, string pool reallocated
					{
						Assert(m_cbStringIndex == 2);
						for (int i = 0; i < iCol; i++)  // unbind all of the strings we've bound
							m_riTransformDb.UnbindStringIndex(rgiData[i]);
						return WriteTransformRow(iOperationMask, riCursor); // output with marker
					}
					break;
				}
			default: // persistent stream
				{
					PMsiStream pStream = riCursor.GetStream(iCol);
					// This has been changed to account for null streams
					if (pStream) // stream exists...stored in transform storage
					{
						*(short UNALIGNED*)pData = 1;
						// only copy stream if Add, for Modify stream copied as needed by CompareRows
						if ((iOperationMask & fTransformAdd) && m_piStorage)
						{
							if ((piError = CopyStream(*pStream, riCursor)) != 0)
								return piError;
						}
					}
					else // null stream
					{
						*(short UNALIGNED*)pData = 0;
					}

					pData += sizeof(short);
					break;
				}
			}
		}
	}

//	Assert((pData-rgData) <= UINT_MAX);			//--merced: 64-bit pointer subtraction may theoretically lead to values too big to fit into UINT values
	m_piStream->PutData(rgData, (unsigned int)(pData-rgData));

	if (m_piStream->Error())
		piError = m_riCurrentDb.PostError(Imsg(idbgTransStreamError));
	
	return piError;
}

/*------------------------------------------------------------------------------
CTransformStreamRead::GetValue - Fills the given cursor column with the next value in 
the transform stream. Strings that are not yet in this database are bound to it.
------------------------------------------------------------------------------*/
bool CTransformStreamRead::GetValue(int iCol, IMsiCursor& riCursor)
{
	Assert(m_piTable && m_piStream);
	if (!m_piTable)
		return false;

	switch (m_piTable->GetColumnType(iCol) & (icdTypeMask | icdInternalFlag))
	{
	case icdShort:
		{
			int iData = iMsiNullInteger;
			m_piStream->GetData(&iData, sizeof(short));
			if (iData != iMsiNullInteger)
				iData += 0x7FFF8000;  // translate offset from long to short
			riCursor.PutInteger(iCol, iData);
			break;
		}
	case icdLong:
		{
			riCursor.PutInteger(iCol, m_piStream->GetInt32() - iIntegerDataOffset);
			break;
		}
	case icdString:
		{
			MsiStringId iTransStr = 0;
			m_piStream->GetData(&iTransStr, m_cbStringIndex);
			MsiString str(m_riTransformDb.DecodeString(iTransStr));
			MsiStringId iThisStr = m_riDatabase.BindString(*str);
			riCursor.PutInteger(iCol, iThisStr);
			m_riDatabase.UnbindStringIndex(iThisStr); // release refcnt added by BindString
			break;
		}
	case icdObject: // persistent stream
		{
			int iTransStream = m_piStream->GetInt16();
			if (iTransStream == 0) // stream is null
				riCursor.PutNull(iCol);
			else // stream is in separate transform storage
			{
				Assert( m_iCurTransId);
				riCursor.PutInteger(iCol, m_iCurTransId);
			}
			break;
		}
	case icdInternalFlag:  // HideStrings() called, 2nd application of transform
		{
			MsiStringId iTransStr = 0;
			m_piStream->GetData(&iTransStr, m_cbStringIndex);
			MsiString str(m_riTransformDb.DecodeString(iTransStr));
			MsiStringId iThisStr = m_riDatabase.EncodeString(*str);  // must exist
			riCursor.PutInteger(iCol, iThisStr - iIntegerDataOffset);
			break;
		}
	}

	return m_piStream->Error() ? false : true;
}

IMsiRecord* CMsiDatabase::SetCodePageFromTransform(int iTransCodePage, int iError)
{
	// Update our codepage. We have the following scenarios:
	// 1) Database is LANG_NEUTRAL: set database to the codepage of the transform; otherwise
	// 2) Transform is LANG_NEUTRAL: leave the database codepage as is; otherwise
	// 3) Neither are LANG_NEUTRAL: set the database to the codepage of the transform if allowed by error condition
	if (iTransCodePage != m_iCodePage)
	{
		if (m_iCodePage == LANG_NEUTRAL)
		{
			m_iCodePage = iTransCodePage;  
		}
		else if ((iTransCodePage != LANG_NEUTRAL) && (iTransCodePage != m_iCodePage))
		{
#ifdef UNICODE  // can support multiple codepages in Unicode, as long as not persisted
			if((iError & iteChangeCodePage) == 0 && m_idsUpdate != idsRead)
#else
			if((iError & iteChangeCodePage) == 0)
#endif
				return PostError(Imsg(idbgTransCodepageConflict), iTransCodePage, m_iCodePage);

			m_iCodePage = iTransCodePage;
		}
	}
	return 0;
}

/*------------------------------------------------------------------------------
CMsiDatabase::Transform - Transforms the given table with the given storage.
------------------------------------------------------------------------------*/
IMsiRecord* CMsiDatabase::TransformTable(MsiStringId iTableName, CMsiTable& riTable,
													  IMsiStorage& riTransform, CMsiDatabase& riTransDb,
													  int iCurTransId, int iErrors)
{
	IMsiRecord* piError;
	const IMsiString& riTableName = DecodeStringNoRef(iTableName);
	CTransformStreamRead tsr(*this, riTransDb, iErrors, &riTable, iCurTransId);   //!! remove temp iErrors arg for 1.0 ship
	if (!tsr.OpenStream(riTransform, riTableName.GetString(), piError))
		return piError;  // will be 0 if stream missing, nothing to do

	PMsiCursor pTableCursor(riTable.CreateCursor(ictUpdatable));  // force writable cursor
	if (pTableCursor == 0)
		return PostOutOfMemory();

	Bool fSuppress; // fTrue if we should skip updating/adding the current row
	pTableCursor->SetFilter(tsr.GetCursorFilter());

	while (tsr.GetNextOp())
	{
		fSuppress = fFalse;
		pTableCursor->Reset();

		unsigned int iColumnMask = tsr.GetColumnMask();
		int iCol;
		for (iCol = 1; iCol <= tsr.GetPrimaryKeyCount(); iCol++, iColumnMask >>= 1)
		{
			if (!tsr.GetValue(iCol, *pTableCursor))
				return PostError(Imsg(idbgTransStreamError));
		}

		if (!tsr.IsDelete())  // not delete, must be add or update
		{
			if (!tsr.IsAdd())
			{
				if ((Bool)pTableCursor->Next() == fFalse)
				{
					if((iErrors & iteUpdNonExistingRow) == 0) // row doesn't exist
						return PostError(Imsg(idbgTransUpdNonExistingRow), riTableName);
					else
						fSuppress = fTrue; // suppress error
				}
			}

			for (; iColumnMask; iCol++, iColumnMask >>= 1)
			{
				if (iColumnMask & 1) // col data is to be added/updated
				{
					if (!tsr.GetValue(iCol, *pTableCursor))
						return PostError(Imsg(idbgTransStreamError));
				}
			}

			if (!fSuppress)
			{
				if (tsr.IsAdd())
				{
					if (!pTableCursor->Insert() && ((iErrors & iteAddExistingRow) == 0))
						return PostError(Imsg(idbgTransAddExistingRow), riTableName); // Attempt add already existing row
				}
				else //update
				{
					if (!pTableCursor->Update())
						return PostError(Imsg(idbgDbTransformFailed));
				}
			}
		}
		else // delete row
		{
			// cannot release primary key strings from read-only table, else can't retransform
			if (GetUpdateState() != idsWrite && pTableCursor->Next())
				for (int iCol=1; iCol <= tsr.GetPrimaryKeyCount(); iCol++)
					if ((riTable.GetColumnType(iCol) & (icdTypeMask | icdInternalFlag)) == icdString)
						BindStringIndex(pTableCursor->GetInteger(iCol));  // add artificial count to lock string

			if (!pTableCursor->Delete() && ((iErrors & iteDelNonExistingRow) == 0))
				return PostError(Imsg(idbgTransDelNonExistingRow), riTableName); // Attempt delete non existing row
		}
	} // while more ops
	if (tsr.StreamError())
		return PostError(Imsg(idbgTransStreamError));
	m_piCatalogTables->SetTransformLevel(iTableName, iCurTransId);
	return 0;
}

/*------------------------------------------------------------------------------
CMsiDatabase::TransformTableCatalog - Updates the table catalog as specified in
the given transform. This function does *not* update any row data. 
------------------------------------------------------------------------------*/
IMsiRecord* CMsiDatabase::TransformTableCatalog(IMsiStorage& riTransform, CMsiDatabase& riTransDb, int iErrors)
{
	IMsiRecord* piError;
	CTransformStreamRead tsr(*this, riTransDb, iErrors);  //!! remove temp iErrors arg for 1.0 ship
	if (!tsr.OpenStream(riTransform, szTableCatalog, piError))
		return piError;  // will be 0 if stream missing, nothing to do

	// Add/Delete tables as specified in the transform file
	while (!piError && tsr.GetNextOp())
	{
		MsiStringId iTransStr = tsr.ReadStringId();
		m_piTableCursor->Reset();

		Assert(tsr.IsAdd() || tsr.IsDelete());
		if (tsr.IsAdd()) // add table
		{
			MsiString istrTableName = riTransDb.DecodeString(iTransStr);
			MsiStringId iThisStr    = BindString(riTransDb.DecodeStringNoRef(iTransStr));
			m_piTableCursor->PutInteger(ctcName, iThisStr);
			UnbindStringIndex(iThisStr); // release refcnt added by BindString
			if (!m_piTableCursor->Insert())  // ctcTable null by cursor Reset
			{
				if ((iErrors & iteAddExistingTable) == 0) 	// Attempt to add an existing table
					piError = PostError(Imsg(idbgTransAddExistingTable), *istrTableName);
			}
		}
		else // delete table
		{
			MsiString istrTableName = riTransDb.DecodeString(iTransStr);
			if ((piError = DropTable(istrTableName)) != 0)
			{
				if (piError->GetInteger(1) == idbgDbTableUndefined)
				{
					piError->Release(), piError = 0;
					if ((iErrors & iteDelNonExistingTable) == 0) // Attempt to delete a non-existing table
						piError = PostError(Imsg(idbgTransDelNonExistingTable), *istrTableName);
				}
			}
		}
			
	} // while more ops and no error

	m_piTableCursor->Reset();
	return piError;
}


/*------------------------------------------------------------------------------
CMsiDatabase::TransformColumnCatalog - Updates the column catalog as specified
the given transform. This function does *not* update any row data. 
------------------------------------------------------------------------------*/
IMsiRecord* CMsiDatabase::TransformColumnCatalog(IMsiStorage& riTransform, CMsiDatabase& riTransDb, int iErrors)
{
	IMsiRecord* piError;
	CTransformStreamRead tsr(*this, riTransDb, iErrors);    //!! remove temp iErrors arg for 1.0 ship
	if (!tsr.OpenStream(riTransform, szColumnCatalog, piError))
		return piError;  // will be 0 if stream missing, nothing to do

	// Add columns as specified in the transform file
	int iStat = 1;    // status from column update
	MsiStringId iThisTableStr = 0;
	MsiString istrColName;

	while (tsr.GetNextOp() && iStat > 0)
	{
		Assert(tsr.IsAdd());
		m_piColumnCursor->Reset();
		m_piColumnCursor->SetFilter(iColumnBit(cccTable));
		iThisTableStr  = BindString(riTransDb.DecodeStringNoRef(tsr.ReadStringId()));
		Assert(iThisTableStr != 0);

		int iOrigCol = tsr.ReadShortInt(); // skip column number in transform stream

		istrColName = riTransDb.DecodeString(tsr.ReadStringId());
		int iColDef = tsr.ReadShortInt();

		CMsiTable* piTable;
		m_piCatalogTables->GetLoadedTable(iThisTableStr, piTable); // doesn't addref
		if (piTable)
		{
			iStat = piTable->CreateColumn(iColDef, *istrColName);
			if(iStat < 0)
			{
				// the column is a dup. check whether we're ignoring the addition of existing
				// tables. if so then we also ignore the addition of existing columns as
				// long as the two columns are of the same type
				if (((iErrors & iteAddExistingTable) == 0) || 
					 ((iColDef & icdTypeMask) != (piTable->GetColumnType(iStat * -1) & icdTypeMask)))
				{
					// leave iStat < 0
				}
				else
				{
					// ignore duplicate column - make iStat > 0
					iStat *= -1;
				}
			}
		}
		else
		{
			m_piColumnCursor->PutInteger(cccTable, iThisTableStr);
			int cColumns = 0;
			while (m_piColumnCursor->Next())
				cColumns++;
		
			// See if it is a duplicate column
			m_piColumnCursor->Reset();
			m_piColumnCursor->SetFilter ((iColumnBit(cccTable) | iColumnBit(cccName)));
			m_piColumnCursor->PutInteger(cccTable, iThisTableStr);
			m_piColumnCursor->PutString (cccName,  *istrColName);
			if (m_piColumnCursor->Next())
			{
				// the column is a dup. check whether we're ignoring the addition of existing
				// tables. if so then we also ignore the addition of existing columns as
				// long as the two columns are of the same type

				if (((iErrors & iteAddExistingTable) == 0) || 
					 ((iColDef & icdTypeMask) != (m_piColumnCursor->GetInteger(cccType) & icdTypeMask)))
					iStat = -1;
			}
			else
			{
				// Update column catalog
				m_piColumnCursor->Reset();
				m_piColumnCursor->PutInteger(cccTable,  iThisTableStr);
				m_piColumnCursor->PutInteger(cccColumn, ++cColumns);
				m_piColumnCursor->PutString (cccName,   *istrColName);
				m_piColumnCursor->PutInteger(cccType,   (iColDef & ~icdPersistent));
				if (!m_piColumnCursor->Insert())
					iStat = 0;
			}
		}

		UnbindStringIndex(iThisTableStr); // release refcnt added by BindString

	} // while more transform data

	m_piColumnCursor->Reset();
	if (iStat == 0)
		return PostError(Imsg(idbgDbTransformFailed));
	if (iStat < 0)
		return PostError(Imsg(idbgTransDuplicateCol), (DecodeStringNoRef(iThisTableStr)).GetString(), (const ICHAR*)istrColName);
	return 0;
}

/*------------------------------------------------------------------------------
CMsiDatabase::ApplyTransforms - Transforms the given table with the set of transforms
------------------------------------------------------------------------------*/
IMsiRecord* CMsiDatabase::ApplyTransforms(MsiStringId iTableName, CMsiTable& riTable, int iState)
{
	IMsiRecord* piError;
	CComPointer <IMsiCursor> pTransformCatalogCursor(m_piTransformCatalog->CreateCursor(fFalse));
	Assert(pTransformCatalogCursor);
	IMsiStorage* piPrevStorage = 0;
	CComPointer<CMsiDatabase> pTransDb(0);

	int iTransform = (iState >> iRowTableTransformOffset) & iRowTableTransformMask;
	bool fStringsHidden = (iTransform && m_idsUpdate != idsWrite) ?  riTable.HideStrings() : false;

	while (pTransformCatalogCursor->Next())
	{
		int iCurTransId = pTransformCatalogCursor->GetInteger(tccID);
		if (!(iCurTransId > 0 && iCurTransId <= iMaxStreamId))
			return PostError(Imsg(idbgDbTransformFailed));

		int iErrors = pTransformCatalogCursor->GetInteger(tccErrors);
		if (iCurTransId <= iTransform)
		{
			if (m_idsUpdate == idsWrite)
				continue;  // already applied
		}
		else // > iTransform
		{
			if (fStringsHidden)
				fStringsHidden = riTable.UnhideStrings();
		}
		IMsiStorage* piStorage = (IMsiStorage*)pTransformCatalogCursor->GetMsiData(tccTransform);
		if (!piStorage)
			return PostError(Imsg(idbgDbTransformFailed));
		if ((void*)piPrevStorage != (void*)piStorage)
		{
			if ((piError = CreateTransformStringPool(*piStorage, *&pTransDb)) != 0)
			{
				piStorage->Release();
				return piError;
			}
			piPrevStorage = piStorage;
		}
		DEBUGMSG1(TEXT("Transforming table %s.\n"), DecodeStringNoRef(iTableName).GetString());
		piError = TransformTable(iTableName, riTable, *piStorage, *pTransDb, iCurTransId, iErrors);
		piStorage->Release();
		if (piError)
			return piError;
	}	
	if (fStringsHidden)
		riTable.UnhideStrings();
	return 0;
}

//____________________________________________________________________________
//
// Transform viewer implementation - logs transform ops into table instead of applying
//____________________________________________________________________________

// _TransformView table schema definitions

const int icdtvTable   = icdString + icdTemporary + icdPrimaryKey;
const int icdtvColumn  = icdString + icdTemporary + icdPrimaryKey;
const int icdtvRow     = icdString + icdTemporary + icdPrimaryKey + icdNullable;
const int icdtvData    = icdString + icdTemporary                 + icdNullable;
const int icdtvCurrent = icdString + icdTemporary                 + icdNullable;

const IMsiString& CTransformStreamRead::GetStringValue(int iColDef, const IMsiString& riStreamName)
{
	const IMsiString* pistrValue = &g_MsiStringNull;
	if ((iColDef & icdObject) == 0) // integer
	{
		int iData = iMsiNullInteger;
		if (iColDef & icdShort)
		{
			m_piStream->GetData(&iData, sizeof(short));
			if (iData != iMsiNullInteger)
				iData += 0x7FFF8000;  // translate offset from long to short
		}
		else
			iData = m_piStream->GetInt32() - iIntegerDataOffset;
		pistrValue->SetInteger(iData, pistrValue);
	}
	else if (iColDef & icdShort) // string
	{
		MsiStringId iTransStr = 0;
		m_piStream->GetData(&iTransStr, m_cbStringIndex);
		pistrValue = &m_riTransformDb.DecodeString(iTransStr);
	}
	else  // persistent stream
	{
		int iTransStream = m_piStream->GetInt16();
		if (iTransStream != 0) // stream not null
			pistrValue = &riStreamName, pistrValue->AddRef();
	}
	return *pistrValue;
}


IMsiRecord* CMsiDatabase::ViewTransform(IMsiStorage& riTransform, int iErrors,
													 const ICHAR* szTransformViewTableName,
													 IMsiRecord* piOnlyTheseTablesRec)
{
	IMsiRecord* piError;
	CComPointer<CMsiDatabase> pTransDb(0);
	if ((piError = CreateTransformStringPool(riTransform, *&pTransDb)) != 0)
		return piError;

	// Check codepage mismatch
#ifdef UNICODE  // can support multiple codepages in Unicode, as long as not persisted
	if ((iErrors & iteChangeCodePage) == 0 && m_idsUpdate != idsRead
#else
	if ((iErrors & iteChangeCodePage) == 0
#endif
	  && pTransDb->m_iCodePage != 0 && m_iCodePage != 0 && pTransDb->m_iCodePage != m_iCodePage)
		return PostError(Imsg(idbgTransCodepageConflict), pTransDb->m_iCodePage, m_iCodePage);

	// Create or load transform view table
	MsiString strViewTableName;
	if(szTransformViewTableName && *szTransformViewTableName)
	{
		strViewTableName = szTransformViewTableName;
	}
	else
	{
		strViewTableName = (*sztblTransformView);
	}

	PMsiTable pTransformView(0);
	int iName = EncodeString(*strViewTableName);
	if (iName && m_piCatalogTables->GetLoadedTable(iName, (CMsiTable*&)*&pTransformView) != -1)  // already present
		(*pTransformView).AddRef();
	else  // must create temporary table
	{
		if ((piError = CreateTable(*strViewTableName, 32, *&pTransformView)) != 0)
			return piError;
		AssertNonZero(ctvTable   == pTransformView->CreateColumn(icdtvTable,   *MsiString(sztblTransformView_colTable))
				   && ctvColumn  == pTransformView->CreateColumn(icdtvColumn,  *MsiString(sztblTransformView_colColumn))
				   && ctvRow     == pTransformView->CreateColumn(icdtvRow,     *MsiString(sztblTransformView_colRow))
				   && ctvData    == pTransformView->CreateColumn(icdtvData,    *MsiString(sztblTransformView_colData))
				   && ctvCurrent == pTransformView->CreateColumn(icdtvCurrent, *MsiString(sztblTransformView_colCurrent)));
	}
	PMsiCursor pCatalogCursor(m_piCatalogTables->CreateCursor(fFalse));
	PMsiCursor pColumnCursor(m_piCatalogColumns->CreateCursor(fFalse));
	PMsiCursor pViewCursor(pTransformView->CreateCursor(fFalse));
	PMsiCursor pFindCursor(pTransformView->CreateCursor(fFalse));  // always leave in reset state
	PMsiCursor pNewTableCursor(pTransformView->CreateCursor(fFalse));

	// Process transform table catalog
	{//block
	CTransformStreamRead tsr(*this, *pTransDb, iErrors);  //!! remove temp iErrors arg for 1.0 ship
	bool fStreamPresent = tsr.OpenStream(riTransform, szTableCatalog, piError);
	if (piError)
		return piError;  // will be 0 if stream missing, nothing to do
	while (fStreamPresent && tsr.GetNextOp())
	{
		const IMsiString& ristrTable = pTransDb->DecodeStringNoRef(tsr.ReadStringId());
		pViewCursor->PutString(ctvTable, ristrTable);
		pCatalogCursor->SetFilter(iColumnBit(ctcName));
		pCatalogCursor->PutString(ctcName, ristrTable);
		int iTableExists = pCatalogCursor->Next();
		pCatalogCursor->Reset();
		pFindCursor->SetFilter(iColumnBit(ctvTable));
		pFindCursor->PutString(ctvTable, ristrTable);
		if (tsr.IsAdd())
		{
			while (pFindCursor->Next())  // check if previously added or dropped
			{
				iTableExists |= 256;     // ops for this table in previous transform
				if (MsiString(pFindCursor->GetString(ctvColumn)).Compare(iscExact, sztvopDrop) == 1)
					iTableExists = -1;   // table dropped in previous transform, no error
			}
			if (iTableExists > 0 && (iErrors & iteAddExistingTable) == 0)
				return PostError(Imsg(idbgTransAddExistingTable), ristrTable);
			pViewCursor->PutString(ctvColumn, *MsiString(*sztvopCreate));
			AssertNonZero(pViewCursor->Assign());  // prevent duplicate record error
		}
		else // IsDelete
		{
			while (pFindCursor->Next())  // remove all previous ops for this table
			{
				iTableExists |= 256;
				pFindCursor->Delete();
			}
			if (iTableExists == 0 && (iErrors & iteDelNonExistingTable) == 0)
				return PostError(Imsg(idbgTransDelNonExistingTable), ristrTable);
			if (iTableExists != 256)  // delete op canceled if table added in previous transform
			{
				pViewCursor->PutString(ctvColumn, *MsiString(*sztvopDrop));
				AssertNonZero(pViewCursor->Insert());
			}
		}
	} // while more table catalog ops and no error
	}//block

	// Process transform column catalog
	{//block
	CTransformStreamRead tsr(*this, *pTransDb, iErrors);  //!! remove temp iErrors arg for 1.0 ship
	bool fStreamPresent = tsr.OpenStream(riTransform, szColumnCatalog, piError);
	if (piError)
		return piError;  // will be 0 if stream missing, nothing to do
	MsiStringId iLastTable = 0;
	int iLastColumn = 0;
	while (fStreamPresent && tsr.GetNextOp())
	{
		MsiStringId iTable = tsr.ReadStringId();
		const IMsiString& ristrTable  = pTransDb->DecodeStringNoRef(iTable);
		int iOrigCol                  = tsr.ReadShortInt(); // column number in transform stream
		const IMsiString& ristrColumn = pTransDb->DecodeStringNoRef(tsr.ReadStringId());
		int iColDef                   = tsr.ReadShortInt();
		if (iOrigCol == 0x8000)  // null, column added to new table
		{
			if (iTable != iLastTable)
				iLastColumn = 0;
			iOrigCol = ++iLastColumn;
		}
		iLastTable = iTable;
		pViewCursor->PutString(ctvTable,  ristrTable);
		pViewCursor->PutString(ctvColumn, ristrColumn);
		pViewCursor->PutString(ctvData,   *MsiString(iColDef));
		pViewCursor->PutString(ctvCurrent,*MsiString(iOrigCol));
		if ((iErrors & iteAddExistingTable) != 0)  // ignore existing column
			pViewCursor->Assign();   // overwrite if present
		else // check for existing column if error not suppressed
		{
			pColumnCursor->SetFilter(iColumnBit(cccTable) | iColumnBit(cccName));
			pColumnCursor->PutString(cccTable, ristrTable);
			pColumnCursor->PutString(cccName,  ristrColumn);
			int iColumnExists = pColumnCursor->Next();
			pColumnCursor->Reset();
		 	if (iColumnExists != 0 || !pViewCursor->Insert()) // duplicate in database or previous transform
				return PostError(Imsg(idbgTransDuplicateCol), ristrTable.GetString(), ristrColumn.GetString());
		}
	} // while more column catalog ops and no error
	}//block

	// Process transform table streams

	pCatalogCursor->SetFilter(0); // erase any previous filters that were set
	pCatalogCursor->Reset();
	bool fNewTables = false;
	int rgiColName[32];  // columns names for added tables
	int rgiColDef[32];   // column defs for added tables
	bool fNoMoreTables = false;
	int iTableRecIndex = 0;
	for (;;)  // scan all current and added tables
	{
		const ICHAR* szThisTableOnly = 0;
		
		if(fNoMoreTables && !piOnlyTheseTablesRec)
			break; // not looking for specific tables, so must be done with all tables

		if(piOnlyTheseTablesRec)
		{
			iTableRecIndex++;
			if(iTableRecIndex > piOnlyTheseTablesRec->GetFieldCount())
				break; // no more specific tables to look at

			szThisTableOnly = piOnlyTheseTablesRec->GetString(iTableRecIndex);
			Assert(szThisTableOnly);

			if(!fNewTables)
			{
				pCatalogCursor->Reset();
				pCatalogCursor->SetFilter(iColumnBit(ctcName));
				AssertNonZero(pCatalogCursor->PutString(ctcName, *MsiString(szThisTableOnly)));
			}
			else
			{
				pNewTableCursor->Reset();
				pNewTableCursor->SetFilter(iColumnBit(ctvTable) | iColumnBit(ctvColumn));
				pNewTableCursor->PutString(ctvTable,  *MsiString(szThisTableOnly));
				pNewTableCursor->PutString(ctvColumn, *MsiString(*sztvopCreate));
			}
		}

		int iTableName;
		int cCurrentColumns = 0;
		int cPrimaryKey = 0;
		PMsiTable pTable(0);
		PMsiCursor pTableCursor(0);
		if (!fNewTables)  // fetch next table from current database
		{
			if (!pCatalogCursor->Next())  // check if more current tables
			{
				fNewTables = true;

				pNewTableCursor->SetFilter(iColumnBit(ctvColumn));
				pNewTableCursor->PutString(ctvColumn, *MsiString(*sztvopCreate));

				if(iTableRecIndex)
					iTableRecIndex--; // so next iteration stays with same table

				continue;
			}
			if (pCatalogCursor->GetInteger(~iTreeLinkMask) & iRowTemporaryBit)
				continue;
			IMsiStream* piStream;
			iTableName = pCatalogCursor->GetInteger(ctcName);
			piError = riTransform.OpenStream(DecodeStringNoRef(iTableName).GetString(), (iErrors & iteNoSystemStreamNames) ? fFalse : Bool(iCatalogStreamFlag), piStream); //!! remove test for 1.0 ship
			if (piError)  // no transform stream, or error
			{
				if (piError->GetInteger(1) != idbgStgStreamMissing)  // stream failure, should be rare
					return piError;
				piError->Release();
				continue;
			}
			else  // stream exists, close now, will open below by CTransformStreamRead
				piStream->Release();
			if ((piError = LoadTable(DecodeStringNoRef(iTableName), 0, *&pTable)) != 0)
				return piError;
			cPrimaryKey = pTable->GetPrimaryKeyCount();
			cCurrentColumns = pTable->GetPersistentColumnCount();
			pTableCursor = pTable->CreateCursor(fFalse);
		}
		else // fetch next added table
		{
			if (!pNewTableCursor->Next())
			{
				fNoMoreTables = true;
				continue;
			}
			memset(rgiColName, 0, sizeof(rgiColName));
			iTableName = pNewTableCursor->GetInteger(ctvTable);
			pFindCursor->SetFilter(iColumnBit(ctvTable) | iColumnBit(ctvRow));
			pFindCursor->PutInteger(ctvTable, iTableName);
			while (pFindCursor->Next())
			{
				unsigned int iCol  = pFindCursor->GetInteger(ctvCurrent);
				unsigned int iDef  = pFindCursor->GetInteger(ctvData);
				unsigned int iName = pFindCursor->GetInteger(ctvColumn);
				if (iCol == 0)  // add or drop table
					continue;
				iCol = DecodeStringNoRef(iCol).GetIntegerValue();
				iDef = DecodeStringNoRef(iDef).GetIntegerValue();
				Assert(iCol <= 32);
				rgiColName[iCol] = iName;
				rgiColDef[iCol] = iDef;
				if (iCol > cCurrentColumns)
					cCurrentColumns = iCol;
				if ((iDef & icdPrimaryKey) && iCol > cPrimaryKey)
					cPrimaryKey = iCol;
			}
		}
		const IMsiString& riTableName = DecodeStringNoRef(iTableName); // not ref counted
		CTransformStreamRead tsr(*this, *pTransDb, iErrors, (CMsiTable*)(IMsiTable*)pTable, 1);   //!! remove temp iErrors arg for 1.0 ship
		if (!tsr.OpenStream(riTransform, riTableName.GetString(), piError))
		{
			if (piError)
				return piError;
			continue;  // stream not present, should not happen unless corrupt transform
		}
		pViewCursor->PutString(ctvTable, riTableName);

		while (tsr.GetNextOp())
		{
			MsiString strRow;
			MsiString strStreamName(riTableName); riTableName.AddRef();
			if (!fNewTables)
				pTableCursor->Reset();
			unsigned int iColumnMask = tsr.GetColumnMask();
			int iCol;
			int iColDef;
			for (iCol = 1; iCol <= cPrimaryKey; iCol++, iColumnMask >>= 1)
			{
				MsiString strData;
				if (fNewTables)
				{
					iColDef = rgiColDef[iCol];
					strData = tsr.GetStringValue(iColDef, *strStreamName);
				}
				else
				{
					iColDef = pTable->GetColumnType(iCol);
					if (!tsr.GetValue(iCol, *pTableCursor))
						return PostError(Imsg(idbgTransStreamError));
					if (iColDef & icdObject)
						strData = pTableCursor->GetString(iCol);
					else
						strData = MsiString(pTableCursor->GetInteger(iCol));
				}
				if (strData.TextSize() == 0)
					strData = TEXT(" ");  // space used for NULL data
				if (iCol != 1)
					strRow += MsiChar('\t');  // tab used as separator
				strRow += strData;
				strStreamName += MsiChar('.');
				strStreamName += strData;
			}
			pViewCursor->PutString(ctvRow, *strRow);
			pViewCursor->PutNull(ctvData);
			pViewCursor->PutNull(ctvCurrent);
			int iFetch = 0;
			if (!fNewTables)
			{
				pTableCursor->SetFilter((1 << cPrimaryKey) - 1);
				iFetch = pTableCursor->Next();
			}
			if (tsr.IsDelete()) // delete row
			{
				pFindCursor->SetFilter(iColumnBit(ctvTable)  | iColumnBit(ctvRow));
				pFindCursor->PutString(ctvTable, riTableName);
				pFindCursor->PutString(ctvRow,    *strRow);
				while (pFindCursor->Next())  // remove any previous ops on this row
				{
					iFetch |= 256;
					pFindCursor->Delete();
				}
				if (iFetch == 0 && (iErrors & iteDelNonExistingRow) == 0) // unknown row
					return PostError(Imsg(idbgTransDelNonExistingRow), riTableName);
				if (iFetch != 256)  // no insert if not in reference database (nothing left in transform)
				{
					pViewCursor->PutString(ctvColumn, *MsiString(*sztvopDelete));
					AssertNonZero(pViewCursor->Insert()); // cannot fail now
				}
				continue;
			}
			if (tsr.IsAdd()) // inssert row, followed by data values
			{
				pViewCursor->PutString(ctvColumn, *MsiString(*sztvopInsert));
				if ((iFetch && (iErrors & iteAddExistingRow) == 0)  // existing row in database
				 || (!pViewCursor->Insert() && (iErrors & iteAddExistingRow) == 0)) // added in previous transform
					return PostError(Imsg(idbgTransAddExistingRow), riTableName);
			}
			for (; iColumnMask; iCol++, iColumnMask >>= 1)
			{
				if (iColumnMask & 1) // col data is to be added/updated
				{
					pViewCursor->PutNull(ctvCurrent);
					if (fNewTables)
					{
						iColDef = rgiColDef[iCol];
						pViewCursor->PutInteger(ctvColumn, rgiColName[iCol]);
					}
					else if (!fNewTables && iCol <= cCurrentColumns)
					{
						iColDef = pTable->GetColumnType(iCol);
						pViewCursor->PutString(ctvColumn, DecodeStringNoRef(pTable->GetColumnName(iCol)));
						if (!iFetch || (iColDef == icdObject && !pTableCursor->GetInteger(iCol)))
							;
						else if ((iColDef & icdObject) == 0)  // integer
							pViewCursor->PutString(ctvCurrent, *MsiString(pTableCursor->GetInteger(iCol)));
						else if ((iColDef & icdShort) == 0)   // stream
							pViewCursor->PutString(ctvCurrent, *strStreamName);
						else
							pViewCursor->PutString(ctvCurrent, *MsiString(pTableCursor->GetString(iCol)));
					}
					else // must be added column
					{
						pFindCursor->SetFilter(iColumnBit(ctvTable) | iColumnBit(ctvCurrent));
						pFindCursor->PutString(ctvTable, riTableName);
						pFindCursor->PutString(ctvCurrent, *MsiString(iCol));
						if (pFindCursor->Next())
						{
							iColDef = MsiString(pFindCursor->GetString(ctvData));
							pViewCursor->PutString(ctvColumn, *MsiString(pFindCursor->GetString(ctvColumn)));
							pFindCursor->Reset();
						}
						else // column unknown, transform base not compatible
						{
							iColDef = icdString; // just guess, if not string, stream may be out of sync
							pViewCursor->PutString(ctvColumn, *MsiString(MsiString(MsiChar('@')) + MsiString(iCol)));
							pViewCursor->PutString(ctvCurrent, *MsiString(*TEXT("N/A")));
						}
					}
					pViewCursor->PutString(ctvData, *MsiString(tsr.GetStringValue(iColDef, *strStreamName)));

					if(!fNewTables && !tsr.IsAdd() && !iFetch && (iErrors & iteUpdNonExistingRow) == 0) // row doesn't exist
						return PostError(Imsg(idbgTransUpdNonExistingRow), riTableName);
					AssertNonZero(pViewCursor->Assign()); // already an update for this value
													  // shouldn't ever fail
				}
			}  // while next column
		} // while next row
	} // while next table

	// add a lock count to hold temp table in memory
	m_piCatalogTables->SetTableState(EncodeString(*strViewTableName), ictsLockTable);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\srcmgmt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       srcmgmt.cpp
//
//--------------------------------------------------------------------------

/* srcmgmt.cpp - Source management implementation
____________________________________________________________________________*/

#include "precomp.h"
#include "_msiutil.h"
#include "_msinst.h"
#include "_srcmgmt.h"
#include "resource.h"

extern HINSTANCE g_hInstance;
extern scEnum g_scServerContext;

// REVIEW davidmck - looks a lot like several other functions in engine.cpp and msiutil.cpp
static IMsiServer* CreateServer() 
{
	IMsiServer* piUnknown;
	if (g_scServerContext != scService && g_scServerContext != scServer && (piUnknown = ENG::CreateMsiServerProxy()) != 0)
	{
		return piUnknown;
	}
	return ENG::CreateConfigurationManager();
}

Bool MapSourceCharToIsf(const ICHAR chSourceType, isfEnum& isf)
{
	switch (chSourceType | 0x20) // lower-case
	{
	case chNetSource:   isf = isfNet;   break;
	case chURLSource:   isf = isfURL;   break;
	case chMediaSource: isf = isfMedia; break;
	default:	return fFalse;
	}
	return fTrue;
}

const IMsiString& GetDiskLabel(IMsiServices& riServices, unsigned int uiDiskId, const ICHAR* szProduct)
{
	LONG lResult;
	CRegHandle HSourceListKey;
	
	PMsiRecord pError = 0;

	if ((lResult = OpenSourceListKey(szProduct, fFalse, HSourceListKey, fFalse, false)) != ERROR_SUCCESS)
		return g_MsiStringNull;

	PMsiRegKey pSourceListKey = &riServices.GetRootKey((rrkEnum)(int)HSourceListKey, ibtCommon); // x86 and ia64 same
	PMsiRegKey pMediaKey = &pSourceListKey->CreateChild(szSourceListMediaSubKey, 0);
	
	MsiString strDiskLabelAndPrompt;
	if ((pError = pMediaKey->GetValue(MsiString((int)uiDiskId), *&strDiskLabelAndPrompt)) != 0)
		return g_MsiStringNull;

	return MsiString(strDiskLabelAndPrompt.Extract(iseUpto, ';')).Return();
}

Bool LastUsedSourceIsMedia(IMsiServices& riServices, const ICHAR* szProduct)
{
	isfEnum isf;
	return (GetLastUsedSourceType(riServices, szProduct, isf) && (isf == isfMedia)) ? fTrue : fFalse;
}

bool GetLastUsedSourceType(IMsiServices& riServices, const ICHAR* szProduct, isfEnum &isf)
{
	LONG lResult;
	CRegHandle HSourceListKey;
	
	PMsiRecord pError = 0;

	if ((lResult = OpenSourceListKey(szProduct, fFalse, HSourceListKey, fFalse, false)) != ERROR_SUCCESS)
		return false;

	PMsiRegKey pSourceListKey = &riServices.GetRootKey((rrkEnum)(int)HSourceListKey, ibtCommon); // x86 and ia64 same

	MsiString strLastUsedSource;
	if ((pError = pSourceListKey->GetValue(szLastUsedSourceValueName, *&strLastUsedSource)) != 0)
		return false;

	if (strLastUsedSource.Compare(iscStart, TEXT("#%"))) 
		strLastUsedSource.Remove(iseFirst, 2); // remove REG_EXPAND_SZ token

	if (!MapSourceCharToIsf(*(const ICHAR*)strLastUsedSource, isf))
		return false;

	return true;
}

icscEnum CheckShareCSCStatus(isfEnum isf, const ICHAR *szLastUsedSource)
{
	// media or URL sources don't need to be checked. An isfFullPath can be 
	// absolutely anything, so we need to check in case it is a net share that is
	// CSC enabled.
	if (isf == isfNet || isf == isfFullPath)
	{
		// CSC only avilable on NT5
		if (!g_fWin9X && g_iMajorVersion >= 5)
		{
			DWORD dwStatus = 0;
		
			if (CSCDLL::CSCQueryFileStatusW(szLastUsedSource, &dwStatus, 0, 0))
			{
				if ((dwStatus & FLAG_CSC_SHARE_STATUS_NO_CACHING) == FLAG_CSC_SHARE_STATUS_NO_CACHING) // mask is made up of more than 1 bit
				{
					// CSC is not enabled for this share. Source is valid and cached
					return cscNoCaching;
				}
				else if (dwStatus & FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP)
				{
					DEBUGMSG1(TEXT("Share %s is a disconnected CSC share."), szLastUsedSource);
					return cscDisconnected;
				}
				else
				{
					DEBUGMSG1(TEXT("Share %s is a connected CSC share."), szLastUsedSource);
					return cscConnected;
				}
			}
		}
	}
	return cscNoCaching;
}

//____________________________________________________________________________
//
// CResolveSource implementation
//____________________________________________________________________________

CResolveSource::CResolveSource(IMsiServices* piServices, bool fPackageRecache) : m_pSourceListKey(0), m_piServices(piServices), m_fAllowDisconnectedCSCSource(true), m_fValidatePackageCode(true),
	m_uiMinimumDiskId(0), m_fCSOS(false)
{ 
	if (!piServices) 
	{
		m_fLoadedServices = fTrue;
		m_piServices = ENG::LoadServices();
		Assert(m_piServices);
	}
	else
		m_fLoadedServices = fFalse;


	GetStringPolicyValue(szSearchOrderValueName, fFalse, m_rgchSearchOrder);

	// if resolving for an MSI network recache, and media is first in the sourcelist, 
	// promote the second source type and place media second. Also ignore all lastused
	// values, and don't validate the package code at the source. See bug 9166
	m_fIgnoreLastUsedSource = fPackageRecache;
	m_fValidatePackageCode = !fPackageRecache;
	
	if (fPackageRecache)
	{
		if (m_rgchSearchOrder[0] == chMediaSource && m_rgchSearchOrder[1] != 0)
		{
			isfEnum isfPromoting;
			MapSourceCharToIsf(m_rgchSearchOrder[1], isfPromoting);
			DEBUGMSG1("SOURCEMGMT: Modifying search order: Demoting media, promoting %s.", 
				isfPromoting == isfURL ? "URL" : isfPromoting == isfNet ? "net" : "unknown");
			m_rgchSearchOrder[0] = m_rgchSearchOrder[1];
			m_rgchSearchOrder[1] = chMediaSource;
		}
	}

	// determine what policy says about media (not product dependent) and cache results.
	if (GetIntegerPolicyValue(szDisableMediaValueName, fFalse) == 1)
	{
		m_imdMediaDisabled = imdAlwaysDisable;
	} 
	else if (GetIntegerPolicyValue(szAllowLockdownMediaValueName, fTrue) ==1) 
	{
		m_imdMediaDisabled = imdAlwaysEnable;
	}
	else
	{
		DEBUGMSG("SOURCEMGMT: Media enabled only if package is safe.");
		m_imdMediaDisabled = imdOnlyIfSafe;
	}
	
	m_fMediaDisabled = false;
	m_szProduct[0] = 0;
}

CResolveSource::~CResolveSource()
{
	if (m_fLoadedServices)
		ENG::FreeServices();
}


void CResolveSource::AddToRecord(IMsiRecord*& rpiRecord, const IMsiString& riString)
{
	int cFields = rpiRecord->GetFieldCount();
	for (int c = 1; c <= cFields && !rpiRecord->IsNull(c); c++)
		;

	if (c > cFields)
	{
		PMsiRecord pRec = rpiRecord;
		rpiRecord = &m_piServices->CreateRecord(cFields+10);
		
		for (c = 1; c <= cFields; c++)
		{
			rpiRecord->SetMsiString(c, *MsiString(pRec->GetMsiString(c)));
		}
	}
	rpiRecord->SetMsiString(c, riString);
}

IMsiRecord* CResolveSource::GetProductsToSearch(const IMsiString& riClient, IMsiRecord*& rpiRecord, Bool fPatch)
{
	MsiString strProducts;
	CRegHandle HKey;

	MsiString strProduct = riClient.Extract(iseUpto, ';');

	DEBUGMSG1(TEXT("SOURCEMGMT: Looking for sourcelist for product %s"), (const ICHAR*)strProduct);
	
	DWORD dwResult;
	if (fPatch)
		dwResult = OpenAdvertisedPatchKey(strProduct, HKey, false);
	else
		dwResult = OpenAdvertisedProductKey(strProduct, HKey, false, 0);
	
	if (ERROR_SUCCESS != dwResult)
		return 0;
	
	const int cExpectedMaxClients = 10;
	if (!rpiRecord)
		rpiRecord = &m_piServices->CreateRecord(cExpectedMaxClients);

	PMsiRegKey pProductKey    = &m_piServices->GetRootKey((rrkEnum)(int)HKey, ibtCommon); // x86 and ia64 same
	PMsiRegKey pSourceListKey = &pProductKey->CreateChild(szSourceListSubKey);
	
	Bool fKeyExists = fFalse;
	AssertRecord(pSourceListKey->Exists(fKeyExists));
	if (fKeyExists)
	{
		DEBUGMSG1(TEXT("SOURCEMGMT: Adding %s to potential sourcelist list (pcode;disk;relpath)."), riClient.GetString());
		AddToRecord(rpiRecord, riClient);
	}

	MsiString strClients;
	AssertRecord(pProductKey->GetValue(szClientsValueName, *&strClients));
	while (strClients.TextSize())
	{
		MsiString strClient = strClients.Extract(iseUpto, '\0');
		if (!strClients.Remove(iseIncluding, '\0'))
			break;

		if (strClient.TextSize() == 0)
			continue;

		if (strClient.Compare(iscExact, szSelfClientToken)) // skip "self" client
			continue;
	
		AssertRecord(GetProductsToSearch(*strClient, rpiRecord, fPatch));
	}
	return 0;
}

enum rspResolveSourcePrompt
{
	rspPatch=1,
	rspPackageName,
	rspProduct,
	rspRelativePath,
	rspAllowDisconnectedCSCSource,
	rspValidatePackageCode,
	rspRequiredDisk,
	rspfCSOS,
	rspNext
};

imsEnum PromptUserForSource(IMsiRecord& riInfo)
{
	IMsiServices* piServices = ENG::LoadServices();
	Assert(piServices);

	Bool fPatch              = (Bool)riInfo.GetInteger(rspPatch);
	MsiString strPackageName = riInfo.GetMsiString(rspPackageName);
	
	bool fSuccess = false;
	MsiString strSource;

	// display UI
	ICHAR rgchUseFeature[64];   // caption for combo box (German is 23 chars)
	LANGID iLangId = g_MessageContext.GetCurrentUILanguage();
	UINT iCodepage = MsiLoadString(g_hInstance, IDS_USE_FEATURE_TEXT, rgchUseFeature, sizeof(rgchUseFeature)/sizeof(*rgchUseFeature), iLangId);
	CResolveSourceUI resolveSource(piServices, rgchUseFeature, iCodepage, iLangId);

	DEBUGMSG("SOURCEMGMT: Prompting user for a valid source.");
	// enable browse when admin, non-elevated, machine AllowLockdownBrowse set, but ALWAYS disable browse 
	// if DisableBrowse policy is set
	bool fEnableBrowse = (GetIntegerPolicyValue(szDisableBrowseValueName, fTrue) != 1) &&
						  (GetIntegerPolicyValue(szAllowLockdownBrowseValueName, fTrue) == 1 ||
						   SafeForDangerousSourceActions(riInfo.GetString(rspProduct)));

	DEBUGMSG1(TEXT("SOURCEMGMT: Browsing is %s."), fEnableBrowse ? TEXT("enabled") : TEXT("disabled"));

	// only use the first product in our search list in the UI.
	MsiString strRelativePath = riInfo.GetMsiString(rspRelativePath);
	MsiString strProductToSearch = riInfo.GetMsiString(rspProduct);
	bool fAllowDisconnectedCSCSource = riInfo.GetInteger(rspAllowDisconnectedCSCSource) == 1;
	bool fValidatePackageCode = riInfo.GetInteger(rspValidatePackageCode) == 1;
	bool fCSOS = riInfo.GetInteger(rspfCSOS) == 1;
	UINT uiDisk = riInfo.GetInteger(rspRequiredDisk);
	strRelativePath.Remove(iseIncluding, ';');
	if (!riInfo.IsNull(rspProduct) && 
		  resolveSource.ResolveSource(strProductToSearch, fPatch ? istPatch : istInstallPackage, fEnableBrowse, strPackageName, *&strSource, fTrue, uiDisk, fAllowDisconnectedCSCSource, fValidatePackageCode, fCSOS))
	{
		strSource += strRelativePath;
		fSuccess = true;
		DEBUGMSG1(TEXT("SOURCEMGMT: Resolved source to: '%s'"), (const ICHAR*)strSource);
	}
	ENG::FreeServices();

	return fSuccess ? imsOk : imsCancel;
}

IMsiRecord* CResolveSource::ResolveSource(const ICHAR* szProduct, Bool fPatch, unsigned int uiDisk, 
														const IMsiString*& rpiSource, const IMsiString*& rpiSourceProduct,
														Bool fSetLastUsedSource, HWND /*hWnd*/, bool fAllowDisconnectedCSCSource)
/*----------------------------------------------------------------------------
	Finds a source for the given product and returns it in rgchSource. 
	First an attempt is made to find a source without presenting UI. If this
	fails, we allow the user to select a source via 
	a dialog.
--------------------------------------------------------------------------*/
{	
	m_fSetLastUsedSource = fSetLastUsedSource;
	m_fAllowDisconnectedCSCSource = fAllowDisconnectedCSCSource;
	
	IMsiRecord* piError = 0;

	MsiString strPackageName;
	BOOL fResult = FALSE;
	Bool fOnlyMediaSources;
	psfEnum psfFlags = (psfEnum)(psfProcessRawLastUsed|psfConnectToSources|psfProcessMultipleFormats|psfReplaceIData);

	PMsiRecord pProductsToSearch(0);
	PMsiRecord pCachedProducts(0);

	MsiString strClient = szProduct;
	strClient += MsiChar(';');

	if (fPatch)
		m_isptSourcePackageType = istPatch;
	else
		m_isptSourcePackageType = istInstallPackage;

	piError = GetProductsToSearch(*strClient, *&pProductsToSearch, fPatch);
	if (pProductsToSearch == 0)
		piError = PostError(Imsg(imsgSourceResolutionFailed), szProduct, TEXT(""));

	if (piError == 0)
	{
		// Look for cached products that are in our list of products to search. Move any
		// matches to the front of the list of products to search.
		if (((piError = ProcessSources(*pProductsToSearch, fPatch, rpiSource, *&strPackageName, rpiSourceProduct, uiDisk,
										 ValidateSource, (INT_PTR)szProduct, fOnlyMediaSources, psfFlags)) != 0) &&		//--merced: changed (int) to (INT_PTR)
			 (piError->GetInteger(1) == imsgSourceResolutionFailed || piError->GetInteger(1) == imsgSourceResolutionFailedCSOS))
		{
			PMsiRecord pSourcePromptInfo(&CreateRecord(rspNext-1));
			
			if(piError->GetInteger(1) == imsgSourceResolutionFailed)
			{
				pSourcePromptInfo->SetInteger(rspfCSOS, 0);
			}
			else if(piError->GetInteger(1) == imsgSourceResolutionFailedCSOS)
			{
				pSourcePromptInfo->SetInteger(rspfCSOS, 1);
			}

			pSourcePromptInfo->SetInteger(rspPatch, (int)fPatch);

			MsiString strRelativePath = pProductsToSearch->GetMsiString(1);
			MsiString strProductToSearch = strRelativePath.Extract(iseUpto, ';');

			pSourcePromptInfo->SetMsiString(rspProduct, *strProductToSearch);
			pSourcePromptInfo->SetMsiString(rspRelativePath, *strRelativePath);
			pSourcePromptInfo->SetMsiString(rspPackageName, *strPackageName);
			pSourcePromptInfo->SetInteger(rspAllowDisconnectedCSCSource, (int)fAllowDisconnectedCSCSource);
			pSourcePromptInfo->SetInteger(rspValidatePackageCode, (int)m_fValidatePackageCode);
			pSourcePromptInfo->SetInteger(rspRequiredDisk, (int)uiDisk);
			
			if (imsOk == g_MessageContext.Invoke(imtResolveSource, pSourcePromptInfo))
			{
				// the user has chosen a source, and it is now the LUS. Because the UI
				// could be in a different process than this one, run through
				// the source processor one more time, but only looking at the LUS.
				// If we're doing a recache via productcode, reset m_fIgnoreLastUsedSource 
				// to false so that we can connect to the source.
				//!!future: can we not do this if client-side?
				piError->Release();
				pProductsToSearch->SetNull(2); // only process the first product
				psfFlags = psfEnum(psfFlags | psfOnlyProcessLastUsed);
				ClearObjectCache();
				m_fIgnoreLastUsedSource = false;
				piError = ProcessSources(*pProductsToSearch, fPatch, rpiSource, *&strPackageName, *&rpiSourceProduct, uiDisk,
												 ValidateSource, (INT_PTR)szProduct, fOnlyMediaSources, psfFlags);		//--merced: changed (int) to (INT_PTR)
			}
		}
		else if (piError == 0)
		{
			if (fSetLastUsedSource)
				piError = SetLastUsedSource(rpiSourceProduct->GetString(), rpiSource->GetString(), fFalse, fPatch==fTrue); //?? Should this be a fatal error? Perhaps just a warning is in order
		}
	}

	DEBUGMSG1(piError ? TEXT("SOURCEMGMT: Failed to resolve source") : TEXT("SOURCEMGMT: Resolved source to: '%s'"), rpiSource->GetString());

	return piError;
}

void CResolveSource::ClearObjectCache()
{
	m_szProduct[0] = 0;
}

IMsiRecord* CResolveSource::InitializeProduct(const ICHAR* szProduct, Bool fPatch, const IMsiString*& rpiPackageName)
{
	if (0 == IStrComp(szProduct, m_szProduct))
	{
		if (rpiPackageName)
			rpiPackageName->Release(), rpiPackageName = 0;
		return m_pSourceListKey->GetValue(szPackageNameValueName, rpiPackageName);
	}

	LONG lResult;
	if ((lResult = OpenSourceListKey(szProduct, fPatch, m_HSourceListKey, fFalse, false)) != ERROR_SUCCESS)
		return PostError(Imsg(idbgSrcOpenSourceListKey), lResult);

	DEBUGMSG1(TEXT("SOURCEMGMT: Now checking product %s"), szProduct);

	IMsiRecord* piError = 0;
	m_pSourceListKey   = &m_piServices->GetRootKey((rrkEnum)(int)m_HSourceListKey, ibtCommon); // x86 and ia64 same

	// get the package name -- we'll need it to validate the source
	if ((piError = m_pSourceListKey->GetValue(szPackageNameValueName, rpiPackageName)) != 0)
		return piError;
	if (rpiPackageName->TextSize() == 0) // package name is missing from registry
		return PostError(Imsg(idbgSrcNoPackageName), szProduct); 

	m_strLastUsedSourceIndex = *TEXT("");
	m_uiMinimumDiskId = 1;

	MsiString strLastUsedSource;
	MsiString strLastUsedSourceType;
	MsiString strLastUsedSourceIndex;
	isfEnum isfLastUsedSource;

	// rgchSourceType contains:  type;index;source
	if ((piError = m_pSourceListKey->GetValue(szLastUsedSourceValueName, *&strLastUsedSource)) != 0)
		return piError;

	if (strLastUsedSource.Compare(iscStart, TEXT("#%"))) 
		strLastUsedSource.Remove(iseFirst, 2); // remove REG_EXPAND_SZ token
	strLastUsedSourceType = strLastUsedSource.Extract(iseUpto, ';');
	strLastUsedSource.Remove(iseIncluding, ';');
	strLastUsedSourceIndex = strLastUsedSource.Extract(iseUpto, ';');

	if (MapSourceCharToIsf(*(const ICHAR*)strLastUsedSourceType, isfLastUsedSource))
		m_isfLastUsedSourceFormat = isfLastUsedSource;
	else
	{
		// ??
	}
		
	// disable media based on policy or product elevation state.
	m_strLastUsedSourceIndex  = strLastUsedSourceIndex;
	StringCchCopy(m_szProduct, (sizeof(m_szProduct)/sizeof(ICHAR)), szProduct);
	switch (m_imdMediaDisabled) {
	case imdAlwaysEnable:
		m_fMediaDisabled = false;
		break;
	default:
		// fall through to most secure option if confused
		AssertSz(0, "Unknown media disable state. Assuming Disabled");
	case imdAlwaysDisable:
		m_fMediaDisabled = true;
		break;
	case imdOnlyIfSafe:
		m_fMediaDisabled = !SafeForDangerousSourceActions(szProduct);
		DEBUGMSG1("SOURCEMGMT: Media is %s for product.", m_fMediaDisabled ? "disabled" : "enabled" );
		break;
	}

	// packages written for 1.0/1.1 were not required to have the first DiskId be 1. Thus,
	// when asked explicitly for Disk1 (usually to determine the packagecode, sourcetype, etc),
	// we actually return the first disk, regardless of ID. Thus we must determine what the 
	// minimum disk ID is.
	PMsiRegKey pSourceListSubKey = 0;
	pSourceListSubKey = &m_pSourceListKey->CreateChild(szSourceListMediaSubKey);
	if (pSourceListSubKey)
	{
		// 99.99% of packages will have 1 as the first DiskId, so try that first
		// to avoid having to enum the key.
		MsiString strValueName = TEXT("1");
		Bool fExists = fFalse;;
		if ((piError = pSourceListSubKey->ValueExists(strValueName, fExists)) != NULL)
			return piError;
		
		if (fExists)
		{
			// yes, it exists.
			m_uiMinimumDiskId = 1;
		}
		else
		{
			// initialize the minimum disk value 
			m_uiMinimumDiskId = 0;

			// Create an enumerator for the source list media key
			PEnumMsiString pEnum(0);
			if ((piError = pSourceListSubKey->GetValueEnumerator(*&pEnum)) != 0)
			{
				return piError;
			}

			// enumerate all values and check each diskId 
			const IMsiString* piValueName = 0;
			while (pEnum->Next(1, &piValueName, 0) == S_OK)
			{
				strValueName = *piValueName;

				// ignore non-disk media values
				if (strValueName.Compare(iscExact, szMediaPackagePathValueName)   ||
					strValueName.Compare(iscExact, szDiskPromptTemplateValueName))
					continue;

				// yes, it exists.
				if (m_uiMinimumDiskId == 0 || m_uiMinimumDiskId > (int)strValueName)
					m_uiMinimumDiskId = strValueName;
			}
		}
	}
		
	return 0;
}

IMsiRecord* CResolveSource::ProcessSources(IMsiRecord& riProducts, Bool fPatch, const IMsiString*& rpiSource, 
						 const IMsiString*& rpiPackageName,
						 const IMsiString*& rpiSourceProduct,
						 unsigned int uiDisk,
						 PfnProcessSource pfnProcessSource, INT_PTR iData,			//--merced: changed int to INT_PTR
						 Bool &fOnlyMediaSources,
						 psfEnum psfFlags)
/*----------------------------------------------------------------------------
	1) Processes raw LastUsedSource
	2) Processes LastUsedSource
	3) Processes source lists
 --------------------------------------------------------------------------*/
{
	MsiString strSourceListKey;
	strSourceListKey += MsiString(MsiChar(chRegSep));
	strSourceListKey += szSourceListSubKey;

	fOnlyMediaSources = fTrue;
	Bool fSourceListEmpty;
	IMsiRecord* piError = 0;
	PMsiRecord pDiscardableError = 0;

	bool fCSOS = false;

	if (!m_fIgnoreLastUsedSource)
	{
		int iProduct = 1;
		while (!riProducts.IsNull(iProduct))
		{
			MsiString strRelativePath = riProducts.GetString(iProduct);
			MsiString strProduct = strRelativePath.Extract(iseUpto, ';');
			strRelativePath.Remove(iseIncluding, ';');
			MsiString strDisk = strRelativePath.Extract(iseUpto, ';');
			strRelativePath.Remove(iseIncluding, ';');

			if (psfFlags & psfReplaceIData)
				iData = (INT_PTR)(const ICHAR*)strProduct;		//--merced: changed (int) to (INT_PTR)

			if ((piError = InitializeProduct(strProduct, fPatch, rpiPackageName)) != 0)
				return piError;

			// if asking for disk 1, we really mean "first disk" regardless of ID
			UINT uiActualDiskId = (uiDisk == 1) ? m_uiMinimumDiskId : uiDisk;
			
			// if media is disabled and the last source for this product is media, we are
			// forced to reject the source.
			if (m_isfLastUsedSourceFormat == isfMedia && m_fMediaDisabled)
			{
				DEBUGMSG("SOURCEMGMT: LastUsedSource is Media. Media Disabled for this package.");
			}
			else
			{
				// we can't trust the raw last used source if looking for a particular disk
				if (uiActualDiskId == 0 && (psfFlags & psfProcessRawLastUsed))
				{
					// Try raw LastUsedSource value first
					DEBUGMSG("SOURCEMGMT: Attempting to use raw LastUsedSource value.");
					pDiscardableError = ProcessGenericSourceList(m_pSourceListKey, rpiSource, rpiPackageName->GetString(), 0, 
																				isfFullPath, pfnProcessSource, iData, psfFlags, /*fSkipLastUsed=*/false,
																				/*fCheckOnlySpecifiedIndex=*/false, fSourceListEmpty);
					if (pDiscardableError == 0)
					{
						rpiSource->AppendMsiString(*strRelativePath, rpiSource);
						strProduct.ReturnArg(rpiSourceProduct);
						return 0;
					}
				}

				// Next try LastUsedSource again, but this time use the source information we have stored in our list
				DEBUGMSG("SOURCEMGMT: Attempting to use LastUsedSource from source list.");
				int iLastUsedSourceIndex = (int)m_strLastUsedSourceIndex;

				// if the index is invalid but the type is media and a specific disk is needed, we'll still be able to 
				// perform a check because the requested disk is equivalent to the index.
				if (iLastUsedSourceIndex == iMsiNullInteger && m_isfLastUsedSourceFormat == isfMedia && uiActualDiskId)
					iLastUsedSourceIndex = uiActualDiskId;
					
				if (iLastUsedSourceIndex != iMsiNullInteger && iLastUsedSourceIndex > 0)
				{
					// only process the last used source if it is not media or if its the same disk we are looking
					// for now.
					if (m_isfLastUsedSourceFormat != isfMedia || !uiActualDiskId || uiActualDiskId == iLastUsedSourceIndex)
					{
						pDiscardableError = ProcessGenericSourceList(m_pSourceListKey, rpiSource, rpiPackageName->GetString(), 
																	 iLastUsedSourceIndex, m_isfLastUsedSourceFormat, pfnProcessSource, 
																	 iData, psfFlags, /*fSkipLastUsed=*/false, 
                                                                     /*fCheckOnlySpecifiedIndex=*/true, fSourceListEmpty);
						if (pDiscardableError == 0)
						{
							rpiSource->AppendMsiString(*strRelativePath, rpiSource);
							strProduct.ReturnArg(rpiSourceProduct);
							return 0;
						}
						else if(pDiscardableError->GetInteger(1) == imsgSourceResolutionFailedCSOS)
						{
							fCSOS = true;
						}
					}
				}
				// else ignore invalid source indexes
			}
			iProduct++;
		}
	}
	else
	{
		DEBUGMSG("SOURCEMGMT: Ignoring last used source.");
	}

	// If we get here then we have a missing or invalid LastUsedSource.
	// We need to look around for a good source.

	if ((psfFlags & psfOnlyProcessLastUsed) == 0)
	{
		const ICHAR* pch = m_rgchSearchOrder;

		while (*pch)
		{
			isfEnum isf;
			AssertNonZero(MapSourceCharToIsf(*pch++, isf));

			int iProduct = 1;
			while (!riProducts.IsNull(iProduct))
			{
				MsiString strRelativePath = riProducts.GetString(iProduct);
				MsiString strProduct = strRelativePath.Extract(iseUpto, ';');
				strRelativePath.Remove(iseIncluding, ';');
				MsiString strDisk = strRelativePath.Extract(iseUpto, ';');
				if (!strDisk.TextSize())
					strDisk = 0;

				strRelativePath.Remove(iseIncluding, ';');

				if ((piError = InitializeProduct(strProduct, fPatch, rpiPackageName)) != 0)
					return piError;

				// if asking for disk 1, we really mean "first disk" regardless of ID
				UINT uiActualDiskId = (uiDisk == 1) ? m_uiMinimumDiskId : uiDisk;

				if (isf == isfMedia && m_fMediaDisabled)
				{
					DEBUGMSG("SOURCEMGMT: Media Disabled for this package.");
				}
				else
				{
					if (psfFlags & psfReplaceIData)
					{
						iData = (INT_PTR)(const ICHAR*)strProduct;		//--merced: changed (int) to (INT_PTR)
					}

					DEBUGMSG1("SOURCEMGMT: Processing %s source list.", isf == isfMedia ? "media" : isf == isfURL ? "URL" : isf == isfNet ? "net" : "unknown");
					piError = ProcessGenericSourceList(m_pSourceListKey, rpiSource, rpiPackageName->GetString(), uiActualDiskId, isf, pfnProcessSource, iData, psfFlags, 
                                                       /*fSkipLastUsed=*/!m_fIgnoreLastUsedSource, /*fCheckOnlySpecifiedIndex=*/false, fSourceListEmpty);
					if (piError == 0)
					{
						rpiSource->AppendMsiString(*strRelativePath, rpiSource);
						strProduct.ReturnArg(rpiSourceProduct);
						return 0;
					}
					else if (piError->GetInteger(1) == imsgSourceResolutionFailed || piError->GetInteger(1) == imsgSourceResolutionFailedCSOS) //?? do we want to ignore all errors here?
					{
						if(piError->GetInteger(1) == imsgSourceResolutionFailedCSOS)
						{
							fCSOS = true;
						}
						if (((isf == isfMedia) && fSourceListEmpty) || ((isf != isfMedia) && !fSourceListEmpty))
							fOnlyMediaSources = fFalse;

						piError->Release();
						piError = 0;
					}
					else
						return piError;
				}
				iProduct++;
			}
		}
	}
	
	// If we reach here, all sources have been tried and failed due to source
	// source resolution failure.
	if (!piError)
	{
		if(fCSOS == true)
		{
			piError = PostError(Imsg(imsgSourceResolutionFailedCSOS), TEXT(""), rpiPackageName->GetString());
		}
		else
		{
			piError = PostError(Imsg(imsgSourceResolutionFailed), TEXT(""), rpiPackageName->GetString());
		}
	}
	return piError;
}

IMsiRecord* CResolveSource::ProcessGenericSourceList(
									IMsiRegKey* piSourceListKey,      // list to process
									const IMsiString*& rpiSource,     // on success, the last valid source found
									const ICHAR* szPackageName,       // the package name we're looking for
									unsigned int uiRequestedDisk,     // the disk we need; 0 if any disk will do
									isfEnum isfSourceFormat,          // URL, etc.
									PfnProcessSource pfnProcessSource, 
									INT_PTR iData,						//--merced: changed int to INT_PTR
									psfEnum psfFlags,
									bool fSkipLastUsedSource,           
                                    bool fOnlyCheckSpecifiedIndex,    // only check the requested disk
									Bool& fSourceListEmpty)           // on success, fTrue if the source list is empty 
/*----------------------------------------------------------------------------
	For each source in the given source list key, the given function, 
	pfnProcessSource is applied. Each source is normalized and it and 'iData' 
	is passed to pfnProcessSource. pfnProcessSource's return value determines
	whether or not we abort processing.
 --------------------------------------------------------------------------*/
{
	Assert(((psfRejectInvalidPolicy & psfFlags) && (psfConnectToSources & psfFlags)) ||
			 (!(psfRejectInvalidPolicy & psfFlags)));
			
	IMsiRecord* piError = 0;
	fSourceListEmpty = fTrue;
	bool	fCSOS = false;

	// Open the appropriate source list key if necessary

	const ICHAR* szSubKey = 0;
	switch (isfSourceFormat)
	{
	case isfNet:              szSubKey = szSourceListNetSubKey;   break;
	case isfMedia:            szSubKey = szSourceListMediaSubKey; break;
	case isfURL:              szSubKey = szSourceListURLSubKey;   break;
	case isfFullPath:         szSubKey = 0; break;
	case isfFullPathWithFile: szSubKey = 0; break;
	default:
		Assert(0);
	}

	PMsiRegKey pSourceListSubKey = 0;

	if (piSourceListKey)
	{
		if (szSubKey)
			pSourceListSubKey = &piSourceListKey->CreateChild(szSubKey);
		else
		{
			pSourceListSubKey = piSourceListKey; 
			piSourceListKey->AddRef();
		}
	}

	// Create an enumerator for the source list if we need once. Don't process all of the 
	// entries if we're processing media and looking for a particular disk, or if not
    // media but told to only check specified disk.
	PEnumMsiString pEnum(0);
	int iDisk = 1;
	if (!szSubKey ||
        (isfSourceFormat == isfMedia && uiRequestedDisk != 0) ||
        (isfSourceFormat != isfMedia && fOnlyCheckSpecifiedIndex)) 
    {
        iDisk = uiRequestedDisk;
    }
    else
	{
		if ((piError = pSourceListSubKey->GetValueEnumerator(*&pEnum)) != 0)
			return piError;
		iDisk = 1;
	}

	// If it's a media source then we need to grab the media relative path
	MsiString strMediaRelativePath;
	PMsiRecord pDiskPrompt(&CreateRecord(2));
	if (isfMedia == isfSourceFormat)
	{
		MsiString strDiskPromptTemplate;
		if (((piError = pSourceListSubKey->GetValue(szMediaPackagePathValueName, *&strMediaRelativePath)) != 0) ||
			 ((piError = pSourceListSubKey->GetValue(szDiskPromptTemplateValueName, *&strDiskPromptTemplate)) != 0))
			return piError;

		if (strDiskPromptTemplate.TextSize() == 0)
			strDiskPromptTemplate = TEXT("[1]");

		pDiskPrompt->SetMsiString(0, *strDiskPromptTemplate);
	}


	psEnum psRet = psFileNotFound;
	MsiString strNormalizedSource;
	PMsiPath pPath(0);

	const IMsiString* piValueName = 0;
	while ((pEnum == 0) || (pEnum->Next(1, &piValueName, 0) == S_OK))
	{
		fSourceListEmpty = fFalse;

		// Grab the source from the registry
		
		MsiString strSource;
		MsiString strValueName;
		
		if (piValueName)
			strValueName = *piValueName;
		else if (isfSourceFormat == isfFullPath)
			strValueName = szLastUsedSourceValueName;
		else
			strValueName = MsiString((int)uiRequestedDisk);


		if (strValueName.Compare(iscExact, szMediaPackagePathValueName)   ||
		    strValueName.Compare(iscExact, szDiskPromptTemplateValueName) ||
			strValueName.Compare(iscExact, szURLSourceTypeValueName))
			continue;

		// if looking for a specific disk and processing media sources, only process that specific
		// disk. This keeps us from accepting any product disk that happens to be in the drive and keeps
		// us from populating the UI with the wrong disk 
		if (uiRequestedDisk && m_isfLastUsedSourceFormat == isfMedia && uiRequestedDisk != iDisk)
		{
			iDisk++;
			continue;
		}

		// If we've already processed the last used source in ProcessSources, don't process it, as it
		// was obviously invalid for some reason.
		if (fSkipLastUsedSource && (m_isfLastUsedSourceFormat == isfSourceFormat) && strValueName.Compare(iscExact, m_strLastUsedSourceIndex))
		{
			if (!pEnum) 
				break;
			iDisk++;
			continue;
		}
		
		if (piSourceListKey)
		{
			if ((piError = pSourceListSubKey->GetValue(strValueName, *&strSource)) != 0)
				return piError;

			if (isfSourceFormat == isfFullPath)
			{
				// remove type and index from lastusedsource string
				strSource.Remove(iseIncluding, ';');
				strSource.Remove(iseIncluding, ';');
			}
		}
		else
		{
			Assert(rpiSource);
			strSource = *rpiSource; // don't AddRef; we want to release rpiSource
		}

		if (!strSource.TextSize())
		{
			DEBUGMSG1(TEXT("SOURCEMGMT: Source with value name '%s' is blank"), strValueName);
			break;
		}

		// Process the source.

		MsiString strUnnormalizedSource = strSource;
		MsiString strDiskPrompt;

		// If we're not supposed to attempt to connect to the source then we don't pass a path object pointer
		// to the ConnectTo* functions and they won't attempt the connection.

		bool fConnectToSuccess = false;
		int cMediaPaths = 0;
		CTempBuffer<IMsiPath*, 5> rgiMediaPaths;

		if (isfMedia == isfSourceFormat)
		{
			if (psfFlags & psfConnectToSources)
			{
				// if told to connect to sources, we must actually enumerate all media drives in the system
				// to ensure that we don't miss the disk when looking for disk 1 (where volume label is irrelevant)
				fConnectToSuccess = ConnectToMediaSource(strSource, iDisk, *strMediaRelativePath, rgiMediaPaths, cMediaPaths);
			}
			else
			{
				DEBUGMSG1(TEXT("SOURCEMGMT: Trying media source %s."), strUnnormalizedSource);

				fConnectToSuccess = true;
				strSource.Remove(iseIncluding, ';'); // remove label
				pDiskPrompt->SetMsiString(1, *strSource); // disk label
				strNormalizedSource = pDiskPrompt->FormatText(fFalse);
			}
		}
		else
		{
			if (strSource.Compare(iscStart, TEXT("#%"))) 
			{
				strSource.Remove(iseFirst, 2); // remove REG_EXPAND_SZ token
				ENG::ExpandEnvironmentStrings(strSource, *&strUnnormalizedSource);
			}

			if (psfFlags & psfConnectToSources)
			{
				DEBUGMSG1(TEXT("SOURCEMGMT: Trying source %s."), strSource);
				fConnectToSuccess = ConnectToSource(strUnnormalizedSource, *&pPath, *&strNormalizedSource, isfSourceFormat);
			}
			else
			{
				fConnectToSuccess   = true;
				strNormalizedSource = strUnnormalizedSource;
			}
		}

		if (fConnectToSuccess)
		{
			int iMediaPath = 0;

			Assert(!cMediaPaths || (cMediaPaths < rgiMediaPaths.GetSize()));

			do
			{
				if (cMediaPaths)
				{
					// the PMsiPath object assumes the refcount. Set array to NULL
					// to ensure that nobody else can hijack the refcount.
					pPath = rgiMediaPaths[iMediaPath];
					rgiMediaPaths[iMediaPath++] = 0;

					if (!pPath)
						continue;

					DEBUGMSG1(TEXT("SOURCEMGMT: Trying media source %s."), MsiString(pPath->GetPath()));
				}

				// In some situations the caller wants _us_ to determine whether a given source 
				// is allowed by policy, usually because the caller has only a full path 
				// and doesn't want to bother creating a path object when we're going
				// to do so anyway.
	
				Bool fReject = fFalse;
				if ((psfFlags & psfRejectInvalidPolicy) && pPath)
				{
					fReject = fTrue;
					
					PMsiVolume pVolume = &pPath->GetVolume();
					idtEnum idt = pVolume->DriveType();
					Assert((idt == idtCDROM || idt == idtFloppy || idt == idtRemovable) || (idt == idtRemote || idt == idtFixed));
					if (pVolume->IsURLServer())
						idt = idtNextEnum; // use idtNextEnum to represent URL
	
					const ICHAR* pch = m_rgchSearchOrder;
					while (*pch && fReject)
					{
						isfEnum isf;
						AssertNonZero(MapSourceCharToIsf(*pch++, isf));
						switch (isf)
						{
						case isfMedia:   if (idt == idtCDROM || idt == idtFloppy || idt == idtRemovable) fReject = fFalse; break;
						case isfNet:     if (idt == idtRemote || idt == idtFixed) fReject = fFalse; break;
						case isfURL:     if (idt == idtNextEnum) fReject = fFalse; break;
						default: Assert(0);
						}
					}
					if (fReject)
						psRet = psInvalidProduct;
					else
						psRet = psFileNotFound;
				}
	
				// We now call the ProcessSource function that was passed in
	
				if (!fReject)
				{
					MsiString strPackagePath;
	
					if (pPath)
					{
						PMsiRecord pError = pPath->GetFullFilePath(szPackageName, *&strPackagePath);
						if ( pError )
                            continue;
					}
	
					if ((psRet = pfnProcessSource(m_piServices, strNormalizedSource, strPackagePath, isfSourceFormat, iDisk, iData, m_fAllowDisconnectedCSCSource, m_fValidatePackageCode, m_isptSourcePackageType)) > 0)
					{
						if (pPath)
							MsiString(pPath->GetPath()).ReturnArg(rpiSource);
						else
							strNormalizedSource.ReturnArg(rpiSource);
						
						return 0;
					}
					else if(psRet == psCSOS)
					{
						// Client and source are out of sync. Continue processing
						// the source list, but remember the error so we can
						// return imsgSourceResolutionFailedCSOS.
						fCSOS = true;
					}
				}
			}
			while (cMediaPaths && iMediaPath < cMediaPaths);
		}
		else // ignore errors
		{
			DEBUGMSG2(TEXT("SOURCEMGMT: %s source '%s' is invalid."), isfSourceFormat == isfMedia ? TEXT("media") : isfSourceFormat == isfURL ? TEXT("URL") : isfSourceFormat == isfNet ? TEXT("net") : TEXT("unknown"), strUnnormalizedSource);
		}
		

		if (pEnum == 0)
			break;
		iDisk++;
	}

	Assert(!piError);
	// this is an overload of imsgSourceResolutionFailed. the psRet error code is being used in place
	// of the product name.
	if(fCSOS == true)
	{
		return PostError(Imsg(imsgSourceResolutionFailedCSOS), (int)psRet, szPackageName);
	}
	return PostError(Imsg(imsgSourceResolutionFailed), (int)psRet, szPackageName);
}

bool CResolveSource::ConnectToSource(const ICHAR* szUnnormalizedSource, IMsiPath*& rpiPath, const IMsiString*& rpiNormalizedSource, isfEnum isfSourceFormat)
/*----------------------------------------------------------------------------
	Convert a source into a path. Attempt to connect to the source by 
	creating a path object. 
--------------------------------------------------------------------------*/
{
	Assert(isfNext - 1 == isfMedia);
	PMsiRecord pError = 0;
	Assert(isfSourceFormat == isfFullPathWithFile ||
			 isfSourceFormat == isfFullPath ||
			 isfSourceFormat == isfNet ||
			 isfSourceFormat == isfURL);

	PMsiPath pPath(0);
	MsiString strFileName;
	if (isfSourceFormat == isfFullPathWithFile)
		pError = m_piServices->CreateFilePath(szUnnormalizedSource, *&pPath, *&strFileName);
	else
		pError = m_piServices->CreatePath(szUnnormalizedSource, *&pPath);

	if (pError == 0)
	{
		rpiPath = pPath; rpiPath->AddRef();
		MsiString(pPath->GetPath()).ReturnArg(rpiNormalizedSource);
		return true;
	}
	else
	{
		DEBUGMSG3(TEXT("ConnectToSource: CreatePath/CreateFilePath failed with: %d %d %d"), 
			(const ICHAR*)(INT_PTR)pError->GetInteger(0), 
			(const ICHAR*)(INT_PTR)pError->GetInteger(1), 
			(const ICHAR*)(INT_PTR)pError->GetInteger(2));
		DEBUGMSG2(TEXT("ConnectToSource (con't): CreatePath/CreateFilePath failed with: %d %d"),
			(const ICHAR*)(INT_PTR)pError->GetInteger(3), 
			(const ICHAR*)(INT_PTR)pError->GetInteger(4));

		return false;
	}
}


const idtEnum rgidtMediaTypes[] = {idtCDROM, idtRemovable}; //!! need to add floppy when it's distinguished from removable

bool CResolveSource::ConnectToMediaSource(const ICHAR* szSource, unsigned int uiDisk, const IMsiString& riRelativePath, CTempBufferRef<IMsiPath*>& rgiMediaPaths, int &cMediaPaths)
/*----------------------------------------------------------------------------
	Extract the volume label and disk prompt from a media source.
	If ppiPath is not null then attempt to connect to the source by searching
	all media drives for a volume with the matching label.
--------------------------------------------------------------------------*/
{
	if (!m_piServices)
		return false;

	Assert(isfNext - 1 == isfMedia);

	MsiString strSource = szSource;
	MsiString strLabel  = strSource.Extract(iseUpto, ';');
	strSource.Remove(iseIncluding, ';');
	MsiString strDiskPrompt = strSource;

	PMsiRecord pError = 0;

	cMediaPaths = 0;

	for (int c=0; c < sizeof(rgidtMediaTypes)/sizeof(idtEnum); c++)
	{
		// obtain an enumerator for all volumes of the relevant type (CDROM or Floppy)
		IEnumMsiVolume& riEnum = m_piServices->EnumDriveType(rgidtMediaTypes[c]);

		// loop through all volume objects of that type
		PMsiVolume piVolume(0);
		for (int iMax = 0; riEnum.Next(1, &piVolume, 0) == S_OK; )
		{
			if (!piVolume)
				continue;

			if (!piVolume->DiskNotInDrive())
			{
				bool fVolumeOK = true;
				if (uiDisk != 1)
				{			
					MsiString strCurrLabel(piVolume->VolumeLabel());
					if (!strCurrLabel.Compare(iscExactI,strLabel))
					{
						fVolumeOK = false;
					}
				}

				if (fVolumeOK)
				{
					PMsiPath pPath(0);

					// create path to volume
					if ((pError = m_piServices->CreatePath(MsiString(piVolume->GetPath()), *&pPath)) != 0)
						continue;

					// ensure path was created successfully
					if (!pPath)
						continue;

					// if disk 1, append relative path
					if (uiDisk == 1)
					{
						if ((pError = pPath->AppendPiece(riRelativePath)) != 0)
						{
							continue;
						}
					}

					// add this path to the array of path objects. Must addref to
					// ensure path object lives beyond pPath lifetime.
					if (cMediaPaths+1 == rgiMediaPaths.GetSize())
						rgiMediaPaths.Resize(cMediaPaths*2);
					rgiMediaPaths[cMediaPaths++] = pPath;
					pPath->AddRef();
				}
			}
		}
		riEnum.Release();
	}
	return true;
}

psEnum CResolveSource::ValidateSource(IMsiServices* piServices, const ICHAR* /*szDisplay*/, const ICHAR* szPackageFullPath, isfEnum isfSourceFormat, int iSourceIndex, INT_PTR iUserData, bool fAllowDisconnectedCSCSource, bool fValidatePackageCode, isptEnum isptSourcePackageType)		//--merced: changed int to INT_PTR
/*----------------------------------------------------------------------------
	Returns a psEnum indicating the validity of the given source.
--------------------------------------------------------------------------*/
{
	psEnum psRet = psInvalidProduct;

	if (isfSourceFormat == isfMedia && iSourceIndex > 1) // We can't look for the package except on disk 1. 
																		  // We'll just have to assume that because the volume label
																		  // matched then it's the correct disk
	{
		psRet = psValidSource;
	}
	else
	{
		PMsiStorage pStorage(0);
		MsiString strPackageFullPath = szPackageFullPath;
		CDeleteUrlLocalFileOnClose cDeleteUrlLocalFileOnClose; // will set later
		bool fUsedWinHttp = true;
		bool fFileUrl = false;
		UINT uiStat = ERROR_SUCCESS;

		if (ERROR_SUCCESS == uiStat && IsURL(szPackageFullPath, fFileUrl))
		{
			if (fFileUrl)
			{
				// canonicalize and convert to DOS path
				CTempBuffer<ICHAR, 1> rgchFullPath(cchExpectedMaxPath + 1);
				DWORD cchFullPath = rgchFullPath.GetSize();

				if (MsiConvertFileUrlToFilePath(szPackageFullPath, rgchFullPath, &cchFullPath, 0))
				{
					strPackageFullPath = static_cast<const ICHAR*>(rgchFullPath);
				}
				else
					uiStat = ERROR_FILE_NOT_FOUND;
			}
			else // http or https download
			{
				bool fURL = false;
				uiStat = DownloadUrlFile(szPackageFullPath, *&strPackageFullPath, fURL, /* cTicks = */ 0, &fUsedWinHttp);
				
				// FUTURE: Consider using a smart cache manager that would prevent multiple downloads by asking
				//         the cache manager for the location of the downloaded file (if already downloaded)
				//

				Assert(fURL);
				if (!fURL || (ERROR_SUCCESS != uiStat))
					uiStat = ERROR_FILE_NOT_FOUND;
				else if (ERROR_SUCCESS == uiStat && fURL && fUsedWinHttp)
				{
					// only handle cleanup for winhttp style downloads
					cDeleteUrlLocalFileOnClose.SetFileName(*strPackageFullPath, /* fDeleteFromIECache = */ !fUsedWinHttp);
				}
			}
		}
		
		// SAFER check does not occur when validating source for ResolveSource
		if (ERROR_SUCCESS == uiStat)
			uiStat = OpenAndValidateMsiStorage(strPackageFullPath, isptSourcePackageType == istPatch ? stPatch : stDatabase, *piServices, *&pStorage, /*fCallSAFER = */false, /*szFriendlyName*/NULL,/*phSaferLevel*/NULL);

		if (ERROR_SUCCESS == uiStat)
		{
			CTempBuffer<ICHAR,cchPackageCode+1> rgchExistingPackageCode;
			rgchExistingPackageCode[0] = 0;
			
			const ICHAR* szProductCode = (const ICHAR*)(iUserData);		
		
			Bool fRet = fTrue;
			if (isptSourcePackageType==istPatch)
			{
				rgchExistingPackageCode.SetSize(lstrlen(szProductCode)+1); // for a patch the patch code is what we use for the package code
				StringCchCopy(rgchExistingPackageCode, rgchExistingPackageCode.GetSize(), szProductCode);
			}
			else 
			{
				fRet = GetExpandedProductInfo(szProductCode, INSTALLPROPERTY_PACKAGECODE,rgchExistingPackageCode,isptSourcePackageType==istPatch);
			}

			if (fRet)
			{
				ICHAR szPackageCode[39];
				ICHAR szPackageProductCode[39];
				uiStat = GetPackageCodeAndLanguageFromStorage(*pStorage, szPackageCode);
				if(uiStat == ERROR_SUCCESS)
				{
					if (!fValidatePackageCode || 0 == IStrCompI(szPackageCode, rgchExistingPackageCode))
					{
						if (isptSourcePackageType==istPatch)
						{
							psRet = psValidSource;
						}
						else
						{
							DWORD dwStatus = 0;
							MsiString strFile;
							PMsiPath pPath(0);
							MsiString strServerShare;
							PMsiRecord pError = piServices->CreateFilePath(szPackageFullPath, *&pPath, *&strFile);
							if (pError)
								psRet = psFileNotFound;
							else
							{
								strServerShare = PMsiVolume(&pPath->GetVolume())->GetPath();

								switch (CheckShareCSCStatus(isfSourceFormat, strServerShare))
								{
								case cscNoCaching:	// fall through
								case cscConnected:
									psRet = psValidSource;
									break;
								case cscDisconnected:
									if (fAllowDisconnectedCSCSource)
										psRet = psValidSource;
									else
									{
										DEBUGMSG(TEXT("SOURCEMGMT: Source is invalid due to CSC state."));
										psRet = psFileNotFound;
									}
									break;
								default:
									AssertSz(0, TEXT("Unknown CSC Status in CResolveSource::ValidateSource()"));
									psRet = psFileNotFound;
								}
							}
						}
					}
					else
					{
						if(fValidatePackageCode)
						{
							// Package code is different. Check to see if this
							// is a client source out of sync problem.

							uiStat = GetProductCodeFromPackage(szPackageFullPath, szPackageProductCode);
							if(uiStat == ERROR_SUCCESS)
							{
								if(IStrCompI(szProductCode, szPackageProductCode) == 0)
								{
									psRet = psCSOS;
									DEBUGMSG("SOURCEMGMT: Source is invalid due to client source our of sync (product code is the same).");
								}
								else
								{
									DEBUGMSG("SOURCEMGMT: Source is invalid due to invalid package code (product code doesn't match).");
								}
							}
							else
							{
								DEBUGMSG("SOURCEMGMT: Source is invalid due to invalid package code (can not get product code).");
							}
						}
					}
				}
			}
		}
		else if (ERROR_FILE_NOT_FOUND == uiStat || ERROR_PATH_NOT_FOUND == uiStat)
		{
			DEBUGMSG(TEXT("SOURCEMGMT: Source is invalid due to missing/inaccessible package."));
			psRet = psFileNotFound;
		}

		// force release of storage first so URL file can be deleted via cDeleteUrlLocalFileOnClose smart class
		pStorage = 0;
	}
	
#ifdef DEBUG
	if (GetEnvironmentVariable(TEXT("MSI_MANUAL_SOURCE_VALIDATION"), 0, 0))
	{
		if (IDYES == MessageBox(0, szPackageFullPath, TEXT("Is this source valid?"), MB_YESNO | MB_ICONQUESTION))
		{
			psRet = psValidSource;
		}
	}
#endif

#ifdef DEBUG
	DEBUGMSG2(TEXT("SOURCEMGMT: Source '%s' is %s"), szPackageFullPath, psRet == psFileNotFound ? TEXT("not found") : psRet == psValidSource ? TEXT("valid") : TEXT("invalid"));
#endif

	return psRet;
}

Bool ConstructNetSourceListEntry(IMsiPath& riPath, const IMsiString*& rpiDriveLetter, const IMsiString*& rpiUNC,
											const IMsiString*& rpiRelativePath)
/*----------------------------------------------------------------------------
	Returns the parts necessary to create a network sourcelist entry. 
	Returns fTrue if the path is an NT path and fFalse otherwise.
--------------------------------------------------------------------------*/
{
	PMsiVolume pVolume = &(riPath.GetVolume());
	MsiString strUNC    = pVolume->UNCServer();
	MsiString strVolume = pVolume->GetPath();
	MsiString strRelativePath;
	MsiString strDriveLetter;

	strRelativePath = riPath.GetPath();
	strRelativePath.Remove(iseFirst, strVolume.CharacterCount());
	strRelativePath.Remove(iseLast, 1); // remove trailing backslash

	if (!strVolume.Compare(iscExact, strUNC)) // if these match then they're both UNCs
		strDriveLetter = strVolume;

	strDriveLetter.ReturnArg(rpiDriveLetter);
	strUNC.ReturnArg(rpiUNC);
	strRelativePath.ReturnArg(rpiRelativePath);

	MsiString strFileSys = MsiString(PMsiVolume(&riPath.GetVolume())->FileSystem());
	Bool fNTPath = fFalse;
	if (strFileSys.Compare(iscExactI, TEXT("NTFS")) ||
		 strFileSys.Compare(iscExactI, TEXT("FAT")) ||
		 strFileSys.Compare(iscExactI, TEXT("FAT32")))
	{
		fNTPath = fTrue;
	}

	return fNTPath;
}

IMsiRecord* SetLastUsedSource(const ICHAR* szProductCode, const ICHAR* szPath, Bool fAddToList, bool fPatch)
/*----------------------------------------------------------------------------*/
{
	bool fOLEInitialized = false;

	HRESULT hRes = OLE32::CoInitialize(0);
	if (SUCCEEDED(hRes))
		fOLEInitialized = true;

	IMsiRecord* piError = 0;
	
	// if in the service call directly into the configuration manager to set the last used source.
	// this avoids impersonation conflicts with the public IMsiServer version of the call
	if (g_scServerContext == scService)
	{
		IMsiConfigurationManager *piServer = CreateConfigurationManager();
		Assert(piServer);
		
		piError = piServer->SetLastUsedSource(szProductCode, szPath, fAddToList ? fTrue : fFalse, fPatch ? fTrue : fFalse, 0, 0, 0, 0, 0, 0);
		piServer->Release();
	}
	else
	{
		IMsiServer* piServer = CreateServer(); //!! like the engine, this will fall back to using a local conman object. Is this OK?
		
		Assert(SUCCEEDED(hRes) || (RPC_E_CHANGED_MODE == hRes));

		piError = piServer->SetLastUsedSource(szProductCode, szPath, fAddToList ? true : false, fPatch);
		piServer->Release();
	}
	
	if (fOLEInitialized)
		OLE32::CoUninitialize();

#ifdef DEBUG
	if (piError)
	{
		DEBUGMSG("piServer->SetLastUsedSource failed ... ");
		DEBUGMSG2(TEXT("1: %s (%d)"), piError->GetString(1)?piError->GetString(1):TEXT(""), (const ICHAR*)(INT_PTR)piError->GetInteger(1));
		DEBUGMSG2(TEXT("2: %s (%d)"), piError->GetString(2)?piError->GetString(2):TEXT(""), (const ICHAR*)(INT_PTR)piError->GetInteger(2));
		DEBUGMSG2(TEXT("3: %s (%d)"), piError->GetString(3)?piError->GetString(3):TEXT(""), (const ICHAR*)(INT_PTR)piError->GetInteger(3));
		DEBUGMSG2(TEXT("4: %s (%d)"), piError->GetString(4)?piError->GetString(4):TEXT(""), (const ICHAR*)(INT_PTR)piError->GetInteger(4));
	}
#endif
	return piError;
}

//____________________________________________________________________________
//
// CResolveSourceUI implementation
//____________________________________________________________________________

CResolveSourceUI::CResolveSourceUI(IMsiServices* piServices, const ICHAR* szUseFeature, UINT iCodepage, LANGID iLangId)
	: CResolveSource(piServices, false), CMsiMessageBox(szUseFeature, 0, 0, 2, IDOK, IDCANCEL, IDBROWSE, iCodepage, iLangId)
	, m_iLangId(iLangId), m_hFont(0), m_uiRequestedDisk(0)
{
}

CResolveSourceUI::~CResolveSourceUI()
{
	MsiDestroyFont(m_hFont);
}

void CResolveSourceUI::PopulateDropDownWithSources()
/*----------------------------------------------------------------------------*/
{
	m_strPath = TEXT("");
	MsiString strPackageName;
	MsiString strSource;
	MsiString strSourceProduct;

	psfEnum psfFlags = (psfEnum)0;
	PMsiRecord pProducts = &CreateRecord(1);
	pProducts->SetString(1, m_szProduct);
	PMsiRecord pError = ProcessSources(*pProducts, m_isptSourcePackageType == istPatch ? fTrue : fFalse,
													*&strSource, *&strPackageName, *&strSourceProduct, m_uiRequestedDisk,
													CResolveSourceUI::AddSourceToList, (INT_PTR)this, m_fOnlyMediaSources, psfFlags); //?? is it ok to ignore all errors here?			//--merced: changed (int) to (INT_PTR)
	SendDlgItemMessage(m_hDlg, m_iListControlId, CB_SETCURSEL, 0, 0);
}

bool CResolveSourceUI::InitSpecial()  // overridden virtual from CMsiMessageBox
/*----------------------------------------------------------------------------*/
{
	// We need to display file paths as they would appear to the user with system tools
	UINT iListCodepage = MsiGetSystemDataCodepage();  // need to display paths correctly
	HFONT hfontList = m_hfontText;
	if (iListCodepage != m_iCodepage) // database codepage different that resource strings
		hfontList = m_hFont = MsiCreateFont(iListCodepage);
	SetControlText(m_iListControlId, hfontList, (const ICHAR*)0);

	PopulateDropDownWithSources();

	// if the user cannot add new sources and the dropdown list is empty, there is no point
	// to creating the dialog at all. We can fail immediately.
	if (!m_fNewSourceAllowed)
	{
		int iItemCount = 0;
		AssertZero(CB_ERR == (iItemCount = (int)SendDlgItemMessage(m_hDlg, m_iListControlId, CB_GETCOUNT, (WPARAM)0, 0)));
		if (iItemCount == 0)
		{
			DEBUGMSG(TEXT("SOURCEMGMT: No valid sources and browsing disabled. Not creating SourceList dialog."));
			WIN::EndDialog(m_hDlg, IDOK);
			return true;		
		}
	}
			
	ICHAR szPromptTemplate[256] = {0}; // prompt for insert disk or enter path (German is 111 chars)
	ICHAR szText[256] = {0};           // error message (German is 95 chars without product name)

	// Load prompt string and caption
	UINT uiPrompt  = IDS_CD_PROMPT;
	UINT uiText    = IDS_CD_TEXT;
	int iIconResId = IDI_CDROM;

	if (!(m_fOnlyMediaSources))
	{
		if(m_fCSOS)
		{
			uiPrompt   = m_fNewSourceAllowed ? IDS_NET_PROMPT_CSOS_BROWSE : IDS_NET_PROMPT_CSOS_NO_BROWSE;
			uiText     = IDS_NET_TEXT_CSOS;
		}
		else
		{
			uiPrompt   = m_fNewSourceAllowed ? IDS_NET_PROMPT_BROWSE : IDS_NET_PROMPT_NO_BROWSE;
			uiText     = IDS_NET_TEXT;
		}
		iIconResId = IDI_NET;
	}

	AssertNonZero(MsiLoadString(g_hInstance, uiPrompt, szPromptTemplate, sizeof(szPromptTemplate)/sizeof(ICHAR), m_iLangId));
	AssertNonZero(MsiLoadString(g_hInstance, uiText,   szText,           sizeof(szText)          /sizeof(ICHAR), m_iLangId));

	SetControlText(IDC_ERRORTEXT, m_hfontText, szText);

	if (m_fOnlyMediaSources)
	{
		
		ShowWindow(GetDlgItem(m_hDlg, IDC_NETICON), SW_HIDE);
		
		// Set prompt text

		CTempBuffer<ICHAR, 1> rgchProductName(256);
		CTempBuffer<ICHAR, 1> rgchPrompt(512);

		AssertNonZero(ENG::GetProductInfo(m_szProduct, INSTALLPROPERTY_PRODUCTNAME, rgchProductName));
		unsigned int cch = 0;
		if (rgchPrompt.GetSize() < (cch = sizeof(szPromptTemplate)/sizeof(ICHAR) + rgchProductName.GetSize()))
			rgchPrompt.SetSize(cch);

		StringCchPrintf((ICHAR*)rgchPrompt, rgchPrompt.GetSize(), szPromptTemplate, (const ICHAR*)rgchProductName);
		SetControlText(IDC_PROMPTTEXT, m_hfontText, rgchPrompt);
	}
	else
	{
		// Set prompt text
		CTempBuffer<ICHAR, 1> rgchPrompt(IStrLen(m_szPackageName)+IStrLen(szPromptTemplate)+1);
		StringCchPrintf((ICHAR *)rgchPrompt, rgchPrompt.GetSize(), szPromptTemplate, m_szPackageName);
		SetControlText(IDC_PROMPTTEXT, m_hfontText, rgchPrompt);
		ShowWindow(GetDlgItem(m_hDlg, IDC_CDICON), SW_HIDE);
	}

	HICON hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(iIconResId));
	Assert(hIcon);
	SendMessage(m_hDlg, WM_SETICON, (WPARAM)ICON_BIG,   (LPARAM) (HICON) hIcon);
	SendMessage(m_hDlg, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM) (HICON) hIcon);
	ShowWindow(GetDlgItem(m_hDlg, m_iListControlId), SW_SHOW); // either drop-down list box or combo box
	if (m_fNewSourceAllowed)
		ShowWindow(GetDlgItem(m_hDlg, IDC_MSGBTN3), SW_SHOW);

	return true;
}

BOOL CResolveSourceUI::HandleCommand(UINT idControl)  // overridden virtual from CMsiMessageBox
/*----------------------------------------------------------------------------*/
{
	Bool fAddToList = fFalse;
	switch (idControl)
	{
	case IDC_MSGBTN1: // OK
		{
		isfEnum isf;
		psEnum ps = psFileNotFound;
		unsigned int uiDisk = 0;
		CTempBuffer<ICHAR, MAX_PATH> rgchSource;
		IMsiRegKey* piSourceListKey = 0;
		const IMsiString* piSource = &CreateString();
		MsiString strDialogBoxSource;
		LONG_PTR lSelection = SendDlgItemMessage(m_hDlg, m_iListControlId, CB_GETCURSEL, 0, 0);				//--merced: changed long to LONG_PTR
		if (CB_ERR == lSelection) // no item is selected -- edit box contains path
		{
			LONG_PTR cchSource = SendDlgItemMessage(m_hDlg, m_iListControlId, WM_GETTEXTLENGTH, 0, 0);		//--merced: changed long to LONG_PTR
			rgchSource.SetSize((int)(INT_PTR)cchSource+1);			//!>merced: 4244. 4311 ptr to int
			AssertNonZero(cchSource == SendDlgItemMessage(m_hDlg, m_iListControlId, WM_GETTEXT, (WPARAM)cchSource+1, (LPARAM)(const ICHAR*)rgchSource));
			fAddToList = fTrue;
			piSource->SetString((const ICHAR*)rgchSource, piSource);

			DWORD dwAttributes = MsiGetFileAttributes(rgchSource);
			if (dwAttributes == 0xFFFFFFFF)
			{
				// failed to get the attributes. Most likely rgch did not exist. 
				isf = isfFullPathWithFile;
			}	
			else if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
				isf = isfFullPath;
			else
				isf = isfFullPathWithFile;
		}
		else // combo box item is selected
		{
			LONG_PTR cchSource = SendDlgItemMessage(m_hDlg, m_iListControlId, CB_GETLBTEXTLEN, (WPARAM)lSelection, 0);			//--merced: changed long to LONG_PTR
			rgchSource.SetSize((int)(INT_PTR)cchSource+1);			//!>merced: 4244. 4311 ptr to int
			AssertNonZero(cchSource == SendDlgItemMessage(m_hDlg, m_iListControlId, CB_GETLBTEXT, (WPARAM)lSelection, (LPARAM)(const ICHAR*)rgchSource));
			INT_PTR iSourceId = SendDlgItemMessage(m_hDlg, m_iListControlId, CB_GETITEMDATA, (WPARAM)lSelection, 0);			//--merced: changed int to INT_PTR
			isf = (isfEnum) (iSourceId >> 16);
			uiDisk = (int)(iSourceId & 0xFFFF);
			Assert(m_pSourceListKey);
			piSourceListKey = m_pSourceListKey;
		}

		strDialogBoxSource = (const ICHAR*)rgchSource;

		// Validate selected source

		Bool fSourceListEmpty;
		psfEnum psfFlags = psfEnum(psfConnectToSources | psfRejectInvalidPolicy);
		SetCursor(LoadCursor(0, MAKEINTRESOURCE(IDC_WAIT)));
		Sleep(10000);	// Give CD a chance to spin up first.
		PMsiRecord pDiscardableError = ProcessGenericSourceList(piSourceListKey, piSource, m_szPackageName, uiDisk, 
                                                                isf, ValidateSource, (INT_PTR)(m_szProduct),	//--merced: changed (int) to (INT_PTR)
																psfFlags, /*fSkipLastUsed=*/false, /*fCheckOnlySpecifiedIndex=*/false, fSourceListEmpty);
		
		SetCursor(LoadCursor(0, MAKEINTRESOURCE(IDC_ARROW)));
		if (pDiscardableError == 0)
		{
			m_strPath = *piSource;
			ps = psValidSource;
		}
		else if (pDiscardableError->GetInteger(1) == imsgSourceResolutionFailed)
			ps = (psEnum)pDiscardableError->GetInteger(2);

		UINT uiErrorString = IDS_INVALID_FILE_MESSAGE;
		switch (ps)
		{
		case psValidSource:
			AssertRecord(SetLastUsedSource(m_szProduct, m_strPath, fAddToList, m_isptSourcePackageType == istPatch));
			piSource = 0;
			WIN::EndDialog(m_hDlg, IDOK);
			return TRUE;
			break;
		case psFileNotFound:
			if (isf == isfFullPath || isf == isfNet)
			{
				if (!strDialogBoxSource.Compare(iscEnd, szDirSep))
					strDialogBoxSource += szDirSep;
				
				strDialogBoxSource += m_szPackageName;
			}

			if (isf == isfFullPathWithFile)
				uiErrorString = IDS_INVALID_FILE_MESSAGE;
			else
				uiErrorString  = IDS_INVALID_PATH_MESSAGE;
			break;
		case psInvalidProduct:
			uiErrorString  = IDS_INVALID_FILE_MESSAGE;
		}

		ICHAR szErrorString[256];
		unsigned int iCodepage = MsiLoadString(g_hInstance, uiErrorString, szErrorString, sizeof(szErrorString)/sizeof(ICHAR), m_iLangId);
		if (!iCodepage)
		{
			AssertSz(0, TEXT("Missing 'invalid path' or 'missing component' error string"));
			StringCchCopy(szErrorString, (sizeof(szErrorString)/sizeof(ICHAR)), 
							TEXT("The selected source is not a valid source for this product or is inaccessible.")); // should never happen
		}

		MsiString strErrorArg = strDialogBoxSource;
		if (strErrorArg.TextSize() > MAX_PATH)
			strErrorArg.Remove(iseLast, strErrorArg.TextSize() - MAX_PATH); //?? correct?
		
		CTempBuffer<ICHAR, 1> rgchExpandedErrorString(MAX_PATH + 256);
		CTempBuffer<ICHAR, 1> rgchProductName(256);
		AssertNonZero(ENG::GetProductInfo(m_szProduct, INSTALLPROPERTY_PRODUCTNAME, rgchProductName));
		if (uiErrorString == IDS_INVALID_PATH_MESSAGE) 
		{
			rgchExpandedErrorString.SetSize(IStrLen(szErrorString)+strErrorArg.TextSize()+
				IStrLen(m_szPackageName)+IStrLen(rgchProductName)+1);
			StringCchPrintf((ICHAR *)rgchExpandedErrorString, 
					rgchExpandedErrorString.GetSize(), szErrorString, 
					(const ICHAR*)strErrorArg, m_szPackageName, 
					(const ICHAR *)rgchProductName);
		}
		else if (uiErrorString == IDS_INVALID_FILE_MESSAGE) 
		{
			rgchExpandedErrorString.SetSize(IStrLen(szErrorString)+strErrorArg.TextSize()+
				IStrLen(m_szPackageName)+2*IStrLen(rgchProductName)+1);
			StringCchPrintf((ICHAR *)rgchExpandedErrorString, 
						rgchExpandedErrorString.GetSize(), szErrorString, 
						(const ICHAR*)strErrorArg, 
						(const ICHAR *)rgchProductName, m_szPackageName, 
						(const ICHAR *)rgchProductName);
		}
		else
		{
			AssertSz(0, TEXT("Unknown Error String in SourceList Dialog"));
		}

		MsiMessageBox(m_hDlg, rgchExpandedErrorString, 0, MB_OK|MB_ICONEXCLAMATION, iCodepage, m_iLangId);
		}
		return TRUE;
	case IDC_MSGBTN2: // Cancel
		EndDialog(m_hDlg, IDCANCEL);
		return TRUE;
	case IDC_MSGBTN3: // Browse
		Browse();
		return TRUE;
	}
	return FALSE;
}

const ICHAR szClassName[] = TEXT("MsiResolveSource");


Bool CResolveSourceUI::ResolveSource(const ICHAR* szProduct, isptEnum isptSourcePackageType, bool fNewSourceAllowed, const ICHAR* szPackageName, const IMsiString*& rpiSource, Bool fSetLastUsedSource, UINT uiRequestedDisk, bool fAllowDisconnectedCSCSource, bool fValidatePackageCode, bool fCSOS)
/*----------------------------------------------------------------------------
	Allows the user to choose a source.
	
	fNewSourceAllowed controls whether the user can enter their own source
	or whether they're restricted to the sources in the source list. 
----------------------------------------------------------------------------*/
{
	m_fNewSourceAllowed           = fNewSourceAllowed;
	m_isptSourcePackageType       = isptSourcePackageType;
	m_szPackageName               = szPackageName;
	m_szProduct                   = szProduct;
	m_fSetLastUsedSource          = fSetLastUsedSource;
	m_fAllowDisconnectedCSCSource = fAllowDisconnectedCSCSource;
	m_fValidatePackageCode        = fValidatePackageCode;
	m_uiRequestedDisk             = uiRequestedDisk;
	m_fCSOS						  = fCSOS;

	if (m_fNewSourceAllowed)
		m_iListControlId = IDC_EDITCOMBO;
	else
		m_iListControlId = IDC_READONLYCOMBO;

	HANDLE	hMutex = CreateDiskPromptMutex();
	int		idDialog = IDD_NETWORK;

	if(m_fCSOS)
	{
		idDialog = IDD_NETWORK_CSOS;
		if (m_iCodepage == 1256 || m_iCodepage == 1255)
			idDialog = MinimumPlatformWindows2000() ? IDD_NETWORKMIRRORED_CSOS : IDD_NETWORKRTL_CSOS; // mirrored template for BiDi on Win2K and greater; reversed template for BiDi
	}
	else
	{
		if (m_iCodepage == 1256 || m_iCodepage == 1255)
			idDialog = MinimumPlatformWindows2000() ? IDD_NETWORKMIRRORED: IDD_NETWORKRTL; // mirrored template for BiDi on Win2K and greater; reversed template for BiDi
	}
	int iRet = Execute(0, idDialog, 0);
	CloseDiskPromptMutex(hMutex);

	Assert(iRet == IDOK || iRet == IDCANCEL);
	if (iRet == IDOK)
	{
		m_strPath.ReturnArg(rpiSource);
		return fTrue;
	}
	else
		return fFalse;
}

psEnum CResolveSourceUI::AddSourceToList(IMsiServices* /*piServices*/, const ICHAR* szDisplay, const ICHAR* /*szPackageFullPath*/,
													  isfEnum isfSourceFormat, int iSourceIndex, INT_PTR iUserData, bool /*fAllowDisconnectedCSCSource*/,
													  bool /*fValidatePackageCode*/,
													  isptEnum /*isptSourcePackageType*/) 		//--merced: changed int to INT_PTR
/*----------------------------------------------------------------------------
	Adds the given package path to our drop-down list box. iUserData contains
	our "this" pointer as this is a static function.
----------------------------------------------------------------------------*/
{
	CResolveSourceUI* This = (CResolveSourceUI*)iUserData;
	Assert(This);
	LONG_PTR lResult = SendDlgItemMessage(This->m_hDlg, This->m_iListControlId, CB_ADDSTRING, 0,				//--merced: changed long to LONG_PTR
												 (LPARAM)szDisplay);

	Assert(lResult != CB_ERR && lResult != CB_ERRSPACE);
	if (lResult != CB_ERR && lResult != CB_ERRSPACE)
	{
		// Store identifying information for this source with the combo-box item
		Assert(!(iSourceIndex & ~0xFFFF));
		int iSourceId = (((int)isfSourceFormat << 16) | (iSourceIndex & 0xFFFF));

		AssertZero(CB_ERR == SendDlgItemMessage(This->m_hDlg, This->m_iListControlId, CB_SETITEMDATA, (WPARAM)lResult, 
															 iSourceId));
	}
	return psContinue;
}

void CResolveSourceUI::Browse()
/*----------------------------------------------------------------------------
	CResolveSourceUI::Browse() - display a standard Windows FileOpen dialog

	A FileOpen dialog is displayed. The dialog filters on the appropriate
	extension based on m_ist. Upon successfully validating a source, the path
	to the source is placed in the edit field of the source selection dialog.
----------------------------------------------------------------------------*/
{
   OPENFILENAME ofn;

	CTempBuffer<ICHAR, 1> rgchPath(MAX_PATH + 1);
	CTempBuffer<ICHAR, 1> rgchFilter(256);
	CTempBuffer<ICHAR, 1> rgchInstallationPackage(256);
	const ICHAR* szExtension;

	int iBrowseTypeStringId;
	switch (m_isptSourcePackageType)
	{
	case istTransform:      
		szExtension         = szTransformExtension;
		iBrowseTypeStringId = IDS_TRANSFORM_PACKAGE;
		break;
	case istPatch:
		szExtension         = szPatchExtension;
		iBrowseTypeStringId = IDS_PATCH_PACKAGE;
		break;
	default:				
		AssertSz(0, TEXT("Invalid browse type")); // fall through
	case istInstallPackage: 
		szExtension         = szDatabaseExtension;
		iBrowseTypeStringId = IDS_INSTALLATION_PACKAGE; 
		int iSize = IStrLen(m_szPackageName)+1;
		if (iSize > rgchPath.GetSize())
			rgchPath.Resize(iSize);
		StringCchCopy(rgchPath, rgchPath.GetSize(), m_szPackageName);
		break;
	}

	if (!MsiLoadString(g_hInstance, iBrowseTypeStringId, rgchInstallationPackage, rgchInstallationPackage.GetSize(), m_iLangId))
	{
		AssertSz(0, TEXT("Missing browse type string"));
		StringCchCopy(rgchInstallationPackage, rgchInstallationPackage.GetSize(), TEXT("Installation Package")); // should never happen
	}

	CApiConvertString szWideExtension(szExtension);
	StringCchPrintf(rgchFilter, rgchFilter.GetSize(), 
				TEXT("%s (*.%s)%c*.%s%c"), static_cast<const ICHAR*>(rgchInstallationPackage), 
				static_cast<const ICHAR*>(szWideExtension), 0, static_cast<const ICHAR*>(szWideExtension), 0);
	
	memset((void*)&ofn, 0, sizeof(ofn));
	ofn.lStructSize       = (MinimumPlatformWindows2000())
                                        ? sizeof(OPENFILENAME)
                                        : (OPENFILENAME_SIZE_VERSION_400);
	ofn.hwndOwner         = m_hDlg;
	ofn.hInstance         = g_hInstance;
	ofn.lpstrFilter       = rgchFilter;
	ofn.lpstrCustomFilter = NULL;
	ofn.nFilterIndex      = 1;
	ofn.lpstrFile         = rgchPath;
	ofn.nMaxFile          = _MAX_PATH;
	ofn.lpstrFileTitle    = NULL;
	ofn.Flags             = OFN_EXPLORER      | // ensure new-style interface
									OFN_FILEMUSTEXIST | // allow only valid file names
									OFN_PATHMUSTEXIST | // allow only valid paths
									OFN_HIDEREADONLY  | // hide the read-only check box
									0
									;

	if (COMDLG32::GetOpenFileName(&ofn))
	{
		SendDlgItemMessage(m_hDlg, m_iListControlId, CB_SETCURSEL, -1, 0); // remove current selection
		SendDlgItemMessage(m_hDlg, m_iListControlId, WM_SETTEXT, 0,	(LPARAM)(LPCTSTR)rgchPath);
	}
#ifdef DEBUG
	else
	{ 
		DWORD dwErr = COMDLG32::CommDlgExtendedError();
		if (dwErr != 0) // 0 == user cancelled
		{
			ICHAR szBuf[100];
			StringCchPrintf(szBuf, (sizeof(szBuf)/sizeof(ICHAR)), TEXT("Browse dialog error: %X"), dwErr);
			AssertSz(0, szBuf);
		}
	}
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\vertrust.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       vertrust.cpp
//
//--------------------------------------------------------------------------

#include "precomp.h"

#include "vertrust.h"
#include "_engine.h"
#include "_msiutil.h"


extern CMsiCustomAction* g_pCustomActionContext;

// provides conversion from privileges to bitfield locations
const ICHAR* rgszPrivilegeMap[] =
{
	SE_CREATE_TOKEN_NAME,           // 0x00000001
	SE_ASSIGNPRIMARYTOKEN_NAME,     // 0x00000002
	SE_LOCK_MEMORY_NAME,            // 0x00000004
	SE_INCREASE_QUOTA_NAME,         // 0x00000008
	SE_UNSOLICITED_INPUT_NAME,      // 0x00000010
	SE_MACHINE_ACCOUNT_NAME,        // 0x00000020
	SE_TCB_NAME,                    // 0x00000040
	SE_SECURITY_NAME,               // 0x00000080
	SE_TAKE_OWNERSHIP_NAME,         // 0x00000100
	SE_LOAD_DRIVER_NAME,            // 0x00000200
	SE_SYSTEM_PROFILE_NAME,         // 0x00000400
	SE_SYSTEMTIME_NAME,             // 0x00000800
	SE_PROF_SINGLE_PROCESS_NAME,    // 0x00001000
	SE_INC_BASE_PRIORITY_NAME,      // 0x00002000
	SE_CREATE_PAGEFILE_NAME,        // 0x00004000
	SE_CREATE_PERMANENT_NAME,       // 0x00008000
	SE_BACKUP_NAME,                 // 0x00010000
	SE_RESTORE_NAME,                // 0x00020000
	SE_SHUTDOWN_NAME,               // 0x00040000
	SE_DEBUG_NAME,                  // 0x00080000
	SE_AUDIT_NAME,                  // 0x00100000
	SE_SYSTEM_ENVIRONMENT_NAME,     // 0x00200000
	SE_CHANGE_NOTIFY_NAME,          // 0x00400000
	SE_REMOTE_SHUTDOWN_NAME,        // 0x00800000
	SE_UNDOCK_NAME,                 // 0x01000000
	SE_SYNC_AGENT_NAME,             // 0x02000000
	SE_ENABLE_DELEGATION_NAME,      // 0x04000000
	SE_MANAGE_VOLUME_NAME,          // 0x08000000
	SE_IMPERSONATE_NAME	            // 0x10000000
};
const int cszPrivileges = sizeof(rgszPrivilegeMap)/sizeof(ICHAR*);

// cached LUID values for the privileges. Any not understood by the machine
// for some reason are simply marked as not valid
struct {
	bool fValid;
	LUID luidPriv;
} rgPrivilegeLUIDs[cszPrivileges];

// synchronization for LUID cache, as well as flag to determine if
// the cache has already been initialized.
static int iLUIDLock = 0;
static bool fLUIDInitialized = false;

///////////////////////////////////////////////////////////////////////
// looks up and caches LUIDs for all interesting privileges. Thread 
// safe. Returns true on success, false on failure.
bool PreparePrivilegeLUIDs()
{
	// synchronize write access to the global cache.
	while (TestAndSet(&iLUIDLock))
	{
		Sleep(10);		
	}

	// only initialized if not done yet
	if (!fLUIDInitialized)
	{
		for (int iPriv = 0; iPriv < cszPrivileges; iPriv++)
		{
			rgPrivilegeLUIDs[iPriv].fValid = false;

			// if any priv is not understood, just don't mark that entry as valid.
			if (LookupPrivilegeValue(NULL, rgszPrivilegeMap[iPriv], &rgPrivilegeLUIDs[iPriv].luidPriv))
				rgPrivilegeLUIDs[iPriv].fValid = true;
		}
		fLUIDInitialized = true;
	}

	// release synchronization lock
	iLUIDLock = 0;
	return true;
}

///////////////////////////////////////////////////////////////////////
// Given a token, attempts to enable all token privileges and
// returns a bitmask indicating which privileges changed state. 
// Returns true on success, false on failure. hToken must
// have TOKEN_ADJUST_PRIVILEGES and TOKEN_QUERY access.
bool EnableAndMapDisabledPrivileges(HANDLE hToken, DWORD &dwPrivileges)
{
	// verify that we haven't added so many privileges that the map is too small
	Assert(cszPrivileges <= 32);

	if (!PreparePrivilegeLUIDs())
		return false;

	// allocate a byte buffer large enough to handle the variable-sized TOKEN_PRIVILEGES structure.
	unsigned char rgchTokenPrivBuffer[sizeof(TOKEN_PRIVILEGES)+(sizeof(LUID_AND_ATTRIBUTES)*(cszPrivileges-1))];
	unsigned char rgchPrevTokenPrivBuffer[sizeof(TOKEN_PRIVILEGES)+(sizeof(LUID_AND_ATTRIBUTES)*(cszPrivileges-1))];

	// loop through the array of privileges and for each valid priv add it to the LUID_AND_ATTRIBUTES structure
	// inside the TOKEN_PRIVILEGES structure at the next array slot. Set the priv to be enabled on API call.
	PTOKEN_PRIVILEGES pTokenPrivs = reinterpret_cast<PTOKEN_PRIVILEGES>(rgchTokenPrivBuffer);
	int cTokenPrivs = 0;
	for (int iPriv =0; iPriv < cszPrivileges; iPriv++)
	{
		if (rgPrivilegeLUIDs[iPriv].fValid)
		{
			pTokenPrivs->Privileges[cTokenPrivs].Luid = rgPrivilegeLUIDs[iPriv].luidPriv;
			pTokenPrivs->Privileges[cTokenPrivs].Attributes = SE_PRIVILEGE_ENABLED;
			cTokenPrivs++;
		}
	}
	pTokenPrivs->PrivilegeCount = cTokenPrivs;

	PTOKEN_PRIVILEGES pPreviousTokenPrivs = reinterpret_cast<PTOKEN_PRIVILEGES>(rgchPrevTokenPrivBuffer);
	DWORD dwRequiredSize = 0;

	// AdjustTokenPrivileges won't fail if it can't set one or more privileges, it just doesn't mark those
	// piviliges as differnt in pPreviousTokenPrivs
	if (!AdjustTokenPrivileges(hToken, FALSE, pTokenPrivs, sizeof(rgchPrevTokenPrivBuffer), pPreviousTokenPrivs, &dwRequiredSize))
		return false;

	// loop through the previous state of all privileges, determining which ones were modified from disabled to enabled
	for (int iPrevPriv=0; iPrevPriv < pPreviousTokenPrivs->PrivilegeCount; iPrevPriv++)
	{
		// find the associated LUID in our array 
		for (int iPriv =0; iPriv < cszPrivileges; iPriv++)
		{
			if ((rgPrivilegeLUIDs[iPriv].luidPriv.LowPart == pPreviousTokenPrivs->Privileges[iPrevPriv].Luid.LowPart) &&
				(rgPrivilegeLUIDs[iPriv].luidPriv.HighPart == pPreviousTokenPrivs->Privileges[iPrevPriv].Luid.HighPart))
			{
				// set the bit in the mask
				dwPrivileges |= (1 << iPriv);
				break;
			}
		}
	}

	return true;
}


///////////////////////////////////////////////////////////////////////
// Given a token and bitfield, disables all privileges whose bit is set
// in the bitfield. Returns true on success, false on failure.
bool DisablePrivilegesFromMap(HANDLE hToken, DWORD dwPrivileges)
{
	// verify that we haven't added so many privileges that the map is too small
	Assert(cszPrivileges <= 32);

	// short circuit if dwPrivileges is 0. (nothing to do)
	if (dwPrivileges == 0)
		return true;

	// initialize LUID array for this process
	if (!PreparePrivilegeLUIDs())
		return false;

	// allocate a byte buffer large enough to handle the variable-sized TOKEN_PRIVILEGES structure.
	unsigned char rgchTokenPrivBuffer[sizeof(TOKEN_PRIVILEGES)+(sizeof(LUID_AND_ATTRIBUTES)*(cszPrivileges-1))];

	// loop through the array of privileges and for each valid priv add it to the LUID_AND_ATTRIBUTES structure
	// inside the TOKEN_PRIVILEGES structure at the next array slot. Set the priv to be enabled on API call.
	PTOKEN_PRIVILEGES pTokenPrivs = reinterpret_cast<PTOKEN_PRIVILEGES>(rgchTokenPrivBuffer);
	int cTokenPrivs = 0;
	for (int iPriv =0; iPriv < cszPrivileges; iPriv++)
	{
		// check each privilege in the bitmap, adding itto the next luid/attributes slot in the
		// adjustment argument
		if (dwPrivileges & (1 << iPriv))
		{
			pTokenPrivs->Privileges[cTokenPrivs].Luid = rgPrivilegeLUIDs[iPriv].luidPriv;
			pTokenPrivs->Privileges[cTokenPrivs].Attributes = 0;
			cTokenPrivs++;
		}
	}

	// cTokenPrivs should never be 0 because of the short circuit above.
	Assert(cTokenPrivs);
	pTokenPrivs->PrivilegeCount = cTokenPrivs;

	// there's nothing to be done if this fails.
	return (AdjustTokenPrivileges(hToken, FALSE, pTokenPrivs, 0, NULL, NULL) ? true : false);
}

// if there is an impersonation or elevation failure, the process must exit immediately
// to avoid security problems. However we can only exit if in the service or CA server, 
// where impersonation is enabled and MSI owns the process.
static void ExitProcessIfNotClient()
{
	if ((g_scServerContext == scService) || (g_scServerContext == scCustomActionServer))
		ExitProcess(-1);
}

//____________________________________________________________________________
//
// Functions for manipulating and verifying our user context (impersonating, etc)
//____________________________________________________________________________

int g_fImpersonationLock = 0;
DWORD g_dwImpersonationSlot = INVALID_TLS_SLOT;
typedef enum ImpersonationType
{
	impTypeUndefined     = 0, // 000
	impTypeCOM           = 1, // 001
	impTypeSession       = 2, // 010
	impTypeCustomAction  = 3, // 011
	impTypeForbidden     = 4, // 100
} ImpersonationType;

#define IMPERSONATE_COUNT_MASK 0x1FFFFFFF
#define IMPERSONATE_TYPE_MASK  0xE0000000
#define IMPERSONATE_TYPE(x) (static_cast<ImpersonationType>(((x) & IMPERSONATE_TYPE_MASK) >> 29))
#define IMPERSONATE_TYPE_TO_DWORD(x) ((x) << 29)

// ImpersonateCore handles the actual impersonation duties for both Session and COM impersonation.
// returns true if impersonation was successful, and fActuallyImpersonated is set to true if an
// actual impersonation was done to the point that a StopImpersonating call is expected. You can not 
// impersonate and still be successful if you're running as localsystem in a client engine with no 
// thread token. Note that if we're already impersonated, fActuallyImpersonated will still be true
// because a matching StopImpersonating call is expected.
bool ImpersonateCore(ImpersonationType impDesiredType, int* cRetEntryCount, bool* fActuallyImpersonated)
{
	AssertSz(((g_scServerContext == scService) || RunningAsLocalSystem()), "ImpersonateCore caller did not check that we are in the service!");

	if (fActuallyImpersonated)
		*fActuallyImpersonated = false;
		
	// must block all other impersonations while we are potentially accessing the 
	// global TLS slot number
	while (TestAndSet(&g_fImpersonationLock))
	{
		Sleep(10);		
	}

	if (g_dwImpersonationSlot == INVALID_TLS_SLOT)
	{
		// TLS Alloc
		g_dwImpersonationSlot = TlsAlloc();
		if (g_dwImpersonationSlot == INVALID_TLS_SLOT)
		{
			AssertSz(0, "Unable to allocate TLS slot in service!");
			// can unblock other threads
			g_fImpersonationLock = 0;
			ExitProcessIfNotClient();
			return false;
		}
	}
	DWORD dwImpersonationSlot = g_dwImpersonationSlot;

	// can unblock other threads
	g_fImpersonationLock = 0;
	
	// determine current impersonation count and type
	DWORD dwValue = PtrToUlong(::TlsGetValue(dwImpersonationSlot));
	int cEntryCount = dwValue & IMPERSONATE_COUNT_MASK;

	// if the entry count is our max impersonation count, assert
	if (cEntryCount == IMPERSONATE_COUNT_MASK)
	{
		AssertSz(0, "Security Warning: Impersonate count is over 1 billion. Are you in an infinite recursion?");
	}

	// if impersonation is forbidden on this thread, don't do anything
	if (IMPERSONATE_TYPE(dwValue) == impTypeForbidden)
	{
		return true;
	}

#ifdef DEBUG
/*	// if the current impersonation count is 0, there must NOT be a thread token, 
	// otherwise there MUST be a thread token. Don't check this in ship builds
	// because the token will be explicitly set anyway.
	HANDLE hToken;
	bool fHaveThreadToken = false;
	if (WIN::OpenThreadToken(WIN::GetCurrentThread(), TOKEN_QUERY , TRUE, &hToken))
	{
		fHaveThreadToken = true;
		::CloseHandle(hToken);
	}
	else
	{
		if (ERROR_NO_TOKEN == GetLastError())
			fHaveThreadToken = false;
		else
		{
			AssertSz(0, "Error retrieving thread token!");
			return false;
		}
	}

	if ((cEntryCount ? true : false) != fHaveThreadToken)
	{
		if (cEntryCount)
			AssertSz(0, "Security Warning: Impersonate count is non-zero but there is no thread token.");
		else
		{
			AssertSz(0, "Security Warning: Impersonate count is zero but there is a thread token.");
		}
	}*/

#endif
	
	// if running in the custom action server, Session impersonation becomes CA impersonation 
	if (g_scServerContext == scCustomActionServer && impDesiredType==impTypeSession)
		impDesiredType = impTypeCustomAction;
	
	// validate the requested type against the history of the thread. Thread's cannot change
	// types of impersonation except at MSI entry points. Some requests for impersonation are
	// silently changed to the appropriate type, but most assert in debug builds.
	DWORD dwNewValue = dwValue;
	switch (IMPERSONATE_TYPE(dwValue))
	{
	case impTypeUndefined:
		// thread has never impersonated
		dwNewValue = IMPERSONATE_TYPE_TO_DWORD(impDesiredType);
		cEntryCount = 0;
		break;
	case impTypeSession:
		if (impDesiredType != impTypeSession)
		{
			AssertSz(0, "Security Warning: You are mixing COM impersonation and Session impersonation on the same thread.");
		}
		break;
	case impTypeCOM:
		// because so much of our code relies on global CImpersonate calls, the workaround until we can isolate
		// state on a per-session basis is to look at the thread's impersonation type and if it is COM, switch
		// over to COM impersonation. Note that this is a one-way change, you can't switch from COM to Session
		// within a CCoImpersonate call, because that would just make things worse. 
		if (impDesiredType == impTypeCustomAction)
		{
			AssertSz(0, "Security Warning: You are mixing COM impersonation and CA impersonation on the same thread.");
		}
		impDesiredType = impTypeCOM;
		break;
	case impTypeCustomAction:
		// threads in the custom action server must always use CA impersonation. 
		impDesiredType = impTypeCustomAction;
		break;
	case impTypeForbidden:
		AssertSz(0, "Internal error in thread impersonation. Impersonation is Forbidden but wasn't caught.");
		break;
	default:
		AssertSz(0, "Internal error in thread impersonation. Unknown impersonation type.");
		break;
	}

	// set the TLS value before setting the token, so if this fails we are still in a known state
	dwNewValue = (dwNewValue & IMPERSONATE_TYPE_MASK) | ((cEntryCount+1) & IMPERSONATE_COUNT_MASK);
	if (!::TlsSetValue(dwImpersonationSlot, reinterpret_cast<void *>((INT_PTR)dwNewValue)))
	{
		AssertSz(0, "TlsSetValue failed.");
		ExitProcessIfNotClient();
		return false;
	}

	// begin the impersonation
	switch (impDesiredType)
	{
	case impTypeSession:
	{
		// check the user token
		HANDLE hToken = GetUserToken();
		if (!hToken)
		{
			// its OK if there is no user token when we're called as LocalSystem and not in the service
			// (such as AD doing a per-machine advertise). But if we're in the service with no token,
			// this indicates a serious error.
			if (g_scServerContext == scService)
			{
				AssertSz(0, "Security Warning: Performing Session impersonation in the service with no user token!");
				::TlsSetValue(dwImpersonationSlot, reinterpret_cast<void *>((INT_PTR)dwValue));
				ExitProcessIfNotClient();
				return false;
			}
		}
		else if (!WIN::SetThreadToken(NULL, hToken))
		{
			AssertSz(0, "Set impersonation token failed");
			::TlsSetValue(dwImpersonationSlot, reinterpret_cast<void *>((INT_PTR)dwValue));
			ExitProcessIfNotClient();
			return false;
		}
		else if (fActuallyImpersonated)
			*fActuallyImpersonated = true;
		break;
	}
	case impTypeCustomAction:
	{
		AssertSz(g_scServerContext == scCustomActionServer, "Attempting CA impersonation from outside the custom action server.");
		HANDLE hToken = g_pCustomActionContext->GetImpersonationToken();

		// its not OK for there to be no impersonation token, unless we're an impersonated CA server that 
		// happens to be running as LocalSystem because the client is a LocalSystem process (such as AD)
		if ((hToken == INVALID_HANDLE_VALUE) || (hToken == 0))
		{
			#ifdef _WIN64
			if (g_pCustomActionContext->GetServerContext() != icac64Impersonated)
			#else
			if (g_pCustomActionContext->GetServerContext() != icac32Impersonated)
			#endif	
			{
				AssertSz(0, "Attempting to impersonate in the CA server with no user token!");
				ExitProcessIfNotClient();
			}
			::TlsSetValue(dwImpersonationSlot, reinterpret_cast<void *>((INT_PTR)dwValue));
			return false;
		}

		if (!WIN::SetThreadToken(NULL, hToken))
		{
			AssertSz(0, "Set impersonation token failed");
			::TlsSetValue(dwImpersonationSlot, reinterpret_cast<void *>((INT_PTR)dwValue));
			ExitProcessIfNotClient();
			return false;
		}
		else if (fActuallyImpersonated)
			*fActuallyImpersonated = true;
		break;
	}
	case impTypeCOM:
	{
		if (S_OK != OLE32::CoImpersonateClient())
		{
			AssertSz(0, "CoImpersonateClient failed!");
			::TlsSetValue(dwImpersonationSlot, reinterpret_cast<void *>((INT_PTR)dwValue));
			ExitProcessIfNotClient();
			return false;
		}
		if (fActuallyImpersonated)
			*fActuallyImpersonated = true;
		break;
	}
	default:
		AssertSz(0, "Unknown impersonation type in ImpersonateCore.");
		::TlsSetValue(dwImpersonationSlot, reinterpret_cast<void *>((INT_PTR)dwValue));
		ExitProcessIfNotClient();
		return false;
	}
	
	if (cRetEntryCount)
		*cRetEntryCount = cEntryCount;
	return true;
}

bool StopImpersonateCore(ImpersonationType impDesiredType, int* cEntryCount)
{
	AssertSz(((g_scServerContext == scService) || RunningAsLocalSystem()), "StopImpersonateCore caller did not check that we are in the service!");

	// must block all other impersonations while we are potentially accessing the 
	// global TLS slot number
	while (TestAndSet(&g_fImpersonationLock))
	{
		Sleep(10);		
	}
	DWORD dwImpersonationSlot = g_dwImpersonationSlot;

	// can unblock other threads
	g_fImpersonationLock = 0;

	if (dwImpersonationSlot == INVALID_TLS_SLOT)
	{
		// obviously not impersonating
		AssertSz(0, "Security Warning: Attempting to stop Impersonating without StartImpersonating call.");
		return true;
	}

	// determine current impersonation count and type
	DWORD dwValue = PtrToUlong(::TlsGetValue(g_dwImpersonationSlot));
	int cCount = dwValue & IMPERSONATE_COUNT_MASK;

	// if impersonation is forbidden on this thread, so is un-impersonating
	if (IMPERSONATE_TYPE(dwValue) == impTypeForbidden)
	{
		return true;
	}

	if (cEntryCount && (*cEntryCount != cCount-1))
	{
		AssertSz(0, "Security Warning: Impersonation count leaving block differs from that when block was entered. Possible mismatched start/stop calls inside block.");
	}

	if (0 == cCount)
	{
		AssertSz(0, "Security Warning: Impersonation count attempting to drop below 0. Possible mismatched start/stop calls inside block.");
	}

	// set the TLS value before setting the token, so if this fails we are still in a known state
	DWORD dwNewValue = (dwValue & IMPERSONATE_TYPE_MASK) | ((cCount-1) & IMPERSONATE_COUNT_MASK);
	if (!::TlsSetValue(dwImpersonationSlot, reinterpret_cast<void *>((INT_PTR)dwNewValue)))
	{
		AssertSz(0, "TlsSetValue failed.");
		ExitProcessIfNotClient();
		return false;
	}

	// stop impersonating if this is the last impersonation count on the thread.
	if (1 == cCount)
	{
		if (impDesiredType == impTypeCOM)
		{
			if (S_OK != OLE32::CoRevertToSelf())
			{
				// CoRevertToSelf failed. Set the TLS slot back to a known value
				AssertSz(0, "CoRevertToSelf failed.");
				::TlsSetValue(dwImpersonationSlot, reinterpret_cast<void *>((INT_PTR)dwValue));
				ExitProcessIfNotClient();
				return false;
			}
		}
		else
		{
			if (!WIN::SetThreadToken(NULL, 0))
			{
				// failed - set TLS back to known value
				AssertSz(0, "Clear impersonation token failed");
				::TlsSetValue(dwImpersonationSlot, reinterpret_cast<void *>((INT_PTR)dwValue));
				ExitProcessIfNotClient();
				return false;
			}
		}
	}
	return true;
}

int ImpersonateCount()
{
	// must block all other impersonations while we are potentially accessing the 
	// TLS slot number
	while (TestAndSet(&g_fImpersonationLock))
	{
		Sleep(10);		
	}

	int cCount = 0;
	// if no slot has been assigned, just return imp count of 0
	if (g_dwImpersonationSlot != INVALID_TLS_SLOT)
	{
		// determine current impersonation count
		cCount = PtrToUlong(::TlsGetValue(g_dwImpersonationSlot)) & IMPERSONATE_COUNT_MASK;
	}
	
	// unblock waiting threads
	g_fImpersonationLock = 0;	
	return cCount;	
}

// several functions involving user identity (eg GetUserToken) perform some DEBUG safety
// checks based on what type of impersonation is active for the thread. The following two calls
// will return true if the specified type of impersonation is safe. The thread does not
// need to be actively impersonating at the time of this check.

// BEWARE: In SHIP builds these calls will always return true. They are intended for
//   debugging assistance only.

// NOTE - IsThreadSafeForSessionImpersonation() is now used in ship builds as well

bool IsThreadSafeForCOMImpersonation() 
{
	bool fResult = true;
#ifdef DEBUG
	// if not in the service, we're safe
	if ((g_scServerContext != scService) && !RunningAsLocalSystem())
		return true;

	// must block all other impersonations while we are potentially accessing the 
	// TLS slot number
	while (TestAndSet(&g_fImpersonationLock))
	{
		Sleep(10);		
	}

	// if no slot has been assigned, just return imp count of 0
	if (g_dwImpersonationSlot != INVALID_TLS_SLOT)
	{
		// determine current impersonation count
		fResult = (IMPERSONATE_TYPE(PtrToUlong(::TlsGetValue(g_dwImpersonationSlot))) != impTypeSession);
	}
	
	// unblock waiting threads
	g_fImpersonationLock = 0;	
#endif
	return fResult;
}

bool IsThreadSafeForSessionImpersonation() 
{
	bool fResult = true;
	// if not in the service, we're safe
	if ((g_scServerContext != scService) && !RunningAsLocalSystem())
		return true;

	// must block all other impersonations while we are potentially accessing the 
	// TLS slot number
	while (TestAndSet(&g_fImpersonationLock))
	{
		Sleep(10);		
	}

	// if no slot has been assigned, just return imp count of 0
	if (g_dwImpersonationSlot != INVALID_TLS_SLOT)
	{
		// determine current impersonation count
		fResult = (IMPERSONATE_TYPE(PtrToUlong(::TlsGetValue(g_dwImpersonationSlot))) != impTypeCOM);
	}
	
	// unblock waiting threads
	g_fImpersonationLock = 0;	
	return fResult;
}


// Impersonation is used when we are running an install but need to act on behalf of a user. 
// Impersonation is valid for any thread after an install begins, as it uses a stored thread
// token to perform the impersonation. Mixing this type of impersonation with COM CoImpersonate
// on the same thread is very bad because you could potentially cross user boundaries. If the 
// user making the service call is not the same user that is running the active install session.
// Impersonation calls can also be nested arbitrarily with other Impersonation calls and/or 
// CElevate calls. We must also ensure that we don't end up in a state that we aren't expecting
// (such as negative impersonation counts).

// To that end, we use the CImpersonate class to ensure that we don't mess things up. 
// The CImpersonate class increments the impersonation count and ensures the thread is impersonated. 
// It resets to the previous state when it goes out of scope.

// BEWARE: This is a function declaration: CImpersonate impersonate(); <--- DON'T DO THIS
//         This is a variable declaration: CImpersonate impersonate;


CImpersonate::CImpersonate(bool fImpersonate) : m_fImpersonate(false), m_cEntryCount(0)
{
	if ((g_scServerContext != scService) && !RunningAsLocalSystem())
		m_fImpersonate = false;
	else
		m_fImpersonate = fImpersonate;
		
	if (!m_fImpersonate)
		return;

	// if impersonation doesn't actually happen, set m_fImpersonate to false so we don't try to stop
	// impersonating in the destructor
	ImpersonateCore(g_scServerContext == scCustomActionServer ? impTypeCustomAction : impTypeSession, &m_cEntryCount, &m_fImpersonate);
}

CImpersonate::~CImpersonate()
{
	// if the constructor didn't impersonate don't do anything
	if (!m_fImpersonate)
		return;

	// nothing we can do in failure 
	StopImpersonateCore(g_scServerContext == scCustomActionServer ? impTypeCustomAction : impTypeSession, &m_cEntryCount);
}


// CoImpersonation is used when we may or may not be running an install but need to 
// act on behalf of a user. The difference between CCoImpersonate and CImpersonate is that
// CCoImpersonate is only valid for threads that are the result of COM calls and impersonate
// using the user context of the client, not the user running the install. Mixing this type
// of impersonation with the regular type of impersonation on the same thread is very bad
// because you could potentially cross user boundaries if the COM client is not the same
// user that is running the install.

// To that end, we use the CCoImpersonate class to ensure that we don't mess up. The CCoImpersonate class 
// increments the impersonation count and ensures the thread is impersonated. It resets to the 
// previous state when it goes out of scope.

// BEWARE: This is a function declaration: CCoImpersonate impersonate(); <--- DON'T DO THIS
//         This is a variable declaration: CCoImpersonate impersonate;

CCoImpersonate::CCoImpersonate(bool fImpersonate) : m_fImpersonate(false), m_cEntryCount(0)
{
	if ((g_scServerContext != scService) && !RunningAsLocalSystem())
		m_fImpersonate = false;
	else
		m_fImpersonate = fImpersonate;
		
	if (!m_fImpersonate)
		return;

	// if impersonation doen't actually happen, set m_fImpersonate to false so we don't try to stop
	// impersonating in the destructor
	ImpersonateCore(impTypeCOM, &m_cEntryCount, &m_fImpersonate);
}

CCoImpersonate::~CCoImpersonate()
{
	// if the constructor didn't impersonate don't do anything
	if (!m_fImpersonate)
		return;
	
	StopImpersonateCore(impTypeCOM, &m_cEntryCount);
}

// Elevation is used when we're running an impersonated install or responding to a COM
// call but need to access our private (ACL'd) reg keys, directories, and files. We need to
// elevate for the shortest time necessary and we need to be sure that whenever we elevate
// don't forget to unelevate. Forgetting is a *bad thing* as we'd run part of the install
// with higher priviledges then we were supposed to. When we stop elevating, we must be 
// careful to re-impersonate with the same type of token that we were using on entry,
// or we could end up mixing up COM and Session impersonation.

// To that end, we use the CElevate class to ensure that we don't mess up and forget to 
// resume impersonation. The CElevate class temporarily resets the current impersonate count to 0 and
// resets it when the object goes out of scope.

// BEWARE: This is a function declaration: CElevate elevate(); <--- DON'T DO THIS
//         This is a variable declaration: CElevate elevate;

CElevate::CElevate(bool fElevate) : m_fElevate(false), m_cEntryCount(0)
{
	if ((g_scServerContext != scService) && !RunningAsLocalSystem())
		m_fElevate = false;
	else
		m_fElevate = fElevate;
		
	if (!m_fElevate)
		return;

	// must block all other impersonations while we are potentially accessing the 
	// global TLS slot number
	while (TestAndSet(&g_fImpersonationLock))
	{
		Sleep(10);		
	}

	if (g_dwImpersonationSlot == INVALID_TLS_SLOT)
	{
		// TLS Alloc
		g_dwImpersonationSlot = TlsAlloc();
		if (g_dwImpersonationSlot == INVALID_TLS_SLOT)
		{
			// set m_fElevate to false so we won't try to stop elevating in the destructor
			m_fElevate = false;
			AssertSz(0, "Unable to allocate TLS slot in service!");
			
			// can unblock other threads
			g_fImpersonationLock = 0;
			ExitProcessIfNotClient();
			return;
		}
	}
	DWORD dwImpersonationSlot = g_dwImpersonationSlot;

	// can unblock other threads
	g_fImpersonationLock = 0;
	
	// determine current impersonation count and type
	DWORD dwValue = PtrToUlong(::TlsGetValue(dwImpersonationSlot));
	m_cEntryCount = dwValue & IMPERSONATE_COUNT_MASK;

	// if impersonation is forbidden on this thread, so is elevation
	if (IMPERSONATE_TYPE(dwValue) == impTypeForbidden)
	{
		m_fElevate = false;
		return;
	}

	bool fHaveThreadToken = true;
#ifdef DEBUG
/*	// if the current impersonation count is 0, there must NOT be a thread token, 
	// otherwise there MUST be a thread token. For performance, only
	// actually check this in DEBUG builds. In ship builds just 
	// explicitly set us to the desired state.
	HANDLE hToken;
	if (WIN::OpenThreadToken(WIN::GetCurrentThread(), TOKEN_QUERY , TRUE, &hToken))
	{
		fHaveThreadToken = true;
		::CloseHandle(hToken);
	}
	else
	{
		if (ERROR_NO_TOKEN == GetLastError())
			fHaveThreadToken = false;
		else
			AssertSz(0, "Error retrieving thread token!");
	}

	if ((m_cEntryCount ? true : false) != fHaveThreadToken)
	{
		if (m_cEntryCount)
			AssertSz(0, "Security Warning: Impersonate count is non-zero but there is no thread token.");
		else
			AssertSz(0, "Security Warning: Impersonate count is zero but there is a thread token.");
	}*/
#endif
	
	// clear the impersonation count	
	if (!::TlsSetValue(dwImpersonationSlot, reinterpret_cast<void *>((INT_PTR)(dwValue & IMPERSONATE_TYPE_MASK))))
	{
		// set m_fElevate to false so we won't try to stop elevating in the destructor
		AssertSz(0, "TlsSetValue failed.");
		m_fElevate = false;
		ExitProcessIfNotClient();
		return;
	}

	// begin the elevation if there is a thread token
	if (fHaveThreadToken)
	{
		if (!WIN::SetThreadToken(NULL, 0))
		{
			// set m_fElevate to false so we won't try to stop elevating in the destructor
			m_fElevate = false;

			// return the TLS value to a known state
			::TlsSetValue(dwImpersonationSlot, reinterpret_cast<void *>((INT_PTR)dwValue));
			AssertSz(0, "Set impersonation token failed");
			ExitProcessIfNotClient();
			return;
		}
	}
}

CElevate::~CElevate()
{
	// if the constructor didn't impersonate don't do anything
	if (!m_fElevate)
		return;
	
	// must block all other impersonations while we are potentially accessing the 
	// global TLS slot number
	while (TestAndSet(&g_fImpersonationLock))
	{
		Sleep(10);		
	}
	DWORD dwImpersonationSlot = g_dwImpersonationSlot;

	// can unblock other threads
	g_fImpersonationLock = 0;

	// constructor should have allocated TLS slot.
	AssertSz(dwImpersonationSlot != INVALID_TLS_SLOT, "Bad TLS slot!");
	
	// determine current impersonation count and type. Must re-impersonate in same style
	// as upon entry.
	DWORD dwValue = PtrToUlong(::TlsGetValue(dwImpersonationSlot));

#ifdef DEBUG	
	// in debug builds, perform the additional check that we are leaving the block with a 0 impersonation count.
	// For ship builds, explicitly set to the desired state, because there's nothing the user can do.
	int cCount = dwValue & IMPERSONATE_COUNT_MASK;
	if (0 != cCount)
		AssertSz(0, "Security Warning: Impersonation count leaving elevation block is non-zero. Possible mismatched start/stop calls inside block.");
#endif


	// restore the threads impersonation count to what it was upon entry. Do this first so
	// if it fails we're still in a known state
	if (!::TlsSetValue(dwImpersonationSlot, reinterpret_cast<void *>((INT_PTR)((dwValue & IMPERSONATE_TYPE_MASK) | (m_cEntryCount & IMPERSONATE_COUNT_MASK)))))
	{
		AssertSz(0, "TlsSetValue failed.");
		ExitProcessIfNotClient();
		return;
	}

	bool fFailed = false;
	switch (IMPERSONATE_TYPE(dwValue))
	{
	case impTypeUndefined:
		// thread has never impersonated, re-impersonating is a no-op
		AssertSz(m_cEntryCount == 0, "Security Warning: Thread is attempting to stop elevating with an unknown elevation state.");
		break;
	case impTypeSession:
	{
		if (m_cEntryCount > 0)
		{
			// set this thread to install-token impersonation		
			HANDLE hToken = GetUserToken();
			if (!hToken)
			{
				// if we're a client called as localsystem, there might not be a thread token.
				// If not, this is a no-op.
				if (g_scServerContext == scService)
				{
					AssertSz(0, "There is no user token to impersonate with.");
					fFailed = true;
				}
			}
			else
			{
				// begin the impersonation if there is no current thread token
				fFailed = !WIN::SetThreadToken(NULL, GetUserToken());
				AssertSz(!fFailed, "Set impersonation token failed");
			}
		}
		break;
	}
	case impTypeCustomAction:
	{
		HANDLE hToken = g_pCustomActionContext->GetImpersonationToken();

		// there MUST be an impersonation token in the CA server when
		// trying to impersonate via CA impersonation, unless we're in 
		// the impersonated server
		if ((hToken == INVALID_HANDLE_VALUE) || (hToken == 0))
		{
			#ifdef _WIN64
			if (g_pCustomActionContext->GetServerContext() != icac64Impersonated)
			#else
			if (g_pCustomActionContext->GetServerContext() != icac32Impersonated)
			#endif	
			{
				AssertSz(0, "Set impersonation token failed");
				fFailed = true;
			}
		}
		else if (!WIN::SetThreadToken(NULL, hToken))
		{
			AssertSz(0, "Set impersonation token failed");
			fFailed = true;
		}
		break;
	}
	case impTypeCOM:
	{
		if (m_cEntryCount > 0)
		{
			fFailed = (S_OK != OLE32::CoImpersonateClient());
			AssertSz(!fFailed, "Internal error in stop elevation call. Could not CoImpersonate.");
		}
		break;
	}
	case impTypeForbidden:
		AssertSz(0, "Internal error in stop elevation call. Impersonation forbidden on this thread.");
		break;
	default:
		AssertSz(0, "Unknown impersonation type in ~CElevate.");
		fFailed = true;
		break;
	}

   	// if setting the token failed, restore the old TLS value
	if (fFailed)
	{
		::TlsSetValue(dwImpersonationSlot, reinterpret_cast<void *>((INT_PTR)dwValue));
		ExitProcessIfNotClient();
	}
}



bool IsImpersonating(bool fStrict)
// If fStrict == true then IsImpersonating will return true if the current
// thread has an impersonating token.
//
// If fStrict == false then IsImpersonating is a bit more liberal, and will
// also return true if we're running "as the user" but not impersonated. 
// This is the case (most of the time) when we're not running as LocalSystem.
{
	if (!fStrict && !RunningAsLocalSystem())
		return true;

	HANDLE hToken;
	if (WIN::OpenThreadToken(WIN::GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
	{
		TOKEN_TYPE tt = (TOKEN_TYPE)0;   // TokenPrimary = 1, TokenImpersonation = 2
		DWORD dwLen = 0;
		AssertNonZero(WIN::GetTokenInformation(hToken, TokenType, &tt , sizeof(tt), &dwLen));
		WIN::CloseHandle(hToken);
//		Assert(fStrict || (tt == TokenImpersonation && ImpersonateCount() > 0) || (tt != TokenImpersonation && ImpersonateCount() == 0));
		return tt == TokenImpersonation;
	}
	else
	{
		DWORD dwErr = GetLastError();
		Assert(dwErr == ERROR_NO_TOKEN);
		Assert((ImpersonateCount() == 0)  || (g_scServerContext == scClient && !GetUserToken() && RunningAsLocalSystem()));
		return false;
	}
}

// CResetImpersonationInfo clears the impersonation type flag for the current thread, 
// allowing the thread to switch between COM and Session impersonation. This should
// ONLY be used at the beginning of an interface stub into the service. (so that 
// worker threads from the RPC pool don't remember their previous incarnation).
// On exit it restores the previous value, and previous thread token as its possible 
// for the thread to be nested in the IMsiServer if the service is pumping messages 
// (such as in custom action server creation).
CResetImpersonationInfo::CResetImpersonationInfo()
{
	if (g_scServerContext != scService)
		return;

	// must block all other impersonations while we are potentially accessing the 
	// TLS slot number
	while (TestAndSet(&g_fImpersonationLock))
	{
		Sleep(10);		
	}

	// if no TLS slot has been created, there is obviously nothing to clear
	if (g_dwImpersonationSlot != INVALID_TLS_SLOT)
	{
		// save off old value
		m_pOldValue = ::TlsGetValue(g_dwImpersonationSlot);
		
		// clear the impersonation type and count information
		if (!::TlsSetValue(g_dwImpersonationSlot, NULL))
		{
			AssertSz(0, "TlsSetValue failed.");
			ExitProcessIfNotClient();
		}
		if (!SetThreadToken(0,0))
		{
			AssertSz(0, "SetThreadToken failed.");
			ExitProcessIfNotClient();
		}
	}

	m_hOldToken = 0;
	if (!WIN::OpenThreadToken(WIN::GetCurrentThread(), TOKEN_IMPERSONATE, TRUE, &m_hOldToken))
	{
		AssertSz(ERROR_NO_TOKEN == GetLastError(), "Failed to get Thread Token");
	}

	// unblock waiting threads
	g_fImpersonationLock = 0;	
}


CResetImpersonationInfo::~CResetImpersonationInfo()
{
	if (g_scServerContext != scService)
		return;
		
	// must block all other impersonations while we are potentially accessing the 
	// TLS slot number
	while (TestAndSet(&g_fImpersonationLock))
	{
		Sleep(10);		
	}

	if (g_dwImpersonationSlot == INVALID_TLS_SLOT)
	{
		AssertSz(0, "Unable to return API thread to previous impersonation level.");
		// unblock waiting threads
		g_fImpersonationLock = 0;	
		return;
	}
	DWORD dwImpersonationSlot = g_dwImpersonationSlot;
	
	// unblock waiting threads
	g_fImpersonationLock = 0;	

	// if fNoImpersonate is true, the thread should never impersonate, otherwise
	// we need to check for a thread token. If one exists, we must bump the 
	if (!::TlsSetValue(dwImpersonationSlot, m_pOldValue))
	{
		AssertSz(0, "TlsSetValue failed.");
		ExitProcessIfNotClient();
	}
	if (!SetThreadToken(0, m_hOldToken))
	{
		AssertSz(0, "SetThreadToken failed.");
		ExitProcessIfNotClient();
	}
	if (m_hOldToken)
		CloseHandle(m_hOldToken);
}


// CForbidTokenChangesDuringCall should be placed at the beginning of any entry
// APIs into MSI.DLL. It marks the thread as "impersonation forbidden"
// to protect non-engine API calls from accidentally picking up the
// impersonation information from an install running in the same process.
// The class restores the previous value on destruction to allow reentrant
// calls. (MsiLoadString and MsiGetProductInfo are often called from the 
// engine). Is a no-op when in non-system client (never allowed to impersonate)
// or service (always allowed to impersonate).
CForbidTokenChangesDuringCall::CForbidTokenChangesDuringCall()
{
	if ((g_scServerContext == scService) || !RunningAsLocalSystem())
		return;
		
	// must block all other impersonations while we are potentially accessing the 
	// TLS slot number
	while (TestAndSet(&g_fImpersonationLock))
	{
		Sleep(10);		
	}

	if (g_dwImpersonationSlot == INVALID_TLS_SLOT)
	{
		// TLS Alloc
		g_dwImpersonationSlot = TlsAlloc();
		if (g_dwImpersonationSlot == INVALID_TLS_SLOT)
		{
			AssertSz(0, "Unable to allocate TLS slot.");

			// can unblock other threads
			g_fImpersonationLock = 0;
			return;
		}
	}
	DWORD dwImpersonationSlot = g_dwImpersonationSlot;
	
	// unblock waiting threads
	g_fImpersonationLock = 0;	

	// if fNoImpersonate is true, the thread should never impersonate, otherwise
	// we need to check for a thread token. If one exists, we must bump the 
	m_pOldValue = ::TlsGetValue(dwImpersonationSlot);
	::TlsSetValue(dwImpersonationSlot, reinterpret_cast<void *>((INT_PTR)IMPERSONATE_TYPE_TO_DWORD(impTypeForbidden)));
}

CForbidTokenChangesDuringCall::~CForbidTokenChangesDuringCall()
{
	if ((g_scServerContext == scService) || !RunningAsLocalSystem())
		return;
		
	// must block all other impersonations while we are potentially accessing the 
	// TLS slot number
	while (TestAndSet(&g_fImpersonationLock))
	{
		Sleep(10);		
	}

	if (g_dwImpersonationSlot == INVALID_TLS_SLOT)
	{
		AssertSz(0, "Unable to return API thread to previous impersonation level.");
		// unblock waiting threads
		g_fImpersonationLock = 0;	
		return;
	}
	DWORD dwImpersonationSlot = g_dwImpersonationSlot;
	
	// unblock waiting threads
	g_fImpersonationLock = 0;	

	// if fNoImpersonate is true, the thread should never impersonate, otherwise
	// we need to check for a thread token. If one exists, we must bump the 
	::TlsSetValue(dwImpersonationSlot, m_pOldValue);
}

// 
void SetEngineInitialImpersonationCount()
{
	if ((g_scServerContext != scService) && !RunningAsLocalSystem())
		return;
		
	// must block all other impersonations while we are potentially accessing the 
	// TLS slot number
	while (TestAndSet(&g_fImpersonationLock))
	{
		Sleep(10);		
	}

	if (g_dwImpersonationSlot == INVALID_TLS_SLOT)
	{
		// TLS Alloc
		g_dwImpersonationSlot = TlsAlloc();
		if (g_dwImpersonationSlot == INVALID_TLS_SLOT)
		{
			AssertSz(0, "Unable to allocate TLS slot.");
			// can unblock other threads
			g_fImpersonationLock = 0;
			ExitProcessIfNotClient();
			return;
		}
	}
	DWORD dwImpersonationSlot = g_dwImpersonationSlot;
	
	// unblock waiting threads
	g_fImpersonationLock = 0;	

	// the thread which sets the user token has a thread token. Set the initial impersonation count on this thread
	// to 1 so if any impersonation happens on this thread we won't accidentally clear the thread token on the
	// last StopImpersonating call.
	if (!::TlsSetValue(g_dwImpersonationSlot, reinterpret_cast<void *>((INT_PTR)IMPERSONATE_TYPE_TO_DWORD(impTypeSession) | 1)))
	{
		AssertSz(0, "TlsSetValue failed.");
		ExitProcessIfNotClient();
	}
}


bool StartImpersonating()
{
	// if in the client and not called as local system
	if ((g_scServerContext != scService) && !RunningAsLocalSystem())
		return true;
	
	return ImpersonateCore(g_scServerContext == scCustomActionServer ? impTypeCustomAction : impTypeSession, NULL, NULL);
}

void StopImpersonating(bool fSaveLastError/*=true*/)
{
	DWORD dwLastError = ERROR_SUCCESS;
	if ( fSaveLastError )
		dwLastError = WIN::GetLastError();
	
	if ((g_scServerContext != scService) && !RunningAsLocalSystem())
		goto Return;
	
	StopImpersonateCore(g_scServerContext == scCustomActionServer ? impTypeCustomAction : impTypeSession, NULL);
	
Return:
	if ( fSaveLastError )
		WIN::SetLastError(dwLastError);
}

// Check to see whether the client has the privilege in question enabled.
// the token's privileges are static so the privilege must have been acquired 
// on the client before we connected to the server for this function to return true
bool IsClientPrivileged(const ICHAR* szPrivilege)
{
	if (g_fWin9X)
		return true; // always privileged on Win9X

	bool fRet = false;
	HANDLE hToken = 0;

	{
		CImpersonate impersonate;
		if (!WIN::OpenThreadToken(WIN::GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
			if (ERROR_NO_TOKEN == GetLastError()) // if there's no thread token then assume we have the privilege
				fRet = true;
	}

	if (hToken && !fRet)
	{
		LUID luid;
		if (WIN::LookupPrivilegeValue(0, szPrivilege, &luid))
		{
			PRIVILEGE_SET ps;
			ps.PrivilegeCount = 1;
			ps.Control = 0;
			ps.Privilege[0].Luid = luid;
			ps.Privilege[0].Attributes = 0;

			BOOL fPrivilege;
			if (WIN::PrivilegeCheck(hToken, &ps, &fPrivilege) && fPrivilege)
				fRet = true;
		}
		WIN::CloseHandle(hToken);
	}
	return fRet;
}			  

// Security descriptors are passed around in a myriad number of forms, 
// and created in far too many ways.
// The CSecurityDescription can be created in a number of different
// ways, and returns a number of different forms that are in use for the
// system.

void CSecurityDescription::Initialize()
{
	m_SA.nLength = sizeof(SECURITY_ATTRIBUTES);
	m_SA.bInheritHandle = true;

	m_SA.lpSecurityDescriptor = NULL;

	m_fValid = true;
	m_fLocalData = true;

	CElevate elevate; //!! What is this for?  I *think* it's something to make
	                  // sure the impersonation/elevation stuff is initialized.
}

CSecurityDescription::CSecurityDescription()
{
	Initialize();
}

CSecurityDescription::CSecurityDescription(const ICHAR* szReferencePath)
{
	Initialize();
	Set(szReferencePath);
}

void CSecurityDescription::Set(const ICHAR* szReferencePath)
{
	Assert(m_SA.lpSecurityDescriptor == NULL);

	if (g_fWin9X || !szReferencePath)
		return;
	
	bool fNetPath = FIsNetworkVolume(szReferencePath);
	bool fElevate = RunningAsLocalSystem() && !fNetPath;

	Assert(!(fNetPath && fElevate));

	SECURITY_INFORMATION     si =  DACL_SECURITY_INFORMATION;
	if (fElevate)            si |= OWNER_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION; 

	DWORD cbNeeded = 0;

	CImpersonate impersonate(fNetPath);

	// we need to elevate when querying security on local objects. Block provides scope for elevation
	{
		CElevate elevate(fElevate);

		if (!ADVAPI32::GetFileSecurity(szReferencePath, si, m_SA.lpSecurityDescriptor, 0, &cbNeeded))
		{
			DWORD dwLastError = WIN::GetLastError();
			if (ERROR_INSUFFICIENT_BUFFER == dwLastError)
			{
				m_SA.lpSecurityDescriptor = GlobalAlloc(GMEM_FIXED, cbNeeded);
				if (!ADVAPI32::GetFileSecurity(szReferencePath, si, m_SA.lpSecurityDescriptor, cbNeeded, &cbNeeded))
				{
					m_fValid = false;
					Assert(0);
				}
			}
			else
			{
				m_fValid = false;
				Assert(0);
			}
		}
	}
}

CSecurityDescription::CSecurityDescription(bool fAllowDelete, bool fHidden)
{
	Initialize();

	if (g_fWin9X)
		return;

	// the data returned from GetSecureSecurityDescriptor is a static, so
	// we should never try to delete it.
	m_fLocalData = false;

	if (RunningAsLocalSystem() && (ERROR_SUCCESS != GetSecureSecurityDescriptor((char**) &(m_SA.lpSecurityDescriptor), (fAllowDelete) ? fTrue : fFalse, (fHidden) ? fTrue : fFalse)))
	{
		m_fValid = false;
		Assert(0);
	}
}

CSecurityDescription::CSecurityDescription(PSID psidOwner, PSID psidGroup, CSIDAccess* SIDAccessAllow, int cSIDAccessAllow)
{
	// Initialize our ACL

	Initialize();

	m_fValid = false;

	const int cbAce = sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD); // subtract ACE.SidStart from the size
	int cbAcl = sizeof (ACL);

	for (int c=0; c < cSIDAccessAllow; c++)
		cbAcl += (GetLengthSid(SIDAccessAllow[c].pSID) + cbAce);

	const int cbDefaultAcl = 512;
	CAPITempBuffer<char, cbDefaultAcl> rgchACL;
	if (rgchACL.GetSize() < cbAcl)
		rgchACL.SetSize(cbAcl);

	if (!WIN::InitializeAcl ((ACL*) (char*) rgchACL, cbAcl, ACL_REVISION))
	{
		return;
	}
	// Add an access-allowed ACE for each of our SIDs

	for (c=0; c < cSIDAccessAllow; c++)
	{
		if (!WIN::AddAccessAllowedAce((ACL*) (char*) rgchACL, ACL_REVISION, SIDAccessAllow[c].dwAccessMask, SIDAccessAllow[c].pSID))
		{
			return;
		}

		ACCESS_ALLOWED_ACE* pAce;
		if (!GetAce((ACL*)(char*)rgchACL, c, (void**)&pAce))
		{
			return;
		}		

		pAce->Header.AceFlags = CONTAINER_INHERIT_ACE|OBJECT_INHERIT_ACE;
	}

	// Initialize our security descriptor,throw the ACL into it, and set the owner
	SECURITY_DESCRIPTOR sd;
	
	if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION) ||
		(!SetSecurityDescriptorDacl(&sd, TRUE, (ACL*) (char*) rgchACL, FALSE)) ||
		(!SetSecurityDescriptorOwner(&sd, psidOwner, FALSE)) || 
		(psidGroup && !SetSecurityDescriptorGroup(m_SA.lpSecurityDescriptor, psidGroup, FALSE)))
	{
		return;
	}
	
	m_fValid = false;

	DWORD cbSD = WIN::GetSecurityDescriptorLength(&sd);
	m_SA.lpSecurityDescriptor = GlobalAlloc(GMEM_FIXED, cbSD);
	if ( m_SA.lpSecurityDescriptor )
	{
		AssertNonZero(WIN::MakeSelfRelativeSD(&sd, (char*) m_SA.lpSecurityDescriptor, &cbSD));
	
		m_fValid = (IsValidSecurityDescriptor(m_SA.lpSecurityDescriptor)) ? true : false;
	}

	return;
}
CSecurityDescription::CSecurityDescription(IMsiStream* piStream)
{
	Initialize();

	if (piStream)
	{
		m_fValid = false;

		piStream->Reset();

		int cbSD = piStream->GetIntegerValue();
		m_SA.lpSecurityDescriptor = GlobalAlloc(GMEM_FIXED, cbSD);

		if (m_SA.lpSecurityDescriptor)
		{
			// Self Relative Security Descriptor
			piStream->GetData(m_SA.lpSecurityDescriptor, cbSD);
			m_fValid = (IsValidSecurityDescriptor(m_SA.lpSecurityDescriptor)) ? true : false;
			Assert(m_fValid);
		}
	}
}

CSecurityDescription::~CSecurityDescription()
{
	if (m_fLocalData && m_SA.lpSecurityDescriptor)
	{
		GlobalFree(m_SA.lpSecurityDescriptor);
		m_SA.lpSecurityDescriptor = NULL;
	}
}

void CSecurityDescription::SecurityDescriptorStream(IMsiServices& riServices, IMsiStream*& rpiStream)
{
	Assert(m_fValid);

	PMsiStream pStream(0);

	DWORD dwLength = GetSecurityDescriptorLength(m_SA.lpSecurityDescriptor);
	char* pbstrmSid = riServices.AllocateMemoryStream(dwLength, rpiStream);
	Assert(pbstrmSid);
	memcpy(pbstrmSid, m_SA.lpSecurityDescriptor, dwLength);
}

const PSECURITY_DESCRIPTOR CSecurityDescription::SecurityDescriptor()
{
	if (!this)
		return NULL;

	Assert(m_fValid);
	return m_SA.lpSecurityDescriptor;
}

const LPSECURITY_ATTRIBUTES CSecurityDescription::SecurityAttributes()
{
	if (!this)
		return NULL;

	Assert(m_fValid);

	return (m_SA.lpSecurityDescriptor) ? &m_SA : NULL;
}


//____________________________________________________________________________
//
// Functions for manipulating SIDs
//____________________________________________________________________________

#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES


void GetStringSID(PISID pSID, ICHAR szSID[cchMaxSID])
// Converts a binary SID into its string form (S-n-...). 
// szSID should be of length cchMaxSID
{
	ICHAR Buffer[cchMaxSID];
	
    StringCchPrintf(Buffer, (sizeof(Buffer)/sizeof(ICHAR)), TEXT("S-%u-"), (USHORT)pSID->Revision);

	StringCchCopy(szSID, cchMaxSID, Buffer);

	if (  (pSID->IdentifierAuthority.Value[0] != 0)  ||
			(pSID->IdentifierAuthority.Value[1] != 0)     )
	{
		StringCchPrintf(Buffer, (sizeof(Buffer)/sizeof(ICHAR)), TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
					 (USHORT)pSID->IdentifierAuthority.Value[0],
					 (USHORT)pSID->IdentifierAuthority.Value[1],
                    (USHORT)pSID->IdentifierAuthority.Value[2],
                    (USHORT)pSID->IdentifierAuthority.Value[3],
                    (USHORT)pSID->IdentifierAuthority.Value[4],
                    (USHORT)pSID->IdentifierAuthority.Value[5] );
		StringCchCat(szSID, cchMaxSID, Buffer);

    } else {

        ULONG Tmp = (ULONG)pSID->IdentifierAuthority.Value[5]          +
              (ULONG)(pSID->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(pSID->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(pSID->IdentifierAuthority.Value[2] << 24);
        StringCchPrintf(Buffer, (sizeof(Buffer)/sizeof(ICHAR)), TEXT("%lu"), Tmp);
		StringCchCat(szSID, cchMaxSID, Buffer);
    }

    for (int i=0;i<pSID->SubAuthorityCount ;i++ ) {
        StringCchPrintf(Buffer, (sizeof(Buffer)/sizeof(ICHAR)), TEXT("-%lu"), pSID->SubAuthority[i]);
		StringCchCat(szSID, cchMaxSID, Buffer);
    }
}

DWORD GetUserSID(HANDLE hToken, char rgSID[cbMaxSID])
// get the (binary form of the) SID for the user specified by hToken
{
	UCHAR TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
	ULONG ReturnLength;

	BOOL f = WIN::GetTokenInformation(hToken,
												TokenUser,
												TokenInformation,
												sizeof(TokenInformation),
												&ReturnLength);

	if(f == FALSE)
	{
		DWORD dwRet = GetLastError();
		DEBUGMSG1(TEXT("GetTokenInformation failed with error %d"), (const ICHAR*)(INT_PTR)dwRet);
		Assert(0);
		return dwRet;
	}

	PISID iSid = (PISID)((PTOKEN_USER)TokenInformation)->User.Sid;
	if (WIN::CopySid(cbMaxSID, rgSID, iSid))
		return ERROR_SUCCESS;
	else
		return GetLastError();
}


DWORD OpenUserToken(HANDLE &hToken, bool* pfThreadToken=0)
/*----------------------------------------------------------------------------
Returns the user's thread token if possible; otherwise obtains the user's
process token.
------------------------------------------------------------------------------*/
{
	DWORD dwResult = ERROR_SUCCESS;
	if (pfThreadToken)
		*pfThreadToken = true;

	if (!WIN::OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE|TOKEN_QUERY, TRUE, &hToken))
	{
		// if the thread has no access token then use the process's access token
		dwResult = GetLastError();
		if (pfThreadToken)
			*pfThreadToken = false;
		if (ERROR_NO_TOKEN == dwResult)
		{
			dwResult = ERROR_SUCCESS;
			if (!WIN::OpenProcessToken(GetCurrentProcess(), TOKEN_IMPERSONATE|TOKEN_QUERY, &hToken))
				dwResult = GetLastError();
		}
	}
	return dwResult;
}

DWORD GetCurrentUserToken(HANDLE &hToken, bool& fCloseHandle)
{
	// if the current thread has ever impersonated via COM, don't use the current
	// install session token. Instead use the current thread token (after 
	// impersonating
	ImpersonationType impType = impTypeUndefined;
	if ((g_scServerContext == scService)  || RunningAsLocalSystem())
	{
		// block waiting threads
		while (TestAndSet(&g_fImpersonationLock))
		{
			Sleep(10);		
		}

		// if no slot has been assigned, we aren't impersonating
		if (g_dwImpersonationSlot != INVALID_TLS_SLOT)
		{
			// determine current impersonation count
			impType = IMPERSONATE_TYPE(PtrToUlong(::TlsGetValue(g_dwImpersonationSlot)));
		}
		
		// unblock waiting threads
		g_fImpersonationLock = 0;	
	}
	
	DWORD dwRet = ERROR_SUCCESS;
	fCloseHandle = false;

	if (g_scServerContext == scService && impType == impTypeCOM)
	{
		// thread has impersonated via COM. Use that token.
		CCoImpersonate impersonate;
		dwRet = OpenUserToken(hToken);
		fCloseHandle = true;
	}
	else
	{
		// client-side, not impersonated, or session impersonation. Use the stored token
		// or the thread token if none exists
		if ((hToken = GetUserToken()) == 0)
		{
			dwRet = OpenUserToken(hToken);
			fCloseHandle = true;
		}
	}
	return dwRet;
}

DWORD GetCurrentUserSID(char rgchSID[cbMaxSID])
// get the (binary form of the) SID for the current user: caller does NOT need to impersonate
{
	HANDLE hToken;
	bool fCloseHandle = false;
	DWORD dwRet = ERROR_SUCCESS;

	dwRet = GetCurrentUserToken(hToken, fCloseHandle);
	if (ERROR_SUCCESS == dwRet)
	{
		dwRet = GetUserSID(hToken, rgchSID);
		if (fCloseHandle)
			WIN::CloseHandle(hToken);
	}
	return dwRet;
}

DWORD GetCurrentUserStringSID(ICHAR szSID[cchMaxSID])
// get string form of SID for current user: caller does NOT need to impersonate
{
	char rgchSID[cbMaxSID];
	DWORD dwRet;

	if (ERROR_SUCCESS == (dwRet = GetCurrentUserSID(rgchSID)))
	{
		GetStringSID((PISID)rgchSID, szSID);
	}
	return dwRet;
}

DWORD GetCurrentUserStringSID(const IMsiString*& rpistrSid)
// get string form of SID for current user: caller does NOT need to impersonate
{
	ICHAR szSID[cchMaxSID];
	DWORD dwRet;

	if (ERROR_SUCCESS == (dwRet = GetCurrentUserStringSID(szSID)))
	{
		MsiString(szSID).ReturnArg(rpistrSid);
	}
	return dwRet;
}


bool IsLocalSystemToken(HANDLE hToken)
{
	ICHAR szCurrentStringSID[cchMaxSID];
	char  rgchCurrentSID[cbMaxSID];
	if ((hToken == 0) || (ERROR_SUCCESS != GetUserSID(hToken, rgchCurrentSID)))
		return false;

	GetStringSID((PISID)rgchCurrentSID, szCurrentStringSID);
	return 0 == IStrComp(szLocalSystemSID, szCurrentStringSID);
}

////
// determines if the provided token came from a unique logon token from
// the normal system token. Works only for LocalSystem tokens. Caller must
// ensure that the token handle is valid and is a LocalSystem token.
bool TokenIsUniqueSystemToken(HANDLE hUserToken)
{
	TOKEN_STATISTICS TokenInfo;
	DWORD dwBytesSet = 0;

	// retrieve token statistic information from the token, which contains the AuthId
	if (!GetTokenInformation(hUserToken, TokenStatistics, &TokenInfo, sizeof(TokenInfo), &dwBytesSet))
		return false;

	// verify that the structure was filled.
	if (dwBytesSet != sizeof(TokenInfo))
		return false;

	// check the authentication ID
	LUID SystemLUID = SYSTEM_LUID;
    return (0 != memcmp(&TokenInfo.AuthenticationId, &SystemLUID, sizeof(SystemLUID)));
}

bool RunningAsLocalSystem()
{
	static int iRet = -1;

	if(iRet != -1)
		return (iRet != 0);
	{
		iRet = 0;
		HANDLE hTokenImpersonate = INVALID_HANDLE_VALUE;
		if(WIN::OpenThreadToken(WIN::GetCurrentThread(), TOKEN_IMPERSONATE , TRUE, &hTokenImpersonate))
		{
			if (!WIN::SetThreadToken(0, 0)) // stop impersonation
			{
				AssertSz(0, "SetThreadToken failed");
				ExitProcessIfNotClient();
			}
		}

		HANDLE hToken;

		if (WIN::OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
		{
			bool fIsLocalSystem = IsLocalSystemToken(hToken);
			WIN::CloseHandle(hToken);

			if (fIsLocalSystem)
				iRet = 1;
		}
		if(hTokenImpersonate != INVALID_HANDLE_VALUE)
		{
			if (!WIN::SetThreadToken(0, hTokenImpersonate)) // start impersonation
			{
				AssertSz(0, "SetThreadToken failed");
				ExitProcessIfNotClient();
			}

			WIN::CloseHandle(hTokenImpersonate);
		}
		return (iRet != 0);
	}
}

#ifdef DEBUG
bool GetAccountNameFromToken(HANDLE hToken, ICHAR* szAccount, DWORD cchSize)
{
	ICHAR szUser[500];
	DWORD cbUser = 500;
	ICHAR szDomain[400];
	DWORD cbDomain = 400;

	UCHAR TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
	ULONG ReturnLength;

	BOOL f = GetTokenInformation(hToken,
										  TokenUser,
										  TokenInformation,
										  sizeof(TokenInformation),
										  &ReturnLength);

	if(f == FALSE)
		return false;

	PISID iSid = (PISID)((PTOKEN_USER)TokenInformation)->User.Sid;

	SID_NAME_USE nu;
	if (0 == LookupAccountSid(0, iSid, szUser, &cbUser, szDomain, &cbDomain, &nu))
		return false;
	else
	{
		StringCchPrintf(szAccount, cchSize, TEXT("%s\\%s"), szDomain, szUser);
		return true;
	}
}
#endif

SECURITY_INFORMATION GetSecurityInformation(PSECURITY_DESCRIPTOR pSD)
{
	SECURITY_DESCRIPTOR_CONTROL sdc = 0;
	DWORD dwRevision = 0;
	PSID pOwner = 0;
	PSID pGroup = 0;
	BOOL fDefaulted;

	if (!pSD) 
		return 0;

	AssertNonZero(GetSecurityDescriptorControl(pSD, &sdc, &dwRevision));
	AssertNonZero(GetSecurityDescriptorOwner(pSD, &pOwner, &fDefaulted));
	AssertNonZero(GetSecurityDescriptorGroup(pSD, &pGroup, &fDefaulted));

	return 	((sdc & SE_DACL_PRESENT)  ? DACL_SECURITY_INFORMATION  : 0) +
				((sdc & SE_SACL_PRESENT)  ? SACL_SECURITY_INFORMATION  : 0) +
				((pOwner)                 ? OWNER_SECURITY_INFORMATION : 0) +
				((pGroup)                 ? GROUP_SECURITY_INFORMATION : 0);
}


#ifdef DEBUG
void DisplayAccountName(const ICHAR* szMessage, PISID pSid)
{
	if (pSid)
	{
		ICHAR szName[256];
		ICHAR szDomain[256];
		DWORD cbName = 128, cbDomain = 128;
		SID_NAME_USE nu;

		if (!LookupAccountSid(0, pSid, szName, &cbName, szDomain, &cbDomain, &nu))
			DEBUGMSG1(TEXT("Error looking up account SID: %d"), (const ICHAR*)(INT_PTR)GetLastError());
		else
			DEBUGMSG3(TEXT("%s: %s\\%s"), szMessage, szDomain, szName);
	}
	else
	{
		ICHAR szAccount[256];

		HANDLE hToken;
		DWORD dwRet;
		bool fThreadToken;
		if ((dwRet = OpenUserToken(hToken, &fThreadToken)) != ERROR_SUCCESS)
		{
			DEBUGMSG1(TEXT("In DisplayAccountName, OpenUserToken failed with %d"), (const ICHAR*)(INT_PTR)dwRet);
			return;
		}

		bool f = GetAccountNameFromToken(hToken, szAccount, (sizeof(szAccount)/sizeof(ICHAR)));

		WIN::CloseHandle(hToken);
		
		if(!f)
		{
			DEBUGMSG1(TEXT("In DisplayAccountName, GetAccountNameFromToken failed with %d"), (const ICHAR*)(INT_PTR)GetLastError());
			return;
		}

		DEBUGMSG3(TEXT("%s: %s [%s]"), szMessage, szAccount, fThreadToken ? TEXT("thread") : TEXT("process"));

		return;
	}
}
#endif

// IsAdmin(): return true if current user is an Administrator (or if on Win95)
// See KB Q118626 
bool IsAdmin(void)
{
	if(g_fWin9X)
		return true; // convention: always Admin on Win95
	
#ifdef DEBUG
	if(GetTestFlag('N'))
		return false; // pretend user is non-admin
#endif //DEBUG

	CImpersonate impersonate;
	
	// get the administrator sid		
	PSID psidAdministrators;
	SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
	if(!AllocateAndInitializeSid(&siaNtAuthority, 2,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0, 0, 0, 0, 0, 0,
		&psidAdministrators))
		return false;

	// on NT5, use the CheckTokenMembershipAPI to correctly handle cases where
	// the Adiminstrators group might be disabled. bIsAdmin is BOOL for 
	BOOL bIsAdmin = FALSE;
	if (g_iMajorVersion >= 5) 
	{
		// CheckTokenMembership checks if the SID is enabled in the token. NULL for
		// the token means the token of the current thread. Disabled groups, restricted
		// SIDS, and SE_GROUP_USE_FOR_DENY_ONLY are all considered. If the function
		// returns false, ignore the result.
		if (!ADVAPI32::CheckTokenMembership(NULL, psidAdministrators, &bIsAdmin))
			bIsAdmin = FALSE;
	}
	else
	{
		// NT4, check groups of user
		HANDLE hAccessToken;
		CAPITempBuffer<UCHAR,1024> InfoBuffer; // may need to resize if TokenInfo too big
		DWORD dwInfoBufferSize;
		UINT x;

		if (OpenProcessToken(GetCurrentProcess(),TOKEN_READ,&hAccessToken))
		{
			bool bSuccess = false;
			bSuccess = GetTokenInformation(hAccessToken,TokenGroups,InfoBuffer,
				InfoBuffer.GetSize(), &dwInfoBufferSize) == TRUE;

			if(dwInfoBufferSize > InfoBuffer.GetSize())
			{
				Assert(!bSuccess);
				InfoBuffer.SetSize(dwInfoBufferSize);
				bSuccess = GetTokenInformation(hAccessToken,TokenGroups,InfoBuffer,
					InfoBuffer.GetSize(), &dwInfoBufferSize) == TRUE;
			}

			CloseHandle(hAccessToken);
			
			if (bSuccess)
			{
				PTOKEN_GROUPS ptgGroups = (PTOKEN_GROUPS)(UCHAR*)InfoBuffer;
				for(x=0;x<ptgGroups->GroupCount;x++)
				{
					if( EqualSid(psidAdministrators, ptgGroups->Groups[x].Sid) )
					{
						bIsAdmin = TRUE;
						break;
					}

				}
			}
		}
	}
	
	FreeSid(psidAdministrators);
	return bIsAdmin ? true : false;
}

bool FIsSecurityDescriptorOwnedBy(PSECURITY_DESCRIPTOR pSD, char* psidDesiredOwner)
{
	PSID psidOwner;
	BOOL fOwnerDefaulted;

	if (WIN::GetSecurityDescriptorOwner(pSD, &psidOwner, &fOwnerDefaulted))
	{
		if (psidOwner && WIN::EqualSid(psidOwner, psidDesiredOwner))
			return true;
	}
	return false;
}

inline bool FIsSecurityDescriptorAdminOwned(PSECURITY_DESCRIPTOR pSD)
{
	char* psidLocalAdmin;
	DWORD dwRet = GetAdminSID(&psidLocalAdmin);

	return (ERROR_SUCCESS == dwRet && FIsSecurityDescriptorOwnedBy(pSD, psidLocalAdmin));
}

inline bool FIsSecurityDescriptorSystemOwned(PSECURITY_DESCRIPTOR pSD)
{
	char *psidLocalSystem;
	DWORD dwRet = GetLocalSystemSID(&psidLocalSystem);

	return (ERROR_SUCCESS == dwRet && FIsSecurityDescriptorOwnedBy(pSD, psidLocalSystem));
}

bool FIsSecurityDescriptorSystemOrAdminOwned(PSECURITY_DESCRIPTOR pSD)
{
	return (FIsSecurityDescriptorAdminOwned(pSD) ||
			  FIsSecurityDescriptorSystemOwned(pSD));
}

LONG FIsKeySystemOrAdminOwned(HKEY hKey, bool &fResult)
{
	Assert(!g_fWin9X);
	
	// if someone messes up checking returns, 
	// we'd better default to insecure.
	fResult = false;

	// reading just the owner doesn't take very much space
	CAPITempBuffer<char, 64> rgchSD;
	DWORD cbSD = 64;

	LONG dwRet = WIN::RegGetKeySecurity(hKey, OWNER_SECURITY_INFORMATION, rgchSD, &cbSD);
	if (ERROR_SUCCESS != dwRet)
	{
		if (ERROR_INSUFFICIENT_BUFFER == dwRet)
		{
			rgchSD.SetSize(cbSD);
			dwRet = WIN::RegGetKeySecurity(hKey, OWNER_SECURITY_INFORMATION, rgchSD, &cbSD);
		}
		
		if (ERROR_SUCCESS != dwRet)
		{
			return dwRet;
		}
	}

	if (FIsSecurityDescriptorSystemOwned(rgchSD) || FIsSecurityDescriptorAdminOwned(rgchSD))
	{
		fResult = true;
	}

	return ERROR_SUCCESS;
}

HANDLE OpenSecuredTempFile(bool fHidden, ICHAR* szTempFile)
{
	Assert(szTempFile);
	MsiString strTempFolder = ENG::GetTempDirectory();

	if (WIN::GetTempFileName(strTempFolder, TEXT("MSI"), /*uUnique*/ 0, szTempFile) == 0)
		return INVALID_HANDLE_VALUE;
	// when a temporary file is requested with the '0' argument for the uUnique,
	// a file is actually created.

	// we must now ACL it, and zero out any rogue data that snuck in between
	// the creation, and the securing of the file.
	PMsiRecord pErr = LockdownPath(szTempFile, fHidden);
	if (pErr)
		return INVALID_HANDLE_VALUE;

	return WIN::CreateFile(szTempFile, GENERIC_WRITE, FILE_SHARE_READ, 0, TRUNCATE_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);
}

DWORD GetLockdownSecurityAttributes(SECURITY_ATTRIBUTES &SA, bool fHidden)
{
	SA.nLength = sizeof(SECURITY_ATTRIBUTES);
	SA.bInheritHandle = true;

	if (g_scServerContext != scService)
	{
		SA.lpSecurityDescriptor = 0;
		return 0;
	}
	return GetSecureSecurityDescriptor((char**) &(SA.lpSecurityDescriptor), fTrue, fHidden);
}

IMsiRecord* LockdownPath(const ICHAR* szLocation, bool fHidden)
{
	// similar to CMsiOpExecute::SetSecureACL, but this locks the file down regardless of who currently
	// owns it, or what the current permissions happen to be.
	
	if (g_fWin9X)
		return 0; // short circuit on 9X, or when running as a server.

	DWORD dwError = 0;
	char* rgchSD; 
	if (ERROR_SUCCESS != (dwError = ::GetSecureSecurityDescriptor(&rgchSD, /*fAllowDelete*/fTrue, fHidden)))
	{
		return PostError(Imsg(idbgOpSecureSecurityDescriptor), dwError);
	}

	CRefCountedTokenPrivileges cPrivs(itkpSD_WRITE);
	if (!WIN::SetFileSecurity(szLocation, OWNER_SECURITY_INFORMATION, (char*)rgchSD) ||
		!WIN::SetFileSecurity(szLocation, DACL_SECURITY_INFORMATION, (char*)rgchSD)) 
	{
		return PostError(Imsg(imsgOpSetFileSecurity), GetLastError(), szLocation);
	}

	return 0;
}
     		
bool SetInteractiveSynchronizeRights(bool fEnable)
{
	// must elevate to ensure access to the system token
	CElevate 	elevate;
	bool		bStatus = false;
	HANDLE		hProcess = NULL;
	PACL 		pNewDACL = NULL;
	PSID 		pSID = NULL;
	DWORD		dwResult = ERROR_SUCCESS;
	SID_IDENTIFIER_AUTHORITY siaNT = SECURITY_NT_AUTHORITY;

	PACL pOldDACL = NULL;
	PSECURITY_DESCRIPTOR pSD = NULL;

	// obtain existing process DACL information.
	// note: we must use OpenProcess here because GetSecurityInfo requires
	// a real handle (rather than a pseudo handle as returned by GetCurrentProcess)
	// on NT4.0.
	hProcess = WIN::OpenProcess (PROCESS_ALL_ACCESS, TRUE, GetCurrentProcessId());
	if (NULL == hProcess)
	{
		dwResult = GetLastError();
		DEBUGMSG1(TEXT("Unable to get a handle to the current process. Return code 0x%08x."), reinterpret_cast<ICHAR*>(static_cast<INT_PTR>(dwResult)));
		bStatus = false;
		goto SetInteractiveSynchRightsEnd;
	}
	
	if (ERROR_SUCCESS != (dwResult = ADVAPI32::GetSecurityInfo(hProcess, SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, &pOldDACL, NULL, &pSD)))
	{
		DEBUGMSG1(TEXT("Unable to obtain process security information. Return code 0x%08x."), reinterpret_cast<ICHAR*>(static_cast<INT_PTR>(dwResult)));
		bStatus = false;
		goto SetInteractiveSynchRightsEnd;
	}

	// obtain interactive user group SID
	if (!AllocateAndInitializeSid(&siaNT, 1, SECURITY_INTERACTIVE_RID, 0, 0, 0, 0, 0, 0, 0, &pSID))
	{
		dwResult = GetLastError();
		DEBUGMSG1(TEXT("ACL Creation for non-admin Synchronize rights failed with code 0x%08x."), reinterpret_cast<ICHAR*>(static_cast<INT_PTR>(dwResult)));
		bStatus = false;
		goto SetInteractiveSynchRightsEnd;
	}

	// build an explicit access entry for use in the DACL.
	EXPLICIT_ACCESS ExplicitAccess;
	ExplicitAccess.grfAccessPermissions = SYNCHRONIZE;
	ExplicitAccess.grfAccessMode = (fEnable ? GRANT_ACCESS : REVOKE_ACCESS);
	ExplicitAccess.grfInheritance = NO_INHERITANCE;
	ExplicitAccess.Trustee.pMultipleTrustee = NULL;
	ExplicitAccess.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
	ExplicitAccess.Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ExplicitAccess.Trustee.TrusteeType = TRUSTEE_IS_GROUP;
	ExplicitAccess.Trustee.ptstrName = reinterpret_cast<LPTSTR>(pSID);

	if (ERROR_SUCCESS != (dwResult = ADVAPI32::SetEntriesInAcl(1, &ExplicitAccess, pOldDACL, &pNewDACL)))
	{
		DEBUGMSG1(TEXT("ACL Creation for non-admin Synchronize rights failed with code 0x%08x."), reinterpret_cast<ICHAR*>(static_cast<INT_PTR>(dwResult)));
		bStatus = false;
		goto SetInteractiveSynchRightsEnd;
	}

	dwResult = ADVAPI32::SetSecurityInfo(hProcess, SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, pNewDACL, NULL);
	if (ERROR_SUCCESS != dwResult)
	{
		DEBUGMSG1(TEXT("Unable to set process security information. Return code 0x%08x."), reinterpret_cast<ICHAR*>(static_cast<INT_PTR>(dwResult)));
		bStatus = false;
		goto SetInteractiveSynchRightsEnd;
	}
	
	// If we are here, everything was successful.
	bStatus = true;
	
SetInteractiveSynchRightsEnd:
	// Cleanup
	if (NULL != hProcess)
		CloseHandle (hProcess);
	if (pSD)
		LocalFree (pSD);
	if (pNewDACL)
		LocalFree (pNewDACL);
	if (pSID)
		FreeSid(pSID);
	
	return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\urlfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation.  All rights reserved.
//
//  File:       urlfunc.cpp
//
//--------------------------------------------------------------------------

#include "precomp.h"
#include "resource.h"
#include "msi.h"
#include "msip.h"
#include "_engine.h"
#include "_msiutil.h"

#include <winhttp.h>
#include <inetmsg.h>
#include <urlmon.h>

// helper functions
DWORD ShlwapiUrlHrToWin32Error(HRESULT hr);
BOOL MsiWinHttpSendRequestAndReceiveResponse(HINTERNET hSession, HINTERNET hRequest, const ICHAR* szUrl);
BOOL MsiWinHttpGetProxy(HINTERNET hSession, HINTERNET hRequest, const ICHAR* szUrl, LPWINHTTP_PROXY_INFO* ppProxyInfo);
BOOL MsiWinHttpSetProxy(HINTERNET hSession, HINTERNET hRequest, LPWINHTTP_PROXY_INFO pProxyInfo);
BOOL MsiWinHttpIsBadProxy(DWORD dwError);
BOOL MsiWinHttpSetNextProxy(HINTERNET hSession, HINTERNET hRequest, LPWINHTTP_PROXY_INFO pProxyInfo);
BOOL MsiWinHttpGetProxyCount(LPWSTR wszProxy, unsigned int* pcProxies);

const unsigned int iMAX_RESEND_REQUEST_COUNT = 5;

//+---------------------------------------------------------------------------------------------------
//
//  Function:	MsiWinHttpSendRequestAndReceiveResponse
//
//  Synopsis:   Determines proxy to use when making request for resource and implements
//              proxy failover since winhttp doesn't automatically support it
//
//  Arguments:
//             [IN] hSession - handle to internet session (from WinHttpOpen)
//             [IN] hRequest - handle to internet request (from WinHttpOpenRequest)
//             [IN] szUrl    - null terminated Url string for resource to download
//
//  Notes:
//             Will retry request for up to 5 ERROR_WINHTTP_RESEND_REQUEST returns.
//             If proxy failure, will retry next proxy in list until all proxies
//             in the list are exhausted
//
//  Returns:   BOOL
//                   TRUE = success, WinHttpSendRequest and WinHttpReceiveResponse succeeded
//                   FALSE = error, more info available via GetLastError()
//
//  Future:
//            (-) to improve performance, cache proxy information and perform lookups from
//                the cache first before querying the proxy settings
//
//            (-) if using a proxy cache, can also put last known good proxy first in the list
//
//            (-) provide some mechanism for providing authentication credentials
//------------------------------------------------------------------------------------------------------
BOOL MsiWinHttpSendRequestAndReceiveResponse(HINTERNET hSession, HINTERNET hRequest, const ICHAR* szUrl)
{
	WINHTTP_PROXY_INFO* pProxyInfo = NULL;
	
	BOOL fReturn = FALSE;
	BOOL fStatus = TRUE;

	DWORD dwError = ERROR_SUCCESS;

	unsigned int cResendRequest    = 0;
	unsigned int cTriedProxies     = 1;
	unsigned int cAvailableProxies = 0;

	//
	// obtain proxy list for this Url
	//

	if (!MsiWinHttpGetProxy(hSession, hRequest, szUrl, &pProxyInfo))
	{
		dwError = GetLastError();
		goto CommonReturn;
	}

	//
	// count number of proxies in proxy list
	//

	if (pProxyInfo)
	{
		if (!MsiWinHttpGetProxyCount(pProxyInfo->lpszProxy, &cAvailableProxies))
		{
			dwError = GetLastError();
			goto CommonReturn;
		}
	}

	//
	// set proxy to be used by winhttp
	//

	if (!MsiWinHttpSetProxy(hSession, hRequest, pProxyInfo))
	{
		dwError = GetLastError();
		goto CommonReturn;
	}

	for (;;)
	{
		//
		// send request
		//

		fStatus = WINHTTP::WinHttpSendRequest(hRequest,
												WINHTTP_NO_ADDITIONAL_HEADERS, // pwszHeaders
												0,                             // dwHeadersLength
												WINHTTP_NO_REQUEST_DATA,       // lpOptional
												0,                             // dwOptionalLength
												0,                             // dwTotalLength
												NULL);                         // lpContext

		if (fStatus)
		{
			//
			// receive response from request for resource
			//

			fStatus = WINHTTP::WinHttpReceiveResponse(hRequest,	/* lpReserved */ NULL);
		}

		if (fStatus)
		{
			// done - successful response
			fReturn = TRUE;
			break;
		}

		dwError = GetLastError();

		//
		// should we try sending request again?
		//

		if (ERROR_WINHTTP_RESEND_REQUEST == dwError && cResendRequest < iMAX_RESEND_REQUEST_COUNT)
		{
			cResendRequest++;
			continue;
		}

		//
		// check for proxy issue
		//

		if (MsiWinHttpIsBadProxy(dwError))
		{
			// possible proxy problem, try next proxy if available

			if (cTriedProxies < cAvailableProxies)
			{
				cTriedProxies++;

				if (MsiWinHttpSetNextProxy(hSession, hRequest, pProxyInfo))
				{
					// found another proxy, let's give it a go
					continue;
				}
			}
		}

		// other problem, end it
		break;
	}



CommonReturn:
	if (pProxyInfo)
		GlobalFree(pProxyInfo);

	SetLastError(dwError);

	return fReturn;
}

//+--------------------------------------------------------------------------------------------------
//
//  Function:	  MsiWinHttpGetProxy
//
//  Synopsis:     Obtains proxy information for a given Url. If no proxy info
//                is available, obtains auto-configured proxy info from
//                Internet Explorer settings
//
//  Arguments:
//                [IN]  hSession    - HINTERNET handle of session (from WinHttpOpen)
//                [IN]  hRequest    - HINTERNET handle of resource request (from WinHttpOpenRequest)
//                [IN]  szUrl       - null-terminated Url for resource
//                [OUT] ppProxyInfo - returned WINHTTP_PROXY_INFO structure containing proxy info
//
//  Returns:      BOOL
//                      true = success
//                      false = error, more info via GetLastError()
//  Notes:
//                Boilerplate for code provided by Stephen Sulzer. 
//                If no proxy info is found, ppProxyInfo will be NULL and TRUE is returned
//
//-----------------------------------------------------------------------------------------------------
BOOL MsiWinHttpGetProxy(HINTERNET hSession, HINTERNET hRequest, const ICHAR* szUrl, LPWINHTTP_PROXY_INFO* ppProxyInfo)
{
	WINHTTP_PROXY_INFO                   ProxyInfo;
	WINHTTP_AUTOPROXY_OPTIONS            AutoProxyOptions;
	WINHTTP_CURRENT_USER_IE_PROXY_CONFIG IEProxyConfig;

	WINHTTP_PROXY_INFO* pProxyInfo = NULL;

	BOOL fResult       = TRUE;
	BOOL fTryAutoProxy = FALSE;
	BOOL fSuccess      = FALSE;

	DWORD dwStatus     = ERROR_SUCCESS;

	ZeroMemory(&ProxyInfo, sizeof(ProxyInfo));
	ZeroMemory(&AutoProxyOptions, sizeof(AutoProxyOptions));
	ZeroMemory(&IEProxyConfig, sizeof(IEProxyConfig));

	DWORD cbProxy        = 0;
	DWORD cchProxy       = 0; // includes null terminator
	DWORD cchProxyBypass = 0; // includes null terminator

	if (!hSession || !hRequest || !ppProxyInfo || !szUrl)
	{
		dwStatus = ERROR_INVALID_PARAMETER;
		goto CommonReturn;
	}

	// first, determine how IE is configured
	if (WINHTTP::WinHttpGetIEProxyConfigForCurrentUser(&IEProxyConfig))
	{
		// if IE is configured to autodetect, then we'll autodetect too
		if (IEProxyConfig.fAutoDetect)
		{
			AutoProxyOptions.dwFlags = WINHTTP_AUTOPROXY_AUTO_DETECT;

			// use both DHCP and DNS-based autodetection
			AutoProxyOptions.dwAutoDetectFlags = WINHTTP_AUTO_DETECT_TYPE_DHCP | WINHTTP_AUTO_DETECT_TYPE_DNS_A;

			fTryAutoProxy = TRUE;
		}

		// if there's an autoconfig URL stored in the IE proxy settings, save it
		if (IEProxyConfig.lpszAutoConfigUrl)
		{
			AutoProxyOptions.dwFlags |= WINHTTP_AUTOPROXY_CONFIG_URL;
			AutoProxyOptions.lpszAutoConfigUrl = IEProxyConfig.lpszAutoConfigUrl;
			
			fTryAutoProxy = TRUE;
		}

		// if obtaining the autoproxy config script requires NTLM auth, then automatically
		// use this client's credentials
		AutoProxyOptions.fAutoLogonIfChallenged = TRUE;
	}
	else
	{
		// failed to determine IE configuration, try auto detection anyway

		AutoProxyOptions.dwFlags = WINHTTP_AUTOPROXY_AUTO_DETECT;
		AutoProxyOptions.dwAutoDetectFlags = WINHTTP_AUTO_DETECT_TYPE_DHCP | WINHTTP_AUTO_DETECT_TYPE_DNS_A;
		AutoProxyOptions.fAutoLogonIfChallenged = TRUE;

		fTryAutoProxy = TRUE;
	}

	if (fTryAutoProxy)
	{
		DEBUGMSGV(TEXT("Msi WinHttp: Performing auto proxy detection"));

		fSuccess = WINHTTP::WinHttpGetProxyForUrl(hSession, szUrl, &AutoProxyOptions, &ProxyInfo);
	}

	// If we didn't do autoproxy or if it failed, see if there's an explicit proxy server
	// in the IE proxy configuration...
	//
	// This is where the WinHttpGetIEProxyConfigForCurrentUser API really comes in handy:
	// in environments in which autoproxy is not implemented and the user's IE browser is
	// instead configured with an explicit proxy server.
	//
	if ((!fTryAutoProxy || !fSuccess) && IEProxyConfig.lpszProxy)
	{
		// the empty string and L':' are not valid server names, so skip them if they
		// are the proxy value
		if (!(IEProxyConfig.lpszProxy[0] == L'\0'
			|| (IEProxyConfig.lpszProxy[0] == L':'
			&& IEProxyConfig.lpszProxy[1] == L'\0')))
		{
			ProxyInfo.dwAccessType  = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
			ProxyInfo.lpszProxy     = IEProxyConfig.lpszProxy;
		}

		// the empty string and L':' are not valid server names, so skip them if they
		// are the proxy value
		if (IEProxyConfig.lpszProxyBypass != NULL
			&& !(IEProxyConfig.lpszProxyBypass[0] == L'\0'
			|| (IEProxyConfig.lpszProxyBypass[0] == L':'
			&& IEProxyConfig.lpszProxyBypass[1] == L'\0')))
		{
			ProxyInfo.lpszProxyBypass     = IEProxyConfig.lpszProxyBypass;
		}
	}

	//
	// log proxy output
	//

	DEBUGMSGV3(TEXT("MSI WinHttp: Proxy Settings Proxy: %s | Bypass: %s | AccessType: %d"),
		ProxyInfo.lpszProxy ? ProxyInfo.lpszProxy : TEXT("(none)"),
		ProxyInfo.lpszProxyBypass ? ProxyInfo.lpszProxyBypass : TEXT("(none)"),
		(const ICHAR*)(INT_PTR)ProxyInfo.dwAccessType);

	//
	// copy proxy info for return parameter
	//

	if (NULL != ProxyInfo.lpszProxy)
	{
		cchProxy = lstrlen(ProxyInfo.lpszProxy) + 1;
		if (ProxyInfo.lpszProxyBypass)
			cchProxyBypass = lstrlen(ProxyInfo.lpszProxyBypass) + 1;

		cbProxy = sizeof(WINHTTP_PROXY_INFO) + ((cchProxy + cchProxyBypass) * sizeof(WCHAR));

		pProxyInfo = (WINHTTP_PROXY_INFO*) GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, cbProxy);
		if (!pProxyInfo)
		{
			dwStatus = ERROR_OUTOFMEMORY;
			fResult = FALSE;
			goto CommonReturn;
		}

		*pProxyInfo = ProxyInfo;
		pProxyInfo->lpszProxy = (LPWSTR)&pProxyInfo[1];
		memcpy(pProxyInfo->lpszProxy, ProxyInfo.lpszProxy, cchProxy * sizeof(WCHAR));

		if (cchProxyBypass)
		{
			pProxyInfo->lpszProxyBypass = pProxyInfo->lpszProxy + cchProxy;
			memcpy(pProxyInfo->lpszProxyBypass, ProxyInfo.lpszProxyBypass, cchProxyBypass * sizeof(WCHAR));
		}
	}

CommonReturn:

	// fSuccess == TRUE means WinHttpGetProxyForUrl succeeded, so clean up
	// the WINHTTP_PROXY_INFO structure it returned
	if (fSuccess)
	{
		if (ProxyInfo.lpszProxy)
			GlobalFree(ProxyInfo.lpszProxy);
		if (ProxyInfo.lpszProxyBypass)
			GlobalFree(ProxyInfo.lpszProxyBypass);
	}

	// cleanup the IE Proxy Config struct
    if (IEProxyConfig.lpszProxy)
		GlobalFree(IEProxyConfig.lpszProxy);
	if (IEProxyConfig.lpszProxyBypass)
		GlobalFree(IEProxyConfig.lpszProxyBypass);
	if (IEProxyConfig.lpszAutoConfigUrl)
		GlobalFree(IEProxyConfig.lpszAutoConfigUrl);

	*ppProxyInfo = pProxyInfo;

	SetLastError(dwStatus);
	return fResult;

}

//+--------------------------------------------------------------------------
//
//  Function:	MsiWinHttpGetProxyCount
//
//  Synopsis:   Counts the number of proxies in the proxy list
//
//  Arguments:
//              [IN]  wszProxy  - null terminated string proxy list
//              [OUT] pcProxies - returned count of proxies
//
//  Returns:    BOOL
//                   TRUE = success
//                   FALSE = error, GetLastError() has more info
//  Notes:
//              Proxy list is assumed to be delimited by L';'
//
//---------------------------------------------------------------------------
BOOL MsiWinHttpGetProxyCount(LPWSTR wszProxy, unsigned int* pcProxies)
{
	unsigned int cProxies = 0;
	LPWSTR pszProxy = wszProxy;

	if (!pcProxies)
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	if (pszProxy && *pszProxy != L'\0')
	{
		for (;;)
		{
			for (; *pszProxy != L';' && *pszProxy != L'\0'; pszProxy++)
				;

			cProxies++;

			if (L'\0' == *pszProxy)
				break;
			else
                pszProxy++;
		}
	}

	*pcProxies = cProxies;

	return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Function:	MsiWinHttpSetProxy
//
//  Synopsis:   Sets proxy info into the session and request handles.
//
//  Arguments:  
//              [IN] hSession   - HINTERNET handle to session (from WinHttpOpen)
//              [IN] hRequest   - HINTERNET handle to request (from WinHttpOpenRequest)
//              [IN] pProxyInfo - proxy info to set
//
//  Returns:    BOOL
//                   TRUE = success
//                   FALSE = error, use GetLastError() for more info
//  Notes:
//              For proxies to work using https, proxy must be set on session
//               handle as well as request handle
//              If no proxy, simply returns TRUE as nothing to set
//
//---------------------------------------------------------------------------
BOOL MsiWinHttpSetProxy(HINTERNET hSession, HINTERNET hRequest, LPWINHTTP_PROXY_INFO pProxyInfo)
{
	if (!hSession || !hRequest)
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	if (!pProxyInfo || !pProxyInfo->lpszProxy)
		return TRUE; // no proxy to set

	BOOL fResult = WINHTTP::WinHttpSetOption(hSession, WINHTTP_OPTION_PROXY, pProxyInfo, sizeof(*pProxyInfo));
	if (fResult)
	{
		fResult = WINHTTP::WinHttpSetOption(hRequest, WINHTTP_OPTION_PROXY, pProxyInfo, sizeof(*pProxyInfo));
	}

	return fResult;
}

//+--------------------------------------------------------------------------
//
//  Function:	MsiWinHttpIsBadProxy
//
//  Synopsis:   Determines whether or not specified error indicates a proxy
//              issue
//
//  Arguments:
//              [IN] dwError - error value to check
//
//  Returns:    BOOL
//                   TRUE  = dwError is a possible proxy issue error
//                   FALSE = dwError is not related to proxy problems
//
//---------------------------------------------------------------------------
BOOL MsiWinHttpIsBadProxy(DWORD dwError)
{
	switch (dwError)
	{
	case ERROR_WINHTTP_NAME_NOT_RESOLVED: // fall through
	case ERROR_WINHTTP_CANNOT_CONNECT:    // fall through
	case ERROR_WINHTTP_CONNECTION_ERROR:  // fall through
	case ERROR_WINHTTP_TIMEOUT:           
		return TRUE; // possible proxy problem

	default:
		return FALSE;
	}
}

//+------------------------------------------------------------------------------------------------
//
//  Function:	MsiWinHttpSetNextProxy
//
//  Synopsis:   Sets proxy info in hSession and hRequest using the next
//              available proxy in the list
//
//  Arguments:
//              [IN] hSession   - HINTERNET handle to session (from WinHttpOpen)
//              [IN] hRequest   - HINTERNET handle to resource request (from WinHttpOpenRequest)
//              [IN] pProxyInfo - proxy info structure containing proxy list
//
//  Returns:    BOOL
//                   TRUE  = success
//                   FALSE = error, GetLastError() has more info
//
//  Notes:      
//              Preserves last error in failure case.
//              Returns FALSE if no more proxies available in proxy list
//
//--------------------------------------------------------------------------------------------------
BOOL MsiWinHttpSetNextProxy(HINTERNET hSession, HINTERNET hRequest, LPWINHTTP_PROXY_INFO pProxyInfo)
{
	DWORD dwLastError = GetLastError();
	BOOL fResult = FALSE;

	if (pProxyInfo && pProxyInfo->lpszProxy)
	{
		DEBUGMSGV2(TEXT("MsiWinHttp: Bad Proxy %s, Last Error %d"), pProxyInfo->lpszProxy, (const ICHAR*)(INT_PTR)dwLastError);
		LPWSTR lpszProxy = pProxyInfo->lpszProxy;

		// pProxyInfo->lpszProxy represents a possible proxy list, move to next proxy in the list
		// ASSUMPTION: proxy delimiter is L';'

		while (L'\0' != *lpszProxy && L';' != *lpszProxy)
			lpszProxy++;

		if (L';' == *lpszProxy)
			lpszProxy++;


		if (L'\0' == *lpszProxy)
		{
			// no more proxies in the list
			pProxyInfo->lpszProxy = NULL;
		}
		else
		{
			// set to next proxy in the list
			pProxyInfo->lpszProxy = lpszProxy;

			fResult = MsiWinHttpSetProxy(hSession,  hRequest, pProxyInfo);
		}
	}

	SetLastError(dwLastError);

	return fResult;
}

//+--------------------------------------------------------------------------
//
//  Function:	WinHttpDownloadUrlFile
//
//  Synopsis:	URL file downloaded using WinHttp
//
//  Arguments:
//             [in] szUrl - provided path to Url resource
//             [out] rpistrPackagePath - location of local file on disk
//             [in] cTicks - progress tick representation
//
//  Notes:
//             Due to this functions use of MsiString objects, services must
//             already have been loaded via ENG::LoadServices() call.
//
//---------------------------------------------------------------------------
DWORD WinHttpDownloadUrlFile(const ICHAR* szUrl, const IMsiString *&rpistrPackagePath, int cTicks)
{
	DEBUGMSG(TEXT("File path is a URL. Downloading file. . ."));

	LPCWSTR pwszEmpty             = L"";
	LPCWSTR pwszUserAgent         = L"Windows Installer";
	LPCWSTR rgpwszAcceptedTypes[] = { L"*/*", NULL};

	HINTERNET hInetSession = NULL; // handle to initialized winhttp session
	HINTERNET hInetConnect = NULL; // handle to opened hostname connection
	HINTERNET hInetRequest = NULL; // handle to requested Url resource

	URL_COMPONENTSW urlComponents;
	LPWSTR pwszHostName            = NULL;
	LPWSTR pwszUrlPathPlusInfo     = NULL;

	CMsiWinHttpProgress cMsiWinHttpProgress(cTicks); // class for handling progress notifications

	DWORD dwError   = ERROR_SUCCESS;
	DWORD dwStatus  = ERROR_SUCCESS;
	DWORD dwHttpStatusCode = 0;
	
	DWORD  dwRequestFlags= 0;    // flags for opening the request
	DWORD  cbData        = 0;    // amount of data from url currently available
	DWORD  cbRead        = 0;    // amount of data currently read
	DWORD  cbWritten     = 0;    // amount of data written to local file
	DWORD  cbBuf         = 0;    // current byte count size of pbData
	DWORD  dwFileSize    = 0;    // size of resource to be downloaded
	DWORD  dwLength      = 0;    // length of file size "buffer"
	LPBYTE pbData        = NULL; // actual data from url resource

	BOOL  fRet = FALSE;

	MsiString strTempFolder;
	MsiString strSecureFolder;
	MsiString strTempFilename;
	PMsiPath   pTempPath(0);
	PMsiRecord pRecError(0);

	HANDLE hLocalFile = INVALID_HANDLE_VALUE; // handle to local file on disk
	CTempBuffer<ICHAR, 1> szLocalFile(cchExpectedMaxPath + 1); // name of local file on disk

	//
	// initialize WinHttp
	//

	hInetSession = WINHTTP::WinHttpOpen(pwszUserAgent,
									    WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, // dwAccessType
										WINHTTP_NO_PROXY_NAME,             // pwszProxyName
										WINHTTP_NO_PROXY_BYPASS,           // pwszProxyBypass
										0);                                // dwFlags, use synchronous download

	if (NULL == hInetSession)
	{
		dwError = GetLastError();
		goto ErrorReturn;
	}

	//
	// crack provided Url into relevant parts of host name and url path and port information
	//

	ZeroMemory(&urlComponents, sizeof(urlComponents));
	urlComponents.dwStructSize = sizeof(urlComponents);

	urlComponents.dwUrlPathLength = -1;
	urlComponents.dwHostNameLength = -1;
	urlComponents.dwExtraInfoLength = -1;

	if (!WINHTTP::WinHttpCrackUrl(szUrl,
         						  0, // dwUrlLength, 0 implies null terminated
								  0, // dwFlags
								  &urlComponents)) 
	{
		dwError = GetLastError();
		goto ErrorReturn;
	}

	if (NULL == urlComponents.lpszUrlPath)
	{
		urlComponents.lpszUrlPath = (LPWSTR) pwszEmpty;
		urlComponents.dwUrlPathLength = 0;
	}

	if (NULL == urlComponents.lpszHostName)
	{
		urlComponents.lpszHostName = (LPWSTR) pwszEmpty;
		urlComponents.dwHostNameLength = 0;
	}

	if (NULL == urlComponents.lpszExtraInfo)
	{
		urlComponents.lpszExtraInfo = (LPWSTR) pwszEmpty;
		urlComponents.dwExtraInfoLength = 0;
	}

	pwszHostName = (LPWSTR) new WCHAR[urlComponents.dwHostNameLength + 1];
	pwszUrlPathPlusInfo  = (LPWSTR) new WCHAR[urlComponents.dwUrlPathLength + urlComponents.dwExtraInfoLength + 1];

	if (!pwszHostName || !pwszUrlPathPlusInfo)
	{
		dwError = ERROR_OUTOFMEMORY;
		goto ErrorReturn;
	}

	memcpy(pwszHostName, urlComponents.lpszHostName, urlComponents.dwHostNameLength * sizeof(WCHAR));
	pwszHostName[urlComponents.dwHostNameLength] = L'\0';

	memcpy(pwszUrlPathPlusInfo, urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength * sizeof(WCHAR));
	memcpy(pwszUrlPathPlusInfo + urlComponents.dwUrlPathLength, urlComponents.lpszExtraInfo, urlComponents.dwExtraInfoLength * sizeof(WCHAR));
	pwszUrlPathPlusInfo[urlComponents.dwUrlPathLength + urlComponents.dwExtraInfoLength] = L'\0';

	//
	// connect to the target server in the Url
	//

	hInetConnect = WINHTTP::WinHttpConnect(hInetSession,        
										   pwszHostName,        
										   urlComponents.nPort, 
										   0); // dwReserved

	if (NULL == hInetConnect)
	{
		dwError = GetLastError();
		goto ErrorReturn;
	}

	//
	// open a request for the resource
	//

	//
	// Use the secure flag for the https:// protocol otherwise
	// winhttp won't use SSL for the handshake and therefore
	// won't be able to communicate with the server. Note that using the secure
	// flag blindly can result in an ERROR_WINHTTP_SECURE_FAILURE error. So
	// it must only be used with the https:// protocol.
	//
	if (INTERNET_SCHEME_HTTPS == urlComponents.nScheme)
		dwRequestFlags |= WINHTTP_FLAG_SECURE;
	hInetRequest = WINHTTP::WinHttpOpenRequest(hInetConnect,
											   NULL, // pwszVerb, NULL implies GET
											   pwszUrlPathPlusInfo,
											   NULL, // pwszVersion, NULL implies HTTP/1.0
											   WINHTTP_NO_REFERER,
											   rgpwszAcceptedTypes,
											   dwRequestFlags);

	if (NULL == hInetRequest)
	{
		dwError = GetLastError();
		goto ErrorReturn;
	}

	//
	// send request and receive response
	//

	if (!MsiWinHttpSendRequestAndReceiveResponse(hInetSession, hInetRequest, szUrl))
	{
		dwError = GetLastError();
		goto ErrorReturn;
	}

	//
	// make sure this resource is actually available
	//
    
	dwLength = sizeof(dwHttpStatusCode);
	if (!WINHTTP::WinHttpQueryHeaders(hInetRequest,
									  WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,
									  WINHTTP_HEADER_NAME_BY_INDEX,
									  (LPVOID)&dwHttpStatusCode, &dwLength,
									  WINHTTP_NO_HEADER_INDEX))
	{
		dwError = GetLastError();
		goto ErrorReturn;
	}
	
	if (HTTP_STATUS_OK != dwHttpStatusCode)
	{
		dwError = ERROR_FILE_NOT_FOUND;
		goto ErrorReturn;
	}
	
	//
	// determine resource size
	//

	dwLength = sizeof(dwFileSize);

	if (!WINHTTP::WinHttpQueryHeaders(hInetRequest,
									  WINHTTP_QUERY_CONTENT_LENGTH | WINHTTP_QUERY_FLAG_NUMBER, // dwInfoLevel
									  WINHTTP_HEADER_NAME_BY_INDEX, (LPVOID)&dwFileSize,
									  &dwLength, WINHTTP_NO_HEADER_INDEX))
	{
		dwError = GetLastError();
		goto ErrorReturn;
	}

	//
	// create local file
	//

	if (scService == g_scServerContext || IsAdmin())
	{
		// always create download file in secure location if service or admin
		//  note: admin's and local system have full control on our secure folder
		//        everyone else has read

		CElevate elevate;
		strSecureFolder = ENG::GetMsiDirectory();
		if (0 == GetTempFileName(strSecureFolder, TEXT("MSI"), 0, static_cast<WCHAR*>(szLocalFile)))
		{
			dwError = GetLastError();
			goto ErrorReturn;
		}

		pRecError = LockdownPath(static_cast<WCHAR*>(szLocalFile), /*fHidden=*/false);
		if (pRecError)
		{
			dwError = pRecError->GetInteger(2);
			goto ErrorReturn;
		}

		hLocalFile = CreateFile(static_cast<WCHAR*>(szLocalFile), GENERIC_WRITE, FILE_SHARE_READ, 0, TRUNCATE_EXISTING,
								SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS, 0);
	}
	else
	{
		// use user's temp directory
		strTempFolder = ENG::GetTempDirectory();
		if (0 == GetTempFileName(strTempFolder, TEXT("MSI"), 0, szLocalFile))
		{
			dwError = GetLastError();
			goto ErrorReturn;
		}

		hLocalFile = CreateFile(static_cast<WCHAR*>(szLocalFile), GENERIC_WRITE, FILE_SHARE_READ, 0, TRUNCATE_EXISTING,
								SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS, 0);
	}

	if (INVALID_HANDLE_VALUE == hLocalFile)
	{
		dwError = GetLastError();
		goto ErrorReturn;
	}

	DEBUGMSGV2(TEXT("Downloading %s to local file %s"), szUrl, static_cast<ICHAR*>(szLocalFile));

	// send UI initialization, check for cancel (false return)
	if (!cMsiWinHttpProgress.BeginDownload(dwFileSize))
	{
		dwError = GetLastError();
		goto ErrorReturn;
	}

	//
	// read data and write to local file
	//

	for (;;)
	{
		cbData = 0;
		if (!WINHTTP::WinHttpQueryDataAvailable(hInetRequest, &cbData))
		{
			dwError = GetLastError();
			goto ErrorReturn;
		}

		if (0 == cbData)
			break;

		// cbBuf is used primarily to prevent unnecessary buf allocations
		// if cbData > cbBuf, we'll reallocate pbData; otherwise just use currently
		// allocated pbData buf

		if (cbData > cbBuf)
		{
			// need to make pbData larger
			if (pbData)
			{
				delete [] pbData;
			}

			pbData = new BYTE[cbData];
			
			if (!pbData)
			{
				dwError = ERROR_OUTOFMEMORY;
				goto ErrorReturn;
			}
			
			cbBuf = cbData;
		}

		Assert(cbData <= cbBuf);

		cbRead = 0;
		if (!WINHTTP::WinHttpReadData(hInetRequest, pbData, cbData, &cbRead))
		{
			dwError = GetLastError();
			goto ErrorReturn;
		}

		// send progress notification, check for cancel
		if (!cMsiWinHttpProgress.ContinueDownload(cbRead))
		{
			dwError = GetLastError();
			goto ErrorReturn;
		}

		cbWritten = 0;
		if (scService == g_scServerContext || IsAdmin())
		{
			// elevate block to write to secure location
			CElevate elevate;
			fRet = WriteFile(hLocalFile, pbData, cbRead, &cbWritten, NULL);
		}
		else
		{
			fRet = WriteFile(hLocalFile, pbData, cbRead, &cbWritten, NULL);
		}

		if (!fRet || cbRead != cbWritten)
		{
			dwError = GetLastError();
			goto ErrorReturn;
		}
	}

	// complete progress notification, check for cancel
	if (!cMsiWinHttpProgress.FinishDownload())
	{
		dwError = GetLastError();
		goto ErrorReturn;
	}

	MsiString(static_cast<ICHAR*>(szLocalFile)).ReturnArg(rpistrPackagePath);
	dwStatus = ERROR_SUCCESS;

CommonReturn:

	if (pwszHostName)
		delete [] pwszHostName;
	if (pwszUrlPathPlusInfo)
		delete [] pwszUrlPathPlusInfo;

	if (pbData)
		delete [] pbData;

	if (hInetRequest)
		WINHTTP::WinHttpCloseHandle(hInetRequest);
	if (hInetConnect)
		WINHTTP::WinHttpCloseHandle(hInetConnect);
	if (hInetSession)
		WINHTTP::WinHttpCloseHandle(hInetSession);

	if (INVALID_HANDLE_VALUE != hLocalFile)
	{
		CloseHandle(hLocalFile);

		// delete file if we created it, but failed in obtaining data
		if (ERROR_SUCCESS != dwStatus)
		{
			if (scService == g_scServerContext || IsAdmin())
			{
				// elevate block to access secure location
				CElevate elevate;
				DeleteFile(szLocalFile);
			}
			else
			{
				DeleteFile(szLocalFile);
			}
		}
	}

	return (dwStatus);

ErrorReturn:

	DEBUGMSGV2(TEXT("Download of URL resource %s failed with last error %d"), szUrl, (const ICHAR*)(INT_PTR)dwError);

	// map error return to an appropriate value
	switch (dwError)
	{
	case ERROR_INSTALL_USEREXIT: dwStatus = ERROR_INSTALL_USEREXIT; break;
	case ERROR_OUTOFMEMORY:      dwStatus = ERROR_OUTOFMEMORY;      break;
	default:                     dwStatus = ERROR_FILE_NOT_FOUND;   break;
	}

	rpistrPackagePath = &g_MsiStringNull;
	goto CommonReturn;
}


//____________________________________________________________________________________
//
//	CMsiWinHttpProgress class - progress handler for WINHTTP internet download
//____________________________________________________________________________________

//+------------------------------------------------------------------------------------------
//
//  Function:	CMsiWinHttpProgress::CMsiWinHttpProgress
//
//  Synopsis:	Initializes progress handling class used in winhttp downloads
//
//  Arguments:
//              [IN] cTicks - number of ticks to use in progress bar
//
//  Returns:    {none}
//
//  Notes:
//	            cTicks is the number of ticks we're alloted in the progress bar.
//	
//	            If cTicks is 0 then we'll assume that we own the progress bar and
//              use however many ticks we want, resetting the progress bar when
//              we start and when we're done. Total number of ticks comes from
//              BeginDownload call
//
//	            If cTicks is -1, we simply send keep alive messages, without
//              moving the progress bar.
//
// Future:
//              Allow for cTicks to be a value other than 0 or -1 so that
//              the progress bar percentage can be calculated for increment. In this
//              case we're only given a portion of the progress bar to use
//-------------------------------------------------------------------------------------------
CMsiWinHttpProgress::CMsiWinHttpProgress(int cTicks) :
	m_cTotalTicks(cTicks),
	m_cTicksSoFar(0),
	m_fReset(false),
	m_pRecProgress(&CreateRecord(ProgressData::imdNextEnum))
{
	Assert (m_pRecProgress);
	Assert (0 == m_cTotalTicks || -1 == m_cTotalTicks);
}

CMsiWinHttpProgress::~CMsiWinHttpProgress()
{
}

//+--------------------------------------------------------------------------
//
//  Function:	CMsiWinHttpProgress::BeginDownload
//
//  Synopsis:	Sends initial progress information in preparation of 
//              impending download
//
//  Arguments:  {none}
//
//  Returns:    bool
//                    true  = continue download
//                    false = abort download
//
//  Notes: GetLastError() will indicate reason for false return.
//
//            ERROR_INSTALL_USEREXIT set for user cancellation
//            ERROR_FUNCTION_FAILED set for all error conditions
//
//---------------------------------------------------------------------------
bool CMsiWinHttpProgress::BeginDownload(DWORD cProgressMax)
{
	if (!m_pRecProgress)
	{
		SetLastError(ERROR_FUNCTION_FAILED);
		return false;
	}

	m_cTicksSoFar = 0;

	if (-1 == m_cTotalTicks)
	{
		// only send keep alive ticks
		m_cTotalTicks = 0;
	}
	else if (0 == m_cTotalTicks)
	{
		// initialize with max # of ticks, and reset progress bar
		m_fReset      = true;
		m_cTotalTicks = cProgressMax;

		if (m_pRecProgress->SetInteger(ProgressData::imdSubclass, ProgressData::iscMasterReset)
			&& m_pRecProgress->SetInteger(ProgressData::imdProgressTotal, m_cTotalTicks)
			&& m_pRecProgress->SetInteger(ProgressData::imdDirection, ProgressData::ipdForward))
		{
			if (imsCancel == g_MessageContext.Invoke(imtProgress, m_pRecProgress))
			{
				// user cancelled install
				SetLastError(ERROR_INSTALL_USEREXIT);
				return false;
			}
		}
		else
		{
			// unexpected, failed to update record
			SetLastError(ERROR_FUNCTION_FAILED);
			return false; 
		}
	}

	return true;
}

//+--------------------------------------------------------------------------
//
//  Function:	CMsiWinHttpProgress::ContinueDownload
//
//  Synopsis:	Sends updated progress information
//
//  Arguments:  
//              [IN] cProgressIncr - number of ticks to increment progress bar
//
//  Returns:    bool
//                    true  = continue download
//                    false = abort download
//
//  Notes:      GetLastError() will indicate reason for false return.
//
//                    ERROR_INSTALL_USEREXIT set for user cancellation
//                    ERROR_FUNCTION_FAILED set for all error conditions
//
//  Future:
//              If not allowed full control of progress bar (i.e. tick count
//              assigned to us), will need to use percentage based formula
//              to determine number of ticks to increment bar
//
//---------------------------------------------------------------------------
bool CMsiWinHttpProgress::ContinueDownload(DWORD cProgressIncr)
{
	if (!m_pRecProgress)
	{
		SetLastError(ERROR_FUNCTION_FAILED);
		return false;
	}

	// calculate our percentage completed. If it's less than last time then don't
	// move the progress bar

	int cIncrement = 0;

	if (m_cTotalTicks)
	{
		cIncrement = cProgressIncr;
	}

	m_cTicksSoFar += cProgressIncr;

	Assert(m_cTotalTicks == 0 || m_cTicksSoFar <= m_cTotalTicks);

	if (m_pRecProgress->SetInteger(ProgressData::imdSubclass, ProgressData::iscProgressReport)
		&& m_pRecProgress->SetInteger(ProgressData::imdIncrement, cIncrement))
	{
		if (imsCancel == g_MessageContext.Invoke(imtProgress, m_pRecProgress))
		{
			SetLastError(ERROR_INSTALL_USEREXIT);
			return false;
		}
	}
	else
	{
		SetLastError(ERROR_FUNCTION_FAILED);
		return false;
	}

	return true;
}

//+--------------------------------------------------------------------------
//
//  Function:	CMsiWinHttpProgress::FinishDownload
//
//  Synopsis:   Sends remaining progress information and reset progress bar
//              (if indicated)
//
//  Arguments:  {none}
//
//  Returns:    bool
//                    true  = continue download
//                    false = abort download
//
//  Notes:      GetLastError() will indicate reason for false return.
//
//                    ERROR_INSTALL_USEREXIT set for user cancellation
//                    ERROR_FUNCTION_FAILED set for all error conditions
//
//---------------------------------------------------------------------------
bool CMsiWinHttpProgress::FinishDownload()
{
	if (!m_pRecProgress)
	{
		SetLastError(ERROR_FUNCTION_FAILED);
		return false;
	}

	int cLeftOverTicks = m_cTotalTicks - m_cTicksSoFar;
	if (0 > cLeftOverTicks)
		cLeftOverTicks = 0;

	// send remaining ticks
	if (m_pRecProgress->SetInteger(ProgressData::imdSubclass, ProgressData::iscProgressReport)
		&& m_pRecProgress->SetInteger(ProgressData::imdIncrement, cLeftOverTicks))
	{
		if (imsCancel == g_MessageContext.Invoke(imtProgress, m_pRecProgress))
		{
			SetLastError(ERROR_INSTALL_USEREXIT);
			return false;
		}
	}
	else
	{
		SetLastError(ERROR_FUNCTION_FAILED);
		return false;
	}

	// reset progress bar
	if (m_fReset)
	{
		if (m_pRecProgress->SetInteger(ProgressData::imdSubclass, ProgressData::iscMasterReset)
			&& m_pRecProgress->SetInteger(ProgressData::imdProgressTotal, 0)
			&& m_pRecProgress->SetInteger(ProgressData::imdDirection, ProgressData::ipdForward))
		{
			if (imsCancel == g_MessageContext.Invoke(imtProgress, m_pRecProgress))
			{
				SetLastError(ERROR_INSTALL_USEREXIT);
				return false;
			}
		}
		else
		{
			SetLastError(ERROR_FUNCTION_FAILED);
			return false;
		}
	}

	return true;
}


//+--------------------------------------------------------------------------
//
//  Function:	IsURL
//
//  Synopsis:	Determines whether a given path is a Url path. Also indicates
//              whether or not a Url path is a file Url path (file:// scheme)
//
//  Arguments:  
//              [IN] szPath -- path to verify
//              [OUT] fFileUrl -- true if file Url path, false otherwise
//
//  Returns:
//              bool ->> true if Url path, false if not Url path or unsupported scheme
//
//  Notes:
//              Only supported schemes are file:, http:, https:
//              If true returned, caller should check fIsFileUrl to see
//                if the path is a file Url path which must be handled differently
//
//---------------------------------------------------------------------------

const ICHAR szHttpScheme[] = TEXT("http");
const ICHAR szHttpsScheme[] = TEXT("https");
const DWORD cchMaxScheme = 10; // should be sufficient for schemes we care about

bool IsURL(const ICHAR* szPath, bool& fFileUrl)
{
	fFileUrl = false; // initialize to not a file Url

	if (SHLWAPI::UrlIs(szPath, URLIS_URL))
	{
		// path is valid Url
		if (SHLWAPI::UrlIsFileUrl(szPath))
		{
			// path is file Url (has FILE:// prefix)
			fFileUrl = true;

			return true; // scheme supported
		}
		else
		{
			// check for supported scheme

			CAPITempBuffer<ICHAR, 1> rgchScheme;
			if (!rgchScheme.SetSize(cchMaxScheme))
				return false; // out of memory

			DWORD cchScheme = rgchScheme.GetSize();

			if (FAILED(SHLWAPI::UrlGetPart(szPath, rgchScheme, &cchScheme, URL_PART_SCHEME, /* dwFlags = */ 0)))
			{
				return false; // invalid or buffer to small (but we don't support that scheme)
			}

			if (0 == IStrCompI(rgchScheme, szHttpScheme) || 0 == IStrCompI(rgchScheme, szHttpsScheme))
			{
				return true; // scheme supported
			}
		}
	}

	return false; // unsupported scheme or not a Url
}

//+--------------------------------------------------------------------------
//
//  Function:  MsiConvertFileUrlToFilePath
//
//  Synopsis:  Converts a given file url path to a DOS path
//             after canonicalization
//
//  Notes:
//             pszPath buffer should be at a minimum MAX_PATH characters
//
//---------------------------------------------------------------------------
bool MsiConvertFileUrlToFilePath(LPCTSTR lpszFileUrl, LPTSTR pszPath, LPDWORD pcchPath, DWORD dwFlags)
{
	DWORD dwStat = ERROR_SUCCESS;

	CAPITempBuffer<ICHAR, 1> rgchUrl;
	if (!rgchUrl.SetSize(cchExpectedMaxPath + 1))
	{
		SetLastError(ERROR_OUTOFMEMORY);
		return false;
	}

	// first canonicalize the Url
	DWORD cchUrl = rgchUrl.GetSize();

	if (!MsiCanonicalizeUrl(lpszFileUrl, rgchUrl, &cchUrl, dwFlags))
	{
		dwStat = WIN::GetLastError();
		if (ERROR_INSUFFICIENT_BUFFER == dwStat)
		{
			cchUrl++; // documentation on shlwapi behavior unclear, so being safe
			if (!rgchUrl.SetSize(cchUrl))
			{
				WIN::SetLastError(ERROR_OUTOFMEMORY);
				return false;
			}
		
			if (!MsiCanonicalizeUrl(lpszFileUrl, rgchUrl, &cchUrl, dwFlags))
			{
				return false;
			}
		}
		else
		{
			WIN::SetLastError(dwStat);
			return false;
		}
	}

	// now convert the file url to a DOS path
	HRESULT hr = SHLWAPI::PathCreateFromUrl(rgchUrl, pszPath, pcchPath, /* dwReserved = */ 0);
	if (FAILED(hr))
	{
		WIN::SetLastError(ShlwapiUrlHrToWin32Error(hr));
		return false;
	}

	return true;
}


//+--------------------------------------------------------------------------
//
//  Function:	ConvertMsiFlagsToShlwapiFlags
//
//  Synopsis:	converts provided Msi flags to the appropriate shlwapi
//              representations for UrlCombine and UrlCanonicalize API
//
//  Arguments:
//             [in] dwMsiFlags -- msi flags to use
//
//  Returns:
//             DWORD value of the flags to provide the shlwapi Internet API
//
//  Notes:
//            The flag determination is based off of the previous wininet implementation.
//            Wininet and Winhttp cannot co-exist happily due to header file issues and
//            preprocessor conflicts, so we now use the shlwapi versions of the API.  Wininet
//            internally actually called the shlwapi version, so we're safe here, but there
//            are two gotchas with this interaction.
//
//              1. NO_ENCODE is on by default in shlwapi whereas it's not in wininet so it
//                  needs to be flipped.  
//              2. URL_WININET_COMPATIBILITY mode needs to be included in the shlwapi flags
//
//---------------------------------------------------------------------------
DWORD ConvertMsiFlagsToShlwapiFlags(DWORD dwMsiFlags)
{
	DWORD dwShlwapiFlags = dwMsiFlags;
	dwShlwapiFlags ^= dwMsiInternetNoEncode;
	dwShlwapiFlags |= URL_WININET_COMPATIBILITY;

	return dwShlwapiFlags;
}

//
// ShlwapiUrlHrToWin32Error specifically converts HRESULT return codes
//  for the shlwapi Url* APIs to win32 errors (as expected by WinInet)
//  DO NOT USE THIS FUNCTION FOR ANY OTHER PURPOSE
//
DWORD ShlwapiUrlHrToWin32Error(HRESULT hr)
{
    DWORD dwError = ERROR_INVALID_PARAMETER;
    switch(hr)
    {
    case E_OUTOFMEMORY:
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case E_POINTER:
        dwError = ERROR_INSUFFICIENT_BUFFER;
        break;

    case S_OK:
        dwError = ERROR_SUCCESS;
        break;

    default:
        break;
    }
    return dwError;
}


BOOL MsiCombineUrl(
	IN LPCTSTR lpszBaseUrl,
	IN LPCTSTR lpszRelativeUrl,
	OUT LPTSTR lpszBuffer,
	IN OUT LPDWORD lpdwBufferLength,
	IN DWORD dwFlags)
{
	HRESULT hr = SHLWAPI::UrlCombine(lpszBaseUrl, lpszRelativeUrl, lpszBuffer, lpdwBufferLength, ConvertMsiFlagsToShlwapiFlags(dwFlags));
	if (FAILED(hr))
	{
		if (TYPE_E_DLLFUNCTIONNOTFOUND == hr)
		{
			// should never happen since shlwapi should always be available
			AssertSz(0, TEXT("shlwapi unavailable!"));
			WIN::SetLastError(ERROR_PROC_NOT_FOUND);
			return FALSE;
		}
		else
		{
			WIN::SetLastError(ShlwapiUrlHrToWin32Error(hr));
			return FALSE;
		}
	}

	return TRUE;
}

BOOL MsiCanonicalizeUrl(
	LPCTSTR lpszUrl,
	OUT LPTSTR lpszBuffer,
	IN OUT LPDWORD lpdwBufferLength,
	IN DWORD dwFlags)
{
	HRESULT hr = SHLWAPI::UrlCanonicalize(lpszUrl, lpszBuffer, lpdwBufferLength, ConvertMsiFlagsToShlwapiFlags(dwFlags));
	if (FAILED(hr))
	{
		if (TYPE_E_DLLFUNCTIONNOTFOUND == hr)
		{
			// should never happen since shlwapi should always be available
			AssertSz(0, TEXT("shlwapi unavailable!"));
			WIN::SetLastError(ERROR_PROC_NOT_FOUND);
			return FALSE;
		}
		else
		{
			WIN::SetLastError(ShlwapiUrlHrToWin32Error(hr));
			return FALSE;
		}
	}
	return TRUE;
}

//____________________________________________________________________________
//
// URLMON download & CMsiBindStatusCallback Implementation
//____________________________________________________________________________


CMsiBindStatusCallback::CMsiBindStatusCallback(unsigned int cTicks) :
	m_iRefCnt(1), 
	m_pProgress(&CreateRecord(ProgressData::imdNextEnum)),
	m_cTotalTicks(cTicks),
	m_fResetProgress(fFalse)
/*----------------------------------------------------------------------------
	cTicks is the number of ticks we're allotted in the progress bar. If cTicks
	is 0 then we'll assume that we own the progress bar and use however many
	ticks we want, resetting the progress bar when we start and when we're done.

  If cTicks is set, however, we won't reset the progress bar.

  If cTicks is set to -1, we simply send keep alive messages, without moving
	the progress bar.
  -----------------------------------------------------------------------------*/
{
	Assert(m_pProgress);
}

HRESULT CMsiBindStatusCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR /*szStatusText*/)
{
	switch (ulStatusCode)
	{
	case BINDSTATUS_BEGINDOWNLOADDATA:
		m_cTicksSoFar = 0;
		if (m_cTotalTicks == -1)
		{
			// only send keep alive ticks
			m_cTotalTicks = 0;
		}
		else if (m_cTotalTicks == 0)
		{
			// Initialize w/ max # of ticks, as the max progress passed to us can change...
			m_fResetProgress = fTrue;
			m_cTotalTicks    = 1024*2;
			AssertNonZero(m_pProgress->SetInteger(ProgressData::imdSubclass,      ProgressData::iscMasterReset));
			AssertNonZero(m_pProgress->SetInteger(ProgressData::imdProgressTotal, m_cTotalTicks));
			AssertNonZero(m_pProgress->SetInteger(ProgressData::imdDirection,     ProgressData::ipdForward));
			if(g_MessageContext.Invoke(imtProgress, m_pProgress) == imsCancel)
				return E_ABORT;
		}
		// fall through
	case BINDSTATUS_DOWNLOADINGDATA:
		{
		// calculate our percentage completed. if it's less than last time then don't move the 
		// progress bar.
		int cProgress = 0;
		int cIncrement = 0;

		if (m_cTotalTicks)
		{
			cProgress = MulDiv(ulProgress, m_cTotalTicks, ulProgressMax);
			cIncrement = cProgress - m_cTicksSoFar;
			if (cIncrement < 0)
				cIncrement = 0;
		}

		m_cTicksSoFar = cProgress;
		AssertNonZero(m_pProgress->SetInteger(ProgressData::imdSubclass,  ProgressData::iscProgressReport));
		AssertNonZero(m_pProgress->SetInteger(ProgressData::imdIncrement, cIncrement));
		if(g_MessageContext.Invoke(imtProgress, m_pProgress) == imsCancel)
			return E_ABORT;
		}
		break;
	case BINDSTATUS_ENDDOWNLOADDATA:
		// Send any remaining progress
		int cLeftOverTicks = m_cTotalTicks - m_cTicksSoFar;
		if (0 > cLeftOverTicks) 
			cLeftOverTicks = 0;

		AssertNonZero(m_pProgress->SetInteger(ProgressData::imdSubclass,  ProgressData::iscProgressReport));
		AssertNonZero(m_pProgress->SetInteger(ProgressData::imdIncrement, cLeftOverTicks));
		if(g_MessageContext.Invoke(imtProgress, m_pProgress) == imsCancel)
			return E_ABORT;

		if (m_fResetProgress)
		{
			// Reset progress bar
			AssertNonZero(m_pProgress->SetInteger(ProgressData::imdSubclass,      ProgressData::iscMasterReset));
			AssertNonZero(m_pProgress->SetInteger(ProgressData::imdProgressTotal, 0));
			AssertNonZero(m_pProgress->SetInteger(ProgressData::imdDirection,     ProgressData::ipdForward));
			if(g_MessageContext.Invoke(imtProgress, m_pProgress) == imsCancel)
				return E_ABORT;
		}
		break;
	}
	return S_OK;
}

HRESULT CMsiBindStatusCallback::QueryInterface(const IID& riid, void** ppvObj)
{
	if (!ppvObj)
		return E_INVALIDARG;

	if (MsGuidEqual(riid, IID_IUnknown)
	 || MsGuidEqual(riid, IID_IBindStatusCallback))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CMsiBindStatusCallback::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiBindStatusCallback::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

//+--------------------------------------------------------------------------
//
//  Function:	UrlMonDownloadUrlFile
//
//  Synopsis:	URL file downloaded using URLMON
//
//---------------------------------------------------------------------------
DWORD UrlMonDownloadUrlFile(const ICHAR* szUrl, const IMsiString *&rpistrPackagePath, int cTicks)
{
	AssertSz(!MinimumPlatformWindowsDotNETServer(), "URLMON used for internet downloads! Should be WinHttp!");

	CTempBuffer<ICHAR, 1> rgchPackagePath(cchExpectedMaxPath + 1);

	Assert(cchExpectedMaxPath >= MAX_PATH);
	DEBUGMSG("Package path is a URL. Downloading package.");
	// Cache the database locally, and run from that.

	// The returned path is a local path.  Max path should adequately cover it.
	HRESULT hResult = URLMON::URLDownloadToCacheFile(NULL, szUrl, rgchPackagePath,  
																	 URLOSTRM_USECACHEDCOPY, 0, &CMsiBindStatusCallback(cTicks));

	if (SUCCEEDED(hResult))
	{
		MsiString((ICHAR*) rgchPackagePath).ReturnArg(rpistrPackagePath);
		return ERROR_SUCCESS;
	}

	// else failure
	rpistrPackagePath = &g_MsiStringNull;

	if (E_ABORT == hResult)
		return ERROR_INSTALL_USEREXIT;
	else if (E_OUTOFMEMORY == hResult)
		return ERROR_OUTOFMEMORY;
	else
		return ERROR_FILE_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\_camgr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       _camgr.h
//
//--------------------------------------------------------------------------

//
// The CustomActionManager is responsible for managing the states
// of all custom action servers. This includes interfaces, watching
// for unexpected termination, etc.
//

#include "common.h"
#include "iconfig.h"

class CMsiRemoteAPI;
class CMsiCustomActionManager
{
public:
	CMsiCustomActionManager(bool fRemapHKCU);
	~CMsiCustomActionManager();

	bool EnsureHKCUKeyMappingState(bool fRemapHKCU);
	bool FindAndValidateContextFromCallerPID(icacCustomActionContext *picacContext) const;
	
	HRESULT RunCustomAction(icacCustomActionContext icacContext, const ICHAR* szPath, const ICHAR* szEntryPoint, 
		MSIHANDLE hInstall, bool fDebugBreak, bool fDisableMessages, bool fAppCompat, const GUID* pguidAppCompatDB, 
		const GUID* pguidAppCompatID, IMsiMessage& riMessage, const ICHAR* szAction, unsigned long* pulRet);
	HRESULT RunScriptAction(icacCustomActionContext icacContext, int icaType, IDispatch* piDispatch, 
		const ICHAR* szSource, const ICHAR *szTarget, LANGID iLangId, bool fDisableMessages, DWORD dwLaunchingThread,
		int* iScriptResult, IMsiRecord **pMSIReturn);
	UINT ShutdownCustomActionServer();

	HRESULT QueryPathOfRegTypeLib(REFGUID guid, unsigned short wVerMajor,
										unsigned short wVerMinor, LCID lcid,
										OLECHAR *lpszPathName, int cchPath);
	HRESULT ProcessTypeLibrary(const OLECHAR* szLibID, LCID lcidLocale, 
										const OLECHAR* szTypeLib, const OLECHAR* szHelpPath, 
										int fRemove, int *fInfoMismatch);
	BOOL SQLInstallDriverEx(int cDrvLen, const ICHAR* szDriver, const ICHAR* szPathIn, 
										ICHAR* szPathOut, WORD cbPathOutMax, WORD* pcbPathOut,
										WORD fRequest, DWORD* pdwUsageCount);
	BOOL SQLConfigDriver(WORD fRequest,
										const ICHAR* szDriver, const ICHAR* szArgs,
										ICHAR* szMsg, WORD cbMsgMax, WORD* pcbMsgOut);
	BOOL SQLRemoveDriver(const ICHAR* szDriver, int fRemoveDSN, DWORD* pdwUsageCount);
	BOOL SQLInstallTranslatorEx(int cTraLen, const ICHAR* szTranslator, const ICHAR* szPathIn,
										ICHAR* szPathOut, WORD cbPathOutMax, WORD* pcbPathOut,
										WORD fRequest, DWORD* pdwUsageCount);
	BOOL SQLRemoveTranslator(const ICHAR* szTranslator, DWORD* pdwUsageCount);
	BOOL SQLConfigDataSource(WORD fRequest, const ICHAR* szDriver,
										const ICHAR* szAttributes, DWORD cbAttrSize);
	BOOL SQLInstallDriverManager(ICHAR* szPath, WORD cbPathMax, WORD* pcbPathOut);
	BOOL SQLRemoveDriverManager(DWORD* pdwUsageCount);
	short SQLInstallerError(WORD iError, DWORD* pfErrorCode, ICHAR* szErrorMsg,
										WORD cbErrorMsgMax, WORD* pcbErrorMsg);

private:
	// custom action server information
	struct {
		HANDLE         hServerProcess;
		DWORD          dwGITCookie;
		DWORD          dwServerProcess;
	} m_CustomActionInfo[icacNext];

	CRITICAL_SECTION  m_csCreateProxy;

	CMsiRemoteAPI*    m_pRemoteAPI;
	HANDLE            m_hRemoteAPIEvent;
	DWORD             m_dwRemoteAPIThread;
	HANDLE            m_hRemoteAPIThread;
	IGlobalInterfaceTable* m_piGIT;
	bool              m_fRemapHKCU;
	
	IMsiCustomAction *GetCustomActionInterface(bool fCreate, icacCustomActionContext icacContext);

	// shuts down a specific CA server by context
	void ShutdownSpecificCustomActionServer(icacCustomActionContext iContext);

	// pumps messages while waiting for the thread to die or signal
	bool MsgWaitForThreadOrEvent();

	// thread proc for RemoteAPI
	static DWORD WINAPI CustomActionManagerThread(CMsiCustomActionManager *pThis);

	icacCustomActionContext m_icacCreateContext;
	HANDLE            m_hCreateEvent;

	DWORD WINAPI CMsiCustomActionManager::CreateAndRegisterInterface(icacCustomActionContext icacDesiredContext);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\_databas.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       _databas.h
//
//--------------------------------------------------------------------------

/* _databas.h - private header for database implementation
____________________________________________________________________________*/

#ifndef __DATABAS
#define __DATABAS
#include "_service.h"

#define STD_IDENTIFIER_QUOTE_CHAR '`'  // character used in ViewQuery table

// reserved names for system streams
const ICHAR szMsiInfo[]          = TEXT("\005SummaryProperties");
const ICHAR szStringPool[]       = TEXT("_StringPool");
const ICHAR szStringData[]       = TEXT("_StringData");
const ICHAR szTableCatalog[]     = TEXT("_Tables");
const ICHAR szColumnCatalog[]    = TEXT("_Columns");
const ICHAR szTransformCatalog[] = TEXT("_Transforms");
const ICHAR szStreamCatalog[]    = TEXT("_Streams");
const ICHAR szStorageCatalog[]   = TEXT("_Storages");

const int iCatalogStreamFlag = 2;  // internal use with CMsiStorage::RemoveElement, CEnumStorage

// local factories exposed within this DLL
class CMsiDatabase;
class CScriptView;
CMsiDatabase* CreateODBCDatabase(IMsiServices& riServices);
IMsiRecord* CreateMsiView(CMsiDatabase& riDatabase, IMsiServices& m_riServices, const ICHAR* szQuery, ivcEnum ivcIntent,IMsiView*& rpiView);
const IMsiString& CreateStringComRef(const ICHAR& sz, unsigned int cbSize, const IUnknown& riOwner);

//____________________________________________________________________________
//
// Validation requirements
//____________________________________________________________________________

// Source directory table column names -- required in 'DefaultDir' validation
const ICHAR szsdtcSourceDir[] = TEXT("SourceDir");
const ICHAR szsdtcSourceParentDir[] = TEXT("SourceParentDir");

// Language column names
const ICHAR sztcLanguage[] = TEXT("Language");
const ICHAR szmdtcLanguage[] = TEXT("RequiredLanguage"); // ModuleDependency
const ICHAR szmetcLanguage[] = TEXT("ExcludedLanguage"); // ModuleExclusion

// Custom Action table column names -- required in foreign key validation of 'CustomAction' table
const ICHAR szcatcType[]         = TEXT("Type");

// Validation table Category strings -- determine how to validate string
const ICHAR szText[]                = TEXT("Text");
const ICHAR szFormatted[]           = TEXT("Formatted");
const ICHAR szTemplate[]            = TEXT("Template");
const ICHAR szCondition[]           = TEXT("Condition");
const ICHAR szGuid[]                = TEXT("Guid");
const ICHAR szPath[]                = TEXT("Path");
const ICHAR szPaths[]               = TEXT("Paths");
const ICHAR szAnyPath[]             = TEXT("AnyPath");
const ICHAR szFilename[]            = TEXT("Filename");
const ICHAR szWildCardFilename[]    = TEXT("WildCardFilename");
const ICHAR szVersion[]             = TEXT("Version");
const ICHAR szLanguage[]            = TEXT("Language");
const ICHAR szIdentifier[]          = TEXT("Identifier");
const ICHAR szBinary[]              = TEXT("Binary");
const ICHAR szUpperCase[]           = TEXT("UpperCase");
const ICHAR szLowerCase[]           = TEXT("LowerCase");
const ICHAR szKeyFormatted[]        = TEXT("KeyFormatted");
const ICHAR szDefaultDir[]          = TEXT("DefaultDir");
const ICHAR szRegPath[]             = TEXT("RegPath");
const ICHAR szCustomSource[]        = TEXT("CustomSource");
const ICHAR szProperty[]            = TEXT("Property");
const ICHAR szCabinet[]             = TEXT("Cabinet");
const ICHAR szShortcut[]            = TEXT("Shortcut");
const ICHAR szURL[]                 = TEXT("URL");

//____________________________________________________________________________
//
// Cursor / table definitions
//____________________________________________________________________________

typedef unsigned int   MsiTableData;   // type of loaded database table element
typedef unsigned int   MsiColumnMask;  // bit array of column attributes
typedef unsigned short MsiColumnDef;  // internal column definition as stored in array

// temporary remapping until old use of itsEnum removed
enum ictsEnum  // table catalog status update options, stored in catalog table row status
{
    ictsPermanent       = itsPermanent  ,  // 0 table has persistent columns
    ictsTemporary       = itsTemporary  ,  // 1 temporary table, no persistent columns
    ictsTableExists     = itsTableExists,  // 2 read-only, table currently defined in system catalog
    ictsDataLoaded      = itsDataLoaded ,  // 3 read-only, table currently present in memory, address is in catalog
    ictsUserClear       = itsUserClear  ,  // 4 state flag reset, not used internally
    ictsUserSet         = itsUserSet    ,  // 5 state flag set, not used internally
    ictsOutputDb        = itsOutputDb   ,  // 6 persistence transferred to output database, cleared by ictsNotSaved
    ictsSaveError       = itsSaveError  ,  // 7 error saving table, will return at Commit()
    ictsUnlockTable     = itsUnlockTable,  // 8 release lock count on table, or test if unlocked
    ictsLockTable       = itsLockTable  ,  // 9 lock count set on table (refcnt actually kept internally)
    ictsTransform       = itsTransform  ,  //10 table needs to be transformed when first loaded
    ictsStringPoolSet   = 11,              // string indices must be changed from 2 to 3
    ictsStringPoolClear = 12,              // clear string pool state flag
    ictsNoTransform     = 13,              // internal only for clearing bit
    ictsNoSaveError     = 14,              // internal only for clearing bit
    ictsTransformDone   = 15,              // internal only for setting read-only transform
};

//____________________________________________________________________________
//
// CMsiDatabase definitions - used ONLY by CMsiDatabase, CMsiTable, CMsiRow, CMsiView
//____________________________________________________________________________

class CMsiTable;
class IMsiStorage;
class CCatalogTable;
class CStreamTable;
class CStorageTable;
struct MsiCacheLink;
class CTransformStreamWrite;
class CTransformStreamRead;

typedef int MsiCacheIndex; // internal cache index, negative if hash bin
typedef unsigned short MsiCacheRefCnt; // internal ref count for cache usage

const int iIntegerDataOffset = iMsiNullInteger;  // integer table data offset
const int iPersistentStream = 1; // reserved address for non-null, unloaded stream
const int iMaxStreamId = 255; // avoid actual address space

const int icdInternalFlag = 1 << 15; // used to temporarily flag column definitions

enum TableCatalogColumnsEnum
{
    ctcName  = 1, // MsiStringId
    ctcTable = 2, // IMsiTable*
    ctcPersistent = 1
};

enum ColumnCatalogColumnsEnum
{
    cccTable  = 1, // MsiStringId
    cccColumn = 2, // int, 1-origin
    cccName   = 3, // MsiStringId
    cccType   = 4, // int, its + itc + itd + itw
    cccPersistent = 4
};

enum TransformCatalogColumns
{
    tccID        = 1, // int
    tccTransform = 2, // MsiStorage
    tccErrors    = 3, // short
};

enum StreamCatalogColumns
{
    tscName = 1, // MsiStringId
    tscData = 2, // IMsiStream* or iPersistentStream
};

const int iNumMergeErrorCol = 3;

class CMsiDatabase : public IMsiDatabase // common implementation class
{
 public: // implemented virtual functions
    IMsiServices& __stdcall GetServices();
    HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();
    IMsiRecord*   __stdcall OpenView(const ICHAR* szQuery, ivcEnum ivcIntent,
                                                IMsiView*& rpiView);
    IMsiRecord*  __stdcall GetPrimaryKeys(const ICHAR* szTable);
    IMsiRecord*  __stdcall ImportTable(IMsiPath& riPath, const ICHAR* szFile);
    IMsiRecord*  __stdcall ExportTable(const ICHAR* szTable, IMsiPath& riPath, const ICHAR* szFile);
    IMsiRecord*  __stdcall DropTable(const ICHAR* szName);
    itsEnum      __stdcall FindTable(const IMsiString& ristrTable);
    IMsiRecord*  __stdcall LoadTable(const IMsiString& ristrTable,
                                                unsigned int cAddColumns,
                                                IMsiTable*& riTable);
    IMsiRecord*  __stdcall CreateTable(const IMsiString& ristrTable,
                                                  unsigned int cAddColumns,
                                                  IMsiTable*& riTable);
    Bool         __stdcall LockTable(const IMsiString& ristrTable, Bool fLock);
    IMsiTable*   __stdcall GetCatalogTable(int iTable);
    const IMsiString&  __stdcall DecodeString(MsiStringId iString);
    MsiStringId  __stdcall EncodeStringSz(const ICHAR* riString);
    MsiStringId  __stdcall EncodeString(const IMsiString& riString);
    const IMsiString&  __stdcall CreateTempTableName();
    IMsiRecord*  __stdcall CreateOutputDatabase(const ICHAR* szFile, Bool fSaveTempRows);
    IMsiRecord*  __stdcall Commit();
    idsEnum      __stdcall GetUpdateState();
    IMsiStorage* __stdcall GetStorage(int iStorage); // 0:Output 1:Input >:Transform
    IMsiRecord*  __stdcall GenerateTransform(IMsiDatabase& riReference, IMsiStorage* piTransform,
                                  int iErrorConditions, int iValidation);
    IMsiRecord*  __stdcall SetTransform(IMsiStorage& riTransform, int iErrors);
    IMsiRecord*  __stdcall SetTransformEx(IMsiStorage& riTransform, int iErrors,
														const ICHAR* szViewTable,
														IMsiRecord* piViewTheseTablesOnlyRecord);
    IMsiRecord*  __stdcall MergeDatabase(IMsiDatabase& riReference, IMsiTable* pErrorTable);
    bool         __stdcall GetTableState(const ICHAR * szTable, itsEnum its);
    int          __stdcall GetANSICodePage();  // returns 0 if codepage neutral
#ifdef USE_OBJECT_POOL
    void         __stdcall RemoveObjectData(int iIndex);
#endif //USE_OBJECT_POOL

 public: // available only to CMsiTable, CMsiCursor, CMsiView
    MsiStringId  BindString(const IMsiString& riString);      // adds refcount
    void         BindStringIndex(MsiStringId iString); // adds refcount
    void         UnbindStringIndex(MsiStringId iString); // removes ref
    void         DerefTemporaryString(MsiStringId iString); // release non-persistent refs
    const IMsiString&  DecodeStringNoRef(MsiStringId iString); // no addref, no bounds check
    MsiStringId  MaxStringIndex(); // return highest string index used
    void         TableReleased(MsiStringId iName);  // table destruction
    bool         SetTableState(MsiStringId iName, ictsEnum icts); // table must exist
    bool         GetTableState(MsiStringId iName, ictsEnum icts); // table must exist
    IMsiCursor*  GetColumnCursor(); // no addref on returned pointer
    IMsiStorage* GetOutputStorage(); // no addref on returned pointer
    IMsiStorage* GetCurrentStorage(); // no addref on returned pointer
    int          GetStringIndexSize(); // accessor for m_cbStringIndex
    const IMsiString&  ComputeStreamName(const IMsiString& riTableName, MsiTableData* pData, MsiColumnDef* pColumnDef);
    void         AddTableCount();    // called only from CCatalogCursor
    void         RemoveTableCount(); // called only from CCatalogCursor
    IMsiStorage* GetTransformStorage(unsigned int iStorage);
    Bool         LockIfNotPersisted(MsiStringId iTable);
    CMsiTable**  GetNonCatalogTableListHead(); // get the list of non catalog tables
    void         StreamTableReleased();  // accessor for m_piCatalogStreams
    void         StorageTableReleased(); // accessor for m_piCatalogStorages
    inline void  Block()        // prevent access by other threads
                                    {WIN::EnterCriticalSection(&m_csBlock); };
    inline void  Unblock()      // unblock access by other threads
                                    {WIN::LeaveCriticalSection(&m_csBlock); };
 public: //  constructor/destructor/open, called from database factory
    CMsiDatabase(IMsiServices& riServices);
    IMsiRecord* OpenDatabase(const ICHAR* szDataSource, idoEnum idoOpenMode);
    IMsiRecord* OpenDatabase(IMsiStorage& riStorage, Bool fReadOnly);
    void* operator new(size_t cb);
    void  operator delete(void * pv);
 protected:
    virtual ~CMsiDatabase();  // protected to prevent creation on stack
 public:
    IMsiRecord*  PostError(IErrorCode iErr, const IMsiString& istr);
    IMsiRecord*  PostError(IErrorCode iErr, const ICHAR* szText1=0, const ICHAR* szText2=0);
    IMsiRecord*  PostError(IErrorCode iErr, int iCol);
    IMsiRecord*  PostError(IErrorCode iErr, const IMsiString& istr, int iCol);
    IMsiRecord*  PostError(IErrorCode iErr, const ICHAR* szText, int iCol);
    IMsiRecord*  PostError(IErrorCode iErr, int i1, int i2);
    IMsiRecord*  PostOutOfMemory();
 protected:  // functions callable by this or derived classes
    IMsiRecord*  CreateSystemTables(IMsiStorage* piStorage, idoEnum idoOpenMode);
    IMsiRecord*  InitStringCache(IMsiStorage* piStorage);
    IMsiRecord*  StoreStringCache(IMsiStorage& riStorage, MsiCacheRefCnt* rgRefCntTemp, int cRefCntTemp);
    Bool         LoadSystemTables(IMsiStorage& riStorage);
    IMsiRecord*  TransformTableCatalog(IMsiStorage& riTransform, CMsiDatabase& riTransDb, int iErrors);
    IMsiRecord*  TransformColumnCatalog(IMsiStorage& riTransform, CMsiDatabase& riTransDb, int iErrors);
    IMsiRecord*  TransformTable(MsiStringId iTableName, CMsiTable& riTable,
                                        IMsiStorage& riTransform, CMsiDatabase& riTransDb, int iCurTransId, int iErrors);
    IMsiRecord*  TransformCompareTables(const IMsiString& riTableName, IMsiDatabase& riBaseDb,
                                                    IMsiDatabase& riRefDb, CMsiDatabase& riTransDb,
                                                    IMsiStorage* piTransform,
                                                    CTransformStreamWrite& tswColumns,
                                                    Bool& fTablesAreDifferent);
    IMsiRecord*  CompareRows(CTransformStreamWrite& tswTable, IMsiCursor& riBaseCursor,
                                                  IMsiCursor& riRefCursor,
                                                  IMsiDatabase& riRefDb,
                                                  int& iMask, IMsiStorage* piTransform);
    IMsiRecord*  ApplyTransforms(MsiStringId iTableName, CMsiTable& riTable, int iState);
    IMsiRecord*  CreateTransformSummaryStream(IMsiStorage& riBaseStorage,
                                                      IMsiStorage& riRefStorage,
                                                      IMsiStorage& riTransStorage,
                                                      int iValidation,
                                                      int iErrorConditions);
    IMsiRecord*  AddMarkingColumn(IMsiTable& riTable, IMsiCursor& riTableCursor, int& iTempCol);
    Bool         CompareTableName(IMsiCursor& riCursor, int iTempCol);
    IMsiRecord*  MergeCompareTables(const IMsiString& riTableName, CMsiDatabase& riBaseDB,
                                    IMsiDatabase& riRefDb, int& cRowMergeFailures,
                                    Bool& fSetupMergeErrorTable, IMsiTable* pErrorTable);
    IMsiRecord*  CheckTableProperties(int& cExtraColumns, int& cBaseColumn, int& cPrimaryKey,
                                        IMsiTable& riBaseTable, IMsiTable& riRefTable,
                                        const IMsiString& riTableName, IMsiDatabase& riBaseDb,
                                        IMsiDatabase& riRefDb);
    void         MergeOperation(IMsiCursor& riBaseCursor, IMsiCursor& riRefCursor,
                                IMsiTable& riRefTable, int cColumn, int& cRowMergeErrors);
    void         MergeErrorTableSetup(IMsiTable& riErrorTable);
    Bool         UpdateMergeErrorTable(IMsiTable& riErrorTable, const IMsiString& riTableName,
                                        int cRowMergeFailures, IMsiTable& riTableWithError);
    IMsiRecord* SetCodePageFromTransform(int iCodePage, int iErrors);
    IMsiRecord* CreateTransformStringPool(IMsiStorage& riTransform, CMsiDatabase*& pDatabase);
    IMsiRecord* ViewTransform(IMsiStorage& riTransform, int iErrors,
										const ICHAR* szTransformViewTableName,
										IMsiRecord* piTheseTablesOnlyRec);
 protected: //  state data used by derived classes
    IMsiServices& m_riServices;
    const IMsiString*  m_piDatabaseName; // never null, need pointer for string ops
    CCatalogTable* m_piCatalogTables;  // table of tables
    CCatalogTable* m_piCatalogColumns; // table of columns
    CStreamTable*  m_piCatalogStreams; // table of streams
    CStorageTable* m_piCatalogStorages;// table of storages
    IMsiCursor*  m_piTableCursor;  // cursor to table table
    IMsiCursor*  m_piColumnCursor; // cursor to column table
    idsEnum      m_idsUpdate;   // update state of the database
    IMsiStorage* m_piStorage;   // persistent file object
    IMsiStorage* m_piOutput;    // persistent file ouput storage
    Bool         m_fSaveTempRows;// temp rows kept in output database file
    CMsiTable*   m_piTransformCatalog; // table of transforms
    int          m_iCodePage;    // ANSI codepage used for Unicode translations
    CMsiTable*   m_piTables;   // linked list of non catalog tables
    const GUID*  m_pguidClass;  // storage class ID
    Bool         m_fRawStreamNames;  // compatibility mode, no stream compression
 private: //  state data private to CMsiDatabase
    CMsiRef<iidMsiDatabase>     m_Ref;     // COM external reference count
    int          m_iTableCnt;   // tables holding database references
    MsiCacheRefCnt* m_rgiCacheTempRefCnt; // used and computed during persistence
    CRITICAL_SECTION m_csBlock;   // serialization of data access
 private: //  string cache data
    unsigned int HashString(const ICHAR* sz, int& iLen);
    unsigned int FindString(int iLen, int iHash, const ICHAR* sz);
    HGLOBAL      m_hCache;      // memory handle to moveable cache
    MsiCacheLink*   m_rgCacheLink;   // pointer to string cache
    MsiCacheRefCnt* m_rgCacheRefCnt; // string cache ref count array
    int             m_cbStringIndex; // persistent size of string indices
    int             m_iDatabaseOptions; // database options from string pool header
    MsiCacheIndex* m_rgHash;    // string hash bucket array
    int          m_cHashBins;   // number of string hash bins, power or 2
    int          m_cCacheInit;  // intial size of string cache array
    int          m_cCacheTotal; // size of string cache array in structs
    int          m_cCacheUsed;  // number of used cache entries
    unsigned int m_iFreeLink;   // index of first free string cache link
 protected: // data used for transforming
    int           m_iLastTransId; // the last used transform ID
 protected: // data used for merging
     int              m_rgiMergeErrorCol[iNumMergeErrorCol]; // error columns
 private: // eliminate warning: assignment operator could not be generated
    void operator =(const CMsiDatabase&){}
 friend class CTransformStreamWrite;
};

inline IMsiCursor* CMsiDatabase::GetColumnCursor() {return m_piColumnCursor;}
inline IMsiStorage* CMsiDatabase::GetOutputStorage()
    {return m_idsUpdate == idsWrite ? (m_piOutput ? m_piOutput : m_piStorage) : 0;}
inline IMsiStorage* CMsiDatabase::GetCurrentStorage()
    {return (m_piOutput ? m_piOutput : m_piStorage);}
inline int CMsiDatabase::GetStringIndexSize() {return m_cbStringIndex;}
inline void CMsiDatabase::AddTableCount() {m_iTableCnt++;}
inline void CMsiDatabase::RemoveTableCount() {m_iTableCnt--;}
inline void* CMsiDatabase::operator new(size_t cb)
    {void* pv = AllocObject(cb); if (pv) memset(pv, 0, cb); return pv;}
inline void  CMsiDatabase::operator delete(void * pv) { FreeObject(pv); }
inline CMsiTable** CMsiDatabase::GetNonCatalogTableListHead() {return &m_piTables;}
inline void CMsiDatabase::StreamTableReleased() {m_piCatalogStreams = 0; --m_iTableCnt;}
inline void CMsiDatabase::StorageTableReleased(){m_piCatalogStorages = 0; --m_iTableCnt;}

inline void CMsiDatabase::BindStringIndex(MsiStringId iString)
{
    if (iString >= m_cCacheUsed)
    {
        AssertSz(0, "Database string pool is corrupted.");
        DEBUGMSGV("Database string pool is corrupted.");
        return;
    }
    if (iString != 0)
    {
        ++m_rgCacheRefCnt[iString];
        AssertSz(m_rgCacheRefCnt[iString] != 0, "Refcounts wrapped, all bets are off");
    }
}

class CDatabaseBlock
{
 public:
    inline CDatabaseBlock(CMsiDatabase& riDatabase) : m_riDatabase(riDatabase) { riDatabase.Block(); };
    inline ~CDatabaseBlock() { m_riDatabase.Unblock(); };
 private:
    CMsiDatabase& m_riDatabase;
 };

// NOTE: m_piTableCursor must be left in a reset state to allow tables to be released.
//       This does not apply to m_piColumnCursor, which may be left pointing to any row.

//____________________________________________________________________________
//
// CMsiTable row header definitions, stored as column[0] in data array
//____________________________________________________________________________

const int iTreeLinkBits   = 16;  // bits holding row number of next link, low order
const int iTreeLevelBits  = 8;   // bits holding row number of next link, must shift
const int iTreeLinkMask   = (1 << iTreeLinkBits) - 1;  // row number of next link
const int iTreeLevelMask  = (1 << iTreeLevelBits) - 1; // tree level after shift right
const int iTreeInfoMask   = (1 << (iTreeLinkBits + iTreeLevelBits)) - 1; // all tree bits

const int iRowBitShift = iTreeLinkBits + iTreeLevelBits;
const int iRowTemporaryBit  = 1 << (iRowBitShift+iraTemporary);  // no persistent columns
const int iRowUserInfoBit   = 1 << (iRowBitShift+iraUserInfo);   // for external use
const int iRowModifiedBit   = 1 << (iRowBitShift+iraModified);   // row has been updated
const int iRowInsertedBit   = 1 << (iRowBitShift+iraInserted);   // row has been inserted
const int iRowMergeFailedBit= 1 << (iRowBitShift+iraMergeFailed);// non-identical non-key data
const int iRowReserved5Bit  = 1 << (iRowBitShift+iraReserved5);  // future use (used by _Tables table)
const int iRowReserved6Bit  = 1 << (iRowBitShift+iraReserved6);  // future use (used by _Tables table)
const int iRowReserved7Bit  = 1 << (iRowBitShift+iraReserved7);  // future use (used by _Tables table)

const int iRowSettableBits = ((1<<iraSettableCount)-1) << iRowBitShift;  // settable bit mask
const int iRowGettableBits = ((1<<iraTotalCount)-1) << iRowBitShift;  // gettable bit mask

// additional row status definitions for table catalog only
const int iRowTableLockCountMask = iTreeLinkMask;  // reuses tree link for lock count
const int iRowTableTransformMask = iTreeLevelMask; // reuses tree level for transform count
const int iRowTableTransformOffset = iTreeLinkBits;

const int iRowTableSaveErrorBit  = iRowMergeFailedBit;   // unsuccessful table persist
const int iRowTableOutputDbBit   = iRowReserved5Bit;     // written to output database
const int iRowTableStringPoolBit = iRowReserved6Bit;     // need to expand string indices
const int iRowTableTransformBit  = iRowReserved7Bit;     // need to transform (optimization)
//const int iRowTableTransformedBit= 1 << iTreeLinkBits + 3;   // read-only table transformed

//____________________________________________________________________________
//
// CScriptDatabase declaration
//____________________________________________________________________________


class CScriptDatabase : public IMsiDatabase {
 public:
    CScriptDatabase(IMsiServices& riServices);
    HRESULT       __stdcall QueryInterface(const IID& /*riid*/, void** /*ppvObj*/){return 0; };
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();
     IMsiServices& __stdcall GetServices();
     IMsiRecord* __stdcall OpenView(const ICHAR* szQuery, ivcEnum ivcIntent,
                                                        IMsiView*& rpiView);
     IMsiRecord* __stdcall GetPrimaryKeys(const ICHAR* /*szTable*/) {return 0; };
     IMsiRecord* __stdcall ImportTable(IMsiPath& /*riPath*/, const ICHAR* /*szFile*/) {return 0;};
     IMsiRecord* __stdcall ExportTable(const ICHAR* /*szTable*/, IMsiPath& /*riPath*/, const ICHAR* /*szFile*/) {return 0;};
     IMsiRecord* __stdcall DropTable(const ICHAR* /*szName*/) {return 0;};
     itsEnum     __stdcall FindTable(const IMsiString& /*ristrTable*/) {return itsUnknown;};/*OBSOLETE*/
     IMsiRecord* __stdcall LoadTable(const IMsiString& /*ristrTable*/,
                                                         unsigned int /*cAddColumns*/,
                                                         IMsiTable*& /*rpiTable*/) {return 0;};
     IMsiRecord* __stdcall CreateTable(const IMsiString& /*ristrTable*/,
                                                           unsigned int /*cInitRows*/,
                                                           IMsiTable*& /*rpiTable*/) {return 0;};
     Bool         __stdcall LockTable(const IMsiString& /*ristrTable*/, Bool /*fLock*/) {return fTrue;};
     IMsiTable*   __stdcall GetCatalogTable(int /*iTable*/) {return 0;};
     const IMsiString& __stdcall DecodeString(MsiStringId iString);
     MsiStringId  __stdcall EncodeStringSz(const ICHAR* /*riString*/) {return 0;};
     MsiStringId  __stdcall EncodeString(const IMsiString& /*riString*/) {return 0;};
     const IMsiString& __stdcall CreateTempTableName();
     IMsiRecord*  __stdcall CreateOutputDatabase(const ICHAR* /*szFile*/, Bool /*fSaveTempRows*/) {return 0;};
     IMsiRecord*  __stdcall Commit(/**/) {return 0;};
     idsEnum      __stdcall GetUpdateState(/**/) {return idsRead;};
     IMsiStorage* __stdcall GetStorage(int /*iStorage*/) {return 0;}; // 0:Output 1:Input >:Transform
     IMsiRecord*  __stdcall GenerateTransform(IMsiDatabase& /*riReference*/,
                                             IMsiStorage* /*piTransform*/,
                                             int /*iErrorConditions*/,
                                             int /*iValidation*/) {return 0;};
     IMsiRecord*  __stdcall SetTransform(IMsiStorage& /*riTransform*/, int /*iErrors*/) {return 0;};
     IMsiRecord*  __stdcall SetTransformEx(IMsiStorage& /*riTransform*/, int /*iErrors*/,
														 const ICHAR* /*szViewTable*/,
														 IMsiRecord* /*piViewTheseTablesOnlyRecord*/) {return 0;};
     IMsiRecord*  __stdcall MergeDatabase(IMsiDatabase& /*riReference*/, IMsiTable* /*pErrorTable*/) {return 0;};
     bool         __stdcall GetTableState(const ICHAR * /*szTable*/, itsEnum /*its*/) {return false;}
     int          __stdcall GetANSICodePage() {return 0;}

#ifdef USE_OBJECT_POOL
    void         __stdcall RemoveObjectData(int iIndex);
#endif //USE_OBJECT_POOL
     IMsiRecord* OpenDatabase(const ICHAR* szDataSource);

    void* operator new(size_t cb);
    void  operator delete(void * pv);

 protected:
  ~CScriptDatabase();  // protected to prevent creation on stack
 private:
    void operator =(const CScriptDatabase&){}
    CMsiRef<iidMsiDatabase>     m_Ref;     // COM external reference count
 protected:
        IMsiServices&      m_riServices;
        CScriptView*       m_piView;
        //ICHAR szFileName[MAX_PATH];
        const IMsiString*  m_piName;


};

inline void* CScriptDatabase::operator new(size_t cb) {return AllocObject(cb);}
inline void  CScriptDatabase::operator delete(void * pv) { FreeObject(pv); }



//____________________________________________________________________________
//
// CMsiTable, CMsiCursor definitions
//____________________________________________________________________________

// special value passed to constructor's AddColumns arg to avoid catalog management
const unsigned int iNonCatalog = 0xde10;

class CMsiCursor;

class CMsiTable : public IMsiTable
{
 public: // implemented virtual functions
    HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();
    const IMsiString&   __stdcall GetMsiStringValue() const;
    int           __stdcall GetIntegerValue() const;
#ifdef USE_OBJECT_POOL
    unsigned int  __stdcall GetUniqueId() const;
    void          __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
    IMsiDatabase& __stdcall GetDatabase();
    unsigned int  __stdcall GetRowCount();
    unsigned int  __stdcall GetColumnCount();
    unsigned int  __stdcall GetPrimaryKeyCount();
    Bool          __stdcall IsReadOnly();
    unsigned int  __stdcall GetColumnIndex(MsiStringId iColumnName);
    MsiStringId   __stdcall GetColumnName(unsigned int iColumn);
    int           __stdcall GetColumnType(unsigned int iColumn);
    int           __stdcall CreateColumn(int iColumnDef, const IMsiString& istrName);
    IMsiCursor*   __stdcall CreateCursor(Bool fTree);
    int           __stdcall LinkTree(unsigned int iParentColumn);
    unsigned int  __stdcall GetPersistentColumnCount();
 public: // constructor/destructor
    void* operator new(size_t cb); // needed to clear object data
    void  operator delete(void * pv);
    CMsiTable(CMsiDatabase& riDatabase, MsiStringId iName, unsigned int cInitRows,
                 unsigned int cAddColumns);
 protected:
  ~CMsiTable();
 public: // methods accessed by CMsiDatabase
    void         SetReadOnly();
    int          CreateColumnsFromCatalog(MsiStringId iName, int cbStringIndex);
    Bool         LoadFromStorage(const IMsiString& riName, IMsiStorage& riStorage, int cbFileWidth, int cbStringIndex);
    Bool         SaveToStorage(const IMsiString& riName, IMsiStorage& riStorage);
    Bool         SaveToSummaryInfo(IMsiStorage& riStorage);
    Bool         FillColumn(unsigned int iColumn, MsiTableData iData);
    void         ClearDirty();
    void         MakeNonCatalog();
    Bool         RemovePersistentStreams(MsiStringId iName, IMsiStorage& riStorage);
    void         DerefStrings();  // release counts from persistent storage
    Bool         SaveIfDirty();
    Bool         ReleaseData();
    void         TableDropped();
    void         SetColumnDef(unsigned int iColumn, MsiColumnDef iColDef); // for ODBC Access hack
    CMsiTable*   GetNextNonCatalogTable();
    bool         HideStrings();  // for reapplying transforms to read-only database
    bool         UnhideStrings();
 public: // private use by CMsiCursor
    MsiColumnDef* GetColumnDefArray();
    int&          GetColumnCountRef();
    CMsiCursor** GetCursorListHead();
    MsiStringId  GetTableName();
    MsiStringId  GetColumnName(int iColumn);
    IMsiStorage* GetInputStorage();
    idsEnum      GetUpdateState();
    Bool         FindNextRow(int& iRow, MsiTableData* pData,
                                     MsiColumnMask fFilter, Bool fTree);
    int          FetchRow(int iRow, MsiTableData* pData); // returns tree level
    Bool         ReplaceRow(int& iRow, MsiTableData* pData);
    Bool         InsertRow(int& iRow, MsiTableData* pData);
    Bool         MatchRow(int& iRow, MsiTableData* pData);
    Bool         DeleteRow(int iRow);
    Bool         FindKey(int& iCursorRow, MsiTableData* pData);
    Bool         RenameStream(unsigned int iCurrentRow, MsiTableData* pData, unsigned int iStreamCol);
 protected: // internal methods
    Bool         AllocateData(int cWidth, int cLength);
    int          LinkParent(int iChildRow, MsiTableData* rgiChild); // recursive
    int*         IndexByTextKey();
    MsiTableData* FindFirstKey(MsiTableData iKeyData, int iRowLower, int& iRowCurrent);
 protected:  // private data, initialized to 0 by new
    CMsiRef<iidMsiTable>       m_Ref;     // COM reference count
    CMsiDatabase& m_riDatabase;  // database, not ref counted
    MsiStringId   m_iName;       // name of this table
    HGLOBAL       m_hData;       // handle to moveable memory block
    MsiTableData* m_rgiData;     // pointer to data array
    Bool          m_fNonCatalog; // temp. table not included in table catalog
    idsEnum       m_idsUpdate;   // update state of the table
    int           m_cColumns;    // total database columns (not counting node link)
    int           m_cWidth;      // number of integers in table row (array width)
    int           m_cAddColumns; // extra columns to allocate at first allocation
    int           m_cPersist;    // persistant column count (left-justified in row)
    IMsiStorage*  m_pinrStorage; // non-refcounted input storage for later comparison
    int           m_cPrimaryKey; // columns comprising primary key (left-justified)
    int           m_iTreeParent; // column number of tree link, 0 if not tree linked
    int           m_iTreeRoot;   // top node of tree traversal, 0 if not tree linked
    int           m_cRows;       // current row count (not including unused rows)
    int           m_cLength;     // length of allocated array in rows
    int           m_cInitRows;   // length of initial allocated array
    CMsiCursor*   m_piCursors;   // linked list of active cursors
    int           m_cLoadColumns;// number of originally oaded columns
    unsigned int  m_fDirty;      // dirty flags for upto 32 columns
    MsiStringId   m_rgiColumnNames[cMsiMaxTableColumns];  // column name indices
    MsiColumnDef  m_rgiColumnDef[1+cMsiMaxTableColumns];  // column definitions
    CMsiTable**   m_ppiPrevTable;// linked list of non catalog table objects for table
    CMsiTable*    m_piNextTable; // linked list of non catalog table objects for table
    Bool          m_fStorages;   // stream objects are persisted as storages
#ifdef USE_OBJECT_POOL
    unsigned int  m_iCacheId;
#endif //USE_OBJECT_POOL
 private: // eliminate warning: assignment operator could not be generated
    void operator =(const CMsiTable&){}
};
inline void* CMsiTable::operator new(size_t cb)
    {void* pv = AllocObject(cb); if (pv) memset(pv, 0, cb); return pv;}
inline void CMsiTable::SetReadOnly() {m_idsUpdate = idsNone;}
inline CMsiCursor** CMsiTable::GetCursorListHead() {return &m_piCursors;}
inline void CMsiTable::ClearDirty() {m_fDirty = 0;}
inline MsiColumnDef* CMsiTable::GetColumnDefArray(){return m_rgiColumnDef;}
inline int& CMsiTable::GetColumnCountRef(){return m_cColumns;}
inline MsiStringId CMsiTable::GetTableName(){return m_iName;}
inline MsiStringId CMsiTable::GetColumnName(int iColumn){return m_rgiColumnNames[iColumn-1];}
inline IMsiStorage* CMsiTable::GetInputStorage(){return m_pinrStorage;}
inline void CMsiTable::MakeNonCatalog(){m_fNonCatalog = fTrue; m_cPersist = 0;}
inline void CMsiTable::SetColumnDef(unsigned int iColumn, MsiColumnDef icd){m_rgiColumnDef[iColumn] = icd;}
inline idsEnum CMsiTable::GetUpdateState() {return m_idsUpdate;}
inline void CMsiTable::operator delete(void * pv) { FreeObject(pv); }
inline CMsiTable* CMsiTable::GetNextNonCatalogTable(){return m_piNextTable;}

class CMsiCursor : public IMsiCursor
{
 public: // implemented virtual functions
    HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();
    IMsiTable&   __stdcall GetTable();
    void         __stdcall Reset();
    int          __stdcall Next();
    unsigned int __stdcall SetFilter(unsigned int fFilter);
    int          __stdcall GetInteger(unsigned int iCol);
    const IMsiString& __stdcall GetString(unsigned int iCol);
    const IMsiData*   __stdcall GetMsiData(unsigned int iCol);
   IMsiStream*  __stdcall GetStream(unsigned int iCol);
    Bool         __stdcall PutInteger(unsigned int iCol, int iData);
    Bool         __stdcall PutString(unsigned int iCol, const IMsiString& riData);
    Bool         __stdcall PutMsiData(unsigned int iCol, const IMsiData* piData);
    Bool         __stdcall PutStream(unsigned int iCol, IMsiStream* piStream);
    Bool         __stdcall PutNull(unsigned int iCol);
    Bool         __stdcall Update(); // replace at new primary key match
    Bool         __stdcall Insert(); // insert new row, ordered by key
    Bool         __stdcall InsertTemporary(); // insert temporary new row
    Bool         __stdcall Assign(); // insert or replace row by key
    Bool         __stdcall Replace();// allow primary key update by delete+insert
    Bool         __stdcall Merge();  // insert or match identically
    Bool         __stdcall Refresh();// refresh current row
    Bool         __stdcall Delete(); // delete at current position
    Bool         __stdcall Seek();   // seek to primary keys, then refresh
    IMsiRecord*  __stdcall Validate(IMsiTable& riValidationTable, IMsiCursor& riValidationCursor, int iCol);
    Bool         __stdcall SetRowState(iraEnum ira, Bool fState); // set/clear row attribute
    Bool         __stdcall GetRowState(iraEnum ira); // query row attribute
    const IMsiString& __stdcall GetMoniker(); // return unique identifier for row (table.key1.key2...)
 public: // constructor/destructor
    void* operator new(size_t cb);
    void  operator delete(void * pv);
    CMsiCursor(CMsiTable& riTable, CMsiDatabase& riDatabase, Bool fTree);
   IMsiStream*   CreateInputStream(IMsiStorage* piStorage);  // creates a stream object from storage
 protected:
     ~CMsiCursor(){} // protected to prevent creation on stack
 public: // methods accessed by CMsiTable
    virtual void  RowDeleted(unsigned int iRow, unsigned int iPrevNode);
    virtual void  RowInserted(unsigned int iRow);
    void          DerefStrings();  // release counts from persistent storage
 protected:  // local functions
    Bool          CheckNonNullColumns();
    iveEnum       ValidateField(IMsiTable& riValidationTable, IMsiCursor& riValidationCursor, int iCol, int& iForeignKeyMask, Bool fRow, int vtcTable, int vtcColumn);
    void          CheckDuplicateKeys(IMsiRecord*& rpiRecord, int& iNumErrors);
    void          CheckForeignKeys(IMsiTable& riValidationTable, IMsiCursor& riValidationCursor, IMsiRecord*& rpiRecord, int iForeignKeyMask, int& iNumErrors);
    int           SetupForeignKeyValidation(MsiString& rstrForeignTableName, MsiString& rstrCategory, int iCol, int iForeignCol);
    int           ValidateForeignKey(MsiString& rstrTableName, MsiString& rstrData, Bool fSpecialKey, int iCol, int iForeignCol);
    iveEnum       CheckIntegerValue(IMsiTable& riValidationTable, IMsiCursor& riValidationCursor, int iCol, int& iForeignKeyMask, Bool fVersionString);
    iveEnum       CheckStringValue(IMsiTable& riValidationTable, IMsiCursor& riValidationCursor, int iCol, int& iForeignKeyMask, Bool fRow);
    IMsiRecord&   SetUpRecord(int iCol);
    IMsiStream*   GetObjectStream(int iCol);  // internal, column assured to be icdObject
 protected:  // local data, used by derived cursor classes
    CMsiRef<iidMsiCursor> m_Ref;  // COM reference count
    int           m_iRow;         // current row number, 0 if reset, - if deleted
    CMsiTable&    m_riTable;      // this reference is reference counted
    CMsiDatabase& m_riDatabase;   // NOT reference counted, table owns the refcnt
//  Bool          m_fReadOnly;    // table data cannot be modified
    idsEnum       m_idsUpdate;    // update state of the table
    Bool          m_fTree;        // tree-walking cursor
    int&          m_rcColumns;    // number of data columns
    MsiColumnDef* m_pColumnDef;   // pointer to column def array in table object
   unsigned int  m_fDirty;       // dirty flags for upto 32 columns
   unsigned int  m_fFilter;      // current filter flags for cursor
 private:
    CMsiCursor**  m_ppiPrevCursor;// linked list of cursor objects for table
    CMsiCursor*   m_piNextCursor; // linked list of cursor objects for table
 protected:  // needed by derived cursor classes
    MsiTableData  m_Data[1+cMsiMaxTableColumns]; // copy of table row data
 private: // eliminate warning: assignment operator could not be generated
    void operator =(const CMsiCursor&){}
/*!!TEMP*/  friend IMsiRecord* CMsiDatabase::MergeDatabase(IMsiDatabase& riRefDb, IMsiTable* pMergeErrorTable);
/*!!TEMP*/  friend IMsiRecord* CMsiDatabase::GenerateTransform(IMsiDatabase& riRefDb,
                                                          IMsiStorage* piTransStorage,
                                                          int iErrorConditions,
                                                          int iValidation);
/*!!TEMP*/  friend IMsiRecord* CMsiDatabase::Commit();
};

inline void* CMsiCursor::operator new(size_t cb)
    {void* pv = AllocObject(cb); if (pv) memset(pv, 0, cb); return pv;}
inline void  CMsiCursor::operator delete(void * pv) { FreeObject(pv); }
inline IMsiRecord& CMsiCursor::SetUpRecord(int iCol) { return PMsiServices(&(m_riDatabase.GetServices()))->CreateRecord(iCol); }

//____________________________________________________________________________
//
// CCatalogTable definitions - subclassed AddRef/Release to manage external references
//____________________________________________________________________________

class CCatalogTable : public CMsiTable
{
 public:
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();
 public:  // constructor
    CCatalogTable(CMsiDatabase& riDatabase, unsigned int cInitRows, int cRefBase);
 public:  // methods used by CMsiDatabase to manage catalog
    bool SetTableState(MsiStringId iName, ictsEnum icts);
    bool GetTableState(MsiStringId iName, ictsEnum icts);
    bool SetTransformLevel(MsiStringId iName, int iTransform);
    int  GetLoadedTable(MsiStringId iName, CMsiTable*& rpiTable);  // returns row status
    int  SetLoadedTable(MsiStringId iName, CMsiTable* piTable);    // returns row status
    Bool LoadData(const IMsiString& riName, IMsiStorage& riStorage, int cbFileWidth, int cbStringIndex);
 private:
    int m_cRefBase;
    int m_iLastRow;  // cached last row for optimizing TableState methods
 private: // eliminate warning: assignment operator could not be generated
    void operator =(const CCatalogTable&);
};

inline Bool CCatalogTable::LoadData(const IMsiString& riName, IMsiStorage& riStorage, int cbFileWidth, int cbStringIndex)
{
    m_cLoadColumns = m_cPersist;
    return LoadFromStorage(riName, riStorage, cbFileWidth, cbStringIndex);
}

inline bool CMsiDatabase::SetTableState(MsiStringId iName, ictsEnum icts)
    {return m_piCatalogTables->SetTableState(iName, icts);}

inline bool CMsiDatabase::GetTableState(MsiStringId iName, ictsEnum icts)
    {return m_piCatalogTables->GetTableState(iName, icts);}
//____________________________________________________________________________
//
// CMsiView definitions
//____________________________________________________________________________

// the ipqToks of the SQL supported statement, bit shifted consts used to allow for or/ and operations
// need bit array > 32 therefore the microsoft bitarray class
template <int C> class bitarray{
public:
    bitarray(){memset(iBitArray, 0, C*sizeof(int));}
    bitarray(int iValue){memset(iBitArray, 0, C*sizeof(int));iBitArray[iValue/(sizeof(int)*8)]=1<<(iValue%((sizeof(int)*8)));}
    bitarray<C> operator&(const bitarray<C>& riArray) const
    {
        bitarray<C> iTmp(0);;
        for(int iCnt = 0;iCnt<C;iCnt++) iTmp.iBitArray[iCnt] = iBitArray[iCnt] & riArray.iBitArray[iCnt];
        return iTmp;
    }
    bitarray<C> operator|(const bitarray<C>& riArray) const
    {
        bitarray<C> iTmp(0);
        for(int iCnt = 0;iCnt<C;iCnt++) iTmp.iBitArray[iCnt] = iBitArray[iCnt] | riArray.iBitArray[iCnt];
        return iTmp;
    }
    const bitarray<C>& operator=(const bitarray<C>& riArray)
    {
        memmove(iBitArray, riArray.iBitArray, C*sizeof(int));
        return *this;
    }
    operator==(const bitarray<C>& riArray) const
    {
        for(int iCnt = 0;((iCnt<C) && (iBitArray[iCnt] == riArray.iBitArray[iCnt]));iCnt++);
        return (iCnt == C);
    }
    operator!=(const bitarray<C>& riArray) const
    {
        for(int iCnt = 0;((iCnt<C) && (iBitArray[iCnt] == riArray.iBitArray[iCnt]));iCnt++);
        return (iCnt != C);
    }
    operator int() const
    {
        for(int iCnt = 0;((iCnt<C) && (iBitArray[iCnt] == 0));iCnt++);
        return (iCnt != C);
    }
protected:
    int iBitArray[C];
    operator<(const bitarray<C>);
    operator>(const bitarray<C>);
    operator<=(const bitarray<C>);
    operator>=(const bitarray<C>);
    operator<(int);
    operator>(int);
    operator<=(int);
    operator>=(int);
};
typedef  bitarray<2> ipqToken;

const ipqToken ipqTokUnknown = 0;
const ipqToken ipqTokSelect = 1;
const ipqToken ipqTokFrom = 2;
const ipqToken ipqTokAs = 3;
const ipqToken ipqTokWhere = 4;
const ipqToken ipqTokId = 5;
const ipqToken ipqTokLiteralS = 6;
const ipqToken ipqTokLiteralI = 7;
const ipqToken ipqTokNull = 8;
const ipqToken ipqTokDot = 9;
const ipqToken ipqTokOpen = 10;
const ipqToken ipqTokClose = 11;
const ipqToken ipqTokComma = 12;
const ipqToken ipqTokOrOp = 13;
const ipqToken ipqTokAndOp = 14;
const ipqToken ipqTokNotop = 15;
const ipqToken ipqTokEqual = 16;
const ipqToken ipqTokGreater = 17;
const ipqToken ipqTokLess = 18;
const ipqToken ipqTokNotEq = 19;
const ipqToken ipqTokGreaterEq = 20;
const ipqToken ipqTokLessEq = 21;
const ipqToken ipqTokOrder = 22;
const ipqToken ipqTokBy = 23;
const ipqToken ipqTokEnd = 24;
const ipqToken ipqTokParam = 25;
const ipqToken ipqTokQuotes = 26;
const ipqToken ipqTokIdQuotes = 27;
const ipqToken ipqTokWhiteSpace = 28;
const ipqToken ipqTokDistinct = 29;
const ipqToken ipqTokUpdate = 30;
const ipqToken ipqTokDelete = 31;
const ipqToken ipqTokInsert = 32;
const ipqToken ipqTokSet = 33;
const ipqToken ipqTokValues = 34;
const ipqToken ipqTokInto = 35;
const ipqToken ipqTokIs = 36;
const ipqToken ipqTokStar = 37;
const ipqToken ipqTokCreate = 38;
const ipqToken ipqTokAlter = 39;
const ipqToken ipqTokTable = 40;
const ipqToken ipqTokAdd = 41;
const ipqToken ipqTokPrimary = 42;
const ipqToken ipqTokKey = 43;
const ipqToken ipqTokChar = 44;
const ipqToken ipqTokCharacter = 45;
const ipqToken ipqTokVarChar = 46;
const ipqToken ipqTokLongChar = 47;
const ipqToken ipqTokInt = 48;
const ipqToken ipqTokInteger = 49;
const ipqToken ipqTokShort = 50;
const ipqToken ipqTokLong = 51;
const ipqToken ipqTokObject = 52;
const ipqToken ipqTokTemporary = 53;
const ipqToken ipqTokDrop = 54;
const ipqToken ipqTokHold = 55;
const ipqToken ipqTokFree = 56;
const ipqToken ipqTokLocalizable = 57;

class CMsiView;

// Derived class from CMsiCursor
// class used privately by CMsiView for handling sorting
class CMsiDCursor : public CMsiCursor
{
public:
    CMsiDCursor(CMsiTable& riTable, CMsiDatabase& riDatabase, CMsiView& cView, int iHandle);
    int  GetRow();
    void SetRow(int iRow);
    void RowDeleted(unsigned int iRow, unsigned int iPrevNode);
    void RowInserted(unsigned int iRow);
protected:
    CMsiView& m_cView;
    int m_iHandle;
 private: // eliminate warning: assignment operator could not be generated
    void operator =(const CMsiDCursor&){}
};

// the definitions for the tables occuring in the join.
struct TableDefn{
    PMsiTable piTable;
    CComPointer<CMsiDCursor> piCursor;
    MsiStringId  iTable;
    unsigned int iParentIndex; //index into Tables array
    unsigned int iExpressions;  //bit set for each Operation in the Expressions array corr. to this table
    TableDefn();
    ~TableDefn();
    const TableDefn& operator=(const TableDefn&);
};

inline TableDefn::TableDefn():piTable(0),piCursor(0),iTable(0)
{
    iTable = 0;
    iParentIndex = 0;
    iExpressions = 0;
}

inline TableDefn::~TableDefn()
{
}

inline const TableDefn& TableDefn::operator=(const TableDefn& rTableDefn)
{
    piTable = rTableDefn.piTable;
    piCursor = rTableDefn.piCursor;
    return *this;
}

// types of joins expression
enum ijtJoinType
{
     ijtNoJoin = 0,
     ijt1ToMJoin,
     ijt1To1Join,
     ijtMToMJoin
};

// the definitions for the expressions occuring in the sql
struct ExpressionDefn{
    unsigned int iTableIndex1; //index into Tables array
    unsigned int iColumn1;  // index of column in table
    unsigned int iTableIndex2; //0, if literal comparison else index into Tables array
    unsigned int iColumn2;  // int corr. to literal, or index of column in table
    const ipqToken* ptokOperation;
    Bool fFlags; // set if expression is not rooted, directly or indirectly to an OR operation
    ijtJoinType ijtType;
    int itdType; // expression operand(s) type, used when literal to literal comparison expression involving parameter
    ExpressionDefn();
};

inline ExpressionDefn::ExpressionDefn()
{
    iTableIndex1 = 0;
    iColumn1 = 0;
    iTableIndex2 = 0;
    iColumn2 = 0;
    ptokOperation = &ipqTokUnknown;
    fFlags = fFalse;
    ijtType = ijtNoJoin;
}

// the definitions for the columns (return/ order) occuring in the sql
struct ColumnDefn{
    unsigned int iTableIndex; //index into Tables array
    unsigned int iColumnIndex;// index of column in table
    int itdType; // operand(s) type, used when literal being passed back
    ColumnDefn();
};

inline ColumnDefn::ColumnDefn()
{
    iTableIndex = 0;
    iColumnIndex = 0;
    itdType = 0;
}

// the operation tree, the tree of the AND/ OR operations with expressions as the leaf nodes
struct OperationTree{
    unsigned int iValue; // overloaded, if non - leaf node = iopAND or iopOR, else index into Expressions array
    unsigned int iParentIndex;//index into  Operations array
    OperationTree();
};

inline OperationTree::OperationTree()
{
    iValue = 0;
    iParentIndex = 0;
}

struct TokenStringList{
    TokenStringList(const ICHAR* pStr, const ipqToken& ripqTok):string(pStr), ipqTok(ripqTok){}
    const ICHAR* string;
    const ipqToken ipqTok;
};

struct TokenCharList{
    TokenCharList(const ICHAR& rch, const ipqToken& ripqTok):string(rch), ipqTok(ripqTok){}
#ifdef _WIN64
// Fix data alignment faults for WIN64 by aligning ipqTok on an 8-byte boundary
    union
    {
        const ICHAR * pPadding;
#endif  //_WIN64
        const ICHAR string;
#ifdef _WIN64
    };
#endif  //_WIN64

    const ipqToken ipqTok;
};

// default buffer size for Lex
const unsigned int cchExpectedMaxSQLQuery = 1024;

// lex class for SQL query tokens
class Lex{
public:
    Lex(const ICHAR* szSQL);// constructor
    ~Lex();// destructor
    // function to check if next ipqTok in statement is the desired ipqTok
    // if matched, current posisiotn is advanced, else it is maintained
    // as is
    Bool MatchNext(const ipqToken& rtokToMatch);
    // function to inspect the next ipqTok, w/o advancing the
    // current position
    Bool InspectNext(const ipqToken& rtokToInspect);
    // function to get the next ipqTok, advancing the
    // current position
    const ipqToken& GetNext();
    // function to get the next ipqTok, advancing the
    // current position, string corr. to token returned (used for ids, literals)
    const ipqToken& GetNext(const IMsiString*& rpistrToken);
    // function to return number of entries occuring before the endTokens,
    // each entry is delimited be  delimitTokens,
    // can pass in ORed endTokens, delimitTokens
    int NumEntriesInList(const ipqToken& rtokEnds,const ipqToken& rtokDelimits);
    // function to skip all subsequent ipqToks upto and including
    // ipqTokToMSkipUpto. Returns true, if found, false otherwise
    // position at end of ip if not found
    Bool Skip(const ipqToken& rtokSkipUpto);
    // function to reset ip position
    inline void Reset()
    {
        m_ipos = 0;
    }
private:
    void  CharNext(ICHAR*& rpchCur);
    const ipqToken& GetNextToken(INT_PTR& currPos, const ipqToken* ptokHint, const IMsiString** ppistrRet);         //--merced: changed int to INT_PTR
    const ipqToken& GetCharToken(ICHAR cCur);
    const ipqToken& GetStringToken(ICHAR* pcCur, const ipqToken* ptokHint);
    static const TokenStringList m_rgTokenStringArray[];
    static const TokenCharList m_rgTokenCharArray[];
    static const ICHAR m_chQuotes;
    static const ICHAR m_chIdQuotes;
    static const ICHAR m_chEnd;
    static const ICHAR m_chSpace;

    CTempBuffer<ICHAR, cchExpectedMaxSQLQuery> m_szBuffer;
    INT_PTR m_ipos;         //--merced: changed int to INT_PTR
};

// CMsiView, SQL interface to Darwin database
class CMsiView : public IMsiView
{
 public:
     // IUnknown fuctions
    HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();

    // IMsiView functions
    IMsiRecord*   __stdcall Execute(IMsiRecord* piParams);
    unsigned int  __stdcall GetFieldCount();
    IMsiRecord*   __stdcall GetColumnNames();
    IMsiRecord*   __stdcall GetColumnTypes();
    IMsiRecord*   __stdcall Fetch();
    IMsiRecord*   __stdcall Modify(IMsiRecord& riRecord, irmEnum irmAction);
    IMsiRecord*   __stdcall Close();
    IMsiRecord*   __stdcall GetRowCount(long& lRowCount);
    iveEnum       __stdcall GetError(const IMsiString*& rpiColumnName);
    dvcsCursorState __stdcall GetState(){return m_CursorState;}
 public:
     // member functions use by this module
    CMsiView(CMsiDatabase& riDatabase, IMsiServices& riServices);
    IMsiRecord* OpenView(const ICHAR* szSQL, ivcEnum ivcIntent);
    void RowDeleted(int iRow, int iTable);
    void RowInserted(int iRow, int iTable);
 protected:
    virtual ~CMsiView();
 protected:
    // member functions used by this class
    // called for the first fetch for setting up the first records satisfying the query
    Bool FetchFirst(unsigned int iTableSequence = 0);
    // called always but for the first fetch
    Bool FetchNext(unsigned int iTableSequence = 0);
    // does the record satisfy the independant expressions related to iTable
    Bool FitCriteria(unsigned int iTable);
    // evaluate a unit expression - id operation id/literal
    Bool EvaluateExpression(unsigned int iExpression);
    // set the filters for the iTable
    Bool SetTableFilters(unsigned int iTable);
    // set the parent child relations from the join
    virtual Bool SetupTableJoins();
    // set up the the individual filters
    Bool CMsiView::InitialiseFilters();
    // set up the the sorting reqmt.
    void CMsiView::SetupSortTable();
    // reverse the join sequence for iTable and all its ancestors
    void ReverseJoinLink(unsigned int iTable);
    // whats the cost of reversing the join sequence for iTable and all its ancestors
    int GetSearchReversingCost(unsigned int iTable, unsigned int& riParentTable);
    // set the sequence in which the records for the tables should be fetched
    void SetTableSequence(int iParent, int& iPos);
    // evaluate the auxiliary OR expression if present
    Bool FitCriteriaORExpr(unsigned int iTreeParent);
    // set the expressions that are independant (not rooted directly or indirectly to an OR expression
    void SetAndExpressions(unsigned int iTreeParent);
    // function that binds a string and keeps the index in a temporary table
    MsiStringId BindString(MsiString& rastr);
    // function to evaluate constant expressions before the first fetch
    Bool EvaluateConstExpressions();
    // function that is used to resolve the columns in the query, returns column def, -1 if failure
    virtual IMsiRecord* ResolveColumn(Lex& lex, MsiString& strColumn, unsigned int& iTableIndex, unsigned int& iColumnIndex, int& iColumnDef);
    // function that is used to resolve the table names in the join
    virtual IMsiRecord* ResolveTable(Lex& lex,MsiString& tableName);
    // for DISTINCT clause
    virtual Bool IsDistinct();
    // for prefetching the result set
    virtual IMsiRecord* GetResult();

    // the parse logic functions
    IMsiRecord* CheckSQL(const ICHAR* sqlquery);
    IMsiRecord* ParseCreateSQL(Lex& lex);
    IMsiRecord* ParseAlterSQL(Lex& lex);
    IMsiRecord* ParseInsertSQL(Lex& lex);
    IMsiRecord* ParseUpdateSQL(Lex& lex);
    IMsiRecord* ParseDeleteSQL(Lex& lex);
    IMsiRecord* ParseSelectSQL(Lex& lex);
    IMsiRecord* ParseDropSQL(Lex& lex);
    IMsiRecord* ParseCreateColumns(Lex & lex);
    IMsiRecord* ParsePrimaryColumns(Lex & lex);
    IMsiRecord* ResolveCreateColumn(Lex& lex, MsiString& strColumn, int iColumnIndex);
    IMsiRecord* ResolvePrimaryColumn(Lex& lex, MsiString& strColumn, int iColumnIndex);
    IMsiRecord* ParseInsertColumns(Lex& lex);
    IMsiRecord* ParseInsertValues(Lex& lex);
    IMsiRecord* ParseUpdateColumns(Lex& lex);
    IMsiRecord* ParseSelectColumns(Lex& lex);
    IMsiRecord* ParseColumns(Lex& lex);
    IMsiRecord* ParseTables(Lex& lex);
    IMsiRecord* ParseExpression(Lex& lex, unsigned int& iPosInArray,unsigned int& iPosInTree,unsigned int& iChild);
    IMsiRecord* ParseExpr2(Lex& lex,unsigned int& iPosInArray,unsigned int& iPosInTree,unsigned int& iChild);
    IMsiRecord* ParseOrderBy(Lex& lex);
    IMsiRecord* ParseColumnAttributes(Lex& lex, int iColumnIndex);

    // for prefetches
    Bool GetNextFetchRecord();
    void SetNextFetchRecord();

    void FetchRecordInfoFromCursors();

    IMsiRecord* _Fetch();
    IMsiRecord* FetchCore();

 protected:  //  state data
    CMsiRef<iidMsiView> m_Ref;
    IMsiServices&   m_riServices;
    CMsiDatabase&   m_riDatabase;
    ivcEnum         m_ivcIntent;
    unsigned int    m_iParams;
    unsigned int    m_iColumns;
    dvcsCursorState m_CursorState;
    unsigned int    m_iRowNum;      // current result set row, 0 if none fetched
    PMsiRecord      m_piRecord;     // current record referencing row m_szBuffer
    unsigned int    m_iTables;
    unsigned int    m_iExpressions;
    unsigned int    m_iSortColumns;
    unsigned int    m_iParamExpressions;
    unsigned int    m_iParamOutputs;
    unsigned int    m_iParamInputs;
    CTempBuffer<TableDefn, 10> m_rgTableDefn;
    CTempBuffer<unsigned int, 10> m_rgiTableSequence;
    CTempBuffer<ExpressionDefn, 10> m_rgExpressionDefn;
    CTempBuffer<ColumnDefn, 10> m_rgColumnDefn;
    CTempBuffer<ColumnDefn, 10> m_rgColumnsortDefn;
    CTempBuffer<OperationTree, 10> m_rgOperationTree; // the auxiliary OR expression holder
    unsigned int    m_iOperations;
    unsigned int    m_iTreeParent;
    PMsiCursor      m_piFetchCursor;
    PMsiTable       m_piFetchTable;
    PMsiTable       m_piBindTable;
    PMsiCursor      m_piBindTableCursor;
    PMsiTable       m_piDistinctTable;
    long            m_lRowCount;
    Bool            m_fDistinct;
    MsiString       m_istrSqlQuery;
    PMsiRecord      m_piInsertUpdateRec;
    char               m_rgchError[1+cMsiMaxTableColumns];
    Bool                m_fErrorRefreshed;
    int             m_iFirstErrorIndex;
    int             m_fLock;
 private: // eliminate warning: assignment operator could not be generated
    void operator =(const CMsiView&){}
};

//____________________________________________________________________________
//
// CScriptView: for reading in installation scripts
//____________________________________________________________________________

class CScriptView: public IMsiView {
 public:
     CScriptView(CScriptDatabase& riDatabase, IMsiServices& riServices);
// IUnknown fuctions
     HRESULT       __stdcall QueryInterface(const IID& /*riid*/, void** /*ppvObj*/){return 0;};
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();

//  CScriptView(CScriptDatabase& riDatabase, IMsiServices& riServices);
    IMsiRecord*  __stdcall Execute(IMsiRecord* piParams);
    IMsiRecord*  __stdcall Fetch();  // return record is result row
    IMsiRecord*  __stdcall Initialise(const ICHAR* szScriptFile);

    unsigned int __stdcall GetFieldCount(){return 0;};
    IMsiRecord*  __stdcall GetColumnNames(){return 0;};
    IMsiRecord*  __stdcall GetColumnTypes(){return 0;};
    IMsiRecord*  __stdcall Modify(IMsiRecord& /*riRecord*/, irmEnum /*irmAction*/){return 0;};
    IMsiRecord*  __stdcall GetRowCount(long& /*lRowCount*/){return 0;};
    IMsiRecord*  __stdcall Close();
    iveEnum     __stdcall GetError(const IMsiString*& /*rpiColumnName*/){return iveNoError;};
    dvcsCursorState __stdcall GetState(){return dvcsBound;} // always okay

 protected:
    CScriptView::~CScriptView();

 protected:
    CMsiRef<iidMsiView> m_Ref;
    IMsiServices&       m_riServices;
    CScriptDatabase&    m_riDatabase;
    PMsiStream          m_pStream;
    IMsiRecord*         m_piPrevRecord;
    ixoEnum             m_ixoPrev;
    int                 m_iScriptVersion;

};

extern bool g_fUseObjectPool;

int PutObjectDataProc(const IMsiData* pvData);
const IMsiData* GetObjectDataProc(int iIndex);

//
// Object pool defines
//
#ifdef _WIN64
#define PutObjectData(x)    PutObjectDataProc(x)
#define GetObjectData(x)    GetObjectDataProc(x)
#elif defined(USE_OBJECT_POOL)
inline int PutObjectData(const IMsiData* pvData)
{
    if (g_fUseObjectPool)
        return PutObjectDataProc(pvData);
    else
        return (int)pvData;
};

inline const IMsiData* GetObjectData(int iIndex)
{
    if (g_fUseObjectPool)
        return GetObjectDataProc(iIndex);
    else
        return (const IMsiData*)iIndex;
};
#else
#define PutObjectData(x)    ((int)x)
#define GetObjectData(x)    ((IMsiData*)(int)x)
#endif

#endif // #define __DATABAS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\_dgtlsig.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       _digtlsig.h
//
//--------------------------------------------------------------------------

#ifndef _DGTLSIG_H
#define _DGTLSIG_H

enum icsrCheckSignatureResult
{
	icsrTrusted = 0,       // subject trusted
	icsrNotTrusted,        // initial "not trust" state
	icsrNoSignature,       // object does not have a signature
	icsrBadSignature,      // object's hash or certificate are invalid (WVT determined)
	icsrWrongCertificate,  // object's certificate does not match that in MSI (authored)
	icsrWrongHash,         // object's hash does not match that in MSI (authored)
	icsrBrokenRegistration,// crypto registration is broken
	icsrMissingCrypto,     // crypto is not on machine
};

enum icrCompareResult
{
	icrMatch = 0,         // match (size and data)
	icrSizesDiffer,       // sizes differ
	icrDataDiffer,        // data differs
	icrError              // some other error occurred
};

iesEnum GetObjectSignatureInformation(IMsiEngine& riEngine, const IMsiString& riTable, const IMsiString& riObject, IMsiStream*& rpiCertificate, IMsiStream*& rpiHash);
icsrCheckSignatureResult MsiVerifyNonPackageSignature(const IMsiString& riFileName, HANDLE hFile, IMsiStream& riSignatureCert, IMsiStream* piSignatureHash, HRESULT& hrWVT);
void ReleaseWintrustStateData(GUID *pgAction, WINTRUST_DATA& sWinTrustData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\_msinst.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       _msinst.h
//
//--------------------------------------------------------------------------

// This file *must* be unguarded to allow msinst.cpp to include it twice.

#if (!defined(MSINST) && defined(UNICODE)) || (defined(MSINST) && defined(MSIUNICODE))
#pragma message("_msinst.h: UNICODE")
#pragma warning(disable: 4005)
#define SPECIALTEXT(quote) L##quote
#define _SPECIALTEXT(quote) L##quote
#define __SPECIALTEXT(quote) L##quote
#pragma warning(default : 4005)
#else 
#pragma message("_msinst.h: ANSI")
#define SPECIALTEXT(quote) quote
#define _SPECIALTEXT(quote) quote
#define __SPECIALTEXT(quote) quote
#endif

// Win 95 Ref Count
#define szSharedDlls __SPECIALTEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDLLs")
#define szExternalClient __SPECIALTEXT("External") //!! should this be 39 bytes

// Policy information -- under HKCU (user policy) or HKLM (machine policy)

#define szPolicyKey                      __SPECIALTEXT("Software\\Policies\\Microsoft\\Windows\\Installer")

  // user policies
  #define    szSearchOrderValueName           __SPECIALTEXT("SearchOrder")
  #define    szTransformsAtSourceValueName    __SPECIALTEXT("TransformsAtSource") 
  #define    szTransformsSecureValueName      __SPECIALTEXT("TransformsSecure")
  #define    szDisableMediaValueName          __SPECIALTEXT("DisableMedia")

  // machine policies
  #define    szDisableBrowseValueName         __SPECIALTEXT("DisableBrowse")
  #define    szDisablePatchValueName          __SPECIALTEXT("DisablePatch")
  #define    szDisableMsiValueName            __SPECIALTEXT("DisableMsi")
  #define    szWaitTimeoutValueName           __SPECIALTEXT("Timeout")
  #define    szLoggingValueName               __SPECIALTEXT("Logging")
  #define    szDebugValueName                 __SPECIALTEXT("Debug")
  #define    szAllowAllPublicProperties       __SPECIALTEXT("EnableUserControl")
  #define    szSafeForScripting               __SPECIALTEXT("SafeForScripting")
  #define    szEnableAdminTSRemote            __SPECIALTEXT("EnableAdminTSRemote")
  #define    szAllowLockdownBrowseValueName   __SPECIALTEXT("AllowLockdownBrowse")
  #define    szAllowLockdownPatchValueName    __SPECIALTEXT("AllowLockdownPatch")
  #define    szAllowLockdownMediaValueName    __SPECIALTEXT("AllowLockdownMedia")
  #define    szInstallKnownOnlyValueName      __SPECIALTEXT("InstallKnownPackagesOnly") // digital signature policy
#ifndef _msinst_h
  const WCHAR szDisableUserInstallsValueName[]=           L"DisableUserInstalls";
  const WCHAR szResolveIODValueName[]=                    L"ResolveIOD"; // private policy
#endif
  #define    szLimitSystemRestoreCheckpoint   __SPECIALTEXT("LimitSystemRestoreCheckpointing") // integration with system restore on whistler/millennium


  // user and machine policies
  #define    szAlwaysElevateValueName         __SPECIALTEXT("AlwaysInstallElevated")
  #define    szDisableRollbackValueName       __SPECIALTEXT("DisableRollback")

// Published information -- under HKCU

#define szManagedUserSubKey              __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Managed")
#define szNonManagedUserSubKey           __SPECIALTEXT("Software\\Microsoft\\Installer")
#define szMachineSubKey                  __SPECIALTEXT("Software\\Classes\\Installer")
#ifndef _msinst_h
	const WCHAR szClassInfoSubKey[]					= L"Software\\Classes";
#endif

#define szGPTProductsKey                 __SPECIALTEXT("Products")
#define szGPTFeaturesKey                 __SPECIALTEXT("Features")
#define szGPTComponentsKey               __SPECIALTEXT("Components")
#define szGPTUpgradeCodesKey             __SPECIALTEXT("UpgradeCodes")
#define szGPTNetAssembliesKey            __SPECIALTEXT("Assemblies")
#define szGPTWin32AssembliesKey          __SPECIALTEXT("Win32Assemblies")


//need to define another set of defines to use in execute.cpp
#define _szManagedUserSubKey              __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Managed")
#define _szNonManagedUserSubKey           __SPECIALTEXT("Software\\Microsoft")
#define _szMachineSubKey                  __SPECIALTEXT("Software\\Classes")

#define _szGPTProductsKey        __SPECIALTEXT("Installer\\Products")
#define _szGPTFeaturesKey        __SPECIALTEXT("Installer\\Features")
#define _szGPTComponentsKey      __SPECIALTEXT("Installer\\Components")
#define _szGPTPatchesKey         __SPECIALTEXT("Installer\\Patches")
#define _szGPTUpgradeCodesKey    __SPECIALTEXT("Installer\\UpgradeCodes")
#define _szGPTNetAssembliesKey   __SPECIALTEXT("Installer\\Assemblies")
#define _szGPTWin32AssembliesKey __SPECIALTEXT("Installer\\Win32Assemblies")

#define    szLanguageValueName              __SPECIALTEXT("Language")
#define    szProductNameValueName           __SPECIALTEXT("ProductName")
#define    szPackageCodeValueName           __SPECIALTEXT("PackageCode")
#define    szTransformsValueName            __SPECIALTEXT("Transforms")
#define    szVersionValueName               __SPECIALTEXT("Version")
#define    szAssignmentTypeValueName        __SPECIALTEXT("Assignment")
#define    szAssignedValueName              __SPECIALTEXT("Assigned")
#define    szClientsValueName               __SPECIALTEXT("Clients") // this is also used under the Uninstall key
#define    szAdvertisementFlags				__SPECIALTEXT("AdvertiseFlags")
#define    szProductIconValueName           __SPECIALTEXT("ProductIcon")
#define    szInstanceTypeValueName          __SPECIALTEXT("InstanceType")

#ifndef _msinst_h
	const WCHAR	szSourceListSubKey[]=                    L"SourceList";
#endif
#define    szPatchesSubKey                  __SPECIALTEXT("Patches")
#define    szPatchesValueName               __SPECIALTEXT("Patches")

#define    szLastUsedSourceValueName        __SPECIALTEXT("LastUsedSource")
#define    szPackageNameValueName           __SPECIALTEXT("PackageName")

#define      szSourceListNetSubKey               __SPECIALTEXT("Net")
#define      szSourceListURLSubKey               __SPECIALTEXT("URL")
#define      szSourceListMediaSubKey             __SPECIALTEXT("Media")
#define         szMediaPackagePathValueName         __SPECIALTEXT("MediaPackage")
#define         szVolumeLabelValueName              __SPECIALTEXT("VolumeLabel")
#define         szDiskPromptTemplateValueName       __SPECIALTEXT("DiskPrompt")
#define         szURLSourceTypeValueName            __SPECIALTEXT("SourceType")

#define szGPTPatchesKey                  __SPECIALTEXT("Patches")

#define szGlobalAssembliesCtx            __SPECIALTEXT("Global")
// Local machine information -- under HKLM

// legacy/Win9x locations
#define szMsiFeatureUsageKey_Win9x       __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Products")
#define szMsiFeaturesKey_Win9x           __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Features")
#define szMsiComponentsKey_Win9x         __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components")
#define szMsiUninstallProductsKey_legacy __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall")


#define szMsiUserDataKey                 __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData")

#define szMsiLocalInstallerKey           __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer")
#define szMsiSecureSubKey                __SPECIALTEXT("Secure")

#define szMsiPatchesSubKey               __SPECIALTEXT("Patches")
#define szMsiFeaturesSubKey              __SPECIALTEXT("Features")
#define szMsiProductsSubKey              __SPECIALTEXT("Products")
#define szMsiComponentsSubKey            __SPECIALTEXT("Components")
#define szMsiInstallPropertiesSubKey     __SPECIALTEXT("InstallProperties")
#define szMsiFeatureUsageSubKey          __SPECIALTEXT("Usage")
#define szMsiTransformsSubKey            __SPECIALTEXT("Transforms")

#define szMsiLocalPackagesKey            __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\LocalPackages")
#define szManagedText                    __SPECIALTEXT("(Managed)")
#define    szKeyFileValueName               __SPECIALTEXT("") // There are currently 
																		 // assumptions in the code 
																		 // this value name is "". If
																		 // it's changed then the code
																		 // must be changed

#define szSelfRefMsiExecRegKey              __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer")
#define szMsiExec64ValueName                __SPECIALTEXT("MsiExecCA64")
#define szMsiExec32ValueName                __SPECIALTEXT("MsiExecCA32")
#define szMsiLocationValueName				__SPECIALTEXT("InstallerLocation")

#define    szAuthorizedCDFPrefixValueName   __SPECIALTEXT("AuthorizedCDFPrefix")
#define    szCommentsValueName              __SPECIALTEXT("Comments")
#define    szContactValueName               __SPECIALTEXT("Contact")
#define    szDisplayNameValueName           __SPECIALTEXT("DisplayName")
#define    szDisplayVersionValueName        __SPECIALTEXT("DisplayVersion")
#define    szHelpLinkValueName              __SPECIALTEXT("HelpLink")
#define    szHelpTelephoneValueName         __SPECIALTEXT("HelpTelephone")
#define    szInstallDateValueName           __SPECIALTEXT("InstallDate")
#define    szInstallLocationValueName       __SPECIALTEXT("InstallLocation")
#define    szInstallSourceValueName         __SPECIALTEXT("InstallSource")
#define    szLocalPackageValueName          __SPECIALTEXT("LocalPackage")
#define    szLocalPackageManagedValueName   __SPECIALTEXT("ManagedLocalPackage")
#define    szModifyPathValueName            __SPECIALTEXT("ModifyPath")
#define    szNoModifyValueName              __SPECIALTEXT("NoModify")
#define    szNoRemoveValueName              __SPECIALTEXT("NoRemove")
#define    szNoRepairValueName              __SPECIALTEXT("NoRepair")
#define    szPIDValueName                   __SPECIALTEXT("ProductID")
#define    szPublisherValueName             __SPECIALTEXT("Publisher")
#define    szReadmeValueName                __SPECIALTEXT("Readme")
#define    szOrgNameValueName               __SPECIALTEXT("RegCompany")
#define    szUserNameValueName              __SPECIALTEXT("RegOwner")
#define    szSizeValueName                  __SPECIALTEXT("Size")
#define    szEstimatedSizeValueName         __SPECIALTEXT("EstimatedSize")
#define    szSystemComponentValueName       __SPECIALTEXT("SystemComponent")
#define    szUninstallStringValueName       __SPECIALTEXT("UninstallString")
#define    szURLInfoAboutValueName          __SPECIALTEXT("URLInfoAbout")
#define    szURLUpdateInfoValueName         __SPECIALTEXT("URLUpdateInfo")
#define    szVersionMajorValueName          __SPECIALTEXT("VersionMajor")
#define    szVersionMinorValueName          __SPECIALTEXT("VersionMinor")
#define    szWindowsInstallerValueName      __SPECIALTEXT("WindowsInstaller")
//#define  szVersionValueName               defined above


#define szMsiProductsKey                 __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Products")
// szMsiProductsKey\{Product Code}\{Feature Id}
#define    szUsageValueName                 __SPECIALTEXT("Usage")


// Folders key -- under HKLM

#define szMsiFoldersKey                  __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Folders")

// Rollback keys -- under HKLM

#define szMsiRollbackKey                 __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Rollback")
#define szMsiRollbackScriptsKey             __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Rollback\\Scripts")
#define szMsiRollbackScriptsDisabled     __SPECIALTEXT("ScriptsDisabled")

// In-progress key -- under HKLM

#ifndef _msinst_h
const WCHAR szMsiInProgressKey[]= L"Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\InProgress";
#endif
#define szMsiInProgressProductCodeValue  __SPECIALTEXT("ProductId")
#define szMsiInProgressProductNameValue  __SPECIALTEXT("ProductName")
#define szMsiInProgressLogonUserValue    __SPECIALTEXT("LogonUser")
#define szMsiInProgressSelectionsValue   __SPECIALTEXT("Selections")
#define szMsiInProgressFoldersValue      __SPECIALTEXT("Folders")
#define szMsiInProgressPropertiesValue   __SPECIALTEXT("Properties")
#define szMsiInProgressTimeStampValue    __SPECIALTEXT("TimeStamp")
#define szMsiInProgressDatabasePathValue __SPECIALTEXT("DatabasePath")
#define szMsiInProgressDatabasePathValueA "DatabasePath"
#define szMsiInProgressDiskPromptValue   __SPECIALTEXT("DiskPrompt")
#define szMsiInProgressDiskSerialValue   __SPECIALTEXT("DiskSerial")
#define szMsiInProgressSRSequence        __SPECIALTEXT("SystemRestoreSequence")   // Millenium only
#define szMsiInProgressAfterRebootValue  __SPECIALTEXT("AfterReboot")

// Patches key -- under HKLM

#define szMsiPatchesKey                  __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Patches")

// UpgradeCodes key -- under HKLM

#define szMsiUpgradeCodesKey             __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UpgradeCodes")

// RunOnceEntries key -- under HKLM

#define szMsiRunOnceEntriesKey           __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\RunOnceEntries")

// Hacks -- under HKLM

#ifndef _msinst_h
	const WCHAR szMsiResolveIODKey[]=                 L"Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\ResolveIOD";
#endif
#define szMsiTempPackages                __SPECIALTEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\TempPackages")

// TEMP: until NT folks truely provide a merged HKCR
#define szMergedClassesSuffix            __SPECIALTEXT("_Merged_Classes")

#ifndef chFeatureIdTerminator
#define chFeatureIdTerminator   '\x02'
#define chAbsentToken           '\x06'
#define chSharedDllCountToken   '?'

// The following ranges are currently used on different architectures.
/*
----------------------------------------------------------------------------------------
  Value Range   |               x86                |             Win64
----------------------------------------------------------------------------------------
    0 - 19      |   Hives (not run from source)    |  32-bit hive (not run from source)
----------------------------------------------------------------------------------------
   20 - 39      |     I N V A L I D                |  64-bit hive (not run from source)
----------------------------------------------------------------------------------------
   50 - 69      |   Hives (run from source)        |  32-bit hive (run from source)
----------------------------------------------------------------------------------------
   70 - 89      |     I N V A L I D                |  64-bit hive (run from source)
----------------------------------------------------------------------------------------
*/
const int iRegistryHiveSourceOffset = 50; // don't change this w/o changing GetComponentClientState
const int iRegistryHiveWin64Offset = 20;  // on the 64-bit OS, distinguishes 64-bit paths in the registry
                                          // from the 32-bit ones.

// flags for IxoFeaturePublish::Absent
const int iPublishFeatureAbsent  = 1;  // feature name registered, but uninstalled (no advertisements)
const int iPublishFeatureInstall = 2;  // machine registration, not (fMode & iefAdvertise)

// const modes for GetComponentPath
const int DETECTMODE_VALIDATENONE    =0x0;
const int DETECTMODE_VALIDATESOURCE  =0x1;
const int DETECTMODE_VALIDATEPATH    =0x2;
const int DETECTMODE_VALIDATEALL     =DETECTMODE_VALIDATESOURCE | DETECTMODE_VALIDATEPATH;

// flags used in TempPackages key
const int TEMPPACKAGE_DELETEFOLDER   =0x1;

// token that represents assemblies, if present at front of key path
const int chTokenFusionComponent     = '<';
const int chTokenWin32Component     = '>';

#endif // chFeatureIdTerminator

// portions of this header file must only be included only once, even in msinst.cpp
#ifndef _msinst_h
#define _msinst_h
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\_engine.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       _engine.h
//
//--------------------------------------------------------------------------

/* _engine.h - private definitions for CMsiEngine, CMsiConfigurationManager

 Included by object implementations, NOT by action implementations.
____________________________________________________________________________*/
#ifndef ___ENGINE
#define ___ENGINE
#include "engine.h"
#include "msi.h"
#include "msip.h"
#include "icust.h"
#include "remapi.h"
#include "_diagnos.h"

#define ENG  // ENG:: for readability, scoping globals within engine module
#define SRV  // SRV:: for readability, scoping services globals to engine module
#define MSI  // MSI:: for readability, namespace for MSI API

//__________________________________________________________________________
//
// Command-line options that are used within MSI
//__________________________________________________________________________

// Lower-case options are executed as they are seen.
// Upper-case options are executed last. There can only be 1 upper-case option specified on the command-line.

// The option can be specified in either upper or lower case on
// the command-line. 'a' and 'A' are the same option. They are
// just types of options.

#define NETWORK_PACKAGE_OPTION          'A'
#define REG_SHELL_DATA_OPTION           'D'
#define EMBEDDING_OPTION                'E'  // cannot change -- used by OLE
#define REPAIR_PACKAGE_OPTION           'F'
#define LANGUAGE_OPTION                 'g'
#define HELP_1_OPTION                   'H'
#define INSTALL_PACKAGE_OPTION          'I'
#define ADVERTISE_PACKAGE_OPTION        'J'
#define LOG_OPTION                      'l'
#define SMS_MIF_OPTION                  'm'
#define PROPERTIES_OPTION               'o'
#define APPLY_PATCH_OPTION              'P'
#define QUIET_OPTION                    'q'
#define REG_SERVER_OPTION               'R'
#define TRANSFORMS_OPTION               't'
#define UNREG_SERVER_OPTION             'U'
#define SERVICE_OPTION                  'V'
#define UNINSTALL_PACKAGE_OPTION        'X'
#define SELF_REG_OPTION                 'Y'
#define SELF_UNREG_OPTION               'Z'
#define HELP_2_OPTION                   '?'
#define INSTANCE_OPTION                 'n'
#define ADVERTISE_INSTANCE_OPTION       'c'

#define CHECKRUNONCE_OPTION             '@' // special option only allowed in RunOnce command-line
														  // so its not a part of the szCmdLineOptions array 

//__________________________________________________________________________
//
// Global variables in engine module
//__________________________________________________________________________

extern long g_cInstances; // defined by module.h within engine.cpp
extern scEnum g_scServerContext;
extern bool g_fWin9X;   // true if Windows 95 or 98, else false
extern bool g_fWinNT64; // true if 64-bit Windows NT, else false
extern int g_fSmartShell; // true if on shell that supports DD shortcuts
extern int g_iMajorVersion;
extern int g_iMinorVersion;
extern int g_iWindowsBuild;
extern HINSTANCE g_hInstance;
extern REGSAM g_samRead; // used in msinst.cpp to factor in the ability to read 64 bit hive from 32 bit msi.dll

// ShellFolder structures used in coreactn.cpp and execute.cpp for shell folders determination
// defined in services.cpp
extern const ShellFolder rgShellFolders[];
extern const ShellFolder rgAllUsersProfileShellFolders[];
extern const ShellFolder rgPersonalProfileShellFolders[];

// Reinstall mode flag chars
// WARNING: These characters must track the REINSTALLMODE bit flags in
//          msi.h. REINSTALLMODE 0x1 must correspond to the first reinstall 
//          mode specified here, 0x2 to the second, 0x4 to the third, etc...
//
//          Also, these modes must all be lower-case letters!

const ICHAR szReinstallMode[] ={'r',  // Reserved - unused
								'p',  // Reinstall only if file not present
								'o',  // Overwrite Older versioned files
								'e',  // Overwrite Equal versioned files
								'd',  // Overwrite files of Differing version (either older or newer)
								'c',  // Overwrite Corrupted exes and dlls
								'a',  // Overwrite All files, regardless of version
								'm',  // write required machine reg entries
								'u',  // write required user reg entries
								's',  // Install shortcuts, overwrite any existing
								'v',  // Re-install source install package
								0};


// Log file definitions
// WARNING: These characters must track the INSTALLLOGMODE bit flags in
//          msi.h. INSTALLLOGMODE 0x1 must correspond to the first log
//          mode specified here, 0x2 to the second, 0x4 to the third, etc...


const ICHAR szLogChars[] = {'m', // imtOutOfMemory
							'e', // imtError
							'w', // imtWarning
							'u', // imtUser
							'i', // imtInfo
							'f', // OBSOLETE: imtFilesInUse - only used as placeholder for this array
								  //           since INSTALLMESSAGE_FILESINUSE is in this place in the
								  //           INSTALLMESSAGE enum
							's', // imtResolveSource
							'o', // imtOutOfDiskSpace
							'a', // imtActionStart
							'r', // imtActionData (record)
							'p', // iLogPropertyDump
							'c', // imtCommonData
							'v', // verbose
							'x', // secondary debugging information - useful for setup developers
								 // Place new true log modes here.
								 // See comment below on how these characters must track with lmaEnum
							'!', 
							 0};

#ifdef DEBUG
const ICHAR g_szNoSFCMessage[] = TEXT("Windows File Protection handle has not been initialized!");
#endif // DEBUG

// This should be the number of characters before the '!' character
const int cchLogModeCharsMax = 14;

enum lmaEnum	// Log Mode Attribute Enum
                // These should track the characters at the end of szLogChars
{
	lmaFlushEachLine = 0,
};


// Byte equivalents for each action
const int ibeRemoveFiles	       = 175000;
const int ibeRegisterFonts        = 1800000;
const int ibeUnregisterFonts      = 1800000;
const int ibeWriteRegistryValues  = 13200;
const int ibeRemoveRegistryValues = 13200;
const int ibeWriteIniValues       = 13200;
const int ibeRemoveIniValues      = 13200;
const int ibeSelfRegModules       = 1300000;
const int ibeSelfUnregModules     = 1300000;
const int ibeBindImage            = 800000;
const int ibeRegisterComponents   = 24000;
const int ibeUnregisterComponents = 24000;
const int ibeServiceControl       = 1300000;


const int iesReboot    = -1;     // private return Terminate: propogate reboot requirement to caller
const int iesRebootNow = -2;     // private return Terminate: propogate reboot requirement to caller
const int iesCallerReboot = -3;  // private return Terminate: expect caller to invoke reboot
const int iesRebootRejected = -4;// private return Terminate: reboot required but rejected by user

const int iesNotDoneYet = -1;     // private return from FindAndRunAction and RunThread
const int iesActionNotFound = -2; // private return from FindAndRunAction
const int iesExeLoadFailed  = -3; // private return from RunThread
const int iesDLLLoadFailed  = -5; // private return from RunThread
const int iesServiceConnectionFailed = -6; // private return from RunThread
const int iesUnsupportedScriptVersion = -10; // private return from CMsiExecute::RunScript

const int iesErrorIgnored   = -11; // private return from ixo* operations - indicates error occurred
											  // but was ignored so script processing should continue

const int msidbSumInfoSourceTypeURL = 0x8000; // private return from GetSourceType

const int iuiUseUninstallBannerText = 0x8000;
const int iuiNoModalDialogs   = 0x4000;
const int iuiDefault          = 0x2000;
const int iuiHideBasicUI      = 0x1000;
const int iuiHideCancel       = 0x0800;
const int iuiSourceResOnly    = 0x0400;

// Bit flags for the RuntimeFlags column of the component table
const int bfComponentCostMarker        = 0x01;
const int bfComponentCompressed        = 0x02;
const int bfComponentPatchable         = 0x04;
const int bfComponentDisabled          = 0x08;
const int bfComponentCostInitialized   = 0x10;
const int bfComponentNeverOverwrite    = 0x20;

// Bit flags for the RuntimeFlags column of the FeatureComponents table
const int bfComponentRegistered        = 0x01;

// Bit flags for the RuntimeFlags column of the Feature table
const int bfFeatureMark      = 0x01;
const int bfFeaturePatchable = 0x02;
const int bfFeatureCompressable = 0x04;

// MAINTAIN: compatibility with versions used to create script files
const int iScriptCurrentMinorVersion =  4; // bump when any change made to script format
const int iScriptCurrentMajorVersion = 21; // bump when non-backward-compatible change made to script format (SHOULD NEVER HAPPEN)

const int iScriptVersionMinimum = 18; // TEMP - should be set to iScriptCurrentMajorVersion when that is bumped to 21
const int iScriptVersionMaximum = iScriptCurrentMajorVersion;

// internal script flag that is set so that we honour the Assignment option in the script
// the MsiAdvertiseScript call ignores the Assignment option in the script so that the 
// user vs machine assignment is controlled by the flag in the MsiAdvertiseScript fn.
#define SCRIPTFLAGS_MACHINEASSIGN_SCRIPTSETTINGS 0x80000000L

// internal script flag that is set to force the reversal of the script operations 
// when unadvertising from MsiAdvertiseScript
#define SCRIPTFLAGS_REVERSE_SCRIPT 0x40000000L

// internal script flag to indicate we have been called via MsiAdvertiseScript
#define SCRIPTFLAGS_INPROC_ADVERTISEMENT 0x20000000L

// older SCRIPTFLAGS defines used for backward compatibility
const int SCRIPTFLAGS_REGDATA_OLD = 0x00000002L;
const int SCRIPTFLAGS_REGDATA_APPINFO_OLD = 0x00000010L;

enum ipiEnum  // GetInProgressInstallInfo record fields
{
	ipiProductKey = 1,
	ipiProductName,
	ipiLogonUser,
	ipiSelections,
	ipiFolders,
	ipiProperties,
	ipiDatabasePath,
	ipiDiskPrompt,
	ipiDiskSerial,
	ipiRunning,
	ipiTimeStamp,
	ipiSRSequence,   // System Restore Sequence # - Millenium only
	ipiAfterReboot,
	ipiEnumNext,
	ipiEnumCount = ipiEnumNext-1
};

enum ircSharedDllFlags
{
	ircenumRefCountDll        = 0x1,
	ircenumLegacyFileExisted  = 0x2,
};

enum tsEnum // TransformsSecure
{
	tsUnknown,   // Transforms are secure but we're not 
					 // sure yet whether they're relative or absolute
	tsNo,        // Transforms are not secure
	tsRelative,  // Transforms are secure and relatively pathed (i.e at-source)
	tsAbsolute   // Transforms are secure and absolutely pathed
};

// assignment types
enum iaaAppAssignment{
	iaaUserAssign = 0,
	iaaBegin = iaaUserAssign,
	iaaUserAssignNonManaged,
	iaaMachineAssign,
	iaaNone,
	iaaEnd = iaaNone,
};

// positions for applying appcompat transforms
enum iacpAppCompatTransformApplyPoint{
	iacpBeforeTransforms = 1,
	iacpAfterTransforms  = 2,
};

//__________________________________________________________________________
//
// Global factory functions in engine module
//__________________________________________________________________________

class CMsiEngine;

IMsiServices*  LoadServices();   // managed pointer, DO NOT RELEASE()
int            FreeServices();   // must be called for each LoadServices

IMsiServices*  CreateServices(); // should be removed from here and made private

IUnknown*    CreateEngine();
IMsiEngine*  CreateEngine(IMsiServer& riConfigManager);
IMsiEngine*  CreateEngine(IMsiDatabase& riDatabase);
IMsiEngine*  CreateEngine(IMsiStorage* piStorage, IMsiDatabase* piDatabase, CMsiEngine* piParentEngine, BOOL fServiceRequired);

IUnknown* CreateMessageHandler();
IMsiMessage* CreateMessageHandler(HWND hwndParent);

IUnknown* CreateExecutor();
IMsiExecute* CreateExecutor(IMsiConfigurationManager& riConfigurationManager,
									 IMsiMessage& riMessage, IMsiDirectoryManager* piDirectoryManager,
									 Bool fRollbackEnabled,
									 unsigned int fFlags = SCRIPTFLAGS_MACHINEASSIGN_SCRIPTSETTINGS | SCRIPTFLAGS_REGDATA | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS, HKEY* phKey = 0);
IMsiRecord*  CreateScriptEnumerator(const ICHAR* szScriptFile, IMsiServices& riServices,
												IEnumMsiRecord*& rpiEnum);

IMsiConfigurationManager* CreateConfigurationManager();
IMsiConfigurationManager* CreateConfigManagerAsServer();

IMsiCustomAction* CreateCustomAction();

IMsiServer* CreateMsiServerProxyFromRemote(IMsiServer& riDispatch);
IMsiRemoteAPI*    CreateMsiRemoteAPI();

const IMsiString& GetMsiDirectory();
const IMsiString& GetTempDirectory();

const ICHAR szLocalSystemSID[] = TEXT("S-1-5-18");
bool IsLocalSystemToken(HANDLE hToken);

void GetHomeEnvironmentVariables(const IMsiString*& rpiProperties);

IMsiRecord* GetSharedDLLCount(IMsiServices& riServices,
										const ICHAR* szFullFilePath,
										ibtBinaryType iType,
										const IMsiString*& rpistrCount);
IMsiRecord* SetSharedDLLCount(IMsiServices& riServices,
										const ICHAR* szFullFilePath,
										ibtBinaryType iType,
										const IMsiString& ristrCount);
extern IMsiRegKey* g_piSharedDllsRegKey;
extern IMsiRegKey* g_piSharedDllsRegKey32;	// initialized only on Win64 (to the redirected 32-bit key)
class CWin64DualFolders;
extern CWin64DualFolders g_Win64DualFolders;


//IMsiConfigurationManager* CreateConfigurationManager(IMsiServices& riServices);

IDispatch* CreateAutoEngineEx(MSIHANDLE hEngine, DWORD dwThreadId);  // in autoapi.cpp

class CCoUninitialize
{
public:
	CCoUninitialize(bool fCoUninitialize) : m_fCoUninitialize(fCoUninitialize) {}
	~CCoUninitialize() {if (m_fCoUninitialize) OLE32::CoUninitialize();}
protected:
	bool m_fCoUninitialize;
};


//__________________________________________________________________________
//
// global string objects exposed without implementation
// dummy implementation of IMsiString to allow external global string object refs

// NOTE: implementation required to get around compiler bug that won't allow
// externs to global string object refs.  This is a purely virtual class that mimics
// the CMsiStringBase: public IMsiString declaration.  Additionally, for support on Win64,
// must also include the same data members because on IA64, global variables come
// in 2 different flavors -- near and far -- depending on their size.  Without the data
// members, the global variable is generated as near because it has no data members.
// The linker error (lnk2003) results because the actual variable is far

//__________________________________________________________________________

class CMsiStringExternal : public IMsiString
{
 public:
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	const IMsiString&   __stdcall GetMsiStringValue() const;
	const ICHAR*  __stdcall GetString() const;
#ifdef USE_OBJECT_POOL
	unsigned int  __stdcall GetUniqueId() const;
	void          __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
	int           __stdcall CopyToBuf(ICHAR* rgch, unsigned int cchMax) const;
	void          __stdcall SetString(const ICHAR* sz, const IMsiString*& rpi) const;
	int           __stdcall GetIntegerValue() const;
	int           __stdcall TextSize() const;
	int           __stdcall CharacterCount() const;
	Bool          __stdcall IsDBCS() const;
	void          __stdcall RefString(const ICHAR* sz, const IMsiString*& rpi) const;
	void          __stdcall RemoveRef(const IMsiString*& rpi) const;
	void          __stdcall SetChar  (ICHAR ch, const IMsiString*& rpi) const;
	void          __stdcall SetInteger(int i,   const IMsiString*& rpi) const;
	void          __stdcall SetBinary(const unsigned char* rgb, unsigned int cb, const IMsiString*& rpi) const;
	void          __stdcall AppendString(const ICHAR* sz, const IMsiString*& rpi) const;
	void          __stdcall AppendMsiString(const IMsiString& pi, const IMsiString*& rpi) const;
	const IMsiString&   __stdcall AddString(const ICHAR* sz) const;
	const IMsiString&   __stdcall AddMsiString(const IMsiString& ri) const;
	const IMsiString&   __stdcall Extract(iseEnum ase, unsigned int iLimit) const;
	Bool          __stdcall Remove(iseEnum ase, unsigned int iLimit, const IMsiString*& rpi) const;
	int           __stdcall Compare(iscEnum asc, const ICHAR* sz) const;
	void          __stdcall UpperCase(const IMsiString*& rpi) const;
	void          __stdcall LowerCase(const IMsiString*& rpi) const;
	ICHAR*        __stdcall AllocateString(unsigned int cb, Bool fDBCS, const IMsiString*& rpi) const;
 protected:  // state data
	int  m_iRefCnt;
	unsigned int  m_cchLen;
};
class CMsiStringNull : public CMsiStringExternal {};
class CMsiStringLive : public CMsiStringExternal {};

extern const CMsiStringNull g_MsiStringNull;     // THE only static null string object
extern const CMsiStringLive g_MsiStringDate;     // dynamic global date string object
extern const CMsiStringLive g_MsiStringTime;     // dynamic global time string object

//__________________________________________________________________________
//
// Global factory functions from services, available only in engine+services DLL
//__________________________________________________________________________

inline const IMsiString&  CreateString() {return g_MsiStringNull;};  //!! obsolete
IMsiRecord&  CreateRecord(unsigned int cParam);
ICHAR*       AllocateString(unsigned int cbSize, Bool fDBCS, const IMsiString*& rpiStr);
IMsiRecord*  CreateFileStream(const ICHAR* szFile, Bool fWrite, IMsiStream*& rpiStream);

//__________________________________________________________________________
//
// General utility functions
//__________________________________________________________________________

const IMsiString& GetInstallerMessage(UINT iError);
UINT              MapInitializeReturnToUINT(ieiEnum iei);
ieiEnum           MapStorageErrorToInitializeReturn(IMsiRecord* piError);
bool			  __stdcall FIsUpdatingProcess (void);
IMsiRecord*       GetServerPath(IMsiServices& riServices, bool fUNC, bool f64Bit,
										  const IMsiString*& rpistrServerPath);

void              CreateCabinetStreamList(IMsiEngine& riEngine, const IMsiString*& rpistrStreamList);

Bool              GetProductInfo(const ICHAR* szProductKey, const ICHAR* szProperty, CTempBufferRef<ICHAR>& rgchInfo);
Bool              GetPatchInfo(const ICHAR* szPatchCode, const ICHAR* szProperty, CTempBufferRef<ICHAR>& rgchInfo);

Bool              GetExpandedProductInfo(const ICHAR* szProductCode, const ICHAR* szProperty, 
                     CTempBufferRef<ICHAR>& rgchExpandedInfo, bool fPatch=false);
IMsiRecord*       GenerateSD(IMsiEngine& riEngine, IMsiView& riviewLockList, IMsiRecord* piExecute, IMsiStream*& rpiSD);
IMsiRecord*       GetSourcedir(IMsiDirectoryManager& riDirManager, const IMsiString*& rpiValue);
IMsiRecord*       GetSourcedir(IMsiDirectoryManager& riDirManager, IMsiPath*& rpiPath);
Bool              IsCachedPackage(IMsiEngine& riEngine, const IMsiString& riPackage, Bool fPatch = fFalse, const ICHAR* szPatchCode = 0);
Bool              FFeaturesInstalled(IMsiEngine& riEngine, Bool fAllClients = fTrue);
IMsiRecord*       GetProductClients(IMsiServices& riServices, const ICHAR* szProduct, const IMsiString*& rpistrClients);
void              ExpandEnvironmentStrings(const ICHAR* szString, const IMsiString*& rpiExpandedString);
IMsiRecord*       GetComponentPath(IMsiServices& riServices, const ICHAR* szUserId, const IMsiString& riProductKey, 
											  const IMsiString& riComponentCode, 
											  IMsiRecord *& rpiRec,
											  iaaAppAssignment* piaaAsgnType);
Bool              ProcessCommandLine(const ICHAR* szCommandLine,
											  const IMsiString** ppistrLanguage, const IMsiString** ppistrTransforms,
											  const IMsiString** ppistrPatch, const IMsiString** ppistrAction,
											  const IMsiString** ppistrDatabase,
											  const IMsiString* pistrOtherProp, const IMsiString** ppistrOtherPropValue,
											  Bool fUpperCasePropNames, const IMsiString** ppistrErrorInfo,
											  IMsiEngine* piEngine, bool fRejectDisallowedProperties=false);
unsigned int      ProductVersionStringToInt(const ICHAR* szVersion);
HANDLE            GetUserToken();

bool              __stdcall TestAndSet(int* pi);
IMsiRecord* ExpandShellFolderTransformPath(const IMsiString& riOriginalPath, const IMsiString*& riExpandedPath, IMsiServices& riServices);

struct PatchTransformState
{
	int iMinDiskID;
	int iMaxDiskID;
	int iMinSequence;
	int iMaxSequence;
};


IMsiRecord* ApplyTransform(IMsiDatabase& riDatabase,
									IMsiStorage& riTransform,
									int iErrorConditions,
									bool fPatchOnlyTransform,
									PatchTransformState* piState);

bool PostScriptWriteError(IMsiMessage& riMessage);
bool WriteScriptRecord(CScriptGenerate* pScript, ixoEnum ixoOpCode, IMsiRecord& riParams,
							  bool fForceFlush, IMsiMessage& riMessage);

IMsiRecord* SetInProgressInstallInfo(IMsiServices& riServices, IMsiRecord& riRec);
IMsiRecord* UpdateInProgressInstallInfo(IMsiServices& riServices, IMsiRecord& riRec);
IMsiRecord* GetInProgressInstallInfo(IMsiServices& riServices, IMsiRecord*& rpiRec);
bool ClearInProgressInformation(IMsiServices& riServices);
DWORD GetFileLastWriteTime(const ICHAR* szSrcFile, FILETIME& rftLastWrite);
DWORD MsiSetFileTime(const ICHAR* szDestFile, FILETIME* pftLastWrite);


#ifdef DEBUG
void              DisplayAccountName(const ICHAR* szMessage, PISID pSid=0);
bool              GetAccountNameFromToken(HANDLE hToken, ICHAR* szAccount, DWORD cchSize);
#define           DISPLAYACCOUNTNAMEFROMSID(m, s) DisplayAccountName(m, s)
#define           DISPLAYACCOUNTNAME(m)           DisplayAccountName(m)
#define           GETACCOUNTNAMEFROMTOKEN(t, a, c)   GetAccountNameFromToken(t,a,c);
#else
#define           DISPLAYACCOUNTNAMEFROMSID(m, s)
#define           DISPLAYACCOUNTNAME(m)
#define           GETACCOUNTNAMEFROMTOKEN(t, a, c)
#endif

//__________________________________________________________________________
//
// SID manipulation functions
//__________________________________________________________________________

const int cbMaxSID = sizeof(SID) + SID_MAX_SUB_AUTHORITIES*sizeof(DWORD);
const int cchMaxSID = 256;

void  GetStringSID(PISID pSID, ICHAR* szSID);
DWORD GetUserSID(HANDLE hToken, char rgchSID[cbMaxSID]);
//DWORD GetUserStringSID(HANDLE hToken, ICHAR* szSID);
DWORD GetCurrentUserSID(char rgchSID[cbMaxSID]);
DWORD GetCurrentUserStringSID(const IMsiString*& rpistrSid);
DWORD GetCurrentUserStringSID(ICHAR szSID[cchMaxSID]);
DWORD GetCurrentUserToken(HANDLE& hToken, bool& fCloseHandle);

struct ThreadIdImpersonate
{
	DWORD        m_dwThreadId;
	DWORD        m_dwClientThreadId;
};

// return values from PathType
enum iptEnum
{
	iptInvalid = 1,
	iptRelative,
	iptFull,
};
iptEnum      PathType(const ICHAR* szPath);


enum ielEnum
{
	ielNoAction = 0,
	ielLogFatalError,
	ielFatalErrorLogged,
	ielNextEnum
};

//____________________________________________________________________________
//
// Script record format definitions
//   all data is 16-bit aligned, except within non-Unicode strings
//____________________________________________________________________________


const int iScriptSignature     = 0x534f5849L; // signature to valid script file type

//____________________________________________________________________________
//
// User registraion and PID 2.0 definitions
//____________________________________________________________________________

// ProductId definitions
const int cchPidRpc    = 5;  // product code, followed by '-'
const int cchPidSite   = 3;  // site code, followed by '-'
const int cchPidSerial = 7;  // serial number with check digit, followed by '-'
const int cchPidUnique = 5;  // randomized per install, or part of OEM COA serial
const int cchPidTotal = cchPidRpc + 1 + cchPidSite + 1 + cchPidSerial + 1 + cchPidUnique;
const int cchPidCdKey = cchPidSite + 1 + cchPidSerial;
const ICHAR chPidSeparator = '-'; // dashes used to separate PID fields

// Next location to query for User/Company info, ACME installs, HKEY_CURRENT_USER,
// if MsiGetUserInfo fails to get the information
const ICHAR szUserInfoKey[] = TEXT("Software\\Microsoft\\MS Setup (ACME)\\User Info");
const ICHAR szDefName[]     = TEXT("DefName");
const ICHAR szDefOrg[]      = TEXT("DefCompany");
// Final location to query for User/Company info, OS installation, HKEY_LOCAL_MACHINE
const ICHAR szSysUserKey[]  = TEXT("Software\\Microsoft\\Windows\\CurrentVersion");
const ICHAR szSysUserKeyNT[]  = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion");
const ICHAR szSysUserName[] = TEXT("RegisteredOwner");
const ICHAR szSysOrgName[]  = TEXT("RegisteredOrganization"); 

const int cchUserNameOrgMax = 62;

//____________________________________________________________________________
//
// Miscellaneous shared constants
//____________________________________________________________________________

const ICHAR szDefaultAction[] = TEXT("INSTALL");

const ICHAR szRunOnceKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
const ICHAR szBlankVolumeLabelToken[] = TEXT("?");

// string representing self as client, for parent installs
const ICHAR szSelfClientToken[] = TEXT(":");


const ICHAR szUserEnvironmentSubKey[]    = TEXT("Environment");
const ICHAR szMachineEnvironmentSubKey[] = TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Environment");

const ICHAR szNonEmptyPath[] = TEXT("TOKEN"); // token string to cause removal of the filename registration

const ICHAR szUnresolvedSourceRootTokenWithBS[] = TEXT("1\\");

//____________________________________________________________________________
//
// Miscellaneous queries used by several actions
//____________________________________________________________________________
const ICHAR sqlLockPermissions[] = TEXT("SELECT `Domain`,`User`,`Permission` FROM `LockPermissions` WHERE `Table`=? AND `LockObject`=? ORDER BY `Permission`");

//____________________________________________________________________________
//
// Internet Download Wrapper
//____________________________________________________________________________

DWORD DownloadUrlFile(const ICHAR* szPotentialURL, const IMsiString*& rpistrDownload, bool& fURL, int cTicks = 0, bool* pfUsedWinHttp = 0);

//____________________________________________________________________________
//
// WinHttp download
//____________________________________________________________________________

DWORD WinHttpDownloadUrlFile(const ICHAR* szUrl, const IMsiString*& rpistrDownload, int cTicks);

//____________________________________________________________________________________
//
//	CMsiWinHttpProgress class - progress handler for WINHTTP internet download
//____________________________________________________________________________________

class CMsiWinHttpProgress
{
public:
	 CMsiWinHttpProgress(int cTicks = 0);
	~CMsiWinHttpProgress();

	bool BeginDownload(DWORD cProgressMax);
	bool ContinueDownload(DWORD cProgressIncr);
	bool FinishDownload();

private:
	PMsiRecord   m_pRecProgress;
	unsigned int m_cTicksSoFar;
	int          m_cTotalTicks;
	bool         m_fReset;
};

//_______________________________________________________________________________
//
// CDeleteUrlLocalFileOnClose - smart class to cleanup URL download local files
//_______________________________________________________________________________

class CDeleteUrlLocalFileOnClose
{
public:
	CDeleteUrlLocalFileOnClose(IMsiString const& ristrFileName, bool fDeleteFromIECache) : m_pistrFileName(&ristrFileName), m_fDeleteFromIECache(fDeleteFromIECache)
		{ m_pistrFileName->AddRef(); }
	CDeleteUrlLocalFileOnClose() : m_pistrFileName(0), m_fDeleteFromIECache(false)
		{ /* do nothing, will most likely be set explicitly later.*/ }

	~CDeleteUrlLocalFileOnClose()
		{
			// delete url file from URLMON cache
			if (m_pistrFileName && m_pistrFileName->TextSize())
			{
				if (m_fDeleteFromIECache)
				{
					DEBUGMSGV1(TEXT("Deleting URL cache copy %s."), m_pistrFileName->GetString());
                    // cleaning up is just being polite, don't do anything special if this fails
					WININET::DeleteUrlCacheEntry(m_pistrFileName->GetString());
				}
				else
				{
					DEBUGMSGV1(TEXT("Deleting URL local copy %s."), m_pistrFileName->GetString());

					// cleaning up is just being polite, don't do anything special if this fails.
					if (scService == g_scServerContext)
					{
						// elevate block to access secure location
						CElevate elevate;
						DeleteFile(m_pistrFileName->GetString());
					}
					else
					{
						DeleteFile(m_pistrFileName->GetString());
					}
				}
			}

			// clean up class
			if (m_pistrFileName)
			{
				m_pistrFileName->Release(), m_pistrFileName=0;
			}
		}

	void SetFileName(IMsiString const& ristrFileName, bool fDeleteFromIECache)
		{
			Assert(!m_pistrFileName);
			m_pistrFileName = &ristrFileName;
			m_pistrFileName->AddRef();
			m_fDeleteFromIECache = fDeleteFromIECache;
		}

	const IMsiString* GetFileName()
		{
			if (m_pistrFileName)
				m_pistrFileName->AddRef();
			
			return m_pistrFileName;
		}

 protected:
 	const IMsiString *m_pistrFileName;
	bool m_fDeleteFromIECache;
};

//____________________________________________________________________________
//
// URLMON download
//____________________________________________________________________________

DWORD UrlMonDownloadUrlFile(const ICHAR* szUrl, const IMsiString*& rpistrDownload, int cTicks);

//________________________________________________________________________________
//
//	CMsiBindStatusCallback class - progress handler for URLMON internet download
//________________________________________________________________________________

class CMsiBindStatusCallback : public IBindStatusCallback
{
 public: // IUnknown implemented virtual functions
	HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long   __stdcall AddRef();
	unsigned long   __stdcall Release();
 public: // IBindStatusCallback implemented virtual functions

	/*----------------------------------------------------------------------------
	cTicks is the number of ticks we're allotted in the progress bar. If cTicks
	is 0 then we'll assume that we own the progress bar and use however many
	ticks we want, resetting the progress bar when we start and when we're done.
	If cTicks is set, however, we won't reset the progress bar. 
  -----------------------------------------------------------------------------*/
	CMsiBindStatusCallback(unsigned int cTicks = 0);

	HRESULT __stdcall OnStartBinding(DWORD, IBinding*) {return S_OK;}
	HRESULT __stdcall GetPriority(LONG*) {return S_OK;}
	HRESULT __stdcall OnLowResource(DWORD ) {return S_OK;}
	HRESULT __stdcall OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText);
	HRESULT __stdcall OnStopBinding(HRESULT, LPCWSTR ) {return S_OK;}
	HRESULT __stdcall GetBindInfo(DWORD*, BINDINFO*) {return S_OK;}
	HRESULT __stdcall OnDataAvailable(DWORD, DWORD, FORMATETC*, STGMEDIUM*) {return S_OK;}
	HRESULT __stdcall OnObjectAvailable(REFIID, IUnknown*) {return S_OK;}
 private:
	int          m_iRefCnt;
	PMsiRecord   m_pProgress;
	unsigned int m_cTicksSoFar;
	unsigned int m_cTotalTicks;
	Bool         m_fResetProgress;
};

//____________________________________________________________________________
//
// External handle management
//____________________________________________________________________________

typedef unsigned long MSIHANDLE;     // abstract generic handle, 0 == no handle
MSIHANDLE CreateMsiHandle(IUnknown* pi, int iid); // no AddRef called
MSIHANDLE CreateMsiProductHandle(IMsiEngine* pi); // no AddRef called

IMsiEngine* GetEngineFromHandle(MSIHANDLE h);
IUnknown* FindMsiHandle(MSIHANDLE h, int iid);

class CActionThreadData;
iesEnum ScheduledCustomAction(IMsiRecord& riParams, const IMsiString& ristrProductCode,
				LANGID langid, IMsiMessage& riMessage, bool fRunScriptElevated, bool fAppCompatEnabled, 
				const GUID* guidAppCompatDB, const GUID* guidAppCompatID);
MSIHANDLE CreateCustomActionContext(int icaFlags, const IMsiString& ristrCustomActionData,
					const IMsiString& ristrProductCode, LANGID langid, IMsiMessage& riMessage);
void WaitForCustomActionThreads(IMsiEngine* piEngine, Bool fTerminate, IMsiMessage& riMessage);

//____________________________________________________________________________
//
// Exception handling functions
//____________________________________________________________________________

extern void GenerateExceptionReport(LPEXCEPTION_POINTERS pExceptionInfo);
extern void GenerateExceptionReport(EXCEPTION_RECORD* pExceptionRecord, CONTEXT* pCtx);
extern int HandleException(LPEXCEPTION_POINTERS pExceptionInfo);

//____________________________________________________________________________
//
// String handling utilities
//____________________________________________________________________________

UINT FillBufferW(const ICHAR* psz, unsigned int cch, LPWSTR szBuf, DWORD* pcchBuf);
UINT FillBufferA(const ICHAR* psz, unsigned int cch, LPSTR szBuf, DWORD* pcchBuf);

inline UINT FillBufferA(const IMsiString* pistr, LPSTR szBuf, DWORD* pcchBuf)
{
	return FillBufferA((pistr ? pistr->GetString() : 0), (pistr ? pistr->TextSize() : 0), szBuf, pcchBuf);
}

inline UINT FillBufferW(const IMsiString* pistr, LPWSTR szBuf, DWORD* pcchBuf)
{
	return FillBufferW((pistr ? pistr->GetString() : 0), (pistr ? pistr->TextSize() : 0), szBuf, pcchBuf);
}

const IMsiString& GetMsiStringW(LPCWSTR sz);

// special chars in string

const ICHAR DELIMITER_BEGIN('[');
const ICHAR DELIMITER_END(']');
const ICHAR PATH_TOKEN('%');
const ICHAR FILE_TOKEN('#');
const ICHAR STORAGE_TOKEN(':');  // transform
const ICHAR PATCHONLY_TOKEN('#');  // transform containing patch information only
const ICHAR SHELLFOLDER_TOKEN('*');  // transform
const ICHAR SECURE_RELATIVE_TOKEN('@'); // transform
const ICHAR SECURE_ABSOLUTE_TOKEN('|'); // transform

//____________________________________________________________________________
//
// CMsiClientMessage definition - COM object to wrapper g_MessageContext.Invoke
//____________________________________________________________________________

class CMsiClientMessage: public IMsiMessage
{
 public: // IMsiMessage implemented virtual functions
	HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long   __stdcall AddRef();
	unsigned long   __stdcall Release();
	imsEnum         __stdcall Message(imtEnum imt, IMsiRecord& riRecord);
	imsEnum         __stdcall MessageNoRecord(imtEnum imt);
 public: // constructor/destructor
	void *operator new(size_t cb) { return AllocSpc(cb); }
	void operator delete(void * pv) { FreeSpc(pv); }
	CMsiClientMessage() : m_iRefCnt(1) {g_cInstances++;}
 private:
	int                m_iRefCnt;
	bool               m_fMessageContextInitialized;
	friend IUnknown*   CreateMessageHandler();
};

//____________________________________________________________________________
//
// MsiUIMessageContext - Message dispatching definitions
//____________________________________________________________________________

#define imtInvalid  imtEnum(0x80000000)  // to detect invalid event triggers
#define imsInvalid  imsEnum(0x80000000)  // to detect invalid event triggers
#define imsBusy     imsEnum(0x80000001)  // in UI processing thread

class CBasicUI;
class CMsiConfigurationManager;

struct CMainThreadData  // temp arguments to CreateAndRunEngine passed to new thread
{
	CMainThreadData(ireEnum ireProductSpec) : m_ireProductSpec(ireProductSpec) {}
	ireEnum m_ireProductSpec;     // type of product specification
};

struct CEngineMainThreadData : public CMainThreadData
{
	CEngineMainThreadData(ireEnum ireProductSpec, const ICHAR* szProduct, const ICHAR* szAction, const ICHAR* szCmdLine, iioEnum iioOptions) : 
								CMainThreadData(ireProductSpec), 
								m_szProduct(szProduct), 
								m_szAction(szAction), 
								m_szCmdLine(szCmdLine),
								m_iioOptions(iioOptions) {}

	const ICHAR* m_szProduct;  // product specification
	const ICHAR* m_szAction;   // optional, engine defaults to "INSTALL"
	const ICHAR* m_szCmdLine;  // optional property list
	iioEnum      m_iioOptions; // install options
};

struct CInstallFinalizeMainThreadData : public CMainThreadData
{
	CInstallFinalizeMainThreadData(ireEnum ireProductSpec, iesEnum iesState, CMsiConfigurationManager* piConman) : 
							CMainThreadData(ireProductSpec), 
							m_iesState(iesState), 
							m_piConman(piConman) {}

	iesEnum                   m_iesState;
	CMsiConfigurationManager* m_piConman;
};

extern CRITICAL_SECTION  g_csWriteLog;      // serialization of writes to the log file

struct MsiUIMessageContext
{
 public: // data dynamically set by message handling before Invoke
	IMsiEngine*           m_piEngine;     // temp. for LoadHandler, not ref counted
	const ICHAR*          m_szAction;     // temp. for ShowDialog, not allocated
	CRITICAL_SECTION      m_csDispatch;   // serialization of UI message requests
	ICHAR                 m_rgchExceptionInfo[1024]; // stores exception message when we crash
 private:
	IMsiRecord*           m_pirecMessage; // current message
	imtEnum               m_imtMessage;   // type of current message or function request
 private:  // data set during creation of main thread, or by a function dispatch
	HANDLE  /* / [0] \ */ m_hUIRequest;   // UI request event, must preceed m_hMainThread
	HANDLE  /* \ [1] / */ m_hMainThread;  // main engine thread, must follow m_hUIRequest
	HANDLE  /* / [0] \ */ m_hUIReturn;    // event to unblock UI request thread, preceeds m_hUIThread
	HANDLE  /* \ [1] / */ m_hUIThread;    // UI thread if UI in child thread, must follow m_hUIReturn
	DWORD                 m_tidUIHandler; // thread ID used to identify call from UI thread
	DWORD                 m_tidMainThread; // thread ID used to identify call from MainEngineThread
	DWORD                 m_tidInitialize; // thread ID used to initialize this object
	DWORD                 m_tidDisableMessages; // disable messages for this thread; used for custom actions in the UI thread
	HINSTANCE             m_hinstHandler;  // DLL instance handle if UI handler used
	int                   m_iLogMode;      // mask of message types to log
	IMsiRecord*           m_pirecNoData;   // empty record used internally, access only via GetNoDataRecord()
	imsEnum               m_imsReturn;     // return status passed back to requestor
	bool                  m_fCancelPending; // UI cancel status, cached response to progress messages 
	bool                  m_fInitialized;  // message context initialized
#ifdef DEBUG
	bool                  m_fCancelReturned;// UI cancel status returned from progress message, save for assert
#endif
	HANDLE                m_hUserToken;    // user impersonation token
	int                   m_iBusyLock;     // 1 when message context busy (initialized), 0 when not
	HANDLE                m_hExternalMutex;// named mutex for testing by external processes, such as autorun
	IMsiHandler*          m_piHandlerSave; // in case handler disabled
//	IServerSecurity*      m_piServerSecurity;// call context to allow impersonation
	IMsiMessage*          m_piClientMessage; // message object from the client side
	HANDLE                m_hLogFile;        // handle to log file if open, else 0
	bool                  m_fLoggingFromPolicy; // policy has triggered logging  //TODO: rename to m_fTemporaryLog
	iuiEnum               m_iuiLevel;        // UI level
	int                   m_cTimeoutDisable; // for custom actions to disable timeout UI
	int                   m_cTimeoutSuppress;// for actions to suppress timeout when no messages being sent
	int                   m_iTimeoutRetry;   // current retry counter
	LPTOP_LEVEL_EXCEPTION_FILTER m_tlefOld;  // old exception fileter
	bool                  m_fHideBasicUI; // set to prevent basic UI from being initialized
	HWND                  m_hwndHidden;      // Hidden window
	bool                  m_fServicesAndCritSecInitialized;
	IMsiServices*         m_piServices;
	LANGID                m_iLangId;         // language of package, used to select resource strings
	unsigned int          m_iCodepage;       // codepage of package, used to select font charset
	bool                  m_fNoModalDialogs;
	bool                  m_fHideCancel;
	bool                  m_fUseUninstallBannerText;
	bool                  m_fSourceResolutionOnly;
	bool                  m_fOEMInstall;
	bool                  m_fOleInitialized; // whether OLE has been initialized on the thread
	bool                  m_fChildUIOleInitialized; // whether OLE has been initialized on the child UI thread
 public: //!! only until GetHandler() fixed or better removed
	IMsiHandler*          m_piHandler;    // full UI handler, only if in use
	HANDLE m_hSfcHandle;   //  handle to Windows 2000 system file protection service
	SAFER_LEVEL_HANDLE m_hSaferLevel; // handle to Whistler SAFER authorization level object
 public:
	UINT    Initialize(bool fCreateUIThread, iuiEnum iuiLevel, DWORD dwPrivilegesMask=0); // false if UI in main thread, true if UI in child thread
	bool    Terminate(bool fFatalExit);       // false for normal termination, true if main thread dead

	UINT    RunInstall(CMainThreadData& riThreadData,
							 iuiEnum iuiLevel,
							 IMsiMessage* piClientMessage, // optional client message handler
							DWORD dwPrivilegesMask =0);
	imsEnum Invoke(imtEnum imt, IMsiRecord* piRecord);
	HWND    GetCurrentWindow();
	const ICHAR* GetWindowCaption();
	bool    IsHandlerLoaded()        { return m_piHandler   != 0; }
	bool    IsInitialized()          { return m_fInitialized; }
//	bool    MainEngineThreadExists() { return m_hMainThread != 0; }
	bool    ChildUIThreadExists()    { return m_hUIThread   != 0; }
	bool    ChildUIThreadRunning()   { DWORD extCode; 
											if (ChildUIThreadExists())
												return !GetExitCodeThread(m_hUIThread, &extCode);
											return fFalse;
									   };
	bool    IsUIThread()             { return WIN::GetCurrentThreadId() == m_tidUIHandler; }
	bool    IsMainEngineThread()     { return WIN::GetCurrentThreadId() == m_tidMainThread; }
	int     GetLogMode()             { return m_iLogMode; }
	LANGID  GetCurrentUILanguage();
//	IServerSecurity* GetServerSecurity() { return m_piServerSecurity;}
	HANDLE           GetUserToken() { AssertSz(IsThreadSafeForSessionImpersonation(), "Security Warning: Accessing install session token from a direct COM thread. This is a security hole in multi-user scenarios.");
									  return m_hUserToken;
									};
	IMsiRecord* GetNoDataRecord();
	void    DisableTimeout()         { m_cTimeoutDisable++; }
	void    EnableTimeout()          { if (m_cTimeoutDisable) m_cTimeoutDisable--; }
	void    SuppressTimeout()        { m_cTimeoutSuppress++; }
	//!! the following should be imt operations or put in CriticalSection!
	void    DisableHandler()         { if (!m_piHandlerSave) m_piHandlerSave=m_piHandler, m_piHandler=0;}
	void    RestoreHandler()         { if (m_piHandlerSave)  m_piHandler=m_piHandlerSave, m_piHandlerSave=0;}
	UINT    SetUserToken(bool fReset=false, DWORD dwPrivilegesMask=0);
	void    DisableThreadMessages(DWORD tid) { Assert(m_tidDisableMessages == 0); m_tidDisableMessages = tid;}
	void    EnableMessages() { Assert(m_tidDisableMessages != 0); m_tidDisableMessages = 0;}
	bool    IsServiceInstalling() { return g_scServerContext == scService && m_iBusyLock != 0 ? true : false; }
	UINT    SetServiceInstalling(boolean fToSet);
#ifdef DEBUG
	bool    WasCancelReturned() {if (m_fCancelReturned){ m_fCancelReturned = false; return true; } return false;}
#endif
	iuiEnum GetUILevel() { return m_iuiLevel; } // For use *ONLY* to set the CLIENTUILEVEL property
	inline bool IsOEMInstall() { return m_fOEMInstall; }
	inline void SetOEMInstall(bool fArg) { m_fOEMInstall = fArg; }
 private:
	static DWORD WINAPI MsiUIMessageContext::ChildUIThread(MsiUIMessageContext* This);
	static DWORD WINAPI MsiUIMessageContext::MainEngineThread(LPVOID);
	static LONG  WINAPI MsiUIMessageContext::ExceptionHandler(EXCEPTION_POINTERS* ExceptionInfo);
	bool FCreateHiddenWindow();
	void KillHiddenWindow();
	imsEnum ProcessMessage(imtEnum imt, IMsiRecord* piRecord); // UI thread message processor
	bool    InitializeEnvironmentVariables();
	bool    RestoreEnvironmentVariables();
	bool    InitializeLog(bool fDynamicLog = false);

 public:  // static constructor
	MsiUIMessageContext()  // static constructor optimized to init static data
	: m_hUIRequest(0), m_hUIReturn(0), m_hMainThread(0), m_hUIThread(0), m_hExternalMutex(0)
	, m_piEngine(0), m_piHandler(0), m_hinstHandler(0), m_piHandlerSave(0)
//	, m_piServerSecurity(0)
	, m_pirecMessage(0), m_pirecNoData(0)
	, m_hLogFile(0), m_cTimeoutDisable(0), m_cTimeoutSuppress(0), m_hUserToken(0), m_iTimeoutRetry(0)
	, m_imtMessage(imtInvalid), m_imsReturn(imsInvalid), m_fCancelPending(false), m_iuiLevel((iuiEnum)iuiDefault)
	, m_fHideBasicUI(false), m_fHideCancel(false), m_fInitialized(false), m_fLoggingFromPolicy(false)
	, m_iBusyLock(0), m_tidUIHandler(0), m_tidMainThread(0), m_tidDisableMessages(0), m_hwndHidden(0)
	, m_piServices(0), m_iLangId(0), m_iCodepage(0)
	, m_hSfcHandle(0), m_hSaferLevel(0), m_fOEMInstall(false), m_fNoModalDialogs(false), m_fUseUninstallBannerText(false)
	, m_fOleInitialized(false), m_fChildUIOleInitialized(false), m_fSourceResolutionOnly(false)
#ifdef DEBUG
	, m_fCancelReturned(false) 
#endif
	{
		m_csDispatch.OwningThread = INVALID_HANDLE_VALUE;
		g_csWriteLog.OwningThread = INVALID_HANDLE_VALUE;
	}
 friend bool CreateLog(const ICHAR* szFile, bool fAppend);
 friend bool LoggingEnabled();
 friend bool WriteLog(const ICHAR* szText);

};

extern MsiUIMessageContext g_MessageContext;  // only one per process


//____________________________________________________________________________
//
// CMsiEngine definitions   
//____________________________________________________________________________

enum scmEnum // m_scmScriptMode
{
	scmIdleScript, // not writing or running script
	scmWriteScript, // writing script
	scmRunScript, // running script
};

enum ippEnum // types of in-progress property strings
{
	ippSelection,
	ippFolder,
	ippProperty,
};

enum issEnum   // install sequence state/segment
{
	issNotSequenced = 0,     // no sequence running, actions called directly
	issPreExecution,         // before InstallInitialize (before script generation)
	issScriptGeneration,     // after InstallInitialize, before InstallFinalize
	issPostExecution,        // after InstallFinalize (after script execution)
};

enum ipitEnum // bit-flags: return from InProgressInstallType
{
	ipitSameConfig    = 0x00,
	ipitDiffUser      = 0x01,
	ipitDiffProduct   = 0x02,
	ipitDiffConfig    = 0x04,
};

enum ieftEnum // Index into the array of ints that gives us column numbers to the file table
{
	ieftKey,
	ieftComponent,
	ieftAttributes,
	ieftName,
	ieftMax,
};

enum ievtEnum // ValidateTransform return values
{
	ievtTransformValid,   // valid transform
	ievtTransformRejected,// transform rejected due to policy
	ievtTransformFailed,  // transform failed
};

class CActionThreadData;  // custom action thread data, defined in action.cpp

// token class used by engine
struct CClientEnumToken{
	CClientEnumToken():m_dwProductIndex(0), m_pCursor(0){}
	void Reset(){m_dwProductIndex = 0;m_pCursor = 0;}
	int m_dwProductIndex;
	PMsiCursor m_pCursor;
};

// Forward declaration
class CMsiServerConnMgr;

class CMsiEngine : public IMsiEngine,
						 public IMsiSelectionManager,
						 public IMsiDirectoryManager
#ifdef DEBUG
						, public IMsiDebug
#endif //DEBUG
{
 public: // IMsiEngine implemented virtual functions
	HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long   __stdcall AddRef();
	unsigned long   __stdcall Release();
	ieiEnum         __stdcall Initialize(const ICHAR* szDatabase,
													 iuiEnum iuiLevel,
													 const ICHAR* szCommandLine,
													 const ICHAR* szProductCode,
													 iioEnum iioOptions);
	iesEnum         __stdcall Terminate(iesEnum iesState);
	IMsiServices*   __stdcall GetServices();
	IMsiHandler*    __stdcall GetHandler();
	IMsiDatabase*   __stdcall GetDatabase();
	IMsiServer*     __stdcall GetConfigurationServer();
	LANGID          __stdcall GetLanguage();
	int             __stdcall GetMode();
	void            __stdcall SetMode(int iefMode, Bool fState);
	iesEnum         __stdcall DoAction(const ICHAR* szAction);
	iesEnum         __stdcall Sequence(const ICHAR* szColumn);
	iesEnum         __stdcall ExecuteRecord(ixoEnum ixoOpCode, IMsiRecord& riParams);
	imsEnum         __stdcall Message(imtEnum imt, IMsiRecord& riRecord);
	imsEnum         __stdcall MessageNoRecord(imtEnum imt);
	IMsiRecord*     __stdcall OpenView(const ICHAR* szName, ivcEnum ivcIntent,
												  IMsiView*& rpiView);
	const IMsiString&     __stdcall FormatText(const IMsiString& riTextString);
	iecEnum         __stdcall EvaluateCondition(const ICHAR* szCondition);
	Bool            __stdcall SetProperty(const IMsiString& riPropertyString,const IMsiString& rData);
	Bool            __stdcall SetPropertyInt(const IMsiString& riPropertyString, int iData);
	const IMsiString&     __stdcall GetProperty(const IMsiString& riPropertyString);
	const IMsiString&     __stdcall GetPropertyFromSz(const ICHAR* szPropertyString);
	const IMsiString&     __stdcall GetEnvironmentVariable(const ICHAR* szEnvVar);
	int             __stdcall GetPropertyInt(const IMsiString& riPropertyString);
	Bool            __stdcall ResolveFolderProperty(const IMsiString& riPropertyString);
	iesEnum         __stdcall FatalError(IMsiRecord& riRecord);
	iesEnum         __stdcall RegisterProduct();
	iesEnum         __stdcall UnregisterProduct();
	iesEnum         __stdcall UnpublishProduct();
	iesEnum         __stdcall RegisterUser(bool fDirect);
	const IMsiString& __stdcall GetProductKey();
	iesEnum         __stdcall CreateProductInfoRec(IMsiRecord*& rpiRec);
	Bool            __stdcall ValidateProductID(bool fForce);
	imsEnum         __stdcall ActionProgress();
	iesEnum         __stdcall RunExecutionPhase(const ICHAR* szActionOrSequence,
															  bool fSequence);
	iesEnum         __stdcall RunNestedInstall(const IMsiString& ristrProduct,
															 Bool fProductCode, // else package path
															 const ICHAR* szAction,
															 const IMsiString& ristrCommandLine,
															 iioEnum iioOptions,
															 bool fIgnoreFailure);
	bool              __stdcall SafeSetProperty(const IMsiString& ristrProperty, const IMsiString& rData);
	const IMsiString& __stdcall SafeGetProperty(const IMsiString& ristrProperty);
	iesEnum         __stdcall BeginTransaction();
	iesEnum         __stdcall RunScript(bool fForceIfMergedChild);
	iesEnum         __stdcall EndTransaction(iesEnum iesStatus);
	CMsiFile*       __stdcall GetSharedCMsiFile();
	void            __stdcall ReleaseSharedCMsiFile();
	IMsiRecord*     __stdcall CreateTempActionTable(ttblEnum iTable);
	const IMsiString& __stdcall GetErrorTableString(int iError);
	UINT            __stdcall ShutdownCustomActionServer();
	CMsiCustomActionManager* __stdcall GetCustomActionManager();
	IMsiRecord*     __stdcall GetAssemblyInfo(const IMsiString& rstrComponent, iatAssemblyType& riatAssemblyType,  const IMsiString** ppistrAssemblyName, const IMsiString** ppistrManifestFileKey);

	IMsiRecord*     __stdcall GetFileHashInfo(const IMsiString& ristrFileKey, DWORD dwFileSize,
															MD5Hash& rhHash, bool& fHashInfo);
	IMsiRecord*    __stdcall GetFolderCachePath(const int iFolderId, IMsiPath*& rpiPath);
	int            __stdcall GetDeterminedPackageSourceType();
	bool           __stdcall FSafeForFullUninstall(iremEnum iremUninstallType);
	iesEnum        __stdcall CleanupTempFilesViaOpcode();



 public: // IMsiDirectoryManager implemented virtual functions
	IMsiRecord*    __stdcall LoadDirectoryTable(const ICHAR* szTableName);
	IMsiTable*     __stdcall GetDirectoryTable();
	void           __stdcall FreeDirectoryTable();
	IMsiRecord*    __stdcall CreateTargetPaths();
	IMsiRecord*    __stdcall CreateSourcePaths();
	IMsiRecord*    __stdcall ResolveSourceSubPaths();

	IMsiRecord*    __stdcall GetTargetPath(const IMsiString& piDest,IMsiPath*& rpiPath);
	IMsiRecord*    __stdcall SetTargetPath(const IMsiString& piDest, const ICHAR* szPath, Bool fWriteCheck);
	IMsiRecord*    __stdcall GetSourcePath(const IMsiString& riDirKey,IMsiPath*& rpiPath); 
	IMsiRecord*    __stdcall GetSourceSubPath(const IMsiString& riDirKey, bool fPrependSourceDirToken,
															const IMsiString*& rpistrSubPath);
	IMsiRecord*    __stdcall GetSourceRootAndType(IMsiPath*& rpiSourceRoot, int& iSourceType);

 public: // IMsiSelectionManager implemented virtual functions
	IMsiRecord*    __stdcall LoadSelectionTables();
	IMsiTable*     __stdcall GetComponentTable();
	IMsiTable*     __stdcall GetFeatureTable();
	IMsiTable*     __stdcall GetVolumeCostTable();
	IMsiRecord*	   __stdcall SetReinstallMode(const IMsiString& riModeString);
	IMsiRecord*    __stdcall ConfigureFeature(const IMsiString& riFeatureString,iisEnum iisActionRequest);
	IMsiRecord*    __stdcall ProcessConditionTable();
	Bool           __stdcall FreeSelectionTables();
	Bool           __stdcall SetFeatureHandle(const IMsiString& riFeature, INT_PTR iHandle);
	IMsiRecord*    __stdcall GetDescendentFeatureCost(const IMsiString& riFeatureString, iisEnum iisAction, int& iCost);
	IMsiRecord*    __stdcall GetFeatureCost(const IMsiString& riFeatureString, iisEnum iisAction, int& iCost);
	IMsiRecord*    __stdcall SetComponentSz(const ICHAR* szComponentString, iisEnum iRequestedSelectState);
	IMsiRecord*    __stdcall SetComponent(const MsiStringId idComponentString, iisEnum iRequestedSelectState);
	IMsiRecord*    __stdcall SetInstallLevel(int iInstallLevel);
	IMsiRecord*    __stdcall SetAllFeaturesLocal();
	IMsiRecord*    __stdcall InitializeComponents();
	IMsiRecord*    __stdcall InitializeDynamicCost(bool fReinitialize);
	IMsiRecord*    __stdcall RegisterCostAdjuster(IMsiCostAdjuster& riCostAdjuster);
	IMsiRecord*    __stdcall RecostDirectory(const IMsiString& riDestString, IMsiPath& riOldPath);
	IMsiRecord*    __stdcall GetFeatureValidStates(MsiStringId idFeatureName,int& iValidStates);
	IMsiRecord*    __stdcall GetFeatureValidStatesSz(const ICHAR *szFeatureName,int& iValidStates);
	Bool           __stdcall DetermineOutOfDiskSpace(Bool* pfOutOfNoRbDiskSpace, Bool* pfUserCancelled);
	IMsiRecord*    __stdcall DetermineEngineCostOODS();
	IMsiRecord*    __stdcall RegisterFeatureCostLinkedComponent(const IMsiString& riFeatureString, const IMsiString& riComponentString);
	IMsiRecord*    __stdcall RegisterCostLinkedComponent(const IMsiString& riComponentString, const IMsiString& riRecostComponentString);
	IMsiRecord*    __stdcall RegisterComponentDirectory(const IMsiString& riComponentString, const IMsiString& riDirectoryString);
	IMsiRecord*    __stdcall RegisterComponentDirectoryId(const MsiStringId idComponentString, const MsiStringId idDirectoryString);
	Bool           __stdcall GetFeatureInfo(const IMsiString& riFeature, const IMsiString*& rpiTitle, const IMsiString*& rpiHelp, int& iAttributes);
	IMsiRecord*    __stdcall GetFeatureStates(const IMsiString& riFeatureString,iisEnum* iisInstalled, iisEnum* iisAction);
	IMsiRecord*    __stdcall GetFeatureStates(const MsiStringId idFeatureString,iisEnum* iisInstalled, iisEnum* iisAction);
	IMsiRecord*    __stdcall GetComponentStates(const IMsiString& riComponentString,iisEnum* iisInstalled, iisEnum* iisAction);
	IMsiRecord*    __stdcall GetAncestryFeatureCost(const IMsiString& riFeatureString, iisEnum iisAction, int& iCost);
	IMsiRecord*    __stdcall GetFeatureConfigurableDirectory(const IMsiString& riFeatureString, const IMsiString*& rpiDirKey);
	IMsiRecord*    __stdcall CostOneComponent(const IMsiString& riComponentString);
	bool           __stdcall IsCostingComplete();
	IMsiRecord*    __stdcall RecostAllComponents(Bool& fCancel);
	virtual void   __stdcall EnableRollback(Bool fEnable);
	IMsiRecord*    __stdcall IsPathWritable(IMsiPath& riPath, Bool& fIsWritable);
	IMsiRecord*    __stdcall CheckFeatureTreeGrayState(const IMsiString& riFeatureString, bool& rfIsGray);
	IMsiTable*     __stdcall GetFeatureComponentsTable();
	bool           __stdcall IsBackgroundCostingEnabled();
	IMsiRecord*    __stdcall SetFeatureAttributes(const IMsiString& ristrFeature, int iAttributes);
	IMsiRecord*    __stdcall EnumComponentCosts(const IMsiString& riComponentName, const iisEnum iisAction, const DWORD dwIndex, IMsiVolume*& rpiVolume, int& iCost, int& iTempCost);
	IMsiRecord*    __stdcall EnumEngineCostsPerVolume(const DWORD dwIndex, IMsiVolume*& rpiVolume, int& iCost, int& iTempCost);
	bool           __stdcall FChildInstall() { return m_fChildInstall; }
	const IMsiString& __stdcall GetPackageName() { return m_strPackageName.Return(); }

	ieiEnum        __stdcall LoadUpgradeUninstallMessageHeaders(IMsiDatabase* piDatabase, bool fUninstallHeaders);
	iitEnum        __stdcall GetInstallType();
	IMsiRecord*    __stdcall GetAssemblyNameSz(const IMsiString& rstrComponent, iatAssemblyType iatAT, bool fOldPatchAssembly, const IMsiString*& rpistrAssemblyName);
	IMsiRecord*    __stdcall GetFeatureRuntimeFlags(const MsiStringId idFeatureString,int *piRuntimeFlags);
	bool           __stdcall FPerformAppcompatFix(iacsAppCompatShimFlags iacsFlag);

#ifdef DEBUG
 public: // IMsiDebug
	void           __stdcall SetAssertFlag(Bool fShowAsserts);
	void           __stdcall SetDBCSSimulation(char chLeadByte);
	Bool		   __stdcall WriteLog(const ICHAR* szText);
	void		   __stdcall AssertNoObjects(void);
	void  		   __stdcall SetRefTracking(long iid, Bool fTrack);

#endif //DEBUG
 public:  // constructor/destructor
	void *operator new(size_t cb) { return AllocSpc(cb); }
	void operator delete(void * pv) { FreeSpc(pv); }
	CMsiEngine(IMsiServices& riServices, IMsiServer * piServer, 
				  IMsiStorage* piStorage, IMsiDatabase* piDatabase, CMsiEngine* piParentEngine);
 protected:
  ~CMsiEngine();  // protected to prevent construction on stack
	iesEnum FindAndRunAction(const ICHAR* szAction);
	Bool GetActionText(const ICHAR* szAction,
							 const IMsiString*& rpistrDescription,
							 const IMsiString*& rpistrTemplate);
	IMsiRecord*  FetchSingleRow(const ICHAR* szQuery, const ICHAR* szValue);
	HRESULT      SetLanguage(LANGID iLangId);
	ieiEnum      DoInitialize(const ICHAR* szDatabase,
									  iuiEnum iuiLevel,
									  const ICHAR* szCommandLine,
									  const ICHAR* szProductCode,
									  iioEnum iioOptions);
	void         InitializeUserInfo(const IMsiString& ristrProductKey);
	ieiEnum      InitializeUI(iuiEnum iuiLevel);
	void         InitializeExtendedSystemFeatures();
	ieiEnum      ApplyLanguageTransform(int iLanguage, IMsiDatabase& riDatabase);
	Bool         CreatePropertyTable(IMsiDatabase& riDatabase, const ICHAR* szSourceTable,
												Bool fLoadPersistent);
	void         ClearEngineData();  // called from Initialize and Terminate
	void         ReleaseHandler();   // called from Initialize and Terminate
#ifdef OBSOLETE
	Bool         ProcessPropertyFile(const ICHAR* szFile);
#endif // OBSOLETE
	ieiEnum      InitializeTransforms(IMsiDatabase& riDatabase, IMsiStorage* piStorage,
												  const IMsiString& riTransforms,
												  Bool fValidateAll, const IMsiString** ppistrValidTransforms,
												  bool fTransformsFromPatch,
												  bool fProcessingInstanceMst,
												  bool fUseLocalCacheForSecureTransforms,
												  int *pcTranformsProcessed=0,
												  const ICHAR* szSourceDir=0,
												  const ICHAR* szCurrentDirectory=0,
												  const IMsiString** ppistrRecacheTransforms=0,
												  tsEnum *ptsTransformsSecure=0,
												  const IMsiString** ppistrNewTransformsList=0);
	ievtEnum     ValidateTransform(IMsiStorage& riStorage, const ICHAR* szProductKey,
											 const ICHAR* szProductVersion, const ICHAR* szUpgradeCode,
											 int& iTransErrors, bool fCallSAFER, const ICHAR* szFriendlyName, bool fSkipValidation, int* piTransValidation);
	IMsiRecord*  LoadComponentTable();
	IMsiRecord*  LoadFeatureTable();
	IMsiRecord*  ProcessPropertyFeatureRequests(int* iRequestCountParam, Bool fCountOnly);
	IMsiRecord*  ConfigureAllFeatures(iisEnum iisActionRequest);
	IMsiRecord*  ConfigureFile(const IMsiString& riFileString,iisEnum iisActionRequest);
	IMsiRecord*  ConfigureComponent(const IMsiString& riComponentString,iisEnum iisActionRequest);
	IMsiRecord*  ConfigureThisFeature(const IMsiString& riFeatureString,iisEnum iisActionRequest, Bool fThisOnly);
	IMsiRecord*  SetThisFeature(const IMsiString& riFeatureString, iisEnum iisRequestedState, Bool fSettingAll);
	IMsiRecord*  SetFeature(const IMsiString& riFeature, iisEnum iRequestedSelectState);
	iisEnum      GetFeatureComponentsInstalledState(const MsiStringId idFeatureString, bool fIgnoreAddedComponents, int& cComponents);
	IMsiRecord*  DetermineFeatureInstalledStates();
	IMsiRecord*  GetFeatureCompositeInstalledState(const IMsiString& riFeatureString, iisEnum& riisInstalled);
	IMsiRecord*  CalculateFeatureInstalledStates();
	int          GetFeatureRegisteredComponentTotal(const IMsiString& riProductString, const IMsiString& riFeatureString);
	IMsiRecord*  DetermineComponentInstalledStates();
	IMsiRecord*  SetFeatureComponents(const MsiStringId idFeatureString);
	IMsiRecord*  UpdateFeatureActionState(const IMsiString* piFeatureString,Bool fTrackParent, IMsiCursor* piFeatureComponentCursor = 0, IMsiCursor* piFeatureCursor = 0);
	IMsiRecord*  UpdateThisFeatureActionState(IMsiCursor* piCursor);
	IMsiRecord*  UpdateComponentActionStates(const MsiStringId idComponent, iisEnum iRequestedActionState, iisEnum iActionRequestState, bool fComponentEnabled);
	IMsiRecord*  UpdateFeatureComponents(const IMsiString* piFeatureString);
	IMsiRecord*  GetComponentCost(IMsiCursor* piCursor, int& iTotalCost, int& iNoRbTotalCost, int& iARPTotalCost, int& iNoRbARPTotalCost);
	IMsiRecord*  GetComponentActionCost(IMsiCursor* piCursor, iisEnum iisAction, int& iActionCost, int& iNoRbTotalCost, int& iARPActionCost, int& iNoRbARPTotalCost);
	IMsiRecord*  GetTotalSubComponentActionCost(const IMsiString& riComponentString, iisEnum iisAction, int& iTotalCost, int& iNoRbTotalCost);
	IMsiRecord*  AddCostToVolumeTable(IMsiPath* piDestPath, int iCost, int iNoRbCost, int iARPCost, int iNoRbARPCost);
	IMsiRecord*  RecostComponentDirectoryChange(IMsiCursor* piCursor, IMsiPath* piOldPath, bool fCostLinked);
	IMsiRecord*  RecostComponentActionChange(IMsiCursor* piCursor, iisEnum iisOldAction);
	IMsiRecord*  RecostComponent(const MsiStringId idComponentString, bool fCostLinked);
	void         ResetComponentCostMarkers();
	IMsiRecord*  ValidateFeatureSelectState(const IMsiString& riFeatureString,iisEnum iisRequestedState,
												   iisEnum& iisValidState);
	IMsiRecord*  GetFeatureParent(const IMsiString& riFeatureString,const IMsiString*& rpiParentString);
	int          GetComponentColumnIndex(const ICHAR* szColumnName);
	int          GetFeatureColumnIndex(const ICHAR* szColumnName);
	int          GetFeatureComponentsColumnIndex(const ICHAR* szColumnName);
	IMsiRecord*  MarkOrResetFeatureTree(const IMsiString& riFeatureString, Bool fMark);
	IMsiRecord*  RecostLinkedComponents(const IMsiString& riComponentString);
	IMsiRecord*  RecostFeatureLinkedComponents(const IMsiString& riFeatureString);
	ieiEnum      PostInitializeError(IMsiRecord* piError, const IMsiString& ristrErrorInfo, ieiEnum ieiError);
	IMsiRecord*  CreatePathObject(const IMsiString& riPathString,IMsiPath*& rpiPath);
	const IMsiString&  ValidatePIDSegment(const IMsiString& ristrSegment, Bool fUser);
	Bool         PIDCheckSum(const IMsiString& ristrDigits);
	unsigned int ProductVersion();
	IMsiRecord*  GetCurrentSelectState(const IMsiString*& rpistrSelections,
												 const IMsiString*& rpistrProperties,
												 const IMsiString** ppistrLoggedProperties,
												 const IMsiString** ppistrFolders,
												 Bool fReturnPresetSelections);
	IMsiRecord*  SetDirectoryNonConfigurable(const IMsiString& ristrDirKey);
	ieiEnum      ProcessInProgressInstall();
	ieiEnum      InitializePatch(IMsiDatabase& riDatabase, const IMsiString& ristrPatchPackage, const IMsiString& ristrLocalCopy,
										  const ICHAR* szProductKey, Bool fApplyExisting, const ICHAR* szCurrentDirectory,
										  iuiEnum iuiLevel);
	ieiEnum      InitializeLogging();
	ieiEnum      ProcessPreselectedAndResumeInfo();
	void         GetSummaryInfoProperties(IMsiSummaryInfo& riSummary, const IMsiString *&rpiTemplate, int &iSourceType);
	imsEnum      LoadHandler();
	ieiEnum      ProcessLanguage(const IMsiString& riAvailableLanguages, const IMsiString& riLanguage, unsigned short& iBaseLangId, Bool fNoUI, bool fIgnoreCurrentMachineLanguage);
	ieiEnum      ProcessPlatform(const IMsiString& riAvailablePlatforms, WORD& wChosenPlatform);
	ieiEnum      LoadMessageHeaders(IMsiDatabase* piDatabase);
	void         ResetEngineCosts();
	IMsiRecord*  EnumEngineCosts(int iIndex, Bool fRecalc, Bool fExact, Bool& fValidEnum, IMsiPath*& rpiPath, int& iCost, int& iNoRbCost, Bool* pfUserCancelled);
	IMsiRecord*  DetermineEngineCost(int* piNetCost, int* piNetNoRbCost);
	bool         AdjustForScriptGuess(int& iVolCost, int &iNoRbVolCost, UINT64 iVolSpace, Bool* pfUserCancelled);
	IMsiRecord*  ComponentIDToComponent(const IMsiString& riIDString, const IMsiString*& rpiComponentString);
	static int __stdcall FormatTextCallback(const ICHAR* pch, int cch, CTempBufferRef<ICHAR>&, 
															  Bool& fPropMissing,
															  Bool& fUnresolvedProp,
															  Bool& fSFN,
															  IUnknown* piContext);
	static int __stdcall FormatTextCallbackEx(const ICHAR* pch, int cch, CTempBufferRef<ICHAR>&, 
															  Bool& fPropMissing,
															  Bool& fUnresolvedProp,
															  Bool& fSFN,
															  IUnknown* piContext);
	static int __stdcall FormatTextCallbackCore(const ICHAR* pch, int cch, CTempBufferRef<ICHAR>&, 
															  Bool& fPropMissing,
															  Bool& fUnresolvedProp,
															  Bool& fSFN,
															  IUnknown* piContext,
															  bool fUseRequestedComponentState);
	IMsiRecord* DoStateTransitionForSharedUninstalls(iisEnum& riisAction, const IMsiRecord& riComponentPathRec);
	IMsiRecord* DoStateTransitionForSharedInstalls(const MsiStringId idComponentString, iisEnum& riisAction);
	IMsiRecord* CheckNeverOverwriteForRegKeypath(const MsiStringId idComponentString, iisEnum& riisAction);

	IMsiRecord* CheckLegacyAppsForSharedUninstalls(const IMsiString& riComponentId, iisEnum& riisAction, const IMsiRecord& riComponentPathRec);
	IMsiRecord* GetProductClientState(const ICHAR* szProductCode, const ICHAR* szComponentCode, INSTALLSTATE& riState, const IMsiString*& rpistrLocalPath);
	IMsiRecord* CachePatchInfo(IMsiDatabase& riDatabase, const IMsiString& ristrPatchCode,
										const IMsiString& ristrPackageName, const IMsiString& ristrSourceList,
										const IMsiString& ristrTransformList, const IMsiString& ristrLocalPackagePath,
										const IMsiString& ristrSourcePath, Bool fExisting, Bool fUnregister,
										int iSequence);
	Bool        SetPatchSourceProperties();
	bool		CreateFolderCache(IMsiDatabase& riDatabase);
	IMsiRecord* ResolveSource(const ICHAR* szProductKey=0, bool fPatchKey = false, const ICHAR* szOriginalDatabasePath=0, iuiEnum iuiLevel=(iuiEnum)-1, Bool fMaintenanceMode=(Bool)-1, const IMsiString** ppiSourceDir=0, const IMsiString** ppiSourceDirProduct=0);
	Bool        InTransaction();
	const IMsiString& GetRootParentProductKey();
	IMsiRecord* SetFileComponentStates(IMsiCursor* pComponentCursor, IMsiCursor* pFileCursor, IMsiCursor* pPatchCursor);
	iesEnum     CacheDatabaseIfNecessary();
	const IMsiString& GetProperty(IMsiCursor& riPropCursor, const IMsiString& riProperty);
	iesEnum     RunNestedInstallCustomAction(const IMsiString& ristrProduct,
														  const IMsiString& ristrCommandLine,
														  const ICHAR* szAction,
														  int icaFlags,
														  iioEnum iioOptions);
	void        ReportToEventLog(WORD wEventType, int iEventLogTemplate, IMsiRecord& riRecord, UINT uFakeError=0);  // uFakeError should go away once bug # 463473 gets fixed.
	INSTALLSTATE GetProductState(const ICHAR* szProductKey, Bool& rfRegistered, Bool& rfAdvertised);
	const IMsiString& GetDefaultDir(const IMsiString& ristrValue, bool fSource);
	IMsiRecord* LockInstallServer(IMsiRecord* piSetInProgressInfo,
											IMsiRecord*& rpiCurrentInProgressInfo);
	Bool        UnlockInstallServer(Bool fSuspend);
	bool        GetInProgressInfo(IMsiRecord*& rpiInProgressInfo);
	iesEnum     RollbackSuspendedInstall(IMsiRecord& riInProgressParams, Bool fPrompt,
													 Bool& fRollbackAttempted, Bool fUserChangedDuringInstall);
	ipitEnum    InProgressInstallType(IMsiRecord& riInProgressInfo);
	IMsiRecord* CreateTargetPathsCore(const IMsiString* piDirKey);
	void        SetProductAlienClientsFlag();
	void        SetCostingComplete(bool fCostingComplete);
	IMsiRecord*	LoadFileTable(int cAddColumns, IMsiTable*& pFileTable);
	IMsiRecord* GetScriptCost(int* piScriptCost, int* piScriptEvents, Bool fExact, Bool* pfUserCancelled);
	bool        WriteExecuteScriptRecord(ixoEnum ixoOpCode, IMsiRecord& riParams);
	bool        WriteSaveScriptRecord(ixoEnum ixoOpCode, IMsiRecord& riParams);
	IMsiRecord* SetFeatureChildren(const IMsiString& riFeatureString, iisEnum iisRequestedState);
	IMsiRecord* SetComponentState(IMsiCursor *piCursor, int colFeature, const MsiStringId idComponent, iisEnum iisComponentInstalled);
	IMsiRecord* CreateComponentFeatureTable(IMsiTable*& rpiCompFeatureTable);
	IMsiRecord* GetFileInstalledLocation(const IMsiString& ristrFile, const IMsiString*& rpistrFilePath, bool fUseRequestedComponentState = false, bool *pfSourceResolutionAttempted=0);	
	IMsiRecord* GetFeatureValidStates(MsiStringId idFeatureName,int& iValidStates, IMsiCursor* piFeatureComponentsCursor, IMsiCursor* piComponentCursor);
	bool        TerminalServerInstallsAreAllowed(bool fAdminUser);
	int         GetTotalCostAcrossVolumes(bool fRollbackCost, bool fARPCost);
	const IMsiString& GetEstimatedInstallSize();
	Bool        m_fAlienClients;
	bool        OpenHydraRegistryWindow(bool fNewTransaction);
	bool        CloseHydraRegistryWindow(bool Commit);
	void        BeginSystemChange();
	void        EndSystemChange(bool fCommitChange, INT64 iSequenceNo);
	void        EndSystemChange(bool fCommitChange, const ICHAR *szSequenceNo);
	bool        IsPropertyHidden(const ICHAR* szProperty, const ICHAR* szHiddenProperties, IMsiTable* rpiControlTable, IMsiDatabase&, bool* pfError); // if called w/ szHiddenProperties set to NULL, it will get it from the database
	void        LogCommandLine(const ICHAR* szCommandLine,  IMsiDatabase&);
	bool        IgnoreMachineState();
	bool        IgnoreReboot();
	bool        ApplyAppCompatTransforms(IMsiDatabase& riDatabase,
													 const IMsiString& ristrProductCode,
													 const IMsiString& ristrPackageCode,
													 iacpAppCompatTransformApplyPoint iacpApplyPoint,
													 iacsAppCompatShimFlags& iacsFlags,
													 bool fQuiet,
													 bool fProductCodeChanged,
													 bool& fDontInstallPackage);
	IMsiRecord* CreateNewPatchTableSchema(IMsiDatabase& riDatabase);
	void		AddFileToCleanupList(const ICHAR* szFileToCleanup);


 protected: //  state data
	int           m_iRefCnt;
	LANGID        m_iLangId;
	int           m_fMode;
	Bool          m_fLogAction; // logging for current action - false when LOGACTION set but not for action
	MsiString     m_istrLogActions;
	iuiEnum       m_iuiLevel;   // UI level, initialized to 0 == iuiFull
	ixmEnum       m_ixmExecuteMode;  // execution mode, initialized to 0 == ixmScript
	Bool          m_fInitialized;
	Bool          m_fRegistered;  // registered with config mgr, output to maint.db.
	Bool          m_fAdvertised;  // the product had been previously advertised
	Bool          m_fInParentTransaction; // nested install inside main engine's transaction
	Bool          m_fMergingScriptWithParent; // in parent transaction and merging script operations
	Bool          m_fCustomActionTable; // custom action table present in database
	Bool          m_fServerLocked;
	Bool          m_fJustGotBackFromServer;
	CScriptGenerate* m_pExecuteScript;
	CScriptGenerate* m_pSaveScript;
	Bool          m_fConfigDatabaseOpen;
	IMsiServices& m_riServices;
	IMsiServer*   m_piServer;
	IMsiConfigurationManager* m_piConfigManager;
	IMsiDatabase* m_piDatabase;
	IMsiStorage*  m_piExternalStorage;
	IMsiDatabase* m_piExternalDatabase;
	CMsiEngine*   m_piParentEngine;
	IMsiCursor*   m_piPropertyCursor;
	IMsiCursor*   m_piActionTextCursor;
	const IMsiString*   m_rgpiMessageHeader[cCachedHeaders];
	const IMsiString*   m_piActionDataFormat;
	const IMsiString*   m_piActionDataLogFormat;
	bool          m_fProgressByData;
	Bool          m_fSummaryInfo;
	const IMsiString*   m_pistrSummaryComments;
	const IMsiString*   m_pistrSummaryKeywords;
	const IMsiString*   m_pistrSummaryTitle;
	const IMsiString*   m_pistrSummaryProduct;
	const IMsiString*   m_pistrSummaryPackageCode;
	MsiDate       m_idSummaryCreateDateTime;
	MsiDate       m_idSummaryInstallDateTime;
	MsiDate       m_idSummaryModifyDateTime;
	int           m_iCodePage;
	const IMsiString*   m_piProductKey;
	const IMsiString*   m_pistrPlatform;
	const IMsiString*   m_pistrExecuteScript; // script executed by server
	const IMsiString*   m_pistrSaveScript;  // script containing all operations for this install
	const IMsiString*   m_piErrorInfo;  // used only to return strings from DoInitialize to Initialize
	int           m_iDatabaseVersion;
	PMsiRecord    m_pCachedActionStart; // held for use by ExecuteRecord and Message
	PMsiRecord    m_pActionStartLogRec; // record for imsgActionStarted and imsgActionEnded - for log use only
	scmEnum       m_scmScriptMode;  // script mode: write, run, idle
	issEnum       m_issSegment;     // current sequence window
	Bool          m_fInExecuteRecord; // true when making recursive call to ExecuteRecord
	Bool          m_fDispatchedActionStart; // true when Message dispatched ActionStart for current action
	Bool          m_fExecutedActionStart; // true when ExecuteRecord executed ixoActionStart
	int           m_cSequenceLevels; // count of levels of recursion to Sequence, used to determine outermost call
	int           m_cExecutionPhaseSequenceLevel; // sequence level count when execution phase was begun
	Bool          m_fDisabledRollbackInScript; // disabled rollback in the middle of script generation
	MsiString     m_strPackagePath; // path to package we are running from
	MsiString     m_strPackageName;
	int           m_iProgressTotal;
	PMsiRecord    m_pActionProgressRec;
	PMsiRecord    m_pScriptProgressRec;
	bool          m_fBeingUpgraded;
	bool          m_fChildInstall;
	bool          m_fEndDialog;
	bool          m_fRunScriptElevated;
	iioEnum       m_iioOptions;
	bool          m_fSourceResolutionAttempted;
	int           m_iSourceType;   // source type suminfo property from SOURCE package - set by GetSourceType
	int           m_iCachedPackageSourceType;  // source type suminfo property from CACHED package - set in Engine::Initialize
	WORD          m_wPackagePlatform; // platform chosen by ProcessPlatform()
	bool          m_fRestrictedEngine; // whether or not the engine is restricted to only running SAFE actions
	bool          m_fRemapHKCUInCAServers; // whether or not to remap HKCU in the custom action servers
	iacsAppCompatShimFlags m_iacsShimFlags;
	bool          m_fNewInstance; // whether this is a new instance install or not
	MsiString     m_strPackageDownloadLocalCopy; // local file location for URL package download (prevent re-download)
	MsiString     m_strPatchDownloadLocalCopy; // local file location for URL package download (prevent re-download)

	// cached patch information
	PMsiTable     m_pPatchCacheTable;
	PMsiCursor    m_pPatchCacheCursor;
	int           m_colPatchCachePatchId;
	int           m_colPatchCachePackageName;
	int           m_colPatchCacheSourceList;
	int           m_colPatchCacheTransformList;
	int           m_colPatchCacheTempCopy;
	int           m_colPatchCacheSourcePath;
	int           m_colPatchCacheExisting;
	int           m_colPatchCacheUnregister;
	int           m_colPatchCacheSequence;
	PatchTransformState m_ptsState;

	// custom action information
	CRITICAL_SECTION         m_csCreateProxy;
	CMsiCustomActionManager* m_pCustomActionManager;
	
	// assembly data
	bool m_fAssemblyTableExists;
	PMsiView m_pViewFusion;
	PMsiView m_pViewFusionNameName;
	PMsiView m_pViewFusionName;
	PMsiView m_pViewOldPatchFusionNameName;
	PMsiView m_pViewOldPatchFusionName;

	// IMsiSelectionManager data
	IMsiTable*  m_piFeatureTable;
	IMsiCursor* m_piFeatureCursor;
	IMsiTable*  m_piFeatureComponentsTable;
	IMsiCursor* m_piFeatureComponentsCursor;
	IMsiTable*  m_piComponentTable;
	IMsiCursor* m_piComponentCursor;
	IMsiTable*  m_piCostAdjusterTable;
	int         m_colCostAdjuster;
	IMsiTable*  m_piVolumeCostTable;
	IMsiTable*  m_piCostLinkTable;
	IMsiTable*  m_piFeatureCostLinkTable;
	int         m_colVolumeObject;
	int         m_colVolumeCost;
	int         m_colNoRbVolumeCost;
	int         m_colVolumeARPCost;
	int         m_colNoRbVolumeARPCost;
	int         m_colCostLinkComponent;
	int         m_colCostLinkRecostComponent;
	int         m_colFeatureCostLinkFeature;
	int         m_colFeatureCostLinkComponent;
	bool        m_fCostingComplete;
	bool        m_fSelManInitComplete;
	Bool        m_fExclusiveComponentCost;
	Bool        m_fForceRequestedState;
	int         m_colFeatureKey;
	int         m_colFeatureParent;
	int         m_colFeatureLevel;
	int         m_colFeatureAuthoredLevel;
	int         m_colFeatureHandle;
	int         m_colFeatureSelect;
	int         m_colFeatureAction;
	int         m_colFeatureActionRequested;
	int         m_colFeatureInstalled;
	int         m_colFeatureAttributes;
	int         m_colFeatureAuthoredAttributes;
	int         m_colFeatureComponentsFeature;
	int         m_colFeatureComponentsComponent;
	int         m_colFeatureComponentsRuntimeFlags;
	int         m_colFeatureRuntimeFlags;
	int         m_colFeatureTitle;
	int         m_colFeatureConfigurableDir;
	int         m_colFeatureDescription;
	int         m_colFeatureDefaultSelect;
	int         m_colFeatureDisplay;
	int         m_colComponentKey;
	int         m_colComponentParent;
	int         m_colComponentDir;
	int         m_colComponentAttributes;
	int         m_colComponentInstalled;
	int         m_colComponentCondition;
	int         m_colComponentAction;
	int         m_colComponentActionRequest;
	int         m_colComponentLocalCost;
	int         m_colComponentNoRbLocalCost;
	int         m_colComponentSourceCost;
	int         m_colComponentNoRbSourceCost;
	int         m_colComponentRemoveCost;
	int         m_colComponentNoRbRemoveCost;
	int         m_colComponentARPLocalCost;
	int         m_colComponentNoRbARPLocalCost;
	int         m_colComponentRuntimeFlags;
	int			m_colComponentID;
	int			m_colComponentKeyPath;
	int			m_colComponentForceLocalFiles;
	int			m_colComponentLegacyFileExisted;
	int         m_colComponentTrueInstallState;
	int         m_fForegroundCostingInProgress;

	// IMsiDirectoryManager data
	bool        m_fDirectoryManagerInitialized;
	IMsiTable*  m_piDirTable;
	int         m_colDirKey;
	int         m_colDirParent;
	int         m_colDirSubPath;
	int         m_colDirTarget;
	int         m_colDirSource;
	int         m_colDirNonConfigurable;
	int         m_colDirPreconfigured;
	int         m_colDirLongSourceSubPath;
	int         m_colDirShortSourceSubPath;
	PMsiCursor  m_pCostingCursor;
	bool        m_fReinitializeComponentCost;
	bool        m_fSourceResolved;
	bool        m_fSourcePathsCreated;
	bool        m_fSourceSubPathsResolved;
	PMsiCursor  m_pTempCostsCursor;
	int         m_colTempCostsVolume;
	int         m_colTempCostsTempCost;

	// shell and folder caching
	PMsiTable  m_pFolderCacheTable;
	PMsiCursor m_pFolderCacheCursor;
	int        m_colFolderCacheFolderId;
	int        m_colFolderCacheFolder;
	int        m_colFolderCacheFolderPath;

	// transform and patch temp copy cleanup list
	MsiString  m_strTempFileCopyCleanupList;

	// File table information
	int			m_mpeftCol[ieftMax];

	// Patch table information
	int			m_colPatchKey;
	int			m_colPatchAttributes;

	// MsiFileHash table information
	bool        m_fLookedForFileHashTable;
	PMsiCursor  m_pFileHashCursor;
	int         m_colFileHashKey;
	int         m_colFileHashOptions;
	int         m_colFileHashPart1;
	int         m_colFileHashPart2;
	int         m_colFileHashPart3;
	int         m_colFileHashPart4;

	// AppCompat information for CA Shims
	bool        m_fCAShimsEnabled;
	GUID        m_guidAppCompatDB;
	GUID        m_guidAppCompatID;

	// Internal Engine costing
	int			m_iDatabaseCost;
	int         m_iScriptCost;
	int         m_iScriptCostGuess;
	int         m_iRollbackScriptCost;
	int         m_iRollbackScriptCostGuess;
	int         m_iPatchPackagesCost;

	INT64       m_i64PCHEalthSequenceNo;   //  Windows Millenium System Restore sequence number

	bool		m_fResultEventLogged;
	
	CMsiFile*	m_pcmsiFile;
	int         m_fcmsiFileInUse;

	IMsiTable*  m_piRegistryActionTable;
	IMsiTable*  m_piFileActionTable;
	int         m_iScriptEvents;
	DWORD       m_lTickNextProgress;
	friend const IMsiString& FormatTextEx(const IMsiString& riTextString, IMsiEngine& riEngine, bool fUseRequestedComponentState);
	friend const IMsiString& FormatTextSFN(const IMsiString& riTextString, IMsiEngine& riEngine, int rgiSFNPos[][2], int& riSFNPos, bool fUseRequestedComponentState);
    friend class CMsiServerConnMgr;
};

/*
    Class for managing the connection to the server. This class was introduced
    because MSI now fails if CreateMsiServer cannot connect to the service. Due
    to this change, certain APIs like MsiOpenPackage which don't really need the
    service and used to fall back on the in-proc processing would have failed.

    Using this class, we can delay the connection to the service until it is
    absolutely necessary. Thus, we can prevent APIs MsiOpenPackage from failing
    right off the bat. This ensures backward compatibility. Also, callers of
    this API may not necessarily need to connect to the service and we do not
    want them to fail unnecessarily. Note: One of the main reasons for
    failure to connect to the service is when the MsiOpenPackage API is called
    from threads that have not done a CoInit. This is not very uncommon, so
    we need to make sure that we do not fail there.

    The objects of this class cleanup after themselves. i.e., if they create the
    connection to the service, then upon destruction, the connection is removed.
*/
class CMsiServerConnMgr
{
public:
    // Construction and destruction
    CMsiServerConnMgr (CMsiEngine* pEngine);
    ~CMsiServerConnMgr();

private:
    // Data members
    BOOL                        m_fOleInitialized;
    BOOL                        m_fCreatedConnection;
    BOOL                        m_fObtainedConfigManager;
    IMsiServer**                m_ppServer;
    IMsiConfigurationManager**  m_ppConfigManager;
};

extern CActionThreadData* g_pActionThreadHead;  // linked list of custom action threads
void InsertInCustomActionList(CActionThreadData* pData);
void RemoveFromCustomActionList(CActionThreadData* pData);
bool FIsCustomActionThread(DWORD dwThreadId);
bool FFileIsCompressed(int iSourceType, int iFileAttributes);
bool FSourceIsLFN(int iSourceType, IMsiPath& riPath);

// fn to convert multisz to wide
#ifndef UNICODE
void ConvertMultiSzToWideChar(const IMsiString& ristrFileNames, CTempBufferRef<WCHAR>& rgch);
#endif


class CMsiFileBase
{
public:

	// Enums for accessing file record fields
	enum ifqEnum
	{
		ifqFileName = 1,
		ifqVersion,
		ifqState,
		ifqAttributes,
		ifqTempAttributes,
		ifqFileKey,
		ifqFileSize,
		ifqLanguage,
		ifqSequence,
		ifqDirectory,
		ifqInstalled,
		ifqAction,
		ifqComponent,
		ifqForceLocalFiles,
		ifqComponentId,
		ifqNextEnum
	};
public:
	CMsiFileBase::CMsiFileBase(IMsiEngine& riEngine);
	virtual ~CMsiFileBase();
	IMsiRecord* GetFileRecord( void );
	IMsiRecord* GetTargetPath(IMsiPath*& rpiDestPath);
	IMsiRecord* GetExtractedTargetFileName(IMsiPath& riPath,const IMsiString*& rpistrFileName);
protected:
	IMsiEngine& m_riEngine;
	IMsiServices& m_riServices;
	PMsiRecord  m_pFileRec;
};

class CMsiFile : public CMsiFileBase
/*------------------------------------------
Simple internal class for managing queries
into the File Table
-------------------------------------------*/
{

public:
	CMsiFile::CMsiFile(IMsiEngine& riEngine);
	virtual ~CMsiFile();
	IMsiRecord* FetchFile(const IMsiString& riFileKeyString);
private:
	IMsiRecord* ExecuteView(const IMsiString& riFileKeyString);
protected:
	PMsiView    m_pFileView;
};

//
// Resets the shared CMsiFile cursor when we are done with it
//
class PMsiFile 
{
	public:
		inline PMsiFile(IMsiEngine& riEngine, CMsiFile*& pcmsiFileRet) :
			m_riEngine(riEngine)
		{
			pcmsiFileRet = m_riEngine.GetSharedCMsiFile();
		}
		inline ~PMsiFile()
		{
			m_riEngine.ReleaseSharedCMsiFile();
		}
	public:
		IMsiEngine&  m_riEngine;
};


#define GetSharedEngineCMsiFile(var, engine)		CMsiFile* var; PMsiFile CSharedMsiFile(engine, var)

// function to determine whether a file is to be installed to the system
IMsiRecord* GetFileInstallState(IMsiEngine& riEngine,IMsiRecord& riFileRec,
										  IMsiRecord* piCompanionFileRec,
									   unsigned int* puiExistingClusteredSize, Bool* pfInUse,
									   ifsEnum* pifsState, bool fIgnoreCompanionParentAction, bool fIncludeHashCheck, int *pfVersioning);


class CMsiFileInstall : public CMsiFileBase
{
public:
	CMsiFileInstall::CMsiFileInstall(IMsiEngine& riEngine);
	virtual ~CMsiFileInstall();
	IMsiRecord* TotalBytesToCopy(unsigned int& uiTotalBytesToCopy);
	IMsiRecord* FetchFile();
private:
	IMsiRecord* Initialize();
	IMsiView*		m_piView;
	bool    m_fInitialized;
};

class CMsiFileRemove
{
public:
	enum ifqrEnum
	{
		ifqrFileName = 1,
		ifqrDirectory,
		ifqrComponentId,
		ifqrNextEnum,
	};
	
	CMsiFileRemove::CMsiFileRemove(IMsiEngine& riEngine);
	virtual ~CMsiFileRemove();
	IMsiRecord* TotalFilesToDelete(unsigned int& uiTotalFileCount);
	IMsiRecord* FetchFile(IMsiRecord*&);
	IMsiRecord* GetExtractedTargetFileName(IMsiPath& riPath,const IMsiString*& rpistrFileName);
private:
	IMsiRecord* Initialize();
	bool    m_fInitialized;
	bool    m_fEmpty;
	int		m_colFileName;
	int		m_colFileActionDir;
	int     m_colFileKey;
	int     m_colFileActKey;
	int		m_colFileActAction;
	int 	m_colFileActInstalled;
	int 	m_colFileActComponentId;
	IMsiCursor*		m_piCursor;
	IMsiCursor*		m_piCursorFile;
	IMsiEngine& m_riEngine;
	IMsiServices& m_riServices;
	PMsiRecord  m_pFileRec;
};

struct TTBD		// Temp TaBle Definition
{
	int icd;
	const ICHAR *szColName;
};

UINT __stdcall CheckAllHandlesClosed(bool fClose, DWORD dwThreadId);

// flags for Darwin Descriptor optimization
const int ofSingleComponent = 0x1;
const int ofSingleFeature   = 0x2;

void SetNoPowerdown();
void ClearNoPowerdown();

// additional define for registry root types to do HKLM or HKCU based on ALLUSERS
const int rrkUserOrMachineRoot = -1;

// special format texts used by WriteRegistryValues for using the special callback fn AND SFN handling
const IMsiString& FormatTextEx(const IMsiString& riTextString, IMsiEngine& riEngine, bool fUseRequestedComponentState);
const IMsiString& FormatTextSFN(const IMsiString& riTextString, IMsiEngine& riEngine, int rgiSFNPos[][2], int& riSFNPos, bool fUseRequestedComponentState);

typedef iesEnum (__stdcall *PCustomActionEntry)(MSIHANDLE);
DWORD CallCustomDllEntrypoint(PCustomActionEntry pfEntry, bool fDebugBreak, MSIHANDLE hInstall, const ICHAR* szAction);

// GUID that represents the product key of the system
const ICHAR szSystemProductKey[] = TEXT("{00000000-0000-0000-0000-000000000000}");

enum cpConvertType 
{
	cpToLong  = 0,
	cpToShort = 1,
};

Bool ConvertPathName(const ICHAR* pszPathFormatIn, CTempBufferRef<ICHAR>& rgchPathFormatOut, cpConvertType cpTo);
bool DetermineLongFileNameOnly(const ICHAR* pszPathFormatIn, CTempBufferRef<ICHAR>& rgchFileNameOut);

// the number of bytes for the Custom Action cookie. Currently a 128 bit key.
const int iRemoteAPICookieSize = 16;


//____________________________________________________________________________
//
// CMsiRemoteAPI - Stub for remoted MSI API
//____________________________________________________________________________

class CMsiRemoteAPI : public IMsiRemoteAPI
{
 public:
	HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long   __stdcall AddRef();
	unsigned long   __stdcall Release();
	HRESULT         __stdcall GetProperty(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, const ICHAR* szName, ICHAR* szValue, unsigned long cchValue, unsigned long* pcchValueRes);
	HRESULT         __stdcall CreateRecord(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned int cParams,unsigned long* pHandle);
	HRESULT         __stdcall CloseAllHandles(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie);
	HRESULT         __stdcall CloseHandle(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hAny);
	HRESULT         __stdcall DatabaseOpenView(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hDatabase, const ichar* szQuery,unsigned long* phView);
	HRESULT         __stdcall ViewGetError(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hView, ichar* szColumnNameBuffer, unsigned long cchBuf, unsigned long* pcchBufRes, int *pMsidbError);
	HRESULT         __stdcall ViewExecute(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hView, unsigned long hRecord);
	HRESULT         __stdcall ViewFetch(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hView,unsigned long*  phRecord);
	HRESULT         __stdcall ViewModify(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hView, long eUpdateMode, unsigned long hRecord);
	HRESULT         __stdcall ViewClose(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hView);
	HRESULT         __stdcall OpenDatabase(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, const ichar* szDatabasePath, const ichar* szPersist,unsigned long *phDatabase);
	HRESULT         __stdcall DatabaseCommit(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hDatabase);
	HRESULT         __stdcall DatabaseGetPrimaryKeys(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hDatabase, const ichar * szTableName,unsigned long *phRecord);
	HRESULT         __stdcall RecordIsNull(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hRecord, unsigned int iField, boolean *pfIsNull);
	HRESULT         __stdcall RecordDataSize(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hRecord, unsigned int iField,unsigned int* puiSize);
	HRESULT         __stdcall RecordSetInteger(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hRecord, unsigned int iField, int iValue);
	HRESULT         __stdcall RecordSetString(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hRecord,	unsigned int iField, const ichar* szValue);
	HRESULT         __stdcall RecordGetInteger(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hRecord, unsigned int iField, int *piValue);
	HRESULT         __stdcall RecordGetString(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hRecord, unsigned int iField, ichar* szValueBuf, unsigned long cchValueBuf,unsigned long *pcchValueRes);
	HRESULT         __stdcall RecordGetFieldCount(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hRecord,unsigned int* piCount);
	HRESULT         __stdcall RecordSetStream(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hRecord, unsigned int iField, const ichar* szFilePath);
	HRESULT         __stdcall RecordReadStream(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hRecord, unsigned int iField, boolean fBufferIsNull, char *szDataBuf,unsigned long *pcbDataBuf);
	HRESULT         __stdcall RecordClearData(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hRecord);
	HRESULT         __stdcall GetSummaryInformation(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hDatabase, const ichar*  szDatabasePath, unsigned int    uiUpdateCount, unsigned long *phSummaryInfo);
	HRESULT         __stdcall SummaryInfoGetPropertyCount(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hSummaryInfo,	unsigned int *puiPropertyCount);
	HRESULT         __stdcall SummaryInfoSetProperty(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hSummaryInfo,unsigned intuiProperty, unsigned intuiDataType, int iValue, FILETIME *pftValue, const ichar* szValue); 
	HRESULT         __stdcall SummaryInfoGetProperty(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hSummaryInfo,unsigned intuiProperty,unsigned int *puiDataType, int *piValue, FILETIME *pftValue, ichar* szValueBuf, unsigned long cchValueBuf, unsigned long *pcchValueBufRes);
	HRESULT         __stdcall SummaryInfoPersist(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hSummaryInfo);
	HRESULT         __stdcall GetActiveDatabase(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall,unsigned long* phDatabase);
	HRESULT         __stdcall SetProperty(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, const ichar* szName, const ichar* szValue);
	HRESULT         __stdcall GetLanguage(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall,unsigned short* pLangId);
	HRESULT         __stdcall GetMode(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, long eRunMode, boolean* pfSet); 
	HRESULT         __stdcall SetMode(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, long eRunMode, boolean fState);
	HRESULT         __stdcall FormatRecord(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, unsigned long hRecord, ichar* szResultBuf, unsigned long cchResultBuf, unsigned long *pcchResultBufRes);
	HRESULT         __stdcall DoAction(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, const ichar* szAction);    
	HRESULT         __stdcall Sequence(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, const ichar* szTable, int iSequenceMode);   
	HRESULT         __stdcall ProcessMessage(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, long eMessageType, unsigned long hRecord, int* piRes);
	HRESULT         __stdcall EvaluateCondition(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, const ichar* szCondition, int *piCondition);
	HRESULT         __stdcall GetFeatureState(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, const ichar* szFeature, long *piInstalled, long *piAction);
	HRESULT         __stdcall SetFeatureState(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, const ichar* szFeature, long iState);
	HRESULT         __stdcall GetComponentState(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, const ichar* szComponent, long *piInstalled, long *piAction);
	HRESULT         __stdcall SetComponentState(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, const ichar*     szComponent, long iState);
	HRESULT         __stdcall GetFeatureCost(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, const ichar* szFeature, int iCostTree, long iState, int *piCost);
	HRESULT         __stdcall SetInstallLevel(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, int iInstallLevel);
	HRESULT         __stdcall GetFeatureValidStates(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, const ichar* szFeature,unsigned long *dwInstallStates);
	HRESULT         __stdcall DatabaseIsTablePersistent(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hDatabase, const ichar* szTableName, int *piCondition);
	HRESULT         __stdcall ViewGetColumnInfo(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hView, long eColumnInfo,unsigned long *phRecord);
	HRESULT         __stdcall GetLastErrorRecord(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long *phRecord);
	HRESULT         __stdcall GetSourcePath(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, const ichar* szFolder, ichar* szPathBuf, unsigned long cchPathBuf, unsigned long *pcchPathBufRes);
	HRESULT         __stdcall GetTargetPath(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, const ichar* szFolder, ichar* szPathBuf, unsigned long cchPathBuf, unsigned long *pcchPathBufRes); 
	HRESULT         __stdcall SetTargetPath(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, const ichar* szFolder, const ichar* szFolderPath);
	HRESULT         __stdcall VerifyDiskSpace(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall);
	HRESULT         __stdcall SetFeatureAttributes(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall,  const ichar* szFeature,  long iAttributes);
	HRESULT         __stdcall EnumComponentCosts(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, const ichar* szComponent, unsigned long iIndex, long iState, ichar* szDrive, unsigned long cchDrive, unsigned long* pcchDriveSize, int *piCost, int *piTempCost);
	HRESULT         __stdcall GetInstallerObject(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, IDispatch** piDispatch);

 public:  // constructor
 	void *operator new(size_t cb) { return AllocSpc(cb); }
	void operator delete(void * pv) { FreeSpc(pv); }
	CMsiRemoteAPI();
	bool SetCookieAndPid(const int icacContext, const unsigned char *rgchCookie, const unsigned long lPid);
	HRESULT BeginAction(const int icacContext);
	HRESULT EndAction(const int icacContext);
	bool FindAndValidateContextFromCallerPID(icacCustomActionContext *picacContext) const;

 protected:
	~CMsiRemoteAPI();  // protected to prevent creation on stack
 private:
	struct {
		long           m_iActionCount;
		unsigned char  m_rgchCookie[iRemoteAPICookieSize];
		unsigned long  m_lPid;
	} m_rgContextData[icacNext];

 	DWORD          m_dwRemoteAPIThread;
	bool           m_fPerformSystemUserTranslation;
 	bool ValidateCookie(const int icacContext, const unsigned char *rgchCookie, const int cbCookie) const;
 	
	long  m_iRefCnt;
};

#define EVENTLOG_ERROR_OFFSET      10000

enum ieSwapAttrib
{
	ieSwapInvalid      = -1,
	ieSwapAlways       = 0,
	ieSwapForSharedDll = 1,
	ieSwapAttribFirst  = ieSwapForSharedDll,
	ieSwapAttribLast   = ieSwapForSharedDll,
//	ieNextThing        = 2,...         // better make the next one(s) multiples of 2
//	ieSwapAttribLast   = ieNextThing,  // ieSwapAttribLast needs to be updated too
};

struct strFolderPairs
{
	MsiString     str64bit;
	MsiString     str32bit;
	int           iSwapAttrib;
	strFolderPairs() {}
	strFolderPairs(const ICHAR* sz64bit, const ICHAR* sz32bit) : str64bit(sz64bit), str32bit(sz32bit), iSwapAttrib(ieSwapAlways)
		{Assert(str64bit.TextSize() <= MAX_PATH); Assert(str32bit.TextSize() <= MAX_PATH);}
	strFolderPairs(const ICHAR* sz64bit, const ICHAR* sz32bit, int iAttrib)
	{
		*this = strFolderPairs(sz64bit, sz32bit);
		if ( IsValidSwapAttrib(iAttrib) )
			iSwapAttrib = iAttrib;
		else
		{
			Assert(0);
			iSwapAttrib = ieSwapAlways;
		}
	}
	static bool IsValidSwapAttrib(int iArg)
	{
		if ( iArg == ieSwapAlways )
			return true;
		int iTest = ieSwapAttribFirst;
		do
		{
			if ( (iArg & iTest) == iTest )
				iArg &= ~iTest;
			iTest <<= 1;
		} while ( iTest <= ieSwapAttribLast );

		return iArg ? false : true;
	}
};

enum ieFolderSwapType
{
	ie32to64 = 0,
	ie64to32,
};

enum ieIsDualFolder
{
	ieisError = 0,
	ieisNotInitialized,
	ieisNotWin64DualFolder,
	ieisWin64DualFolder,
};

enum ieSwappedFolder
{
	iesrError = 0,
	iesrNotInitialized,
	iesrNotSwapped,
	iesrSwapped,
};

//  A tiny class that encapsulates on Win64 the 3 folders below and their
//  32-bit counterparts.
//    - %SystemDrive%\Program Files\
//    - %SystemDrive%\Program Files\Common Files\
//    - %Windir%\system32
//
//  Its only useful method is SwapFolder that translates its szFolder path
//  argument from one type of binary into the other.  It can do translations
//  both ways between 32 and 64-bit paths.  The new path is copied into
//  szSubstituted argument.  The translation happens only if szFolder is
//  either one of the 3 special folders (of the right binarity) or a
//  subfolder of those.
//
//  Since none of these 6 folders can be changed externally, there's no
//  use in reinitializing the object once it got initialized.

class CWin64DualFolders
{
private:
	bool m_f32bitPackage;
	strFolderPairs* m_prgFolderPairs;
	void ClearArray();
	bool CopyArray(const strFolderPairs* pArg);
	ieIsDualFolder IsWin64DualFolder(ieFolderSwapType iConvertFrom,
												const ICHAR* szFolder,
												int& iSwapAttrib,
												int* iCharsToSubstite,
												ICHAR* szToSubstituteWith,
												const size_t cchToSubstituteWith);
	int m_iRefCnt;

public:
	CWin64DualFolders() : m_f32bitPackage(false), m_prgFolderPairs(NULL), m_iRefCnt(1) {}
	~CWin64DualFolders() { ClearArray(); }
	CWin64DualFolders& operator = (const CWin64DualFolders& Arg);
	CWin64DualFolders(bool fArg, strFolderPairs* pArg) :
		m_f32bitPackage(fArg), m_prgFolderPairs(NULL), m_iRefCnt(1)
		{CopyArray(pArg);}

	bool IsInitialized() { return m_prgFolderPairs != NULL ? true : false; }
	bool ShouldCheckFolders() { return m_f32bitPackage; }
	ieSwappedFolder SwapFolder(ieFolderSwapType iConvert,
										const ICHAR* szFolder,
										ICHAR* szSubstituted,
										const size_t cchSubstituted,
										int iSwapMask = ieSwapAlways);
	unsigned long AddRef() {
		if ( !g_fWinNT64 )
			return 0;

		 return ++m_iRefCnt;
	}
	unsigned long Release() {
		if ( !g_fWinNT64 )
			return 0;

		if (--m_iRefCnt != 0)
			return m_iRefCnt;
		ClearArray(); // we're talking about a global object here, so "delete this" is innapropriate.
		return 0;
	}
};

// global fn to post assembly errors, in addition to posting error, this fn also logs the formatmessage string for the error
IMsiRecord* PostAssemblyError(const ICHAR* szComponentId, HRESULT hResult, const ICHAR* szInterface, const ICHAR* szFunction, const ICHAR* szAssemblyName, iatAssemblyType iatAT);

#endif // ___ENGINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\_execute.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       _execute.h
//
//--------------------------------------------------------------------------

/* _execute.h - private definitions for CMsiExecute opcode execution members
____________________________________________________________________________*/

#ifndef __EXECUTE_H
#define __EXECUTE_H

#include "_engine.h"
#include "msi.h"
#include "_msinst.h"

#define szRollbackScriptExt __TEXT("rbs")
#define szRollbackFileExt   __TEXT("rbf")

enum ixsEnum
{
	ixsIdle = 0, // no spooling or script execution
	ixsRunning,  // executing normal script
	ixsRollback, // executing rollback script
	ixsCommit,   // executing commit ops or removing rollback files
};

enum irlEnum // rollback level
{
	irlNone, // no rollback
	irlRollbackNoSave, // allow for rollback, remove backup files after install
};

enum icfsEnum // bits in m_pFileCacheTable.State column
{
	icfsFileNotInstalled          = 1,   // The file was not copied because one was already on the machine
	icfsPatchFile                 = 2,
	icfsProtectedInstalledBySFC   = 4,   // The file is protected by SFP, and we should call SFP to install the file
	icfsProtected                 = 8,   // The file is protected by SFP (and may or may not be installed by SFP)
	icfsPatchTempOverwriteTarget = 16,   // after patching this intermediate file, copy it to the correct and final location
};

#define MAX_RECORD_STACK_SIZE 15
struct RBSInfo;

enum iehEnum
{
	iehShowIgnorableError,
	iehShowNonIgnorableError,
	iehSilentlyIgnoreError,
	iehNextEnum
};

inline LONG GetPublishKey(iaaAppAssignment iaaAsgnType, HKEY& rhKey, HKEY& rhOLEKey, const IMsiString*& rpiPublishSubKey, const IMsiString*& rpiPublishOLESubKey);
LONG GetPublishKeyByUser(const ICHAR* szUserSID, iaaAppAssignment iaaAsgnType, HKEY& rhKey, HKEY& rhOLEKey, const IMsiString*& rpiPublishSubKey, const IMsiString*& rpiPublishOLESubKey);

//__________________________________________________________________________
//
// CActionState: provides state data for actions. Scope of data is
//               life of action, i.e. data is cleaned up before each
//               action begins.
//__________________________________________________________________________

class CActionState
{
public:
	CActionState();
	~CActionState();
	void* operator new(size_t /*cb*/, void * pv) {return pv;} // no memory allocation
	void operator delete(void* /*pv*/) {} // no memory de-allocation
// public data members accessed by the CMsiOpExecute class
public:
	PMsiPath       pCurrentSourcePathPrivate; // should only be accessed through GetCurrentSourcePathAndType
	int            iCurrentSourceTypePrivate; // should only be accessed through GetCurrentSourcePathAndType
	MsiString      strCurrentSourceSubPathPrivate; // set by ixoSetSourcePath
	bool           fSourcePathSpecified;

	PMsiPath       pTargetPath; // set (and only set) by ixfSetTargetFolder - no other op should set this
	PMsiPath       pMediaPath; // used by VerifySourceMedia
	PMsiRegKey     pRegKey;
	rrkEnum        rrkRegRoot;
	MsiString      strRegSubKey;  // sub-key beneath root - set to Key of ixoRegOpenKey
	ibtBinaryType  iRegBinaryType;
	PMsiFilePatch  pFilePatch;
	PMsiPath       pParentPath;
	MsiString		strParentFileName;
	MsiString		strParentVersion;
	MsiString      strParentLanguage;
	Bool           fWaitingForMediaChange;
	Bool           fPendingMediaChange;
	Bool           fCompressedSourceVerified;
	Bool           fUncompressedSourceVerified;
	Bool           fSplitFileInProgress;
	int            cbFileSoFar;
	MsiString		strMediaLabel;
	MsiString		strMediaPrompt;
	PMsiPath       pIniPath; // set by ixfIniFilePath - no other op should set this
	MsiString      strIniFile; // set by ixfIniFilePath - no other op should set this
	PMsiFileCopy   pFileCopier;
	PMsiFileCopy   pCabinetCopier;
	ictEnum        ictCabinetCopierType;
	PMsiRecord     pCurrentMediaRec;
	IMsiFileCopy*  piCopier;
	MsiString      strMediaModuleFileName;
	MsiString      strMediaModuleSubStorageList;
	MsiString      strLastFileKey;
	MsiString      strLastFileName;
	PMsiPath       pLastTargetPath; //	Used when making duplicate copies of files uncompressed from cabs


	// reg key names are cached seperately of the PMsiRegKeys since the key to display to the
	// user may be different than the actual key written to
	// (i.e. display HKEY_CURRENT_USER\..., write to HKEY_USERS\S-...)
	// use these strings in ActionData and error messages
	MsiString strRegKey;
};

inline CActionState::CActionState()
 : pCurrentSourcePathPrivate(0), pTargetPath(0), pMediaPath(0), pParentPath(0), pRegKey(0), pFilePatch(0),
   fWaitingForMediaChange(fFalse),fPendingMediaChange(fFalse),fSplitFileInProgress(fFalse),
	fCompressedSourceVerified(fFalse), fUncompressedSourceVerified(fFalse), pIniPath(0),
	cbFileSoFar(0), pFileCopier(0), pCabinetCopier(0), pCurrentMediaRec(0),
	ictCabinetCopierType(ictNextEnum),pLastTargetPath(0)
{}

inline CActionState::~CActionState()
{
}


//____________________________________________________________________________
//
// CMsiOpExecute - environment for execution functions dispatched via opcode
//____________________________________________________________________________

const int cMaxSharedRecord = 10;   // limit for shared message record pool

class CMsiOpExecute
{
 protected:
#define MSIXO(op,type,args) iesEnum ixf##op(IMsiRecord& riParams);
#include "opcodes.h"
 protected:  // local accessors available to operators
	imsEnum       Message(imtEnum imt, IMsiRecord& riRecord);
	imsEnum       DispatchMessage(imtEnum imt, IMsiRecord& riRecord, Bool fConfirmCancel);
	IMsiRecord&   GetSharedRecord(int cParams);
	imsEnum       DispatchError(imtEnum imtType, IErrorCode imsg);
	imsEnum       DispatchError(imtEnum imtType, IErrorCode imsg, int i);
	imsEnum       DispatchError(imtEnum imtType, IErrorCode imsg, const IMsiString& riStr);
	imsEnum       DispatchError(imtEnum imtType, IErrorCode imsg, int i, const ICHAR* sz);
	imsEnum       DispatchError(imtEnum imtType, IErrorCode imsg, const IMsiString& riStr1, const IMsiString& riStr2);
	imsEnum       DispatchError(imtEnum imtType, IErrorCode imsg, const IMsiString& riStr1, const IMsiString& riStr2, const IMsiString& riStr3);
	imsEnum       DispatchError(imtEnum imtType, IErrorCode imsg, const IMsiString& riStr1, const IMsiString& riStr2, const IMsiString& riStr3, int i);
	imsEnum       DispatchError(imtEnum imtType, IErrorCode imsg, const IMsiString& riStr1, const IMsiString& riStr2, const IMsiString& riStr3, const IMsiString& riStr4, const IMsiString& riStr5);
	imsEnum       DispatchError(imtEnum imtType, IErrorCode imsg, const ICHAR* sz, int i);
	imsEnum       DispatchError(imtEnum imtType, IErrorCode imsg, const ICHAR* sz, int i1,int i2,int i3);
	imsEnum       DispatchProgress(unsigned int iIncrement);
	Bool          ReplaceFileOnReboot(const ICHAR* pszExisting, const ICHAR* pszNew);
	iesEnum       DeleteFileDuringCleanup(const ICHAR* szFile, bool fDeleteEmptyFolderToo);
	bool          VerifySourceMedia(IMsiPath& riSourcePath, const ICHAR* szLabel,
									const ICHAR* szPrompt, const unsigned int uiDisk,IMsiVolume*& rpiNewVol);
	iesEnum       InitCopier(Bool fCabinetCopier, int cbPerTick, const IMsiString& ristrFileName,
									 IMsiPath* piSourcePath, Bool fVerifyMedia);
	iesEnum       CreateFolder(IMsiPath& riPath, Bool fForeign=fFalse, Bool fExplicitCreation=fFalse, IMsiStream* pSD=0);
	iesEnum       RemoveFolder(IMsiPath& riPath, Bool fForeign=fFalse, Bool fExplicitCreation=fFalse);
	iesEnum       FileCheckExists(const IMsiString& ristrName, const IMsiString& ristrPath);
	iesEnum       ProcessRegInfo(const ICHAR** pszData, HKEY hkey, Bool fRemove, IMsiStream* pSecurityDescriptor=0, bool* pfAbortedRemoval = 0, ibtBinaryType iType = ibtUndefined);
	bool          RollbackRecord(ixoEnum ixoOpCode, IMsiRecord& riParams);
	inline Bool   RollbackEnabled(void);
	iesEnum       SetRemoveKeyUndoOps(IMsiRegKey& riRegKey);
	iesEnum       SetRegValueUndoOps(rrkEnum rrkRoot, const ICHAR* szKey, const ICHAR* szName, ibtBinaryType iType);
	iesEnum       BackupFile(IMsiPath& riPath, const IMsiString& ristrFile, Bool fRemoveOriginal,
									 Bool fRemoveFolder, iehEnum iehErrorMode, bool fRebootOnRenameFailure=true,
									 bool fWillReplace = false, const IMsiString* pistrAssemblyComponentId = false, bool fManifest = false);
	iesEnum       GetBackupFolder(IMsiPath* piRootPath, IMsiPath*& rpiBackupFolder);
	iesEnum       BackupAssembly(const IMsiString& rstrComponentId, const IMsiString& rstrAssemblyName, iatAssemblyType iatType);
	iesEnum       RemoveFile(IMsiPath& riPath, const IMsiString& ristrFileName, Bool fHandleRollback, bool fBypassSFC,
									 bool fRebootOnRenameFailure = true, Bool fRemoveFolder = fTrue, iehEnum iehErrorMode = iehSilentlyIgnoreError,
									 bool fWillReplace = false);
	iesEnum       CopyFile(IMsiPath& riSourcePath, IMsiPath& riTargetPath, IMsiRecord& riParams, Bool fHandleRollback, 
								  iehEnum iehErrorMode, bool fCabinetCopy);
	iesEnum       CopyFile(IMsiPath& riSourcePath, IAssemblyCacheItem& riASM, bool fManifest, IMsiRecord& riParams, Bool fHandleRollback, 
								  iehEnum iehErrorMode, bool fCabinetCopy);
	iesEnum       _CopyFile(IMsiPath& riSourcePath, IMsiPath* piTargetPath, IAssemblyCacheItem* piASM, bool fManifest, IMsiRecord& riParams, Bool fHandleRollback, 
								  iehEnum iehErrorMode, bool fCabinetCopy);
	iesEnum       MoveFile(IMsiPath& riSourcePath, IMsiPath& riDestPath, IMsiRecord& riParams,
								  Bool fRemoveFolder, Bool fHandleRollback,
								  bool fRebootOnSourceRenameFailure, bool fWillReplaceSource,
								  iehEnum iehErrorMode);
	iesEnum       CopyOrMoveFile(IMsiPath& riSourcePath, IMsiPath& riDestPath,
								  const IMsiString& ristrSourceName, const IMsiString& ristrDestName,
								  Bool fMove, Bool fRemoveFolder, Bool fHandleRollback, iehEnum iehErrorMode,
								  IMsiStream* piSecurityDescriptor=0, ielfEnum ielfElevateFlags=ielfNoElevate, bool fCopyACLs=false,
								  bool fRebootOnSourceRenameFailure=true, bool fWillReplaceSource=false);
	iesEnum       CopyASM(IMsiPath& riSourcePath, const IMsiString& ristrSourceName,
								 IAssemblyCacheItem& riASM, const IMsiString& ristrDestName, bool fManifest, 
								 Bool fHandleRollback, iehEnum iehErrorMode, ielfEnum ielfElevateFlags);
	iesEnum       HandleExistingFile(IMsiPath& riDestPath, IMsiRecord& riParams, Bool fHandleRollback, 
										iehEnum iehErrorMode, bool& fFileExisted);
	iesEnum       VerifyAccessibility(IMsiPath& riPath, const ICHAR* szFile, DWORD dwAccess, iehEnum iehErrorMode);
	void          PushRecord(IMsiRecord& riParams);
	void          InsertTopRecord(IMsiRecord& riParams);
	IMsiRecord*   PullRecord();
	imsEnum       ShowFileErrorDialog(IErrorCode err,const IMsiString& riFullPathString,Bool fVital);

	iesEnum       ProcessPublishProduct(IMsiRecord& riParams, Bool fRemove, const IMsiString** pistrTransformsValue=0);
	iesEnum       ProcessPublishProductClient(IMsiRecord& riParams, Bool fRemove);
	iesEnum       ProcessPublishFeature(IMsiRecord& riParams, Bool fRemove);
	iesEnum       ProcessPublishComponent(IMsiRecord& riParams, Bool fRemove);
	iesEnum       ProcessAppIdInfo(IMsiRecord& riParams, Bool fRemove, const ibtBinaryType);
	iesEnum       ProcessClassInfo(IMsiRecord& riParams, Bool fRemove, const ibtBinaryType);
	iesEnum       ProcessProgIdInfo(IMsiRecord& riParams, Bool fRemov, const ibtBinaryType);
	iesEnum       ProcessMIMEInfo(IMsiRecord& riParams, Bool fRemove, const ibtBinaryType);
	iesEnum       ProcessExtensionInfo(IMsiRecord& riParams, Bool fRemove, const ibtBinaryType);
	iesEnum       ProcessTypeLibraryInfo(IMsiRecord& riParams, Bool fRemove);
	iesEnum       ProcessShortcut(IMsiRecord& riParams, Bool fRemove);
	iesEnum       ProcessIcon(IMsiRecord& riParams, Bool fRemove);
	iesEnum       ProcessFont(IMsiRecord& riParams, Bool fRemove);
	iesEnum       ProcessFileFromData(IMsiPath& riPath, const IMsiString& ristrFileName, const IMsiData* piData, LPSECURITY_ATTRIBUTES pAttributes);
	iesEnum       ProcessSelfReg(IMsiRecord& riParams, Bool fReg);
	iesEnum       ProcessPatchRegistration(IMsiRecord& riParams, Bool fRemove);
	iesEnum       ProcessPublishSourceList(IMsiRecord& riParams, Bool fRemove);
	iesEnum       ProcessPublishSourceListEx(IMsiRecord& riParams);
	iesEnum       ProcessPublishMediaSourceList(IMsiRecord& riParams);
	iesEnum       ProcessRegisterUser(IMsiRecord& riUserInfo, Bool fRemove);
	iesEnum       ProcessRegisterProduct(IMsiRecord& riProductInfo, Bool fRemove);
	iesEnum       ProcessRegisterProductCPDisplayInfo(IMsiRecord& riParams, Bool fRemove);
	iesEnum       ProcessUpgradeCodePublish(IMsiRecord& riParams, Bool fRemove);
	iesEnum       ProcessComPlusInfo(IMsiRecord& riParams, Bool fRemove);
	iesEnum       ProcessPublishAssembly(IMsiRecord& riParams, Bool fRemove);


	Bool          GetSpecialFolderLocation(int iFolder, CTempBufferRef<ICHAR>& rgchProfilePath);
	Bool          FFileExists(IMsiPath& riPath, const IMsiString& ristrFile);
	iesEnum       FatalError(IMsiRecord& riError) { Message(imtError,riError); return iesFailure; }
	IMsiRecord*   DoShellNotify(IMsiPath& riShortcutPath, const ICHAR* szFileName, IMsiPath& riPath2, Bool fRemove);
	IMsiRecord*   DoShellNotifyDefer(IMsiPath& riShortcutPath, const ICHAR* szFileName, IMsiPath& riPath2, Bool fRemove);
	iesEnum       ShellNotifyProcessDeferred(void);

	ICHAR**       NewArgumentArray(const IMsiString& ristrArguments, int& cArguments);
	bool          WaitForService(const SC_HANDLE hService, const DWORD dwDesiredState, const DWORD dwFailedState);
	bool          StartService(IMsiRecord& riParams, IMsiRecord& riUndoParams, BOOL fRollback);
	bool          StopService(IMsiRecord& riParams, IMsiRecord& riUndoParams, BOOL fRollback, IMsiRecord* piActionData = NULL);
	bool          DeleteService(IMsiRecord& riParams, IMsiRecord& riUndoParams, BOOL fRollback, IMsiRecord* piActionData = NULL);
	bool          RollbackServiceConfiguration(const SC_HANDLE hService, const IMsiString& ristrName, IMsiRecord& riParams);
	iesEnum       RollbackODBCINSTEntry(const ICHAR* szSection, const ICHAR* ristrName, ibtBinaryType iType);
	iesEnum       RollbackODBCEntry(const ICHAR* szName, rrkEnum rrkRoot, ibtBinaryType iType);

	iesEnum       CheckODBCError(BOOL fResult, IErrorCode imsg, const ICHAR* sz, imsEnum imsDefault, ibtBinaryType iType);

	iesEnum       ODBCInstallDriverCore(IMsiRecord& riParams, ibtBinaryType iType);
	iesEnum       ODBCRemoveDriverCore(IMsiRecord& riParams, ibtBinaryType iType);
	iesEnum       ODBCInstallTranslatorCore(IMsiRecord& riParams, ibtBinaryType iType);
	iesEnum       ODBCRemoveTranslatorCore(IMsiRecord& riParams, ibtBinaryType iType);
	iesEnum       ODBCDataSourceCore(IMsiRecord& riParams, ibtBinaryType iType);

	const         IMsiString& ComposeDescriptor(const IMsiString& riFeature, const IMsiString& riComponent, bool fComClassicInteropForAssembly = false);
	IMsiRecord*   GetShellFolder(int iFolderId, const IMsiString*& rpistrLocation);
	iesEnum       DoMachineVsUserInitialization(void);
	void          GetRollbackPolicy(irlEnum& irlLevel);
	iesEnum       CreateFileFromData(IMsiPath& riPath, const IMsiString& ristrFileName, const IMsiData* piData, LPSECURITY_ATTRIBUTES pAttributes=0);
	iesEnum       TestPatchHeaders(IMsiPath& riPath, const IMsiString& ristrFile, IMsiRecord& riParams, icpEnum& icpResult, int& iPatch);
	bool  	     UpdateWindowsEnvironmentStrings(IMsiRecord& riParams);
	bool          UpdateRegistryEnvironmentStrings(IMsiRecord& riParams);
	bool          RewriteEnvironmentString(const iueEnum iueAction, const ICHAR chDelimiter, const IMsiString& ristrCurrent, const IMsiString& ristrNew, const IMsiString*& rpiReturn);
	bool          InitializeWindowsEnvironmentFiles(const IMsiString& ristrAutoExecPath, int &iFileAttributes);
	IMsiRecord*   CacheFileState(const IMsiString& ristrFilePath,icfsEnum* picfsState,
										  const IMsiString* pistrTempLocation, const IMsiString* pistrVersion,
										  int *pcPatchesRemaining, int *pcPatchesRemainingToSkip);
	Bool          GetFileState(const IMsiString& ristrFilePath,icfsEnum* picfsState,
										const IMsiString** ppistrTempLocation,
										int *pcPatchesRemaining, int *pcPatchesRemainingToSkip);
	IMsiRecord*   SetSecureACL(IMsiPath& riPath, bool fHidden=false);
	IMsiRecord*   GetSecureSecurityDescriptor(IMsiStream*& rpiStream, bool fHidden=false);
	IMsiRecord*   GetUsageKeySecurityDescriptor(IMsiStream*& rpiStream);
	void          GetProductClientList(const ICHAR* szParent, const ICHAR* szRelativePackagePath, unsigned int uiDiskId, const IMsiString*& rpiClientList);
	IMsiRecord*   GetCachePath(IMsiPath*& rpiPath, const IMsiString** ppistrEncodedPath);
	iesEnum       CreateUninstallKey();
	iesEnum       PinOrUnpinSecureTransform(const ICHAR* szTransform, bool fUnpin);
	bool          WriteRollbackRecord(ixoEnum ixoOpCode, IMsiRecord& riParams);
	iesEnum       CreateFilePath(const ICHAR* szPath, IMsiPath*& rpiPath, const IMsiString*& rpistrFileName);
	bool          PatchHasClients(const IMsiString& ristrPatchId, const IMsiString& ristrUpgradingProductCode);
	iesEnum       GetSecurityDescriptor(const ICHAR* szFile, IMsiStream*& rpiSecurityDescriptor);
	const IMsiString& GetUserProfileEnvPath(const IMsiString& ristrPath, bool& fExpand);
	iesEnum       RemoveRegKeys(const ICHAR** pszData, HKEY hkey, ibtBinaryType iType);
	iesEnum       EnsureClassesRootKeyRW();
	static        BOOL CALLBACK SfpProgressCallback(IN PFILEINSTALL_STATUS pFileInstallStatus, IN DWORD_PTR Context);
	// access to current ProductInfo record
	const IMsiString& GetProductKey();
	const IMsiString& GetProductName();
	const IMsiString& GetProductIcon();
	const IMsiString& GetPackageName();
	int               GetProduct