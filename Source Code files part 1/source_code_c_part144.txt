 (MAX_PATH + 13)) == NULL){
        free (pszTempPath);
        return FALSE;
    }

         // if this fails it probably means we have a bad path
    if (!GetTempFileName(pszTempPath, "scs", 0, pszTempFileName))
       {
          // lets get something else, which should succeed
         TempPathSize = GetWindowsDirectory(pszTempPath, MAX_PATH);
         if (!TempPathSize || TempPathSize >= MAX_PATH)
             strcpy(pszTempPath, "\\");

          // try again and hope for the best
         GetTempFileName(pszTempPath, "scs", 0, pszTempFileName);
         }


    // must have a security descriptor so that the child process
    // can inherit this file handle. This is done because when we
    // shell out with piping the 32 bits application must have inherited
    // the temp filewe created, see cmdGetStdHandle
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    if ((hTempFile = CreateFile (pszTempFileName,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 &sa,
                                 OPEN_ALWAYS,
                                 FILE_ATTRIBUTE_TEMPORARY,
                                 NULL)) == (HANDLE)-1){
        free (pszTempFileName);
        free (pszTempPath);
        return FALSE;
    }

    *phTempFile = hTempFile;
    *ppszTempFile = pszTempFileName;
    free (pszTempPath);
    return TRUE;
}

/* cmdCheckStandardHandles - Check if we have to do anything to support
 *                           standard io redirection, if so save away
 *                           pertaining information.
 *
 *  Entry - pVDMInfo - VDMInfo Structure
 *          pbStdHandle - pointer to bit array for std handles
 *
 *  EXIT  - return NULL if no redirection involved
 *          return pointer to REDIRECTION_INFO
 */

PREDIRCOMPLETE_INFO cmdCheckStandardHandles (
    PVDMINFO pVDMInfo,
    USHORT UNALIGNED *pbStdHandle
    )
{
USHORT bTemp = 0;
PREDIRCOMPLETE_INFO pRdrInfo;

    if (pVDMInfo->StdIn)
        bTemp |= MASK_STDIN;

    if (pVDMInfo->StdOut)
        bTemp |= MASK_STDOUT;

    if (pVDMInfo->StdErr)
        bTemp |= MASK_STDERR;

    if(bTemp){

        if ((pRdrInfo = malloc (sizeof (REDIRCOMPLETE_INFO))) == NULL) {
            RcErrorDialogBox(EG_MALLOC_FAILURE, NULL, NULL);
            TerminateVDM();
        }

        RtlZeroMemory ((PVOID)pRdrInfo, sizeof(REDIRCOMPLETE_INFO));
        pRdrInfo->ri_hStdErr = pVDMInfo->StdErr;
        pRdrInfo->ri_hStdOut = pVDMInfo->StdOut;
        pRdrInfo->ri_hStdIn  = pVDMInfo->StdIn;

        nt_std_handle_notification(TRUE);
        fSoftpcRedirection = TRUE;
    }
    else{
        pRdrInfo = NULL;
        nt_std_handle_notification(FALSE);
        fSoftpcRedirection = FALSE;
    }

    *pbStdHandle = bTemp;
    return pRdrInfo;
}

/* cmdGetStdHandle - Get the 32 bit NT standard handle for the VDM
 *
 *
 *  Entry - Client (CX) - 0,1 or 2 (stdin stdout stderr)
 *          Client (AX:BX) - redirinfo pointer
 *
 *  EXIT  - Client (BX:CX) - 32 bit handle
 *          Client (DX:AX) - file size
 */

VOID cmdGetStdHandle (VOID)
{
USHORT iStdHandle;
PREDIRCOMPLETE_INFO pRdrInfo;

    iStdHandle = getCX();
    pRdrInfo = (PREDIRCOMPLETE_INFO) (((ULONG)getAX() << 16) + (ULONG)getBX());

    switch (iStdHandle) {

        case HANDLE_STDIN:

            if (GetFileType(pRdrInfo->ri_hStdIn) == FILE_TYPE_PIPE) {
                if (!cmdHandleStdinWithPipe (pRdrInfo)) {
                    RcErrorDialogBox(EG_MALLOC_FAILURE, NULL, NULL);
                    TerminateVDM();
                    setCF(1);
                    return;
                }
                setCX ((USHORT)pRdrInfo->ri_hStdInFile);
                setBX ((USHORT)((ULONG)pRdrInfo->ri_hStdInFile >> 16));
            }
            else {
                setCX ((USHORT)pRdrInfo->ri_hStdIn);
                setBX ((USHORT)((ULONG)pRdrInfo->ri_hStdIn >> 16));
            }
            break;

        case HANDLE_STDOUT:
            if (GetFileType (pRdrInfo->ri_hStdOut) == FILE_TYPE_PIPE){
                if (!cmdHandleStdOutErrWithPipe(pRdrInfo, HANDLE_STDOUT)) {
                    RcErrorDialogBox(EG_MALLOC_FAILURE, NULL, NULL);
                    TerminateVDM();
                    setCF(1);
                    return;
                }
                setCX ((USHORT)pRdrInfo->ri_hStdOutFile);
                setBX ((USHORT)((ULONG)pRdrInfo->ri_hStdOutFile >> 16));

            }
            else {
                // sudeepb 16-Mar-1992; This will be a compatibilty problem.
                // If the user gives the command "dosls > lpt1" we will
                // inherit the 32 bit handle of lpt1, so the ouput will
                // directly go to the LPT1 and a DOS TSR/APP hooking int17
                // wont see this printing. Is this a big deal???
                setCX ((USHORT)pRdrInfo->ri_hStdOut);
                setBX ((USHORT)((ULONG)pRdrInfo->ri_hStdOut >> 16));
            }
            break;

        case HANDLE_STDERR:

            if (pRdrInfo->ri_hStdErr == pRdrInfo->ri_hStdOut
                              && pRdrInfo->ri_hStdOutFile != 0) {
                setCX ((USHORT)pRdrInfo->ri_hStdOutFile);
                setBX ((USHORT)((ULONG)pRdrInfo->ri_hStdOutFile >> 16));
                pRdrInfo->ri_hStdErrFile = pRdrInfo->ri_hStdOutFile;
                break;
            }

            if (GetFileType (pRdrInfo->ri_hStdErr) == FILE_TYPE_PIPE){
                if(!cmdHandleStdOutErrWithPipe(pRdrInfo, HANDLE_STDERR)) {
                    RcErrorDialogBox(EG_MALLOC_FAILURE, NULL, NULL);
                    TerminateVDM();
                    setCF(1);
                    return;
                }
                setCX ((USHORT)pRdrInfo->ri_hStdErrFile);
                setBX ((USHORT)((ULONG)pRdrInfo->ri_hStdErrFile >> 16));
            }
            else {
                setCX ((USHORT)pRdrInfo->ri_hStdErr);
                setBX ((USHORT)((ULONG)pRdrInfo->ri_hStdErr >> 16));
            }
            break;
    }
    setAX(0);
    setDX(0);
    setCF(0);
    return;
}

BOOL cmdHandleStdOutErrWithPipe(
    PREDIRCOMPLETE_INFO pRdrInfo,
    USHORT  HandleType
    )
{

    HANDLE  hFile;
    PCHAR   pFileName;
    PPIPE_OUTPUT pPipe;
    BYTE    *Buffer;
    DWORD   ThreadId;
    HANDLE  hEvent;
    HANDLE  hFileWrite;
    HANDLE  hThread;

    if(!cmdCreateTempFile(&hFile,&pFileName))
        return FALSE;
    // must have a different handle so that writter(dos app) and reader(us)
    // wont use the same handle object(especially, file position)
    hFileWrite = CreateFile(pFileName,
                            GENERIC_WRITE | GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_TEMPORARY,
                            NULL
                           );
    if (hFileWrite == INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
        DeleteFile(pFileName);
        return FALSE;
    }
    Buffer = malloc(sizeof(PIPE_OUTPUT) + PIPE_OUTPUT_BUFFER_SIZE);
    if (Buffer == NULL) {
        CloseHandle(hFile);
        CloseHandle(hFileWrite);
        DeleteFile(pFileName);
        return FALSE;
    }
    pPipe = (PPIPE_OUTPUT)Buffer;
    pPipe->Buffer = Buffer + sizeof(PIPE_OUTPUT);
    pPipe->BufferSize = PIPE_OUTPUT_BUFFER_SIZE;
    pPipe->hFile = hFileWrite;
    pPipe->pFileName = pFileName;
    pPipe->hExitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (pPipe->hExitEvent == NULL) {
        CloseHandle(hFile);
        CloseHandle(hFileWrite);
        DeleteFile(pFileName);
        free(pPipe);
        return FALSE;
    }

    if (HandleType == HANDLE_STDOUT) {
        pPipe->hPipe = pRdrInfo->ri_hStdOut;
        pRdrInfo->ri_pPipeStdOut = pPipe;
        pRdrInfo->ri_hStdOutFile = hFile;

    }
    else {
        pPipe->hPipe = pRdrInfo->ri_hStdErr;
        pRdrInfo->ri_pPipeStdErr = pPipe;
        pRdrInfo->ri_hStdErrFile = hFile;

    }
    hThread = CreateThread ((LPSECURITY_ATTRIBUTES)NULL,
                            (DWORD)0,
                            (LPTHREAD_START_ROUTINE)cmdPipeOutThread,
                            (LPVOID)pPipe,
                            0,
                            &ThreadId
                            );
    if (hThread == NULL) {
        CloseHandle(pPipe->hExitEvent);
        CloseHandle(hFileWrite);
        CloseHandle(hFile);
        DeleteFile(pFileName);
        free(Buffer);
        return FALSE;
    }
    if (HandleType == HANDLE_STDOUT)
        pRdrInfo->ri_hStdOutThread = hThread;
    else
        pRdrInfo->ri_hStdErrThread = hThread;
    return TRUE;
}

/* independent thread to read application stdout(file) to NTVDM stdout(PIPE).
   The CPU thread would notify us through hExitEvent when the application
   is terminating(thus, we can detect EOF and exit
 */

VOID  cmdPipeOutThread(LPVOID lpParam)
{
    PPIPE_OUTPUT pPipe;
    DWORD        BytesRead;
    DWORD        BytesWritten;
    BOOL         ExitPending;

    pPipe = (PPIPE_OUTPUT)lpParam;

    ExitPending = FALSE;

    while(ReadFile(pPipe->hFile, pPipe->Buffer, pPipe->BufferSize, &BytesRead, NULL) ) {
        // go nothing doesn't mean it hits EOF!!!!!!
        // we can not just exit now, instead, we have to wait and poll
        // until the application is terminated.
        //
        if (BytesRead == 0) {
            // if read nothing and the application is gone, we can quit now
            if (ExitPending)
                break;
            if (!WaitForSingleObject(pPipe->hExitEvent, PIPE_OUTPUT_TIMEOUT))
                ExitPending = TRUE;
        }
        else {
            if (!WriteFile(pPipe->hPipe, pPipe->Buffer, BytesRead, &BytesWritten, NULL) ||
                BytesWritten != BytesRead)
                break;
        }
    }
    // if we were out of loop because of errors, wait for the cpu thread.
    if (!ExitPending)
        WaitForSingleObject(pPipe->hExitEvent, INFINITE);

    CloseHandle(pPipe->hFile);
    CloseHandle(pPipe->hPipe);
    CloseHandle(pPipe->hExitEvent);
    DeleteFile(pPipe->pFileName);
    free(pPipe->pFileName);
    free(pPipe);
    ExitThread(0);
}

BOOL cmdHandleStdinWithPipe (
    PREDIRCOMPLETE_INFO pRdrInfo
    )
{

    HANDLE  hStdinFile;
    PCHAR   pStdinFileName;
    PPIPE_INPUT pPipe;
    BYTE    *Buffer;
    DWORD   ThreadId;
    HANDLE  hEvent;
    HANDLE  hFileWrite;

    if(!cmdCreateTempFile(&hStdinFile,&pStdinFileName))
        return FALSE;


    // must have a different handle so that reader(dos app) and writter(us)
    // wont use the same handle object(especially, file position)
    hFileWrite = CreateFile(pStdinFileName,
                            GENERIC_WRITE | GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_TEMPORARY,
                            NULL
                           );
    if (hFileWrite == INVALID_HANDLE_VALUE) {
        CloseHandle(hStdinFile);
        DeleteFile(pStdinFileName);
        return FALSE;
    }
    Buffer = malloc(sizeof(PIPE_INPUT) + PIPE_INPUT_BUFFER_SIZE);
    if (Buffer == NULL) {
        CloseHandle(hStdinFile);
        CloseHandle(hFileWrite);
        DeleteFile(pStdinFileName);
        return FALSE;
    }
    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hEvent == NULL) {
        CloseHandle(hStdinFile);
        CloseHandle(hFileWrite);
        DeleteFile(pStdinFileName);
        free(Buffer);
        return FALSE;
    }
    pPipe = (PPIPE_INPUT)Buffer;
    pPipe->Buffer = Buffer + sizeof(PIPE_INPUT);
    pPipe->BufferSize = PIPE_INPUT_BUFFER_SIZE;
    pPipe->fEOF = FALSE;
    pPipe->hFileWrite = hFileWrite;
    pPipe->hFileRead  = hStdinFile;
    pPipe->hDataEvent = hEvent;
    pPipe->hPipe = pRdrInfo->ri_hStdIn;
    pPipe->pFileName = pStdinFileName;
    InitializeCriticalSection(&pPipe->CriticalSection);
    pPipe->hThread = CreateThread ((LPSECURITY_ATTRIBUTES)NULL,
                               (DWORD)0,
                               (LPTHREAD_START_ROUTINE)cmdPipeInThread,
                               (LPVOID)pPipe,
                               0,
                               &ThreadId
                              );
    if (pPipe->hThread == NULL) {
        CloseHandle(hFileWrite);
        CloseHandle(pPipe->hDataEvent);
        CloseHandle(hStdinFile);
        DeleteFile(pStdinFileName);
        free(Buffer);
        return FALSE;
    }
    // always have the new node in the head of the list because
    // it is the node used by the top command.com running in the process.
    // We may have multiple command.com instances running in the same
    // ntvdm proecess and each command.com has a private PREDIRCOMPLETE_INFO
    // associated with it if its stdin is redirected to a pipe.
    pPipe->Next = cmdPipeList;
    cmdPipeList = pPipe;
    pRdrInfo->ri_hStdInFile = hStdinFile;
    pRdrInfo->ri_pPipeStdIn = pPipe;
    return TRUE;
}

/* Independent thread to read from pipe(NTVDM STDIN) and write to
   file(DOS application STDIN) until either the pipe is broken or
   there are some errors.
   This thread may never terminate itself because it can block
   in the ReadFile call to the pipe forever. If this is the case,
   we have to rely on the CPU thread to kill it. To allow the CPU
   thread safely launching the killing, this thread yields the
   critical section when it is safe to be killed and the CPU thread
   would claim the critical section first before going for kill.
 */

VOID cmdPipeInThread(LPVOID lpParam)
{
    PPIPE_INPUT pPipe;
    DWORD       BytesRead, BytesWritten;
    BOOL        ReadStatus, WriteStatus;
    BOOL        ApplicationTerminated, fEOF;

    pPipe = (PPIPE_INPUT)lpParam;
    while (TRUE) {

        // this read can take forever without getting back anything
        ReadStatus = ReadFile(pPipe->hPipe, pPipe->Buffer,
                              pPipe->BufferSize, &BytesRead, NULL);

        // claim the critical section so we won't get killed
        // by the CPU thread
        EnterCriticalSection(&pPipe->CriticalSection);
        if (ReadStatus) {
            if (BytesRead != 0) {
                WriteStatus = WriteFile(pPipe->hFileWrite,
                                        pPipe->Buffer,
                                        BytesRead,
                                        &BytesWritten,
                                        NULL
                                        );
                if (pPipe->WaitData && WriteStatus && BytesWritten != 0) {
                    PulseEvent(pPipe->hDataEvent);

                    //
                    // Reset WaitData so we won't signal Event again before
                    // data is read out.
                    //
                    pPipe->WaitData = FALSE;
                }
            }
        } else {
            if (GetLastError() == ERROR_BROKEN_PIPE) {

                // pipe is broken and more data to read?
                ASSERT(BytesRead == 0);
                pPipe->fEOF = TRUE;
                LeaveCriticalSection(&pPipe->CriticalSection);
                break;
            }
        }
        // as soon as we leave the critical seciton, the CPU thread may
        // step in and kill us
        LeaveCriticalSection(&pPipe->CriticalSection);
    }
    ExitThread(0);
}

/* cmdPipeFileDataEOF - Check for new data or EOF
 *
 *
 *  Entry - hFile, DOS application STDIN file handle(file)
 *          &fEOF, to return if the pipe is broken
 *  EXIT  - TRUE if either there are new data or EOF is true
 *          *fEOF == TRUE if EOF
 */

BOOL cmdPipeFileDataEOF(HANDLE hFile, BOOL *fEOF)
{
    PPIPE_INPUT pPipe;
    BOOL        NewData = FALSE;
    DWORD       WaitStatus;
    DWORD       FilePointerLow, FilePointerHigh = 0;
    DWORD       FileSizeLow, FileSizeHigh;

    pPipe = cmdPipeList;
    while (pPipe != NULL && pPipe->hFileRead != hFile)
        pPipe = pPipe->Next;

    if (pPipe != NULL) {
        *fEOF = pPipe->fEOF;
        if (!(*fEOF)) {

            //
            // If not EOF, check file pointer and file size to see
            // if new data is available.
            //
            FilePointerLow = SetFilePointer(
                                 hFile,
                                 (LONG)0,
                                 &FilePointerHigh,
                                 (DWORD)FILE_CURRENT
                                 );
            ASSERT(FilePointerLow != 0xffffffff);

            EnterCriticalSection(&pPipe->CriticalSection);

            *fEOF = pPipe->fEOF;
            FileSizeLow = GetFileSize(hFile, &FileSizeHigh);
            ASSERT(FileSizeLow != 0xffffffff);

            //
            // If (file size == file pointer) there is NO new data
            // Just in case the file grows bigger than 4G.  We compare the
            // whole 64 bits.
            //
            if ((FilePointerLow == FileSizeLow) && (FilePointerHigh == FileSizeHigh)) {
                pPipe->WaitData = TRUE;
            } else {
                NewData = TRUE;
            }
            LeaveCriticalSection(&pPipe->CriticalSection);

            if (!NewData) {

                //
                // If InThread enters critical section, writes data and
                // pulses event before we start wait.  We will not be waken up.
                // But, we should be able to pick up the new data next
                // time we enter this routine.
                //
                WaitStatus = WaitForSingleObject(pPipe->hDataEvent, PIPE_INPUT_TIMEOUT);
                NewData = WaitStatus == WAIT_OBJECT_0 ? TRUE : FALSE;
                pPipe->WaitData = FALSE; // Not in Critical Section
            }
        }
    } else {
        *fEOF = TRUE;
    }
    return(NewData || *fEOF);
}

/* cmdPipeFileEOF - Check if the pipe is broken
 *
 *
 *  Entry - hFile, DOS application STDIN file handle(file)
 *
 *  EXIT  - TRUE if the write end of the pipe is closed
 */


BOOL cmdPipeFileEOF(HANDLE hFile)
{
    PPIPE_INPUT pPipe;
    BOOL       fEOF;

    pPipe = cmdPipeList;
    while (pPipe != NULL && pPipe->hFileRead != hFile)
        pPipe = pPipe->Next;

    fEOF = TRUE;

    if (pPipe != NULL) {
        EnterCriticalSection(&pPipe->CriticalSection);
        fEOF = pPipe->fEOF;
        LeaveCriticalSection(&pPipe->CriticalSection);
    }
    if (!fEOF) {
        Sleep(PIPE_INPUT_TIMEOUT);
        EnterCriticalSection(&pPipe->CriticalSection);
        fEOF = pPipe->fEOF;
        LeaveCriticalSection(&pPipe->CriticalSection);
    }
    return (fEOF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demdisp.c ===
/*
 *  demdisp.c - SVC dispatch module
 *
 *  Modification History:
 *
 *  Sudeepb 31-Mar-1991 Created
 */

#include "dem.h"
#include <stdio.h>
#include <softpc.h>
#include <dbgsvc.h>


#if DBG

PCHAR   aSVCNames[] = {
     "demChgFilePtr",
     "demChMod",
     "demClose",
     "demCreate",
     "demCreateDir",
     "demDelete",
     "demDeleteDir",
     "demDeleteFCB",
     "demFileTimes",
     "demFindFirst",
     "demFindFirstFCB",
     "demFindNext",
     "demFindNextFCB",
     "demGetBootDrive",
     "demGetDriveFreeSpace",
     "demGetDrives",
     "demGSetMediaID",
     "demLoadDos",
     "demOpen",
     "demQueryCurrentDir",
     "demQueryDate",
     "demQueryTime",
     "demRead",
     "demRename",
     "demSetCurrentDir",
     "demSetDate",
     "demSetDefaultDrive",
     "demSetDTALocation",
     "demSetTime",
     "demSetV86KernelAddr",
     "demWrite",
     "demGetDriveInfo",
     "demRenameFCB",
     "demIOCTL",
     "demCreateNew",
     "DemDiskReset",
     "DemSetDPB",
     "DemGetDPB",
     "DemSleazeFunc",
     "demCommit",
     "DemExtHandle",
     "DemAbsDRD",
     "DemAbsDWRT",
     "DemGsetCDPG",
     "DemCreateFCB",
     "DemOpenFCB",
     "DemCloseFCB",
     "DemFCBIO",
     "DemDate16",
     "DemGetFileInfo",
     "DemSetHardErrorInfo",
     "DemRetry",
     "DemLoadDosAppSym",
     "DemFreeDosAppSym",
     "DemEntryDosApp",
     "DemDOSDispCall",
     "DemDOSDispRet",
     "DemOutputString",
     "DemInputString",
     "DemIsDebug",
     "DemTerminatePDB",
     "DemExitVDM",
     "DemWOWFiles",
     "DemLockOper",
     "demNotYetImplemented",
     "DemGetComputerName",
     "DemFastRead",
     "DemFastWrite",
     "DemCheckPath",
     "DemSystemSymbolOp",
     "DemGetDpbList",
     "DemPipeFileDataEOF",
     "DemPipeFileEOF",
     "DemLFNEntry",
     "DemSetDosVarLocation"
};

#endif   // DBG

DWORD  fShowSVCMsg = 0;
ULONG  CurrentISVC;


PFNSVC  apfnSVC [] = {
     demChgFilePtr,     //SVC_DEMCHGFILEPTR
     demChMod,          //SVC_DEMCHMOD
     demClose,          //SVC_DEMCLOSE
     demCreate,         //SVC_DEMCREATE
     demCreateDir,      //SVC_DEMCREATEDIR
     demDelete,         //SVC_DEMDELETE
     demDeleteDir,      //SVC_DEMDELETEDIR
     demDeleteFCB,      //SVC_DEMDELETEFCB
     demFileTimes,      //SVC_DEMFILETIMES
     demFindFirst,      //SVC_DEMFINDFIRST
     demFindFirstFCB,       //SVC_DEMFINDFIRSTFCB
     demFindNext,       //SVC_DEMFINDNEXT
     demFindNextFCB,        //SVC_DEMFINDNEXTFCB
     demGetBootDrive,       //SVC_DEMGETBOOTDRIVE
     demGetDriveFreeSpace,  //SVC_DEMGETDRIVEFREESPACE
     demGetDrives,      //SVC_DEMGETDRIVES
     demGSetMediaID,        //SVC_DEMGSETMEDIAID
     demLoadDos,        //SVC_DEMLOADDOS
     demOpen,           //SVC_DEMOPEN
     demQueryCurrentDir,    //SVC_DEMQUERYCURRENTDIR
     demQueryDate,      //SVC_DEMQUERYDATE
     demQueryTime,      //SVC_DEMQUERYTIME
     demRead,           //SVC_DEMREAD
     demRename,         //SVC_DEMRENAME
     demSetCurrentDir,      //SVC_DEMSETCURRENTDIR
     demSetDate,        //SVC_DEMSETDATE
     demSetDefaultDrive,    //SVC_DEMSETDEFAULTDRIVE
     demSetDTALocation,     //SVC_DEMSETDTALOCATION
     demSetTime,        //SVC_DEMSETTIME
     demSetV86KernelAddr,   //SVC_DEMSETV86KERNELADDR
     demWrite,          //SVC_DEMWRITE
     demNotYetImplemented,  //SVC_GETDRIVEINFO
     demRenameFCB,      //SVC_DEMRENAMEFCB
     demIOCTL,          //SVC_DEMIOCTL
     demCreateNew,      //SVC_DEMCREATENEW
     demDiskReset,      //SVC_DEMDISKRESET
     demNotYetImplemented,  //SVC_DEMSETDPB
     demGetDPB,         //SVC_DEMGETDPB
     demNotYetImplemented,  //SVC_DEMSLEAZEFUNC
     demCommit,         //SVC_DEMCOMMIT
     demNotYetImplemented,  //SVC_DEMEXTHANDLE
     demAbsRead,        //SVC_DEMABSDRD
     demAbsWrite,       //SVC_DEMABSDWRT
     demNotYetImplemented,  //SVC_DEMGSETCDPG
     demCreateFCB,      //SVC_DEMCREATEFCB
     demOpenFCB,        //SVC_DEMOPENFCB
     demCloseFCB,       //SVC_DEMCLOSEFCB
     demFCBIO,          //SVC_FCBIO
     demDate16,         //SVC_DEMDATE16
     demGetFileInfo,        //SVC_DEMGETFILEINFO
     demSetHardErrorInfo,   //SVC_DEMSETHARDERRORINFO
     demRetry,          //SVC_DEMRETRY
     demLoadDosAppSym,      //SVC_DEMLOADDOSAPPSYM
     demFreeDosAppSym,          //SVC_DEMFREEDOSAPPSYM
     demEntryDosApp,            //SVC_DEMENTRYDOSAPP
     demDOSDispCall,            //SVC_DEMDOSDISPCALL
     demDOSDispRet,             //SVC_DEMDOSDISPRET
     demOutputString,           //SVC_OUTPUT_STRING
     demInputString,        //SVC_INPUT_STRING
     demIsDebug,        //SVC_ISDEBUG
     demTerminatePDB,       //SVC_PDBTERMINATE
     demExitVDM,        //SVC_DEMEXITVDM
     demWOWFiles,       //SVC_DEMWOWFILES
     demLockOper,               //SVC_DEMLOCKOPER
     demNotYetImplemented,      //SVC_DEMDRIVEFROMHANDLE
     demGetComputerName,        //SVC_DEMGETCOMPUTERNAME
     demNotYetImplemented,      //SVC_DEMFASTREAD
     demNotYetImplemented,  //SVC_DEMFASTWRITE
     demCheckPath,      //SVC_DEMCHECKPATH
     demSystemSymbolOp,     //SVC_DEMSYSTEMSYMBOLOP
     demGetDPBList,     //SVC_DEMBUILDDPBLIST
     demPipeFileDataEOF,    //SVC_DEMPIPEFILEDATAEOF
     demPipeFileEOF,     //SVC_DEMPIPEFILEEOF
     demLFNEntry,               //SVC_DEMLFNENTRY
     demSetDosVarLocation       //SVC_SETDOSVARLOCATION
};


/* DemDispatch - Dispatch SVC call to right handler.
 *
 * Entry - iSvc (SVC byte following SVCop)
 *
 * Exit  - None
 *
 * Note  - Some mechanism has to be worked out to let the emulator know
 *     about DOSKRNL code segment and size. Using these it will figure
 *     out whether SVCop (hlt for the moment) has to be passed to
 *     DEM or to be handled as normal invalid opcode.
 */

BOOL DemDispatch (ULONG iSvc)
{

    DBGTRACE(VDMTR_TYPE_DEM + DEM_EVENT_DISPATCH, 0, iSvc);

    if (iSvc >= SVC_DEMLASTSVC){
#if DBG
        sprintf(demDebugBuffer,"Unimplemented SVC index %x\n",iSvc);
        OutputDebugStringOem(demDebugBuffer);
#endif
        setCF(1);
        return FALSE;
    }

    if (pHardErrPacket) {
        pHardErrPacket->vhe_fbInt24 = 0;
    }

    CurrentISVC = iSvc;
    (apfnSVC [iSvc])();

    DBGTRACE(VDMTR_TYPE_DEM + DEM_EVENT_DISPATCH_EXIT, 0, iSvc);

    return TRUE;
}

VOID demNotYetImplemented (VOID)
{
    if (fShowSVCMsg)  {
        sprintf(demDebugBuffer,"Unimplemented SVC %d\n",CurrentISVC);
        OutputDebugStringOem(demDebugBuffer);
        }

    setCF(0);
    return;
}

VOID demSetV86KernelAddr (VOID)
{
    // Here debugger callout has to be made for DOSKRNL symbols
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demdir.c ===
/* demdir.c - SVC handlers for directory calls
 *
 * DemCreateDir
 * DemDeleteDir
 * DemQueryCurrentDir
 * DemSetCurrentDir
 *
 * Modification History:
 *
 * Sudeepb 04-Apr-1991 Created
 */

#include "dem.h"
#include "demmsg.h"

#include <softpc.h>

/* demCreateDir - Create a directory
 *
 *
 * Entry - Client (DS:DX) directory name to create
 *         Client (BX:SI) EAs (NULL if no EAs)
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = system status code
 *
 *
 * Notes : Extended Attributes is not yet taken care of.
 */

VOID demCreateDir (VOID)
{
LPSTR   lpDir;
#ifdef DBCS /* demCreateDir() for CSNW */
CHAR    achPath[MAX_PATH];
#endif /* DBCS */

    // EAs not yet implemented
    if (getBX() || getSI()){
        demPrintMsg (MSG_EAS);
        return;
    }

    lpDir = (LPSTR) GetVDMAddr (getDS(),getDX());

#ifdef DBCS /* demCreateDir() for CSNW */
    /*
     * convert Netware path to Dos path
     */
    ConvNwPathToDosPath(achPath,lpDir, sizeof(achPath));
    lpDir = achPath;
#endif /* DBCS */

    if(CreateDirectoryOem (lpDir,NULL) == FALSE){
        demClientError(INVALID_HANDLE_VALUE, *lpDir);
        return;
    }

    setCF(0);
    return;
}


/* demDeleteDir - Create a directory
 *
 *
 * Entry - Client (DS:DX) directory name to create
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = system status code
 *
 */

VOID demDeleteDir (VOID)
{
LPSTR  lpDir;

    lpDir = (LPSTR) GetVDMAddr (getDS(),getDX());

    if (RemoveDirectoryOem(lpDir) == FALSE){
        demClientError(INVALID_HANDLE_VALUE, *lpDir);
        return;
    }

    setCF(0);
    return;
}



/* demQueryCurrentDir - Verifies current dir provided in CDS structure
 *                      for $CURRENT_DIR
 *
 * First Validates Media, if invalid -> i24 error
 * Next  Validates Path, if invalid set path to root (not an error)
 *
 * Entry - Client (DS:SI) Buffer to CDS path to verify
 *         Client (AL)    Physical Drive in question (A=0, B=1, ...)
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *
 *         FAILURE
 *           Client (CY) = 1 , I24 drive invalid
 */
VOID demQueryCurrentDir (VOID)
{
PCDS  pcds;
DWORD dw;
CHAR  chDrive;
CHAR  pPath[]="?:\\";
CHAR  EnvVar[] = "=?:";

    pcds = (PCDS)GetVDMAddr(getDS(),getSI());

          // validate media
    chDrive = getAL() + 'A';
    pPath[0] = chDrive;
    dw = GetFileAttributesOemSys(pPath, TRUE);
    if (dw == 0xFFFFFFFF || !(dw & FILE_ATTRIBUTE_DIRECTORY))
      {
        demClientError(INVALID_HANDLE_VALUE, chDrive);
        return;
        }

       // if invalid path, set path to the root
       // reset CDS, and win32 env for win32
    dw = GetFileAttributesOemSys(pcds->CurDir_Text, TRUE);
    if (dw == 0xFFFFFFFF || !(dw & FILE_ATTRIBUTE_DIRECTORY))
      {
        strcpy(pcds->CurDir_Text, pPath);
        pcds->CurDir_End = 2;
        EnvVar[1] = chDrive;
        SetEnvironmentVariableOem(EnvVar,pPath);
        }

    setCF(0);
    return;
}



/* demSetCurrentDir - Set the current directory
 *
 *
 * Entry - Client (DS:DX) directory name
 *         Client (ES:DI) CDS structure
 *         Dos default drive (AL) , CurDrv, where 1 == A.
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = system status code
 *
 */

VOID demSetCurrentDir (VOID)
{
DWORD  dw;
LPSTR  lpBuf;
CHAR   EnvVar[] = "=?:";
CHAR   ch;
PCDS   pCDS;
BOOL   bLongDirName;


    lpBuf = (LPSTR) GetVDMAddr (getDS(),getDX());
    ch = (CHAR) toupper(*(PCHAR)lpBuf);
    if (ch < 'A' || ch > 'Z'){
        setCF(1);
        return;
    }

    // got the darn cds ptr
    pCDS = (PCDS)GetVDMAddr(getES(), getDI());

    // now see if the directory name is too long
    bLongDirName = (strlen(lpBuf) > DIRSTRLEN);
            //
        // if the current dir is for the default drive
        // set the win32 process's current drive,dir. This
        // will open an NT dir handle, and verify that it
        // exists.
        //

    if (ch == getAL() + 'A') {
       if (SetCurrentDirectoryOem (lpBuf) == FALSE){
           demClientError(INVALID_HANDLE_VALUE, ch);
           return;
           }
       }

        //
        // if its not for the default drive, we still need
        // to verify that the dir\drive combinations exits.
        //

    else {
       dw = GetFileAttributesOemSys(lpBuf, TRUE);
       if (dw == 0xFFFFFFFF || !(dw & FILE_ATTRIBUTE_DIRECTORY))
         {
           demClientError(INVALID_HANDLE_VALUE, ch);
           return;
           }
       }


    EnvVar[1] = *(PCHAR)lpBuf;
    if(SetEnvironmentVariableOem ((LPSTR)EnvVar,lpBuf) == FALSE)
        setCF(1);
    else {
        // this is what '95 is doing for dos apps.
        // upon a getcurdir call -- it is going to be invalid

        strncpy(pCDS->CurDir_Text, lpBuf, DIRSTRLEN);
        pCDS->CurDir_Text[DIRSTRLEN-1] = 0;
        if (bLongDirName) {
           setCF(1);
        }
        else {
           setCF(0);
        }
    }

    return;
}
#ifdef DBCS /* ConvNwPathToDosPath() for CSNW */
//
// TO BT LATER and IT SHOULD BE...
//
//  This routine does change Novell-J-laized file name to
// our well-known filename, but this code is only for the
// request from Novell utilities. these code should be
// laied onto nw16.exe (nw\nw16\tsr\resident.asm).
//
VOID ConvNwPathToDosPath(CHAR *lpszDos,CHAR *lpszNw, ULONG uDosSize)
{
    /*
     * check parameter
     */
    if((lpszDos == NULL) || (lpszNw == NULL)) return;

    /*
     * copy data from vdm buffer to our local buffer
     */
    strncpy(lpszDos,lpszNw, uDosSize);
    lpszDos[uDosSize-1] = 0;

    /*
     * replace the specified character
     */
    while(*lpszDos) {

        if(IsDBCSLeadByte(*lpszDos)) {
            /*
             * This is a DBCS character, check trailbyte is 0x5C or not.
             */
            lpszDos++;

            if( *lpszDos == 0x13 ) {
                *lpszDos++ = (UCHAR)0x5C;
                continue;
            }
        }

        switch((UCHAR)*lpszDos) {
            case 0x10 :
                *lpszDos = (UCHAR)0xBF;
                break;
            case 0x11 :
                *lpszDos = (UCHAR)0xAE;
                break;
            case 0x12 :
                *lpszDos = (UCHAR)0xAA;
                break;
        }

        /*
         * next char
         */
        lpszDos++;
    }
}
#endif /* DBCS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demfcb.c ===
/* demfcb.c - SVC handlers for misc. FCB operations
 *
 * demCloseFCB
 * demCreateFCB
 * demDate16
 * demDeleteFCB
 * demFCBIO
 * demGetFileInfo
 * demOpenFCB
 * demRenameFCB
 *
 * Modification History:
 *
 * Sudeepb 09-Apr-1991 Created
 * Sudeepb 21-Nov-1991 Added FCB based IO functions
 * Jonle   30-Jun-1994 add wild card support for fcb rename
 */

#include "dem.h"
#include "demmsg.h"

#include <softpc.h>
#include <winbase.h>
#include <mvdm.h>
#include "dpmtbls.h"

#define DOT '.'
#define QMARK '?'


/* demDeleteFCB - FCB based File Delete
 *
 *
 * Entry - Client (ES:DI) - Full File Path
 *    Client (AL)   - 0 if not extended FCB
 *    Client (DL)   - File Attr. to be deleted (valid only if Al !=0 )
 *
 * Exit
 *    SUCCESS
 *      Client (CF) = 0
 *
 *    FAILURE
 *      Client (CF) = 1
 *      Client (AX) = system status code
 *     HARD ERROR
 *      Client (CF) = 1
 *      Client (AX) = 0ffffh
 *
 * Notes:  Following are the rules for FCB based delete:
 * 1. If normal FCB than dont allow delete on hidden,system files
 * 2. if extended FCB than search attributes should include hidden,
 *    system or read-only if that kind of file is to be deleted.
 */

VOID demDeleteFCB (VOID)
{
HANDLE   hFind;
LPSTR lpFileName;
BYTE  bClientAttr=0;
BOOL  fExtendedFCB=FALSE;
WIN32_FIND_DATA  wfBuffer;
BOOL  fSuccess = FALSE;
DWORD dwAttr;
USHORT   uErr;

CHAR szPath_buffer[_MAX_PATH];
CHAR szDrive[_MAX_DRIVE];
CHAR szDir[_MAX_DIR];
CHAR szFname[_MAX_FNAME];
CHAR szExt[_MAX_EXT];

DWORD dwErrCode = 0, dwErrCodeKeep = 0;

    // Get the file name
    lpFileName = (LPSTR) GetVDMAddr (getES(),getDI());

    _splitpath( lpFileName, szDrive, szDir, szFname, szExt );

    // Check if handling extended FCB
    if(getAL() != 0){
   bClientAttr = getDL();

    /* Special case for delete volume label (INT 21 Func 13H, Attr = 8H */

    if((bClientAttr == ATTR_VOLUME_ID)) {
   if((uErr = demDeleteLabel(lpFileName[DRIVEBYTE]))) {
       setCF(1);
       setAX(uErr);
       return;
   }
   setAX(0);
   setCF(0);
   return;
    }


   bClientAttr &= (ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM);
   fExtendedFCB = TRUE;
    }

    // Find the first instance of file
    if((hFind = FindFirstFileOem (lpFileName,&wfBuffer)) == (HANDLE)-1){
        demClientError(INVALID_HANDLE_VALUE, *lpFileName);
        return;
    }

    // loop for all files which match the name and attributes
    do {
   // Check if read_only,hidden or system file
   if((dwAttr= wfBuffer.dwFileAttributes & (FILE_ATTRIBUTE_READONLY |
            FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM))){

       // if so, try next file if normal FCB case. If extended fcb case
       // then check if right attributes are given by client.
       if(fExtendedFCB && ((dwAttr & (DWORD)bClientAttr) == dwAttr)){

      // Yes, right attributes are given. So if the file is read
      // only then change the modes to normal. Note NT will
      // delete hidden and system files anyway.
      if (dwAttr & FILE_ATTRIBUTE_READONLY){
          strcpy( szPath_buffer, szDrive);
          strcat( szPath_buffer, szDir);
          strncat( szPath_buffer, wfBuffer.cFileName,sizeof(szPath_buffer)-strlen(szPath_buffer));
          szPath_buffer[sizeof(szPath_buffer)-1] = 0;

          // if set attributes fail try next file
          if(SetFileAttributesOemSys (szPath_buffer,
                    FILE_ATTRIBUTE_NORMAL, FALSE) == -1)
         continue;
      }
       }
       else {
      dwErrCodeKeep = ERROR_ACCESS_DENIED;
      continue;
       }
   }

   strcpy( szPath_buffer, szDrive);
   strcat( szPath_buffer, szDir);
   strncat( szPath_buffer, wfBuffer.cFileName,sizeof(szPath_buffer)-strlen(szPath_buffer));
   szPath_buffer[sizeof(szPath_buffer)-1] = 0;

   if(DeleteFileOem(szPath_buffer) == FALSE) {
       dwErrCode = GetLastError();

       SetLastError(dwErrCode);

       if (((dwErrCode >= ERROR_WRITE_PROTECT) &&
         (dwErrCode <= ERROR_GEN_FAILURE)) ||
         dwErrCode == ERROR_WRONG_DISK ) {
      demClientError(INVALID_HANDLE_VALUE, szPath_buffer[0]);
      return;
       }
       continue;
   }

   // We have deleted at least one file, so report success
   fSuccess = TRUE;

    } while (FindNextFileOem(hFind,&wfBuffer) == TRUE);

    if(DPM_FindClose(hFind) == FALSE)
   demPrintMsg (MSG_INVALID_HFIND);

    if (fSuccess == TRUE){
   setCF(0);
   return;
    }

    setCF(1);

    if(dwErrCodeKeep)
   setAX((SHORT) dwErrCodeKeep);
    else
   setAX(ERROR_FILE_NOT_FOUND);
    return;
}


/* demRenameFCB - FCB based Rename file
 *
 * Entry - Client (DS:SI)    Sources file to be renamed
 *    Client (ES:DI)    Destination file to be renamed to
 *
 * Exit  - SUCCESS
 *    Client (CF) = 0
 *
 *    FAILURE
 *    Client(CF)  = 1
 *    Client(AX)  = error code
 */

VOID demRenameFCB (VOID)
{
    LPSTR  lpSrc,lpDst;
    DWORD  dw;
    HANDLE hFind;
    PCHAR pNewDstFilePart;
    PCHAR pDstFilePart;
    PCHAR pCurrSrcFilePart;
    WIN32_FIND_DATA  W32FindData;
    CHAR  NewDst[MAX_PATH];
    CHAR  CurrSrc[MAX_PATH];

    lpSrc = (LPSTR) GetVDMAddr (getDS(),getSI());
    lpDst = (LPSTR) GetVDMAddr (getES(),getDI());

      // Find the first instance of the source file
    hFind = FindFirstFileOem (lpSrc,&W32FindData);
    if (hFind == INVALID_HANDLE_VALUE) {
        dw = GetLastError();
        if (dw == ERROR_BAD_PATHNAME || dw == ERROR_DIRECTORY ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            }
        demClientError(INVALID_HANDLE_VALUE, *lpSrc);
        return;
        }

    //
    // Source string consists of the path taken from the original
    // source specified plus the filename part retrieved from the
    // FindFile call
    //
    strncpy(CurrSrc, lpSrc,sizeof(CurrSrc));
    CurrSrc[sizeof(CurrSrc)-1] = 0;
    pCurrSrcFilePart = strrchr(CurrSrc, '\\');
    pCurrSrcFilePart++;

    //
    // Destination string is template for meta character substitution
    //
    pDstFilePart = strrchr(lpDst, '\\');
    pDstFilePart++;

    //
    //  NewDst string is constructed from template and the source string
    //  when doing meta file character substitution.
    //
    strncpy(NewDst, lpDst, sizeof(NewDst));
    NewDst[sizeof(NewDst)-1] = 0;
    pNewDstFilePart = strrchr(NewDst, '\\');
    pNewDstFilePart++;


    do {
       PCHAR pNew;
       PCHAR pSrc;
       PCHAR pDst;

       strncpy(pCurrSrcFilePart,
              W32FindData.cAlternateFileName[0]
                  ? W32FindData.cAlternateFileName
                  : W32FindData.cFileName,  //// ??? hpfs lfns ????
              sizeof(CurrSrc)+CurrSrc-pCurrSrcFilePart);
              CurrSrc[sizeof(CurrSrc)-1] = 0;

       pSrc = pCurrSrcFilePart; // source fname
       pNew = pNewDstFilePart;  // dest fname to be constructed
       pDst = pDstFilePart;     // raw dest fname template (with metas)

       while (*pDst) {

              //
              // If Found a '?' in Dest template, use character from src
              //
          if (*pDst == QMARK) {
              if (*pSrc != DOT && *pSrc)
                  *pNew++ = *pSrc++;
              }

              //
              // if Found a DOT in Dest template, Align DOTS between Src\Dst
              //
          else if (*pDst == DOT) {
              while (*pSrc != DOT && *pSrc) {  // mov src to one past DOT
                  pSrc++;
                  }
              if (*pSrc)
                  pSrc++;

              *pNew++ = DOT;
              }

              //
              // Nothing special found, use character from Dest template
              //
          else {
              if (*pSrc != DOT && *pSrc)
                  pSrc++;
              *pNew++ = *pDst;
              }

          pDst++;
          }

       *pNew = '\0';

       //
       // MoveFile does not return error if dst and src are the same,
       // but DOS does, so check first..
       //
       if (!_stricmp (CurrSrc, NewDst)) {
           setCF(1);
           setAX(0x5);
           DPM_FindClose(hFind);
           return;
           }

       if (!MoveFileOem(CurrSrc, NewDst)){
           demClientError(INVALID_HANDLE_VALUE, *lpSrc);
           DPM_FindClose(hFind);
           return;
           }

       } while (FindNextFileOem(hFind,&W32FindData));



   //
   // If the search on the source string for any reason besides
   // no more files, then its a genuine error.
   //
   dw = GetLastError();
   if (dw != ERROR_NO_MORE_FILES) {
       if (dw == ERROR_BAD_PATHNAME || dw == ERROR_DIRECTORY ) {
           SetLastError(ERROR_PATH_NOT_FOUND);
           }
       demClientError(INVALID_HANDLE_VALUE, *lpSrc);
       }
   else {
       setCF(0);
       }

   DPM_FindClose(hFind);
   return;
}



/* demCloseFCB - Close the NT handle associated with the FCB being closed.
 *
 * Entry - Client (AX:SI)    DWORD NT handle
 *
 * Exit  - SUCCESS
 *    Client (CF) = 0
 *
 *    FAILURE
 *    Client(CF)  = 1
 *    Client(AX)  = error code
 */

VOID demCloseFCB (VOID)
{
HANDLE   hFile;

    hFile = GETHANDLE (getAX(),getSI());

    if(hFile == 0) {

   setCF(0);
   return;
    }

    if (DPM_CloseHandle (hFile) == FALSE){

   demClientError(hFile, (CHAR)-1);
   return;

    }
    setCF(0);
    return;
}

/* demCreateFCB - An FCB is being created get the NT handle.
 *
 * Entry - Client (AL)    Creation Mode
 *         00 - Normal File
 *         01 - Read-only file
 *         02 - Hidden File
 *         04 - System file
 *    Client (DS:SI) Full path filename
 *    Client (ES:DI) SFT address
 *
 * Exit  - SUCCESS
 *    Client (CF)   = 0
 *    Client (AX:BP) = NT Handle
 *    Client (BX)   = Time
 *    Client (CX)   = Date
 *    Client (DX:SI) = Size
 *
 *    FAILURE
 *    Client(CF)  = 1
 *    Client(AX)  = error code
 */

VOID demCreateFCB (VOID)
{
    demFCBCommon (CREATE_ALWAYS);
    return;
}

/* demDate16 - Get the current date/time in DOS FCB format.
 *
 * Entry - None
 *
 * Exit  - Always Success
 *    Client (AX) has date
 *    Client (DX) has time
 * NOTES:
 *
 * DemDate16 returns the current date in AX, current time in DX in this format
 *    AX - YYYYYYYMMMMDDDDD   years months days
 *    DX - HHHHHMMMMMMSSSSS   hours minutes seconds/2
 */

VOID demDate16 (VOID)
{
SYSTEMTIME TimeDate;

    GetLocalTime(&TimeDate);
    // date is stored in a packed word: ((year-1980)*512) + (month*32) + day
    setAX ( (USHORT) (((TimeDate.wYear-1980) << 9 ) |
       ((TimeDate.wMonth & 0xf) << 5 ) |
            (TimeDate.wDay & 0x1f))
     );
    setDX ( (USHORT) ((TimeDate.wHour << 11) |
       ((TimeDate.wMinute & 0x3f) << 5) |
            ((TimeDate.wSecond / 2) & 0x1f))
     );
    return;
}

/* demFCBIO - Carry out the FCB based IO operation.
 *
 * Entry - Client (BX) = 1 if read operation, 0 if write
 *    Client (AX:BP)  NT Handle
 *    Client (DI:DX)  offset to start the operation with
 *    Client (CX)    Count of bytes
 *
 * Exit  - SUCCESS
 *    Client (CF) = 0
 *    Client (CX) = counts of bytes read/written
 *    Client (AX:BX)  = size
 *
 *    FAILURE
 *    Client(CF)  = 1
 *    Client(AX)  = error code
 */

VOID demFCBIO (VOID)
{
HANDLE   hFile;
ULONG CurOffset;
PVOID   pBuf;
DWORD dwBytesIO=0;
DWORD dwSize,dwSizeHigh;
DWORD dwErrCode;

    hFile = GETHANDLE (getAX(),getBP());
    CurOffset = (((ULONG)getDI()) << 16) + (ULONG)getDX();

    if (DPM_SetFilePointer (hFile,
         (LONG)CurOffset,
         NULL,
         (DWORD)FILE_BEGIN) == -1L){
        demClientError(hFile, (CHAR)-1);
        return ;
    }

    pBuf = (PVOID)GetVDMAddr(*((PUSHORT)pulDTALocation + 1),
                              *((PUSHORT)pulDTALocation));

    if(getBX()) { // Read Operation
       if (DPM_ReadFile (hFile,
                      pBuf,
            (DWORD)getCX(),
            &dwBytesIO,
            NULL) == FALSE){

            Sim32FlushVDMPointer(*pulDTALocation, getCX(), pBuf, FALSE);
            Sim32FreeVDMPointer(*pulDTALocation, getCX(), pBuf, FALSE);
            demClientError(hFile, (CHAR)-1);
            return ;
       }
       Sim32FlushVDMPointer (*pulDTALocation, getCX(),pBuf, FALSE);
       Sim32FreeVDMPointer (*pulDTALocation, getCX(), pBuf, FALSE);
    }
    else {
        if (getCX() == 0) {
            //0 byte write, adjust file size
           if(!DPM_SetEndOfFile(hFile)) {
              dwErrCode = GetLastError();
              SetLastError(dwErrCode);
              demClientError(hFile,(CHAR)-1);
              return;
           }
        }
        else if (DPM_WriteFile (hFile,
                            pBuf,
                            (DWORD)getCX(),
                            &dwBytesIO,
                            NULL) == FALSE) {

                            // If disk is full then we should return number of bytes written
                            // AX = 1 and CF = 1

                            dwErrCode = GetLastError();
                            if(dwErrCode == ERROR_DISK_FULL) {

                               setCX( (USHORT) dwBytesIO);
                               setAX(1);
                               setCF(1);
                               return;
                            }

                            SetLastError(dwErrCode);

                            demClientError(hFile, (CHAR)-1);
                            return ;

        }
    }

    // Get File Size
    if((dwSize = DPM_GetFileSize(hFile,&dwSizeHigh)) == -1){

   demPrintMsg(MSG_FILEINFO);
        ASSERT(FALSE);
        demClientError(hFile, (CHAR)-1);
        return;
    }

    if(dwSizeHigh) {
   demPrintMsg(MSG_FILESIZE_TOOBIG);
        ASSERT(FALSE);
        demClientError(hFile, (CHAR)-1);
        return;
    }

    // Setup the exit registers
    setCX((USHORT)dwBytesIO);
    setBX((USHORT)dwSize);
    setAX((USHORT)(dwSize >> 16 ));
    setCF(0);
    return;
}

/* demGetFileInfo - Get Misc. file info in FCB format.
 *
 * Entry - Client (DS:SI)    full path file name
 *
 * Exit  - SUCCESS
 *    Client (CF) = 0
 *    Client (AX) = Attribute of file
 *    Client (CX) = Time stamp of file
 *    Client (DX  = Date stamp of file
 *    Client (BX:DI)= Size of file (32 bit)
 *
 *    FAILURE
 *    Client(CF)  = 1
 *    Client(AX)  = error code
 */

VOID demGetFileInfo (VOID)
{
HANDLE   hFile;
LPSTR lpFileName;
WORD  wDate,wTime;
DWORD dwSize,dwAttr;

    lpFileName = (LPSTR) GetVDMAddr (getDS(),getSI());

    if ((hFile = CreateFileOem(lpFileName,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL)) == (HANDLE)-1){
            demClientError(INVALID_HANDLE_VALUE, *lpFileName);
            return;
    }

    // Get Misc. INfo
    if (demGetMiscInfo (hFile,&wTime, &wDate, &dwSize) == FALSE) {
        DPM_CloseHandle (hFile);
        return;
    }

    DPM_CloseHandle (hFile);

    if ((dwAttr = GetFileAttributesOemSys (lpFileName, FALSE)) == -1) {
         demClientError(INVALID_HANDLE_VALUE, *lpFileName);
         return;
    }

    if (dwAttr == FILE_ATTRIBUTE_NORMAL)
   dwAttr = 0;

    setAX((USHORT)dwAttr);
    setCX(wTime);
    setDX(wDate);
    setDI((USHORT)dwSize);
    setBX((USHORT)(dwSize >> 16));
    return;
}


/* demOpenFCB - An FCB is being opened get the NT handle.
 *
 * Entry - Client (AL)    Open Mode
 *    Client (DS:SI) Full path filename
 *
 * Exit  - SUCCESS
 *    Client (CF)   = 0
 *    Client (AX:BP) = NT Handle
 *    Client (BX)   = Time
 *    Client (CX)   = Date
 *    Client (DX:SI) = Size
 *
 *    FAILURE
 *    Client(CF)  = 1
 *    Client(AX)  = error code
 */

VOID demOpenFCB (VOID)
{
    demFCBCommon (OPEN_EXISTING);
    return;
}

/* demFCBCommon - FCB Open/Create.
 *
 * Entry - CreateDirective - Open/Create
 *    Client (AL)   Open Mode
 *    Client (DS:SI) Full path filename
 *
 * Exit  - SUCCESS
 *    Client (CF)   = 0
 *    Client (AX:BP) = NT Handle
 *    Client (BX)   = Time
 *    Client (CX)   = Date
 *    Client (DX:SI) = Size
 *
 *    FAILURE
 *    Client(CF)  = 1
 *    Client(AX)  = error code
 */
VOID demFCBCommon (ULONG CreateDirective)
{
HANDLE   hFile;
LPSTR lpFileName;
UCHAR uchMode,uchAccess;
DWORD dwDesiredAccess = GENERIC_WRITE | GENERIC_READ;
DWORD dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
WORD  wDate,wTime;
DWORD dwSize,dwAttr=0;
USHORT   uErr;
SECURITY_ATTRIBUTES sa;

    lpFileName = (LPSTR) GetVDMAddr (getDS(),getSI());
    uchMode = getAL();

    /* Special case for delete volume label (INT 21 Func 13H, Attr = 8H */

    if((uchMode == ATTR_VOLUME_ID) && (CreateDirective == CREATE_ALWAYS)) {
   if((uErr = demCreateLabel(lpFileName[DRIVEBYTE],
             lpFileName+LABELOFF))) {
       setCF(1);
       setAX(uErr);
       return;
   }
   setAX(0);
   setBP(0);
   setCF(0);
   return;
    }


    // In create case AL has creation attributes. By default
    // Access is for read/write and sharing for both. In open
    // case AL has appropriate access and sharing information.
    if((CreateDirective == CREATE_ALWAYS) && ((uchMode &0xff) == 0)) {

   dwAttr = FILE_ATTRIBUTE_NORMAL;
   dwShareMode = FILE_SHARE_WRITE | FILE_SHARE_READ;
    }
    else {
   uchAccess = uchMode & (UCHAR)ACCESS_MASK;

   if (uchAccess == OPEN_FOR_READ)
       dwDesiredAccess = GENERIC_READ;

   else if (uchAccess == OPEN_FOR_WRITE)
       dwDesiredAccess = GENERIC_WRITE;

   uchMode = uchMode & (UCHAR)SHARING_MASK;

   switch (uchMode) {
       case SHARING_DENY_BOTH:
      dwShareMode = 0;
      break;
       case SHARING_DENY_WRITE:
      dwShareMode = FILE_SHARE_READ;
      break;
       case SHARING_DENY_READ:
      dwShareMode = FILE_SHARE_WRITE;
      break;
   }
    }
    sa.nLength = sizeof (SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    if ((hFile = CreateFileOem(lpFileName,
                dwDesiredAccess,
                dwShareMode | FILE_SHARE_DELETE,
                               &sa,
                               CreateDirective,
                               dwAttr,
                               NULL)) == (HANDLE)-1){
            demClientError(INVALID_HANDLE_VALUE, *lpFileName);
            return;
    }

    // Get Misc. INfo
    if (demGetMiscInfo (hFile,&wTime, &wDate, &dwSize) == FALSE)
        return;

    // Setup the exit registers
    setBX(wTime);
    setCX(wDate);
    setBP((USHORT)hFile);
    setAX((USHORT)((ULONG)hFile >> 16));
    setSI((USHORT)dwSize);
    setDX((USHORT)(dwSize >> 16));
    setCF(0);
    return;
}


BOOL demGetMiscInfo (hFile, lpTime, lpDate, lpSize)
HANDLE hFile;
LPWORD lpTime;
LPWORD lpDate;
LPDWORD lpSize;
{
FILETIME LastWriteTime,ftLocal;
DWORD  dwSizeHigh=0;

    if(GetFileTime (hFile,NULL,NULL,&LastWriteTime) == -1){
   demPrintMsg(MSG_FILEINFO);
        ASSERT(FALSE);
        demClientError(hFile, (CHAR)-1);
        DPM_CloseHandle (hFile);
        return FALSE;
    }

    FileTimeToLocalFileTime (&LastWriteTime,&ftLocal);

    if(FileTimeToDosDateTime(&ftLocal,
              lpDate,
              lpTime) == FALSE){
   demPrintMsg(MSG_FILEINFO);
        ASSERT(FALSE);
        demClientError(hFile, (CHAR)-1);
        return FALSE;
    }

    if((*lpSize = DPM_GetFileSize(hFile,&dwSizeHigh)) == -1){
   demPrintMsg(MSG_FILEINFO);
        ASSERT(FALSE);
        demClientError(hFile, (CHAR)-1);
        return FALSE;
    }

    if(dwSizeHigh) {
   demPrintMsg(MSG_FILESIZE_TOOBIG);
        ASSERT(FALSE);
        demClientError(hFile, (CHAR)-1);
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demerror.c ===
/*  demerror.c - Error handling routines of DEM
 *
 *  demSetHardErrorInfo
 *  demClientError
 *  demRetry
 *
 *  Modification History:
 *
 *  Sudeepb 27-Nov-1991 Created
 */

#include "dem.h"
#include "demmsg.h"

#include <softpc.h>

PVHE    pHardErrPacket;
PSYSDEV pDeviceChain;
SAVEDEMWORLD RetryInfo;

CHAR GetDriveLetterByHandle(HANDLE hFile);
VOID SubstituteDeviceName( PUNICODE_STRING InputDeviceName,
                           LPSTR OutputDriveLetter);

/* demSetHardErrorInfo - Store away harderr related address of DOSKRNL
 *
 * Entry
 *      Client (DS:DX) - VHE structure
 *      Client (DS:BX) - nuldev, first device in BIOS chain
 *
 * Exit
 *      None
 */

VOID demSetHardErrorInfo (VOID)
{
    pHardErrPacket = (PVHE) GetVDMAddr (getDS(),getDX());
    pDeviceChain = (PSYSDEV) GetVDMAddr(getDS(),getBX());
    return;
}

/* demRetry - Retry the operation which last resulted in hard error
 *
 * Entry
 *      None
 *
 * Exit
 *      None
 */

VOID demRetry (VOID)
{
ULONG iSvc;

    demRestoreHardErrInfo ();
    iSvc = CurrentISVC;

#if DBG
    if(iSvc < SVC_DEMLASTSVC && (fShowSVCMsg & DEMSVCTRACE) &&
         apfnSVC[iSvc] != demNotYetImplemented){
        sprintf(demDebugBuffer,"demRetry:Retrying %s\n\tAX=%.4x BX=%.4x CX=%.4x DX=%.4x DI=%.4x SI=%.4x\n",
               aSVCNames[iSvc],getAX(),getBX(),getCX(),getDX(),getDI(),getSI());
        OutputDebugStringOem(demDebugBuffer);
        sprintf(demDebugBuffer,"\tCS=%.4x IP=%.4x DS=%.4x ES=%.4x SS=%.4x SP=%.4x BP=%.4x\n",
                getCS(),getIP(), getDS(),getES(),getSS(),getSP(),getBP());
        OutputDebugStringOem(demDebugBuffer);
    }

    if (iSvc >= SVC_DEMLASTSVC || apfnSVC[iSvc] == demNotYetImplemented ){
        ASSERT(FALSE);
        setCF(1);
        setAX(0xff);
        return;
    }
#endif // DBG

    (apfnSVC [iSvc])();

#if DBG
    if((fShowSVCMsg & DEMSVCTRACE)){
        sprintf(demDebugBuffer,"demRetry:After %s\n\tAX=%.4x BX=%.4x CX=%.4x DX=%.4x DI=%.4x SI=%.4x\n",
               aSVCNames[iSvc],getAX(),getBX(),getCX(),getDX(),getDI(),getSI());
        OutputDebugStringOem(demDebugBuffer);
        sprintf(demDebugBuffer,"\tCS=%.4x IP=%.4x DS=%.4x ES=%.4x SS=%.4x SP=%.4x BP=%.4x CF=%x\n",
               getCS(),getIP(), getDS(),getES(),getSS(),getSP(),getBP(),getCF());
        OutputDebugStringOem(demDebugBuffer);
    }
#endif
    return;
}

/* demClientError - Update client registers to signal error
 *
 * Entry
 *       HANDLE hFile; file handle  , if none == -1
 *       char chDrive; drive letter , if none == -1
 *
 * Exit
 *      Client (CF) = 1
 *      Client (AX) = Error Code
 *
 * Notes
 *      the following errors cause hard errors
 *      errors above ERROR_GEN_FAILURE are mapped to general fail by the DOS
 *
 *
 *      ERROR_WRITE_PROTECT              19L
 *      ERROR_BAD_UNIT                   20L
 *      ERROR_NOT_READY                  21L
 *      ERROR_BAD_COMMAND                22L
 *      ERROR_CRC                        23L
 *      ERROR_BAD_LENGTH                 24L
 *      ERROR_SEEK                       25L
 *      ERROR_NOT_DOS_DISK               26L
 *      ERROR_SECTOR_NOT_FOUND           27L
 *      ERROR_OUT_OF_PAPER               28L
 *      ERROR_WRITE_FAULT                29L
 *      ERROR_READ_FAULT                 30L
 *      ERROR_GEN_FAILURE                31L
 *      ERROR_WRONG_DISK                 34l
 *      ERROR_NO_MEDIA_IN_DRIVE        1112l
 *      #ifdef JAPAN
 *      ERROR_UNRECOGNIZED_MEDIA       1785L
 *      #ifdef JAPAN
 *
 */

VOID demClientError (HANDLE hFile, CHAR chDrive)
{
    demClientErrorEx (hFile, chDrive, TRUE);
}

ULONG demClientErrorEx (HANDLE hFile, CHAR chDrive, BOOL bSetRegs)
{
ULONG ulErrCode;

    if(!(ulErrCode = GetLastError()))
        ulErrCode = ERROR_ACCESS_DENIED;

#ifdef JAPAN
    if ((ulErrCode < ERROR_WRITE_PROTECT || ulErrCode > ERROR_GEN_FAILURE)
        && ulErrCode != ERROR_WRONG_DISK && ulErrCode != ERROR_UNRECOGNIZED_MEDIA)
#else // !JAPAN
    if ((ulErrCode < ERROR_WRITE_PROTECT || ulErrCode > ERROR_GEN_FAILURE)
        && ulErrCode != ERROR_WRONG_DISK )
#endif // !JAPAN
       {
#if DBG
       if (fShowSVCMsg & DEMERROR) {
           sprintf(demDebugBuffer,"demClientErr: ErrCode=%ld\n", ulErrCode);
           OutputDebugStringOem(demDebugBuffer);
           }
#endif
        if (bSetRegs) {
            setAX((USHORT)ulErrCode);
            }
        }
    else {   // handle hard error case
        if (ulErrCode > ERROR_GEN_FAILURE)
            ulErrCode = ERROR_GEN_FAILURE;

        // Set the hard error flag
        pHardErrPacket->vhe_fbInt24 = 1;

        // Get the drive letter
        if (hFile != INVALID_HANDLE_VALUE)
            chDrive = GetDriveLetterByHandle(hFile);

        pHardErrPacket->vhe_bDriveNum = chDrive == -1
                                        ? -1 : toupper(chDrive) - 'A';

        // convert error code to i24 based error.
        ulErrCode -= ERROR_WRITE_PROTECT;
        pHardErrPacket->vhe_HrdErrCode =  (UCHAR)ulErrCode;

#if DBG
        if (fShowSVCMsg & DEMERROR) {
            sprintf(demDebugBuffer,
                    "demClientErr HRDERR: DriveNum=%ld ErrCode=%ld\n",
                    (DWORD)pHardErrPacket->vhe_bDriveNum,
                    (DWORD)pHardErrPacket->vhe_HrdErrCode);
            OutputDebugStringOem(demDebugBuffer);
            }
#endif
        // Save Away Information for possible retry operation
        demSaveHardErrInfo ();


        }

    if (bSetRegs)
        setCF(1);
    return (ulErrCode);
}



/*
 *  GetDriveLetterByHandle
 *
 *  retrieves the drive letter for the file handle
 *  if its a remote drive or fails returns -1
 */
CHAR GetDriveLetterByHandle(HANDLE hFile)
{
     NTSTATUS Status;
     ULONG    ul;
     ANSI_STRING  AnsiString;
     FILE_FS_DEVICE_INFORMATION DeviceInfo;
     IO_STATUS_BLOCK IoStatusBlock;
     POBJECT_NAME_INFORMATION pObNameInfo;
     CHAR    Buffer[MAX_PATH+sizeof(OBJECT_NAME_INFORMATION)];
     CHAR    ch;

       // if a remote drive return -1 for drive letter
     Status = NtQueryVolumeInformationFile(
                hFile,
                &IoStatusBlock,
                &DeviceInfo,
                sizeof(DeviceInfo),
                FileFsDeviceInformation );

     if (NT_SUCCESS(Status) &&
         DeviceInfo.Characteristics & FILE_REMOTE_DEVICE )
         return (CHAR) -1;

       // get the name
     pObNameInfo = (POBJECT_NAME_INFORMATION)Buffer;
     Status = NtQueryObject(              // get len of name
                hFile,
                ObjectNameInformation,
                pObNameInfo,
                sizeof(Buffer),
                &ul);

     if (!NT_SUCCESS(Status))
          return -1;

     RtlUnicodeStringToAnsiString(&AnsiString, &(pObNameInfo->Name), TRUE);
     if (strstr(AnsiString.Buffer,"\\Device") == AnsiString.Buffer)
         SubstituteDeviceName(&(pObNameInfo->Name), AnsiString.Buffer);

     ch = AnsiString.Buffer[0];
     RtlFreeAnsiString(&AnsiString);
     return ch;
}

static WCHAR wszDosDevices[] = L"\\DosDevices\\?:";

/*
 *  SubstituteDeviceName
 *
 *  lifted this code from the user\harderror hard error thread
 */
VOID SubstituteDeviceName( PUNICODE_STRING InputDeviceName,
                           LPSTR OutputDriveLetter )
{
    UNICODE_STRING LinkName;
    UNICODE_STRING DeviceName;
    OBJECT_ATTRIBUTES Obja;
    HANDLE LinkHandle;
    NTSTATUS Status;
    ULONG i;
    PWCHAR p;
    PWCHAR pSlash = L"\\";
    WCHAR DeviceNameBuffer[MAXIMUM_FILENAME_LENGTH];

       /*
        *  Ensure have trailing backslash
        */

    if (InputDeviceName->Buffer[(InputDeviceName->Length >>1) - 1] != *pSlash)
        RtlAppendUnicodeToString(InputDeviceName, pSlash);

    RtlInitUnicodeString(&LinkName,wszDosDevices);
    p = (PWCHAR)LinkName.Buffer;
    p = p+12;
    for(i=0;i<26;i++){
        *p = (WCHAR)'A' + (WCHAR)i;

        InitializeObjectAttributes(
            &Obja,
            &LinkName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );
        Status = NtOpenSymbolicLinkObject(
                    &LinkHandle,
                    SYMBOLIC_LINK_QUERY,
                    &Obja
                    );
        if (NT_SUCCESS( Status )) {

            //
            // Open succeeded, Now get the link value
            //
            DeviceName.Length = 0;
            DeviceName.MaximumLength = sizeof(DeviceNameBuffer);
            DeviceName.Buffer = DeviceNameBuffer;

            Status = NtQuerySymbolicLinkObject(
                        LinkHandle,
                        &DeviceName,
                        NULL
                        );
            NtClose(LinkHandle);
            if ( NT_SUCCESS(Status) ) {

                if (DeviceName.Buffer[(DeviceName.Length >>1) - 1] != *pSlash)
                    RtlAppendUnicodeToString(&DeviceName, pSlash);

#ifdef JAPAN
                // #6197 compare only device name
                if (InputDeviceName->Length > DeviceName.Length)
                    InputDeviceName->Length = DeviceName.Length;

#endif // JAPAN
                if ( RtlEqualUnicodeString(InputDeviceName,&DeviceName,TRUE) )
                   {
                    OutputDriveLetter[0]='A'+(WCHAR)i;
                    OutputDriveLetter[1]='\0';
                    return;
                    }
                }
            }
        }

     // just in case we don't find it
    OutputDriveLetter[0]=(char)-1;
    OutputDriveLetter[1]='\0';
    return;


}





/* demSaveHardErrInfo
 * demRestoreHardErrInfo
 *
 * These two routines are used to preserve all the DOSKRNL registers
 * which will be needed to retry an SVC handler, in case user opts for
 * retry in harderr popup. This is a preferred way to handle retry
 * as it gives the DOSKRNL code the freedom to trash any register
 * even though it might have to retry the operation. It saves lots
 * of code bytes in heavily used DOS macro "HrdSVC".
 *
 * Entry
 *      None
 *
 * Exit
 *      None
 *
 * Notes
 *
 *  1. Doing things this way means, DOSKRNL cannot change the
 *     registers for retry. Under any circumstances, i can't think
 *     why it would need to do that anyway.
 *
 *  2. This mechanism also assumes that DOSKRNL never uses CS,IP,SS,SP
 *     for passing SVC parameters.
 *
 *  3. DOS does'nt allow int24 hookers to make any call which comes
 *     to DEM, so using CurrentISVC is safe.
 *
 *  4. If an SVC handler can pssibly return a hard error it should never
 *     modify the client registers.
 */


VOID demSaveHardErrInfo (VOID)
{
    RetryInfo.ax    =   getAX();
    RetryInfo.bx    =   getBX();
    RetryInfo.cx    =   getCX();
    RetryInfo.dx    =   getDX();
    RetryInfo.ds    =   getDS();
    RetryInfo.es    =   getES();
    RetryInfo.si    =   getSI();
    RetryInfo.di    =   getDI();
    RetryInfo.bp    =   getBP();
    RetryInfo.iSVC  =   CurrentISVC;
    return;
}


VOID demRestoreHardErrInfo (VOID)
{
    setAX(RetryInfo.ax);
    setBX(RetryInfo.bx);
    setCX(RetryInfo.cx);
    setDX(RetryInfo.dx);
    setDS(RetryInfo.ds);
    setES(RetryInfo.es);
    setSI(RetryInfo.si);
    setDI(RetryInfo.di);
    setBP(RetryInfo.bp);
    CurrentISVC =   RetryInfo.iSVC;
    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demgset.c ===
/* demgset.c - Drive related SVC hanlers.
 *
 * demSetDefaultDrive
 * demGetBootDrive
 * demGetDriveFreeSpace
 * demGetDrives
 * demGSetMediaID
 * demQueryDate
 * demQueryTime
 * demSetDate
 * demSetTime
 * demSetDTALocation
 * demGSetMediaID
 * demGetDPB

 * Modification History:
 *
 * Sudeepb 02-Apr-1991 Created
 *
 */
#include "dem.h"
#include "demmsg.h"

#include <softpc.h>
#include <mvdm.h>
#include <winbase.h>
#include "demdasd.h"
#include "dpmtbls.h"

#define BOOTDRIVE_PATH "Software\\Microsoft\\Windows\\CurrentVersion\\Setup"
#define BOOTDRIVE_VALUE "BootDir"


#define     SUCCESS 0
#define     NODISK  1
#define     FAILURE 2
BYTE demGetDpbI(BYTE Drive, DPB UNALIGNED *pDpb);


UCHAR PhysicalDriveTypes[26]={0};

extern PDOSSF pSFTHead;

USHORT  nDrives = 0;
CHAR    IsAPresent = TRUE;
CHAR    IsBPresent = TRUE;


/* demSetDefaultDrive - Set the default drive
 *
 *
 * Entry -
 *     Client (DS:SI) Current Directory on that drive
 *     Client (dl) Zero based DriveNum
 *
 * Exit  - SUCCESS
 *      Client (CY) = 0
 *      Current Drive Set
 *
 *     FAILURE
 *      Client (CY) = 1
 *      Current Drive Not Set
 *
 * Notes:
 *  The DOS keeps a current directory for each of the drives,
 *  However winnt keeps only one current Drive, Directory per
 *  process, and it is cmd.exe which associates a current
 *  directory for each of the drive.




 */

VOID demSetDefaultDrive (VOID)
{
LPSTR   lpPath;

    lpPath = (LPSTR)GetVDMAddr (getDS(),getSI());


// only in sp4
#ifdef NOVELL_NETWARE_SETERRORMODE

    //
    // For removable drives check for media\volume info to avoid triggering
    // hard errors when no media is present. There exists win32 code
    // (e.g novell netware redir vdd) which is known to clobber our error
    // mode setting.
    //
    // 16-Jul-1997 Jonle
    //

    {

    UCHAR DriveType;
    CHAR DriveNum;

    DriveNum = (CHAR)getDL();

    DriveType = demGetPhysicalDriveType(DriveNum);
    if (DriveType == DRIVE_REMOVABLE || DriveType == DRIVE_CDROM) {
        VOLINFO VolInfo;

          //
          // if No Media in drive, the drive is still valid,
          // but the win32 curdir is still the old one.
          //

        if (!GetMediaId(DriveNum, &VolInfo)) {
            if (GetLastError() == ERROR_INVALID_DRIVE) {
                setCF(1);
                }
            else {
                setCF(0);
                }
            return;
            }
        }
    }
#endif


    if (!SetCurrentDirectoryOem(lpPath) && GetLastError() == ERROR_INVALID_DRIVE) {

        //
        // Only return error if drive was invalid, the DOS doesn't check
        // for curdir when changing drives. Note that a number of old dos
        // apps will walk all of the drives, and do setdefaultdrive,
        // to determine the valid drives letters. The SetCurrentDirectoryOem
        // causes ntio to touch the drive and verify that the dir exists.
        // This is a significant performance problem for removable media
        // and network drives, but we have no choice since locking the
        // current dir for this drive is mandatory for winnt.
        //

        setCF(1);
        }
    else {
        setCF(0);
        }

    return;
}


/* demGetBootDrive - Get the boot drive
 *
 *
 * Entry - None
 *
 * Exit  - CLIENT (AL) has 1 base boot drive (i.e. C=3)
 *
 * We try to read the registry value that indicates the real boot drive. This
 * should be the location of autoexec.bat, etc. If we can't find the key,
 * or if the value indicates some drive letter that is not a fixed drive,
 * then we use a fallback plan of just saying drive C.
 *
 */

VOID demGetBootDrive (VOID)
{
    HKEY hKey;
    DWORD retCode;
    DWORD dwType, cbData = MAX_PATH;
    CHAR szBootDir[MAX_PATH];
    BYTE Drive = 3;     // default it to 'C:'

    retCode = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            BOOTDRIVE_PATH,
                            0,
                            KEY_EXECUTE, // Requesting read access.
                            &hKey);


    if (retCode) {
        // error: can't find section
        goto DefaultBootDrive;
    }

    retCode = RegQueryValueEx(hKey,
                              BOOTDRIVE_VALUE,
                              NULL,
                              &dwType,
                              szBootDir,
                              &cbData);

    RegCloseKey(hKey);

    if (retCode) {
        // error: can't find key
        goto DefaultBootDrive;
    }

    if (DPM_GetDriveType(szBootDir) != DRIVE_FIXED) {
        // error: drive is not a valid boot drive
        goto DefaultBootDrive;
    }

    Drive = (BYTE)(tolower(szBootDir[0])-'a')+1;

DefaultBootDrive:

    setAL(Drive);
    return;

}

/* demGetDriveFreeSpace - Get free Space on the drive
 *
 *
 * Entry - Client (AL)  Drive in question
 *          0 - A: etc.
 *
 * Exit  -
 *     SUCCESS
 *      Client (CY) = 0
 *      Client (AL) = FAT ID byte
 *      Client (BX) = Number of free allocation units
 *      Client (CX) = Sector size
 *      Client (DX) = Total Number of allocation units on disk
 *      Client (SI) = Sectors per allocation unit
 *
 *     FAILURE
 *      Client (CY) = 1
 *      Client (AX) = Error code
 */


VOID demGetDriveFreeSpace (VOID)
{
WORD   SectorsPerCluster;
WORD   BytesPerSector;
WORD   FreeClusters;
WORD   TotalClusters;

BYTE	Drive;
PBDS	pbds;


    Drive = getAL();
    if (demGetDiskFreeSpace(Drive,
			    &BytesPerSector,
			    &SectorsPerCluster,
			    &TotalClusters,
			    &FreeClusters) == FALSE)
       {
	demClientError(INVALID_HANDLE_VALUE, (CHAR)(getAL() + 'A'));
        return;
        }

    if (pbds = demGetBDS(Drive)) {
	    // if the device is a floppy, reload its bpb
	    if (!(pbds->Flags & NON_REMOVABLE) && !demGetBPB(pbds))
		pbds->bpb.MediaID = 0xF8;

	    setAL(pbds->bpb.MediaID);
    }
    else
	setAL(0);

    setBX(FreeClusters);
    setCX(BytesPerSector);
    setDX(TotalClusters);
    setSI(SectorsPerCluster);
    setCF(0);
    return;
}


//
//  retrieves drive type for physical drives
//  substd, redir drives are returned as unknown
//  uses same DriveType definitions as win32 GetDriveTypeW
//
UCHAR
demGetPhysicalDriveType(
      UCHAR DriveNum)
{
    return DriveNum < 26 ? PhysicalDriveTypes[DriveNum] : DRIVE_UNKNOWN;
}




//
// worker function for DemGetDrives
//
UCHAR
DosDeviceDriveTypeToPhysicalDriveType(
      UCHAR DeviceDriveType
      )
{
   switch (DeviceDriveType) {
        case DOSDEVICE_DRIVE_REMOVABLE:
            return DRIVE_REMOVABLE;

        case DOSDEVICE_DRIVE_FIXED:
            return DRIVE_FIXED;

        case DOSDEVICE_DRIVE_CDROM:
            return DRIVE_CDROM;

        case DOSDEVICE_DRIVE_RAMDISK:
            return DRIVE_RAMDISK;

        }

   //case DOSDEVICE_DRIVE_REMOTE:
   //case DOSDEVICE_DRIVE_UNKNOWN:
   //default:


   return DRIVE_UNKNOWN;
}





/* demGetDrives - Get number of logical drives in the system
 *                called by ntdos from msinit to get numio
 *                initializes the physical drive list, which consists
 *                of drive types for true physical drives. subst
 *                and redir drives are classed as DRIVE_UNKNOWN.
 *
 * Entry - None
 *
 * Exit  -
 *     SUCCESS
 *      Client (CY) = 0
 *      Client (AL) = number of drives
 *
 *     FAILURE
 *      None
 */

VOID demGetDrives (VOID)
{
    NTSTATUS Status;
    UCHAR    DriveNum;
    UCHAR    DriveType;
    BOOL     bCounting;

    PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo;

    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessDeviceMap,
                                        &ProcessDeviceMapInfo.Query,
                                        sizeof(ProcessDeviceMapInfo.Query),
                                        NULL
                                      );
    if (!NT_SUCCESS(Status)) {
        RtlZeroMemory( &ProcessDeviceMapInfo, sizeof(ProcessDeviceMapInfo));
        }

    //
    // A and B are special cases.
    // if A doesn't exist means b also doesn't exist
    //

    PhysicalDriveTypes[0] = DosDeviceDriveTypeToPhysicalDriveType(
                                        ProcessDeviceMapInfo.Query.DriveType[0]
                                        );

    if (PhysicalDriveTypes[0] == DRIVE_UNKNOWN) {
        IsAPresent = FALSE;
        IsBPresent = FALSE;
        }


    PhysicalDriveTypes[1] = DosDeviceDriveTypeToPhysicalDriveType(
                                  ProcessDeviceMapInfo.Query.DriveType[1]
                                  );

    if (PhysicalDriveTypes[1] == DRIVE_UNKNOWN) {
        IsBPresent = FALSE;
        }

    DriveNum = 2;
    nDrives = 2;
    bCounting = TRUE;

    do {

        PhysicalDriveTypes[DriveNum] = DosDeviceDriveTypeToPhysicalDriveType(
                                            ProcessDeviceMapInfo.Query.DriveType[DriveNum]
                                            );

        if (bCounting) {
            if (PhysicalDriveTypes[DriveNum] == DRIVE_REMOVABLE ||
                PhysicalDriveTypes[DriveNum] == DRIVE_FIXED ||
                PhysicalDriveTypes[DriveNum] == DRIVE_CDROM ||
                PhysicalDriveTypes[DriveNum] == DRIVE_RAMDISK )
              {
                nDrives++;
                }
            else {
                bCounting = FALSE;
                }
            }

        } while (++DriveNum < 26);


    setAX(nDrives);
    setCF(0);
    return;

}


/* demQueryDate - Get The Date
 *
 *
 * Entry - None
 *
 * Exit  -
 *     SUCCESS
 *      Client (DH) - month
 *      Client (DL) - Day
 *      Client (CX) - Year
 *      Client (AL) - WeekDay
 *
 *     FAILURE
 *      Never
 */

VOID demQueryDate (VOID)
{
SYSTEMTIME TimeDate;

    GetLocalTime(&TimeDate);
    setDH((UCHAR)TimeDate.wMonth);
    setDL((UCHAR)TimeDate.wDay);
    setCX(TimeDate.wYear);
    setAL((UCHAR)TimeDate.wDayOfWeek);
    return;
}


/* demQueryTime - Get The Time
 *
 *
 * Entry - None
 *
 * Exit  -
 *     SUCCESS
 *      Client (CH) - hour
 *      Client (CL) - minutes
 *      Client (DH) - seconds
 *      Client (DL) - hundredth of seconds
 *
 *     FAILURE
 *      Never
 */

VOID demQueryTime (VOID)
{
SYSTEMTIME TimeDate;

    GetLocalTime(&TimeDate);
    setCH((UCHAR)TimeDate.wHour);
    setCL((UCHAR)TimeDate.wMinute);
    setDH((UCHAR)TimeDate.wSecond);
    setDL((UCHAR)(TimeDate.wMilliseconds/10));
    return;
}


/* demSetDate - Set The Date
 *
 *
 * Entry -  Client (CX) - Year
 *      Client (DH) - month
 *      Client (DL) - Day
 *
 * Exit  - SUCCESS
 *      Client (AL) - 00
 *
 *
 *     FAILURE
 *      Client (AL) - ff
 */

VOID demSetDate (VOID)
{
SYSTEMTIME TimeDate;

    GetLocalTime(&TimeDate);
    TimeDate.wYear  = (WORD)getCX();
    TimeDate.wMonth = (WORD)getDH();
    TimeDate.wDay   = (WORD)getDL();
    if(SetLocalTime(&TimeDate) || GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
        setAL(0);
    else
        setAL(0xff);
}


/* demSetTime - Set The Time
 *
 *
 * Entry -  Client (CH) - hour
 *      Client (CL) - minutes
 *      Client (DH) - seconds
 *      Client (DL) - hundredth of seconds
 *
 * Exit  -  None
 *
 */

VOID demSetTime (VOID)
{
SYSTEMTIME TimeDate;

    GetLocalTime(&TimeDate);
    TimeDate.wHour     = (WORD)getCH();
    TimeDate.wMinute       = (WORD)getCL();
    TimeDate.wSecond       = (WORD)getDH();
    TimeDate.wMilliseconds = (WORD)getDL()*10;
    if (SetLocalTime(&TimeDate) || GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
	setAL(0);
    else
	setAL(0xff);
}


/* demSetDTALocation - Set The address of variable where Disk Transfer Address
 *             is stored in NTDOS.
 *
 *
 * Entry -  Client (DS:AX) - DTA variable Address
 *      Client (DS:DX) - CurrentPDB address
 *
 * Exit  -  None
 *
 */

VOID demSetDTALocation (VOID)
{
    PDOSWOWDATA pDosWowData;

    pulDTALocation = (PULONG)  GetVDMAddr(getDS(),getAX());
    pusCurrentPDB  = (PUSHORT) GetVDMAddr(getDS(),getDX());
    pExtendedError = (PDEMEXTERR) GetVDMAddr(getDS(),getCX());

    pDosWowData = (PDOSWOWDATA) GetVDMAddr(getDS(),getSI());
    pSFTHead    = (PDOSSF) GetVDMAddr(getDS(),(WORD)pDosWowData->lpSftAddr);
    return;
}


/* demGSetMediaID - Get or set volume serial and volume label
 *
 * Entry - Client (BL)     - Drive Number (0=A;1=B..etc)
 *     Client (AL)     - Get or Set (0=Get;1=Set)
 *     Client (DS:DX)  - Buffer to return information
 *               (see VOLINFO in dosdef.h)
 *
 * Exit  - SUCCESS
 *     Client (CF)     - 0
 *
 *     FAILURE
 *     Client (CF)     - 1
 *     Client (AX)     - Error code
 *
 * NOTES:
 *     Currently There is no way for us to set Volume info.
 */

VOID demGSetMediaID (VOID)
{
CHAR    Drive;
PVOLINFO pVolInfo;

    // Set Volume info is not currently supported
    if(getAL() != 0){
       setCF(1);
       return;
    }

    pVolInfo = (PVOLINFO) GetVDMAddr (getDS(),getDX());
    Drive = (CHAR)getBL();

    if (!GetMediaId(Drive, pVolInfo)) {
        demClientError(INVALID_HANDLE_VALUE, (CHAR)(Drive + 'A'));
        return;
        }

    setCF(0);
    return;
}

//
// GetMediaId
//
//
BOOL
GetMediaId(
    CHAR DriveNum,
    PVOLINFO pVolInfo
    )
{
CHAR    RootPathName[] = "?:\\";
CHAR    achVolumeName[NT_VOLUME_NAME_SIZE];
CHAR    achFileSystemType[MAX_PATH];
DWORD   adwVolumeSerial[2],i;



    // Form Root path
    RootPathName[0] = DriveNum + 'A';

    // Call the supreme source of information
    if(!GetVolumeInformationOem( RootPathName,
                                 achVolumeName,
                                 NT_VOLUME_NAME_SIZE,
                                 adwVolumeSerial,
                                 NULL,
                                 NULL,
                                 achFileSystemType,
                                 MAX_PATH) )
     {
       return FALSE;
    }

    // Fill in user buffer. Remember to convert the null characters
    // to spaces in different strings.

    STOREDWORD(pVolInfo->ulSerialNumber,adwVolumeSerial[0]);

    strncpy(pVolInfo->VolumeID,achVolumeName,DOS_VOLUME_NAME_SIZE);

    for(i=0;i<DOS_VOLUME_NAME_SIZE;i++)  {
        if (pVolInfo->VolumeID[i] == '\0')
            pVolInfo->VolumeID[i] = '\x020';
        }

    strncpy(pVolInfo->FileSystemType,achFileSystemType,FILESYS_NAME_SIZE);

    for(i=0;i<FILESYS_NAME_SIZE;i++) {
        if (pVolInfo->FileSystemType[i] == '\0')
            pVolInfo->VolumeID[i] = '\x020';
        }


    return TRUE;
}











/* demGetDPB - Get Devicr Parameter Block
 *
 * Entry - Client (AL)	   - Drive Number (0=A;1=B..etc)
 *     Client (DS:DI)	- Buffer to return information
 *
 * Exit  - SUCCESS
 *     Client (CF)     - 0
 *
 *     FAILURE
 *     Client (CF)     - 1
 *     Client (AX)     - Error code
 *
 */
VOID demGetDPB(VOID)
{
BYTE	Drive;
DPB UNALIGNED *pDPB;
BYTE    Result;

    Drive = getAL();
    pDPB = (PDPB) GetVDMAddr(getDS(), getDI());

    Result = demGetDpbI(Drive, pDPB);
    if (Result == FAILURE) {
	demClientError(INVALID_HANDLE_VALUE,(CHAR)(Drive + 'A'));
	return;
    }
    else if (Result == NODISK){
        setCF(1);
        return;
    }
    setAX(0);
    setCF(0);
}

/* demGetDPBI - Worker for GetDPB and GetDPBList
 *
 * Entry -
 *      Drive -- Drive Number (0=A;1=B..etc)
 *      pDPB -- pointer to the location to store the dpb
 *
 * Exit  - SUCCESS
 *              returns success, fills in DPB
 *          FAILURE
 *              returns FAILURE or NODISK
 */
BYTE demGetDpbI(BYTE Drive, DPB UNALIGNED *pDPB)
{
    WORD SectorSize, ClusterSize, FreeClusters, TotalClusters;
    PBDS pbds;
    WORD DirsPerSector;

    if (demGetDiskFreeSpace(Drive,
			    &SectorSize,
			    &ClusterSize,
			    &TotalClusters,
			    &FreeClusters
			    ))
    {
	pDPB->Next = (PDPB) 0xFFFFFFFF;
	pDPB->SectorSize = SectorSize;
	pDPB->FreeClusters = FreeClusters;
	pDPB->MaxCluster = TotalClusters + 1;
	pDPB->ClusterMask = ClusterSize - 1;
	pDPB->ClusterShift = 0;
	pDPB->DriveNum = pDPB->Unit = Drive;
	while ((ClusterSize & 1) == 0) {
	    ClusterSize >>= 1;
	    pDPB->ClusterShift++;
	}
	if (pbds = demGetBDS(Drive)) {
	    // if the device is a floppy, reload its bpb
	    if (!(pbds->Flags & NON_REMOVABLE) && !demGetBPB(pbds)) {
		return NODISK;
	    }
	    pDPB->MediaID = pbds->bpb.MediaID;
	    pDPB->FATSector = pbds->bpb.ReservedSectors;
	    pDPB->FATs = pbds->bpb.FATs;
	    pDPB->RootDirs = pbds->bpb.RootDirs;
	    pDPB->FATSize = pbds->bpb.FATSize;
	    pDPB->DirSector = pbds->bpb.FATs * pbds->bpb.FATSize +
			      pDPB->FATSector;
	    DirsPerSector = pDPB->SectorSize >> DOS_DIR_ENTRY_LENGTH_SHIFT_COUNT;
	    pDPB->FirstDataSector = pDPB->DirSector +
				    ((pDPB->RootDirs + DirsPerSector - 1) /
				     DirsPerSector);
	    pDPB->DriveAddr = 0x123456;
	    pDPB->FirstAccess = 10;
	}
	// if we don't know the drive, fake a DPB for it
	else {

	    pDPB->MediaID = 0xF8;
	    pDPB->FATSector = 1;
	    pDPB->FATs	= 2;
	    pDPB->RootDirs	= 63;
	    pDPB->FATSize	= 512;
	    pDPB->DirSector = 1;
	    pDPB->DriveAddr = 1212L * 64L * 1024L + 1212L;
	    pDPB->FirstAccess = 10;
	}
        return SUCCESS;
    }
    else {
        return FAILURE;
    }
}

/* demGetComputerName - Get computer name
 *
 * Entry -
 *     Client (DS:DX)   - 16 byte buffer
 *
 * Exit  - Always Succeeds
 *      DS:DX is filled with the computer name (NULL terminated).
 */

VOID demGetComputerName (VOID)
{
PCHAR   pDOSBuffer;
CHAR    ComputerName[MAX_COMPUTERNAME_LENGTH+1];
DWORD   BufferSize = MAX_COMPUTERNAME_LENGTH+1;
ULONG   i;

    pDOSBuffer = (PCHAR) GetVDMAddr(getDS(), getDX());

    if (GetComputerNameOem(ComputerName, &BufferSize)){
        if (BufferSize <= 15){
            for (i = BufferSize ; i < 15 ; i++)
                ComputerName [i] = ' ';
            ComputerName[15] = '\0';
            strcpy (pDOSBuffer, ComputerName);
        }
        else{
            strncpy (pDOSBuffer, ComputerName, 15);
            pDOSBuffer [15] = '\0';
        }
        setCX(0x1ff);
    }
    else {
        *pDOSBuffer = '\0';
        setCH(0);
    }
}

#define APPS_SPACE_LIMIT    999990*1024 //999990kb to be on the safe side

BOOL demGetDiskFreeSpace(
    BYTE    Drive,
    WORD   * BytesPerSector,
    WORD   * SectorsPerCluster,
    WORD   * TotalClusters,
    WORD   * FreeClusters
)
{
CHAR	chRoot[]="?:\\";
DWORD	dwBytesPerSector;
DWORD	dwSectorsPerCluster;
DWORD	dwTotalClusters;
DWORD	dwFreeClusters;
DWORD   dwLostFreeSectors;
DWORD   dwLostTotalSectors;
DWORD   dwNewSectorPerCluster;
ULONG   ulTotal,ulTemp;

    // sudeepb 22-Jun-1993;
    // Please read this routine with an empty stomach.
    // The most common mistake all the apps do when calculating total
    // disk space or free space is to neglect overflow. Excel/Winword/Ppnt
    // and lots of other apps use "mul cx mul bx" never taking care
    // of first multiplication which can overflow. Hence this routine makes
    // sure that first multiplication will never overflow by fixing
    // appropriate values. Secondly, all these above apps use signed long
    // to deal with these free spaces. This puts a limit of 2Gb-1 on
    // the final outcome of the multiplication. If its above this the setup
    // fails. So here we have to make sure that total should never exceed
    // 0x7fffffff. Another bug in above setup program's that if you return
    // anything more than 999,999KB then they try to put "999,999KB+\0", but
    // unfortunately the buffer is only 10 bytes. Hence it corrupts something
    // with the last byte. In our case that is low byte of a segment which
    // it later tries to pop and GPF. This shrinks the maximum size that
    // we can return is 999,999KB.

    chRoot[0]=(CHAR)('A'+ Drive);

    if (GetDiskFreeSpaceOem(chRoot,
                            &dwSectorsPerCluster,
                            &dwBytesPerSector,
                            &dwFreeClusters,
                            &dwTotalClusters) == FALSE)
       return FALSE;

      /*
       *  HPFS and NTFS can give num clusters over dos limit
       *  For these cases increase SectorPerCluster and lower
       *  cluster number accordingly. If the disk is very large
       *  even this isn't enuf, so pass max sizes that dos can
       *  handle.
       *
       *  The following algorithm is accurate within 1 cluster
       *  (final figure)
       *
       */
    dwLostFreeSectors  = dwLostTotalSectors = 0;
    while (dwTotalClusters + dwLostTotalSectors/dwSectorsPerCluster > 0xFFFF)
        {
         if (dwSectorsPerCluster > 0x7FFF)
            {
             dwTotalClusters     = 0xFFFF;
             if (dwFreeClusters > 0xFFFF)
                 dwFreeClusters = 0xFFFF;
             break;
             }

         if (dwFreeClusters & 1) {
             dwLostFreeSectors += dwSectorsPerCluster;
             }
         if (dwTotalClusters & 1) {
             dwLostTotalSectors += dwSectorsPerCluster;
             }
         dwSectorsPerCluster <<= 1;
         dwFreeClusters      >>= 1;
         dwTotalClusters     >>= 1;
         }

    if (dwTotalClusters < 0xFFFF) {
        dwFreeClusters   +=  dwLostFreeSectors/dwSectorsPerCluster;
        dwTotalClusters  +=  dwLostTotalSectors/dwSectorsPerCluster;
        }

    if ((dwNewSectorPerCluster = (0xffff / dwBytesPerSector)) < dwSectorsPerCluster)
        dwSectorsPerCluster = dwNewSectorPerCluster;

    // finally check for 999,999kb
    ulTemp =  (ULONG)((USHORT)dwSectorsPerCluster * (USHORT)dwBytesPerSector);

    // check that total space does'nt exceed 999,999kb
    ulTotal = ulTemp * (USHORT)dwTotalClusters;

    if (ulTotal > APPS_SPACE_LIMIT){
        if (ulTemp <= APPS_SPACE_LIMIT)
            dwTotalClusters = APPS_SPACE_LIMIT / ulTemp;
        else
            dwTotalClusters = 1;
    }

    ulTotal = ulTemp * (USHORT)dwFreeClusters;

    if (ulTotal > APPS_SPACE_LIMIT) {
        if (ulTemp <= APPS_SPACE_LIMIT)
            dwFreeClusters = APPS_SPACE_LIMIT / ulTemp;
        else
            dwFreeClusters = 1;
    }

    *BytesPerSector = (WORD) dwBytesPerSector;
    *SectorsPerCluster = (WORD) dwSectorsPerCluster;
    *TotalClusters = (WORD) dwTotalClusters;
    *FreeClusters = (WORD) dwFreeClusters;
    return TRUE;
}

/* demGetDPBList - Create the list of dpbs
 *
 * Entry -
 *      Client(ES:BP) - points to destination for the dpb list
 * Exit  - SUCCESS
 *      Client (BP) - points to first byte past dpb list
 *     FAILURE
 *      Client (BP) unchanged
 *
 * Notes:
 *      For performance reasons, only the drive and unit fields are
 *      filled in.  The only application I know of that depends on the
 *      dpb list is go.exe (a shareware app installer).  Even if we filled
 *      in the other fields they would likely be incorrect when the app
 *      looked at them, since ntdos.sys never updates the pdbs in the pdb
 *      list
 */
VOID demGetDPBList (VOID)
{
    UCHAR DriveType;
    UCHAR DriveNum;
    DPB UNALIGNED *pDpb;
    USHORT usDpbOffset, usDpbSeg;

    usDpbOffset = getBP();
    usDpbSeg = getES();
    pDpb = (PDPB)GetVDMAddr(usDpbSeg, usDpbOffset);

    //
    // Iterate over all of the drive letters.
    //
    DriveNum = 0;
    do {
        DriveType = demGetPhysicalDriveType(DriveNum);

        //
        // Only include the local non cd rom drives ?? ramdisk ???
        //
        if ((DriveType == DRIVE_REMOVABLE) || (DriveType == DRIVE_FIXED)) {

            //
            // Fake the Dpb for the drive
            //
            pDpb->DriveNum = pDpb->Unit = DriveNum;

            //
            // Link it to the next dpb
            //
            usDpbOffset += sizeof(DPB);
            pDpb->Next = (PDPB)(((ULONG)usDpbSeg) << 16 | usDpbOffset);

            //
            // Advance to the next dpb
            //
            pDpb += 1;

            ASSERT(usDpbOffset < 0xFFFF);
        }

    } while (++DriveNum < 26);

    //
    // Terminate the list if necessary
    //
    if (usDpbOffset != getBP()) {
        pDpb -= 1;
        pDpb->Next = (PDPB)-1;
    }

    //
    // Return the new free space pointer
    //
    setBP(usDpbOffset);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demfile.c ===
/* demfile.c - SVC handlers for calls where file name is specified.
 *
 * demOpen
 * demCreate
 * demUnlink
 * demChMod
 * demRename
 *
 * Modification History:
 *
 * Sudeepb 02-Apr-1991 Created
 *
 */

#include "dem.h"
#include "demmsg.h"

#include <softpc.h>
#include <winbase.h>
#include <vrnmpipe.h>
#include <nt_vdd.h>
#include "dpmtbls.h"

#define DOS_FLAG_EXEC_OPEN 1  // See dos\v86\inc\dossym.inc
extern PDOSSF pSFTHead;

BOOL (*VrInitialized)(VOID);  // POINTER TO FUNCTION
extern BOOL LoadVdmRedir(VOID);
extern BOOL IsVdmRedirLoaded(VOID);
extern BYTE *Dos_Flag_Addr;

BOOL
IsNamedPipeName(
    IN LPSTR Name
    );

BOOL
IsNamedPipeName(
    IN LPSTR Name
    )

/*++

Routine Description:

    Lifted from VDMREDIR.DLL - we don't want to load the entire DLL if we
    need to check for a named pipe

    Checks if a string designates a named pipe. As criteria for the decision
    we use:

        \\computername\PIPE\...

    DOS (client-side) can only open a named pipe which is created at a server
    and must therefore be prefixed by a computername

Arguments:

    Name    - to check for (Dos) named pipe syntax

Return Value:

    BOOL
        TRUE    - Name refers to (local or remote) named pipe
        FALSE   - Name doesn't look like name of pipe

--*/

{
    int CharCount;


    if (IS_ASCII_PATH_SEPARATOR(*Name)) {
        ++Name;
        if (IS_ASCII_PATH_SEPARATOR(*Name)) {
            ++Name;
            CharCount = 0;
            while (*Name && !IS_ASCII_PATH_SEPARATOR(*Name)) {
                ++Name;
                ++CharCount;
            }
            if (!CharCount || !*Name) {

                //
                // Name is \\ or \\\ or just \\name which I don't understand,
                // so its not a named pipe - fail it
                //

                return FALSE;
            }

            //
            // bump name past next path separator. Note that we don't have to
            // check CharCount for max. length of a computername, because this
            // function is called only after the (presumed) named pipe has been
            // successfully opened, therefore we know that the name has been
            // validated
            //

            ++Name;
        } else {
            return FALSE;
        }

        //
        // We are at <something> (after \ or \\<name>\). Check if <something>
        // is [Pp][Ii][Pp][Ee][\\/]
        //

        if (!_strnicmp(Name, "PIPE", 4)) {
            Name += 4;
            if (IS_ASCII_PATH_SEPARATOR(*Name)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

/* demOpen - Open a file
 *
 *
 * Entry - Client (DS:SI) Full path of File
 *         Client (BL)    Open Mode
 *         Client (ES:DI) Address of extended attributes buffer
 *         Client (AL)    0 - No EA's ; 1 - EA's specified
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *           Client (AX) = Assigned Open Handle (high word)
 *           Client (BP) = Assigned Open Handle (low word)
 *           Client (DX) = 1 if pipe was opened
 *           Client (BX) = High word of the file size
 *           Client (CX) = low word of the file size
 *
 *
 *         FAILURE
 *              CY = 1
 *              AX = system status code
 *          HARD ERROR
 *              CY = 1
 *              AX = 0FFFFh
 *
 *
 * Notes : Extended Attributes is not yet taken care of.
 */

VOID demOpen (VOID)
{
HANDLE  hFile;
LPSTR   lpFileName;
UCHAR   uchMode,uchAccess;
DWORD   dwDesiredAccess = GENERIC_WRITE | GENERIC_READ;
DWORD   dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
BOOL    ItsANamedPipe = FALSE;
BOOL    IsFirst;
LPSTR   dupFileName;
DWORD   dwFileSize,dwSizeHigh;
SECURITY_ATTRIBUTES sa;

    if (getAL()){
        demPrintMsg (MSG_EAS);
        return;
    }

    lpFileName = (LPSTR) GetVDMAddr (getDS(),getSI());

#if DBG
    if(fShowSVCMsg & DEMFILIO){
       sprintf(demDebugBuffer,"demfile: Opening File <%s>\n",lpFileName);
       OutputDebugStringOem(demDebugBuffer);
    }
#endif

    //
    // the DOS filename must be 'canonicalized': forward slashes (/) must be
    // converted to back slashes (\) and the filename should be upper-cased
    // using the current code page info
    //

    //
    // BUBUG: Kanji? (/other DBCS)
    //

    if (strchr(lpFileName, '/')) {
        char ch= *lpFileName;
        lpFileName = _strdup(lpFileName);
        if (lpFileName == NULL) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            demClientError(INVALID_HANDLE_VALUE, ch);
            return;
        }
        for (dupFileName = lpFileName; *dupFileName; ++dupFileName) {
            if (*dupFileName == '/') {
                *dupFileName = '\\';
            }
        }
        dupFileName = lpFileName;
    } else {
        dupFileName = NULL;
    }

    uchMode = getBL();
    uchAccess = uchMode & (UCHAR)ACCESS_MASK;

    if (uchAccess == OPEN_FOR_READ)
        dwDesiredAccess = GENERIC_READ;
    else if (uchAccess == OPEN_FOR_WRITE)
        dwDesiredAccess = GENERIC_WRITE;

    if (Dos_Flag_Addr && (*Dos_Flag_Addr & DOS_FLAG_EXEC_OPEN)) {
        dwDesiredAccess |= GENERIC_EXECUTE;
    }
    uchMode = uchMode & (UCHAR)SHARING_MASK;

    switch (uchMode) {
        case SHARING_DENY_BOTH:
            dwShareMode = 0;
            break;
        case SHARING_DENY_WRITE:
            dwShareMode = FILE_SHARE_READ;
            break;
        case SHARING_DENY_READ:
            dwShareMode = FILE_SHARE_WRITE;
            break;
    }

    //
    // slightly new scheme - the redir isn't automatically loaded anymore. We
    // may perform a named pipe operation before VDMREDIR is loaded. So now we
    // load VDMREDIR.DLL if the filespec designates a named pipe
    //

    if (IsNamedPipeName(lpFileName)) {
        if (!LoadVdmRedir()) {
            goto errorReturn;
        }
        ItsANamedPipe = TRUE;

        //
        // convert \\<this_computer>\PIPE\foo\bar\etc to \\.\PIPE\...
        // if we already allocated a buffer for the slash conversion use
        // that else this call will allocate another buffer (we don't
        // want to write over DOS memory)
        //

        lpFileName = VrConvertLocalNtPipeName(dupFileName, lpFileName);
        if (!lpFileName) {
            goto errorReturn;
        }
    }

    //
    // open the file. If we think its a named pipe then use FILE_FLAG_OVERLAPPED
    // because the client might use DosReadAsyncNmPipe or DosWriteAsyncNmPipe
    // and the only way to accomplish that is to open the named pipe handle in
    // overlapped I/O mode now
    //

    // sudeepb 26-Apr-1993 We are retrying opening the file in case
    // of failure without GENERIC_WRITE because of the incompatibility
    // of DOS and NT CD ROM driver. DOS CDROM driver ignores the write
    // bit which we have to fakeout in this way.

    sa.nLength = sizeof (SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    IsFirst = TRUE;

    while (TRUE) {
        if ((hFile = CreateFileOem(lpFileName,
                                   dwDesiredAccess,
                                   dwShareMode | FILE_SHARE_DELETE,
                                   &sa,
                                   OPEN_EXISTING,
                                   ItsANamedPipe ? FILE_FLAG_OVERLAPPED : 0,
                                   NULL)) == (HANDLE)-1){
            if (IsFirst && dwDesiredAccess & GENERIC_WRITE &&
                IsCdRomFile(lpFileName)) {
                dwDesiredAccess &= ~GENERIC_WRITE;
                IsFirst = FALSE;
                continue;
            }

errorReturn:

            demClientError(INVALID_HANDLE_VALUE, *lpFileName);
            if (dupFileName) {
                free(dupFileName);
            } else if (ItsANamedPipe && lpFileName) {
                LocalFree(lpFileName);
            }
            return;
        }
        else
            break;
    }

    //
    // we have to keep some info around when we open a named pipe
    //

    if (ItsANamedPipe) {
        VrAddOpenNamedPipeInfo(hFile, lpFileName);
        setDX(1);
    }
    else {
        if(((dwFileSize=DPM_GetFileSize(hFile,&dwSizeHigh)) == (DWORD)-1) ||
             dwSizeHigh) {
            DPM_CloseHandle (hFile);
            demClientError(INVALID_HANDLE_VALUE, *lpFileName);
            return;
        }
        setCX ((USHORT)dwFileSize);
        setBX ((USHORT)(dwFileSize >> 16 ));
        setDX(0);
    }

    setBP((USHORT)hFile);
    setAX((USHORT)((ULONG)hFile >> 16));
    setCF(0);
    if (dupFileName) {
        free(dupFileName);
    } else if (ItsANamedPipe) {
        LocalFree(lpFileName);
    }
    return;
}

#define DEM_CREATE     0
#define DEM_CREATE_NEW 1

/* demCreate - Create a file
 *
 *
 * Entry - Client (DS:SI) Full path of File
 *         Client (CX)    Attributes
 *                        00 - Normal File
 *                        01 - Read-only file
 *                        02 - Hidden File
 *                        04 - System file
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *           Client (AX) = Assigned Open Handle (high word)
 *           VSF(BP)     = Assigned Open Handle (low word)
 *
 *         FAILURE
 *              CY = 1
 *              AX = error code
 *          HARD ERROR
 *              CY = 1
 *              AX = 0FFFFh
 *
 */

VOID demCreate (VOID)
{
    demCreateCommon (DEM_CREATE);
    return;
}

/* demCreateNew - Create a New file
 *
 *
 * Entry - Client (DS:SI) Full path of File
 *         Client (CX)    Attributes
 *                        00 - Normal File
 *                        01 - Read-only file
 *                        02 - Hidden File
 *                        04 - System file
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *           Client (AX) = Assigned Open Handle (high word)
 *           VSF(BP)     = Assigned Open Handle (low word)
 *
 *         FAILURE
 *              CY = 1
 *              AX = error code
 *          HARD ERROR
 *              CY = 1
 *              AX = 0FFFFh
 *
 */

VOID demCreateNew (VOID)
{
    demCreateCommon (DEM_CREATE_NEW);
    return;
}


/* demFileDelete
 *
 * EXPORTED FUNCTION
 *
 * ENTRY:
 *      lpFile -> OEM file name to be deleted
 *
 * EXIT:
 *      returns 0 on success, DOS error code on failure
 *
 * NOTES:
 * Some apps keep a file open and delete it.   Then rename another file to
 * the old name.   On NT since the orignal object is still open the second
 * rename fails.
 * To get around this problem we rename the file before deleteing it
 * this allows the second rename to work
 *
 * But since renaming the file is known to be expensive over the net, we try
 * first to open the file exclusively to see if there is really any reason to
 * rename it. If we can get a handle to it, then we should be able to skip the
 * rename and just delete it. If we can't get a handle to it, then we try
 * the rename trick. This should cut down our overhead for the normal case.
 */

DWORD demFileDelete (LPSTR lpFile)
{
    CHAR vdmtemp[MAX_PATH];
    CHAR tmpfile[MAX_PATH];
    PSZ pFileName;
    HANDLE hFile;

    //
    // First, try to access the file exclusively
    //

    hFile = CreateFileOem(lpFile,
                          DELETE,
                          0,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);

    if (hFile != INVALID_HANDLE_VALUE) {
        NTSTATUS status;
        IO_STATUS_BLOCK ioStatusBlock;
        FILE_DISPOSITION_INFORMATION fileDispositionInformation;

        // Member name "DeleteFile" conflicts with win32 definition (it
        // becomes "DeleteFileA".
#undef DeleteFile
        fileDispositionInformation.DeleteFile = TRUE;

        //
        // We got a handle to it, so there can't be any open
        // handles to it. Set the disposition to DELETE.
        //

        status = NtSetInformationFile(hFile,
                                      &ioStatusBlock,
                                      &fileDispositionInformation,
                                      sizeof(FILE_DISPOSITION_INFORMATION),
                                      FileDispositionInformation);

        DPM_CloseHandle(hFile);

        if NT_SUCCESS(status) {
            SetLastError(NO_ERROR);
        } else {
            SetLastError(ERROR_ACCESS_DENIED);
        }
    }

    //
    // Check to see if the delete went OK. If not, try renaming
    // the file.
    //
    switch (GetLastError()) {

    case NO_ERROR:
    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:
        // Can't find it, forget about it
        break;

    case ERROR_SHARING_VIOLATION:
    case ERROR_ACCESS_DENIED:
        //
        // The file didn't really go away because there appears to
        // be an open handle to the file.
        //
        if (GetFullPathNameOemSys(lpFile,MAX_PATH,vdmtemp,&pFileName,FALSE)) {
            if ( pFileName )
               *(pFileName) = 0;
            if (GetTempFileNameOem(vdmtemp,"VDM",0,tmpfile)) {
                if (MoveFileExOem(lpFile,tmpfile, MOVEFILE_REPLACE_EXISTING)) {
                    if(DeleteFileOem(tmpfile)) {
                        SetLastError(NO_ERROR);
                    } else {
                        MoveFileOem(tmpfile,lpFile);
                        SetLastError(ERROR_ACCESS_DENIED);
                    }
                }
            }
        }
        break;

    default:

        //
        // We couldn't open or delete the file, and it's not because of a
        // sharing violation. Just try a last ditch effort of a
        // plain old delete, and see if it works.
        //
        if(DeleteFileOem(lpFile)) {
            SetLastError(NO_ERROR);
        }
    }

    //
    // Map win32 error code to DOS
    //
    switch(GetLastError()) {

    case NO_ERROR:
    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:
    case ERROR_ACCESS_DENIED:
        break;
    default:
        // make sure demClientError can see retval
        SetLastError(ERROR_ACCESS_DENIED);
    }

    return GetLastError();
}

/* demDelete - Delete a file
 *
 *
 * Entry - Client (DS:DX) Full path of File
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *
 *         FAILURE
 *              CY = 1
 *              AX = system status code
 *          HARD ERROR
 *              CY = 1
 *              AX = 0FFFFh
 *
 */

VOID demDelete (VOID)
{
LPSTR   lpFileName;


    lpFileName = (LPSTR) GetVDMAddr (getDS(),getDX());

#if DBG
    if(fShowSVCMsg & DEMFILIO){
       sprintf(demDebugBuffer,"demfile: Deleting File<%s>\n",lpFileName);
       OutputDebugStringOem(demDebugBuffer);
    }
#endif

    if (demFileDelete(lpFileName)){
        demClientError(INVALID_HANDLE_VALUE, *lpFileName);
        return;
    }

    setCF(0);
    return;
}


/* demChMod - Change the file modes
 *
 * Entry - Client (DS:DX) Full path of File
 *         Client (AL) = 0 Get File Modes 1 Set File Modes
 *         Client (CL) new modes
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *           Client (CL) = file attributes in get case.
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = Error Code
 *          HARD ERROR
 *              CY = 1
 *              AX = 0FFFFh
 *
 * Compatibility Notes:
 *
 *      ATTR_VOLUME_ID,ATTR_DEVICE and ATTR_DIRECTORY are not supported
 *      by WIN32 call. Although these are unpublished for DOS world also
 *      but still a compatibility requirement.
 */

VOID demChMod (VOID)
{
LPSTR   lpFileName;
DWORD   dwAttr;

    lpFileName = (LPSTR) GetVDMAddr (getDS(),getDX());

#if DBG
    if(fShowSVCMsg & DEMFILIO){
       sprintf(demDebugBuffer,"demfile: ChMod File <%s>\n",lpFileName);
       OutputDebugStringOem(demDebugBuffer);
    }
#endif


    if(getAL() == 0){
        if ((dwAttr = GetFileAttributesOemSys(lpFileName, FALSE)) == -1)
            goto dcerr;


        if (dwAttr == FILE_ATTRIBUTE_NORMAL) {
            dwAttr = 0;
            }
        else {
            dwAttr &= DOS_ATTR_MASK;
            }

        // SudeepB - 28-Jul-1997
        //
        // For CDFS, Win3.1/DOS/Win95, only return FILE_ATTRIBUTE_DIRECTORY (10)
        // for directories while WinNT returns
        // FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY (11).
        // Some VB controls that app setups use, depend on getting
        // FILE_ATTRIBUTE_DIRECTORY (10) only or otherwise are broken.
        // An example of this is Cliffs StudyWare series.

        if (dwAttr == (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY)) {
            if(IsCdRomFile(lpFileName))
                dwAttr = FILE_ATTRIBUTE_DIRECTORY;
        }

        setCX((USHORT)dwAttr);
        setCF(0);
        return;
    }

    if((dwAttr = getCX()) == 0)
        dwAttr = FILE_ATTRIBUTE_NORMAL;

    dwAttr &= DOS_ATTR_MASK;
    if (!SetFileAttributesOemSys(lpFileName,dwAttr,FALSE))
        goto dcerr;

    setCF(0);
    return;

dcerr:
    demClientError(INVALID_HANDLE_VALUE, *lpFileName);
    return;
}


/* demRename - Rename a file
 *
 * Entry - Client (DS:DX) Source File
 *         Client (ES:DI) Destination File
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = Error Code
 *
 */

VOID demRename (VOID)
{
LPSTR   lpSrc,lpDst;

    lpSrc = (LPSTR) GetVDMAddr (getDS(),getDX());
    lpDst = (LPSTR) GetVDMAddr (getES(),getDI());

#if DBG
    if(fShowSVCMsg & DEMFILIO){
       sprintf(demDebugBuffer,"demfile: Rename File <%s> to <%s>\n",lpSrc,lpDst);
       OutputDebugStringOem(demDebugBuffer);
    }
#endif

    // DOS rename fails accross drives with 11h error code
    // This following check is OK even for UNC names and SUBST drives.
    // SUBST drives come to NTVDM as env variables for current directory
    // and we will treet them just like a network drive and full qualified
    // path will be sent from NTDOS.
    if(toupper(lpSrc[0]) != toupper(lpDst[0])) {
        setCF(1);
        setAX(0x11);
        return;
    }

    // Now check that SRC and DEST are not pointing to the same file.
    // if they do return error 5.
    if (!_stricmp (lpSrc, lpDst)) {
        setCF(1);
        setAX(0x5);
        return;
    }

    if(MoveFileOem(lpSrc,lpDst) == FALSE){
        demClientError(INVALID_HANDLE_VALUE, *lpSrc);
        return;
    }

    setCF(0);
    return;
}

/* demCreateCommon - Create a file or Create a new file
 *
 *
 * Entry - flCreateType - DEM_CREATE_NEW create new
 *                        DEM_CREATE     create
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *           Client (AX) = Assigned Open Handle (high word)
 *           Client (BP)     = Assigned Open Handle (low word)
 *
 *         FAILURE
 *              CY = 1
 *              AX = error code
 *          HARD ERROR
 *              CY = 1
 *              AX = 0FFFFh
 *
 */

VOID demCreateCommon (flCreateType)
ULONG  flCreateType;
{
HANDLE  hFile;
LPSTR   lpFileName;
LPSTR   lpDot;
DWORD   dwAttr;
DWORD   dwFileSize,dwSizeHigh;
USHORT  uErr;
DWORD   dwDesiredAccess;
SECURITY_ATTRIBUTES sa;
CHAR    cFOTName[MAX_PATH];
BOOL    ttfOnce,IsFirst;
DWORD   dwLastError;


    lpFileName = (LPSTR) GetVDMAddr (getDS(),getSI());
    dwAttr = (DWORD)getCX();

    // Here is some code stolen from DOS_Create (create.asm) for handling the
    // attributes

    if (flCreateType == DEM_CREATE || flCreateType == DEM_CREATE_NEW)
        dwAttr &= 0xff;

    if (dwAttr & ~(ATTR_ALL | ATTR_IGNORE | ATTR_VOLUME_ID)) {
        setCF(1);
        setAX(5);   //Attribute problem
        return;
    }

    /* Special case for set volume label (INT 21 Func 3CH, Attr = 8H */

    if((flCreateType == DEM_CREATE || flCreateType == DEM_CREATE_NEW) && (dwAttr == ATTR_VOLUME_ID)) {
        if((uErr = demCreateLabel(lpFileName[DRIVEBYTE],
                                  lpFileName+LABELOFF))) {
            setCF(1);
            setAX(uErr);
            return;
        }
        setAX(0);
        setBP(0);   // in this case handle = 0 and if we will
        setCF(0);   // close this handle CF will be 0(!)
        return;
    }


    if ((dwAttr & 0xff) == 0) {
        dwAttr = FILE_ATTRIBUTE_NORMAL;
    } else {
        dwAttr &= DOS_ATTR_MASK;
    }


#if DBG
    if(fShowSVCMsg & DEMFILIO){
       sprintf(demDebugBuffer,"demfile: Creating File <%s>\n",lpFileName);
       OutputDebugStringOem(demDebugBuffer);
    }
#endif

    dwDesiredAccess = GENERIC_WRITE | GENERIC_READ;
    sa.nLength = sizeof (SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;
    ttfOnce = TRUE;
    IsFirst = TRUE;

    while (TRUE) {
        if ((hFile = CreateFileOem(lpFileName,
                    // create file with delete access and sharing mode
                    // so that anybody can delete it without closing
                    // the file handle returned from create file
                    dwDesiredAccess,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    &sa,
                    flCreateType == DEM_CREATE ? CREATE_ALWAYS : CREATE_NEW,
                    dwAttr,
                    NULL)) == (HANDLE)-1){

            if (IsFirst && dwDesiredAccess & GENERIC_WRITE &&
                IsCdRomFile(lpFileName)) {
                dwDesiredAccess &= ~GENERIC_WRITE;
                IsFirst = FALSE;
                continue;
            }

            // APP COMPATABILITY
            // Some WOW apps installing .TTF or .FON or Fonts fail to create
            // The file because the font is already open by GDI32 server.
            // The install/setup programs don't gracefully handle
            // this error, they bomb out of the install with retry or cancel
            // without offering the user a way to ignore the error (which
            // would be the right thing since the font already exists.
            // To work around this problem we do a RemoveFontResource here
            // which causes GDI32 to unmap the file, we then retry
            // the create.  - mattfe june 93

            // If it is a TTF file then we need to remove the font resource
            // for the .FOT file of the same name

            if (ttfOnce) {

                // Look for the file extension

                lpDot = strrchr(lpFileName,'.');

                if (lpDot) {
                    if ( (!_strcmpi(lpDot,".TTF")) ||
                         (!_strcmpi(lpDot,".FON")) ||
                         (!_strcmpi(lpDot,".FOT")) ) {

                        if ( RemoveFontResourceOem(lpFileName) ) {
                            PostMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0);
                            ttfOnce = FALSE;
                            continue;
                        }

                        // We failed to remove the .TTF file probably because
                        // the .FOT file was loaded, so try to remove it

                        if (!_strcmpi(lpDot,".TTF") &&
                            ((ULONG)lpDot-(ULONG)lpFileName) < sizeof(cFOTName)-sizeof(".FOT")) {

                            RtlZeroMemory(cFOTName,sizeof(cFOTName));
                            RtlCopyMemory(cFOTName,lpFileName,(ULONG)lpDot-(ULONG)lpFileName);
                            strcat(cFOTName,".FOT");
                            if ( RemoveFontResourceOem(cFOTName) ) {
                                PostMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0);
                                ttfOnce = FALSE;
                                continue;
                            }
                        }
                    }
                }
            }
            demClientError(INVALID_HANDLE_VALUE, *lpFileName);
            return;
        }
        else
            break;
    }

    if((dwFileSize=DPM_GetFileSize(hFile,&dwSizeHigh) == -1) || dwSizeHigh) {
        DPM_CloseHandle (hFile);
        demClientError(INVALID_HANDLE_VALUE, *lpFileName);
        return;
    }
    setCX ((USHORT)dwFileSize);
    setBX ((USHORT)(dwFileSize >> 16 ));
    setBP((USHORT)hFile);
    setAX((USHORT)((ULONG)hFile >> 16));
    setCF(0);
    return;
}

BOOL IsCdRomFile (PSTR pszPath)
{
    UCHAR   pszRootDir[MAX_PATH];
    UCHAR   file_system[MAX_PATH];
    int     i, j;

    // The given path is either a network path or has D: at the start.

    if (!pszPath[0]) {
        return FALSE;
    }

    if (pszPath[1] == ':') {
        pszRootDir[0] = pszPath[0];
        pszRootDir[1] = ':';
        pszRootDir[2] = '\\';
        pszRootDir[3] = 0;
    } else if (IS_ASCII_PATH_SEPARATOR(pszPath[0]) &&
               IS_ASCII_PATH_SEPARATOR(pszPath[1])) {
        j = 0;
        for (i = 2; pszPath[i]; i++) {
            if (IS_ASCII_PATH_SEPARATOR(pszPath[i])) {
                if (++j == 2) {
                    break;
                }
            }
        }
        if(i > sizeof(pszRootDir)-2) {
           return FALSE;
        }

        memcpy(pszRootDir, pszPath, i);
        pszRootDir[i] = '\\';
        pszRootDir[i+1] = 0;
    } else {
        return FALSE;
    }

    if (GetVolumeInformationOem(pszRootDir, NULL, 0, NULL, NULL, NULL,
                                file_system, MAX_PATH) &&
        !_stricmp(file_system, "CDFS")) {

        return TRUE;
    }

    return FALSE;
}

/* demCheckPath - Check path (for device only)
 *
 *
 * Entry - Client (DS:SI) Full path (with last '\')
 *         Client DL is drive number (1-based)
 *
 * Exit -  Set client DX to 0
 *
 *         SUCCESS
 *       Client (CF) = 0
 *
 *         FAILURE
 *      CF = 1
 */

VOID demCheckPath (VOID)
{
HANDLE  hFile;
LPSTR   lpFileName;
CHAR    cDRV;
CHAR    szFileName[MAX_PATH];

    lpFileName = (LPSTR) GetVDMAddr (getDS(),getSI());
    cDRV = getDL()+'A'-1;

    setDX(0);

    // If we have \dev dir then return OK, DOS always has this directory for
    // devices.

    if(!_strnicmp(lpFileName, "\\DEV\\",6)) {
    setCF(0);
    return;
    }

    sprintf(szFileName, "%c:%sNUL", cDRV, lpFileName);

#if DBG
    if(fShowSVCMsg & DEMFILIO){
       sprintf(demDebugBuffer,"demfile: Check Pathe <%s>\n",lpFileName);
       OutputDebugStringOem(demDebugBuffer);
    }
#endif


    // If path exists then we always can open NUL file in this directory,
    // if path doesn't exists then CreateFile returns INVALID_HANDLE_VALUE
    //

    if ((hFile = CreateFileOem((LPSTR) szFileName,
                   GENERIC_WRITE,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL,
                   CREATE_ALWAYS,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL)) == INVALID_HANDLE_VALUE) {

    demClientError(INVALID_HANDLE_VALUE, *lpFileName);

    setCF(1);
        return;
    }

    DPM_CloseHandle (hFile);
    setCF(0);

    return;
}


PDOSSFT GetFreeSftEntry(PDOSSF pSfHead, PWORD usSFN)
{
    WORD    i;
    PDOSSFT pSft;
    DWORD   ulSFLink;

    *usSFN = 0;
    for (;;) {

        pSft = (PDOSSFT) &(pSfHead->SFTable);
        for (i = 0; i < pSfHead->SFCount; i++) {
            if (pSft[i].SFT_Ref_Count == 0) {
                *usSFN += i;
                return (pSft + i);
            }
        }
        *usSFN += pSfHead->SFCount;

        ulSFLink = pSfHead->SFLink;
        if (LOWORD(ulSFLink) == 0xFFFF) {
            break;
        }

        pSfHead = (PDOSSF) Sim32GetVDMPointer (ulSFLink, 0, 0);
    }

    return NULL;
}


/** VDDAllocateDosHandle - Allocates an unused DOS file handle.
 *
 *  ENTRY -
 *      IN  pPDB  - OPTIONAL: (16:16) address of the PDB for the task
 *      OUT ppSFT - OPTIONAL: Returns a 32-bit flat pointer to the SFT
 *                            associated with the allocated file handle.
 *      OUT ppJFT - OPTIONAL: Returns a 32-bit flat pointer to the JFT
 *                            associated with the given PDB.
 *
 *
 *  EXIT
 *      SUCCESS - Returns the value of the DOS file handle and associated
 *                pointers.
 *      FAILURE - Returns a negative value. The absolute value of this number
 *                is the DOS error code.
 *
 * Comments:
 *  This routine searches for an unused DOS file handle and SFT and "opens"
 *  a file. After the successful completion of this call, the returned file
 *  handle and the corresponding SFT will be reserved for the caller's use, and
 *  will be unavailable to other callers trying to issue DOS Open or Create api
 *  calls. It is the caller's responsibility to release this file handle (with
 *  a call to VDDReleaseDosHandle).
 *
 *  If the pPDB pointer is not supplied (e.g., is NULL), then the current
 *  PDB as reported by DOS will be used.
 *
 *  Although the ppSFT parameter is technically optional, it is a required
 *  parameter of the VDDAssociateNtHandle call. This was done to avoid a
 *  second handle lookup in the Associate call.
 *
 */

SHORT VDDAllocateDosHandle (pPDB,ppSFT,ppJFT)
ULONG       pPDB;
PDOSSFT*    ppSFT;
PBYTE*      ppJFT;
{
PDOSPDB pPDBFlat;
PBYTE   pJFT;
PDOSSFT pSFT;
USHORT  usSFN;
WORD    JFTLength;
SHORT   hDosHandle;

    if (!pPDB) {
        pPDB = (ULONG) (*pusCurrentPDB) << 16;
    }

    //
    // Get the JFT.
    //

    pPDBFlat = (PDOSPDB) Sim32GetVDMPointer (pPDB, 0, 0);

    if ( NULL == pPDBFlat ) {
      return (- ERROR_INVALID_HANDLE);
    }

    pJFT     = (PBYTE)   Sim32GetVDMPointer (pPDBFlat->PDB_JFN_Pointer, 0, 0);

    if ( NULL == pJFT ) {
      return (- ERROR_INVALID_HANDLE);
    }

    //
    // Check to see if there's a free entry in the JFT.
    //

    JFTLength = pPDBFlat->PDB_JFN_Length;
    for (hDosHandle = 0; hDosHandle < JFTLength; hDosHandle++) {
        if (pJFT[hDosHandle] == 0xFF) {
            break;
        }
    }

    // If no room in the JFT then return ERROR_TOO_MANY_OPEN_FILES

    if (hDosHandle == JFTLength) {
        return (- ERROR_TOO_MANY_OPEN_FILES);
    }

    //
    // Check the SF for a free SFT.
    //

    if (!(pSFT = GetFreeSftEntry(pSFTHead, &usSFN))) {
        return (- ERROR_TOO_MANY_OPEN_FILES);
    }

    pJFT[hDosHandle] = (BYTE)usSFN;
    RtlZeroMemory((PVOID)pSFT, sizeof(DOSSFT));
    pSFT->SFT_Ref_Count = 1;

    if (ppSFT) {
        *ppSFT = (pSFT);
    }

    if (ppJFT) {
        *ppJFT = pJFT;
    }

    return(hDosHandle);

}

/** VDDAssociateNtHandle - Associates the passed NT handle and access flags
 *                          the given DOS handle.
 *
 * ENTRY -
 *      IN pSFT    - flat address of the SFT to be updated
 *      IN hFile32 - NT handle to be stored
 *      IN wAccess - access flags to set in the SFT
 *
 * EXIT -
 *      This routine has no return value.
 *
 * Comments:
 *  This routine takes the passed NT handle value and stores it in a DOS SFT
 *  so that it can later be retrieved by the VDDRetrieveNtHandle api. The
 *  pointer to the SFT is returned by the VDDAllocateDosHandle api.
 *
 *  The format of the third parameter is the same as the file access flags
 *  defined for DOS Open File with Handle call (Int 21h, func 3dh), documented
 *  in Microsoft MS-DOS Programmer's Reference. Only the low order byte of
 *  this parameter is used, the upper byte is reserved and must be zero.
 *  The value of this parameter is placed into the passed SFT. This is provided
 *  to allow the caller to define the access rights for the corresponding
 *  DOS file handle.
 *
 */

VOID VDDAssociateNtHandle (pSFT,hFile,wAccess)
PDOSSFT     pSFT;
HANDLE      hFile;
WORD        wAccess;
{

    pSFT->SFT_Mode = wAccess&0x7f; // take out no_inherit bit
    pSFT->SFT_Attr = 0;                     // Not used.
    pSFT->SFT_Flags = (wAccess&0x80) ? 0x1000 : 0; // copy no_inherit bit.
    pSFT->SFT_Devptr = (ULONG) -1;
    pSFT->SFT_NTHandle = (ULONG) hFile;

}


/** VDDReleaseDosHandle - Release the given DOS file handle.
 *
 * ENTRY -
 *      IN pPDB  - OPTIONAL: (16:16) address of the PDB for the task
 *      IN hFile - DOS handle (in low byte)
 *
 * EXIT -
 *      TRUE  - the file handle was released
 *      FALSE - The file handle was not valid or open
 *
 * Comments:
 *  This routine updates the DOS file system data areas to free the passed
 *  file handle. No effort is made to determine if this handle was previously
 *  opened by the VDDAllocateDosHandle call. It is the responsibility of the
 *  caller to insure that the given file handle in the specified PDB should
 *  be closed.
 *
 *  If the pPDB pointer is not supplied (e.g., is NULL), then the current
 *  PDB as reported by DOS will be used.
 *
 */

BOOL VDDReleaseDosHandle (pPDB,hFile)
ULONG       pPDB;
SHORT       hFile;
{
PBYTE   pJFT;
PDOSSFT pSFT;
HANDLE  ntHandle;


    if (!pPDB) {
        pPDB = (ULONG) (*pusCurrentPDB) << 16;
    }

    ntHandle = VDDRetrieveNtHandle(pPDB,hFile,(PVOID *)&pSFT,&pJFT);
    if (!ntHandle) {
        return(FALSE);
    }

    pJFT[hFile] = 0xFF;

    // Decrement reference count.

    pSFT->SFT_Ref_Count--;

    return(TRUE);

}


/** VDDRetrieveNtHandle - Given a DOS file handle get the associated
 *                         NT handle.
 *
 * ENTRY -
 *      IN  pPDB  - OPTIONAL: (16:16) address of the PDB for the task
 *      IN  hFile - DOS handle (in low byte)
 *      OUT ppSFT - OPTIONAL: Returns a 32-bit flat pointer to the SFT
 *                            associated with the given file.
 *      OUT ppJFT - OPTIONAL: Returns a 32-bit flat pointer to the JFT
 *                            associated with the given PDB.
 *
 *
 * EXIT -
 *      SUCCESS - returns 4byte NT handle
 *      FAILURE - returns 0
 *
 * Comments:
 *  The value returned by this function will be the NT handle passed in a
 *  previous VDDAssociateNtHandle call. If no previous call is made to the
 *  the Associate api, then the value returned by this function is undefined.
 *
 *  If the pPDB pointer is not supplied (e.g., is NULL), then the current
 *  PDB as reported by DOS will be used.
 *
 *  Although the ppSFT parameter is technically optional, it is a required
 *  parameter of the VDDAssociateNtHandle call. This was done to avoid a
 *  second handle lookup in the Associate call.
 *
 *  The third and fourth parameters are provided to provide the caller the
 *  ability to update the DOS system data areas directly. This may be useful
 *  for performance reasons, or necessary depending on the application. In
 *  general, care must be taken when using these pointers to avoid causing
 *  system integrity problems.
 *
 */

HANDLE VDDRetrieveNtHandle (pPDB,hFile,ppSFT,ppJFT)
ULONG       pPDB;
SHORT       hFile;
PDOSSFT*    ppSFT;
PBYTE*      ppJFT;
{
PDOSPDB pPDBFlat;
PDOSSF  pSfFlat;
PDOSSFT pSftFlat;
PBYTE   pJFT;
USHORT  usSFN;
USHORT  usSFTCount;
ULONG   ulSFLink;

    if (!pPDB) {
        pPDB = (ULONG) (*pusCurrentPDB) << 16;
    }

    // Get flat pointer to PDB
    pPDBFlat = (PDOSPDB) Sim32GetVDMPointer(pPDB, 0, 0);

    // Check that handle is within JFT
    if (hFile >= pPDBFlat->PDB_JFN_Length) {
        return 0;
    }

    // Get the pointer to JFT
    pJFT = (PBYTE) Sim32GetVDMPointer (pPDBFlat->PDB_JFN_Pointer, 0, 0);

    // Get the SFN, remember -1 indicates unused JFT
    usSFN = (USHORT) pJFT[hFile];
    if (usSFN == 0xff) {
        return 0;
    }

    // Get flat pointer to SF
    pSfFlat =  pSFTHead;

    // Find the right SFT group
    while (usSFN >= (usSFTCount = pSfFlat->SFCount)){
        usSFN = usSFN - usSFTCount;
        ulSFLink = pSfFlat->SFLink;
        if (LOWORD(ulSFLink) == 0xffff)
            return 0;
        pSfFlat = (PDOSSF) Sim32GetVDMPointer (ulSFLink, 0, 0);
    }

    // Get the begining of SFT

    pSftFlat = (PDOSSFT)&(pSfFlat->SFTable);

    // Get the SFN, Finally
    if(pSftFlat[usSFN].SFT_Ref_Count == 0) {
        return 0;
    }

    if (ppSFT) {
        *ppSFT = (pSftFlat + usSFN);
    }

    if (ppJFT) {
        *ppJFT = pJFT;
    }

    return (HANDLE) pSftFlat[usSFN].SFT_NTHandle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demhndl.c ===
/* demhndl.c - SVC handlers for calls where file handle is provided.
 *
 * demClose
 * demRead
 * demWrite
 * demChgFilePtr
 * demFileTimes
 *
 * Modification History:
 *
 * Sudeepb 02-Apr-1991 Created
 * rfirth  25-Sep-1991 Added Vdm Redir stuff for named pipes
 */

#include "dem.h"
#include "demmsg.h"

#include <softpc.h>
#include <io.h>
#include <fcntl.h>
#include <vrnmpipe.h>
#include <exterr.h>
#include <mvdm.h>
#include "dpmtbls.h"

BOOL (*VrInitialized)(VOID);  // POINTER TO FUNCTION
extern BOOL IsVdmRedirLoaded(VOID);

/* demClose - Close a file
 *
 *
 * Entry - Client (AX:BP) File Handle
 *         Client (CX:DX) File position (if -1 no seek needed before closing
 *                        the handle.
 *         (VadimB)
 *         Client (es:di) SFT ptr - this is implied in abort.asm code
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = system status code
 *
 */

VOID demClose (VOID)
{
HANDLE  hFile;
LONG    lLoc;
USHORT  usDX,usCX;

    hFile = GETHANDLE (getAX(),getBP());

    if (hFile == 0) {
    setCF (0);
    return;
    }

    usCX = getCX();
    usDX = getDX();

    if (!((usCX == (USHORT)-1) && (usDX == (USHORT)-1))) {
        lLoc  = (LONG)((((int)usCX) << 16) + (int)usDX);

        //
        // Note that we don't check for failure in this case as edlin,
        // for instance, can have the file position be negative and
        // we still need to do the cleanup below. Note that we are not
        // even sure why seeking on close matter, but the DOS code does it...
        //
        DPM_SetFilePointer (hFile,
                        lLoc,
                        NULL,
                        FILE_BEGIN);

    }

    if (DPM_CloseHandle (hFile) == FALSE){
        demClientError(hFile, (CHAR)-1);
    }

    //
    // if the redir TSR is being run in this VDM session, check if the handle
    // being closed references a named pipe - we have to delete some info
    // that we keep for the open named pipe
    //

    if (IsVdmRedirLoaded()) {
        VrRemoveOpenNamedPipeInfo(hFile);
    }

    setCF(0);
    return;
}


/* demRead - Read a file
 *
 *
 * Entry - Client (AX:BP) File Handle
 *         Client (CX)    Count to read
 *         Client (DS:DX) Buffer Address
 *         Client (BX:SI) = current file pointer location.
 *         ZF = 1 if seek is not needed prior to read.
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *           Client (AX) = Count of bytes read
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = system status code
 *
 */

VOID demRead (VOID)
{
HANDLE  hFile;
LPVOID  lpBuf;
DWORD   dwBytesRead;
USHORT  usDS,usDX;
DWORD   dwReadError;
BOOL    ok;
UCHAR   locus, action, class;
LONG    lLoc;

    hFile = GETHANDLE (getAX(),getBP());
    usDS = getDS();
    usDX = getDX();
    lpBuf  = (LPVOID) GetVDMAddr (usDS,usDX);

    //
    // if this handle is a named pipe then use VrReadNamedPipe since we have
    // to perform an overlapped read, and wait on the event handle for completion
    // even though we're still doing synchronous read
    //

    if (IsVdmRedirLoaded()) {
        if (VrIsNamedPipeHandle(hFile)) {

            //
            // named pipe read always sets the extended error information in the
            // DOS data segment. This is the only way we can return bytes read
            // information and a more data indication
            //

            ok = VrReadNamedPipe(hFile,
                                 lpBuf,
                                 (DWORD)getCX(),
                                 &dwBytesRead,
                                 &dwReadError
                                 );
            switch (dwReadError) {
            case NO_ERROR:
                locus = action = class = 0;
                break;

            case ERROR_NO_DATA:
            case ERROR_MORE_DATA:
                locus = errLOC_Net;
                class = errCLASS_TempSit;
                action = errACT_Retry;
                break;

            default:

                //
                // any error other than the specific ones we handle here should be
                // correctly handled by DOS
                //

                goto readFailureExit;
            }
            pExtendedError->ExtendedErrorLocus = locus;
            STOREWORD(pExtendedError->ExtendedError, (WORD)dwReadError);
            pExtendedError->ExtendedErrorAction = action;
            pExtendedError->ExtendedErrorClass = class;
            if (ok) {
                goto readSuccessExit;
            } else {
                goto readFailureExit;
            }
        }
    }

    //
    // if the redir TSR is not loaded, or the handle is not a named pipe then
    // perform normal file read
    //

    if (!getZF()) {
        ULONG   Zero = 0;
        lLoc  = (LONG)((((int)getBX()) << 16) + (int)getSI());
        if ((DPM_SetFilePointer (hFile,
                            lLoc,
                            &Zero,
                            FILE_BEGIN) == -1L) &&
            (GetLastError() != NO_ERROR)) {
            goto readFailureExit;
        }

    }

    if (DPM_ReadFile (hFile,
                  lpBuf,
                  (DWORD)getCX(),
                  &dwBytesRead,
                  NULL) == FALSE){

readFailureExit:
        Sim32FlushVDMPointer (((ULONG)(usDS << 16)) | usDX, getCX(),
                               (PBYTE )lpBuf, FALSE);
        Sim32FreeVDMPointer (((ULONG)(usDS << 16)) | usDX, getCX(),
                               (PBYTE )lpBuf, FALSE);

        if (GetLastError() == ERROR_BROKEN_PIPE)  {
             setAX(0);
             setCF(0);
             return;
         }
        demClientError(hFile, (CHAR)-1);
        return ;
    }

readSuccessExit:
    Sim32FlushVDMPointer (((ULONG)(usDS << 16)) | usDX, getCX(),
                          (PBYTE )lpBuf, FALSE);
    Sim32FreeVDMPointer (((ULONG)(usDS << 16)) | usDX, getCX(),
                         (PBYTE )lpBuf, FALSE);
    setCF(0);
    setAX((USHORT)dwBytesRead);
    return;
}



/* demWrite - Write to a file
 *
 *
 * Entry - Client (AX:BP) File Handle
 *         Client (CX)    Count to write
 *         Client (DS:DX) Buffer Address
 *         Client (BX:SI) = current file pointer location.
 *         ZF = 1 if seek is not needed prior to write.
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *           Client (AX) = Count of bytes written
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = system status code
 *
 */

VOID demWrite (VOID)
{
HANDLE  hFile;
DWORD   dwBytesWritten;
LPVOID  lpBuf;
LONG    lLoc;
DWORD   dwErrCode;

    hFile = GETHANDLE (getAX(),getBP());
    lpBuf  = (LPVOID) GetVDMAddr (getDS(),getDX());


    //
    // if this handle is a named pipe then use VrWriteNamedPipe since we have
    // to perform an overlapped write, and wait on the event handle for completion
    // even though we're still doing synchronous write
    //

    if (IsVdmRedirLoaded()) {
        if (VrIsNamedPipeHandle(hFile)) {
            if (VrWriteNamedPipe(hFile, lpBuf, (DWORD)getCX(), &dwBytesWritten)) {
                goto writeSuccessExit;
            } else {
                goto writeFailureExit;
            }
        }
    }

    //
    // if the redir TSR is not loaded, or the handle is not a named pipe then
    // perform normal file write
    //


    if (!getZF()) {
        ULONG   Zero = 0;
        lLoc  = (LONG)((((int)getBX()) << 16) + (int)getSI());
        if ((DPM_SetFilePointer (hFile,
                            lLoc,
                            &Zero,
                            FILE_BEGIN) == -1L) &&
            (GetLastError() != NO_ERROR)) {
            demClientError(hFile, (CHAR)-1);
            return ;
        }

    }

    // In DOS CX=0 truncates or extends the file to current file pointer.
    if (getCX() == 0){
        if (DPM_SetEndOfFile(hFile) == FALSE){
            demClientError(hFile, (CHAR)-1);
            return;
        }
        setCF (0);
        return;
    }

    if (DPM_WriteFile (hFile,
           lpBuf,
           (DWORD)getCX(),
           &dwBytesWritten,
           NULL) == FALSE){

        // If disk is full then we should return 0 byte written and CF is clear
        dwErrCode = GetLastError();
        if(dwErrCode == ERROR_DISK_FULL) {

            setCF(0);
            setAX(0);
            return;
        }

        SetLastError(dwErrCode);

writeFailureExit:
        demClientError(hFile, (CHAR)-1);
        return ;
    }

writeSuccessExit:
    setCF(0);
    setAX((USHORT)dwBytesWritten);
    return;
}



/* demChgFilePtr - Change File Pointer
 *
 *
 * Entry - Client (AX:BP) File Handle
 *         Client (CX:DX) New Location
 *         Client (BL)    Positioning Method
 *                        0 - File Absolute
 *                        1 - Relative to Current Position
 *                        2 - Relative to end of file
 *
 * Exit
 *         SUCCESS
 *           Client (CY)    = 0
 *           Client (DX:AX) = New Location
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = system status code
 *
 */

VOID demChgFilePtr (VOID)
{
HANDLE  hFile;
LONG    lLoc;
DWORD   dwLoc;

#if (FILE_BEGIN != 0 || FILE_CURRENT != 1 || FILE_END !=2)
    #error "Win32 values not DOS compatible"
#

#endif
    hFile =  GETHANDLE (getAX(),getBP());
    lLoc  = (LONG)((((int)getCX()) << 16) + (int)getDX());

    if ((dwLoc = DPM_SetFilePointer (hFile,
                               lLoc,
                               NULL,
                               (DWORD)getBL())) == -1L){
        demClientError(hFile, (CHAR)-1);
        return ;
    }

    setCF(0);
    setAX((USHORT)dwLoc);
    setDX((USHORT)(dwLoc >> 16));
    return;
}



/* DemCommit -- Commit File(Flush file buffers)
 *
 * Entry - Client (AX:BP) File Handle
 *
 * Exit
 *         SUCCESS
 *           Client (CY)    = 0
 *           buffer flushed
 *
 *         FAILURE
 *           Client (CY) = 1
 *
 */
VOID demCommit(VOID)
{
    HANDLE  hFile;
    BOOL bRet;

    hFile = GETHANDLE(getAX(),getBP());
    bRet = DPM_FlushFileBuffers(hFile);
#if DBG
    if (!bRet) {

        //
        // FlushFileBuffers fails with access denied if the handle
        // is open for read-only access, however it's not an error
        // for DOS.
        //

        DWORD LastError;
        LastError = GetLastError();

        if (LastError != ERROR_ACCESS_DENIED) {
            sprintf(demDebugBuffer,
                    "ntvdm demCommit warning: FlushFileBuffers error %d\n",
                    LastError);
            OutputDebugStringOem(demDebugBuffer);
        }
    }
#endif

    setCF(0);

}

/* function to check if new data has been written to the file or
   if the file has been marked EOF

   Input:   Client (AX:BP) = 32bits NT file handle
   Output:  Client ZF = 1 if new data or EOF
                   CF = 1 if EOF
*/


VOID demPipeFileDataEOF(VOID)
{
    HANDLE  hFile;
    BOOL    fEOF;
    BOOL    DataEOF;
    DWORD   FileSizeLow;
    DWORD   FileSizeHigh;

    hFile = GETHANDLE(getAX(), getBP());

    DataEOF = cmdPipeFileDataEOF(hFile, &fEOF);
    if (fEOF) {
        //EOF, get file size, max size = 32bits
        FileSizeLow = GetFileSize(hFile, &FileSizeHigh);
        setAX((WORD)(FileSizeLow / 0x10000));
        setBP((WORD)FileSizeLow);
        setCF(1);                   // EOF is encountered
    }
    else
        setCF(0);
    setZF(DataEOF ? 0 : 1);
}

/* function to check if the file has been marked EOF
   Input:   Client(AX:BP) = 32bits NT file handle
   Output:  Client CY = 1 if EOF
*/

VOID demPipeFileEOF(VOID)
{
    HANDLE  hFile;
    DWORD   FileSizeLow;
    DWORD   FileSizeHigh;

    hFile = GETHANDLE(getAX(), getBP());
    if (cmdPipeFileEOF(hFile)) {
        FileSizeLow = GetFileSize(hFile, &FileSizeHigh);
        setAX((WORD)(FileSizeLow / 0x10000));   // file size in 32bits
        setBP((WORD)FileSizeLow);
        setCF(1);                   //EOF is encountered
    }
    else
        setCF(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demlabel.c ===
/* demlabel.c - functions for working this volume labels.
 *
 * demDeleteLabel()
 * demCreateLabel()
 *
 * Modification History:
 *
 * YST 1-Feb-1993 Created
 *
 */

#include "dem.h"
#include "demmsg.h"

#include <softpc.h>

#include <winbase.h>
#include "dpmtbls.h"

USHORT demDeleteLabel(BYTE Drive)
{
    CHAR szStr[32];


    sprintf(szStr, "%c:\\", Drive);

    if(!SetVolumeLabelOem(szStr, NULL))
	return(1);
    else
	return(0);
}


USHORT demCreateLabel(BYTE Drive, LPSTR lpszName)
{
    CHAR szStr[32];
    CHAR szTmp[32];
    CHAR *p, *s;
    int  i = 0;


    sprintf(szStr, "%c:\\", Drive);

    s = lpszName;
    p = szTmp;

    while(s) {
        if(*s != '.')  {
            *p = *s;
            i++;
            p++;
        }
        else {
            while(i < 8) {
                *p++ = ' ';
                i++;
            }
        }
        s++;

        if(i > 11) {
            break;
        }
    }

    szTmp[i] = '\0';

    if(!SetVolumeLabelOem(szStr, szTmp))
	    return(1);

    else
	    return(0);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demioctl.c ===
/* demioctl.c - SVC handlers for DOS IOCTL calls
 *
 * demIOCTL
 *
 * Modification History:
 *
 * Sudeepb 23-Apr-1991 Created
 *
 */

#include "dem.h"
#include "demmsg.h"

#include <softpc.h>
#include <winbase.h>
#include "demdasd.h"
#include "dpmtbls.h"

PFNSVC	apfnSVCIoctl [] = {
    demIoctlInvalid,		// IOCTL_GET_DEVICE_INFO    0
    demIoctlInvalid,		// IOCTL_SET_DEVICE_INFO    1
    demIoctlInvalid,		// IOCTL_READ_HANDLE	    2
    demIoctlInvalid,		// IOCTL_WRITE_HANDLE	    3
    demIoctlInvalid,		// IOCTL_READ_DRIVE	    4
    demIoctlInvalid,		// IOCTL_WRITE_DRIVE	    5
    demIoctlInvalid,		// IOCTL_GET_INPUT_STATUS   6
    demIoctlInvalid,		// IOCTL_GET_OUTPUT_STATUS  7
    demIoctlChangeable,		// IOCTL_CHANGEABLE	    8
    demIoctlChangeable,		// IOCTL_DeviceLocOrRem     9
    demIoctlInvalid,		// IOCTL_HandleLocOrRem     a
    demIoctlInvalid,		// IOCTL_SHARING_RETRY	    b
    demIoctlInvalid,		// GENERIC_IOCTL_HANDLE     c
    demIoctlDiskGeneric,	// GENERIC_IOCTL	    d
    demIoctlInvalid,            // IOCTL_GET_DRIVE_MAP      e
    demIoctlInvalid,		// IOCTL_SET_DRIVE_MAP	    f
    demIoctlInvalid,		// IOCTL_QUERY_HANDLE	    10
    demIoctlDiskQuery,		// IOCTL_QUERY_BLOCK	    11
    demIoctlInvalid

};

MEDIA_TYPE  MediaForFormat;

#define MAX_IOCTL_INDEX     (sizeof (apfnSVCIoctl) / sizeof (PFNSVC))


/* demIOCTL - DOS IOCTLS
 *
 *
 * Entry - depends on the subfunction. See dos\ioctl.asm
 *
 * Exit
 *	   SUCCESS
 *	     Client (CY) = 0
 *	     for other registers see the corresponding function header
 *
 *	   FAILURE
 *	     Client (CY) = 1
 *	     for other registers see the corresponding function header
 */

VOID demIOCTL (VOID)
{
ULONG	iIoctl;

    iIoctl = (ULONG) getAL();

#if DBG
    if (iIoctl >= MAX_IOCTL_INDEX){
	setAX((USHORT) ERROR_INVALID_FUNCTION);
        setCF(1);
        return;
    }
#endif

    (apfnSVCIoctl [iIoctl])();

    return;
}

/* demIoctlChangeable - Is drive removeable (subfunc 8) or remote (subfunc 9)
 *
 *
 * Entry - Client (AL) - subfunc
 *	   Client (BL) - drive number (a=0,b=1 etc)
 *
 * Exit
 *	   SUCCESS
 *	     Client (CY) = 0
 *	     if subfunc 8
 *		AX = 0	if removeable media
 *		AX = 1	otherwise
 *	     if subfunc 9
 *              DX = 0     if not remote
 *              DX = 1000  if remote
 *
 *	   FAILURE
 *	     Client (CY) = 1
 *           Client (AX) = error code
 *
 *  CDROM drives are considered remote drives with write protection
 *        by dos. (full support requires a VDD)
 */

VOID demIoctlChangeable (VOID)
{
ULONG	ulSubFunc;

CHAR	RootPathName[] = "?:\\";
DWORD   DriveType;
UCHAR   DriveNum;

    ulSubFunc = getAL();

    // Form Root path
    DriveNum = getBL();
    DriveType = demGetPhysicalDriveType(DriveNum);
    if (DriveType == DRIVE_UNKNOWN) {
        RootPathName[0] = (CHAR)('A' + DriveNum);
        DriveType = GetDriveTypeOem(RootPathName);
    }

    if (DriveType == DRIVE_UNKNOWN || DriveType == DRIVE_NO_ROOT_DIR){
	setAX (ERROR_INVALID_DRIVE);
	setCF(1);
	return;
    }

    if (ulSubFunc == IOCTL_CHANGEABLE){
#ifdef	JAPAN
	/* For MS-WORKS 2.5 */
        if (DriveType == DRIVE_REMOTE || DriveType == DRIVE_CDROM){
	    setCF(1);
	    setAX(0x000f);
	    return;
	}
#endif // JAPAN
        if(DriveType == DRIVE_REMOVABLE)
	    setAX(0);
	else
            setAX(1);  // includes CDROM drives
    }
    else {
        setAL(0);
        if (DriveType == DRIVE_REMOTE || DriveType == DRIVE_CDROM)
#ifdef	JAPAN
	/* For ICHITARO Ver.4 */
            setDH(0x10);
        else
            setDH(0);
#else // !JAPAN
            setDX(0x1000);
        else
            // We have to return 800 rather then 0 as Dos Based Quatrro pro
            // behaves very badly if this bit is not set. sudeepb 15-Jun-1994
            setDX(0x800);
#endif // !JAPAN
    }
    setCF(0);
    return;

}



/* demIoctlDiskGeneric - Block device generic ioctl
 *
 *
 * Entry - Client (BL) = drive number (a=0;b=1 etc)
 *		  (CL) = subfucntion code
 *		  (SI:DX) pointer to parameter block.
 * Exit
 *	   SUCCESS
 *	     Client (CY) = 0
 *		    (AX) = 0
 *		    parameter block updated
 *	   FAILURE
 *	     Client (CY) = 1
 *		    (AX) = error code
 */

VOID demIoctlDiskGeneric (VOID)

{
    BYTE    Code, Drive;
    PDEVICE_PARAMETERS	pdms;
    PMID      pmid;
    PRW_BLOCK pRW;
    PFMT_BLOCK pfmt;
    PBDS    pbds;
    DWORD    Head, Cylinder;
    DWORD    TrackSize;
    DWORD    Sectors, StartSector;
    BYTE    BootSector[BYTES_PER_SECTOR];
    PBOOTSECTOR pbs;
    PBPB    pBPB;
    PACCESSCTRL pAccessCtrl;
    WORD SectorSize, ClusterSize, TotalClusters, FreeClusters;

    Code = getCL();
    Drive = getBL();

    if (Code == IOCTL_GETMEDIA) {
        pmid = (PMID) GetVDMAddr(getSI(), getDX());
        if (!GetMediaId(Drive, (PVOLINFO)pmid)) {
            setAX(demWinErrorToDosError(GetLastError()));
            setCF(1);
            }
        else {
            setAX(0);
            setCF(0);
            }

        return;
        }


#ifdef	JAPAN
    /* For Ichitaro Ver.4 */
    if (!demIsDriveFloppy(Drive) && Code==IOCTL_GETDPM){
	CHAR	RootPathName[] = "?:\\";
	DWORD	dwDriveType;
	RootPathName[0] = (CHAR)('A' + getBL());
	dwDriveType = GetDriveTypeOem(RootPathName);
	if (dwDriveType == DRIVE_FIXED){
	    pdms = (PDEVICE_PARAMETERS)GetVDMAddr(getSI(), getDX());
	    pdms->DeviceType  = 5;
	    pdms->DeviceAttrs = NON_REMOVABLE;
	}
    }
#endif // JAPAN

    // if we don't know the drive, bail out
    if((pbds = demGetBDS(Drive)) == NULL && Code != IOCTL_GETDPM) {
	if (!demIsDriveFloppy(Drive))
	    host_direct_access_error(NOSUPPORT_HARDDISK);
	setAX(DOS_FILE_NOT_FOUND);
	setCF(1);
	return;
    }
    switch (Code) {
	case IOCTL_SETDPM:

		pdms = (PDEVICE_PARAMETERS)GetVDMAddr(getSI(), getDX());
		if (!(pdms->Functions & ONLY_SET_TRACKLAYOUT)) {
		    pbds->FormFactor = pdms->DeviceType;
		    pbds->Cylinders = pdms->Cylinders;
		    pbds->Flags = pdms->DeviceAttrs;
		    pbds->MediaType = pdms->MediaType;
		    if (pdms->Functions & INSTALL_FAKE_BPB) {
			pbds->Flags |= RETURN_FAKE_BPB;
			pbds->bpb = pdms->bpb;
			// update the total sectors, we need it
			// for verification
			pbds->TotalSectors = (pbds->bpb.Sectors) ?
					     pbds->bpb.Sectors :
					     pbds->bpb.BigSectors;
		    }
		    else {
			pbds->Flags &= ~RETURN_FAKE_BPB;
			pbds->rbpb = pdms->bpb;
		    }
		}
		MediaForFormat = Unknown;
		if (!(pbds->Flags & NON_REMOVABLE)){
		    nt_floppy_close(pbds->DrivePhys);
		}
		else {
		    nt_fdisk_close(pbds->DrivePhys);
		}
		break;

	case IOCTL_WRITETRACK:

		pRW = (PRW_BLOCK) GetVDMAddr(getSI(), getDX());
		Sectors = pRW->Sectors;
		StartSector = pRW->StartSector;
		StartSector += pbds->bpb.TrackSize *
			       (pRW->Cylinder * pbds->bpb.Heads + pRW->Head);
		Sectors = demDasdWrite(pbds,
				       StartSector,
				       Sectors,
				       pRW->BufferOff,
				       pRW->BufferSeg
				       );
		if (Sectors != pRW->Sectors) {
		    setAX(demWinErrorToDosError(GetLastError()));
		    setCF(1);
		    return;
		}
		break;

	    case IOCTL_FORMATTRACK:
		pfmt = (PFMT_BLOCK)GetVDMAddr(getSI(), getDX());
		Head = pfmt->Head;
		Cylinder = pfmt->Cylinder;
		if ((pbds->Flags & NON_REMOVABLE) &&
		    pfmt->Head < pbds->bpb.Heads &&
		    pfmt->Cylinder < pbds->Cylinders)
		    {
		    if (pfmt->Functions == STATUS_FOR_FORMAT){
			pfmt->Functions = 0;
			setCF(0);
			return;
		    }
		    if (!demDasdFormat(pbds, Head, Cylinder, NULL)) {
			setAX(demWinErrorToDosError(GetLastError()));
			setCF(1);
			return;
		    }
		}
		else {
		    if (MediaForFormat == Unknown) {
			demDasdFormat(pbds,
				      Head,
				      Cylinder,
				      &MediaForFormat
				      );
		    }
		    if (pfmt->Functions & STATUS_FOR_FORMAT){
			if (MediaForFormat == Unknown)
			    pfmt->Functions = 2;	// illegal combination
			else
			    pfmt->Functions = 0;
			break;
		    }
		    if (MediaForFormat == Unknown ||
			!demDasdFormat(pbds, Head, Cylinder, &MediaForFormat)) {
			setAX(demWinErrorToDosError(GetLastError()));
			setCF(1);
			return;
		    }
		}
		break;

	    case IOCTL_SETMEDIA:
		pmid = (PMID) GetVDMAddr(getSI(), getDX());

		if (pbds->Flags & NON_REMOVABLE) {
		    Sectors = nt_fdisk_read(pbds->DrivePhys,
					    0,
					    BYTES_PER_SECTOR,
					    BootSector
					    );
		}
		else {
		    if (demGetBPB(pbds))
			Sectors = nt_floppy_read(pbds->DrivePhys,
						 0,
						 BYTES_PER_SECTOR,
						 BootSector
						 );
		    else
			Sectors = 0;
		}
		pbs = (PBOOTSECTOR) BootSector;
		if (Sectors != BYTES_PER_SECTOR ||
		    pbs->ExtBootSig != EXT_BOOTSECT_SIG)
		    {
		    setAX(demWinErrorToDosError(GetLastError()));
		    setCF(1);
		    return;
		}
		pbs->SerialNum = pmid->SerialNum;
		pbs->Label = pmid->Label;
		pbs->FileSysType = pmid->FileSysType;
		if (pbds->Flags & NON_REMOVABLE) {
		    Sectors = nt_fdisk_write(pbds->DrivePhys,
					     0,
					     BYTES_PER_SECTOR,
					     (PBYTE)pbs
					     );
		    nt_fdisk_close(pbds->DrivePhys);
		}
		else {
		    Sectors = nt_floppy_write(pbds->DrivePhys,
					      0,
					      BYTES_PER_SECTOR,
					      (PBYTE) pbs
					      );
		    nt_floppy_close(pbds->DrivePhys);
		}
		if (Sectors != BYTES_PER_SECTOR) {
		    setAX(demWinErrorToDosError(GetLastError()));
		    setCF(1);
		    return;
		}
		break;


	    // ioctl get device parameters
	    case IOCTL_GETDPM:
		pdms = (PDEVICE_PARAMETERS)GetVDMAddr(getSI(), getDX());
		// if we couldn't find the bds, fake one
		if (pbds == NULL) {
		    HANDLE	  hVolume;
		    CHAR	  achRoot[]="\\\\.\\?:";
		    DISK_GEOMETRY DiskGM;
		    DWORD	  SizeReturned;

		    if (!demGetDiskFreeSpace(Drive,
					    &SectorSize,
					    &ClusterSize,
					    &TotalClusters,
					    &FreeClusters
					    )){
			setAX(demWinErrorToDosError(GetLastError()));
			setCF(1);
			return;
		    }

		    achRoot[4] = Drive + 'A';

		    hVolume = DPM_CreateFile(achRoot,
					  FILE_READ_ATTRIBUTES | SYNCHRONIZE,
					  FILE_SHARE_READ | FILE_SHARE_WRITE,
					  NULL,
					  OPEN_EXISTING,
					  0,
					  NULL);
		    if (hVolume == INVALID_HANDLE_VALUE) {
			setAX(demWinErrorToDosError(GetLastError()));
			setCF(1);
			return;
		    }
		    if (!DeviceIoControl(hVolume,
					 IOCTL_DISK_GET_DRIVE_GEOMETRY,
					 NULL,
					 0,
					 &DiskGM,
					 sizeof(DISK_GEOMETRY),
					 &SizeReturned,
					 NULL
					 )) {
			DPM_CloseHandle(hVolume);
			setAX(demWinErrorToDosError(GetLastError()));
			setCF(1);
			return;
		    }
		    DPM_CloseHandle(hVolume);
		    Sectors = DiskGM.Cylinders.LowPart *
			      DiskGM.TracksPerCylinder *
			      DiskGM.SectorsPerTrack;
		    pdms->DeviceType = FF_FDISK;
		    pdms->DeviceAttrs = NON_REMOVABLE;
		    pdms->MediaType = 0;
		    pdms->bpb.SectorSize = SectorSize;
                    pdms->bpb.ClusterSize = (BYTE) ClusterSize;
		    pdms->bpb.ReservedSectors = 1;
		    pdms->bpb.FATs = 2;
		    pdms->bpb.RootDirs = (Sectors > 32680) ? 512 : 64;
		    pdms->bpb.MediaID = 0xF8;
                    pdms->bpb.TrackSize = (WORD) DiskGM.SectorsPerTrack;
                    pdms->bpb.Heads = (WORD) DiskGM.TracksPerCylinder;
                    pdms->Cylinders = (WORD) DiskGM.Cylinders.LowPart;
		    if (Sectors >= 40000) {
			TrackSize = 256 * ClusterSize + 2;
                        pdms->bpb.FATSize = (WORD) ((Sectors - pdms->bpb.ReservedSectors
					     - pdms->bpb.RootDirs * 32 / 512 +
                                             TrackSize - 1 ) / TrackSize);
		    }
		    else {
                        pdms->bpb.FATSize = (WORD) (((Sectors / ClusterSize) * 3 / 2) /
                                            512 + 1);
		    }
		    pdms->bpb.HiddenSectors = Sectors;
		    Sectors = TotalClusters * ClusterSize;
		    if (Sectors >= 0x10000) {
			pdms->bpb.Sectors = 0;
			pdms->bpb.BigSectors = Sectors;
		    }
		    else {
                        pdms->bpb.Sectors = (WORD) Sectors;
			pdms->bpb.BigSectors = 0;
		    }
		    pdms->bpb.HiddenSectors -= Sectors;
		    break;
		}
		pdms->DeviceType = pbds->FormFactor;
		pdms->DeviceAttrs = pbds->Flags & ~(HAS_CHANGELINE);
		pdms->Cylinders = pbds->Cylinders;
		pdms->MediaType = 0;
		if (pdms->Functions & BUILD_DEVICE_BPB){
		    if (!(pbds->Flags & NON_REMOVABLE) &&
			!demGetBPB(pbds)) {
			setAX(demWinErrorToDosError(GetLastError()));
			setCF(1);
			return;
		    }
		    pBPB = &pbds->bpb;
		}
		else
		    // copy recommended bpb
		    pBPB = &pbds->rbpb;

		pdms->bpb = *pBPB;
		break;

	    case IOCTL_READTRACK:
		pRW = (PRW_BLOCK) GetVDMAddr(getSI(), getDX());
		Sectors = pRW->Sectors;
		StartSector = pRW->StartSector;
		StartSector += pbds->bpb.TrackSize *
			       (pRW->Cylinder * pbds->bpb.Heads + pRW->Head);
		Sectors = demDasdRead(pbds,
				      StartSector,
				      Sectors,
				      pRW->BufferOff,
				      pRW->BufferSeg
				      );

		if (Sectors != pRW->Sectors) {
		    setAX(demWinErrorToDosError(GetLastError()));
		    setCF(1);
		    return;
		}
		break;

	    case IOCTL_VERIFYTRACK:
		pfmt = (PFMT_BLOCK) GetVDMAddr(getSI(), getDX());
		if(!demDasdVerify(pbds,  pfmt->Head, pfmt->Cylinder)) {
		    setAX(demWinErrorToDosError(GetLastError()));
		    setCF(1);
		    return;
		}
		break;

            case IOCTL_GETACCESS:
		    pAccessCtrl = (PACCESSCTRL) GetVDMAddr(getSI(), getDX());
		    pAccessCtrl->AccessFlag = (pbds->Flags & UNFORMATTED_MEDIA) ?
					       0 : 1;
		    break;
	    case IOCTL_SETACCESS:
		    pAccessCtrl = (PACCESSCTRL) GetVDMAddr(getSI(), getDX());
		    pbds->Flags &= ~(UNFORMATTED_MEDIA);
		    if (pAccessCtrl->AccessFlag == 0)
			pAccessCtrl->AccessFlag |= UNFORMATTED_MEDIA;
		    break;

	    default:
		setAX(DOS_INVALID_FUNCTION);
		setCF(1);
		return;
	}
    setAX(0);
    setCF(0);
}

/* demIoctlDiskQuery - Query block device generic ioctl capability
 *
 *
 * Entry - Client (BL) = drive number (a=0;b=1 etc)
 *		  (CL) = generic ioctl subfuntion to be queried
 * Exit
 *	   SUCCESS
 *	     Client (CY) = 0
 *		   The specific ioctl is supported
 *	   FAILURE
 *	     Client (CY) = 1
 *		    The given ioctl is not supported
 */

VOID demIoctlDiskQuery (VOID)
{
    BYTE    Code, Drive;

    Code = getCL();
    Drive = getBL();
    if (demGetBDS(Drive) == NULL) {
	setAX(DOS_FILE_NOT_FOUND);
	setCF(1);
	return;
    }
    switch (Code) {

	case IOCTL_SETDPM:
	case IOCTL_WRITETRACK:
	case IOCTL_FORMATTRACK:
	case IOCTL_SETMEDIA:
	case IOCTL_GETDPM:
	case IOCTL_READTRACK:
	case IOCTL_VERIFYTRACK:
	case IOCTL_GETMEDIA:
//	case IOCTL_GETACCESS:
//	case IOCTL_SETACCESS:
		setAX(0);
		setCF(0);
		break;
	default:
		setAX(DOS_ACCESS_DENIED);
		setCF(1);
		break;
    }
}


/* demIoctlInvalid - For those subfunctions which may be implemented later
 *
 *
 * Entry -
 *
 * Exit
 *	     Client (CY) = 1
 *	     Client (AX) = error_invalid_function
 */


VOID demIoctlInvalid (VOID)
{
    setCF(1);
    setAX(ERROR_INVALID_FUNCTION);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demmsg.c ===
/* demmsg.c - debug messages handling for DEM
 *
 * Modification History
 *
 * Sudeepb 31-Mar-1991 Created
 */
#if DBG

#include <stdio.h>
#include "demmsg.h"
#include "dem.h"

PCHAR   aMsg [] = {
    "DOS Location Not Found. Using Default.\n",
    "Read On NTDOS.SYS Failed.\n",
    "Open On NTDOS.SYS Failed.\n",
    "EAs Not Supported\n",
    "Letter mismatch in Set_Default_Drive\n",
    "Volume ID support is missing\n",
    "Invalid Date Time Format for NT\n",
    "DTA has an Invalid Find Handle for FINDNEXT\n",
    "Unexpected failure to get file information\n",
    "File Size is too big for DOS\n"
};


/* demPrintMsg - Print Debug Message
 *
 * Entry - iMsg (Message Index; See demmsg.h)
 *
 * Exit  - None
 *
 */

VOID demPrintMsg (ULONG iMsg)
{

    if (fShowSVCMsg){
       sprintf(demDebugBuffer,aMsg[iMsg]);
       OutputDebugStringOem(demDebugBuffer);
    }

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demlock.c ===
/* demlock.c - SVC handler for file file locking calls
 *
 * demLockOper
 *
 * Modification History:
 *
 * Sudeepb 07-Aug-1992 Created
 */

#include "dem.h"
#include "demmsg.h"

#include <softpc.h>
#include "dpmtbls.h"

/* demLockOper - Lock or Unlock the file data
 *
 * Entry    Client(AX) : Lock = 0 Unlock = 1
 *	    Client(BX:BP) : NT Handle
 *	    Client(CX:DX) : offset in the file
 *	    Client(SI:DI) : Data Length to be locked
 * Exit
 *	    SUCCESS: Client CF = 0
 *	    FAILURE: Client CF = 1
 */

VOID demLockOper (VOID)
{
HANDLE	hFile;
DWORD	dwFileOffset,cbLock;

    // Collect all the parameters
    hFile = GETHANDLE(getBX(),getBP());
    dwFileOffset = GETULONG (getCX(),getDX());
    cbLock = GETULONG (getSI(),getDI());

    if(getAL() == 0){  // Locking case
	if (DPM_LockFile (hFile,
		      dwFileOffset,
		      0,
		      cbLock,
		      0
		     ) == TRUE) {
	    setCF (0);
	    return;
	}
    }
    else {
	if (DPM_UnlockFile (hFile,
			dwFileOffset,
			0,
			cbLock,
			0
		       ) == TRUE) {
	    setCF (0);
	    return;
	}
    }

    // Operation failed
    demClientError(hFile, (CHAR)-1);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demlfn.c ===
/* demlfn.c - SVC handler for calls that use lfns
 *
 *
 * Modification History:
 *
 * VadimB 10-Sep-1996 Created
 * VadimB Sep-Oct 1996 Functionality added
 *
 */

#include "dem.h"
#include "demmsg.h"
#include "winbasep.h"
#include <vdm.h>
#include <softpc.h>
#include <mvdm.h>
#include <memory.h>
#include <nt_vdd.h>
#include "demlfn.h"
#include "dpmtbls.h"

//
// locally used function
//
DWORD dempLFNCheckDirectory(PUNICODE_STRING pPath);

//
// Global Variables
// (initialized in dempInitLFNSupport)
//
//

UNICODE_STRING DosDevicePrefix;
UNICODE_STRING DosDeviceUNCPrefix;
UNICODE_STRING SlashSlashDotSlash;
UNICODE_STRING ColonSlashSlash;


// this is zero-time for dos in terms of convertability

FILETIME gFileTimeDos0;

//
// Search handle table (see demlfn.h for definitions)
//

DemSearchHandleTable gSearchHandleTable;

//
// Dos/WOW variables (curdir&drive mostly)
//
DOSWOWDATA DosWowData; // this is same exactly as used by wow in wdos.c


#ifdef DBG

/* Function:
 *    dempLFNLog
 *
 *
 */

DWORD gdwLog;

VOID __cdecl dempLFNLog(
   PCHAR pFormat,
   ...)
{
   va_list va;
   CHAR LogStr[512];

   if (gdwLog) {
      va_start(va, pFormat);
      wvsprintf(LogStr, pFormat, va);
      OutputDebugStringOem(LogStr);
   }
}

#else
#define dempLFNLog //
#endif


//
// String Convertion
//
// Define OEM/Ansi->Unicode and Unicode->OEM/Ansi translation functions
//
//

PFNUNICODESTRINGTODESTSTRING pfnUnicodeStringToDestString;
PFNSRCSTRINGTOUNICODESTRING  pfnSrcStringToUnicodeString;

#define ENABLE_CONDITIONAL_TRANSLATION

/*
 * These two macros establish a dependency on oem/ansi api translation
 * WOW32 calls into us and tells us to be ansi. all support is totally
 * transparent.
 *
 */

#define DemSourceStringToUnicodeString(pUnicodeString, pSourceString, fAllocate) \
(*pfnSrcStringToUnicodeString)(pUnicodeString, pSourceString, fAllocate)

#define DemUnicodeStringToDestinationString(pDestString, pUnicodeString, fAllocate, fVerify) \
(*pfnUnicodeStringToDestString)(pDestString, pUnicodeString, fAllocate, fVerify)


/* Function:
 *    DemUnicodeStringToOemString
 *    Convert Unicode counted string to Oem counted string with verification for
 *    bad characters. Verification is provided by RtlUnicodeStringToCountedOemString.
 *    At the same time the aforementioned api does not 0-terminate the dest string.
 *    This function does 0-termination (given the dest string has enough space).
 *
 *    If Translation does not need to be verified then speedier version of the
 *    convertion api is called
 *
 * Parameters
 *    pOemString         - points to a destination oem counted string structure
 *    pUnicodeString     - points to a source unicode counted string
 *    fAllocateResult    - if TRUE, then storage for the resulting string will
 *                         be allocated
 *    fVerifyTranslation - if TRUE, then converted string will be verified for
 *                         correctness (and appropriate status will be returned)
 */


NTSTATUS
DemUnicodeStringToOemString(
   POEM_STRING pOemString,
   PUNICODE_STRING pUnicodeString,
   BOOLEAN fAllocateResult,
   BOOLEAN fVerifyTranslation)
{
   NTSTATUS dwStatus;

   if (fVerifyTranslation) {
      PUCHAR pchBuffer = NULL;

      if (!fAllocateResult && pOemString->MaximumLength > 0) {
         pchBuffer = pOemString->Buffer;
      }

      dwStatus = RtlUnicodeStringToCountedOemString(pOemString, pUnicodeString, fAllocateResult);
      if (NT_SUCCESS(dwStatus)) {
         if (pOemString->Length < pOemString->MaximumLength) {
            pOemString->Buffer[pOemString->Length] = '\0';
         }
         else {
            if (NULL == pOemString->Buffer) { // source string was empty
               if (NULL != pchBuffer) {
                  *pchBuffer = '\0'; // terminate if there was a buffer
               }
            }
            else {
               return(STATUS_BUFFER_OVERFLOW);
            }
         }
      }
   }
   else {
      dwStatus = RtlUnicodeStringToOemString(pOemString, pUnicodeString, fAllocateResult);
   }

   return(dwStatus);
}

/* Function:
 *    DemUnicodeStringToAnsiString
 *    Convert Unicode counted string to Ansi counted string with verification for
 *    bad characters. Note, that verification IS NOT provided by the corresponding
 *    Rtl* api, thus is it never performed(!!!)
 *
 * Parameters
 *    pOemString         - points to a destination oem counted string structure
 *    pUnicodeString     - points to a source unicode counted string
 *    fAllocateResult    - if TRUE, then storage for the resulting string will
 *                         be allocated
 *    fVerifyTranslation - if TRUE, then converted string will be verified for
 *                         correctness (and appropriate status will be returned)
 *
 * Note
 *    This function does not provide verification.
 */


NTSTATUS
DemUnicodeStringToAnsiString(
   PANSI_STRING pAnsiString,
   PUNICODE_STRING pUnicodeString,
   BOOLEAN fAllocateResult,
   BOOLEAN fVerifyTranslation)
{
   return(RtlUnicodeStringToAnsiString(pAnsiString, pUnicodeString, fAllocateResult));
}


/* Function:
 *    demSetLFNApiTranslation
 *    Sets api translation to be Oem or Ansi. Windows seems to want apis to be
 *    Ansi while dos apps require Oem translation. This function allows WOW to
 *    set the appropriate translation at startup
 *
 * Parameters
 *    fIsAnsi - if TRUE, all LFN apis will provide Ansi translation
 *
 *
 *
 */


VOID
demSetLFNApiTranslation(BOOL fIsAnsi)
{
   if (fIsAnsi) {
      pfnUnicodeStringToDestString = (PFNUNICODESTRINGTODESTSTRING) DemUnicodeStringToAnsiString;
      pfnSrcStringToUnicodeString  = (PFNSRCSTRINGTOUNICODESTRING)  DemAnsiStringToUnicodeString;
   }
   else {
      pfnUnicodeStringToDestString = (PFNUNICODESTRINGTODESTSTRING) DemUnicodeStringToOemString;
      pfnSrcStringToUnicodeString  = (PFNSRCSTRINGTOUNICODESTRING)  DemOemStringToUnicodeString;
   }
}

/*
 * Function:
 *    dempGetDosUserEnvironment
 *    Retrieves user stack top from the current process's pdb
 *    see msdisp.asm for details,
 *    ss is at psp:0x30 and sp is at psp:0x2e
 *    Registers are at offsets represented by enumDemUserRegisterOffset
 *
 * Parameters:
 *    fProtectedMode - TRUE if emulator is in 386 protected mode
 *    Uses pusCurrentPDB
 *
 * Return:
 *    Flat pointer to the user stack top
 *
 *
 */

PVOID
dempGetDosUserEnvironment(VOID)
{
   USHORT wPSP;
   PBYTE  pPDB;

   wPSP = *pusCurrentPDB;
   pPDB = (PBYTE)GetVDMAddr(wPSP, 0);
   return((PVOID)GetVDMAddr(*(PUSHORT)(pPDB+0x30), *(PUSHORT)(pPDB+0x2e)));
}


/* NOTES:
 *
 * - On caution when using UNICODE_STRING
 *     A lot of the functions here rely upon Rtl* functions including some
 *     that provide UNICODE_STRING functionality. These functions, unlike one
 *     would have to expect use notion of Length - it is measured in
 *     BYTES not characters.
 *
 * - On return values from worker fns
 *     Throughout this code we use Win32 error codes and nt status codes
 *     Having both aroung can be fun, thus we generally return error codes in
 *     a status code format, making all the return values consistent
 *
 * - On naming convention:
 *     All functions that are internal and are not called directly from within
 *     api dispatching code (such as real working functions for all the apis)
 *     have prefix 'demp' (dem private), other functions that are callable from
 *     within fast thunks (such as for wow32.dll - protected mode windows app)
 *     have the usual prefix 'dem'
 */


/*

   Functions:

   Dos Extentions

   i21h 4302    - GetCompressedFileSize
   i21h 440d 48 - LockUnlockRemovableMedia
   i21h 440d 49 - EjectRemovableMedia
   i21h 440d 6f - GetDriveMapInformation
   i21h 440d 71 - GetFirstCluster - should not be implemented

   LFN

   i21h *5704    - GetFileTimeLastAccess
        *5705    - SetFileTimeLastAccess
        *5706    - GetFileTimeCreation
        *5707    - SetFileTimeCreation
        *7139    - CreateDirectory
        *713a    - RemoveDirectory
        *713b    - SetCurrentDirectory
        *7141    - DeleteFile
        *7143    - SetGetFileAttributes
        *7147    - GetCurrentDirectory
        *714e    - FindFirstFile
        *714f    - FindNextFile
        *7156    - MoveFile
        *7160 0  - GetFullPathName
        *7160 1  - GetShortPathName
        *7160 2  - GetLongPathName
        *716c    - CreateOpenFile
        *71a0    - GetVolumeInformation
        *71a1    - FindClose
        *71a6    - GetFileInformationByHandle
        *71a7 0  - FileTimeToDosDateTime
        *71a7 1  - DOSDateTimeToFileTime
        71a8    - GenerateShortFileName *** no impl
        71a9    - ServerCreateOpenFile
        *71aa 0  - CreateSubst
        *71aa 1  - TerminateSubst
        *71aa 2  - QuerySubst

*/

#if 0

typedef struct tagCLOSEAPPSTATE {
   DWORD dwFlags;
   FILETIME CloseCmdTime;
}  CLOSEAPPSTATE;

#define CLOSESTATE_QUERYCALLED    0x00000001UL // app has called QueryClose at least once
#define CLOSESTATE_CLOSECMD       0x00010000UL // close command was chosen
#define CLOSESTATE_APPGOTCLOSE    0x00020000UL // app received close notify
#define CLOSESTATE_CLOSEACK       0x01000000UL // close cmd


CLOSEAPPSTATE GlobalCloseState;

// handle variour close apis

VOID dempLFNHandleClose(
   VOID)
{
   switch(getDX()) {
   case 1: // query close
      GlobalCloseState.dwFlags |= CLOSESTATE_QUERYCALLED;
      if (GlobalCloseState.dwFlags & CLOSESTATE_CLOSECMD) {
         // bummer
      }
      break;

   case 2: // ack close
      GlobalCloseState.dwFlags |= CLOSESTATE_CLOSEACK;
      break;

   case 3: // cancel close
      GlobalCloseState.dwFlags |= CLOSESTATE_CLOSECANCEL;
      break;
}



BOOL dempCompareTimeInterval(
   FILETIME* pTimeStart,
   FILETIME* pTimeEnd,
   DWORD dwIntervalMilliseconds)
{
   LARGE_INTEGER TimeStart;
   LARGE_INTEGER TimeEnd;

   TimeStart.LowPart  = pTimeStart->dwLowDateTime;
   TimeStart.HighPart = pTimeStart->dwHighDateTime;

   TimeEnd.LowPart  = pTimeEnd->dwLowDateTime;
   TimeEnd.HighPart = pTimeEnd->dwHighDateTime;

   return(((TimeEnd.QuadPart - TimeStart.QuadPart) * 1000 * 10) <
          (LONGLONG)dwIntervalMilliseconds);
}

#define DOS_APP_CLOSE_TIMEOUT 5000 // 5s

//
// This is how  we handle query close calls
//
//    Upon receiving a ctrl_close_event we set the global flag and wait
//    when pinged by app with query close
//
//


BOOL dempLFNConsoleCtrlHandler(
   DWORD dwCtrlType)
{
   FILETIME SysTime;

   switch(dwCtrlType) {
   case CTRL_CLOSE_EVENT:


      // -- set the flag
      // -- return true



      // this is the only event we are interested in

      if (GlobalCloseState.dwFlags & CLOSESTATE_CLOSECMD) {

         if (GlobalCloseState.dwFlags & CLOSESTATE_CLOSEACK) {
            // allow 1 sec from close ack to either close or die


         }

          !(GlobalCloseState.dwFlags & CLOSESTATE_APPRECEIVEDCLOSE))

         // another close event - after the first one -
         // and in these 5sec app has not called queryclose -
         // then handle by default

         GetSystemTimeAsFileTime(&SysTime);
         if (dempCompareTimeInterval(&GlobalCloseState.CloseCmdTime,
                                     &SysTime,
                                     DOS_APP_CLOSE_TIMEOUT))
            return(


         }





      }


      // set the flag so we can signal the app
      if (GlobalCloseState.dwFlags & CLOSESTATE_QUERYCALLED) {
         GlobalCloseState.dwFlags |= CLOSESTATE_CLOSECMD


      }




   }




}

// if the handler is not installed, then we don't care ...

VOID
demLFNInstallCtrlHandler(VOID)
{
   if (!VDMForWOW) {
      SetConsoleCtrlHandler(dempLFNConsoleCtrlHandler, TRUE);
   }
}

#endif

/*
 * Function:
 *    dempInitLFNSupport
 *    Initializes LFN (Long File Names) support for NT DOS emulation
 *    (global vars). Called from demInit in dem.c
 *
 *    This function sets api translation to OEM.
 *
 */


VOID
dempInitLFNSupport(
   VOID)
{
   TIME_FIELDS TimeFields;
   LARGE_INTEGER ft0;

   RtlInitUnicodeString(&DosDevicePrefix,    L"\\??\\");
   RtlInitUnicodeString(&DosDeviceUNCPrefix, L"\\??\\UNC\\");
   RtlInitUnicodeString(&SlashSlashDotSlash, L"\\\\.\\");
   RtlInitUnicodeString(&ColonSlashSlash,    L":\\\\");


   demSetLFNApiTranslation(FALSE); // set api to oem mode

   // init important time conversion constants
   RtlZeroMemory(&TimeFields, sizeof(TimeFields));
   TimeFields.Year  = (USHORT)1980;
   TimeFields.Month = 1;
   TimeFields.Day   = 1;
   RtlTimeFieldsToTime(&TimeFields, &ft0);
   gFileTimeDos0.dwLowDateTime = ft0.LowPart;
   gFileTimeDos0.dwHighDateTime = ft0.HighPart;

   // now initialize our control handler api
   // we are watching for a 'close' call with an assumption
   // app will be doing QueryClose calls

#if 0
   demLFNInstallCtrlHandler();
#endif
}

/*
 * Function:
 *    dempStringInitZeroUnicode
 *    Initializes an empty Unicode counted string given the pointer
 *    to the character buffer
 *
 * Parameters:
 *    IN OUT pStr       - unicode counted string
 *    IN pwsz           - pointer to the string buffer
 *    IN nMaximumLength - size (in BYTES) of the buffer pointed to by pwsz
 *
 * Returns:
 *    NOTHING
 *
 */

VOID
dempStringInitZeroUnicode(
   PUNICODE_STRING pStr,
   PWSTR pwsz,
   USHORT nMaximumLength)
{
   pStr->Length = 0;
   pStr->MaximumLength = nMaximumLength;
   pStr->Buffer = pwsz;
   if (NULL != pwsz) {
      pwsz[0] = UNICODE_NULL;
   }
}


/*
 * Function:
 *    dempStringPrefixUnicode
 *    Verifies if a string is a prefix in another unicode counted string
 *    Equivalent to RtlStringPrefix
 *
 * Parameters:
 *    IN StrPrefix - unicode counted string - prefix
 *    IN String    - unicode counted string to check for prefix
 *    IN CaseInSensitive - whether the comparison should be case insensitive
 *       TRUE - case insensitive
 *       FALSE- case sensitive
 *
 * Returns:
 *    TRUE - String contains StrPrefix at it's start
 *
 */

BOOL
dempStringPrefixUnicode(
   PUNICODE_STRING pStrPrefix,
   PUNICODE_STRING pString,
   BOOL CaseInSensitive)
{
   PWSTR ps1, ps2;
   UINT n;
   WCHAR c1, c2;

   n = pStrPrefix->Length;
   if (pString->Length < n) {
      return(FALSE);
   }

   n /= sizeof(WCHAR); // convert to char count

   ps1 = pStrPrefix->Buffer;
   ps2 = pString->Buffer;

   if (CaseInSensitive) {
      while (n--) {
         c1 = *ps1++;
         c2 = *ps2++;

         if (c1 != c2) {
            c1 = RtlUpcaseUnicodeChar(c1);
            c2 = RtlUpcaseUnicodeChar(c2);
            if (c1 != c2) {
               return(FALSE);
            }
         }
      }
   }
   else {
      while (n--) {
         if (*ps1++ != *ps2++) {
            return(FALSE);
         }
      }

   }

   return(TRUE);
}

/*
 * Function:
 *    dempStringDeleteCharsUnicode
 *    Removes specified number of characters from a unicode counted string
 *    starting at specified position (including starting character)
 *
 * Parameters:
 *    IN OUT pStringDest - unicode counted string to operate on
 *    IN nIndexStart     - starting byte for deletion
 *    IN nLength         - number of bytes to be removed
 *
 * Returns:
 *    TRUE - characters were removed
 *    FALSE- starting position exceeds string length
 *
 */


BOOL
dempStringDeleteCharsUnicode(
   PUNICODE_STRING pStringDest,
   USHORT nIndexStart,
   USHORT nLength)
{
   if (nIndexStart > pStringDest->Length) { // start past length
      return(FALSE);
   }

   if (nLength >= (pStringDest->Length - nIndexStart)) {
      pStringDest->Length = nIndexStart;
      *(PWCHAR)((PUCHAR)pStringDest->Buffer + nIndexStart) = UNICODE_NULL;
   }
   else
   {
      USHORT nNewLength;

      nNewLength = pStringDest->Length - nLength;

      RtlMoveMemory((PUCHAR)pStringDest->Buffer + nIndexStart,
                    (PUCHAR)pStringDest->Buffer + nIndexStart + nLength,
                    nNewLength - nIndexStart);

      pStringDest->Length = nNewLength;
      *(PWCHAR)((PUCHAR)pStringDest->Buffer + nNewLength) = UNICODE_NULL;
   }

   return(TRUE);
}

/*
 * Function:
 *    dempStringFindLastChar
 *    implements strrchr - finds the last occurence of a character in
 *    unicode counted string
 *
 * Parameters
 *    pString - target string to search
 *    wch     - Unicode character to look for
 *    CaseInSensitive - if TRUE, search is case insensitive
 *
 * Returns
 *    Index of the character in the string or -1 if char
 *    could not be found. Index is (as always with counted strings) is bytes,
 *    not characters
 *
 */

LONG
dempStringFindLastChar(
   PUNICODE_STRING pString,
   WCHAR wch,
   BOOL CaseInSensitive)
{
   INT Index = (INT)UNICODESTRLENGTH(pString);
   PWCHAR pBuffer = (PWCHAR)((PUCHAR)pString->Buffer + pString->Length);
   WCHAR c2;

   if (CaseInSensitive) {
      wch = RtlUpcaseUnicodeChar(wch);

      while (--Index >= 0) {
         c2 = *--pBuffer;

         c2 = RtlUpcaseUnicodeChar(c2);
         if (wch == c2) {
            return((LONG)(Index << 1));
         }
      }
   }
   else {
      while (--Index >= 0) {
          if (wch == (*--pBuffer)) {
             return((LONG)(Index << 1));
          }
      }
   }

   return(-1);
}

/*
 * Function:
 *    This function checks LFN path for abnormalities, such as a presence of
 *    a drive letter followed by a :\\ such as in d:\\mycomputer\myshare\foo.txt
 *    subsequently d: is removed
 *
 * Parameters:
 *    IN OUT pPath      - unicode path
 *
 * Returns:
 *    NOTHING
 *
 */
VOID dempLFNNormalizePath(
   PUNICODE_STRING pPath)
{
   UNICODE_STRING PathNormal;

   if (pPath->Length > 8) { // 8 as in "d:\\"

      RtlInitUnicodeString(&PathNormal, pPath->Buffer + 1);
      if (dempStringPrefixUnicode(&ColonSlashSlash, &PathNormal, TRUE)) {
         dempStringDeleteCharsUnicode(pPath, 0, 2 * sizeof(WCHAR));
      }

   }

}


/*
 * Function:
 *    dempQuerySubst
 *    Verify if drive is a subst (sym link) and return the base path
 *    for this drive.
 *    Uses QueryDosDeviceW api which does exactly what we need
 *    Checks against substed UNC devices and forms correct unc path
 *    Function works on Unicode counted strings
 *
 * Parameters:
 *    IN  wcDrive    - Drive Letter to be checked
 *    OUT pSubstPath - Buffer that will receive mapping if the drive is substed
 *                     should contain sufficient buffer
 *
 * Returns:
 *    The status value (maybe Win32 error wrapped in)
 *    STATUS_SUCCESS     - Drive is substed and mapping was put into SubstPath
 *    ERROR_NOT_SUBSTED - Drive is not substed
 *    or the error code
 *
 */

NTSTATUS
dempQuerySubst(
   WCHAR wcDrive, // dos drive letter to inquire
   PUNICODE_STRING pSubstPath)
{
   WCHAR wszDriveStr[3];
   DWORD dwStatus;

   wszDriveStr[0] = wcDrive;
   wszDriveStr[1] = L':';
   wszDriveStr[2] = UNICODE_NULL;

   dwStatus = DPM_QueryDosDeviceW(wszDriveStr,
                              pSubstPath->Buffer,
                              pSubstPath->MaximumLength/sizeof(WCHAR));
   if (dwStatus) {

      // fix the length (in BYTES) - QueryDosDeviceW returns 2 chars more then
      // the length of the string

      pSubstPath->Length = (USHORT)(dwStatus - 2) * sizeof(WCHAR);

      // see if we hit a unc string there

      if (dempStringPrefixUnicode(&DosDeviceUNCPrefix, pSubstPath, TRUE)) {


         // This is a unc name - convert to \\<uncname>
         // if we hit this code - potential trouble, as win95
         // does not allow for subst'ing unc names
         dempStringDeleteCharsUnicode(pSubstPath,
                                      (USHORT)0,
                                      (USHORT)(DosDeviceUNCPrefix.Length - 2 * sizeof(WCHAR)));

         pSubstPath->Buffer[0] = L'\\';
         dwStatus = STATUS_SUCCESS;

      }  //  string is not prefixed by <UNC\>
      else
      if (dempStringPrefixUnicode(&DosDevicePrefix, pSubstPath, TRUE)) {

         dempStringDeleteCharsUnicode(pSubstPath,
                                      0,
                                      DosDevicePrefix.Length);
         dwStatus = STATUS_SUCCESS;

      }  // string is not prefixed by <\??\>
      else {
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_NOT_SUBSTED);
      }

   }
   else {
      dwStatus = GET_LAST_STATUS();
   }

   return(dwStatus);
}

/*
 * Function:
 *    dempExpandSubst
 *    Verify if the full path that is passed in relates to a substed drive
 *    and expands the substed drive mapping
 *    Optionally converts subst mapping to a short form
 *    Win95 always removes the terminating backslash from the resulting path
 *    after the expansion hence this function should do it as well
 *
 * Parameters:
 *    IN OUT pPath      - Full path to be verified/expanded
 *    IN fShortPathName - expand path in a short form
 *
 * Returns:
 *    ERROR_SUCCESS         - Drive is substed and mapping was put into SubstPath
 *    ERROR_NOT_SUBSTED     - Drive is not substed
 *    ERROR_BUFFER_OVERFLOW - Either subst mapping or the resulting path is too long
 *    or the error code if invalid path/etc
 *
 */

NTSTATUS
dempExpandSubst(
   PUNICODE_STRING pPath,
   BOOL fShortPathName)
{
   UNICODE_STRING SubstPath;
   DWORD dwStatus;
   WCHAR wszSubstPath[MAX_PATH];
   WORD  wCharType;

   PWSTR pwszPath = pPath->Buffer;

   // check if we have a canonical dos path in Path
   // to do so we
   // - check that the first char is alpha
   // - check that the second char is ':'
   if ( !GetStringTypeW(CT_CTYPE1,
                             pwszPath,
                             1,
                             &wCharType)) {
       // Couldn't get string type
       // assuming Drive is not substed

       return(NT_STATUS_FROM_WIN32(GetLastError()));
   }

   if (!(C1_ALPHA & wCharType) || L':' != pwszPath[1]) {
      // this could have been a unc name
      // or something weird
      return(NT_STATUS_FROM_WIN32(ERROR_NOT_SUBSTED));
   }

   dempStringInitZeroUnicode(&SubstPath,
                             wszSubstPath,
                             sizeof(wszSubstPath));

   dwStatus = dempQuerySubst(*pwszPath, &SubstPath);
   if (NT_SUCCESS(dwStatus)) {
      USHORT nSubstLength = SubstPath.Length;

      // see if we need a short path
      if (fShortPathName) {
         dwStatus = GetShortPathNameW(wszSubstPath, // this is SubstPath counted string
                                      wszSubstPath,
                                      ARRAYCOUNT(wszSubstPath));

         CHECK_LENGTH_RESULT(dwStatus, ARRAYCOUNT(wszSubstPath), nSubstLength);

         if (!NT_SUCCESS(dwStatus)) {
            return(dwStatus);
         }

         // nSubstLength is set to the length of a string
      }


      // okay - we have a subst there
      // replace now a <devletter><:> with a subst
      if (L'\\' == *(PWCHAR)((PUCHAR)wszSubstPath + nSubstLength - sizeof(WCHAR))) {
         nSubstLength -= sizeof(WCHAR);
      }

      // see if we might overflow the destination string
      if (pPath->Length + nSubstLength - 2 * sizeof(WCHAR) > pPath->MaximumLength) {
         return(NT_STATUS_FROM_WIN32(ERROR_BUFFER_OVERFLOW));
      }


      // now we have to insert the right subst path in
      // move stuff to the right in the path department
      RtlMoveMemory((PUCHAR)pwszPath + nSubstLength - 2 * sizeof(WCHAR),  // to the right, less 2 chars
                    (PUCHAR)pwszPath,  // from the beginning
                    pPath->Length);

      // after this is done we will insert the chars from subst expansion
      // at the starting position of the path
      RtlCopyMemory(pwszPath,
                    wszSubstPath,
                    nSubstLength);

      // at this point we fix the length of the path
      pPath->Length += nSubstLength - 2 * sizeof(WCHAR);

      dwStatus = STATUS_SUCCESS;
   }

   return(dwStatus);
}




/* Function 7160
 *
 *
 * Implements fn 0 - GetFullPathName
 *
 * Parameters
 *    ax = 0x7160 - fn major code
 *    cl = 0      - minor code
 *    ch = SubstExpand
 *          0x00 - expand subst drive
 *          0x80 - do not expand subst drive
 *    ds:si = Source Path
 *    es:di = Destination Path
 *
 * The base path as in GetFullPathName will be given in a short form and
 * in a long form sometimes
 *
 *    c:\foo bar\john dow\
 * will return
 *    c:\foobar~1\john dow
 *    from GetFullPathName "john dow", c:\foo bar being the current dir
 * and
 *    c:\foobar~1\johndo~1
 *    from GetFullPathName "johndo~1"
 *
 * Return
 *    Success -
 *              carry not set, ax modified(?)
 *    Failure -
 *              carry set, ax = error value
 *
 */

NTSTATUS
dempGetFullPathName(
   PUNICODE_STRING pSourcePath,
   PUNICODE_STRING pDestinationPath,
   BOOL  fExpandSubst)

{
   DWORD dwStatus;

   // maps to GetFullPathName
   dwStatus = DPM_RtlGetFullPathName_U(pSourcePath->Buffer,
                                   pDestinationPath->MaximumLength,
                                   pDestinationPath->Buffer,
                                   NULL);

   // check result, fix string length
   // dwStatus will be set to error if buffer overflow

   CHECK_LENGTH_RESULT_RTL_USTR(dwStatus, pDestinationPath);

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }

   // now check for dos device names being passed in
   if (dempStringPrefixUnicode(&SlashSlashDotSlash, pDestinationPath, TRUE)) {

      // this is a bit strange though this is what Win95 returns

      return(NT_STATUS_FROM_WIN32(ERROR_FILE_NOT_FOUND));
   }


   // now see if we need to expand the subst
   // note that this implementation is exactly what win95 does - the subst
   // path is always expanded as short unless the long filename is being
   // requested

   if (fExpandSubst) {
      dwStatus = dempExpandSubst(pDestinationPath, FALSE);
      if (!NT_SUCCESS(dwStatus)) {
         if (WIN32_ERROR_FROM_NT_STATUS(dwStatus) != ERROR_NOT_SUBSTED) {
            return(dwStatus);
         }
      }
   }

   return(STATUS_SUCCESS);
}

/* Function
 *    dempGetShortPathName
 *    Retrieves short path name for the given path
 *
 * Parameters
 *    ax = 0x7160 - fn major code
 *    cl = 1      - minor code
 *    ch = SubstExpand
 *          0x00 - expand subst drive
 *          0x80 - do not expand subst drive
 *    ds:si = Source Path
 *    es:di = Destination Path
 *
 * The base path as in GetFullPathName will be given in a short form and
 * in a long form sometimes
 *
 *    c:\foo bar\john dow\
 * will return
 *    c:\foobar~1\john dow
 *    from GetFullPathName "john dow", c:\foo bar being the current dir
 * and
 *    c:\foobar~1\johndo~1
 *    from GetFullPathName "johndo~1"
 *
 * Return
 *    Success -
 *              carry not set, ax modified(?)
 *    Failure -
 *              carry set, ax = error value
 *
 */




NTSTATUS
dempGetShortPathName(
   PUNICODE_STRING pSourcePath,
   PUNICODE_STRING pDestinationPath,
   BOOL  fExpandSubst)
{
   DWORD dwStatus;

   dwStatus = dempGetFullPathName(pSourcePath,
                                  pDestinationPath,
                                  fExpandSubst);
   if (NT_SUCCESS(dwStatus)) {
      dwStatus = DPM_GetShortPathNameW(pDestinationPath->Buffer,
                                   pDestinationPath->Buffer,
                                   pDestinationPath->MaximumLength / sizeof(WCHAR));

      CHECK_LENGTH_RESULT_USTR(dwStatus, pDestinationPath);
   }

   return(dwStatus);
}

// the code below was mostly partially ripped from base/client/vdm.c

DWORD   rgdwIllegalMask[] =
{
    // code 0x00 - 0x1F --> all illegal
    0xFFFFFFFF,
    // code 0x20 - 0x3f --> 0x20,0x22,0x2A-0x2C,0x2F and 0x3A-0x3F are illegal
    0xFC009C05,
    // code 0x40 - 0x5F --> 0x5B-0x5D are illegal
    0x38000000,
    // code 0x60 - 0x7F --> 0x7C is illegal
    0x10000000
};


BOOL
dempIsShortNameW(
    LPCWSTR Name,
    int     Length,
    BOOL    fAllowWildCard
    )
{
    int Index;
    BOOL ExtensionFound;
    DWORD      dwStatus;
    UNICODE_STRING unicodeName;
    OEM_STRING oemString;
    UCHAR      oemBuffer[MAX_PATH];
    UCHAR      Char;

    ASSERT(Name);

    // total length must less than 13(8.3 = 8 + 1 + 3 = 12)
    if (Length > 12)
        return FALSE;
    //  "" or "." or ".."
    if (!Length)
        return TRUE;
    if (L'.' == *Name)
    {
        // "." or ".."
        if (1 == Length || (2 == Length && L'.' == Name[1]))
            return TRUE;
        else
            // '.' can not be the first char(base name length is 0)
            return FALSE;
    }

    unicodeName.Buffer = (LPWSTR)Name;
    unicodeName.Length =
    unicodeName.MaximumLength = Length * sizeof(WCHAR);

    oemString.Buffer = oemBuffer;
    oemString.Length = 0;
    oemString.MaximumLength = MAX_PATH; // make a dangerous assumption

#ifdef ENABLE_CONDITIONAL_TRANSLATION
    dwStatus = DemUnicodeStringToDestinationString(&oemString,
                                                   &unicodeName,
                                                   FALSE,
                                                   FALSE);
#else
    dwStatus = RtlUnicodeStringToOemString(&oemString,
                                           &unicodeName,
                                           FALSE);
#endif
    if (! NT_SUCCESS(dwStatus)) {
         return(FALSE);
    }

    // all trivial cases are tested, now we have to walk through the name
    ExtensionFound = FALSE;
    for (Index = 0; Index < oemString.Length; Index++)
    {
        Char = oemString.Buffer[Index];

        // Skip over and Dbcs characters
        if (IsDBCSLeadByte(Char)) {
            //
            //  1) if we're looking at base part ( !ExtensionPresent ) and the 8th byte
            //     is in the dbcs leading byte range, it's error ( Index == 7 ). If the
            //     length of base part is more than 8 ( Index > 7 ), it's definitely error.
            //
            //  2) if the last byte ( Index == DbcsName.Length - 1 ) is in the dbcs leading
            //     byte range, it's error
            //
            if ((!ExtensionFound && (Index >= 7)) ||
                (Index == oemString.Length - 1)) {
                return FALSE;
            }
            Index += 1;
            continue;
        }

        // make sure the char is legal
        if ((Char < 0x80) &&
            (rgdwIllegalMask[Char / 32] & (1 << (Char % 32)))) {
           if (!fAllowWildCard || ('?' != Char && '*' != Char)) {
              return(FALSE);
           }
        }
        if ('.' == Char)
        {
            // (1) can have only one '.'
            // (2) can not have more than 3 chars following.
            if (ExtensionFound || Length - (Index + 1) > 3)
            {
                return FALSE;
            }
            ExtensionFound = TRUE;
        }
        // base length > 8 chars
        if (Index >= 8 && !ExtensionFound)
            return FALSE;
    }
    return TRUE;

}



/* Function:
 *    demIsShortPathName
 *    Returns true is the path name passed in is a short path name
 *
 *
 *
 *
 */


 // this function was ripped from windows\base\client\vdm.c

LPCWSTR
dempSkipPathTypeIndicatorW(
    LPCWSTR Path
    )
{
    RTL_PATH_TYPE   RtlPathType;
    LPCWSTR         pFirst;
    DWORD           Count;

    RtlPathType = RtlDetermineDosPathNameType_U(Path);
    switch (RtlPathType) {
        // form: "\\server_name\share_name\rest_of_the_path"
        case RtlPathTypeUncAbsolute:
            pFirst = Path + 2;
            Count = 2;
            // guard for UNICODE_NULL is necessary because
            // RtlDetermineDosPathNameType_U doesn't really
            // verify an UNC name.
            while (Count && *pFirst != UNICODE_NULL) {
                if (*pFirst == L'\\' || *pFirst == L'/')
                    Count--;
                pFirst++;
                }
            break;

        // form: "\\.\rest_of_the_path"
        case RtlPathTypeLocalDevice:
            pFirst = Path + 4;
            break;

        // form: "\\."
        case RtlPathTypeRootLocalDevice:
            pFirst = NULL;
            break;

        // form: "D:\rest_of_the_path"
        case RtlPathTypeDriveAbsolute:
            pFirst = Path + 3;
            break;

        // form: "D:rest_of_the_path"
        case RtlPathTypeDriveRelative:
            pFirst = Path + 2;
            break;

        // form: "\rest_of_the_path"
        case RtlPathTypeRooted:
            pFirst = Path + 1;
            break;

        // form: "rest_of_the_path"
        case RtlPathTypeRelative:
            pFirst = Path;
            break;

        default:
            pFirst = NULL;
            break;
        }
    return pFirst;
}

// this function is rather "permissive" if it errs and can't find
// out for sure -- we then hope that the failure will occur later...

BOOL
demIsShortPathName(
   LPSTR pszPath,
   BOOL fAllowWildCardName)
{
   NTSTATUS dwStatus;
   PUNICODE_STRING pUnicodeStaticFileName;
   OEM_STRING oemFileName;
   LPWSTR lpwszPath;
   LPWSTR pFirst, pLast;
   BOOL   fWild = FALSE;

   //
   // convert parameters to unicode - we use a static string here
   //

   RtlInitOemString(&oemFileName, pszPath);

   pUnicodeStaticFileName = GET_STATIC_UNICODE_STRING_PTR();

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(pUnicodeStaticFileName,
                                             &oemFileName,
                                             FALSE);
#else

   dwStatus = RtlOemStringToUnicodeString(pUnicodeStaticFileName,
                                          &oemFileName,
                                          FALSE);
#endif

   if (!NT_SUCCESS(dwStatus)) {
      return(TRUE);
   }

   // now we have a unicode string to mess with
   lpwszPath = pUnicodeStaticFileName->Buffer;

   // chop off the intro part first
   lpwszPath = (LPWSTR)dempSkipPathTypeIndicatorW((LPCWSTR)pUnicodeStaticFileName->Buffer);
   if (NULL == lpwszPath) {
      // some weird path type ? just let it go
      return(TRUE); // we assume findfirst will hopefully choke on it too
   }

   pFirst = lpwszPath;

   // we go through the name now
   while (TRUE) {
      while (UNICODE_NULL != *pFirst && (L'\\' == *pFirst || L'/' == *pFirst)) {
         ++pFirst; // this is legal -- to have multiple separators!
      }

      if (UNICODE_NULL == *pFirst) {
         // meaning -- just separators found or end of string
         break;
      }


      // now see that we find the end of this name
      pLast = pFirst + 1;
      while (UNICODE_NULL != *pLast && (L'\\' != *pLast && L'/' != *pLast)) {
         ++pLast;
      }

      fWild = fAllowWildCardName && UNICODE_NULL == *pLast;

      // now pLast points to the UNICODE_NULL or the very next backslash
      if (!dempIsShortNameW(pFirst, (int)(pLast-pFirst), fWild)) {
         return(FALSE); // this means long path name found in the middle
      }

      // now we continue
      if (UNICODE_NULL == *pLast) {
         break;
      }
      pFirst = pLast + 1;
   }

   return(TRUE);
}




/* Function:
 *    dempGetLongPathName
 *    Retrieves long version of a path name given it's short form
 *
 *
 * Parameters
 *    IN pSourcePath       - unicode counted string representing short path
 *    OUT pDestinationPath - unicode counted string - output long path
 *    IN fExpandSubst      - flag indicating whether to perform subst expansion
 *
 * Return
 *    NT Error code
 *
 *
 *
 *
 */


NTSTATUS
dempGetLongPathName(
   PUNICODE_STRING pSourcePath,
   PUNICODE_STRING pDestinationPath,
   BOOL fExpandSubst)
{
   UNICODE_STRING NtPathName;
   RTL_PATH_TYPE  RtlPathType; // path type
   PWCHAR pchStart, pchEnd;
   PWCHAR pchDest, pchLast;
   UINT nCount,  // temp counter
        nLength = 0; // final string length
   WCHAR wchSave; // save char during path parsing
   DWORD dwStatus;

   UNICODE_STRING FullPathName;
   UNICODE_STRING FileName;
   BOOL fVerify = FALSE;            // flag indicating that only verification
                                    // is performed on a path and no long path
                                    // retrieval is necessary

   struct tagDirectoryInformationBuffer { // directory information (see ntioapi.h)
      FILE_DIRECTORY_INFORMATION DirInfo;
      WCHAR name[MAX_PATH];
   } DirectoryInformationBuf;
   PFILE_DIRECTORY_INFORMATION pDirInfo = &DirectoryInformationBuf.DirInfo;

   OBJECT_ATTRIBUTES FileObjectAttributes; // used for querying name info
   HANDLE FileHandle;
   IO_STATUS_BLOCK IoStatusBlock;

// algorithm here:
// 1. call getfullpathname
// 2. verify(on each part of the name) and retrieve lfn version of the name

// first we need a buffer for our full expanded path
// allocate this buffer from the heap -- * local ? *

   RtlInitUnicodeString(&NtPathName, NULL);

   pchStart = RtlAllocateHeap(RtlProcessHeap(),
                              0,
                              MAX_PATH * sizeof(WCHAR));
   if (NULL == pchStart) {
      return(NT_STATUS_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY));
   }

   dempStringInitZeroUnicode(&FullPathName,
                              pchStart,
                              MAX_PATH * sizeof(WCHAR));


   dwStatus = DPM_RtlGetFullPathName_U(pSourcePath->Buffer,
                                   FullPathName.MaximumLength,
                                   FullPathName.Buffer,
                                   NULL);

   CHECK_LENGTH_RESULT_RTL_USTR(dwStatus, &FullPathName);

   if (!NT_SUCCESS(dwStatus)) {
      goto glpExit;
   }

   // optionally expand the subst
   // to whatever it should have been

   if (fExpandSubst) {
      dwStatus = dempExpandSubst(&FullPathName, FALSE);
      if (!NT_SUCCESS(dwStatus)) {
         if (WIN32_ERROR_FROM_NT_STATUS(dwStatus) != ERROR_NOT_SUBSTED) {
            goto glpExit;
         }
      }
   }


   // at this point recycle the input source path -- we will know that
   // this modification took place

   RtlPathType = RtlDetermineDosPathNameType_U(FullPathName.Buffer);

   switch(RtlPathType) {

   case RtlPathTypeUncAbsolute:

      // this is a unc name

      pchStart = FullPathName.Buffer + 2; // beyond initial "\\"

      // drive ahead looking past second backslash -- this is really
      // bogus approach as unc name should be cared for by redirector
      // yet I do same as base

      nCount = 2;
      while (UNICODE_NULL != *pchStart && nCount > 0) {
         if (L'\\' == *pchStart || L'/' == *pchStart) {
            --nCount;
         }
         ++pchStart;
      }
      break;

   case RtlPathTypeDriveAbsolute:
      pchStart = FullPathName.Buffer + 3; // includes <drive><:><\\>
      break;

   default:
      // this error will never occur, yet to be safe we are aware of this...
      // case ... we will keep it here as a safeguard
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_BAD_PATHNAME);
      goto glpExit;
   }

   // prepare destination

   pchDest = pDestinationPath->Buffer; // current pointer to destination buffer
   pchLast = FullPathName.Buffer;      // last piece of the source path
   pchEnd  = pchStart;                 // current end-of-scan portion

   // we are going to walk the filename assembling it's various pieces
   //
   while (TRUE) {
      // copy the already-assembled part into the dest buffer
      // this is rather dubious part as all it copies are prefix and backslashes
      nCount = (PUCHAR)pchEnd - (PUCHAR)pchLast;
      if (nCount > 0) {
         // copy this portion
         nLength += nCount; // dest length-to-be
         if (nLength >= pDestinationPath->MaximumLength) {
            dwStatus = NT_STATUS_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            break;
         }

         // copy the memory
         RtlMoveMemory(pchDest, pchLast, nCount);
         pchDest += nCount / sizeof(WCHAR);
      }

      // if we are at the end here, then there is nothing left
      // we should be running a verification pass only
      if (UNICODE_NULL == *pchEnd) {
         fVerify = TRUE;
      }
      else {
      // look for the next backslash
         while (UNICODE_NULL != *pchEnd &&
                L'\\' != *pchEnd &&
                L'/' != *pchEnd) {
               ++pchEnd;
         }
      }

      // found backslash or end here
      // temporary null-terminate the string and research it's full name

      wchSave = *pchEnd;
      *pchEnd = UNICODE_NULL;

      dwStatus = RtlDosPathNameToNtPathName_U(FullPathName.Buffer,
                                              &NtPathName,
                                              &FileName.Buffer,
                                              NULL);
      if (!dwStatus) {
         // could also be a memory problem here
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_FILE_NOT_FOUND);
         break;
      }

      if (fVerify || NULL == FileName.Buffer) {
         // no filename portion there - panic ? or this is just a
         // directory (root)
         // this also may signal that our job is done as there is nothing
         // to query about - we are at the root of things

         // let us open this stuff then and if it exists - just exit,
         // else return error
         fVerify = TRUE;
         FileName.Length = 0;
      }
      else {

         USHORT nPathLength;

         nPathLength = (USHORT)((ULONG)FileName.Buffer - (ULONG)NtPathName.Buffer);

         FileName.Length = NtPathName.Length - nPathLength;

         // chop the backslash off if this is not the last one only
         NtPathName.Length = nPathLength;
         if (L':' != *(PWCHAR)((PUCHAR)NtPathName.Buffer+nPathLength-2*sizeof(WCHAR))) {
            NtPathName.Length -= sizeof(WCHAR);
         }
      }

      FileName.MaximumLength = FileName.Length;
      NtPathName.MaximumLength = NtPathName.Length;



      // now we should have a full nt path sitting right in NtPathName
      // restore saved char

      *pchEnd = wchSave;

      // initialize info obj
      InitializeObjectAttributes(&FileObjectAttributes,
                                 &NtPathName,
                                 OBJ_CASE_INSENSITIVE,
                                 NULL,
                                 NULL);

      dwStatus = DPM_NtOpenFile(&FileHandle,
                            FILE_LIST_DIRECTORY | SYNCHRONIZE,
                            &FileObjectAttributes,
                            &IoStatusBlock,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_DIRECTORY_FILE |
                              FILE_SYNCHRONOUS_IO_NONALERT |
                              FILE_OPEN_FOR_BACKUP_INTENT);

      if (!NT_SUCCESS(dwStatus)) {
         break;
      }

      dwStatus = DPM_NtQueryDirectoryFile(FileHandle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &IoStatusBlock,
                                      pDirInfo,
                                      sizeof(DirectoryInformationBuf),
                                      FileDirectoryInformation,
                                      TRUE,
                                      &FileName,
                                      FALSE);

      NtClose(FileHandle);

      // we need NtPathName no more - release it here
      RtlFreeUnicodeString(&NtPathName);
      NtPathName.Buffer = NULL;

      if (!NT_SUCCESS(dwStatus)) {
         break;
      }

      if (fVerify) {
         dwStatus = STATUS_SUCCESS;
         break;
      }

      nLength += pDirInfo->FileNameLength;
      if (nLength >= pDestinationPath->MaximumLength) {
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
         break;
      }

      RtlMoveMemory(pchDest,
                    pDirInfo->FileName,
                    pDirInfo->FileNameLength);

       // update dest pointer
      pchDest += pDirInfo->FileNameLength / sizeof(WCHAR);

      if (UNICODE_NULL == *pchEnd) {
         dwStatus = STATUS_SUCCESS;
         break;
      }

      pchLast = pchEnd++; // this is set to copy backslash

   } // end while

   // only on success condition we touch dest buffer here

   if (NT_SUCCESS(dwStatus)) {
      *pchDest = UNICODE_NULL;
      pDestinationPath->Length = (USHORT)nLength;
   }

glpExit:

   if (NULL != FullPathName.Buffer) {
      RtlFreeHeap(RtlProcessHeap(), 0, FullPathName.Buffer);
   }
   if (NULL != NtPathName.Buffer) {
      RtlFreeUnicodeString(&NtPathName);
   }

   return(dwStatus);
}


/* Function:
 *    demGetPathName
 *    completely handles function 7160 with three minor subfunctions
 *    exported function that could be called from wow32 for fast handling
 *    of a 0x7160 thunk
 *
 * Parameters
 *    IN  lpSourcePath      - source path to query for full/long/short path name
 *    OUT lpDestinationPath - result produced by this function
 *    IN  uiMinorCode       - minor code see enumFullPathNameMinorCode - which
 *                            function to execute -
 *                            fullpathname/shortpathname/longpathname
 *    IN  fExpandSubst      - flag whether to expand substituted drive letter
 *
 * Return
 *    NT Error code
 *
 * Known implementation differences [with Win95]
 *
 *    All these apis will return error on win95 if path does not exist
 *    only GetLongPathName currently returns error in such a case
 *
 *    if a local path does not exist win95 fn0 returns fine while
 *    fns 1 and 2 return error 3 (path not found)
 *
 *    we return the name with a terminating backslash when expanding the
 *    subst e.g.:
 *      z:\ -> substed for c:\foo\bar
 *    we return "c:\foo\bar\" while win95 returns "c:\foo\bar"
 *
 *    if win95 running on \\vadimb9  any of these calls with \\vadimb9\foo
 *    where share foo does not exist - we get a doserror generated with
 *    abort/retry/fail - and code is 46 (bogus)
 *
 *    error codes may differ a bit
 *
 *    win95 does not allow for subst on a unc name, win nt does and fns correctly
 *    process these cases(with long or short filenames)
 *
 */


NTSTATUS
demLFNGetPathName(
   LPSTR lpSourcePath,
   LPSTR lpDestinationPath,
   UINT  uiMinorCode,
   BOOL  fExpandSubst
   )

{
   // convert input parameter to unicode
   //
   UNICODE_STRING unicodeSourcePath;
   UNICODE_STRING unicodeDestinationPath;
   OEM_STRING oemString;
   WCHAR wszDestinationPath[MAX_PATH];
   DWORD dwStatus;

   // Validate input parameters

   if (NULL == lpSourcePath || NULL == lpDestinationPath) {
      return(NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER));
   }


   RtlInitOemString(&oemString, lpSourcePath);

   // convert source path from ansi to unicode and allocate result
   // this rtl function returns status code, not the winerror code
   //

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(&unicodeSourcePath, &oemString, TRUE);

#else

   dwStatus = RtlOemStringToUnicodeString(&unicodeSourcePath, &oemString, TRUE);

#endif


   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }

   dempStringInitZeroUnicode(&unicodeDestinationPath,
                             wszDestinationPath,
                             sizeof(wszDestinationPath));


   // now call api and get appropriate result back

   switch(uiMinorCode) {
   case fnGetFullPathName:

      dwStatus = dempGetFullPathName(&unicodeSourcePath,
                                     &unicodeDestinationPath,
                                     fExpandSubst);

      break;

   case fnGetShortPathName:
      dwStatus = dempGetShortPathName(&unicodeSourcePath,
                                      &unicodeDestinationPath,
                                      fExpandSubst);
      break;

   case fnGetLongPathName:
      dwStatus = dempGetLongPathName(&unicodeSourcePath,
                                     &unicodeDestinationPath,
                                     fExpandSubst);
      break;

   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION);
   }

   if (NT_SUCCESS(dwStatus)) {
      // convert to ansi and we are done
      oemString.Buffer = lpDestinationPath;
      oemString.Length = 0;
      oemString.MaximumLength = MAX_PATH; // make a dangerous assumption


#ifdef ENABLE_CONDITIONAL_TRANSLATION
      dwStatus = DemUnicodeStringToDestinationString(&oemString,
                                                     &unicodeDestinationPath,
                                                     FALSE,
                                                     FALSE);
#else
      dwStatus = RtlUnicodeStringToOemString(&oemString,
                                             &unicodeDestinationPath,
                                             FALSE);
#endif
   }

   RtlFreeUnicodeString(&unicodeSourcePath);

   return(dwStatus);
}


// Create a subst for this particular drive
// using path name
//
// same as used by subst command

// check to see if specified path exists


/* Function:
 *    dempLFNCheckDirectory
 *    Verifies that a supplied path is indeed an existing directory
 *
 * Parameters
 *    IN pPath - pointer to unicode Path String
 *
 * Return
 *    NT Error code
 *
 *
 */

DWORD
dempLFNCheckDirectory(
   PUNICODE_STRING pPath)
{
   // we just read file's attributes
   DWORD dwAttributes;

   dwAttributes = DPM_GetFileAttributesW(pPath->Buffer);

   if ((DWORD)-1 == dwAttributes) {
      return(GET_LAST_STATUS());
   }

   // now see if this is a directory
   if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) {
      return(STATUS_SUCCESS);
   }

   return(NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND));

}


/* Function:
 *    dempLFNCreateSubst
 *    Creates, if possible, new mapping for the supplied dos drive number,
 *    mapping it to the supplied path
 *
 * Parameters
 *    IN uDriveNum - dos drive number (current-0, a-1, b-2, etc)
 *    IN pPathName - pointer to unicode Path String
 *
 * Return
 *    NT Error code
 *
 * Note:
 *    Win95 never works properly with the current drive, we essentially
 *    ignore this case
 *
 */


DWORD
dempLFNCreateSubst(
   UINT uiDriveNum,
   PUNICODE_STRING pPathName)
{
   // first, make a dos drive name
   WCHAR wszDriveStr[3];
   DWORD dwStatus = STATUS_SUCCESS;
   WCHAR wszSubstPath[MAX_PATH];

   wszDriveStr[0] = L'@' + uiDriveNum;
   wszDriveStr[1] = L':';
   wszDriveStr[2] = UNICODE_NULL;

   if (!DPM_QueryDosDeviceW(wszDriveStr, wszSubstPath, ARRAYCOUNT(wszSubstPath))) {
      dwStatus = GetLastError();

      if (ERROR_FILE_NOT_FOUND == dwStatus) {

         // check for the input path validity - it better be valid
         // or else...
         dwStatus = dempLFNCheckDirectory(pPathName);
         if (!NT_SUCCESS(dwStatus)) {
            return(dwStatus);
         }


         if (DefineDosDeviceW(0, wszDriveStr, pPathName->Buffer)) {
            // patch in cds for this device
            // BUGBUG

            return(STATUS_SUCCESS);
         }

         dwStatus = GetLastError();
      }

   }

   return (NT_STATUS_FROM_WIN32(dwStatus));
}

/* Function:
 *    dempLFNRemoveSubst
 *    Removes mapping for the supplied dos drive number
 *
 * Parameters
 *    IN uDriveNum - dos drive number (current-0, a-1, b-2, etc)
 *
 * Return
 *    NT Error code
 *
 * Note:
 *    Win95 never works properly with the current drive, we essentially
 *    ignore this case
 *
 */


DWORD
dempLFNRemoveSubst(
   UINT uiDriveNum)
{
   // for this one query for real subst

   WCHAR wszDriveStr[3];
   PUNICODE_STRING pUnicodeStatic;
   DWORD dwStatus;

   wszDriveStr[0] = L'@' + uiDriveNum;
   wszDriveStr[1] = L':';
   wszDriveStr[2] = UNICODE_NULL;

   pUnicodeStatic = &NtCurrentTeb()->StaticUnicodeString;
   // query

   dwStatus = dempQuerySubst(wszDriveStr[0],
                             pUnicodeStatic);

   if (NT_SUCCESS(dwStatus)) {
      if (DefineDosDeviceW(DDD_REMOVE_DEFINITION,
                           wszDriveStr,
                           pUnicodeStatic->Buffer)) {
         // BUGBUG -- patch in cds for this device


         return(STATUS_SUCCESS);
      }


      dwStatus = GET_LAST_STATUS();
   }

   return(dwStatus);
}

/* Function:
 *    dempLFNQuerySubst
 *    Queries the supplied dos drive number for being a substitute drive,
 *    retrieves dos drive mapping if so
 *
 * Parameters
 *    IN uDriveNum   - dos drive number (current-0, a-1, b-2, etc)
 *    OUT pSubstPath - receives drive mapping if drive is a subst
 *
 * Return
 *    NT Error code
 *
 * Note:
 *    Win95 never works properly with the current drive, we essentially
 *    ignore this case -- This is BUGBUG for this api
 *
 */



DWORD
dempLFNQuerySubst(
   UINT uiDriveNum,
   PUNICODE_STRING pSubstPath)
{
   DWORD dwStatus;

   dwStatus = dempQuerySubst((WCHAR)(L'@' + uiDriveNum),
                             pSubstPath);
   return(dwStatus);
}



/* Function:
 *    demLFNSubstControl
 *    Implements Subst APIs for any valid minor code
 *
 * Parameters
 *    IN uiMinorCode    - function to perform (see enumSubstMinorCode below)
 *    IN uDriveNum      - dos drive number (current-0, a-1, b-2, etc)
 *    IN OUT pSubstPath - receives/supplies drive mapping if drive is a subst
 *
 * Return
 *    NT Error code
 *
 * Note:
 *
 */


DWORD
demLFNSubstControl(
   UINT uiMinorCode,
   UINT uiDriveNum,
   LPSTR lpPathName)
{
   DWORD dwStatus;
   OEM_STRING oemPathName;
   PUNICODE_STRING pUnicodeStatic = NULL;

   switch(uiMinorCode) {
   case fnCreateSubst:

      RtlInitOemString(&oemPathName, lpPathName);
      pUnicodeStatic = GET_STATIC_UNICODE_STRING_PTR();

#ifdef ENABLE_CONDITIONAL_TRANSLATION

      dwStatus = DemSourceStringToUnicodeString(pUnicodeStatic,
                                                &oemPathName,
                                                FALSE);
#else

      dwStatus = RtlOemStringToUnicodeString(pUnicodeStatic,
                                             &oemPathName,
                                             FALSE); // allocate result
#endif

      if (NT_SUCCESS(dwStatus)) {
         dwStatus = dempLFNCreateSubst(uiDriveNum, pUnicodeStatic);
      }
      break;

   case fnRemoveSubst:
      dwStatus = dempLFNRemoveSubst(uiDriveNum);
      break;

   case fnQuerySubst:
      // query lfn stuff
      pUnicodeStatic = GET_STATIC_UNICODE_STRING_PTR();

      dwStatus = dempLFNQuerySubst(uiDriveNum, pUnicodeStatic);
      if (NT_SUCCESS(dwStatus)) {
         oemPathName.Length = 0;
         oemPathName.MaximumLength = MAX_PATH;
         oemPathName.Buffer = lpPathName;

#ifdef ENABLE_CONDITIONAL_TRANSLATION
         dwStatus = DemUnicodeStringToDestinationString(&oemPathName,
                                                        pUnicodeStatic,
                                                        FALSE,
                                                        FALSE);
#else
         dwStatus = RtlUnicodeStringToOemString(&oemPathName,
                                                pUnicodeStatic,
                                                FALSE);
#endif
      }
      break;
   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION);
   }


   //
   // the only thing this ever returns on Win95 is
   // 0x1 - error/invalid function
   // 0xf - error/invalid drive (invalid drive)
   // 0x3 - error/path not found (if bad path is given)

   return(dwStatus);
}




/* Function
 *    dempLFNMatchFile
 *    Matches the given search hit with attributes provided by a search call
 *
 * Parameters
 *    pFindDataW - Unicode WIN32_FIND_DATA structure as returned by FindFirstFile
 *                 or FindNextFile apis
 *
 *    wMustMatchAttributes - attribs that given file must match
 *    wSearchAttributes    - search attribs for the file
 *
 * Returns
 *    TRUE if the file matches the search criteria
 *
 *
 */

BOOL
dempLFNMatchFile(
   PWIN32_FIND_DATAW pFindDataW,
   USHORT wMustMatchAttributes,
   USHORT wSearchAttributes)
{
   DWORD dwAttributes = pFindDataW->dwFileAttributes;

   // now clear out a volume id flag - it is not matched here
   dwAttributes &= ~DEM_FILE_ATTRIBUTE_VOLUME_ID;

   return (
     ((dwAttributes & (DWORD)wMustMatchAttributes) == (DWORD)wMustMatchAttributes) &&
     (((dwAttributes & (~(DWORD)wSearchAttributes)) & 0x1e) == 0));
}


DWORD
dempLFNFindFirstFile(
   HANDLE* pFindHandle,
   PUNICODE_STRING pFileName,
   PWIN32_FIND_DATAW pFindDataW,
   USHORT wMustMatchAttributes,
   USHORT wSearchAttributes)
{
   HANDLE hFindFile;
   DWORD dwStatus;


   // match the volume file name first

   hFindFile = DPM_FindFirstFileW(pFileName->Buffer, pFindDataW);
   if (INVALID_HANDLE_VALUE != hFindFile) {
      BOOL fContinue = TRUE;

      while (!dempLFNMatchFile(pFindDataW, wMustMatchAttributes, wSearchAttributes) &&
             fContinue) {
         fContinue = DPM_FindNextFileW(hFindFile, pFindDataW);
      }

      if (fContinue) {
         // we found some
         *pFindHandle = hFindFile;
         return(STATUS_SUCCESS);
      }
      else {
         // ; return file not found error
         SetLastError(ERROR_FILE_NOT_FOUND);
      }

   }

   dwStatus =  GET_LAST_STATUS();
   if (INVALID_HANDLE_VALUE != hFindFile) {
      DPM_FindClose(hFindFile);
   }

   return(dwStatus);
}


DWORD
dempLFNFindNextFile(
   HANDLE hFindFile,
   PWIN32_FIND_DATAW pFindDataW,
   USHORT wMustMatchAttributes,
   USHORT wSearchAttributes)
{
   BOOL fFindNext;

   do {

      fFindNext = DPM_FindNextFileW(hFindFile, pFindDataW);
      if (fFindNext &&
          dempLFNMatchFile(pFindDataW, wMustMatchAttributes, wSearchAttributes)) {
         // found a match!
         return(STATUS_SUCCESS);
      }
   } while (fFindNext);

   return(GET_LAST_STATUS());
}

// the handle we return is a number of the entry into this table below
// with high bit turned on (to be different then any other handle in dos)


DWORD
dempLFNAllocateHandleEntry(
   PUSHORT pDosHandle,
   PLFN_SEARCH_HANDLE_ENTRY* ppHandleEntry)
{
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry = gSearchHandleTable.pHandleTable;

   if (NULL == pHandleEntry) {
      pHandleEntry = RtlAllocateHeap(RtlProcessHeap(),
                                     0,
                                     LFN_SEARCH_HANDLE_INITIAL_SIZE *
                                         sizeof(LFN_SEARCH_HANDLE_ENTRY));
      if (NULL == pHandleEntry) {
         return(NT_STATUS_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY)); // not enough memory
      }
      gSearchHandleTable.pHandleTable = pHandleEntry;
      gSearchHandleTable.nTableSize   = LFN_SEARCH_HANDLE_INITIAL_SIZE;
      gSearchHandleTable.nHandleCount = 0;
      gSearchHandleTable.nFreeEntry   = LFN_SEARCH_HANDLE_LIST_END;
   }

   // walk the free list if available....
   if (LFN_SEARCH_HANDLE_LIST_END != gSearchHandleTable.nFreeEntry) {
      pHandleEntry += gSearchHandleTable.nFreeEntry;
      gSearchHandleTable.nFreeEntry = pHandleEntry->nNextFreeEntry;
   }
   else { // no free entries, should we grow ?
      UINT nHandleCount = gSearchHandleTable.nHandleCount;
      if (nHandleCount >= gSearchHandleTable.nTableSize) {
         // oops - need to grow.

         UINT nTableSize = gSearchHandleTable.nTableSize + LFN_SEARCH_HANDLE_INCREMENT;

         if (nTableSize >= LFN_DOS_HANDLE_LIMIT) {
            // handle as error - we cannot have that many handles

             ASSERT(FALSE);
             return(STATUS_UNSUCCESSFUL);
         }

#pragma prefast(suppress:308, ptr is saved elsewhere (PREfast bug 506))
         pHandleEntry = RtlReAllocateHeap(RtlProcessHeap(),
                                          0,
                                          pHandleEntry,
                                          nTableSize * sizeof(LFN_SEARCH_HANDLE_ENTRY));
         if (NULL != pHandleEntry) {
            gSearchHandleTable.pHandleTable = pHandleEntry;
            gSearchHandleTable.nTableSize = nTableSize;
         }
         else {
            // error - out of memory
            return(NT_STATUS_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY));
         }

      }

      // now set the new entry
      pHandleEntry += nHandleCount;
      gSearchHandleTable.nHandleCount = nHandleCount + 1;
   }

   *pDosHandle = (USHORT)(pHandleEntry - gSearchHandleTable.pHandleTable) | LFN_DOS_HANDLE_MASK;
   *ppHandleEntry = pHandleEntry;
   return(STATUS_SUCCESS);

}

/*
 * The list of free entries is sorted in the last-to-first order
 *
 *
 */

VOID
dempLFNFreeHandleEntry(
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry)
{
   UINT nHandleCount = gSearchHandleTable.nHandleCount - 1;
   UINT DosHandle = (UINT)(pHandleEntry - gSearchHandleTable.pHandleTable);

   // this is the entry - is this the last one ?
   if (DosHandle == nHandleCount) { // if so, chop it off

      UINT nCurHandle = gSearchHandleTable.nFreeEntry;

      // if this handle was the last one and is gone, maybe
      // shrink the list by checking free entry list
      // this is rather simple as the list is sorted in high-to-low
      // numerical order
      while (LFN_SEARCH_HANDLE_LIST_END != nCurHandle &&
             nCurHandle == (nHandleCount-1)) {
         --nHandleCount;
         nCurHandle = gSearchHandleTable.pHandleTable[nCurHandle].nNextFreeEntry;
      }

      // now update free list entry and handle count

      gSearchHandleTable.nFreeEntry   = nCurHandle;
      gSearchHandleTable.nHandleCount = nHandleCount;

   }
   else { //  mark as free and include in the free list
      // find an in-order spot for it
      // this means that the first free handle in the list has the biggest
      // numerical value, thus facilitating shrinking of the table if needed

      UINT nCurHandle  = gSearchHandleTable.nFreeEntry;
      UINT nPrevHandle = LFN_SEARCH_HANDLE_LIST_END;
      PLFN_SEARCH_HANDLE_ENTRY pHandlePrev;

      while (LFN_SEARCH_HANDLE_LIST_END != nCurHandle && nCurHandle > DosHandle) {
         nPrevHandle = nCurHandle;
         nCurHandle = gSearchHandleTable.pHandleTable[nCurHandle].nNextFreeEntry;
      }

      // at this point nCurHandle == -1 or nCurHandle < DosHandle
      // insert DosHandle in between nPrevHandle and nCurHandle

      if (LFN_SEARCH_HANDLE_LIST_END == nPrevHandle) {
         // becomes the first item
         pHandleEntry->nNextFreeEntry  = gSearchHandleTable.nFreeEntry;
         gSearchHandleTable.nFreeEntry = DosHandle;
      }
      else {
         pHandlePrev = gSearchHandleTable.pHandleTable + nPrevHandle;

         pHandleEntry->nNextFreeEntry = pHandlePrev->nNextFreeEntry;
         pHandlePrev->nNextFreeEntry  = DosHandle;
      }

      pHandleEntry->wProcessPDB     = 0; // no pdb there
   }
}

PLFN_SEARCH_HANDLE_ENTRY
dempLFNGetHandleEntry(
   USHORT DosHandle)
{
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry = NULL;

   if (DosHandle & LFN_DOS_HANDLE_MASK) {

      DosHandle &= ~LFN_DOS_HANDLE_MASK; // this is to filter real offset

      if (NULL != gSearchHandleTable.pHandleTable) {
         UINT nHandleCount = gSearchHandleTable.nHandleCount;
         if (DosHandle < nHandleCount) {
            pHandleEntry = gSearchHandleTable.pHandleTable + DosHandle;
            if (pHandleEntry->wProcessPDB != FETCHWORD(*pusCurrentPDB)) {
               return(NULL);
            }
         }
      }
   }

   return(pHandleEntry);
}

VOID
dempLFNCloseSearchHandles(
   VOID)
{
   INT DosHandle;

   for (DosHandle = (int)gSearchHandleTable.nHandleCount-1;
        DosHandle >= 0;
        --DosHandle) {
      PLFN_SEARCH_HANDLE_ENTRY pHandleEntry;

      pHandleEntry = dempLFNGetHandleEntry((USHORT)(DosHandle|LFN_DOS_HANDLE_MASK));
      if (NULL != pHandleEntry) {
         if (INVALID_HANDLE_VALUE != pHandleEntry->hFindHandle) {
            DPM_FindClose(pHandleEntry->hFindHandle);
         }
         dempLFNFreeHandleEntry(pHandleEntry);
      }
   }
}


DWORD dempLFNConvertFileTime(
   FILETIME* pDosFileTime,
   FILETIME* pNTFileTime,
   UINT      uDateTimeFormat)
{
   DWORD dwStatus = STATUS_SUCCESS;

   // before we do that assume pNTFileTime is a UTC time
   switch (uDateTimeFormat) {
   case dtfDos:
      {
         WORD wDosDate, wDosTime;
         BOOL fResult;
         LARGE_INTEGER ftNT   = { pNTFileTime->dwLowDateTime,  pNTFileTime->dwHighDateTime };
         LARGE_INTEGER ftDos0 = { gFileTimeDos0.dwLowDateTime, gFileTimeDos0.dwHighDateTime };

         //
         // before we start frolicking with local file time, check to see
         // if the nt filetime refers to 01-01-80 and if so, keep it this way
         //
         if (ftNT.QuadPart <= ftDos0.QuadPart) {
            *pDosFileTime = gFileTimeDos0;
            fResult = TRUE;
         }
         else {
            fResult = FileTimeToLocalFileTime(pNTFileTime, pDosFileTime);
         }

         if (fResult) {
            fResult = FileTimeToDosDateTime(pDosFileTime, &wDosDate, &wDosTime);
         }

         if (fResult) {
            // date is in high-order word low dword
            // time is in low-order word of a low dword

            pDosFileTime->dwLowDateTime  = (DWORD)MAKELONG(wDosTime, wDosDate);
            pDosFileTime->dwHighDateTime = 0;
         }
         else {
            dwStatus = GET_LAST_STATUS();
         }
      }
      break;

   case dtfWin32:
      *pDosFileTime = *pNTFileTime;
      break;

   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER);
      break;
   }

   return(dwStatus);
}

// please note that the date time format in case of 32-bit is not returned
// local but the original 32-bit

//
// Note that if we pass lpFileName
// and                  lpAltFileName
// than this is what will be used for these fields...
//


NTSTATUS
dempLFNConvertFindDataUnicodeToOem(
   LPWIN32_FIND_DATA  lpFindDataOem,
   LPWIN32_FIND_DATAW lpFindDataW,
   UINT    uDateTimeFormat,
   PUSHORT pConversionCode,
   LPSTR   lpFileName,
   LPSTR   lpAltFileName
   )

{
   OEM_STRING oemString;
   UNICODE_STRING unicodeString;
   NTSTATUS dwStatus;
   WORD     wConversionCode = 0;

   dwStatus = dempLFNConvertFileTime(&lpFindDataOem->ftLastWriteTime,
                                     &lpFindDataW->ftLastWriteTime,
                                     uDateTimeFormat);
   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }

   if (0 == lpFindDataW->ftCreationTime.dwLowDateTime &&
       0 == lpFindDataW->ftCreationTime.dwHighDateTime) {
       lpFindDataW->ftCreationTime = lpFindDataW->ftLastWriteTime;
   }


   dwStatus = dempLFNConvertFileTime(&lpFindDataOem->ftCreationTime,
                                     &lpFindDataW->ftCreationTime,
                                     uDateTimeFormat);
   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }


   if (0 == lpFindDataW->ftLastAccessTime.dwLowDateTime &&
       0 == lpFindDataW->ftLastAccessTime.dwHighDateTime) {
      lpFindDataW->ftLastAccessTime = lpFindDataW->ftLastWriteTime;
   }

   dwStatus = dempLFNConvertFileTime(&lpFindDataOem->ftLastAccessTime,
                                     &lpFindDataW->ftLastAccessTime,
                                     uDateTimeFormat);
   if (!NT_SUCCESS(dwStatus)) {
      // could be a bogus last access date time as provided to us by win32
      // don't bail out! Just give same as creation time
      return(dwStatus);
   }



   // convert both the name and the alternative name

   oemString.Buffer = (NULL == lpFileName) ? lpFindDataOem->cFileName : lpFileName;
   oemString.MaximumLength = ARRAYCOUNT(lpFindDataOem->cFileName);
   oemString.Length = 0;

   RtlInitUnicodeString(&unicodeString, lpFindDataW->cFileName);

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemUnicodeStringToDestinationString(&oemString,
                                                  &unicodeString,
                                                  FALSE,
                                                  TRUE); // verify result
   if (!NT_SUCCESS(dwStatus)) {
      if (STATUS_UNMAPPABLE_CHARACTER == dwStatus) {
         wConversionCode |= 0x01; // mask we have unmappable chars in file name
      }
      else {
         return(dwStatus); // failed
      }
   }

#else

   dwStatus = RtlUnicodeStringToCountedOemString(&oemString, &unicodeString, FALSE);
   if (!NT_SUCCESS(dwStatus)) {
      if (STATUS_UNMAPPABLE_CHARACTER == dwStatus) {
         wConversionCode |= 0x01;
      }
      else {
         return(dwStatus);
      }
   }

   if (oemString.Length < oemString.MaximumLength) {
      oemString.Buffer[oemString.Length] = '\0';
   }
   else {
      if (NULL == oemString.Buffer) { // string is empty
         *lpFindDataOem->cFileName = '\0';
      }
      else {
         return(STATUS_BUFFER_OVERFLOW);
      }
   }

#endif


   oemString.Buffer = (NULL == lpAltFileName) ? lpFindDataOem->cAlternateFileName :
                                                lpAltFileName;
   oemString.MaximumLength = ARRAYCOUNT(lpFindDataOem->cAlternateFileName);
   oemString.Length = 0;

   RtlInitUnicodeString(&unicodeString, lpFindDataW->cAlternateFileName);

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemUnicodeStringToDestinationString(&oemString,
                                                  &unicodeString,
                                                  FALSE,
                                                  TRUE); // verify result
   if (!NT_SUCCESS(dwStatus)) {
      if (STATUS_UNMAPPABLE_CHARACTER == dwStatus) {
         wConversionCode |= 0x02; // mask we have unmappable chars in file name
      }
      else {
         return(dwStatus); // failed
      }
   }

#else

   dwStatus = RtlUnicodeStringToCountedOemString(&oemString, &unicodeString, FALSE);
   if (!NT_SUCCESS(dwStatus)) {
      if (STATUS_UNMAPPABLE_CHARACTER == dwStatus) {
         wConversionCode |= 0x02;
      }
      else {
         return(dwStatus);
      }
   }

   if (oemString.Length < oemString.MaximumLength) {
      oemString.Buffer[oemString.Length] = '\0';
   }
   else {
      if (NULL == oemString.Buffer) { // 0-length string
         *lpFindDataOem->cAlternateFileName = '\0';
      }
      else {
         return(STATUS_BUFFER_OVERFLOW);
      }
   }

#endif

   // attributes - these are not touched at the moment

   lpFindDataOem->dwFileAttributes = lpFindDataW->dwFileAttributes;

   // file size

   lpFindDataOem->nFileSizeHigh = lpFindDataW->nFileSizeHigh;
   lpFindDataOem->nFileSizeLow  = lpFindDataW->nFileSizeLow;


   // set the conversion code here
   *pConversionCode = wConversionCode;

   return(STATUS_SUCCESS);
}


NTSTATUS
demLFNFindFirstFile(
   LPSTR lpFileName,    // file name to look for
   LPWIN32_FIND_DATA lpFindData,
   USHORT wDateTimeFormat,
   USHORT wMustMatchAttributes,
   USHORT wSearchAttributes,
   PUSHORT pConversionCode, // points to conversion code -- out
   PUSHORT pDosHandle,      // points to dos handle      -- out
   LPSTR  lpDstFileName,    // points to a destination for a file name
   LPSTR  lpAltFileName     // points to a destination for a short name
   ) // hibyte == MustMatchAttrs, lobyte == SearchAttrs
{
   HANDLE hFindFile;
   WIN32_FIND_DATAW FindDataW;
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry;
   NTSTATUS dwStatus;
   PUNICODE_STRING pUnicodeStaticFileName;
   OEM_STRING oemFileName;

   //
   // convert parameters to unicode - we use a static string here
   //

   RtlInitOemString(&oemFileName, lpFileName);

   pUnicodeStaticFileName = GET_STATIC_UNICODE_STRING_PTR();

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(pUnicodeStaticFileName,
                                             &oemFileName,
                                             FALSE);
#else

   dwStatus = RtlOemStringToUnicodeString(pUnicodeStaticFileName,
                                          &oemFileName,
                                          FALSE);
#endif

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }

   // match volume label here
   if (DEM_FILE_ATTRIBUTE_VOLUME_ID == wMustMatchAttributes &&
       DEM_FILE_ATTRIBUTE_VOLUME_ID == wSearchAttributes) {

      // this is a query for the volume information file
      // actually this is what documented, yet ifsmgr source tells a different
      // story. We adhere to documentation here as it is much simpler to do it
      // this  way, see fastfat source in Win95 for more fun with matching
      // attrs and files

      // match the volume label and if we do have a match then

      // call RtlCreateDestinationString( ); to create a string that is stored
      // inside the HandleEntry

      return(0);
   }

   // normalize path
   dempLFNNormalizePath(pUnicodeStaticFileName);

   // call worker api

   dwStatus = dempLFNFindFirstFile(&hFindFile,
                                   pUnicodeStaticFileName,
                                   &FindDataW,
                                   wMustMatchAttributes,
                                   wSearchAttributes);

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }


   //
   // convert from unicode to oem
   //

   dwStatus = dempLFNConvertFindDataUnicodeToOem(lpFindData,
                                                 &FindDataW,
                                                 (UINT)wDateTimeFormat,
                                                 pConversionCode,
                                                 lpDstFileName,
                                                 lpAltFileName);
   if (!NT_SUCCESS(dwStatus)) {
      if (INVALID_HANDLE_VALUE != hFindFile) {
         DPM_FindClose(hFindFile);
      }
      return(dwStatus);
   }

   // allocate dos handle if needed
   dwStatus = dempLFNAllocateHandleEntry(pDosHandle,
                                         &pHandleEntry);
   if (NT_SUCCESS(dwStatus)) {
      pHandleEntry->hFindHandle = hFindFile;
      pHandleEntry->wMustMatchAttributes = wMustMatchAttributes;
      pHandleEntry->wSearchAttributes = wSearchAttributes;
      pHandleEntry->wProcessPDB = *pusCurrentPDB;
   }
   else { // could not allocate dos handle
      if (NULL != hFindFile) {
         DPM_FindClose(hFindFile);
      }

   }

   return(dwStatus);
}

VOID
demLFNCleanup(
   VOID)
{
   // this fn will cleanup after unclosed lfn searches

   dempLFNCloseSearchHandles();

   // also -- close the clipboard if this api has been used by the application
   // in question. How do we know ???

}


DWORD
demLFNFindNextFile(
   USHORT DosHandle,
   LPWIN32_FIND_DATAA lpFindData,
   USHORT wDateTimeFormat,
   PUSHORT pConversionCode,
   LPSTR  lpFileName,
   LPSTR  lpAltFileName)

{
   // unpack parameters
   WIN32_FIND_DATAW FindDataW;
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry;
   DWORD dwStatus;
   USHORT ConversionStatus;


   // this call never has to deal with volume labels
   //

   pHandleEntry = dempLFNGetHandleEntry(DosHandle);
   if (NULL != pHandleEntry) {

      // possible we had a volume-label match the last time around
      // so we should then deploy dempLFNFindFirstFile if this the case
      //
      if (INVALID_HANDLE_VALUE == pHandleEntry->hFindHandle) {
         dwStatus = dempLFNFindFirstFile(&pHandleEntry->hFindHandle,
                                         &pHandleEntry->unicodeFileName,
                                         &FindDataW,
                                         pHandleEntry->wMustMatchAttributes,
                                         pHandleEntry->wSearchAttributes);

         RtlFreeUnicodeString(&pHandleEntry->unicodeFileName);
      }
      else {
         dwStatus = dempLFNFindNextFile(pHandleEntry->hFindHandle,
                                        &FindDataW,
                                        pHandleEntry->wMustMatchAttributes,
                                        pHandleEntry->wSearchAttributes);
      }
      if (NT_SUCCESS(dwStatus)) {
         // this is ok

         dwStatus = dempLFNConvertFindDataUnicodeToOem(lpFindData,
                                                       &FindDataW,
                                                       wDateTimeFormat,
                                                       pConversionCode,
                                                       lpFileName,
                                                       lpAltFileName);
      }

   }
   else {
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_HANDLE);
   }

   return(dwStatus);
}

DWORD
demLFNFindClose(
   USHORT DosHandle)
{
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry;
   DWORD dwStatus = STATUS_SUCCESS;

   pHandleEntry = dempLFNGetHandleEntry(DosHandle);
   if (NULL != pHandleEntry) {
      if (INVALID_HANDLE_VALUE != pHandleEntry->hFindHandle) {
         dwStatus = DPM_FindClose(pHandleEntry->hFindHandle);
      }

      dempLFNFreeHandleEntry(pHandleEntry);
   }
   else {
      // invalid handle
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_HANDLE);
   }

   return(dwStatus);

}

////////////////////////////////////////////////////////////////////////////
//
// The current directory wrath
//
//
//
// Rules:
// - we keep the directory in question in SHORT form
// - if the length of it exceeds what's in CDS -- then we
//   keep it in LCDS

// current directory is stored:
// TDB -- \foo\blah
// cds -- c:\foo\blah
// getcurrentdirectory apis return foo\blah
//

#define MAX_DOS_DRIVES 26

#define CD_NOTDB         0x00010000 // ignore tdb
#define CD_NOCDS         0x00020000 // ignore cds
#define CD_DIRNAMEMASK   0x0000FFFF
#define CD_SHORTDIRNAME  0x00000001
#define CD_LONGDIRNAME   0x00000002
#define CD_CDSDIRNAME    0x00000003


typedef enum tagDirType {
   dtLFNDirName = CD_LONGDIRNAME,
   dtShortDirName = CD_SHORTDIRNAME,
   dtCDSDirName = CD_CDSDIRNAME
}  enumDirType;

// drive here is 0-25

// check whether we received this ptr from wow

BOOL (*DosWowGetTDBDir)(UCHAR Drive, LPSTR pCurrentDirectory);
VOID (*DosWowUpdateTDBDir)(UCHAR Drive, LPSTR pCurrentDirectory);
BOOL (*DosWowDoDirectHDPopup)(VOID);

// makes sure cds directory is valid

BOOL dempValidateDirectory (PCDS pcds, UCHAR Drive)
{
    DWORD dw;
    CHAR  chDrive;
    static CHAR  pPath[]="?:\\";
    static CHAR  EnvVar[] = "=?:";

    // validate media
    chDrive = Drive + 'A';
    pPath[0] = chDrive;
    dw = GetFileAttributesOemSys(pPath, TRUE);
    if (dw == 0xFFFFFFFF || !(dw & FILE_ATTRIBUTE_DIRECTORY)) {
       return (FALSE);
    }

    // if invalid path, set path to the root
    // reset CDS, and win32 env for win32
    dw = GetFileAttributesOemSys(pcds->CurDir_Text, TRUE);
    if (dw == 0xFFFFFFFF || !(dw & FILE_ATTRIBUTE_DIRECTORY)) {
       strcpy(pcds->CurDir_Text, pPath);
       pcds->CurDir_End = 2;
       EnvVar[1] = chDrive;
       SetEnvironmentVariableOem(EnvVar,pPath);
    }

    return (TRUE);
}


// drive here is 0-25
// returns: pointer to cds entry

PCDS dempGetCDSPtr(USHORT Drive)
{
   PCDS pCDS = NULL;
   static CHAR Path[] = "?:\\";

   if (Drive >= (USHORT)*(PUCHAR)DosWowData.lpCDSCount) {
      // so it's more than fixed
      if (Drive <= (MAX_DOS_DRIVES-1)) {
         Path[0] = 'A' + Drive;
         if ((USHORT)*(PUCHAR)DosWowData.lpCurDrv == Drive || DPM_GetDriveType(Path) > DRIVE_NO_ROOT_DIR) {
            pCDS = (PCDS)DosWowData.lpCDSBuffer;
         }
      }
   }
   else {
      Path[0] = 'A' + Drive;
      if (1 != Drive || (DRIVE_REMOVABLE == DPM_GetDriveType(Path))) {
         pCDS = (PCDS)DosWowData.lpCDSFixedTable;
#ifdef FE_SB
         if (GetSystemDefaultLangID() == MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT)) {
             pCDS = (PCDS)((ULONG)pCDS + (Drive*sizeof(CDS_JPN)));
         }
         else
             pCDS = (PCDS)((ULONG)pCDS + (Drive*sizeof(CDS)));
#else
         pCDS = (PCDS)((ULONG)pCDS + (Drive*sizeof(CDS)));
#endif
      }
   }
   return pCDS;
}

#define MAXIMUM_VDM_CURRENT_DIR 64

BOOL
dempUpdateCDS(USHORT Drive, PCDS pcds)
{
   // update cds with the current directory as specified in env variable
   // please note that it only happens upon a flag being reset in cds

   static CHAR  EnvVar[] = "=?:";
   DWORD EnvVarLen;
   BOOL bStatus = TRUE;
   UCHAR FixedCount;
   int i;
   PCDS pcdstemp;

   FixedCount = *(PUCHAR) DosWowData.lpCDSCount;
   //
   // from Macro.Asm in DOS:
   // ; Sudeepb 20-Dec-1991 ; Added for redirected drives
   // ; We always sync the redirected drives. Local drives are sync
   // ; as per the curdir_tosync flag and SCS_ToSync
   //

   if (*(PUCHAR)DosWowData.lpSCS_ToSync) {

#ifdef FE_SB
       if (GetSystemDefaultLangID() == MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT)) {
           PCDS_JPN pcdstemp_jpn;

           pcdstemp_jpn = (PCDS_JPN) DosWowData.lpCDSFixedTable;
           for (i=0;i < (int)FixedCount; i++, pcdstemp_jpn++)
               pcdstemp_jpn->CurDirJPN_Flags |= CURDIR_TOSYNC;
       }
       else {
           pcdstemp = (PCDS) DosWowData.lpCDSFixedTable;
           for (i=0;i < (int)FixedCount; i++, pcdstemp++)
               pcdstemp->CurDir_Flags |= CURDIR_TOSYNC;
       }
#else
       pcdstemp = (PCDS) DosWowData.lpCDSFixedTable;
       for (i=0;i < (int)FixedCount; i++, pcdstemp++)
           pcdstemp->CurDir_Flags |= CURDIR_TOSYNC;
#endif

       // Mark tosync in network drive as well
       pcdstemp = (PCDS)DosWowData.lpCDSBuffer;
       pcdstemp->CurDir_Flags |= CURDIR_TOSYNC;

       *(PUCHAR)DosWowData.lpSCS_ToSync = 0;
   }

   // If CDS needs to be synched or if the requested drive is different
   // then the the drive being used by NetCDS go refresh the CDS.
   if ((pcds->CurDir_Flags & CURDIR_TOSYNC) ||
       ((Drive >= FixedCount) && (pcds->CurDir_Text[0] != (Drive + 'A') &&
                                  pcds->CurDir_Text[0] != (Drive + 'a')))) {
       // validate media
       EnvVar[1] = Drive + 'A';
       if((EnvVarLen = GetEnvironmentVariableOem (EnvVar, (LPSTR)pcds,
                                               MAXIMUM_VDM_CURRENT_DIR+3)) == 0){

       // if its not in env then and drive exist then we have'nt
       // yet touched it.

           pcds->CurDir_Text[0] = EnvVar[1];
           pcds->CurDir_Text[1] = ':';
           pcds->CurDir_Text[2] = '\\';
           pcds->CurDir_Text[3] = 0;
           SetEnvironmentVariableOem ((LPSTR)EnvVar,(LPSTR)pcds);
       }

       if (EnvVarLen > MAXIMUM_VDM_CURRENT_DIR+3) {
           //
           // The current directory on this drive is too long to fit in the
           // cds. That's ok for a win16 app in general, since it won't be
           // using the cds in this case. But just to be more robust, put
           // a valid directory in the cds instead of just truncating it on
           // the off chance that it gets used.
           //
           pcds->CurDir_Text[0] = EnvVar[1];
           pcds->CurDir_Text[1] = ':';
           pcds->CurDir_Text[2] = '\\';
           pcds->CurDir_Text[3] = 0;
       }

       pcds->CurDir_Flags &= 0xFFFF - CURDIR_TOSYNC;
       pcds->CurDir_End = 2;

   }

   if (!bStatus) {

       *(PUCHAR)DosWowData.lpDrvErr = ERROR_INVALID_DRIVE;
   }

   return (bStatus);
}


// takes:
//           Drive 0-25
// returns:
//           fully-qualified current directory if success
//

NTSTATUS
dempGetCurrentDirectoryTDB(UCHAR Drive, LPSTR pCurDir)
{
   NTSTATUS Status;

   // see if we're wow-bound
   if (NULL != DosWowGetTDBDir) {
      if (DosWowGetTDBDir(Drive, &pCurDir[3])) {
         pCurDir[0] = 'A' + Drive;
         pCurDir[1] = ':';
         pCurDir[2] = '\\';
         return(STATUS_SUCCESS);
      }
   }

   return(NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND));
}

VOID
dempSetCurrentDirectoryTDB(UCHAR Drive, LPSTR pCurDir)
{
   if (NULL != DosWowUpdateTDBDir) {
      DosWowUpdateTDBDir(Drive, pCurDir);
   }
}

NTSTATUS
dempGetCurrentDirectoryCDS(UCHAR Drive, LPSTR pCurDir)
{
   PCDS pCDS;
   NTSTATUS Status = NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND);

   if (NULL != (pCDS = dempGetCDSPtr(Drive))) {
      if (dempUpdateCDS(Drive, pCDS)) {
         // now we can get cds data
         // DOS. sudeepb 30-Dec-1993
         if (!(pCDS->CurDir_Flags & CURDIR_NT_FIX)) {
            // that means -- re-query the drive
            if (!dempValidateDirectory(pCDS, Drive)) {
               return(Status);
            }
         }

         strcpy(pCurDir, &pCDS->CurDir_Text[0]);
         Status = STATUS_SUCCESS;
      }

   }
   return(Status);
}

BOOL
dempValidateDirectoryCDS(PCDS pCDS, UCHAR Drive)
{
   BOOL fValid = TRUE;

   if (NULL == pCDS) {
      pCDS = dempGetCDSPtr(Drive);
   }
   if (NULL != pCDS) {
      if (!(pCDS->CurDir_Flags & CURDIR_NT_FIX)) {
         fValid = dempValidateDirectory(pCDS, Drive);
      }
   }
   return(fValid);
}


// we assume that drive here is 0-based drive number and
// pszDir is a full-formed path

NTSTATUS
dempSetCurrentDirectoryCDS(UCHAR Drive, LPSTR pszDir)
{
   PCDS pCDS;
   NTSTATUS Status = NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND);

   if (NULL != (pCDS = dempGetCDSPtr(Drive))) {
      // cds retrieved successfully

      // now for this drive -- validate

      if (strlen(pszDir) > MAXIMUM_VDM_CURRENT_DIR+3) {
         // put a valid directory in cds just for robustness' sake
         strncpy(&pCDS->CurDir_Text[0], pszDir, 3);
         pCDS->CurDir_Text[3] = '\0';
         Status = STATUS_SUCCESS;
      } else {
         strcpy(&pCDS->CurDir_Text[0], pszDir);
         Status = STATUS_SUCCESS;
      }
   }
   return(Status);
}

NTSTATUS
dempGetCurrentDirectoryWin32(UCHAR Drive, LPSTR pCurDir)
{
   // we do a getenvironment blah instead
   static CHAR EnvVar[] = "=?:\\";
   DWORD EnvVarLen;
   DWORD dwAttributes;
   NTSTATUS Status = STATUS_SUCCESS;

   EnvVar[1] = 'A' + Drive;
   EnvVarLen = GetEnvironmentVariableOem (EnvVar, pCurDir, MAX_PATH);
   if (0 == EnvVarLen) {
      // that was not touched before
      pCurDir[0] = EnvVar[1];
      pCurDir[1] = ':';
      pCurDir[2] = '\\';
      pCurDir[3] = '\0';
      SetEnvironmentVariableOem ((LPSTR)EnvVar,(LPSTR)pCurDir);
   }
   else {
      if (EnvVarLen > MAX_PATH) {
         Status = NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND);
         return(Status);
      }
      // if we're doing it here -- validate dir

      dwAttributes = GetFileAttributesOemSys(pCurDir, TRUE);
      if (0xffffffff == dwAttributes) {
         Status = GET_LAST_STATUS();
      }
      else {
         // now see if this is a directory
         if (!(dwAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            Status = NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND);
         }
      }
   }

   return(Status);
}

// lifted from wdos.c

NTSTATUS
dempSetCurrentDirectoryWin32(UCHAR Drive, LPSTR pCurDir)
{
    static CHAR EnvVar[] = "=?:";
    CHAR chDrive = Drive + 'A';
    BOOL bRet;
    NTSTATUS Status = STATUS_SUCCESS;

    // ok -- we are setting the current directory ONLY if the drive
    // is the current drive for the app

    if (*(PUCHAR)DosWowData.lpCurDrv == Drive) { // if on the current drive--go win32
       bRet = SetCurrentDirectoryOem(pCurDir);
       if (!bRet) {
          Status = GET_LAST_STATUS();
       }
    }
    else {  // verify it's a valid dir
       DWORD dwAttributes;

       dwAttributes = GetFileAttributesOemSys(pCurDir, TRUE);
       bRet = (0xffffffff != dwAttributes) && (dwAttributes & FILE_ATTRIBUTE_DIRECTORY);
       if (!bRet) {
          Status = STATUS_INVALID_HANDLE;
       }
    }

    if (!bRet) {
       return(Status);
    }

    EnvVar[1] = chDrive;
    bRet = SetEnvironmentVariableOem((LPSTR)EnvVar, pCurDir);
    if (!bRet) {
       Status = GET_LAST_STATUS();
    }

    return (Status);
}

NTSTATUS
demGetCurrentDirectoryLong(UCHAR Drive, LPSTR pCurDir, DWORD LongDir)
{
   NTSTATUS Status = NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND);
   CHAR szCurrentDirectory[MAX_PATH];

   // first -- attempt to get the dir from tdb in WOW (if this is wow)
   // unless off course it's been blocked

   if (!(LongDir & CD_NOTDB)) {
      Status = dempGetCurrentDirectoryTDB(Drive, szCurrentDirectory);
   }

   if (!NT_SUCCESS(Status) && !(LongDir & CD_NOCDS)) { // so not TDB -- try CDS
      Status = dempGetCurrentDirectoryCDS(Drive, szCurrentDirectory);
   }

   // so at this point if we've failed -- that means our directory is not
   // good at all. Hence return error -- all means have failed
   // we do the very last in all the things
   if (!NT_SUCCESS(Status)) {
      // this one could be lfn !
      Status = dempGetCurrentDirectoryWin32(Drive, szCurrentDirectory);
   }

   // so we have gone through all the stages --

   if (!NT_SUCCESS(Status)) {
      return(NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND));
   }

   // now see that we convert the dir we have in a proper manner

   switch(LongDir & CD_DIRNAMEMASK) {
   case dtLFNDirName:
      Status = demLFNGetPathName(szCurrentDirectory, pCurDir, fnGetLongPathName, FALSE);
      break;
   case dtCDSDirName:
      if (strlen(szCurrentDirectory) > MAXIMUM_VDM_CURRENT_DIR+3) {
         Status = NT_STATUS_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
         break;
      }
      // intentional fall-through

   case dtShortDirName:
      strcpy(pCurDir, szCurrentDirectory);
      break;
   }

   return Status;
}

// remember -- this should be called with a full-formed path -- short or long

NTSTATUS
demSetCurrentDirectoryLong(UCHAR Drive, LPSTR pCurDir, DWORD LongDir)
{
   NTSTATUS Status;
   CHAR szCurrentDirectory[MAX_PATH];

   // first convert to a short path
   Status = demLFNGetPathName(pCurDir, szCurrentDirectory, fnGetShortPathName, FALSE);
   if (!NT_SUCCESS(Status)) {
      return(Status);
   }

   Status = dempSetCurrentDirectoryWin32(Drive, szCurrentDirectory);
   if (!NT_SUCCESS(Status)) {
      return(Status);
   }

   // first we have to see if we have to poke through
   if (!(LongDir & CD_NOCDS)) {
      // set it in cds
      Status = dempSetCurrentDirectoryCDS(Drive, szCurrentDirectory);
      if (!NT_SUCCESS(Status)) {
         return(Status);
      }
   }

   if (!(LongDir & CD_NOTDB)) {
      dempSetCurrentDirectoryTDB(Drive, szCurrentDirectory);
   }

   return(Status);
}

/* Rules of engagement:
 *
 *    - the env variable -- which ?:= is not useful as it's max length is
 *      limited to 64+3 chars.
 *    - the cds entry is also limited in length
 *    - we have our own entry in the
 *
 *    - jarbats bug 207913
 *      demLFNGetCurrentDirectory, returns an empty string, if the current directory is the root
 *      RtlGetFullPathName_U fails when the first parameter (CurrentDirectory) is an empty string
 *      dempLFNSetCurrentDirectory fails
 *      fix by changing empty string to \
 *
 */


NTSTATUS
dempLFNSetCurrentDirectory(
   PUNICODE_STRING pCurrentDirectory,
   PUINT pDriveNum // optional
)
{
   UNICODE_STRING FullPathName;
   DWORD dwStatus;
   RTL_PATH_TYPE RtlPathType;
   UCHAR Drive;
   BOOL  fCurrentDrive;
   OEM_STRING OemDirectoryName;
   CHAR szFullPathOem[MAX_PATH];
   WCHAR szFullPathUnicode[MAX_PATH];
   LPWSTR lpCurrentDir=L"\\";

   if ( pCurrentDirectory->Buffer && pCurrentDirectory->Buffer[0] != L'\0' ) {
        lpCurrentDir = pCurrentDirectory->Buffer;
   }

   RtlPathType = RtlDetermineDosPathNameType_U(lpCurrentDir);
   // now --

   switch(RtlPathType) {
   case RtlPathTypeDriveAbsolute:

      // this is a chdir on a specific drive  -- is this a current drive ?
      CharUpperBuffW(lpCurrentDir, 1);
      Drive = (UCHAR)(lpCurrentDir[0] - L'A');
      fCurrentDrive = (Drive == *(PUCHAR)DosWowData.lpCurDrv);
      break;

   case RtlPathTypeDriveRelative:
   case RtlPathTypeRelative:
   case RtlPathTypeRooted:

      // this is a chdir on a current drive
      Drive = *(PUCHAR)DosWowData.lpCurDrv;
      fCurrentDrive = TRUE;
      break;

   default:
      // invalid call -- goodbye
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND);
      goto scdExit;
      break;
   }

   // please remember that we should have set the current dir
   // when curdrive gets selected -- hence we can rely upon win32
   // for path expansion...
   // actually this is only true for the current drives. In case of this
   // particular api it may not be true.
   // so -- uncash the current setting here -- bugbug ??


   // now get the full path name

   FullPathName.Buffer = szFullPathUnicode;
   FullPathName.MaximumLength = sizeof(szFullPathUnicode);

   dwStatus = DPM_RtlGetFullPathName_U(lpCurrentDir,
                                   FullPathName.MaximumLength,
                                   FullPathName.Buffer,
                                   NULL);
   // check length and set status
   CHECK_LENGTH_RESULT_RTL_USTR(dwStatus, &FullPathName);

   if (!NT_SUCCESS(dwStatus)) {
      goto scdExit; // exit with status code
   }

   OemDirectoryName.Buffer = szFullPathOem;
   OemDirectoryName.MaximumLength = sizeof(szFullPathOem);

   // convert this stuff (fullpath) to oem

   dwStatus = DemUnicodeStringToDestinationString(&OemDirectoryName,
                                                  &FullPathName,
                                                  FALSE,
                                                  FALSE);
   if (!NT_SUCCESS(dwStatus)) {
      goto scdExit;
   }

   dwStatus = demSetCurrentDirectoryLong(Drive, OemDirectoryName.Buffer, 0);
   if (NULL != pDriveNum) {
      *pDriveNum = Drive;
   }

scdExit:

   return(dwStatus);
}

// this is a compound api that sets both current drive and current directory
// according to what has been specified in a parameter
// the return value is also for the drive number

DWORD
demSetCurrentDirectoryGetDrive(LPSTR lpDirectoryName, PUINT pDriveNum)
{
   PUNICODE_STRING pUnicodeStaticDirectoryName;
   OEM_STRING OemDirectoryName;
   DWORD dwStatus;
   UINT Drive;

   // this is external api callable from wow ONLY -- it depends on
   // deminitcdsptr having been initialized!!! which happens if:
   // -- call has been made through lfn api
   // -- app running on wow (windows app)


   // convert to uni
   pUnicodeStaticDirectoryName = GET_STATIC_UNICODE_STRING_PTR();

   // preamble - convert input parameter/validate

   // init oem counted string
   RtlInitOemString(&OemDirectoryName, lpDirectoryName);

   // convert oem->unicode

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(pUnicodeStaticDirectoryName,
                                             &OemDirectoryName,
                                             FALSE);
#else

   dwStatus = RtlOemStringToUnicodeString(pUnicodeStaticDirectoryName,
                                          &OemDirectoryName,
                                          FALSE);
#endif


   // first we extract the drive
   dwStatus = dempLFNSetCurrentDirectory(pUnicodeStaticDirectoryName, pDriveNum);

   return(dwStatus);
}

// each of these functions could have used OEM thunk in oemuni
// for efficiency purpose we basically do what they did

#if 1

DWORD
demLFNDirectoryControl(
   UINT  uiFunctionCode,
   LPSTR lpDirectoryName)
{
   DWORD dwStatus = STATUS_SUCCESS;
   PUNICODE_STRING pUnicodeStaticDirectoryName;
   OEM_STRING OemDirectoryName;
   BOOL fResult;


   // we use a temp static unicode string
   pUnicodeStaticDirectoryName = GET_STATIC_UNICODE_STRING_PTR();

   // preamble - convert input parameter/validate

   // init oem counted string
   RtlInitOemString(&OemDirectoryName, lpDirectoryName);

   // convert oem->unicode

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(pUnicodeStaticDirectoryName,
                                             &OemDirectoryName,
                                             FALSE);
#else

   dwStatus = RtlOemStringToUnicodeString(pUnicodeStaticDirectoryName,
                                          &OemDirectoryName,
                                          FALSE);
#endif

   if (!NT_SUCCESS(dwStatus)) {
      //
      // fix bizarre behavior of win95 apis
      //
      if (dwStatus == STATUS_BUFFER_OVERFLOW) {
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND);
      }

      return(dwStatus);
   }


   switch (uiFunctionCode) {
   case fnLFNCreateDirectory:

      fResult = DPM_CreateDirectoryW(pUnicodeStaticDirectoryName->Buffer,NULL);
      if (!fResult) {
         dwStatus = GET_LAST_STATUS();
         if (NT_STATUS_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE) == dwStatus ||
             NT_STATUS_FROM_WIN32(ERROR_ALREADY_EXISTS) == dwStatus) {
            dwStatus = NT_STATUS_FROM_WIN32(ERROR_ACCESS_DENIED);
         }
      }
      break;

   case fnLFNRemoveDirectory:

      fResult = DPM_RemoveDirectoryW(pUnicodeStaticDirectoryName->Buffer);
      if (!fResult) {
         dwStatus = GET_LAST_STATUS();
      }
      break;

   case fnLFNSetCurrentDirectory:

      // as it appears, this implementation is not good enough
      // dos does a lot more fun things than just call to an api
      dwStatus = dempLFNSetCurrentDirectory(pUnicodeStaticDirectoryName, NULL);
      break;
   }

   return(dwStatus);
}

#else

DWORD
demLFNDirectoryControl(
   UINT uiFunctionCode,
   LPSTR lpDirectoryName)
{
   BOOL fResult;

   switch(uiFunctionCode) {
   case fnLFNCreateDirectory:
      fResult = CreateDirectoryOem(lpDirectoryName, NULL);
      break;

   case fnLFNRemoveDirectory:
      fResult = RemoveDirectoryOem(lpDirectoryName);
      break;

   case fnLFNSetCurrentDirectory:
      fResult = SetCurrentDirectoryOem(lpDirectoryName);
      break;

   default:
      return(NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION));
   }

   return(fResult ? STATUS_SUCCESS :
                    GET_LAST_STATUS());

}

#endif

/*
 * With this api win95 returns :
 * - int24's are generated
 * - 0x0f if drive is invalid
 * - 0x03 on set to invalid
 *
 *
 *
 *
 */


DWORD
demLFNGetCurrentDirectory(
   UINT  DriveNum,
   LPSTR lpDirectoryName)
{
   // unfortunately, this fn is not present in win nt so we emulate
   DWORD dwStatus;
   CHAR  szCurrentDirectory[MAX_PATH];

   if (0 == DriveNum) {
      DriveNum = (UINT)*(PUCHAR)DosWowData.lpCurDrv;
   }
   else {
      --DriveNum;
   }


   dwStatus = demGetCurrentDirectoryLong((UCHAR)DriveNum, szCurrentDirectory, dtLFNDirName);
   if (NT_SUCCESS(dwStatus)) {
      strcpy(lpDirectoryName, &szCurrentDirectory[3]);
   }
   // done
   return(dwStatus);
}



DWORD
demLFNMoveFile(
   LPSTR lpOldName,
   LPSTR lpNewName)
{
   DWORD dwStatus = STATUS_SUCCESS;
   UNICODE_STRING unicodeOldName;
   UNICODE_STRING unicodeNewName;
   OEM_STRING oemString;

   //
   // Perform a simple check that SRC and DEST are not pointing to the same file.
   // if they do return error 5.

   if (!_stricmp (lpOldName, lpNewName)) {
       dwStatus = NT_STATUS_FROM_WIN32(ERROR_ACCESS_DENIED);
       return (dwStatus);
   }

   RtlInitOemString(&oemString, lpOldName);

   // convert source path from ansi to unicode and allocate result
   // this rtl function returns status code, not the winerror code
   //

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(&unicodeOldName, &oemString, TRUE);

#else

   dwStatus = RtlOemStringToUnicodeString(&unicodeOldName, &oemString, TRUE);

#endif

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }

   dempLFNNormalizePath(&unicodeOldName);


   RtlInitOemString(&oemString, lpNewName);

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(&unicodeNewName, &oemString, TRUE);

#else

   dwStatus = RtlOemStringToUnicodeString(&unicodeNewName, &oemString, TRUE);

#endif


   if (!NT_SUCCESS(dwStatus)) {
      RtlFreeUnicodeString(&unicodeOldName);
      return(dwStatus);
   }

   dempLFNNormalizePath(&unicodeNewName);

   if (!DPM_MoveFileW(unicodeOldName.Buffer, unicodeNewName.Buffer)) {
      dwStatus = GetLastError();
      if (dwStatus == ERROR_ALREADY_EXISTS) {
          dwStatus = ERROR_ACCESS_DENIED;
      }
      dwStatus = NT_STATUS_FROM_WIN32(dwStatus);
   }


   RtlFreeUnicodeString(&unicodeOldName);
   RtlFreeUnicodeString(&unicodeNewName);
   return(dwStatus);
}




DWORD
demLFNGetVolumeInformation(
   LPSTR  lpRootName,
   LPLFNVOLUMEINFO lpVolumeInfo)
{
   DWORD dwStatus = STATUS_SUCCESS;
   DWORD dwFSFlags;

#if 0

   if (_stricmp(lpRootName, "\\:\\")) {
      // special case of edit.com calling us to see if we support LFN when
      // started from a unc path


   }

#endif


   if (!GetVolumeInformationOem(lpRootName,
                                NULL, // name buffer
                                0,
                                NULL, // volume serial num
                                &lpVolumeInfo->dwMaximumFileNameLength,
                                &dwFSFlags,
                                lpVolumeInfo->lpFSNameBuffer,
                                lpVolumeInfo->dwFSNameBufferSize)) {
      dwStatus = GET_LAST_STATUS();
   }
   else {

      dwFSFlags &= LFN_FS_ALLOWED_FLAGS; // clear out anything that is not Win95
      dwFSFlags |= FS_LFN_APIS;          // say we support lfn apis always
      lpVolumeInfo->dwFSFlags = dwFSFlags;

      // this is shaky yet who'd really use it ?
      // 4 = <driveletter><:><\><FileName><\0>
      lpVolumeInfo->dwMaximumPathNameLength = lpVolumeInfo->dwMaximumFileNameLength + 5;
   }

   return(dwStatus);
}



// assume the pFileTime being a UTC format always
// uiMinorCode is enumFileTimeControlMinorCode type

#define AlmostTwoSeconds (2*1000*1000*10 - 1)

DWORD
demLFNFileTimeControl(
   UINT uiMinorCode,
   FILETIME* pFileTime,
   PLFNFILETIMEINFO pFileTimeInfo)
{
   DWORD dwStatus = STATUS_SUCCESS;
   TIME_FIELDS TimeFields;
   LARGE_INTEGER Time;
   USHORT u;
   FILETIME ftLocal;
   BOOL fResult;


   switch(uiMinorCode & FTCTL_CODEMASK) {
   case fnFileTimeToDosDateTime:

      if (!(uiMinorCode & FTCTL_UTCTIME)) {
         if (!FileTimeToLocalFileTime(pFileTime, &ftLocal)) {
            dwStatus = GET_LAST_STATUS();
            break; // break out as the conv error occured
         }
      }
      else {
         ftLocal = *pFileTime;   // just utc file time
      }

      Time.LowPart  = ftLocal.dwLowDateTime;
      Time.HighPart = ftLocal.dwHighDateTime;
      Time.QuadPart += (LONGLONG)AlmostTwoSeconds;

      RtlTimeToTimeFields(&Time, &TimeFields);

      if (TimeFields.Year < (USHORT)1980 || TimeFields.Year > (USHORT)2107) {
         pFileTimeInfo->uDosDate = (1 << 5) | 1; // January, 1st, 1980
         pFileTimeInfo->uDosTime = 0;
         pFileTimeInfo->uMilliseconds = 0;
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_DATA);
      }
      else {
         pFileTimeInfo->uDosDate = (USHORT)(
                           ((USHORT)(TimeFields.Year-(USHORT)1980) << 9) |
                           ((USHORT)TimeFields.Month << 5) |
                           (USHORT)TimeFields.Day
                           );

         pFileTimeInfo->uDosTime = (USHORT)(
                           ((USHORT)TimeFields.Hour << 11) |
                           ((USHORT)TimeFields.Minute << 5) |
                           ((USHORT)TimeFields.Second >> 1)
                           );

         // set the spillover so we can correctly retrieve the seconds
         // we are talking of milliseconds in units of 10
         // so the max value here is 199

         pFileTimeInfo->uMilliseconds = ((TimeFields.Second & 0x1) * 1000 +
                                          TimeFields.Milliseconds) / 10;
      }
      break;

   case fnDosDateTimeToFileTime:
      // here the process is backwards
      u = pFileTimeInfo->uDosDate;

      TimeFields.Year  = ((u & 0xFE00) >> 9) + (USHORT)1980;
      TimeFields.Month = ((u & 0x01E0) >> 5);
      TimeFields.Day   =  (u & 0x001F);

      u = pFileTimeInfo->uDosTime;

      TimeFields.Hour   = (u  & 0xF800) >> 11;
      TimeFields.Minute = (u  & 0x07E0) >> 5;
      TimeFields.Second = (u  & 0x001F) << 1; // seconds as multiplied...

      // correction
      u = pFileTimeInfo->uMilliseconds * 10; // approx millisecs
      TimeFields.Second += u / 1000;
      TimeFields.Milliseconds = u % 1000;

      if (RtlTimeFieldsToTime(&TimeFields, &Time)) {

         // now convert to global time
         ftLocal.dwLowDateTime  = Time.LowPart;
         ftLocal.dwHighDateTime = Time.HighPart;
         if (!LocalFileTimeToFileTime(&ftLocal, pFileTime)) {
            dwStatus = GET_LAST_STATUS();
         }
      }
      else {
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_DATA);
      }

      break;

   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION);
      break;
   }

   return(dwStatus);

}



NTSTATUS
dempLFNSetFileTime(
   UINT uMinorCode,
   PUNICODE_STRING pFileName,
   PLFNFILETIMEINFO pTimeInfo)
{
   OBJECT_ATTRIBUTES ObjAttributes;
   HANDLE hFile;
   UNICODE_STRING FileName;
   RTL_RELATIVE_NAME_U RelativeName;
   BOOL TranslationStatus;
   PVOID FreeBuffer;
   FILE_BASIC_INFORMATION FileBasicInfo;
   IO_STATUS_BLOCK IoStatusBlock;
   LPFILETIME pFileTime;
   NTSTATUS dwStatus;


   //
   // Prepare info
   //

   RtlZeroMemory(&FileBasicInfo, sizeof(FileBasicInfo));
   switch(uMinorCode) {
   case fnSetCreationDateTime:
      pFileTime = (LPFILETIME)&FileBasicInfo.CreationTime;
      break;

   case fnSetLastAccessDateTime:
      pFileTime = (LPFILETIME)&FileBasicInfo.LastAccessTime;
      break;

   case fnSetLastWriteDateTime:
      pFileTime = (LPFILETIME)&FileBasicInfo.LastWriteTime;
      break;
   }

   dwStatus = demLFNFileTimeControl(fnDosDateTimeToFileTime,
                                    pFileTime,
                                    pTimeInfo);

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }


   TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(pFileName->Buffer,
                                                            &FileName,
                                                            NULL,
                                                            &RelativeName);

   if (!TranslationStatus) {
      return(NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND));
   }

   FreeBuffer = FileName.Buffer;

   // this is relative-path optimization stolen from filehops.c in base/client

   if (0 != RelativeName.RelativeName.Length) {
      FileName = RelativeName.RelativeName;
   }
   else {
      RelativeName.ContainingDirectory = NULL;
   }

   InitializeObjectAttributes(
       &ObjAttributes,
       &FileName,
       OBJ_CASE_INSENSITIVE,
       RelativeName.ContainingDirectory,
       NULL
       );

   //
   // Open the file
   //

   dwStatus = DPM_NtOpenFile(
               &hFile,
               FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
               &ObjAttributes,
               &IoStatusBlock,
               FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
               FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
               );

   RtlReleaseRelativeName(&RelativeName);
   RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }

   //
   // Set file basic info.
   //

   dwStatus = NtSetInformationFile(
               hFile,
               &IoStatusBlock,
               &FileBasicInfo,
               sizeof(FileBasicInfo),
               FileBasicInformation
               );

   NtClose(hFile);

   return(dwStatus);
}



NTSTATUS
dempLFNGetFileTime(
   UINT uMinorCode,
   PUNICODE_STRING pFileName,
   PLFNFILETIMEINFO pTimeInfo)
{

   OBJECT_ATTRIBUTES ObjAttributes;
   UNICODE_STRING FileName;
   RTL_RELATIVE_NAME_U RelativeName;
   BOOL TranslationStatus;
   PVOID FreeBuffer;
   LPFILETIME pFileTime;
   NTSTATUS dwStatus;
   FILE_NETWORK_OPEN_INFORMATION NetworkInfo;

   TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(pFileName->Buffer,
                                                            &FileName,
                                                            NULL,
                                                            &RelativeName);

   if (!TranslationStatus) {
      return(NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND));
   }

   FreeBuffer = FileName.Buffer;

   // this is relative-path optimization stolen from filehops.c in base/client

   if (0 != RelativeName.RelativeName.Length) {
      FileName = RelativeName.RelativeName;
   }
   else {
      RelativeName.ContainingDirectory = NULL;
   }

   InitializeObjectAttributes(
       &ObjAttributes,
       &FileName,
       OBJ_CASE_INSENSITIVE,
       RelativeName.ContainingDirectory,
       NULL
       );


   dwStatus = NtQueryFullAttributesFile( &ObjAttributes, &NetworkInfo);
   RtlReleaseRelativeName(&RelativeName);
   RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }

   switch (uMinorCode) {
   case fnGetCreationDateTime:
      pFileTime = (LPFILETIME)&NetworkInfo.CreationTime;
      break;

   case fnGetLastAccessDateTime:
      pFileTime = (LPFILETIME)&NetworkInfo.LastAccessTime;
      break;

   case fnGetLastWriteDateTime:
      pFileTime = (LPFILETIME)&NetworkInfo.LastWriteTime;
      break;
   }

   // assert here against pFileTime

   // convert to dos style
   dwStatus = demLFNFileTimeControl(fnFileTimeToDosDateTime |
                                       (dempUseUTCTimeByName(pFileName) ? FTCTL_UTCTIME : 0),
                                    pFileTime,
                                    pTimeInfo);
   if (!NT_SUCCESS(dwStatus) &&
       NT_STATUS_FROM_WIN32(ERROR_INVALID_DATA) == dwStatus &&
       fnGetLastWriteDateTime == uMinorCode) {
      dwStatus = STATUS_SUCCESS;
   }

   return(dwStatus);
}


NTSTATUS
demLFNGetSetFileAttributes(
   UINT uMinorCode,
   LPSTR lpFileName,
   PLFNFILEATTRIBUTES pLFNFileAttributes)
{
   PUNICODE_STRING pUnicodeStaticFileName;
   OEM_STRING oemFileName;
   NTSTATUS dwStatus = STATUS_SUCCESS;


   pUnicodeStaticFileName = GET_STATIC_UNICODE_STRING_PTR();

   RtlInitOemString(&oemFileName, lpFileName);

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(pUnicodeStaticFileName,
                                             &oemFileName,
                                             FALSE);
#else

   dwStatus = RtlOemStringToUnicodeString(pUnicodeStaticFileName,
                                          &oemFileName,
                                          FALSE);
#endif

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }

   dempLFNNormalizePath(pUnicodeStaticFileName);

   switch(uMinorCode) {
   case fnGetFileAttributes:
      {
         DWORD dwAttributes;

         // attention! BUGBUG
         // need to check for volume id here - if the name actually matches...

         dwAttributes = DPM_GetFileAttributesW(pUnicodeStaticFileName->Buffer);
         if ((DWORD)-1 == dwAttributes) {
            dwStatus = GET_LAST_STATUS();
         }
         else {
            pLFNFileAttributes->wFileAttributes = (WORD)(dwAttributes & DEM_FILE_ATTRIBUTE_VALID);
         }
      }
      break;

   case fnSetFileAttributes:
      {
         DWORD dwAttributes;

         // this is how win95 handles this api:
         // the volume bit is valid but ignored, setting everything else but
         // DEM_FILE_ATTRIBUTE_SET_VALID is causing error 0x5 (access denied)
         //

         dwAttributes = (DWORD)pLFNFileAttributes->wFileAttributes;

         if (dwAttributes & (~(DEM_FILE_ATTRIBUTE_SET_VALID |
                               DEM_FILE_ATTRIBUTE_VOLUME_ID))) {
            dwStatus = NT_STATUS_FROM_WIN32(ERROR_ACCESS_DENIED);
         }
         else {

            dwAttributes &= DEM_FILE_ATTRIBUTE_SET_VALID; // clear possible volume id

            if (!DPM_SetFileAttributesW(pUnicodeStaticFileName->Buffer, dwAttributes)) {
               dwStatus = GET_LAST_STATUS();
            }
         }
      }
      break;

   case fnGetCompressedFileSize:
      {
         DWORD dwFileSize;


         dwFileSize = GetCompressedFileSizeW(pUnicodeStaticFileName->Buffer,
                                             NULL); // for dos we have no high part
         if ((DWORD)-1 == dwFileSize) {
            dwStatus = GET_LAST_STATUS();
         }
         else {
            pLFNFileAttributes->dwFileSize = dwFileSize;
         }
      }
      break;

   case fnSetLastWriteDateTime:
   case fnSetCreationDateTime:
   case fnSetLastAccessDateTime:
      dwStatus = dempLFNSetFileTime(uMinorCode,
                                    pUnicodeStaticFileName,
                                    &pLFNFileAttributes->TimeInfo);
      break;


   case fnGetLastAccessDateTime:
   case fnGetCreationDateTime:
   case fnGetLastWriteDateTime:
      dwStatus = dempLFNGetFileTime(uMinorCode,
                                    pUnicodeStaticFileName,
                                    &pLFNFileAttributes->TimeInfo);
      break;


   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION);
      break;
   }

   return(dwStatus);
}


BOOL
dempUseUTCTimeByHandle(
   HANDLE hFile)
{
   // if file is on a cdrom -- then we use utc time as opposed to other
   // local time
   NTSTATUS Status;
   IO_STATUS_BLOCK IoStatusBlock;
   FILE_FS_DEVICE_INFORMATION DeviceInfo;
   BOOL fUseUTCTime = FALSE;

   Status = NtQueryVolumeInformationFile(hFile,
                                         &IoStatusBlock,
                                         &DeviceInfo,
                                         sizeof(DeviceInfo),
                                         FileFsDeviceInformation);
   if (NT_SUCCESS(Status)) {
      // we look at the characteristics of this particular device --
      // if the media is cdrom -- then we DO NOT need to convert to local time
      fUseUTCTime = (DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA) &&
                        (DeviceInfo.DeviceType == FILE_DEVICE_CD_ROM ||
                         DeviceInfo.DeviceType == FILE_DEVICE_CD_ROM_FILE_SYSTEM);
   }

   return(fUseUTCTime);
}

BOOL
dempUseUTCTimeByName(
   PUNICODE_STRING pFileName)
{
   DWORD Status;
   UNICODE_STRING UnicodeFullPath;
   WCHAR wszFullPath[MAX_PATH];
   RTL_PATH_TYPE RtlPathType;
   BOOL fUseUTCTime = FALSE;

   dempStringInitZeroUnicode(&UnicodeFullPath,
                             wszFullPath,
                             sizeof(wszFullPath)/sizeof(wszFullPath[0]));

   Status = DPM_RtlGetFullPathName_U(pFileName->Buffer,
                                 UnicodeFullPath.MaximumLength,
                                 UnicodeFullPath.Buffer,
                                 NULL);

   CHECK_LENGTH_RESULT_RTL_USTR(Status, &UnicodeFullPath);
   if (NT_SUCCESS(Status)) {
      RtlPathType = RtlDetermineDosPathNameType_U(UnicodeFullPath.Buffer);
      if (RtlPathTypeDriveAbsolute == RtlPathType) { // see that we have a valid root dir
         wszFullPath[3] = L'\0';
         fUseUTCTime = (DRIVE_CDROM == DPM_GetDriveTypeW(wszFullPath));
      }

   }
   return(fUseUTCTime);
}



/*
 * Handle a file handle - based time apis
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

NTSTATUS
dempGetFileTimeByHandle(
   UINT uFunctionCode,
   HANDLE hFile,
   PLFNFILETIMEINFO pTimeInfo)
{
   NTSTATUS dwStatus;
   FILETIME* pCreationTime   = NULL;
   FILETIME* pLastAccessTime = NULL;
   FILETIME* pLastWriteTime  = NULL;
   FILETIME FileTime;

   switch (uFunctionCode) {
   case fnFTGetLastWriteDateTime:
      pLastWriteTime = &FileTime;
      break;

   case fnFTGetLastAccessDateTime:
      pLastAccessTime = &FileTime;
      break;

   case fnFTGetCreationDateTime:
      pCreationTime = &FileTime;
      break;
   }

   if (GetFileTime(hFile, pCreationTime, pLastAccessTime, pLastWriteTime)) {
      // now convert the result
      dwStatus = demLFNFileTimeControl(fnFileTimeToDosDateTime |
                                          (dempUseUTCTimeByHandle(hFile) ? FTCTL_UTCTIME : 0),
                                       &FileTime,
                                       pTimeInfo);
       if (!NT_SUCCESS(dwStatus) &&
           NT_STATUS_FROM_WIN32(ERROR_INVALID_DATA) == dwStatus &&
           fnFTGetLastWriteDateTime == uFunctionCode) {
          dwStatus = STATUS_SUCCESS;
       }

   }
   else {
      dwStatus = GET_LAST_STATUS();
   }

   return(dwStatus);
}


/*
 *  This is a special wow32 - callable function for getting file time by handle
 *  from wow. We have not done any extensive checking (like in demFileTimes
 *  but rather provided for the behavior consistent with wow
 *
 *
 *
 */

ULONG demGetFileTimeByHandle_WOW(
   HANDLE hFile)
{
   LFNFILETIMEINFO fti;
   NTSTATUS Status;

   Status = dempGetFileTimeByHandle(fnFTGetLastWriteDateTime,
                                    hFile,
                                    &fti);
   if (NT_SUCCESS(Status)) {
       return (fti.uDosTime | ((ULONG)fti.uDosDate << 16));
   }

   return(0xFFFF);
}



NTSTATUS
dempSetFileTimeByHandle(
   UINT uFunctionCode,
   HANDLE hFile,
   PLFNFILETIMEINFO pTimeInfo)
{

   NTSTATUS dwStatus;
   FILETIME* pCreationTime   = NULL;
   FILETIME* pLastAccessTime = NULL;
   FILETIME* pLastWriteTime  = NULL;
   FILETIME FileTime;

   //
   // see which time we are setting and fixup parameters
   //

   switch (uFunctionCode) {
   case fnFTSetLastWriteDateTime:
      pLastWriteTime = &FileTime;
      pTimeInfo->uMilliseconds = 0; // not supported
      break;

   case fnFTSetLastAccessDateTime:
      pLastAccessTime = &FileTime;
      pTimeInfo->uMilliseconds = 0; // not supported

      // time is also not supported in this function and should be somehow
      // ignored, but Win95 resets the time to 0 every time this fn is
      // executed - we monkey
      //

      pTimeInfo->uDosTime = 0;

      break;

   case fnFTSetCreationDateTime:
      pCreationTime = &FileTime;
      break;
   }

   dwStatus = demLFNFileTimeControl(fnDosDateTimeToFileTime,
                                    &FileTime,
                                    pTimeInfo);
   if (NT_SUCCESS(dwStatus)) {
      // set the file time
      if (!SetFileTime(hFile, pCreationTime, pLastAccessTime, pLastWriteTime)) {
         dwStatus = GET_LAST_STATUS();
      }
   }

   return(dwStatus);
}


/* Function
 *    demFileTimes
 *    works for all handle-based file time apis
 *
 * Parameters
 *    None
 *
 * Returns
 *    Nothing
 *
 * Note
 *    This function is for handling real-mode cases only
 *    reason: using getXX macros instead of frame-based getUserXX macros
 *
 *
 */


VOID
demFileTimes(VOID)
{
   UINT uFunctionCode;
   LFNFILETIMEINFO TimeInfo;
   NTSTATUS dwStatus = STATUS_SUCCESS;
   PVOID pUserEnvironment;
   PDOSSFT pSFT = NULL;
   HANDLE hFile;

   uFunctionCode = (UINT)getAL();

   hFile = VDDRetrieveNtHandle((ULONG)NULL,    // uses current pdb
                               getBX(), // dos handle
                               (PVOID*)&pSFT,   // retrieve sft ptr
                               NULL);   // no jft pleast

   //
   // it is possible to have NULL nt handle for the particular file -
   // e.g. stdaux, stdprn devices
   //
   // We are catching only the case of bad dos handle here
   //

   if (NULL == pSFT && NULL == hFile) {
      //
      // invalid handle value here
      //
      // We know that dos handles it in the same way, so we just
      // put error code in, set carry and return
      //
      setAX((USHORT)ERROR_INVALID_HANDLE);
      setCF(1);
      return;
   }


   switch(uFunctionCode) {
   case fnFTGetCreationDateTime:
   case fnFTGetLastWriteDateTime:
   case fnFTGetLastAccessDateTime:
      if (pSFT->SFT_Flags & SFTFLAG_DEVICE_ID) {

         SYSTEMTIME stCurrentTime;
         FILETIME FileTime;

         //
         // for a local device return current time
         //

         GetSystemTime(&stCurrentTime);
         SystemTimeToFileTime(&stCurrentTime, &FileTime);
         // now make a dos file time
         dwStatus = demLFNFileTimeControl(fnFileTimeToDosDateTime,
                                          &FileTime,
                                          &TimeInfo);
      }
      else {
         dwStatus = dempGetFileTimeByHandle(uFunctionCode,
                                            hFile,
                                            &TimeInfo);
      }

      if (NT_SUCCESS(dwStatus)) {
         // set the regs
         pUserEnvironment = dempGetDosUserEnvironment();

         setUserDX(TimeInfo.uDosDate, pUserEnvironment);
         setUserCX(TimeInfo.uDosTime, pUserEnvironment);

         // if this was a creation date/time then set msecs
         if (fnGetCreationDateTime != uFunctionCode) {
            TimeInfo.uMilliseconds = 0;
         }

         // Note that this is valid only for new (LFN) functions
         // and not for the old functionality (get/set last write)
         // -- BUGBUG (what do other cases amount to on Win95)

         if (fnFTGetLastWriteDateTime != uFunctionCode) {
            setUserSI(TimeInfo.uMilliseconds, pUserEnvironment);
         }

      }
      break;

   case fnFTSetCreationDateTime:
   case fnFTSetLastWriteDateTime:
   case fnFTSetLastAccessDateTime:
      if (!(pSFT->SFT_Flags & SFTFLAG_DEVICE_ID)) {

         // if this is a local device and a request to set time
         // then as dos code does it, we just return ok
         // we set times here for all other stuff

         TimeInfo.uDosDate = getDX();
         TimeInfo.uDosTime = getCX(); // for one of those it is 0 (!!!)

         //
         // we just retrieve value that will be ignored later
         // for some of the functions
         //


         TimeInfo.uMilliseconds = getSI();

         dwStatus = dempSetFileTimeByHandle(uFunctionCode,
                                            hFile,
                                            &TimeInfo);
      }


      break;

   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION);
      break;
   }

   if (NT_SUCCESS(dwStatus)) {
      setCF(0);
   }
   else {

      //
      // demClientError sets cf and appropriate registers
      //

      SetLastError(WIN32_ERROR_FROM_NT_STATUS(dwStatus));
      demClientError(hFile, (CHAR)-1);
   }
}


/*
 * Open file (analogous to 6c)
 * This actually calls into CreateFile and is quite similar in
 * behaviour (with appropriate restrictions)
 *
 * uModeAndFlags
 * Combination of OPEN_* stuff
 *
 * uAttributes
 * See DEM_FILE_ATTRIBUTES_VALID
 *
 *
 *
 *
 *
 */



NTSTATUS
demLFNOpenFile(
   LPSTR  lpFileName,
   USHORT uModeAndFlags,
   USHORT uAttributes,
   USHORT uAction,
   USHORT uAliasHint, // ignored
   PUSHORT puDosHandle,
   PUSHORT puActionTaken)
{

   // convert the filename please
   PUNICODE_STRING pUnicodeStaticFileName;
   OEM_STRING OemFileName;
   NTSTATUS dwStatus;
   DWORD dwCreateDistribution;
   DWORD dwDesiredAccess;
   DWORD dwShareMode;
   DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
   HANDLE hFile;
   USHORT uDosHandle;
   PDOSSFT   pSFT;
   BOOL   fFileExists;
   USHORT uActionTaken = ACTION_OPENED;

   // convert the filename in question

   pUnicodeStaticFileName = GET_STATIC_UNICODE_STRING_PTR();

   RtlInitOemString(&OemFileName, lpFileName);

   // convert oem->unicode

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(pUnicodeStaticFileName,
                                             &OemFileName,
                                             FALSE);
#else

   dwStatus = RtlOemStringToUnicodeString(pUnicodeStaticFileName,
                                          &OemFileName,
                                          FALSE);
#endif

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }


   if (uModeAndFlags & DEM_FILE_ATTRIBUTE_VOLUME_ID) {
      // process this completely separately
      ;
      return(NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION));
   }


   // we are calling into CreateFile with it's flags
   // so find out what we are set to do first
   // as determined by MSDN
   //   FILE_CREATE   (0010h)  Creates a new file if it does not
   //                           already exist. The function fails if
   //                           the file already exists.
   //   FILE_OPEN     (0001h)  Opens the file. The function fails if
   //                           the file does not exist.
   //   FILE_TRUNCATE (0002h)  Opens the file and truncates it to zero
   //                           length (replaces the existing file).
   //                           The function fails if the file does not exist.
   //
   //   The only valid combinations are FILE_CREATE combined with FILE_OPEN
   //   or FILE_CREATE combined with FILE_TRUNCATE.

   switch(uAction & 0x0f) {
   case DEM_OPEN_ACTION_FILE_OPEN:
      if (uAction & DEM_OPEN_ACTION_FILE_CREATE) {
         dwCreateDistribution = OPEN_ALWAYS;
      }
      else {
         dwCreateDistribution = OPEN_EXISTING;
      }
      break;

   case DEM_OPEN_ACTION_FILE_TRUNCATE:
      if (uAction & DEM_OPEN_ACTION_FILE_CREATE) {
         // this is an unmappable situation
         //
         dwCreateDistribution = OPEN_ALWAYS;
         // we truncate ourselves
         // note that we need access mode to permit this !!!

      }
      else {
         dwCreateDistribution = TRUNCATE_EXISTING;
      }
      break;


   case 0:   // this is the case that could only be file_create call
      if (uAction == DEM_OPEN_ACTION_FILE_CREATE) {
         dwCreateDistribution = CREATE_NEW;
         break;
      }
      // else we fall through to the bad param return

   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER);
      return(dwStatus);
      break;
   }

   // now see what sort of sharing mode we can inflict upon ourselves


   switch(uModeAndFlags & DEM_OPEN_SHARE_MASK) {
   case DEM_OPEN_SHARE_COMPATIBLE:
      // the reason we see share_delete here is to emulate compat mode
      // behaviour requiring to fail if any other (than compat) mode was
      // used to open the file

      dwShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE;
      break;

   case DEM_OPEN_SHARE_DENYREADWRITE:
      dwShareMode = 0;
      break;

   case DEM_OPEN_SHARE_DENYWRITE:
      dwShareMode = FILE_SHARE_READ;
      break;

   case DEM_OPEN_SHARE_DENYREAD:
      dwShareMode = FILE_SHARE_WRITE;
      break;

   case DEM_OPEN_SHARE_DENYNONE:
      dwShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;
      break;

   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER);
      return(dwStatus);
      break;
   }

   // now crack the access mode to fill in dwDesiredAccess

   switch(uModeAndFlags & DEM_OPEN_ACCESS_MASK) {

   case DEM_OPEN_ACCESS_READONLY:
      dwDesiredAccess = GENERIC_READ;
      break;

   case DEM_OPEN_ACCESS_WRITEONLY:
      dwDesiredAccess = GENERIC_WRITE;
      break;

   case DEM_OPEN_ACCESS_READWRITE:
      dwDesiredAccess = GENERIC_READ|GENERIC_WRITE;
      break;

   case DEM_OPEN_ACCESS_RO_NOMODLASTACCESS:
      // although this is a weird mode - we care not for the last
      // access time - proper implementation would have been to
      // provide for a last access time retrieval and reset upon
      // closing the file
      // Put a message up here and a breakpoint

      dwDesiredAccess = GENERIC_READ;
      break;


   case DEM_OPEN_ACCESS_RESERVED:
   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER);
      return(dwStatus);
      break;

   }

   // and now crack the flags used -
   // fill in the flags portion of dwFlagsAndAttributes

   if ((uModeAndFlags & DEM_OPEN_FLAGS_MASK) & (~DEM_OPEN_FLAGS_VALID)) {
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER);
      return(dwStatus);
   }

   if (uModeAndFlags & DEM_OPEN_FLAGS_NO_BUFFERING) {
      // if unbuffered mode is used then the buffer is to be aligned on
      // a volume sector size boundary. This is not necessarily true for
      // win95 or is it ?
      dwFlagsAndAttributes |= FILE_FLAG_NO_BUFFERING;
   }

   if (uModeAndFlags & DEM_OPEN_FLAGS_COMMIT) {
      dwFlagsAndAttributes |= FILE_FLAG_WRITE_THROUGH;
   }

   if (uModeAndFlags & DEM_OPEN_FLAGS_ALIAS_HINT) {
      // print a message, ignore the hint
      ;
   }


   if (uModeAndFlags & DEM_OPEN_FLAGS_NO_COMPRESS) {
      // what the heck we do with this one ?
      ;
   }

   // set the attributes

   dwFlagsAndAttributes |= ((DWORD)uAttributes & DEM_FILE_ATTRIBUTE_SET_VALID);

   dempLFNNormalizePath(pUnicodeStaticFileName);

   // out we go
   {
       //
       // Need to create this because if we don't, any process we cause to be launched will not
       // be able to inherit handles (ie: launch FINDSTR.EXE via 21h/4bh to pipe to a file
       // ala NT Bug 199416 - bjm)
       //
       SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), NULL, TRUE  };

       hFile = DPM_CreateFileW(pUnicodeStaticFileName->Buffer,
                       dwDesiredAccess,
                       dwShareMode,
                       &sa,   /// NULL, // no security attr here
                       dwCreateDistribution,
                       dwFlagsAndAttributes,
                       NULL);
   }

   // now see what the return should be

   dwStatus = GetLastError();

   fFileExists = ERROR_ALREADY_EXISTS == dwStatus;

   if (INVALID_HANDLE_VALUE == hFile) {
      return(NT_STATUS_FROM_WIN32(dwStatus));
   }


   if (fFileExists) {
      if ((DEM_OPEN_ACTION_FILE_TRUNCATE|DEM_OPEN_ACTION_FILE_CREATE) == uAction) {
         if (FILE_TYPE_DISK == DPM_GetFileType(hFile) ) {
            // truncate the file here please
            if (!DPM_SetEndOfFile(hFile)) {
               dwStatus = GET_LAST_STATUS();
               DPM_CloseHandle(hFile);
               return (dwStatus);
            }

            uActionTaken = ACTION_REPLACED_OPENED;
         }
         else {
            uActionTaken = ACTION_CREATED_OPENED;
         }
      }
   }
   else {
      if (DEM_OPEN_ACTION_FILE_CREATE & uAction) {
         uActionTaken = ACTION_CREATED_OPENED;
      }
   }


   // now we insert the handle and allocate a dos handle
   uDosHandle = VDDAllocateDosHandle(0L, (PVOID*)&pSFT, NULL);

   if ((SHORT)uDosHandle < 0) {
      DPM_CloseHandle(hFile);
      return(NT_STATUS_FROM_WIN32((DWORD)(-(SHORT)uDosHandle)));
   }
   else {
      WCHAR drive = 0, *pwchBuffer;
      ULONG length;

      pwchBuffer = RtlAllocateHeap(RtlProcessHeap(),
                                 0,
                                 MAX_PATH * sizeof(WCHAR));
      if (pwchBuffer)
      {
          length = DPM_RtlGetFullPathName_U(pUnicodeStaticFileName->Buffer,
                                      MAX_PATH * sizeof(WCHAR),
                                      pwchBuffer,
                                      NULL);
          if (length != 0 && length <= MAX_PATH * sizeof(WCHAR))
          {
              if (pwchBuffer[1] == L':')
              {
                  drive = RtlUpcaseUnicodeChar(pwchBuffer[0]) - L'A';
              }
          }
          RtlFreeHeap(RtlProcessHeap(), 0, pwchBuffer);
      }
      // we have obtained a good handle here
      // so place the nt handle into sft

      pSFT->SFT_Mode     = uModeAndFlags & 0x7f;  // up to no_inherit bit
      pSFT->SFT_Attr     = 0;                     // Not used.
      pSFT->SFT_Flags    = (uModeAndFlags & DEM_OPEN_FLAGS_NOINHERIT) ? 0x1000 : 0; // copy no_inherit bit.
      pSFT->SFT_Flags    |= (UCHAR)drive;         // add the drive number bits
      pSFT->SFT_Devptr   = (ULONG) -1;
      pSFT->SFT_NTHandle = (ULONG) hFile;

      *puActionTaken = uActionTaken;
      *puDosHandle = uDosHandle;
   }


   return(STATUS_SUCCESS);
}


NTSTATUS
demLFNDeleteFile(
   LPSTR lpFileName,
   USHORT wMustMatchAttributes,
   USHORT wSearchAttributes,
   BOOL   fUseWildCard)
{
   // this is how we deal with this rather harsh function:
   //
   HANDLE hFind;
   NTSTATUS dwStatus;
   WIN32_FIND_DATAW FindData;
   PUNICODE_STRING pUnicodeStaticFileName;
   OEM_STRING OemFileName;
   UNICODE_STRING UnicodeFileName; // for deletion

   // convert file name / pattern to uni

   pUnicodeStaticFileName = GET_STATIC_UNICODE_STRING_PTR();

   RtlInitOemString(&OemFileName, lpFileName);

   // convert oem->unicode

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(pUnicodeStaticFileName,
                                             &OemFileName,
                                             FALSE);
#else

   dwStatus = RtlOemStringToUnicodeString(pUnicodeStaticFileName,
                                          &OemFileName,
                                          FALSE);
#endif

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }


   // check for the deletion of a volume label - this hurts
   // BUGBUG
   dempLFNNormalizePath(pUnicodeStaticFileName);

   if (fUseWildCard) {

      // make a template for a file name by backtracking the last backslash
      LONG Index;
      BOOL fSuccess = FALSE;

      dwStatus = dempLFNFindFirstFile(&hFind,
                                      pUnicodeStaticFileName,
                                      &FindData,
                                      wMustMatchAttributes,
                                      wSearchAttributes);

      if (!NT_SUCCESS(dwStatus)) {
         return(dwStatus); // this is safe as dempLFNFindFirstFile closed the handle
      }

      // cut the filename part off
      // index is (-1) if not found or 0-based index of a char

      Index = dempStringFindLastChar(pUnicodeStaticFileName,
                                     L'\\',
                                     FALSE) + 1;


      while (NT_SUCCESS(dwStatus)) {
         // construct a filename

         RtlInitUnicodeString(&UnicodeFileName, FindData.cFileName);
         if (UnicodeFileName.Length < 3 &&
               (L'.' == UnicodeFileName.Buffer[0] &&
                   (UnicodeFileName.Length < 2 ||
                      L'.' == UnicodeFileName.Buffer[1]))) {

            // this is deletion of '.' or '..'
            ; // assert ?

         }

         pUnicodeStaticFileName->Length = (USHORT)Index;

         dwStatus = RtlAppendUnicodeStringToString(pUnicodeStaticFileName,
                                                   &UnicodeFileName);

         if (!NT_SUCCESS(dwStatus)) {
            break;
         }

         // now delete the file in question given it's not '.' or '..'
         // (although I have no idea what '95 would have done)

         if (!DPM_DeleteFileW(pUnicodeStaticFileName->Buffer)) {

            dwStatus = GET_LAST_STATUS();
            break;

         }
         else {

            fSuccess = TRUE;

         }


         dwStatus = dempLFNFindNextFile(hFind,
                                        &FindData,
                                        wMustMatchAttributes,
                                        wSearchAttributes);

      }

      DPM_FindClose(hFind);

      // note success if at least one file nuked
      if (fSuccess) {
         dwStatus = STATUS_SUCCESS;
      }
   }
   else { // wilds are not used here

      // scan for wild card chars using our fn
      LONG Index;

      Index = dempStringFindLastChar(pUnicodeStaticFileName,
                                     L'*',
                                     FALSE);
      if (Index >= 0) {
         return(NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER));
      }

      Index = dempStringFindLastChar(pUnicodeStaticFileName,
                                     L'?',
                                     FALSE);
      if (Index >= 0) {
         return(NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER));
      }

      if (DPM_DeleteFileW(pUnicodeStaticFileName->Buffer)) {
         dwStatus = STATUS_SUCCESS;
      }
      else {

         dwStatus = GET_LAST_STATUS();
      }
   }

   return(dwStatus);
}

NTSTATUS
demLFNGetFileInformationByHandle(
   USHORT wDosHandle,
   LPBY_HANDLE_FILE_INFORMATION pFileInformation)
{
   HANDLE hFile;

   hFile = VDDRetrieveNtHandle((ULONG)NULL,    // uses current pdb
                               wDosHandle,
                               NULL,    // no sft
                               NULL);   // no jft

   if (NULL == hFile) {
      return(NT_STATUS_FROM_WIN32(ERROR_INVALID_HANDLE));
   }


   if (!DPM_GetFileInformationByHandle(hFile, pFileInformation)) {
      return(GET_LAST_STATUS());
   }

   return(STATUS_SUCCESS);
}


#define BCS_SRC_WANSI   0x0
#define BCS_SRC_OEM     0x01
#define BCS_SRC_UNICODE 0x02
#define BCS_DST_WANSI   0x00
#define BCS_DST_OEM     0x10
#define BCS_DST_UNICODE 0x20



/* Function:
 *    demLFNGenerateShortFileName
 *    Produces surrogate short file name given the long file name
 *    Note, that win'95 implementation seems to be quite bogus.
 *    They do not bother to adhere to docs, and return whatever
 *    is on their mind.
 *
 *    This implementation corresponds to name-generating habits of NT
 *    thus allowing 16-bit apps seemless interaction with lfn apis
 *
 *
 */

NTSTATUS
demLFNGenerateShortFileName(
   LPSTR lpShortFileName,
   LPSTR lpLongFileName,
   USHORT wShortNameFormat,
   USHORT wCharSet)
{

   UNICODE_STRING UnicodeShortName;
   WCHAR szShortNameBuffer[13];
   OEM_STRING OemFileName;
   GENERATE_NAME_CONTEXT GenNameContext;
   LONG Index;
   DWORD dwStatus;

   PUNICODE_STRING pUnicodeLongName = GET_STATIC_UNICODE_STRING_PTR();

   // convert to unicode
   switch(wCharSet & 0x0f) {
   case BCS_SRC_WANSI: // BCS_WANSI - windows ansi
      RtlInitAnsiString(&OemFileName, lpLongFileName);
      dwStatus = RtlAnsiStringToUnicodeString(pUnicodeLongName, &OemFileName, FALSE);
      break;

   case BCS_SRC_OEM: // oem
      RtlInitOemString(&OemFileName, lpLongFileName);
      dwStatus = RtlOemStringToUnicodeString(pUnicodeLongName, &OemFileName, FALSE);
      break;

   case BCS_SRC_UNICODE: // unicode (what ?)
      // copy unicode str into our buf
      RtlInitUnicodeString(pUnicodeLongName, (PWCHAR)lpLongFileName);
      dwStatus = STATUS_SUCCESS;
      break;

   default:
      return(NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER));
   }

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }


   wCharSet &= 0xf0; // filter out the dest

   dempStringInitZeroUnicode(&UnicodeShortName,
                             (BCS_DST_UNICODE == wCharSet) ?
                                 (LPWSTR)lpShortFileName :
                                 (LPWSTR)szShortNameBuffer,
                             13 * sizeof(WCHAR));

   RtlZeroMemory(&GenNameContext, sizeof(GenNameContext));

   // generate name
   RtlGenerate8dot3Name(pUnicodeLongName,
                        FALSE, // allowed ext chars ? and why not ?
                        &GenNameContext,
                        &UnicodeShortName);

   // chop off the part starting with ~

   Index = dempStringFindLastChar(&UnicodeShortName,
                                  L'~',
                                  FALSE);
   if (Index >= 0) {
      // remove ~<Number>
      //
      dempStringDeleteCharsUnicode(&UnicodeShortName,
                                   (USHORT)Index,
                                   2 * sizeof(WCHAR));
   }

   if (0 == wShortNameFormat) {
      // directory entry - 11 chars format
      // just remove the darn '.' from the name

      Index = dempStringFindLastChar(&UnicodeShortName,
                                     L'.',
                                     TRUE);
      if (Index >= 0) {
         dempStringDeleteCharsUnicode(&UnicodeShortName,
                                      (USHORT)Index,
                                      1 * sizeof(WCHAR));
      }
   }

   if (BCS_DST_UNICODE == wCharSet) { // if result is uni, we are done
      return(STATUS_SUCCESS);
   }


   OemFileName.Buffer = lpShortFileName;
   OemFileName.Length = 0;
   OemFileName.MaximumLength = 13 * sizeof(WCHAR);


   switch(wCharSet) {
   case BCS_DST_WANSI: // windows ansi
      dwStatus = RtlUnicodeStringToAnsiString(&OemFileName,
                                              &UnicodeShortName,
                                              FALSE);
      break;

   case BCS_DST_OEM: // oem
      dwStatus = RtlUnicodeStringToOemString(&OemFileName,
                                             &UnicodeShortName,
                                             FALSE);
      break;

   default:
      return(NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER));
   }


   return(dwStatus);
}


/*
 *    This function dispatches lfn calls
 *
 *    ATTN: All the pointers coming from 16-bit code could be unaligned!!!
 *
 *    danger: dependency on relative location of things in pdb
 *
 *
 *
 */



BOOL gfInitCDSPtr = FALSE;
VOID demInitCDSPtr(VOID);

NTSTATUS
demLFNDispatch(
   PVOID pUserEnvironment,
   BOOL  fProtectedMode,
   PUSHORT pUserAX)
{
   DWORD dwStatus;
   USHORT wUserAX;

   if (!gfInitCDSPtr) {
      demInitCDSPtr();
   }

   if (NULL == pUserEnvironment) {
      pUserEnvironment = dempGetDosUserEnvironment();
   }

   wUserAX = getUserAX(pUserEnvironment);
   *pUserAX = wUserAX; // initialize to initial value

   if (fnLFNMajorFunction == HIB(wUserAX)) {
      dempLFNLog("LFN Function: 0x%x \r\n", (DWORD)wUserAX);

      switch(LOB(wUserAX)) {
      case fnLFNFileTime:
         {
            LFNFILETIMEINFO TimeInfo;
            UINT uMinorFunction = (UINT)getUserBL(pUserEnvironment);

            switch(uMinorFunction) {
            case fnFileTimeToDosDateTime:
               dwStatus = demLFNFileTimeControl(uMinorFunction,
                                                (FILETIME*)getUserDSSI(pUserEnvironment, fProtectedMode),
                                                &TimeInfo);
               if (NT_SUCCESS(dwStatus)) {

                  // set registers
                  setUserDX(TimeInfo.uDosDate, pUserEnvironment);
                  setUserCX(TimeInfo.uDosTime, pUserEnvironment);
                  setUserBH((BYTE)TimeInfo.uMilliseconds, pUserEnvironment);
               }
               break;

            case fnDosDateTimeToFileTime:
               TimeInfo.uDosDate = (USHORT)getUserDX(pUserEnvironment);
               TimeInfo.uDosTime = (USHORT)getUserCX(pUserEnvironment);
               TimeInfo.uMilliseconds = (USHORT)getUserBH(pUserEnvironment);

               dwStatus = demLFNFileTimeControl((UINT)getBL(),
                                                (FILETIME*)getUserESDI(pUserEnvironment, fProtectedMode),
                                                &TimeInfo);
               break;
            default:
               dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION);
               break;
            }
         }
         break;

      case fnLFNGetVolumeInformation:
         {
            LFNVOLUMEINFO vi;

            vi.dwFSNameBufferSize = (DWORD)getUserCX(pUserEnvironment);
            vi.lpFSNameBuffer = (LPSTR)getUserESDI(pUserEnvironment, fProtectedMode);

            dwStatus = demLFNGetVolumeInformation((LPSTR)getUserDSDX(pUserEnvironment, fProtectedMode),
                                                  &vi);
            if (NT_SUCCESS(dwStatus)) {

               setUserBX((USHORT)vi.dwFSFlags, pUserEnvironment);
               setUserCX((USHORT)vi.dwMaximumFileNameLength, pUserEnvironment);
               setUserDX((USHORT)vi.dwMaximumPathNameLength, pUserEnvironment);
            }
         }
         break;

      case fnLFNMoveFile:
         dwStatus = demLFNMoveFile((LPSTR)getUserDSDX(pUserEnvironment, fProtectedMode),
                                   (LPSTR)getUserESDI(pUserEnvironment, fProtectedMode));
         break;

      case fnLFNGetCurrentDirectory:
         dwStatus = demLFNGetCurrentDirectory((UINT)getUserDL(pUserEnvironment), // drive no
                                              (LPSTR)getUserDSSI(pUserEnvironment, fProtectedMode)); // ptr to buf
         break;

      case fnLFNSetCurrentDirectory:
      case fnLFNRemoveDirectory:
      case fnLFNCreateDirectory:
         dwStatus = demLFNDirectoryControl((UINT)getUserAL(pUserEnvironment),
                                           (LPSTR)getUserDSDX(pUserEnvironment, fProtectedMode));
         break;

      case fnLFNGetPathName:

         dwStatus = demLFNGetPathName((LPSTR)getUserDSSI(pUserEnvironment, fProtectedMode), // SourcePath
                                      (LPSTR)getUserESDI(pUserEnvironment, fProtectedMode), // Destination Path
                                      (UINT)getUserCL(pUserEnvironment),                    // minor code
                                      (BOOL)!(getUserCH(pUserEnvironment) & 0x80));            // expand subst flag

         if (NT_SUCCESS(dwStatus)) { // doc says modify ax
            *pUserAX = 0;
         }
         break;

      case fnLFNSubst:
         dwStatus = demLFNSubstControl((UINT)getUserBH(pUserEnvironment),
                                       (UINT)getUserBL(pUserEnvironment),
                                       (LPSTR)getUserDSDX(pUserEnvironment, fProtectedMode));
         break;
      case fnLFNFindFirstFile:
         {
            USHORT wConversionCode;
            USHORT wDosHandle;
            WIN32_FIND_DATAA FindData; // used to enforce alignment
            LPWIN32_FIND_DATAA lpFindDataDest; // resulting ptr

            lpFindDataDest = (LPWIN32_FIND_DATAA)getUserESDI(pUserEnvironment,
                                                             fProtectedMode);
            ASSERT(NULL != lpFindDataDest);

            dwStatus = demLFNFindFirstFile((LPSTR)getUserDSDX(pUserEnvironment, fProtectedMode),
                                           &FindData,
                                           (USHORT)getUserSI(pUserEnvironment), // date/time format
                                           (USHORT)getUserCH(pUserEnvironment), // must match attrs
                                           (USHORT)getUserCL(pUserEnvironment), // search attrs
                                           &wConversionCode,
                                           &wDosHandle,
                                           lpFindDataDest->cFileName,
                                           lpFindDataDest->cAlternateFileName
                                           );
            if (NT_SUCCESS(dwStatus)) {
               // now copy the data

               //
               // WARNING: THIS CODE DEPENDS ON THE LAYOUT OF THE WIN32_FIND_DATA
               // STRUCTURE IN THE ASSUMPTION THAT cFileName and CAlternateFileName
               // ARE THE VERY LAST MEMBERS OF IT!!!
               //

               RtlMoveMemory((PUCHAR)lpFindDataDest,
                             (PUCHAR)&FindData,

                             // warning -- this will move more data
                             // than we ever wanted to -- so break into pieces
                             sizeof(FindData.dwFileAttributes)+
                             sizeof(FindData.ftCreationTime)+
                             sizeof(FindData.ftLastAccessTime)+
                             sizeof(FindData.ftLastWriteTime)+
                             sizeof(FindData.nFileSizeHigh)+
                             sizeof(FindData.nFileSizeLow)+
                             sizeof(FindData.dwReserved0)+
                             sizeof(FindData.dwReserved1));

               *pUserAX = wDosHandle;
               setUserCX(wConversionCode, pUserEnvironment);
            }
         }
         break;

      case fnLFNFindNextFile:
         {
            USHORT wConversionCode;
            WIN32_FIND_DATAA FindData;
            LPWIN32_FIND_DATAA lpFindDataDest;

            lpFindDataDest = (LPWIN32_FIND_DATAA)getUserESDI(pUserEnvironment, fProtectedMode);
            ASSERT(NULL != lpFindDataDest);

            dwStatus = demLFNFindNextFile((USHORT)getUserBX(pUserEnvironment), // handle
                                          &FindData,
                                          (USHORT)getUserSI(pUserEnvironment),   // date/time format
                                          &wConversionCode,
                                          lpFindDataDest->cFileName,
                                          lpFindDataDest->cAlternateFileName
                                          );

            if (NT_SUCCESS(dwStatus)) {
               RtlMoveMemory((PUCHAR)lpFindDataDest,
                             (PUCHAR)&FindData,

                             sizeof(FindData.dwFileAttributes)+
                             sizeof(FindData.ftCreationTime)+
                             sizeof(FindData.ftLastAccessTime)+
                             sizeof(FindData.ftLastWriteTime)+
                             sizeof(FindData.nFileSizeHigh)+
                             sizeof(FindData.nFileSizeLow)+
                             sizeof(FindData.dwReserved0)+
                             sizeof(FindData.dwReserved1));

               setUserCX(wConversionCode, pUserEnvironment);
            }
         }
         break;

      case fnLFNFindClose:
         {
            dwStatus = demLFNFindClose((USHORT)getUserBX(pUserEnvironment));
         }
         break;

      case fnLFNDeleteFile:
         {
            dwStatus = demLFNDeleteFile((LPSTR) getUserDSDX(pUserEnvironment, fProtectedMode),
                                        (USHORT)getUserCH(pUserEnvironment), // must match
                                        (USHORT)getUserCL(pUserEnvironment), // search
                                        (BOOL)  getUserSI(pUserEnvironment));
         }
         break;

      case fnLFNGetSetFileAttributes:
         {
            USHORT wAction = (USHORT)getUserBL(pUserEnvironment);

            LFNFILEATTRIBUTES FileAttributes;

            RtlZeroMemory(&FileAttributes, sizeof(FileAttributes));

            switch (wAction) {
            case fnSetFileAttributes:
               FileAttributes.wFileAttributes = getUserCX(pUserEnvironment);
               break;

            case fnSetCreationDateTime:
               FileAttributes.TimeInfo.uMilliseconds = (USHORT)getUserSI(pUserEnvironment);
               // fall through

            case fnSetLastAccessDateTime:
            case fnSetLastWriteDateTime:
               FileAttributes.TimeInfo.uDosDate = (USHORT)getUserDI(pUserEnvironment);
               FileAttributes.TimeInfo.uDosTime = (USHORT)getUserCX(pUserEnvironment);
               break;
            }


            dwStatus = demLFNGetSetFileAttributes(wAction, // action
                                                  (LPSTR)getUserDSDX(pUserEnvironment, fProtectedMode),
                                                  &FileAttributes); // filename
            if (NT_SUCCESS(dwStatus)) {

               // return stuff
               switch (wAction) {
               case fnGetFileAttributes:
                  setUserCX(FileAttributes.wFileAttributes, pUserEnvironment);
                  *pUserAX = FileAttributes.wFileAttributes;
                  break;

               case fnGetCreationDateTime:
               case fnGetLastAccessDateTime:
               case fnGetLastWriteDateTime:
                  setUserSI(FileAttributes.TimeInfo.uMilliseconds, pUserEnvironment);
                  setUserCX(FileAttributes.TimeInfo.uDosTime, pUserEnvironment);
                  setUserDI(FileAttributes.TimeInfo.uDosDate, pUserEnvironment);
                  break;

               case fnGetCompressedFileSize:
                  setUserDX(HIWORD(FileAttributes.dwFileSize), pUserEnvironment);
                  *pUserAX = LOWORD(FileAttributes.dwFileSize);
                  break;
               }


            }
         }
         break;

      case fnLFNOpenFile:
         {
            USHORT uDosHandle;
            USHORT uActionTaken;


            dwStatus = demLFNOpenFile((LPSTR)getUserDSSI(pUserEnvironment, fProtectedMode), // filename
                                      getUserBX(pUserEnvironment), // mode and flags
                                      getUserCX(pUserEnvironment), // attribs
                                      getUserDX(pUserEnvironment), // action
                                      getUserDI(pUserEnvironment), // alias hint - unused
                                      &uDosHandle,
                                      &uActionTaken);

            if (NT_SUCCESS(dwStatus)) {
               *pUserAX = uDosHandle;
               setUserCX(uActionTaken, pUserEnvironment);
            }
         }
         break;

      case fnLFNGetFileInformationByHandle:
         {
            BY_HANDLE_FILE_INFORMATION FileInfo;

            dwStatus = demLFNGetFileInformationByHandle(getUserBX(pUserEnvironment), // handle
                                                        &FileInfo);
            if (NT_SUCCESS(dwStatus)) {
               RtlMoveMemory((PUCHAR)getUserDSDX(pUserEnvironment, fProtectedMode),
                             (PUCHAR)&FileInfo,
                             sizeof(FileInfo));
            }
         }


         break;


      case fnLFNGenerateShortFileName:

         // using rtl function, off course
         dwStatus = demLFNGenerateShortFileName((LPSTR)getUserESDI(pUserEnvironment, fProtectedMode),
                                                (LPSTR)getUserDSSI(pUserEnvironment, fProtectedMode),
                                                (USHORT)getUserDH(pUserEnvironment),
                                                (USHORT)getUserDL(pUserEnvironment));
         break;


      default:
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION);
         break;
      }

      // we handle here any case that sets ax to error and cf to 1 if error
      if (!NT_SUCCESS(dwStatus)) {
         *pUserAX = (USHORT)WIN32_ERROR_FROM_NT_STATUS(dwStatus);
      }
   }
   else { // this is a service call such as cleanup
      demLFNCleanup();
      dwStatus = STATUS_SUCCESS;
   }

   dempLFNLog("LFN returns: 0x%x\r\n", dwStatus);
   return(dwStatus);
}

ULONG
dempWOWLFNReturn(
   NTSTATUS dwStatus)
{
   DWORD  dwError = WIN32_ERROR_FROM_NT_STATUS(dwStatus);
   USHORT wErrorCode = (USHORT)ERROR_CODE_FROM_NT_STATUS(dwError);

   if (wErrorCode  < ERROR_WRITE_PROTECT || wErrorCode > ERROR_GEN_FAILURE &&
       wErrorCode != ERROR_WRONG_DISK) {

      // this is not hard error
      return((ULONG)wErrorCode);
   }

   return((ULONG)MAKELONG(wErrorCode, 0xFFFF));
}

VOID
demLFNEntry(VOID)
{
   NTSTATUS dwStatus;
   USHORT UserAX;

   // second parm is a ptr to the value of an ax register

   dwStatus = demLFNDispatch(NULL, FALSE, &UserAX);


   // in any case set ax
   setAX(UserAX);


   //
   // in case of a failure we do not necessarily mess with user registers
   //
   // as ax set on the user side will be over-written by dos
   if (NT_SUCCESS(dwStatus)) {
      // ok, we are ok
      setCF(0); // not the user cf
   }
   else {
      // we are in error

      setCF(1);


      // see if we need to fire int24....

      // set error code

      // set error flag
   }




}

/* Function
 *    demWOWLFNEntry
 *    The main entry point for protected-mode calls (e.g. from kernel31)
 *    It provides all the dispatching and, unlike the dos entry point,
 *    does not modify any x86 processor registers, instead, it operates
 *    on "User" Registers on the stack.
 *
 *
 * Parameters
 *    pUserEnvironment - pointer to user stack frame. Registers should be
 *                       pushed on stack according to dos (see DEMUSERFRAME)
 *
 * Returns
 *    ULONG containing error code in the low word and 0xffff in the high word
 *    if the error is "hard error" and int24 should have been generated
 *
 *    It also modifies (in case of success) registers on the user's stack
 *    and patches flags into the processor flags word on the stack
 *    No flags - no error
 *    Carry Set - error
 *    Carry & Zero set - hard error
 */



ULONG
demWOWLFNEntry(
   PVOID pUserEnvironment)
{
   NTSTATUS dwStatus;
   USHORT UserAX;
   USHORT Flags;

   // protected-mode entry

   dwStatus = demLFNDispatch(pUserEnvironment, TRUE, &UserAX);


   // now set up for return

   Flags = getUserPModeFlags(pUserEnvironment) & ~(FLG_ZERO|FLG_CARRY);

   if (NT_SUCCESS(dwStatus)) {
      //
      // this is set only when we succeed!!!
      //

      setUserAX(UserAX, pUserEnvironment);
      // success  - no flags necessary

   }
   else {
      // set carry flag ... meaning error
      Flags |= FLG_CARRY;

      // possibly set zero flag indicating hard error
      dwStatus = (NTSTATUS)dempWOWLFNReturn(dwStatus);

      if (dwStatus & 0xFFFF0000UL) { // we are harderr
         Flags |= FLG_ZERO;
      }
   }

   //
   // in any event set user flags
   //
   setUserPModeFlags(Flags, pUserEnvironment);

   return(dwStatus);
}


/////////////////////////////////////////////////////////////////////////
//
// Retrieve important dos/wow variables
//
//

#define FETCHVDMADDR(varTo, varFrom) \
{ DWORD __dwTemp; \
  __dwTemp = FETCHDWORD(varFrom); \
  varTo = (DWORD)GetVDMAddr(HIWORD(__dwTemp), LOWORD(__dwTemp)); \
}


VOID
demInitCDSPtr(VOID)
{

   DWORD dwTemp;
   PULONG pTemp;

   if (!gfInitCDSPtr) {
      gfInitCDSPtr = TRUE;
      pTemp = (PULONG)DosWowData.lpCDSFixedTable;
      dwTemp = FETCHDWORD(*pTemp);
      DosWowData.lpCDSFixedTable = (DWORD)GetVDMAddr(HIWORD(dwTemp), LOWORD(dwTemp));
   }
}

VOID
demSetDosVarLocation(VOID)
{
   PDOSWOWDATA pDosWowData;
   DWORD dwTemp;
   PULONG pTemp;

   pDosWowData = (PDOSWOWDATA)GetVDMAddr (getDS(),getSI());

   FETCHVDMADDR(DosWowData.lpCDSCount, pDosWowData->lpCDSCount);

   // the real pointer should be obtained through double-indirection
   // but we opt to do it later through deminitcdsptr
   dwTemp = FETCHDWORD(pDosWowData->lpCDSFixedTable);
   pTemp = (PULONG)GetVDMAddr(HIWORD(dwTemp), LOWORD(dwTemp));
   DosWowData.lpCDSFixedTable = (DWORD)pTemp;

   FETCHVDMADDR(DosWowData.lpCDSBuffer, pDosWowData->lpCDSBuffer);
   FETCHVDMADDR(DosWowData.lpCurDrv, pDosWowData->lpCurDrv);
   FETCHVDMADDR(DosWowData.lpCurPDB, pDosWowData->lpCurPDB);
   FETCHVDMADDR(DosWowData.lpDrvErr, pDosWowData->lpDrvErr);
   FETCHVDMADDR(DosWowData.lpExterrLocus, pDosWowData->lpExterrLocus);
   FETCHVDMADDR(DosWowData.lpSCS_ToSync, pDosWowData->lpSCS_ToSync);
   FETCHVDMADDR(DosWowData.lpSftAddr, pDosWowData->lpSftAddr);
}

///////////////////////////////////////////////////////////////////////////
//
// Initialization for this module and temp environment variables
//
//
///////////////////////////////////////////////////////////////////////////

//
// these functions could be found in cmd
//
extern VOID cmdCheckTempInit(VOID);
extern LPSTR cmdCheckTemp(LPSTR lpszzEnv);

VOID
dempCheckTempEnvironmentVariables(
VOID
)
{
   LPSTR rgszTempVars[] = { "TEMP", "TMP" };
   int i;
   DWORD len;
   DWORD EnvVarLen;
   CHAR szBuf[MAX_PATH+6];
   LPSTR pszVar;

   cmdCheckTempInit();

   // this code below depends on the fact that none of the vars listed in
   // rgszTempVars are longer than 5 chars!

   for (i = 0; i < sizeof(rgszTempVars)/sizeof(rgszTempVars[0]); ++i) {
      strcpy(szBuf, rgszTempVars[i]);
      len = strlen(szBuf);
      EnvVarLen = GetEnvironmentVariable(szBuf, szBuf+len+1, sizeof(szBuf)-6);
      if (EnvVarLen > 0 && EnvVarLen < sizeof(szBuf)-6) {
         *(szBuf+len) = '=';
         pszVar = cmdCheckTemp(szBuf);
         if (NULL != pszVar) {
            *(pszVar+len) = '\0';
            dempLFNLog("%s: substituted for %s\r\n", pszVar, pszVar+len+1);
            SetEnvironmentVariable(pszVar, pszVar+len+1);
         }
      }
   }

}


VOID
demWOWLFNInit(
   PWOWLFNINIT pLFNInit
   )
{
   DosWowUpdateTDBDir    = pLFNInit->pDosWowUpdateTDBDir;
   DosWowGetTDBDir       = pLFNInit->pDosWowGetTDBDir;
   DosWowDoDirectHDPopup = pLFNInit->pDosWowDoDirectHDPopup;


   // this api also sets temp variables to their needded values -- for ntvdm
   // process itself that is. These environment variables come to us from
   // cmd

   dempCheckTempEnvironmentVariables();
   demInitCDSPtr();
}


ULONG demWOWLFNAllocateSearchHandle(HANDLE hFind)
{
   DWORD dwStatus;
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry;
   USHORT DosHandle = 0;

   dwStatus = dempLFNAllocateHandleEntry(&DosHandle, &pHandleEntry);
   if (NT_SUCCESS(dwStatus)) {
      pHandleEntry->hFindHandle = hFind;
      pHandleEntry->wMustMatchAttributes = 0;
      pHandleEntry->wSearchAttributes = 0;
      pHandleEntry->wProcessPDB = *pusCurrentPDB;
      return((ULONG)MAKELONG(DosHandle, 0));
   }

   // we have an error
   return((ULONG)INVALID_HANDLE_VALUE);
}

HANDLE demWOWLFNGetSearchHandle(USHORT DosHandle)
{
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry;

   pHandleEntry = dempLFNGetHandleEntry(DosHandle);

   return(NULL == pHandleEntry ? INVALID_HANDLE_VALUE :
                                 pHandleEntry->hFindHandle);
}

BOOL demWOWLFNCloseSearchHandle(USHORT DosHandle)
{
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry;
   HANDLE hFind = INVALID_HANDLE_VALUE;

   pHandleEntry = dempLFNGetHandleEntry(DosHandle);
   if (NULL != pHandleEntry) {
      hFind = pHandleEntry->hFindHandle;
      dempLFNFreeHandleEntry(pHandleEntry);
   }

   return(DPM_FindClose(hFind));
}


#if 0

///////////////////////////////////////////////////////
//
//
// Clipboard dispatch api

typedef enum tagClipbrdFunctionNumber {
   fnIdentifyClipboard = 0x00,
   fnOpenClipboard = 0x01,
   fnEmptyClipboard = 0x02,
   fnSetClipboardData = 0x03,
   fnGetClipboardDataSize = 0x04,
   fnGetClipboardData = 0x05,
   fnInvalidFunction6 = 0x06,
   fnInvalidFunction7 = 0x07,
   fnCloseClipboard = 0x08,
   fnCompactClipboard = 0x09,
   fnGetDeviceCaps = 0x0a
}  enumClipbrdFunctionNumber;

#define CLIPBOARD_VERSION 0x0200
#define SWAPBYTES(w) \
((((USHORT)w & 0x0ff) << 8) | ((USHORT)w >> 8))

#pragma pack(1)

typedef struct tagBITMAPDOS {
   WORD  bmdType;
   WORD  bmdWidth;
   WORD  bmdHeight;
   WORD  bmdWidthBytes;
   BYTE  bmdPlanes;
   BYTE  bmdBitsPixel;
   DWORD bmdBits;
   DWORD bmdJunk;
   WORD  bmdWidthUm;
   WORD  bmdHeightUm;
}  BITMAPDOS, UNALIGNED*PBITMAPDOS;

typedef struct tagMETAFILEPICTDOS {
   WORD mfpd_mm;
   WORD mfpd_xExt;
   WORD mfpd_yExt;
}  METAFILEPICTDOS, UNALIGNED* PMETAFILEPICTDOS;

#pragma pack()


BOOL
demSetClipboardData(
   VOID
   )
{
   WORD wType = getDX();
   LONG lSize = ((ULONG)getSI() << 16) | getCX();

   if (wType == CF_METAFILEPICT || wType == CF_DSPMETAFILEPICT) {
      if (lSize < sizeof(METAFILEPICTDOS)) {
         return(FALSE);
      }


      hMeta = GlobalAlloc();
      if (NULL == hMeta) {
         return(FALSE);
      }





   }






}

BOOL dempGetClipboardDataSize(
   WORD wFormat,
   LPDWORD lpdwSize;
   )
{
   HANDLE hData;
   DWORD  dwSize = 0;

   hData = GetClipboardData(wFormat);
   if (NULL != hData) {
      switch(wFormat) {
      case CF_BITMAP:
      case CF_DSPBITMAP:
         {
            BITMAP bm;
            int sizeBM;

            sizeBM = GetObject((HGDIOBJ)hData, sizeof(bm), &bm);
            if (sizeBM > 0) {
               dwSize = bm.bmWidthBytes * bm.bmHeight * bm.bmPlanes;
               dwSize += sizeof(BITMAPDOS);
            }
         }
         break;

      case CF_METAFILEPICT:
      case CF_DSPMETAFILEPICT:
         dwSize = GlobalSize(hData);
         if (dwSize) {
            dwSize += sizeof(METAFILEPICTDOS);
         }
         break;

      default:
         dwSize = GlobalSize(hData);
         break;
      }
   }


   *lpdwSize = dwSize;
   return(0 != dwSize);
}


extern HANDLE GetConsoleWindow(VOID);

BOOL demClipbrdDispatch(
   VOID
)
{
   BOOL fHandled = TRUE;
   HWND hWndConsole;

   switch(getAL()) {
   case fnIdentifyClipboard:
      // identify call just checks for installation
      setAX(SWAPBYTES(CLIPBOARD_VERSION));
      setDX(0);
      break;

   case fnOpenClipboard:
      // open clipboard -- opens a clipboard on behalf of console app
      //
      hWndConsole = GetConsoleWindow();
      if (OpenClipboard(hWndConsole)) {
         setDX(0);
         setAX(1);
      }
      else {
         setDX(0);
         setAX(0);
      }
      break;

   case fnEmptyClipboard:
      if (EmptyClipboard()) {
         setDX(0);
         setAX(1);
      }
      else {
         setDX(0);
         setAX(0);
      }
      break;

   case fnSetClipboardData:
//      if (dempSetClipboardData()) {
//
//      }
      break;
   case fnGetClipboardDataSize:
//      if (dempGetClipboardDataSize(getDX())) {
// then we have it
//
//      }
      break;
   case fnGetClipboardData:
//      if (dempGetClipboardData( )) {
//      }
      break;
   case fnCloseClipboard:
      if (CloseClipboard()) {
         setDX(0);
         setAX(1);
      }
      else {
         setDX(0);
         setAX(0);
      }
      break;

   case fnCompactClipboard:
      // this should really mess with GlobalCompact but we don't have any
      // idea of how to handle these things. The only valid case could be
      // made for Windows apps that call this api for some reason
      // while they have a "real" GlobalCompact avaliable...

      break;
   case fnGetDeviceCaps:
      {
         HWND hWndConsole;
         HDC  hDC;
         DWORD  dwCaps = 0;
         hWndConsole = GetConsoleWindow();
         hDC = GetDC(hWndConsole);
         dwCaps = (DWORD)GetDeviceCaps(hDC, getDX());
         if (NULL != hDC) {
            ReleaseDC(hWndConsole, hDC);
         }
         setDX(HIWORD(dwCaps));
         setAX(LOWORD(dwCaps));
      }
      break;
   default:
      fHandled = FALSE;
      break;
   }


   return(fHandled);
}


#endif


BOOL demClipbrdDispatch(
   VOID
)
{
   return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demmsg.h ===
/* demmsg.h - debug message numbers for DEM
 *
 * Modification History
 *
 * Sudeepb 31-Mar-1991 Created
 */


#define MSG_DEFAULTDOS		0
#define MSG_PARTIALREAD 	1
#define MSG_OPENFAILED		2
#define MSG_EAS 		3
#define MSG_DEFAULT_DRIVE	4
#define MSG_VOLID		5
#define MSG_TIMEDATE		6
#define MSG_INVALID_HFIND	7
#define MSG_FILEINFO		8
#define MSG_FILESIZE_TOOBIG	9
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demlfn.h ===
/*
 * DemLFN.H
 *
 * Include file for all the things that lfn implementation is using
 *
 * VadimB   Created  09-12-96
 *
 */


/* --------------------------------------------------------------------------

   LFN function numbers defined as enum

   -------------------------------------------------------------------------- */

typedef enum tagLFNFunctionNumber {
   fnLFNCreateDirectory = 0x39,
   fnLFNRemoveDirectory = 0x3A,
   fnLFNSetCurrentDirectory = 0x3B,
   fnLFNDeleteFile = 0x41,
   fnLFNGetSetFileAttributes= 0x43,
   fnLFNGetCurrentDirectory = 0x47,
   fnLFNFindFirstFile = 0x4e,
   fnLFNFindNextFile = 0x4f,
   fnLFNMoveFile = 0x56,
   fnLFNGetPathName = 0x60,
   fnLFNOpenFile = 0x6c,
   fnLFNGetVolumeInformation = 0xa0,
   fnLFNFindClose = 0xa1,
   fnLFNGetFileInformationByHandle = 0xa6,
   fnLFNFileTime = 0xa7,
   fnLFNGenerateShortFileName = 0xa8,
   fnLFNSubst = 0xaa
}  enumLFNFunctionNumber;

#define fnLFNMajorFunction 0x71


/* --------------------------------------------------------------------------

   Useful Macros

   -------------------------------------------------------------------------- */

// returns : count of elements in an array
#define ARRAYCOUNT(rgX) (sizeof(rgX)/sizeof(rgX[0]))

// returns : length (in characters) of a counted Unicode string
#define UNICODESTRLENGTH(pStr) ((pStr)->Length >> 1)


// returns : whether an api (like GetShortPathName) has returned count of
// characters required and failed to succeed (due to buffer being too short)
// Note that api here means win32 api, not rtl api (as return value is assumed
// be count of chars, not bytes
#define CHECK_LENGTH_RESULT_USTR(dwStatus, pUnicodeString) \
CHECK_LENGTH_RESULT(dwStatus,                              \
                    (pUnicodeString)->MaximumLength,       \
                    (pUnicodeString)->Length)


// returns : dwStatus - whether an api that returns char count
// succeeded on a call, takes string count variables instead of
// unicode string structure (see prev call)
#define CHECK_LENGTH_RESULT(dwStatus, MaximumLength, Length) \
{                                                                         \
   if (0 == dwStatus) {                                                   \
      dwStatus = GET_LAST_STATUS();                                       \
   }                                                                      \
   else {                                                                 \
      Length = (USHORT)dwStatus * sizeof(WCHAR);                          \
      if ((MaximumLength) > (Length)) {                                   \
         dwStatus = STATUS_SUCCESS;                                       \
      }                                                                   \
      else {                                                              \
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_BUFFER_OVERFLOW);          \
         Length = 0;                                                      \
      }                                                                   \
   }                                                                      \
}

// these 2 macros are identical to the ones above but dwStatus is assumed
// to represent a byte count rather than the char count (as in rtl apis)
#define CHECK_LENGTH_RESULT_RTL(dwStatus, MaximumLength, Length) \
{                                                                         \
   if (0 == dwStatus) {                                                   \
      dwStatus = GET_LAST_STATUS();                                       \
   }                                                                      \
   else {                                                                 \
      Length = (USHORT)dwStatus;                                          \
      if ((MaximumLength) > (Length)) {                                   \
         dwStatus = STATUS_SUCCESS;                                       \
      }                                                                   \
      else {                                                              \
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_BUFFER_OVERFLOW);          \
         Length = 0;                                                      \
      }                                                                   \
   }                                                                      \
}

#define CHECK_LENGTH_RESULT_RTL_USTR(dwStatus, pUnicodeString) \
CHECK_LENGTH_RESULT_RTL(dwStatus,                              \
                        (pUnicodeString)->MaximumLength,       \
                        (pUnicodeString)->Length)



/* --------------------------------------------------------------------------

   STATUS and ERROR code macros

   -------------------------------------------------------------------------- */

// returns nt status code assembled from separate parts
// see ntstatus.h for details
#define MAKE_STATUS_CODE(Severity,Facility,ErrorCode) \
(((ULONG)Severity << 30) | ((ULONG)Facility << 16) | ((ULONG)ErrorCode))

#define ERROR_CODE_FROM_NT_STATUS(Status) \
((ULONG)Status & 0xffff)

#define FACILITY_FROM_NT_STATUS(Status) \
(((ULONG)Status >> 16) & 0x0fff)

// returns TRUE if nt status signifies error
#define IS_NT_STATUS_ERROR(Status) \
(((ULONG)Status >> 30) == STATUS_SEVERITY_ERROR)

// converts win32 error code to nt status code
#define NT_STATUS_FROM_WIN32(dwErrorCode) \
MAKE_STATUS_CODE(STATUS_SEVERITY_WARNING,FACILITY_WIN32,dwErrorCode)

// converts nt status to win32 error code
#define WIN32_ERROR_FROM_NT_STATUS(Status) \
RtlNtStatusToDosError(Status)

// returns last win32 error in nt status format
#define GET_LAST_STATUS() NT_STATUS_FROM_WIN32(GetLastError())


/* --------------------------------------------------------------------------

   String Conversion macros and functions

   -------------------------------------------------------------------------- */

//
// Macro to provide init fn for oem counted strings
//

#define RtlInitOemString(lpOemStr,lpBuf) \
RtlInitString(lpOemStr, lpBuf)

//
// defines a conversion fn from Unicode to Destination type (as accepted by the
// application (oem or ansi)
//
//

typedef NTSTATUS (*PFNUNICODESTRINGTODESTSTRING)(
   PVOID pDestString,               // counted oem/ansi string -- returned
   PUNICODE_STRING pUnicodeString,  // unicode string to convert
   BOOLEAN fAllocateDestination,    // allocate destination dynamically ?
   BOOLEAN fVerifyTranslation);     // should the translation unicode->oem/ansi be verified ?


//
// defines a conversion fn from Oem/Ansi to Unicode type (as needed by dem)
//
//

typedef NTSTATUS (*PFNSRCSTRINGTOUNICODESTRING)(
   PUNICODE_STRING pUnicodeString,  // counted unicode string -- returned
   PVOID pSrcString,                // oem or ansi string to convert
   BOOLEAN fAllocateDestination);   // allocate destination dynamically ?


//
// these two macros define apis we use for consistency across lfn support land
//

#define DemAnsiStringToUnicodeString RtlAnsiStringToUnicodeString
#define DemOemStringToUnicodeString  RtlOemStringToUnicodeString

//
// these two functions provide actual translations
// oem/ansi to unicode
//

NTSTATUS
DemUnicodeStringToAnsiString(
   PANSI_STRING pAnsiString,
   PUNICODE_STRING pUnicodeString,
   BOOLEAN fAllocateResult,
   BOOLEAN fVerifyTranslation);

NTSTATUS
DemUnicodeStringToOemString(
   POEM_STRING pOemString,
   PUNICODE_STRING pUnicodeString,
   BOOLEAN fAllocateResult,
   BOOLEAN fVerifyTranslation);



//
// This macro returns a pointer (in the current teb) to a unicode string,
// we are using this buffer for unicode/ansi/oem translations
// be careful with inter-function passing of this buffer
// Many Win32's Ansi apis use this buffer as a translation buffer
//
#define GET_STATIC_UNICODE_STRING_PTR() \
(&NtCurrentTeb()->StaticUnicodeString)


/* --------------------------------------------------------------------------

   DOS and Windows call frame definition
   These macros allow for access to the User's registers, that is
   registers which the calling application receives after dos returns

   -------------------------------------------------------------------------- */



/*
 *  See dossym.inc for more details (if any)
 *  These values represent offsets from user stack top
 *  during the system call (again, as defined in dossym.inc)
 *
 *  The stack layout is formed by dos and mimicked by kernel in windows
 *
 */


#pragma pack(1)

// macro: used to declare a named word size register
//

#define DECLARE_WORDREG(Name) \
union { \
   USHORT User_ ## Name ## X; \
   struct { \
      UCHAR User_ ## Name ## L; \
      UCHAR User_ ## Name ## H; \
   }; \
}

typedef struct tagUserFrame {

   DECLARE_WORDREG(A); // ax 0x00
   DECLARE_WORDREG(B); // bx 0x02
   DECLARE_WORDREG(C); // cx 0x04
   DECLARE_WORDREG(D); // dx 0x06

   USHORT User_SI; // si 0x8
   USHORT User_DI; // di 0xa
   USHORT User_BP; // bp 0xc
   USHORT User_DS; // ds 0xe
   USHORT User_ES; // es 0x10
   union {
      USHORT User_IP; // ip 0x12 -- Real Mode IP
      USHORT User_ProtMode_F; // prot-mode Flags (see i21entry.asm)
   };

   USHORT User_CS; // cs 0x14 -- this is Real Mode CS!
   USHORT User_F;  // f  0x16 -- this is Real Mode Flags!!!

} DEMUSERFRAME;

typedef DEMUSERFRAME UNALIGNED *PDEMUSERFRAME;

#pragma pack()


// macro: retrieve flat ptr given separate segment/offset and prot mode
//        flag
//

#define dempGetVDMPtr(Segment, Offset, fProtMode) \
Sim32GetVDMPointer((ULONG)MAKELONG(Offset, Segment), 0, (UCHAR)fProtMode)


/*
 * Macros to set misc registers on user's stack -
 * this is equivalent to what dos kernel does with regular calls
 *
 * remember that ax is set according to the call result
 * (and then dos takes care of it)
 *
 */


#define getUserDSSI(pUserEnv, fProtMode) \
dempGetVDMPtr(getUserDS(pUserEnv), getUserSI(pUserEnv), fProtMode)

#define getUserDSDX(pUserEnv, fProtMode) \
dempGetVDMPtr(getUserDS(pUserEnv), getUserDX(pUserEnv), fProtMode)

#define getUserESDI(pUserEnv, fProtMode) \
dempGetVDMPtr(getUserES(pUserEnv), getUserDI(pUserEnv), fProtMode)

#define setUserReg(pUserEnv, Reg, Value) \
( ((PDEMUSERFRAME)pUserEnv)->User_ ## Reg = Value )

#define getUserReg(pUserEnv, Reg) \
(((PDEMUSERFRAME)pUserEnv)->User_ ## Reg)

#define getUserAX(pUserEnv) getUserReg(pUserEnv,AX)
#define getUserBX(pUserEnv) getUserReg(pUserEnv,BX)
#define getUserCX(pUserEnv) getUserReg(pUserEnv,CX)
#define getUserDX(pUserEnv) getUserReg(pUserEnv,DX)
#define getUserSI(pUserEnv) getUserReg(pUserEnv,SI)
#define getUserDI(pUserEnv) getUserReg(pUserEnv,DI)
#define getUserES(pUserEnv) getUserReg(pUserEnv,ES)
#define getUserDS(pUserEnv) getUserReg(pUserEnv,DS)

#define getUserAL(pUserEnv) getUserReg(pUserEnv,AL)
#define getUserAH(pUserEnv) getUserReg(pUserEnv,AH)
#define getUserBL(pUserEnv) getUserReg(pUserEnv,BL)
#define getUserBH(pUserEnv) getUserReg(pUserEnv,BH)
#define getUserCL(pUserEnv) getUserReg(pUserEnv,CL)
#define getUserCH(pUserEnv) getUserReg(pUserEnv,CH)
#define getUserDL(pUserEnv) getUserReg(pUserEnv,DL)
#define getUserDH(pUserEnv) getUserReg(pUserEnv,DH)

#define setUserAX(Value, pUserEnv) setUserReg(pUserEnv, AX, Value)
#define setUserBX(Value, pUserEnv) setUserReg(pUserEnv, BX, Value)
#define setUserCX(Value, pUserEnv) setUserReg(pUserEnv, CX, Value)
#define setUserDX(Value, pUserEnv) setUserReg(pUserEnv, DX, Value)
#define setUserSI(Value, pUserEnv) setUserReg(pUserEnv, SI, Value)
#define setUserDI(Value, pUserEnv) setUserReg(pUserEnv, DI, Value)

#define setUserAL(Value, pUserEnv) setUserReg(pUserEnv, AL, Value)
#define setUserAH(Value, pUserEnv) setUserReg(pUserEnv, AH, Value)
#define setUserBL(Value, pUserEnv) setUserReg(pUserEnv, BL, Value)
#define setUserBH(Value, pUserEnv) setUserReg(pUserEnv, BH, Value)
#define setUserCL(Value, pUserEnv) setUserReg(pUserEnv, CL, Value)
#define setUserCH(Value, pUserEnv) setUserReg(pUserEnv, CH, Value)
#define setUserDL(Value, pUserEnv) setUserReg(pUserEnv, DL, Value)
#define setUserDH(Value, pUserEnv) setUserReg(pUserEnv, DH, Value)


//
// These macros are supposed to be used ONLY when being called from
// protected mode Windows (i.e. krnl386 supplies proper stack)
//

#define getUserPModeFlags(pUserEnv) getUserReg(pUserEnv, ProtMode_F)
#define setUserPModeFlags(Value, pUserEnv) setUserReg(pUserEnv, ProtMode_F, Value)


/* --------------------------------------------------------------------------

   Volume information definitions
   as they apply to a GetVolumeInformation api

   -------------------------------------------------------------------------- */

typedef struct tagLFNVolumeInformation {
   DWORD dwFSNameBufferSize;
   LPSTR lpFSNameBuffer;
   DWORD dwMaximumFileNameLength;
   DWORD dwMaximumPathNameLength;
   DWORD dwFSFlags;
}  LFNVOLUMEINFO, *PLFNVOLUMEINFO, *LPLFNVOLUMEINFO;


//
// defines a flag that indicates LFN api support on a volume
//
#define FS_LFN_APIS 0x00004000UL

//
// allowed lfn volume flags
//

#define LFN_FS_ALLOWED_FLAGS \
(FS_CASE_IS_PRESERVED | FS_CASE_SENSITIVE | \
 FS_UNICODE_STORED_ON_DISK | FS_VOL_IS_COMPRESSED | \
 FS_LFN_APIS)


/* --------------------------------------------------------------------------

   File Time /Dos time conversion definitions

   -------------------------------------------------------------------------- */

//
// minor code to use in demLFNFileTimeControl
//

typedef enum tagFileTimeControlMinorCode {

   fnFileTimeToDosDateTime = 0,
   fnDosDateTimeToFileTime = 1

}  enumFileTimeControlMinorCode;

// this constant masks enumFileTimeControlMinorCode values
//
#define FTCTL_CODEMASK (UINT)0x000F

// this flag tells file time control to use UTC time in conversion
//
#define FTCTL_UTCTIME  (UINT)0x0010

//
// structure that is used in time conversion calls in demlfn.c
//

typedef struct tagLFNFileTimeInfo {
   USHORT uDosDate;
   USHORT uDosTime;
   USHORT uMilliseconds; // spill-over

}  LFNFILETIMEINFO, *PLFNFILETIMEINFO, *LPLFNFILETIMEINFO;


//
// These functions determine whether the target file's time should not be
// converted to local time -- such as files from the cdrom
//
BOOL dempUseUTCTimeByHandle(HANDLE hFile);
BOOL dempUseUTCTimeByName(PUNICODE_STRING pFileName);


/* --------------------------------------------------------------------------

   Get/Set File attributes definitions

   -------------------------------------------------------------------------- */


typedef enum tagGetSetFileAttributesMinorCode {
   fnGetFileAttributes     = 0,
   fnSetFileAttributes     = 1,
   fnGetCompressedFileSize = 2,
   fnSetLastWriteDateTime  = 3,
   fnGetLastWriteDateTime  = 4,
   fnSetLastAccessDateTime = 5,
   fnGetLastAccessDateTime = 6,
   fnSetCreationDateTime   = 7,
   fnGetCreationDateTime   = 8
}  enumGetSetFileAttributesMinorCode;

typedef union tagLFNFileAttributes {

   USHORT wFileAttributes;   // file attrs
   LFNFILETIMEINFO TimeInfo; // for date/time
   DWORD  dwFileSize;        // for compressed file size

}  LFNFILEATTRIBUTES, *PLFNFILEATTRIBUTES;

/* --------------------------------------------------------------------------

   Get/Set File Time (by handle) definitions - fn 57h
   handled by demFileTimes

   -------------------------------------------------------------------------- */

//
// flag in SFT indicating that entry references a device (com1:, lpt1:, etc)
//

#define SFTFLAG_DEVICE_ID 0x0080

//
// Minor code for file time requests
//

typedef enum tagFileTimeMinorCode {
   fnFTGetLastWriteDateTime  = 0x00,
   fnFTSetLastWriteDateTime  = 0x01,
   fnFTGetLastAccessDateTime = 0x04,
   fnFTSetLastAccessDateTime = 0x05,
   fnFTGetCreationDateTime   = 0x06,
   fnFTSetCreationDateTime   = 0x07
}  enumFileTimeMinorCode;


/* --------------------------------------------------------------------------

   Open File (function 716ch) definitions
   largely equivalent to handling fn 6ch

   -------------------------------------------------------------------------- */

//
// Access flags
//

#define DEM_OPEN_ACCESS_READONLY  0x0000
#define DEM_OPEN_ACCESS_WRITEONLY 0x0001
#define DEM_OPEN_ACCESS_READWRITE 0x0002
#define DEM_OPEN_ACCESS_RESERVED  0x0003

// Not supported
#define DEM_OPEN_ACCESS_RO_NOMODLASTACCESS 0x0004

#define DEM_OPEN_ACCESS_MASK      0x000F

//
// Share flags
//

#define DEM_OPEN_SHARE_COMPATIBLE    0x0000
#define DEM_OPEN_SHARE_DENYREADWRITE 0x0010
#define DEM_OPEN_SHARE_DENYWRITE     0x0020
#define DEM_OPEN_SHARE_DENYREAD      0x0030
#define DEM_OPEN_SHARE_DENYNONE      0x0040
#define DEM_OPEN_SHARE_MASK          0x0070

//
// Open flags
//

#define DEM_OPEN_FLAGS_NOINHERIT     0x0080
#define DEM_OPEN_FLAGS_NO_BUFFERING  0x0100
#define DEM_OPEN_FLAGS_NO_COMPRESS   0x0200

// Not supported
#define DEM_OPEN_FLAGS_ALIAS_HINT    0x0400

#define DEM_OPEN_FLAGS_NOCRITERR     0x2000
#define DEM_OPEN_FLAGS_COMMIT        0x4000
#define DEM_OPEN_FLAGS_VALID         \
(DEM_OPEN_FLAGS_NOINHERIT    | DEM_OPEN_FLAGS_NO_BUFFERING | \
 DEM_OPEN_FLAGS_NO_COMPRESS  | DEM_OPEN_FLAGS_ALIAS_HINT   | \
 DEM_OPEN_FLAGS_NOCRITERR    | DEM_OPEN_FLAGS_COMMIT)
#define DEM_OPEN_FLAGS_MASK          0xFF00

//
// Action flags
//

// DEM_OPEN_FUNCTION_FILE_CREATE combines with action_file_open or
// action_file_truncate flags

#define DEM_OPEN_ACTION_FILE_CREATE       0x0010
#define DEM_OPEN_ACTION_FILE_OPEN         0x0001
#define DEM_OPEN_ACTION_FILE_TRUNCATE     0x0002

//
// resulting action (returned to the app)
//

#define ACTION_OPENED            0x0001
#define ACTION_CREATED_OPENED    0x0002
#define ACTION_REPLACED_OPENED   0x0003


/* --------------------------------------------------------------------------

   Additional file attribute definitions

   -------------------------------------------------------------------------- */

// Volume id attribute

#define DEM_FILE_ATTRIBUTE_VOLUME_ID 0x00000008L

//
// Valid file attributes mask as understood by dos
//

#define DEM_FILE_ATTRIBUTE_VALID  \
(FILE_ATTRIBUTE_READONLY| FILE_ATTRIBUTE_HIDDEN| \
 FILE_ATTRIBUTE_SYSTEM  | FILE_ATTRIBUTE_DIRECTORY | \
 FILE_ATTRIBUTE_ARCHIVE | DEM_FILE_ATTRIBUTE_VOLUME_ID)

//
// Valid to set attributes
//

#define DEM_FILE_ATTRIBUTE_SET_VALID  \
(FILE_ATTRIBUTE_READONLY| FILE_ATTRIBUTE_HIDDEN| \
 FILE_ATTRIBUTE_SYSTEM  | FILE_ATTRIBUTE_ARCHIVE)

/* --------------------------------------------------------------------------

   FindFirst/FindNext definitions

   -------------------------------------------------------------------------- */

//
// Definition for the handle table entries
// Handle (which is returned to the app) references this entry
// providing all the relevant info for FindFirst/FindNext
//

typedef struct tagLFNFindHandleTableEntry {
   union {
      HANDLE hFindHandle; // handle for searching
      UINT   nNextFreeEntry;
   };

   USHORT wMustMatchAttributes;
   USHORT wSearchAttributes;

   UNICODE_STRING unicodeFileName; // counted file name string,
                                   // only used if matched a vol label

   // process id, aka pdb requesting this handle
   // or 0xffff if the entry is empty
   USHORT wProcessPDB;

}  LFN_SEARCH_HANDLE_ENTRY, *PLFN_SEARCH_HANDLE_ENTRY;

//
// Definition of a handle table
// Table is dynamic and it expands/shrinks as necessary
//

typedef struct tagFindHandleTable {

   PLFN_SEARCH_HANDLE_ENTRY pHandleTable;
   UINT nTableSize;           // total size in entries
   UINT nFreeEntry;           // free list head
   UINT nHandleCount;         // handles stored (bottom)
}  DemSearchHandleTable;

//
// Definitions of a constants used in managing handle table
//

// initial table size
#define LFN_SEARCH_HANDLE_INITIAL_SIZE 0x20

// handle table growth increment
#define LFN_SEARCH_HANDLE_INCREMENT    0x10

// used to mark a last free list entry
#define LFN_SEARCH_HANDLE_LIST_END     ((UINT)-1)

//
// Application receives handles in format
// LFN_DOS_HANDLE_MASK + (index to the handle table)
// so that it looks legit to the app
//

#define LFN_DOS_HANDLE_MASK ((USHORT)0x4000)

// max number of search handles we can support

#define LFN_DOS_HANDLE_LIMIT ((USHORT)0x3FFF)

//
// Date/Time format as returned in WIN32_FIND_DATAA structure
//

typedef enum tagLFNDateTimeFormat {
   dtfWin32 = 0, // win32 file time/date format
   dtfDos   = 1  // dos date time format
}  enumLFNDateTimeFormat;



/* --------------------------------------------------------------------------

   GetPathName definitions

   -------------------------------------------------------------------------- */

//
// minor code for the fn 7160h
//

typedef enum tagFullPathNameMinorCode {
   fnGetFullPathName  = 0,
   fnGetShortPathName = 1,
   fnGetLongPathName  = 2
} enumFullPathNameMinorCode;


/* --------------------------------------------------------------------------

   Subst function definitions

   -------------------------------------------------------------------------- */


//
// minor code for the fn 71aah
// used in demLFNSubstControl
//

typedef enum tagSubstMinorCode {
   fnCreateSubst = 0,
   fnRemoveSubst = 1,
   fnQuerySubst  = 2
}  enumSubstMinorCode;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demmisc.c ===
/*  demmisc.c - Misc. SVC routines
 *
 *  demLoadDos
 *
 *  Modification History:
 *
 *  Sudeepb 31-Mar-1991 Created
 */

#include "dem.h"
#include "demmsg.h"
// #include "demdasd.h"

#include <stdio.h>
#include <string.h>
#include <softpc.h>
#include <mvdm.h>
#include <dbgsvc.h>
#include <nt_vdd.h>
#include <host_def.h>

#if DEVL
// int 21h func names
// index off of function number in ah
char *scname[] = {
     "Terminate Program",
     "Read Kbd with Echo",
     "Display Character",
     "Auxillary Input",
     "Auxillary Output",
     "Print Character",
     "Direct Con Output",
     "Direct Con Input",
     "Read Kbd without Echo",
     "Display String",
     "Read String",
     "Check Keyboard Status",
     "Flush Buffer,Read Kbd",
     "Reset Drive",
     "Set Default Drive",
     "FCB Open",
     "FCB Close",
     "FCB Find First",
     "FCB Find Next",
     "FCB Delete",
     "FCB Seq Read",
     "FCB Seq Write",
     "FCB Create",
     "FCB Rename",
     "18h??",
     "Get Default Drive",
     "Set Disk Transfer Addr",
     "Get Default Drive Data",
     "Get Drive Data",
     "1Dh??",
     "1Eh??",
     "Get Default DPB",
     "20h??",
     "FCB Random Read",
     "FCB Random Write",
     "FCB Get File Size",
     "FCB Set Random Record",
     "Set Interrupt Vector",
     "Create Process Data Block",
     "FCB Random Read Block",
     "FCB Random Write Block",
     "FCB Parse File Name",
     "Get Date",
     "Set Date",
     "Get Time",
     "Set Time",
     "SetReset Write Verify",
     "Get Disk Transefr Addr",
     "Get Version Number",
     "Keep Process",
     "Get Drive Parameters",
     "GetSet CTRL C",
     "Get InDOS Flag",
     "Get Interrupt Vector",
     "Get Disk Free Space",
     "Char Oper",
     "GetSet Country/Region Info",
     "Make Dir",
     "Remove Dir",
     "Change DirDir",
     "Create File",
     "Open File",
     "Close File",
     "Read File",
     "Write File",
     "Delete File",
     "Move File Ptr",
     "GetSet File Attr",
     "IOCTL",
     "Dup File Handle",
     "Force Dup Handle",
     "Get Current Dir",
     "Alloc Mem",
     "Free Mem",
     "Realloc Mem",
     "Exec Process",
     "Exit Process",
     "Get Child Process Exit Code",
     "Find First",
     "Find Next",
     "Set Current PSP",
     "Get Current PSP",
     "Get In Vars",
     "Set DPB",
     "Get Verify On Write",
     "Dup PDB",
     "Rename File",
     "GetSet File Date and Time",
     "Allocation Strategy",
     "Get Extended Error",
     "Create Temp File",
     "Create New File",
     "LockUnlock File",
     "SetExtendedErrorNetwork-ServerCall",
     "Network-UserOper",
     "Network-AssignOper",
     "xNameTrans",
     "PathParse",
     "GetCurrentPSP",
     "ECS CALL",
     "Set Printer Flag",
     "Extended Country Info",
     "GetSet CodePage",
     "Set Max Handle",
     "Commit File",
     "GetSetMediaID",
     "6ah??",
     "IFS IOCTL",
     "Extended OpenCreate",
     "6d??",
     "6e??",
     "6f??",
     "70??",
     "LFN API"
     };
#endif

extern BOOL IsFirstCall;

extern void nt_floppy_release_lock(void);

LPSTR pszBIOSDirectory;
LPSTR pszDOSDirectory;

// internal func prototype
BOOL IsDebuggee(void);
void SignalSegmentNotice(WORD  wType,
                         WORD  wModuleSeg,
                         WORD  wLoadSeg,
                         WORD  wNewSeg,
                         LPSTR lpName,
                         DWORD dwImageLen );

/* demLoadDos - Load NTDOS.SYS.
 *
 * This SVC is made by NTIO.SYS to load NTDOS.SYS.
 *
 * Entry - Client (DI) - Load Segment
 *
 * Exit  - SUCCESS returns
 *         FAILURE Kills the VDM
 */
VOID demLoadDos (VOID)
{
PBYTE   pbLoadAddr;
HANDLE  hfile;
DWORD   BytesRead;
#ifdef FE_SB
LANGID  LcId = GetSystemDefaultLangID();
#endif //FE_SB

    // get linear address where ntdos.sys will be loaded
    pbLoadAddr = (PBYTE) GetVDMAddr(getDI(),0);

    // set up BIOS path string
    if(DbgIsDebuggee() &&
       ((pszBIOSDirectory = (PCHAR)malloc (ulSystem32PathLen +
                                  1 + sizeof(NTIO_409) + sizeof(NTIO_411) + 1 )) != NULL)) {
        memcpy (pszBIOSDirectory, pszSystem32Path, ulSystem32PathLen);
#ifdef FE_SB
        switch (LcId) {
            case MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT):
                memcpy (pszBIOSDirectory + ulSystem32PathLen, NTIO_411, strlen(NTIO_411)+1);
                break;
            case MAKELANGID(LANG_KOREAN,SUBLANG_DEFAULT):
                memcpy (pszBIOSDirectory + ulSystem32PathLen, NTIO_412, strlen(NTIO_412)+1);
                break;
            case MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_TRADITIONAL):
                memcpy (pszBIOSDirectory + ulSystem32PathLen, NTIO_404, strlen(NTIO_404)+1);
                break;
            case MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED):
            case MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_HONGKONG):
                memcpy (pszBIOSDirectory + ulSystem32PathLen, NTIO_804, strlen(NTIO_804)+1);
                break;
            default:
                memcpy (pszBIOSDirectory + ulSystem32PathLen, NTIO_409, strlen(NTIO_409)+1);
                break;
        }
#else
        strcat (pszBIOSDirectory,"\\ntio.sys");
#endif
    }

    // prepare the dos file name
    if ((pszDOSDirectory = (PCHAR)malloc (ulSystem32PathLen + 1 + 8 + 1 + 3 + 1 + 1)) == NULL) {
        RcErrorDialogBox(EG_MALLOC_FAILURE,NULL,NULL);
        TerminateVDM ();
    }

    memcpy (pszDOSDirectory, pszSystem32Path, ulSystem32PathLen);

#ifdef FE_SB
    switch (LcId)
    {
    case MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT):
        memcpy (pszDOSDirectory + ulSystem32PathLen, NTDOS_411, strlen(NTDOS_411)+1);
        break;
    case MAKELANGID(LANG_KOREAN,SUBLANG_DEFAULT):
        memcpy (pszDOSDirectory + ulSystem32PathLen, NTDOS_412, strlen(NTDOS_412)+1);
        break;
    case MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_TRADITIONAL):
        memcpy (pszDOSDirectory + ulSystem32PathLen, NTDOS_404, strlen(NTDOS_404)+1);
        break;
    case MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED):
    case MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_HONGKONG):
        memcpy (pszDOSDirectory + ulSystem32PathLen, NTDOS_804, strlen(NTDOS_804)+1);
        break;
    default:
        memcpy (pszDOSDirectory + ulSystem32PathLen, NTDOS_409, strlen(NTDOS_409)+1);
        break;
    }
#else
    memcpy (pszDOSDirectory + ulSystem32PathLen, NTDOS_409, strlen(NTDOS_409)+1);
#endif

    hfile = CreateFileOem(pszDOSDirectory,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL );

    if (hfile == (HANDLE)0xffffffff) {
        TerminateVDM();
    }

    BytesRead = 1;
    while (BytesRead) {
        if (!ReadFile(hfile, pbLoadAddr, 16384, &BytesRead, NULL)) {
            TerminateVDM();
        }
        pbLoadAddr = (PBYTE)((ULONG)pbLoadAddr + BytesRead);

    }

    CloseHandle (hfile);

    if (!DbgIsDebuggee()) {
        free(pszDOSDirectory);
    }
    return;
}


/* demDOSDispCall
 *
 * This SVC is made by System_Call upon entering the dos
 *
 *
 * Entry: Client registers as per user app upon entry to dos
 *
 * Exit  - SUCCESS returns, if being debugged and DEMDOSDISP&fShowSvcMsg
 *                          dumps user app's registers and service name
 */
VOID demDOSDispCall(VOID)
{
#if DEVL
   WORD ax;

    if (!DbgIsDebuggee()) {
         return;
         }
    if (fShowSVCMsg & DEMDOSDISP) {
        ax = getAX();
        sprintf(demDebugBuffer,"demDosDispCall %s\n\tAX=%.4x BX=%.4x CX=%.4x DX=%.4x DI=%.4x SI=%.4x\n",
                 scname[HIBYTE(ax)],
                 ax,getBX(),getCX(),getDX(),getDI(), getSI());

        OutputDebugStringOem(demDebugBuffer);

        sprintf(demDebugBuffer,"\tCS=%.4x IP=%.4x DS=%.4x ES=%.4x SS=%.4x SP=%.4x BP=%.4x\n",
                 getCS(),getIP(), getDS(),getES(),getSS(),getSP()+2,getBP());

        OutputDebugStringOem(demDebugBuffer);
        }
#endif
}




/* demDOSDispRet
 *
 * This SVC is made by System_Call upon exiting from the dos
 *
 * Entry: Client registers as per user app upon exit to dos
 *
 * Exit  - SUCCESS returns, if being debugged and DEMDOSDISP&fShowSvcMsg
 *                          dumps user app's registers
 */
VOID demDOSDispRet(VOID)
{
#if DEVL
   PWORD16 pStk;

   if (!DbgIsDebuggee()) {
        return;
        }

   if (fShowSVCMsg & DEMDOSDISP) {

         // get ptr to flag word on stack
       pStk = (WORD *)GetVDMAddr(getSS(), getSP());
       pStk += 2;

       sprintf (demDebugBuffer,"demDosDispRet\n\tAX=%.4x BX=%.4x CX=%.4x DX=%.4x DI=%.4x SI=%.4x\n",
                getAX(),getBX(),getCX(),getDX(),getDI(),getSI());

       OutputDebugStringOem(demDebugBuffer);

       sprintf(demDebugBuffer,"\tCS=%.4x IP=%.4x DS=%.4x ES=%.4x SS=%.4x SP=%.4x BP=%.4x CF=%.1x\n",
               getCS(),getIP(), getDS(),getES(),getSS(),getSP(),getBP(), (*pStk) & 1);

       OutputDebugStringOem(demDebugBuffer);
       }
#endif
}


/* demEntryDosApp - Dump Entry Point Dos Apps
 *
 * This SVC is made by NTDOS.SYS,$exec just prior to entering dos app
 *
 * Entry - Client DS:SI points to entry point
 *         Client AX:DI points to initial stack
 *         Client DX has PDB pointer
 *
 * Exit  - SUCCESS returns, if being debugged and DEMDOSAPPBREAK&fShowSvcMsg
 *                          breaks to debugger
 */
VOID demEntryDosApp(VOID)
{
USHORT  PDB;

    PDB = getDX();
    if(!IsFirstCall)
       VDDCreateUserHook(PDB);

    if (!DbgIsDebuggee()) {
         return;
         }

    DbgDosAppStart(getDS(), getSI());

#if DEVL
    if (fShowSVCMsg & DEMDOSAPPBREAK) {
        sprintf(demDebugBuffer,"demEntryDosApp: Entry=%.4x:%.4x, Stk=%.4x:%.4x PDB=%.4x\n",
                  getCS(),getIP(),getAX(),getDI(),PDB);
        OutputDebugStringOem(demDebugBuffer);
        DebugBreak();
        }
#endif

}

/* demLoadDosAppSym - Load Dos Apps Symbols
 *
 * This SVC is made by NTDOS.SYS,$exec to load Dos App symbols
 *
 * Entry - Client ES:DI  -Fully Qualified Path Name of executable
 *         Client BX     -Load Segment\Reloc Factor
 *         Client DX:AX  -HIWORD:LOWORD exe size
 *
 * Exit  - SUCCESS returns, raises debug exception, if being debugged
 *
 */
VOID demLoadDosAppSym(VOID)
{

    SignalSegmentNotice(DBG_MODLOAD,
                        0, getBX(), 0,
                        (LPSTR)GetVDMAddr(getES(),getDI()),
                        MAKELONG(getAX(), getDX()) );

}



/* demFreeDosAppSym - Free Dos Apps Symbols
 *
 * This SVC is made by NTDOS.SYS,$exec to Free Dos App symbols
 *
 * Entry - Client ES:DI  -Fully Qualified Path Name of executable
 *
 * Exit  - SUCCESS returns, raises debug exception, if being debugged
 *
 */
VOID demFreeDosAppSym(VOID)
{

    SignalSegmentNotice(DBG_MODFREE,
                        0, 0, 0,
                        (LPSTR)GetVDMAddr(getES(), getDI()),
                        0);
}


/* demSystemSymbolOp - Manipulate Symbols for special modules
 *
 * This SVC is made by NTDOS.SYS,NTIO.SYS
 *
 *         Client AH     -Operation
 *         Client AL     -module identifier
 *         Client BX     -Load Segment\Reloc Factor
 *         Client CX:DX  -HIWORD:LOWORD exe size
 *
 * Exit  - SUCCESS returns, raises debug exception, if being debugged
 *
 */
VOID demSystemSymbolOp(VOID)
{

    LPSTR pszPathName;

    if (!DbgIsDebuggee()) {
         return;
         }
    switch(getAL()) {

        case ID_NTIO:
            pszPathName = pszBIOSDirectory;
            break;
        case ID_NTDOS:
            pszPathName = pszDOSDirectory;
            break;
        default:
            pszPathName = NULL;

    }

    // check this again for the case where the static strings have been freed
    if (pszPathName != NULL) {

        switch(getAH() & (255-SYMOP_CLEANUP)) {

            case SYMOP_LOAD:
                SignalSegmentNotice(DBG_MODLOAD,
                    0, getBX(), 0,
                    pszPathName,
                    MAKELONG(getDX(), getCX()) );
                break;

            case SYMOP_FREE:
                //bugbug not implemented yet
                break;

            case SYMOP_MOVE:
                SignalSegmentNotice(DBG_SEGMOVE,
                    getDI(), getBX(), getES(),
                    pszPathName,
                    MAKELONG(getDX(), getCX()) );
                break;
        }
    }

    if (getAH() & SYMOP_CLEANUP) {

        if (pszBIOSDirectory != NULL) {
            free (pszBIOSDirectory);
        }

        if (pszDOSDirectory != NULL) {
            free(pszDOSDirectory);
        }

    }

}

VOID demOutputString(VOID)
{
    LPSTR   lpText;
    UCHAR   fPE;

    if ( !DbgIsDebuggee() ) {
        return;
    }

    fPE = ISPESET;

    lpText = (LPSTR)Sim32GetVDMPointer(
                        ((ULONG)getDS() << 16) + (ULONG)getSI(),
                        (ULONG)getBX(), fPE );

    OutputDebugStringOem( lpText );
}

VOID demInputString(VOID)
{
    LPSTR   lpText;
    UCHAR   fPE;

    if ( !DbgIsDebuggee() ) {
        return;
    }

    fPE = ISPESET;

    lpText = (LPSTR)Sim32GetVDMPointer(
                        ((ULONG)getDS() << 16) + (ULONG)getDI(),
                        (ULONG)getBX(), fPE );

    DbgPrompt( "", lpText, 0x80 );
}

/* SignalSegmentNotice
 *
 * packs up the data and raises STATUS_SEGMENT_NOTIFICATION
 *
 * Entry - WORD  wType     - DBG_MODLOAD, DBG_MODFREE
 *         WORD  wModuleSeg- segment number within module (1 based)
 *         WORD  wLoadSeg  - Starting Segment (reloc factor)
 *         LPSTR lpName    - ptr to Name of Image
 *         DWORD dwModLen  - Length of module
 *
 *
 *         if wType ==DBG_MODLOAD wOldLoadSeg is unused
 *         if wType ==DBG_MODFREE wLoadSeg,dwImageLen,wOldLoadSeg are unused
 *
 *         Use 0 or NULL for unused parameters
 *
 * Exit  - void
 *
 */
void SignalSegmentNotice(WORD  wType,
                         WORD  wModuleSeg,
                         WORD  wLoadSeg,
                         WORD  wNewSeg,
                         LPSTR lpName,
                         DWORD dwImageLen )
{
    int         i;
    DWORD       dw;
    LPSTR       lpstr;
    LPSTR       lpModuleName;
    char        ach[MAX_PATH+9];   // 9 for module name

    if (!DbgIsDebuggee()) {
         return;
         }

       // create file name
    dw = GetFullPathNameOemSys(lpName,
                         sizeof(ach)-9, // 9 for module name
                         ach,
                         &lpstr,
                         TRUE);

    if (!dw || dw >= sizeof(ach))  {
        lpName = " ";
        strcpy(ach, lpName);
        }
    else {
        lpName = lpstr;
        }

       // copy in module name
    i  = 8;   // limit len of module name

    lpModuleName = lpstr = ach+strlen(ach)+1;
    while (*lpName && *lpName != '.' && i--)
         {
          *lpstr++ = *lpName++;          
          }
    *lpstr = '\0';

#if DBG
    if (fShowSVCMsg)  {
        sprintf(demDebugBuffer,"dem Segment Notify: <%s> Seg=%lxh, ImageLen=%ld\n",
                  ach, (DWORD)wLoadSeg, dwImageLen);
        OutputDebugStringOem(demDebugBuffer);
        }
#endif

    // Send it to the debugger
    DbgSegmentNotice(wType, wModuleSeg, wLoadSeg, wNewSeg, lpModuleName, ach, dwImageLen);
}


/* demIsDebug - Determine if 16bit DOS should make entry/exit calls at int21
 *
 * Entry: void
 *
 * Exit:  Client AL = 0 if not
 *        Client AL = 1 if yes
 *
 */
VOID demIsDebug(void)
{
    BYTE dbgflags = 0;

    if (DbgIsDebuggee()) {
        dbgflags |= ISDBG_DEBUGGEE;
        if (fShowSVCMsg)
            dbgflags |= ISDBG_SHOWSVC;
    }

    setAL (dbgflags);
    return;
}

/* demDiskReset - Reset floppy disks.
 *
 * Entry - None
 *
 * Exit  - FDAccess in DOSDATA (NTDOS.SYS) is 0.
 */

VOID demDiskReset (VOID)
{
    extern WORD * pFDAccess;        // defined in SoftPC.

    HostFloppyReset();
    HostFdiskReset();
    *pFDAccess = 0;

    return;
}

/* demExitVDM - Kill the VDM From 16Bit side with a proper message
 *              in case something goes wrong.
 *
 * Entry - None
 *
 * Exit  - None (VDM Is killed)
 */

VOID demExitVDM ( VOID )
{
    RcErrorDialogBox(ED_BADSYSFILE,"config.nt",NULL);
    TerminateVDM ();
}

/* demWOWFiles - Return what should be the value of files= for WOW VDM.
 *
 * Entry - AL - files= specified in config.sys
 *
 * Exit  - client AL is set to max if WOW VDM else unmodified
 */

VOID demWOWFiles ( VOID )
{
    if(VDMForWOW)
        setAL (255);
    return;
}

/** GetDOSAppName - Return the name of the current DOS executable
 *
 *  ENTRY -
 *      OUT ppszApp Name: address of the app
 *
 *  EXIT
 *      SUCCESS - Returns SUCCESS
 *      FAILURE - Returns FAILURE
 *
 * Comments:
 *  This routine uses the current PDB to figure out the name of the currently
 *  executing DOS application.
 */

VOID GetDOSAppName(LPSTR pszAppName)
{
    PCHAR pch = NULL;
    PUSHORT pusEnvSeg;

#define PDB_ENV_OFFSET 0x2c
    if (pusCurrentPDB) {
        pusEnvSeg = (PUSHORT)Sim32GetVDMPointer((*pusCurrentPDB) << 16, 0, 0);

        pusEnvSeg = (PUSHORT)((PCHAR)pusEnvSeg + PDB_ENV_OFFSET);

        // Get a pointer to the environment
        if (VDMForWOW || (getMSW() & MSW_PE)) {
            pch = (PCHAR)Sim32GetVDMPointer(*pusEnvSeg << 16, 1, TRUE);
        } else {
            pch = (PCHAR)Sim32GetVDMPointer(*pusEnvSeg << 16, 0, 0);
        }
    }

    if (NULL == pch) {
       *pszAppName = '\0';
    }
    else {
        // Walk through the environment strings until we get to the command line
       while (*pch) {
           pch += strlen(pch) + 1;
       }

       pch += 3;          // skip past the double null and string count
       strcpy(pszAppName, pch);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demsrch.c ===
/* demsrch.c - SVC handlers for calls to search files
 *
 * demFindFirst
 * demFindNext
 * demFindFirstFCB
 * demFindNextFCB
 *
 * Modification History:
 *
 * Sudeepb 06-Apr-1991 Created
 *
 */

#include "dem.h"
#include "demmsg.h"
#include "winbasep.h"
#include <vdm.h>
#include <softpc.h>
#include <mvdm.h>
#include <memory.h>
#include <nt_vdd.h>
#include "dpmtbls.h"

extern BOOL IsFirstCall;

// Defined in host\src\nt_devs.c
VOID nt_devices_block_or_terminate(VOID);

/*
 *  Internal globals, function prototypes
 */

#define FINDFILE_DEVICE (HANDLE)0xffffffff

typedef struct _PSP_FILEFINDLIST {
    LIST_ENTRY PspFFindEntry;      // Next psp
    LIST_ENTRY FFindHeadList;      // File Find list for this psp
    ULONG      usPsp;              // PSP id
} PSP_FFINDLIST, *PPSP_FFINDLIST;

typedef struct _FFINDDOSDATA {
    ULONG    FileIndex;
    ULONG    FileNameLength;
    WCHAR    FileName[MAXIMUM_FILENAME_LENGTH + 1];
    FILETIME ftLastWriteTime;
    DWORD    dwFileSizeLow;
    UCHAR    uchFileAttributes;
    CHAR     cFileName[14];
} FFINDDOSDATA, *PFFINDDOSDATA;

typedef struct _FILEFINDLIST {
    LIST_ENTRY     FFindEntry;
    ULONG          FFindId;
    NTSTATUS       LastQueryStatus;
    LARGE_INTEGER  FindFileTics;
    HANDLE         DirectoryHandle;
    PVOID          FindBufferBase;
    PVOID          FindBufferNext;
    ULONG          FindBufferLength;
    FFINDDOSDATA   DosData;
    USHORT         usSrchAttr;
    BOOLEAN        SupportReset;
    UNICODE_STRING PathName;
    UNICODE_STRING FileName;
    BOOL           SearchOnCD;
}FFINDLIST, *PFFINDLIST;

LIST_ENTRY PspFFindHeadList= {&PspFFindHeadList, &PspFFindHeadList};


#define FFINDID_BASE 0x80000000
ULONG NextFFindId = FFINDID_BASE;
BOOLEAN FFindIdWrap = FALSE;
#define MAX_DIRECTORYHANDLE 64
#define MAX_FINDBUFFER 128
ULONG NumDirectoryHandle = 0;
ULONG NumFindBuffer=0;
LARGE_INTEGER FindFileTics = {0,0};
LARGE_INTEGER NextFindFileTics = {0,0};

char szStartDotStar[]="????????.???";


PFFINDLIST
SearchFile(
    PWCHAR pwcFile,
    USHORT SearchAttr,
    PFFINDLIST pFFindEntry,
    PFFINDDOSDATA pFFindDDOut
    );


NTSTATUS
FileFindNext(
    PFFINDDOSDATA pFFindDD,
    PFFINDLIST pFFindEntry
    );

NTSTATUS
FileFindLast(
    PFFINDLIST pFFindEntry
    );

VOID
FileFindClose(
    PFFINDLIST pFFindEntry
    );


NTSTATUS
FileFindOpen(
    PWCHAR pwcFile,
    PFFINDLIST pFFindEntry,
    ULONG BufferSize
    );

NTSTATUS
FileFindReset(
   PFFINDLIST pFFindEntry
   );


HANDLE
FileFindFirstDevice(
    PWCHAR FileName,
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo
    );

void
CloseOldestFileFindBuffer(
   void
   );


BOOL
CopyDirInfoToDosData(
    PFFINDDOSDATA pFFindDD,
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo,
    USHORT SearchAttr
    );

BOOL
DemOemToUni(
    PUNICODE_STRING pUnicode,
    LPSTR lpstr
    );

VOID
FillFcbVolume(
    PSRCHBUF pSrchBuf,
    CHAR *pFileName,
    USHORT SearchAttr
    );

BOOL
FillDtaVolume(
    CHAR *pFileName,
    PSRCHDTA  pDta,
    USHORT SearchAttr
    );

BOOL
MatchVolLabel(
    CHAR * pVolLabel,
    CHAR * pBaseName
    );

VOID
NtVolumeNameToDosVolumeName(
    CHAR * pDosName,
    CHAR * pNtName
    );

VOID
FillFCBSrchBuf(
     PFFINDDOSDATA pFFindDD,
     PSRCHBUF pSrchBuf,
     BOOL     IsOnCD
     );

VOID
FillSrchDta(
     PFFINDDOSDATA pFFindDD,
     PSRCHDTA pDta,
     BOOL     IsOnCD
     );

PFFINDLIST
AddFFindEntry(
     PWCHAR     pwcFile,
     PFFINDLIST pFFindEntrySrc
     );

PPSP_FFINDLIST
GetPspFFindList(
     USHORT CurrPsp
     );

PFFINDLIST
GetFFindEntryByFindId(
     ULONG NextFFindId
     );

VOID
FreeFFindEntry(
     PFFINDLIST pFFindEntry
     );

VOID
FreeFFindList(
     PLIST_ENTRY pFFindHeadList
     );


/* demFindFirst - Path-Style Find First File
 *
 * Entry -  Client (DS:DX) - File Path with wildcard
 *      Client (CX)    - Search Attributes
 *
 * Exit  - Success
 *      Client (CF) = 0
 *      DTA updated
 *
 *     Failure
 *      Client (CF) = 1
 *      Client (AX) = Error Code
 *
 * NOTES
 *    Search Rules: Ignore Read_only and Archive bits.
 *          If CX == ATTR_NORMAL Search only for normal files
 *          If CX == ATTR_HIDDEN Search Hidden or normal files
 *          If CX == ATTR_SYSTEM Search System or normal files
 *          If CX == ATTR_DIRECTORY Search directory or normal files
 *                  If CX == ATTR_VOLUME_ID Search Volume_ID
 *                  if CX == -1 return everytiing you find
 *
 *   Limitations - 21-Sep-1992 Jonle
 *     cannot return label from a UNC name,just like dos.
 *     Apps which keep many find handles open can cause
 *     serious trouble, we must rewrite so that we can
 *     close the handles
 *
 */

VOID demFindFirst (VOID)
{
    DWORD dwRet;
    PVOID pDta;
#ifdef DBCS /* demFindFirst() for CSNW */
    CHAR  achPath[MAX_PATH];
#endif /* DBCS */


    LPSTR lpFile = (LPSTR) GetVDMAddr (getDS(),getDX());

    pDta = (PVOID) GetVDMAddr (*((PUSHORT)pulDTALocation + 1),
                               *((PUSHORT)pulDTALocation));
#ifdef DBCS /* demFindFirst() for CSNW */
    /*
     * convert Netware path to Dos path
     */
    ConvNwPathToDosPath(achPath,lpFile, sizeof(achPath));
    lpFile = achPath;
#endif /* DBCS */
    dwRet = demFileFindFirst (pDta, lpFile, getCX());

    if (dwRet == -1) {
        dwRet = GetLastError();
        demClientError(INVALID_HANDLE_VALUE, *lpFile);
        return;
    }

    if (dwRet != 0) {
        setAX((USHORT) dwRet);
        setCF (1);
    } else {
        setCF (0);
    }
    return;

}


DWORD demFileFindFirst (
    PVOID pvDTA,
    LPSTR lpFile,
    USHORT SearchAttr)
{
    PSRCHDTA       pDta = (PSRCHDTA)pvDTA;
    PFFINDLIST     pFFindEntry;
    FFINDDOSDATA   FFindDD;
    UNICODE_STRING FileUni;
    WCHAR          wcFile[MAX_PATH + sizeof(WCHAR)];
    BOOL           IsOnCD;


#if DBG
    if (SIZEOF_DOSSRCHDTA != sizeof(SRCHDTA)) {
        sprintf(demDebugBuffer,
                "demsrch: FFirst SIZEOF_DOSSRCHDTA %ld != sizeof(SRCHDTA) %ld\n",
                SIZEOF_DOSSRCHDTA,
                sizeof(SRCHDTA));
        OutputDebugStringOem(demDebugBuffer);
        }

    if (fShowSVCMsg & DEMFILIO){
        sprintf(demDebugBuffer,"demsrch: FindFirst<%s>\n", lpFile);
        OutputDebugStringOem(demDebugBuffer);
        }
#endif

    STOREDWORD(pDta->FFindId,0);
    STOREDWORD(pDta->pFFindEntry,0);

    FileUni.Buffer = wcFile;
    FileUni.MaximumLength = sizeof(wcFile);
    DemOemToUni(&FileUni, lpFile);

    IsOnCD = IsCdRomFile(lpFile);

    //
    //  Do volume label first.
    //
    if (SearchAttr & ATTR_VOLUME_ID) {
        if (FillDtaVolume(lpFile, pDta, SearchAttr)) {

            // got vol label match
            // do look ahead before returning
            if (SearchAttr != ATTR_VOLUME_ID) {
                pFFindEntry = SearchFile(wcFile, SearchAttr, NULL, NULL);
                if (pFFindEntry) {
                    pFFindEntry->SearchOnCD = IsOnCD;
                    STOREDWORD(pDta->pFFindEntry,pFFindEntry);
                    STOREDWORD(pDta->FFindId,pFFindEntry->FFindId);
                    }
                }
            return 0;
            }

           // no vol match, if asking for more than vol label
           // fall thru to file search code, otherwise ret error
        else if (SearchAttr == ATTR_VOLUME_ID) {
            return GetLastError();
            }
        }

    //
    // Search the dir
    //
    pFFindEntry = SearchFile(wcFile, SearchAttr, NULL, &FFindDD);

    if (!FFindDD.cFileName[0]) {

        // search.asm in doskrnl never returns ERROR_FILE_NOT_FOUND
        // only ERROR_PATH_NOT_FOUND, ERROR_NO_MORE_FILES
        DWORD dw;

        dw = GetLastError();
        if (dw == ERROR_FILE_NOT_FOUND) {
            SetLastError(ERROR_NO_MORE_FILES);
            }
        else if (dw == ERROR_BAD_PATHNAME || dw == ERROR_DIRECTORY ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            }
        return (DWORD)-1;
        }


    FillSrchDta(&FFindDD, pDta, IsOnCD);

    if (pFFindEntry) {
        pFFindEntry->SearchOnCD = IsOnCD;
        STOREDWORD(pDta->pFFindEntry,pFFindEntry);
        STOREDWORD(pDta->FFindId,pFFindEntry->FFindId);
        }

    return 0;
}


/*
 * DemOemToUni
 *
 * returns TRUE\FALSE for success, sets last error if fail
 *
 */
BOOL DemOemToUni(PUNICODE_STRING pUnicode, LPSTR lpstr)
{
    NTSTATUS   Status;
    OEM_STRING OemString;

    RtlInitString(&OemString,lpstr);
    Status = RtlOemStringToUnicodeString(pUnicode,&OemString,FALSE);
    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_BUFFER_OVERFLOW) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            SetLastError(RtlNtStatusToDosError(Status));
            }
        return FALSE;
        }

    *(PWCHAR)((PUCHAR)pUnicode->Buffer + pUnicode->Length) = UNICODE_NULL;

    return TRUE;
}





/* demFindNext - Path-Style Find Next File
 *
 * Entry -  None
 *
 * Exit  - Success
 *      Client (CF) = 0
 *      DTA updated
 *
 *     Failure
 *      Client (CF) = 1
 *      Client (AX) = Error Code
 */
VOID demFindNext (VOID)
{
    DWORD dwRet;
    PVOID pDta;

    pDta = (PVOID) GetVDMAddr(*((PUSHORT)pulDTALocation + 1),
                              *((PUSHORT)pulDTALocation));

    dwRet = demFileFindNext (pDta);

    if (dwRet != 0) {
        setAX((USHORT) dwRet);
        setCF (1);
        return;
        }

    setCF (0);
    return;

}


DWORD demFileFindNext (
    PVOID pvDta)
{
    PSRCHDTA pDta = (PSRCHDTA)pvDta;
    USHORT   SearchAttr;
    PFFINDLIST   pFFindEntry;
    FFINDDOSDATA FFindDD;
    BOOL    IsOnCD;

    pFFindEntry = GetFFindEntryByFindId(FETCHDWORD(pDta->FFindId));
    if (!pFFindEntry ||
        FETCHDWORD(pDta->pFFindEntry) != (DWORD)pFFindEntry )
      {
        STOREDWORD(pDta->FFindId,0);
        STOREDWORD(pDta->pFFindEntry,0);

        // DOS has only one error (no_more_files) for all causes.
        return(ERROR_NO_MORE_FILES);
        }

#if DBG
    if (fShowSVCMsg & DEMFILIO) {
        sprintf(demDebugBuffer, "demFileFindNext<%ws>\n", pFFindEntry->PathName.Buffer);
        OutputDebugStringOem(demDebugBuffer);
        }
#endif

    SearchAttr = pFFindEntry->usSrchAttr;

    IsOnCD = pFFindEntry->SearchOnCD;
    //
    // Search the dir
    //
    pFFindEntry = SearchFile(NULL,
                             SearchAttr,
                             pFFindEntry,
                             &FFindDD
                             );

    if (!FFindDD.cFileName[0]) {
        STOREDWORD(pDta->FFindId,0);
        STOREDWORD(pDta->pFFindEntry,0);
        return GetLastError();
        }

    FillSrchDta(&FFindDD, pDta, IsOnCD);

    if (!pFFindEntry) {
        STOREDWORD(pDta->FFindId,0);
        STOREDWORD(pDta->pFFindEntry,0);
        }
     return 0;
}



/* demFindFirstFCB - FCB based Find First file
 *
 * Entry -  Client (DS:SI) - SRCHBUF where the information will be returned
 *      Client (ES:DI) - Full path file name with possibly wild cards
 *      Client (Al)    - 0 if not an extended FCB
 *      Client (DL)    - Search Attributes
 *
 * Exit  - Success
 *      Client (CF) = 0
 *      SRCHBUF is filled in
 *
 *     Failure
 *      Client (AL) = -1
 *
 * NOTES
 *    Search Rules: Ignore Read_only and Archive bits.
 *          If DL == ATTR_NORMAL Search only for normal files
 *          If DL == ATTR_HIDDEN Search Hidden or normal files
 *          If DL == ATTR_SYSTEM Search System or normal files
 *          If DL == ATTR_DIRECTORY Search directory or normal files
 *          If DL == ATTR_VOLUME_ID Search only Volume_ID
 *          if DL == -1 return everytiing you find
 */

VOID demFindFirstFCB (VOID)
{
    LPSTR   lpFile;
    USHORT  SearchAttr;
    PSRCHBUF        pFCBSrchBuf;
    PDIRENT         pDirEnt;
    PFFINDLIST      pFFindEntry;
    FFINDDOSDATA    FFindDD;
    UNICODE_STRING  FileUni;
    WCHAR           wcFile[MAX_PATH];
    BOOL            IsOnCD;


    lpFile = (LPSTR) GetVDMAddr (getES(),getDI());

#if DBG
    if (fShowSVCMsg & DEMFILIO) {
        sprintf(demDebugBuffer, "demFindFirstFCB<%s>\n", lpFile);
        OutputDebugStringOem(demDebugBuffer);
        }
#endif

    pFCBSrchBuf = (PSRCHBUF) GetVDMAddr (getDS(),getSI());
    pDirEnt = &pFCBSrchBuf->DirEnt;

    STOREDWORD(pDirEnt->pFFindEntry,0);
    STOREDWORD(pDirEnt->FFindId,0);


    if (getDL() == ATTR_VOLUME_ID) {
        FillFcbVolume(pFCBSrchBuf,lpFile, ATTR_VOLUME_ID);
        return;
        }


    FileUni.Buffer = wcFile;
    FileUni.MaximumLength = sizeof(wcFile);
    if (!DemOemToUni(&FileUni ,lpFile)) {
         setCF(1);
         return;
         }

    SearchAttr = getAL() ? getDL() : 0;
    pFFindEntry = SearchFile(wcFile, SearchAttr, NULL, &FFindDD);
    if (!FFindDD.cFileName[0]){
        demClientError(INVALID_HANDLE_VALUE, *lpFile);
        return;
        }

    IsOnCD = IsCdRomFile(lpFile);
    FillFCBSrchBuf(&FFindDD, pFCBSrchBuf, IsOnCD);

    if (pFFindEntry) {
        pFFindEntry->SearchOnCD = IsOnCD;
        STOREDWORD(pDirEnt->pFFindEntry,pFFindEntry);
        STOREDWORD(pDirEnt->FFindId,pFFindEntry->FFindId);
        }

    setCF(0);
    return;
}



/* demFindNextFCB - FCB based Find Next file
 *
 * Entry -  Client (DS:SI) - SRCHBUF where the information will be returned
 *      Client (Al)    - 0 if not an extended FCB
 *      Client (DL)    - Search Attributes
 *
 * Exit  - Success
 *      Client (CF) = 0
 *      SRCHBUF is filled in
 *
 *     Failure
 *      Client (AL) = -1
 *
 * NOTES
 *    Search Rules: Ignore Read_only and Archive bits.
 *          If DL == ATTR_NORMAL Search only for normal files
 *          If DL == ATTR_HIDDEN Search Hidden or normal files
 *          If DL == ATTR_SYSTEM Search System or normal files
 *          If DL == ATTR_DIRECTORY Search directory or normal files
 *          If DL == ATTR_VOLUME_ID Search only Volume_ID
 */

VOID demFindNextFCB (VOID)
{
    USHORT          SearchAttr;
    PSRCHBUF        pSrchBuf;
    PDIRENT         pDirEnt;
    PFFINDLIST      pFFindEntry;
    FFINDDOSDATA    FFindDD;
    BOOL         IsOnCD;


    pSrchBuf = (PSRCHBUF) GetVDMAddr (getDS(),getSI());
    pDirEnt  = &pSrchBuf->DirEnt;

    pFFindEntry = GetFFindEntryByFindId(FETCHDWORD(pDirEnt->FFindId));
    if (!pFFindEntry ||
        FETCHDWORD(pDirEnt->pFFindEntry) != (DWORD)pFFindEntry ||
        getDL() == ATTR_VOLUME_ID )
      {
        if (pFFindEntry &&
            FETCHDWORD(pDirEnt->pFFindEntry) != (DWORD)pFFindEntry)
          {
            FreeFFindEntry(pFFindEntry);
            }

        STOREDWORD(pDirEnt->pFFindEntry,0);
        STOREDWORD(pDirEnt->FFindId,0);

        // DOS has only one error (no_more_files) for all causes.
        setAX(ERROR_NO_MORE_FILES);
        setCF(1);
        return;
        }

#if DBG
    if (fShowSVCMsg & DEMFILIO) {
        sprintf(demDebugBuffer, "demFindNextFCB<%ws>\n", pFFindEntry->PathName.Buffer);
        OutputDebugStringOem(demDebugBuffer);
        }
#endif

    SearchAttr = getAL() ? getDL() : 0;

    IsOnCD = pFFindEntry->SearchOnCD;
    //
    // Search the dir
    //
    pFFindEntry = SearchFile(NULL,
                             SearchAttr,
                             pFFindEntry,
                             &FFindDD
                             );

    if (!FFindDD.cFileName[0]) {
        STOREDWORD(pDirEnt->pFFindEntry,0);
        STOREDWORD(pDirEnt->FFindId,0);
        setAX((USHORT) GetLastError());
        setCF(1);
        return;
        }

    FillFCBSrchBuf(&FFindDD, pSrchBuf,IsOnCD);

    if (!pFFindEntry) {
        STOREDWORD(pDirEnt->FFindId,0);
        STOREDWORD(pDirEnt->pFFindEntry,0);
        }

    setCF(0);
    return;
}



/* demTerminatePDB - PDB Terminate Notification
 *
 * Entry -  Client (BX) - Terminating PDB
 *
 * Exit  -  None
 *
 */

VOID demTerminatePDB (VOID)
{
    PPSP_FFINDLIST pPspFFindEntry;
    USHORT     PSP;

    PSP = getBX ();

    if(!IsFirstCall) {
        nt_devices_block_or_terminate();
        VDDTerminateUserHook(PSP);
    }
    /* let host knows a process is terminating */

    HostTerminatePDB(PSP);

    pPspFFindEntry = GetPspFFindList(PSP);
    if (!pPspFFindEntry)
         return;

    if (!IsListEmpty(&pPspFFindEntry->FFindHeadList)) {
        FreeFFindList( &pPspFFindEntry->FFindHeadList);
        }

    RemoveEntryList(&pPspFFindEntry->PspFFindEntry);
    free(pPspFFindEntry);

    return;
}


/* SearchFile - Common routine for FIND_FRST and FIND_NEXT
 *
 * Entry -
 * PCHAR  pwcFile              file name to search for
 * USHORT SearchAttr           file attributes to match
 * PFFINDLIST pFFindEntry,     current list entry
 *                             if new search FFindId is expected to be zero
 * PFFINDDOSDATA pFFindDDOut,  filled with the next file in search
 *
 * Exit - if no more files pFFindDDOut is filled with zeros
 *        returns PFFINDLIST if buffered entries exist, else NULL
 */
PFFINDLIST
SearchFile(
    PWCHAR pwcFile,
    USHORT SearchAttr,
    PFFINDLIST pFFindEntry,
    PFFINDDOSDATA pFFindDDOut)
{
    NTSTATUS Status;
    ULONG    BufferSize;
    FFINDLIST  FFindEntry;
    PFFINDLIST pFFEntry = NULL;


    SearchAttr &= ~(ATTR_READ_ONLY | ATTR_ARCHIVE | ATTR_DEVICE);
    Status = STATUS_NO_MORE_FILES;

    if (pFFindDDOut) {
        memset(pFFindDDOut, 0, sizeof(FFINDDOSDATA));
        }

    try {
       if (pFFindEntry) {
           pFFEntry = pFFindEntry;
           Status = pFFindEntry->LastQueryStatus;

           if (pFFindDDOut) {
               *pFFindDDOut = pFFEntry->DosData;
               pFFEntry->DosData.cFileName[0] = '\0';
               }
           else {
               return pFFEntry;
               }

           if (pFFEntry->FindBufferNext || pFFEntry->DirectoryHandle) {
               NTSTATUS st;

               st = FileFindNext(&pFFEntry->DosData,
                                 pFFEntry
                                 );

               if (NT_SUCCESS(st)) {
                   return pFFEntry;
                   }

               if (pFFEntry->DirectoryHandle) {
                   Status = st;
                   }
               }

              //
              // Check Last Known Status before retrying
              //
           if (!NT_SUCCESS(Status)) {
               return NULL;
               }


              //
              // Reopen the FileFind Handle with a large buffer size
              //
           Status = FileFindOpen(NULL,
                                 pFFEntry,
                                 4096
                                 );
           if (!NT_SUCCESS(Status)) {
               return NULL;
               }

              //
              // reset the search to the last known search pos
              //
           Status = FileFindReset(pFFEntry);
           if (!NT_SUCCESS(Status)) {
               return NULL;
               }
           }
       else {
           pFFEntry = &FFindEntry;
           memset(pFFEntry, 0, sizeof(FFINDLIST));
           pFFEntry->SupportReset = TRUE;
           pFFEntry->usSrchAttr = SearchAttr;


           Status = FileFindOpen(pwcFile,
                                 pFFEntry,
                                 1024
                                 );

           if (!NT_SUCCESS(Status)) {
               return NULL;
               }

           //
           // Fill up pFFindDDOut
           //
           if (pFFindDDOut) {
               Status = FileFindNext(pFFindDDOut, pFFEntry);
               if (!NT_SUCCESS(Status)) {
                   return NULL;
                   }
               }
           }

        //
        // Fill up pFFEntry->DosData
        //
        Status = FileFindNext(&pFFEntry->DosData, pFFEntry);
        if (!NT_SUCCESS(Status)) {
            return NULL;
            }


       //
       // if findfirst, fill in the static entries, and add the find entry
       //
       if (!pFFindEntry) {
           pFFEntry->FFindId = NextFFindId++;
           if (NextFFindId == 0xffffffff) {
               NextFFindId = FFINDID_BASE;
               FFindIdWrap = TRUE;
               }

           if (FFindIdWrap) {
               pFFindEntry = GetFFindEntryByFindId(NextFFindId);
               if (pFFindEntry) {
                   FreeFFindEntry(pFFindEntry);
                   pFFindEntry = NULL;
                   }
               }

           pFFEntry = AddFFindEntry(pwcFile, pFFEntry);
           if (!pFFEntry) {
               pFFEntry = &FFindEntry;
               pFFEntry->DosData.cFileName[0] = '\0';
               Status = STATUS_NO_MEMORY;
               return NULL;
               }
           }


       //
       // Try to fill one more entry. If the NtQuery for this search
       // is complete we can set the LastQueryStatus, and close dir handles.
       //
       Status = FileFindLast(pFFEntry);


       }
    finally {

       if (pFFEntry) {

           pFFEntry->LastQueryStatus = Status;

               //
               // if nothing is buffered, cleanup look aheads
               //
           if (!pFFEntry->DosData.cFileName[0] ||
                pFFEntry->DirectoryHandle == FINDFILE_DEVICE)
              {
               if (pFFEntry == &FFindEntry) {
                   FileFindClose(pFFEntry);
                   RtlFreeUnicodeString(&pFFEntry->FileName);
                   RtlFreeUnicodeString(&pFFEntry->PathName);
                   }
               else {
                   FreeFFindEntry(pFFEntry);
                   }
               SetLastError(RtlNtStatusToDosError(Status));
               pFFEntry = NULL;
               }
           }



       if (pFFEntry) {

           if (pFFEntry->DirectoryHandle) {
               if (!pFFindEntry || !NT_SUCCESS(pFFEntry->LastQueryStatus)) {
                   NumDirectoryHandle--;
                   NtClose(pFFEntry->DirectoryHandle);
                   pFFEntry->DirectoryHandle = 0;
                   }
               }

           if (NumFindBuffer > MAX_FINDBUFFER ||
               NumDirectoryHandle > MAX_DIRECTORYHANDLE)
             {
               CloseOldestFileFindBuffer();
               }

           //
           // Set HeartBeat timer to close find buffers, directory handle
           //   Tics  = 8(min) * 60(sec/min) * 18(tic/sec)
           //
           pFFEntry->FindFileTics.QuadPart = 8640 + FindFileTics.QuadPart;
           if (!FindFileTics.QuadPart) {
                NextFindFileTics.QuadPart = pFFEntry->FindFileTics.QuadPart;
                }
           }


       }

     return pFFEntry;
}



NTSTATUS
FileFindOpen(
    PWCHAR pwcFile,
    PFFINDLIST pFFindEntry,
    ULONG BufferSize
    )
{
    NTSTATUS Status;
    BOOLEAN bStatus;
    BOOLEAN bReturnSingleEntry;
    PWCHAR  pwc;
    OBJECT_ATTRIBUTES Obja;
    PUNICODE_STRING FileName;
    PUNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;


    Status = STATUS_SUCCESS;
    PathName = &pFFindEntry->PathName;
    FileName = &pFFindEntry->FileName;

    try {

         if (pFFindEntry->DirectoryHandle == FINDFILE_DEVICE) {
             Status = STATUS_NO_MORE_FILES;
             goto FFOFinallyExit;
             }


         if (BufferSize <=  sizeof(FILE_BOTH_DIR_INFORMATION) +
                            MAXIMUM_FILENAME_LENGTH*sizeof(WCHAR))
           {
             Status = STATUS_BUFFER_TOO_SMALL;
             goto FFOFinallyExit;
             }



         if (pwcFile) {
             bStatus = RtlDosPathNameToNtPathName_U(pwcFile,
                                                    PathName,
                                                    &pwc,
                                                    NULL
                                                    );

             if (!bStatus ) {
                 Status = STATUS_OBJECT_PATH_NOT_FOUND;
                 goto FFOFinallyExit;
                 }

             //
             // Copy out the PathName, FileName
             //
             if (pwc) {
                 bStatus = RtlCreateUnicodeString(FileName,
                                                  pwc
                                                  );
                 if (!bStatus) {
                     Status = STATUS_NO_MEMORY;
                     goto FFOFinallyExit;
                     }

                 PathName->Length = (USHORT)((ULONG)pwc - (ULONG)PathName->Buffer);
                 if (PathName->Buffer[(PathName->Length>>1)-2] != (WCHAR)':' ) {
                     PathName->Length -= sizeof(UNICODE_NULL);
                     }
                 }
             else {
                 FileName->Length = 0;
                 FileName->MaximumLength = 0;
                 }

             bReturnSingleEntry = FALSE;
             }
         else {
             bReturnSingleEntry = pFFindEntry->SupportReset;
             }



         //
         // Prepare Find Buffer for NtQueryDirectory
         //
         if (BufferSize != pFFindEntry->FindBufferLength) {
             if (pFFindEntry->FindBufferBase) {
                 RtlFreeHeap(RtlProcessHeap(), 0, pFFindEntry->FindBufferBase);
                 }
             else {
                 NumFindBuffer++;
                 }

             pFFindEntry->FindBufferBase = RtlAllocateHeap(RtlProcessHeap(),
                                                           0,
                                                           BufferSize
                                                           );
             if (!pFFindEntry->FindBufferBase) {
                 Status = STATUS_NO_MEMORY;
                 goto FFOFinallyExit;
                 }
             }

         pFFindEntry->FindBufferNext = NULL;
         pFFindEntry->FindBufferLength = BufferSize;
         DirectoryInfo = pFFindEntry->FindBufferBase;

         //
         // Open the directory for list access
         //
         if (!pFFindEntry->DirectoryHandle) {

             InitializeObjectAttributes(
                 &Obja,
                 PathName,
                 OBJ_CASE_INSENSITIVE,
                 NULL,
                 NULL
                 );

             Status = NtOpenFile(
                         &pFFindEntry->DirectoryHandle,
                         FILE_LIST_DIRECTORY | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                         );

             if (!NT_SUCCESS(Status)) {

                 if (pwcFile) {
                     pFFindEntry->DirectoryHandle = FileFindFirstDevice(pwcFile,
                                                                        DirectoryInfo
                                                                        );
                     }
                 else {
                     pFFindEntry->DirectoryHandle = NULL;
                     }

                 if (pFFindEntry->DirectoryHandle) {
                     Status = STATUS_SUCCESS;
                     goto FFOFinallyExit;
                     }

                 if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
                     Status == STATUS_OBJECT_TYPE_MISMATCH )
                    {
                     Status = STATUS_OBJECT_PATH_NOT_FOUND;
                     }
                 goto FFOFinallyExit;
                 }

             NumDirectoryHandle++;
             }


         //
         // Prepare the filename for NtQueryDirectory
         //

         if (pwcFile) {
             WCHAR wchCurr, wchPrev;

             int Len = FileName->Length/sizeof(WCHAR);

             //
             // If there is no file part, but we are not looking at a device exit
             //
             if (!Len) {

                 //
                 // At this point, pwcFile has been parsed to PathName and FileName.  If PathName
                 // does not exist, the NtOpen() above will have failed and we will not be here.
                 // PathName is formatted to  \??\c:\xxx\yyy\zzz
                 // DOS had this "feature" that if you looked for something like c:\foobar\, you'd
                 // get PATH_NOT_FOUND, but if you looked for c:\  or  \   you'd get NO_MORE_FILES,
                 // so we special case this here.  If the caller is only looking for  c:\  or   \
                 // PathName will be  \??\c:\   If the caller is looking for ANY other string,
                 // the PathName string will be longer than strlen("\??\c:\") because the text of
                 // any dir will be added to the end.  That's why a simple check of the string len
                 // works at this time.
                 //
                 if ( PathName->Length > (sizeof( L"\\??\\c:\\")-sizeof(WCHAR))  ) {
                     Status = STATUS_OBJECT_PATH_NOT_FOUND;
                 }
                 else {
                     Status = STATUS_NO_MORE_FILES;
                 }

                 goto FFOFinallyExit;
                 }


             //
             //  ntio expects the following transmogrifications:
             //
             //  - Change all ? to DOS_QM
             //  - Change all . followed by ? or * to DOS_DOT
             //  - Change all * followed by a . into DOS_STAR
             //
             //  However, the doskrnl and wow32 have expanded '*'s to '?'s
             //  so the * rules can be ignored.
             //
             pwc = FileName->Buffer;
             wchPrev = 0;
             while (Len--) {
                wchCurr = *pwc;

                if (wchCurr == L'?') {
                    if (wchPrev == L'.') {
                        *(pwc - 1) = DOS_DOT;
                        }

                    *pwc = DOS_QM;
                    }

                wchPrev = wchCurr;
                pwc++;
                }

             }

#if DBG
         if (fShowSVCMsg & DEMFILIO) {
             sprintf(demDebugBuffer,
                     "FFOpen %x %ws (%ws)\n",
                     pFFindEntry->DirectoryHandle,
                     FileName->Buffer,
                     pwcFile
                     );
             OutputDebugStringOem(demDebugBuffer);
             }
#endif


         //
         // Do an initial query to fill the buffers, and verify everything is ok
         //

         Status = DPM_NtQueryDirectoryFile(
                         pFFindEntry->DirectoryHandle,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         DirectoryInfo,
                         BufferSize,
                         FileBothDirectoryInformation,
                         bReturnSingleEntry,
                         FileName,
                         FALSE
                         );

FFOFinallyExit:;

         }
    finally {
         if (!NT_SUCCESS(Status)) {
#if DBG
             if ((fShowSVCMsg & DEMFILIO) && !NT_SUCCESS(Status)) {
                 sprintf(demDebugBuffer, "FFOpen Status %x\n", Status);
                 OutputDebugStringOem(demDebugBuffer);
                 }
#endif

             FileFindClose(pFFindEntry);
             RtlFreeUnicodeString(PathName);
             PathName->Buffer = NULL;
             RtlFreeUnicodeString(FileName);
             FileName->Buffer = NULL;
             }
          else {
             pFFindEntry->FindBufferNext = pFFindEntry->FindBufferBase;
             }
         }

    return Status;
}



/*
 *  Closes a FileFindHandle
 */
VOID
FileFindClose(
    PFFINDLIST pFFindEntry
    )
{
    NTSTATUS Status;
    HANDLE DirectoryHandle;

    DirectoryHandle = pFFindEntry->DirectoryHandle;
    if (DirectoryHandle &&
        DirectoryHandle != FINDFILE_DEVICE)
      {
        NtClose(DirectoryHandle);
        --NumDirectoryHandle;
        }

    pFFindEntry->DirectoryHandle = 0;

    if (pFFindEntry->FindBufferBase) {
        RtlFreeHeap(RtlProcessHeap(), 0, pFFindEntry->FindBufferBase);
        --NumFindBuffer;
        }

    pFFindEntry->FindBufferBase = NULL;
    pFFindEntry->FindBufferNext = NULL;
    pFFindEntry->FindBufferLength = 0;
    pFFindEntry->FindFileTics.QuadPart = 0;

    if (!NumDirectoryHandle && !NumFindBuffer) {
        FindFileTics.QuadPart = 0;
        NextFindFileTics.QuadPart = 0;
        }
}



/*
 *  FileFindReset
 *
 *   Resets search pos according to FileName, FileIndex.
 *   The FindBuffers will point to the next file in the search
 *   order. Assumes that the remembered search pos, has not been
 *   reached yet for the current search.
 *
 */
NTSTATUS
FileFindReset(
   PFFINDLIST pFFindEntry
   )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    UNICODE_STRING LastFileName;
    UNICODE_STRING CurrFileName;
    BOOLEAN bSlowReset;


    if (pFFindEntry->DirectoryHandle == FINDFILE_DEVICE) {
        return STATUS_NO_MORE_FILES;
        }

    Status = STATUS_UNSUCCESSFUL;

    LastFileName.Length = (USHORT)pFFindEntry->DosData.FileNameLength;
    LastFileName.MaximumLength = (USHORT)pFFindEntry->DosData.FileNameLength;
    LastFileName.Buffer = pFFindEntry->DosData.FileName;

    RtlInitUnicodeString(&CurrFileName, L".");
    if (!RtlCompareUnicodeString(&LastFileName, &CurrFileName, TRUE)) {
        bSlowReset = TRUE;
        }
    else {
        RtlInitUnicodeString(&CurrFileName, L"..");
        if (!RtlCompareUnicodeString(&LastFileName, &CurrFileName, TRUE)) {
            bSlowReset = TRUE;
            }
        else {
            bSlowReset = FALSE;
            }
        }

    //
    // if the last file name, wasn't Dots and the volume supports reset
    // functionality call nt file sysetm to do the reset.
    //
    if (!bSlowReset && pFFindEntry->SupportReset) {
        VDMQUERYDIRINFO VdmQueryDirInfo;
        UNICODE_STRING  UnicodeString;

        DirectoryInfo = (PFILE_BOTH_DIR_INFORMATION) pFFindEntry->FindBufferBase;

        VdmQueryDirInfo.FileHandle = pFFindEntry->DirectoryHandle;
        VdmQueryDirInfo.FileInformation = DirectoryInfo;
        VdmQueryDirInfo.Length = pFFindEntry->FindBufferLength;
        VdmQueryDirInfo.FileIndex = pFFindEntry->DosData.FileIndex;

        UnicodeString.Length = (USHORT)pFFindEntry->DosData.FileNameLength;
        UnicodeString.MaximumLength = UnicodeString.Length;
        UnicodeString.Buffer = pFFindEntry->DosData.FileName;
        VdmQueryDirInfo.FileName = &UnicodeString;

        Status = DPM_NtVdmControl(VdmQueryDir, &VdmQueryDirInfo);
        if (NT_SUCCESS(Status) ||
            Status == STATUS_NO_MORE_FILES || Status == STATUS_NO_SUCH_FILE)
           {
            return Status;
            }

        pFFindEntry->SupportReset = FALSE;

        }

   //
   // Reset the slow way by comparing FileName directly.
   //
   // WARNING: if the "remembered" File has been deleted we will
   //          fail, is there something else we can do ?
   //

    Status = STATUS_NO_MORE_FILES;
    while (TRUE) {

       //
       // If there is no data in the find file buffer, call NtQueryDir
       //

       DirectoryInfo = pFFindEntry->FindBufferNext;
       if (!DirectoryInfo) {
            DirectoryInfo = pFFindEntry->FindBufferBase;

            Status = DPM_NtQueryDirectoryFile(
                            pFFindEntry->DirectoryHandle,
                            NULL,                          // no event
                            NULL,                          // no apcRoutine
                            NULL,                          // no apcContext
                            &IoStatusBlock,
                            DirectoryInfo,
                            pFFindEntry->FindBufferLength,
                            FileBothDirectoryInformation,
                            FALSE,                         // single entry
                            NULL,                          // no file name
                            FALSE
                            );

           if (!NT_SUCCESS(Status)) {
#if DBG
               if (fShowSVCMsg & DEMFILIO) {
                   sprintf(demDebugBuffer, "FFReset Status %x\n", Status);
                   OutputDebugStringOem(demDebugBuffer);
                   }
#endif
               return Status;
               }
           }

       if ( DirectoryInfo->NextEntryOffset ) {
           pFFindEntry->FindBufferNext = (PVOID)((ULONG)DirectoryInfo +
                                                DirectoryInfo->NextEntryOffset);
           }
       else {
           pFFindEntry->FindBufferNext = NULL;
           }


       if (DirectoryInfo->FileIndex == pFFindEntry->DosData.FileIndex) {
           CurrFileName.Length = (USHORT)DirectoryInfo->FileNameLength;
           CurrFileName.MaximumLength = (USHORT)DirectoryInfo->FileNameLength;
           CurrFileName.Buffer = DirectoryInfo->FileName;

           if (!RtlCompareUnicodeString(&LastFileName, &CurrFileName, TRUE)) {
               return STATUS_SUCCESS;
               }
           }

       }

    return Status;

}




/*
 * FileFindLast - Attempts to fill the FindFile buffer completely.
 *
 *
 * PFFINDLIST pFFindEntry -
 *
 * Returns - Status of NtQueryDir operation if invoked, otherwise
 *           STATUS_SUCCESS.
 *
 */
NTSTATUS
FileFindLast(
    PFFINDLIST pFFindEntry
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirInfo, LastDirInfo;
    LONG BytesLeft;

    if (pFFindEntry->DirectoryHandle == FINDFILE_DEVICE) {
        return STATUS_NO_MORE_FILES;
        }

    if (pFFindEntry->FindBufferNext) {
        ULONG BytesOffset;

        BytesOffset = (ULONG)pFFindEntry->FindBufferNext -
                      (ULONG)pFFindEntry->FindBufferBase;

        if (BytesOffset) {
            RtlMoveMemory(pFFindEntry->FindBufferBase,
                          pFFindEntry->FindBufferNext,
                          pFFindEntry->FindBufferLength - BytesOffset
                          );
            }

        pFFindEntry->FindBufferNext = pFFindEntry->FindBufferBase;
        DirInfo = pFFindEntry->FindBufferBase;

        while (DirInfo->NextEntryOffset) {
            DirInfo = (PVOID)((ULONG)DirInfo + DirInfo->NextEntryOffset);
            }
        LastDirInfo = DirInfo;

        DirInfo = (PVOID)&DirInfo->FileName[DirInfo->FileNameLength>>1];

        DirInfo = (PVOID) (((ULONG) DirInfo + sizeof(LONGLONG) - 1) &
            ~(sizeof(LONGLONG) - 1));

        BytesLeft = pFFindEntry->FindBufferLength -
                     ((ULONG)DirInfo - (ULONG)pFFindEntry->FindBufferBase);
        }
    else {
        DirInfo = pFFindEntry->FindBufferBase;
        LastDirInfo = NULL;
        BytesLeft = pFFindEntry->FindBufferLength;
        }


    // the size of the dirinfo structure including the name must be a longlong.
    while (BytesLeft > sizeof(FILE_BOTH_DIR_INFORMATION) + sizeof(LONGLONG) + MAXIMUM_FILENAME_LENGTH*sizeof(WCHAR)) {


       Status = DPM_NtQueryDirectoryFile(
                       pFFindEntry->DirectoryHandle,
                       NULL,                          // no event
                       NULL,                          // no apcRoutine
                       NULL,                          // no apcContext
                       &IoStatusBlock,
                       DirInfo,
                       BytesLeft,
                       FileBothDirectoryInformation,
                       FALSE,                          // single entry ?
                       NULL,                          // no file name
                       FALSE
                       );

       if (Status == STATUS_NO_MORE_FILES || Status == STATUS_NO_SUCH_FILE) {
#if DBG
           if ((fShowSVCMsg & DEMFILIO)) {
               sprintf(demDebugBuffer, "FFLast Status %x\n", Status);
               OutputDebugStringOem(demDebugBuffer);
               }
#endif
           return Status;
           }


       if (!NT_SUCCESS(Status)) {
           break;
           }

       if (LastDirInfo) {
           LastDirInfo->NextEntryOffset =(ULONG)DirInfo - (ULONG)LastDirInfo;
           }
       else {
           pFFindEntry->FindBufferNext = pFFindEntry->FindBufferBase;
           }

       while (DirInfo->NextEntryOffset) {
           DirInfo = (PVOID)((ULONG)DirInfo + DirInfo->NextEntryOffset);
           }
       LastDirInfo = DirInfo;
       DirInfo = (PVOID)&DirInfo->FileName[DirInfo->FileNameLength>>1];

        DirInfo = (PVOID) (((ULONG) DirInfo + sizeof(LONGLONG) - 1) &
            ~(sizeof(LONGLONG) - 1));

       BytesLeft = pFFindEntry->FindBufferLength -
                    ((ULONG)DirInfo - (ULONG)pFFindEntry->FindBufferBase);
       }

   return STATUS_SUCCESS;
}






/*
 * FileFindNext - retrieves the next file in the current search order,
 *
 * PFFINDDOSDATA pFFindDD
 *    Receives File info returned by the nt FileSystem
 *
 * PFFINDLIST pFFindEntry -
 *    Contains the DirectoryInfo (FileName,FileIndex) necessary to reset a
 *    search pos. For operations other than QDIR_RESET_SCAN, this is ignored.
 *
 * Returns -
 *    If Got a DirectoryInformation Entry, STATUS_SUCCESS
 *    If no Open Directory handle and is unknown if there are more files
 *    returns STATUS_IN`VALID_HANDLE
 *
 */
NTSTATUS
FileFindNext(
    PFFINDDOSDATA pFFindDD,
    PFFINDLIST pFFindEntry
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;

    if (pFFindEntry->DirectoryHandle == FINDFILE_DEVICE) {
        return STATUS_NO_MORE_FILES;
        }

    Status = STATUS_UNSUCCESSFUL;

    do {

       //
       // If there is no data in the find file buffer, call NtQueryDir
       //

       DirectoryInfo = pFFindEntry->FindBufferNext;
       if (!DirectoryInfo) {
           if (!pFFindEntry->DirectoryHandle) {
               return STATUS_INVALID_HANDLE;
               }

           DirectoryInfo = pFFindEntry->FindBufferBase;

           Status = DPM_NtQueryDirectoryFile(
                            pFFindEntry->DirectoryHandle,
                            NULL,                          // no event
                            NULL,                          // no apcRoutine
                            NULL,                          // no apcContext
                            &IoStatusBlock,
                            DirectoryInfo,
                            pFFindEntry->FindBufferLength,
                            FileBothDirectoryInformation,
                            FALSE,                         // single entry ?
                            NULL,                          // no file name
                            FALSE
                            );

           if (!NT_SUCCESS(Status)) {
#if DBG
               if (fShowSVCMsg & DEMFILIO) {
                   sprintf(demDebugBuffer, "FFNext Status %x\n", Status);
                   OutputDebugStringOem(demDebugBuffer);
                   }
#endif
               return Status;
               }
           }


       if ( DirectoryInfo->NextEntryOffset ) {
           pFFindEntry->FindBufferNext = (PVOID)((ULONG)DirectoryInfo +
                                                DirectoryInfo->NextEntryOffset);
           }
       else {
           pFFindEntry->FindBufferNext = NULL;
           }

       } while (!CopyDirInfoToDosData(pFFindDD,
                                      DirectoryInfo,
                                      pFFindEntry->usSrchAttr
                                      ));

    return STATUS_SUCCESS;
}



/*
 *  CopyDirInfoToDosData
 *
 */
BOOL
CopyDirInfoToDosData(
    PFFINDDOSDATA pFFindDD,
    PFILE_BOTH_DIR_INFORMATION DirInfo,
    USHORT SearchAttr
    )
{
    NTSTATUS Status;
    OEM_STRING OemString;
    UNICODE_STRING UnicodeString;
    DWORD   dwAttr;
    BOOLEAN SpacesInName = FALSE;
    BOOLEAN NameValid8Dot3;

    //
    // match the attributes
    // See DOS5.0 sources (dir2.asm, MatchAttributes)
    // ignores READONLY and ARCHIVE bits
    //
    if (FILE_ATTRIBUTE_NORMAL == DirInfo->FileAttributes) {
        DirInfo->FileAttributes = 0;
        }
    else {
        DirInfo->FileAttributes &= DOS_ATTR_MASK;
        }


    dwAttr = DirInfo->FileAttributes;
    dwAttr &= ~(FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_READONLY);
    if (((~(ULONG)SearchAttr) & dwAttr) & ATTR_ALL)
        return FALSE;


    //
    // set up the destination oem string buffer
    //
    OemString.Buffer        = pFFindDD->cFileName;
    OemString.MaximumLength = 14;

    //
    // see if the name is legal fat
    //

    UnicodeString.Buffer = DirInfo->FileName;
    UnicodeString.Length = (USHORT)DirInfo->FileNameLength;
    UnicodeString.MaximumLength = (USHORT)DirInfo->FileNameLength;

    NameValid8Dot3 = RtlIsNameLegalDOS8Dot3( &UnicodeString,
                                             &OemString,
                                             &SpacesInName );

    //
    // if failed (incompatible codepage or illegal FAT name),
    //    use the short name
    //
    if (!NameValid8Dot3 ||
        (SpacesInName && (DirInfo->ShortName[0] != UNICODE_NULL))) {

        if (DirInfo->ShortName[0] == UNICODE_NULL) {
            pFFindDD->cFileName[0] = '\0';
            return FALSE;
            }

        UnicodeString.Buffer = DirInfo->ShortName;
        UnicodeString.Length = (USHORT)DirInfo->ShortNameLength;
        UnicodeString.MaximumLength = (USHORT)DirInfo->ShortNameLength;

        if (!NT_SUCCESS(RtlUpcaseUnicodeStringToCountedOemString(&OemString, &UnicodeString, FALSE))) {
            pFFindDD->cFileName[0] = '\0';
            return FALSE;
            }
        }

    OemString.Buffer[OemString.Length] = '\0';

    // fill in time, size and attributes

    //
    // bjm-11/10/97 - for directories, FAT does not update lastwritten time
    // when things actually happen in the directory.  NTFS does.  This causes
    // a problem for Encore 3.0 (when running on NTFS) which, at install time,
    // gets the lastwritten time for it's directory, then compares it, at app
    // run time, to the "current" last written time and will bail (with a "Not
    // correctly installed" message) if they're different.  So, 16 bit apps
    // (which can only reasonably expect FAT info), should only get creation
    // time for this file if it's a directory.
    //
    // VadimB: 11/20/98 -- this hold true ONLY for apps running on NTFS and
    // not FAT -- since older FAT partitions are then given an incorrect
    // creation time

    if (FILE_ATTRIBUTE_DIRECTORY & DirInfo->FileAttributes)  {
        pFFindDD->ftLastWriteTime   = *(LPFILETIME)&DirInfo->CreationTime;
    }
    else {
        pFFindDD->ftLastWriteTime   = *(LPFILETIME)&DirInfo->LastWriteTime;
    }
    pFFindDD->dwFileSizeLow     = DirInfo->EndOfFile.LowPart;
    pFFindDD->uchFileAttributes = (UCHAR)DirInfo->FileAttributes;

    // Save File Name, Index for restarting searches
    pFFindDD->FileIndex = DirInfo->FileIndex;
    pFFindDD->FileNameLength = DirInfo->FileNameLength;

    RtlCopyMemory(pFFindDD->FileName,
                  DirInfo->FileName,
                  DirInfo->FileNameLength
                  );

    pFFindDD->FileName[DirInfo->FileNameLength >> 1] = UNICODE_NULL;

    return TRUE;
}




HANDLE
FileFindFirstDevice(
    PWCHAR FileName,
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo
    )

/*++

Routine Description:

    Determines if the FileName is a device, and copies out the
    device name found if it is.

Arguments:

    FileName - Supplies the device name of the file to find.

    pQueryDirInfo - On a successful find, this parameter returns information
                    about the located file.

Return Value:


--*/

{
    ULONG DeviceNameData;
    PWSTR DeviceName;

    DeviceNameData = RtlIsDosDeviceName_U(FileName);
    if (DeviceNameData) {
        RtlZeroMemory(DirectoryInfo, sizeof(FILE_BOTH_DIR_INFORMATION));

        DirectoryInfo->FileAttributes = FILE_ATTRIBUTE_ARCHIVE;
        DeviceName = (PWSTR)((ULONG)FileName + (DeviceNameData >> 16));

        DeviceNameData &= 0xffff;

        DirectoryInfo->FileNameLength = DeviceNameData;
        DirectoryInfo->ShortNameLength = (CCHAR)DeviceNameData;


        RtlCopyMemory(DirectoryInfo->FileName,
                      DeviceName,
                      DeviceNameData
                      );

        RtlCopyMemory(DirectoryInfo->ShortName,
                      DeviceName,
                      DeviceNameData
                      );

        return FINDFILE_DEVICE;
        }

    return NULL;
}




/* FillFcbVolume - fill Volume info in the FCB
 *
 * Entry -  pSrchBuf    FCB Search buffer to be filled in
 *          FileName  File Name (interesting part is the drive letter)
 *
 * Exit -  SUCCESS
 *      Client (CF) - 0
 *      pSrchBuf is filled with volume info
 *
 *     FAILURE
 *      Client (CF) - 1
 *      Client (AX) = Error Code
 */
VOID
FillFcbVolume(
     PSRCHBUF pSrchBuf,
     CHAR *pFileName,
     USHORT SearchAttr
     )
{
    CHAR    *pch;
    PDIRENT pDirEnt = &pSrchBuf->DirEnt;
    CHAR    FullPathBuffer[MAX_PATH];
    CHAR    achBaseName[DOS_VOLUME_NAME_SIZE + 2];  // 11 chars, '.', and null
    CHAR    achVolumeName[NT_VOLUME_NAME_SIZE];

    //
    // form a path without base name
    // this makes sure only on root directory will get the
    // volume label(the GetVolumeInformationOem will fail
    // if the given path is not root directory)
    //

    strncpy(FullPathBuffer,pFileName,MAX_PATH);
    FullPathBuffer[MAX_PATH-1] = 0;

    pch = strrchr(FullPathBuffer, '\\');
    if (pch)  {
        pch++;
        // truncate to dos file name length (including period)
        pch[DOS_VOLUME_NAME_SIZE + 1] = '\0';
        strcpy(achBaseName, pch);
#ifdef DBCS
        CharUpper(achBaseName);
#else // !DBCS
        _strupr(achBaseName);
#endif // !DBCS
        *pch = '\0';
        }
    else {
        achBaseName[0] = '\0';
        }


    //
    // if searching for volume only the DOS uses first 3 letters for
    // root drive path ignoring the rest of the path
    // as long as the full pathname is valid.
    //
    if (SearchAttr == ATTR_VOLUME_ID &&
        (pch = strchr(FullPathBuffer, '\\')) &&
        DPM_GetFileAttributes(FullPathBuffer) != 0xffffffff )
      {
        pch++;
        *pch = '\0';
        strcpy(achBaseName, szStartDotStar);
        }


    if (GetVolumeInformationOem(FullPathBuffer,
                                achVolumeName,
                                NT_VOLUME_NAME_SIZE,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                0) == FALSE)
       {

        demClientError(INVALID_HANDLE_VALUE, *pFileName);
        return;
        }

    // truncate to dos volumen max size (no period)
    achVolumeName[DOS_VOLUME_NAME_SIZE] = '\0';

    if (!achVolumeName[0] || !MatchVolLabel(achVolumeName, achBaseName)) {
        SetLastError(ERROR_NO_MORE_FILES);
        demClientError(INVALID_HANDLE_VALUE, *pFileName);
        return;
        }

    // warning !!! this assumes the FileExt follows FileName immediately
    memset(pSrchBuf->FileName, ' ', DOS_VOLUME_NAME_SIZE);
    strncpy(pSrchBuf->FileName, achVolumeName, strlen(achVolumeName));

    // Now copy the directory entry
    strncpy(pDirEnt->FileName,pSrchBuf->FileName,8);
    strncpy(pDirEnt->FileExt,pSrchBuf->FileExt,3);
    setCF (0);
    return;
}


/* FillDtaVolume - fill Volume info in the DTA
 *
 * Entry - CHAR lpSearchName - name to match with volume name
 *
 *
 * Exit -  SUCCESS
 *      Returns - TRUE
 *      pSrchBuf is filled with volume info
 *
 *     FAILURE
 *      Returns - FALSE
 *      sets last error code
 */

BOOL FillDtaVolume(
     CHAR *pFileName,
     PSRCHDTA  pDta,
     USHORT SearchAttr
     )
{
    CHAR    *pch;
    CHAR    FullPathBuffer[MAX_PATH];
    CHAR    achBaseName[DOS_VOLUME_NAME_SIZE + 2];  // 11 chars, '.' and null
    CHAR    achVolumeName[NT_VOLUME_NAME_SIZE];

    //
    // form a path without base name
    // this makes sure only on root directory will get the
    // volume label(the GetVolumeInformationOem will fail
    // if the given path is not root directory)
    //

    strncpy(FullPathBuffer, pFileName,MAX_PATH);
    FullPathBuffer[MAX_PATH-1] = 0;

    pch = strrchr(FullPathBuffer, '\\');
    if (pch)  {
        pch++;
        pch[DOS_VOLUME_NAME_SIZE + 1] = '\0'; // max len (including period)
        strcpy(achBaseName, pch);
#ifdef DBCS
        CharUpper(achBaseName);
#else // !DBCS
        _strupr(achBaseName);
#endif // !DBCS
        *pch = '\0';
        }
    else {
        achBaseName[0] = '\0';
        }


    //
    // if searching for volume only the DOS uses first 3 letters for
    // root drive path ignoring the rest of the path, if there is no basename assume *.*
    //
    if (SearchAttr == ATTR_VOLUME_ID &&
        (pch = strchr(FullPathBuffer, '\\')) &&
        DPM_GetFileAttributes(FullPathBuffer) != 0xffffffff )
      {
        pch++;
        if(!*pch) {
          strcpy(achBaseName, szStartDotStar);
          }                
        *pch = '\0';

      }

    if (GetVolumeInformationOem(FullPathBuffer,
                                achVolumeName,
                                NT_VOLUME_NAME_SIZE,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                0) == FALSE)
       {
        return FALSE;
        }

    // truncate to dos file name length (no period)
    achVolumeName[DOS_VOLUME_NAME_SIZE] = '\0';

    if  (!achVolumeName[0] || !MatchVolLabel(achVolumeName, achBaseName)) {
        SetLastError(ERROR_NO_MORE_FILES);
        return FALSE;
        }

    //
    // DOS Dta search returns volume label in 8.3 format. But if label is
    // more than 8 characters long than NT just returns that as it is
    // without adding a ".". So here we have to add a "." in volume
    // labels, if needed. But note that FCB based volume search does'nt
    // add the "." So nothing need to be done there.
    //
    NtVolumeNameToDosVolumeName(pDta->achFileName, achVolumeName);
    pDta->uchFileAttr =  ATTR_VOLUME_ID;
    STOREWORD(pDta->usLowSize,0);
    STOREWORD(pDta->usHighSize,0);

    // Zero out dates as we can not fetch dates for volume labels.
    STOREWORD(pDta->usTimeLastWrite,0);
    STOREWORD(pDta->usDateLastWrite,0);

    return TRUE;
}



/*
 *  MatchVolLabel
 *  Does a string compare to see if the vol label matches
 *  a FAT search string. The search string is expected to
 *  have the '*' character already expanded into '?' characters.
 *
 *  WARNING: maintanes dos5.0 quirk of not caring about characters past
 *  the defined len of each part of the vol label.
 *  12345678.123
 *  ^       ^
 *
 *        foovol      foovol1  (srch string)
 *        foo.vol     foo.vol1 (srch string)
 *
 *  entry: CHAR *pVol   -- NT volume name
 *     CHAR *pSrch  -- dos volume name
 *
 *  exit: TRUE for a match
 */
BOOL MatchVolLabel(CHAR *pVol, CHAR *pSrch )
{
    WORD w;
    CHAR  achDosVolumeName[DOS_VOLUME_NAME_SIZE + 2]; // 11 chars, '.' and null

    NtVolumeNameToDosVolumeName(achDosVolumeName, pVol);
    pVol = achDosVolumeName;

    w = 8;
    while (w--) {
        if (*pVol == *pSrch)  {
            if (!*pVol && !*pSrch)
                return TRUE;
            }
        else if (*pSrch == '.') {
            if (*pVol)
                return FALSE;
            }
        else if (*pSrch != '?') {
            return FALSE;
            }

           // move on to the next character
           // but not past second component part
        if (*pVol && *pVol != '.')
            pVol++;
        if (*pSrch && *pSrch != '.')
            pSrch++;
        }

      // skip trailing part of search string, in the first comp
    while (*pSrch && *pSrch != '.')
         pSrch++;


    w = 4;
    while (w--) {
        if (*pVol == *pSrch)  {
            if (!*pVol && !*pSrch)
                return TRUE;
            }
        else if (*pSrch == '.') {
            if (*pVol)
                return FALSE;
            }
        else if (*pSrch != '?') {
            return FALSE;
            }

           // move on to the next character
        if (*pVol)
            pVol++;
        if (*pSrch)
            pSrch++;
        }

     return TRUE;
}


VOID NtVolumeNameToDosVolumeName(CHAR * pDosName, CHAR * pNtName)
{

    char    NtNameBuffer[NT_VOLUME_NAME_SIZE];
    int     i;
    char    char8, char9, char10;

    // make a local copy so that the caller can use the same
    // buffer

    strncpy(NtNameBuffer, pNtName, NT_VOLUME_NAME_SIZE);
    NtNameBuffer[NT_VOLUME_NAME_SIZE-1] = 0;

    if (strlen(NtNameBuffer) > 8) {
    char8 = NtNameBuffer[8];
    char9 = NtNameBuffer[9];
    char10 = NtNameBuffer[10];
        // eat spaces from first 8 characters
        i = 7;
    while (NtNameBuffer[i] == ' ')
            i--;
    NtNameBuffer[i+1] = '.';
    NtNameBuffer[i+2] = char8;
    NtNameBuffer[i+3] = char9;
    NtNameBuffer[i+4] = char10;
    NtNameBuffer[i+5] = '\0';
    }
    strcpy(pDosName, NtNameBuffer);
}





/* FillFCBSrchBuf - Fill the FCB Search buffer.
 *
 * Entry -  pSrchBuf FCB Search buffer to be filled in
 *      hFind Search Handle
 *      fFirst TRUE if call from FindFirstFCB
 *
 * Exit  - None (pSrchBuf filled in)
 *
 */

VOID FillFCBSrchBuf(
     PFFINDDOSDATA pFFindDD,
     PSRCHBUF pSrchBuf,
     BOOL IsOnCD)
{
    PDIRENT     pDirEnt = &pSrchBuf->DirEnt;
    PCHAR       pDot;
    USHORT      usDate,usTime,i;
    FILETIME    ftLocal;

#if DBG
    if (fShowSVCMsg & DEMFILIO) {
        sprintf(demDebugBuffer, "FillFCBSrchBuf<%s>\n", pFFindDD->cFileName);
        OutputDebugStringOem(demDebugBuffer);
        }
#endif

    // Copy file name (Max Name = 8 and Max ext = 3)
    if ((pDot = strchr(pFFindDD->cFileName,'.')) == NULL) {
        strncpy(pSrchBuf->FileName,pFFindDD->cFileName,8);
        _strnset(pSrchBuf->FileExt,'\x020',3);
        }
    else if (pDot == pFFindDD->cFileName) {
        strncpy(pSrchBuf->FileName,pFFindDD->cFileName,8);
        _strnset(pSrchBuf->FileExt,'\x020',3);
        }
    else {
        *pDot = '\0';
        strncpy(pSrchBuf->FileName,pFFindDD->cFileName,8);
        *pDot++ = '\0';
        strncpy(pSrchBuf->FileExt,pDot,3);
        }


    for (i=0;i<8;i++) {
      if (pSrchBuf->FileName[i] == '\0')
          pSrchBuf->FileName[i]='\x020';
      }

    for (i=0;i<3;i++) {
      if (pSrchBuf->FileExt[i] == '\0')
          pSrchBuf->FileExt[i]='\x020';
      }

    STOREWORD(pSrchBuf->usCurBlkNumber,0);
    STOREWORD(pSrchBuf->usRecordSize,0);
    STOREDWORD(pSrchBuf->ulFileSize, pFFindDD->dwFileSizeLow);

    // Convert NT File time/date to DOS time/date
    FileTimeToLocalFileTime (&pFFindDD->ftLastWriteTime,&ftLocal);
    FileTimeToDosDateTime (&ftLocal,
                           &usDate,
                           &usTime);

    // Now copy the directory entry
    strncpy(pDirEnt->FileName,pSrchBuf->FileName,8);
    strncpy(pDirEnt->FileExt,pSrchBuf->FileExt,3);

    // SudeepB - 28-Jul-1997
    //
    // For CDFS, Win3.1/DOS/Win95, only return FILE_ATTRIBUTE_DIRECTORY (10)
    // for directories while WinNT returns
    // FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY (11).
    // Some VB controls that app setups use, depend on getting
    // FILE_ATTRIBUTE_DIRECTORY (10) only or otherwise are broken.
    // An example of this is Cliffs StudyWare series.
    //

    if (IsOnCD && pFFindDD->uchFileAttributes == (ATTR_DIRECTORY | ATTR_READ_ONLY))
        pDirEnt->uchAttributes = ATTR_DIRECTORY;
    else
        pDirEnt->uchAttributes  = pFFindDD->uchFileAttributes;

    STOREWORD(pDirEnt->usTime,usTime);
    STOREWORD(pDirEnt->usDate,usDate);
    STOREDWORD(pDirEnt->ulFileSize,pFFindDD->dwFileSizeLow);

    return;
}



/* FillSrchDta - Fill DTA for FIND_FIRST,FIND_NEXT operations.
 *
 * Entry - pW32FindData Buffer containing file data
 *         hFind - Handle returned by FindFirstFile
 *         PSRCHDTA pDta
 *
 * Exit  - None
 *
 * Note : It is guranteed that file name adhers to 8:3 convention.
 *    demSrchFile makes sure of that condition.
 *
 */
VOID
FillSrchDta(
     PFFINDDOSDATA pFFindDD,
     PSRCHDTA pDta,
     BOOL IsOnCD)
{
    USHORT   usDate,usTime;
    FILETIME ftLocal;

    // SudeepB - 28-Jul-1997
    //
    // For CDFS, Win3.1/DOS/Win95, only return FILE_ATTRIBUTE_DIRECTORY (10)
    // for directories while WinNT returns
    // FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY (11).
    // Some VB controls that app setups use, depend on getting
    // FILE_ATTRIBUTE_DIRECTORY (10) only or otherwise are broken.
    // An example of this is Cliffs StudyWare series.
    //
    if (IsOnCD && pFFindDD->uchFileAttributes == (ATTR_DIRECTORY | ATTR_READ_ONLY))
        pDta->uchFileAttr = ATTR_DIRECTORY;
    else
        pDta->uchFileAttr = pFFindDD->uchFileAttributes;

    // Convert NT File time/date to DOS time/date
    FileTimeToLocalFileTime (&pFFindDD->ftLastWriteTime,&ftLocal);
    FileTimeToDosDateTime (&ftLocal,
                           &usDate,
                           &usTime);

    STOREWORD(pDta->usTimeLastWrite,usTime);
    STOREWORD(pDta->usDateLastWrite,usDate);
    STOREWORD(pDta->usLowSize,(USHORT)pFFindDD->dwFileSizeLow);
    STOREWORD(pDta->usHighSize,(USHORT)(pFFindDD->dwFileSizeLow >> 16));

#if DBG
    if (fShowSVCMsg & DEMFILIO) {
        sprintf(demDebugBuffer, "FillSrchDta<%s>\n", pFFindDD->cFileName);
        OutputDebugStringOem(demDebugBuffer);
        }
#endif

    strncpy(pDta->achFileName,pFFindDD->cFileName, 13);

    pDta->achFileName[12] = '\0';
    return;
}





VOID demCloseAllPSPRecords (VOID)
{
   PLIST_ENTRY Next;
   PPSP_FFINDLIST pPspFFindEntry;

   Next = PspFFindHeadList.Flink;
   while (Next != &PspFFindHeadList) {
       pPspFFindEntry = CONTAINING_RECORD(Next,PSP_FFINDLIST,PspFFindEntry);
       FreeFFindList( &pPspFFindEntry->FFindHeadList);
       Next= Next->Flink;
       RemoveEntryList(&pPspFFindEntry->PspFFindEntry);
       free(pPspFFindEntry);
       }
}


void
DemHeartBeat(void)
{

   PLIST_ENTRY    Next;
   PLIST_ENTRY    pFFindHeadList;
   PPSP_FFINDLIST pPspFFindEntry;
   PFFINDLIST  pFFindEntry;

   if (!NumFindBuffer ||
       NextFindFileTics.QuadPart > ++FindFileTics.QuadPart)
     {
       return;
       }

   pPspFFindEntry = GetPspFFindList(FETCHWORD(pusCurrentPDB[0]));
   if (!pPspFFindEntry) {
       return;
       }
   pFFindHeadList = &pPspFFindEntry->FFindHeadList;
   Next = pFFindHeadList->Blink;
   while (Next != pFFindHeadList) {
        pFFindEntry = CONTAINING_RECORD(Next,FFINDLIST, FFindEntry);

        if (pFFindEntry->FindFileTics.QuadPart) {
            if (pFFindEntry->FindFileTics.QuadPart <= FindFileTics.QuadPart) {
                FileFindClose(pFFindEntry);
                }
            else {
                NextFindFileTics.QuadPart = pFFindEntry->FindFileTics.QuadPart;
                return;
                }
            }

        Next = Next->Blink;
        }

   NextFindFileTics.QuadPart = 0;
   FindFileTics.QuadPart = 0;
}





//
// CloseOldestFileFindBuffer
// walks the psp file find list backwards to find the oldest
// entry with FindBuffers, directory handles and closes it.
//
void
CloseOldestFileFindBuffer(
   void
   )
{
   PLIST_ENTRY    Next, NextPsp;
   PLIST_ENTRY    pFFindHeadList;
   PPSP_FFINDLIST pPspFFindEntry;
   PFFINDLIST     pFFEntry;

   NextPsp = PspFFindHeadList.Blink;
   while (NextPsp != &PspFFindHeadList) {
       pPspFFindEntry = CONTAINING_RECORD(NextPsp,PSP_FFINDLIST,PspFFindEntry);

       pFFindHeadList = &pPspFFindEntry->FFindHeadList;
       Next = pFFindHeadList->Blink;
       while (Next != pFFindHeadList) {
            pFFEntry = CONTAINING_RECORD(Next,FFINDLIST, FFindEntry);
            if (NumFindBuffer >= MAX_FINDBUFFER) {
                FileFindClose(pFFEntry);
                }
            else if (pFFEntry->DirectoryHandle &&
                     NumDirectoryHandle >= MAX_DIRECTORYHANDLE)
               {
                NumDirectoryHandle--;
                NtClose(pFFEntry->DirectoryHandle);
                pFFEntry->DirectoryHandle = 0;
                }

            if (NumFindBuffer < MAX_FINDBUFFER &&
                NumDirectoryHandle < MAX_DIRECTORYHANDLE)
               {
                return;
                }
            Next = Next->Blink;
            }

       NextPsp= NextPsp->Blink;
       }
}





/*
 * GetFFindEntryByFindId
 */
PFFINDLIST GetFFindEntryByFindId(ULONG NextFFindId)
{
   PLIST_ENTRY NextPsp;
   PLIST_ENTRY Next;
   PPSP_FFINDLIST pPspFFindEntry;
   PFFINDLIST     pFFindEntry;
   PLIST_ENTRY    pFFindHeadList;

   NextPsp = PspFFindHeadList.Flink;
   while (NextPsp != &PspFFindHeadList) {
       pPspFFindEntry = CONTAINING_RECORD(NextPsp,PSP_FFINDLIST,PspFFindEntry);

       pFFindHeadList = &pPspFFindEntry->FFindHeadList;
       Next = pFFindHeadList->Flink;
       while (Next != pFFindHeadList) {
            pFFindEntry = CONTAINING_RECORD(Next, FFINDLIST, FFindEntry);
            if (pFFindEntry->FFindId == NextFFindId) {
                return pFFindEntry;
                }
            Next= Next->Flink;
            }

       NextPsp= NextPsp->Flink;
       }

   return NULL;
}



/* AddFFindEntry - Adds a new File Find entry to the current
 *                    PSP's PspFileFindList
 *
 * Entry -
 *
 * Exit  -  PFFINDLIST  pFFindList;
 */
PFFINDLIST
AddFFindEntry(
        PWCHAR pwcFile,
        PFFINDLIST pFFindEntrySrc
        )

{
    PPSP_FFINDLIST pPspFFindEntry;
    PFFINDLIST     pFFindEntry;
    ULONG          Len;

    pPspFFindEntry = GetPspFFindList(FETCHWORD(pusCurrentPDB[0]));

        //
        // if a Psp entry doesn't exist
        //    Allocate one, initialize it and insert it into the list
        //
    if (!pPspFFindEntry) {
        pPspFFindEntry = (PPSP_FFINDLIST) malloc(sizeof(PSP_FFINDLIST));
        if (!pPspFFindEntry)
            return NULL;

        pPspFFindEntry->usPsp = FETCHWORD(pusCurrentPDB[0]);
        InitializeListHead(&pPspFFindEntry->FFindHeadList);
        InsertHeadList(&PspFFindHeadList, &pPspFFindEntry->PspFFindEntry);
        }

    //
    // Create the FileFindEntry and add to the FileFind list
    //
    pFFindEntry = (PFFINDLIST) malloc(sizeof(FFINDLIST));
    if (!pFFindEntry) {
        return pFFindEntry;
        }

    //
    // Fill in FFindList
    //
    *pFFindEntry = *pFFindEntrySrc;

    //
    //  Insert at  the head of this psp list
    //
    InsertHeadList(&pPspFFindEntry->FFindHeadList, &pFFindEntry->FFindEntry);

    return pFFindEntry;
}





/* FreeFFindEntry
 *
 * Entry -  PFFINDLIST pFFindEntry
 *
 * Exit  -  None
 *
 */
VOID FreeFFindEntry(PFFINDLIST pFFindEntry)
{
    RemoveEntryList(&pFFindEntry->FFindEntry);
    FileFindClose(pFFindEntry);
    RtlFreeUnicodeString(&pFFindEntry->FileName);
    RtlFreeUnicodeString(&pFFindEntry->PathName);
    free(pFFindEntry);
    return;
}



/* FreeFFindList
 *
 * Entry -  Frees the entire list
 *
 * Exit  -  None
 *
 */
VOID FreeFFindList(PLIST_ENTRY pFFindHeadList)
{
    PLIST_ENTRY  Next;
    PFFINDLIST  pFFindEntry;

    Next = pFFindHeadList->Flink;
    while (Next != pFFindHeadList) {
         pFFindEntry = CONTAINING_RECORD(Next,FFINDLIST, FFindEntry);
         Next= Next->Flink;
         FreeFFindEntry(pFFindEntry);
         }

    return;
}


/* GetPspFFindList
 *
 * Entry -  USHORT CurrPsp
 *
 * Exit  -  Success - PPSP_FFINDLIST
 *      Failure - NULL
 *
 */
PPSP_FFINDLIST GetPspFFindList(USHORT CurrPsp)
{
   PLIST_ENTRY    Next;
   PPSP_FFINDLIST pPspFFindEntry;

   Next = PspFFindHeadList.Flink;
   while (Next != &PspFFindHeadList) {
       pPspFFindEntry = CONTAINING_RECORD(Next,PSP_FFINDLIST,PspFFindEntry);
       if (CurrPsp == pPspFFindEntry->usPsp) {
           return pPspFFindEntry;
           }
       Next= Next->Flink;
       }

   return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

MAJORCOMP=mvdm
MINORCOMP=dem

TARGETNAME=dem
TARGETPATH=obj
TARGETTYPE=LIBRARY

W32_SB=1

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=\
    ..\..\..\inc;\
    $(WINDOWS_INC_PATH);\
    $(SOFTPC_TREE)\base\inc;\
    $(SOFTPC_TREE)\host\inc;\
    ..\..\..\vdd\h

SOURCES=..\dem.c       \
    ..\demfcb.c    \
    ..\demdata.c   \
    ..\demdir.c    \
    ..\demdisp.c   \
    ..\demerror.c  \
    ..\demfile.c   \
    ..\demgset.c   \
    ..\demhndl.c   \
    ..\demioctl.c  \
    ..\demlock.c   \
    ..\demmisc.c   \
    ..\demmsg.c    \
    ..\demsrch.c   \
    ..\demdasd.c   \
    ..\demlabel.c  \
    ..\demlfn.c

C_DEFINES=-DWIN_32

UMTYPE=console
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\dosdef.h ===
/* dosdef.h - This file duplicates few important dos defines of use to
 *	      DEM.
 *
 * As these defines are not going to change at all, its better to give
 * DEM a separate copy and not share h and inc files between DOSKRNL and
 * DEM.
 *
 * Sudeepb 05-Apr-1991 Created
 */

#include <doswow.h>
#include <curdir.h>

/**	DEFINES 	**/

/**	File Attributes **/

#define ATTR_NORMAL          0x0
#define ATTR_READ_ONLY       0x1
#define ATTR_HIDDEN          0x2
#define ATTR_SYSTEM          0x4
#define ATTR_VOLUME_ID       0x8
#define ATTR_DIRECTORY       0x10
#define ATTR_ARCHIVE         0x20
#define ATTR_DEVICE          0x40

#define ATTR_ALL             (ATTR_HIDDEN | ATTR_SYSTEM | ATTR_DIRECTORY)
#define ATTR_IGNORE          (ATTR_READ_ONLY | ATTR_ARCHIVE | ATTR_DEVICE)
#define DOS_ATTR_MASK        0x0037  // ATTR_DEVICE isn't used on 32 bit side.
                                     // ATTR_VOL maps to FILE_ATTRIBUTES_NORMAL.

/**	File Modes  **/

#define ACCESS_MASK	     0x0F
#define OPEN_FOR_READ	     0x00
#define OPEN_FOR_WRITE	     0x01
#define OPEN_FOR_BOTH	     0x02
#define EXEC_OPEN	     0x03  /* access code of 3 indicates that
				      open was made from exec */

#define SHARING_MASK         0x70
#define SHARING_COMPAT	     0x00
#define SHARING_DENY_BOTH    0x10
#define SHARING_DENY_WRITE   0x20
#define SHARING_DENY_READ    0x30
#define SHARING_DENY_NONE    0x40
#define SHARING_NET_FCB      0x70
#define SHARING_NO_INHERIT   0x80


/*	Volume Info **/

#define DOS_VOLUME_NAME_SIZE	11
#define NT_VOLUME_NAME_SIZE	255
#define FILESYS_NAME_SIZE    8

/*	IOCTLs	   **/

#define IOCTL_CHANGEABLE	8
#define IOCTL_DeviceLocOrRem	9
#define IOCTL_GET_DRIVE_MAP	0xE

/**     TYPEDEFS        **/

/** SRCHDTA defines the DTA format for FIND_FIRST/NEXT operations **/
#pragma pack(1)

typedef struct _SRCHDTA {               /* DTA */
    PVOID       pFFindEntry;          // 21 bytes reserved area begins
    ULONG       FFindId;
    BYTE        bReserved[13];        // 21 bytes reserved area ends
    UCHAR       uchFileAttr;
    USHORT      usTimeLastWrite;
    USHORT      usDateLastWrite;
    USHORT      usLowSize;
    USHORT      usHighSize;
    CHAR        achFileName[13];
} SRCHDTA;

#pragma pack()

typedef SRCHDTA UNALIGNED *PSRCHDTA;


/** SRCHBUF - defines DOS SEARCHBUF data structure which is used in
 *	      FCBFINDFIRST/NEXT operations.
 */

#pragma pack(1)

typedef struct _DIRENT {
    CHAR	FileName[8];
    CHAR	FileExt[3];
    UCHAR       uchAttributes;
    PVOID       pFFindEntry;         // DOS Reserved Area
    ULONG       FFindId;             // DOS Reserved Area
    USHORT      usDummy;             // DOS Reserved Area
    USHORT	usTime;
    USHORT	usDate;
    USHORT	usReserved2;		// Cluster Number in actual DOS
    ULONG	ulFileSize;
} DIRENT;

#pragma pack()

typedef DIRENT *PDIRENT;

#pragma pack(1)

typedef struct _SRCHBUF {
    UCHAR	uchDriveNumber;
    CHAR	FileName[8];
    CHAR	FileExt[3];
    USHORT	usCurBlkNumber;
    USHORT	usRecordSize;
    ULONG	ulFileSize;
    DIRENT	DirEnt;
} SRCHBUF;

#pragma pack()

typedef SRCHBUF *PSRCHBUF;


/** VOLINFO - GetSetMediaID data structure */

#pragma pack(1)

typedef struct _VOLINFO {
    USHORT	usInfoLevel;
    ULONG	ulSerialNumber;
    CHAR	VolumeID[DOS_VOLUME_NAME_SIZE];
    CHAR	FileSystemType[FILESYS_NAME_SIZE];
} VOLINFO;

#pragma pack()

typedef VOLINFO *PVOLINFO;


/** CDS LIST - CurrDirStructure (Moved to DOSWOW.H) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cleanup.inc ===
makedir:
!if "$(OBJ)" != ""
    @-if not exist $(OBJ) md $(OBJ)
!endif
!if "$(OBJINTL)" != ""
    @-if not exist $(OBJINTL) md $(OBJINTL)
!endif

clean: cleanup all

cleanup:
    -del *.bin *.sys *.obj *.sym *.map *.exe *.exc *.exs *.cl* *.ctl *.com 2>nul
!if "$(OBJ)" != ""
    if exist $(OBJ)\*.obj del $(OBJ)\*.obj
!endif
!if "$(OBJINTL)" != ""
    if exist $(OBJINTL)\*.obj del $(OBJINTL)\*.obj
    if exist $(OBJINTL)\*.cl* del $(OBJINTL)\*.cl*
    if exist $(OBJINTL)\*.ctl del $(OBJINTL)\*.ctl
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\append.asm ===
page	60,120
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
.sall
title	APPEND
include sysmsg.inc
include version.inc
msg_utilname<APPEND>
;-----------------------------------------------------------------------------
;
;      Title:	       APPEND
;
;      Author:	       G. G. A. 		     Network version
;		       B. A. F.`		     DOS changes
;
;      Syntax:	       From the DOS command line:
;
;		       APPEND [d:]path[[;[d:]path]...]
;			     - Used to specify the directories to be
;			       searched after the working directory.
;
;		       APPEND ;
;			     - Used to release all appended directories.
;
;		       APPEND
;			     - Used to show appended directories.
;
;		       First time only:
;
;		       APPEND  [[d:]path |  | /X | /E | /X /E]
;			     - [d:]path Normal support and Set path
;			     -		Normal support
;			     - /X	Extended support, SEARCH, FIND and EXEC
;			     - /E	Use DOS Environment for path(s)
;
;      Revision History:
;      @@01 07/11/86 Fix hang in TopView start			    PTM P00000??
;      @@02 07/28/86 Fix APPEND size problem			    PTM P0000045
;      @@03 07/29/86 Fix APPEND status with /E problem		    PTM P00000??
;      @@04 07/30/86 Fix second APPEND hang			    PTM P0000053
;      @@05 08/13/86 Fix parameter error			    PTM P0000125
;      @@06 08/20/86 Fix APPEND xxx fails in TopView		    PTM P0000217
;      @@07 08/21/86 Resurrect APPEND version message		    PTM P0000252
;      @@08 08/21/86 APPEND=path first time hangs		    PTM P0000254
;      @@09 08/22/86 APPEND gets wrong path under nested COMMAND    PTM P0000276
;      @@10 08/28/86 Change message for @@05			    PTM P0000291
;      @@11 09/10/86 Support message profile and make
;		     msg length variable.	R.G.		    PTM P0000479
;      @@12 09/25/86 Allow second external append call. (RG)	    PTM P0000515
;      @@13 09/30/86 APPEND gets wrong path under nested COMMAND    PTM P0000600
;		     Again. Fix in COMMAND now, so remove @@09 changes
;      @@14 10/01/86 Lower case drive in path files		    PTM P0000600
;      @@15 10/06/86 Include "," and "=" in skip leading of
;		     argument area parsing.			    PTM P0000677
;      @@16 10/06/86 Fix not using full APPEND path		    PTM P0000794
;      @@17 12/03/86 When searching for "APPEND=" string in
;		     environment, make sure delimiter precedes.(RG) PTM P0000893
;
;-------------------------------------------------------------------
;
;      AN000	     3.30 changes, GGA 6/87 new code.			P000
;      AN001	     Support DRIVE and PATH modes			D043
;      AN002	     Add truename function				P1276
;      AN003	     Add extended handle open function			D250
;      AN005
;      AN006	     Add DBCS support
;      AN007	     Release Environmental Vector space 		P2666
;      AN008	     Allow equal symbol with append - APPEND=A:/1;	P2901
;      AN009	     Release Environmental Vector on only the		P3333
;		     first invocation of APPEND
;      AN010	     display invalid parm from command line		P3908
;
;
;-----------------------------------------------------------------------------
;Date	       Rev     Comments
;-----------------------------------------------------------------------------
;06-02-86      0.0     Begin conversion to PC/DOS version
;06-20-86      0.0     End conversion to PC/DOS version
;
page

cseg		segment public para 'CODE'
		assume	cs:cseg
		assume	ds:nothing,es:nothing

;-----------------------------------------------------------------------------
;	Equates
;-----------------------------------------------------------------------------

.xlist
;include fsi.lib
NETSYSUTIL   EQU  0C2H			; SYSTEM UTILITIES
NETENQ	     EQU  07H			; ENQ RESOURCE
NETDEQ	     EQU  08H			; DEQ RESOURCE
;include task.lib
TCBR_APPEND	EQU	   001H 	; APPEND ACTIVE
;include DOS.lib
DOSSERVER    EQU  5DH			; SERVER OPERATION
DOSSETERROR  EQU  0AH			; SET EXTENDED ERROR
;include server.lib
DPL		STRUC
DPL_AX		DW	0		;AX REG
DPL_BX		DW	0		;BX REG
DPL_CX		DW	0		;CX REG
DPL_DX		DW	0		;DX REG
DPL_SI		DW	0		;SI REG
DPL_DI		DW	0		;DI REG
DPL_DS		DW	0		;DS REG
DPL_ES		DW	0		;ES REG
DPL_XID 	DW	0		;RESERVED
DPL_UID 	DW	0		;SERVER USER ID
DPL_PID 	DW	0		;REDIRECTOR PROCESS ID
DPL		ENDS
include sysmac.lib
include versiona.inc
include appendp.inc			; parseing stuff for append			 ;AN004;
.list
;		extrn	end_address:near	; end of stay resident stuff

;		extrn	bad_append_msg:byte	; messages
;		extrn	path_error_msg:byte
;		extrn	parm_error_msg:byte
;		extrn	path_parm_error_msg:byte
;		extrn	no_append_msg:byte		; @@05
;		extrn	append_assign_msg:byte
;		extrn	append_TV_msg:byte		; @@01
;		extrn	bad_DOS_msg:byte
;		extrn	second_APPEND_msg:byte		; @@04

;		extrn	len_bad_append_msg:word 	;@@11
;		extrn	len_path_error_msg:word 	;@@11
;		extrn	len_parm_error_msg:word 	;@@11
;		extrn	len_path_parm_error_msg:word	;@@11
;		extrn	len_no_append_msg:word		;@@11
;		extrn	len_append_assign_msg:word	;@@11
;		extrn	len_append_TV_msg:word		;@@11
;		extrn	len_bad_DOS_msg:word		;@@11
;		extrn	len_second_APPEND_msg:word	;@@11

;	Environmental Vector

PSP_Env 	equ	2ch		;Environmental vector segment in PSP	;an007; dms;

;	Interrupts

DOS_function	equ	21h		; DOS function call interrupt
int_function	equ	2fh		; DOS internal function interrupt, used
					; to verify APPEND presence
termpgm 	equ	20h						; @@05
resident	equ	27h

;	Function calls

get_vector	equ	3521h		; DOS function call to get INT 21 vector
set_vector	equ	2521h		; DOS function call to set INT 21 vector
get_intfcn	equ	352fh		; DOS function call to get INT 2f vector
set_intfcn	equ	252fh		; DOS function call to set INT 2f vector
get_version	equ	30h		; DOS function call to get DOS version number
get_DTA 	equ	2fh		; DOS function get DTA
set_DTA 	equ	1ah		; DOS function set DTA
get_crit_err	equ	3524h		; DOS function call to get INT 24 vector
set_crit_err	equ	2524h		; DOS function call to set INT 24 vector
get_PSP 	equ	62h		; DOS function call to get PSP address
Free_Alloc_Mem	equ	49h		; DOS function call to free alloc. mem. ;an007; dms;

print_string	equ	09h		; DOS function call to get print a string
ctrl_break	equ	33h		; DOS function call to get/set ctrl-break

awrite		equ	40h		; write function
get_dir 	equ	47h		; get current dir
change_dir	equ	3bh		; change dir
get_disk	equ	19h		; get current disk
change_disk	equ	0eh		; change disk
term_stay	equ	31h		; terminate a process and stay resident
term_proc	equ	4ch		; terminate a process

redir_flag	equ	0000000000001000B ; redir flag for net installation check

;	DOS INT 2f function for APPEND presence

append_2f	equ	0b7h		; int 2f function code for append
applic_2f	equ	0aeh		; int 2f function code for applications
COMMAND_2f	equ	-1		; int 2f subfunction code for COMMAND call
append_inst	equ	0ffh		; flag means append is there

;	INT 2f sub-function codes						;AN000;

are_you_there	equ	0		; function code for presence check
old_dir_ptr	equ	1		; means APPEND 1.0 is trying to run
get_app_version equ	2		; fun code for get ver request
tv_vector	equ	3		; fun code for set TV vector
dir_ptr 	equ	4		; function code to return dirlist ptr
get_state	equ	6		; function code to return append ;AN001;
					; state 			 ;AN001;
set_state	equ	7		; function code to set append	 ;AN001;
					; state 			 ;AN001;

DOS_version	equ	10h		; function call to get DOS version
true_name	equ	11h		; one-shot truename fcn for ASCIIZ ops ;AN002;

;	DOS INT 21 function calls that APPEND traps

FCB_opn 	equ	0fh
file_sz 	equ	23h
handle_opn	equ	3dh
dat_tim 	equ	57h
FCB_sch1	equ	11h
handle_fnd1	equ	4eh
exec_proc	equ	4bh
ext_handle_opn	equ	6ch								  ;AN003;

break	macro			; this is a dummy break macro so PDB.INC
	endm			; won't blow up in the build

;	define some things for PDB (PSP)						  ;AN002;
											  ;AN002;
include pdb.inc 									  ;AN002;
											  ;AN002;
true_name_flag		equ	01h	; flag for true name function			  ;AN002;
eo_create		equ	00f0h	; mask to check extended opens for create	  ;AN003;

;	Error codes that don't mean stop looking

FCB_failed		equ	0ffh	; FCB open failed
FCB_file_not_found	equ	2	; file not found on FCB open
handle_file_not_found	equ	2	; file not found on handle open
handle_path_not_found	equ	3	; path not found on handle open
FCB_no_more_files	equ	18	; no more matching files
handle_no_more_files	equ	18	; no more matching files

;	Equates for TOPVIEW barrier
TV_TRUE equ	-1			; this was changed from TRUE	 ;AN000;
					; because 3.30 parser uses TRUE  ;AN000;
false	equ	0			;

;	Message equates

tab_char equ	9
cr	equ	13
lf	equ	10
beep	equ	7
STDOUT	equ	0001h			; standard output file
STDERR	equ	0002h			; standard error file
null	equ	0

MSG_OPTIONS_FIRST	equ	300
MSG_OPTIONS_LAST        equ     316

page

;-----------------------------------------------------------------------------
;	Resident data area
;-----------------------------------------------------------------------------

version_loc:				; version number
	db	major_version,minor_version
;	 dw	 message_list		 ; pointer to message table

		even
vector_offset	dw	0		; save pointer to old int 21 here
vector_segment	dw	0
crit_vector_offset  dw	0		; save pointer to old int 24 here
crit_vector_segment dw	0
intfcn_offset	dw	0		; save pointer to old int 2f here
intfcn_segment	dw	0
dirlst_offset	dw	0		; save pointer to dir list here
dirlst_segment	dw	0
tv_vec_off	dw	0		; save TV vector here
tv_vec_seg	dw	0

pars_off	dd	cseg: SysParse	; save pointer to parser here
;pars_off	 dw	 offset SysParse ; save pointer to parser here
;pars_seg	 dw	 0

app_dirs_seg	dw	0		; save ES here during FCB

FCB_ptr 	dd	0		; save pointer to FCB here
handle_ptr	dd	0		; save pointer to ASCIIZ string here

stack_offset	dw	0
stack_segment	dw	0		; Calling process stack

incoming_AX	dw	0		; AX saved at entry to interrupt handler
incoming_CX	dw	0		; CX saved at entry to interrupt handler
; must be together
incoming_BX	dw	0		; BX saved at entry to interrupt handler
incoming_ES	dw	0		; ES saved at entry to interrupt handler
; must be together
ax_after_21	dw	0		; AX saved after call to real INT 21
; temp_DS_save	  dw	  0		  ; DS saved during stack ops
temp_CS_save	dw	0		; CS saved during stack ops (set_return_flags)
temp_IP_save	dw	0		; IP saved during stack ops (set_return_flags)
FCB_drive_id	db	0		; save the drive id for FCB opens here

;------------------------
;	DBCS stuff here 								 ;AN006;
											 ;AN006;
DBCSEV_OFF	DW	0		; OFFSET OF DBCS EV				 ;AN006;
DBCSEV_SEG	DW	0		; SEGMENT OF DBCS EV				 ;AN006;
											 ;AN006;
;DEFAULT DBCS ENVIRONMENTAL VECTOR							 ;AN006;
EVEV	DB	00H,00H 								 ;AN006;
	DB	00H,00H 								 ;AN006;
	DB	00H,00H 								 ;AN006;
											 ;AN006;
dbcs_fb 	dw	0		; offset of DBCS first byte chars found
;------------------------

initial_pass	dw	0		; flag used to indicate inital APPEND		 ;AN007;

incoming_DX	dw	0		; used for saves for extended open		  ;AN003;
incoming_SI	dw	0		; used for saves for extended open		  ;AN003;
incoming_DI	dw	0		; used for saves for extended open		  ;AN003;
incoming_DS	dw	0		; used for saves for extended open		  ;AN003;
true_name_count dw	0		; used to save number of chars in true_name dir   ;AN003;

int_save_ip	dw	0		; save registers here during critical
int_save_cs	dw	0		; error handler stack ops

work_disk	db	"?:\"		; user's working disk
work_dir	db	64 dup(" ")	; user's working dir
app_disk	db	"?:\"		; user's working disk
app_dir 	db	64 dup(" ")	; user's append disk's working dir
ctrl_break_state db	0		; save the old ctrl-break state here

end_search	db	0		; end search flag
try_dir 	db	128 dup (0)	; try this dir
fname		db	15 dup (0)	; 8.3 filename stripped from original
					; ASCIIZ string
app_dirs_ptr	dw	0		; pointer to appended dir to try

set_name	db	"SET     "	; SET command
; must be together
setappend_name	db	"SET "		; SET command
append_id	db	"APPEND="	; display from here for user
; must be together
app_dirs	db	";"
		db	128 dup (0)	; area for storing appended dirs
		db	0		; just to insure that the last dir is null terminated
semicolon	db	";",0		; null list

;	Flags / barriers added for TopView

tv_flag 	db	0		; flag to indicate re-entr from TopView

parse_flag	db	0		; flag used by APPEND parsing

FCB_ext_err	db	0		; flag used to indicate that FCB
					; open failed and ext err was done
crit_err_flag	db	0		; flag used to indicate that a critical
					; error happened
ext_err_flag	db	0		; flag used to indicate that ext err
					; must be set 0 = don't set, 1 = do set
in_middle	db	0		; flag used to tell if we made it to
					; middle of string before finding a space
equal_found	db	0		; multiple = check
;crit_sect_flag  db	 0		 ; critical section flag

stack_area	dw	99 dup(0)	; stack area for append
append_stack	dw	0

net_config	dw	0		; flag word for what (if any) network
					; config we are running under
					; as long as this word is zero, a clear determination
					; has not been made about the configuration

		even
ext_err_dpl	DPL	<>		; reserve a DPL for get/set extended error code


save_ext_err	DPL	<>		; reserve a DPL for first extended
					; error code

;-------------------------------------------------------------------	 ;AN001;
;									 ;AN001;
;	mode_flags	This status word is used to control the various  ;AN001;
;			APPEND functions and modes.			 ;AN001;
;									 ;AN001;
;-------------------------------------------------------------------	 ;AN001;
mode_flags	dw	Path_mode + Drive_mode + Enabled		 ;AN001;
					; mode control flags		 ;AN001;
					; initially - path, drive and	 ;AN001;
					; enabled			 ;AN001;

;	equates for mode_flags follow:					 ;AN001;

X_mode		equ	8000h		; in /X mode
E_mode		equ	4000h		; in /E mode
Path_mode	equ	2000h		; PATH in string OK		 ;AN001;
Drive_mode	equ	1000h		; DRIVE in string OK		 ;AN001;
Enabled 	equ	0001h		; APPEND enabled		 ;AN001;

;-------------------------------------------------------------------

cmd_name@	dd	?		; internal name string

expected_error	dw	?		; error to do append scan
expected_ext_error dw	?		; error to do append scan

cmd_env 	dw	?		; pointer to COMMANDs environment
cmd_buf 	dw	?		; CMDBUF offset (in SS)

incoming_DTA	dd	?		; user's DTA (on EXEC)
exec_DTA	db	21+1+2+2+2+2+13 dup(0)	; find DTA for exec emulation

old_syntax	db	0		; using network syntax

res_append	db	0		; resident append call		  ; @@05

abort_sp	dw	?		; sp to restore on errors	  ; @@05

crlf	label	byte
	db	CR,LF
crlf_len equ	 $ - crlf

;*******************************************************************		;an010;bgb
; parser message display area							;an010;bgb
;*******************************************************************		;an010;bgb
inv_parm    db	0bh	;length 						;an010;bgb
	    db	0	;reserved						;an010;bgb
si_off	    dw	0	;put offset of command line here			;an010;bgb
si_seg	    dw	0	;put segment of command line here			;an010;bgb
	    db	0	;use percent zero					;an010;bgb
	    db	Left_Align+Char_Field_ASCIIZ ;type of data			;an010;bgb
	    db	128			;max width				;an010;bgb
	    db	1			;min width				;an010;bgb
	    db	' '			;pad char				;an010;bgb

;-------------------------------------------------------------------
;
;	resident message area
;
;-------------------------------------------------------------------

MSG_SERVICES <MSGDATA>
MSG_SERVICES <DISPLAYmsg,CHARmsg>						;an010;bgb
MSG_SERVICES <APPEND.CLA,APPEND.CL1,APPEND.CTL>

.xlist
;-----------------------------------------------------------------------------
;	macros
;-----------------------------------------------------------------------------

;-----------------------------
;	save and restore register macros
save_regs macro
	push	bx
	push	cx
	push	dx

	push	di
	push	si
	push	ds
	push	es
	endm

restore_regs macro
	pop	es
	pop	ds
	pop	si
	pop	di

	pop	dx
	pop	cx
	pop	bx
	endm

;-----------------------------
;	this macro is used instead of the normal POPF instruction to help
;	prevent a 286 bug from occurring
popff	macro
	local	myret
	jmp	$+3
myret	label	near
	iret
	push	cs
	call	myret
	endm

;-----------------------------						  ; @@12
;	check character 						  ; @@12
;									  ; @@12
chkchar macro	char							  ; @@12
	lodsb								  ; @@12
	and	al,0dfh 						  ; @@12
	cmp	al,char 						  ; @@12
	jne	ccn_ret 						  ; @@12
	endm								  ; @@12
.list

page
;-----------------------------------------------------------------------------
;	resident routine - control transferred here on INT 21
;	check to see if this call has a function code we are interested in
;-----------------------------------------------------------------------------


tv_entry:
	pushf								  ; @@01
	jmp	SHORT  check_fcb_open						  ; @@01

interrupt_hook:
resident_routine:
	pushf				; save the user's flags (old stack)

	cmp	tv_flag,TV_TRUE 	; see if in TV			 ;AN000;
	je	use_old 		; yes, old_vect

check_fcb_open: 							  ; @@01

;-------------------------------------------------------------------	 ;AN001;
;	first, check to see if APPEND disabled, if so, skip everything	 ;AN001;
;	and go to real INT 21 handler					 ;AN001;
;-------------------------------------------------------------------	 ;AN001;
	test	mode_flags,Enabled	; APPEND disabled?		 ;AN001;
	jz	real_jump		; yes, skip all other checks	 ;AN001;

	cmp	ah,FCB_opn		; FCB open?
	jump	E,FCB_open		; yes, do the APPEND

	cmp	ah,handle_opn		; handle open?
	jump	E,handle_open		; yes, do the APPEND

	cmp	ah,ext_handle_opn	; extended handle open? 			  ;AN003;
	jump	E,ext_handle_open	; yes, do the APPEND				  ;AN003;
											  ;AN003;
	cmp	ah,file_sz		; file size?
	je	FCB_open		; yes, do the APPEND


	test	mode_flags,X_mode	; /X mode not selected
	jz	real_jump

	call	IsItFCB_FindFirst?
	je	FCB_search1

;------ following two lines replaced by the above to lines of code Bug #121
;	 cmp	 ah,FCB_sch1		 ; search?
;	 jump	 E,FCB_search1		 ; yes, do the APPEND
;--------------------------------------------------------------------------

	call	IsItHandle_FindFirst?
	jump	E, handle_find1

;------ following two lines replaced by the above to lines of code Bug #121
;	 cmp	 ah,handle_fnd1 	 ; find?
;	 jump	 E,handle_find1 	 ; yes, do the APPEND
;--------------------------------------------------------------------------

	cmp	tv_flag,TV_TRUE 	; cant do in TopView		 ;AN000;
	je	skip_exec
	cmp	ax,exec_proc*256+0	; EXEC?
	jump	E,exec_pgm		; yes, do the APPEND
skip_exec:
	cmp	ax,exec_proc*256+3	; EXEC?
	jump	E,exec_pgm		; yes, do the APPEND

	page
;-----------------------------------------------------------------------------
;	By here, we know that the call was not one we are interested in,
;	pass through to old INT 21.
;	Since this is done with a jmp, control will pass back to original caller
;	after DOS is finished.
;-----------------------------------------------------------------------------

real_jump:
	cmp	tv_flag,TV_TRUE 	; see if called by TV		 ;AN000;
	jne	use_old 		; yes, use old vect

	popff				; restore user's flags
	jmp	dword ptr tv_vec_off	; pass through to TV

use_old:
	popff				; restore user's flags (old stack)
	jmp	dword ptr Vector_Offset ; jump to old INT 21

page
;-----------------------------------------------------------------------------
; New functions added to resolve Bug #121
; IsItFCB_FindFirst?
; IsItHandle_FindFirst?
;-----------------------------------------------------------------------------
VOL_LABEL	equ	08h
IsItFCB_FindFirst?	proc	near
		cmp	ah, FCB_sch1		; search?
		jne	not_FCB_FindFirst
		push	bx
		mov	bx, dx			; ds:bx == ptr to FCB
		cmp	byte ptr [bx], 0ffh	; extended FCB ?
		jne	FCB_FindFirst
		test	byte ptr [bx+6], VOL_LABEL	; search for label ?
		pop	bx
		ret
FCB_FindFirst:
		pop	bx			; restore BX (bug #1027)
		cmp	al, al
not_FCB_FindFirst:
		ret
IsItFCB_FindFirst?	endp
;
;----------------- This routine can be made in line MOHAN
;
IsItHandle_FindFirst?	proc	near
		cmp	ah, handle_fnd1 	; handle find ?
		jne	not_Handle_FindFirst
		test	cl, VOL_LABEL
not_Handle_FindFirst:
		ret
IsItHandle_FindFirst?	endp
;
page
;-----------------------------------------------------------------------------
;	FCB_search1 - this routine handles FCB search first calls
;-----------------------------------------------------------------------------

FCB_search1:
	mov	expected_ext_error,fcb_no_more_files
	jmp	short FCB_openx1

;-----------------------------------------------------------------------------
;	FCB_open - this routine handles FCB open calls
;-----------------------------------------------------------------------------

FCB_open:
	mov	expected_ext_error,fcb_file_not_found
FCB_openx1:
	call	check_config		; check the config flags
	call	crit_sect_set		; set critical section flag

	call	tv_barrier

	mov	incoming_AX,ax		; save user's AX
	mov	word ptr FCB_ptr+0,dx	; save FCB pointer
	mov	word ptr FCB_ptr+2,ds

	popff				; restore user's flags
	call	int_21			; try the open

	cli
	mov	AX_after_21,ax		; save AX as it came back from INT
	pushf				; save flags from operation
	cmp	al,FCB_failed		; open failed ?
	je	check_error		; yes, lets check extended error
	jmp	set_return_flags	; no, fix the stack, then ret to caller

check_error:
	call	get_ext_err_code	; get the extended error code
	mov	FCB_ext_err,1		; set FCB ext error
	call	save_first_ext_err	; save first extended error code
	mov	ax,ext_err_dpl.DPL_AX	; get error in ax
	cmp	ax,expected_ext_error	; file not found?
	je	FCB_openx2		; yes, lets look around for file
	lea	dx,save_ext_err 	;
	call	set_ext_err_code	; set the extended error code
	jmp	set_return_flags	; no, fix the stack, then return

FCB_openx2:

;	set up APPEND's stack

	popff				; get rid of the flags from the
					; real operation
;	mov	temp_DS_save,ds 	; Save DS reg
	mov	stack_segment,ss	; Save it
	mov	stack_offset,sp 	; Save it
	mov	ax,cs			; Get current segment
	mov	ss,ax			; and point stack seg here
	lea	sp,append_stack 	; set up new stack

	save_regs			; save registers

	push	cs			; establish addressability
	pop	ds

	call	ctrl_break_set		; set ctrl-break handler
	call	crit_err_set		; set crit err handler

	mov	ext_err_flag,1		; flag for setting critical error

;	fix FCB drive spec

	les	bx,dword ptr FCB_ptr	; ES:BX points to FCB
	mov	ah,ES:byte ptr [bx]	; get FCB drive spec
	cmp	ah,-1			; extended FCB?
	jne	not_ext_FCB1
	add	bx,1+5+1		; point to real drive letter
	mov	ah,ES:byte ptr [bx]	; get FCB drive spec

not_ext_FCB1:
	mov	FCB_drive_id,ah 	; save it for later
	mov	ES:byte ptr [bx],0	; zero the drive field out to
					; use default drive

	mov	ah,get_disk		; get disk
	call	int_21			; call DOS INT 21 handler

	add	al,"A"			; make it a character
	mov	work_disk,al		; save it

	mov	ah,get_dir		; get directory
	xor	dx,dx			; default drive
	lea	si,work_dir		; save area
	call	int_21			; call DOS INT 21 handler

	call	address_path		; get address of path
	cmp	es: byte ptr [di],";"	; is the append list null?
	jump	E,null_list		; exit append
	mov	app_dirs_seg,es 	; save app dirs segment
	mov	si,di			; source

try_another1:
	lea	di,try_dir		; destination
	call	get_app_dir		; copy dir to try into try_dir
	mov	app_dirs_ptr,si 	; save updated pointer


;-----------------------------
try_app_dir1:
	mov	app_disk,0		; zero for current dir
	cmp	try_dir+1,":"		; see if we have a drive
	jne	no_drive		; char should be a colon

;	yes, there was a drive specified, must do the change disk function call

	mov	ah,change_disk		; change disk
	mov	dl,try_dir		; get the char representation of the drive
	mov	app_disk,dl		; save it away for later use
	call	cap_dl
	sub	dl,"A"			; convert from char to drive spec
	call	int_21			; call DOS INT 21 handler
;	jc	check_end_dir_list	; there was an error, see if there is
					; another to try

	cmp	crit_err_flag,0 	; did we experience a critical error
	jne	set_err_code		; yes, fake a file_not_found

no_drive:
	mov	ah,get_dir		; get directory
	xor	dx,dx			; default drive
	lea	si,app_dir		; save area
	call	int_21			; call DOS INT 21 handler

;	check to see if there was a critical error

	cmp	crit_err_flag,0 	; did we experience a critical error
	je	cd_worked		; no, the cd worked
	jmp	short set_err_code

save_regs_and_set:
	pushf				; save everything again
	save_regs
	push	cs			; re-establish addressability
	pop	ds			; ds = cs

set_err_code:
	xor	ah,ah			; make ax look like open failed
	mov	al,FCB_failed
	mov	ax_after_21,ax		; save it away so we can restore it below

	jmp	no_more_to_try

cd_worked:
	lea	dx,try_dir		; point dx to dir to try
	mov	ah,change_dir		; change dir to appended directory
	call	int_21			; call DOS INT 21 handler

;	try the open in this dir

	restore_regs			; make regs look like when user
	mov	ax,incoming_AX		; called us

	call	int_21			; call DOS INT 21 handler
	mov	ax_after_21,ax		; save AX
	cmp	crit_err_flag,0 	; did we get critical error?
	jne	save_regs_and_set	; yes, fake a file_not_found
	cmp	al,FCB_failed	   ; did open work?
	jne	open_ok
	call	get_ext_err_code	; get the extended error code

open_ok:
	pushf				; save everything again
	save_regs

	push	cs			; re-establish addressability
	pop	ds			; ds = cs

;	restore user's working disk and restore the dir on the appended drive

	mov	ah,change_disk		; change disk back to our original
	mov	dl,work_disk
	call	cap_dl
	sub	dl,"A"			; convert from char to drive spec
	call	int_21			; call DOS INT 21 handler

	mov	ah,change_dir		; change dir
	lea	dx,app_disk		; save area (this time include drive)
	call	int_21			; call DOS INT 21 handler

;	this is for ..\dirname ptr

	mov	ah,change_dir		; change dir
	lea	dx,work_disk		; save area (this time include drive)
	call	int_21			; call DOS INT 21 handler

	mov	ax,ax_after_21		; restore AX
	cmp	al,FCB_failed		; did open work?
	jne	FCB_open_worked
	mov	ax,ext_err_dpl.DPL_AX
	cmp	ax,expected_ext_error
	jne	no_more_to_try		; not file not found

check_end_dir_list:
	mov	es,app_dirs_seg 	; restore es
	mov	si,app_dirs_ptr
	cmp	si,null 		; should we try again?
	je	no_more_to_try		; no
	jmp	try_another1		; yes

FCB_open_worked:
	mov	byte ptr ext_err_flag,0 ; the open worked, no need to set ext err code
	jmp	short set_disk

no_more_to_try:
;	restore user's working disk and dir

;	The following code up to label "null_list" which
;	restores the user's drive and path was moved in front
;	of the code to restore the drive spec in FCB.
;
	mov	ah,change_disk		; change disk
	mov	dl,work_disk
	call	cap_dl
	sub	dl,"A"			; convert from char to drive spec
	call	int_21			; call DOS INT 21 handler

	mov	ah,change_dir		; change dir
	lea	dx,work_disk		; save area (this time include drive)
	call	int_21			; call DOS INT 21 handler

null_list:
	mov	ah,FCB_drive_id 	; get FCB drive spec
;	cmp	ah,0			; did they ask for default drive?
;	je	fix_drive_spec		; yes, leave it alone
	jmp	short fix_drive_spec

set_disk:				; set drive number in FCB
	mov	ah,work_disk		; no, give them the found drive spec
	sub	ah,"A"-1		; convert from char to drive spec

;	ah has proper drive spec to put into FCB, do it

fix_drive_spec:
	les	bx,dword ptr FCB_ptr	; ES:BX points to FCB
	cmp	ES:byte ptr[bx],-1	; extended FCB
	jne	not_ext_FCB2		; put in the proper drive spec
	add	bx,1+5+1		; point to real drive letter

not_ext_FCB2:
	mov	ES:byte ptr [bx],ah


	call	ctrl_break_restore
	call	crit_err_restore

;	find out if there is a need to set the extended error code

	cmp	ext_err_flag,0		; do we need to set the extended error code?
	je	no_ext_err		; no, finish up
	lea	dx,ext_err_dpl
	cmp	FCB_ext_err,0
	je	handle_ext_err
	lea	dx,save_ext_err

handle_ext_err:
	call	set_ext_err_code	; yes, go set the ext error info

;	all done with append, clean things back up for the user

no_ext_err:
	restore_regs			; restore registers

	jmp	reset_stack		; fix stack, ret to caller
page

;-----------------------------------------------------------------------------
;	handle_find - APPEND handle find function
;-----------------------------------------------------------------------------

handle_find1:
	mov	incoming_CX,cx		; save user's CX
	mov	expected_error,handle_no_more_files
;	mov	expected_ext_error,handle_no_more_files
	jmp	short handle_openx

;-----------------------------------------------------------------------------
;	exec_pgm - APPEND exec program function
;-----------------------------------------------------------------------------

exec_pgm:
	mov	incoming_BX,bx		; save user's ES:BX
	mov	incoming_ES,es
	mov	expected_error,handle_file_not_found
;	mov	expected_ext_error,handle_no_more_files
	jmp	short handle_openx

;-----------------------------------------------------------------------------		  ;AN003;
;	ext_handle_open - APPEND extended handle open function					       ;AN003;
;-----------------------------------------------------------------------------		  ;AN003;
ext_handle_open:									  ;AN003;
	test	dx,eo_create		; does this call specify create?		  ;AN003;
	jz	no_eo_create		; no, we can continue				  ;AN003;
											  ;AN003;
	jmp	real_jump		; yes, do nothing but pass on to real		  ;AN003;
					; INT 21 handler				  ;AN003;
											  ;AN003;
;	getting here means the caller did not specify the create option 		  ;AN003;
											  ;AN003;
no_eo_create:										  ;AN003;
											  ;AN003;
	mov	incoming_BX,bx		; save user's registers                           ;AN003;
	mov	incoming_CX,cx		; extended open sure does use a lot		  ;AN003;
	mov	incoming_DX,dx		; of registers					  ;AN003;
	mov	incoming_SI,si								  ;AN003;
	mov	incoming_DI,di								  ;AN003;
	mov	incoming_ES,es								  ;AN003;
	mov	incoming_DS,ds								  ;AN003;
											  ;AN003;
	mov	expected_error,handle_file_not_found					  ;AN003;
	jmp	short handle_openx	; for now ...					  ;AN003;
											  ;AN003;
;-----------------------------------------------------------------------------
;	handle_open - APPEND handle open function
;-----------------------------------------------------------------------------

handle_open:
	mov	expected_error,handle_file_not_found
;	mov	expected_ext_error,handle_file_not_found

handle_openx:
	call	check_config		; check the config flags
	call	crit_sect_set		; set critical section flag

	call	tv_barrier		; no op on exec

	mov	incoming_AX,ax		; save user's AX
	mov	word ptr handle_ptr+0,dx	 ; save path pointer
	mov	word ptr handle_ptr+2,ds

	popff				; restore user's flags
	call	int_21			; try the open

	cli
	mov	AX_after_21,ax		; save AX as it came back from INT
	pushf				; save flags from operation

;	find out if we had an error, and if so was it the one we were
;	looking for

	jc	what_happened		; yes, lets find out what happened
	mov	incoming_AX,-1		; insure no exec done later
	jmp	set_return_flags	; no, fix the stack, then ret to caller
					; this means that the real call worked,
					; APPEND does not need to do anything

what_happened:
;	cmp	ax,handle_path_not_found  ; normal errors
;	je	handle_search		; yes, look for the file
	cmp	ax,expected_error	; was the error file not found?
	je	handle_search		; yes, look for the file
	jmp	set_return_flags	; no, fix the stack, then ret to caller


handle_search:
	call	get_ext_err_code	; get the extended error code information

;	set up APPEND's stack
	popff				; get rid of the flags from the
					; real operation
;	mov	temp_DS_save,ds 	; Save DS reg
	mov	stack_segment,ss	; Save it
	mov	stack_offset,sp 	; Save it
	mov	ax,cs			; Get current segment
	mov	ss,ax			; and point stack seg here
	lea	sp,append_stack 	; set up new stack

	save_regs			; save registers
	pushf				;
	push	cs			; establish addressability
	pop	ds

	call	crit_err_set

	call	ctrl_break_set

;	all done with the prep stuff, let's get down to business

;-------------------------------------------------------------------	 ;AN001;
;									 ;AN001;
;	before doing anything else, check DRIVE and PATH modes		 ;AN001;
;									 ;AN001;
;-------------------------------------------------------------------	 ;AN001;
;									 ;AN001;

	pushf				; save flags			 ;AN001;
	push	ax			; save AX			 ;AN001;
									 ;AN001;
	cmp	incoming_AX,exec_proc*256 ; is this call an exec?
	je	drive_and_path_ok


;-------------------------------------------------------------------
;	Set up ES:SI to point to incoming string
;-------------------------------------------------------------------

	cmp	incoming_AX,ext_handle_opn*256+0 ;is this call an ext open?		  ;AN003;
	jne	no_eo13 								  ;AN003;
	mov	si,incoming_SI		; DS:SI points to original name for ex open	  ;AN003;
	mov	es,incoming_DS		; but this code wants ES:SI to point to it	 ;AN003;
	lea	di,fname		; DS:DI points to fname area			  ;AN003;
	jmp	SHORT eo_skip3		; skip the old stuff				  ;AN003;
											  ;AN003;
no_eo13:										   ;AN003;
	les	si,dword ptr handle_ptr ; ES:SI points to original handle
	lea	di,fname		; DS:DI points to fname area
eo_skip3:
;-------------------------------------------------------------------

	test	mode_flags,Drive_mode	; Drive_mode enabled?
	jnz	check_path_mode 	; yes, go check path mode

	call	check_for_drive 	; no, find out if there is a drive
					; specified
	cmp	ax,0			; was there a drive letter?
	je	check_path_mode 	; no, go check path mode

;-------------------------------------------------------------------
;	getting here means that Drive_mode is disabled and that a drive letter
;	was found.  This means we give up on this APPEND operation

	jmp	SHORT drive_or_path_conflict


check_path_mode:
	test	mode_flags,Path_mode	; Path_mode enabled?
	jnz	drive_and_path_ok	; yes, go do the APPEND function

	call	check_for_path		; no, find out if there is a path
					; specified

	cmp	ax,0			; was there a path?
	jne	drive_or_path_conflict	; no, go do the APPEND function


	call	check_for_drive 	; no, find out if there is a drive
					; specified
	cmp	ax,0			; was there a drive letter?
	je	drive_and_path_ok	; no, everything is OK
					; yes, fall through and exit w/error

;-------------------------------------------------------------------	 ;AN001;
;	getting here means that Drive_mode is disabled and that a drive  ;AN001;
;	letter was found.  This means we give up on this APPEND operatio ;AN001; n

drive_or_path_conflict:

	pop	ax			; clean up stack
	popff

;	restore_regs			; restore some regs				  ;AN002;
;	pop	ax

	mov	ext_err_flag,1		; we need to set extended error info
	mov	ax,expected_error	; make ax look like we got file not found
	mov	ax_after_21,ax		; save it away so we can restore it below
	popff				; get flags from stack
	stc				; set the carry flag
	pushf				; put 'em back

	jmp	no_more_to_try2


drive_and_path_ok:							 ;AN001;
	pop	ax			; restore AX			 ;AN001;
	popff				; restore flags 		 ;AN001;
									 ;AN001;
;-------------------------------------------------------------------	 ;AN001;
;	end of code to check DRIVE and PATH modes			 ;AN001;
;-------------------------------------------------------------------	 ;AN001;

	cmp	incoming_AX,ext_handle_opn*256+0 ;is this call an ext open?		  ;AN003;
	jne	no_eo1									  ;AN003;
	mov	si,incoming_SI		; DS:SI points to original name for ex open	  ;AN003;
	mov	es,incoming_DS		; but this code wants ES:SI to point to it	 ;AN003;
	lea	di,fname		; DS:DI points to fname area			  ;AN003;
	jmp	SHORT eo_skip1		; skip the old stuff				  ;AN003;
											  ;AN003;
no_eo1: 										  ;AN003;
	les	si,dword ptr handle_ptr ; ES:SI points to original handle
	lea	di,fname		; DS:DI points to fname area
eo_skip1:										  ;AN003;
	call	get_fname		; strip just the 8.3 filename from
					; the original ASCIIZ string
	call	address_path		; address the path
	cmp	es: byte ptr [di],";"	; is append list null ?
	jump	E,no_more_to_try2	; exit append
	popff				;
	mov	si,di			; pointer to list of appended directories
	pushf				; push flags onto stack just for the
					; popff below

try_another2:
	popff
	lea	di,try_dir		; buffer to be filled with dir name
					; to try
	push	cx			; save CX
	call	get_app_dir		; this routine will return with a dir
					; to try in try_dir
	mov	true_name_count,cx	; save number of chars for later us		  ;AN003;
	pop	cx
	mov	app_dirs_ptr,si 	; save updated pointer


;-----------------------------
try_app_dir2:

	call	append_fname		; glue the filename onto the end of the dir to try


;	we now have an ASCIIZ string that includes the original 8.3 filename
;	and one of the appended dir paths

	mov	ax,incoming_AX
	mov	cx,incoming_CX
	lea	dx,try_dir		; point to new ASCIIZ string

	cmp	incoming_AX,ext_handle_opn*256+0     ; extended open?			  ;AN003;
	jne	not_eo1 								  ;AN003;
											  ;AN003;
;	this is an extended open call							  ;AN003;
											  ;AN003;
	save_regs									  ;AN003;
											  ;AN003;
	mov	si,dx			; ext open wants DS:SI -> filename		  ;AN003;
	push	cs									  ;AN003;
	pop	ds									  ;AN003;
											  ;AN003;
	mov	ax,incoming_AX		; function code 				  ;AN003;
	mov	bx,incoming_BX		; mode word					  ;AN003;
	mov	cx,incoming_CX		; attributes					  ;AN003;
	mov	dx,incoming_DX		; flags 					  ;AN003;
	mov	es,incoming_ES		; ES:DI parm_list pointer			  ;AN003;
	mov	di,incoming_DI								  ;AN003;
											  ;AN003;
	call	int_21			; try the extended open 			  ;AN003;
											  ;AN003;
	restore_regs									  ;AN003;
	pushf				; save flags					  ;AN003;
;	mov	es,incoming_ES		; restore es as it was				  ;AN003;
	jmp	SHORT not_exec2		; go find out what happened			  ;AN003;
											  ;AN003;
											  ;AN003;
not_eo1:										  ;AN003;
	cmp	incoming_AX,exec_proc*256+0	; exec pgm call
	jne	not_exec1

;	this is an exec call								  ;AN003;

	push	es
	push	bx
	mov	ah,get_DTA
	call	int_21
	mov	word ptr incoming_DTA+0,bx	; save callers DTA
	mov	word ptr incoming_DTA+2,es
	pop	bx
	pop	es
	push	ds
	push	dx
	mov	ah,set_DTA
	lea	dx,exec_DTA		; set for fake exec search
	push	cs
	pop	ds
	call	int_21
	pop	dx
	pop	ds
	mov	ah,handle_fnd1		; precess search by finds
	mov	expected_error,handle_no_more_files

not_exec1:

	push	es			; save append's ES
	push	bx			; save append's BX
	mov	es,incoming_ES		; must restore ES before doing the call ; fix for P37, GGA 9/10/87
	mov	bx,incoming_BX		; must resatore user's ES:BX

	call	int_21			; try the open

	pop	bx			; restore append's BX
	pop	es			; restore append's es
	pushf				; save flags
	cmp	incoming_AX,exec_proc*256+0	; exec pgm call
	jne	not_exec2
	push	ds
	push	dx
	push	ax
	mov	ah,set_DTA
	mov	dx,word ptr incoming_DTA+0	; restore callers DTA
	mov	ds,word ptr incoming_DTA+2
	call	int_21
	pop	ax
	pop	dx
	pop	ds
not_exec2:
	popff
	pushf
	jnc	found_it_remote 	; all done

	cmp	crit_err_flag,0 	; process critical errors
	jne	check_crit_err

	cmp	ax,handle_path_not_found  ; normal errors
	je	should_we_look_more

	cmp	ax,expected_error	; was the error we found file not found?
	je	should_we_look_more	; yes, look some more
	jmp	no_more_to_try2 	; no, any other error, we pack it in

should_we_look_more:
	mov	si,app_dirs_ptr 	; yes, see if we should look more
	cmp	si,null 		; should we try again?
	je	no_more_to_tryx
	jmp	try_another2		; yes
no_more_to_tryx:
	jmp	no_more_to_try2

check_crit_err:
	mov	ext_err_flag,1		; we need to set extended error info
	mov	ax,expected_error	; make ax look like we got file not found
	mov	ax_after_21,ax		; save it away so we can restore it below
	popff				; get clags from stack
	stc				; set the carry flag
	pushf				; put 'em back

	jmp	no_more_to_try2

found_it_remote:			; come here only if the file was found in
					; an appended directory
	mov	ax_after_21,ax		; save AX


;											  ;AN002;
;	Find out if this process has the true_name flag set in thier PSP.		  ;AN002;
;	At this point, DS:DX points to the true name of the found file			  ;AN002;
;											  ;AN002;
											  ;AN002;
	push	ax			; save some regs				  ;AN002;
	save_regs
											  ;AN002;
	mov	ah,get_PSP		; function code for get PSP operation		  ;AN002;
	call	int_21			; get the PSP, segment returned in BX		  ;AN002;
	mov	es,bx			; need to use it as a segment			  ;AN002;
	mov	di,PDB_Append		; get pointer to APPEND flag in PDB		  ;AN002;
											  ;AN002;
	mov	ax,es:[di]		; get APPEND flag into AX			  ;AN002;
	test	ax,true_name_flag	; is true name flag armed?			  ;AN002;
	jz	no_true_name		; no, don't copy true name                        ;AN002;
											  ;AN002;
	sub	ax,true_name_flag	; clear true name flag				  ;AN002;
	mov	es:[di],ax		; save it in PSP				  ;AN002;
											  ;AN002;
	mov	di,word ptr handle_ptr+0	; get user's buffer pointer ES:DI         ;AN002;
	mov	es,word ptr handle_ptr+2						  ;AN002;

;	find out if this is a handle find or an open or an exec

	cmp	incoming_AX,exec_proc*256+0   ; exec?
	je	no_true_name		; yes, do nothing with true name
											  ;AN002;
	cmp	incoming_AX,handle_fnd1*256+0	; handle find?
	jne	not_hf			; no, go do the easy stuff
											  ;AN002;
;	function we are doing is a handle find, must get part of true_name
;	string from append path, part from DTA.  Messy!

	lea	si,try_dir		; buffer that has last APPEND path tried

	mov	cx,true_name_count	; get number of chars in true_name dir		  ;AN002;

copy_true_name_loop2:
	mov	ah,ds:[si]		; get byte of append dir path			  ;AN002;
	mov	es:[di],ah		; copy it to user's buffer                        ;AN002;
	inc	si			; in this loop, the null is not copied		  ;AN002;
	inc	di									  ;AN002;
	loop	copy_true_name_loop2							  ;AN002;

;	put in the "\"

	mov	ah,"\"			; get a \
	mov	es:[di],ah		; copy it
	inc	di			; increment pointer

;	we have copied the first part of the string, now get the real filename
;	from the DTA

	push	es
	push	bx

	mov	ah,get_DTA
	call	int_21
	push	es
	pop	ds
	mov	si,bx

	pop	bx
	pop	es

copy_true_name_loop3:
	mov	ah,ds:[si+30]	     ; get byte of actual filename		       ;AN002;
	mov	es:[di],ah		; copy it to user's buffer                        ;AN002;
	cmp	ah,null 		; is it a null? 				  ;AN002;
	je	true_name_copied	; yes, all done 				  ;AN002;
	inc	si			; in this loop the null is copied		  ;AN002;
	inc	di									  ;AN002;
	jmp	copy_true_name_loop3							  ;AN002;

not_hf:
	mov	si,dx			; make DS:SI point to true name

copy_true_name_loop:									  ;AN002;
	mov	ah,ds:[si]		; get byte of true name 			  ;AN002;
	mov	es:[di],ah		; copy it to user's buffer                        ;AN002;
	cmp	ah,null 		; is it a null? 				  ;AN002;
	je	true_name_copied	; yes, all done 				  ;AN002;
	inc	si									  ;AN002;
	inc	di									  ;AN002;
	jmp	copy_true_name_loop							  ;AN002;
											  ;AN002;
true_name_copied:									  ;AN002;
											  ;AN002;
no_true_name:										  ;AN002;
	restore_regs			; restore some regs				  ;AN002;
	pop	ax
											  ;AN002;
											  ;AN002;
no_more_to_try2:

	call	ctrl_break_restore	; restore normal control break address
	call	crit_err_restore	; restore normal critical error  address

;	find out if there is a need to set the extended error code

	cmp	ext_err_flag,0		; do we need to set the extended error code?
	je	no_ext_err2		; no, finish up
	lea	dx,ext_err_dpl
	call	set_ext_err_code	; yes, go set the ext error info

;	reset flags, and pack it in

no_ext_err2:
	popff
	restore_regs			; restore registers
	pushf				; put the real flags on the stack

	jmp	reset_stack		; fix stack, ret to caller

page
;-------------------------------------------------------------------
;
;	support routines for drive and path mode checking
;
;
;-------------------------------------------------------------------


check_for_drive:			; input:  ES:SI -> original string
					; output: AX = 0  no drive present
					; output: AX = -1 drive present

	xor	ax,ax			; assume no drive letter present

	cmp	es: byte ptr [si+1],':' ; is the second char a ":"?
	jne	exit_check_for_drive	; no, skip setting the flag

	mov	ax,-1			; yes, set the flag

exit_check_for_drive:

	ret

;-------------------------------------------------------------------

check_for_path: 			; input:  ES:SI -> original string
					; output: AX = 0  no path present
					; output: AX = -1 path present

	push	si			; save pointer

	xor	ax,ax			; assume no path present


;	walk the string and look for "/", or "\".  Any of these mean that a
;	path is present

walk_handle_string:

	push	ax									 ;AN006;
	mov	al,es: byte ptr [si]	; is this a dbcs char?				 ;AN006;
	call	Chk_DBCS								 ;AN006;
	pop	ax									 ;AN006;
											 ;AN006;
	jnc	no_dbcs1		; no, keep looking				 ;AN006;

	add	si,2			; yes, skip it and the next char		 ;AN006;
	jmp	walk_handle_string	; the next char could be a "\", but		 ;AN006;
					; would not mean a path was found		 ;AN006;
											 ;AN006;
no_dbcs1:										 ;AN006;
	cmp	es: byte ptr [si],"\"	; is the char a "\"?
	je	found_path		; yes, set flag and return
	cmp	es: byte ptr [si],"/"	; is the char a "/"?
	je	found_path		; yes, set flag and return
	cmp	es: byte ptr [si],0	; is the char a null
	je	exit_check_for_path	; yes, got to the end of the
					; handle string

	inc	si			; point to next char
	jmp	walk_handle_string	; and look again

found_path:
	mov	ax,-1			; yes, set the flag

exit_check_for_path:
	pop	si			; restore si
	ret

page
;-----------------------------------------------------------------------------
;	Entry point for interrupt 2f handler
;-----------------------------------------------------------------------------

intfcn_hook:
	cmp	ah,append_2f		; is this function call for append?
;;;;;;	je	do_appends						  ; @@12
	jne	ih_10							  ; @@12
	jmp	do_appends						  ; @@12
ih_10:									  ; @@12
	cmp	ah,applic_2f		; is this function call for applications
	je	do_applic
	jmp	pass_it_on

do_applic:
	cmp	dx,-1			; not COMMAND call
	jump	NE,pass_it_on
	cmp	al,0			; match name request
	jne	ck01

	mov	cmd_buf,bx		; save CMDBUF offset
	call	check_cmd_name
	jne	no_internal1
	mov	al,append_inst		; inidicate I want this command
no_internal1:
	iret

ck01:
	cmp	al,1			; match name request
	jne	ck02

;	save pointer to parser

	mov	word ptr pars_off+0,di	; ES:DI points to COMMAND.COM's parser
	mov	word ptr pars_off+2,es	; save it for later

	mov	cmd_env,bx		; save env pointer address
	call	check_cmd_name
	jne	no_internal2
	call	COMMAND_begin		; process internal command
no_internal2:
	iret

ck02:
;	cmp	al,2			; set COMMAND active	    ; @@13; @@09
;	jne	ck03						    ; @@13; @@09
;	mov	cmd_active,1					    ; @@13; @@09
;	iret							    ; @@13; @@09
ck03:								    ; @@13; @@09
;	cmp	al,3			; set COMMAND in active     ; @@13; @@09
;	jne	ck04						    ; @@13; @@09
;	mov	cmd_active,0					    ; @@13; @@09
;	iret							    ; @@13; @@09
ck04:								    ; @@13; @@09
	jmp	pass_it_on

;*******************************************************************************
;   The following old code is commented out.				    @@12
;*******************************************************************************
;check_cmd_name:			 ; see if internal APPEND
;	push	es
;	push	cs
;	pop	es
;	push	di
;	push	cx
;	push	si
;	cmp	ds:byte ptr[si],6	; length must match
;	jne	skip_comp
;	comp	append_id,6,[si+1]	; see if APPEND is command
;skip_comp:
;	pop	si
;	pop	cx
;	pop	di
;	pop	es
;	ret
;*********************************************************************
check_cmd_name: 			; See if APPEND 		    @@12
	push	ax			;				    @@12
	push	si			;				    @@12
	push	cx			;				    @@12
	push	di			;				    @@12
	push	es			;				    @@12
	mov	si,cmd_buf		; DS:SI -> cmd buf ended with cr    @@12
	add	si,2			; 1st 2 bytes garbage		    @@12
					;				    @@12
ccn_skip_leading:			;				    @@12
	lodsb				; skip leading stuff		    @@12

	call	Chk_DBCS		; find out if this is DBCS			 ;AN006;
	jnc	no_dbcs2		; no, keep looking				 ;AN006;
	lodsb				; yes, skip it and the next byte		 ;AN006;
	jmp	ccn_skip_leading	; the second byte will be skipper when		 ;AN006;
					; we go back through				 ;AN006;

no_dbcs2:										 ;AN006;
	cmp	al," "			;	blank			    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,tab_char		;	tab			    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,","			;	comma			    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,"="			;	equal			    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,";"			;	semi-colon		    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,"\"			;	back slash		    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,cr			; bad ret for early terminate	    @@12
	jne	ccn_02			;				    @@12
	cmp	al,0			;   reset z for no match	    @@12
	jmp	SHORT ccn_ret 		;				    @@12
ccn_02: 				;				    @@12
	mov	di,si			; di -> beginning of possible	    @@12
	dec	di			;	"APPEND " string	    @@12
	lodsb				;				    @@12
	cmp	al,":"			;				    @@12
	jne	ccn_cont		;				    @@12
	mov	di,si			;				    @@12
	lodsb				;				    @@12
ccn_cont:				;				    @@12
	call	Chk_DBCS								 ;AN006;
	jnc	no_dbcs3		; no, carry on					 ;AN006;
	add	si,2			; yes, skip it and the next byte		 ;AN006;
	jmp	SHORT ccn_20									 ;AN006;
											 ;AN006;
no_dbcs3:										 ;AN006;
	cmp	al,"\"			; move di up upon "\"		    @@12
	jne	ccn_20			;				    @@12
	mov	di,si			;				    @@12
ccn_10: 				;				    @@12
	lodsb				;				    @@12
	jmp	ccn_cont		;				    @@12
ccn_20: 				;				    @@12
	cmp	al," "			; look for separator		    @@12
	je	ccn_30			; if found, then have command	    @@12
	cmp	al,"="			;				    @@12
	je	ccn_30			;				    @@12
	cmp	al,cr			;				    @@12
	je	ccn_30			;				    @@12
	cmp	al,tab_char		;				    @@12
	je	ccn_30			;				    @@12
	cmp	al,","			;				    @@12
	je	ccn_30			;				    @@12
	cmp	al,";"			;				    @@12
	jne	ccn_10			;				    @@12

ccn_30: 				;				    @@12
	sub	si,di			;				    @@12
	cmp	si,7			;				    @@12
	jne	ccn_ret 		; no match			    @@12
					;				    @@12
	mov	si,di			;				    @@12
	chkchar "A"			; look for "APPEND" string	    @@12
	chkchar "P"			;				    @@12
	chkchar "P"			;				    @@12
	chkchar "E"			;				    @@12
	chkchar "N"			;				    @@12
	chkchar "D"			;				    @@12
					; exit with z set for match	    @@12
ccn_ret:				;				    @@12
	pop	es			;				    @@12
	pop	di			;				    @@12
	pop	cx			;				    @@12
	pop	si			;				    @@12
	pop	ax			;				    @@12
	ret				;				    @@12

page
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
;	do_appends							 ;AN000;
;									 ;AN000;
;	This is the INT 2F handler for the APPEND			 ;AN000;
;			  subfunction					 ;AN000;
;									 ;AN000;
;	New functions added for 3.30:					 ;AN000;
;									 ;AN000;
;									 ;AN000;
;									 ;AN000;
;	Get /X status							 ;AN000;
;									 ;AN000;
;	Input:	AX = B706						 ;AN000;
;									 ;AN000;
;	Output: BX = 0000	/X not active				 ;AN000;
;		   = 0001	/X active				 ;AN000;
;									 ;AN000;
;									 ;AN000;
;									 ;AN000;
;	Set /X status							 ;AN000;
;									 ;AN000;
;	Input:	AX = B707						 ;AN000;
;									 ;AN000;
;		BX = 0000	turn /X off				 ;AN000;
;		BX = 0001	turn /X on (active)			 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;
do_appends:
	cmp	al,are_you_there	; is the function request for presence?
	jne	ck1

	mov	al,-1			; set flag to indicate we are here
	iret				; return to user

ck1:
	cmp	al,dir_ptr		; is the function request for pointer?
	jne	ck2

	les	di,dword ptr dirlst_offset     ; return dirlist pointer to caller
	iret

ck2:
	cmp	al,get_app_version	; is the function request for version?
	jne	ck3			; no, check for next function

	mov	ax,-1			; yes, set NOT NETWORK version
	iret

ck3:
	cmp	al,tv_vector		; is the function request for TV vector?
	jne	ck4			; no, check for old dir ptr

	mov	tv_vec_seg,es		; yes, save the TV vector
	mov	tv_vec_off,di

	push	cs			; set ES:DI to tv ent pnt
	pop	es			;
	lea	di,tv_entry

	xor	byte ptr tv_flag,TV_TRUE ; set flag			  ;AN000;
	iret

ck4:					;
	cmp	al,old_dir_ptr		; is it the old dir ptr
	jne	ck5			; no, pass it on

	push	ds
	push	cs
	pop	ds

	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,1			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;

	pop	ds
	mov	al,1
	call	terminate		; exit to DOS			  ; @@05

ck5:					;
	cmp	al,DOS_version		; is it the new version check
	jne	ck6			; no, pass it on

	mov	ax,mode_flags		; set mode bits
	xor	bx,bx			; destroy registers
	xor	cx,cx
	mov	dl,byte ptr version_loc   ; major version num
	mov	dh,byte ptr version_loc+1 ; minor version num
	iret

ck6:									 ;AN000;
	cmp	al,get_state		; is it get state call? 	 ;AN001;
	jne	ck7			; no, look some more		 ;AN000;
									 ;AN000;
	mov	bx,mode_flags		; get mode bits 		 ;AN000;
	iret				; return to user		 ;AN000;
									 ;AN000;
ck7:									 ;AN000;
	cmp	al,set_state		; is it set state  call?	 ;AN001;
	jne	ck8			; no, look some more		 ;AN000;
									 ;AN000;
	mov	mode_flags,bx		; save the new state		 ;AN001;
	iret								 ;AN000;
									 ;AN000;
ck8:									 ;AN000;

	cmp	al,true_name		; is it the set true name function?		  ;AN002;
	jne	ck9			; no, look some more				  ;AN002;
											  ;AN002;
	push	ax			; save some regs				  ;AN002;
	push	bx									  ;AN002;
	push	es									  ;AN002;
	push	di									  ;AN002;
											  ;AN002;
											  ;AN002;
;	get the PSP and then get the APPEND flags byte

	mov	ah,get_PSP		; function code to get PSP address		  ;AN002;
	call	int_21			; get the PSP address				  ;AN002;
	mov	es,bx			; need to use it as a segment			  ;AN002;
	mov	di,PDB_Append		; get pointer to APPEND flag in PDB		  ;AN002;
											  ;AN002;
;	is the flag already set?

	mov	ax,es:[di]		; get APPEND flag into AX			  ;AN002;
	test	ax,true_name_flag	; is it set?					  ;AN002;
	jnz	no_set_true_name	; yes, do nothing				  ;AN002;
											  ;AN002;
;	set the true_name flag

set_true_name:										  ;AN002;
	add	ax,true_name_flag	; set true name flag				  ;AN002;
	mov	es:[di],ax		; save in PSP					  ;AN002;
											  ;AN002;
no_set_true_name:
	pop	di			; restore some regs				  ;AN002;
	pop	es									  ;AN002;
	pop	bx									  ;AN002;
	pop	ax									  ;AN002;
											  ;AN002;
	iret				; return					  ;AN002;
											  ;AN002;
ck9:											  ;AN002;

;-------------------------------------------------------------------
;	fill in additional 2F functions here
;-------------------------------------------------------------------

pass_it_on:				; the function call (ah) was not for append
	jmp	dword ptr intfcn_Offset ; jump to old INT 2f

page
;-----------------------------------------------------------------------------
;	Entry point for interrupt 24 handler
;-----------------------------------------------------------------------------

crit_err_handler:

	mov	crit_err_flag,0ffh	; set critical error flag
	mov	al,3			; fail int 21h
	iret

page
;-----------------------------------------------------------------------------
;	miscellaneous routines
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;	tv_barrier
;-----------------------------------------------------------------------------

tv_barrier:

	cmp	tv_flag,TV_TRUE 	; in Topview			 ;AN000;
	jne	no_barrier

	push	ax
	mov	ax,2002h		; wait on DOS barrier
	int	2Ah
	pop	ax
no_barrier:
	ret

;-----------------------------
;	check_config - this routine is called by both the FCB and handle open
;	code.  I checks the net_config flag to see if it is zero, if so it
;	does an installation check. If it is non-zero, nothing is done.

check_config:

	push	ax			; save a few registers
	push	bx

;	examine the config flag to see if we already know what config we have

	cmp	net_config,0
	jne	do_not_look		; we know config already

;	the flag word has not been set before,	go find out what config we have

	mov	ax,0b800h		; installation code function code
	int	2fh			; do the installation check

	mov	net_config,bx		; save flag word for later

do_not_look:
	pop	bx			;restore regs and leave
	pop	ax
	ret

;*( Chk_DBCS ) *************************************************************
;*									   *
;*  Function: Check if a specified byte is in ranges of the DBCS lead bytes*
;*  Attention: If your code is resident, comment out the lines marked	   *
;*	       ;** .							   *
;*									   *
;*  Input:								   *
;*	   AL	 = Code to be examined					   *
;*									   *
;*									   *
;*  Output:								   *
;*	   If CF is on then a lead byte of DBCS 			   *
;*									   *
;* Register:								   *
;*	   FL is used for the output, others are unchanged.		   *
;*									   *
;***************************************************************************
Chk_DBCS	PROC
	PUSH	DS
	PUSH	SI
;	CMP	CS:DBCSEV_SEG,0 	; ALREADY SET ? ;**
;	JNE	DBCS00					;**
	MOV	SI,OFFSET EVEV		; SET DEFAULT OFFSET  ;**
	PUSH	CS					      ;**
	POP	DS			; SET DEFAULT SEGMENT ;**
     PUSH    AX
	MOV	AX,6300H		; GET DBCS EV CALL
	INT	21H
	MOV	CS:DBCSEV_OFF,SI			      ;**
	MOV	CS:DBCSEV_SEG,DS			      ;**
     POP     AX
DBCS00:
	MOV	SI,CS:DBCSEV_OFF			      ;**
	MOV	DS,CS:DBCSEV_SEG			      ;**
DBCS_LOOP:
	CMP	WORD PTR [SI],0
	JE	NON_DBCS
	CMP	AL,[SI]
	JB	DBCS01
	CMP	AL,[SI+1]
	JA	DBCS01
	STC
	JMP	SHORT DBCS_EXIT
DBCS01:
	ADD	SI,2
	JMP	DBCS_LOOP
NON_DBCS:
	CLC
DBCS_EXIT:
	POP	SI
	POP	DS
	RET
Chk_DBCS	ENDP


;-----------------------------
;	append_fname - glues the fname onto the end of the dir to try

append_fname:
	push	es
	push	ds
	pop	es
	lea	di,try_dir		; destination, sort of (dir name)
	lea	si,fname		; source (filename)

;	find the end of the dir name

	mov	dbcs_fb,-1		; set flag for no dbcs first byte chars 	 ;AN006;

walk_dir_name:
	mov	al,byte ptr [di]	; get a char from dir name
	cmp	al,null 		; are we at the end?
	je	end_of_dir		; yes, add on the fname

	call	Chk_DBCS		; char is in al 				 ;AN006;
	jnc	no_dbcs4		; no, keep looking				 ;AN006;
	mov	dbcs_fb,di		; save offset					 ;AN006;
	inc	di			; skip second byte

no_dbcs4:
	inc	di			; no, keep stepping
	jmp	walk_dir_name

;	now it is time to append the filename

end_of_dir:
	mov	al,byte ptr [di-1]	; get last char of dir name
	cmp	al,"\"			; is it a dir seperator?
	jne	check_next_dir_sep	; no, check the next dir sep char		 ;AN006;
											 ;AN006;
	sub	di,2			; yes, must find out if real dir sep		 ;AN006;
					; or DBCS second byte				 ;AN006;
	cmp	dbcs_fb,di		; is the char before our dir sep a DBCS 	 ;AN006;
					; first byte?					 ;AN006;
	jne	no_dbcs4a		; no, must check for the next dir sep		 ;AN006;
					; yes, this means we must put in a dir sep	 ;AN006;
	add	di,2			; restore di					 ;AN006;
	jmp	SHORT put_in_dir_sep	; put int the dir sep char			 ;AN006;
											 ;AN006;
no_dbcs4a:										 ;AN006;
	add	di,1			; restore di, then check next dir sep		 ;AN006;

check_next_dir_sep:
	cmp	al,"/"			; is it the other dir seperator?
	je	add_fname		; yes, no need to add one
put_in_dir_sep: 									 ;AN006;
	mov	al,"\"			; get dir seperator
	stosb				; add to end of dir

add_fname:
	lodsb				; get a char from fname
	stosb				; copy the char
	cmp	al,null 		; are we at the and of the filename?
	je	eo_name 		; yes, all done!
	jmp	add_fname







eo_name:
	pop	es
	ret


;-----------------------------
;	get_fname strips out the 8.3 filename from the original ASCIIZ string
;
;	INPUT:	ES:SI points to original string
;		DS:DI points to area for filename

get_fname:

	mov	bx,si			; save the pointer
	mov	dbcs_fb,-1		; set the dbcs flag off 			 ;AN006;

gfn1:
	mov	ah,ES:byte ptr [si]	; get a char from the source
	cmp	ah,null 		; is it a null?
	je	got_the_end		; yes, we found the end

	call	chk_dbcs		; is this char a DBCS first byte?		 ;AN006;
	jnc	no_dbcs5		; no, carry on
	mov	dbcs_fb,si		; yes, save pointer
	inc	si			; skip second byte

no_dbcs5:
	inc	si			; no, point to next char
	jmp	gfn1			; loop till end found

got_the_end:
	mov	ah,ES:byte ptr [si]	; get a char
	cmp	ah,"/"			; did we find a /
	je	went_too_far		; yes, we found the start
	cmp	ah,"\"			; did we find a \
	je	found_bslash		; yes, we found the start			 ;AN006;
	cmp	ah,":"			; did we find a :
	je	went_too_far		; yes, we found the start
	cmp	si,bx			; are we back to the original start?
	je	got_the_beg		; yes, we found the start of the fname
	dec	si			; step back a char, then look some more
	jmp	got_the_end

found_bslash:				; found a backslash, must figure out if 	 ;AN006;
					; is second byte of DBCS			 ;AN006;
	dec	si			; point to next char				 ;AN006;
	cmp	si,dbcs_fb		; do they match?
	jne	no_dbcs5a		; no, fix up si and carry on			 ;AN006;
	dec	si			; skip dbcs byte and loop some more		 ;AN006;
	jmp	got_the_end								 ;AN006;

no_dbcs5a:										 ;AN006;
	inc	si			; went too far by one extra			 ;AN006;
											 ;AN006;
went_too_far:
	inc	si			; went one char too far back

;	ES:SI now points to the beginning of the filename

got_the_beg:
	mov	ah,ES:byte ptr [si]	; get a char from the source
	mov	byte ptr [di],ah	; copy to dest
	cmp	ah,null 		; did we just copy the end?
	je	done_with_fname 	; yes, all done
	inc	si			; no, get the next char
	inc	di
	cmp	di,offset app_dirs_ptr	; make sure we dont try to copy past the
	je	done_with_fname 	; area
	jmp	got_the_beg

done_with_fname:
	ret

;-----------------------------
;	this code executed to return to caller after APPEND's stack has been
;	initialized

reset_stack:

;	reset the stack 								  ;AN002;

	popff				; restore flags from real open
	mov	ss,Stack_Segment	; Get original stack segment
	mov	sp,Stack_Offset 	; Get original stack pointer
	pushf				; put the flags on the old stack


;-----------------------------
;	before jumping to this routine, SS:SP must point to the caller's stack,
;	and the flags from the real INT 21 operation must have been pushed

set_return_flags:

;	must be sure to clear the true_name flag before leaving 			  ;AN002;
											  ;AN002;
	push	ax			; save some regs				  ;AN002;
	push	bx									  ;AN002;
	push	es									  ;AN002;
	push	di									  ;AN002;
											  ;AN002;
	mov	ah,get_PSP		; function code for get PSP operation		  ;AN002;
	call	int_21			; get the PSP, segment returned in BX		  ;AN002;
	mov	es,bx			; need to use it as a segment			  ;AN002;
	mov	di,PDB_Append		; get pointer to APPEND flag in PDB		  ;AN002;
											  ;AN002;
	mov	ax,es:[di]		; get APPEND flag into AX			  ;AN002;
	test	ax,true_name_flag	; is true name flag armed?			  ;AN002;
	jz	reset_stack2		; no, don't copy true name                        ;AN002;
											  ;AN002;
	sub	ax,true_name_flag	; clear true name flag				  ;AN002;
	mov	es:[di],ax		; save it in PSP				  ;AN002;
											  ;AN002;
											  ;AN002;
reset_stack2:										  ;AN002;
											  ;AN002;
	pop	di			; restore					  ;AN002;
	pop	es									  ;AN002;
	pop	bx									  ;AN002;
	pop	ax									  ;AN002;
											  ;AN002;
	cmp	tv_flag,TV_TRUE 					 ;AN000;
	jne	tv_flag_not_set

	mov	ax,2003h		; clear open barrier
	int	2Ah


;	pop down to the old flags on the user's stack

tv_flag_not_set:

	cmp	incoming_AX,exec_proc*256+0	; need to do exec
	jne	not_exec3
	popff				; discard bad flags
	mov	ax,incoming_AX		; set exec parms

	push	ds			; save DS, this must be done					;an005;
					; to pervent DS from being trashed on return to caller		;an005;

	push	cs
	pop	ds
	lea	dx,try_dir
	mov	bx,incoming_BX
	mov	es,incoming_ES
	call	int_21			; issue the exec

	pop	ds			; restore DS							; an005;

	pushf

not_exec3:
	popff				; get flags from real int 21 (old stack)
	pop	temp_IP_save		; save IP, CS
	pop	temp_CS_save
	lahf				; save flags in AH
	popff				; pop old flags off stack
	sahf				; replace old with new

;	push the new flags onto the stack, then fix CS and IP on stack

	pushf				; push new flags onto stack
	push	temp_CS_save		; restore IP, CS
	push	temp_IP_save
	mov	ax,AX_after_21		; Set AX as it was after open

	call	crit_sect_reset 	; clear the critical section flag
	iret				; return to the calling routine


;-----------------------------
;	This routine is used to extract an appended dir from the dir list
;	On entry, DS:DI points to an area for the appended dir
;	and ES:SI points to the source string

get_app_dir:

	xor	cx,cx			; keep a count of chars in cx			  ;AN003;
copy_dir:
	mov	ah,es:byte ptr [si]	; get the char, and copy it into dest
	cmp	ah,null 		; find a null?
	je	no_more_dirs		; yes, inform caller that this is the last one

	cmp	ah,";"			; check to see if we are at the end of a dir
	je	update_pointer		; yes,

	mov	byte ptr [di],ah	; if not null or semi-colon, then copy it
	inc	si			; increment both pointers
	inc	di
	inc	cx			; count of chars				  ;AN003;
	jmp	copy_dir		; do it some more

update_pointer:
	inc	si			; point to next char
	mov	ah,es:byte ptr [si]	; get char			  ; @@16
	cmp	ah,null 		; did we reach the end of the dir list?
	je	no_more_dirs		;

	cmp	ah,";"			; is is a semi-colon
	je	update_pointer
	jmp	SHORT  all_done


no_more_dirs:
	xor	si,si			; set end search flag

all_done:
	mov	byte ptr [di],null	; null terminate destination
	ret				; return to caller

;-----------------------------
;	set ctrl-break check off
;	first, save the old state so we can restore it later,
;	then turn ctrl-break checking off

ctrl_break_set:

	mov	ah,ctrl_break		; function code for ctrl-break check
	xor	al,al			; 0 = get current state
	call	int_21			; call DOS INT 21 handler

	mov	ctrl_break_state,dl	; save the old ctrl-break state

	mov	ah,ctrl_break		; function code for ctrl-break check
	mov	al,01			; set current state
	xor	dl,dl			; 0 = off
	call	int_21			; call DOS INT 21 handler
	ret


;-----------------------------
;	restore ctrl-break checking flag to the way it was
ctrl_break_restore:
	mov	ah,ctrl_break		; function code for ctrl-break check
	mov	al,01			; set current state
	mov	dl,ctrl_break_state	; get the way is was before we messed with it
	call	int_21			; call DOS INT 21 handler
	ret

;-----------------------------
;	restore ctrl-break checking flag to the way it was
ctrl_break_rest:
	mov	ah,ctrl_break		; function code for ctrl-break check
	mov	al,01			; set current state
	mov	dl,ctrl_break_state	; get the way is was before we messed with it
	call	int_21
	ret

;-----------------------------
;
crit_err_set:
	mov	crit_err_flag,0 	; clear the critical error flag

	mov	ax,get_crit_err 	; Get INT 24h vector
	call	int_21			; call DOS INT 21 handler

	mov	crit_vector_offset,bx	; Save it
	mov	ax,es			; es hase segment for resident code
	mov	crit_vector_segment,ax

	lea	dx,crit_err_handler	; DS:DX = New INT 21h vector
	mov	ax,set_crit_err 	; function code for setting critical error vector
	call	int_21			; call DOS INT 21 handler
	ret				; go back to the caller


;-----------------------------
;
crit_err_restore:
	push	ds			; save ds for this function
	mov	ax,set_crit_err 	; function code for setting critical error vector
	mov	dx,crit_vector_offset	; get old int 24 offset
	mov	ds,crit_vector_segment	; get old int 24 segment
	call	int_21			; call INT 21
	pop	ds
	ret

;-----------------------------
;	crit_sect_set - issues an enque request to the server to protect
;	against reentry.  This request is issued only if the network is started,
;	and then, only for RCV, MSG, and SRV configurations
crit_sect_set:
	push	ax
	push	bx
	push	di
	push	es

	mov	ax,net_config		; check the server config flag
	cmp	ax,0			; is it zero?
	je	dont_set_crit_sect	; yes, skip it

	cmp	ax,redir_flag		; is it a redir?
	je	dont_set_crit_sect	; yes, skip it
					; otherwise, issue the request

;	the config flag was not zero or redir, so set crit section

	mov	ah,NETSYSUTIL
	mov	al,NETENQ
	mov	bx,TCBR_APPEND
	int	2Ah

dont_set_crit_sect:			; because of the config we don't want
	pop	es			; to set critical section
	pop	di
	pop	bx
	pop	ax
	ret

;-----------------------------
;
crit_sect_reset:
	push	ax
	push	bx

	mov	ax,net_config		; check the server config flag
	cmp	ax,0			; is it zero?
	je	not_set 		; yes, skip it

	cmp	ax,redir_flag		; is it a redir?
	je	not_set 		; yes, skip it

	mov	ah,NETSYSUTIL		; turn critical section off
	mov	al,NETDEQ
	mov	bx,TCBR_APPEND
	int	2Ah

not_set:
	pop	bx
	pop	ax
	ret


;-----------------------------
;	save_first_ext_err - this routine is used to save the extended
;		error info after the first FCB open.
save_first_ext_err:

	push	ax

	mov	ax,ext_err_dpl.DPL_AX		; copy all registers
	mov	save_ext_err.DPL_AX,ax
	mov	ax,ext_err_dpl.DPL_BX
	mov	save_ext_err.DPL_BX,ax
	mov	ax,ext_err_dpl.DPL_CX
	mov	save_ext_err.DPL_CX,ax
	mov	ax,ext_err_dpl.DPL_DX
	mov	save_ext_err.DPL_DX,ax
	mov	ax,ext_err_dpl.DPL_SI
	mov	save_ext_err.DPL_SI,ax
	mov	ax,ext_err_dpl.DPL_DI
	mov	save_ext_err.DPL_DI,ax
	mov	ax,ext_err_dpl.DPL_DS
	mov	save_ext_err.DPL_DS,ax
	mov	ax,ext_err_dpl.DPL_ES
	mov	save_ext_err.DPL_ES,ax

	pop	ax
	ret

;-----------------------------
;	get_ext_err_code - this routine is used to get the extended error
;		info for the error that cause append to start its search

get_ext_err_code:
	push	ax			; save register that are changed by this
	push	bx			; DOS function
	push	cx
	push	di
	push	si
	push	es
	push	ds

;	get the extended error information

	mov	ah,59h			; function code for get extended error
	xor	bx,bx			; version number
	call	int_21			; get the extended error

;	save it away in a DPL for set_ext_error_code
;	all fields in the DPL will be filled in except the last three,
;	which will be left at zero

	mov	ext_err_dpl.DPL_AX,ax
	mov	ext_err_dpl.DPL_BX,bx
	mov	ext_err_dpl.DPL_CX,cx
	mov	ext_err_dpl.DPL_DX,dx
	mov	ext_err_dpl.DPL_SI,si
	mov	ext_err_dpl.DPL_DI,di
	mov	ext_err_dpl.DPL_DS,ds
	mov	ext_err_dpl.DPL_ES,es


;	restore regs and return

	pop	ds
	pop	es			; restore registers
	pop	si
	pop	di
	pop	cx
	pop	bx
	pop	ax
	ret

;-----------------------------
;	set_ext_err_code - this routine is used to get the extended error
;		info for the error that cause append to start its search
;		CS:DX points to return list
set_ext_err_code:
	push	ax			; save register that are changed by this
	push	ds			; DOS function

;	get the extended error information

	mov	ah,DOSSERVER		; function code for DOSSERVER call
	mov	al,DOSSETERROR		; sub-function code for set extended error
	push	cs
	pop	ds
	call	int_21			; set the extended error

;	restore regs and return

	pop	ds			; restore registers
	pop	ax
	ret
page
;-----------------------------
;	This routine is used to initiate DOS calls from within the APPEND interrupt
;	handlers.  An INT instruction can not be used because it would cause APPEND
;	to be re-entered.
;
;	SS, SP saved incase call is EXEC which blows them away
int_21: 				;
	cmp	tv_flag,TV_TRUE 	; see if being re-entered	 ;AN000;
	jne	use_old_vec		; yes, pass through to DOS

	pushf				; to comp for iret pops
	call	dword ptr tv_vec_off	; Call INT 21h
	ret				;

use_old_vec:
	cmp	vector_segment,0	; not installed yet
	je	use_int

	pushf				;  to comp for iret pops
	call	dword ptr vector_offset ; Call INT 21h
	ret				;

use_int:
	int	DOS_function
	ret
page
;-----------------------------
;	This routine is used to locate the current APPEND path string
;	result to ES:DI

address_path:
address_status: 							  ; @@13
	test	mode_flags,E_mode
	jnz	get_env_mode

address_pathx:
	mov	ax,append_2f*256+dir_ptr	; get from buffer
	int	int_function
	clc
	ret

get_env_mode:					; get from environment
;	cmp	cmd_active,0			; different logic   ; @@13; @@09
;	jne	use_cmd_env			; if in COMMAND     ; @@13; @@09
	push	bx
	mov	ah,get_PSP
	call	int_21				; get the PSP
	mov	es,bx
	mov	bx,002ch			; address environment
	mov	ax,es:word ptr[bx]
	mov	es,ax
	pop	bx
	cmp	ax,0				; PSP pointer is set
	je	address_pathx						  ; @@13
use_cmd_env:								  ; @@13
;	cmp	cmd_env,0			; have not set my pointer yet
;	je	address_pathx						  ; @@13
;	mov	es,cmd_env						  ; @@13
env_mode1:
	mov	di,0				; start at start
	cmp	es:byte ptr[di],0		; no environment
	je	no_appendeq
find_append:
	cmp	es:word ptr[di],0		; at environment end
	je	no_appendeq
	push	di
	push	si
	push	cx
	push	ds
	push	cs
	pop	ds
	comp	,6+1,append_id			; string = "APPEND="
	pop	ds
	pop	cx
	pop	si
	pop	di
	je	at_appendeq
	inc	di
	jmp	find_append
at_appendeq:					; must insure this is	    @@17
	cmp	di,0				; genuine "APPEND=" string  @@17
	je	at_appendeq_genuine		; if start of environ ok    @@17
	dec	di				; else check that 0	    @@17
	cmp	es:byte ptr[di],0		;      precedes string	    @@17
	je	at_appendeq_10			; jmp if ok		    @@17
	add	di,8				; else cont.search after    @@17
	jmp	find_append			;      "="		    @@17
at_appendeq_10: 				;			    @@17
	inc	di				;			    @@17
at_appendeq_genuine:				;			    @@17
	add	di,6+1				; skip APPEND=
	cmp	es:byte ptr[di],0		; null value
	je	no_appendeq			; treat as not found
	cmp	es:byte ptr[di]," "
	je	no_appendeq
	cmp	es:byte ptr[di],";"
	je	no_appendeq
	clc					; set ok
	ret

no_appendeq:					; not found, use default
	lea	di,semicolon			; null list
	push	cs
	pop	es
	stc					; set error
	ret

;-----------------------------						  ; @@03
;	This routine is used to locate the current APPEND path string	  ; @@03
;	result to ES:DI.  Used by APPEND status.			  ; @@03

;address_status:						    ; @@13; @@03
;	test	mode_flags,E_mode				    ; @@13; @@03
;	jump	Z,address_pathx 				    ; @@13; @@03
;	jmp	use_cmd_env					    ; @@13; @@03

cap_dl: 					; convert dl to uppercase
	cmp	dl,"a"			; find out if we have a lower case; @@14
	jb	cap_dlx 		; char				  ; @@14
	cmp	dl,"z"							  ; @@14
	ja	cap_dlx 						  ; @@14
	sub	dl,"a"-"A"		; convert char to upper case	  ; @@14
cap_dlx:
	ret

;	end_address:				; this is the end of the TSR stuff		 ;AN002;

page
;-----------------------------------------------------------------------------
;	Main routine. Used to determine if APPEND has been loaded
;	before. If not, load resident portion of APPEND. Then handle setting
;	or displaying appended directory list.
;-----------------------------------------------------------------------------

main_begin:				; DOS entry point

	mov	ax,seg mystack		; set up stack
	mov	ss,ax
	lea	sp,mystack

	cld

	mov	res_append,0		; set external copy		  ; @@05

	push	cs			; make DS point to CS
	pop	ds

	push	cs			; make ES point to CS
	pop	es


;	find out if append has been loaded				  ; @@04
									  ; @@04
	mov	ah,append_2f		; int 2f function code for append ; @@04
	mov	al,are_you_there	; function code to ask if append  ; @@04
					; has been loaded		  ; @@04
	int	int_function						  ; @@04
									  ; @@04
	cmp	al,append_inst		; is append there?		  ; @@04
	jne	not_there_yet		; no				  ; @@04

	mov	dx,0			; set for network version	  ; @@07
	mov	ah,append_2f		; int 2F function code for append ; @@07
	mov	al,DOS_version		; function code for get version   ; @@07
	int	int_function						  ; @@07
	cmp	dx,word ptr version_loc ; does the version match?	  ; @@07
	jne	bad_append_ver		; no, cough up an error messsage  ; @@07


	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,9			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;
;	mov	cx,len_second_APPEND_msg; length of string		 ;AN000;   ; @@04
;	lea	dx,second_APPEND_msg	; second load message		 ;AN000;   ; @@04
;	call	print_STDERR		; display error message 	 ;AN000;   ; @@04
;	lea	dx,crlf 		; carriage return, line feed	  ; @@04
;	mov	cx,crlf_len		; length of string		  ; @@04
;	call	print_STDERR						  ; @@04
									  ; @@04
	mov	al,0fch 		; second load			  ; @@05
	call	terminate		; exit to DOS			  ; @@05

bad_append_ver: 			; append version mismatch	  ; @@07
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,1			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;
;	mov	cx,len_bad_append_msg					 ;AN000;   ; @@07
;	lea	dx,bad_append_msg	; bad app message		 ;AN000;   ; @@07
;	call	print_STDERR						 ;AN000;   ; @@07
;	lea	dx,crlf 		; carriage return, line feed	  ; @@07
;	mov	cx,crlf_len		; length of string		  ; @@07
;	call	print_STDERR						  ; @@07
	mov	ax,0feh 		; bad APPEND version		  ; @@05
	call	terminate		; exit to DOS			  ; @@05

not_there_yet:								  ; @@04

	mov	cs:initial_pass,-1	; set a flag for initial pass			 ;AN007;
	call	do_command		; do actual APPEND

	mov	bx,4			; close all standard files
do_closes:
	mov	ah,3eh			; close file handle
	call	int_21
	dec	bx
	jns	do_closes

	call	set_vectors		; set append vectors on success   ; @@05

	call	Release_Environment	; release the environmental vector space	;an007; dms;

	lea	dx,end_address+15	; normal end
	mov	cl,4			; calc end address in paragraphs
	shr	dx,cl
	mov	ah,get_PSP		; calc space from PSP to my code  ; @@02
	call	int_21							  ; @@02
	mov	ax,cs							  ; @@02
	sub	ax,bx							  ; @@02
	add	dx,ax			; calc length to keep		  ; @@02
	mov	al,0			; exit with no error
	mov	ah,term_stay
	call	int_21

page

COMMAND_begin:				; COMMAND entry point
	save_regs
	mov	word ptr cmd_name@+0,si  ; save internal command buffer @
	mov	word ptr cmd_name@+2,ds
	cld

	mov	abort_sp,sp		; save sp for aborts		  ; @@05
	mov	res_append,1		; set resident copy		  ; @@05
	call	do_command		; do actual APPEND
abort_exit:				; exit to abort append		  ; @@05
	mov	sp,abort_sp						  ; @@05

	push	es
	push	di
	les	di,cmd_name@
	mov	es:byte ptr[di],0	; set no command now
	pop	di
	pop	es

	cmp	ax,0			; error
	jne	no_E_mode_via
	test	mode_flags,E_mode	; no /E processing
	jz	no_E_mode_via

	mov	ax,append_2f*256+dir_ptr; int 2f function code for append
	int	int_function
	push	es
	pop	ds
	mov	si,di

;	mov	ah,get_PSP		; set new command
;	call	int_21
	mov	bx,ss
	mov	es,bx
	mov	bx,cmd_buf		; command line iput buffer
	inc	bx			; skip max length
	mov	es:byte ptr[bx],3+1+6+1
	mov	di,bx			; address command line buffer
	inc	di			; skip current length
	push	ds
	push	si
	push	cs
	pop	ds
	move	,3+1+6+1,setappend_name ; set in "SET APPEND="
	pop	si
	pop	ds
	cmp	ds:byte ptr[si],";"	; null list is special case
	jne	copy_path
append_blank:
	mov	al," "
	stosb
	inc	es:byte ptr[bx]
	jmp	short copy_path_done
no_E_mode_via:
	jmp	short no_E_mode
copy_path:
	mov	dl, byte ptr es:[bx-1]	; get max len of command buffer
	sub	dl, 3+1+6+1		; take care of 'SET APPEND='
;
;------ now find the strlen of path string pointed by ds:si
;
;	REPLACE WITH BETTER CODE LATER --- mohan
;
	push	si			; save ptr to paths
	xor	cx, cx
count_next_char:
	lodsb
	or	al, al
	jz	check_len
	inc	cx
	jmp	count_next_char
null_path:
	pop	si
	jmp	append_blank
check_len:
	pop	si
;
;------ check whether the length is ok
;
	cmp	cl, dl			; len < maxlen ?
	jb	copy_it
	push	si
	add	si, cx			; point to end of path str
next_char:
	jcxz	null_path		; null str ?
	dec	cl
	dec	si
	cmp	byte ptr ds:[si], ';'
	jne	next_char
	cmp	cl, dl			; found ';' but is len ok?
	jae	next_char
	pop	si
	add	byte ptr es:[bx], cl
copy_it:
	rep	movsb
;
;------ The code in this box replaced by code below copy_path:------------
;	 lodsb								;
;	 cmp	 al,0							;
;	 je	 copy_path_done 					;
;	 stosb								;
;	 inc	 es:byte ptr[bx]					;
;	 jmp	 copy_path						;
;--------------------------------------------------------------------------
copy_path_done:
	mov	es:byte ptr[di],cr	; set end delimiter

	les	di,cmd_name@
	mov	al,3			; SET length
	stosb
	push	cs							  ; @@06
	pop	ds							  ; @@06
	move	,8,set_name		; set up "SET" command

	mov	ax,0			; set to do SET
no_E_mode:

	restore_regs
	ret

page

do_command:				; APPEND process

;	set ctrl-break check off
;	first, save the old state so we can restore it later,
;	then turn ctrl-break checking off

	mov	ah,ctrl_break		; function code for ctrl-break check
	xor	al,al			; 0 = get current state
	call	int_21

	mov	ctrl_break_state,dl	; save the old ctrl-break state

	mov	ah,ctrl_break		; function code for ctrl-break check
	mov	al,01			; set current state
	xor	dl,dl			; 0 = off
	call	int_21

;	find out if append has been loaded

	mov	ah,append_2f		; int 2f function code for append
	mov	al,are_you_there	; function code to ask if append
					; has been loaded
	int	int_function

	cmp	al,append_inst		; is append there?
	jne	not_already_there	; yes, don't try to put it
	jmp	already_there		; yes, don't try to put it
					; there again

;	get DOS version and decide if it is in the allowed range for
;	APPEND

not_already_there:
	mov	ah,get_version		; lets find out if we should do it
	call	int_21			; try the open
	cmp	ax,expected_version	; compare with DOS version
	jne	bad_DOS

	jmp	SHORT check_assign	; valid range
					; lets see if assign has been loaded

;	Break it to the user that he's trying to do an APPEND with
;	the wrong DOS version

bad_DOS:
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,8			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;

;	mov	cx,len_bad_DOS_msg	; length of string		 ;AN000;
;	lea	dx,bad_DOS_msg		; bad DOS message		 ;AN000;
;	call	print_STDERR		; display error message 	 ;AN000;

	call	ctrl_break_rest
	mov	al,0ffh 		; bad DOS version		  ; @@05
	call	terminate		; exit to DOS			  ; @@05

check_assign:
	mov	ax,0600h
	int	2fh
	or	al,al
	jnz	assign_there
	jmp	SHORT check_TopView	; ASSIGN has not been loaded,	  ; @@01

;	ASSIGN has been loaded before APPEND, bad news!

assign_there:
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,6			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;

;	mov	cx,len_append_assign_msg; length of string
;	lea	dx,append_assign_msg
;	call	print_STDERR		; display error message
	jmp	SHORT conflict_exit						  ; @@01
									  ; @@01
check_Topview:								  ; @@01
	mov	bx,0			; incase not there		  ; @@01
if	not MSVER			; MSKK02 07/14/89
	mov	ax,10h*256+34		; TopView version check 	  ; @@01
	int	15h							  ; @@01
endif
	cmp	bx,0							  ; @@01
	jnz	TopView_there						  ; @@01
	jmp	replace_vector		; TopView has not been loaded,	  ; @@01
									  ; @@01
;	TopView has been loaded before APPEND, bad news!		  ; @@01
									  ; @@01
TopView_there:								  ; @@01
;	mov	cx,len_append_TV_msg	; length of string		  ; @@01
;	lea	dx,append_TV_msg					  ; @@01
;	call	print_STDERR		; display error message 	  ; @@01
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,7			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;

									  ; @@01
conflict_exit:								  ; @@01
	call	ctrl_break_rest
	mov	al,0fdh 						  ; @@05
	call	terminate		; exit to DOS			  ; @@05

;	get pointer to dir list, on return ES:DI points to buffer

already_there:

;	This code has been moved to main_begin				  ; @@07
;									  ; @@07
;	make sure the right version of APPEND has been loaded		  ; @@07
;

;	mov	dx,0			; set for network version	  ; @@07
;	mov	ah,append_2f		; int 2F function code for append ; @@07
;	mov	al,DOS_version		; function code for get version   ; @@07
;	int	int_function						  ; @@07
;	cmp	dx,word ptr version_loc ; does the version match?	  ; @@07
;	jump	NE,bad_append_ver	; no, cough up an error messsage  ; @@07

process_args:				; process all arguments

;-------------------------------------------------------------------
	mov	si,0081h		; DS:SI points to argument area
	mov	cs:byte ptr e_switch+9,0	; turn /E switch off

process_argsx:				; process all arguments
;


;	make sure that the /PATH and /X switches are re-enabled, and
;	various flags are cleared

	xor	cx,cx			; ordinal value, must start as 0
	xor	dx,dx			; these regs must be 0 for call to Scan_For_Equal

	mov	ah,"/"
	mov	cs:byte ptr x_switch+9,ah		; re-enable /X switch
	mov	cs:byte ptr path_switch+9,ah		; re-enable /PATH switch
	mov	cs:byte ptr x_result.$P_Type,cl 	; clear flag
	mov	cs:byte ptr path_result.$P_Type,cl	; clear flag
	mov	cs:byte ptr dirs_result.$P_Type,cl	; clear flag
	mov	cs:parse_flag,cl			; clear parse flag

;	set up things to call PARSER

	push	cs			; make sure ES points to segment where
	pop	es			; parm block info is
	lea	di,cs:p_block2		; ES:DI points to parm block, for secondary parsing

;
;	Note CX and DX, cleared above, must stay cleared for this call

	call	Scan_For_Equal		; yes - let's see if we have "=" symbol ;an008; dms;
					; parse past it if we do

get_pars_info:
	call	dword ptr pars_off	; call to COMMAND.COM's parser

	or	ax,ax			; end of line?	-1 if yes
	jns	not_end_of_line 	; no, carry on
	jmp	end_of_line_reached	; yes, go figure out what we got

not_end_of_line:

	or	ax,ax			; no, find out if there an error
	je	not_parse_error 	; no, carry on
	jmp	parse_error		; yes, go display the error message

;	got here without any errors, set the proper bits in mode_flags

not_parse_error:
	mov	cs: parse_flag,0ffh	; set parse flag

check_e:
	cmp	e_result.$P_Type,3	; was there a /E in this pass?
	jne	check_? 		; no, look for an ?

	mov	byte ptr e_switch+9,0	; turn this off so we don't allow another
	mov	e_result.$P_Type,0	; clear this so we don't get fooled later

	or	mode_flags,E_mode	; set E mode on

	jmp	get_pars_info		; go get another argument


check_?:
	cmp	qu_result.$P_Type,3
	jne	check_x
	mov	qu_result.$P_Type,0	; clear this so we don't get fooled later
	call	sysloadmsg				
						
	mov	ax,MSG_OPTIONS_FIRST
p_n:	cmp	ax,MSG_OPTIONS_LAST
	jg 	end_?
	mov	bx,STDOUT		; no handle	
	xor	cx,cx			; sub count	
	xor	dl,dl			; no input	
	mov	dh,-1			; message class 
	call	sysdispmsg				
	inc	ax                      ; sysdispmsg does NOT trash ax
	jmp	short  p_n

end_?:	xor	ax,ax                   ; return normal exit code
	call	ctrl_break_rest
	call    terminate	

check_x:
	cmp	x_result.$P_Type,3	; was there a /X on this pass? list index
	je	set_x			; yes, and it was /X w/o ON or OFF

	cmp	x_result.$P_Type,2	; was there a /X on this pass? list index
	jne	check_path

	mov	byte ptr x_switch+9,0	; turn this off so we don't allow  another
	mov	x_result.$P_Type,0	; clear this so we don't get fooled later

	cmp	x_result.$P_Item_Tag,1	; was /X or /X:ON specified?
	je	set_x			; yes, set X mode on
	and	mode_flags,NOT x_mode	; no, clear it
	jmp	get_pars_info

set_x:
	or	mode_flags,x_mode
	jmp	get_pars_info

check_path:
	cmp	path_result.$P_Type,2	; was there a /path on this pass? list index
	jne	check_dirs

	xor	ah,ah			; turn this off so we don't allow
	mov	byte ptr path_switch+9,ah	 ; another
	mov	path_result.$P_Type,0	; clear this so we don't get fooled later


	cmp	path_result.$P_Item_Tag,1	; was /PATH:ON specified?
	je	set_path			; yes, set PATH mode
	and	mode_flags,NOT path_mode	; no, clear it
	jmp	get_pars_info

set_path:
	or	mode_flags,path_mode	; set PATH mode on
	jmp	get_pars_info

;	find out if dirs specified

check_dirs:
	cmp	dirs_result.$P_Type,3	; was a simple string returned?
	je	check_dirs2		; yes, carry on
	jmp	get_pars_info		; no, all done for now

;	set up stuff to do the dirs copy

check_dirs2:
	push	es
	push	ds
	push	si
	push	di

	lds	si,dword ptr dirs_result.$P_Picked_Val	  ; get pointer to dirs string
	mov	dirs_result.$P_Type,0	; clear this so we don't get fooled later

	mov	di,0			; set incase int 2f not installed ; @@08
	mov	es,di							  ; @@08
	mov	ax,append_2f*256+dir_ptr  ; es:di -> internal result area ; @@08
	int	int_function						  ; @@08
	mov	ax,es			; see if active yet		  ; @@08
	or	ax,di							  ; @@08
	jnz	copy_dirs_loop		; ok, do the copy		  ; @@08
	push	cs			; not active, set myself	  ; @@08
	pop	es							  ; @@08
	lea	di,app_dirs						  ; @@08

copy_dirs_loop:
	movs	es: byte ptr[di],ds:[si]; copy char

	cmp	byte ptr ds:[si-1],0	; is char a null
	je	done_copy_dirs

	jmp	copy_dirs_loop

done_copy_dirs:

	pop	di
	pop	si
	pop	ds
	pop	es

	jmp	get_pars_info		; no error yet, loop till done

end_of_line_reached:
	mov	old_syntax,0		; process old format operands

	cmp	cs:initial_pass,-1	; is this the first APPEND			 ;AN006;
	je	first_one		; yes, clear flag and exit			 ;AN006;

	cmp	cs:parse_flag,0 	; if this flag is off, means null command line
					; was nothing on the command line
	je	display_dirs		; go display the dirs

first_one:										 ;AN006;
	mov	cs:initial_pass,0	; clear first pass flag 			 ;AN006;

done_for_now:
normal_exit:
	call	ctrl_break_rest 	; reset control break checking
	mov	ax,0			; set string
	ret				; exit to COMMAND


parse_error:
	push	ax			;save parser error code 		;an010;bgb
	call	sysloadmsg						 ;AN000;
	pop	ax			;restore parser error coed		;an010;bgb
	call	do_parse_err							;an010;bgb
	jmp	SHORT bad_parmx		; display message and get out

;-------------------------------------------------------------------

;	 mov	 si,0081h		 ; point si to argument area
;	 mov	 bx,ss
;	 mov	 ds,bx
;
;process_argsx: 			 ; process all arguments
;	 mov	 di,0			 ; set incase int 2f not installed ; @@08
;	 mov	 es,di							   ; @@08
;	 mov	 ax,append_2f*256+dir_ptr  ; es:di -> internal result area ; @@08
;	 int	 int_function						   ; @@08
;	 mov	 ax,es			 ; see if active yet		   ; @@08
;	 or	 ax,di							   ; @@08
;	 jnz	 have_ptr						   ; @@08
;	 push	 cs			 ; not active, set myself	   ; @@08
;	 pop	 es							   ; @@08
;	 lea	 di,app_dirs						   ; @@08
;have_ptr:								   ; @@08
;
;;	 step through the DOS command line argument area, and copy the new dir
;;	 list to the proper place in APPEND. This requires some parsing for
;;	 spaces, tabs chars, equal signs, as well as conversion to upper case
;
;	 cmp	 byte ptr[si],"="	 ; APPEND=path is OK syntax
;	 jne	 skip_leading
;	 inc	 si
;skip_leading:				 ; skip leading spaces
;	 lodsb
;	 cmp	 al," "
;	 je	 skip_leading
;	 cmp	 al,tab_char
;	 je	 skip_leading
;	 cmp	 al,"," 						   ; @@15
;	 je	 skip_leading						   ; @@15
;	 cmp	 al,"=" 						   ; @@15
;	 je	 skip_leading						   ; @@15
;	 cmp	 al,cr			 ; did we have command line arguments?
;	 jump	 E,display_dirs 	 ; no, display the dirs currently appended
;	 cmp	 al,"/" 		 ; is it a parm starter?	   ; @@05
;	 jump	 E,bad_path_parm	 ; yes, it's an error              ; @@05
;	 dec	 si
;
;copy_args:
;	 lodsb				 ; get char from command line area
;	 cmp	 al,cr			 ; are we at the end?
;	 jump	 E,found_end		 ; yes, display the currently appended dirs
;	 cmp	 al," " 		 ; is it a space?
;	 je	 found_space		 ; yes, at end
;	 cmp	 al,tab_char		 ; is it a tab?
;	 je	 found_space		 ; yes, treat it like a space
;	 cmp	 al,"/" 		 ; is it a parm starter?
;	 je	 bad_path_parm		 ; yes, it's an error              ; @@05
;	 cmp	 al,"a" 		 ; find out if we have a lower case char
;	 jb	 copy_char						   ; @@14
;	 cmp	 al,"z"
;	 ja	 copy_char						   ; @@14
;	 sub	 al,"a"-"A"		 ; convert char to upper case	   ; @@14
;
;copy_char:
;	 mov	 in_middle,-1		 ; say that we made it to the middle
;	 stosb				 ; no, copy char into resident storage area
;	 jmp	 copy_args		 ; do it some more
;
;found_space:
;	 cmp	 in_middle,0		 ; set the space flag then go through
;	 jump	 E,copy_args		 ; loop some more
;
;found_end:
;	 cmp	 in_middle,0		 ; if I found the end of string but not
;	 jump	 E,display_dirs 	 ; in the middle, go display some dirs
;
;	 mov	 es:byte ptr [di],0	 ; null terminate the string
;	 mov	 in_middle,0
;	 cmp	 al,cr
;	 je	 past_trailing
;
;skip_trailing: 			 ; skip end spaces
;	 lodsb
;	 cmp	 al," "
;	 je	 skip_trailing
;	 cmp	 al,tab_char
;	 je	 skip_trailing
;	 cmp	 al,"/" 		 ; path and parm not together	   ; @@05
;	 je	 bad_path_parm						   ; @@05
;	 cmp	 al,cr			 ; only white space allowed at end
;	 jne	 bad_path
;past_trailing:
;
;	 cmp	 old_syntax,0		 ; go back to normal mode
;	 je	 normal_exit
;	 jmp	 exit_append2
;normal_exit:
;	 call	 ctrl_break_rest	 ; reset control break checking
;	 mov	 ax,0			 ; set string
;	 ret				 ; exit to COMMAND

bad_path:				; bad paath operand
;	mov	cx,len_path_error_msg	; length of string
;	lea	dx,path_error_msg
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,3			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
;gga	call	sysdispmsg						 ;AN000;

	jmp	short bad_parmx

bad_path_parm:				; bad parameter 		  ; @@05
;	mov	cx,len_path_parm_error_msg   ; length of string 	  ; @@05
;	lea	dx,path_parm_error_msg					  ; @@05
	call	sysloadmsg						 ;AN000;
	mov	ax,3			; message number		 ;AN000;
	mov	bx,STDERR		; standard error		 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	jmp	short bad_parmx 					  ; @@05
bad_parm:				; bad parameter
;	mov	cx,len_parm_error_msg	; length of string
;	lea	dx,parm_error_msg
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,3			; message number		 ;AN000;
	mov	bx,STDERR		; standard error		 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;

bad_parmx:				; bad parameter
	push	ds
	push	cs
	pop	ds
;	call	print_STDERR		; display error message
	lea	si,inv_parm		; point to msg parm			;an010;bgb
	call	sysdispmsg						 ;AN000;
	pop	ds
	call	ctrl_break_rest
	mov	al,1							  ; @@05
	call	terminate		; exit to DOS			  ; @@05

;	This code has been moved to main_begin				  ; @@07
;bad_append_ver:			; append version mismatch	  ; @@07
;	push	ds							  ; @@07
;	push	cs							  ; @@07
;	pop	ds							  ; @@07
;	mov	cx,len_bad_append_msg					  ; @@07
;	lea	dx,bad_append_msg	; bad app message		  ; @@07
;	call	print_STDERR						  ; @@07
;	lea	dx,crlf 		; carriage return, line feed	  ; @@07
;	mov	cx,crlf_len		; length of string		  ; @@07
;	call	print_STDERR						  ; @@07
;	pop	ds							  ; @@07
;	call	ctrl_break_rest 					  ; @@07
;	mov	ax,0feh 		; bad APPEND version		  ; @@05
;	call	terminate		; exit to DOS			  ; @@05

;	Display currently appended directories

display_dirs:
	call	address_status		; get working path		  ; @@03
	push	ds
	push	es
	pop	ds

	cmp	es:byte ptr[di],";"	; no append now
	je	no_dirs_appended

;	count the chars in the dir list, cx will hold the count

	mov	si,di
	sub	si,6+1			; move pointer to APPEND
	mov	dx,si			; save pointer to string
	xor	cx,cx

scanit:
	lodsb				; get character
	cmp	al,null 		; are we at end?
	je	print_it		; yes, print it
	inc	cx			; look at the next character
	jmp	scanit			; loop till we find the end

print_it:
	call	print_STDOUT		; display appended dirs
	push	cs
	pop	ds
	lea	dx,crlf 		; carriage return, line feed
	mov	cx,crlf_len		; length of string
	call	print_STDOUT
	pop	ds

exit_append:
	cmp	old_syntax,0		; process old format operands
	je	exit_append2
	mov	si,0081h		; set up rescan
	mov	ah,get_PSP
	call	int_21
	mov	ds,bx
	jmp	process_argsx

exit_append2:
	mov	old_syntax,0		; after first time this must be off
	call	ctrl_break_rest 	; reset control break checking
	mov	ax,-1			; no action
	ret				; exit to COMMAND

no_dirs_appended:
	push	cs
	pop	ds

	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,5			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;

;	lea	dx,no_append_msg	; no dirs message		 ;AN000;
;	mov	cx,len_no_append_msg	; length of string		 ;AN000;
;	call	print_STDOUT						 ;AN000;
	pop	ds
	jmp	exit_append2		; APPEND = = fix		    ;GGA

page
;-------------------------------------------------------------------
;	Getting here means that APPEND has not been loaded yet.  Get the
;	old vector, save it, and point the vector to the new routine.
;-------------------------------------------------------------------

replace_vector:

	push	ds
	mov	si,0081h		; point si to argument area
	mov	ah,get_PSP
	call	int_21
	mov	ds,bx

;	Process /X and /E parameters

skip_leading2:				; skip leading spaces
;	lodsb
;	cmp	al," "
;	je	skip_leading2
;	cmp	al,tab_char
;	je	skip_leading2
;	cmp	al,cr			; at end
;	jump	E,parms_done
;	cmp	al,"/"
;	jne	set_old_syntax

found_slash:
;	lodsb
;	cmp	al,"e"
;	je	slash_E
;	cmp	al,"E"
;	je	slash_E
;	cmp	al,"x"
;	je	slash_X
;	cmp	al,"X"
;	je	slash_X
bad_parmy:
;	pop	ds
;	jmp	bad_parm
bad_path_parmy:
;	pop	ds
;	jmp	bad_path_parm

slash_X:
;	test	mode_flags,X_mode	; no duplicates allowed
;	jnz	bad_parmy
;	or	mode_flags,X_mode
;	jmp	short slashx

slash_E:
;	test	mode_flags,E_mode	; no duplicates allowed
;	jnz	bad_parmy
;	or	mode_flags,E_mode
slashx:
;	jmp	skip_leading2		; loop some more
set_old_syntax:
;;	test	mode_flags,0		; no /? switches on old mode
;;	jne	bad_path_parmy
	mov	old_syntax,1
parms_done:
	pop	ds
	jmp	exit_append
page

set_vectors:				; set append hooks		  ; @@05
	push	es

;	Get INT 2f vector. Save to call older 2f handlers

	mov	ax,get_intfcn		; Get INT 2fh vector
	call	int_21
	mov	intfcn_offset,bx	; Save it
	mov	intfcn_segment,es

;	get int 21 vector

	mov	ax,get_vector		; Get INT 21h vector
	call	int_21
	mov	vector_offset,bx	; Save it
	mov	vector_segment,es
	pop	es

	push	ds							  ; @@08
	push	cs							  ; @@08
	pop	ds							  ; @@08
	lea	dx,intfcn_hook		; DS:DX = New INT 2fh vector
	mov	ax,set_intfcn		; Hook the interrupt
	call	int_21

	lea	dx,interrupt_hook	; DS:DX = New INT 21h vector
	mov	ax,set_vector		; Hook the interrupt
	call	int_21

	mov	dirlst_segment,cs	; save the address of the dirlist
	lea	dx,app_dirs
	mov	dirlst_offset,dx
	pop	ds							  ; @@08

	ret								  ; @@05

terminate:				; terminate to dos or return	  ; @@05
	cmp	res_append,0						  ; @@05
	jne	is_res							  ; @@05
	call	Release_Environment	; release environmental vector		;ac009; dms;
	mov	ah,term_proc		; return to DOS on first time	  ; @@05
	call	int_21							  ; @@05
is_res: 								  ; @@05
	mov	ax,-1			; set abort requested		  ; @@05
	jmp	abort_exit		; must go back to COMMAND	  ; @@05


print_STDOUT:
	mov	bx,STDOUT		; Standard output device handle
	mov	ah,awrite		; function code for write
	call	int_21
	ret

print_STDERR:
	mov	bx,STDERR		; Standard output device handle
	mov	ah,awrite
	call	int_21
	ret

Release_Environment:								;an007; dms;

	push	ax			;save regs				;an007; dms;
	push	bx			;					;an007; dms;
	push	es			;					;an007; dms;
	mov	ah,Get_PSP		; get the PSP segment			;an007; dms;
	call	int_21			; invoke INT 21h			;an007; dms;
	mov	es,bx			; BX contains PSP segment - put in ES	;an007; dms;
	mov	bx,word ptr es:[PSP_Env]; get segment of environmental vector	;an007; dms;
	mov	es,bx			; place segment in ES for Free Memory	;an007; dms;
	mov	ah,Free_Alloc_Mem	; Free Allocated Memory 		;an007; dms;
	int	21h			; invoke INT 21h			;an007; dms;
	pop	es			; restore regs				;an007; dms;
	pop	bx			;					;an007; dms;
	pop	ax			;					;an007; dms;

	ret				; return to caller			;an007; dms;

;=========================================================================
; Scan_For_Equal	: This routine scans the command line from the
;			  beginning until it encounters anything other
;			  than the equal, tab, or space characters.
;			  Register SI is sent back to the caller pointing
;			  to the character that does not meet the match
;			  criteria.
;
;	Inputs	: DS:SI - pointer to next parm
;
;	Outputs : SI	- adjusted to byte not matching the following:
;			  "="
;			  " "
;			  TAB
;
;	Author	: David M. Sewell
;	Date	: 1/27/88
;	Version : DOS 3.4
;=========================================================================

Scan_For_Equal:

	push	ax				; save regs			;an008; dms;
	push	cx				;				;an008; dms;

	xor	cx,cx				; clear cx			;an008; dms;
	mov	cl,byte ptr ds:[80h]		; get length of command line	;an008; dms;

Scan_For_Equal_Loop:

	cmp	cx,0				; at end?			;an008; dms;
	jbe	Scan_For_Equal_Exit		; exit loop			;an008; dms;
	mov	al,byte ptr ds:[si]		; get 1st. character		;an008; dms;
	call	Chk_DBCS			; DBCS lead byte?		;an008; dms;
	jnc	Scan_For_Equal_No_DBCS		; no				;an008; dms;
		cmp	byte ptr ds:[si],DB_SP_HI   ; blank lead byte		    ;an008; dms;
		jne	Scan_For_Equal_Exit	; exit with adjusted SI 	;an008; dms;
		cmp	byte ptr ds:[si+1],DB_SP_LO ; DBCS blank		    ;an008; dms;
		jne	Scan_For_Equal_Exit	; exit with adjusted SI 	;an008; dms;

		add	si,2			; yes - DBCS lead byte		;an008; dms;
		sub	dx,2			; decrease counter		;an008; dms;
		jmp	Scan_For_Equal_Loop

Scan_For_Equal_No_DBCS:

	cmp	al,"="				; = found?			;an008; dms;
	je	Scan_For_Equal_Next		; next character		;an008; dms;
	cmp	al,20h				; space?			;an008; dms;
	je	Scan_For_Equal_Next		; next character		;an008; dms;
	cmp	al,09h				; tab?				;an008; dms;
	je	Scan_For_Equal_Next		; next character		;an008; dms;
	jmp	SHORT Scan_For_Equal_Exit	; exit with adjusted SI 	;an008; dms;

Scan_For_Equal_Next:

	inc	si				; adjust ptr			;an008; dms;
	dec	cx				; decrease counter		;an008; dms;
	jmp	Scan_For_Equal_Loop		; continue loop 		;an008; dms;

Scan_For_Equal_Exit:

	pop	cx				;				;an008; dms;
	pop	ax				;				;an008; dms;

	ret					; return to caller		;an008; dms;



;=========================================================================	;an010;bgb
; do_parse_err		: This routine sets up for the display of a parse	;an010;bgb
;			  error, and displays the offending parameter.		;an010;bgb
;										;an010;bgb
;	Inputs	: DS:SI - points just past offending parm in command line	;an010;bgb
;										;an010;bgb
;	Outputs : si_off- parm for msg ret.					;an010;bgb
;		  si_seg- parm for msg ret.					;an010;bgb
;		  command line - hex zero at end of offending parm		;an010;bgb
;										;an010;bgb
;	Date	: 3/29/88							;an010;bgb
;	Version : DOS 4.0 (wow!)						;an010;bgb
;=========================================================================	;an010;bgb
do_parse_err	PROC								;an010;bgb
;;;;;;;;mov	ax,3 ;removed- parser handles this				;an010;bgb
	mov	bx,STDERR		; handle				;an010;bgb
;;;;;;;;xor	cx,cx			; sub count				;an010;bgb
	mov	cx,1			;display invalid parm			;an010;bgb
	xor	dl,dl			; no input				;an010;bgb
	mov	dh,02			; message class of parse error		;an010;bgb
;;;;;;;;mov	cs:si_off,81h		   ;initialize pointer			;an010;bgb
										;an010;bgb
	   dec	  si			;point to last byte of invalid parm	;an010;bgb
public decsi									;an010;bgb
decsi:	   cmp	   byte ptr [si],' '	;are we pointing to a space?		;an010;bgb
;	   $IF	   E,OR 		;if so, we dont want to do that 	;an010;bgb
	   JE $$LL1
	   cmp	   byte ptr [si],0dh	;are we pointing to CR? 		;an010;bgb
;	   $IF	   E			;if so, we dont want to do that 	;an010;bgb
	   JNE $$IF1
$$LL1:
	       dec   si 		;find the last byte of parm		;an010;bgb
	       jmp   decsi							;an010;bgb
;	   $ENDIF								;an010;bgb
$$IF1:
	   mov	   byte ptr [si+1],00	  ;zero terminate display string	;an010;bgb
nextsi: 									;an010;bgb
public nextsi									;an010;bgb
	   dec	   si			;look at previous char			;an010;bgb
	   cmp	   byte ptr [si],' '	;find parm separator			;an010;bgb
	   jnz	   nextsi		;loop until begin of parm found 	;an010;bgb
										;an010;bgb
	mov	cs:si_off,si		;mov si into display parms		;an010;bgb
	mov	cs:si_seg,ds		   ;initialize pointer			;an010;bgb
	ret					; return to caller		;an010;bgb
do_parse_err	ENDP								;an010;bgb


;-------------------------------------------------------------------
;
;-------------------------------------------------------------------

MSG_SERVICES <LOADmsg>
MSG_SERVICES <APPEND.CLB,APPEND.CL2,APPEND.CTL>

end_address:				; this is the end of the TSR stuff		 ;AN004;

include parse.asm			; include the parser code
include msgdcl.inc

cseg	ends
sseg	segment para stack 'STACK'
	assume	ss:sseg
	dw	512 dup(0)
mystack dw	0
sseg	ends



	end	main_begin

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\make.inc ===
!include $(NTMAKEENV)\makefile.plt

# Common makefile defines for DOSKRNL (NTIO.SYS and NTDOS.SYS) and utilities
#
# Created Sudeepb 20-Mar-1991

MAKE	=nmake

!IFNDEF ALT_PROJECT
ALT_PROJECT=usa
ALT_PROJECT_TARGET=.
!ENDIF

msg = ..\..\messages\$(ALT_PROJECT)

!if "$(PROCESSOR_ARCHITECTURE)" == "x86"
DEST=$(ALT_PROJECT)\obj\i386
!elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
DEST=$(ALT_PROJECT)\obj\alpha
!endif

inc	=..\..\inc
cinc	=..\..\..\..\inc

#############################################################################
#                                                                           #
# These are the built in rules and path definitions used by the new MS Make #
# Utility (NMAKE). The following variables are set externaly (ie set in the #
# individual makefiles.                                                     #
#                                                                           #
# extasw = The 'extra assembly switch' variable is optionaly used in the    #
#          makefile to specify special MASM command line switches.          #
#                                                                           #
# extcsw = The 'extra C switch' variable is optionaly used in the makefile  #
#          to specify special C compiler command line switches.             #
#                                                                           #
# inc    = The include file search path from the utility being built to the #
#          INC directory. Used if needed.                                   #
#                                                                           #
# hinc   = The include file search path from the utility being built to the #
#          H directory. Used if needed for C source compilation.            #
#                                                                           #
#############################################################################

########## Definitions for the Assembler      #####
########## awarn can be overridden by placing #####
##########    the new warning level in extasw #####
##########    in the makefile                 #####

asm     =masm386
awarn	=-W1
!if "$(ALT_PROJECT)" == "JPN" || "$(ALT_PROJECT)" == "KOR"
aflags  =-Mx -t $(awarn) $(extasw) $(DBCS_FLAGS) -DBILINGUAL
!else
aflags  =-Mx -t $(awarn) $(extasw) $(DBCS_FLAGS)
!endif
ainc    =-I. -I..\..\inc -I..\..\..\..\inc -I$(msg) -I$(DEST)

########## Definitions for C compiler         #####
########## cwarn can be overridden by placing #####
##########    the new warning level in extcsw #####
##########    in the makefile                 #####

cc      =cl16
cwarn   =-W3
cflags  =-Os -Zp $(cwarn) $(extcsw) $(DBCS_FLAGS) /Zl

incc	=-I. -I..\..\h

########## Definitions for linker ##########

link_opts = /MAP
LINK    =link16
exelink =/E

########## Definitions for compress ##########

compress =compress

########## Path definition so we find 16 bit tools ##########
# Also works around bug in RC 3.1 that doesn't allow rcpp.err to be
# in a directory that is greater than 128 chars down the path, even if
# rc 3.1 is running as an OS/2 app.

PATH    = $(BASEDIR)\tools\tools16;$(PATH)

########## Built-in rules ##########

.SUFFIXES:
.SUFFIXES: .c .obj .lst .exe .exc .exs .com .sal .cod .sil .inc .skl .cla .cl1 .ctl .asm .idx .msg

.sal.asm:
        salut $*.sal,nul,$*.asm

.asm{$(DEST)}.obj:
        $(asm) $(ainc) $(aflags) $(<F),$*.obj;

.asm{$(DEST)}.lst:
        $(asm) -l $(ainc) $(aflags) $(<F),$*.obj;

.asm{$(DEST)}.obj:
        $(asm) $(ainc) $(aflags) $<,$*.obj;

.asm{$(DEST)}.lst:
        $(asm) -l $(ainc) $(aflags) $<,$*.obj;

.asm.obj:
        $(asm) $(ainc) $(aflags) $*.asm;

.asm.lst:
        $(asm) -l $(ainc) $(aflags) $*.asm;

.c{$(DEST)}.obj:
        $(cc) -c $(incc) $(cflags) -Fo$*.obj $<

.c{$(DEST)}.lst:
        $(cc) -c $(incc) $(cflags) -Fc$*.cod -Fo$*.obj $<

.c{$(DEST)}.obj:
        $(cc) -c $(incc) $(cflags) -Fo$*.obj $<

.c{$(DEST)}.lst:
        $(cc) -c $(incc) $(cflags) -Fc$*.cod -Fo$*.obj $<

.c.obj:
	$(cc) -c $(incc) $(cflags) $*.c

.c.lst:
	$(cc) -c $(incc) $(cflags) -fc$*.cod -fo$*.obj $*.c

{$(DEST)}.exs{$(DEST)}.sys:
        copy $*.exs $*.exe
        reloc $* $*.sys
        del $*.exe

{$(DEST)}.exc{$(DEST)}.com:
        copy $*.exc $*.exe
        reloc $* $*.com
        del $*.exe

.exs.sys:
        copy $*.exs $*.exe
        reloc $* $*.sys
        del $*.exe

.exc.com:
        copy $*.exc $*.exe
        reloc $* $*.com
        del $*.exe

.exe.com:
        convert $*.exe

{$(ALT_PROJECT)}.skl{$(DEST)}.cl1:
        cd $(DEST)
        copy ..\..\$(<F)
        -nosrvbld $(<F) ..\..\..\$(msg)\$(ALT_PROJECT).msg
        -nosrvbld $(<F) ..\..\..\$(msg)\$(ALT_PROJECT).msg
        erase $(<F)
        cd ..\..\..

{$(ALT_PROJECT)}.skl{$(DEST)}.ctl:
        cd $(DEST)
        buildmsg ..\..\..\$(msg)\$(ALT_PROJECT) ..\..\$(<F)
        cd ..\..\..


{$(ALT_PROJECT)}.skl{$(DEST)}.cla:
        cd $(DEST)
        buildmsg ..\..\..\$(msg)\$(ALT_PROJECT) ..\..\$(<F)
        cd ..\..\..

.sil.inc:
	salut $*.sil,nul,$*.inc

.sal.obj:
	salut $*.sal,nul,$*.asm
	$(asm) $(aflags) $(ainc) $*.asm,$*.obj;

.msg.idx:
        chmode -r $*.msg
        buildidx $*.msg
        chmode +r $*.msg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\appendp.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

INCSW	EQU	0			;INCLUDE PSDATA.INC			;AN000;
FARSW	EQU	1			;CALL THE PARSER BY NEAR CALL
DATESW	EQU	0			;SUPPRESS DATE CHECKING 		;AN000;
TIMESW	EQU	0			;SUPPRESS TIME CHECKING 		;AN000;
FILESW	EQU	0			;SUPPRESS CHECKING FILE SPECIFICATION	;AN000;
CAPSW	EQU	0			;SUPPRESS FILE TABLE CAPS		;AN000;
CMPXSW	EQU	1			;SUPPRESS CHECKING COMPLEX LIST
DRVSW	EQU	1			;SUPPRESS SUPPORT OF DRIVE ONLY FORMAT
QUSSW	EQU	0			;SUPPRESS SUPPORT OF QUOTED STRING FORMAT ;AN000;
NUMSW	EQU	1			;SUPPRESS CHECKING NUMERIC VALUE
KEYSW	EQU	0			;SUPPRESS KEYWORD SUPPORT		;AN000;
SWSW	EQU	1			;DO SUPPORT SWITCHES			;AN000;
VAL1SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 1 ;AN000;
VAL2SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 2 ;AN000;
VAL3SW	EQU	1			;DO SUPPORT VALUE DEFINITION 3

include psdata.inc
;***********************************************************************

;-------------------------------------------------------------------
;
;	parser stuff for APPEND
;
;-------------------------------------------------------------------



p_block1  $P_PARMS_Blk <offset px_block1, 0, 0>    ; parm block
p_block2  $P_PARMS_Blk <offset px_block2, 0, 0>    ; parm block

;------------------------
;	extended parameter block for APPEND first load

px_block1:
	db	0		; min number positional operands
	db	0		; max number positional operands
;	dw	0		; offset into control block for positionals

	db	4		; APPEND has two switches /E, /X, /PATH, /?
	dw	offset e_switch 	; control block for /E switch
	dw	offset x_switch 	; control block for /X switch
	dw	offset qu_switch        ; " " for /? switch
	dw	offset path_switch	; control block for /PATH switch

	db	0		; max number of keywords
	dw	0		; offset of keyword control block

;------------------------
;	extended parameter block for 2nd, 3rd, ... APPEND invocations

px_block2:
	db	0		; min number positional operands
	db	1		; max number positional operands
	dw	offset dirs_control	; pointer to dirs control block

;	db	2		; APPEND after first load has two switches /X, /PATH
	db	4		; APPEND has two switches /E, /X, /PATH
	dw	offset e_switch 	; control block for /E switch
	dw	offset x_switch 	; control block for /X switch
	dw	offset qu_switch        ; " " for /? switch
	dw	offset path_switch	; control block for /PATH switch

	db	0		; max number of keywords

;------------------------
dirs_control:
	dw	$P_Simple_S+$P_Optional   ; complex, optional string
	dw	$P_CAP_File		; cap by file table
	dw	offset dirs_result	; dirs result buffer
	dw	offset dirs_values	; pointer to null value list
	db	0			; no synonyms

dirs_values:
	db	0			; null value list for dirs



;------------------------
x_switch:
	dw	$P_Simple_s+$P_Optional       ; /X, /X:ON, /X:OFF simple, optional string
	dw	$P_CAP_Char		; cap by char table
	dw	offset x_result 	; pointer to result block
	dw	offset x_values 	; pointer to values block
	db	1			; number of switches and synonyms
	db	"/X",0                  ; only /X is valid

x_values:
	db	3			; string values
	db	0			; zeroes here for ranges and
	db	0			; values
	db	2			; 2 possible string values
	db	0			; /X:OFF = 0
	dw	offset off_string	; pointer to "OFF"
	db	1			; /X:ON  = 1
	dw	offset on_string
;------------------------

e_switch:
	dw	0			; /E
	dw	$P_CAP_Char		; cap by char table
	dw	offset e_result 	; pointer to result block
	dw	offset e_values 	; pointer to values block, none
	db	1			; number of switches and synonyms
	db	"/E",0                   ; only /E is valid

e_values:
	db	0			; null value list for /E


;------------------------

qu_switch:
	dw      1                       ; optional
	dw	0
	dw	offset qu_result 	; pointer to result block
	dw	offset qu_values 	; pointer to values block, none
	db	1			; number of switches and synonyms
	db	"/?",0                   ; only /? is valid

qu_values:
	db	0			; null value list for /E



path_switch:
	dw	$P_Simple_s		; /PATH:ON, /PATH:OFF simple string
	dw	$P_CAP_Char		; cap by char table
	dw	offset path_result	; pointer to result block
	dw	offset path_values	; pointer to values block
	db	1			; number of switches and synonyms
	db	"/PATH",0                ; only /PATH is valid


path_values:
	db	3			; string values
	db	0			; zeroes here for ranges and
	db	0			; values
	db	2			; 2 possible string values
	db	0			; /PATH:OFF = 0
	dw	offset off_string	; pointer to "OFF"
	db	1			; /PATH:ON  = 1
	dw	offset on_string


;------------------------

off_string:
	db	"OFF",0                 ; off string

on_string:
	db	"ON",0                  ; on string


;------------------------

x_result	$P_Result_Blk <>	; /X result block
e_result	$P_Result_Blk <>	; /E result block
qu_result       $P_Result_Blk <>        ; /? result block
path_result	$P_Result_Blk <>	; /PATH result block
dirs_result	$P_Result_Blk <>	; dirs result block



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\appendm.asm ===
page	60,120
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;      @@04 07/30/86 Fix second APPEND hang		 PTM P0000053
;      @@05 08/13/86 Fix bad parm message		PTM P0000125
;      @@10 08/28/86 Change message for @@05		PTM P0000291
;      @@11 09/10/86 Support message profile and make
;		     msg length variable.	R.G. PTM P0000479
cseg	segment public para 'CODE'
	assume	cs:cseg

	public	bad_append_msg			;@@11
	public	path_error_msg			;@@11
	public	parm_error_msg			;@@11
	public	path_parm_error_msg		;@@11
	public	no_append_msg			;@@11
	public	append_assign_msg		;@@11
	public	append_tv_msg			;@@11
	public	bad_DOS_msg			;@@11
	public	second_append_msg		;@@11

	public	len_bad_append_msg		;@@11
	public	len_path_error_msg		;@@11
	public	len_parm_error_msg		;@@11
	public	len_path_parm_error_msg 	;@@11
	public	len_no_append_msg		;@@11
	public	len_append_assign_msg		;@@11
	public	len_append_tv_msg		;@@11
	public	len_bad_DOS_msg 		;@@11
	public	len_second_append_msg		;@@11

cr	equ	13
lf	equ	10

include appendm.inc

cseg		ends
		end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\backup\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\backup\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\backup\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\append\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\backup\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\backup\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\backup\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\backup\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\backup\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\command2.asm ===
page ,132
	title	COMMAND2 - resident code for COMMAND.COM part II
	name	COMMAND2
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
;			reserve memory by changing int 12h and then give it
;			back to DOS by changing arenas in autoexec.bat.
;			This makes command.com reload transient and this
;			cannot be done at this stage.
;
;



.xcref
.xlist
	include dossym.inc
	include pdb.inc
	include syscall.inc
	include comsw.asm
	include comequ.asm
	include resmsg.equ

	include comseg.asm
.list
.cref


DATARES 	segment public byte
		extrn	Append_State:word
		extrn	Append_Flag:byte
		extrn	BMemMes:byte
		extrn	ComBad:byte
		extrn	ComDrv:byte
		extrn	ComSpec:byte
		extrn	EnvirSeg:word
		extrn	ExtCom:byte
		extrn	FRetMes:byte
		extrn	HaltMes:byte
		extrn	Handle01:word
		extrn	InitFlag:BYTE
		extrn	Int_2e_Ret:dword
		extrn	Io_Save:word
		extrn	Io_Stderr:byte
		extrn	Loading:byte
		extrn	LTpa:word
		extrn	MemSiz:word
		extrn	NoHandMes:byte
		extrn	OldTerm:dword
		extrn	Parent:word
		extrn	PermCom:byte
		extrn	Prompt:byte
		extrn	PutBackDrv:byte
		extrn	PutBackMsg:byte
		extrn	PutBackSubst:byte
		extrn	Res_Tpa:word
		extrn	RetCode:word
		extrn	Save_Pdb:word
		extrn	SingleCom:word
		extrn	Sum:word
		extrn	Trans:dword
		extrn	TranVarEnd:byte
		extrn	TranVars:byte
		extrn	TrnSeg:word
		extrn	VerVal:word

		extrn	ResSize:word
		extrn	OldDS:word
		extrn	RStack:word

		extrn	Ctrlc_Trap:near
		extrn	CritErr_Trap:near
		extrn	LodCom_Trap:near

DATARES 	ends

;;ENVARENA 	segment public para
;;ENVARENA 	ends

;;ENVIRONMENT 	segment public para      ; default COMMAND environment
;;ENVIRONMENT 	ends

INIT		segment public para
		extrn	EnvSiz:word
		extrn	OldEnv:word
		extrn	ResetEnv:byte
		extrn	UsedEnv:word

		extrn	Chuckenv:byte


INIT		ends


TRANDATA	segment public byte
		extrn	trandataend:byte
TRANDATA	ends

TRANSPACE	segment public byte
		extrn	transpaceend:byte
		extrn	headcall:dword
TRANSPACE	ends




CODERES segment public byte

	public	BadMemErr

	public	ChkSum
;;	public	EndInit
	public	GetComDsk2
	public	Int_2e
	public	LoadCom
	public	LodCom
	public	LodCom1
	public	RestHand
	public	SavHand
	public	SetVect
	public	THeadFix
	public	TRemCheck
	public	TJmp

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	extrn	ContC:near
	extrn	DskErr:near

	extrn	Alloc_error:near

;*	If we cannot allocate enough memory for the transient or there
;	was some other allocation error, we display a message and
;	then die.

;SR;
; We will have to make sure that at this entry point and at FatalC, 
;ds = DATARES. All jumps to these points are made from only within this file
;and so we should be able to do this

	assume	ds:DATARES
BadMemErr:
	mov	dx,offset DATARES:BMemMes	; DX = ptr to msg
FatalC:

;;	push	cs
;;	pop	ds
;;	assume	ds:ResGroup
	invoke	RPrint

;	If this is NOT a permanent (top-level) COMMAND, then we exit;
;	we can't do anything else!

	cmp	PermCom,0
	je	FatalRet

;	We are a permanent command.  If we are in the process of the
;	magic interrupt (Singlecom) then exit too.

	cmp	SingleCom,0			; if permcom and singlecom
	jne	FatalRet			; must take int_2e exit

;	Permanent command.  We can't do ANYthing except halt.

	mov	dx,offset DATARES:HaltMes	; DX = ptr to msg
	invoke	RPrint
	sti
Stall:
	jmp	Stall				; crash the system nicely

FatalRet:
	mov	dx,offset DATARES:FRetMes	; DX = ptr to msg
	invoke	RPrint
FatalRet2:
	cmp	PermCom,0			; if we get here and permcom,
	jne	Ret_2e				; must be int_2e

;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
;	were a non-permanent COMMAND that had hooked it!  (Just in 
;	case we decide to do that.)
	mov	ax,Parent
	mov	word ptr ds:Pdb_Parent_Pid,ax
	mov	ax,word ptr OldTerm
	mov	word ptr ds:Pdb_Exit,ax
	mov	ax,word ptr OldTerm+2
	mov	word ptr ds:Pdb_Exit+2,ax
	mov	ax,(EXIT shl 8) 		; return to lower level
	int	21h

Ret_2e:
;SR;
; We will ensure that ds = DATARES for all entries to this place
;

;;	push	cs
;;	pop	ds
;;	assume	ds:resgroup,es:nothing,ss:nothing
  	
	assume	ds:DATARES

	mov	SingleCom,0		; turn off singlecom
	mov	es,Res_Tpa
	mov	ah,DEALLOC
	int	21h			; free up space used by transient
	mov	bx,Save_Pdb
	mov	ah,SET_CURRENT_PDB
	int	21h			; current process is user
	mov	ax,RetCode
	cmp	ExtCom,0
	jne	GotECode
	xor	ax,ax			; internals always return 0
GotECode:
	mov	ExtCom,1		; force external

;SR; This is actually returning to the caller. However, the old code had
;ds = RESGROUP so I guess we can keep ds = DATARES for us.
;Yes, int 2eh can corrupt all registers so we are ok.
;
	jmp	Int_2e_Ret		;"iret"




;***	Int_2e, magic command executer

Int_2e:
	assume	ds:NOTHING,es:NOTHING,ss:NOTHING
;SR;
; We are going to come here from the stub with the old ds and DATARES value
;pushed on the stack in that order. Pick up this stuff off the stack
;
	pop	ds			;ds = DATARES
	assume	ds:DATARES
	pop	ax
;	pop	ds:OldDS 		;Save old value of ds

	pop	word ptr Int_2e_Ret
	pop	word ptr [Int_2e_Ret+2] ; store return address
	;pop	ax			; chuck flags
	add	sp,2

;;	push	cs
;;	pop	es

	push	ds
	pop	es			;es = DATARES
;	mov	ds,OldDS
	mov	ds,ax
	assume	ds:nothing		;ds = old value

	mov	di,80h
	mov	cx,64
;	Bugbug:	cld
	rep	movsw
	mov	ah,GET_CURRENT_PDB
	int	21h			; get user's header
	mov	es:Save_Pdb,bx
	mov	ah,SET_CURRENT_PDB

;;	mov	bx,cs
;SR;
; Set ds = DATARES because BadMemErr expects this
;
	push	es
	pop	ds
	assume	ds:DATARES

	mov	bx,ds			;es = our PSP now

	int	21h			; current process is me
	mov	SingleCom,81h
	mov	ExtCom,1		; make sure this case forced

;SR;
; We can enter LodCom directly after a command shell is terminated or we
;can fall thru from above. When we enter directly from the stub, the stack
;has the old ds value and the data seg value on the stack, so that ds can
;be properly set. To fake this, we push dummy values here.
;
	push	ds			;old value of ds
	push	ds			;data seg value, ds = DATARES

LodCom: 					; termination handler
	pop	ds			;ds = DATARES 
	assume	ds:DATARES
	add	sp,2
;	pop	OldDS			;store old ds

	cmp	ExtCom,0
	jne	@f 		; internal cmd - memory allocated
	jmp	LodCom1
@@:
	mov	bx,0FFFFh
	mov	ah,ALLOC
	int	21h
	call	SetSize
	add	ax,20h
	cmp	bx,ax
	jnc	MemOk			; > 512 byte buffer - good enough
BadMemErrJ:
	jmp BadMemErr			; not enough memory




;***	SetSize - get transient size in paragraphs

SetSize	proc
	assume	ds:NOTHING,es:NOTHING
	mov	ax,offset TRANGROUP:TranSpaceEnd + 15
	mov	cl,4
	shr	ax,cl
	ret
SetSize	endp




MemOk:
	assume	ds:DATARES		;we have set ds = DATARES 

	mov	ah,ALLOC
	int	21h
	jc	BadMemErrJ		; memory arenas probably trashed
	mov	ExtCom,0		; flag not to alloc again
	mov	Res_Tpa,ax		; save current tpa segment
	and	ax, 0F000h
	add	ax, 01000h		; round up to next 64k boundary
	jc	Bad_Tpa 		; memory wrap if carry set

;	Make sure that new boundary is within allocated range

	mov	dx,Res_Tpa
	add	dx,bx			; compute maximum address
	cmp	dx,ax			; is 64k address out of range?
	jbe	Bad_Tpa

;	Must have 64K of usable space.

	sub	dx,ax			; compute the usable space
	cmp	dx,01000h		; is space >= 64k ?
	jae	LTpaSet
Bad_Tpa:
	mov	ax,Res_Tpa
LTpaSet:
	mov	LTpa,ax			; usable tpa is 64k buffer aligned
	mov	ax,Res_Tpa		; actual tpa is buffer allocated
	add	bx,ax
	mov	MemSiz,bx
	call	SetSize
	sub	bx,ax
;
;M038; Start of changes
; Changes for Novell RPL. These guys reserve memory for themselves by
;reducing int 12h size and add this memory to the system at autoexec time by
;running a program that changes arenas. This changes the largest block that
;command.com gets and so changes the transient segment. So, command.com does
;a checksum at the wrong address and thinks that the transient is destroyed
;and tries to reload it. At this point, no Comspec is defined and so the
;reload fails, hanging the system. To get around this we just copy the
;transient from the previous address to the new address(if changed) and
;then let command.com do the checksum. So, if the transient area is not
;corrupted, there will not be any reload. In Novell's case, the transient
;is not really corrupted and so this should work.
;
	cmp	bx,TrnSeg		;Segment still the same?
	je	LodCom1		;yes, dont copy
;
;Check if the new segment is above or below the current move. If the new
;segment is above(i.e new block is larger than previous block), then we
;have to move in the reverse direction
;
	mov	cx,offset TRANGROUP:TranSpaceEnd ;cx = length to move
	ja	mov_down		;new seg > old seg, reverse move
	xor	si,si			;normal move
	mov	di,si
	cld
	jmp	short copy_trans
mov_down:
	mov	si,cx			;reverse move, start from end
	dec	si
	mov	di,si
	std
copy_trans:
	push	ds
	push	es
	mov	es,bx			;dest segment
	mov	ds,TrnSeg		;source segment
	assume	ds:nothing

	rep	movsb			;copy transient
	cld
	pop	es
	pop	ds
	assume	ds:DATARES
;
;M038; End of changes
;

	mov	TrnSeg,bx		;new location of transient
LodCom1:
;;	mov	ax,cs
;;	mov	ss,ax
;SR; At this point ds = DATARES which is where the stack is located
;
	mov	ax,ds
	mov	ss,ax
	assume	ss:DATARES
	mov	sp,offset DATARES:RStack

;;	mov	ds,ax

	assume	ds:DATARES
	call	HeadFix 		; close files, restore stdin, stdout
	xor	bp,bp			; flag command ok
	mov	ax,-1
	xchg	ax,VerVal
	cmp	ax,-1
	je	NoSetVer
	mov	ah,SET_VERIFY_ON_WRITE	; AL has correct value
	int	21h
NoSetVer:
	cmp	SingleCom,-1
	jne	NoSng
	jmp	FatalRet2		; we have finished the single command
NoSng:
	call	ChkSum			; check the transient
	cmp	dx,Sum
	je	HavCom			; transient ok
Bogus_Com:
	mov	Loading,1		; flag DskErr routine
	call	LoadCom
ChkSame:

	call	ChkSum
	cmp	dx,Sum
	jz	HavCom			; same command
Also_Bogus:
	call	WrongCom
	jmp	short ChkSame
HavCom:
	mov	Loading,0		; flag to DskErr
	mov	si,offset DATARES:TranVars
	mov	di,offset TRANGROUP:HeadCall
	mov	es,TrnSeg
	cld
	mov	cx,offset DATARES:TranVarEnd
	sub	cx,si
	rep	movsb			; transfer info to transient
	mov	ax,MemSiz
	mov	word ptr ds:Pdb_Block_Len,ax	; adjust my own header

;***	TJmp - jump-off to transient
;
;	Public label so debugger can find this spot.

TJmp:
	jmp	Trans




;***	TRemCheck - far version of RemCheck for transient

TRemCheck	proc	far

	pop	ds			;ds = DATARES
	add	sp,2			;discard old value of ds

	call	RemCheck
	ret

TRemCheck endp




;***	RemCheck
;
;	ENTRY	AL = drive (0=default, 1=A, ...)
;
;	EXIT	ZR set if removeable media
;		ZR clear if fixed media
;
;	USED	none

RemCheck:
	savereg	<ax,bx>
	mov	bx,ax
	mov	ax,(IOCTL shl 8) + 8
	int	21h
	jnc	rcCont			

;	If an error occurred, assume the media is non-removable.
;	AX contains the non-zero error code from the int 21, so
;	'or ax,ax; sets non-zero. This behavior makes network drives
;	appear to be non-removable.				
					
	or	ax,ax			
	jmp	short ResRegs
rcCont:
	and	ax,1
	not	ax
ResRegs:
	restorereg  <bx,ax>
	ret




;***	THeadFix
;
;	Far version of HeadFix, called from transient.

THeadFix	proc	far
	pop	ds			;ds = DATARES
	add	sp,2			;discard old ds value on stack

	call	HeadFix
	ret

THeadFix	endp




;***	HeadFix

HeadFix:
	call	SetVect			; set vectors to our values

;	Clean up header

;	Bugbug:	optimize:
;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes

	xor	bx,bx				; BX = handle = 0
	mov	cx,Io_Save			; CX = original stdin, stdout
	mov	dx,word ptr ds:Pdb_Jfn_Table	; DX = current stdin, stdout
	cmp	cl,dl
	je	Chk1			; stdin matches
	mov	ah,CLOSE
	int	21h			; close stdin
	mov	ds:Pdb_Jfn_Table,cl	; restore stdin
Chk1:
	inc	bx			; BX = handle = 1
	cmp	ch,dh			
	je	ChkStderr		; stdout matches
	mov	ah,CLOSE
	int	21h			; close stdout
	mov	ds:Pdb_Jfn_Table+1,ch	; restore stdout

ChkStderr:
	inc	bx			; BX = handle = 2
	mov	dl,byte ptr ds:[Pdb_Jfn_Table+2]	; Dl = current stderr
	mov	cl,Io_Stderr		; Cl = original stderr
	cmp	dl,cl
	je	ChkOtherHand		; stderr matches
	mov	ah,CLOSE
	int	21h			; close stderr
	mov	ds:Pdb_Jfn_Table+2,cl	; restore stderr

ChkOtherHand:
	add	bx,3			; skip handles 3,4
ifdef NEC_98
	add	bx,4   			 ; skip handles 2,3,4
endif   ;NEC_98
	mov	cx,FILPERPROC - 5	; CX = # handles to close
					;   (handles 0-4 already done)
;; williamh: March 30, 1993, don't close invalid handle , save some time
	push	si
	mov	si, pdb_jfn_table	;go to the handle table
CloseLoop:
	cmp	byte ptr [bx][si], 0ffh
	je	Skip_this_handle
	mov	ah,CLOSE
	int	21h			; close each handle
Skip_this_handle:
	inc	bx
	loop	CloseLoop
	pop	si
;	Bugbug:	since this is for transient code, move it there

;	M012: remove this CS -> DS.  Must've been missed during
;	purification.
;;	push	ds			; save data segment
;;	push	cs			; get local segment into DS
;;	pop	ds			;
	cmp	Append_Flag,-1		; do we need to reset APPEND?
	jne	Append_Fix_End		; no - just exit
	mov	ax,AppendSetState	; set the state of Append
	mov	bx,Append_State 	;     back to the original state
	int	2Fh			;
	mov	Append_Flag,0		; set append flag to invalid
Append_Fix_End: 			;
;;	pop	ds			; get data segment back
	ret




;***	SavHand - save current program's stdin/out & set to our stderr
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	flags
;
;	EFFECTS
;	  Handle01 = current program's stdin,stdout JFN entries
;	  current program's stdin,stdout set to our stderr
;

;SR;
; Changed ds = DATARES. We need it to access our JFN_Table
; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).
;
SavHand	proc

	assume	ds:DATARES,es:NOTHING,ss:NOTHING

	push	bx			;preserve registers
	push	ax
	push	es
	push	ds			; save DATARES value

	mov	ah,GET_CURRENT_PDB
	int	21h			; BX = user's header seg addr
	mov	ds,bx			; DS = user's header seg addr
	lds	bx,ds:PDB_JFN_POINTER	; DS:BX = ptr to JFN table
	mov	ax,word ptr ds:[bx]	; AX = stdin,stdout JFN's

	pop	es			;es = DATARES
	push	es			;save it back on stack
	mov	es:Handle01,ax		; save user's stdin, stdout

;SR;
; Use es to address Handle01 & our JFN_Table
;

	mov	al,es:[PDB_JFN_TABLE+2] ; AL = COMMAND stderr
	mov	ah,al			; AH = COMMAND stderr
	mov	word ptr ds:[bx],ax	; set user's stdin/out to our stderr

	pop	ds			; restore registers
	pop	es
	pop	ax
	pop	bx
	ret

SavHand	endp




	assume	ds:DATARES

GetComDsk2:
	call	GetComDsk
	jmp	LodCom1 		; memory already allocated

RestHand:
	push	ds
	push	bx			; restore stdin, stdout to user
	push	ax
	mov	ah,GET_CURRENT_PDB
	int	21h			; point to user's header
	mov	ax,Handle01
	mov	ds,bx
	assume ds:NOTHING
	lds	bx,ds:Pdb_Jfn_Pointer	; DS:BX = ptr to jfn table
	mov	word ptr ds:[bx],ax	; stuff his old 0 and 1
	pop	ax
	pop	bx
	pop	ds
	ret




	assume ds:DATARES,ss:DATARES

Hopeless:
	mov	dx,offset DATARES:ComBad
	jmp	FatalC

GetComDsk:
	mov	al,ComDrv
	call	RemCheck
	jnz	Hopeless			; non-removable media
GetComDsk3:
	cmp	dx,offset DATARES:ComBad
	jnz	GetComDsk4
	mov	dx,offset DATARES:ComBad	; DX = ptr to msg
	invoke	RPrint				; say COMMAND is invalid
GetComDsk4:
;	Bugbug:	there's always a drive here?  No need to check?
	cmp	PutBackDrv,0		; is there a drive in the comspec?
	jnz	Users_Drive		; yes - use it
	mov	ah,GET_DEFAULT_DRIVE	; use default drive
	int	21h
	add	al,"A"                  ; convert to ascii
	mov	PutBackDrv,al		; put in message to print out

Users_Drive:
	mov	dx,offset DATARES:PutBackMsg		; prompt for diskette
	mov	si,offset DATARES:PutBackSubst		;  containing COMMAND
	invoke	RPrint
	mov	dx,offset DATARES:Prompt		; "Press any key"
	invoke	RPrint
	call	GetRawFlushedByte
	ret




;***	GetRawFlushedByte - flush world and get raw input

GetRawFlushedByte:
	mov	ax,(STD_CON_INPUT_FLUSH shl 8) or RAW_CON_INPUT
	int	21h			; get char without testing or echo
	mov	ax,(STD_CON_INPUT_FLUSH shl 8) + 0
	int	21h
;	Bugbug:	get rid of this return and the following retz.
	return




;***	LoadCom - load in transient

LoadCom:
	inc	bp				; flag command read
	mov	dx,offset DATARES:ComSpec
	mov	ax,OPEN shl 8
	int	21h				; open command.com
	jnc	ReadCom
	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
	jnz	TryDoOpen
	mov	dx,offset DATARES:NoHandMes
	jmp	FatalC				; will never find a handle

TryDoOpen:
	call	GetComDsk
	jmp	LoadCom

ReadCom:
	mov	bx,ax				; BX = handle
	mov	dx,offset RESGROUP:TranStart
	xor	cx,cx				; CX:DX = seek loc
	mov	ax,LSEEK shl 8
	int	21h
	jc	WrongCom1
	mov	cx,offset TRANGROUP:TranSpaceEnd - 100h

	push	ds
	mov	ds,TrnSeg
	assume	ds:NOTHING
	mov	dx,100h
	mov	ah,READ
	int	21h
	pop	ds
	assume	ds:DATARES
WrongCom1:
	pushf
	push	ax
	mov	ah,CLOSE
	int	21h			; close command.com
	pop	ax
	popf
	jc	WrongCom		; error on read
	cmp	ax,cx
	retz				; size matched
WrongCom:
	mov	dx,offset DATARES:ComBad
	call	GetComDsk
	jmp	LoadCom 		; try again



;***	ChkSum - compute transient checksum

ChkSum:
	push	ds
	mov	ds,TrnSeg
	mov	si,100h
	mov	cx,offset TRANGROUP:TranDataEnd - 100H

Check_Sum:
	cld
	shr	cx,1
	xor	dx,dx
Chk:
	lodsw
	add	dx,ax
	adc	dx,0
	loop	Chk
	pop	ds
	ret




;***	SetVect - set interrupt vectors

SetVect:
	mov	dx,offset DATARES:LodCom_Trap
	mov	ax,(SET_INTERRUPT_VECTOR shl 8) or 22h
	mov	word ptr ds:Pdb_Exit,dx
	mov	word ptr ds:Pdb_Exit+2,ds
	int	21h
	mov	dx,offset DATARES:Ctrlc_Trap
	inc	al
	int	21h
	mov	dx,offset DATARES:CritErr_Trap
	inc	al
	int	21h
	ret

;SR;
; We have this to take care of the extra values pushed on the stack by 
;the stub before jumping to LodCom1. We set up ds here and then jump to
;Lodcom1
;
public	TrnLodCom1
TrnLodCom1:
	pop	ds			;ds = DATARES
	add	sp,2
;	pop	ds:OldDS
	jmp	LodCom1




;***	EndInit - end up initialization sequence
;
;	Move the environment to a newly allocated segment.

;;EndInit:
;;	push	ds			; save segments
;;	push	es			;
;;	push	cs			; get resident segment to DS
;;	pop	ds			;
;;	assume	ds:RESGROUP
;;	mov	cx,UsedEnv		; get number of bytes to move
;;	mov	es,EnvirSeg		; get target environment segment
;;	assume	es:NOTHING
;;
;;	mov	ds:Pdb_Environ,es	; put new environment in my header
;;	mov	ds,OldEnv		; source environment segment
;;	assume	ds:NOTHING
;;	xor	si,si			; set up offsets to start of segments
;;	xor	di,di
;;	cld
;;	rep	movsb			; move it
;;	xor	ax,ax
;;	stosb				; make sure it ends with double-null
;;
;;	cmp	ResetEnv,1		; do we need to setblock to env end?
;;	jne	NoReset 		; no - we already did it
;;	mov	bx,EnvSiz		; BX = size of environ in paragraphs
;;	push	es			; save environment - just to be sure
;;	mov	ah,SETBLOCK		;
;;	int	21h
;;	pop	es
;;
;;NoReset:
;;	mov	InitFlag,FALSE		; turn off init flag
;;	pop	es
;;	pop	ds
;;	jmp	LodCom			; allocate transient

;
;The init code has been changed to take care of the new way in which the
;environment segment is allocated.
;NB: We can use all the init variables at this point because they are all in
;RESGROUP
;Bugbug: The above approach will not work for ROMDOS
;

IF 0

EndInit:
	push	ds
	push	es			;save segments
	push	cs
	pop	ds		
	assume	ds:RESGROUP
;
;Chuckenv flag signals whether it is a passed environment or not
;
	mov	bx,ds
	mov	es,bx			;es = RESGROUP
;
;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
; code + data for low COMMAND
;
	mov	bx,ResSize		;Total size of resident
	mov	ah,SETBLOCK
	int	21h			;Set block to resident size
;
;Allocate the correct size for the environment
;
	mov	bx,EnvSiz		;bx = env size in paras
	mov	ah,ALLOC
	int	21h			;get memory
	jc	nomem_err		;out of memory,signal error

	mov	EnvirSeg,ax		;Store new environment segment
	mov	ds:PDB_Environ,ax		;Put new env seg in PSP
	mov	es,ax			;es = address of allocated memory
	assume	es:nothing

;
;Copy the environment to the newly allocated segment
;
	mov	cx,UsedEnv		;number of bytes to move

	push	ds
	mov	ds,OldEnv		;ds = Old environment segment
	assume	ds:nothing

	xor	si,si
	mov	di,si			;Start transfer from 0

	cld
	rep	movsb			;Do the copy

	xor	ax,ax			
	stosb				;Make it end with double-null

	pop	ds			;ds = RESGROUP
	assume	ds:RESGROUP
;
;We have to free the old environment block if it was allocated by INIT
;
	cmp	Chuckenv,0		;has env been allocated by INIT?
	jne	no_free		;no, do not free it

	mov	ax,OldEnv		;Get old environment
	mov	es,ax
	mov	ah,DEALLOC	
	int	21h			;Free it
no_free:
	mov	InitFlag,FALSE		;indicate INIT is done
	
	pop	es
	pop	ds
	assume	ds:nothing
	
	jmp	LodCom			;allocate transient

nomem_err:
;
;We call the error routine which will never return. It will either exit
;with an error ( if not the first COMMAND ) or just hang after an error 
;message ( if first COMMAND )
;

	call	Alloc_error
ENDIF

CODERES ends



;	This TAIL segment is used to produce a PARA aligned label in
;	the resident group which is the location where the transient
;	segments will be loaded initial.

TAIL		segment public para

		org	0
TranStart	label	word
		public	TranStart

TAIL		ends



;	This TAIL segment is used to produce a PARA aligned label in
;	the transient group which is the location where the exec
;	segments will be loaded initial.
;
;	Bugbug:	Is TRANTAIL used anymore?

TRANTAIL	segment public para

		org	0
ExecStart   	label   word

TRANTAIL    	ends

		end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\comequ.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)comequ.asm 1.1 85/05/14
;	SCCSID = @(#)comequ.asm 1.1 85/05/14
;*************************************
; COMMAND EQUs which are not switch dependant

		include	curdir.inc	; to get DIRSTRLEN
;		Note dossym.inc must already have been included!

EMGDEBUG = FALSE

SYM		EQU	">"

ifdef JAPAN
LINESPERPAGE	EQU	24
else					; if Not JAPAN
LINESPERPAGE	EQU	25		;AC000; default lines per page
endif
NORMPERLIN	EQU	1
WIDEPERLIN	EQU	5
COMBUFLEN       EQU     128             ; Length of commmand buffer
EXECPATHLEN     EQU     273             ; MAX_PATH+13 (expanded for ntvdm)
BatLen		EQU	32		; buffer for batch files
YES_ECHO	EQU	1		; echo line
NO_ECHO 	EQU	0		; don't echo line
No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
call_in_progress EQU	1		; indicate we're in the CALL command
length_call	EQU	4		; length of CALL
max_nest	EQU    10		; max # levels of batch nesting allowed
fail_allowed	EQU    00001000b	; critical error
retry_allowed	EQU    00010000b	; critical error
Ignore_allowed	EQU    00100000b	; critical error
nullcommand	EQU    1		; no command on command line
end_of_line	EQU    -1		;AN000; end of line return from parser
end_of_line_out EQU	0		;AN000; end of line for output
end_of_line_in	EQU	0dh		;AN000; end of line for input
result_number	EQU	1		;AN000; number returned from parser
result_string	EQU	3		;AN000; string returned from parser
result_filespec EQU	5		;AN000; filespec returned from parser
result_drive	EQU	6		;AN000; drive returned from parser
result_date	EQU	7		;AN000; date returned from parser
result_time	EQU	8		;AN000; time returned from parser
result_no_error EQU	0		;AN000; no error returned from parser
no_cont_flag	EQU	0		;AN000; no control flags for message
util_msg_class	EQU	-1		;AN000; message class for utility
ext_msg_class	EQU	1		;AN000; message class for extended error
parse_msg_class EQU	2		;AN000; message class for parse error
crit_msg_class	EQU	3		;AN000; message class for critical error
ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
colon_char	EQU	":"             ;AN000; colon character
crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
text_mode	EQU	1		;AN000; text mode return from ioctl
get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
shell_action	equ	0ffh		;AN000; SHELL - return for taking SHELL specific action
bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
Parm_off_pos	equ	word ptr 2	;AN000; Offset from start of subst list for subst offset
parm_block_size equ	11		;AN000; size of message subst block
blank		equ	" "             ;AN000; blank character
no_subst	equ	0		;AN000; no substitutions for messages
one_subst	equ	1		;AN000; one substitution for messages
no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
res_subst	equ	2		;AN000; offset from start of message definition to number of subst
read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
capital_A	equ	'A'             ;AC000;
vbar		equ	'|'             ;AC000;
labracket	equ	'<'             ;AC000;
rabracket	equ	'>'             ;AC000;
dollar		equ	'$'             ;AC000;
lparen		equ	'('             ;AC000;
rparen		equ	')'             ;AC000;
nullrparen	equ	29h		;AC000;
in_word 	equ	4e49h		;AC000; 'NI'  ('IN' backwards)
do_word 	equ	4f44h		;AC000; 'OD'  ('DO' backwards)
star		equ	'*'             ;AC000;
plus_chr	equ	'+'             ;AC000;
small_a 	equ	'a'             ;AC000;
small_z 	equ	'z'             ;AC000;
dot_chr 	equ	'.'             ;AC000;
tab_chr 	equ	9		;AN032;
equal_chr	equ	'='             ;AN032;
semicolon	equ	';'             ;AN049;
dot_qmark	equ	2e3fh		;AC000; '.?'
dot_colon	equ	2e3ah		;AC000; '.:'
capital_n	equ	0		;AC000; result from Y/N call if N entered
capital_y	equ	1		;AC000; result from Y/N call if Y entered
AppendInstall	equ	0B700H		;AN020; append install check
AppendDOS	equ	0B702H		;AN020; append DOS version check
AppendGetState	equ	0B706H		;AN020; append get current state
AppendSetState	equ	0B707H		;AN020; append set current state
AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
search_attr	equ	attr_read_only+attr_hidden+attr_directory  ;AC042;

;*************************************
;* PARSE ERROR MESSAGES
;*************************************

MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number

;*************************************
;* EQUATES FOR MESSAGE RETRIEVER
;*************************************

GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever

;*********************************
;* EQUATES FOR INT 10H
;*********************************

VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white

AltPipeChr	equ	"|"             ; alternate pipe character

FCB		EQU	5CH

VARSTRUC	STRUC
ISDIR		DB	?
SIZ		DB	?
TTAIL		DW	?
INFO		DB	?
BUF		DB	DIRSTRLEN + 20 DUP (?)
VARSTRUC	ENDS

;
; Flags for internal command parsing
;
fCheckDrive	equ	00000001b	; validate drive letter
fSwitchAllowed	equ	00000010b	; switches allowed
fLimitHelp	equ	00000100b	; /? must appear alone

;
; Test switches
;
fParse		EQU	0001h		; display results of parseline

;
; Batch segment structure
;
;   BYTE    type of segment
;   BYTE    echo state of parent on entry to batch file
;   WORD    segment of last batch file
;   WORD    segment for FOR command
;   BYTE    FOR flag state on entry to batch file
;   DWORD   offset for next line
;   10 WORD pointers to parameters.  -1 is empty parameter
;   ASCIZ   file name (with . and ..)
;   BYTES   CR-terminated parameters
;   BYTE    0 flag to indicate end of parameters
;

BatchType   equ 0

BatchSegment	struc
BatType 	DB	BatchType	; signature
Batechoflag	DB	0		; G state of echo
BatchEOF		DB	0	;records if EOF reached on file
Batlast 	DW	0		; G segment of last batch file
Batforptr	DW	0		; G segment for FOR command
Batforflag	DB	0		; G state of FOR
BatSeek 	DD	?		; lseek position of next char
BatParm 	DW	10 dup (?)	; pointers to parameters
BatFile 	DB	?		; beginning of batch file name
BatchSegment	ends

ANULL		equ	0		; terminates an argv string
ARGMAX		equ	64		; max args on a command line
ARGBLEN 	equ	2*128		; 1char each plus term NUL
tplen		equ	64		; max size of one argument
arg_cnt_error	equ	1		; number of args > MAXARG
arg_buf_ovflow	equ	2		; overflowed argbuffer

argv_ele   STRUC			; elements in the argv array
    argpointer	DW	(?)		; pointer to the argstring
    argflags	DB	(?)		; cparse flags for this argstring
    argstartel	DW	(?)		; the result of cparse's [STARTEL]
    arglen	DW	(?)		; cparse's char count + one (for null)
    argsw_word	DW	(?)		; any switches after this?  what kinds?
    arg_ocomptr DW	(?)		; pointer into original command string
argv_ele   ENDS

arg_unit    STRUC
    argv	DB	(ARGMAX * SIZE argv_ele) DUP (?)
    argvcnt	DW	(?)		; number of arguments
    argswinfo	DW	(?)		; Switch information for entire line
    argbuf	DW	ARGBLEN DUP (?) ; storage for argv strings
    argforcombuf db	COMBUFLEN DUP (?) ; Original for loop command string
arg_unit    ENDS

parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1

SwitchQues 	EQU	20h
SwitchV 	EQU	10h
SwitchB 	EQU	08h
SwitchA 	EQU	04h
SwitchP 	EQU	02h
SwitchW 	EQU	01h
fSwitch 	EQU	8000h
fBadSwitch	EQU	4000h

SwitchDir	EQU	SwitchP + SwitchW + fSwitch
SwitchCopy	EQU	SwitchV + SwitchA + SwitchB + fSwitch

break <Trap:  Get the attention of MSDOS>
;   TRAP snares the operating system for a service call
; AX, as well as any other registers MS-DOS takes a fancy to, will be crunched.
trap	MACRO	dos_function,dos_info
    ifnb    <dos_info>
	mov	AX, (dos_function SHL 8) + dos_info
    else
	mov	AX, (dos_function SHL 8)
    endif
	int	21h
ENDM

;
; Equates for initialization
;
initInit	equ	01h		; initialization in progress
initSpecial	equ	02h		; in initialization time/date routine
initCtrlC	equ	04h		; already in ^C handler

;M052 BETA3WARN	equ	1		; Yank anything related to this EQU
					; out before we ship


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\command1.asm ===
page ,132
	title	COMMAND - resident code for COMMAND.COM
	name	COMMAND
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;*****************************************************************************
;
; MODULE:	       COMMAND.COM
;
; DESCRIPTIVE NAME:    Default DOS command interpreter
;
; FUNCTION:	       This version of COMMAND is divided into three distinct
;		       parts.  First is the resident portion, which includes
;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
;		       error), and 2EH (command line execute); it also has
;		       code to test and, if necessary, reload the transient
;		       portion. Following the resident is the init code, which
;		       is overwritten after use.  Then comes the transient
;		       portion, which includes all command processing (whether
;		       internal or external).  The transient portion loads at
;		       the end of physical memory, and it may be overlayed by
;		       programs that need as much memory as possible. When the
;		       resident portion of command regains control from a user
;		       program, a check sum is performed on the transient
;		       portion to see if it must be reloaded.  Thus programs
;		       which do not need maximum memory will save the time
;		       required to reload COMMAND when they terminate.
;
; ENTRY POINT:	       PROGSTART
;
; INPUT:	       command line at offset 81H
;
; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
;		       from a secondary command processor via the EXIT
;		       internal command.
;
; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
;		       hang the system.
;
; INTERNAL REFERENCES:
;
;     ROUTINES:        See the COMMAND Subroutine Description Document
;		       (COMMAND.DOC)
;
;     DATA AREAS:      See the COMMAND Subroutine Description Document
;		       (COMMAND.DOC)
;
; EXTERNAL REFERENCES:
;
;      ROUTINES:       none
;
;      DATA AREAS:     none
;
;*****************************************************************************
;
;			      REVISION HISTORY
;			      ----------------
;
; DOS 1.00 to DOS 3.30
; --------------------------
; SEE REVISION LOG IN COPY.ASM ALSO
;
; REV 1.17
;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
;	       resident since the EXELOAD may have overwritten the transient.
;
; REV 1.18
;    05/21/82  IBM version always looks on drive A
;	       MSVER always looks on default drive
;
; REV 1.19
;    06/03/82  Drive spec now entered in command line
;    06/07/82  Added VER command (print DOS version number) and VOL command
;	       (print volume label)
;
; REV 1.20
;    06/09/82  Prints "directory" after directories
;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
;
; REV 1.50
;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
;	       do it right.
;
; REV 1.70
;	       EXEC used to fork off new processes
;
; REV 1.80
;	       C switch for single command execution
;
; REV 1.90
;	       Batch uses XENIX
;
; Rev 2.00
;	       Lots of neato stuff
;	       IBM 2.00 level
;
; Rev 2.01
;	       'D' switch for date time suppression
;
; Rev 2.02
;	       Default userpath is NUL rather than BIN
;		       same as IBM
;	       COMMAND split into pieces
;
; Rev 2.10
;	       INTERNATIONAL SUPPORT
;
; Rev 2.50
;	       all the 2.x new stuff -MU
;
; Rev 3.30     (Ellen G)
;	       CALL internal command (TBATCH2.ASM)
;	       CHCP internal command (TCMD2B.ASM)
;	       INT 24H support of abort, retry, ignore, and fail prompt
;	       @ sign suppression of batch file line
;	       Replaceable environment value support in batch files
;	       INT 2FH calls for APPEND
;	       Lots of PTR fixes!
;
; Beyond 3.30 to forever  (Ellen G)
; ----------------------
;
; A000 DOS 4.00  -	Use SYSPARSE for internal commands
;			Use Message Retriever services
;			/MSG switch for resident extended error msg
;			Convert to new capitalization support
;			Better error recovery on CHCP command
;			Code page file tag support
;			TRUENAME internal command
;			Extended screen line support
;			/P switch on DEL/ERASE command
;			Improved file redirection error recovery
;	(removed)	Improved batch file performance
;			Unconditional DBCS support
;			Volume serial number support
;	(removed)	COMMENT=?? support
;
; A001	PTM P20 	Move system_cpage from TDATA to TSPC
;
; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
;			require delimiters.
;
; A003	PTM P5,P9,P111	Included in A000 development
;
; A004	PTM P86 	Fix IF command to turn off piping before
;			executing
;
; A005	DCR D17 	If user specifies an extension on the command
;			line search for that extension only.
;
; A006	DCR D15 	New message for MkDir - "Directory already
;			exists"
;
; A007	DCR D2		Change CTTY so that a write is done before XDUP
;
; A008	PTM P182	Change COPY to set default if invalid function
;			returned from code page call.
;
; A009	PTM P179	Add CRLF to invalid disk change message
;
; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
;			transient COMMAND.
;
; A011	DCR D130	Change redirection to overwrite an EOF mark
;			before appending to a file.
;
; A012	PTM P189	Fix redirection error recovery.
;
; A013	PTM P330	Change date format
;
; A014	PTM P455	Fix echo parsing
;
; A015	PTM P517	Fix DIR problem with * vs *.
;
; A016	PTM P354	Fix extended error message addressing
;
; A017	PTM P448	Fix appending to 0 length files
;
; A018	PTM P566,P3903	Fix parse error messages to print out parameter
;			the parser fails on. Fail on duplicate switches.
;
; A019	PTM P542	Fix device name to be printed correctly during
;			critical error
;
; A020	DCR D43 	Set append state off while in DIR
;
; A021	PTM P709	Fix CTTY printing ascii characters.
;
; A022	DCR D209	Enhanced error recovery
;
; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
;
; A024	PTM P899	Fix EXTOPEN open modes.
;
; A025	PTM P922	Fix messages and optimize PARSE switches
;
; A026	DCR D191	Change redirection error recovery support.
;
; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
;			with a carriage return.
;
; A028	PTM P1076	Print a blank line before printing invalid
;			date and invalid time messages.
;
; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
;			and TIME.
;
; A030	DCR D201	New extended attribute format.
;
; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
;
; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
;
; A033	PTM P1298	Fix problem with system crashes on ECHO >""
;
; A034	PTM P1387	Fix COPY D:fname+,, to work
;
; A035	PTM P1407	Fix so that >> (appending) to a device does
;			do a read to determine eof.
;
; A036	PTM P1406	Use 69h instead of 44h to get volume serial
;			so that ASSIGN works correctly.
;
; A037	PTM P1335	Fix COMMAND /C with FOR
;
; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
;
; A039	DCR D284	Change invalid code page tag from -1 to 0.
;
; A040	PTM P1787	Fix redirection to cause error when no file is
;			specified.
;
; A041	PTM P1705	Close redirected files after internal APPEND
;			executes.
;
; A042	PTM P1276	Fix problem of APPEND paths changes in batch
;			files causing loss of batch file.
;
; A043	PTM P2208	Make sure redirection is not set up twice for
;			CALL'ed batch files.
;
; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
;			as an end of line character
;
; A045	PTM P2560	Make sure we don't lose parse, critical error,
;			and extended message pointers when we EXIT if
;			COMMAND /P is the top level process.
;
; A046	PTM P2690	Change COPY message "fn File not found" to
;			"File not found - fn"
;
; A047	PTM P2819	Fix transient reload prompt message
;
; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
;			when DBCS code was added.
;
; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
;			on line.
;
; A050	PTM P3030	Fix TYPE to work properly on files > 64K
;
; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
;
; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
;
; A053	PTM P2865	Fix DIR to work in 40 column mode.
;
; A054	PTM P3407	Code reduction and critical error on single line
;	PTM P3672	(Change to single parser exported under P3407)
;
; A055	PTM P3282	Reset message service variables in INT 23h to fix
;			problems with breaking out of INT 24h
;
; A056	PTM P3389	Fix problem of environment overlaying transient.
;
; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
;			before the "string".  EX: COMMAND /CDIR
;
; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
;			DBCS switch.
;
; A059	PTM P3394	Change the TIME command to right align the display of
;			the time.
;
; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
;			messages to be disk based.  Only keep them if /MSG
;			is used.
;
; A061	PTM P3928	Fix so that transient doesn't reload when breaking
;			out of internal commands, due to substitution blocks
;			not being reset.
;
; A062	PTM P4079	Fix segment override for fetching address of environment
;			of parent copy of COMMAND when no COMSPEC exists in
;			secondary copy of environment.	Change default slash in
;			default comspec string to backslash.
;
; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
;			text for critical error messages.
;
; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
;	5/20/88 	with Microsoft product already shipped.
;
; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
;	 5/20/88	with Microsoft product already shipped.
;
; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
;	 5/24/88	cases; where the listing would barely fit without the
;			header and space remaining.
;
; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
;			environment was putting a "Z block" marker in the old
;			environment.  The fix is to move to the old environment
;			to the new environment before doing the SETBLOCK.
;
; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
;        09/19/88       because the check for APPEND needed to be performed
;                       before the DIR's findfirst.
;
; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
;                       loading trans w/new comspec with no user change comspec.
;
; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
;        11/05/88       Expansion of environment variables into batch line of
;                       128 chars was not being counted and "%" which should be
;                       ignored were being counted.
;
; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
;        03/02/89       used.  Comspec_flag was not in protected data file be-
;                       ing included in checksum and was being overwritten by
;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
;                       Also removed fix A069 (because flag now protected).
;
; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
;        07/25/89       version and CSD version in U.S. date format.  Files
;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
;
;***********************************************************************************

;
;	Revision History
;	================
;
;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
;				at init time (date/time prompt)
;


.xcref
.xlist
	include dossym.inc		; basic DOS symbol set
	include syscall.inc		; DOS function names
	include comsw.asm		; build version info
	include comequ.asm		; common command.com symbols
	include resmsg.equ		; resident message names

	include comseg.asm		;segment ordering
.list
.cref

CODERES segment public byte
CODERES ends

DATARES 	segment public byte
		extrn	AccDen:byte
		extrn	Batch:word
		extrn	EchoFlag:byte
		extrn	ExeBad:byte
		extrn	ExecEMes:byte
		extrn	ExecErrSubst:byte
		extrn	ExtCom:byte
		extrn	ForFlag:byte
		extrn	IfFlag:byte
		extrn	InitFlag:BYTE
		extrn	Nest:word
		extrn	PipeFlag:byte
		extrn	RBadNam:byte
		extrn	RetCode:word
		extrn	SingleCom:word
		extrn	TooBig:byte

		extrn	OldDS:word
                EXTRN   SCS_REENTERED:BYTE
                EXTRN   SCS_CMDPROMPT:BYTE

DATARES 	ends


INIT		segment public para
		extrn	ConProc:near
		extrn	Init_Contc_SpecialCase:near
INIT		ends


		include envdata.asm

Prompt32        equ     1

;***	START OF RESIDENT PORTION

CODERES segment public byte

	public	Ext_Exec
	public	ContC
	public	Exec_Wait
	public	Exec_Ret

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	extrn	LodCom:near
	extrn	LodCom1:near

	org	0
Zero	=	$

;;	org	80h - 1
;;ResCom	label byte
;;	public	ResCom

;;	org	100h

public	StartCode
StartCode:
;;	jmp	RESGROUP:ConProc



;***	EXEC error handling
;
;	COMMAND has issued an EXEC system call and it has returned an error.
;	We examine the error code and select an appropriate message.

;	Bugbug:	optimize reg usage in following code?  Careful of DX!
;	Condense the error scan?
;	RBADNAM is checked by transient, no need here?
;	Move below Ext_Exec.

Exec_Err:
;SR;
; ds,es are setup when the transient jumps to Ext_Exec. So segment regs are
;in order here

	assume	ds:DATARES,es:DATARES

;	Bugbug:	can we use byte compares here?
;	Might be able to use byte msg#s, too.

;	Store errors in a 3 or 4 byte table.  Msg #s in another.
;	Speed not high priority here.

;	Move this to transient.

	mov	bx,offset DATARES:RBadNam
	cmp	al,ERROR_FILE_NOT_FOUND
	je	GotExecEMes		  	; bad command
	mov	bx,offset DATARES:TooBig
	cmp	al,ERROR_NOT_ENOUGH_MEMORY
	je	GotExecEMes		 	; file not found
	mov	bx,offset DATARES:ExeBad
	cmp	al,ERROR_BAD_FORMAT
	je	GotExecEMes		 	; bad exe file
	mov	bx,offset DATARES:AccDen
	cmp	al,ERROR_ACCESS_DENIED
	je	GotExecEMes		 	; access denied

Default_Message:
	mov	bx,offset DATARES:ExecEMes	; default message
	mov	si,offset DATARES:ExecErrSubst ; get address of subst block

GotExecEMes:
        mov     dx,bx                           ; DX = ptr to msg
;; williamh: no reason of doing this. When command.com receives a command,
;;	     it means the VDM process has been created successfully and there
;;	     is no way for the parent process to know that we are not able
;;	     to launch the program and therefore, it won't display any error
;;	     message for us.
;;	 cmp	 byte ptr [scs_reentered],1
;;	 jne	 NoErrMsg
;;	 cmp	 byte ptr [scs_cmdprompt],Prompt32
;;	 je	 NoErrMsg
        invoke  RPrint
NoErrMsg:
	jmp	short NoExec



;***	EXEC call
;
;	The transient has set up everything for an EXEC system call.
;	For cleanliness, we issue the EXEC here in the resident 
;	so that we may be able to recover cleanly upon success.
;
;	CS,DS,ES,SS = DATARES seg addr

Ext_Exec:
;SR;
; The words put on the stack by the stub will be popped off when we finally
;jump to LodCom ( by LodCom).
;
;;	int	21h			; do the exec

Exec_Ret:
	jc	Exec_Err		; exec failed

;	The exec has completed.  Retrieve the exit code.

Exec_Wait:
	mov	ah,WAITPROCESS		; get errorlevel
	int	21h			; get the return code
	mov	RetCode,ax

;	See if we can reload the transient.  The external command
;	may have overwritten part of the transient.

NoExec:
;SR;
; ds = es = ss = DATARES when we jump to LodCom
;
	jmp	LodCom




;***	Int 23 (ctrl-c) handler
;
;	This is the default system INT 23 handler.  All processes
;	(including COMMAND) get it by default.  There are some
;	games that are played:  We ignore ^C during most of the
;	INIT code.  This is because we may perform an ALLOC and
;	diddle the header!  Also, if we are prompting for date/time
;	in the init code, we are to treat ^C as empty responses.


;	Bugbug:	put init ctrl-c handling in init module.

;SR;
; The stub has pushed the previous ds and DATARES onto the stack. We get
;both these values off the stack now
;
ContC	proc	far

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	pop	ds			;ds = DATARES
	assume	ds:DATARES
;	pop	OldDS			;OldDS = old ds

	test	InitFlag,INITINIT		; in initialization?
	jz	NotAtInit			; no
	test	InitFlag,INITSPECIAL		; doing special stuff?
	jz	CmdIRet 			; no, ignore ^C
	pop	ds			; restore before jumping; M021
	jmp	RESGROUP:Init_ContC_SpecialCase ; Yes, go handle it
CmdIret:
;SR;
; Restore ds to its previous value
;

;	mov	ds,OLdDS		;
	pop	ds
	iret				; yes, ignore the ^C

NotAtInit:
	test	InitFlag,INITCTRLC		; are we already in a ^C?
	jz	NotInit 			; nope too.

;*	We are interrupting ourselves in this ^C handler.  We need
;	to set carry and return to the user sans flags only if the
;	system call was a 1-12 one.  Otherwise, we ignore the ^C.

	cmp	ah,1
	jb	CmdIRet
	cmp	ah,12
	ja	CmdIRet

	pop	ds			;restore ds to old value
	add	sp,6				; remove int frame
	stc

;	mov	ds,OldDS		;restore ds to its old value
	ret	2				; remove those flags...

NotInit:

;*	We have now received a ^C for some process (maybe ourselves
;	but not at INIT).
;	
;	Note that we are running on the user's stack!!!  Bad news if
;	any of the system calls below go and issue another INT
;	24...  Massive stack overflow!  Another bad point is that
;	SavHand will save an already saved handle, thus losing a
;	possible redirection...
;	
;	All we need to do is set the flag to indicate nested ^C. 
;	The above code will correctly flag the ^C diring the
;	message output and prompting while ignoring the ^C the rest
;	of the time.
;	
;	Clean up: flush disk.  If we are in the middle of a batch
;	file, we ask if he wants to terminate it.  If he does, then
;	we turn off all internal flags and let the DOS abort.

	or	InitFlag,INITCTRLC	; nested ^c is on
	sti

;;	push	cs			; el yucko!  change the user's ds!!
;;	pop	ds
;;	assume	ds:RESGROUP

	pop	ax			;discard the old ds value

	mov	ax,SingleCom
	or	ax,ax
	jnz	NoReset
	push	ax
	mov	ah,DISK_RESET
	int	21h			; reset disks in case files were open
	pop	ax

NoReset:

;	In the generalized version of FOR, PIPE and BATCH, we would
;	walk the entire active list and free each segment.  Here,
;	we just free the single batch segment.

	test	Batch,-1
	jz	ContCTerm
	or	ax,ax
	jnz	ContCTerm
	invoke	SavHand
	invoke	AskEnd			; ask if user wants to end batch

;	If the carry flag is clear, we do NOT free up the batch file

	jnc	ContBatch
	mov	cl,EchoFlag		; get current echo flag
	push	bx

ClearBatch:
	mov	es,Batch		; get batch segment
	mov	di,BatFile		; get offset of batch file name
;	Bugbug:	verify the following shell interface still works
;;	mov	ax,MULT_SHELL_BRK	; does the SHELL want this terminated?
;;	int	2Fh			; call the SHELL
;;	cmp	al,SHELL_ACTION 	; does shell want this batch?
;;	je	Shell_Bat_Cont		; yes - keep it

	mov	bx,es:BatForPtr		; get old FOR segment
	cmp	bx,0			; is a FOR in progress
	je	no_bat_for		; no - don't deallocate
	push	es			;
	mov	es,bx			; yes - free it up...
	mov	ah,DEALLOC		;
	int	21h			;
	pop	es			; restore to batch segment

No_Bat_For:
	mov	cl,es:BatEchoFlag	; get old echo flag
	mov	bx,es:BatLast	 	; get old batch segment
	mov	ah,DEALLOC		; free it up...
	int	21h
	mov	Batch,bx		; get ready to deallocate next batch
	dec	nest			; is there another batch file?
	jnz	ClearBatch		; keep going until no batch file


;	We are terminating a batch file; restore the echo status


Shell_Bat_Cont: 			; continue batch for SHELL

	pop	bx
	mov	EchoFlag,cl		; reset echo status
	mov	PipeFlag,0		; turn off pipeflag
ContBatch:
	invoke	Crlf			; print out crlf before returning
	invoke	RestHand

;	Yes, we are terminating.  Turn off flags and allow the DOS to abort.

ContCTerm:
	xor	ax,ax			; indicate no read
	mov	bp,ax

;	The following resetting of the state flags is good for the
;	generalized batch processing.

	mov	IfFlag,al		; turn off iffing
	mov	ForFlag,al		; turn off for processing
	call	ResPipeOff
	cmp	SingleCom,ax		; see if we need to set singlecom
	jz	NoSetSing
	mov	SingleCom,-1		; cause termination on 
					;  pipe, batch, for
NoSetSing:

;	If we are doing an internal command, go through the reload process.
;	If we are doing an external, let DOS abort the process.
;	In both cases, we are now done with the ^C processing.

	and	InitFlag,not INITCTRLC
	cmp	ExtCom,al
	jnz	DoDAb				; internal ^c
	jmp	LodCom1
DoDAb:
	stc					; tell dos to abort

;SR;
;We dont need to restore ds here because we are forcing DOS to  do an abort
;by setting carry and leaving flags on the stack
;
	ret					; Leave flags on stack
ContC	endp


;SR;
; ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
;both have ds = DATARES
;

ResPipeOff:
	public	ResPipeOff

	assume	ds:DATARES,es:NOTHING

	savereg <ax>
	xor	ax,ax
	xchg	PipeFlag,al
	or	al,al
	jz	NoPipePop
	shr	EchoFlag,1
NoPipePop:
	restorereg  <ax>
	return


CODERES ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\buildmsg.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/* -------------------------------------------------------------------------- */

#include "dos.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
#include "ctype.h"
#include "process.h"
#include "malloc.h"
#include "bldmsg.h"

/* -------------------------------------------------------------------------- */

#define FALSE		(char) (1==0)
#define TRUE		(char) !FALSE
#define NUL		(char) '\0'
#define READONLY	0
#define NAME_COMMAND	"COMMAND\0"     /* Mar 88, SWN */

#define MAXLINE 	200		/* Supposed to be used for getting the message text. */
#define MAXUTILERROR	       300
#define MAXEXTENDEDERROR       100
#define MAXPARSERERROR		20
#define MAXCOMMONERROR	       100
#define MAXLENGTH	       500
#define TOTALUTIL		45

/* -------------------------------------------------------------------------- */

#define ParseOrExtend ((!strnicmp(USEstring,"PARSE\n",5) ) || (!strnicmp(USEstring,"EXTEND\0",5) ) )
#define IsReserved(c)	( (c == '1') || (c == '2') )

/* -------------------------------------------------------------------------- */

	char	*MessageSkeletonFilePtr;


	char	*CommentLinePtr = "\x0d\x0a; ----------------------------------------------------------\x0d\x0a\x0d\x0a";

	char	EofFlags[256];

	char	ClassFlag1;
	char	ClassFlag2;
	int	ClassCount;
	int	ClassCounts[256];
	int	CurrentClass;
	int	CurrentClassIndex;
	int	CurrentMessageNumber;
	int	LineNumber;
	int	add_crlf ;

	int	Pass;

	char	Done;
	char	MessagePending;
	char	ClassPending;

	char	UtilityName[16];
	char	USEstring[16] ;
	char	Is_Utility_Command[16]; /* Mar 88, SWN */
	char	Is_Command_set[] = "12cdeCDE";
	char	CurrentClassFileName[128];

	unsigned	SkeletonHandle = 0xffff;
	unsigned	ClassHandle = 0xffff;
	unsigned	CommonMessageLines;
	unsigned	ParserMessageLines;
	unsigned	ExtendedMessageLines;
	unsigned	UtilMessageLines;
	unsigned	ContinueLine;

	char	CountryIdx[128];
	char	CountryMsg[128];
	char	CountryName[128];

	char	ReadCommonFlag = FALSE;
	char	ReadExtendFlag = FALSE;
	char	ReadParserFlag = FALSE;
	char	ReadUtilFlag   = FALSE;

	char	*UtilErrorTexts[MAXUTILERROR+1];
	char	*ExtendedErrorTexts[MAXEXTENDEDERROR+1];
	char	*ParserErrorTexts[MAXPARSERERROR+1];
	char	*CommonErrorTexts[MAXCOMMONERROR+1];

	char	Debugging = FALSE;

/* -------------------------------------------------------------------------- */

void	 error(union REGS *, union REGS *, struct SREGS *);

void	 LineInput( unsigned, char far * );
unsigned DosRead( unsigned, char far *, int );
unsigned DosWrite( unsigned, char far *, int );
long	 DosLSeek( unsigned, long, int );
void	 DosClose( unsigned );
unsigned DosOpen( char far *, unsigned );
unsigned DosCreate( char far *, unsigned );

unsigned LowOf(long);
unsigned HighOf(long);
long	 LongOf(unsigned, unsigned);

void	 main(int, char * []);

void	 ProcessSkeletonFile(char *);
void	 UtilRecord(char *);
void	 ClassRecord(char *);
void	 DefRecord(char *);
void	 UseRecord(char *);
void	 EndRecord(char *);
void	 DefContinue(char *);
void	 UseContinue(char *);
void	 MessageTerminate(void);
void	 ClassTerminate(void);

void	 CommentLine(void);
void	 BlankLine(void);
void	 PublicLine(void);
void	 ReadCommon(void);

char	*MyMalloc(int);

/* -------------------------------------------------------------------------- */

void	main(argc,argv)
int	argc;
char	*argv[];
{

	int		i;
	char		*s;
	unsigned	len;

	char	 far	*PspCharPtr;
	unsigned far	*PspWordPtr;
	unsigned long	ProgramSize;
	unsigned long	MemoryAllocatable;

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	/* check for assistance needed */

	if ( (argc < 3) && (*argv[1] == (char) '?') )
	      {
		printf("BUILDMSG country skeleton-file-spec\n");
		exit(1);
		}

	/* get the 1st parm is the Country name       */
	/* get the skeleton file name (2nd Parm) to be processed */

	strcpy(CountryName, argv[1]);
    strupr(CountryName);
	strcpy(CountryIdx,CountryName);
	strcat(CountryIdx, ".IDX");
	strcpy(CountryMsg,CountryName);
	strcat(CountryMsg, ".MSG");

	for (i = 0; i <= MAXUTILERROR	 ; i++) UtilErrorTexts[i]     = "";
	for (i = 0; i <= MAXEXTENDEDERROR; i++) ExtendedErrorTexts[i] = "";
	for (i = 0; i <= MAXPARSERERROR  ; i++) ParserErrorTexts[i]   = "";
	for (i = 0; i <= MAXCOMMONERROR  ; i++) CommonErrorTexts[i]   = "";

	for (i = 0; i < 256; i++)
	      {
		ClassCounts[i] = 0;
		EofFlags[i] = TRUE;
		}

    if ( (argc > 3) && (strnicmp(argv[3],"/D",2) == 0) ) Debugging = TRUE;

	InRegs.x.ax = 0x6200;
	intdos(&InRegs, &OutRegs);

	printf("BuildMsg - PSP at %04x\n",OutRegs.x.bx);
	FP_SEG(PspWordPtr) = OutRegs.x.bx;
	FP_OFF(PspWordPtr) = 0;
	FP_SEG(PspCharPtr) = OutRegs.x.bx;
	FP_OFF(PspCharPtr) = 0;
	ProgramSize = (unsigned long) *(PspWordPtr+1);
	printf("Program memory size is %ld\n",ProgramSize);

	InRegs.x.ax = 0x4800;
	InRegs.x.bx = 0xffff;
	intdos(&InRegs, &OutRegs);
	if (OutRegs.x.cflag)
	      {
		InRegs.x.bx = OutRegs.x.bx;
		}
	 else {
		SegRegs.es = OutRegs.x.ax;
		InRegs.x.ax = 0x4900;
		intdosx(&InRegs, &OutRegs, &SegRegs);
		}

	MemoryAllocatable = (unsigned long) InRegs.x.bx;
	MemoryAllocatable *= 16;
	printf("Allocatable memory size is %ld\n",MemoryAllocatable);


	ProcessSkeletonFile(argv[2]);

	exit(0);

}

/* -------------------------------------------------------------------------- */

void	ProcessSkeletonFile(FileName)
char	*FileName;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	unsigned	SkeletonHandle;

	char		*s;
	int		i;
	char		out[128];

	char		CurrentRecord[256];
	char		RecordTypeText[32];
	int		LastRecord;
	char		Processed;


	MessageSkeletonFilePtr = FileName;

	printf("Processing [%s]\n",MessageSkeletonFilePtr);

	/* Process the MESSAGE.SKL file */

	SkeletonHandle = DosOpen( (char far *) MessageSkeletonFilePtr, READONLY);

	ClassCount = 0;

	for (Pass = 1; Pass < 3; Pass++)
	      {
		if (Debugging) printf("--> Starting Pass %d <--\n",Pass);
		ClassFlag1 = FALSE;
		ClassFlag2 = FALSE;
		CurrentClassIndex = 0;
		LineNumber = 0;
		CurrentClass = 0;
		Done = FALSE;
		LastRecord = 0;
		MessagePending = FALSE;
		ClassPending = FALSE;

		InRegs.x.ax = 0x4200;
		InRegs.x.bx = SkeletonHandle;
		InRegs.x.cx = 0;
		InRegs.x.dx = 0;
		intdosx(&InRegs,&OutRegs,&SegRegs);
		if (OutRegs.x.cflag)
			error(&InRegs,&OutRegs,&SegRegs);

		while ( (!EofFlags[SkeletonHandle]) && (!Done) )
		      { CurrentRecord[0] = NUL;
			LineInput(SkeletonHandle, (char far *) &CurrentRecord[0] );
			LineNumber++;

			RecordTypeText[0] = NUL;
			sscanf(&CurrentRecord[0]," %s ",&RecordTypeText[0]);
			i = strlen(RecordTypeText);

            strupr(RecordTypeText);

			if (RecordTypeText[0] == (char) ':') Processed = FALSE;
						       else  Processed = TRUE;

			if (strcmp(RecordTypeText,":UTIL")  == 0)
			      { UtilRecord(&CurrentRecord[i]);
				Processed = TRUE;
				LastRecord = 1;
				}

			if (strcmp(RecordTypeText,":CLASS") == 0)
			      { ClassRecord(&CurrentRecord[i]);
				Processed = TRUE;
				LastRecord = 2;
				}

			if (strcmp(RecordTypeText,":DEF")   == 0)
			      { DefRecord(&CurrentRecord[i]);
				Processed = TRUE;
				LastRecord = 3;
				}

			if (strcmp(RecordTypeText,":USE")   == 0)
			      { UseRecord(&CurrentRecord[i]);
				Processed = TRUE;
				LastRecord = 4;
				}

			if (strcmp(RecordTypeText,":END")   == 0)
			      { EndRecord(&CurrentRecord[i]);
				Processed = TRUE;
				LastRecord = 5;
				}

			if (!Processed)
			      { printf("Error: unrecognized record in skeleton file, line %d\n",LineNumber);
				exit(1);
				}

			}

		if (!ClassFlag1) ClassRecord(" 1 ");
		if (!ClassFlag2) ClassRecord(" 2 ");

		if (MessagePending) MessageTerminate();
		if (ClassPending) ClassTerminate();

		if (Debugging) printf("--> Ending   Pass %d <--\n",Pass);
		}

	DosClose(SkeletonHandle);

	sprintf(CurrentClassFileName,"%s.CTL",UtilityName);
	ClassHandle = DosCreate((char far *) &CurrentClassFileName[0], 0);
	i = sprintf(out,"$M_NUM_CLS  EQU %d\x0d\x0a",ClassCount-2);
	DosWrite(ClassHandle,(char far *) &out[0], i);
	DosClose(ClassHandle);

	SkeletonHandle = 0xfffe;  /*  0xfffe == -2  */

	return;

	}

/* -------------------------------------------------------------------------- */

void UtilRecord(Record)
char	*Record;
{

	sscanf(Record," %s ",UtilityName);

    strupr(UtilityName);

	if (Pass == 1)
	      {
		printf(" Utility Name = [%s]\n",UtilityName);
		ReadCommon();

		}

	return;
	}

/* -------------------------------------------------------------------------- */

void	PublicLine()
{

	int	i;
	char	out[128];

	if ( !IsReserved(CurrentClass) ) i = sprintf(out,"        PUBLIC  $M_CLS_%d\x0d\x0a",CurrentClassIndex);
				else i = sprintf(out,"        PUBLIC  $M_MSGSERV_%c\x0d\x0a",CurrentClass);

	DosWrite(ClassHandle,(char far *) &out[0], i);

	return;

	}

/* -------------------------------------------------------------------------- */

void ClassRecord(Record)
char	*Record;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	int	i;
	char	out[128];

	MessageTerminate();
	ClassTerminate();

	while ( isspace(*Record) ) Record++;

	*Record = (char) toupper(*Record);
	CurrentClass = (int) *Record;

	if ( !IsReserved(CurrentClass) ) CurrentClassIndex++;

	if (CurrentClass == '1') ClassFlag1 = TRUE;
	if (CurrentClass == '2') ClassFlag2 = TRUE;

	sprintf(CurrentClassFileName,"%s.%s%c",UtilityName,"CL",CurrentClass);

	if (Pass == 1)
	      {
		ClassHandle = DosCreate((char far *) &CurrentClassFileName[0], 0);

		printf(" Created include file [%s]\n",CurrentClassFileName);

		CommentLine();

		PublicLine();
		i = sprintf(out,"        IF1\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        %%out    ... Including message Class %c\x0d\x0a",CurrentClass);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        ENDIF\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);

		CommentLine();

		i = sprintf(out,"$M_CLASS_%c_STRUC LABEL BYTE\x0d\x0a",CurrentClass);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        $M_CLASS_ID <%03XH,EXPECTED_VERSION,Class_%c_MessageCount>\x0d\x0a",
			   ((!IsReserved(CurrentClass)) ? 255 : (CurrentClass-'0')),CurrentClass);
		DosWrite(ClassHandle,(char far *) &out[0], i);

		CommentLine();

		ClassCount++;

		}

	if (Pass == 2)
	      {

		ClassHandle = DosOpen((char far *) &CurrentClassFileName[0], 2);

		InRegs.x.ax = 0x4202;
		InRegs.x.bx = ClassHandle;
		InRegs.x.cx = 0;
		InRegs.x.dx = 0;
		intdosx(&InRegs,&OutRegs,&SegRegs);
		if (OutRegs.x.cflag)
			error(&InRegs,&OutRegs,&SegRegs);

		}

	ClassPending = TRUE;

	return;
	}

/* -------------------------------------------------------------------------- */

void	CommentLine()
{

	DosWrite(ClassHandle,(char far *) CommentLinePtr, strlen(CommentLinePtr) );

	return;

	}

/* -------------------------------------------------------------------------- */

void	BlankLine()
{

	DosWrite(ClassHandle,(char far *) "\x0d\x0a", 2 );

	return;

	}

/* -------------------------------------------------------------------------- */

void DefRecord(Record)
char	*Record;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	int	i,m;
	char	*TextPtr;
	char	*NumberPtr;
	char	out[128];
	char	ActualMsg[256];
	int	MsgNumber;

	char	MsgStatus;
	char	MsgLevel[5];

	char	*LfPtr;

	if ( IsReserved(CurrentClass) )
	      { printf("Error: :DEF not allowed in Class 1 or Class2, line %d\n",LineNumber);
		exit(1);
		}

	MessageTerminate();

	TextPtr = Record;
	while ( (isspace(*TextPtr)) && (*TextPtr != NUL) ) TextPtr++;
	NumberPtr = TextPtr;
	while ( (!isspace(*TextPtr)) && (*TextPtr != NUL) ) TextPtr++;

	sscanf(NumberPtr," %d ",&CurrentMessageNumber);

	if (Pass == 1)
	      {
		BlankLine();

		i = sprintf(out,"$M_%c_%05XH_STRUC LABEL BYTE\x0d\x0a",CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);
	/*	i = sprintf(out,"        $M_ID   <%05XH,0,$M_%c_%05XH_MSG-$M_%c_%05XH_STRUC>\x0d\x0a",  */
		i = sprintf(out,"        $M_ID   <%05XH,$M_%c_%05XH_MSG-$M_%c_%05XH_STRUC>\x0d\x0a",    /* Mar 88, SWN */
				CurrentMessageNumber,CurrentClass,CurrentMessageNumber,CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		}

	if (Pass == 2)
	      {
		BlankLine();
		while ( (*TextPtr != NUL) && (isspace(*TextPtr)) ) TextPtr++;

		i = sprintf(out,"$M_%c_%05XH_MSG LABEL BYTE\x0d\x0a",CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);
	/*	i = sprintf(out,"        DW      $M_%c_%05XH_END-$M_%c_%05XH_MSG-2\x0d\x0a",     */
		i = sprintf(out,"        DB      $M_%c_%05XH_END-$M_%c_%05XH_MSG-1\x0d\x0a",    /* Mar 88, SWN */
				CurrentClass,CurrentMessageNumber,CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);

		for ( m=1; m <= UtilMessageLines; m++)
		      {
			sscanf(UtilErrorTexts[m], " %d %s %s ",&MsgNumber,&MsgStatus,&MsgLevel[0]);
			LfPtr = strchr(UtilErrorTexts[m], ' ');
			LfPtr = strchr(LfPtr+1, ' ');
			LfPtr = strchr(LfPtr+1, ' ');
			strcpy(ActualMsg, LfPtr+1 );
			if ( MsgNumber == CurrentMessageNumber)
			      {
				if (Debugging) printf("DefRecord() :: MsgNumber = %d, CurrentMessageNumber = %d\n",
						       MsgNumber,CurrentMessageNumber);
				i = sprintf(out,"        DB      %s\x0d\x0a",ActualMsg);
				DosWrite(ClassHandle,(char far *) &out[0], i);
				ContinueLine = m + 1;
				}
			}

		MessagePending = TRUE;
	      }


	return;
	}

/* -------------------------------------------------------------------------- */

void UseRecord(Record)
char	*Record;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	int	i,j;
	char	*TextPtr;
	char	*NumberPtr;
	int	TempNumber;
	char	out[128];

	MessageTerminate();

	NumberPtr = Record;
	while ( (isspace(*NumberPtr)) && (*NumberPtr != NUL) ) NumberPtr++;

	if ( (isdigit(*NumberPtr)) || ( (*NumberPtr == (char) '-') && (isdigit(*(NumberPtr+1))) ) )
	      { if ( IsReserved(CurrentClass) )
		      { printf("Error: :USE in CLASS 1, cannot specify a msg-number on line %d\n",LineNumber);
			exit(1);
			}

		sscanf(NumberPtr," %d ",&CurrentMessageNumber);

		TextPtr = NumberPtr;
		while ( (!isspace(*TextPtr)) && (*TextPtr != NUL) ) TextPtr++;
		while ( ( isspace(*TextPtr)) && (*TextPtr != NUL) ) TextPtr++;

		strcpy(USEstring, "empty\0");

        if (strnicmp(TextPtr,"PARSE",5) == 0)  { strcpy(USEstring, "PARSE\0");  i = 5; j = 1; }
        if (strnicmp(TextPtr,"COMMON",6) == 0) { i = 6; j = 2; }
        if (strnicmp(TextPtr,"EXTEND",6) == 0) { strcpy(USEstring, "EXTEND\0"); i = 6; j = 3; }

		NumberPtr = TextPtr + i;
		sscanf(NumberPtr," %d ",&TempNumber);

		switch(j)
		      {
			case 1: if (TempNumber <= MAXPARSERERROR)
					TextPtr = ParserErrorTexts[TempNumber];
				   else if (TempNumber == 999)
					      { TextPtr = ParserErrorText999;
						}
					   else TextPtr = "";
				break;
			case 2: if (TempNumber <= MAXCOMMONERROR)
					TextPtr = CommonErrorTexts[TempNumber];
				   else TextPtr = "";
				break;
			case 3: if (TempNumber <= MAXEXTENDEDERROR)
					TextPtr = ExtendedErrorTexts[TempNumber];
				   else if (TempNumber == 999)
					      { TextPtr = ExtendedErrorText999;
						}
					   else TextPtr = "";
				break;

			default:TextPtr = "";
				break;
			}

		if (*TextPtr == NUL)
		      { printf("Error: :USE of PARSE, COMMON or EXTENDED with invalid msg-number, line %d\n",LineNumber);
			if (Debugging) printf("then ->CurrentMessageNumber = %d, TempNumber = %d, j = %d\n",
					       CurrentMessageNumber,TempNumber,j);
			exit(1);
			}

		}

	 else {

		strcpy(USEstring, "empty\0");

		TextPtr = NumberPtr;
        if (strnicmp(TextPtr,"PARSE",5) == 0)  { strcpy(USEstring, "PARSE\0"); i = 5; j = 1; }
        if (strnicmp(TextPtr,"COMMON",6) == 0) { i = 6; j = 2; }
        if (strnicmp(TextPtr,"EXTEND",6) == 0) { strcpy(USEstring, "PARSE\0"); i = 6; j = 3; }

		NumberPtr += i;
		sscanf(NumberPtr," %d ",&CurrentMessageNumber);

		TempNumber = CurrentMessageNumber;

		if ( (CurrentClass == '1') && (j != 3) )
		      { printf("Error: :USE in CLASS 1 must be EXTENDED ERROR on line %d\n",LineNumber);
			exit(1);
			}

		if ( (CurrentClass == '2') && (j != 1) )
		      { printf("Error: :USE in CLASS 1 must be PARSE ERROR on line %d\n",LineNumber);
			exit(1);
			}

		switch(j)
		      {
			case 1: if (TempNumber <= MAXPARSERERROR)
					TextPtr = ParserErrorTexts[TempNumber];
				   else if (TempNumber == 999)
						TextPtr = ParserErrorText999;
					   else TextPtr = "";
				break;
			case 2: if (TempNumber <= MAXCOMMONERROR)
					TextPtr = CommonErrorTexts[TempNumber];
				   else TextPtr = "";
				break;
			case 3: if (TempNumber <= MAXEXTENDEDERROR)
					TextPtr = ExtendedErrorTexts[TempNumber];
				   else if (TempNumber == 999)
						TextPtr = ExtendedErrorText999;
					   else TextPtr = "";
				break;

			default:TextPtr = "";
				break;
			}

		if (*TextPtr == NUL)
		      { printf("Error: :USE of PARSE, COMMON or EXTENDED with invalid msg-number, line %d\n",LineNumber);
			if (Debugging) printf("else ->CurrentMessageNumber = %d, TempNumber = %d, j = %d\n",
					      CurrentMessageNumber,TempNumber,j);
			exit(1);
			}

		}

	if (Pass == 1)
	      {
		BlankLine();

		i = sprintf(out,"$M_%c_%05XH_STRUC LABEL BYTE\x0d\x0a",CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);
	/*	i = sprintf(out,"        $M_ID   <%05XH,0,$M_%c_%05XH_MSG-$M_%c_%05XH_STRUC>\x0d\x0a",   */
		i = sprintf(out,"        $M_ID   <%05XH,$M_%c_%05XH_MSG-$M_%c_%05XH_STRUC>\x0d\x0a",    /* Mar 88, SWN */
				CurrentMessageNumber,CurrentClass,CurrentMessageNumber,CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		}

	if (Pass == 2)
	  {
	  strcpy( Is_Utility_Command, NAME_COMMAND ) ;
	  if ( !ParseOrExtend )
	    {
	    add_crlf = 0 ;
	    }
	  else
	    {
        if ( !strnicmp( Is_Utility_Command, UtilityName, 5) )
	      {
	      if ( ( CurrentClass != 67 ) && ( CurrentClass != 68 ) &&
		   ( CurrentClass != 69 ) && ( CurrentClass != '1') &&
		   ( CurrentClass != '2') )
		{
		add_crlf = 1 ;
		}
	      else
		{
		add_crlf = 0 ;
		}

	      }
	    else
	      {
	      if ( ( CurrentClass != '1') && ( CurrentClass != '2') )
		{
		add_crlf = 1 ;
		}
	      else
		{
		add_crlf = 0 ;
		}

	      }
	    }

	  BlankLine();

	  i = sprintf(out,"$M_%c_%05XH_MSG LABEL BYTE\x0d\x0a",CurrentClass,CurrentMessageNumber);
	  DosWrite(ClassHandle,(char far *) &out[0], i);
  /*	  i = sprintf(out,"        DW      $M_%c_%05XH_END-$M_%c_%05XH_MSG-2\x0d\x0a",     */
	  i = sprintf(out,"        DB      $M_%c_%05XH_END-$M_%c_%05XH_MSG-1\x0d\x0a",    /* Mar 88, SWN */
			  CurrentClass,CurrentMessageNumber,CurrentClass,CurrentMessageNumber);
	  DosWrite(ClassHandle,(char far *) &out[0], i);
	  if ( add_crlf )
	    {
	    i = sprintf(out,"        DB      %s,CR,LF\x0d\x0a",TextPtr);
	    }
	  else
	    {
	    i = sprintf(out,"        DB      %s\x0d\x0a",TextPtr);
	    }
	  DosWrite(ClassHandle,(char far *) &out[0], i);

	  MessagePending = TRUE;
	  }

	return;
	}

/* -------------------------------------------------------------------------- */

void DefContinue(Record)
char	*Record;
{

	printf("Error: :DEF continue should not occur",LineNumber);
	exit(1);

	return;

}

/* -------------------------------------------------------------------------- */

void UseContinue(Record)
char	*Record;
{

	printf("Error: :USE continue should not occur",LineNumber);
	exit(1);

	}

/* -------------------------------------------------------------------------- */

void EndRecord(Record)
char	*Record;
{

	if (!ClassFlag1) ClassRecord(" 1 ");
	if (!ClassFlag2) ClassRecord(" 2 ");

	MessageTerminate();
	ClassTerminate();

	Done = TRUE;

	return;
	}

/* -------------------------------------------------------------------------- */

void MessageTerminate()
{

	char	out[128];

	if (MessagePending)
	      {
		sprintf(out,"$M_%c_%05XH_END LABEL BYTE\x0d\x0a",CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0],strlen(out) );
	 /*	sprintf(out,"        DB        \"$\"\x0d\x0a");      */
		sprintf(out,"  \0",CurrentClass,CurrentMessageNumber);  /* Mar 88, SWN */
		DosWrite(ClassHandle,(char far *) &out[0],strlen(out) );

		ClassCounts[CurrentClass]++;
		}

	MessagePending = FALSE;

	return;
	}

/* -------------------------------------------------------------------------- */

void ClassTerminate()
{

	int	i;
	char	out[128];

	if ( (ClassPending) && (Pass == 1) )
	      { CommentLine();

		if (CurrentClass == '1')
		      { i = sprintf(out,"$M_1_FF_STRUC LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        $M_ID <0FFFFH,0,$M_1_FF_MSG-$M_1_FF_STRUC>\x0d\x0a");  */
			i = sprintf(out,"        $M_ID <0FFFFH,$M_1_FF_MSG-$M_1_FF_STRUC>\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
			ClassCounts[CurrentClass] ++;
			CommentLine();
			}

		if (CurrentClass == '2')
		      { i = sprintf(out,"$M_2_FF_STRUC LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        $M_ID <0FFFFH,0,$M_2_FF_MSG-$M_2_FF_STRUC>\x0d\x0a");  */
			i = sprintf(out,"        $M_ID <0FFFFH,$M_2_FF_MSG-$M_2_FF_STRUC>\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
			ClassCounts[CurrentClass] ++;
			CommentLine();
			}


		DosClose(ClassHandle);
		ClassHandle = 0xfffe;	 /* 0xfffe  ==	-2  */
		}

	if ( (ClassPending) && (Pass == 2) )
	      { CommentLine();

		if (CurrentClass == '1')
		      { i = sprintf(out,"$M_1_FF_MSG LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        DW      $M_1_FF_END-$M_1_FF_MSG-2\x0d\x0a");   */
			i = sprintf(out,"        DB      $M_1_FF_END-$M_1_FF_MSG-1\x0d\x0a");   /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			i = sprintf(out, EXTENDED_STR);	 /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			i = sprintf(out,"$M_1_FF_END LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        DB      \"$\"\x0d\x0a");       */
			i = sprintf(out,"  \0");        /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			CommentLine();
			}

		if (CurrentClass == '2')
		      { i = sprintf(out,"$M_2_FF_MSG LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        DW      $M_2_FF_END-$M_2_FF_MSG-2\x0d\x0a");   */
			i = sprintf(out,"        DB      $M_2_FF_END-$M_2_FF_MSG-1\x0d\x0a");   /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			i = sprintf(out,PARSE_STR); /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			i = sprintf(out,"$M_2_FF_END LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        DB      \"$\"\x0d\x0a");       */
			i = sprintf(out,"  \0");        /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			CommentLine();
			}

		i = sprintf(out,"Class_%c_MessageCount EQU     %d\x0d\x0a",CurrentClass,ClassCounts[CurrentClass]);
		DosWrite(ClassHandle,(char far *) &out[0], i );

		CommentLine();

		i = sprintf(out,"        IF      FARmsg\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		if ( !IsReserved(CurrentClass) )
		      { i = sprintf(out,"$M_CLS_%d PROC FAR\x0d\x0a",CurrentClassIndex);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}
		 else { i = sprintf(out,"$M_MSGSERV_%c PROC FAR\x0d\x0a",CurrentClass);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}
		i = sprintf(out,"        ELSE\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		if ( !IsReserved(CurrentClass) )
		      { i = sprintf(out,"$M_CLS_%d PROC NEAR\x0d\x0a",CurrentClassIndex);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}
		 else { i = sprintf(out,"$M_MSGSERV_%c PROC NEAR\x0d\x0a",CurrentClass);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}
		i = sprintf(out,"        ENDIF\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		BlankLine();
		i = sprintf(out,"        PUSH    CS\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        POP     ES\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        LEA     DI,$M_CLASS_%c_STRUC\x0d\x0a",CurrentClass);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        ADD     CX,$-$M_CLASS_%c_STRUC\x0d\x0a",CurrentClass);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        RET\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		BlankLine();
		if ( !IsReserved(CurrentClass) )
		      { i = sprintf(out,"$M_CLS_%d ENDP\x0d\x0a",CurrentClassIndex);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}
		 else { i = sprintf(out,"$M_MSGSERV_%c Endp\x0d\x0a",CurrentClass);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}

		CommentLine();

		DosClose(ClassHandle);
		ClassHandle = 0xfffe;	   /* 0xfffe == -2   */

		printf(" Completed [%s]\n",CurrentClassFileName);

		}

	ClassPending = FALSE;

	return;
	}

/* -------------------------------------------------------------------------- */

unsigned LowOf(LongValue)
long LongValue;
{

	return ( (unsigned) ( LongValue & 0x0000FFFFl ) );

	}

/* -------------------------------------------------------------------------- */

unsigned HighOf(LongValue)
long LongValue;
{

	return ( (unsigned) ( (LongValue & 0xFFFF0000l) >> 16 ) );

	}

/* -------------------------------------------------------------------------- */

long	 LongOf(HighValue,LowValue)
unsigned HighValue;
unsigned LowValue;
{

	long	hv;
	long	lv;

	hv = (long) HighValue;
	lv = (long) LowValue;

	return ( ( hv << 16 ) + lv );

	}

/* -------------------------------------------------------------------------- */

unsigned DosOpen(FileNamePtr,OpenType)
char far *FileNamePtr;
unsigned OpenType;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	InRegs.x.ax = 0x3d00 + OpenType;
	InRegs.x.dx = FP_OFF(FileNamePtr);
	SegRegs.ds = FP_SEG(FileNamePtr);
	intdosx(&InRegs, &OutRegs, &SegRegs);
	if (OutRegs.x.cflag)
		error(&InRegs,&OutRegs,&SegRegs);

	EofFlags[OutRegs.x.ax] = FALSE;
	return(OutRegs.x.ax);

	}

/* -------------------------------------------------------------------------- */

long	 DosLSeek(Handle, ToPosition, Relative)
unsigned Handle;
long	 ToPosition;
int	 Relative;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	InRegs.x.ax = 0x4200 + (Relative & 0x000f);
	InRegs.x.bx = Handle;
	InRegs.x.cx = HighOf(ToPosition);
	InRegs.x.dx = LowOf(ToPosition);
	intdosx(&InRegs, &OutRegs, &SegRegs);

	if (OutRegs.x.cflag)
		error(&InRegs,&OutRegs,&SegRegs);

	return( LongOf(OutRegs.x.dx,OutRegs.x.ax) );

	}

/* -------------------------------------------------------------------------- */

unsigned DosCreate(FileNamePtr,Attributes)
char far *FileNamePtr;
unsigned Attributes;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	InRegs.x.ax = 0x3c00;
	InRegs.x.cx = Attributes;
	InRegs.x.dx = FP_OFF(FileNamePtr);
	SegRegs.ds = FP_SEG(FileNamePtr);
	intdosx(&InRegs, &OutRegs, &SegRegs);
	if (OutRegs.x.cflag)
		error(&InRegs,&OutRegs,&SegRegs);

	EofFlags[OutRegs.x.ax] = FALSE;
	return(OutRegs.x.ax);

	}

/* -------------------------------------------------------------------------- */

void	 DosClose(Handle)
unsigned Handle;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	InRegs.x.ax = 0x3e00;
	InRegs.x.bx = Handle;
	intdosx(&InRegs,&OutRegs,&SegRegs);
	if (OutRegs.x.cflag) error(&InRegs,&OutRegs,&SegRegs);

	return;

	}

/* -------------------------------------------------------------------------- */

unsigned DosRead(Handle,BufferPtr,ReadLength)
unsigned Handle;
char far *BufferPtr;
int	 ReadLength;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	InRegs.x.ax = 0x3f00;
	InRegs.x.bx = Handle;
	InRegs.x.cx = ReadLength;
	InRegs.x.dx = FP_OFF(BufferPtr);
	SegRegs.ds = FP_SEG(BufferPtr);
	intdosx(&InRegs,&OutRegs,&SegRegs);
	if (OutRegs.x.cflag) error(&InRegs,&OutRegs,&SegRegs);

	return(OutRegs.x.ax);

	}

/* -------------------------------------------------------------------------- */

unsigned DosWrite(Handle,BufferPtr,WriteLength)
unsigned Handle;
char far *BufferPtr;
int	 WriteLength;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	union	REGS	InRegs2;
	union	REGS	OutRegs2;
	struct	SREGS	SegRegs2;

	InRegs.x.ax = 0x4000;
	InRegs.x.bx = Handle;
	InRegs.x.cx = WriteLength;
	InRegs.x.dx = FP_OFF(BufferPtr);
	SegRegs.ds = FP_SEG(BufferPtr);
	intdosx(&InRegs,&OutRegs,&SegRegs);
	if (OutRegs.x.cflag)
	      { InRegs2.x.ax = 0x4000;
		InRegs2.x.bx = 1;
		InRegs2.x.cx = WriteLength;
		InRegs2.x.dx = FP_OFF(BufferPtr);
		SegRegs2.ds = FP_SEG(BufferPtr);
	  /*	intdosx(&InRegs2,&OutRegs2,&SegRegs2);	*/
		error(&InRegs,&OutRegs,&SegRegs);
		}

	return(OutRegs.x.ax);

	}

/* -------------------------------------------------------------------------- */

void	 LineInput(Handle,BufferPtr)
unsigned Handle;
char far *BufferPtr;
{
	char		c;
	char far	*BufferPosition;

	BufferPosition = BufferPtr;
	*BufferPosition = NUL;

	if (DosRead( Handle, (char far *) &c, 1) != 1)
		EofFlags[Handle] = TRUE;

	while ( (c != (char) '\x0a') && !EofFlags[Handle])
	      {
		*BufferPosition = c;
		if (c == (char) '\x0d') *BufferPosition = NUL;
		BufferPosition++;

		if (DosRead( Handle, (char far *) &c, 1) != 1)
			EofFlags[Handle] = TRUE;

		}

	*BufferPosition = NUL;

	return;
}

/*----------------------------------------------------------------------------*/

void	error(InRegs,OutRegs,SegRegs)
union	REGS	*InRegs;
union	REGS	*OutRegs;
struct	SREGS	*SegRegs;
{

	char	far	*s;
	char		*t;
	char	AsciizString[256];

	struct	DOSERROR ErrorInformation;

	dosexterr(&ErrorInformation);

	printf("\n Function %02X, Error %d, Class %d, Action %d, Locus %d \n",
		InRegs->h.ah,
		ErrorInformation.exterror,ErrorInformation.class,
		ErrorInformation.action,ErrorInformation.locus);

	printf("  InRegs:\n");
	printf("  AX:%04X BX:%04X CX:%04X DX:%04X SI:%04X DI:%04X DS:%04X ES:%04X\n",
		InRegs->x.ax,InRegs->x.bx,InRegs->x.cx,InRegs->x.dx,InRegs->x.si,InRegs->x.di,
		SegRegs->ds,SegRegs->es);

	switch(InRegs->h.ah)
	      {
		case 0x3d:
		case 0x3c:
		case 0x4e:
			FP_SEG(s) = SegRegs->ds;
			FP_OFF(s) = InRegs->x.dx;
			t = &AsciizString[0];
			while (*s != (char) '\0') *t++ = *s++;
			*t++ = (char) '\0';
			printf("  DS:DX -> [%s]\n",AsciizString);
			break;
		}

	printf("  OutRegs:\n");
	printf("  AX:%04X BX:%04X CX:%04X DX:%04X SI:%04X DI:%04X DS:%04X ES:%04X\n",
		OutRegs->x.ax,OutRegs->x.bx,OutRegs->x.cx,OutRegs->x.dx,OutRegs->x.si,OutRegs->x.di,
		SegRegs->ds,SegRegs->es);



	exit(1);

	}


/* -------------------------------------------------------------------------- */

char * MyMalloc(Length)
int	Length;
{
	char	*Ptr;

	Ptr = malloc(Length);

	if (Ptr == (char *) 0)
	      { printf("ERROR: insufficient memory available, line %d\n",LineNumber);
		exit(1);
		}

	return (Ptr);
	}


/* -------------------------------------------------------------------------- */

	unsigned	IdxHandle;
	unsigned	MsgHandle;

void ReadCommon()
{


	char	    IdxComponentName[16];
	long	    MsgOffset;
	int	    MsgCount;

	char		Line[MAXLENGTH];
	char		NextLine[MAXLENGTH];
	char		CurrentIdxRecord[256];
	char		CurrentMsgRecord[256];
	int		CurrentIdxLevel;
	int		CurrentMsgLevel;
	char		RcdIDXType[32];
	struct		Idx_Structure  *IdxPtr;
	int		i;
	int		NumberOfMsg;
	int		k;
	long		n;
	int		ComponentNameLen = 20;
	char		*s, *p;
	unsigned	len;
	char		ContinueMessageInfo[32];
	int		ContinueMessageInfoLen;

	/* initialize the things that need to be... */

	printf(" Loading messages from %s\n",CountryMsg);

	k = 32000;
	s = malloc(k);
	while ( (s == (char *) 0) && (k > 1) )
	      {
		k -= 1000;
		s = malloc(k);
		}
	if (s != (char *) 0) free(s);
	printf(" (Available message memory space: %d bytes)\n",k);

	IdxHandle = DosOpen( (char far *) CountryIdx, READONLY);
	MsgHandle = DosOpen( (char far *) CountryMsg, READONLY);

	LineInput(IdxHandle, (char far *) &CurrentIdxRecord[0] );
	LineInput(MsgHandle, (char far *) &CurrentMsgRecord[0] );

	sscanf(CurrentIdxRecord," %d ",&CurrentIdxLevel);
	sscanf(CurrentIdxRecord," %d ",&CurrentMsgLevel);
	if ( CurrentIdxLevel != CurrentMsgLevel )
	      {
		printf("\nERROR: %s and %s levels do not match\n",CountryIdx,CountryMsg);
		exit(1);
		}

	/* find out the offset into the big message file for COMMON error */
	/*						     EXTENDED	  */
	/*						     PARSER	  */
	/*						     Utility	  */

	while ( !EofFlags[IdxHandle] )
	      {
		LineInput(IdxHandle, (char far *) &CurrentIdxRecord[0] );

		sscanf(CurrentIdxRecord, " %s %lx %d ",
			IdxComponentName, &MsgOffset, &MsgCount);
		if (Debugging) printf("---> [%s] %04lX %04d<---\n",IdxComponentName, MsgOffset, MsgCount);

        strupr(IdxComponentName);

		if (strcmp(IdxComponentName,"COMMON")  == 0)
		      {
			if ( !ReadCommonFlag )
			      {
				ReadCommonFlag = TRUE;
				DosLSeek( MsgHandle, MsgOffset, 0);
				LineInput(MsgHandle, (char far *) &CurrentMsgRecord[0] );
				if (strcmp(CurrentIdxRecord, CurrentMsgRecord) != 0)
				      {
					printf("\nERROR: %s and %s COMMON headers do not match\n",CountryIdx,CountryMsg);
					exit(1);
					}
				CommonMessageLines = 1;
				ExtendedMessageLines = 1;
				LineInput(MsgHandle, (char far *) &Line[0] );
				while ( ( !isalpha(Line[0]) ) && (!EofFlags[MsgHandle]) )
				      {
					p = strchr(Line, ' ') + 1;      /* skip msg number */
					p = strchr(p, ' ') + 1;         /* skip status flag */
					p = strchr(p, ' ') + 1;         /* skip revision level */
					len = strlen(p);
					CommonErrorTexts[CommonMessageLines] = MyMalloc(len+1);
					strcpy(CommonErrorTexts[CommonMessageLines], p);
					if (Debugging) printf("CommonErrorTexts[%d] = (%s)\n",
							       CommonMessageLines,CommonErrorTexts[CommonMessageLines]);
					CommonMessageLines++;
					if (CommonMessageLines >= MAXCOMMONERROR)
					      {
						printf("\nERROR: COMMON message number too large, %d\n",CommonMessageLines);
						exit(1);
						}
					LineInput(MsgHandle, (char far *) &Line[0] );
					}
				}
			}

		else if (strcmp(IdxComponentName,"EXTEND")  == 0)
		      {
			if ( !ReadExtendFlag )
			      {
				ReadExtendFlag = TRUE;
				DosLSeek( MsgHandle, MsgOffset, 0);
				LineInput(MsgHandle, (char far *) &CurrentMsgRecord[0] );
				if (strcmp(CurrentIdxRecord, CurrentMsgRecord) != 0)
				      {
					printf("\nERROR: %s and %s EXTEND headers do not match\n",CountryIdx,CountryMsg);
					exit(1);
					}
				ExtendedMessageLines = 1;
				LineInput(MsgHandle, (char far *) &Line[0] );
				while ( ( !isalpha(Line[0]) ) && (!EofFlags[MsgHandle]) )
				      {
					p = strchr(Line, ' ') + 1;      /* skip msg number */
					p = strchr(p, ' ') + 1;         /* skip status flag */
					p = strchr(p, ' ') + 1;         /* skip revision level */
					len = strlen(p);
					ExtendedErrorTexts[ExtendedMessageLines] = MyMalloc(len+1);
					strcpy(ExtendedErrorTexts[ExtendedMessageLines], p);
					if (Debugging) printf("ExtendedErrorTexts[%d] = (%s)\n",
							      ExtendedMessageLines,ExtendedErrorTexts[ExtendedMessageLines]);
					ExtendedMessageLines++;
					if (ExtendedMessageLines >= MAXEXTENDEDERROR)
					      {
						printf("\nERROR: EXTENDED message number too large, %d\n",ExtendedMessageLines);
						exit(1);
						}
					LineInput(MsgHandle, (char far *) &Line[0] );
					}
				}
			}

		else if (strcmp(IdxComponentName,"PARSE")  == 0)
		      {
			if ( !ReadParserFlag )
			      {
				ReadParserFlag = TRUE;
				DosLSeek( MsgHandle, MsgOffset, 0);
				LineInput(MsgHandle, (char far *) &CurrentMsgRecord[0] );
				if (strcmp(CurrentIdxRecord, CurrentMsgRecord) != 0)
				      {
					printf("\nERROR: %s and %s PARSE headers do not match\n",CountryIdx,CountryMsg);
					exit(1);
					}
				ParserMessageLines = 1;
				LineInput(MsgHandle, (char far *) &Line[0] );
				while ( ( !isalpha(Line[0]) ) && (!EofFlags[MsgHandle]) )
				      {
					p = strchr(Line, ' ') + 1;
					p = strchr(p, ' ') + 1;
					p = strchr(p, ' ') + 1;
					len = strlen(p);
					ParserErrorTexts[ParserMessageLines] = MyMalloc(len+1);
					strcpy(ParserErrorTexts[ParserMessageLines], p);
					if (Debugging) printf("ParserErrorTexts[%d] = (%s)\n",
							       ParserMessageLines,ParserErrorTexts[ParserMessageLines]);
					ParserMessageLines++;
					if (ParserMessageLines >= MAXPARSERERROR)
					      {
						printf("\nERROR: PARSER message number too large, %d\n",ParserMessageLines);
						exit(1);
						}
					LineInput(MsgHandle, (char far *) &Line[0] );
					}
				}
			}

		else if (strcmp(IdxComponentName,UtilityName)  == 0)
		      {
			if ( !ReadUtilFlag )
			      {
				ReadUtilFlag = TRUE;
				DosLSeek( MsgHandle, MsgOffset, 0);
				LineInput(MsgHandle, (char far *) &CurrentMsgRecord[0] );
				if (strcmp(CurrentIdxRecord, CurrentMsgRecord) != 0)
				      {
					printf("\nERROR: %s and %s %s headers do not match\n",
						CountryIdx,CountryMsg,UtilityName);
					exit(1);
					}
				UtilMessageLines = 1;
				LineInput(MsgHandle, (char far *) &Line[0] );
				while ( ( !isalpha(Line[0]) ) && (!EofFlags[MsgHandle]) )
				      {
					if ( !isdigit(Line[0]) )
					      {
						MsgCount++;
						/* need to fake  MsgNumber, Status, Level fields*/
						len =  strlen(Line) + strlen(ContinueMessageInfo);
						UtilErrorTexts[UtilMessageLines] = MyMalloc(len+1);
						strcpy(UtilErrorTexts[UtilMessageLines], ContinueMessageInfo);
						strcat(UtilErrorTexts[UtilMessageLines], Line);
						if (Debugging) printf("UtilErrorTexts[%d] = (%s)\n",
								       UtilMessageLines,UtilErrorTexts[UtilMessageLines]);
						}
					 else
					      {
						len = strlen(Line);
						UtilErrorTexts[UtilMessageLines] = MyMalloc(len+1);
						strcpy(UtilErrorTexts[UtilMessageLines], Line);
						if (Debugging) printf("UtilErrorTexts[%d] = (%s)\n",
								       UtilMessageLines,UtilErrorTexts[UtilMessageLines]);
						strncpy(ContinueMessageInfo,Line,12);
						ContinueMessageInfo[12] = (char) '\0';
						if (Debugging) printf(" ContinueMessageInfo = (%s)\n",
								       ContinueMessageInfo);
						}
					UtilMessageLines++;
					if (UtilMessageLines >= MAXUTILERROR)
					      {
						printf("\nERROR: Utility message number too large, %d\n",UtilMessageLines);
						exit(1);
						}
					LineInput(MsgHandle, (char far *) &Line[0] );
					}
				}
			}

		}

	DosClose(IdxHandle);
	DosClose(MsgHandle);

	UtilMessageLines--;
	CommonMessageLines--;
	ParserMessageLines--;
	ExtendedMessageLines--;

	k = 32000;
	s = malloc(k);
	while ( (s == (char *) 0) && (k > 1) )
	      {
		k -= 1000;
		s = malloc(k);
		}
	if (s != (char *) 0) free(s);
	printf(" (Still available message memory space: %d bytes)\n",k);

	if (!ReadCommonFlag)
	      { printf("\nERROR: COMMON messages not found in %s\n",CountryIdx);
		exit(1);
		}

	if (!ReadExtendFlag)
	      { printf("\nERROR: EXTEND messages not found in %s\n",CountryIdx);
		exit(1);
		}

	if (!ReadParserFlag)
	      { printf("\nERROR: PARSE messages not found in %s\n",CountryIdx);
		exit(1);
		}

	if (!ReadUtilFlag)
	      { printf("\nERROR: %s messages not found in %s\n",UtilityName,CountryIdx);
		exit(1);
		}

	return;

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\comsw.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)comsw.asm	1.1 85/05/14
;	SCCSID = @(#)comsw.asm	1.1 85/05/14

include version.inc


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\copy.asm ===
page ,132
	title	COMMAND COPY routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

comment % -----------------------------------------------------------------

;***	COPY.ASM

Source files:  copy.asm, copypr1.asm, copypr2.asm


;***	MODIFICATION HISTORY

11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
11/02/83 EE  Commented out the code in CPARSE which added drive designators
	     to tokens which begin with path characters so that PARSELINE
	     will work correctly.
11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
	     individual tokens.  That distinction is no longer needed for
	     FOR loop processing.
11/17/83 EE  CPARSE upper case conversion is now flag dependent.  Flag is
	     1 when Cparse is called from COPY.
11/17/83 EE  Took out the comment chars around code described in 11/04/83
	     mod.  It now is conditional on flag like previous mod.
11/21/83 NP  Added printf
12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
	     be added to a token.
05/30/84 MZ  Initialize all copy variables.  Fix confusion with destclosed
	     NOTE: DestHand is the destination handle.  There are two
	     special values:  -1 meaning destination was never opened and
	     0 which means that the destination has been openned and
	     closed.
06/01/84 MZ  Above reasoning totally specious.  Returned things to normal
06/06/86 EG  Change to fix problem of source switches /a and /b getting
	     lost on large and multiple file (wildcard) copies.
06/09/86 EG  Change to use xnametrans call to verify that source and
	     destination are not equal.

06/24/90 DO  If the destination of a file concatenation is the same as
	     first source file AND we run out of disk space before
	     completing the concatenation, restore the first source
	     file as best we can.  See SeekEnd and CopErr.  Bug #859.

M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
		instead of compatibility mode. This gives lesser sharing
		violations when files are opened for read on a copy.

% -------------------------------------------------------------------------

	.xlist
	.xcref

	include comsw.asm
	include dossym.inc
	include syscall.inc
	include sf.inc
	include comseg.asm
	include comequ.asm
	.list
	.cref


DATARES 	segment public byte
	extrn	VerVal:word
DATARES 	ends

TRANDATA 	segment public byte
	extrn	BadCd_Ptr:word
	extrn	Copied_Ptr:word
	extrn	Extend_Buf_Ptr:word
	extrn	Extend_Buf_Sub:byte
	extrn	File_Name_Ptr:word
	extrn	InBDev_Ptr:word    
	extrn	Msg_Disp_Class:byte
	extrn	Overwr_Ptr:word
TRANDATA	ends

TRANSPACE	segment public byte
	extrn	AllSwitch:word
	extrn	ArgC:byte
	extrn	Ascii:byte
	extrn	Binary:byte
	extrn	BytCnt:word
	extrn	CFlag:byte
	extrn	Comma:byte
	extrn	Concat:byte
	extrn	Copy_Num:word	   
	extrn	CpDate:word
	extrn	CpTime:word
	extrn	CpyFlag:byte	   
	extrn	CurDrv:byte
	extrn	DestBuf:byte
	extrn	DestClosed:byte
	extrn	DestFcb:byte
	extrn	DestFcb2:byte
	extrn	DestHand:word
	extrn	DestInfo:byte
	extrn	DestIsDir:byte
	extrn	DestSiz:byte
	extrn	DestSwitch:word
	extrn	DestTail:word
	extrn	DestVars:byte
	extrn	DirBuf:byte
	extrn	Expand_Star:byte
	extrn	FileCnt:word
	extrn	FirstDest:byte
	extrn	FrstSrch:byte
	extrn	Inexact:byte
	extrn	MelCopy:byte
	extrn	MelStart:word
	extrn	Msg_Flag:byte	   
	extrn	NoWrite:byte
	extrn	NxtAdd:word
	extrn	ObjCnt:byte
	extrn	OCtrlZ:byte
	extrn	OFilePtr_Hi:word
	extrn	OFilePtr_Lo:word
	extrn	One_Char_Val:byte  
	extrn	Parse_Last:word    
	extrn	Plus:byte
	extrn	Plus_Comma:byte
	extrn	RdEof:byte
	extrn	ResSeg:word
	extrn	ScanBuf:byte
	extrn	SDirBuf:byte
	extrn	SrcBuf:byte
	extrn	SrcHand:word
	extrn	SrcInfo:byte
	extrn	SrcIsDev:byte
	extrn	SrcPt:word
	extrn	SrcSiz:byte
	extrn	SrcTail:word
	extrn	SrcVars:byte
	extrn	SrcXName:byte
	extrn	StartEl:word
	extrn	String_Ptr_2:word
	extrn	TermRead:byte
	extrn	Tpa:word
	extrn	UserDir1:byte
	extrn	Written:word
TRANSPACE	ends




;***	COPY CODE

TRANCODE	segment public byte

	extrn	CError:near
	extrn	CopErr:near
	extrn	TCommand:near

	public	Copy

	assume	cs:TRANGROUP,ds:TRANGROUP,es:TRANGROUP,ss:NOTHING

	break	Copy

Copy:
	assume	ds:TRANGROUP,es:TRANGROUP

; 	Initialize internal variables.

	xor	ax,ax		; AX = 0
	mov	Copy_Num,ax	; # files copied (destinations) = 0
	mov	SrcPt,ax	; cmd line ptr for source scan = 0
	mov	SrcTail,ax	; ptr to last element of source pathname = 0
	mov	CFlag,al	; 'destination file created' = false
	mov	NxtAdd,ax	; ptr into TPA buffer = 0
	mov	DestSwitch,ax	; destination switches = none
	mov	StartEl,ax	; CParse ptr to last pathname element = 0
	mov	DestTail,ax	; ptr to last element of dest pathname = 0
	mov	DestClosed,al	; 'destination file closed' = false
	mov	DestSiz,al	; length of destination pathname = 0
	mov	SrcSiz,al	; length of source pathname = 0
	mov	DestInfo,al	; destination pathname flags = none
	mov	SrcInfo,al	; source pathname flags = none
	mov	Inexact,al	; 'inexact copy' = false
	mov	DestVars,al	; 'dest pathname is directory' = false
	mov	SrcVars,al	; 'source pathname is directory' = false
	mov	UserDir1,al	; saved working directory = null
	mov	NoWrite,al	; 'no write' (source = dest) = false
	mov	RdEof,al	; 'read end of file' = false
	mov	SrcHand,ax	; source handle = 0
	mov	CpDate,ax	; copy date = 0
	mov	CpTime,ax	; copy time = 0
	mov	SrcIsDev,al	; 'source is device' = false
	mov	OCtrlZ,al	; 'Ctrl+Z removed from original' = false
	mov	OFilePtr_Lo,ax
	mov	OFilePtr_Hi,ax	; original destination file ptr = null
	mov	TermRead,al	; 'terminate read' = false
	mov	Comma,al	; '"+,," found' = false
	mov	Plus_Comma,al	; '"+,," found last time' = false (?)
	mov	Msg_Flag,al	;AN022; 'non-utility msg issued' = false
	mov	AllSwitch,ax	; all switches = none
	mov	ArgC,al		; source/dest argument count = 0
	mov	Plus,al		; '"+" in command line' = false
	mov	Binary,al	; 'binary copy' = false
	mov	Ascii,al	; 'ascii copy' = false
	mov	FileCnt,ax	; # files copied (destinations) = 0
	mov	Written,ax	; 'destination written to' = false
	mov	Concat,al	; 'concatenating' = false
	mov	MelCopy,al	; 'Mel Hallerman copy' = false
	mov	MelStart,ax	; Mel Hallerman cmd line ptr = 0

;	Initialize buffers with double-nulls.

	mov	word ptr ScanBuf,ax
	mov	word ptr DestBuf,ax
	mov	word ptr SrcBuf,ax 
	mov	word ptr SDirBuf,ax
	mov	word ptr DirBuf,ax 
	mov	word ptr DestFcb,ax

	mov	ObjCnt,al	; # CParse cmd-line objects found = 0

	dec	ax		; AX = 0FFFFh
	mov	DestHand,ax	; destination handle = 'never opened'
	mov	FrstSrch,al	; 'first search for source' = true
	mov	FirstDest,al	; 'first time for dest' = true
	mov	DestIsDir,al	; 'haven't analyzed destination'

	mov	si,81h		; SI = ptr to command line
	mov	bl,PLUS_CHR	; BL = special delimiter = "+"
	inc	Expand_Star	; CParse 'expand * to ?s' = true
	mov	CpyFlag,1	; CParse 'called from COPY' = true


;*	Scan the command line for destination information.

DestScan:
	xor	bp,bp				; BP = switch flag accumulator
	mov	di,offset TRANGROUP:ScanBuf	; ES:DI = ptr to pathname buf
	mov	Parse_Last,si			;AN018; save cmd line ptr
	invoke	CParse				; parse next object
	pushf					; save CParse flags
	inc	ObjCnt				; count object

	test	bh,80h
	jz	@f			; no "+" delimiter
	mov	Plus,1			; "+" delimiter occurred
@@:
	test	bh,1
	jz	TestP2			; not a switch

;	Found a switch.

	test	bp,SwitchV		;AN038; Verify requested?
	jz	Not_SlashV		;AN038; No - set the switch
	test	AllSwitch,SwitchV	;AN038; Verify already entered?
	jz	Not_SlashV		;AN038; No - set the switch
;AD018; or	AllSwitch,FBadSwitch	;AN038; Set up bad switch
	or	bp,FBadSwitch		;AN018; Set up bad switch

Not_SlashV:				;AN038;
	or	DestSwitch,bp	 	; assume destination
	or	AllSwitch,bp		; keep tabs on all switches

	test	bp,not SwitchCopy	;AN018; Bad switch?
	jz	Not_Bad_Switch		;AN018; Switches are okay
	popf				;AN018; fix up stack
	mov	ax,BadSwt_ptr		;AN018; get "Invalid switch" message number
	invoke	Setup_Parse_Error_Msg	;AN018; setup to print the message
	jmp	CError			;AC018; exit

Not_Bad_Switch: 			;AN018; switch okay
	popf				; restore CParse flags
	jc	CheckDone		; found CR
	jmp	short DestScan		; continue scanning for destination

TestP2:
	popf				; restore CParse flags
	jc	CheckDone		; found CR

	test	bh,80h
	jnz	@f	 		; found a "+pathname" argument
	inc	ArgC			; count independent pathname args
@@:
	push	si				; save cmd line ptr
	mov	ax,StartEl			; AX = ptr to last path element
	mov	si,offset TRANGROUP:ScanBuf	; SI = ptr to path string
	sub	ax,si				; AX = offset of last element
	mov	di,offset TRANGROUP:DestBuf	; DI = ptr to destination buf
	add	ax,di				; AX = ptr to last element in
						;  destination path buffer
	mov	DestTail,ax			; save ptr to last element
	mov	DestSiz,cl			; save path string length

	inc	cx			; CX = mov length (incl null)
	rep	movsb			; DestBuf = possible destination path
	mov	DestInfo,bh		; save CParse info flags
	mov	DestSwitch,0		; clear destination switches
	pop	si			; SI = ptr into cmd line again
	jmp	DestScan		;AC018; continue scanning for dest

CheckDone:

;	We reached the CR.  The destination scan is finished.

;	Disallow "copy file1+" as file overwriting itself.
;
;	(Note that "copy file1+file2+" will be accepted, and
;	equivalent to "copy file1+file2".)

;	Bugbug:  it looks like "copy /x file1+" would slip
;	through this check, since the switch would count
;	as another object in ObjCnt.

	cmp	Plus,1			; "+" with
	jne	cdCont
	cmp	ArgC,1			; one arg,
	jne	cdCont
	cmp	ObjCnt,2		; two objects..
	jne	cdCont
	mov	dx,offset TRANGROUP:OverWr_ptr
	jmp	CopErr			; is file overwrite.

cdCont:	mov	al,Plus			; AL = '"+" occurred'
	mov	Concat,al		; if "+" occurred, we're concatenating
	shl	al,1
	shl	al,1
	mov	Inexact,al		; therefore making an inexact copy

	mov	al,ArgC			; AL = # independent arguments
	or	al,al
	jnz	Try_Too_Many		; more than 0 args; check if too many

	mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
	mov	Extend_Buf_Ptr,LessArgs_Ptr	; set msg # "param missing"
	jmp	short CError_ParseJ		; take parse error exit

Try_Too_Many:
	cmp	al,2
	jbe	ACountOk			; <= 2 arguments - ok

	mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
	mov	Extend_Buf_Ptr,MoreArgs_Ptr	; set msg # "too many params"
CError_ParseJ:
	mov	Msg_Disp_Class,PARSE_MSG_CLASS	; parse error message
CError4J:
	jmp	CError				; command error exit


ACountOk:
	mov	bp,offset TRANGROUP:DestVars	; BP = base of dest variables

;	Bugbug:  use of BP without segment override implies SS.
;	SS is implicitly assumed to point at TRANGROUP.

	cmp	al,1
	jne	Got2Args		; we have 2 arguments

;	Only one independent pathname argument on command line.
;	Set destination to d:*.*, where d: is current drive.

;	Bugbug:  but is this appropriate for "copy x:file1+x:file2"?
;	The two files would be appended as d:file1, rather than x:file1.

	mov	al,CurDrv		; AL = current drive (0 = A)
	add	al,CAPITAL_A		; AL = current drive letter
	mov	ah,':'			; AX = "d:"
	mov	[bp].siz,2		; pathname length = 2

	mov	di,offset TRANGROUP:DestBuf	; ES:DI = ptr to dest path buf
	stosw					; store "d:"

	mov	DestSwitch,0		; clear destination switches
	mov	[bp].info,2		; mark destination 'wildcard present'
	mov	[bp].isdir,0		; mark destination 'not a directory'
	invoke	SetStars		; add wildcards

Got2Args:

;	If destination pathname is "d:", add full wildcard filename

	cmp	[bp].siz,2
	jne	NotShortDest		; not two chars, can't be "d:"

	mov	al,':'
	cmp	destbuf+1,al
	jne	NotShortDest		; it's just a 2-character filename

	or	[bp].info,2		; mark destination 'wildcard present'
	mov	di,offset TRANGROUP:DestBuf+2
					; ES:DI = ptr after "d:"
	mov	[bp].isdir,0		; mark destination 'not a directory'
	invoke	SetStars		; add wildcards

NotShortDest:

;	If destination pathname ends with "\", try to make
;	sure it's "d:\".

	mov	di,[bp].ttail		; DI = ptr to last path element
	cmp	byte ptr [di],0
	jne	ChkSwtches		; not a null, so last char not "\"

	mov	dx,offset TRANGROUP:BadCD_Ptr	; DX = ptr to msg block
	mov	al,':'
	cmp	byte ptr [di-2],al
	jne	CError4J		; it's not "d:\", exit with error msg
	mov	[bp].isdir,2		; destination 'is a directory'
	or	[bp].info,6		; destination wildcarded and contains
					;  path character
	invoke	SetStars		; add wildcards

ChkSwtches:

;AD018; mov	ax,[ALLSWITCH]
;AD018; test	ax,NOT SwitchCopy
;AD018; jz	NOT_BAD_SWITCH			;AN000; Switches are okay
;AD018; MOV	DX,OFFSET TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
;AD018; mov	Extend_Buf_ptr,BadSwt_ptr	;AN000; get "Invalid switch" message number
;AD018; jmp	short CERROR_PARSEJ		;AC000; Switch specified which is not known
;AD018; NOT_BAD_SWITCH:

;	We have enough information about the destination for now.

;	Turn on verify if requested.  Save the current verify flag.

	mov	ax,AllSwitch		; AX = all switch flags
	test	ax,SwitchV
	jz	NoVerif 		; no /v, no verify

	mov	ah,GET_VERIFY_ON_WRITE	; AH = 'Get Verify Flag'
	int	21h			; call DOS

	push	ds
	mov	ds,ResSeg
	assume	ds:RESGROUP
	xor	ah,ah
	mov	VerVal,ax		; save current verify flag
	pop	ds
	assume	ds:TRANGROUP
	mov	ax,(SET_VERIFY_ON_WRITE shl 8) or 1  ; AX = 'Set Verify Flag'
	int	21h				     ; call DOS

NoVerif:

;*	Scan for first source.

	xor	bp,bp			; BP = switch flags accumulator
	mov	si,81h			; SI = ptr into command line
	mov	bl,PLUS_CHR		; BL = special CParse delimiter = "+"
ScanFSrc:
	mov	di,offset TRANGROUP:ScanBuf	; DI = ptr to pathname buf
	invoke	CParse			; parse first source pathname
	test	bh,1			; switch?
	jnz	ScanFSrc		; yes, try again
	or	DestSwitch,bp 		; include copy-wide switches on dest

;	Set ascii copying mode if concatenating, unless /b is specified.

	test	bp,SWITCHB
	jnz	NoSetCAsc		; /b - explicit binary copy
	cmp	Concat,0
	je	NoSetCAsc		; we're not concatenating
	mov	Ascii,SWITCHA		; set ascii copy
NoSetCAsc:
	call	Source_Set		; set source variables
	call	FrstSrc			; set up first source copy
	jmp	FirstEnt		; jump into the copy loop




	public	EndCopy

EndCopy:

;*	End of the road.  Close destination, display # files
;	copied (meaning # destinations), and go back to main
;	transient COMMAND code.

	call	CloseDest
EndCopy2:
	mov	dx,offset TRANGROUP:Copied_Ptr
	mov	si,FileCnt
	mov	Copy_Num,si
	invoke	Std_PrintF
	jmp	TCommand		; stack could be messed up




SrcNonexist:

;*	Source doesn't exist.  If concatenating, ignore and continue.
;	Otherwise, say 'file not found' and quit.

	cmp	Concat,0
	jne	NextSrc 		; concatenating - go on to next source

;	Set up error message.

	mov	Msg_Disp_Class,EXT_MSG_CLASS	     ; extended error msg
	mov	dx,offset TRANGROUP:Extend_Buf_Ptr   ; DX = ptr to msg block
	mov	Extend_Buf_Ptr,ERROR_FILE_NOT_FOUND  ; 'file not found' msg#
	mov	String_Ptr_2,offset TRANGROUP:SrcBuf ; point at bad pathname
	mov	Extend_Buf_Sub,ONE_SUBST	     ; 1 substitution

	jmp	CopErr			; print msg and clean up




SourceProc:

;*	Preparatory processing for each source file.
;	Called at FrstSrc for first source file.

	call	Source_Set		; set source variables & ascii/binary
	cmp	Concat,0
	jne	LeaveCFlag		; concatenating - leave CFlag alone
FrstSrc:
	xor	ax,ax
	mov	CFlag,al		; 'destination not created'
	mov	NxtAdd,ax		; copy buffer ptr = 0
	mov	DestClosed,al		; 'destination not closed'
LeaveCFlag:
	mov	SrcPt,si			; save cmd-line ptr
	mov	di,offset TRANGROUP:UserDir1	; DI = ptr to buf for user's 
						;   current dir
	mov	bp,offset TRANGROUP:SrcVars	; BP = base of source variables
	invoke	BuildPath			; cd to source dir, figure
						;   out stuff about source
	mov	si,SrcTail			; SI = ptr to source filename
	return




NextSrc:

;*	Next source.  Come here after handling each pathname.
;	We're done unless there are additional source pathnames
;	to be appended.
;
;	Note that all files matching an ambiguous pathname
;	are processed before coming here.

	cmp	Plus,0
	jne	MoreCp			; copying "+" sources - keep going

EndCopyJ2:
	jmp	EndCopy 		; done copying

MoreCp:
	xor	bp,bp			; BP = switch flags accumulator
	mov	si,SrcPt		; SI = ptr to current pos'n in cmd line
	mov	bl,PLUS_CHR		; BL = special delimiter = "+"

ScanSrc:
	mov	di,offset TRANGROUP:ScanBuf	; DI = ptr to pathname buf
	invoke	CParse				; parse first source name
	jc	EndCopyJ2			; CR found - we're done

	test	bh,80h
	jz	EndCopyJ2		; no "+" delimiter - we're done

	test	bh,1
	jnz	ScanSrc 		; switch found - keep looking

;	ScanBuf contains the next source pathname.

	call	SourceProc		; prepare this source
	cmp	Comma,1 		;g  was +,, found last time?
	jne	NoStamp 		;g  no - try for a file
	mov	Plus_Comma,1		;g  yes - set flag
	jmp	SrcNonexist		;g  we know we won't find it

NoStamp:				;g
	mov	Plus_Comma,0		;g  reset +,, flag

FirstEnt:
;
;M047
; The only case we need to worry about is when the source is wildcarded and
;the destination is not. For this case, ConCat is not yet set to indicate
;concatenation. We check for this case.
;
;NB: This change has been backed out and replaced by M048. This is not the
;right place to do this check.
;

;	This is where we enter the loop with the first source.

	mov	di,FCB				; DI = ptr to FCB
	mov	ax,PARSE_FILE_DESCRIPTOR shl 8	; 'Parse Filename'
	int	21h				; call DOS

	cmp	byte ptr [si],0 	; did we parse the whole thing?
	jne	SrchDone		; no, error, simulate 'not found'

	mov	ax,word ptr SrcBuf	; AX = possible "d:"
	cmp	ah,':'
	je	@f			; AX = definite "d:"
	mov	al,'@'			; AL = drive 'letter' for current drive
@@:
	or	al,20h			; AL = lowercase drive letter
	sub	al,60h			; AL = drive id (0=current,1=A,..)
	mov	ds:FCB,al		; put drive id in FCB

;	FCB contains drive and filename to search.

	mov	ah,DIR_SEARCH_FIRST	; AH = 'Find First File'
	call	Search

SrchDone:
	pushf				; save flags from Search
	invoke	RestUDir1		; restore users current directory
	popf				; restore flags from search
	jz	@f			; found the source - continue
	jmp	SrcNonexist		; didn't find the source
@@:
	xor	al,al
	xchg	al,FrstSrch
	or	al,al
	jz	NextAmbig

SetNMel:
	mov	cx,12
	mov	di,offset TRANGROUP:SDirBuf
	mov	si,offset TRANGROUP:DirBuf
	rep	movsb			; save very first source name

NextAmbig:
	xor	al,al
	mov	NoWrite,al		; turn off nowrite
	mov	di,SrcTail
	mov	si,offset TRANGROUP:DirBuf + 1
	invoke	Fcb_To_Ascz		; SrcBuf has complete name

MelDo:
	cmp	Concat,0
	jne	ShowCpNam		; concatenating - show name
	test	SrcInfo,2		; wildcard - show name
	jz	DoRead

ShowCpNam:
	mov	dx,offset TRANGROUP:File_Name_Ptr
	invoke	Std_PrintF
	invoke	CrLf2

DoRead:
	call	DoCopy
	cmp	Concat,0
	jne	NoDClose		; concatenating - don't close dest

	call	CloseDest		; close current destination
	jc	NoDClose		; concatenating - dest not closed

	mov	CFlag,0			; 'destination not created'

NoDClose:
	cmp	Concat,0
	je	NoFlush			; not concatenating - don't flush

;	Concatenating - flush output between source files so LostErr
;	stuff works correctly.

	invoke	FlshFil
	test	MelCopy,0FFh
	jz	@f
	jmp	short DoMelCopy
@@:
NoFlush:
	call	SearchNext		; try next match
	jnz	NextSrcJ		; not found - finished with 
					;   this source spec
	mov	DestClosed,0		; 'destination not closed'
	jmp	NextAmbig		; do next ambig match




DoMelCopy:
	cmp	MelCopy,0FFh
	je	ContMel
	mov	si,SrcPt
	mov	MelStart,si
	mov	MelCopy,0FFh
ContMel:
	xor	bp,bp
	mov	si,SrcPt
	mov	bl,PLUS_CHR
ScanSrc2:
	mov	di,offset TRANGROUP:ScanBuf
	invoke	CParse
	test	bh,80h
	jz	NextMel 		; no "+" - go back to start

	test	bh,1
	jnz	ScanSrc2		; switch - keep scanning

	call	SourceProc
	invoke	RestUDir1
	mov	di,offset TRANGROUP:DestFcb2
	mov	ax,PARSE_FILE_DESCRIPTOR shl 8
	int	21h
	mov	bx,offset TRANGROUP:SDirBuf + 1
	mov	si,offset TRANGROUP:DestFcb2 + 1
	mov	di,SrcTail

	invoke	BuildName

	cmp	Concat,0
	je	MelDoJ			; not concatenating - continue

;	Yes, turn off nowrite because this part of the code 
;	is only reached after the first file has been dealt with.

	mov	NoWrite,0

MelDoJ:
	jmp	MelDo

NextSrcJ:
	jmp   NextSrc

NextMel:
	call	CloseDest
	xor	ax,ax
	mov	CFlag,al
	mov	NxtAdd,ax
	mov	DestClosed,al
	mov	si,MelStart
	mov	SrcPt,si
	call	SearchNext
	jz	SetNMelJ
	jmp	EndCopy2
SetNMelJ:
	jmp	SetNMel




SearchNext:
	mov	ah,DIR_SEARCH_NEXT
	test	SrcInfo,2
	jnz	Search			; do search-next if ambig
	or	ah,ah			; reset zero flag
	return

Search:
	push	ax
	mov	ah,SET_DMA
	mov	dx,offset TRANGROUP:DirBuf
	int	21h			; put result of search in dirbuf
	pop	ax			; restore search first/next command
	mov	dx,FCB
	int	21h			; Do the search
	or	al,al
	return




DoCopy:
	mov	si,offset TRANGROUP:SrcBuf	;g do name translate of source
	mov	di,offset TRANGROUP:SrcXName	;g save for name comparison
	mov	ah,XNAMETRANS			;g
	int	21h				;g

	mov	RdEof,0				; no EOF yet

	mov	ax,EXTOPEN shl 8		; open the file
;M046
; For reads, the sharing mode should be deny none so that any process can
;open this file again in any other sharing mode. This is mainly to allow
;multiple command.com's to access the same file without getting sharing
;violations
;
	mov	bx,DENY_NONE or READ_OPEN_MODE ; open mode for COPY ;M046
	xor	cx,cx				; no special files
	mov	dx,READ_OPEN_FLAG		; set up open flags
	int	21h

	jnc	OpenOk

;	Bogosity:  IBM wants us to issue Access Denied in this case.
;	They asked for it...

	jmp	short Error_On_Source 		;AC022; clean up and exit

OpenOk:
	mov	bx,ax				; save handle
	mov	SrcHand,bx			; save handle
	mov	ax,(FILE_TIMES shl 8)
	int	21h
	jc	Error_On_Source
	mov	CpDate,dx			; save date
	mov	CpTime,cx			; save time
	jmp	short No_Copy_Xa		; (xa copy code removed)


Error_On_Source:				;AN022; we have a BAD error
	invoke	Set_Ext_Error_Msg		;AN022; set up the error message
	mov	String_Ptr_2,offset TRANGROUP:SrcBuf ;AN022; get address of failed string
	mov	Extend_Buf_Sub,ONE_SUBST	;AN022; put number of subst in control block
	invoke	Std_EprintF			;AN022; print it
	cmp	SrcHand,0			;AN022; did we open the file?
	je	No_Close_Src			;AN022; no - don't close
	call	CloseSrc			;AN022; clean up
No_Close_Src:					;AN022;
	cmp	CFlag,0				;AN022; was destination created?
	je	EndCopyJ3			;AN022; no - just cleanup and exit
	jmp	EndCopy 			;AN022; clean up concatenation and exit
EndCopyJ3:					;AN022;
	jmp	EndCopy2			;AN022;

No_Copy_Xa:
	mov	bx,SrcHand			;AN022; get handle back
	mov	ax,(IOCTL shl 8)
	int	21h				; get device stuff
	and	dl,DEVID_ISDEV
	mov	SrcIsDev,dl			; set source info
	jz	CopyLp				; source not a device
	cmp	Binary,0
	je	CopyLp				; ascii device ok
	mov	dx,offset TRANGROUP:InBDev_Ptr	; cannot do binary input
	jmp	CopErr


CopyLp:
	mov	bx,SrcHand
	mov	cx,BytCnt
	mov	dx,NxtAdd
	sub	cx,dx				; compute available space
	jnz	GotRoom
	invoke	FlshFil
	cmp	TermRead,0
	jne	CloseSrc			; give up
	mov	cx,BytCnt
GotRoom:
	push	ds
	mov	ds,Tpa
	assume	ds:NOTHING
	mov	ah,READ
	int	21h
	pop	ds
	assume	ds:TRANGROUP
	jc	Error_On_Source 		;AC022; give up if error
	mov	cx,ax				; get count
	jcxz	CloseSrc			; no more to read
	cmp	SrcIsDev,0
	jne	NoTestA 			; is a device, ascii mode
	cmp	Ascii,0
	je	BinRead
NoTestA:
	mov	dx,cx
	mov	di,NxtAdd
	mov	al,1Ah
	push	es
	mov	es,Tpa
	repne	scasb				; scan for EOF
	pop	es
	jne	UseAll
	inc	RdEof
	inc	cx
UseAll:
	sub	dx,cx
	mov	cx,dx
BinRead:
	add	cx,NxtAdd
	mov	NxtAdd,cx
	cmp	cx,BytCnt			; is buffer full?
	jb	TestDev 			; if not, we may have found eof
	invoke	FlshFil
	cmp	TermRead,0
	jne	CloseSrc			; give up
	jmp	short CopyLp

TestDev:
	cmp	SrcIsDev,0
	je	CloseSrc			; if file then EOF
	cmp	RdEof,0
	je	CopyLp				; on device, go till ^Z
CloseSrc:
	mov	bx,SrcHand
	mov	ah,CLOSE
	int	21h
	return




CloseDest:

;	We are called to close the destination.
;	We need to note whether or not there is any internal data left
;	to be flushed out.

	cmp	DestClosed,0
	retnz				; don't double close
	mov	al,byte ptr DestSwitch
	invoke	SetAsc			; check for b or a switch 
	jz	BinClos			;   on destination
	mov	bx,NxtAdd
;
;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
;^Z, let's always flush out. This way if the ConCat flag changes, we will
;just return without appending a ^Z incorrectly for the first file(since we
;are concatenating now). Also, in case it is a single file copy, we will
;anyway write the ^Z out separately. The only drawback is that there is a
;performance overhead on single ASCII file copies which now always involve
;2 writes instead of 1 before. Is this really that important?
;
;M048;	cmp	bx,BytCnt		; is memory full?
;M048;	jne	PutZ

	invoke	TryFlush		; flush (and double-check for concat)
	je	NoConc
ConChng:				; concat flag changed on us
	stc
	return
NoConc:
	xor	bx,bx
PutZ:
	push	ds
	mov	ds,Tpa
	mov	word ptr [bx],1Ah	; add EOF mark (ctrl-Z)
	pop	ds
	inc	NxtAdd
	mov	NoWrite,0		; make sure our ^z gets written
	mov	ax,Written
	add	ax,NxtAdd
	jc	BinClos 		; > 1
	cmp	ax,1
	je	ForgetItJ		; Written = 0 NxtAdd = 1 (the ^Z)
BinClos:
	invoke	TryFlush
	jnz	ConChng
	cmp	Written,0
ForgetItJ:
	jne	No_Forget		; wrote something
	jmp	ForgetIt		; never wrote nothing
No_Forget:
	mov	bx,DestHand
	mov	cx,CpTime
	mov	dx,CpDate
	cmp	Inexact,0		; copy not exact?
	je	DoDClose		; if no, copy date & time
	mov	ah,GET_TIME
	int	21h
	shl	cl,1
	shl	cl,1			; left justify min in cl
	shl	cx,1
	shl	cx,1
	shl	cx,1			; hours to high 5 bits, min to 5-10
	shr	dh,1			; divide seconds by 2 (now 5 bits)
	or	cl,dh			; and stick into low 5 bits of cx
	push	cx			; save packed time
	mov	ah,GET_DATE
	int	21h
	sub	cx,1980
	xchg	ch,cl
	shl	cx,1			; year to high 7 bits
	shl	dh,1			; month to high 3 bits
	shl	dh,1
	shl	dh,1
	shl	dh,1
	shl	dh,1			; most sig bit of month in carry
	adc	ch,0			; put that bit next to year
	or	dl,dh			; or low three of month into day
	mov	dh,ch			; get year and high bit of month
	pop	cx			; get time back
DoDClose:
	cmp	bx,0
	jle	CloseDone
	mov	ax,(FILE_TIMES shl 8) or 1
	int	21h			; set date and time
	jc	Cleanup_Err		;AN022; handle error

;	See if the destination has *anything* in it.
;	If not, just close and delete it.

	mov	ax,(LSEEK shl 8) + 2	; seek to EOF
	xor	dx,dx
	mov	cx,dx
	int	21h

;	DX:AX is file size

	or	dx,ax
	pushf
	mov	ax,(IOCTL SHL 8) + 0	; get the destination attributes
	int	21h
	push	dx			; save them away
	mov	ah,CLOSE
	int	21h
	pop	dx
	jnc	Close_Cont		;AN022; handle error on close
	popf				;AN022; get the flags back
Cleanup_Err: 				;AN022;
	call	CleanUpErr		;AN022; attempt to delete the target
	call	DestDelete		;AN022; attempt to delete the target
	jmp	short FileClosed	;AN022; close the file
Close_Cont:				;AN022; no error - continue
	popf
	jnz	CloseDone
	test	dx,80h			; is the destination a device?
	jnz	CloseDone		; yes, copy succeeded
	call	DestDelete
	jmp	short FileClosed
CloseDone:
	inc	FileCnt
FileClosed:
	inc	DestClosed
Ret50:
	clc
	return


ForgetIt:
	mov	bx,DestHand
	call	DoDClose		; close the dest
	call	DestDelete
	mov	FileCnt,0		; no files transferred
	jmp	Ret50


DestDelete:
	mov	dx,offset TRANGROUP:DestBuf
	mov	ah,UNLINK
	int	21h			; and delete it
	return




Source_Set	proc near

	push	si
	mov	ax,StartEl
	mov	si,offset TRANGROUP:ScanBuf	; adjust to copy
	sub	ax,si
	mov	di,offset TRANGROUP:SrcBuf
	add	ax,di
	mov	SrcTail,ax
	mov	SrcSiz,cl		; save its size
	inc	cx			; include the nul
	rep	movsb			; save this source
	mov	SrcInfo,bh		; save info about it
	pop	si
	mov	ax,bp			; switches so far
	invoke	SetAsc			; set a,b switches accordingly
	invoke	Switch			; get any more switches on this arg
	invoke	SetAsc			; set
	return

Source_Set	endp




;****************************************************************
;*
;* ROUTINE:	CleanupErr
;*
;* FUNCTION:	Issues extended error message for destination
;*		if not alreay issued
;*
;* INPUT:	return from INT 21
;*
;* OUTPUT:	none
;*
;****************************************************************

CleanupErr	proc	near			;AN022;

	cmp	Msg_Flag,0			;AN022; have we already issued a message?
	jnz	CleanupErr_Cont 		;AN022; yes - don't issue duplicate error
	invoke	Set_Ext_Error_Msg		;AN022; set up error message
	mov	String_Ptr_2,offset TRANGROUP:DestBuf ;AN022; get address of failed string
	mov	Extend_Buf_Sub,ONE_SUBST	;AN022; put number of subst in control block
	invoke	Std_EPrintF			;AN022; issue the error message

CleanupErr_Cont:				;AN022;
	ret					;AN022; return to caller

CleanupErr	endp				;AN022;


TRANCODE	ends
		end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\comseg.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; The following are all of the segments used in the load order
;
;SR; We switch the order of the CODE and DATA segments since we will have to
;move the CODE segment for HIMEM COMMAND
;


DATARES 	segment public byte	; resident data
DATARES 	ends

;
;Dummy segment to align the code segment on a paragraph boundary
;
DUMMY	segment public para
DUMMY	ENDS

CODERES 	segment public byte	; resident code
CODERES 	ends

;SR;
;No environment segments
;
;;ENVARENA	segment public para	; space for DOS ALLOCATE header
;;ENVARENA	ends

;;ENVIRONMENT	segment public para	; default COMMAND environment
;;ENVIRONMENT	ends

INIT		segment public para	; initialization code
INIT		ends

TAIL		segment public para	; end of init - start of transient
TAIL		ends

TRANCODE	segment public byte	; transient code
TRANCODE	ends

TRANDATA	segment public byte	; transient data area
TRANDATA	ends

TRANSPACE	segment public byte	; transient modifiable data area
TRANSPACE	ends

TRANTAIL	segment public para	; end of transient
TRANTAIL	ends

;SR;
;  We still keep the CODE and DATA in a group. This is to make addressability
;easy during init. This will not work for COMMAND in ROM but it is fine for
;HIMEM COMMAND. However, the resident code will not refer to any data using
;RESGROUP
;

RESGROUP  	group CODERES,DATARES,INIT,TAIL
TRANGROUP 	group TRANCODE,TRANDATA,TRANSPACE,TRANTAIL

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\copypr1.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

	.xlist
	.xcref

	include comsw.asm
	include dossym.inc
	include syscall.inc
	include sf.inc
	include comseg.asm
	include comequ.asm

	.list
	.cref


TRANDATA	segment public byte
	extrn	DevWMes_Ptr:word
	extrn	Extend_Buf_Sub:byte
	extrn	LostErr_Ptr:word
	extrn	NoSpace_Ptr:word
	extrn	Overwr_Ptr:word
TRANDATA	ends

TRANSPACE	segment public byte
	extrn	Ascii:byte
	extrn	Binary:byte
	extrn	CFlag:byte
	extrn	Concat:byte
	extrn	DestBuf:byte
	extrn	DestClosed:byte
	extrn	DestHand:word
	extrn	DestIsDev:byte
	extrn	DestSwitch:word
	extrn	Inexact:byte
	extrn	NoWrite:byte
	extrn	NxtAdd:word
	extrn	OCtrlZ:byte
	extrn	OFilePtr_Hi:word
	extrn	OFilePtr_Lo:word
	extrn	Plus_Comma:byte
	extrn	RdEof:byte
	extrn	SrcIsDev:byte
	extrn	String_Ptr_2:word
	extrn	TermRead:byte
	extrn	Tpa:word
	extrn	Written:word
TRANSPACE	ends

TRANCODE	segment public byte

	extrn	EndCopy:near

	public	FlshFil
	public	TryFlush

	assume	cs:TRANGROUP,ds:TRANGROUP,es:TRANGROUP,ss:NOTHING



;***	TryFlush - flush copy buffer, double-check for concatenation
;
;	EXIT	ZR set if concatenate flag unchanged

TryFlush:
	mov	al,Concat
	push	ax
	call	FlshFil
	pop	ax
	cmp	al,Concat
	return


;***	Flshfil - write out any data remaining in copy buffer.
;
;	Inputs:
;	  [NXTADD] = No. of bytes to write
;	  [CFLAG] <> 0 if file has been created
;	Outputs:
;	  [NXTADD] = 0

FlshFil:
	mov	TermRead,0
	cmp	CFlag,0
	je	NotExists
	jmp	Exists

NotExists:
	invoke	BuildDest		; find out all about the destination
	invoke	CompName		; source and dest. the same?
	jne	ProcDest		; if not, go ahead

	cmp	SrcIsDev,0
	jne	ProcDest		; same name on device ok

	cmp	Concat,0		; concatenation?
	mov	dx,offset TRANGROUP:Overwr_Ptr
	jne	No_Concat_Err		; concatenating

	jmp	CopErr			; not concatenating - overwrite error

No_Concat_Err:
	mov	NoWrite,1		; flag not writing (just seeking)

ProcDest:
	mov	ax,EXTOPEN shl 8		; open the file
	mov	si,offset TRANGROUP:DestBuf	; get file name
;M046
; For writes, we want to deny writes by anyone else at the same time that we
;are writing to it. For instance, on a network, 2 workstations could try
;writing to the same file. Also, because we opened the source file with
;DENY NONE, it is fine if the source and destination files are the same as
;would happen when we append to an existing file.
;
	mov	bx,DENY_WRITE or WRITE_OPEN_MODE;get open mode for copy; M046
	xor	cx,cx				; no special files
	mov	dx,WRITE_OPEN_FLAG		; set up open flags

	cmp	NoWrite,0
	jne	DoDestOpen		; don't actually create if nowrite set
	mov	dx,CREAT_OPEN_FLAG	; set up create flags

DoDestOpen:
	int	21h

;	We assume that the error is normal.
;	TriageError will correct the DX value appropriately.

	jnc	Dest_Open_Okay			;AC030;

Xa_Set_Error:					;AN030; error occurred on XA
	invoke	Set_Ext_Error_Msg		;AN030; get extended error

Ext_Err_Set:					;AN030;
	mov	String_Ptr_2,offset TRANGROUP:DestBuf ;AN000; get address of failed string
	mov	Extend_Buf_Sub,ONE_SUBST	;AN030; put number of subst in control block


CopErrJ2:					;AN030;
	jmp	CopErr				;AN030; go issue message

Dest_Open_Okay: 				;AC030
	mov	DestHand,ax			; save handle
	mov	CFlag,1				; destination now exists
	mov	bx,ax
	mov	ax,(IOCTL shl 8)
	int	21h				; get device stuff
	mov	DestIsDev,dl			; set dest info
	test	dl,DEVID_ISDEV
	jz	Exists				;AC030; Dest not a device

;	Destination is device.

	mov	al,byte ptr DestSwitch
	and	al,SWITCHA+SWITCHB
	jnz	TestBoth
	mov	al,Ascii		; neither set, use current setting
	or	al,Binary
	jz	ExSetA			; neither set, default to ascii

TestBoth:
	jpe	Exists			; both are set, ignore
	test	al,SWITCHB
	jz	Exists			; leave in cooked mode
	mov	ax,(IOCTL shl 8) or 1
	xor	dh,dh
	or	dl,DEVID_RAW
	mov	DestIsDev,dl		; new value
	int	21h			; set device to raw mode
	jmp	short Exists

CopErrJ:
	jmp	CopErr


ExSetA:

;	What we read in may have been in binary mode, flag zapped write OK

	mov	Ascii,SWITCHA 		; set ascii mode
	or	Inexact,SWITCHA		; ascii -> inexact

Exists:
	cmp	NoWrite,0
	jne	NoChecking		; if nowrite don't bother with name check
	cmp	Plus_Comma,1		;g  don't check if just doing +,,
	je	NoChecking		;g
	invoke	CompName		; source and dest. the same?
	jne	NoChecking		; if not, go ahead
	cmp	SrcIsDev,0
	jne	NoChecking		; same name on device ok

;	At this point we know in append (would have gotten overwrite error
;	on first destination create otherwise), and user trying to specify
;	destination which has been scribbled already (if dest had been named
;	first, NoWrite would be set).

	mov	dx,offset TRANGROUP:LostErr_Ptr ; tell him he's not going to get it
	invoke	Std_EprintF			;ac022;
	mov	NxtAdd,0			; set return
	inc	TermRead			; tell read to give up

Ret60:
	return


NoChecking:
	mov	bx,DestHand		; get handle
	xor	cx,cx
	xchg	cx,NxtAdd
	jcxz	Ret60			; if nothing to write, forget it
	inc	Written			; flag that we wrote something
	cmp	NoWrite,0		; if nowrite set, just seek cx bytes
	jne	SeekEnd
	xor	dx,dx
	push	ds
	mov	ds,Tpa
	assume	ds:NOTHING
	mov	ah,WRITE
	int	21h
	pop	ds
	assume	ds:TRANGROUP
	mov	dx,offset TRANGROUP:NoSpace_Ptr
	jnc	@f
	jmp	Xa_Set_Error			;AC022; failure
@@:	sub	cx,ax
	retz					; wrote all supposed to
	test	DestIsDev,DEVID_ISDEV
	jz	CopErr				; is a file, error
	test	DestIsDev,DEVID_RAW
	jnz	DevWrtErr			; is a raw device, error
	cmp	Inexact,0
	retnz					; inexact so ok
	dec	cx
	retz					; wrote one byte less (the ^z)


DevWrtErr:
	mov	dx,offset TRANGROUP:DevWMes_Ptr
	jmp	short CopErr




SeekEnd:
	xor	dx,dx			; zero high half of offset
	xchg	dx,cx			; cx:dx is seek location
	mov	ax,(LSEEK shl 8) or 1
	int	21h			; seek ahead in the file

;	Save the file pointer in DX:AX to restore the file
;	with in case the copy should fail.

	mov	OFilePtr_Lo,ax
	mov	OFilePtr_Hi,dx

	cmp	RdEof,0
	retz				; EOF not read yet

;	^Z has been read - we must set the file size to the current
;	file pointer location

	mov	ah,WRITE
	int	21h			; cx is zero, truncates file
	jc	Xa_Set_Error_Jmp	;AC022; failure

;	Make note that ^Z was removed, in case the
;	copy should fail and we need to restore the file.

	mov	OCtrlZ,1Ah

	return




	public	CopErr
CopErr:
	invoke	Std_EPrintF		;AC022;

CopErrP:
	inc	DestClosed
	cmp	CFlag,0
	je	EndCopyJ		; never actually got it open
	mov	bx,DestHand
	cmp	bx,0
	jle	NoClose

;	Check to see if we should save part of the destination file.

	mov	cx,OFilePtr_Hi		; CX = hi word of original file ptr
	mov	dx,OFilePtr_Lo		; DX = lo word of original file ptr

	mov	ax,cx
	or	ax,dx
	jz	ceClose			; null file ptr means nothing to save

;	Destination was also the first source.  Do the best we can to
;	restore it.  Truncate it back to the size we took from it (which
;	may have been due to a Ctrl-Z, so may not have included the whole
;	file).  If a Ctrl-Z was originally read, put it back.

	mov	ax,LSEEK shl 8
	int	21h

	xor	cx,cx			; CX = # bytes to write = 0
	mov	ah,WRITE
	int	21h			; truncate file

	cmp	OCtrlZ,0
	je	@f			; no ctrl-z removed from original
	inc	cx			; CX = # bytes to write = 1
	mov	dx,offset TRANGROUP:OCtrlZ  ; DS:DX = ptr to original ctrl-z
	mov	ah,WRITE
	int	21h			; write ctrl-z
@@:
	mov	ah,CLOSE
	int	21h			; close it
;;	mov	CFlag,0
	jmp	EndCopy			; and go home

ceClose:
	mov	ah,CLOSE		; close the file
	int	21h

NoClose:
	mov	dx,offset TRANGROUP:DestBuf
	mov	ah,UNLINK
	int	21h			; and delete it
	mov	CFlag,0

EndCopyJ:
	jmp	EndCopy

Xa_Set_Error_Jmp:			;AN022; go set up error message
	jmp	Xa_Set_Error		;AN022;

TRANCODE	ends
	 	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\copypr2.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;M031	SR 10/11/90    Bug #3069. Use deny write sharing mode to open files
;		      	instead of compatibility mode. This gives lesser
;			sharing violations when files are opened for read on
;			a copy operation.
;
;




	.xlist
	.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include sf.inc
	include comseg.asm
	include comequ.asm
	.list
	.cref


TRANDATA	segment public byte
	extrn	FulDir_Ptr:word 	;AN052;
TRANDATA ends

TRANSPACE	segment public byte
	extrn	Ascii:byte
	extrn	Binary:byte
	extrn	Concat:byte
	extrn	DestBuf:byte
	extrn	DestFcb:byte
	extrn	DestInfo:byte
	extrn	DestIsDir:byte
	extrn	DestTail:word
	extrn	DestVars:byte
	extrn	DirBuf:byte
	extrn	DirChar:byte
	extrn	FirstDest:byte
	extrn	Inexact:byte
	extrn	MelCopy:byte
	extrn	NxtAdd:word
	extrn	Plus:byte
	extrn	SDirBuf:byte
	extrn	SrcInfo:byte
	extrn	SrcXName:byte
	extrn	Tpa:word
	extrn	TrgXName:byte
	extrn	UserDir1:byte
TRANSPACE	ends

TRANCODE	segment public byte

	extrn	BadPath_Err:near	;AN022;
	extrn	CopErr:near		;AN052;
	extrn	Extend_Setup:near	;AN022;

	public	BuildPath
	public	SetStars
	public	SetAsc

ASSUME	cs:TRANGROUP,ds:TRANGROUP,es:TRANGROUP,ss:NOTHING




;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
;
;	Given switch vector in AX,
;	  Set Ascii flag if /a is set
;	  Clear Ascii flag if /b is set
;	  Binary set if /b specified
;	  Leave Ascii unchanged if neither or both are set
; 	Also sets Inexact if Ascii is ever set. 
;	AL = Ascii on exit, flags set
;

SetAsc:

	and	al,SWITCHA+SWITCHB	; AL = /a, /b flags
	jpe	LoadSw			; even parity - both or neither
	push	ax
	and	al,SWITCHB
	mov	Binary,al
	pop	ax
	and	al,SWITCHA
	mov	Ascii,al
	or	Inexact,al

LoadSw:
	mov	al,Ascii
	or	al,al
	return




;***	BuildDest

	public BuildDest

BuildDest:

	cmp	DestIsDir,-1
	jne	KnowAboutDest			; figuring already done
	mov	di,offset TRANGROUP:UserDir1
	mov	bp,offset TRANGROUP:DestVars
	call	BuildPath
	invoke	RestUDir1

;	We now know all about the destination.

KnowAboutDest:
	xor	al,al
	xchg	al,FirstDest
	or	al,al
	jnz	FirstDst
	jmp	NotFirstDest

FirstDst:

;	Create an fcb of the original dest.

	mov	si,DestTail			
	mov	di,offset TRANGROUP:DestFcb
	mov	ax,PARSE_FILE_DESCRIPTOR shl 8
	int	21h
	cmp	byte ptr [si],0
	je	GoodParse
;AD052; mov	byte ptr [di+1],"|"             ; must be illegal file name character
	mov	dx,offset TRANGROUP:FulDir_Ptr	;AN052; issue "file creation error"
	jmp	CopErr				;AN052;

GoodParse:
	mov	ax,word ptr DestBuf		; AX = possible "d:"
	cmp	ah,':'
	je	@f
	mov	al,'@'
@@:
;	AX = "d:" for following FCB drive computation

	mov	cl,Ascii		; CL = saved Ascii flag
	or	al,20h
	sub	al,60h
	mov	DestFcb,al		; store drive # in FCB

;*	Figure out what copy mode we're in.
;	Letters stand for unambiguous, * for ambiguous pathnames.
;	+n stands for additional sources delimited by +'s.
;
;	copy a b	not concatenating
;	copy a *	not concatenating
;	copy * a	concatenating
;	copy * *	not concatenating
;	copy a+n b	concatenating
;	copy *+n a	concatenating
;	copy *+n *	concatenating, Mel Hallorman style

;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file..  Why?
;		 copy a.b+*.a *.t  picks up all *.a files.

	mov	al,DestInfo		; AL = destination CParse flags
	mov	ah,SrcInfo		; AH = source CParse flags
	and	ax,0202h		; AH,AL = source,dest wildcard flags
	or	al,al
	jz	NotMelCopy		; no destination wildcard

;	Destination is wildcarded.

	cmp	al,ah
	jne	NotMelCopy		; no source wildcard

;	Source and destination are both wildcarded.

	cmp	Plus,0
	je	NotMelCopy		; no +'s in source

;	Source and destination are wildcarded, and source includes +'s.
;	It's Mel Hallorman copy time.

	inc	MelCopy			; 'Mel copy' = true
	xor	al,al
	jmp	short SetConc

NotMelCopy:
	xor	al,2		; AL=0 -> ambiguous destination, 2 otherwise
	and	al,ah
	shr	al,1		; AL=1 -> ambiguous source, unambiguous dest
				;   (implies concatenation)

SetConc:
	or	al,Plus		; "+" always infers concatenation

;	Whew.  AL = 1 if concatenating, 0 if not.

	mov	Concat,al
	shl	al,1
	shl	al,1
	mov	Inexact,al		; concatenation -> inexact copy
	cmp	Binary,0
	jne	NotFirstDest		; explicit binary copy

	mov	Ascii,al		; otherwise, concatenate in ascii mode
	or	cl,cl
	jnz	NotFirstDest		; Ascii flag set before, data read correctly
	or	al,al
	jz	NotFirstDest		; Ascii flag did not change state

;	At this point there may already be binary read data in the read
;	buffer.  We need to find the first ^Z (if there is one) and trim the
;	amount of data in the buffer correctly.

	mov	cx,NxtAdd
	jcxz	NotFirstDest		; no data, everything ok
	mov	al,1Ah
	push	es
	xor	di,di
	mov	es,Tpa
	repne	scasb			; scan for EOF
	pop	es
	jne	NotFirstDest		; no ^z in buffer, everything ok
	dec	di			; point at ^z
	mov	NxtAdd,di		; new buffer length

NOTFIRSTDEST:
	mov	bx,offset trangroup:DIRBUF+1	; Source of replacement chars
	cmp	CONCAT,0
	jz	GOTCHRSRC			; Not a concat
	mov	bx,offset trangroup:SDIRBUF+1	; Source of replacement chars

GOTCHRSRC:
	mov	si,offset trangroup:DESTFCB+1	; Original dest name
	mov	di,DESTTAIL			; Where to put result

public buildname
BUILDNAME:

ifdef DBCS					; ### if DBCS ###

	mov	cx,8
	call	make_name
	cmp	byte ptr [si],' '
	jz	@f				; if no extention
	mov	al,dot_chr
	stosb
	mov	cx,3
	call	make_name
@@:
	xor	al,al
	stosb					; nul terminate
	return

else						; ### if Not DBCS ###

	mov	cx,8

BUILDMAIN:
	lodsb
	cmp	al,'?'
	jnz	NOTAMBIG
	mov	al,byte ptr [BX]

NOTAMBIG:
	cmp	al,' '
	jz	NOSTORE
	stosb

NOSTORE:
	inc	bx
	loop	BUILDMAIN
	mov	cl,3
	mov	al,' '
	cmp	byte ptr [SI],al
	jz	ENDDEST 			; No extension
	mov	al,dot_chr
	stosb

BUILDEXT:
	lodsb
	cmp	al,'?'
	jnz	NOTAMBIGE
	mov	al,byte ptr [BX]

NOTAMBIGE:
	cmp	al,' '
	jz	NOSTOREE
	stosb

NOSTOREE:
	inc	bx
	loop	BUILDEXT
ENDDEST:
	xor	al,al
	stosb					; NUL terminate
	return

endif						; ### end if Not DBCS ###


ifdef DBCS				; ### if DBCS ###
make_name:
	mov	ah,0			; reset DBCS flag
	mov	dh,cl			; save length to do
mkname_loop:
	cmp	ah,1			; if it was lead byte
	jz	mkname_dbcs
	mov	ah,0			; reset if it was single or tail byte
	mov	al,[bx]			; get source char
	invoke	testkanj
	jz	mkname_load		; if not lead byte
mkname_dbcs:
	inc	ah			; set dbcs flag
mkname_load:
	lodsb				; get raw char
	cmp	al,'?'
	jnz	mkname_store		; if not '?'
	cmp	ah,0
	jz	mkname_conv		; if source is single
	cmp	ah,1
	jnz	mkname_pass		; if source is not lead
	cmp	cl,dh
	jnz	mkname_lead		; if this is not 1st char
	cmp	byte ptr [si],' '
	jz	mkname_double		; if this is the end
mkname_lead:
	cmp	byte ptr [si],'?'
	jnz	mkname_pass		; if no '?' for tail byte
	cmp	cx,1
	jbe	mkname_pass		; if no room for tail byte
mkname_double:
	mov	al,[bx]
	stosb
	inc	bx
	inc	si
	dec	cx
	inc	ah			; tail byte will be loaded
mkname_conv:
	mov	al,[bx]
mkname_store:
	cmp	al,' '
	jz	mkname_pass
	stosb				; store in destination
mkname_pass:
	inc	bx
	loop	mkname_loop
	return
endif					; ### end if DBCS ###

BUILDPATH:
	test	[BP.INFO],2
	jnz	NOTPFILE			; If ambig don't bother with open
	mov	dx,bp
	add	dx,BUF				; Set DX to spec

	push	di				;AN000;
	MOV	AX,EXTOPEN SHL 8		;AC000; open the file
	mov	bx,DENY_NONE or READ_OPEN_MODE	; open mode for COPY ;M046
	xor	cx,cx				;AN000; no special files
	mov	si,dx				;AN030; get file name offset
	mov	dx,read_open_flag		;AN000; set up open flags
	INT	21h
	pop	di				;AN000;
	jnc	pure_file			;AN022; is pure file
	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_file_not_found 	;AN022; if file not found - okay
	jz	notpfile			;AN022;
	cmp	ax,error_path_not_found 	;AN022; if path not found - okay
	jz	notpfile			;AN022;
	cmp	ax,error_access_denied		;AN022; if access denied - okay
	jz	notpfile			;AN022;
	jmp	extend_setup			;AN022; exit with error

pure_file:
	mov	bx,ax				; Is pure file
	mov	ax,IOCTL SHL 8
	INT	21h
	mov	ah,CLOSE
	INT	21h
	test	dl,devid_ISDEV
	jnz	ISADEV				; If device, done
	test	[BP.INFO],4
	jz	ISSIMPFILE			; If no path seps, done

NOTPFILE:
	mov	dx,word ptr [BP.BUF]
	cmp	dl,0				;AN034; If no drive specified, get
	jz	set_drive_spec			;AN034;    default drive dir
	cmp	dh,':'
	jz	DRVSPEC5

set_drive_spec: 				;AN034;
	mov	dl,'@'

DRVSPEC5:
	or	dl,20h
	sub	dl,60h				; A = 1
	invoke	SAVUDIR1
	jnc	curdir_ok			;AN022; if error - exit
	invoke	get_ext_error_number		;AN022; get the extended error
	jmp	extend_setup			;AN022; exit with error

curdir_ok:					;AN022;
	mov	dx,bp
	add	dx,BUF				; Set DX for upcomming CHDIRs
	mov	bh,[BP.INFO]
	and	bh,6
	cmp	bh,6				; Ambig and path ?
	jnz	CHECKAMB			; jmp if no
	mov	si,[BP.TTAIL]
	mov	bl,':'
	cmp	byte ptr [si-2],bl
	jnz	KNOWNOTSPEC
	mov	[BP.ISDIR],2			; Know is d:/file
	jmp	short DOPCDJ

KNOWNOTSPEC:
	mov	[BP.ISDIR],1			; Know is path/file
	dec	si				; Point to the /

DOPCDJ:
	jmp	DOPCD				;AC022; need long jump

CHECKAMB:
	cmp	bh,2
	jnz	CHECKCD

ISSIMPFILE:
ISADEV:
	mov	[BP.ISDIR],0			; Know is file since ambig but no path
	return

CHECKCD:
	invoke	SETREST1
	mov	ah,CHDIR
	INT	21h
	jc	NOTPDIR
	mov	di,dx
	xor	ax,ax
	mov	cx,ax
	dec	cx

Kloop:						;AN000;  3/3/KK
	MOV	AL,ES:[DI]			;AN000;  3/3/KK
	INC	DI				;AN000;  3/3/KK
	OR	AL,AL				;AN000;  3/3/KK
	JZ	Done				;AN000;  3/3/KK
	xor	ah,ah				;AN000;  3/3/KK
	invoke	Testkanj			;AN000;  3/3/KK
	JZ	Kloop				;AN000;  3/3/KK
	INC	DI				;AN000;  3/3/KK
	INC	AH				;AN000;  3/3/KK
	jmp	Kloop				;AN000;  3/3/KK

Done:						;AN000;  3/3/KK
	dec	di
	mov	al,DIRCHAR
	mov	[bp.ISDIR],2			; assume d:/file
	OR	AH, AH				;AN000; 3/3/KK
	JNZ	Store_pchar			;AN000; 3/3/KK	 this is the trailing byte of ECS code
	cmp	al,[di-1]
	jz	GOTSRCSLSH

Store_pchar:					;AN000; 3/3/KK
	stosb
	mov	[bp.ISDIR],1			; know path/file

GOTSRCSLSH:
	or	[bp.INFO],6
	call	SETSTARS
	return


NOTPDIR:
	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_path_not_found 	;AN022; if path not found - okay
	jz	notpdir_try			;AN022;
	cmp	ax,error_access_denied		;AN022; if access denied - okay
	jnz	extend_setupj			;AN022; otherwise - exit error

notpdir_try:					;AN022;
	mov	[bp.ISDIR],0			; assume pure file
	mov	bh,[bp.INFO]
	test	bh,4
	retz					; Know pure file, no path seps
	mov	[bp.ISDIR],2			; assume d:/file
	mov	si,[bp.TTAIL]
	cmp	byte ptr [si],0
	jz	BADCDERRJ2			; Trailing '/'
	mov	bl,dot_chr
	cmp	byte ptr [si],bl
	jz	BADCDERRJ2			; If . or .. pure cd should have worked
	mov	bl,':'
	cmp	byte ptr [si-2],bl
	jz	DOPCD				; Know d:/file
	mov	[bp.ISDIR],1			; Know path/file
	dec	si				; Point at last '/'

DOPCD:
	xor	bl,bl
	xchg	bl,[SI] 			; Stick in a NUL
	invoke	SETREST1
	CMP	DX,SI				;AN000;  3/3/KK
	JAE	LookBack			;AN000;  3/3/KK
	PUSH	SI				;AN000;  3/3/KK
	PUSH	CX				;AN000;  3/3/KK
	MOV	CX,SI				;AN000;  3/3/KK
	MOV	SI,DX				;AN000;  3/3/KK

Kloop2: 					;AN000;  3/3/KK
	LODSB					;AN000;  3/3/KK
	invoke	TestKanj			;AN000;  3/3/KK
	jz	NotKanj4			;AN000;  3/3/KK
	LODSB					;AN000;  3/3/KK
	CMP	SI,CX				;AN000;  3/3/KK
	JB	Kloop2				;AN000;  3/3/KK
	POP	CX				;AN000;  3/3/KK
	POP	SI				;AN000;  3/3/KK
	JMP	SHORT DoCdr			;AN000;  3/3/KK  Last char is ECS code, don't check for
						;		 trailing path sep
NotKanj4:					;AN000;  3/3/KK
	CMP	SI,CX				;AN000;  3/3/KK
	JB	Kloop2				;AN000;  3/3/KK
	POP	CX				;AN000;  3/3/KK
	POP	SI				;AN000;  3/3/KK

LookBack:					;AN000;  3/3/KK
	CMP	BL,[SI-1]			; if double slash, then complain.
	JZ	BadCDErrJ2

DoCdr:						;AN000;  3/3/KK
	mov	ah,CHDIR
	INT	21h
	xchg	bl,[SI]
	retnc
	invoke	get_ext_error_number		;AN022; get the extended error

EXTEND_SETUPJ:					;AN022;
	JMP	EXTEND_SETUP			;AN022; go issue the error message

BADCDERRJ2:
	jmp	badpath_err			;AC022; go issue path not found message

SETSTARS:
	mov	[bp.TTAIL],DI
	add	[bp.SIZ],12
	mov	ax,dot_qmark
	mov	cx,8
	rep	stosb
	xchg	al,ah
	stosb
	xchg	al,ah
	mov	cl,3
	rep	stosb
	xor	al,al
	stosb
	return

PUBLIC CompName
COMPNAME:

	mov	si,offset trangroup:DESTBUF	;g do name translate of target
	mov	di,offset trangroup:TRGXNAME	;g save for name comparison
	mov	ah,xnametrans			;g
	int	21h			;g

	MOV	si,offset trangroup:SRCXNAME	;g get name translate of source
	MOV	di,offset trangroup:TRGXNAME	;g get name translate of target


	invoke	STRCOMP

	return

TRANCODE ENDS
	 END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\dir.asm ===
page	,132
	title	DIR Internal Command
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;***	DIR.ASM - DIR internal command

comment	% =================================================================

This module replaces TCMD1A.ASM.  The old module was titled 
"PART4 COMMAND Transient routines".

From residual documentation, I surmise that TCMD.ASM originally
contained the internal commands DIR, PAUSE, ERASE, TYPE, VOL, and
VER.  The file seems to have been successively split:

  TCMD -> TCMD1,TCMD2 -> TCMD1A,TCMD1B,TCMD2A,TCMD2B

TCMD1A.ASM contained only the DIR command.

Usage:
------

DIR <filespec> /w /p /b /s /l /o<sortorder> /a<attriblist>

DIR /?


<filespec> may include any or none of:  drive; directory path;
           wildcarded filename.  If drive or directory path are
	   omitted, the current defaults are used.  If the
	   file name or extension is omitted, wildcards are
	   assumed.

/w	Wide listing format.  Files are displayed in compressed
	'name.ext' format.  Subdirectory files are enclosed in
	brackets, '[dirname]'.

/p	Paged, or prompted listing.  A screenful is displayed
	at a time.  The name of the directory being listed appears
	at the top of each page.

	Bugbug:  pages nead to be uniform length..?

/b	Bare listing format.  Turns off /w or /p.  Files are 
	listed in compressed 'name.ext' format, one per line,
	without additional information.  Good for making batch
	files or for piping.  When used with /s, complete
	pathnames are listed.

/s	Descend subdirectory tree.  Performs command on current
	or specified directory, then for each subdirectory below
	that directory.  Directory header and footer is displayed
	for each directory where matching files are found, unless
	used with /b.  /b suppresses headers and footers.

	Tree is explored depth first, alphabetically within the
	same level.

	Bugbug:  hidden directories aren't searched.

/l	Display file names, extensions and paths in lowercase.	;M010

/o	Sort order.  /o alone sorts by default order (dirs-first, name,
	extension).  A sort order may be specified after /o.  Any of
	the following characters may be used: nedsg (name, extension,
	date/time, size, group-dirs-first).  Placing a '-' before any
	letter causes a downward sort on that field.  E.g., /oe-d
	means sort first by extension in alphabetical order, then
	within each extension sort by date and time in reverse chronological
	order.

/a	Attribute selection.  Without /a, hidden and system files
	are suppressed from the listing.  With /a alone, all files
	are listed.  An attribute list may follow /a, consisting of
	any of the following characters:  hsdar (hidden, system,
	directory, archive, read-only).  A '-' before any letter
	means 'not' that attribute.  E.g., /ar-d means files that
	are marked read-only and are not directory files.  Note
	that hidden or system files may be included in the listing.
	They are suppressed without /a but are treated like any other
	attribute with /a.

/?	Help listing.  Display DIR useage information.	;M008;Handled externally

/h has been removed.					;M008

DIRCMD	An environment variable named DIRCMD is parsed before the
	DIR command line.  Any command line options may be specified
	in DIRCMD, and become defaults.  /? will be ignored in DIRCMD.
	A filespec may be specified in DIRCMD and will be used unless
	a filespec is specified on the command line.  Any switch
	specified in DIRCMD may be overridden on the command line.
	If the original DIR default action is desired for a particular
	switch, the switch letter may be preceded by a '-' on the
	command line.  E.g.,

	  /-w	use long listing format
	  /-p	don't page the listing
	  /-b	don't use bare format
	  /-s	don't descend subdirectory tree
	  /-o	display files in disk order
	  /-a	suppress hidden and system files


Notes:
------

For sorted listings, file entries are loaded into the TPA buffer, which
is usually about 64K in size.  This allows sorts of up to 3000 files at
a time.  Each entry takes up 21 bytes in the buffer (see EntryStruc below).
The byte after the last entry is 0FFh.  The first byte of each entry is
a flag byte which is made zero when the entry is loaded, and made one
when the entry is used.


Revision History
================
M01	md	7/13/90 	Use ROM BIOS data area to obtain screen height
				in the absence of ANSI.SYS

M007	sa	8/1/90		Allow /p/b combination

M008	sa	8/1/90		Remove /h parameter.  Eliminate code used
				to internally handle /? message.

M010	sa	8/5/90		Add support for /l (lowercase) option.

M011	sa	8/5/90		Patch up bug where MS-DOS does not load the
				first FCB with the drive number when the drive
				letter in the command line is preceded by a
				switch.  Now dir manually loads the drive
				number after parsing.

M018	md	8/12/90 	Increment the screen height by 1 when obtained
				from the ROM BIOS.

M023	sa	8/31/90		Prevent DIR from failing if it encounters
				a subdirectory having len(pathname)>MAXPATH.
				Just skip over that subdirectory.

M028	dbo	9/24/90		When country=US, sort by strict character
				byte value, rather than collating table.
				This to match MS-DOS Shell's sort order.

========================================================================= %




;***	SYMBOLS & MACROS

	.xlist
	.xcref

	include	comsw.asm	; get COMMAND version switches
	include dossym.inc	; get DOS basic symbol set
	include syscall.inc	; get DOS call names
	include doscntry.inc	; get extended country info symbols
	include bpb.inc
	include filemode.inc
	include find.inc
	include	comseg.asm	; define segment order
	include comequ.asm	; get equates for COMMAND routines
	include ioctl.inc	; get symbols for ioctl's
	include rombios.inc	; get ROM BIOS data definition

	.list
	.cref

				;M008;NUM_DIR_SWS reduced by 2 for /h,/? not used
				;M010;NUM_DIR_SWS increased by 2 for /l,/-l
NUM_DIR_SWS	equ	14	; # of dir switch synonyms in Dir_Sw_Ptrs list

				;M010;'lcase' replaces removed 'help' in OptionRec
OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1	
; 		on/off bit record for /l, /b, /s, /p, /w options
;		(order is hard-coded; see OnOffSw)
;		Inmem is set when entries are loaded in memory.

NUM_ATTR_LTRS	equ	6	; length of attribute letter list
NUM_ORDER_LTRS	equ	5	; length of sort order letter list

ResultBuffer	struc		; structure of parse result buffer
ValueType	db	?
ValueTag	db	?
SynPtr		dw	?
ValuePtr	dd	?
ResultBuffer	ends

ErrorRec	record	baddir:1,dev:1
;		Error bits are:
;		  Invalid directory format
;		  File is device

EntryStruc	struc			; our private directory entry structure
used		db	?		; =0 until entry used, then =1
filename	db	8 dup (?)	; filename
fileext		db	3 dup (?)	; extension
fileattr	db	?		; file attributes
filetime	dw	?		; file time
filedate	dw	?		; file date
filesize	dd	?		; file size
EntryStruc	ends

shove	macro	val		; hose-bag 8086 doesn't push immediate
	mov	ax,val		; invisible, dangerous use of AX!
	push	ax
	endm


	
	
;***	DATA

DATARES	segment public byte

	extrn	Append_Flag:byte	; true when APPEND needs to be reset
	extrn	Append_State:word	; state to reset APPEND to

DATARES	ends


TRANDATA segment public byte

	extrn	AttrLtrs:byte		; list of attribute letters
	extrn	BadCd_Ptr:word		; "invalid directory" msg block
	extrn	Bytes_Ptr:word		; "%1 bytes" msg block
	extrn	BytMes_Ptr:word		; "%1 bytes free" msg block
	extrn	DirCont_Ptr:word	; "(continuing %1)" msg block
	extrn	DirDat_Yr:word		; year field of date msg block
	extrn	DirDat_Mo_Day:word	; month/day field of date msg block
	extrn	DirDatTim_Ptr:word	; date/time msg block
	extrn	DirEnvVar:byte		; DIR environment variable name
	extrn	DirHead_Ptr:word	; directory header message block
	extrn	DirMes_Ptr:word		; "%1 File(s)" msg block
	extrn	DirTim_Hr_Min:word	; time field of msg block
	extrn	Dir_Sw_Ptrs:word	; list of DIR switch synonym ptrs
	extrn	Disp_File_Size_Ptr:word	; file size message block
	extrn	DMes_Ptr:word		; <DIR> message block
	extrn	ErrParsEnv_Ptr:word	; "(Error occurred in env.." msg blk
	extrn	Extend_Buf_Ptr:word	; extended error message block
	extrn	Extend_Buf_Sub:byte	; # substitions in message block
	extrn	Msg_Disp_Class:byte	; message display class
	extrn	OrderLtrs:byte		; list of sort order letters
	extrn	Parse_Dir:byte		; DIR parse block
	extrn	String_Buf_Ptr:word	; message block ptr to string
	extrn	Tab_Ptr:word		; tab output block
	extrn	Total_Ptr:word		; "Total:" msg block

TRANDATA ends


TRANSPACE segment public byte

	extrn	AttrSelect:byte		; attribute select states -
	extrn	AttrSpecified:byte	; attribute mask -

;		Attribute conditions are recorded in two steps.  
;		AttrSpecified indicates which attributes are to be checked.
;		AttrSelect indicates which state the specified attributes
;		 must be in for a file to be included in the listing.
;		Attributes not indicated in AttrSpecified are ignored when
;		 deciding which files to include.

	extrn	Bits:word		; some option flags (see OptionRec)
	extrn	BwdBuf:byte		; 'build working dir string' buf
	extrn	BytCnt:word		; # bytes in TPA
	extrn	Bytes_Free:word		; #bytes free for BytMes_Ptr msg block
	extrn	CharBuf:byte		; character string buffer
	extrn	ComSw:word		; error bits (see ErrorRec)
	extrn	CountryPtrInfo:byte	; buffer for collating table ptr
	extrn	CountryPtrId:byte	; info ID for collating table ptr
	extrn	CountryPtr:dword	; collating table ptr
	extrn	CurDrv:byte		; current drive # (0-based)
	extrn	DestBuf:byte		; null-terminated sort codes -

;	Sort order is specified as a series of 0 to 5 sort code
;	bytes, followed by a zero byte.
;	Codes are 1=name, 2=extension, 3=date&time, 4=size, and
;	5=filetype (subdir or not).
;	Bit 7 of code is set for a downwards sort.

	extrn	DestIsDir:byte		; indicator of delim char's in path
	extrn	DestTail:word		; ptr to filename in pathname
	extrn	Dir_Num:word		; #files for DirMes_Ptr msg block
	extrn	DirBuf:byte		; DTA buffer for DOS calls
	extrn	DirFlag:byte		; signal to PathCrunch routine
	extrn	Display_Ioctl:word	; display info block for IOCTL call
	extrn	EndDestBuf:byte		; end of DestBuf (sort order codes)
	extrn	File_Size_High:word	; field for file size message block
	extrn	File_Size_Low:word	; field for file size message block
	extrn	FileCnt:word		; file count in a single directory
	extrn	FileCntTotal:dword	; file count in all directories
	extrn	FileSiz:dword		; file sizes in a single directory
	extrn	FileSizTotal:dword	; file sizes in all directories
	extrn	InternatVars:byte	; buffer for international info
	extrn	LeftOnLine:byte		; entries left on current display line
	extrn	LeftOnPage:word		; lines left on page
	extrn	LinPerPag:word		; lines/page entry in Display_Ioctl
	extrn	Msg_Numb:word		; extended error code
	extrn	OldCtrlCHandler:dword	; old int 23 vector
	extrn	Parse1_Syn:word		; ptr to matched synonym
	extrn	PathCnt:word		; length of pathname (see PathPos)
	extrn	PathPos:word		; ptr to pathname buffer (see SrcBuf)
	extrn	PerLine:byte		; # entries per line
	extrn	ResSeg:word		; RESGROUP seg addr
	extrn	ScanBuf:byte		; buffer for environment value and
					;  subdirectory names
	extrn	SrcBuf:byte		; pathname buffer
	extrn	String_Ptr_2:word	; message substitution string ptr
	extrn	Tpa:word		; TPA buffer seg addr

TRANSPACE ends




;***	PRINCIPAL ROUTINES

TRANCODE segment public byte

	extrn	CError:near	; COMMAND error recycle point

	public	Catalog		; our entry point

	break	<DIR (Catalog) principal routines>

	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP

;	Bugbug:	Each routine should start with it's own ASSUME.




;***	Catalog - DIR command main routine
;
;	ENTRY	FCB #1 in PSP has drive# from cmd-line or default
;		Cmd-line tail text is at 81h, terminated by 0Dh
;		CS, DS, ES, SS = TRANGROUP seg addr
;		Tpa = TPA buffer seg addr
;		BytCnt = # bytes in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,BX,CX,DX,SI,DI,BP
;
;	ERROR EXITS
;
;	  Errors are handled by setting up error message pointers
;	   for Std_EPrintf and jumping to CError.  Syntax errors in
;	   the environment variable, however, are handled by printing
;	   an error message and continuing.
;
;	EFFECTS
;
;	  Directory listing is displayed (on standard output).
;	  APPEND is disabled.  HeadFix routine is expected to
;	   restore APPEND state.
;	  Working directory may be changed.  The user's default
;	   directory is saved and flagged for restoration by RestUDir
;	   during COMMAND cycle.
;	  Lots of variables may be changed in TRANSPACE segment.
;
;	NOTES
;
;	  ES = TRANGROUP seg addr except when used to address the
;	   the TPA buffer, where directory entries are loaded from disk.

Catalog	proc

	call	SetDefaults
	call	ParseEnvironment
	call	ParseCmdLine
	jnc	@F		; no parse error
	jmp	catErr		; error msg is set up
@@:	call	SetOptions
	call	SetCollatingTable

;	Drive # to operate on has already been placed in FCB by
;	COMMAND preprocessing.  OkVolArg & PathCrunch depend on that.

	test	Bits,mask bare
	jnz	@F		; don't display volume info for /b
	invoke	OkVolArg	; find & display volume info
	sub	LeftOnPage,2	; record display lines used by volume info
	jmp	short catCrunch

;	OkVolArg side effects:
;	APPEND is disabled;
;	DTA established at DirBuf;
;	Filename fields in FCB are wildcarded.

@@:
;	OkVolArg wasn't executed, so we have to do these ourselves.

	invoke	DisAppend	; disable APPEND

	mov	dx,offset TRANGROUP:DirBuf
	mov	ah,Set_DMA
	int	21h		; set DTA

	mov	di,FCB		; ES:DI = ptr to FCB
	inc	di		; ES:DI = ptr to filename field of FCB
	mov	al,'?'		; AL = wildcard character
	mov	cx,11
	rep	stosb		; wildcard filename field

catCrunch:
	call	CrunchPath	; crunch pathname to get directory and filename
	jc	catRecErr	; handle recorded or extended error

;	User's directory has been saved, we've changed to specified directory.
;	ComSw = error bits for later use
;	FCB contains parsed filename

	cmp	ComSw,0
	jne	catRecErr	; handle recorded error

	call	InstallCtrlC	; install control-C handler

	call	ZeroTotals	; zero grand totals
	call	ListDir		; list main directory
	jc	catExtErr

	test	Bits,mask subd
	jz	@F		; subdirectories option not set
	call	ListSubds	; list subdirectories
	jc	catExtErr
@@:
;	Check if any files were found.

	test	Bits,mask bare
	jnz	catRet		; don't bother for bare format

	mov	ax,word ptr FileCntTotal
	or	ax,ax
	jz	catNoFiles	; no files found

	call	DisplayTotals	; display trailing grand totals
	jmp	short catRet	; all done

catRecErr:

;	ComSw may have error bit set.  If not, do extended error.

	test	ComSw,mask dev
	jnz	catNoFiles	; filename is device, respond 'file not found'

	test	ComSw,mask baddir
	jz	catExtErr	; no ComSw error bits, must be extended error
	mov	dx,offset TRANGROUP:BadCd_Ptr	; invalid directory
	jmp	short catErr

catNoFiles:

;	Display header and force 'file not found' message.

	call	DisplayHeader
	mov	ax,ERROR_FILE_NOT_FOUND
	mov	Msg_Disp_Class,EXT_MSG_CLASS
	mov	dx,offset TRANGROUP:Extend_Buf_ptr
	mov	Extend_Buf_ptr,ax
	jmp	short catErr

catExtErr:

;	DOS has returned an error status.  Get the extended error#, and
;	set up an error message, changing 'No more files' error 
;	to 'File not found' error.

	invoke	Set_Ext_Error_Msg
	cmp	Extend_Buf_Ptr,ERROR_NO_MORE_FILES
	jne	@F
	mov	Extend_Buf_Ptr,ERROR_FILE_NOT_FOUND
@@:

;	Error exit.  Error message information has been set up
;	for Std_EPrintf.

catErr:	jmp	CError		; go to COMMAND error recycle point

catRet:	ret

Catalog	endp




;***	SetDefaults - set default pathname, options
;
;	ENTRY	DS = TRANGROUP seg addr
;
;	EXIT	nothing
;
;	USED	AX,DI
;
;	EFFECTS
;	  SrcBuf = '*',EOL - default pathname
;	  PathPos = ptr to pathname
;	  PathCnt = length of pathname



SetDefaults	proc

	mov	di,offset TRANGROUP:SrcBuf	; DI = ptr to pathname buffer
	mov	PathPos,di			; PathPos = ptr to pathname
	mov	al,STAR
	stosb
	mov	al,END_OF_LINE_IN
	stosb				; SrcBuf = '*',0Dh
	mov	PathCnt,1		; PathCnt = pathname length

	xor	ax,ax			; AX = 0
	mov	ComSw,ax		; = no error
	mov	Bits,ax			; = options off
	mov	DestBuf,al		; = no sort
	mov	AttrSpecified,ATTR_HIDDEN+ATTR_SYSTEM
	mov	AttrSelect,al		; exclude hidden, system files

	ret

SetDefaults	endp




;***	ParseEnvironment - find and parse our environment variable
;
;	Find our environment variable and parse it.  If a parse
;	error occurs, issue an error message.  The parse results
;	up to the error will still have effect.  Always leave
;	the option variables in a useable state.
;
;	ENTRY	DS = TRANGROUP seg addr
;
;	EXIT	nothing
;
;	USED	AX,BX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Bits may contain new option settings.
;	  DestBuf may contain new series of sort codes.
;	  AttrSpecified, AttrSelect may contain new attribute conditions.
;	  SrcBuf may contain a new default pathname/filespec.
;	  PathPos, PathCnt updated for new pathname.
;
;	  If a parse error occurred, an error message will be issued.

ParseEnvironment	proc

	call	GetEnvValue		; get environment variable value
	jc	peRet			; name not found in environment

;	SI = ptr to value of environment variable, in TRANGROUP seg

	call	ParseLine		; parse environment value
	cmp	ax,END_OF_LINE
	je	peRet			; successful completion

;	Some kind of parse error occurred.
;	We're set up for a Std_EPrintf call.

	invoke	Std_EPrintf			; display the parse error
	mov	Msg_Disp_Class,UTIL_MSG_CLASS	; restore default msg class

	mov	dx,offset TRANGROUP:ErrParsEnv_Ptr
	invoke	Printf_Crlf		; "(Error occurred in environment.."

					;M008;Internal handling of /? removed
;peOk:	and	Bits,not mask help	; disallow /h in environment variable

peRet:	ret

ParseEnvironment	endp




;***	ParseCmdLine - parse and record command line parameters
;
;	ENTRY	PSP offset 81h is beginning of cmd line buffer
;		DS, ES, CS = TRANGROUP seg addr
;
;	EXIT	CY = set if parse error occurred
;
;		If parse error occurred, we're set up for Std_EPrintf call:
;		AX = system parser error code
;		DX = ptr to message block
;
;	USED	AX,BX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Bits may contain new option settings.
;	  DestBuf may contain new series of sort codes.
;	  AttrSpecified, AttrSelect may contain new attribute conditions.
;	  SrcBuf may contain a new default pathname/filespec.
;	  PathPos, PathCnt updated for new pathname.
;
;	  If parse error occurred, we're set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error class
;	  Byte after last parameter in text is zeroed to make ASCIIZ string
;	  Message block (see DX) is set up for parse error message

ParseCmdLine	proc

	mov	si,81h			; SI = ptr to cmd-line tail text
	call	ParseLine		; parse cmd line tail
	cmp	AX,END_OF_LINE
	je	pcOk			; parse completed successfully

;	A parse error occurred.  We're all set up for message output.

	stc		   		; return failure
	jmp	short pcRet

pcOk:	clc				; return success

pcRet:	ret

ParseCmdLine	endp




;***	SetCollatingTable - set up character collating table for sorting
;
;	If country is other than USA, try to get a collating table
;	for character sorting.  For USA, use straight byte values.
;	This is so DIR behaves like the MS-DOS Shell, which sorts
;	by straight byte values in the USA for better performance.
;
;	ENTRY	ES = TRANGROUP seg addr
;
;	EXIT	nothing
;
;	USED	AX,BX,CX,DX,DI
;
;	EFFECTS
;
;	  If collating table is set -
;	    CountryPtrId = 6.
;	    CountryPtr points to collating table.
;
;	  Otherwise -
;	    CountryPtrId = 0.

SetCollatingTable	proc

;	Begin modification M028

	mov	dx,offset TRANGROUP:InternatVars
				; DS:DX = ptr to international info buffer
	mov	ax,INTERNATIONAL shl 8
				; AX = 'Get current country info'
	int	21h		; call DOS
	jc	scNoTable	; error - so don't collate

;	BX = country code

	cmp	bx,1
	je	scNoTable	; we're in USA, don't collate

;	End modification M028

;*	Country code is other than USA.  Try to get a collating table.

	mov	ax,(GETEXTCNTRY shl 8) + SETCOLLATE
				; AH = 'Get Extended Country Info'
				; AL = 'Get Pointer to Collating Table'
	mov	bx,-1		; BX = code page of interest = CON
	mov	cx,5		; CX = length of info buffer
	mov	dx,bx		; DX = country ID = default
	mov	di,offset TRANGROUP:CountryPtrInfo
				; ES:DI = ptr to info buffer
	int	21h		; call DOS
	jnc	scRet		; success

;*	Set CountryPtrId = 0 to signal no collating table.

scNoTable:			;M028
	mov	CountryPtrId,0

scRet:	ret

SetCollatingTable	endp




;***	SetOptions - check and set options
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	AX,BX,CX,DX
;
;	EFFECTS
;
;	  Bits may contain modified option settings.
;	  Display_Ioctl table, including LinPerPag variable, is filled in.
;	  LeftOnPage is initialized to # lines till end of page is handled.
;	  PerLine is set according to /w presence.

SetOptions	proc

;	If bare listing requested, cancel wide listings.

	test	Bits,mask bare
	jz	@F
	and	Bits,not mask wide		;M007;Allow /p with /b

@@:

;	Set # lines per display page.

;M01  Obtain screen height from ROM BIOS data area
;
;M01	mov	LinPerPag,LINESPERPAGE			; default value

ifndef JAPAN
	push	ds
	MOV	AX,ROMBIOS_DATA 	; Get ROM Data segment
	MOV	DS,AX			;
	Assume	DS:ROMBIOS_DATA

	MOV	al,CRT_Rows		; Get max rows
	pop	ds			;
	Assume	DS:Trangroup

	or	al,al			; If zero specified
	jnz	@F			;
endif
	MOV	al,LINESPERPAGE 	; assume 24 rows

@@:
	xor	ah,ah
ifndef JAPAN
	inc	al			; height + 1 ;M018
endif
	mov	LinPerPag,ax		; set the rows now

; Now the console driver can change the rows if it knows better (M01 end)

	mov	ax,(IOCTL shl 8)+GENERIC_IOCTL_HANDLE	; IOCTL for handles
	mov	bx,STDOUT				; handle #
	mov	ch,IOC_SC				; screen
	mov	cl,GET_GENERIC				; get display info
	mov	dx,offset TRANGROUP:Display_Ioctl	; info block
	int	21h					; call DOS

	mov	ax,LinPerPag		; AX = # lines per page
	mov	LeftOnPage,ax		; initialize # lines left on page

;	Set # entries per line.

	mov	PerLine,NORMPERLIN	; # entries per line without /w
	test	Bits,mask wide
	jz	@F
	mov	PerLine,WIDEPERLIN	; # entries per line with /w
@@:
				;M011;start;The following code checks if a drive
				;letter has been parsed into SrcBuf, and if
				;so, the correct drive number is loaded into
				;the first FCB, at offset 5C.

	cmp	TRANGROUP:[SrcBuf+1],COLON_CHAR	; is this a drive letter?
	jne	soRet
	mov	al,TRANGROUP:[SrcBuf]		; load drive letter into al
	and	al,not 20h			; capitalize ASCII drive letter (LowerCase-32)-->UpperCase
	sub	al,'@'				; convert to 1-based number (1=A)
	mov	ds:FCB,al 			; store in first FCB
						;M011;end
soRet:	ret

SetOptions	endp




;***	CrunchPath - analyze supplied or default pathname
;
;	ENTRY	PathPos = ptr to pathname buffer
;		PathCnt = length of pathname, not incl trailing delimiter
;		Pathname in buffer must end in delimiter (like CR) and
;		 must have space for another char after the delimiter.
;
;	EXIT	CY = clear if no error
;		We are changed to directory found in pathname
;		Previous directory ready to be restored via RestUDir
;		FCB filename fields contain filename (possibly w/ wildcards)
;
;		If error occurred,
;		CY = set
;		ComSw = error bits (see ErrorRec)
;		If ComSw not set,
;		Ready for DOS Get Extended Error call


CrunchPath	proc

	call	FileIsDevice
	jne	@F		; not a device, skip ahead
	or	ComSw,mask dev	; signal file is device
	jmp	short cpErr	; return error
@@:
	push	PathPos		; save ptr to pathname
	mov	DirFlag,-1	; tell PathCrunch not to parse file into FCB
	invoke	PathCrunch	; change to directory in pathname
	mov	DirFlag,0	; reset our little flag
	pop	si		; SI = ptr to pathname
	jc	cpNoDir		; didn't find directory path
	jz	cpRet		; found directory path w/ no filename
				;  - leave wildcard default in FCB and return

;*	We found a directory, and there was a filename attached.
;	DestTail = ptr to ASCIIZ filename

	mov	si,DestTail	; SI = ptr to filename
	jmp	short cpFile	; go parse the file into FCB

;*	PathCrunch failed to find a directory in the pathname.
;
;	Msg_Numb = error code
;	DestIsDir = nonzero if path delimiter char's occur in pathname
;	SI = ptr to pathname (now an ASCIIZ string)

cpNoDir:
	mov	ax,Msg_Numb	  ; AX = error code from PathCrunch
	or	ax,ax
	jnz	cpErr		  ; error occurred - return it
	cmp	DestIsDir,0
	je	cpMaybe		  ; no path delimiters seen, maybe it's a file
	or	ComSw,mask baddir ; signal invalid directory name
	jmp	short cpErr	  ; return error

cpMaybe:

;	SI = ptr to pathname

	cmp	byte ptr [si+1],COLON_CHAR
	jnz	@F		  ; no drive specifier, skip ahead
	lodsw			  ; SI = ptr past drive specifier "d:"
@@:	cmp	[si],".."
	jne	cpFile		  ; if not "..", treat as a file
	cmp	byte ptr [si+2],0
	jne	cpFile		  ; or if there's more after "..", treat as file
	or	ComSw,mask baddir ; signal invalid directory
	jmp	short cpErr	  ; return error

;	The preceding code was taken from the old DIR routine.
;	It's garbage, I'm afraid.  It's meant to check for ".."
;	occurring when we're at the root directory.  Too bad it
;	doesn't handle problems with "..\..", etc.


;	We're ready to parse a filename into the FCB.
;	SI = ptr to ASCIIZ filename

cpFile:	mov	di,FCB		; DI = ptr to FCB
	mov	ax,(PARSE_FILE_DESCRIPTOR shl 8) or 0Eh
				; wildcards already in FCB used as defaults
	int	21h
	clc			; return success
	jmp	short cpRet

cpErr:	stc			; return error

cpRet:	ret

CrunchPath	endp




;***	InstallCtrlC - install our private control-C handler
;
;	Put our control-c handler in front of command.com's default
;	handler, to make sure the user's default directory gets restored.
;	This shouldn't be necessary, but, for now, there are situations
;	where the TDATA segment is left in a modified state when a
;	control-c occurs.  This means that the transient will be
;	reloaded, and the user's directory cannot be restored.
;
;	Bugbug:  fix the wider problem?  Involves message services.  Ugly.
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	AX,BX,DX
;
;	EFFECTS
;
;	  CtrlCHandler address placed in int 23 vector.
;
;	NOTE
;
;	  Command.com's basic control-c handler will be restored
;	  to the int 23 vector by the HeadFix routine, after DIR finishes.

InstallCtrlC	proc

	push	es				 ; preserve ES
	mov	ax,(GET_INTERRUPT_VECTOR shl 8) + 23h
	int	21h
	mov	word ptr OldCtrlCHandler,bx	 ; save old int 23 vector
	mov	word ptr OldCtrlCHandler+2,es	 
	pop	es				 ; restore ES

	mov	dx,offset TRANGROUP:CtrlCHandler ; DS:DX = ptr to CtrlCHandler
	mov	ax,(SET_INTERRUPT_VECTOR shl 8) + 23h
	int	21h
	ret

InstallCtrlC	endp




;***	ListSubds - search and list files in subdirectories
;
;	ENTRY	Current directory (on selected drive) is top of subdir tree
;		FCB is still set up for file searches
;		Bits, AttrSpecified, AttrSelect, DestBuf all still set up
;
;	EXIT	CY = clear if no error
;		FileCnt = # files found & displayed
;		FileSiz = total size of files found
;
;		If error,
;		CY = set
;		Ready for DOS Get Extended Error call
;
;	USED	AX,BX,CX,DX,SI,DI,BP
;
;	EFFECTS
;
;	  FileCntTotal, FileSizTotal are updated.
;	  Subdirectories may be listed on standard output device.
;
;	NOTES
;
;	  ListSubds seeds the recursive entry point lsNode with a ptr
;	   to a buffer where we'll stack up subdirectory filenames.
;	   Each name is stored ASCIIZ.

ListSubds	proc

	invoke	SetRest1		; make sure user's dir gets restored

	mov	bx,offset TRANGROUP:ScanBuf   ; BX = ptr to child name buffer

lsNode:
	mov	byte ptr ds:[bx],0	; start with null child name
lsLoop:
	call	FindNextChild		; search for next subdirectory
	jc	lsErr			; search failed - examine error

	mov	dx,bx			; DX = ptr to child's name
	call	ChangeDir		; enter child directory

					; M023;start
	jnc	@F			; check for error
	cmp	ax,ERROR_PATH_NOT_FOUND	; error due to len(pathname)>MAXPATH?
	je	lsLoop			; yes, skip over this subdirectory
	jmp	SHORT lsRet		; no, other error: DIR must fail
					; M023;end

@@:	push	bx
	call	ListDir			; list the directory
	pop	bx

;	Note we're ignoring errors returned here.

	mov	di,bx			; DI = ptr to child's name
	mov	cx,13			; CX = max name length w/ null
	xor	al,al			; AL = zero byte to look for
	repne	scasb			; DI = ptr to next name pos'n in buf
	push	bx			; save ptr to child's name
	mov	bx,di			; BX = ptr to next name pos'n in buf
	call	lsNode			; recurse from new node
	pop	bx			; BX = ptr to child's name
	pushf				; save error condition
	
	shove	0
	shove	".."
	mov	dx,sp			; DX = ptr to "..",0 on stack
	call	ChangeDir		; return to parent directory
	pop	ax			; restore stack
	pop	ax

	popf				; restore error condition from child
	jc	lsRet			; return error

	jmp	lsLoop			; look for more children
lsErr:
	invoke	Get_Ext_Error_Number	; AX = extended error code
	cmp	ax,ERROR_FILE_NOT_FOUND
	je	lsRet			; file not found, we're ok
	cmp	ax,ERROR_NO_MORE_FILES
	je	lsRet			; no more files, we're ok
	stc				; return other errors

lsRet:	ret

ListSubds	endp




	break	<DIR support routines>

;***	SUPPORT ROUTINES




;***	CheckChild - check potential subdirectory name for FindNextChild
;
;	ENTRY	DirBuf contains DOS Find-buffer with potential child
;		BX = ptr to last child's name
;		BP = ptr to temp child's name
;
;	EXIT	nothing
;
;	USED	AX,CX,SI,DI
;
;	EFFECTS
;
;	  Filename pointed to by BP may be changed.
;
;	NOTES
;
;	  Potential filename replaces temp filename if:
;	   it's a subdirectory file;
;	   it doesn't start with a '.';
;	   it's alphanumerically greater than last child's name;
;	   and it's alphanumerically less than temp name.

CheckChild	proc

	test	DirBuf.find_buf_attr,ATTR_DIRECTORY
	jz	ccRet		; not a subdirectory file- return

	cmp	DirBuf.find_buf_pname,'.'
	je	ccRet		; starts with a dot- return

	mov	si,offset TRANGROUP:DirBuf+find_buf_pname
	mov	di,bx
	call	CmpAscz		; compare candidate to last child's name
	jna	ccRet		; it's not above it- return

	mov	si,offset TRANGROUP:DirBuf+find_buf_pname
	mov	di,bp
	call	CmpAscz		; compare candidate to temp name
	jnb	ccRet		; it's not below it- return

;	New kid is alright.  Copy to temp.

	mov	si,offset TRANGROUP:DirBuf+find_buf_pname
	mov	di,bp
	mov	cx,13
	rep	movsb

ccRet:	ret

CheckChild	endp




;***	CmpEntry - compare one directory entry to another in sort order
;
;	Compare one directory entry against another according to
;	the sort codes in DestBuf.  One or more comparisons
;	may be made of file name, extension, time/date, and
;	size.  Comparisons may be made for upward or downward
;	sort order.
;
;	ENTRY	ES:BX = ptr to entry to compare
;		ES:BP = ptr to entry to be compared against
;		DestBuf contains sort codes (see DestBuf)
;		DS = TRANGROUP seg addr
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry against BP entry.
;		 'Same, above, below' translate to 'same, after, before'.
;
;	USED:	AX,CX,DX,SI,DI

CmpEntry	proc

	mov	si,offset TRANGROUP:DestBuf	; (DS:SI) = ptr to sort codes
ceLoop:
	xor	ax,ax			; AX = 0
	mov	al,[si]			; AL = sort code
	or	al,al
	jz	ceDone			; sort code is zero, we're done
	inc	si			; DS:SI = ptr to next sort code
	push	si			; save ptr to next sort code
	dec	al
	sal	al,1			; AX = index into cmp call table
					; CY set for downward sort order
	mov	si,ax			; SI = index into cmp call table
	mov	ax,cs:FieldCmps[si]	; AX = addr of compare routine
	jc	ceDn			; downwards sort - go swap entries
	call	ax 			; do upwards sort
	jmp	short @F
ceDn:
	xchg	bx,bp		; swap entry ptrs for downward sort order
	call	ax		; do sort
	xchg	bx,bp		; swap ptrs back
@@:
	pop	si		; SI = ptr to next sort code
	je	ceLoop		; compare showed no difference, keep trying

ceDone:

;	Get here either from unequal compare or sort code = 0.
;	In the latter case, condition codes indicate equality,
;	which is correct.

	ret

FieldCmps	label	word	; call table of entry comparisons
		dw	CmpName
		dw	CmpExt
		dw	CmpTime
		dw	CmpSize
		dw	CmpType

CmpEntry	endp




;***	CmpName - compare file name of two entries
;***	CmpExt - compare extension of two entries
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry to BP entry.
;
;	USED:	AX,CX,DX,SI,DI

CmpName	proc

	mov	si,bx		; ES:SI = ptr to BX entry
	mov	di,bp		; ES:DI = ptr to BP entry
	add	si,filename	; ES:SI = ptr to BX name
	add	di,filename	; ES:DI = ptr to BP name
	mov	cx,size filename; CX = length of name
	jmp	short CmpStr

CmpExt:	mov	si,bx		; ES:SI = ptr to BX entry
	mov	di,bp		; ES:DI = ptr to BP entry
	add	si,fileext	; ES:SI = ptr to BX extension
	add	di,fileext	; ES:DI = ptr to BP extension
	mov	cx,size fileext	; CX = length of extension field

;	Bugbug:	use symbol for subfunction code.

CmpStr:	cmp	CountryPtrId,6
	jne	cnNoCollTable	; no collating table available

;*	Compare strings using collating table.
;
;	ES:SI = ptr to 1st string
;	ES:DI = ptr to 2nd string
;	CX = length

	push	bp			; preserve BP
	push	bx			; preserve BX
	push	ds			; preserve DS
	lds	bx,CountryPtr		; DS:BX = ptr to collating table
	assume	ds:NOTHING
	mov	bp,ds:[bx]		; BP = size of collating table
	inc	bx
	inc	bx			; DS:BX = ptr to collating values
					; DS:[BX]-2 = size of table
	xor	ax,ax			; AX = 0 for starters

;	Bugbug:	Investigate removing collating table length checks.

cnNextChar:
	mov	al,es:[di]		; AL = AX = char from 2nd string
	inc	di			; ES:DI = ptr to next char 2nd string
	cmp	ax,bp			; compare to collating table length
	jae	@F			; char not in table
	xlat				
@@:					; AL = AX = collating value
	mov	dx,ax			; DX = collating value from 2nd string
	lods	byte ptr es:[si]	; AL = AX = char from 1st string
					; ES:SI = ptr to next char 1st string
	cmp	ax,bp			; compare to collating table length
	jae	@F			; char not in table
	xlat				
@@:					; AL = AX = collating value
	cmp	ax,dx			; compare collating values

ifdef DBCS				; DBCS tail byte must not use
					; collating table
	jnz	cnNot_Same
	mov	al,es:[di-1]		; get previous 2nd string character
	invoke	testkanj
	jz	cnDo_Next		; if it was not DBCS lead byte
	mov	al,es:[di]		; get tail byte from 2nd string
	cmp	es:[si],al		; compare with 1st strings tail byte
	jnz	cnNot_Same
	inc	si			; pass tail byte
	inc	di
	dec	cx
cnDo_Next:
	loop	cnNextChar
cnNot_Same:

else					; Not DBCS

	loope	cnNextChar		; until unequal or no more left
endif

	pop	ds			; restore DS
	assume	ds:TRANGROUP
	pop	bx			; restore BX
	pop	bp			; restore BP
	ret

;*	If no collating table is available, simply compare raw ASCII values.
;	Don't we wish we could just do this all the time?  Sigh.

cnNoCollTable:
	rep	cmps byte ptr es:[si],[di]
	ret

CmpName	endp




;***	CmpTime - compare entries by date/time
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry to BP entry.
;
;	USED:	CX,SI,DI
;
;	NOTE	Filetime and filedate fields in our private entry
;		structure must be adjacent and in that order.

CmpTime	proc

	mov	si,bx
	mov	di,bp
	add	si,filedate + size filedate - 1
	add	di,filedate + size filedate - 1
	mov	cx,size filetime + size filedate
	std
	repe	cmps byte ptr es:[si],[di]
	cld
	ret

CmpTime	endp




;***	CmpSize - compare entries by size
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry to BP entry.
;
;	USED:	CX,SI,DI

CmpSize	proc

	mov	si,bx
	mov	di,bp
	add	si,filesize + size filesize - 1
	add	di,filesize + size filesize - 1
	mov	cx,size filesize
	std
	repe	cmps byte ptr es:[si],[di]
	cld
	ret

CmpSize	endp




;***	CmpType - compare entries by file type (subdirectory or not)
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry to BP entry.
;
;	USED:	AX

CmpType	proc

	mov	al,es:[bx].fileattr
	mov	ah,es:[bp].fileattr
	and	ax,(ATTR_DIRECTORY shl 8) + ATTR_DIRECTORY
	cmp	ah,al
	ret

CmpType	endp





;***	DefaultAttr - set default attribute conditions
;
;	ENTRY	nothing
;
;	EXIT	CY clear
;
;	USED
;
;	EFFECTS
;
;	  AttrSpecified, AttrSelect are updated with new attribute conditions.

DefaultAttr	proc

	mov	AttrSpecified,ATTR_HIDDEN+ATTR_SYSTEM	; specify H and S
	mov	AttrSelect,0				; H and S must be off
	clc						; return success
	ret

DefaultAttr	endp




;***	DisplayTotals - display grand total stats
;
;	If we searched subdirectories, display the total # files found
;	 and total size of files found.
;	Display disk space remaining.
;
;	ENTRY	FileCntTotal, FileSizTotal contain correct values
;		Bits contains setting of /s
;		FCB contains drive #
;
;	EXIT	nothing
;
;	USES	AX,DX
;		FileSiz

DisplayTotals	proc

	test	Bits,mask subd
	jz	dtFree			; no subdirectories- do bytes free

	invoke	Crlf2			; start on new line
	call	UseLine

	mov	dx,offset TRANGROUP:Total_Ptr
	invoke	Std_Printf			; "Total:",cr,lf
	call	UseLine

	mov	ax,word ptr FileCntTotal	; AX = # files found mod 64K
	mov	si,offset TRANGROUP:FileSizTotal
	mov	di,offset TRANGROUP:FileSiz
	movsw
	movsw				; move total size to size variable
	call	DisplayCntSiz		; display file count & size
dtFree:
	mov	ah,GET_DRIVE_FREESPACE	; AH = DOS Get Free Space function
	mov	dl,byte ptr ds:FCB	; DL = drive#
	int	21h			; call DOS
	cmp	ax,-1			; check 'invalid drive' return code
	jz	dtRet			; can't get drive space - return
	mul	cx
	mul	bx
	mov	Bytes_Free,ax
	mov	Bytes_Free+2,dx
	mov	dx,offset TRANGROUP:BytMes_Ptr
	invoke	Std_Printf		; "nnn bytes free",cr,lf
	call	UseLine

dtRet:	ret

DisplayTotals	endp




;***	FileIsDevice - see if file looks like a device
;
;	ENTRY	PathPos = ptr to pathname
;		PathCnt = length of pathname w/o terminating char
;		DirBuf is DOS DTA
;
;	EXIT	ZR = set if file looks like a device
;
;	USED	AX,BX,CX,DX,DI
;
;	EFFECTS
;
;	  DTA buffer holds results of Find First function
;
;	NOTES
;
;	  We try to flag devices in two ways.  First, we try
;	  the DOS Find First function.  It returns attribute bit 6
;	  set on a successful find if it identifies a device name.
;	  Unfortunately, it returns 'path not found' for a device
;	  name terminated with colon, such as "CON:".  So, we look
;	  for any colon in the pathname after the 2nd character,
;	  and flag the pathname as a device if we find one.

FileIsDevice	proc

	mov	dx,PathPos	 ; DX = ptr to pathname

	mov	di,dx
	add	di,PathCnt	 ; DI = ptr to byte after pathname
	xor	bl,bl		 ; BL = NUL to terminate pathname with
	xchg	bl,byte ptr [di] ; BL = saved pathname terminating char

	xor	cx,cx		 ; CX = attribute mask (normal search)
	mov	ah,FIND_FIRST	 ; AH = DOS Find First function code
	int	21h	 	 ; call DOS
	xchg	bl,byte ptr [di] ; restore pathname terminating char
	jc	piCol		 ; didn't find a dir entry, check for colon

;	Found a dir entry, see if Find First thinks it's a device.

	test	byte ptr DirBuf.Find_Buf_Attr,ATTR_DEVICE
	jz	piCol		 ; device attribute not set, look for colon
	xor	cx,cx		 ; it's a device, return ZR flag
	jmp	short piRet

;	Device attribute not returned by Find First function.  But
;	let's check for a colon anywhere in the pathname after the
;	second byte.
;
;	DI = ptr to byte after pathname

piCol:	dec	di		 ; DI = ptr to last char in pathname
	mov	al,COLON_CHAR	 ; AL = colon char to search for
	mov	cx,PathCnt	 ; CX = # chars to scan
	dec	cx
	dec	cx		 ; ignore 1st two chars of pathname
	or	cx,cx
	js	piRet		 ; if < 2 chars in pathname, just return
	or	di,di		 ; clear ZR in case CX = 0
	std			 ; scan downward
	repne	scasb
	cld			 ; restore default upward direction

;	After scanning, the ZR flag is set to indicate presence of a colon.

piRet:	ret

FileIsDevice	endp




;***	FindFirst - find first directory entry to display
;***	FindNext - find next directory entry to display
;
;	ENTRY	Bits<inmem> = set if entries are loaded in TPA
;		AttrSpecified, AttrSelect are set
;
;	EXIT	CY = clear if successful
;		BX = offset in TPA buffer of directory entry found
;
;		If unsuccessful,
;		CY = set
;		AX = DOS error code
;		DOS Get Extended Error call will get error code
;
;		NOTE:  if entries were loaded into TPA, AX contains
;		ERROR_NO_MORE_FILES when no more entries are available,
;		but DOS Get Extended Error call WON'T return the correct
;		error.  That's ok, because we'll see the value in AX
;		and recognize it as a non-error condition.
;
;	USED	AX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Entries in memory may be marked as output.
;	  If not sorted, entry is loaded at TPA.
;
;	NOTES
;
;	  If we don't find a qualifying file, we return after the final
;	   DOS Find File call.  A DOS Get Extended Error call will then
;	   indicate an appropriate condition.

FindFirst	proc

	mov	ax,offset TRANGROUP:GetFirst
	jmp	short ffFindEntry

FindNext:
	mov	ax,offset TRANGROUP:GetNext

;	AX = address of correct disk get routine to use.

ffFindEntry:
	push	es			; save TRANGROUP seg addr
	test	Bits,mask inmem
	jz	ffDisk			; entries not in memory, search disk

;	Entries are loaded in memory to sort out.  Find the first one.
;	There will always be one, or LoadEntries would've failed.

	call	FindInMem		; find first entry in TPA
	jmp	short ffRet		; return what TPA search returns

;	Get entry from disk.

ffDisk:
	call	ax			; get entry from disk
	jc	ffGetErr		; get & return error
	mov	es,Tpa			; ES = seg addr of TPA
	xor	di,di			; ES:DI = ptr to TPA
	mov	bx,di			; BX = offset of entry in TPA
	call	LoadEntry		; load entry to TPA
	clc				; return success
	jmp	short ffRet

ffGetErr:
	invoke	Get_Ext_Error_Number	; AX = DOS error code
	stc

ffRet:	pop	es			; ES = TRANGROUP seg addr again
	ret

FindFirst	endp




;***	FindInMem - find next directory entry in TPA buffer
;
;	ENTRY	TPA is loaded (see LoadEntries)
;
;	EXIT	BX = offset in TPA of entry found
;
;		If no more files,
;		CY = set
;		AX = DOS 'no more files' error code
;
;	USED	AX,BX,CX,DX,SI,DI,BP,ES
;
;	EFFECTS
;
;	  Entry found is flagged as 'used' (see EntryStruc).

FindInMem	proc

	mov	es,Tpa		; ES = TPA seg addr
	xor	bx,bx		; ES:BX = ptr to 1st entry in TPA
	cld			; make sure default string direction is up
	
	call	FindOneInMem	; locate an entry
	jc	fiNoMore	; none left, set up 'no more files' error

;	BX = ptr to entry in TPA

fiBest:
	mov	bp,bx		; BP = ptr to best entry so far
fiNext:
	call	FindNextInMem	; locate next entry
	jc	fiFound		; no more, best entry so far wins

;	BX = ptr to next entry

	call	CmpEntry	; compare it to best found so far (BP)
	jnb	fiNext		; it's not better, go look at next one
	jmp	fiBest		; it's better, go mark it as best so far

fiNoMore:

;	No more entries available in TPA.  Set up 'no more files' error.

	mov	ax,ERROR_NO_MORE_FILES	; AX = 'no more files' error code
	stc				; return error
	jmp	short fiRet

fiFound:
	mov	bx,bp			; BX = ptr to best entry found
	mov	byte ptr es:[bx],1	; mark entry 'used'
	clc				; return success
fiRet:	ret

FindInMem	endp




;***	FindNextChild - find next subdirectory in current directory
;
;	ENTRY	BX = ptr to last child found, ASCIIZ filename
;		DirBuf is established DTA
;
;	EXIT	BX = ptr (same addr) to next child found, ASCIIZ filename
;
;		If failure,
;		CY = set
;		DOS Get Extended Error call will get error
;
;	USED	AX,CX,DX,SI,DI,BP
;
;	EFFECTS
;
;	  DirBuf is used for find first/next calls.
;
;	NOTES
;
;	  We keep on checking files until DOS returns an error.  If
;	  the error is 'no more files' and the temp filename is not
;	  the initial high tag, copy the temp to the child's name spot
;	  and return success.  Otherwise, send the error back to caller.
;
;	  This routine depends on DS,ES,CS, & SS all being equal.

FindNextChild	proc

	sub	sp,12			; make temp filename buf on stack
	shove	00FFh			; temp filename = high tag
	mov	bp,sp			; BP = ptr to temp filename buf
	shove	"*"
	shove	".*"
	call	GetDriveLtr		; AX = "d:"
	push	ax
	mov	dx,sp			; DX = ptr to "d:*.*",0 on stack

;	See that the stack is restored properly at the end of this proc.

	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
	mov	ah,FIND_FIRST
	int	21h			; DOS- Find First matching file
	jc	fcRet			; return error

	call	CheckChild		; check child against last, temp

fcNext:	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
	mov	ah,FIND_NEXT
	int	21h			; DOS- Find Next matching file
	jc	fcErr			; examine error

	call	CheckChild		; check child against last, temp
	jmp	fcNext			; go find another child

fcErr:
	invoke	Get_Ext_Error_Number	; AX = extended error code
	cmp	ax,ERROR_NO_MORE_FILES	; no more files?
	jne	short fcNope		; some other error- return it

;	We ran out of files.  See if we qualified at least one.

	cmp	byte ptr [bp],0FFh
	je	fcNope			; temp filename is unused- no child

;	Move temp filename to child name position.

	mov	si,bp		; SI = ptr to temp filename
	mov	di,bx		; DI = ptr to child name pos'n
fcMove:	lodsb			; AL = next byte of filename
	stosb			; store byte
	or	al,al
	jz	fcRet		; byte was zero, return success (CY clear)
	jmp	fcMove		; go move another byte

fcNope:	stc			; return error
fcRet:	lahf
	add	sp,20		; restore stack
	sahf
	ret

FindNextChild	endp





;***	FindOneInMem - find the first available entry in TPA
;***	FindNextInMem - find the next available entry in TPA
;
;	ENTRY	ES = TPA seg addr
;		BX = ptr to entry in TPA
;
;	EXIT	BX = ptr to entry found
;		CY = set if no more entries available in TPA
;
;	USED	AL

FindOneInMem	proc

	mov	al,es:[bx]	; examine 'used' byte of starting entry
	cmp	al,1
	je	FindNextInMem	; entry has already been used
	cmp	al,0FFh
	je	foNoMore	; 0FFh, we're at the end of the list

;	BX = ptr to entry that hasn't been output yet.

	clc			; return success
	ret

FindNextInMem:
	add	bx,size EntryStruc	; BX = ptr to next entry
	jmp	FindOneInMem		; go look at it

foNoMore:
	stc				; ran out of entries, return failure
	ret

FindOneInMem	endp




;***	GetEnvValue - get value of our environment variable
;
;	ENTRY	DS, ES = TRANGROUP seg addr
;
;	EXIT	CY = set if environment variable not in environment
;
;		Otherwise:
;		SI = ptr to environment variable asciiz value in TRANGROUP
;
;	USED	AX,BX,CX,DX,DI
;		(We assume the (almost) worst, since we don't know about
;		Find_Name_In_Environment.)
;
;	EFFECTS
;
;	  ScanBuf is loaded with value text

GetEnvValue proc

	push	es				; save ES
	mov	si,offset TRANGROUP:DirEnvVar	; DS:SI = ptr to variable name
	invoke	Find_Name_In_Environment
	jc	geRet				; name not found in environment

;	ES:DI = ptr to value of environment variable
;	We're assuming DS, CS, and SS are unchanged.

	push	ds
	push	es
	pop	ds
	pop	es

	assume	ds:nothing

;	DS = seg addr of environment variable value (in environment segment)
;	ES = TRANGROUP seg addr

	mov	si,di				; DS:SI = ptr to value string
	mov	di,offset TRANGROUP:ScanBuf	; ES:DI = ptr to dest buffer
@@:	lodsb
	or	al,al
	stosb
	loopnz	@B		; move the string, including trailing null

	push	es
	pop	ds		; DS = TRANGROUP seg addr again
	assume	ds:TRANGROUP

	mov	si,offset TRANGROUP:ScanBuf	; SI = ptr to var value
geRet:	pop	es				; restore ES
	ret

GetEnvValue endp




;***	GetFirst - get first directory entry from disk
;
;	ENTRY	DOS DTA established at DirBuf
;		FCB contains drive # and filename
;		Current directory (on selected drive) is the one to search
;		AttrSpecified & AttrSelect masks set
;
;	EXIT	CY = clear if success
;		DirBuf contains extended FCB for file found
;
;		If unsuccessful,
;		CY = set
;		Ready for DOS Get Extended Error call
;
;	USED	AX,DX
;
;	EFFECTS
;
;	  FCB-7 = 0FFh to mark extended FCB
;	  FCB-1 = attribute mask to find all files
;	  These fields should remain unmodified for GetNext calls.
;
;
;***	GetNext - get next directory entry from disk
;
;	ENTRY	As for GetFirst, plus
;		FCB-7 set up as extended FCB w/ find-all attribute byte
;
;	EXIT	As for GetFirst
;
;	USED	AX,DX

GetFirst	proc

	mov	byte ptr ds:FCB-7,0FFh	; signal extended FCB
	mov	byte ptr ds:FCB-1,ATTR_ALL
					; find any file
	mov	dx,FCB-7		; DX = ptr to extended FCB
	mov	ah,DIR_SEARCH_FIRST	; AH = DOS Find First function code
	int	21h			; call DOS
	shl	al,1			; CY = set if error
	jc	gfRet			; return error
	jmp	short gfFound		; go look at attr's

GetNext:
	mov	dx,FCB-7		; DX = ptr to extended FCB
	mov	ah,DIR_SEARCH_NEXT	; AH = DOS Find Next function code
	int	21h			; call DOS
	shl	al,1			; CY = set if error
	jc	gfRet			; return error

;*	Found an entry.  Check attributes.

gfFound:
	mov	al,[DirBuf+8].dir_attr	; AL = file attributes
	mov	ah,AttrSpecified	; AH = mask of pertinent attr's
	and	al,ah			; AL = pertinent attr's of file
	and	ah,AttrSelect		; AH = attr settings to match
	cmp	al,ah
	jne	GetNext			; attr's don't match, look for another

gfRet:	ret

GetFirst	endp




;***	ListDir - search for and list files in the current directory
;
;	List header, files, and trailer for current directory on selected
;	drive.  Header & trailer are listed if at least one file is found.
;	If no qualifying files are found, no display output occurs.
;
;	ENTRY	Current directory (on selected drive) is the one to be listed
;		FCB contains selected drive # and filename spec
;		Option bits, attribute masks, and sort codes set up
;
;	EXIT	CY = clear if no error
;		FileCnt = # files found & displayed
;
;		If error,
;		CY = set
;		Ready for DOS Get Extended Error call
;
;	USED	AX,BX,CX,DX,SI,DI,BP
;		FileSiz
;
;	EFFECTS
;
;	  FileCntTotal, FileSizTotal are updated.
;	  Files found are listed.  A directory header and trailer are
;	   displayed only if files are found.

ListDir	proc

	xor	ax,ax
	mov	FileCnt,ax		; zero file count
	mov	word ptr FileSiz,ax	; zero file size accumulator
	mov	word ptr FileSiz+2,ax

	cmp	DestBuf,0		; check for sort code
	je	@F			; no sort
	call	LoadEntries		; load entries for sorted listing
	jnc	@F			; no error - continue
	invoke	Get_Ext_Error_Number	; AX = DOS error code
	stc
	jmp	short ldErr		; return error
@@:
	call	FindFirst		; find first file
	jc	ldErr			; not found, return error

;	BX = offset in TPA buffer of entry found

	call	DisplayHeader		; if at least one file, display header
	call	DisplayFile		; display the file entry
ldNext:
	call	FindNext		; find another file
	jc	ldErr			; not found
	call	DisplayFile		; display entry
	jmp	ldNext			; go find another one

ldErr:
	cmp	ax,ERROR_FILE_NOT_FOUND
	je	ldDone			; file not found, we're done
	cmp	ax,ERROR_NO_MORE_FILES
	je	ldDone			; no more files, we're done
	stc
	jmp	short ldRet

ldDone:
	cmp	FileCnt,0
	je	@F			; no files found, just return
	call	DisplayTrailer		; display trailing info
@@:	clc				; return success

ldRet:	ret

ListDir	endp




;***	LoadEntries - attempt to load entries from current directory
;
;	Load all qualifying directory entries from the current directory
;	into the TPA.  If an error is returned by FindFirst/FindNext calls
;	other than 'no more files', return to caller with carry flag set.
;	If we run out of buffer space, display a message that we haven't
;	enough memory to sort this directory, but return without error.
;	Other routines know whether or not entries have been loaded by
;	the 'inmem' flag bit, which we set here.
;
;	The TPA is usually 64K - 512 bytes long.  At 20 bytes per entry,
;	this allows sorting over 3000 entries in a directory.
;
;	ENTRY	Tpa = buffer seg addr
;		BytCnt = buffer length, in bytes
;		Current directory (on selected drive) is the one to load
;		FCB contains drive # and filespec
;		Bits, AttrSpecified, AttrSelect, & DestBuf (sort codes) are set
;
;	EXIT	CY = set if error
;		If error, DOS Get Extended Error will get error info
;
;	USED	AX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Inmem bit of Bits = set if load succeeded.
;	  Tpa buffer contains directory entries.
;	  Byte after last entry = 0FFh.

LoadEntries	proc

	push	es			; save TRANGROUP seg addr
	mov	es,Tpa			; ES = TPA seg addr
	xor	di,di			; ES:DI = destination ptr
	and	Bits,not mask inmem	; signal entries not loaded

	call	GetFirst		; look for first file
	jc	leRet			; return any error
	call	LoadEntry		; load entry into TPA

leNext:	call	GetNext			; get another file
	jc	leLoaded		; assume any error is no more files
	mov	ax,BytCnt		; AX = size of TPA
	sub	ax,di			; AX = bytes left in TPA
	cmp	ax,size EntryStruc+2	; insist on entry size + 2 bytes
	jb	leOk			; not enough memory left, give up
	call	LoadEntry		; load entry into TPA
	jmp	leNext			; go get another file

leLoaded:
	mov	byte ptr es:[di],0FFh	; mark end of entry list
	or	Bits,mask inmem		; signal entries loaded in memory
leOk:	clc				; return no error

leRet:	pop	es			; ES = TRANGROUP seg addr again
	ret

LoadEntries	endp




;***	LoadEntry - load directory entry from DirBuf ext'd FCB
;
;	ENTRY	ES:DI = ptr to load point in TPA
;		DirBuf contains extended FCB of entry to load
;
;	EXIT	ES:DI = ptr to next byte available in TPA
;
;	USED	AX,CX,SI
;
;	NOTES
;
;	  I could've used symbolic offsets and sizes of fields from
;	   the dir_entry struc to do this, but this is time-critical,
;	   so I hard-wired the structure of the DOS 4.x returned FCB,
;	   as well as our private directory entry structure.
;
;	  We force a zero size for subdirectory files.  A zero size is
;	   ordinarily returned for subdirectories, but with Novell
;	   Netware 286 or 386 loaded, we can't depend on it.  Bug #1594.

LoadEntry	proc

	mov	si,offset TRANGROUP:Dirbuf+8	; DS:SI = ptr to filename
	xor	al,al				; AL = 0
	stosb					; 'used' byte = false
	mov	cx,11
	rep	movsb				; transfer filename & extension
	lodsb					; AL = attrib byte
	stosb					; store attrib byte
	add	si,dir_time-dir_attr-1		; skip to time field
	movsw					; transfer time
	movsw					; transfer date
	inc	si				; skip alloc unit
	inc	si

	and	al,ATTR_DIRECTORY
	jnz	leSetDirSize			; force zero size for subdir

	movsw
	movsw					; transfer size
	ret

leSetDirSize:
	xor	ax,ax
	stosw
	stosw					; store zero size
	ret

LoadEntry	endp




;***	NoOrder - turn sorting off
;
;	ENTRY	nothing
;
;	EXIT	CY clear
;
;	USED	AX
;
;	EFFECTS
;
;	  DestBuf is updated with sort code bytes.  See DestBuf description.

NoOrder	proc

	mov	DestBuf,0	; no sort
	clc			; no error
	ret

NoOrder	endp




;***	OnOffSw - record occurence of on/off option switch
;
;	ENTRY	DI = index into word list of switches
;
;	EXIT	CY clear
;
;	USED	AX,CX
;
;	EFFECTS
;
;	  Bits modified to indicate option state.

OnOffSw	proc

	mov	cx,di		; CX = index into word list of options
	shr	cx,1
	shr	cx,1		; CX = bit position of option
	mov	ax,1		
	shl	ax,cl		; AX = bit mask of option
	test	di,2		; check if it is a negated option
	jz	@F		; it's negated
	or	Bits,ax		; turn option on
	jmp	short ooRet

@@:	not	ax		; AX = complemented bit mask of option
	and	Bits,ax		; turn option off

ooRet:	clc			; always return success
	ret

OnOffSw	endp




;***	ParseAttr - parse and record /A option
;
;	ENTRY	BX = ptr to system parser result buffer for /A occurence
;
;	EXIT	CY = set if error occurs parsing attribute conditions
;
;		For parse error, we set up for Std_EPrintf call:
;		AX = parse error code, like system parser
;		DX = ptr to message block
;
;	USED	AX,CX,DX,DI
;
;	EFFECTS
;
;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
;	  If parse error occurs, attribute conditions parsed so far hold.
;
;	  For parse error, we set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error message class
;	  Message block (see DX) is set up for parse error message

ParseAttr	proc

	push	si			; save SI
	mov	AttrSpecified,0		; cancel all attribute conditions

;	Each /A invocation starts by assuming all files are to be listed.

	mov	si,word ptr [bx].ValuePtr ; SI = ptr to string after /A

paLoop:	mov	dx,1			; DX = 1 (for un-negated attribute)

	lodsb				; AL = next char in string
	or	al,al
	jz	paOk			; it's terminating null, we're done
	cmp	al,'-'
	jne	@F			; not '-', go look for letter
	dec	dx			; DX = 0 (for negated attribute)
	lodsb				; AL = next char
@@:	
	mov	di,offset TRANGROUP:AttrLtrs  ; DI = ptr to attrib letter list
	mov	cx,NUM_ATTR_LTRS	; CX = length of attrib letter list
	repne	scasb			; look for our letter in the list
	jne	paErr			; not found, return error

	not	cx
	add	cx,NUM_ATTR_LTRS	; CX = attrib bit #, 0-5

;	Note that we rely on AttrLtrs to be in the attribute bit order,
;	starting from bit 0.

;	Record this attribute bit in AttrSpecified.

	mov	al,1
	shl	al,cl			; AL = mask for our bit
	or	AttrSpecified,al	; set it in the 'specified' mask

;	Record the selected state for this attribute in AttrSelect.
;	DX = 0 or 1, the selected state for this attribute.

	not	al			; AL = mask for all other bits
	and	AttrSelect,al		; clear our bit
	shl	dl,cl			; DL = our bit state in position
	or	AttrSelect,dl		; set selected attr state
	jmp	paLoop			; go look at next char

;	The attribute letter string is invalid.

paErr:	
	call	SetupParamError		; set message up for Std_EPrintf
	stc		   		; return error
	jmp	short paRet

paOk:	clc				; return success		

paRet:	pop	si			; restore SI
	ret

ParseAttr	endp




;***	ParseLine - parse a line of text
;
;	Parse text until an EOL (CR or NUL) is found, or until a parse
;	error occurs.
;
;	ENTRY	DS:SI = ptr to text
;		CS, DS, ES = TRANGROUP seg addr
;
;	EXIT	AX = last return code from system parser
;		CX = # positional parameters (pathnames) found - 0 or 1
;
;		If parse error occurred, we're set up for Std_EPrintf call:
;		DX = ptr to message block
;
;	USED	BX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Bits may contain new option settings.
;	  DestBuf may contain new series of sort codes.
;	  AttrSpecified, AttrSelect may contain new attribute conditions.
;	  SrcBuf may contain a new default pathname/filespec.
;	  PathPos, PathCnt updated for new pathname.
;
;	  If parse error occurred, we're set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error class
;	  Byte after last parameter in text is zeroed to make ASCIIZ string
;	  Message block (see DX) is set up for parse error message

ParseLine	proc

	mov	di,offset TRANGROUP:Parse_Dir	 ; ES:DI = ptr to parse block
	xor	cx,cx				 ; CX = # positionals found
plPars:
	invoke	Parse_With_Msg		; call parser
	cmp	ax,END_OF_LINE
	je	plRet			; EOL encountered, return
	cmp	ax,RESULT_NO_ERROR
	jne	plRet			; parse error occurred, return

;	Parse call succeeded.  We have a filespec or a switch.
;	DX = ptr to result buffer

	mov	bx,dx			; BX = ptr to parse result buffer
	cmp	byte ptr [bx],RESULT_FILESPEC
	je	plFil			; we have a filespec

	call	ParseSwitch		; else we have a switch
	jc	plRet			; error parsing switch, return
	jmp	plPars			; parse more

plFil:	call	CopyPathname		; copy pathname into our buffer
	jmp	plPars			; parse more

plRet:	ret

ParseLine	endp




;***	ParseOrder - parse and record /O option
;
;	ENTRY	BX = ptr to system parser result buffer for /O occurence
;
;	EXIT	CY = set if error occurs parsing order
;
;		For parse error, we set up for Std_EPrintf call:
;		AX = parse error code, like system parser
;		DX = ptr to message block
;
;	USED	AX,CX,DX,DI
;
;	EFFECTS
;
;	  DestBuf is updated with sort code bytes.  See DestBuf description.
;
;	  For parse error, we set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error message class
;	  Message block (see DX) is set up for parse error message

ParseOrder	proc

	push	si				; save SI
	push	bx				; save ptr to result buffer

	mov	si,word ptr [bx].ValuePtr	; SI = ptr to order letters
	mov	bx,offset TRANGROUP:DestBuf	; BX = ptr to sort code buffer
	mov	al,[si]				; AL = 1st char of order string
	or	al,al
	jnz	poLtr			; not NUL, go parse letters

;	We have /O alone.  Set standard sort order.
;	Note hardwired dependency on character order in OrderLtrs.

	mov	byte ptr [bx],5		; sort 1st by group (subdirs 1st)
	inc	bx
	mov	byte ptr [bx],1		; then by name
	inc	bx
	mov	byte ptr [bx],2		; then by extension
	inc	bx
	jmp	short poOk		; return success

;	We have /O<something>.  Parse sort order letters.

poLtr:	xor	dl,dl			; DL = 0 (upward sort)
	lodsb				; AL = next sort order letter
	or	al,al
	jz	poOk			; NUL found, return success

	cmp	al,'-'
	jne	@F			; not '-', go look for letter
	mov	dl,80h			; DL = downward sort mask
	lodsb				; AL = next char
@@:
	mov	di,offset TRANGROUP:OrderLtrs  ; DI = ptr to list of letters
	mov	cx,NUM_ORDER_LTRS	; CX = length of list
	repne	scasb			; look for our letter in the list
	jne	poErr			; not found, return error

	neg	cx
	add	cx,NUM_ORDER_LTRS	; CL = sort order code, 1-5
	or	cl,dl			; CL = sort code with up/dn bit
	mov	[bx],cl			; store sort order code in buffer
	inc	bx			; BX = ptr to next spot in buffer
	cmp	bx,offset TRANGROUP:EndDestBuf
	jae	poErr			; too many letters

	jmp	poLtr			; go look at next char

;	The sort order string is invalid.  

poErr:	pop	bx			; BX = ptr to result buffer
	call	SetupParamError		; set message up for Std_EPrintf
	stc				; return failure
	jmp	short poRet

poOk:	mov	byte ptr [bx],0		; mark end of sort code list
	pop	bx			; BX = ptr to result buffer
	clc				; return success

poRet:	pop	si			; restore SI
	ret

ParseOrder	endp




;***	ParseSwitch - parse a switch
;
;	ENTRY	BX = ptr to parse result buffer after system parser processed
;		     a switch
;
;	EXIT	CY = set if parse error occurred
;
;		If parse error occurred, we're set up for Std_EPrintf call:
;		AX = parse error code, like system parser
;		DX = ptr to message block
;
;	USED	AX,BX,DX
;
;	EFFECTS
;
;	  Bits may contain new option settings.
;	  DestBuf may contain new series of sort codes.
;	  AttrSpecified, AttrSelect may contain new attribute conditions.
;
;	  If parse error occurred, we're set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error class
;	  Byte after last parameter in text is zeroed to make ASCIIZ string
;	  Message block (see DX) is set up for parse error message

ParseSwitch	proc

	push	cx			; save CX
	push	di			; save DI

	mov	ax,[bx].SynPtr		; AX = synonym ptr
	mov	di,offset TRANGROUP:Dir_Sw_Ptrs
					; ES:DI = ptr to list of synonym ptrs
	mov	cx,NUM_DIR_SWS		; CX = # of dir switches in list
	cld				; scan direction = upward
	repne	scasw			; locate synonym ptr in list
	sub	di,offset TRANGROUP:Dir_Sw_Ptrs + 2

;	DI = index into word list of synonym ptrs

	call	cs:SwHandlers[di]	; use same index into call table

	pop	di			; restore DI
	pop	cx			; restore CX

	ret

;	Order in this table must correspond to order in Dir_Sw_Ptrs list.
;	Simple on/off switches must occur first in both lists, and must be
;	  in order of option bits in Bits, starting with bit 0.

SwHandlers	label	word
	dw	OnOffSw		; /-W
	dw	OnOffSw		; /W
	dw	OnOffSw		; /-P
	dw	OnOffSw		; /P
	dw	OnOffSw		; /-S
	dw	OnOffSw		; /S
	dw	OnOffSw		; /-B
	dw	OnOffSw		; /B
	dw	OnOffSw		; /-L	;M010
	dw	OnOffSw		; /L	;M010
	dw	NoOrder		; /-O
	dw	ParseOrder	; /O
	dw	DefaultAttr	; /-A
	dw	ParseAttr	; /A

ParseSwitch	endp



	break	<DIR utility routines>

;***	UTILITY ROUTINES




;***	ChangeDir - change directory on target drive
;
;	ENTRY	FCB contains drive #
;		DS:DX = ptr to ASCIIZ string w/o drive specifier
;
;	EXIT	Changed current directory on drive
;
;		If error,
;		CY = set
;		DOS Get Extended Error call will get error
;
;	USED	AX,DX,SI,DI
;
;	EFFECTS
;
;	  DirBuf is used to build "d:string".

ChangeDir	proc

	mov	di,offset TRANGROUP:DirBuf
	call	GetDriveLtr	; AX = "d:"
	stosw			; put drive specifier in buffer
	mov	si,dx		; SI = ptr to argument string
cdLoop:
	lodsb
	stosb			; move byte to buffer
	or	al,al
	jne	cdLoop		; continue until null transferred

	mov	dx,offset TRANGROUP:DirBuf	; DX = ptr to "d:string"
	mov	ah,CHDIR
	int	21h				; change directory
	ret					; return what CHDIR returns

ChangeDir	endp




;***	CmpAscz - compare two ASCIIZ strings alphanumerically
;
;	ENTRY	DS:SI = ptr to one ASCIIZ string
;		ES:DI = ptr to another ASCIIZ string
;
;	EXIT	flags set after REPE CMPSB
;
;	USED	AL,CX,SI,DI
;
;	NOTES
;
;	Maximum run of comparison is length of DS:SI string.
;	This ensures that two identical strings followed by
;	random characters will compare correctly.

CmpAscz	proc

	push	di

	mov	di,si
	xor	al,al
	mov	cx,0FFFFh
	repne	scasb
	not	cx

	pop	di
	repe	cmpsb
	ret

CmpAscz	endp




;***	CopyPathname - copy pathname to our buffer
;
;	ENTRY	BX = ptr to parse result buffer after system parser processed
;		     a filespec
;
;	EXIT	nothing
;
;	USED	AX
;
;	EFFECTS
;
;	  SrcBuf may contain a new pathname/filespec.
;	  PathPos, PathCnt updated for new pathname.

CopyPathname	proc

	push	si
	lds	si,dword ptr [bx].ValuePtr  ; load far ptr from result buffer
	invoke	Move_To_SrcBuf		    ; copy pathname to SrcBuf
	pop	si
	ret

CopyPathname	endp



;***	CountFile - update counters with current file
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,DX
;
;	EFFECTS
;
;	  FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.

CountFile	proc

	push	es			; save TRANGROUP seg addr
	mov	es,Tpa			; ES = TPA seg addr

	inc	FileCnt			; # files this directory
	inc	word ptr FileCntTotal	; # files total
	jnz	@F
	inc	word ptr FileCntTotal+2
@@:
	mov	ax,word ptr es:[bx].filesize	; AX = low word of file size
	mov	dx,word ptr es:[bx].filesize+2	; DX = high word of file size
	add	word ptr FileSiz,ax
	adc	word ptr FileSiz+2,dx		; size of this directory
	add	word ptr FileSizTotal,ax
	adc	word ptr FileSizTotal+2,dx	; total size of files listed

	pop	es			; ES = TRANGROUP seg addr again
	ret

CountFile	endp




;***	DisplayBare - display filename in bare format
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	DX = # char's displayed, including dot
;
;	USED	AX,CX,SI,DI
;
;	EFFECTS
;
;	  Filename is displayed in name.ext format, followed by cr/lf.
;	  If /s is on, complete pathname is displayed.
;
;	NOTE
;
;	  Directory pseudofiles . and .. and suppressed in bare listing.

DisplayBare	proc

;	Suppress . and .. files from bare listing.

	mov	cx,ds			; CX = saved TRANGROUP seg addr
	mov	ds,Tpa			; DS:BX = ptr to file entry
	assume	ds:NOTHING
	cmp	ds:[bx].filename,'.'	; check 1st char of filename
	mov	ds,cx			; DS = TRANGROUP seg addr again
	assume	ds:TRANGROUP
	je	dbRet			; it's . or .. - don't display

	test	Bits,mask subd
	jz	dbNameExt		; not /s - display filename only

	invoke	Build_Dir_String
	mov	di,offset TRANGROUP:BwdBuf	; ES:DI = ptr to dir string
   
	test	Bits,mask lcase		;M010;check for lowercase option
	jz	@F			;M010;lowercase not needed
	mov	si,di			;M010;DS:SI --> ASCIIZ string in BwdBuf	
	call	LowercaseString		;M010;path string is in BwdBuf

@@:	xor	al,al			; AL = 0
	mov	cx,0FFFFh
	cld
	repne	scasb			; ES:DI = ptr to byte after null
	dec	di			; ES:DI = ptr to null byte

ifdef DBCS
	push	si
	push	di
	mov	si,offset TRANGROUP:BwdBuf
	dec	di
	call	CheckDBCSTailByte
	pop	di
	pop	si
	jz	dbTailByte		; if last char is double byte
endif

	cmp	byte ptr es:[di-1],'\'
	je	@F			; already terminated w/ '\'

ifdef DBCS
dbTailByte:
endif

	mov	ax,'\'			; AX = '\',0
	stosw				; add to dir string
@@:
	mov	String_Ptr_2,offset TRANGROUP:BwdBuf
	mov	dx,offset TRANGROUP:String_Buf_Ptr
	invoke	Std_Printf		; display device & directory path

dbNameExt:
	call	DisplayDotForm		; display name.ext
	invoke	CrLf2			; display cr/lf
	call	UseLine			;M007;Allow /p with /b
dbRet:	ret

DisplayBare	endp




;***	DisplayDotForm - display filename in compressed dot format
;
;	Display name.ext, with no cr/lf's.  Dot is displayed only
;	if the filename has a nonblank extension.
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	DX = # char's displayed, including dot
;
;	USED	AX,CX,SI,DI
;
;	EFFECTS
;
;	  Filename is displayed in name.ext format.
;
;	NOTE
;
;	  We allow for bogus filenames that have blanks embedded
;	  in the name or extension.

;	Bugbug:	might be a good performance gain if we buffered
;	up the output and used DOS function 9.

DisplayDotForm	proc

	push	ds			; save TRANGROUP seg addr
	push	es			; save ES
	mov	ax,cs:Tpa		; AX = TPA seg addr
	mov	ds,ax			; DS:BX = ptr to entry
	assume	ds:nothing
	mov	es,ax			; ES:BX = ptr to entry

	mov	di,bx			; ES:DI = ptr to entry
	add	di,filename + size filename - 1
					; ES:DI = ptr to last char in name field
	mov	cx,size filename	; CX = length of name field
	mov	al,' '
	std				; scan down
	repe	scasb			; scan for nonblank

;	Assume file name has at least one character.

	inc	cx			; CX = # chars in name
	mov	dx,cx			; DX = # chars to be displayed

	mov	si,bx			; DS:SI = ptr to entry
	add	si,filename		; DS:SI = ptr to name

NextNameChar:
	cld
	lodsb				; AL = next char

ifdef DBCS
	invoke	testkanj
	jz	@f			; if this is not lead byte
	invoke	Print_Char		; display lead byte
	dec	cx
	jz	ExtChar			; if this is end
	lodsb				; get tail byte
	jmp	short NameChar10	; display tail byte
@@:
endif

	test	Bits,mask lcase		;M010;check for lowercase option
	jz	@F			;M010;lowercase not required
	call	LowerCase		;M010;filename char is in AL

ifdef DBCS
NameChar10:
endif

@@:	invoke	Print_Char		; display it
	loop	NextNameChar

ifdef DBCS
ExtChar:
endif

;	Now do extension.

	mov	di,bx			; ES:DI = ptr to entry
	add	di,fileext + size fileext - 1
					; ES:DI = ptr to last char in ext field
	mov	cx,size fileext		; CX = length of ext field
	mov	al,' '
	std				; scan down
	repe	scasb			; scan for nonblank
	je	ddDone			; no nonblank chars in ext

	inc	cx			; CX = # chars in ext
	add	dx,cx			; DX = total # chars to be displayed
	inc	dx			;      including dot

	mov	al,'.'
	invoke	Print_Char
	mov	si,bx			; DS:SI = ptr to entry
	add	si,fileext		; DS:SI = ptr to ext

NextExtChar:
	cld
	lodsb				; AL = next char

ifdef DBCS
	invoke	testkanj
	jz	@f			; if this is not lead byte
	invoke	Print_Char		; display lead byte
	dec	cx
	jz	ddDone			; if this is end
	lodsb				; get tail byte
	jmp	short ExtChar10		; display tail byte
@@:
endif

	test	CS:Bits,mask lcase	;M010;check for lowercase option
	jz	@F			;M010;lowercase not required
	call	LowerCase		;M010;fileext char is in AL

ifdef DBCS
ExtChar10:
endif

@@:	invoke	Print_Char		; display it
	loop	NextExtChar

ddDone:	pop	es			; restore ES
	pop	ds			; DS = TRANGROUP seg addr again
	assume	ds:TRANGROUP
	cld				; leave direction flag = up
	ret

DisplayDotForm	endp




;***	DisplayFile - display file entry, update counters
;
;	ENTRY	BX = offset of entry in TPA buffer
;		Bits contains /w, /p settings
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI,DI,BP
;
;	EFFECTS
;
;	  Entry is displayed.  
;	  If not /b,
;	    Cursor is left at end of entry on screen.
;	    FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
;	  If /b,
;	    Cursor is left at beginning of next line.
;	    Cnt's and Siz's aren't updated.

DisplayFile	proc

	test	Bits,mask bare
	jz	dfNorm			; not /b - do normal display

	call	DisplayBare		; display file in bare format
	jmp	short dfRet

dfNorm:	call	DisplayNext		; pos'n cursor for next entry
	test	Bits,mask wide
	jz	dfFull			; full format
	call	DisplayWide		; wide format
	jmp	short dfCnt

dfFull:	call	DisplayName		; display filename & extension
	call	DisplayTheRest		; display size, date, time

dfCnt:	call	CountFile		; update file counters
dfRet:	ret

DisplayFile	endp




;***	DisplayHeader - display directory header of working directory
;
;	ENTRY	Current directory (on selected drive) is the one to display
;		LeftOnPage = # lines left on display page
;
;	EXIT	nothing
;
;	ERROR EXIT
;
;	  Build_Dir_String will exit through CError with "Invalid drive
;	   specification" if there's a problem obtaining the current 
;	   directory pathname.
;
;	USED	AX,DX,SI,DI
;
;	EFFECTS
;
;	  BwdBuf (which is really the same buffer as DirBuf, which
;	   we are using for the DTA) contains the directory string.
;	  LeftOnPage is adjusted.

DisplayHeader	proc

	test	Bits,mask bare
	jnz	dhRet			; /b - don't display header

	test	Bits,mask subd
	jz	dhNorm			; not /s

;	For subdirectory listings, put a blank line before the header.

	invoke	Crlf2			; start with a blank line
	call	UseLine
	jmp	short dhCom
dhNorm:
	mov	al,BLANK		; if not /s, precede by a blank
	invoke	Print_Char		; print a leading blank
dhCom:
	invoke	Build_Dir_String
	mov	dx,offset TRANGROUP:DirHead_ptr
	invoke	Std_Printf		; print header & cr/lf
	call	UseLine
	invoke	Crlf2			; another cr/lf
	call	UseLine
dhRet:	ret

DisplayHeader	endp




;***	DisplayName - display file name & extension
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Filename & extension are displayed in spread format.
;	  Cursor is left at end of extension.

DisplayName	proc

	push	ds				; save TRANGROUP seg addr
	mov	ds,Tpa				; DS:BX = ptr to entry
	assume	ds:nothing
	mov	si,bx				; DS:SI = ptr to entry
	add	si,filename			; DS:SI = ptr to filename
	mov	di,offset TRANGROUP:CharBuf	; ES:DI = ptr to CharBuf

	mov	cx,8
	cld
	rep	movsb				; move filename to CharBuf
	mov	al,' '
	stosb					; add a blank
	mov	cx,3
	rep	movsb				; add extension
	xor	al,al
	stosb					; add a NULL

	pop	ds				; DS = TRANGROUP seg addr again
	assume	ds:TRANGROUP

	test	Bits,mask lcase			;M010;check for lowercase option
	jz	@F			        ;M010;lowercase not required
	mov	si,offset TRANGROUP:CharBuf	;M010;DS:SI --> ASCIIZ string
	call	LowercaseString			;M010;filename.ext string is in CharBuf

@@:	mov	String_Ptr_2,offset TRANGROUP:CharBuf
	mov	dx,offset TRANGROUP:String_Buf_Ptr
	invoke	Std_Printf			; print filename & extension
	ret

DisplayName	endp




;***	DisplayNext - move display cursor to next entry position
;
;	ENTRY	LeftOnLine = # entries can still be printed on this line
;		LeftOnPage = # lines can still be printed for this page
;		FileCnt = # files in this dir displayed before this one
;		Bits contains /w setting
;
;	EXIT	nothing
;
;	USED	AX,DX
;
;	EFFECTS
;
;	  LeftOnLine will be updated to reflect the entry about to be
;	   displayed.
;	  LeftOnPage may be updated.

DisplayNext	proc

	cmp	FileCnt,0
	je	dn1st			; 1st file in directory
	cmp	LeftOnLine,0
	jng	dnEol			; no more room on this line

;	We are in wide mode (LeftOnLine is always 0 otherwise) and
;	we still have room for more on this line.
;	Tab to next position.

	mov	dx,offset TRANGROUP:Tab_Ptr
	invoke	Std_Printf
	jmp	short dnDone

dnEol:	

;	Start this entry on a new line.

	invoke	Crlf2		; start on new line
	call	UseLine
dn1st:	mov	al,PerLine
	mov	LeftOnLine,al	; reset # entries left on line

dnDone:	dec	LeftOnLine	; reflect the entry about to be displayed
	ret

DisplayNext	endp




;***	DisplayTheRest - display file size/dir, date, time
;
;	ENTRY	BX = offset of entry in TPA buffer
;		Display cursor is at end of file extension
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI,DI,BP
;
;	EFFECTS
;
;	  File size, date, & time are displayed.

DisplayTheRest	proc

	push	es			; save TRANGROUP seg addr
	mov	es,Tpa			; ES = TPA seg addr
	mov	bp,bx			; BP = offset of entry in TPA
	test	es:[bp].fileattr,ATTR_DIRECTORY
	jz	drNonDir		; not a directory file

;	For a directory file, display <DIR> instead of size.

	mov	dx,offset TRANGROUP:DMes_Ptr
	invoke	Std_Printf
	jmp	short drCom		; skip to common fields

drNonDir:

;	For a non-directory file, display file size.

	mov	dx,word ptr es:[bp].filesize
	mov	File_Size_Low,dx
	mov	dx,word ptr es:[bp].filesize+2
	mov	File_Size_High,dx
	mov	dx,offset TRANGROUP:Disp_File_Size_Ptr
	invoke	Std_Printf

drCom:

;	For all files, display date & time.

	mov	ax,es:[bp].filedate	; AX = date word
	or	ax,ax			; test for null date (DOS 1.x)
	jz	drDone			; no date, skip date/time display
	mov	bx,ax			; BX = date word
	and	ax,1Fh			; AX = day of month
	mov	dl,al			; DL = day of month
	mov	ax,bx			; AX = date word
	mov	cl,5
	shr	ax,cl			; shift day out
	and	al,0Fh			; AL = month
	mov	dh,al			; DH = month
	mov	cl,bh
	shr	cl,1			; CL = year - 1980
	xor	ch,ch			; CX = year - 1980
	add	cx,80			; CX = 2-digit year
	cmp	cl,100
	jb	@F			; not year 2000 yet, skip ahead
	sub	cl,100			; adjust for 21st century
@@:	xchg	dh,dl			; DX = month/day
	mov	DirDat_Yr,cx		; move year to msg block
	mov	DirDat_Mo_Day,dx	; move month/day to msg block
	mov	cx,es:[bp].filetime	; CX = file time
	jcxz	drPrint			; no time field - go print
	shr	cx,1
	shr	cx,1
	shr	cx,1			; CH = hours
	shr	cl,1
	shr	cl,1			; CL = minutes
	xchg	ch,cl			; CX = hr/min
	mov	DirTim_Hr_Min,cx	; move time to msg block
drPrint:mov	dx,offset TRANGROUP:DirDatTim_Ptr
	invoke	Std_Printf		; print date & time

drDone:	pop	es			; ES = TRANGROUP seg addr again	
	mov	bx,bp			; BX = offset of entry in TPA again
	ret

DisplayTheRest	endp




;***	DisplayTrailer - display trailing lines for directory listing
;
;	ENTRY	LeftOnPage = # lines left on display page
;		FileCnt = # files listed
;		FileSiz = total size of files listed
;
;	EXIT	nothing
;
;	USED
;
;	EFFECTS
;
;	  Trailing info lines are displayed

DisplayTrailer	proc

	test	Bits,mask bare
	jnz	dtrRet				; /b - don't display trailer

	invoke	Crlf2				; start on new line
	call	UseLine
	mov	ax,FileCnt			; AX = # files found

DisplayCntSiz:

;	DisplayTotals uses this entry point.
;
;	AX = # files
;	FileSiz = dword total size of files

	mov	Dir_Num,ax			; load # files
	mov	dx,offset TRANGROUP:DirMes_Ptr	; DX = ptr to message block
	invoke	Std_Printf			; "nnn File(s)"

	mov	dx,offset TRANGROUP:Bytes_Ptr
	invoke	Std_Printf			; "nnn bytes",cr,lf
	call	UseLine

dtrRet:	ret

DisplayTrailer	endp




;***	DisplayWide - display filename in wide format
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Name.ext is displayed.  Cursor left at end of field (padded
;	  with blanks).  Subdirectory files are displayed as [name.ext].

DisplayWide	proc

	push	ds				; save TRANGROUP seg addr
	mov	ds,Tpa				; DS:BX = ptr to entry
	assume	ds:nothing

	test	ds:[bx].fileattr,ATTR_DIRECTORY
	jz	@F				; not a subdirectory file
	mov	al,'['
	invoke	Print_Char			; prefix subdirectory

@@:	call	DisplayDotForm			; display name.ext

;	DX = # chars displayed in name.ext

	test	ds:[bx].fileattr,ATTR_DIRECTORY
	jz	@F				; not a subdirectory file
	mov	al,']'
	invoke	Print_Char			; postfix subdirectory
@@:
;	Pad field with blanks.

	mov	cx,size filename + size fileext + 1
						; CX = field size
	sub	cx,dx				; CX = # pad char's
	jcxz	dwDone
	mov	al,' '

@@:	invoke	Print_Char
	loop	@B

dwDone:	pop	ds			; DS = TRANGROUP seg addr again
	assume	ds:TRANGROUP
	ret

DisplayWide	endp




;***	EndPage - end the current display page
;
;	ENTRY	LeftOnPage = # lines left on display page
;		Current directory (on selected drive) is the one being listed
;		Bits contains /p setting
;
;	EXIT	LeftOnPage = # lines left for next page
;
;	USED	AX,DX
;
;	EFFECTS
;
;	  Pause is invoked to display a message and wait for a keystroke.
;	  BwdBuf (same as DirBuf) used to build directory string.

EndPage	proc

	test	Bits,mask pagd
	jz	epNew			; paged display isn't enabled

	push	bx			; save BX
	push	cx			; save CX

	invoke	Pause			; "Press any key to continue..."

	invoke	Build_Dir_String
	mov	dx,offset TRANGROUP:DirCont_Ptr
	invoke	Printf_Crlf		; "(continuing <dir>)", cr/lf

	pop	cx			; restore CX
	pop	bx			; restore BX

epNew:	mov	ax,LinPerPag		; AX = # lines per page
	dec	ax			; AX = # lines till next EndPage
	mov	LeftOnPage,ax		; LeftOnPage = countdown variable

	ret

EndPage	endp




;***	GetDriveLtr - get target drive letter
;
;	ENTRY	FCB contains drive #
;
;	EXIT	AX = "d:"
;
;	USED	nothing

GetDriveLtr	proc

	mov	al,ds:Fcb	; AL = target drive #
	or	al,al
	jnz	@F		; not current drive default, skip ahead
	mov	al,ds:CurDrv	; AL = current drive #
	inc	al		; AL = 1-based drive #
@@:	add	al,'A'-1	; AL = target drive letter
	mov	ah,':'		; AX = "d:"
	ret

GetDriveLtr	endp





;***	SetupParamError - set up for Std_EPrintf parameter parse error message
;
;	Do for our /O and /A string parsers what Parse_With_Msg does
;	for system parser calls.  Set up a message substitution block,
;	etc. for invalid value strings.  I copied the procedure from
;	Setup_Parse_Error_Msg.
;
;	ENTRY	BX = ptr to system parser result buffer (contains ptr to str)
;		
;
;	EXIT	AX = system parser error return code for bad param format
;		DX = ptr to message description block for Std_EPrintf
;
;	USED	SI
;
;	EFFECTS
;
;	  Msg_Disp_Class = parse error message class
;	  Message block (see DX) is set up for parse error message

SetupParamError	proc

	mov	ax,9			; parse error #
	mov	Msg_Disp_Class,PARSE_MSG_CLASS
	mov	Extend_Buf_Ptr,ax
	mov	si,word ptr [bx].ValuePtr
	mov	String_Ptr_2,si
	mov	Extend_Buf_Sub,ONE_SUBST
	mov	dx,offset TRANGROUP:Extend_Buf_Ptr
	ret

SetupParamError	endp




;***	UseLine - use a display line, start a new page if none left
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	flags

UseLine	proc

	dec	LeftOnPage
ifndef NEC_98
	cmp	LeftOnPage,2
else    ;NEC_98
	cmp	LeftOnPage,1            ;NEC04 Canged Page Line (23 to 24)
endif   ;NEC_98
	ja	ulRet
	call	EndPage
ulRet:	ret

UseLine	endp




;***	ZeroTotals - zero grand total file count, size
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	AX
;
;	EFFECTS
;
;	  FileCntTotal & FileSizTotal are zeroed.
;
;	NOTES
;
;	  FileCntTotal & FileSizTotal must be juxtaposed, in that order.

ZeroTotals	proc

	mov	di,offset TRANGROUP:FileCntTotal
	mov	cx,size FileCntTotal+size FileSizTotal
	xor	al,al
	rep	stosb
	ret	

ZeroTotals	endp




;***	CtrlCHandler - our own control-c handler
;
;	Make sure user's default directory gets restored.  See notes
;	at InstallCtrlCHandler.
;
;	ENTRY	control-c
;
;	EXIT	to OldCtrlCHandler
;
;	USED	DS,flags
;
;	EFFECTS
;
;	  Restore user's default directory.
;
;	NOTES
;
;	  This handler is only installed after calling PathCrunch,
;	  which sets UserDir1, so the restoration will work.
;
;	  The original control-c vector will be restored, whether
;	  or not this one is invoked, in the HeadFix routine.

CtrlCHandler	proc	far

;SR;
; Save all registers used: ds, dx, ax. I know ax is being used by the 
;CtrlC handler, am not sure about ds & dx. Save them to be safe
;
	push	ds
	push	cs
	pop	ds			; DS = TRANGROUP seg addr
	push	ax
	push	dx
	invoke	RestUDir		; restore user's default directory
	pop	dx
	pop	ax
	pop	ds
	jmp	cs:OldCtrlCHandler		; go to previous int 23 handler

CtrlCHandler	endp


;M010;start
;***	LowerCase - convert ASCII character in AL to lowercase
;
;	ENTRY	AL = character to be displayed
;
;	EXIT	AL is lowercase
;
;	USED	nothing

LowerCase	proc

	assume	ds:NOTHING,es:NOTHING

	cmp	al,'A'			; ensure AL is in range 'A'-'Z'
	jb	lcRet
	cmp	al,'Z'
	ja	lcRet

	or	al,20h			; convert to ASCII lowercase (UpperCase+32)-->LowerCase

lcRet:	ret

LowerCase	endp




;***	LowercaseString - convert ASCIIZ string at DS:SI to lowercase
;
;	ENTRY	DS:SI points to start of ASCIIZ string
;		ES = DS
;
;	EXIT	nothing
;	
;	USED	AL,SI

LowercaseString	proc

	assume	ds:NOTHING,es:NOTHING

	push	di			; save di
	mov	di,si			; ES:DI --> ASCIIZ string
	cld

NextChar: 
	lodsb				; get character from string into al
	or	al,al			; are we at end of string?
	jz	EndOfString

ifdef DBCS
	invoke	testkanj
	jz	@f			; if this is not lead byte
	stosb				; store lead byte
	lodsb				; get tail byte
	or	al,al
	jz	EndOfString		; if end
	stosb				; store tail byte
	jmp	short NextChar
@@:
endif

	call	LowerCase		; convert character to lowercase
	stosb				; store character back into buffer
	jmp	SHORT NextChar		; repeat until end of string

EndOfString:
	pop	di			; restore di
	ret

LowercaseString	endp
;M010;end	

ifdef DBCS
;
;	Check if the character position is at Tail Byte of DBCS
;
;	input:	ds:si = start address of the string
;		ds:di = character position to check
;	output:	ZF = 1 if at Tail Byte
;
CheckDBCSTailByte	proc	near
	push	ax
	push	cx
	push	di
	mov	cx,di			; save character position
cdtb_check:
	cmp	di,si
	jz	cdtb_next		; if at the top
	dec	di			; go back
	mov	al,[di]			; get character
	invoke	testkanj
	jnz	cdtb_check		; if DBCS lead byte do next
	inc	di			; adjust
cdtb_next:
	sub	cx,di			; if the length is odd then
	xor	cl,1			; the character position is
	test	cl,1			; at the tail byte
	pop	di
	pop	cx
	pop	ax
	ret
CheckDBCSTailByte	endp
endif


TRANCODE ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\ifequ.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;       SCCSID = @(#)ifequ.asm  1.1 85/05/14
;       SCCSID = @(#)ifequ.asm  1.1 85/05/14
;*************************************
; COMMAND EQUs which are switch dependant

IF1
    IF IBM
        %OUT DBCS Enabled IBM  version
    ELSE
        %OUT Normal version
    ENDIF

ENDIF

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\envdata.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)envdata.asm	1.1 85/05/14
;	SCCSID = @(#)envdata.asm	1.1 85/05/14
; This file is included by command.asm and is used as the default command
; environment.

Environment Struc		      ; Default COMMAND environment

Env_PathString 	db	"path="
		db	0		; Null path
Env_Comstring	db	"comspec="
Env_Ecomspec 	db	"\command.com"      ;AC062
		db	134 dup (0)

Environment ends

ENVIRONSIZ 	equ	SIZE Environment
ENVIRONSIZ2 	equ 	SIZE Environment - Env_Ecomspec

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\cparse.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)cparse.asm 1.1 85/05/14
;	SCCSID = @(#)cparse.asm 1.1 85/05/14
	INCLUDE comsw.asm

.xlist
.xcref
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	INCLUDE comseg.asm
	INCLUDE comequ.asm
.list
.cref


TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BADCD_PTR:WORD		;AC022;
	EXTRN	BADCPMES_ptr:word	;AC000;
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	comma:byte
	EXTRN	cpyflag:byte
	EXTRN	CURDRV:BYTE
	EXTRN	ELCNT:BYTE
	EXTRN	ELPOS:BYTE
	EXTRN	EXPAND_STAR:BYTE
	EXTRN	SKPDEL:BYTE
	EXTRN	STARTEL:WORD
	EXTRN	SWITCHAR:BYTE
	EXTRN	switch_list:byte
	EXTRN	TPA:WORD
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:TRANGROUP,SS:NOTHING

	EXTRN	CERROR:NEAR

	PUBLIC	BADCDERR		;AC022;
	PUBLIC	CPARSE

SWCOUNT EQU	6			; Must agree with length of switch_list

;-----------------------------------------------------------------------;
; ENTRY:								;
;	DS:SI	Points input buffer					;
;	ES:DI	Points to the token buffer				;
;	BL	Special delimiter for this call 			;
;		    Always checked last 				;
;		    set it to space if there is no special delimiter	;
; EXIT: 								;
;	DS:SI	Points to next char in the input buffer 		;
;	ES:DI	Points to the token buffer				;
;	[STARTEL] Points to start of last element of path in token	;
;		points to a NUL for no element strings 'd:' 'd:/'       ;
;	CX	Character count 					;
;	BH	Condition Code						;
;			Bit 1H of BH set if switch character		;
;				Token buffer contains char after	;
;				switch character			;
;				BP has switch bits set (ORing only)	;
;			Bit 2H of BH set if ? or * in token		;
;				if * found element ? filled		;
;			Bit 4H of BH set if path sep in token		;
;			Bit 80H of BH set if the special delimiter	;
;			   was skipped at the start of this token	;
;		Token buffer always starts d: for non switch tokens	;
;	CARRY SET							;
;	    if CR on input						;
;		token buffer not altered				;
;									;
;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
; MODIFIES:								;
;	CX, SI, AX, BH, DX and the Carry Flag				;	;
;									;
; -----------------------------------------------------------------------;
;---------------
; Modifications to cparse:  recognition of right and left parentheses
; as integral tokens, and removal of automatic upper-case conversion code.
;
; Both modifications were installed in the course of adding a coherent
; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
; structure for command-line arguments.  This parser relies on cparse to
; recognize individual tokens.
;
; To process for-loops correctly, parentheses must therefore be
; recognized as tokens.  The upper-case conversion code was removed so
; that commands (such as for and echo) would be able to use the "original"
; text of the command line.
;
; Note also the modification to prevent the automatic conversion of colons
; into spaces WITHIN THE SOURCE TEXT!
;
; Also note that BP is also clobbered if cparse recognizes any switches
; on the command line.
;
; Alan L, OS/MSDOS				    14 August 1983
;---------------

CPARSE:
ASSUME	DS:TRANGROUP,ES:TRANGROUP

	xor	ax,ax
	mov	[STARTEL],DI			; No path element (Is DI correct?)
	mov	[ELPOS],al			; Start in 8 char prefix
	mov	[SKPDEL],al			; No skip delimiter yet
	mov	bh,al				; Init nothing
	pushf					; save flags
	push	di				; save the token buffer addrss
	xor	cx,cx				; no chars in token buffer
	mov	comma,cl			;g reset comma flag
moredelim:
	LODSB
	INVOKE	DELIM
	JNZ	SCANCDONE
	CMP	AL,' '
	JZ	moredelim
	CMP	AL,9
	JZ	moredelim
	xchg	al,[SKPDEL]
	or	al,al
	jz	moredelim			; One non space/tab delimiter allowed
	test	bh,080h 			;g  has a special char been found?
	jz	no_comma			;g  no - just exit
	mov	comma,1 			;g  set comma flag
no_comma:
	JMP	x_done				; Nul argument

SCANCDONE:

;;;;	IFNDEF	DBCS	3/3/KK
;---------------
; Mod to avoid upper-case conversion.
;	cmp	cpyflag,1		3/3/KK
;	jnz	cpcont1 		3/3/KK
;	invoke	UPCONV			3/3/KK
cpcont1:
;---------------
;;;;	ENDIF			3/3/KK

	cmp	al,bl				; Special delimiter?
	jnz	nospec
	or	bh,80H
	jmp	short moredelim

nospec:
	cmp	al,0DH				; a CR?
	jne	ncperror
	jmp	cperror

ncperror:
	cmp	al,[SWITCHAR]			; is the char the switch char?
	jne	na_switch			; yes, process...
	jmp	a_switch

na_switch:
	mov	dl,':'
	cmp	byte ptr [si],dl
	jne	anum_chard			; Drive not specified

;;;;	IFDEF	DBCS		3/3/KK
;---------------
; Mod to avoid upper-case conversion.
	cmp	cpyflag,1
	jnz	cpcont2
	invoke	UPCONV
cpcont2:
;---------------
;;;;	ENDIF			3/3/KK

	call	move_char
	lodsb					; Get the ':'
	call	move_char
	mov	[STARTEL],di
	mov	[ELCNT],0
	jmp	anum_test

anum_chard:
	mov	[STARTEL],di
	mov	[ELCNT],0			; Store of this char sets it to one
	cmp	cpyflag,1			; Was CPARSE called from COPY?
	jnz	anum_char			; No, don't add drive spec.
	invoke	PATHCHRCMP			; Starts with a pathchar?
	jnz	anum_char			; no
	push	ax
	mov	al,[CURDRV]			; Insert drive spec
	add	al,capital_A
	call	move_char
	mov	al,':'
	call	move_char
	pop	ax
	mov	[STARTEL],di
	mov	[ELCNT],0

anum_char:

;;;;	IFDEF	DBCS		3/3/KK
	invoke	TESTKANJ
	jz	NOTKANJ 			;AC048;
ifdef NEC_98 
if BUGFIX

	cmp	byte ptr [si],' '
	jb	NOTKANJ
endif
endif   ;NEC_98
	call	move_char
	lodsb
	jmp	short notspecial

NOTKANJ:					;AN048; If not kanji
	cmp	cpyflag,1			;AN048; and if we're in COPY
	jnz	testdot 			;AN048;
	invoke	upconv				;AN048; upper case the char

TESTDOT:
;;;;	ENDIF			3/3/KK

	cmp	al,dot_chr
	jnz	testquest
	inc	[ELPOS] 			; flag in extension
	mov	[ELCNT],0FFH			; Store of the '.' resets it to 0

testquest:
	cmp	al,'?'
	jnz	testsplat
	or	bh,2

testsplat:
	cmp	al,star
	jnz	testpath
	or	bh,2
	cmp	byte ptr [expand_star],0
	jnz	expand_filename
	jmp	SHORT testpath

badperr2j:
	jmp	short badperr2

expand_filename:
	mov	ah,7
	cmp	[ELPOS],0
	jz	gotelcnt
	mov	ah,2

gotelcnt:
	mov	al,'?'
	sub	ah,[ELCNT]
	jc	badperr2j
	xchg	ah,cl
	jcxz	testpathx

qmove:
	xchg	ah,cl
	call	move_char
	xchg	ah,cl
	loop	qmove

testpathx:
	xchg	ah,cl

testpath:
	invoke	PATHCHRCMP
	jnz	notspecial
	or	bh,4
	cmp	byte ptr [expand_star],0
	jz	no_err_check
	test	bh,2				; If just hit a '/', cannot have ? or * yet
	jnz	badperr

no_err_check:
	mov	[STARTEL],di			; New element
	INC	[STARTEL]			; Point to char after /
	mov	[ELCNT],0FFH			; Store of '/' sets it to 0
	mov	[ELPOS],0

notspecial:
	call	move_char			; just an alphanum string
anum_test:

	lodsb

;;;;	IFNDEF	DBCS		3/3/KK
;---------------
; Mod to avoid upper-case conversion.
;	cmp	cpyflag,1		3/3/KK
;	jnz	cpcont3 		3/3/KK
;	invoke	UPCONV			3/3/KK
cpcont3:
;---------------
;;;;	ENDIF				3/3/KK

	INVOKE	DELIM
	je	x_done

	cmp	al,0DH
	je	x_done
	cmp	al,[SWITCHAR]
	je	x_done
	cmp	al,bl
	je	x_done
	cmp	al,':'                          ; ':' allowed as trailer because
						; of devices
;;;;	IFDEF	DBCS		3/3/KK
	je	FOO15
	jmp	anum_char
FOO15:
;;;	ELSE			3/3/KK
;;;	jne	anum_charj	3/3/KK
;;;	ENDIF			3/3/KK

;---------------
; Modification made for parseline.
; Why would it be necessary to change colons to spaces?  In this
; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
; but so does 'echo foo:bar' yield 'echo foo bar'.
;---------------
	cmp	cpyflag,2			; Is CPARSE parsing the 1st token from
						;  from PARSELINE?
	jnz	cpcont4 			; No, continue
	call	move_char			; Yes, save the ':' and go get another
	jmp	anum_test			;  character.

cpcont4:
	inc	si				;Skip the ':'
	jmp	short x_done

anum_charj:
	jmp	anum_char

badperr2:
	mov	dx,offset trangroup:BADCPMES_ptr
	jmp	CERROR

badperr:
BADCDERR:					;AC022; Issue "Invalid Directory"
	MOV	DX,OFFSET TRANGROUP:BADCD_ptr	;AC022;     message
	JMP	CERROR				;AC022;

cperror:
	dec	si				; adjust the pointer
	pop	di				; retrive token buffer address
	popf					; restore flags
	stc					; set the carry bit
	return

x_done:
	dec	si				; adjust for next round
;---------------
; Mod to recognize right and left parens as integral tokens.
x_done2:
;---------------
	jmp	short out_token

a_switch:
	OR	BH,1				; Indicate switch
	OR	BP,fSwitch
	INVOKE	SCANOFF
	INC	SI
	invoke	testkanj			;AN057; See if DBCS lead byte
	jz	a_switch_notkanj		;AN057; no - continue processing
ifdef NEC_98
if BUGFIX
	cmp	byte ptr [si],' '
	jb	a_switch_notkanj		;AN057; no - continue processing
endif
endif   ;NEC_98
	call	move_char			;AN057; DBCS - store first byte
	lodsb					;AN057; get second byte
	call	move_char			;AN057; store second byte
	or	bp,fBadSwitch			;AN057; DBCS switch is invalid
	jmp	short out_token 		;AN057; don't bother checking switch
a_switch_notkanj:				;AN057;
	cmp	al,0DH
	jne	Store_swt
	mov	al,0
	stosb					; null at the end
	OR	BP,fBadSwitch
	jmp	cperror 			; Trailing switch character error
						;   BP = fSwitch but no switch
						;   bit is set (unknown switch)
Store_swt:
	call	move_char			; store the character
;
;---------------
; This upconv call must stay.  It is used to identify copy-switches
; on the command line, and won't store anything into the output buffer.
	invoke	UPCONV
;---------------
;
	PUSH	ES
	PUSH	DI
	PUSH	CX
	PUSH	CS
	POP	ES
ASSUME	ES:TRANGROUP
	MOV	DI,OFFSET TRANGROUP:switch_list
	MOV	CX,SWCOUNT
	OR	BP,fBadSwitch
	REPNE	SCASB
	JNZ	out_tokenp
	AND	BP,NOT fBadSwitch
	MOV	AX,1
	SHL	AX,CL
	OR	BP,AX

out_tokenp:
	POP	CX
	POP	DI
	POP	ES

ASSUME	ES:NOTHING
out_token:
	mov	al,0
	stosb				; null at the end
	pop	di			; restore token buffer pointer
	popf
	clc				; clear carry flag
	return

move_char:
	stosb				; store char in token buffer
	inc	cx			; increment char count
	inc	[ELCNT] 		; increment element count for * substi
	return

TRANCODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\iparse.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)iparse.asm 4.1 87/04/28
;	SCCSID = @(#)iparse.asm 4.1 87/04/28
TITLE	COMMAND interface to SYSPARSE

.xlist
.xcref
	INCLUDE comseg.asm		;AN000;
.list
.cref


INIT		SEGMENT PUBLIC PARA	;AN000;

ASSUME	CS:RESGROUP,DS:RESGROUP,ES:NOTHING,SS:NOTHING	;AN000;


;AD054; public	SYSPARSE		;AN000;

	DateSW	equ	0		;AN000; do not Check date format
	TimeSW	equ	0		;AN000; do not Check time format
	CmpxSW	equ	0		;AN000; do not check complex list
	KeySW	equ	0		;AN025; do not support keywords
	Val2SW	equ	0		;AN025; do not Support value definition 2
	Val3SW	equ	0		;AN000; do not Support value definition 3
	QusSW	equ	0		;AN025; do not include quoted string
	DrvSW	equ	0		;AN025; do not include drive only

.xlist
.xcref
;AD054; INCLUDE parse.asm		;AN000;
.list
.cref


INIT	    ends			;AN000;
	    end 			;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\fordata.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)fordata.asm	1.1 85/05/14
;	SCCSID = @(#)fordata.asm	1.1 85/05/14
; Data structure definitions included by tfor.asm

for_info        STRUC
    for_args        DB          (SIZE arg_unit) DUP (?) ; argv[] structure
    FOR_COM_START   DB          (?)                     ; beginning of <command>
    FOR_EXPAND      DW          (?)                     ; * or ? item in <list>?
    FOR_MINARG      DW          (?)                     ; beginning of <list>
    FOR_MAXARG      DW          (?)                     ; end of <list>
    forbuf          DW          64 DUP (?)              ; temporary buffer
    fordma          DW          64 DUP (?)              ; FindFirst/Next buffer
    FOR_VAR         DB          (?)                     ; loop control variable
for_info        ENDS

; empty segment done for bogus addressing
for_segment     segment
f       LABEL   BYTE
for_segment     ends

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\init.asm ===
page ,132
    title   COMMAND Initialization
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;   Revision History
;   ================
;   M002    SR  07/15/90    Resize right at the start because
;               Carousel depends on it.
;
;   M004    SR  07/17/90    Initialization reworked so that
;               transient is now moved at EndInit.
;               The old approach assumed that the
;               biggest block is the one currently
;               loaded in, an assumption not true
;               for UMBs.
;
;   M005    SR  07/20/90    Numerous hacks for Carousel
;               1. Set CurrentPDB to ours at start
;               2. Normalize cs:ip of int 2fh hook
;               so that cs is different.
;
;   M013    SR  08/06/90    Fixed Setup_res_end & Move_res_code
;               to use new GetVersion call that
;               returns info about whether DOS is in
;               HMA or not.
;
;   M015    SR  08/09/90    Increased default environment size to
;               256 bytes from 160 bytes
;
;   M026    SR  9/12/90 Fixed environment trashing on second
;               Command if new comspec is given.
;
;   M030    SR  10/3/90 Before calling int 2fh 4a02h, set di
;               to 0ffffh so that we are ok if no one
;               answers this int 2fh.
;
;   M042    SR  12/13/90    Bug #4660. Changed setup_res_end to
;               take care of the dummy segment that
;               adds a para to the resident size.
;

.xlist
.xcref
    include comsw.asm
    include dossym.inc
    include pdb.inc
    include mult.inc
    include syscall.inc
    include doscntry.inc
    include comseg.asm
    include comequ.asm
    include resmsg.equ

    include envdata.asm
    include xmm.inc
    include cmdsvc.inc
    include dossvc.inc
.list
.cref



ENVBIG          equ 32768
ENVSML          equ 256     ;Increased to 256 ; M015
KOREA_COUNTRY_CODE  equ 82


CODERES segment public byte

    extrn   ContC       :near
    extrn   DskErr      :near
    extrn   Int_2e      :near
    extrn   LodCom      :near
    extrn   MsgInt2fHandler :far
    extrn   SetVect :near
    extrn   ChkSum      :near
    extrn   CrLf        :near
    extrn   LoadCom :near
    extrn   RPrint      :near
ifdef BILINGUAL
    extrn   RPrint@     :near
endif ; BILINGUAL

    extrn   EndCode :byte
    extrn   StartCode   :byte

    ifdef   DBCS
    extrn   ItestKanj   :near
    endif

    extrn   BadMemErr   :near

CODERES ends

DATARES segment public byte

    extrn   Abort_Char  :byte
    extrn   AccDen      :byte
    extrn   Append_State    :word
    extrn   Batch       :word
    extrn   Com_Fcb1    :dword
    extrn   Com_Fcb2    :dword
    extrn   Com_Ptr :dword
    extrn   ComDrv      :byte
    extrn   ComSpec :byte
    extrn   ComSpec_End :word
    extrn   Crit_Msg_Off    :word
    extrn   Crit_Msg_Seg    :word
    extrn   DataResEnd  :byte
    extrn   Dbcs_Vector_Addr    :word
    extrn   EchoFlag    :byte
    extrn   EnvirSeg    :word
    extrn   ExtMsgEnd   :byte
    extrn   fFail       :byte
    extrn   FUCase_addr :word
    extrn   InitFlag    :byte
    extrn   Int2fHandler    :dword
    extrn   Io_Save :word
    extrn   Io_Stderr   :byte
    extrn   LTpa        :word
    extrn   MemSiz      :word
    extrn   MySeg       :word
    extrn   MySeg1      :word
    extrn   MySeg2      :word
    extrn   MySeg3      :word
    extrn   Nest        :word
    extrn   OldTerm :dword
    extrn   Parent      :word
    extrn   ParseMes_Ptr    :word
    extrn   ParsMsgPtrs :word
    extrn   PermCom :byte
    extrn   PutBackDrv  :byte
    extrn   PutBackComSpec  :byte
    extrn   RDirChar    :byte
    extrn   Res_Tpa :word
    extrn   ResMsgEnd   :word
    extrn   RSwitChar   :byte
    extrn   SingleCom   :word
    extrn   KSwitchFlag :byte
    extrn   Sum     :word
    extrn   TrnSeg      :word
    extrn   TrnMvFlg    :byte

    extrn   ResSize :word
    extrn   RStack      :word

    extrn   ComInHMA    :byte   ;flag set if in HMA
    extrn   XMMCallAddr :dword  ;far call address to XMM
        EXTRN   SCS_CMDPROMPT   :BYTE
        EXTRN   SCS_DOSONLY     :BYTE

;
;All far pointers to resident routines that are to be patched
;
    extrn   Int2f_Entry :dword
    extrn   Int2e_Entry :dword
    extrn   Ctrlc_Entry :dword
    extrn   CritErr_Entry   :dword

    extrn   Int2f_Trap  :near
    extrn   Int2e_Trap  :near
    extrn   Ctrlc_Trap  :near
    extrn   CritErr_Trap    :near
    extrn   LodCom_Trap :near

    EXTRN   SCS_PAUSE:BYTE      ; yst

    extrn   EndInit :near

    extrn   Carousel_i2f_Hook   :byte   ; M005

    extrn   SCS_REENTERED   :byte
    extrn   SCS_FIRSTCOM    :byte

ifdef   BETA3WARN
    %out    Take this out before we ship
    extrn   Beta3Warned:byte
endif


DATARES ends


;;ENVIRONMENT   segment public para     ; default COMMAND environment
;;
;;  extrn   EComSpec    :byte
;;  extrn   EnvirEnd    :byte
;;  extrn   PathString  :byte
;;
;;ENVIRONMENT   ends


TAIL    segment public para

    extrn   TranStart   :word

TAIL    ends


TRANCODE    segment public byte

    extrn   DatInit :far

TRANCODE    ends

TRANDATA    segment

    extrn   TranDataEnd :byte

TRANDATA    ends

TRANSPACE   segment public byte

    extrn   TranSpaceEnd    :byte

TRANSPACE   ends




; *******************************************************************
; START OF INIT PORTION
; This code is deallocated after initialization.

INIT    SEGMENT PUBLIC PARA

;NTVDM not used        extrn   AutoBat :byte
    extrn   BadComAccMsg    :byte
    extrn   BadComLkMsg :byte
    extrn   Badcspfl    :byte
    extrn   BadVerMsg   :byte

    extrn   Chuckenv    :byte
    extrn   Command_?_syn   :byte
    extrn   Command_c_syn   :byte
    extrn   Command_d_syn   :byte
    extrn   Command_e_syn   :byte
    extrn   Command_f_syn   :byte
    extrn   Command_k_syn   :byte
    extrn   Command_l_syn   :byte
    extrn   Command_l2_syn   :byte
    extrn   Command_m_syn   :byte
    extrn   Command_u_syn   :byte
    extrn   Command_p_syn   :byte
    extrn   Command_y_syn   :byte
    extrn   Command_z_syn   :byte
    extrn   Comnd1_syn  :word
    extrn   Comnd1_addr :dword
    extrn   ComSpect    :byte
    extrn   ComspString :byte
    extrn   CopyrightMsg    :byte
    extrn   Dswitch :byte
;;  extrn   Ecomloc :word
    extrn   EnvMax      :word
    extrn   EnvSiz      :word
    extrn   EqualSign   :byte
    extrn   Eswitch :byte
    extrn   Ext_msg :byte
    extrn   HelpMsgs:word
    extrn   InitAdd :dword
    extrn   InitEnd :word
    extrn   Init_Parse  :dword
    extrn   Internat_Info   :byte
; NTVDM not used extrn   KautoBat        :byte
    extrn   Lcasea      :byte
    extrn   Lcasez      :byte
    extrn   Num_positionals :word
    extrn   OldEnv      :word
    extrn   Old_parse_ptr   :word
    extrn   OutEnvMsg   :byte
    extrn   Parse_command   :byte
    extrn   PrdAttm :byte
    extrn   ResetEnv    :word
    extrn   Scswitch    :byte
    extrn   Skswitch    :byte
    extrn   Space       :byte
    extrn   Triage_Add  :dword
    extrn   TrnSize :word
    extrn   Ucasea      :byte
    extrn   UsedEnv :word

    extrn   PathString  :byte
    extrn   ComspString :byte
    extrn   Reloc_Table :word
    extrn   FirstCom    :byte
    extrn   ResJmpTable :dword

    extrn   TriageError :near

    extrn   NUM_RELOC_ENTRIES   :abs

    extrn   DevFlag :byte
        extrn   PathFlag        :byte

        PUBLIC  ConProc
    PUBLIC  Init_ContC_SpecialCase

    assume  cs:ResGroup,ds:ResGroup,es:ResGroup,ss:ResGroup

    org 0
ZERO    =   $


ConProc:
    mov sp,offset ResGroup:RStack   ; must be first instruction
;
; M005; We need to set the PSP to us right at start because Carousel needs
; M005; to be lied to and it does not set PSP when it transfers control to
; M005; us after loading us as an overlay. By setting PSP, we ensure that
; M005; command.com is also not lied to.
;
    mov ah,SET_CURRENT_PDB      ; M005
    mov bx,es           ; M005
    int 21h         ; M005

    mov ah,GET_VERSION
    int 21h
    cmp ax,EXPECTED_VERSION
    je  OkDos               ; DOS version is ok

    mov dx,offset ResGroup:BadVerMsg    ; DX = ptr to msg
    call    RPrint
    mov ax,es
    cmp es:PDB_Parent_Pid,ax        ; if COMMAND is own parent,
Here:   jnz GoExit              ;  loop forever
    SVC SVC_DEMEXITVDM

GoExit:
    int 20h             ; otherwise, exit
okdos:

;
;  Calculate and save the end of the INIT segment (which is also
;  the beginning of TRANGROUP).
;
    mov dx,offset resgroup:TranStart+15 ;eg  get end of init code
    mov cl,4                ;eg change to paragraphs
    shr dx,cl               ;eg
    mov ax,cs               ;eg get current segment
    add ax,dx               ;eg calculate segment of end of init
        mov     InitEnd,ax                      ;eg save this

        SAVE    <SI,BP>
        xor     si,si
        xor     bp,bp
        mov     al,5                            ; query cmdprompt
        mov     ah,setdpb
        int     21h
        mov     byte ptr [scs_cmdprompt],al     ; ds is resseg
        mov     al,7                            ; query DOSONLY bit
        mov     ah,setdpb
        int     21h
        mov     byte ptr [scs_dosonly],al       ; ds is resseg
        RESTORE <BP,SI>

;
;  Check for /? on the command line.  If found, display help text
;  and exit.
;
;  NOTE:  this routine may terminate the program, never returning.
;
    call    CheckHelp

    call    CheckZSwitch

;SR;
; We have to patch the segment values for the various interrupt entry points.
;This is because we need to have the default addresses of the handlers in our
;stub before the relocation is done. These values will then be changed once
;the resident is relocated
;
    call    patch_segs

;
;  Turn APPEND off during initialization processing
;
    mov ax,APPENDINSTALL            ; see if append installed
    int 2fh             ;
    cmp al,0                ; append installed?
    je  set_msg_addr            ; no - continue
    mov ax,APPENDDOS            ; see if append DOS version right
    int 2fh             ;
    cmp ax,-1               ; append version correct?
    jne set_msg_addr            ; no - continue
    mov ax,APPENDGETSTATE           ; Get the state of Append
    int 2fh             ;
    mov Append_State,bx             ; save append state
    xor bx,bx               ; clear out state
    mov ax,APPENDSETSTATE           ; Set the state of Append
    int 2fh             ; set everything off

set_msg_addr:
    mov di,offset resgroup:DataresEnd   ; get address of resident end
    mov ResMsgEnd,di            ; save it


    call    get_XMMAddr         ;get XMM call address
;
;Check if this is the first instance of command.com. If not, we just exit
;this routine without moving any code.
;After the int 2fh, ds:si points at the resident jump table in the previous
;stub. We just have to copy this over
;

    mov ax,GET_COMMAND_STATE
    int 2fh
    assume  ds:nothing

    or  ax,ax
    jnz first_com           ;this is the first instance

ifdef   BETA3WARN
    %out    Take this out before we ship
    mov es:Beta3Warned, 0ffh
endif

    mov word ptr es:ResJmpTable,si      ;save old stub jump table
    mov word ptr es:ResJmpTable+2,ds
    jmp short init_cntry

first_com:
        mov     es:FirstCom,1                   ;indicate first command.com
    mov SCS_FIRSTCOM,1

init_cntry:
    push    es
    pop ds
    assume  ds:RESGROUP


    mov ah,GETEXTCNTRY          ; get extended country info
    mov al,4                ; get file ucase table
    mov dx,-1               ;
    mov bx,-1               ;
    mov cx,5                ; number of bytes we want
    mov di,offset resgroup:Fucase_addr  ; buffer for address
    int 21h             ;

;   Bugbug: conditionalize dbcs_vector stuff?
    push    ds              ;
    mov ax, (ECS_CALL shl 8) or GETLEADBTBL ;
    int 21h             ;
    mov bx,ds               ; get segment to bx
    pop ds              ;
    mov Dbcs_vector_addr,si         ; save address of
    mov Dbcs_vector_addr+2,bx           ; dbcs vector


    mov ax,word ptr ds:PDB_Parent_Pid   ; Init PARENT so we can exit
    mov Parent,ax           ;  correctly.
    mov ax,word ptr ds:Pdb_Exit
    mov word ptr OldTerm,ax
    mov ax,word ptr ds:Pdb_Exit+2
    mov word ptr Oldterm+2,ax


    mov ax,offset ResGroup:EndCode + 15
    mov cl,4                ; ax = size of resident part of
    shr ax,cl               ;  command in paragraphs.  Add
    mov cx,cs               ;  this to CS and you get the
    add ax,cx               ;  segment of the TPA.

    mov Res_tpa, ax         ; Temporarily save the TPA segment
    and ax, 0f000h
    add ax, 01000h          ; Round up to next 64K boundary
    jnc TpaSet              ; Memory wrap if carry set
    mov ax, Res_tpa
TpaSet:
    mov Ltpa,ax         ; Good enough for the moment
    mov ax,word ptr ds:PDB_Block_Len    ; ax = # of paras given to command

    mov Myseg1,ds           ; These 3 variables are used as part of
    mov Myseg2,ds           ;  3 long ptrs that the transient will
    mov Myseg,ds            ;  use to call resident routines.
    mov Myseg3,ds           ; segment of msg retriever routine
    mov Memsiz,ax           ; Needed for execing other programs

; M002;
; M002; First reallocate the COMMAND size to its memory image
; M002;
    push    ax              ; M002
    mov bx,offset RESGROUP:TranStart    ; M002
    add bx,offset TRANGROUP:TranSpaceEnd; M002
    add bx,15               ; M002; round up the size

    mov cl,4                ; M002
    shr bx,cl               ;size of command.com ; M002

    mov ah,SETBLOCK         ;free all memory above pgm ; M002
    int 21h             ; M002
    pop ax              ; M002


;
; Compute maximum size of environment
;
    mov EnvMax,(Environsiz + 15) / 16 + (EnvMaximum-zero + 15)/16 - 1
;
; Compute minimum size of environment
;

    mov EnvSiz, ENVSML / 16

    mov dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
    mov cl,4                ;  in paragraphs.
    shr dx,cl
    mov Trnsize,dx          ;eg save size of transient in paragraphs

    sub ax,dx               ; max seg addr - # para's needed for transient
    mov Trnseg,ax           ;  = seg addr to load the transient at.
    mov ax,ds:PDB_Environ           ; ax = environment segment
    or  ax,ax               ; if there is no environment segment,
    jz  buildenv            ;  go compute one.
    inc byte ptr Chuckenv           ; flag no new environseg to set up
    jmp short environpassed         ; otherwise one was passed to us.

buildenv:   ; (this label isn't very accurate)
;
;We allocate a buffer here just large enough to hold the 'PATH=' and
;the COMSPEC. After parsing, we will allocate an environment of the right
;size and free this buffer. We need this buffer because we no longer have an
;ENVIRONMENT segment but need a place to store the COMSPEC which can be
;given on the command line before we know the environment size. This routine
;will not return in case of an allocation error. It will either exit or hang
;depending on whether or not this is the first COMMAND.COM or not.
;

    call    alloc_env           ;try to allocate buffer

;;  mov ax,offset ResGroup:PathString   ; compute the segment of the
;;  mov cl,4                ;  environment and put it in
;;  shr ax,cl               ;  ax.
;;  mov dx,ds
;;  add ax,dx

environpassed:
    mov Envirseg,ax         ; save the environment's segment and
    mov es,ax               ;  load into es.
    assume  es:nothing

gottheenvir:
;
; initialize the command drive
;
    mov ah,GET_DEFAULT_DRIVE
    int 21h
    inc al
    mov Comdrv,al

    mov al,byte ptr ds:Fcb          ; al = default drive number for command
    or  al,al
    jz  nocomdrv            ; no drive specified

    mov ah,':'
    mov Comdrv,al
    add al,40h              ; convert number to uppercase character

    std
    cmp byte ptr Chuckenv,0         ; if a new environment is being built,
    jnz notwidenv           ;  move the default comspec string in it
    push    ds              ;  2 bytes to make room for a drivespec.
    push    es              ;  the drivespec is in ax and is copied
    pop ds              ;  on to the front of the string.
    mov di,Env_Ecomspec + ENVIRONSIZ2 - 1 ;eg
    mov si,Env_Ecomspec + ENVIRONSIZ2 - 3 ;eg

    mov cx,ENVIRONSIZ2 - 2
    rep movsb
    pop ds
    mov word ptr es:Env_Ecomspec,ax

notwidenv:
        cld                                     ; add the drivespec to the string
; NTVDM not used
;        mov     word ptr AutoBat,ax                     ; used to reference autoexec.bat
;        mov     word ptr KautoBat,ax                    ; used to reference kautoexe.bat 3/3/kk

nocomdrv:
    call    setvect             ; set interrupt vectors 22h, 23h, & 24h

;*********************************
; parsing starts here
;*********************************

    push    cs              ; get local segment
    push    cs              ; into ds,es
    pop ds              ;
    pop es              ;

assume  ds:ResGroup,es:ResGroup             ;

    mov si,80h              ; get command line
    lodsb                   ; get length of line
    mov di,si               ; get line position in di
    xor ah,ah               ; ax = length of command line
;
; insure that the command line correctly ends with a cr
;
    add di,ax               ; go to end of command line
    mov byte ptr [di],0dh           ; insert a carriage return
    xor cx,cx               ; clear cx
    mov Num_positionals,cx          ; initialize positionals
;
; Scan the command line looking for the parameters
;

Parse_command_line:
    mov di,offset ResGroup:Parse_Command ; Get address of parse_command
    mov cx,Num_positionals          ; Get number of positionals
    xor dx,dx               ; clear dx
    mov Old_parse_ptr,si            ; save position before calling parser
    call    init_parse          ; call parser
    mov Num_positionals,cx          ; Save number of positionals
    cmp ax,END_OF_LINE          ; are we at end of line?
    jnz SkipArgdsDoneJmp
    jmp  ArgsDoneJ3          ; yes - exit

SkipArgdsDoneJmp:
    cmp ax,RESULT_NO_ERROR          ; did an error occur
    jz  parse_cont          ; no - continue

;
; Before issuing error message - make sure switch is not /C or /K
;

parse_line_error:
    push    si              ; save line position
    push    ax              ; save error number
    cmp ax,BADSWT_PTR           ; Was error invalid switch?
    jnz parse_line_error_disp           ; No - just issue message
    mov di,si               ; Get terminating pointer in DI
    mov si,Old_parse_ptr            ; Get starting pointer in SI

init_chk_delim:
    cmp si,di               ; at end of parsed parameter?
    jz  parse_line_error_disp           ; Yes - just display message
    lodsb                   ;
    cmp al,Space            ; Skip blank spaces
    jz  init_chk_delim          ;
    cmp al,TAB_CHR          ; Skip tab characters
    jz  init_chk_delim          ;

    cmp al,Rswitchar            ; Switch?
    jnz parse_line_error_disp           ; No - just issue message
    lodsb                   ; Get the char after the switch

    ifdef   DBCS
    call    ItestKanj           ; Is it DBCS?
    jnz parse_line_error_disp           ; Yes - can't be /C or /K
    endif

    call    iupconv             ; upper case it
    cmp al,Scswitch         ; it is /C?
    jz  AltSetCSwitch
    cmp al,Skswitch         ; it is /K?
    jz  AltSetKSwitch
    jmp parse_line_error_disp           ;
AltSetCSwitch:
    pop dx              ; even up stack
    pop dx              ; even up stack
    jmp setSSwitch          ; Yes - go set COMMAND /C

AltSetKSwitch:
    pop dx              ; even up stack
    pop dx              ; even up stack
    jmp setKSwitch          ; Yes - go set COMMAND /K

parse_line_error_disp:

    pop ax              ; restore error number
    pop si              ; restore line position
    mov dx,ax               ; get message number
    call    RPrintParse
    call    CrLf
    jmp short Parse_command_line        ; continue parsing

parse_cont:
;
; See if a switch was entered
;
; Bugbug: See if Comnd1_Syn can be moved into a reg. before the compare

;
; Several stub switches have been added below in order to provide improved
; compatibility with applications using unsupported switches in command.com
; The stubs generally do not do anything, but, they keep command.com
; from erroring out. In many cases, this is enough to keep the app working.
;
;  STUB SWITCHES
;  /LOW             Force command.com to keep resident data in LOW memory.
;   (does nothing)
;  /Y               Step through batch file specified by /c or /k
;   (does nothing)
;  /L:nnnn          internal buffers size
;   (does nothing)
;  /U:nnn           input buffers size
;   (does nothing)
;  /K command       run batch file specified by command and continue
;    turns on /P switch if not already specified.
;

    cmp Comnd1_Syn,offset ResGroup:Command_f_syn ; was /F entered?
    jnz NoFSwitch
    jmp  SetFSwitch               ; yes go set fail switch

NoFSwitch:
    cmp Comnd1_Syn,offset resgroup:Command_p_syn ; was /P entered?
    jnz NoPSwitch
    jmp  SetPSwitch               ; yes go set up PERMCOM

NoPSwitch:
    cmp Comnd1_Syn,offset resgroup:Command_d_syn ; was /D entered?
    jnz NoDSwitch
    jmp  SetDSwitch               ; yes go set date switch

NoDSwitch:
    cmp Comnd1_Syn,offset resgroup:Command_c_syn ; was /C entered?
    jnz NoSSwitch
    jmp  SetSSwitch               ; yes go set up SINGLECOM

NoSSwitch:
    cmp Comnd1_Syn,offset resgroup:Command_k_syn ; was /K entered?
    jnz NoKSwitch
    jmp  SetKSwitch               ; yes go set up environment

NoKSwitch:

    cmp Comnd1_Syn,offset resgroup:Command_y_syn ; was /Y entered?
    jnz NoYSwitch
    jmp  SetYSwitch               ; yes go set up environment

NoYSwitch:

    cmp Comnd1_Syn,offset resgroup:Command_e_syn ; was /E entered?
    jnz NoESwitch
    jmp  SetESwitch               ; yes go set up environment

NoESwitch:

    cmp Comnd1_Syn,offset resgroup:Command_l_syn ; was /LOW entered?
    jnz NoLSwitch
    jmp  SetLSwitch                ; yes go set up message flag

NoLSwitch:


    cmp Comnd1_Syn,offset resgroup:Command_l2_syn ; was /L entered?
    jnz NoL2Switch
    jmp  SetL2Switch               ; yes go set up environment

NoL2Switch:

    cmp Comnd1_Syn,offset resgroup:Command_m_syn ; was /MSG entered?
    jnz NoMSwitch
    jmp  SetMSwitch                ; yes go set up message flag

NoMSwitch:
    cmp Comnd1_Syn,offset resgroup:Command_u_syn ; was /U entered?
    jnz NoUSwitch
    jmp  SetUSwitch                ; yes go set up message flag

NoUSwitch:


    jmp ChkOtherArgs                 ; Must be something else

ArgsdoneJ3:                 ; long jump needed
    jmp ArgsDone            ;

SetFSwitch:
    cmp fFail,-1            ; has fail switch been set?
    jnz failok              ; no - set it
    mov ax,Moreargs_ptr             ; set up too many arguments
    jmp parse_line_error            ; go issue error message

failok:
    mov fFail,-1            ; fail all INT 24s.
    jmp Parse_command_line          ;

SetPSwitch:
;
; We have a permanent COMMAND switch /P.  Flag this and stash the
; termination address.
;
    cmp PermCom,0           ; has /p switch been set?
    jz  permcomok           ; no - set it
    mov ax,moreargs_ptr             ; set up too many arguments
    jmp parse_line_error            ; go issue error message

permcomok:
    inc PermCom
    mov word ptr OldTerm,offset DATARES:LodCom_Trap
    mov word ptr OldTerm+2,ds
;
; make sure that we display the date and time.  if the flag was not
; initialized, set it to indicate yes, do prompt.
;

    cmp Comnd1_Syn,offset resgroup:Command_k_syn
    jnz RealPSwitch
    jmp ArgsDone
RealPSwitch:
    cmp byte ptr PrdAttm,-1
    jnz Parse_command_line_jmp      ; keep parsing
    mov byte ptr PrdAttm,0          ; if not set explicit, set to prompt

Parse_command_line_jmp:             ;
    jmp parse_command_line          ; keep parsing

ArgsDoneJump:
    jmp ArgsDone

SetDSwitch:
;
; Flag no date/time prompting.
;
    cmp Dswitch,0           ; has /D switch been set?
    jz  setdateok           ; no - set it
    mov ax,Moreargs_ptr             ; set up too many arguments
    jmp parse_line_error            ; go issue error message

setdateok:
    inc Dswitch             ; indicate /D entered
    mov byte ptr PrdAttm,1          ; user explicitly says no date time
    jmp Parse_command_line          ; continue parsing

SetYSwitch:
;
; Y switch is ignored. Present to keep apps that actually use it in a
; static create process or something from having problems
; (important after a win9xupg.)
;
    jmp Parse_command_line          ; continue parsing


SetKSwitch:
;
; Treat this just like /C, just keep going
;
    mov KSwitchFlag,1
    jmp SetSSwitch

;
; Look for environment-size setting switch
;
; The environment size is represented in decimal bytes and is
; converted into pargraphs (rounded up to the next paragraph).
;

SetSSwitch:
;
; Set up pointer to command line, flag no date/time and turn off singlecom.
;
    mov SingleCom,si            ; point to the rest of the command line
    mov Permcom,0           ; a singlecom must not be a permcom
    mov byte ptr PrdAttm,1          ; no date or time either, explicit
    jmp ArgsDone
;
; Look for environment-size setting switch
;
; The environment size is represented in decimal bytes and is
; converted into pargraphs (rounded up to the next paragraph).
;

SetESwitch:
    cmp Eswitch,0           ; has fail switch been set?
    jz  eswitchok           ; no - set it
    mov ax,Moreargs_ptr             ; set up too many arguments
    jmp Parse_line_error            ; go issue error message

eswitchok:
    inc Eswitch             ; indicate /E entered
    mov di,offset ResGroup:Comnd1_Addr  ; get number returned
    mov bx,word ptr [di]            ; into bx

    add bx, 0fh             ; Round up to next paragraph
    mov cl,4                ; convert to pargraphs
    shr bx, cl              ; by right 4

    mov EnvSiz,BX           ; EnvSiz is in paragraphs
    jmp Parse_command_line          ; continue parsing command line

SetL2Switch:
    Jmp Parse_Command_Line

SetMSwitch:
    cmp Ext_msg,SET_EXTENDED_MSG        ; has /MSG switch been set?
    jnz setMswitchok            ; no - set it
    mov ax,Moreargs_ptr             ; set up too many arguments
    jmp Parse_line_error            ; go issue error message
setMswitchok:
    mov Ext_msg,SET_EXTENDED_MSG        ; set /MSG switch
    jmp Parse_command_line          ; keep parsing

SetLSwitch:
    jmp Parse_Command_Line

SetUSwitch:
    Jmp Parse_Command_Line


ArgsDoneJ:
    jmp  ArgsDone

;
; We have a non-switch character here.
;
ChkOtherArgs:
    push    ds              ;
    push    si              ; save place in command line
    lds si,Comnd1_Addr          ; get address of filespec
    assume  ds:nothing          ;

    mov dx,si               ; put in dx also
    mov ax,(OPEN shl 8) or 2            ; Read and write
    int 21h
    jc  ChkSrchSpec         ; Wasn't a file
    mov bx,ax
    mov ax,IOCTL shl 8
    int 21h
    test    dl,80h
    jnz IsaDevice

BadSetCon:                  ;
    mov ah,CLOSE            ; Close initial handle, wasn't a device
    int 21h
    jmp short ChkSrchSpec

IsaDevice:
    xor dh,dh
    or  dl,3                ; Make sure has CON attributes
    mov ax,(IOCTL shl 8) or 1
    int 21h
    jc  BadSetCon           ; Can't set attributes - quit
    mov dx,bx               ; Save new handle

    cmp es:DevFlag,1
    jz  DevErr

    push    cx
    mov cx,3
    xor bx,bx

rcclloop:                   ; Close 0,1 and 2
    mov ah,CLOSE
    int 21h
    inc bx
    loop    rcclloop

    mov bx,dx               ; New device handle
    mov ah,XDUP
    int 21h             ; Dup to 0
    mov ah,XDUP
    int 21h             ; Dup to 1
    mov ah,XDUP
    int 21h             ; Dup to 2
    mov ah,CLOSE
    int 21h             ; Close initial handle
    pop cx
    pop si              ; restore position of command line
    pop ds              ;
;SR;
; Register the fact that we already have redirected the output and cannot do
;it again
;
    inc es:DevFlag          ;
    jmp Parse_command_line          ; continue parsing

DevErr:
    pop si
    pop ds
    mov dx,1
    call    RPrintParse                 ;"Too many parameters"
    call    CrLf
    jmp Parse_command_line

ChkSrchSpec:                    ; Not a device, so must be directory spec

    cmp es:PathFlag,1           ;already set COMSPEC?
    jz  DevErr              ;yes, error

    inc es:PathFlag         ;mark that we have a path
;
;We do not have an ENVIRONMENT segment any more so we need to allocate a
;temporary buffer to hold the COMSPEC. Later, this buffer will be freed and
;its contents moved to the final location of the environment. If there was
;no environment passed before, then a buffer has already been allocated and
;so we check for this case. Fortunately, Chuckenv would have been previously
;set if we had been passed an environment.
;

    mov ax,EnvirSeg
    cmp byte ptr Chuckenv,1         ;passed environment?
    mov byte ptr Chuckenv,0         ;ignore passed environment
    jne no_alloc            ;no, default, dont allocate
;
;We have to override the passed environment. Allocate a buffer for use now.
;This buffer will later be replaced by a proper environment
;
    call    alloc_env           ;allocate env buffer

;;  mov ax,offset ResGroup:PathString   ; Figure environment pointer
;;  mov cl,4
;;  shr ax,cl
;;  mov dx,cs               ;
;;  add ax,dx

    mov EnvirSeg,ax
no_alloc:
    mov es,ax
    assume  es:nothing
    push    si              ; remember location of file
    xor cx,cx               ; clear cx for counting

countloop:
    lodsb                   ; get a character
    inc cx              ; increment counter
    cmp al,END_OF_LINE_OUT          ; are we at end of line?
    jnz countloop           ; no - keep counting

    mov al,Space
    dec si              ; move back one
    mov byte ptr [si],al            ; put a space at end of line
    pop si              ; get location back

    mov di,Env_Ecomspec         ; get location of COMSPEC

ComtrLoop:
    lodsb
    dec cx
    cmp al,Space
    jz  SetComsr
    stosb

    ifdef   DBCS
    xor ah,ah
    endif

    jcxz    setcomsr

    ifdef   DBCS

    push    ds              ; Make sure we have
    push    cs              ;  local DS for
    pop ds              ;  ItestKanj
    call    ItestKanj
    pop ds              ; restore parser ds
    jz  ComtrLoop
    dec cx
    movsb
    inc ah
    jcxz    setcomsr

    endif

    jmp short comtrloop

setcomsr:
    push    cx

    push    cs              ; Get local segment
    pop ds              ;
    assume  ds:ResGroup         ;

    push    ds
    mov si,offset ResGroup:ComSpect
    mov cx,14

    mov al,es:[di-1]

    ifdef   DBCS
    or  ah,ah
    jnz iNotRoot            ; Last char was KANJI second byte, might be '\'
    endif

    cmp al,RDirChar
    jnz iNotRoot
    inc si              ; Don't make a double /
    dec cx

iNotRoot:
    rep movsb

    mov dx,Env_Ecomspec         ; Now lets make sure its good!
    push    es
    pop ds

    mov ax,OPEN shl 8
    int 21h             ; Open COMMAND.COM
    pop ds
    jc  SetComsrBad         ; No COMMAND.COM here
    mov bx,ax               ; Handle
    mov ah,CLOSE
    int 21h             ; Close COMMAND.COM

SetComsrRet:
    pop cx
    pop si
    pop ds              ;
    assume  ds:ResGroup         ;

ArgsDoneJ2:
    push    cs              ; Make sure local ES is
    pop es              ;  restored
    jmp Parse_command_line          ; continue parsing command line

SetComsrBad:
    mov dx,offset ResGroup:BadComlkMsg  ; dx = ptr to msg

;   Note:  we're about to make a near call to TriageError, which
;   lives in a different segment and group.  Some linkers will
;   generate a warning like "Possible fix-up overflow".  We're
;   ok, though, because we all fit in 64 KB and, at init time,
;   we're still all together.

    call    triageError
    cmp ax, 65
    jnz doprt
    mov dx,offset ResGroup:BadComaccMsg ; dx = ptr to msg
DoPrt:
    call    RPrint
    mov si,offset ResGroup:ComSpect
    mov di,Env_Ecomspec
    mov cx,14
    rep movsb               ; get my default back

    jmp short SetComsrRet

;*********************************
; Parsing Ends Here
;*********************************

ArgsDone:

    mov es,EnvirSeg         ; get environment back
    assume  es:nothing          ;

    cmp PermCom,0
    jz  ComReturns

    push    es              ; Save environment pointer
    mov ah,SET_CURRENT_PDB
    mov bx,ds
    mov es,bx
    int 21h             ; current process is me
    mov di,PDB_EXIT         ; Diddle the addresses in my header
    mov ax,offset DATARES:LodCom_Trap
    stosw
    mov ax,ds
    stosw
    mov ax,offset DATARES:Ctrlc_Trap
    stosw
    mov ax,ds
    stosw
    mov ax,offset DATARES:CritErr_Trap
    stosw
    mov ax,ds
    stosw
    mov word ptr ds:PDB_Parent_Pid,ds   ; Parent is me forever

    mov dx,offset DATARES:Int2e_Trap
    mov ax,(SET_INTERRUPT_VECTOR shl 8) or 02eh
    int 21h             ;set magic interrupt
    pop es              ;Remember environment

ComReturns:
    mov ax,word ptr ds:PDB_Parent_Pid
    mov Parent,ax           ; Save parent
    mov word ptr ds:PDB_Parent_Pid,ds   ; Parent is me
    mov ax,word ptr ds:PDB_Jfn_Table
    mov Io_save,ax          ; Get the default stdin and out
    mov al,byte ptr ds:[PDB_Jfn_Table+2]
    mov Io_Stderr,al            ; Get the default stdin and out
    mov word ptr Com_ptr+2,ds           ; set all these to resident
    mov word ptr Com_fcb1+2,ds
    mov word ptr Com_fcb2+2,ds
    mov di,offset ResGroup:ComSpec

    mov si,Env_Ecomspec
    cmp byte ptr Chuckenv,0

    mov ax,ds               ; Xchg es,ds
    push    es
    pop ds
    mov es,ax

    jz  CopyComsp           ; All set up for copy

    push    cs
    pop ds

    mov si,offset ResGroup:ComspString
    push    es
    push    di
    call    IfindE
    mov si,di
    push    es
    pop ds
    pop di
    pop es
    jnc CopyComsp

ComSpecNofnd:
    mov si,Env_Ecomspec             ;
    push    cs
    pop ds

    assume  es:ResGroup

CopyComsp:
    mov es:PutBackComSpec.SubstPtr,di   ; Save ptr to beginning of comspec path
    cmp byte ptr [si+1],':'             ; Is there a drive specifier in comspec
    jnz CopyComspLoop           ; If not, do not skip over first 2 bytes
    add es:PutBackComSpec.SubstPtr,2

CopyComspLoop:
    lodsb
    stosb
    or  al,al
    jnz CopyComspLoop
    mov es:Comspec_end,di           ; Save ptr to end of comspec path
    dec es:Comspec_end
    mov ah,es:comdrv
    add ah,'A'-1
    mov es:PutBackDrv,ah            ; save drive letter


    call    setup_for_messages          ; set up parse and extended error messages
;SR;
;The routine below sets up the exact resident size of COMMAND. If this is not
;the first COMMAND, then the resident code is not duplicated and the resident
;size is just the data. If we are the first COMMAND, it checks if we are to
;be loaded into HIMEM. If not, then the resident size includes the code and
;the data otherwise it is just the data.
;
    call    Setup_res_end           ;put resident size in ResSize

    push    cs
    pop ds
    assume  ds:RESGROUP

;; if we are the permanent one, tell ntvdm the real comspec.
    cmp PermCom, 0
    je  comspec_to_32_done
    push    ax
    mov dx, offset RESGROUP:ComSpec
    CMDSVC  SVC_CMDCOMSPEC
    mov SCS_PAUSE,al            ; yst 4-5-93
    pop ax


comspec_to_32_done:
;;  mov bx,ResMsgEnd            ; get end of resident
;;  add bx,15
;;  mov cl,4
;;  shr bx,cl

Public EnvMaximum
EnvMaximum:
;;;
;;; NOTE: The transient has to loaded directly after shrinking to the
;;; resident size.
;;; There is an assumption made when loading the transient that it
;;; still intact after the resident portion.
;;; If any other ALLOC/DEALLOC/SETBLOCK operations are performed
;;; inbetween, then there is a real good chance that the non-resident
;;; portion will be overwritten by arena information.

;SR;
;Do not shrink to the resident now. We will then be running in deallocated
;memory and BAAADNESS! can ensue.
;

;;  mov ah,SETBLOCK
;;  int 21h             ; shrink to the resident only

;
; Load in the transient and compute the checksum.  We may do this in one of
; two ways:  First, cheat and use the transient loading code that exists in
; the resident piece.  This may be OK except that it will hit the disk.
;
; But we do not need to hit the disk!  The transient is already loaded but is
; in the wrong place.  We need to block transfer it up to the correct spot.
;

;
; M004; Start of changes
;

;
; Compute checksum right now before we can get corrupted and save it
;

    mov si,offset RESGROUP:TranStart
    add si,100h
    mov cx,offset TRANGROUP:TranDataEnd - 100H

    cld
    shr cx,1
    xor dx,dx
Ichksum:
    lodsw
    add dx,ax
    adc dx,0
    loop    Ichksum

    mov Sum,dx              ;store checksum

;
; M004; End of changes
;

    cmp byte ptr PrdAttm,0          ;eg
    jnz NoBatchSeg          ;eg don't do autoexec or date time
;
; allocate batch segment for d:/autoexec.bat + no arguments
;

; NTVDM temp name of the batch file may be up to 63 bytes, plus NULL
;        mov     bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16 ;eg
        mov     bx,((SIZE BatchSegment) + 64 + 0fh)/16 ;eg

    mov ah,ALLOC            ;eg
    int 21h             ;eg
    jc  NoBatchSeg          ;eg didn't allocate - pretend no batch
    mov Batch,ax            ;eg save batch segment

nobatchseg:
;;  mov bx, 0ffffh          ; get size of largest block for env
;;  mov ah, ALLOC
;;  int 21h
;;
;;; only allocate maximum 64k worth of environment
;;
;;  sub bx,TrnSize          ;eg subtract # of transient paragraphs
;;  sub bx,128              ;eg make sure we have 2k left
;;  mov EnvMax, bx
;;  cmp bx, 4096            ; 64k = 4096 paragraphs
;;  jb  maxok
;;  mov bx, 4096-1
;;  mov EnvMax, bx
;;maxok:
;;
;;  mov ah, ALLOC           ; get max size
;;  int 21h
;;
    mov bx,EnvirSeg         ;g get old environment segment
    mov OldEnv,bx           ;g save it

    mov UsedEnv,0           ;g initialize env size counter
    mov ds,bx
    assume  ds:nothing

;;  mov EnvirSeg,ax
;;;Bugbug: There is no need to initialize es at this point-- no string moves
;;  mov es,ax

    xor si,si
    mov di,si
;SR;
;This is the maximum allowed size for the environment
;
    mov bx,4096 - 1             ; max. allowed env. size
    mov EnvMax,bx

    shl bx,1
    shl bx,1
    shl bx,1
    shl bx,1
    mov EnvMax, bx          ; convert envmax to bytes
    dec bx              ; dec by one to leave room for double 0
    xor dx,dx               ; use dx to indicate that there was
                        ; no environment size error.
public NxtStr
NxtStr:
    call    GetStrLen           ; get the size of the current env string

;Bugbug: Can use ss here to address UsedEnv

    push    ds              ;g get addressability to environment
    push    cs              ;g           counter
    pop ds              ;g
    assume  ds:ResGroup
    add UsedEnv,cx          ;g  add the string length to env size
    pop ds              ;g
    assume  ds:nothing
    cmp cx,1                ; end of environment was encountered.
    jz  EnvExit
    sub bx,cx
    jae OkCpyStr            ; can't fit in all of enviroment.
    inc dx              ; out of env space msg must be displayed
    jmp short EnvExit
OkCpyStr:
    jmp NxtStr
EnvExit:

    push    cs
    pop ds
    assume  ds:ResGroup
    or  dx,dx               ; dx will be non-zero if error
    jz  EnvNoErr
    mov dx,offset ResGroup:OutEnvMsg    ; dx = ptr to msg
    call    RPrint

EnvNoErr:
    mov ax,EnvSiz           ;env size previously set
    mov cl,4
    shl ax,cl               ;get size in bytes
    cmp ax,UsedEnv          ;is it a new env?
    ja  st_envsize          ;yes, store the size

    mov ax,UsedEnv
    add ax,15               ;round up
st_envsize:
    shr ax,cl
    mov EnvSiz,ax           ;store env size needed(paras)
;;;
;;; bx now has the left over size of the maximum environment
;;; we want to shrink the environment down to the minimum size
;;; set the environment size to max(envsiz,env used)

;;  mov cx, EnvMax
;;  sub cx, bx              ; cx now has the environment used
;;  add cx, 16              ; round up to next paragraph
;;  shr cx, 1
;;  shr cx, 1
;;  shr cx, 1
;;  shr cx, 1
;;  cmp cx, EnvSiz          ; is environment used > envsiz
;;  jb  EnvSet
;;  mov EnvSiz, cx
;;EnvSet:
;;  mov bx, EnvSiz          ; set environment to size needed
;;  mov ax,es               ;eg get environment segment
;;  add ax,bx               ;eg add number of environment paragraphs
;;  cmp ax,InitEnd          ;eg does this go past end of init?
;;  ja  EnvSetOk            ;eg yes - do the setblock
;;  mov ax,es               ;eg no - get back the environment segment
;;  mov bx,InitEnd          ;eg get the segment at end of init
;;  sub bx,ax               ;eg setblock envir segment to end of init code
;;  mov ResetEnv,1          ;eg set flag so we know to set envir later
;;
;;envsetok:
;;  mov ah, setblock
;;  int 21h
ifndef NEC_98
        cmp     SCS_FIRSTCOM,1
        jz      nophead                         ; don't print header for first instance
else    ;NEC_98
endif   ;NEC_98
        cmp     SCS_CMDPROMPT,1
        je      nophead
    cmp SingleCom,0
    jnz nophead             ; don't print header if singlecom
        mov     dx,offset ResGroup:CopyrightMsg ; dx = ptr to msg
        call    RPrint

nophead:

        cmp     Batch,0                 ;eg did we set up a batch segment?
    jnz DoDate              ;eg yes - go initialize it
    jmp NoDttm              ; don't do autoexec or date time
;
; allocate batch segment for d:/autoexec.bat + no arguments
;
DoDate:
    mov ax,Batch            ;eg get batch segment
    mov EchoFlag,3          ; set batch echo
    mov Nest,1              ; g set nest flag to 1 batch
    mov es,ax
;
; initialize the segment
;
    xor di,di
    mov al,BATCHTYPE
    stosb
    mov al,1                ; g initialize echo for batch exit
    stosb                   ; g
;SR;
; Hosebag! This guy does not use the struct fields to init the BatchSegment
;
    xor ax,ax               ; initialize to zero
    stosb                   ; clear out BatchEOF

    stosw                   ; g batch segment of last job - batlast
    stosw                   ; g segment for for
    stosb                   ; g for flag
    stosw                   ; position in file - batseek
    stosw
;
; clean out the parameters
;
    mov ax,-1               ; initialize to no parameters
    mov cx,10
        rep     stosw

;
; NTVDM Get temp file name from 32 bit command.lib
;
if 0
;
; decide whether we should grab the default drive
;
    cmp byte ptr AutoBat,0
    jnz NoAutSet
    mov ah,GET_DEFAULT_DRIVE
    int 21h
    add al,Ucasea

    mov AutoBat,al
    mov KautoBat,al         ; 3/3/kk

NoAutSet:


;
; copy in the batch file name (including nul)
;
    mov si,offset ResGroup:AutoBat
    mov cx,8
    rep movsw
        movsb                                   ; move in carriage return to terminate string
endif
        push    es
        pop     ds
        assume ds:nothing

        mov     dx, di
        CMDSVC  SVC_GETAUTOEXECBAT

;NTVDM not used mov     dx,offset ResGroup:AutoBat
    mov ax,OPEN shl 8
        int     21h                             ; see if autoexec.bat exists

        push    cs
        pop     ds
        assume  ds:ResGroup

        jc      NoAbat
    mov bx,ax
    mov ah,CLOSE
    int 21h
ifndef NEC_98
    jmp Drv0                ; go process autoexec
else    ;NEC_98
    jmp short   Drv0            ; NEC01 91/07/30 Warning Error Del
endif   ;NEC_98

noabat:
    push    ax
    call    Setup_Seg
    mov word ptr Triage_Add+2,ax
    pop ax
    call    Triage_Add
    cmp ax, 65
    jz  AccDenErr           ; was network access denied

; NTVDM we don't do kautoexe.bat
if 0
; If AUTOEXEC.BAT is not found, then check for KAUTOEXE.BAT.  Changed
; by Ellen to check only when in Korea.  The country information
; returned will overlay the old parse data area, but we don't care
; since we won't need the parse information or country information.
; We only care about the country code returned in BX.

    mov dx,offset ResGroup:Internat_Info ; set up internat vars
    mov ax,INTERNATIONAL shl 8      ; get country dependent info
    int 21h             ;
    jc  NoKabat             ; error - don't bother with it
    cmp bx,KOREA_COUNTRY_CODE           ; are we speaking korean?
    jnz OpenErr             ; no, don't check for kautoexe

    mov di,BatFile          ; 3/3/kk
    mov si,offset ResGroup:KautoBat ; another trial to do   3/3/kk
    mov cx,8                ; auto execution for the 3/3/kk
    rep movsw               ; non-english country   3/3/kk
    movsb                   ; move in carraige return to terminate string
    mov dx,offset ResGroup:KautoBat ; 3/3/kk
    mov ax,OPEN shl 8           ; 3/3/kk
    int 21h             ; see if kautoexe.bat exists    3/3/kk
    jc  NoKabat             ; 3/3/kk
    mov bx,ax               ; 3/3/kk
    mov ah,CLOSE            ; 3/3/kk
    int 21h             ; 3/3/kk
    jmp short Drv0          ; 3/3/kk

NoKabat:                        ; 3/3/kk
    call    Triage_Add          ; get extended error
    cmp ax, 65              ; network access denied?
        jnz     OpenErr                         ; no - go deallocate batch
endif

AccDenErr:                  ; yes - put out message
    mov dx,offset ResGroup:AccDen       ; dx = ptr to msg
    call    RPrint

OpenErr:
    mov es,Batch            ; not found--turn off batch job
    mov ah,DEALLOC
    int 21h
    mov Batch,0         ; after dealloc in case of ^c
    mov EchoFlag,1
    mov Nest,0              ;g indicate no batch in progress

DoDttm:
    mov ax,offset TranGroup:Datinit
    mov word ptr InitAdd,ax
;;;M004 mov ax,TrnSeg
;
; M004; We cant use TrnSeg now because it is not initialized. We now that
; M004; the transient starts on a para boundary at the label TranStart.
; M004; We use TranStart to get the start of the transient segment.
;
    mov ax,offset RESGROUP:TranStart    ; M004
    mov cl,4                ; M004
    shr ax,cl               ; get relative seg ; M004
    mov cx,cs
    add ax,cx               ; ax = transient seg ; M004

    mov word ptr InitAdd+2,ax
;   call    dword ptr InitAdd

NoDttm:

Copyright:
    public  Copyright
;   Bugbug: remove Copyright label.

;if IBMVER
;   cmp SingleCom,0
;   jnz Drv0                ; don't print header if singlecom
;   mov dx,offset ResGroup:CopyrightMsg ; dx = ptr to msg
;   call    RPrint
;endif

Drv0:                       ; Reset APPEND state
    push    ds              ; save data segment
    push    cs              ; Get local segment into DS
    pop ds              ;
    mov ax,APPENDSETSTATE           ; Set the state of Append
    mov bx,Append_State             ;  back to the original state
    int 2fh             ;
    pop ds              ; get data segment back
;
;Check FirstCom set previously to see if this is the first instance of
;command.com. If not, we do not move command.com. Instead, we copy over the
;jump table from the previous stub to the current stub.
;
    cmp FirstCom,1          ;first command.com?
    jz  move_code           ;yes, move it

    push    es
    push    ds

    push    ds
    pop es
    mov di,offset DATARES:Int2f_Entry

    mov ds,word ptr es:ResJmpTable+2    ;get segment address
    mov si,word ptr es:ResJmpTable      ;get offset address

    mov     cx,NUM_RELOC_ENTRIES            ;number of dword ptrs
    shl cx,1
    shl cx,1                ;size of table in bytes

    cld
    rep movsb               ;copy the jump table
;
;Check if the resident code is in HMA. We assume that it is in HMA if its
;code segment > 0f000h. If in HMA, we set the ComInHMA flag
;
    cmp es:[di-2],0f000h            ;is resident code in HMA?
    jb  res_low         ;no, dont set flag

    mov es:ComInHMA,1           ;indicate code in HMA

res_low:
    pop ds
    pop es
    jmp short finish_init
;
;Now, we can move the resident code to its final location, either to HIMEM
;or to overlay the messages in the data segment if the user has not used the
;/msg switch.
;
move_code:
    call    Move_res_code           ;move the code

finish_init:
    jmp RESGROUP:EndInit            ;g finish initializing

;
;   Get length of string pointed to by DS:SI.  Length includes NULL.
;   Length is returned in CX
;
GetStrLen:
    xor cx,cx
NxtChar:
    lodsb
    inc cx
    or  al,al
    jnz NxtChar
    ret
;
; If the transient has been loaded in TranSeg, then we need to use that
; segment for calls to routines in the transient area. Otherwise, the current
; code segment is used
; Segment returned in AX.
;
Setup_Seg:
    mov ax,TrnSeg
    cmp TrnMvFlg, 1         ; Has transient portion been moved
    jz  setup_end
    push    bx
    mov bx,cs
    mov ax,offset ResGroup:TranStart
    shr ax,1
    shr ax,1
    shr ax,1
    shr ax,1
    add ax,bx
    pop bx
setup_end:
    ret


;***    RPrintParse - display parse error message
;
;   ENTRY   DX = parse error #
;
;   EXIT    nothing
;
;   USED    flags
;
;   EFFECTS
;     Message is displayed on stdout.

RPrintParse proc

    assume  ds:ResGroup,ss:ResGroup

    push    dx              ; preserve DX
    xchg    bx,dx               ; bx = parse error #
                        ; dx = saved BX
ifdef BILINGUAL
    push    ax
    push    bx
    mov ax,4f01h        ; get code page
    xor bx,bx
    int 2fh
ifdef JAPAN
    cmp bx,932
endif ; JAPAN
ifdef KOREA
    cmp bx,949
endif ; KOREA
ifdef TAIWAN
    cmp bx,950
endif ; TAIWAN
ifdef PRC
    cmp bx,936
endif ; TAIWAN
    pop bx
    pop ax
    jz  @f          ; if DBCS code page
    add bx,11
@@:
endif ; BILINGUAL
    dec bx              ; bx = parse error index, from 0
    shl bx,1                ; bx = offset in word table
    mov bx,ParsMsgPtrs[bx]          ; bx = ptr to error msg
    xchg    bx,dx               ; dx = ptr to error msg
                        ; bx = restored
ifdef BILINGUAL
    call    RPrint@             ; print the message
else ; !BILINGUAL
    call    RPrint              ; print the message
endif ; !BILINGUAL
    pop dx              ; restore DX
    ret

RPrintParse endp



IfindE:
    call    ifind               ; find the name
    jc  ifind2              ; carry means not found
    jmp short Iscasb1           ; scan for = sign
;
; on return of find1, es:di points to beginning of name
;
ifind:
    cld
    call    Icount0             ; cx = length of name
    mov es,EnvirSeg
    xor di,di

ifind1:
    push    cx
    push    si
    push    di

Ifind11:
    lodsb

    ifdef   DBCS

    call    ItestKanj
    jz  NotKanj4
    dec si
    lodsw
    inc di
    inc di
    cmp ax,es:[di-2]
    jnz Ifind12
    dec cx
    loop    Ifind11
    jmp short Ifind12
NotKanj4:

    endif

    call    IupConv
    inc di
    cmp al,es:[di-1]
    jnz Ifind12
    loop    Ifind11

Ifind12:
    pop di
    pop si
    pop cx
    jz  Ifind2
    push    cx
    call    Iscasb2             ; scan for a nul
    pop cx
    cmp byte ptr es:[di],0
    jnz Ifind1
    stc                 ; indicate not found

Ifind2:
    ret

Icount0:
    push    ds
    pop es
    mov di,si

    push    di              ; count number of chars until "="
    call    Iscasb1
    jmp short Icountx
    push    di              ; count number of chars until nul
    call    Iscasb2

Icountx:
    pop cx
    sub di,cx
    xchg    di,cx
    ret

Iscasb1:
    mov al,Equalsign            ; scan for an =
    jmp short Iscasbx

Iscasb2:
    xor al,al               ; scan for a nul

Iscasbx:
    mov cx,100h
    repnz   scasb
    ret


; ****************************************************************
; *
; * ROUTINE:     IUPCONV    (ADDED BY EMG 4.00)
; *
; * FUNCTION:    This routine returns the upper case equivalent of
; *      the character in AL from the file upper case table
; *      in DOS if character if above  ascii 128, else
; *      subtracts 20H if between "a" and "z".
; *
; * INPUT:   DS       set to resident
; *      AL       char to be upper cased
; *      FUCASE_ADDR  set to the file upper case table
; *
; * OUTPUT:  AL       upper cased character
; *
; ****************************************************************


IupConv proc    near
    assume  ds:ResGroup         ;

    cmp al,80h              ; see if char is > ascii 128
    jb  other_fucase            ; no - upper case math
    sub al,80h              ; only upper 128 chars in table
    push    ds              ;
    push    bx              ;
    lds bx,dword ptr fucase_addr+1      ; get table address
    add bx,2                ; skip over first word
    xlat    ds:byte ptr [bx]            ; convert to upper case
    pop bx              ;
    pop ds              ;
    jmp short iupconv_end           ; we finished - exit

other_fucase:                   ;
    cmp al,Lcasea           ; if between "a" and "z",
    jb  iupconv_end         ;     subtract 20h to get
    cmp al,Lcasez           ; upper case equivalent.
    ja  iupconv_end         ;
    sub al,20h              ; Change lower-case to upper

iupconv_end:                    ;
    ret

IupConv endp                    ;


init_contc_specialcase:
                        ; This routine is called if control-C
    add sp,6                ;  is type during the date/time prompt
    push    si              ;  at initialization time.  The desired
    mov si,dx               ;  response is to make it look like the
    mov word ptr [si+1],0d00h           ;  user typed <CR> by "popping" the
    pop si              ;  INT 21h stuff off the stack, putting
    iret                    ;  a <CR> in the user's buffer, and
                        ;  returning directly to the user.
                        ; In this case the user is TCODE.


; ****************************************************************
; *
; * ROUTINE:     Setup_for_messages
; *
; * FUNCTION:    Sets up system for PARSE and EXTENDED ERROR
; *      messages as follows:
; *
; *      IF /P and /MSG are entered
; *         keep PARSE and EXTENDED ERRORS in memory
; *      ELSE IF /P is entered
; *         use PARSE and EXTENDED ERRORS on disk
; *         remove PARSE ERRORS from memory
; *      ELSE
; *         remove PARSE ERRORS from memory
; *      ENDIF
; *
; * INPUT:   PERMCOM    Set up with user input
; *      EXT_MSG    Set up with user input
; *      System set up to retain PARSE ERRORS
; *
; * OUTPUT:  registers unchanged
; *
; ****************************************************************


setup_for_messages  proc    near

    push    bx
    push    ds              ; save data segment
    push    es              ; save environment segment
    push    ax              ;
    push    dx              ;
    push    di              ;
    mov ax,cs               ; get local segment to ES and DS
    mov ds,ax               ;
    mov es,ax               ;

    cmp PermCom,0           ; was permcom set?
    jz  no_permcom          ; No - don't worry about messages

;*  We're permanent.  Install our message services int 2f handler.

    push    es
    mov ax,(GET_INTERRUPT_VECTOR shl 8) or 2Fh
    int 21h
    mov word ptr Int2fHandler,bx
    mov word ptr Int2fHandler+2,es
    pop es

;   DS = RESGROUP seg addr

;
; M005; We will not hook int 2fh on any command.com other than the first.
; M005; Carousel loads as a permanent command.com and when we exit Carousel,
; M005; it just wipes our arena out. So, int 2fh is still hooked and the
; M005; first int 2fh call after exit from Carousel (from the DOS terminate
; M005; call) goes off into space.
;
    cmp FirstCom,0          ; M005
    je  no_msg_hook         ; M005
;
; M005; !!!SLIMIEST CAROUSEL HACK OFF ALL!!!
; M005; Carousel plays around with the interrupt vector tables. He saves it
; M005; before loading a new command.com. Then, it takes hold of the current
; M005; command.com's PSP and then looks at all interrupt vectors whose
; M005; segment matches the command.com PSP and then updates these segments
; M005; to the new command.com's PSP in his saved vector table. Whenever we
; M005; we pop into his menu, he puts this saved table into the vector table.
; M005; If we now quit, Carousel just wipes out command.com's arena and then
; M005; issues a terminate. Unfortunately, the int 2fh vector is pointing at
; M005; the command.com that was wiped out and so the next int 2fh call will
; M005; bomb. To prevent Carousel from doing this clever(1**$$#) patching, we
; M005; renormalize our int 2fh pointer so that its cs is not the same as the
; M005; command.com PSP. Now, he does no such patching and our int 2fh vector
; M005; remains nice and happy. The renormalized pointer points at a far
; M005; jump to the actual int 2fh entry point.
;
    push    ds              ; M005
    mov dx,offset DATARES:Carousel_i2f_Hook ; M005
    sub dx,10h              ; renormalize offset; M005
    mov ax,ds               ; M005
    inc ax              ; Relocated cs ; M005
    mov ds,ax               ; M005
    mov ax,(SET_INTERRUPT_VECTOR shl 8) or 2Fh
    int 21h
    pop ds              ; M005
    mov word ptr Carousel_i2f_Hook+3,ds ; M005
                        ; patch in the cs for jump
no_msg_hook:                    ; M005

    cmp Ext_Msg,SET_EXTENDED_MSG
    jne short permcom_end           ; no /msg - exit

permcom_slash_msg:              ; Keep messages in memory
    mov di,offset ResGroup:ExtMsgEnd    ; get address of resident end
    mov ResMsgEnd,di            ; save it
    jmp short permcom_end           ; exit

no_permcom:
    cmp Ext_msg,SET_EXTENDED_MSG        ; was /msg specified?
    jnz permcom_end         ; no - no error
    mov dx,LessArgs_Ptr             ; get message number for "Required parameter missing"
    call    RPrintParse

permcom_end:
    pop di              ;
    pop dx              ;
    pop ax              ;
    pop es              ; get environment back
    pop ds              ;
    pop bx

    ret                 ;

setup_for_messages  endp




;***    CheckHelp - print help text and exit if /? is on command line
;
;   ENTRY   command-line tail at 81h
;
;   EXIT    return if /? not found
;       terminate if /? found
;
;   USED    AX,BX,CX,DX,SI,DI
;
;   EFFECTS Help text displayed if /? found on command line

CheckHelp   proc

    assume  cs:RESGROUP,ds:RESGROUP,es:RESGROUP,ss:RESGROUP

    mov si,81h          ; DS:SI = ptr to command-line tail
    mov di,offset RESGROUP:Parse_Command
                    ; ES:DI = ptr to primary parse block
    xor cx,cx           ; CX = # positional param's found
    xor dx,dx           ; DX will be ptr to result buffer

chParse:
    call    Init_Parse      ; call system parser

    cmp ax,END_OF_LINE
    je  chRet           ; end of command line, no /? found
    cmp ax,RESULT_NO_ERROR
    je  chWhich         ; valid syntax element found
    jmp chParse         ; go parse more

chWhich:
    cmp Comnd1_Syn,offset RESGROUP:Command_?_Syn
    je  chHelp          ; /? found - display help & exit
    cmp Comnd1_Syn,offset RESGROUP:Command_C_Syn
    je  chRet           ; /c found - ignore rest of line
    cmp Comnd1_Syn,offset RESGROUP:Command_K_Syn
    je  chRet           ; /k found - ignore rest of line
    cmp Comnd1_Syn,offset RESGROUP:Command_z_Syn
    je  chRet           ; /c found - ignore rest of line
    jmp chParse         ; anything else - ignore, keep looking

chHelp:
    mov si,offset RESGROUP:HelpMsgs ; SI = ptr to msg ptr list
chHelpNext:
    lodsw                   ; AX = ptr to msg
    or  ax,ax
    jz  chHelpDone          ; end of list - all done
    mov dx,ax               ; DX = ptr to msg
    call    RPrint              ; display msg
    jmp chHelpNext          ; go do next msg
chHelpDone:
    int 20h             ; terminate program

chRet:  ret

CheckHelp       endp

st_invalid macro
        mov     ax,0ffffh
        push    ax
        push    ax
endm

st_valid macro
        push    bx
        push    cx
endm

CleanForStd macro
        add     sp,12
endm

;***    CheckZSwitch -  Handle special /Z switch of command.com.
;           This switch has been added for SCS functionality
;           such that DOS apps can exec non-dos apps and
;           still leave DOS in a consistant state such that
;           it can be re-entered.
;
;   ENTRY   command-line tail at 81h
;
;   EXIT    non-dos binary is execed and command.com terminates after
;       non-dos binary completes.
;
;   EFFECTS

CheckZSwitch    proc
    assume  cs:RESGROUP,ds:RESGROUP,es:RESGROUP,ss:RESGROUP

    mov si,81h          ; DS:SI = ptr to command-line tail
    mov di,offset RESGROUP:Parse_Command
                    ; ES:DI = ptr to primary parse block
    xor cx,cx           ; CX = # positional param's found
    xor dx,dx           ; DX will be ptr to result buffer

czParse:
    call    Init_Parse      ; call system parser

    cmp ax,END_OF_LINE
    je  czRet           ; end of command line, no /? found
    cmp ax,RESULT_NO_ERROR
    je  czWhich         ; valid syntax element found
    jmp short czRet

czWhich:
    cmp Comnd1_Syn,offset RESGROUP:Command_z_Syn
    je  czSwitch
    jmp short czRet

czSwitch:
        push    bp
        xor     bx,bx
        mov     si,bx
        mov     bp,bx
        mov     ax,5303h
        int     21h
        jnc     st_stdin
        st_invalid
        jmp     short go_stdout
st_stdin:
        st_valid
go_stdout:
        mov     bx,1
        mov     ax,5303h
        int     21h
        jnc     st_stdout
        st_invalid
        jmp     short go_stderr
st_stdout:
        st_valid
go_stderr:
        mov     bx,2
        mov     ax,5303h
        int     21h
        jnc     st_stderr
        st_invalid
        jmp     short std_done
st_stderr:
        st_valid
std_done:
    mov ah,19h
    int 21h
        mov     si,84h                  ; 84h because that is where the real
                                        ; command starts (i.e. 7/z\bfoo.exe)
    mov bx,ds:2ch
        mov     bp,sp
    push    es
        mov     es,bx
        xor     ah,ah                   ; no "cmd /c"
    CMDSVC  SVC_CMDEXEC     ; Exec non-dos binary
    pop es          ; ds:si is command tail (DOS_style)
                    ; es    is env segment
                                        ; al = current drive
                                        ; ss:bp = std handles
                                        ; returns al = return code
        lahf
        CleanForStd
        pop     bp
        sahf
    jc  czReEnter

    mov ah,4ch
    int 21h

czRet:  ret

czReEnter:
        xor     ah,ah
        mov     [SCS_REENTERED],3
    mov byte ptr ds:80h,0
    ret

CheckZSwitch    endp

;***** Setup_res_end -- This routine determines the resident size of COMMAND.
; It determines based on 2 factors:
;   1. Is this is the first COMMAND?
;   2. Is COMMAND to be loaded into HIMEM?
;   The strategy works as follows:
;
;   if ( First COMMAND)
;   then if (COMMAND in HIMEM)
;       ResSize = resident_data;
;        else
;       ResSize = resident_data + resident_code;
;   else
;      ResSize = resident_data;
;
; Int 2fh calls have been added to determine whether or not we are the first
;COMMAND and whether DOS is in HIMEM.
;
;   ENTRY: ResMsgEnd = resident size of data in paras
;
;   EXIT:  ResSize = resident size in low memory
;
;   REGISTERS AFFECTED: ax,cx,dx
;

; NTVDM use diff al value so we don't confuse dos 5.0
; NTVDM command.com GET_COMMAND_STATE       equ     5500h
GET_COMMAND_STATE       equ     5501h
GET_HMA_ADDR        equ 4a02h

Setup_res_end   proc    near

    push    ds
    mov ax,cs
    mov ds,ax               ;ds = RESGROUP
    assume  ds:RESGROUP

    mov cx,ResMsgEnd            ;set resident size = data

;M042 -- Begin changes
;If messages are to be kept behind, we need to round up the messages to
;the next para boundary. This is because we have a dummy segment between the
;data and the resident code segment so that the code segment starts on a
;para boundary
;
    cmp cx,offset RESGROUP: ExtMsgEnd   ;messages to be resident?
    jne calc_res            ;no, continue
    add cx,15               ;round up
    and cx,0fff0h
calc_res:
;
;M042 -- End changes
;
    xor ax,ax
        cmp FirstCom,1          ;is it first command.com?
    jnz not_first           ;no, do not keep code
;
;We issue a version check call with al=01 to detect if DOS is in HMA. If so,
;bit 4 of dh is set
;
    push    bx
    push    cx
    mov ax,(SET_CTRL_C_TRAPPING shl 8) or 06h ;is DOS in HIMEM? ;M013
    int 21h
    pop cx
;bugbug: remove version check after testing
    cmp bl,5                ;bl has true version ; M013
    jb  oldver

    xor ax,ax
    and dh,10h              ;is DOS in HMA ; M013
    pop bx
    jnz not_first           ;DOS in HIMEM, code not
                        ;   resident

    mov ax,offset CODERES: EndCode      ;size of code in bytes
not_first:
;
;Note that ax = 0(side effect of int 2fh), if the code is not to be retained
;
    add cx,ax
    add cx,15               ;round up to next para
    shr cx,1
    shr cx,1
    shr cx,1
    shr cx,1                ;ax = para size of res code
    mov ResSize,cx          ;store resident size

    pop ds
    assume  ds:nothing
    ret
;bugbug: remove this code (for version independent COMMAND) after testing
oldver:
    pop bx
    mov ax,offset CODERES: EndCode      ;size of code in bytes
        jmp short not_first

setup_res_end   endp


;*** Move_res_code -- This routine moves the resident code to its final
; location. We check if DOS is in HIMEM. If so, we try to load ourselves
; in HIMEM. If we fail, then we remain low and update ResSize to reflect
; the correct resident size. When remaining low, we have to check if we
; need to overlay the messages part of the data segment which is determined
; by the /msg switch.
;
;   ENTRY: ResMsgEnd = end of resident data
;
;   EXIT:  The resident code is either up high or in its final location
;       down low.
;
;   REGISTERS AFFECTED: ax,bx,cx,dx,si,di
;

Move_res_code   proc    near

    push    ds
    push    es

    mov ax,cs
    mov ds,ax
    assume  ds:RESGROUP

    mov ax,(SET_CTRL_C_TRAPPING shl 8) or 06h ; M013
    int 21h             ;DOS in HIMEM?

    and dh,10h              ; M013
    jnz move_high           ;yes, move code high

;
;Check if messages have been discarded or not
;
load_low:
    push    ds
    pop es              ;es = RESGROUP
    mov di,ResMsgEnd            ;end offset in DATARES
    mov bx,offset RESGROUP: ExtMsgEnd   ;end offset of messages

    cmp di,bx               ;are messages to be kept?
    jz  no_move         ;yes, dont move code

    jmp short setup_move            ;es:di points at dest.

move_high:

;
;We have to call DOS to get the load address in HIMEM for COMMAND
;We pass in bx the number of bytes we need
;
    mov bx,offset CODERES: EndCode

;M030;
; Set di=0ffffh so that we load low in case no one answers this int 2fh
;
    mov di,0ffffh           ;DT - in case no-one handles
                        ;this ; M030
    mov ax,GET_HMA_ADDR
    int 2fh

;
;If the offset = 0xffff, then no HMA available
;
    cmp di,0ffffh           ;HMA available?
    mov ComInHMA,1          ;assume command.com in HMA
    jnz setup_move          ;no error, es:di = memory

    mov ComInHMA,0          ;could not load in HMA
;
;Zero means that we do not have enough HIMEM. Remain low and update
;ResSize to reflect this
;
    mov cx,ResMsgEnd            ;size of data in bytes
    mov ax,offset CODERES: EndCode      ;size of code in bytes

    add cx,ax
    add cx,15               ;round up to next para
    shr cx,1
    shr cx,1
    shr cx,1
    shr cx,1                ;ax = para size of res code
    mov ResSize,cx          ;store resident size
    jmp short load_low          ;let code remain low

no_move:
    mov cl,4
    add di,0fh
    and di,0fff0h           ;round it to a para offset
    jmp short patch_up

setup_move:
    mov si,offset RESGROUP: StartCode
    mov cx,offset CODERES: EndCode      ;cx = bytes to move

    cld
    push    di              ;need di for patching offset
    rep movsb
    pop di

patch_up:
    call    patch_stub
    pop es
    pop ds
    assume  ds:nothing
    ret

Move_res_code   endp


;*** Alloc_env -- This routine allocates the temporary environment for the
; Init code to initialize the COMSPEC. This is not a complete environment.
; Later on, at EndInit time, a proper sized environment is allocated and
; the contents of this temporary environment are copied to it. This routine
; will not be called in case a valid environment is passed to command.com
;
;   ENTRY:  None
;
;   EXIT:   ax = segment of allocated environment segment
;
;   REGISTERS AFFECTED: ax,bx,cx
;

Alloc_env   proc    near

    push    ds
    push    es
    push    si
    push    di

;
;Allocate default environment size
;
    mov bx,SIZE Environment / 16        ;temp env size in paras
    mov ah,ALLOC
    int 21h
    jc  init_nomem          ;insufficient memory, error

    mov es,ax
    assume  es:nothing          ;es = temp env segment
    xor di,di
    mov ax,di
;
;First clear out the entire buffer
;
    mov cx,SIZE Environment
    rep stosb

;
;Init. the path string (PATH=) first
;

    push    ss              ; M026
    pop ds              ; ds = RESGROUP ; M026
    assume  ds:RESGROUP         ; M026
    mov si,offset RESGROUP: PathString  ;ds:si = "PATH=\0"
    mov di,Env_Pathstring           ;offset of Path in env seg
pathlp:
    lodsb
    stosb
    or  al,al               ;end of string?
    jnz pathlp              ;no, continue transfer
;
;Init. the Comspec string
;
    mov si,offset RESGROUP: ComspString ;"COMSPEC=\COMMAND.COM\0"
    mov di,Env_Comstring            ;location of Comspec string
comsplp:
    lodsb
    stosb
    or  al,al               ;end of string?
    jnz comsplp

    mov ax,es               ;return env seg in ax

    pop di
    pop si
    pop es
    pop ds
    assume  ds:nothing
    ret

init_nomem:
;
;We call the error routine from here. This routine never returns. It either
;terminates COMMAND with error( if it is not the first invocation ) or hangs
;the system ( if it is the first COMMAND.COM ).
;
    call    alloc_error

Alloc_env   endp

;*** Alloc_error: This routine just jumps to the actual label where we
; check if this is a permanent or secondary command.com and take the
; appropriate action.
;
;   ENTRY:  ds = RESGROUP = DATARES
;
;   EXIT:   None - does not return
;
;   REGISTERS AFFECTED: Does not matter
;

public Alloc_error
Alloc_error proc    near

    jmp RESGROUP:BadMemErr

Alloc_error endp

;*** Patch_stub -- This routine patches in the segment and offset values in
; the stub table of the various entry points in the resident code segment.
; Some of them are interrupt entry points and some of them are entries from
; the transient to the resident code segment.
;
;   ENTRY:  ds = RESGROUP
;       es:di = segment:offset of final location of resident code
;
;   EXIT:   All segments and offsets patched into the stub table
;
;   REGISTERS AFFECTED: ax, bx, cx, dx, si, di
;
;
Patch_stub  proc    near

    assume  ds:RESGROUP

    push    es

    mov bx,es           ;bx = resident code segment
    mov dx,di
    mov di,offset DATARES:Int2f_Entry
    mov si,offset RESGROUP:Reloc_Table
    push    ds
    pop es          ;es = RESGROUP = DATARES
;
;bx:dx = segment:offset of resident code segment
;es:di = entry point table in stub
;ds:si = offset table in INIT segment -- offsets of code entry points now
;
    mov cx,NUM_RELOC_ENTRIES        ;number of entry points
patchlp:
    lodsw               ;get current offset
    add ax,dx           ;offset it by code seg location
    stosw               ;store offset
    mov ax,bx
    stosw               ;store segment
    loop    patchlp

    pop es
    ret

Patch_stub  endp

;*** Patch_segs -- This routine patches the segment values in the dword
; pointers that the stub uses to jump to the actual handler. These values
; are temporarily needed to handle these interrupts if they occur before
; the resident is relocated to its final position and all the addresses of
; the handlers have been updated.
;
;   ENTRY:  es = PSP segment = code segment
;
;   EXIT:   Current segment values patched into the jump table in the
;       stub.
;
;   REGISTERS AFFECTED: ax, cx, di
;

Patch_segs  proc    near

    mov di,offset RESGROUP:Int2f_Entry
    mov cx,4            ;we have to patch 4 handlers
    add di,2
    mov ax,es

pseglp:
    stosw               ;store the segment value
    add di,2            ;skip the next offset value
    loop    pseglp

    ret

Patch_segs  endp


;*** get_XMMAddr -- This routine gets the call address for the XMM driver
; by issuing the appropriate int 2fh. This is stored in a stub variable
; and is used by the stub when we have to jump to the resident in HMA
;
;   ENTRY:  ds = RESGROUP
;
;   EXIT:   XMMCallAddr = XMM driver far call address
;
;   REGISTERS AFFECTED:
;

get_XMMAddr proc    near
    assume  ds:RESGROUP

    push    es

    mov ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
    int 2Fh
    cmp al,80h          ; Q: installed
    jne short cXMMexit  ;   N: set error, quit
;
; get the XMM control functions entry point, save it, we
; need to call it later.
;
    mov ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
    int 2Fh

    mov word ptr [XMMCallAddr], bx
    mov word ptr [XMMCallAddr+2],es

cXMMexit:
    pop es
    ret             ; done

get_XMMAddr endp


; IRename
; Input : ds:dx - Existing File
;     ds:di - NewFile
; Output  None
;


IRename proc near

    mov ah,56h
    push    ds
    pop es
    int 21h
    ret

IRename endp

; IAccess
; Input : ds:dx - file name
; Output  CY Set if file not found
;     CY Clear if file found

IAccess proc near

    mov ax,4300h
    int 21h
    ret

IAccess endp

; IDelete
; Input   ds:dx - file to delete
; Output  None

IDelete proc near

    mov ah,41h
    int 21h
    ret

IDelete endp

INIT    ENDS

    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\path1.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)path1.asm	1.1 85/05/14
;	SCCSID = @(#)path1.asm	1.1 85/05/14
.sall
.xlist
.xcref
	include dossym.inc
	include syscall.inc
	include comsw.asm
	include comseg.asm
	include comequ.asm
.list
.cref

break <Path.Asm>
;----------------------------------------------------------------------------
;    PATH.ASM contains the routines to perform pathname incovation.  Path and
;    Parse share a temporary buffer and argv[] definitions.  <Path_Search>,
;    given a pathname, attempts to find a corresponding executable or batch
;    file on disk.  Directories specified in the user's search path will be
;    searched for a matching file, if a match is not found in the current
;    directory and if the pathname is actually only an MSDOS filename.
;    <Path_Search> assumes that the parsed command name can be found in
;    argv[0] -- in other words, <Parseline> should be executed prior to
;    <Path_Search>.  Alternatively, the command name and appropriate
;    information could be placed in argv[0], or <Path_Search> could be
;    (easily) modified to make no assumptions about where its input is found.
;    Please find enclosed yet another important routine, <Save_Args>, which
;    places the entire arg/argv[]/argbuf structure on a piece of newly
;    allocated memory.	This is handy for for-loop processing, and anything
;    else that wants to save the whole shebang and then process other command
;    lines.
;
; Alan L, OS/MSDOS				    August 15, 1983
;
; ENTRY:
;   <Path_Search>:	    argv[0].
;   <Save_Args>:	    bytes to allocate in addition to arg structure
; EXIT:
;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
;   <Save_Args>:	    success flag, segment address of new memory
; NOTE(S):
;   *	<Argv_calc> handily turns an array index into an absolute pointer.
;	The computation depends on the size of an argv[] element (arg_ele).
;   *	<Parseline> calls <cparse> for chunks of the command line.  <Cparse>
;	does not function as specified; see <Parseline> for more details.
;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
;	need to know about.  This extra information is stored in a switch_flag
;	word with each command-line argument; the switches themselves will not
;	appear in the resulting arg structure.
;   *	With the exception of CARRY, flags are generally preserved across calls.
;---------------
; CONSTANTS:
;---------------
    DEBUGx	equ	    FALSE	; prints out debug info
;---------------
; DATA:
;---------------

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	baddrv_ptr:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte
	EXTRN	BADPMES_ptr:word
	EXTRN	curdrv:byte
	EXTRN	EXECPATH:byte
	EXTRN	search_best_buf:byte
	EXTRN	search_error:word
	EXTRN	string_ptr_2:word
	EXTRN	tpbuf:byte
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE	;AC000;

assume cs:trangroup, ds:trangroup, es:trangroup, ss:nothing

break <Path_Search>
;------------------------------------------------------------------------------
;   PATH_SEARCH tries to find the file it's given, somewhere.  An initial value
; of *argv[0].argstartel == 0 implies that there is no command (empty line
; or 'd:'  or 'd:/').  This check is done in strip; otherwise, strip formats
; the filename/pathname into tpbuf.  Search(tpbuf) is executed to see if we
; have a match, either in the current working directory if we were handed
; a filename, or in the specified directory, given a pathname.	If this call
; fails, and we were given a pathname, then Path_Search fails.	Otherwise,
; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
; prefix, we want to skip it) for each pathstring in userpath.	Success on
; either the first invocation of search or on one of the succeeding calls
; sets up the appropriate information for copying the successful pathname
; prefix (if any) into the result buffer, followed by the successful filename
; match (from [search_best_buf]).  The result is returned in in EXECPATH.
; ENTRY:
;   argv[0]		--	command name and associated information
; EXIT:
;   AX			--	non-zero indicates type of file found
;   EXECPATH		--	successful pathname (AX non-zero)
; NOTE(S):
;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
;   2)	Some files are more equal than others.	See search: for rankings.
;   3)	Path_Search terminates as soon as a call to search succeeds, even
;	if search returns an .exe or .bat.
;   5)	Clobbers dma address.

pbuflen         equ     EXECPATHLEN            ; len EXECPATH - ntvdm extended
path_sep_char	equ	';'

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	fbuf:byte
	EXTRN	pathinfo:word
	EXTRN	psep_char:byte
TRANSPACE	ENDS

Procedure   Path_Search,NEAR
	assume	ds:trangroup, es:trangroup

	push	BX
	push	CX
	push	DX				; could use a "stack 'em" instruction
	push	SI
	push	DI
	push	BP
	pushf
	test	DS:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
	jz	path_search_ok

path_failure_jmp:
	jmp	path_failure			; ambiguous commands not allowed

path_search_ok:
	call	store_pchar			; figure out the pathname separator
	mov	DX, OFFSET TRANGROUP:fbuf	; clobber old dma value with
	trap	set_dma 			; a pointer to our dma buffer
	push	ES
	invoke	find_path			; get a handle (ES:DI) on user path
	mov	DS:pathinfo[0], ES		; and squirrel it away
	mov	DS:pathinfo[2], DI		; "old" pathstring pointer
	mov	DS:pathinfo[4], DI		; "new" pathstring pointer
	pop	ES

	mov	BX, pbuflen			; copy/format argv[0] into temp buffer
	mov	SI, OFFSET TRANGROUP:EXECPATH
	invoke	strip
	jc	path_failure_jmp		; if possible, of course

	mov	DX, SI				; search(EXECPATH, error_message)
	mov	[search_error], OFFSET TRANGROUP:BADDRV_ptr
	invoke	search				; must do at least one search
	or	AX, AX				; find anything?
	jz	path_noinit			; failure ... search farther

	mov	BP, AX				; success... save filetype code
	mov	DI, OFFSET TRANGROUP:EXECPATH
	mov	SI, DS:arg.argv[0].argpointer
	mov	CX, DS:arg.argv[0].argstartel
	sub	CX, SI				; compute prefix bytes to copy
;
; We have the number of bytes in the prefix (up to the final component).
; We need to form the complete pathname including leading drive and current
; directory.
;
; Is there a drive letter present?
;
        cmp    word ptr [si], 05c5ch            ; If a UNC name, copy straight in
        je     CopyPath

        mov     ah,':'
	cmp	cx,2				; room for drive letter?
	jb	AddDrive			; no, stick it in
	cmp	[si+1],ah			; colon present?
	jz	MoveDrive			; yes, just move it

AddDrive:
	mov	al,curdrv			; get current drive
	add	al,"A"                          ; convert to uppercase letter
	stosw					; store d:
	jmp	short CheckPath

MoveDrive:
	lodsw					; move d:
	stosw
	sub	cx,2				; 2 bytes less to move

CheckPath:
	or	al,20h
	mov	dl,al
	sub	dl,"a"-1                        ; convert to 1-based for current dir
;
; Stick in beginning path char
;
	mov	al,psep_char
	stosb
;
; Is there a leading /?  If so, then no current dir copy is necessary.
; Otherwise, get current dir for DL.
;
	cmp	cx,1				; is there room for path char?
	jb	AddPath 			; no, go add path
	lodsb
	dec	cx
	cmp	al,psep_char			; is there a path separator?
	jz	MovePath			; yes, go move remainder of path
	inc	cx
	dec	si				; undo the lodsb

AddPath:
	SaveReg <SI>
	mov	si,di				; remainder of buffer
	trap	Current_dir
;
; The previous current dir will succeed a previous find_first already worked.
;
; Find end of string.
;
	mov	di,si
	RestoreReg  <SI>
	mov	al,psep_char
	cmp	byte ptr [di],0 		; root (empty dir string)?
	jz	MovePath			; yes, no need for path char

ScanEnd:
	cmp	byte ptr [dI],0 		; end of string?
	jz	FoundEnd
	inc	di
	jmp	ScanEnd
;
; Stick in a trailing path char
;
FoundEnd:
	stosb
;
; Move remaining part of path.	Skip leading path char if present.
;
MovePath:
	cmp	[si],al 			; first char a path char?
	jnz	CopyPath
	inc	si				; move past leading char
	dec	cx				; drop from count

CopyPath:
	jcxz	CopyDone			; no chars to move!
	rep	movsb

CopyDone:
	jmp	path_success			; run off and form complete pathname

path_noinit:
	test	DS:arg.argv[0].argflags, MASK path_sep
	jnz	path_failure			; complete pathname specified ==> fail

	mov	BH, path_sep_char		; semicolon terminates pathstring
	mov	DX, DS:arg.argv[0].argstartel	; this is where the last element starts
	sub	DX, DS:arg.argv[0].argpointer	; form pointer into EXECPATH,
	add	DX, OFFSET TRANGROUP:EXECPATH	; skipping over drive spec, if any

path_loop:
	call	path_crunch			; pcrunch(EXECPATH, pathinfo)
	mov	BP, AX				; save filetype code

	lahf					; save flags, just in case
	or	BP, BP				; did path_crunch find anything?
	jne	path_found
	sahf					; see?	needed those flags, after all!
	jnc	path_loop			; is there anything left to the path?

path_failure:
	xor	AX, AX
;;	jmp	short path_exit 		; 3/3/KK
	jmp	path_exit			;AC000;  3/3/KK

path_found:					; pathinfo[] points to winner
	mov	DI, OFFSET TRANGROUP:EXECPATH
	mov	CX, pathinfo[4] 		; "new" pointer -- end of string
	mov	SI, pathinfo[2] 		; "old" pointer -- beginning of string

;
;	BAS Nov 20/84
;   Look at the pathname and expand . and .. if they are the first element
;   in the pathname (after the drive letter)
;
	push	ES
	push	pathinfo[0]
	pop	ES
;SR;
; Oops! Gets fooled if path= \;..
; We should also check if a drive letter is really present
;
	cmp	Byte Ptr ES:[SI+2],'.'          ; Look for Current dir at start of path
	jnz	path_cpy

	cmp	byte ptr es:[si+1],':'		;does path have drive letter?
	jnz	path_cpy			;no, copy the path string

	push	CX				; Save pointer to end of string
	mov	AL, ES:[SI]
	mov	[DI],AL 			; Copy drive letter, :, and root char
	mov	AL, ES:[SI+1]			; to EXECPATH
	mov	[DI+1],AL
	mov	AL,psep_char
	mov	[DI+2],AL
	push	SI				; Save pointer to begining of string
	mov	DL,ES:[SI]			; Convert device letter for cur dir
	or	DL,20h
	sub	DL,"a"-1
	mov	SI,DI				; pointer to EXECPATH
	add	SI, 3				; Don't wipe out drive and root info
	trap	Current_dir
	invoke	DStrlen 			; Determine length of present info
	add	SI,CX				; Don't copy over drive and root info
	dec	SI
	mov	DI,SI				; Point to end of target string
	pop	SI				; Restore pointer to begining of string
	add	SI, 3				; Point past drive letter, :, .
	pop	CX				; Restore pointer to end of string

path_cpy:
	pop	ES
	sub	CX, SI				; yields character count
	push	DS				; time to switch segments
	push	pathinfo[0]			; string lives in this segment
	pop	DS
	cld
;;	rep	movsb	    3/3/KK		; copy the prefix path into EXECPATH

Kloop:						;AN000;  3/3/KK
	lodsb					;AN000;  3/3/KK
	stosb					;AN000;  3/3/KK
	invoke	testkanj			;AN000;  3/3/KK
	jz	NotKanj1			;AN000;  3/3/KK
	dec	cx				;AN000;  3/3/KK
	JCXZ	PopDone 			;AN000;  Ignore boundary error	 3/3/KK
	movsb					;AN000;  3/3/KK
	dec	cx				;AN000;  3/3/KK
	cmp	cx,1				;AN000;  One char (the terminator) left ? 3/3/KK
	ja	Kloop				;AN000;  no.			 3/3/KK

PopDone:					;AN000;  3/3/KK
	POP	DS				;AN000;  Yes ES:DI->terminator, last char is 3/3/KK
	mov	AL, psep_char			;AN000;       KANJI		  3/3/KK
	jmp	Short path_store		;AN000;  3/3/KK

NotKanj1:
	loop	Kloop
	pop	DS				; return to our segment
	dec	DI				; overwrite terminator
	mov	AL, psep_char			; with a pathname separator
	cmp	al,byte ptr [di-1]
	jz	path_success

path_store:					;AN000;  3/3/KK
	stosb

path_success:
	mov	SI, OFFSET TRANGROUP:search_best_buf
	xor	CX, CX

path_succ_loop:
	lodsb					; append winning filename to path
	stosb					; (including terminating null)
	or	al,al
	jnz	path_succ_loop
	mov	AX, BP				; retrieve filetype code

path_exit:
	popf
	pop	BP
	pop	DI
	pop	SI				; chill out...
	pop	DX
	pop	CX
	pop	BX
	ret
EndProc Path_Search

break <Store_Pchar>
;----------------------------------------------------------------------------
;   STORE_PCHAR determines the pathname-element separator and squirrels
; it away.  In other words, must we say '/bin/ls' or '\bin\ls'?
; ENTRY:
; EXIT:
; NOTE(S):
;   *	Uses <psep_char>, defined in <path_search>.
;---------------
;---------------
Procedure   Store_PChar,NEAR
;---------------
	assume	ds:trangroup, es:trangroup

	push	AX
	mov	AL, '/'                         ; is the pathname-element separator
	invoke	pathchrcmp			; a regular slash?
	jz	store_slash			; if yes, remember slash
	mov	al,'\'
	mov	[psep_char], al 		; otherwise, remember back-slash
	pop	ax
	ret

store_slash:
	mov	[psep_char], al
	pop	ax
	return
;---------------
EndProc Store_Pchar
;----------------------------------------------------------------------------

break <Path_Crunch>
;----------------------------------------------------------------------------
; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
; EXECPATH, and smooshes them into tpbuf.  The caller may supply an
; additional separator to use for breaking up the path-string.	Null is the
; default.  Once the user-string has been formed, search is invoked to see
; what's out there.
; ENTRY:
;   BH			--	additional terminator character
;   SI			--	pointer into pathstring to be dissected
;   DX			--	pointer to stripped filename
; EXIT:
;   AX			--	non-zero (file type), zero (nothing found)
;   SI			--	moves along pathstring from call to call
;   [search_best_buf]	--	name of best file (AX non-zero)
;   [tpbuf]		--	clobbered
; NOTE(S):
;   *	Implicit in this code is the ability to specify when to search
;	the current directory (if at all) through the PATH defined by
;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
;	current directory before the bin and etc directories of drive c).
;---------------
Procedure   Path_Crunch,NEAR
;---------------
	assume	ds:trangroup, es:trangroup
	push	BX
	push	CX
	push	DX
	push	DI
	push	SI
	pushf
	call	store_pchar			; figure out pathname separator
	mov	DI, OFFSET TRANGROUP:tpbuf	; destination of concatenated string
	mov	SI, pathinfo[4] 		; "new" pointer to start with
	mov	pathinfo[2], SI 		; becomes "old" pointer
	push	DS				; save old segment pointer
	push	pathinfo[0]			; replace with pointer to userpath's
	pop	DS				; segment
	xor	cl,cl				;AN000;  clear flag for later use 3/3/KK

path_cr_copy:
	lodsb					; get a pathname byte
	or	al,al				; check for terminator(s)
	jz	path_seg			; null terminates segment & pathstring
	cmp	AL, BH
	jz	path_seg			; BH terminates a pathstring segment
	invoke	testkanj			;AN000;  3/3/KK
	jz	NotKanj2			;AN000;  3/3/KK
	stosb					;AN000;  3/3/KK
	movsb					;AN000;  3/3/KK
	MOV	CL,1				;AN000;  CL=1 means latest stored char is DBCS 3/3/KK
	jmp	path_cr_copy			;AN000;  3/3/KK

NotKanj2:					;AN000;  3/3/KK
	xor	cl,cl				;AN000;  CL=0 means latest stored char is SBCS 3/3/KK
	stosb					; save byte in concat buffer
	jmp	path_cr_copy			; loop until we see a terminator

path_seg:
	pop	DS				; restore old data segment
	mov	pathinfo[4], SI 		; save "new" pointer for next time
	mov	BL, AL				; remember if we saw null or not...
						;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
	xor	AX, AX				; in case nothing in pathstr...
	cmp	DI, OFFSET TRANGROUP:tpbuf	; was there really anything in pathstr?
	je	path_cr_leave			; if nothing was copied, pathstr empty

path_cr_look:					; form complete pathname
	mov	al, psep_char			; add pathname separator for suffix
	or	cl,cl				;AN000;  3/3/KK
	jnz	path_cr_store			;AN000;  this is a trailing byte of ECS code 3/3/KK
	cmp	al,byte ptr [di-1]
	jz	path_cr_l1

path_cr_store:					;AN000;  3/3/KK
	stosb

path_cr_l1:
	mov	SI, DX

path_cr_l2:
	lodsb					; tack the stripped filename onto
	stosb					; the end of the path, up to and
	or	AL, AL				; including the terminating null
	jnz	path_cr_l2
	mov	DX, OFFSET TRANGROUP:tpbuf	; and look for an appropriate file...
	mov	[search_error], OFFSET TRANGROUP:BADPMES_ptr
	invoke	search				; results are in AX & search_best_buf

path_cr_leave:
	or	BL, BL				; did we finish off the pathstring?
	jz	path_cr_empty			; null in BL means all gone...
	popf					; otherwise, plenty left
	clc
	jmp	short path_cr_exit

path_cr_empty:
	popf
	stc

path_cr_exit:
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	ret
;---------------
EndProc Path_Crunch
;----------------------------------------------------------------------------


trancode    ends
END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\rdata.asm ===
page ,132
    title   COMMAND Resident DATA
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;   Revision History
;   ================
;   M003    SR  07/16/90    Added LoadHiFlg for LoadHigh support
;
;   M004    SR  07/17/90    Transient is now moved to its final
;               location at EndInit time by allocating
;               the largest available block, moving
;               the transient to the top of the block
;               and then freeing up the block.
;
;   M027    SR  9/20/90 Fixed bug #2827. EndInit was using
;               INIT seg variables after INIT seg
;               had been freed.
;
;   M036    SR  11/1/90 Free up environment segment passed
;               by Exec always.
;

.xlist
.xcref
    include dossym.inc
    include pdb.inc
    include syscall.inc
    include comsw.asm
    include comseg.asm
    include resmsg.equ
    include comequ.asm
    include cmdsvc.inc
.list
.cref

;   Equates for initialization (from COMEQU)
;
;   Bugbug:  Toss these after putting ctrl-c handler in init module.

INITINIT    equ     01h         ; initialization in progress
INITSPECIAL equ     02h         ; in initialization time/date routine
INITCTRLC   equ     04h         ; already in ^C handler


CODERES segment public byte
    extrn   Ext_Exec:near
    extrn   MsgRetriever:far
    extrn   TRemCheck:near

;SR;
; The stack has no right to be in the code segment. Moved it to DATARES
;
;   bugbug: Why this odd stack size?  And what should stack size be?
;;  db  (80h - 3) dup (?)
;;RStack    label   word
;;  public  RStack
CODERES ends

INIT    segment

    extrn   ConProc:near
    extrn   Chuckenv:byte
    extrn   UsedEnv:word
    extrn   OldEnv:word
    extrn   EnvSiz:word
    extrn   TrnSize:word        ; M004

INIT    ends

TAIL    segment

    extrn   TranStart   :word

TAIL    ends

TRANCODE    segment public byte
    extrn   Command:near
TRANCODE    ends

TRANSPACE   segment

    extrn   TranSpaceEnd    :byte

TRANSPACE   ends

;SR;
; All the routines below are entry points into the stub from the transient.
;The stub will then transfer control to the appropriate routines in the
;resident code segment, wherever it is present.
;

DATARES segment

    extrn   Exec_Trap   :near
    extrn   RemCheck_Trap   :near
    extrn   MsgRetrv_Trap   :near
    extrn   HeadFix_Trap    :near
    extrn   Issue_Exec_Call :near

DATARES ends


DATARES segment public byte
    assume  cs:DATARES
    Org 0
ZERO    =   $

;;  Org 100h
;;ProgStart:
;;  jmp RESGROUP:ConProc

    public  Abort_Char
    public  Append_Flag
    public  Append_State
    public  BadFatSubst
    public  Batch
    public  Batch_Abort
    public  BlkDevErrRw
    public  BlkDevErrSubst
    public  Call_Batch_Flag
    public  Call_Flag
    public  CDevAt
    public  CharDevErrSubst
    public  CharDevErrRw
    public  Com_Fcb1
    public  Com_Fcb2
    public  Com_Ptr
    public  ComDrv
    public  ComSpec
    public  ComSpec_End
    public  Crit_Err_Info
    public  Crit_Msg_Off
    public  Crit_Msg_Seg
    public  CritMsgPtrs
    public  DataResEnd
    public  Dbcs_Vector_Addr
    public  DevName
    public  DrvLet
    public  EchoFlag
    public  EnvirSeg
    public  ErrCd_24
    public  ErrType
    public  Exec_block
    public  ExecErrSubst
    public  Extcom
    public  ExtMsgEnd
    public  Fail_Char
    public  fFail
    public  ForFlag
    public  ForPtr
    public  FUCase_Addr
    public  Handle01
    public  IfFlag
    public  Ignore_Char
    public  In_Batch
    public  InitFlag
    public  InPipePtr
    public  Int_2e_Ret
    public  Int2fHandler
    public  Io_Save
    public  Io_Stderr
    public  LenMsgOrPathBuf
    public  Loading
    public  LTpa
    public  MemSiz
    public  MsgBuffer
    public  MsgPtrLists
    public  MySeg
    public  MySeg1
    public  MySeg2
    public  MySeg3
    public  NeedVol
    public  NeedVolSubst
    public  Nest
    public  Next_Batch
    public  No_Char
    public  NullFlag
    public  NUMEXTMSGS
    public  NUMPARSMSGS
    public  OldErrNo
    public  OldTerm
    public  OutPipePtr
    public  Parent
    public  ParsMsgPtrs
    public  PermCom
    public  Pipe1
;;; public  Pipe1T
    public  Pipe2
;;; public  Pipe2T
    public  PipeFiles
    public  PipeFlag
    public  PipePtr
    public  PipeStr
    public  KSwitchFlag
    public  PutBackComSpec
    public  PutBackDrv
    public  PutBackSubst
    public  RDirChar
    public  Re_Out_App
    public  Re_OutStr
    public  ResMsgEnd
    public  Res_Tpa
    public  RestDir
    public  ResTest
    public  RetCode
    public  Retry_Char
    public  RSwitChar
    public  SafePathBuffer      ; MSKK01 07/14/89
    public  Save_Pdb
    public  SingleCom
    public  Sum
    public  Suppress
    public  Trans
    public  TranVarEnd
    public  TranVars
    public  TrnSeg
    public  TrnMvFlg
    public  VerVal
    public  VolName
    public  VolSer
    public  Yes_Char

    public  ResSize
    public  RStack
    public  OldDS


    public  LoadHiFlg       ;For LoadHigh support ; M003
    public  SCS_Is_First
    public  SCS_REENTERED
    public  SCS_FIRSTCOM

    public  SCS_PAUSE
        public  SCS_CMDPROMPT
        public  SCS_DOSONLY
        public  SCS_PROMPT16
        public  SCS_FIRSTTSR
        public  RES_RDRINFO
        public  RES_BATSTATUS

    extrn   LodCom_Trap:near
    extrn   Alloc_error:near


;***    Message substitution blocks


BlkDevErrSubst  label   byte
BlkDevErrRw subst   <STRING,>       ; "reading" or "writing"
        subst   <CHAR,DATARES:DrvLet>   ; block device drive letter

DrvLet      db  'A'         ; drive letter


CharDevErrSubst label   byte
CharDevErrRw    subst   <STRING,>         ; "reading" or "writing"
CharDevErrDev   subst   <STRING,DATARES:DevName> ; character device name

DevName     db  8 dup (?),0       ; device name, asciiz


NeedVolSubst    label   byte
        subst   <STRING,DATARES:VolName>    ; volume name
        subst   <HEX,DATARES:VolSer+2>      ; hi word of serial #
        subst   <HEX,DATARES:VolSer>        ; lo word of serial #

;       NOTE:   VolName and VolSer must be adjacent
VolName     db  11 dup (?),0        ; volume name
VolSer      dd  0           ; volume serial #


CDevAt      db  ?


BadFatSubst label   byte
        subst   <CHAR,DATARES:DrvLet>   ; drive letter


PutBackSubst    label   byte
PutBackComSpec  subst   <STRING,>           ; comspec string
        subst   <CHAR,DATARES:PutBackDrv>   ; drive to put it in

PutBackDrv  db  ' '         ; drive letter


ExecErrSubst    subst   <STRING,DATARES:SafePathBuffer>


NeedVol     dd  ?   ; ptr to volume name from get ext err
ErrType     db  ?   ; critical error message style, 0=old, 1=new

Int_2e_Ret  dd  ?   ; magic command executer return address
Save_Pdb    dw  ?
Parent      dw  ?
OldTerm     dd  ?
ErrCd_24    dw  ?
Handle01    dw  ?
Loading     db  0
Batch       dw  0   ; assume no batch mode initially

;;;;SR;
;;;; This flag has been added for a gross hack introduced in batch processing.
;;;;We use it to indicate that this batch file has no CR-LF before EOF and that
;;;;we need to fake the CR-LF for the line to be properly processed
;;;;
;;;BatchEOF     db  0

;       Bugbug: ComSpec should be 64+3+12+1?
;       What's this comspec_end about?
ComSpec     db  64 dup (0)
ComSpec_End dw  ?

Trans       label   dword
        dw  TRANGROUP:Command
TrnSeg      dw  ?

TrnMvFlg    db  0   ; set if transient portion has been moved

In_Batch    db  0   ; set if we are in batch processing mode
Batch_Abort db  0   ; set if user wants to abort from batch mode

ComDrv      db  ?   ; drive spec to load autoexec and command
MemSiz      dw  ?
Sum     dw  ?
ExtCom      db  1   ; for init, pretend just did an external
RetCode     dw  ?
Crit_Err_Info   db  ?   ; hold critical error flags for r,i,f


; The echo flag needs to be pushed and popped around pipes and batch files.
; We implement this as a bit queue that is shr/shl for push and pop.

EchoFlag    db  00000001b   ; low bit true => echo commands
Suppress    db  1       ; used for echo, 1=echo line
Io_Save     dw  ?
Io_Stderr   db  ?
RestDir     db  0
PermCom     db  0       ; true => permanent command
SingleCom   dw  0       ; true => single command version
KSwitchFlag db  0
VerVal      dw  -1
fFail       db  0       ; true => fail all int 24s
IfFlag      db  0       ; true => IF statement in progress

ForFlag     db  0       ; true => FOR statement in progress
ForPtr      dw  0

Nest        dw  0       ; nested batch file counter
Call_Flag   db  0       ; no CALL (batch command) in progress
Call_Batch_Flag db  0
Next_Batch  dw  0       ; address of next batch segment
NullFlag    db  0       ; flag if no command on command line
FUCase_Addr db  5 dup (0)   ; buffer for file ucase address
; Bugbug: don't need crit_msg_ anymore?
Crit_Msg_Off    dw  0       ; saved critical error message offset
Crit_Msg_Seg    dw  0       ; saved critical error message segment
Dbcs_Vector_Addr dw 0       ; DBCS vector offset
         dw 0       ; DBCS vector segment

Append_State    dw  0       ; current state of append
                    ;  (if Append_Flag is set)
Append_Flag db  0       ; set if append state is valid

SCS_PAUSE   db  0       ; yst 4-5-93

Re_Out_App  db  0
Re_OutStr   db  64+3+13 dup (?)
SCS_Is_First    db  1
SCS_REENTERED   db  0
SCS_FIRSTCOM    db  0
SCS_CMDPROMPT   db      0               ; means on TSR/Shell out use command.com
SCS_DOSONLY     db      0               ; means by default run all binaries
                                        ; when at command.com prompt. if 1 means
                                        ; allow only dos binaries.
SCS_PROMPT16    db      0
SCS_FIRSTTSR    db      1
RES_RDRINFO     DD      0
RES_BATSTATUS   db      0

; We flag the state of COMMAND in order to correctly handle the ^Cs at
; various times.  Here is the breakdown:
;
;   INITINIT    We are in the init code.
;   INITSPECIAL We are in the date/time prompt
;   INITCTRLC   We are handling a ^C already.
;
; If we get a ^C in the initialization but not in the date/time prompt, we
; ignore the ^C.  This is so the system calls work on nested commands.
;
; If we are in the date/time prompt at initialization, we stuff the user's
; input buffer with a CR to pretend an empty response.
;
; If we are already handling a ^C, we set the carry bit and return to the user
; (ourselves).  We can then detect the carry set and properly retry the
; operation.

InitFlag    db  INITINIT

; Note:  these two bytes are referenced as a word
PipeFlag    db  0
PipeFiles   db  0

;--- 2.x data for piping
;
; All the "_" are substituted later, the one before the : is substituted
; by the current drive, and the others by the CreateTemp call with the
; unique file name. Note that the first 0 is the first char of the pipe
; name. -MU
;
;--- Order-dependent, do not change

;;;Pipe1        db  "_:/"
;;;Pipe1T       db  0
;;;     db  "_______.___",0
;;;Pipe2        db  "_:/"
;;;Pipe2T       db  0
;;;     db  "_______.___",0

;SR
; Pipe1 & Pipe2 now need to store full-fledged pathnames
;

; Bugbug:  can we find any way around maintaining these
; large buffers?

Pipe1       db  67+12 dup (?)
Pipe2       db  67+12 dup (?)

PipePtr     dw  ?

PipeStr     db  129 dup (?)

EndPipe label   byte            ; marks end of buffers; M004

;SR;
; We can move our EndInit code into above buffers. This way, the code will
;automatically be discarded after init.
;
; M004; We overlap our code with the Pipe buffers located above by changing
; M004; the origin.
;
    ORG Pipe1           ; M004

; Bugbug:  really need a procedure header for EndInit, describing
; what it expects, what it does.

Public  EndInit
EndInit:
    push    ds
    push    es          ;save segments
    push    cs
    pop ds
    assume  ds:RESGROUP

;
; M004; Save size of transient here before INIT segment is deallocated
;
    mov dx,TrnSize      ; M004
;M027
; These variables are also defined in the INIT segment and need to be saved
;before we resize
;
    mov ax,OldEnv       ; Old Environment seg ;M027
    mov bx,EnvSiz       ; Size of new environment ;M027
    mov cx,UsedEnv      ; Size of old environment ;M027
    push    ax          ; Save all these values ;M027
    push    bx          ; M027
    push    cx          ; M027


; Bugbug:  push ds, pop es here.
    mov bx,ds
    mov es,bx           ;es = RESGROUP
;
;ResSize is the actual size to be retained -- only data for HIMEM COMMAND,
; code + data for low COMMAND
;
    mov bx,ResSize      ;Total size of resident
    mov ah,SETBLOCK
    int 21h         ;Set block to resident size
;
;We check if this is for autoexec.bat (PermCom = 1). If so, we then
;allocate a new batch segment, copy the old one into new batchseg and free
;the old batchseg. Remember that the old batchseg was allocated on top of the
;transient and we will leave a big hole if TSRs are loaded by autoexec.bat
;
; Bugbug:  also describe why we alloc & copy batch seg BEFORE environment.
    cmp PermCom,1       ;permanent command.com?
    jne adjust_env      ;no, do not free batchseg

    cmp Batch,0         ;was there a valid batchseg?
    je  adjust_env      ;no, dont juggle

; NTVDM temp name of the batch file may be up to 63 bytes, plus NULL
;        mov     bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16 ;batchseg size
        mov     bx,((SIZE BatchSegment) + 64 + 1 + 0fh)/16 ;batchseg size
    mov ah,ALLOC
    int 21h
; Bugbug:  I just had a thought.  If DOS or SHARE or somebody leaves
; a hole, the batch segment COULD already be in the ideal place.  We
; could be making it worse!  We're second-guessing where memory
; allocations go, which might not be such a great idea.  Is there
; a strategy, short of doing something even worse like diddling
; arena headers, where we can minimize the possibility of fragmentation
; under all cases?  Hmm..
    jc  adjust_env      ;no memory, use old batchseg
    mov es,ax           ;es = New batch segment
    xor di,di
    xor si,si

    push    ds
    mov ds,Batch        ;ds = Old Batch Segment
    assume  ds:nothing
        mov     cx,SIZE BatchSegment
; NTVDM temp name of the batch file may be up to 63 bytes, plus NULL
;       add     cx,16                   ;for the filename
        add     cx,64
    ; Bugbug: 16?  Shouldn't this be a common equate or something?
    ; It's sure be bad if we copied more bytes than the batch segment
    ; holds!
    cld
    rep movsb
    pop ds
    assume  ds:RESGROUP

    mov cx,es           ;save new batch segment
    mov es,Batch
    mov ah,DEALLOC
    int 21h         ;free the old batch segment
    ; Bugbug:  should we check for error?

    mov Batch,cx        ;store new batch segment address

adjust_env:
    pop cx          ;cx = size of old env ;M027
    pop bx          ;bx = size of new env needed ;M027
    pop bp          ;bp = old env seg ;M027

;
;Allocate the correct size for the environment
;
    mov ah,ALLOC
    int 21h         ;get memory
    jc  init_env_err        ;out of memory,signal error

    ; Bugbug:  why not continue, leaving environment where it is?

    mov EnvirSeg,ax     ;Store new environment segment
    mov ds:PDB_Environ,ax       ;Put new env seg in PSP
    mov es,ax           ;es = address of allocated memory
    assume  es:nothing

    cmp PermCom, 1
    jne copy_old_env

;
; First get the size of 32bit env
;

    push bx
    mov bx, 0
    CMDSVC  SVC_GETINITENVIRONMENT
    mov ax, bx
    pop  bx
    cmp ax, 0           ;bx returns 0, use old environment
    je  copy_old_env

;
; now compute the new size
;   [ax] = size of 32 bit env
;

    add bx, ax
    mov ah, DEALLOC     ;free the block
    int 21h
    mov ah, ALLOC       ;and get a new block(don't use realloc please)
    int 21h
    jc  nomem_err

    mov EnvirSeg,ax     ;Store new environment segment
    mov ds:PDB_Environ,ax       ;Put new env seg in PSP
    mov es,ax           ;es = address of allocated memory
    mov EnvSiz, bx      ;new size
    push bx
    CMDSVC  SVC_GETINITENVIRONMENT  ;get new environment
    pop ax
    cmp bx, ax
    jbe adjust_env_done
init_env_err:
    jmp short nomem_err
copy_old_env:
;
;Copy the environment to the newly allocated segment
;
    push ds
    mov  ds, bp           ;ds = Old environment segment
    assume ds:nothing

    xor si,si
    mov di,si           ;Start transfer from 0

    cld
    rep movsb           ;Do the copy

    pop ds          ;ds = RESGROUP
    assume  ds:RESGROUP
adjust_env_done:

;
;We have to free the old environment block if it was allocated by INIT
;
; Bugbug:  is this only for the case when we were NOT passed an environment,
; or does it also apply to passed environments?
;M036
; Free up old env segment always because this is a copy passed by Exec and
;takes up memory that is never used
;
;M044
;Go back to the old strategy of not freeing the environment. Freeing it leaves
;a hole behind that Ventura does not like. Basically, Ventura gives strange
;errors if it gets a memory alloc that it is below its load segment. The
;freed environment creates a large enough hole for some of its allocs to fit
;in
;
    cmp Chuckenv,0      ;has env been allocated by INIT?
    jne no_free     ;no, do not free it

    mov es,bp
    mov ah,DEALLOC
    int 21h         ;Free it
no_free:

;
; M004; Start of changes
;

;
; Move the transient now. We will allocate the biggest block available
; now and move the transient to the top of the block. We will then
; deallocate this block. When the resident starts executing, it will
; hopefully allocate this block again and find the transient intact.
;
    MOV TrnMvFlg, 1         ; Indicate that transient has been moved
    push    es
    mov si,offset ResGroup:TranStart
    mov di,0
    mov cx,offset TranGroup:TranSpaceEnd ;size to move
;
; Find the largest block available
;
    mov bx,0ffffh
    mov ah,ALLOC
    int 21h

;
; dx = size of transient saved previously
;
    cmp bx,dx           ;enough memory?
    jb  nomem_err       ;not enough memory for transient

    mov ah,ALLOC
    int 21h         ;get the largest block
    jc  nomem_err       ;something is really messed up

    push    ax          ;save memory address
    add ax,bx           ;ax = top of my memory block
    sub ax,dx           ;less size of transient
    mov TrnSeg,ax       ;save transient segment
    mov es,ax           ;
    pop ax          ;restore our seg addr

;
; Everything is set for a move. We need to move in the reverse direction to
; make sure we dont overwrite ourselves while copying
;
    add si,cx
    dec si
    add di,cx
    dec di
    std
    rep movsb
    cld
;
; Now we have to free up this block so that resident can get hold of it
;
    mov es,ax
    mov ah,DEALLOC
    int 21h         ;release the memory block

;
; M004; End of changes
;

    mov InitFlag,FALSE      ;indicate INIT is done

    pop es
    pop ds
    ; Bugbug:  did we need to save & restore seg reg's during EndInit?
    assume  ds:nothing

    jmp LodCom_Trap     ;allocate transient

nomem_err:
;
;We call the error routine which will never return. It will either exit
;with an error ( if not the first COMMAND ) or just hang after an error
;message ( if first COMMAND )
;

    jmp Alloc_error

public EndCodeInit          ; M004
EndCodeInit label   byte        ; M004

;
; M004; Check if the EndInit code will fit into the Pipe buffers above.
; M004; If not, we signal an assembly error
;
IF2
    IF ($ GT EndPipe)
        .err
        %out    "ENDINIT CODE TOO BIG"
    ENDIF
ENDIF
;
; M004; Set the origin back to what it was at the end of the buffers
;
        ORG EndPipe     ; M004



InPipePtr   dw  offset DATARES:Pipe1
OutPipePtr  dw  offset DATARES:Pipe2

Exec_Block  label   byte        ; the data block for exec calls
EnvirSeg    dw  ?
Com_Ptr     label   dword
        dw  80h     ; point at unformatted parameters
        dw  ?
Com_Fcb1    label   dword
        dw  5Ch
        dw  ?
Com_Fcb2    label   dword
        dw  6Ch
        dw  ?

;       variables passed to transient
TranVars    label   byte
        dw  offset DATARES:HeadFix_Trap
MySeg       dw  0       ; put our own segment here
LTpa        dw  0       ; will store tpa segment here
RSwitChar   db  "/"
RDirChar    db  "\"
        dw  offset DATARES:Issue_Exec_Call
MySeg1      dw  ?
        dw  offset DATARES:RemCheck_Trap
MySeg2      dw  0
ResTest     dw  0
Res_Tpa     dw  0       ; original tpa (not rounded to 64k)
TranVarEnd  label   byte

OldErrNo    dw  ?


;*      NOTE:  MsgBuffer and SafePathBuffer use the same
;       memory.  MsgBuffer is only used while a command
;       is being executed.  SafePathBuffer is no longer
;       needed, since it is used for unsuccessful program
;       launches.

MsgBuffer   label   byte        ; buffer for messages from disk
SafePathBuffer  label   byte        ; resident pathname for EXEC
;                db      128 dup (0)     ; path + 'd:\' 'file.ext' + null
                 db      EXECPATHLEN dup (0)    ; MAX_PATH+13 ntvdm extended
LenMsgOrPathBuf equ $ - MsgBuffer


Int2fHandler    dd  ?   ; address of next int 2f handler
ResMsgEnd   dw  0   ; holds offset of msg end (end of resident)

;SR;
; The three vars below have been added for a pure COMMAND.COM
;

ResSize     dw  ?

;SR;
; Moved the stack here from the code segment
;
;   bugbug: Why this odd stack size?  And what should stack size be?
    db  (80h - 3) dup (?)
RStack  label   word

OldDS       dw  ?   ;keeps old ds value when jumping to
                ;resident code segments

LoadHiFlg   db  0   ;Flag set to 1 if UMB loading enabled ; M003

ifdef   BETA3WARN
    %out    Take this out before we ship
public  Beta3Warned
Beta3Warned db  0
endif

;***    MESSAGES
;   and other translatable text

    include comrmsg.inc ;M00

DATARES ends
    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\path2.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)path2.asm	1.1 85/05/14
;	SCCSID = @(#)path2.asm	1.1 85/05/14
.sall
.xlist
.xcref
	include dossym.inc
	include syscall.inc
	include find.inc
	include comsw.asm
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES SEGMENT PUBLIC BYTE
	EXTRN	FORFLAG:BYTE
DATARES ENDS


break <Path.Asm>
;----------------------------------------------------------------------------
;    PATH.ASM contains the routines to perform pathname incovation.  Path and
;    Parse share a temporary buffer and argv[] definitions.  <Path_Search>,
;    given a pathname, attempts to find a corresponding executable or batch
;    file on disk.  Directories specified in the user's search path will be
;    searched for a matching file, if a match is not found in the current
;    directory and if the pathname is actually only an MSDOS filename.
;    <Path_Search> assumes that the parsed command name can be found in
;    argv[0] -- in other words, <Parseline> should be executed prior to
;    <Path_Search>.  Alternatively, the command name and appropriate
;    information could be placed in argv[0], or <Path_Search> could be
;    (easily) modified to make no assumptions about where its input is found.
;    Please find enclosed yet another important routine, <Save_Args>, which
;    places the entire arg/argv[]/argbuf structure on a piece of newly
;    allocated memory.	This is handy for for-loop processing, and anything
;    else that wants to save the whole shebang and then process other command
;    lines.
;
; Alan L, OS/MSDOS				    August 15, 1983
;
; ENTRY:
;   <Path_Search>:	    argv[0].
;   <Save_Args>:	    bytes to allocate in addition to arg structure
; EXIT:
;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
;   <Save_Args>:	    success flag, segment address of new memory
; NOTE(S):
;   *	<Argv_calc> handily turns an array index into an absolute pointer.
;	The computation depends on the size of an argv[] element (arg_ele).
;   *	<Parseline> calls <cparse> for chunks of the command line.  <Cparse>
;	does not function as specified; see <Parseline> for more details.
;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
;	need to know about.  This extra information is stored in a switch_flag
;	word with each command-line argument; the switches themselves will not
;	appear in the resulting arg structure.
;   *	With the exception of CARRY, flags are generally preserved across calls.
;---------------
; CONSTANTS:
;---------------
    DEBUGx	equ	    FALSE	; prints out debug info
;---------------
; DATA:
;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte
	EXTRN	BADPMES_ptr:word
	EXTRN	curdrv:byte
	EXTRN	EXECPATH:byte
	EXTRN	ext_entered:byte	;AN005;
	EXTRN	fbuf:byte
	EXTRN	pathinfo:word
	EXTRN	psep_char:byte
	EXTRN	string_ptr_2:word
	EXTRN	tpbuf:byte
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE	;AC000;

assume cs:trangroup, ds:trangroup, es:trangroup, ss:nothing

break <Search>
;----------------------------------------------------------------------------
;   SEARCH, when given a pathname, attempts to find a file with
; one of the following extensions:  .com, .exe, .bat (highest to
; lowest priority).  Where conflicts arise, the extension with
; the highest priority is favored.
; ENTRY:
;   DX		--	pointer to null-terminated pathname
;   fbuf	--	dma buffer for findfirst/next
; EXIT:
;   AX		--	8)  file found with .com extension
;			4)  file found with .exe extension
;			2)  file found with .bat extension
;			0)  no such file to be found
;   (if AX is non-zero:)
;   [search_best]	identical to AX
;   [search_best_buf]	null-terminated filename
; NOTES:
;   1)	Requires caller to have allocated a dma buffer and executed a setdma.
;---------------
; CONSTANTS:
;---------------
search_file_not_found	    equ 	0
search_com		    equ 	8
search_exe		    equ 	4
search_bat		    equ 	2
fname_len		    equ 	8
fname_max_len		    equ 	13
dot			    equ 	'.'
wildchar		    equ 	'?'

;---------------
; DATA:
;---------------
TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	search_best:byte
	EXTRN	search_best_buf:byte
	EXTRN	search_curdir_buf:byte
	EXTRN	search_error:word
TRANSPACE	ENDS

;---------------
Procedure   Search,NEAR
;---------------
	assume	ds:trangroup, es:trangroup
	push	CX
	push	DX
	push	DI
	push	SI
	pushf

	push	DX				; check drivespec (save pname ptr)
	mov	DI, DX				; working copy of pathname
	mov	SI, OFFSET TRANGROUP:search_curdir_buf
	xor	DX, DX				; zero means current drive
	cmp	BYTE PTR [DI+1],':'             ; is there a drive spec?
	jne	search_dir_check
	mov	DL, [DI]			; get the drive byte
	and	DL, NOT 20H			; uppercase it
	sub	DL, '@'                         ; and convert to drive number

search_dir_check:
	trap	Current_Dir			; can we get the drive's current
	pop	DX				; directory?  If we can't we'll
	jc	search_invalid_drive		; assume it's a bad drive...

	mov	CX, search_attr 		; filetypes to search for
	trap	Find_First			; request first match, if any
	jc	search_no_file
	mov	search_best, search_file_not_found
	mov	[search_best_buf], ANULL	; nothing's been found, yet

search_loop:
	call	search_ftype			; determine if .com, &c...
	cmp	AL, search_best 		; better than what we've found so far?
	jle	search_next			; no, look for another
	mov	search_best, AL 		; found something... save its code
	mov	SI, OFFSET TRANGROUP:fbuf.find_buf_pname
	mov	DI, OFFSET TRANGROUP:search_best_buf
	mov	CX, fname_max_len
	cld
	rep	movsb				; save complete pathname representation
	cmp	AL, search_com			; have we found the best of all?
	je	search_done

search_next:					; keep on looking
	mov	CX, search_attr
	trap	Find_Next			; next match
	jnc	search_loop

search_done:					; it's all over with...
	mov	AL, search_best 		; pick best to return with
	cmp	ext_entered,1			;AN005; Did user request a specific ext?
	jz	search_exit			;AN005; no - exit
	mov	al,ext_entered			;AN005; yes - get the real file type back
	mov	search_best,al			;AN005; save the real file type
	jmp	short search_exit

search_invalid_drive:				; Tell the user path/drive
	mov	DX, [search_error]		; appropriate error message
	invoke	std_printf			; and pretend no file found

search_no_file: 				; couldn't find a match
	mov	AX, search_file_not_found

search_exit:
	popf
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	ret
;---------------
EndProc Search
;----------------------------------------------------------------------------


break <Search_Ftype>
;----------------------------------------------------------------------------
;   SEARCH_FTYPE determines the type of a file by examining its extension.
; ENTRY:
;   fbuf    --	    dma buffer containing filename
; EXIT:
;   AX	    --	    file code, as given in search header
; NOTE(S):
;   *	Implicit assumption that NULL == search_file_not_found
;---------------
; DATA:
;---------------
TRANDATA	SEGMENT PUBLIC BYTE		;AC000;
	extrn	comext:byte,exeext:byte,batext:byte
trandata     ends
;---------------
Procedure   Search_Ftype,NEAR
;---------------
	assume	ds:trangroup, es:trangroup
	push	DI
	push	si
	mov	AX, ANULL			; find the end of the filename
	mov	DI, OFFSET TRANGROUP:fbuf.find_buf_pname
	mov	CX, fname_max_len
	cld
	repnz	scasb				; search for the terminating null
	jnz	ftype_exit			; weird... no null byte at end
	sub	di,5				; . + E + X + T + NULL
;
; Compare .COM
;
	mov	si,offset trangroup:comext
	mov	ax,di
	cmpsw
	jnz	ftype_exe
	cmpsw
	jnz	ftype_exe
	mov	AX, search_com			; success!
	jmp	short ftype_exit
;
; Compare .EXE
;

ftype_exe:					; still looking... now for '.exe'
	mov	di,ax
	mov	si,offset trangroup:exeext
	cmpsw
	jnz	ftype_bat
	cmpsw
	jnz	ftype_bat
	mov	AX, search_exe			; success!
	jmp	short ftype_exit
;
; Compare .BAT
;

ftype_bat:					; still looking... now for '.bat'
	mov	di,ax
	mov	si,offset trangroup:batext
	cmpsw
	jnz	ftype_fail
	cmpsw
	jnz	ftype_fail
	mov	AX, search_bat			; success!
	jmp	short ftype_exit

ftype_fail:					; file doesn't match what we need
	mov	ax,ANULL

ftype_exit:
	cmp	ext_entered,1			;AN005; was an extension entered?
	jz	ftype_done			;AN005; no - exit
	cmp	ax,ANULL			;AN005; was any match found
	jz	ftype_done			;AN005; no - exit
	mov	ext_entered,al			;AN005; save the match type found
	mov	AX, search_com			;AN005; send back best was found to stop search

ftype_done:					;AN005;
	pop	SI
	pop	DI
	ret

;---------------
EndProc Search_Ftype
;----------------------------------------------------------------------------


break <Strip>
;----------------------------------------------------------------------------
;    STRIP copies the source string (argv[0]) into the destination buffer,
; replacing any extension with wildcards.
; ENTRY:
;	BX		--		maximum length of destination buffer
;	DS:SI		--		address of destination buffer
;	argv[0] 	--		command name to be stripped
; EXIT:
;	CF		--		set if failure, clear if successful
; NOTE(S):
;---------------
Procedure   Strip,NEAR
;---------------
	assume	ds:trangroup, es:trangroup
	push	AX
	push	BX
	push	CX
	push	DX
	push	DI
	push	SI
	pushf

	mov	ext_entered,1			;AN005; assume no extension on file name
	mov	DX, DS:arg.argv[0].argpointer	; save pointer to beginning of argstring
	mov	DI, DS:arg.argv[0].argstartel	; beginning of last pathname element
	cmp	BYTE PTR [DI], 0		; *STARTEL == NULL means no command
	jz	strip_error
	mov	CX, DX				; compute where end of argstring lies
	add	CX, DS:arg.argv[0].arglen
	sub	CX, DI				; and then find length of last element
	inc	CX				; include null as well
	mov	AL, dot 			; let's find the filetype extension
	cld
	repnz	scasb				; wind up pointing to either null or dot
	jcxz	process_ext			;AN005; if no extension found, just continue
	mov	ext_entered,0			;AN005; we found an extension
	mov	al,ANULL			;AN005; continue scanning until the
	repnz	scasb				;AN005;    end of line is reached.

process_ext:					;AN005;
	mov	CX, DI				; pointer to end of argstring yields
	sub	CX, DX				; number of bytes to be copied
	sub	BX, 4				; can argstring fit into dest. buffer?
	cmp	CX, BX
	jg	strip_error			; if not, we must have a bad pathname
	mov	DI, SI				; destination buffer
	mov	SI, DX				; source is beginning of pathname
	cld
	rep	movsb				; SI=arg,DI=buffer,CX=argend-argbeg
	cmp	ext_entered,1			;AN005; if an extension was entered
	jnz	skip_wilds			;AN005;    don't set up wildcard ext.

	dec	DI				; overwrite null or dot
	stosb					; with a dot
	mov	AL, wildchar			; now add wildcards
	stosb
	stosb
	stosb
	mov	AL, ANULL			; and a terminating null
	stosb

skip_wilds:					;AN005;
	popf
	clc					; chill out...
	jmp	short strip_exit

strip_error:
	popf
	stc

strip_exit:
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	ret
;---------------
EndProc Strip
;----------------------------------------------------------------------------


break <Save_Args>
;----------------------------------------------------------------------------
;   SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
; structure in newly allocated memory.	The argv[] structure is found at the
; beginning of this area.  The caller indicates how much extra space is
; needed in the resulting structure; Save_Args returns a segment number and
; an offset into that area, indicating where the caller may preserve its own
; data.  Note that <argvcnt> can be found at <offset-2>.
; ENTRY:
;   BX	    --	    size (in bytes) of extra area to allocate
; EXIT:
;   AX	    --	    segment of new area.
;   CF	    --	    set if unable to save a copy.
; NOTE(S):
;   1)	The allocated area will be AT LEAST the size requested -- since
;	the underlying MSDOS call, <alloc> returns an integral number of
;	paragraphs.
;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
;	as the caller of Save_Args requests.
;   3)	AX is undefined if CF indicates an error.
;---------------
Procedure   Save_Args,NEAR
;---------------
	assume	ds:trangroup, es:trangroup
	push	BX
	push	CX
	push	DX
	push	DI
	push	SI
	push	BP
	pushf
	add	BX, SIZE arg_unit + 0FH 	; space for arg structure, round up
	mov	CL, 4				; to paragraph size and convert
	shr	BX, CL				; size in bytes to size in paragraphs
	trap	Alloc
	jc	save_error
	mov	BP, AX				; save segment id
	push	ES				; save TRANGROUP address
	mov	ES, AX				; switch to new memory segment
assume	ES:nothing
	mov	CX, SIZE arg_unit		; get back structure size
	xor	DI, DI				; destination is new memory area
	mov	SI, OFFSET TRANGROUP:arg	; source is arg structure
	rep	movsb				; move it
	mov	CX, arg.argvcnt 		; adjust argv pointers
	xor	AX, AX				; base address for argv_calc
;	Bugbug:	What did they mean by this?
;	Note that the replacement line produces exactly the same code.
;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
	mov	SI, OFFSET TRANGROUP:arg

save_ptr_loop:
	dec	CX				; exhausted all args?
	jl	save_done
	mov	BX, CX				; get arg index and
	invoke	argv_calc			; convert to a pointer
	mov	DX, DS:arg.argv[BX].argpointer
	sub	DX, SI				; adjust argpointer
	mov	ES:argv[BX].argpointer, DX
	mov	DX, DS:arg.argv[BX].argstartel
	sub	DX, SI				; and adjust argstartel
	mov	ES:argv[BX].argstartel, DX
	mov	DX, DS:arg.argv[BX].arg_ocomptr
	sub	DX, SI				; and adjust arg_ocomptr
	mov	ES:argv[BX].arg_ocomptr, DX
	jmp	save_ptr_loop

save_done:
	pop	ES				; back we go to TRANGROUP
assume	ES:trangroup
	mov	AX, BP				; restore segment id
	jmp	short save_ok

save_error:
	popf
	stc
	jmp	short save_exit

save_ok:
	popf
	clc
save_exit:
	pop	BP
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	ret
;---------------
EndProc Save_Args
;----------------------------------------------------------------------------

trancode    ends
END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\rucode.asm ===
page ,132
	title	Localizable code for resident COMMAND
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;	M003	SR	07/16/90	Added routines Lh_Off, Lh_Unlink &
;				Lh_OffUnlink for UMB support
;
;	M009	SR	08/01/90	Rewrote Lh_OffUnlink to restore the
;				initial UMB state. Removed Lh_off
;				and Lh_Unlink.
;

.xlist
.xcref
	include dossym.inc
	include syscall.inc
	include filemode.inc
	include pdb.inc
	include mult.inc
	include doscntry.inc
	include devsym.inc
	include comsw.asm
	include comseg.asm
	include comequ.asm
	include resmsg.equ
	include	arena.inc		; M003
.list
.cref


DATARES segment public byte
	extrn	Abort_Char:byte
	extrn	BadFatMsg:byte
	extrn	BadFatSubst:byte
	extrn	Batch_Abort:byte
	extrn	BlkDevErr:byte
	extrn	BlkDevErrRw:byte
	extrn	BlkDevErrSubst:byte
	extrn	CDevAt:byte
	extrn	CharDevErr:byte
	extrn	CharDevErrRw:byte
	extrn	CharDevErrSubst:byte
	extrn	ComSpec:byte
	extrn	Crit_Err_Info:byte
	extrn	Crit_Msg_Off:word
	extrn	Crit_Msg_Seg:word
	extrn	CritMsgPtrs:word
	extrn	Dbcs_Vector_Addr:dword
	extrn	DevName:byte
	extrn	DrvLet:byte
	extrn	EndBatMes:byte
	extrn	ErrCd_24:word
	extrn	ErrType:byte
	extrn	Fail_Char:byte
	extrn	fFail:byte
	extrn	ForFlag:byte
	extrn	Ignore_Char:byte
	extrn	InitFlag:byte
	extrn	In_Batch:byte
	extrn	Int2fHandler:dword
	extrn	Loading:byte
	extrn	MsgBuffer:byte
	extrn	MsgPtrLists:dword
	extrn	MRead:byte
	extrn	MWrite:byte
	extrn	NeedVol:dword
	extrn	NeedVolMsg:byte
	extrn	NeedVolSubst:byte
	extrn	Newlin:byte
	extrn	No_Char:byte
	extrn	NUMEXTMSGS:abs
	extrn	NUMPARSMSGS:abs
	extrn	OldErrNo:word
	extrn	Parent:word
	extrn	ParsMsgPtrs:word
	extrn	Patricide:byte
	extrn	PermCom:byte
	extrn	Retry_Char:byte
	extrn	Req_Abort:byte
	extrn	Req_End:byte
	extrn	Req_Fail:byte
	extrn	Req_Ignore:byte
	extrn	Req_Retry:byte
	extrn	ResMsgEnd:word
	extrn	PipeFlag:byte
	extrn	SingleCom:word
	extrn	VolName:byte
	extrn	Yes_Char:byte

	extrn	OldDS:word
	extrn	Int2f_Entry:dword

DATARES ends

; NTVDM use diff al value so we don't confuse dos 5.0
; NTVDM command.com GET_COMMAND_STATE       equ     5500h
GET_COMMAND_STATE       equ     5501h



CODERES segment public byte

	extrn	GetComDsk2:near

	public	AskEnd
	public	Crlf
	public	DskErr
	public	MsgInt2fHandler
	public	MsgRetriever
	public	RPrint
ifdef BILINGUAL
	public	RPrint@
endif

	ifdef	DBCS
	public	ITestKanj
	endif

;	Bugbug:	Move rest of PUBLIC declarations up here.

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING



;***	AskEnd - ask user to confirm batch file termination
;
;	Confirm with user before freeing batch ...
;
;	ENTRY	nothing
;
;	EXIT	CY = set if batch termination is confirmed
;
;		CY = clear if batch should continue
;
;	USED	AX,DX,...

;	Bugbug:	move this to transient, copy to batch segment.
;	Bugbug:	or move it to command1 1st.

;	Bugbug: No_Char and Yes_Char should be constants.

AskEnd	proc

	assume	ds:DATARES

	mov	dx,offset DATARES:EndBatMes	; DX = message #
	call	RPrint
	mov	ax,(STD_CON_INPUT_FLUSH shl 8) + STD_CON_INPUT
	int	21h
	call	CharToUpper			; change to upper case
	cmp	al,No_Char
	je	aeRet				; answer is no (CY is clear)
	cmp	al,Yes_Char
	jne	AskEnd				; invalid response, try again
	stc					; answer is yes
aeRet:	ret

AskEnd	endp




;***	DskErr - critical error handler
;
;	Default critical error handler unless user intercepts int 24h.
;
;	ENTRY	int 24h
;
;	EXIT
;
;	USED
;
;	EFFECTS

;
;SR; 
; The stub is going to push the old ds value and the resident data segment
;onto the stack in that order. Get it off the stack
;

DskErr	proc	far

	assume	ds:NOTHING,es:NOTHING,ss:NOTHING

	pop	ds			;ds = DATARES
	assume 	ds:DATARES
	pop	OldDS			;save old ds value

	sti
	push	es
	push	si
	push	cx
	push	di
	push	cx
	push	ax

	push	ds			;save our data segment
	pop	es			;es = DATARES

	mov	ds,bp
	assume	ds:nothing

	mov	ax,[si].SDEVATT
	mov	es:CDevAt,ah

;;	push	cs
;;	pop	es

	mov	di,offset DATARES:DevName
	mov	cx,8
	add	si,SDEVNAME	; save device name (even for block device)

	cld
	rep	movsb
	pop	ax
	pop	cx
	pop	di

;	Stack still contains DS and ES.

;SR;
; We need ds = DATARES for SavHand
;
	push	es
	pop	ds
	assume	ds:DATARES

	invoke	SavHand		; save user's stdin/out, set to our stderr

;;	push	cs
;;	pop	ds		; set up local data segment
;;	assume	ds:resgroup

	push	dx
	call	Crlf
	pop	dx

;	Bugbug:	rename Crit_Err_Info to CritErrAH?

	mov	Crit_Err_Info,ah	; save critical error flags

;	Compute and save ASCII drive letter (nonsense for char devices)

	add	al,'A'
	mov	DrvLet,al

;	Bugbug:	These labels are awful.  Change, especially 'NoHardE'.

	test	ah,80h
	jz	NoHardE			; it's a disk-device error
	test	CDevAt,DEVTYP shr 8
	jnz	NoHardE			; it's a character device
	jmp	FatErr			; it's a FAT error

NoHardE:
	mov	si,offset DATARES:MRead  ; SI = "read" msg #
	test	ah,1
	jz	SavMes			  ; it's a read error
	mov	si,offset DATARES:MWrite ; SI = "write" msg #

SavMes:
	mov	OldErrNo,di		; save critical error code

;	Bugbug:	don't need to save/restore all here?
	push	es
	push	ds			; GetExtendedError likes to STOMP
	push	bp
	push	si
	push	dx
	push	cx
	push	bx
	mov	ah,GetExtendedError	; get extended error info
	int	21h
	pop	bx
	pop	cx
	pop	dx
	pop	si
	pop	bp
	pop	ds
	mov	word ptr NeedVol,di 	; save possible ptr to volume label
	mov	word ptr NeedVol+2,es
	pop	es

;	Bugbug:	AX has extended error code, so no need to zero AH?

	xor	ah,ah
	mov	di,ax			; DI = error code

; Bugbug:  somewhat obsolete documentation?
;
; DI is now the correct error code.  Classify things to see what we are
; allowed to report.  We convert DI into a 0-based index into a message table.
; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
; the like) are contiguous.
;

;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
;	Check use of ErrCd_24, though.

	sub	di,ERROR_WRITE_PROTECT
	jae	HavCod

;	Bugbug	wouldn't it be better to display the original error msg,
;	even though it's not a critical error?

	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT
;
; DI now has the mapped error code.  Old style errors are:
;   FOOBAR <read|writ>ing drive ZZ.
; New style errors are:
;   FOOBAR
; We need to figure out which the particular error belongs to.
;

HavCod:
	mov	ErrType,0		; assume old style
	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT
	je	SetStyle
	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT
	jne	GotStyle

SetStyle:
;	Bugbug:	use INC
	mov	ErrType,1		; must be new type

GotStyle:
	mov	[ErrCd_24],di
	cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT
						; If the error message is unknown
	jbe	NormalError			;  redirector, continue.  Otherwise,
;
; We do not know how to handle this error.  Ask IFSFUNC if she knows
; how to handle things
;

;input to IFSFUNC:    AL=1
;		      BX=extended error number
;
;output from IFSFUNC: AL=error type (0 or 1)
;			 0=<message> error (read/writ)ing (drive/device) xxx
;			   Abort, Retry, Ignore
;			 1=<message>
;			   Abort, Retry, Ignore
;		      ES:DI=pointer to message text
;		      carry set=>no message

	mov	di,ax			; retrieve correct extended error...
	mov	ax,0500h		; is the redir there?
	int	2fh
	cmp	al,0ffh
	jne	NoHandler		; no, go to NoHandler
	push	bx
	mov	bx,di			; get ErrType and ptr to error msg
	mov	ax,0501h
	int	2fh
	pop	bx 
	jc	NoHandler

;	Bugbug:	need to record error type?
	mov	ErrType,al
	push	ds
	push	es
	pop	ds
	mov	dx,di
	mov	cx,-1			; find end of msg
	xor	al,al

	cld
	repnz	scasb

;	Bugbug:	we can do better than this.

	mov	byte ptr [di-1],'$'
	mov	ah,STD_CON_STRING_OUTPUT	; print the message
	int	21h
	mov	byte ptr [di-1],0		; restore terminal byte

	pop	ds				; clean up and continue
	jmp	short CheckErrType

;*	Redir isn't available or doesn't recognize the error.
;	Restore regs to unextended error.

NoHandler:
	mov	ErrType,0
;	Bugbug:	won't this break, since we add error_write_protect back in?
	mov	di,OldErrNo
	mov	ErrCd_24,di

NormalError:
	add	di,ERROR_WRITE_PROTECT
	xchg	di,dx			; may need dx later
	call	RPrintCrit		; print error type

CheckErrType:
	cmp	ErrType,0		; Check error style...
	je	ContOld
	call	CrLf			; if new style then done printing
	jmp	short Ask

ContOld:
	inc	si			; DS:SI = ptr to asciiz string

;	Bugbug:	combine some of the following two sections?

	test	[CDevAt],DEVTYP shr 8
	jz	BlkErr
	mov	dx,offset DATARES:CharDevErr	  ; DX = ptr to device message
	mov	CharDevErrRw.SubstPtr,si	  ; point to read/write string
	mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block

	call	RPrint				; print the message
	jmp	short Ask			; don't ralph on command

BlkErr:
	mov	dx,offset DATARES:BlkDevErr	  ; DX = error msg #
	mov	BlkDevErrRw.SubstPtr,si		  ; "reading","writing" ptr
	mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
	call	RPrint

	cmp	Loading,0
	jz	Ask
	invoke	RestHand
	jmp	GetComDsk2		; if error loading COMMAND, re-prompt

Ask:
	cmp	[ErrCd_24],15		; error 15 has an extra message
	jne	Not15			; not error 15

;*	For error 15, tell the user which volume/serial # are needed.

	push	cx

;	Bugbug:	does this push/pop need to be done?
	push	ds
	pop	es
	lds	si,NeedVol
	assume	ds:NOTHING
	push	di
	mov	di,offset DATARES:VolName
	mov	cx,16			; copy volume name & serial #
	cld
	rep	movsb
	pop	di
	push	es
	pop	ds
	pop	cx
	assume	ds:DATARES
	mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
	mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
	call	RPrint
Not15:

;*	Print abort, retry, ignore, fail message.
;	Print only options that are valid.

;	Bugbug:	sizzle this.

	mov	dx,offset DATARES:Req_Abort
	call	RPrint
	test	Crit_Err_Info,RETRY_ALLOWED
	jz	Try_Ignore
	mov	dx,offset DATARES:Req_Retry
	call	RPrint

Try_Ignore:
	test	Crit_Err_Info,IGNORE_ALLOWED
	jz	Try_Fail
	mov	dx,offset DATARES:Req_Ignore
	call	RPrint

Try_Fail:
	test	Crit_Err_Info,FAIL_ALLOWED
	jz	Term_Question
	mov	dx,offset DATARES:Req_Fail
	call	RPrint

Term_Question:
	mov	dx,offset DATARES:Req_End
	call	RPrint

;	If the /f switch was given, we fail all requests.

	test	fFail,-1
	jz	DoPrompt
	mov	ah,3				; signal fail
	jmp	EExit

DoPrompt:
	mov	ax,(STD_CON_INPUT_FLUSH shl 8) + STD_CON_INPUT
	int	21h				; get response


;	Bugbug:	can Kanji code be conditional?

	ifdef	DBCS

	invoke	TestKanjR			; 3/3/KK
	jz	NotKanj 			; 3/3/KK
	mov	ax,(STD_CON_INPUT shl 8)	; eat the 2nd byte of ECS code  3/3/KK
	int	21h				; 3/3/KK
	call	Crlf				; 3/3/KK
	jmp	Ask				; 3/3/KK
NotKanj:					; 3/3/KK

	endif

	call	Crlf
	call	CharToUpper			; convert to upper case
	mov	ah,0				; return code for ignore
	test	Crit_Err_Info,IGNORE_ALLOWED	; is ignore allowed?
	jz	user_retry
	cmp	al,Ignore_Char			; ignore?
	jz	EExitJ

;	Bugbug:	optimize following code.

User_Retry:
	inc	ah				; return code for retry
	test	Crit_Err_Info,RETRY_ALLOWED	; is retry allowed?
	jz	User_Abort
	cmp	al,Retry_Char			; retry?
	jz	EExitJ

User_Abort:
	inc	ah				; return code for abort
						;  (abort always allowed)
	cmp	al,Abort_Char			; abort?
	jz	Abort_Process			; exit user program
	inc	ah				; return code for fail
	test	Crit_Err_Info,FAIL_ALLOWED	; is fail allowed?
	jz	AskJ
	cmp	al,Fail_Char			; fail?
	jz	EExitJ

AskJ:
	jmp	Ask

EExitJ:
	jmp short EExit

Abort_Process:
	test	InitFlag,INITINIT		; COMMAND init interrupted?
	jz	AbortCont			; no, handle it normally
	cmp	PermCom,0			; are we top level process?
	jz	JustExit			; yes, just exit
	mov	dx,offset DATARES:Patricide	; no, load ptr to error msg
	call	RPrint				; print it

DeadInTheWater:
	jmp	DeadInTheWater			; loop until the user reboots

JustExit:
	assume	ds:DATARES
	mov	ax,Parent			; load real parent pid
	mov	word ptr ds:Pdb_Parent_Pid,ax 	; put it back where it belongs
	mov	ax,(EXIT shl 8) or 255
	int	21h

AbortCont:
	test	byte ptr In_Batch,-1	; Are we accessing a batch file?
	jz	Not_Batch_Abort
	mov	byte ptr Batch_Abort,1	; set flag for abort

Not_Batch_Abort:
	mov	dl,PipeFlag
	invoke	ResPipeOff
	or	dl,dl
	je	CheckForA
	cmp	SingleCom,0
	je	CheckForA
	mov	SingleCom,-1			; make sure singlecom exits

CheckForA:
	cmp	ErrCd_24,0			; write protect?
	je	AbortFor
	cmp	ErrCd_24,2			; drive not ready?
	jne	EExit				; don't abort the FOR

abortfor:
	mov	ForFlag,0			; abort a FOR in progress
	cmp	SingleCom,0
	je	EExit
	mov	SingleCom,-1			; make sure singlecom exits

EExit:
	mov	al,ah
	mov	dx,di

RestHd:
	invoke	RestHand
	pop	cx
	pop	si				; restore registers
	pop	es

;;	pop	ds
;SR;
; ds has to be got from the variable we saved it in
;

 	mov	ds,OldDS			;restore old value of ds
;	pop	ds
	assume	ds:nothing

	iret

FatErr:
	mov	dx,offset DATARES:BadFatMsg
	mov	si,offset DATARES:BadFatSubst
	call	RPrint

	mov	al,2				; abort
	jmp	RestHd

DskErr	endp




;***	RPrint - print message
;***	Crlf - display cr/lf
;
;	ENTRY	DS:DX = ptr to count byte, followed by message text
;		DS:SI = ptr to 1st substitution block for this msg, if any
;		variable fields related to substitution blocks are set
;
;	EXIT	nothing
;
;	USED	flags
;
;	EFFECTS
;	  Message is displayed on stdout.
;
;	NOTE
;	  Number of substitutions (%1, %2,...) in message text must not
;	    be greater than number of substition blocks present.


Crlf: 
	mov	dx,offset DATARES:Newlin	; cheap newline

RPrint	proc

	assume	ds:DATARES,ss:DATARES

;	Bugbug:	do we need to save all reg's?

	push	si			; preserve registers
	push	ax
	push	bx
	push	cx
	push	dx

	mov	bx,si			; DS:BX = ptr to subst block
	mov	si,dx			; DS:SI = ptr to count byte
	lodsb				; AL = message length
					; DS:SI = ptr to message text
	xor	cx,cx
	mov	cl,al			; CX = message length

ifdef BILINGUAL
	call	IsDBCSCodePage
	jnz	rp_us			; if not DBCS code page
	push	ax
	push	si
	xor	cx,cx
@@:
	lodsb
	inc	cx
	or	al,al
	jnz	@b
	dec	cx
	pop	si
	pop	ax
	jmp	short rp_next
rp_us:
	push	ax
@@:
	lodsb
	dec	cx
	or	al,al
	jnz	@b
	pop	ax
rp_next:

endif

	jcxz	rpRet

	call	RDispMsg

rpRet:	pop	dx
	pop	cx
	pop	bx
	pop	ax
	pop	si
	ret

RPrint	endp

ifdef BILINGUAL
RPrint@	proc
	push	ax
	push	bx
	push	cx
	push	si
	mov	bx,si			; DS:BX = ptr to subst block
	mov	si,dx			; DS:SI = ptr to count byte
	lodsb				; AL = message length
					; DS:SI = ptr to message text
	xor	cx,cx
	mov	cl,al			; CX = message length
	jcxz	@f

	call	RDispMsg

@@:
	pop	si
	pop	cx
	pop	bx
	pop	ax
	ret
RPrint@	endp
endif




;***	RPrintCrit - print critical error message
;
;	ENTRY	DX = extended error # (19-39)
;
;	EXIT	nothing
;
;	USED	flags
;
;	EFFECTS
;	  Message is displayed on stdout

RPrintCrit	proc

	assume	ds:DATARES,ss:DATARES

	push	dx			; preserve DX
	xchg	bx,dx			; BX = extended error #
					; DX = saved BX
	sub	bx,19			; BX = critical error index, from 0

ifdef BILINGUAL
	call	IsDBCSCodePage
	jz	rpc_next		; if Kanji mode
	add	bx,21
	push	ax
@@:
	lodsb
	or	al,al
	jnz	@b
	pop	ax
	dec	si
rpc_next:
endif

	shl	bx,1			; BX = offset in word table
	mov	bx,CritMsgPtrs[bx]	; BX = ptr to error msg
	xchg	bx,dx			; DX = ptr to error msg
					; BX = restored
ifdef BILINGUAL
	call	RPrint@			; print the message
else
	call	RPrint			; print the message
endif
	pop	dx			; restore DX
	ret

RPrintCrit	endp




;***	RDispMsg - display message
;
;	Display message, with substitutions, for RPrint.
;
;	ENTRY	DS:SI = ptr to message text
;		CX = message length
;		DS:BX = ptr to substitution block, if any
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI

RDispMsg	proc

	assume	ds:DATARES,ss:DATARES

rdNextChar:
	lodsb				; AL = next char
	cmp	al,'%'
	jne	rdOutChar		; not a substitution
	mov	dl,ds:[si]		; DL = possible '1' - '9'
	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
	cmp	dl,9
	jae	rdOutChar		; not a substitution

;*	A substitution code %1 - %9 has been encountered.
;	DL = 0-8, indicating %1-%9
;	DS:BX = ptr to substitution block

	call	SubstMsg		; display the substitution
	inc	si			; SI = ptr past %n
	dec	cx			; count extra character in %n
	jmp	short rdCharDone

;*	Normal character output.

rdOutChar:
	mov	dl,al			; DL = char
	mov	ah,2			; AH = DOS Character Output code
	int	21h			; call DOS
rdCharDone:
	loop	rdNextChar
	ret

RDispMsg	endp




;***	SubstMsg - display message substitution
;
;	Display a substitution string within a message.
;	Substitution can be a char, an ASCIIZ string, or
;	a word to be displayed as hex digits.
;
;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
;		DS:BX = ptr to substitution block
;
;	EXIT	nothing
;
;	USED	AX,DX

SubstMsg	proc

	assume	ds:DATARES,ss:DATARES

	push	bx			; preserve BX
	push	cx			; preserve CX

	mov	al,size SUBST		; AL = size of substitution block
	mul	dl			; AX = offset of desired subst block
	add	bx,ax			; DS:BX = ptr to desired subst block

	mov	al,[bx].SubstType	; AX = substitution type flag
	mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value

;	AL = 1, 2, or 3 for char, string, or hex type

	dec	al
	jz	smChar
	dec	al
	jz	smStr

;*	Hex number substitution.

	mov	ax,ds:[bx]		; AX = word value
	mov	cx,4			; CX = # digits to display
smDigit:
	rol	ax,1
	rol	ax,1
	rol	ax,1
	rol	ax,1			; AL<3:0> = next digit

	push	ax			; save other digits
	and	al,0Fh			; AL = binary digit
	add	al,'0'			; AL = ascii digit if 0-9
	cmp	al,'9'
	jbe	@F			; it's 0-9
	add	al,'A' - '0' - 10	; AL = ascii digit A-F
@@:
	mov	dl,al			; DL = ascii digit
	mov	ah,2
	int	21h			; output the ascii digit
	pop	ax			; restore all digits

	loop	smDigit
	jmp	short smRet

;*	Char substitution.

smChar:
	mov	dl,ds:[bx]		; DL = char to output
	mov	ah,2
	int	21h
	jmp	short smRet

;*	String substitution.

smStr:
	mov	dl,ds:[bx]		; DL = next char
	or	dl,dl
	jz	smRet			; null char - we're done
	mov	ah,2
	int	21h			; display char
	inc	bx			; DS:BX = ptr to next char
	jmp	smStr

smRet:	pop	cx
	pop	bx
	ret

SubstMsg	endp




;***	CharToUpper - convert character to uppercase
;
;	ENTRY	AL = char
;
;	EXIT	AL = uppercase char
;
;	USED	AX

CharToUpper	proc

	assume	ds:DATARES

	push	ax		; put char on stack as arg to int 2F
	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
	int	2Fh
	inc	sp		; throw away old char on stack
	inc	sp
	ret

CharToUpper	endp





	ifdef	DBCS

;***	ITestKanj - DBCS lead byte check

ITestKanj:
TestKanjR:				; 3/3/KK
	push	ds
	push	si
	push	ax
	lds	si,Dbcs_Vector_Addr

ktLop:
	cmp	word ptr ds:[si],0	; end of Lead Byte Table
	je	NotLead
	pop	ax
	push	ax
	cmp	al, byte ptr ds:[si]
	jb	NotLead
	inc	si
	cmp	al, byte ptr ds:[si]
	jbe	IsLead
	inc	si
	jmp	short ktLop		; try another range

NotLead:
	xor	ax,ax			; set zero
	jmp	short ktRet

Islead:
	xor	ax,ax			; reset zero
	inc	ax

ktRet:
	pop	ax
	pop	si
	pop	ds
	ret

	endif




;***	MsgInt2fHandler - int 2f handler for message retrieval
;
;	ENTRY	If we handle it -
;		  AX = ((MULTDOS shl 8) or MESSAGE_2F) = 122Eh
;		  DL = operation =
;		     0 = get extended error messages
;		     1 = set extended error messages
;		     2 = get parse error messages
;		     3 = set parse error messages
;		     4 = get critical error messages
;		     5 = set critical error messages
;		     6 = get file system error messages
;		     7 = set file system error messages
;		     8 = get disk retriever routine
;		     9 = set disk retriever routine
;		  ES:DI = address for 'set' operations
;
;	EXIT	ES:DI = ptr to list of message ptrs, for 'get' operations
;
;	NOTE
;	  This handler replaces the one that used to reside in DOS.
;	  'Set' operations are ignored.
;	  'File system error messages' are not supported.

;SR;
; At the int 2fh entry point we push the old ds value and the resident data
;segment address. Get them off the stack
;

MsgInt2fHandler	proc	far

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	pop	ds			;ds = DATARES
	assume	ds:DATARES
;	pop	OldDS			;save old value of ds

	cmp	ax,(MULTDOS shl 8) or MESSAGE_2F
	je	miOurs			; it's ours

        cmp     ax, GET_COMMAND_STATE
        je      fcOurs

;SR;
; We cannot do a far jump any more because cs cannot be used. Push the cs:ip
;onto the stack and do a far return to jump to the next 2fh handler. 
;Our old ds is on the stack. We need to restore it but we cannot lose the
;current value of ds as it points at the data segment. So we do some kinky
;stack manipulations.
;
	push	ax
	push	ax			;create 2 words on stack for retf

	push	bp
	push	ax

	mov	bp,sp			;bp can be used to address stack
;
;Swap the old ds value with the second dummy word on the stack. Now, we can
;do a 'pop ds' at the end to restore our ds
;
	mov	ax,[bp+8]		;ax = old ds value
	mov	[bp+4],ax
	
	mov	ax,word ptr ds:Int2fHandler+2
	mov	[bp+8],ax		;put segment address
	mov	ax,word ptr ds:Int2fHandler
	mov	[bp+6],ax		;put offset address


	pop	ax
	pop	bp
	pop	ds

	retf				;chain on to next handler

;;	jmp	Int2fHandler		; hand off to next 2f handler

fcOurs:
;
;We have to clear ax, and return in ds:si a pointer to the stub jump table
;
	pop	ax			;discard ds currently on stack
	push	ds			;store our data segment

	mov	si,offset DATARES:Int2f_Entry ;start of table

	xor	ax,ax			;indicate COMMAND present
	jmp	short miRet		;return to caller


miOurs:
	test	dl,1
	jnz	miRet			; ignore 'set' operations

	push	bx			; preserve BX
	mov	bx,dx
	xor	bh,bh			; BX = index in word table
	shl	bx,1			; BX = index in dword table
	les	di,MsgPtrLists[bx]		; ES:DI = ptr to msg ptr list
	pop	bx			; restore BX

miRet:
;	mov	ds,OldDS		;restore ds
	pop	ds
	assume	ds:nothing

	iret

MsgInt2fHandler	endp




;***	MsgRetriever - message retrieval routine for utilities
;
;	Address of this routine is passed to utility programs via 
;	message services int 2f.  We try to find the desired message
;	in memory or in our disk image.
;
;	ENTRY	AX = message #
;		DI = offset in RESGROUP of msg ptr list
;		ComSpec = asciiz pathname to our disk image
;
;	EXIT	CY clear for success
;		ES:DI = ptr to count byte, followed by message text
;
;		CY set for failure
;
;	USED	flags
;
;	NOTE
;	  The message # in AX is used to compute an offset into
;	  the message ptr list pointed to by DI.  The lists must
;	  start with message # 1 and proceed through consecutive
;	  message #'s.  
;
;	  It is assumed that the msg ptr list is either ParsMsgPtrs or
;	  ExtMsgPtrs.  We use NUMPARSEMSGS and NUMEXTMSGS to check for
;	  valid message #.  ;M033
;
;	  List positions with no corresponding message text are
;	  indicated by null pointers, which this routine detects.

;SR; This routine will be called directly by the utilities. So, we have
; trap for it in the stub. The stub pushes the old value of ds and the 
; DATARES value on the stack. We get them off the stack to setup ds here
;

MsgRetriever	proc	far

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	pop	ds			;ds = DATARES
	assume	ds:DATARES
;	pop	OldDS			;save old ds

	push	ax			; preserve registers
	push	bx
	push	cx
	push	dx
	push	si

;;	push	ds
;;	push	cs
;;	pop	ds			; DS = DATARES seg addr
;;	assume	ds:RESGROUP
;;	push	cs

	push	ds			; get es from ds
	pop	es			; ES = DATARES seg addr

;	Begin modification M033.

;	Make sure msg # is valid.
;	Assume msg ptr list is either ParsMsgPtrs or ExtMsgPtrs.

	mov	bx,NUMPARSMSGS		; BX = # parse error msgs in list
	cmp	di,offset DATARES:ParsMsgPtrs
	je	@f			; it's ParsMsgPtrs
	mov	bx,NUMEXTMSGS		; BX = # extended error msgs in list
@@:	cmp	bx,ax
	jc	mrRet			; msg # too high, return carry

;	Msg # is valid.

;	End modification M033.

	dec	ax
	shl	ax,1			; AX = offset into msg ptr list
	add	di,ax			; DI = ptr to msg ptr

	cmp	di,ResMsgEnd
	jb	mrInMem			; ptr (and message) in memory

;*	Retrieve message from disk.
;	Read once to get the ptr to the message, then again for the message.

	mov	si,offset DATARES:ComSpec	; DS:SI = ptr to pathname
	mov	dx,EXT_EXISTS_OPEN		; DX = 'open existing file'
	mov	bx,INT_24_ERROR			; BX = 'fail on crit error'
	mov	ax,EXTOPEN shl 8		; AX = 'Extended Open File'
	int	21h				; call DOS
	jc	mrRet				; return failure

	mov	bx,ax				; BX = file handle
	mov	dx,di				; DX = ptr to msg ptr
	xor	si,si				; SI = read count
mrRead:
	sub	dx,100h				; DX = LSW of file offset
	xor	cx,cx				; CX = MSW of file offset
	mov	ax,LSEEK shl 8			; AX = 'Set File Pointer'
	int	21h				; call DOS
	jc	mrCloseFile			; handle error

	mov	dx,offset DATARES:MsgBuffer	; DS:DX = input buffer
	mov	cx,64				; CX = # bytes to read
	mov	ah,READ				; AH = 'Read File'
	int	21h				; call DOS
	jc	mrCloseFile			; handle error

	or	si,si				; (CY cleared)
	jnz	mrCloseFile			; 2nd time thru - we're done
	inc	si				; mark one read done
	mov	dx,word ptr MsgBuffer		; DX = ptr to message
	or	dx,dx
	jnz	mrRead				; go read the message
	stc					; null ptr found- no msg

mrCloseFile:
	pushf				; save success/failure (CY)
	mov	ah,CLOSE		; AH = 'Close File'
	int	21h			; call DOS
;	Bugbug: should we avoid this popf?
	popf				; CY = success/failure
	mov	di,dx			; ES:DI = ptr to msg, if successful
	jmp	short mrRet		; we're done


;*	Message ptr is in memory.
;	If ptr is in memory, assume message is in memory (/msg).

mrInMem:
	mov	di,es:[di]		; ES:DI = ptr to msg
	or	di,di			; (CY cleared)
	jnz	mrRet			; found message
	stc				; null ptr found- no message

mrRet:	
	pop	si			;restore all registers
	pop	dx
	pop	cx
	pop	bx
	pop	ax

;	mov	ds,OldDS		;restore ds
	pop	ds
	assume	ds:nothing

	ret

MsgRetriever	endp

;
; M003; Start of changes for UMB support
;


;***	Lh_OffUnlink -- Restore allocation strat and link state
;
;	ENTRY	al = Saved alloc strat and link state
;			b0 = 1 if alloc strat to restore is HighFirst
;			b1 = 1 if link state to restore is Linked
;
;	EXIT	None
;
;	USED	ax, bx, cx
;
;

public	Lh_OffUnlink
Lh_OffUnlink	proc	far

	mov	ch,al
	mov	cl,al
	mov	ax,(ALLOCOPER shl 8) OR 0
	int	21h
	mov	bx,ax
	ror	cl,1				;b7 = HighFirst bit
	and	cl,80h				;mask off b6-b0
	and	bl,7fh				;mask off HighFirst bit
	or	bl,cl				;set HighFirst bit state
	mov	ax,(ALLOCOPER shl 8) OR 1
	int	21h				;set alloc strat

	mov	bl,ch
	shr	bl,1
	xor	bh,bh				;bx = linkstate
	mov	ax,(ALLOCOPER shl 8) OR 3
	int	21h				;set linkstate

	ret

Lh_OffUnlink	endp

;
; M003; End of changes for UMB support
;

ifdef BILINGUAL
IsDBCSCodePage	proc	near
	push	ax
	push	bx
	mov	ax,4f01h		; get code page
	xor	bx,bx
	int	2fh
ifdef JAPAN
	cmp	bx,932
endif
ifdef KOREA
	cmp	bx,949
endif
ifdef TAIWAN
	cmp	bx,950
endif
ifdef PRC
	cmp	bx,936
endif
	pop	bx
	pop	ax
	ret
IsDBCSCodePage	endp
endif

public	EndCode
EndCode	label	byte

CODERES ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\loadhi.asm ===
page	,132
	title	LOADHIGH Internal Command
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;************ LOADHIGH command -- loads programs into UMBs.
;
comment %==================================================================

This is a new module added to support loading programs into UMBs provided
by DOS 5.0. 

Usage:

LOADHIGH <filespec>

<filespec> has to be a filename that is not wildcarded.


==========================================================================%

;
;	Revision History
;	================
;
;	M009	SR	08/01/90	Set flags to indicate that we are
;				loading and high and also remember
;				current UMB state.
;
;	M016	SR	08/09/90	Give special error message on attempt
;				to loadhigh batch files and invalid
;				filename on Loadhigh command line.
;
;	M039	SR	11/19/90	Bug #4270. Copy all the whitespaces
;				after the program name also as part
;				of the command line being passed to
;				the program to be invoked.
;


;*** INCLUDE FILES


	.xlist
	.xcref

	include	comseg.asm
	include	comequ.asm
	include	dossym.inc
	include	syscall.inc
	include arena.inc

	.list
	.cref

;*** EQUATES AND STRUCTURES

NUM_LH_SWS	equ	5	;number of valid switches


ResultBuffer	struc		; structure of parse result buffer

ValueType	db	?
ValueTag	db	?
SynPtr		dw	?
ValuePtr	dd	?

ResultBuffer	ends


DATARES		segment

	extrn	LoadHiFlg	:BYTE

DATARES		ends


TRANDATA		segment

	extrn	ComExt		:BYTE
	extrn	ExeExt		:BYTE
	extrn	Extend_Buf_Ptr	:WORD
	extrn	Msg_Disp_Class	:BYTE
	extrn	Parse_LoadHi	:BYTE
	extrn	NoExecBat_Ptr	:WORD	; M016
	extrn	LhInvFil_Ptr	:WORD	; M016

TRANDATA		ends

TRANSPACE	segment

	extrn	ResSeg		:WORD
	extrn	ExecPath	:BYTE
	extrn	Comsw		:WORD
	extrn	Arg		:BYTE
	extrn	SwitChar	:BYTE	; M039

TRANSPACE	ends

TRANCODE		segment

	extrn	Cerror:near
	extrn	Parse_With_Msg:near
	extrn	Lh_Execute:near			;new execute label; M051
	extrn	Path_Search:near

	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP

;****	LoadHigh -- Main routine for Loadhigh command
;
;	ENTRY	Command line tail is at PSP:81h terminated by 0dh
;		CS = DS = SS = TRANGROUP
;
;	EXIT	None
;
;	USED	ax, bx, cx, dx, si, di, es
;
;	ERROR EXITS
;		Message pointers are setup at the error locations and then
;	we jump back to CERROR which is the transient error recycle point.
;	Apart from parse errors, the other errors handled are too many
;	switches anf invalid filenames.
;
;	EFFECTS
;		The allocation strategy and the state of the arena chain are
;	put in the requested state according to the given options. If a 
;	filename is also given, it is executed as well.
;
;

	public	LoadHigh

LoadHigh		proc	near

	push	ds
	pop	es
	assume	es:TRANGROUP
;
;M039
; Get command tail to be passed to the program. This includes any whitespace
;chars between the program name and its parameters as well.
;On return, ds:si points at the start of the command tail.
;
	call	GetCmdTail		;Get command tail for pgm ;M039
	push	si			;save its start offset ;M039

	call	ParseLhCmd		;parse the command line
	pop	si			;restore start offset ;M039
	jc	LhErr			;error parsing, abort

	call	SetupCmdLine		;setup pgm's command line

	call	SetupPath		;setup path for file
	jc	LhErr			;file not found

;
;Set allocation strategy to HighFirst and link in UMBs for exec. This will
;be reset after return from the Exec
;We will also set a resident flag to indicate that UMBs were activated for
;the Exec. On return from the Exec, this flag will be used to deactivate UMBs
;
	call	SetupUMBs		;set alloc strat & link state

	jmp	Lh_Execute		;go and exec file ;M051

LhErr:
;
;The error message has been setup at this stage
;
	jmp	Cerror			;print error message and recycle 
					
LoadHigh		endp


;*** 	ParseLhCmd	-- calls system parser to parse command line
;
;	ENTRY	Parse block Parse_LoadHi setup
;
;	EXIT	Carry clear -- command line parsed successfully
;		Carry set -- appropriate error message setup
;
;	USED	di, cx, bx, ax, si, dx
;
;	EFFECTS
;		Options set up
;		Filename to be executed setup
;


ParseLhCmd	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

	mov	si,81h			;ds:si points at command line
	mov	Comsw,0		;clear switch indicator
	mov	di,offset TRANGROUP:Parse_LoadHi ;es:di = ptr to parse blk
	xor	cx,cx			;no positionals found yet
lhParse:
	call	Parse_With_Msg
	cmp	ax,END_OF_LINE
	je	lhpRet			;EOL encountered, return(no carry)
	cmp	ax,RESULT_NO_ERROR
	jne	lhperrRet		;parse error, return
;
;Parse call succeeded.  We have a filespec
;DX = ptr to result buffer
;
	mov	bx,dx			;BX = ptr to parse result buffer
	call	LhCopyFilename		;copy filename into our buffer
	jc	lhpRet			;bad filename, return
	jmp	short lhpRet		;done parsing, return (no error)

lhperrRet:
	stc
lhpRet:
	ret

	
ParseLhCmd	endp


;***	Lh_On -- Activate allocation of UMBs
;
;	ENTRY	None
;
;	EXIT	None
;
;	USED	
;
;	EFFECTS
;		Allocation strategy is set to HighFirst
;

Lh_On		proc 	near

	mov	ax,(ALLOCOPER shl 8) OR 0
	int	21h			;get alloc strategy

	mov	bx,ax
	or	bx,HIGH_FIRST		;set alloc to HighFirst

	mov	ax,(ALLOCOPER shl 8) OR 1
	int	21h			;set alloc strategy

	ret
Lh_On	endp


;***	Lh_Link -- links UMBs to arena
;
;	ENTRY	None
;
;	EXIT	None
;
;	USED	ax, bx
;
;	EFFECTS
;		UMBs are linked into the DOS arena chain
;

Lh_Link		proc	near

	mov	ax,(ALLOCOPER shl 8) OR 3
	mov	bx,1
	int	21h			;link in UMBs

	ret

Lh_Link		endp


;***	LhCopyFilename -- copy filename from command line to buffer
;
;	ENTRY	ds:bx points at parse result block
;
;	EXIT	CY set -- filename has wildcards
;			   Setup for error message
;
;	USED	ax
;
;	EFFECTS
;		ExecPath contains the filename
;

LhCopyFilename	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

	push	ds
	push	si
	push	di

	lds	si,[bx].ValuePtr
	mov	di,offset TRANGROUP:ExecPath

movlp:
	lodsb
;
;If there are any wildcards in the filename, then we have an error
;
	cmp	al,'*'			;wildcard?
	je	lhfilerr		;yes, error
	cmp	al,'?'			;wildcard?
	je	lhfilerr		;yes, error

	stosb				;store char
	or	al,al			;EOS reached?
	jnz	movlp			;no, continue

	clc				;indicate no error
lhcopyret:
	pop	di
	pop	si
	pop	ds
	ret

lhfilerr:
	mov	dx,offset TRANGROUP:LhInvFil_Ptr ; "Invalid Filename" ; M016
	stc
	jmp	short lhcopyret

LhCopyFilename	endp

;
;M039; Begin changes

;*** 	GetCmdTail -- scan through the command line looking for the start
;	of the command tail to be passed to program that is to be invoked.
;
;	ENTRY	ds = TRANGROUP
;		At ds:80h, command tail for lh is present.
;
;	EXIT	ds:si points at the command tail for program
;
;	USED
;

GetCmdTail	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

	mov	si,81h			;ds:si = command line for lh

	invoke	scanoff		;scan all delims before name
;
; Skip over the program name until we hit a delimiter
;
lhdo_skipcom:
	lodsb			   	; 
	invoke	delim		   	;is it a delimiter? 
	jz	scandone	   	;yes, we are done 
	cmp	AL, 0DH 	   	;end of line? 
	jz	scandone	   	;yes, found command tail
	cmp	al,SwitChar	   	;switch char?
	jnz	lhdo_skipcom		;no, continue scanning

scandone:
	dec	si			;point at the command tail start

	ret

GetCmdTail	endp

;M039; End changes
;

;***	SetupCmdLine -- prepare command line for the program
;
;	ENTRY	ds:si = points just beyond prog name on command line
;
;	EXIT	None
;
;	USED
;
;	EFFECTS		
;		The rest of the command line following the pgm name is 
;	moved to the top of the command line buffer (at TRANGROUP:80h)
;	and a new command line length is put in
;

SetupCmdLine	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP
	
	mov	di,81h
	xor	cl,cl
	dec	cl			;just CR means count = 0
stcllp:
	lodsb
	stosb
	inc	cl			;update count

	cmp	al,0dh			;carriage return?
	jne	stcllp			;no, continue storing

	mov	es:[80h],cl		;store new cmd line length

	ret

SetupCmdLine	endp



;***	LhSetupErrMsg -- Sets up error messages
;
;	ENTRY	ax = error message number
;
;	EXIT	None
;
;	USED	dx
;
;	EFFECTS
;		Everything setup to display error message
;

LhSetupErrMsg	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

	mov	msg_disp_class,EXT_MSG_CLASS
	mov	dx,offset TranGroup:Extend_Buf_ptr
	mov	Extend_Buf_ptr,ax

	ret

LhSetupErrMsg	endp

;
;M009; Start of changes
;

;***	GetUMBState -- get the current alloc strat and link state
;
;	ENTRY	None
;
;	EXIT	al contains the status as follows:
;			b0 = 1 if Alloc strat is HighFirst
;			   = 0 if alloc strat is LowFirst
;			b1 = 1 if UMBs are linked in
;			   = 0 if UMBs are unlinked
;
;	USED	ax, bx
;

GetUMBState	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

	mov	ax,(ALLOCOPER shl 8) OR 0		;get alloc strat
	int	21h
	mov	bl,al

	mov	ax,(ALLOCOPER shl 8) OR 2		;get link state
	int	21h
	mov	bh,al

	xchg	ax,bx				;ax contains the state
	rol	al,1				;get HighFirst state in b0
	and	al,01				;mask off b1-b7
	shl	ah,1				;linkstate in b1
	or	al,ah				;b0=HighFirst, b1=Linkstate

	ret

GetUMBState	endp

;
; M009; End of changes
;


;***	SetupUMBs -- set allocation strategy to HighFirst and link in UMBs to
;	DOS arena to load the program into UMBs
;
;	ENTRY	None
;
;	EXIT	None
;
;	USED	
;
;	EFFECTS
;		Allocation strategy set to HighFirst
;		UMBs linked into DOS arena

SetupUMBs	proc	near
	assume	ds:TRANGROUP

	push	ds

	call	GetUMBState		;get current state of UMBs ;M009

	mov	ds,ds:ResSeg		; M009
	assume	ds:DATARES		; M009
	mov	LoadHiFlg,al		; M009
	or	LoadHiFlg,80h		;indicate loadhigh issued ; M009

	pop	ds
	assume	ds:TRANGROUP

	call	Lh_On			;alloc strategy to HighFirst
	call	Lh_Link		;link in UMBs

	ret

SetupUMBs	endp

;***	SetupPath -- Do path search for the file to be executed
;
;	ENTRY	None
;
;	EXIT	Carry set if file not found or not executable file
;
;	EFFECTS
;		ExecPath contains the full path of the file to be executed
;

SetupPath	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

;
;Juggle around the argv pointers to make argv[1] into argv[0]. This is 
;because the path search routine that we are about to invoke expects the
;filename to search for to be argv[0]
;
	mov	ax,arg.argvcnt		;total number of arguments
	dec	ax			;less one - skip "LoadHigh"
	mov	bx,SIZE Argv_ele
	mul	bx			;dx:ax = size of argument lists

;
;Move argv[1]..argv[n] to argv[0]..argv[n-1]
;
	mov	di,offset TRANGROUP:Arg
	mov	si,di
	add	si,SIZE Argv_ele
	mov	cx,ax			;size to move

	cld
	rep	movsb			;Move the argument list

	dec	arg.argvcnt		;fake one less argument

	call	path_search		;look in the path
;
;ax = 0, no file found
;ax < 4, batch file found -- cant be executed
;ax = 4,8 => .com or .exe file found
;
	or	ax,ax			;any file found?
	jz	no_exec_file		;no, error

	cmp	ax,4			;executable file?
	jl	no_exec_bat		;no, indicate fail ; M016

	clc
	ret

no_exec_bat:				; M016
	mov	dx,offset TRANGROUP:NoExecBat_Ptr ;Setup message ptr ; M016
	jmp	short lhsp_errret		;return error; M016

no_exec_file:
	mov	ax,ERROR_FILE_NOT_FOUND
	call	LhSetupErrMsg		;setup error message

lhsp_errret:				; M016
	stc
	ret

SetupPath	endp



TRANCODE		ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\parse2.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)parse.asm	1.1 85/05/14
;	SCCSID = @(#)parse.asm	1.1 85/05/14
.sall
.xlist
.xcref
    INCLUDE DOSSYM.INC
    INCLUDE DEVSYM.INC
    include comsw.asm
    include comseg.asm
    include comequ.asm
.list
.cref


break <Parse.Asm>
;----------------------------------------------------------------------------
;    PARSE.ASM contains the routines to perform command line parsing.
;    Parse and Path share a buffer and argv[] definitions.
;   Invoking <Parseline> maps the unparsed command line in COMBUF into an
;   array of pointers to the parsed tokens.  The resulting array, argv[],
;   also contains extra information provided by cparse about each token
;   <Parseline> should be executed prior to <Path_Search>
;
; Alan L, OS/MSDOS				    August 15, 1983
;
;
; ENTRY:
;   <Parseline>:	    command line in COMTAB.
; EXIT:
;   <Parseline>:	    success flag, argcnt (number of args), argv[].
; NOTE(S):
;   *	<Argv_calc> handily turns an array index into an absolute pointer.
;	The computation depends on the size of an argv[] element (arg_ele).
;   *	<Parseline> calls <cparse> for chunks of the command line.  <Cparse>
;	does not function as specified; see <Parseline> for more details.
;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
;	need to know about.  This extra information is stored in a switch_flag
;	word with each command-line argument; the switches themselves will not
;	appear in the resulting arg structure.
;   *	With the exception of CARRY, flags are generally preserved across calls.
;---------------
; CONSTANTS:
;---------------
    DEBUGx	equ	    FALSE	; prints out debug info
;---------------
; DATA:
;---------------

DATARES 	SEGMENT PUBLIC BYTE
	EXTRN	FORFLAG:BYTE
DATARES     ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	combuf:byte
	EXTRN	cpyflag:byte
	EXTRN	expand_star:byte
	EXTRN	RESSEG:word
	EXTRN	STARTEL:word
TRANSPACE   ENDS

TRANCODE	SEGMENT PUBLIC BYTE	;AC000;
	PUBLIC	argv_calc		; convert array index into address
	PUBLIC	parseline


assume cs:trangroup, ds:trangroup, es:trangroup, ss:nothing


break <Parseline:  Munch on the command line>
;----------------------------------------------------------------------------
;    PARSELINE takes an MSDOS command line and maps it into a UNIX-style
; argv[argvcnt] array.	The most important difference between this array and
; the tradition UNIX format is the extra cparse information included with
; each argument element.
;---------------
; ENTRY:
;	(BL	     special delimiter for cparse -- not implemented)
;---------------
; EXIT:
;	CF	    set if error
;	AL	    error code (carry set).  Note AH clobbered in any event.
;	argv[]	    array of cparse flags and pointers to arguments
;	argvcnt     argument count
;---------------
; NOTE(S):
;	*   BL (special delimiter) is ignored, for now (set to space).
;	*   Parseflags record contains cparse flags, as follows:
;		sw_flag 	--	was this arg a switch?
;		wildcard	--	whether or not it contained a * or ?
;		path_sep	--	maybe it was a pathname
;		unused		--	for future expansion
;		special_delim	--	was there an initial special delimiter?
;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
;	*   Relationship between input, cparse output, and comtail can be
;	    found in the following chart.  Despite the claim of the cparse
;	    documentation that, "Token buffer always starts d:  for non switch
;	    tokens", such is not the case (see column two, row two).
;	    Similarly, [STARTEL] is not null when the command line is one of
;	    the forms, "d:", "d:\", or "d:/".  In fact, *STARTEL (i.e., what
;	    STARTEL addresses) will be null.  This is clearly just a
;	    documentation error.
;	*   cparse also returns a switch code in BP for each switch it
;	    recognizes on the command line.
;	*   arglen for each token does NOT include the terminating null.
;	*   Finally, note that interesting constructions like 'foodir/*.exe'
;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
;	    echo 'foodir', then '*', then '.exe'.  Using cparse for command-
;	    line parsing may result in slightly different behavior than
;	    previously observed with the old COMMAND.COM command-line parser.
;
;	    Input		    Cparse		Command Line (80H)
;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
;	alan\foo.bat		alan\foo.bat		alan\foo.bat
;	foo.bat 		foo.bat 		foo.bat
;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
;	c:foo.bat		c:foo.bat		c:foo.bat
;---------------
; CONSTANTS:
;---------------
;---------------
; DATA:
;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte
	EXTRN	argbufptr:word
	EXTRN	comptr:word
	EXTRN	last_arg:word
	EXTRN	tpbuf:byte
TRANSPACE	ENDS

;---------------
parseline:
;---------------

	push	AX				; most of these are clobbered
	push	BX				; by cparse...
	push	CX
	push	DX
	push	DI
	push	SI
	pushf
	mov	cpyflag,0			; Turn "CPARSE called from COPY flag" off

	mov	[LAST_ARG], -1			; last argument at which to accumulate
	xor	ax,ax
	mov	cx,SIZE arg_unit
	mov	di,offset trangroup:arg
	rep	stosb
	mov	argbufptr,offset trangroup:arg.argbuf
	mov	arg.argswinfo, 0		; switch information, and info to date
	mov	arg.argvcnt, 0			; initialize argvcnt/argv[]
	mov	SI, OFFSET TRANGROUP:combuf+2	; prescan leaves cooked input in combuf

; This next section of code (up to pcont:)  makes sure that si is set up for
; parsing.  It should point at COMBUF if FORFLAG is set and arg.argforcombuf
; otherwise.  This is done so that commands can get arg pointers into their
; original command line (or an exact copy of it) in arg_ocomptr.
; Arg.argforcombuf is used so that the for loop processor will always be able
; to get a hold of its original command line; even after COMBUF is blasted by
; the command to be repeated or the transient part of command has been
; reloaded.

	push	ds
	mov	ds,[RESSEG]
	assume	ds:resgroup
	cmp	FORFLAG,0
	pop	ds
	assume	ds:trangroup
	jnz	pcont
	mov	di,OFFSET TRANGROUP:arg.argforcombuf
	xor	ch,ch
	mov	cl,[COMBUF+1]
	inc	cl
	rep	movsb
	mov	si,OFFSET TRANGROUP:arg.argforcombuf

pcont:
	mov	DI, OFFSET TRANGROUP:tpbuf	; destination is temporary token buffer
	mov	BL, ' '                         ; no special delimiter, for now

parseloop:
	mov	comptr,si			; save ptr into original command buffer
	xor	BP, BP				; switch information put here by cparse
	mov	byte ptr [expand_star],0	; don't expand *'s to ?'s
	invoke	scanoff 			; skip leading blanks...
	invoke	cparse				; byte off a token (args in SI, DI, BL)
	jnc	More_prse
	or	BP,BP				; Check for trailing switch character
	jz	parsedone
	call	newarg				; We hit CR but BP is non-zero. The
						;   typical cause of this is that a
						;   switch char IMMEDIATELY preceeds
						;   the CR. We have an argument, but it
						;   is sort of an error.
	jmp	short parsedone 		; We're done (found the CR).

More_prse:
	mov	cpyflag,2			; tell CPARSE that 1st token is done
	call	newarg				; add to argv array (CX has char count)
	jnc	parseloop			; was everything OK?
	jmp	short parse_error		; NO, it wasn't -- bug out (CF set)

parsedone:					; successful completion of parseline
	popf
	clc
	jmp	short parse_exit

parse_error:					; error entry (er, exit) point
	popf
	stc
parse_exit:					; depend on not changing CF
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	ret

;---------------
; parseline ends
;----------------------------------------------------------------------------


break <NewArg>
;----------------------------------------------------------------------------
;   NEWARG adds the supplied argstring and cparse data to arg.argv[].
; ENTRY:
;   BH			argflags
;   CX			character count in argstring
;   DI			pointer to argstring
;   comptr		ptr to starting loc of current token in original command
;   [STARTEL]		cparse's answer to where the last element starts
; EXIT:
;   argbufptr		points to next free section of argbuffer
;   arg.argbuf		contains null-terminated argument strings
;   arg.argvcnt 	argument count
;   arg.argv[]		array of flags and pointers
;   arg.arg_ocomptr	ptr to starting loc of current token in original command
;   CF			set if error
;   AL			carry set:  error code; otherwise, zero
;---------------
newarg:
;---------------

	push	BX
	push	CX
	push	DX				; one never knows, do one?
	push	DI
	push	SI
	pushf
	call	arg_switch			; if it's a switch, record switch info
						; LEAVE SWITCH ON COMMAND LINE!!
;;;	jc	newarg_done			; previous arg's switches -- and leave

	cmp	arg.argvcnt, ARGMAX		; check to ensure we've not
	jge	too_many_args			; exceeded array limits
	mov	DH, BH				; save argflags
	mov	BX, arg.argvcnt 		; argv[argvcnt++] = arg data
	inc	arg.argvcnt
	mov	AX, OFFSET TRANGROUP:arg.argv
	call	argv_calc			; convert offset to pointer
	mov	[BX].argsw_word, 0		; no switch information, yet...
	mov	[BX].arglen, CX 		; argv[argvcnt].arglen = arg length
	mov	[BX].argflags, DH		; argv[argvcnt].argflags = cparse flags
	mov	SI, argbufptr
	mov	[BX].argpointer, SI		; argv[argvcnt].argpointer = [argbufptr]
	add	SI, [STARTEL]			; save startel from new location
	sub	SI, DI				; form pointer into argbuf
	mov	[BX].argstartel, SI		; argv[argvcnt].argstartel = new [STARTEL]
	mov	si,[comptr]
	mov	[BX].arg_ocomptr,si		; arg_ocomptr=ptr into original com line

	mov	SI, DI				; now save argstring in argbuffer
	mov	DI, argbufptr			; load the argbuf pointer and make
	add	DI, CX				; sure we're not about to run off
	cmp	DI, OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
	jge	buf_ovflow			; the end of the buffer (plus null byte)
	sub	DI, CX				; adjust the pointer
	cld
	rep	movsb				; and save the string in argbuffer
	mov	AL, ANULL			; tack a null byte on the end
	stosb
	mov	argbufptr, DI			; update argbufptr after copy

newarg_done:
	popf
	clc
	jmp	short newarg_exit

too_many_args:
	mov	AX, arg_cnt_error
	jmp	short newarg_error

buf_ovflow:
	mov	AX, arg_buf_ovflow

newarg_error:
	popf
	stc

newarg_exit:
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	ret

;---------------
; NewArg ends
;----------------------------------------------------------------------------


break <Arg_Switch>
;----------------------------------------------------------------------------
;   ARG_SWITCH decides if an argument might really be a switch.  In the
; event that it is, and we can recognize
; ENTRY:
;   As in <newarg>.
; EXIT:
;   CF	    --	    clear (wasn't a switch); set (was a switch)
; NOTE(S):
;   *	The mechanism mapping a switch into a bit-value depends entirely
;	on the order of definition in the <switch_list> variable and the
;	values chosen to define the bits in CMDT:COMEQU.ASM.  Change either
;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
;	this mechanism.  This code taken from CMDT:TCODE.ASM.
;   *	The <switch_list> declared below is redundant to one declared in
;	TDATA.ASM, and used in TCODE.ASM.
;   *	An ugly routine.
;---------------
; CONSTANTS:
;---------------
;   Constants come from the definitions in CMDT:COMEQU.ASM.
;---------------
; DATA:
;---------------

TRANSPACE	SEGMENT PUBLIC BYTE		;AC000;
    extrn   switch_list:byte
    switch_count    EQU     $-switch_list
transpace   ends

;---------------
Arg_Switch:
;---------------

	push	AX
	push	BX
	push	CX
	push	DI
	pushf
	test	BH, MASK sw_flag		; is it a switch? (preserve flag word)
	jz	arg_no_switch0
	cmp	[LAST_ARG], -1			; have we encountered any REAL args yet?
	je	arg_no_switch1			; no, so leading switches don't matter
	mov	BX, [LAST_ARG]			; yes, add switch info to last REAL arg
	mov	AX, OFFSET TRANGROUP:arg.argv
	call	argv_calc
	or	[BX].argsw_word, BP
	or	arg.argswinfo, BP

arg_yes_switch: 				; ah, sweet success...
	popf
	stc
	jmp	short arg_switch_exit

arg_no_switch0:
	mov	AX, arg.argvcnt 		; future switches should then affect
	mov	[LAST_ARG], AX			; this argument

arg_no_switch1: 				; wasn't a switch, or we're pretending
	popf
	clc

arg_switch_exit:
	pop	DI
	pop	CX
	pop	BX
	pop	AX
	ret

;---------------
; Arg_Switch ends
;----------------------------------------------------------------------------


break <Argv_calc>
;----------------------------------------------------------------------------
;   ARGV_CALC maps an array index into a byte-offset from the base of
; the supplied array.  Method used for computing the address is:
;	Array Index * Array Elt Size + Base Addr = Elt Addr
; ENTRY:
;   AX	    --	    base of array
;   BX	    --	    array index
; EXIT:
;   BX	    --	    byte offset
;---------------

argv_calc:
	push	ax				; Save base
	mov	al,bl				; al = array index
	mov	bl,SIZE argv_ele		; bl = size of an argv element
	mul	bl				; ax = base offset
	pop	bx				; Get base
	add	ax,bx				; Add in base offset
	xchg	ax,bx				; Restore ax and put byte offset in bx
	ret

;---------------
; argv_calc ends
;----------------------------------------------------------------------------



trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\stub.asm ===
page ,132
	title	Command Stub 
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M003	SR	07/16/90	Check if UMB loading enabled and if so
;				turn it off on return from Exec
;
;	M005	SR	07/20/90	Carousel hack. Added a hard-coded far
;				jump to the actual int 2fh entry 
;				point to fix Carousel problems.
;
;	M009	SR	08/01/90	Restore the UMB state before the Exec
;				from the saved state in LoadHiFlg.
;
;	M035	SR	10/27/90	Enable interrupts at the start of
;				the dispatch code. Otherwise interrupts
;				remain disabled through a whole
;                               of code which is not good.
;
;	M049	SR	1/16/91	Bug #5075. Reworked the scheduling
;				strategy. There is no common
;				dispatcher now. Each entry point
;				now checks A20 and then does a far
;				jump to the appropriate code. This
;				added about 15 bytes of code but the
;				speed increase and reentrancy are
;				well worth the price.
;



;
;This file contains the low memory stub for command.com which hooks all the
;entry points into the resident command.com and directs the calls to the
;appropriate routines in the resident code which may be located in HIMEM. 
;	The stub has been made part of the resident data and will always
;be duplicated on every invocation of command.com. However, the only stubs
;that actually hook the interrupt vectors belong to either the first 
;command.com or to any other command.com executed with the /p switch. 
;	The stub also keeps track of the current active data segment. The 
;INIT code of each command.com updates this variable via an int 2fh mechanism
;with its own data segment. The INIT code also updates a pointer in its data
;segment to the previous resident data segment. Whenever a command.com exits,
;the exit code picks up the previous data segment pointer from the current
;data segment and patches it into the CurResDataSeg variable in the stub.
;	Right now the stub does not bother about A20 switching. We assume
;A20 is always on. It just does a far jump to the resident code with the 
;value of the current data segment in one of the registers. A20 toggle 
;support maybe added as a future enhancement, if the need is felt.
;


	include comseg.asm
	include xmm.inc

INIT	segment

	extrn	ConProc:near

INIT	ends

CODERES	segment

	extrn	MsgInt2fHandler	:near
	extrn	Int_2e		:near
	extrn	Contc		:near
	extrn	DskErr		:near

CODERES	ends

DATARES	segment
	assume	cs:DATARES,ds:nothing,es:nothing,ss:nothing
	Org	0
ZERO	=	$

	Org	100h
ProgStart:
	jmp	RESGROUP:ConProc

	db	?		;make following table word-alligned


;
;All the entry points declared below are patched in at INIT time with the
;proper segment and offset values after the resident code segment has been
;moved to its final location
;
public	Int2f_Entry, Int2e_Entry, Ctrlc_Entry, CritErr_Entry, Lodcom_Entry
public	Exec_Entry, RemCheck_Entry, TrnLodCom1_Entry, MsgRetrv_Entry
public	HeadFix_Entry
public	XMMCallAddr, ComInHMA

;!!!WARNING!!!
; All the dword ptrs from Int2f_Entry till MsgRetrv_Entry should be contiguous
;because the init routine 'Patch_stub' (in init.asm) relies on this to patch
;in the correct segments and offsets
;

Int2f_Entry 	label 	dword
		dw	offset RESGROUP:MsgInt2fHandler	;Address of int 2fh handler
		dw	0

Int2e_Entry 	label	dword
		dw	offset RESGROUP:Int_2e ;Address of int 2eh handler
		dw	0

Ctrlc_Entry	label	dword
		dw	offset RESGROUP:ContC ;Address of Ctrl-C handler
		dw	0

CritErr_Entry	label	dword
		dw	offset RESGROUP:DskErr ;Address of critical error handler
		dw	0

Exec_Entry	dd	?	;Entry from transient to Ext_Exec
RemCheck_Entry	dd	?	;Entry from transient to TRemCheck
TrnLodCom1_Entry	dd	?	;Entry from transient to LodCom1
LodCom_Entry	dd	?	;Entry after exit from command.com
MsgRetrv_Entry	dd	?	;Entry from external to MsgRetriever
HeadFix_Entry	dd	?	;Entry from trans to HeadFix

UMBOff_Entry	dd	?	;Entry from here to UMBOff routine; M003

XMMCallAddr	dd	?	;Call address for XMM functions
ComInHMA		db	0	;Flags if command.com in HMA

public	Int2f_Trap, Int2e_Trap, Ctrlc_Trap, CritErr_Trap
public	Exec_Trap, RemCheck_Trap, LodCom_Trap, MsgRetrv_Trap, TrnLodcom1_Trap
public	HeadFix_Trap


Int2f_Trap:
	sti
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	Int2f_Entry

Int2e_Trap:
	sti
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	Int2e_Entry

Ctrlc_Trap:
	sti
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	Ctrlc_Entry

CritErr_Trap:
	sti
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	CritErr_Entry

Exec_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	Exec_Entry

RemCheck_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	RemCheck_Entry

TrnLodCom1_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	TrnLodCom1_Entry

LodCom_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	LodCom_Entry

MsgRetrv_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	MsgRetrv_Entry

HeadFix_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	HeadFix_Entry

CheckA20	proc

	pushf				;save current flags
	push	ax
	cmp	cs:ComInHMA,0		;is resident in HMA?
	jz	A20_on			;no, jump to resident

	call	QueryA20
	jnc	A20_on			;A20 is on, jump to resident

	call	EnableA20		;turn A20 on
A20_on:
	pop	ax
	popf				;flags have to be unchanged
	ret

CheckA20	endp


;
; M005; This is a far jump to the actual int 2fh entry point. The renormalized
; M005; int 2fh cs:ip points here. We hardcode a far jump here to the int 2fh
; M005; handler. Note that we have to hardcode a jump and we cannot use any
; M005; pointers because our cs is going to be different. The segment to
; M005; jump to is patched in at init time. (in init.asm)
;

public Carousel_i2f_Hook		; M005
Carousel_i2f_Hook:			; M005
	db	0eah			; far jump opcode; M005
	dw	offset DATARES:Int2f_Trap	; int 2fh offset ; M005
	dw	?			; int 2fh segment; M005


QueryA20	proc	near

	push	bx
	push	ax
	mov	ah, XMM_QUERY_A20
	call	cs:XMMCallAddr
	or	ax, ax
	pop	ax
	pop	bx
	jnz	short QA20_ON			; AX = 1 => ON

	stc					; OFF
	ret
QA20_ON:
	clc					; ON
	ret

QueryA20	endp



EnableA20	proc	near

	push	bx
	push	ax
	mov	ah, XMM_LOCAL_ENABLE_A20
	call	cs:XMMCallAddr
	or	ax, ax
	jz	XMMerror		; AX = 0 fatal error
	pop	ax
	pop	bx
	ret
;
;If we get an error, we just loop forever
;
XMMerror:
	jmp	short XMMerror
	
EnableA20	endp


;
;The Exec call has to be issued from the data segment. The reason for this 
;is TSRs. When a TSR does a call to terminate and stay resident, the call
;returns with all registers preserved and so all our segment registers are
;still set up. However, if the TSR unloads itself later on, it still 
;comes back here. In this case the segment registers and the stack are
;not set up and random things can happen. The only way to setup all the 
;registers is to use the cs value and this can only be done when we are in
;the data segment ourselves. So, this piece of code had to be moved from
;the code segment to the data segment.
;

	extrn	RStack:WORD
	extrn	LoadHiFlg:BYTE

public 	Issue_Exec_Call
Issue_Exec_Call:
	int 	21h
;
;We disable interrupts while changing the stack because there is a bug in 
;some old 8088 processors where interrupts are let through while ss & sp
;are being changed.
;
	cli
	push	cs
	pop	ss
	mov	sp,offset DATARES:RStack	;stack is set up
	sti
	push	cs
	pop	ds			;ds = DATARES
; 
; M009; Restore UMB state to that before Exec
;
;; save execution status(carry flag)
;; and the error code(AL)
	pushf				;save flags ; M003
	push	ax
	mov	al,LoadHiFlg		;current UMB state ; M009
	test	al,80h			;did we try to loadhigh? ;M009
	jz	no_lh			;no, dont restore ;M009
	and	al,7fh			;clear indicator bit ;M009
	call	dword ptr UMBOff_Entry	;restore UMB state ; M009
no_lh:					; M009
	and	LoadHiFlg,7fh		;clear loadhigh indicator bit
					;M009
	pop	ax
	popf				; M003; *bugbug -- popff??
;
;We now jump to the stub trap which returns us to the resident code. All
;flags are preserved by the stub code.
;
	jmp	Exec_Trap


DATARES	ends
	end	ProgStart


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tcmd1a.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
************************************************************
************************************************************
**							  **
**  THIS FILE IS OBSOLETE, NO LONGER USED, DEFUNCT,	  **
**  AND, IN FACT, DOESN'T EVEN EXIST.  YOU ARE NOT	  **
**  HERE.  YOU MAY NOT BE ANYWHERE AT ALL.  THIS	  **
**  WHOLE THING COULDN'T POSSIBLY BE HAPPENING.		  **
**							  **
**  See DIR.ASM for a reality check.			  **
**							  **
************************************************************
************************************************************

 page 80,132
;	SCCSID = @(#)tcmd1a.asm 1.1 85/05/14
;	SCCSID = @(#)tcmd1a.asm 1.1 85/05/14
TITLE	PART4 COMMAND Transient routines.

;	Internal commands DIR,PAUSE,ERASE,TYPE,VOL,VER

	INCLUDE comsw.asm
.xlist
.xcref
	INCLUDE DOSSYM.INC
	INCLUDE comseg.asm
	INCLUDE comequ.asm		;AC000;
	include ioctl.inc		;AN000;
.list
.cref

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BadCD_ptr:word
	EXTRN	bits:word
	EXTRN	Bytmes_ptr:word
	EXTRN	comsw:word
	EXTRN	dir_w_syn:word		;AC000;
	EXTRN	dirdat_mo_day:word	;AC000;
	EXTRN	dirdat_yr:word		;AC000;
	EXTRN	dirdattim_ptr:word
	EXTRN	dirhead_ptr:word
	EXTRN	dirtim_hr_min:word	;AC000;
	EXTRN	Dirmes_ptr:word
	EXTRN	disp_file_size_ptr:word
	EXTRN	Dmes_ptr:word
	EXTRN	Extend_buf_ptr:word	;AN000;
	EXTRN	msg_disp_class:byte	;AN000;
	EXTRN	parse_dir:byte		;AC000;
	EXTRN	slash_p_syn:word	;AC000;
	EXTRN	string_buf_ptr:word
	EXTRN	tab_ptr:word		;AC000;
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	bytes_free:word
	EXTRN	charbuf:byte
	EXTRN	COM:byte
	EXTRN	Destisdir:byte
	EXTRN	Desttail:word
	EXTRN	dir_num:word
	EXTRN	Dirbuf:byte
	EXTRN	dirflag:byte		;AN015;
	EXTRN	display_ioctl:word	;AC000;
	EXTRN	display_mode:byte	;AC000;
	EXTRN	filecnt:word
	EXTRN	file_size_high:word
	EXTRN	file_size_low:word
	EXTRN	fullscr:word
	EXTRN	ID:byte
	EXTRN	lincnt:byte		;AC000;
	EXTRN	linlen:byte
	EXTRN	linperpag:word		;AC000;
	EXTRN	msg_numb:word		;AN022;
	EXTRN	parse1_addr:dword	;AC000;
	EXTRN	parse1_syn:word 	;AC000;
	EXTRN	parse1_type:byte	;AC000;
	EXTRN	pathcnt:word		;AN000;
	EXTRN	pathpos:word		;AN000;
	EXTRN	srcbuf:byte		;AC000;
	EXTRN	string_ptr_2:word
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
TRANSPACE	ENDS
;---------------

	EXTRN	cerror:near
	EXTRN	std_printf:near


	PUBLIC	catalog


	break	Catalog - Directory command
assume	ds:trangroup,es:trangroup

;
; The DIR command displays the contents of a directory.
;
; ****************************************************************
; *
; * ROUTINE:	 CATALOG - display file(s) in directory
; *
; * FUNCTION:	 PARSE command line for drive, file, or path name.
; *		 DIR allows two switches, /P (pause) and /W (wide).
; *		 If an error occurs issue and error message and
; *		 transfer control to CERROR.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

CATALOG:

;
; Set up DTA for dir search firsts
;
	mov	dx,offset trangroup:Dirbuf	;AC000; Set Disk transfer address
	mov	ah,Set_DMA			;AC000;
	int	int_command			;AC000;
;
; Set up defaults for switches and parse the command line.
;
	mov	msg_numb,0			;AN022; initialize message flag
	mov	di,offset trangroup:srcbuf	;AN000; get address of srcbuf
	mov	[pathpos],di			;AN000; this is start of path
	mov	[pathcnt],1			;AN000; initialize length to 1 char
	mov	al,star 			;AN000; initialize srcbuf to *,0d
	stosb					;AN000;
	mov	al,end_of_line_in		;AN000;
	stosb					;AN000;
	mov	si,81H				;AN000; Get command line
	mov	di,offset trangroup:parse_dir	;AN000; Get adderss of PARSE_DIR
	xor	cx,cx				;AC000; clear counter for positionals
	mov	ComSw,cx			;AC000; initialize flags
	mov	bits,cx 			;AC000; initialize switches
	mov	linperpag,linesperpage		;AC000; Set default for lines per page
	mov	linlen,normperlin		;AC000; Set number of entries per line
	mov	lincnt,normperlin		;AC000;

dirscan:
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,end_of_line			;AN000; are we at end of line?
	jne	dirscan_cont			;AN000; No - continue parsing
	jmp	scandone			;AN000; yes - go process

dirscan_cont:
	cmp	ax,result_no_error		;AN000; did we have an error?
	jz	dirscan_cont2			;AN000; No - continue parsing
	jmp	badparm 			;AN000; yes - exit

dirscan_cont2:
	cmp	parse1_syn,offset trangroup:dir_w_syn ;AN000; was /W entered?
	je	set_dir_width			;AN000; yes - go set wide lines
	cmp	parse1_syn,offset trangroup:slash_p_syn ;AN000; was /P entered?
	je	set_dir_pause			;AN000; yes - go set pause at end of screen
;
; Must be filespec since no other matches occurred. move filename to srcbuf
;
	push	si				;AC000; save position in line
	lds	si,parse1_addr			;AC000; get address of filespec
	push	si				;AN000; save address
	invoke	move_to_srcbuf			;AC000; move to srcbuf
	pop	dx				;AC000; get address in DX

;
; The user may have specified a device.  Search for the path and see if the
; attributes indicate a device.
;
	mov	ah,Find_First			;AC000; find the file
	int	int_command			;AC000;
	jnc	Dir_check_device		;AN022; if no error - check device
	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_no_more_files		;AN022; was error no file found
	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
	cmp	ax,error_path_not_found 	;AN022; was error no file found
	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
	jmp	dir_err_setup			;AN022; otherwise - go issue error message

dir_check_device:				;AN022;
	test	byte ptr (DirBuf+find_buf_attr),attr_device ;AC000;
	jz	Dir_fspec_end			;AC000; no, go do normal operation
	mov	ComSw,-2			;AC000; signal device

dir_fspec_end:
	pop	si				;AC000; restore position in line
	jmp	short dirscan			;AC000; keep parsing

set_dir_width:
	test	byte ptr[bits],SwitchW		;AN018; /W already set?
	jz	ok_set_width			;AN018; no - okay to set width
	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
	invoke	setup_parse_error_msg		;AN018; set up an error message
	jmp	badparm 			;AN018; exit

ok_set_width:
	or	bits,switchw			;AC000; indicate /w was selected
	mov	linlen,wideperlin		;AC000; Set number of entries per line
	mov	lincnt,wideperlin		;AC000;
	jmp	short dirscan			;AC000; keep parsing

set_dir_pause:
	test	byte ptr[bits],SwitchP		;AN018; /p already set?
	jz	ok_set_pause			;AN018; no - okay to set width
	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
	invoke	setup_parse_error_msg		;AN018; set up an error message
	jmp	badparm 			;AN018; exit

ok_set_pause:
	or	bits,switchp			;AC000; indicate /p was selected
	push	cx				;AN000; save necessary registers
	push	si				;AN000;
	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ;AN000; get lines per page on display
	mov	bx,stdout			;AN000; lines for stdout
	mov	ch,ioc_sc			;AN000; type is display
	mov	cl,get_generic			;AN000; get information
	mov	dx,offset trangroup:display_ioctl ;AN000;
	int	int_command			;AN000;

lines_set:
	dec	linperpag			;AN000; lines per actual page should
	dec	linperpag			;AN000;     two less than the max
	mov	ax,linperpag			;AN000; get number of lines into
	mov	[fullscr],ax			;AC000;    screen line counter
	pop	si				;AN000; restore registers
	pop	cx				;AN000;
	jmp	dirscan 			;AC000; keep parsing

;
; The syntax is incorrect.  Report only message we can.
;
BadParm:
	jmp	cerror				;AC000; invalid switches get displayed

ScanDone:

;
; Find and display the volume ID on the drive.
;

	invoke	okvolarg			;AC000;
;
; OkVolArg also disables APPEND, which will be re-enabled
; in the HeadFix routine, after we're done.
;
	mov	[filecnt],0			;AC000; Keep track of how many files found
	cmp	comsw,0 			;AC000; did an error occur?
	jnz	doheader			;AC000; yes - don't bother to fix path

	mov	dirflag,-1			;AN015; set pathcrunch called from DIR
	invoke	pathcrunch			;AC000; set up FCB for dir
	mov	dirflag,0			;AN015; reset dirflag
	jc	DirCheckPath			;AC015; no CHDIRs worked.
	jz	doheader			;AC015; chdirs worked - path\*.*
	mov	si,[desttail]			;AN015; get filename back
	jmp	short DoRealParse		;AN015; go parse it

DirCheckPath:
	mov	ax,[msg_numb]			;AN022; get message number
	cmp	ax,0				;AN022; Is there a message?
	jnz	dir_err_setup			;AN022; yes - there's an error
	cmp	[destisdir],0			;AC000; Were pathchars found?
	jz	doparse 			;AC000; no - no problem
	inc	comsw				;AC000; indicate error
	jmp	short doheader			;AC000; go print header

DirNF:
	mov	ax,error_file_not_found 	;AN022; get message number in control block

dir_err_setup:
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
	mov	extend_buf_ptr,ax		;AN022;

DirError:
	jmp	Cerror

;
; We have changed to something.  We also have a file.  Parse it into a
; reasonable form, leaving drive alone, leaving extention alone and leaving
; filename alone.  We need to special case ...	If we are at the root, the
; parse will fail and it will give us a file not found instead of file not
; found.
;
DoParse:
	mov	si,offset trangroup:srcbuf	;AN000; Get address of source
	cmp	byte ptr [si+1],colon_char	;AN000; Is there a drive?
	jnz	dir_no_drive			;AN000; no - keep going
	lodsw					;AN000; bypass drive

dir_no_drive:
	cmp	[si],".."
	jnz	DoRealParse
	cmp	byte ptr [si+2],0
	jnz	DoRealParse
	inc	ComSw
	jmp	short DoHeader

DoRealParse:
	mov	di,FCB			; where to put the file name
	mov	ax,(Parse_File_Descriptor SHL 8) OR 0EH
	int	int_command

;
; Check to see if APPEND installed.  If it is installed, set all flags
; off.	This will be reset in the HEADFIX routine
;

DoHeader:
; ORIGINAL APPEND CHECK CODE LOCATION ******************************

;
; Display the header
;

DoHeaderCont:
	mov	al,blank			;AN051; Print out a blank
	invoke	print_char			;AN051;   before DIR header
	invoke	build_dir_string		; get current dir string
	mov	dx,offset trangroup:Dirhead_ptr
	invoke	printf_crlf			; bang!

;
; If there were chars left after parse or device, then invalid file name
;
	cmp	ComSw,0
	jz	DoSearch			; nothing left; good parse
	jl	DirNFFix			; not .. => error file not found
	invoke	RestUDir
	mov	dx,offset TranGroup:BadCD_ptr
	jmp	Cerror				; was .. => error directory not found
DirNFFix:
	invoke	RestUDir
	jmp	DirNF
;
; We are assured that everything is correct.  Let's go and search.  Use
; attributes that will include finding directories.  perform the first search
; and reset our directory afterward.
;
DoSearch:
	mov	byte ptr DS:[FCB-7],0FFH
	mov	byte ptr DS:[FCB-1],010H
;
; Caution!  Since we are using an extended FCB, we will *also* be returning
; the directory information as an extended FCB.  We must bias all fetches into
; DIRBUF by 8 (Extended FCB part + drive)
;
	mov	ah,Dir_Search_First
	mov	dx,FCB-7
	int	int_command

	push	ax				;AN022; save return state
	inc	al				;AN022; did an error occur?
	pop	ax				;AN022; get return state back
	jnz	found_first_file		;AN022; no error - start dir
	invoke	set_ext_error_msg		;AN022; yes - set up error message
	push	dx				;AN022; save message
	invoke	restudir			;AN022; restore user's dir
	pop	dx				;AN022; restore message
	cmp	word ptr Extend_Buf_Ptr,Error_No_More_Files ;AN022; convert no more files to
	jnz	DirCerrorJ			;AN022; 	file not found
	mov	Extend_Buf_Ptr,Error_File_Not_Found  ;AN022;

DirCerrorJ:					;AN022;
	jmp	Cerror				;AN022; exit

;
; Restore the user's directory.  We preserve, though, the return from the
; previous system call for later checking.
;

found_first_file:
	push	ax
	invoke	restudir
	pop	ax
;
; Main scanning loop.  Entry has AL = Search first/next error code.  Test for
; no more.
;
DIRSTART:
	inc	al				; FF = file not found
	jnz	Display
	jmp	DirDone 			; Either an error or we are finished
;
; Note that we've seen a file and display the found file.
;

Display:
	inc	[filecnt]			; Keep track of how many we find
	mov	si,offset trangroup:dirbuf+8	; SI -> information returned by sys call
	call	shoname
;
; If we are displaying in wide mode, do not output the file info
;
	test	byte ptr[bits],SwitchW		; W switch set?
	jz	DirTest
	jmp	nexent				; If so, no size, date, or time

;
; Test for directory.
;
DirTest:
	test	[dirbuf+8].dir_attr,attr_directory
	jz	fileent
;
; We have a directory.	Display the <DIR> field in place of the file size
;
	mov	dx,offset trangroup:Dmes_ptr
	call	std_printf
	jmp	short nofsiz
;
; We have a file.  Display the file size
;
fileent:
	mov	dx,[DirBuf+8].dir_size_l
	mov	file_size_low,dx
	mov	dx,[DirBuf+8].dir_size_h
	mov	file_size_high,dx
	mov	dx,offset trangroup:disp_file_size_ptr
	call	std_printf
;
; Display time and date of last modification
;
nofsiz:
	mov	ax,[DirBuf+8].dir_date		; Get date
;
; If the date is 0, then we have found a 1.x level diskette.  We skip the
; date/time fields as 1.x did not have them.
;
	or	ax,ax
	jz	nexent				; Skip if no date
	mov	bx,ax
	and	ax,1FH				; get day
	mov	dl,al
	mov	ax,bx
	mov	cl,5
	shr	ax,cl				; Align month
	and	al,0FH				; Get month
	mov	dh,al
	mov	cl,bh
	shr	cl,1				; Align year
	xor	ch,ch
	add	cx,80				; Relative 1980
	cmp	cl,100
	jb	millenium
	sub	cl,100

millenium:
	xchg	dh,dl				;AN000; switch month & day
	mov	DirDat_yr,cx			;AC000; put year into message control block
	mov	DirDat_mo_day,dx		;AC000; put month and day into message control block
	mov	cx,[DirBuf+8].dir_time		; Get time
	jcxz	prbuf				; Time field present?
	shr	cx,1
	shr	cx,1
	shr	cx,1
	shr	cl,1
	shr	cl,1				; Hours in CH, minutes in CL
	xchg	ch,cl				;AN000; switch hours & minutes
	mov	DirTim_hr_min,cx		;AC000; put hours and minutes into message subst block

prbuf:
	mov	dx,offset trangroup:DirDatTim_ptr
	call	std_printf
	invoke	crlf2				;AC066;end the line
	dec	byte ptr [fullscr]		;AC066;count the line
	jnz	endif04 			;AN066;IF the last on the screen THEN
	   call    check_for_P			;AN066;   pause if /P requested
	endif04:				;AN066;
	jmp	scroll				; If not, just continue
;AD061; mov	DirDat_yr,0			;AC000; reset year, month and day
;AD061; mov	DirDat_mo_day,0 		;AC000;     in control block
;AD061; mov	DirTim_hr_min,0 		;AC000; reset hour & minute in control block
;
; We are done displaying an entry.  The code between "noexent:" and "scroll:"
; is only for /W case.
;
nexent:
	mov	bl,[lincnt]			;AN066;save for check for first entry on line
	dec	[lincnt]			      ;count this entry on the line
	jnz	else01				;AX066;IF last entry on line THEN
	   mov	   al,[linlen]
	   mov	   [lincnt],al
	   invoke  crlf2
	   cmp	   [fullscr],0			;AC066;IF have filled the screen THEN
	   jnz	   endif02			;AN066;
	      call    check_for_P		;AN066;   reinitialize fullscr,
	   endif02:				;AN066;   IF P requested THEN pause
	   jmp	   short endif01		;AN066;
	else01: 				;AN066;ELSE since screen not full
	   cmp	   bl,[linlen]			;AN066;   IF starting new line THEN
	   jne	   endif03			;	     count the line
	      dec     byte ptr [fullscr]	;AN066;   ENDIF
	   endif03:				;AC066;We are outputting on the same line, between fields, we tab.
	   mov	   dx,offset trangroup:tab_ptr	;Output a tab
	   call    std_printf
	endif01:				;AX066;
;
; All we need to do now is to get the next directory entry.
;
scroll:
	mov	ah,Dir_Search_Next
	mov	dx,FCB-7			; DX -> Unopened FCB
	int	int_command			; Search for a file to match FCB
	jmp	DirStart
;
; If no files have been found, display a not-found message
;
DirDone:
	invoke	get_ext_error_number		;AN022; get the extended error number
	cmp	ax,error_no_more_files		;AN022; was error file not found?
	jnz	dir_err_setup_jmp		;AN022; no - setup error message
	test	[filecnt],-1
	jnz	Trailer
	mov	ax,error_file_not_found 	;AN022;

dir_err_setup_jmp:				;AN022;
	jmp	dir_err_setup			;AN022; go setup error msg & print it
;
; If we have printed the maximum number of files per line, terminate it with
; CRLF.
;
Trailer:
	mov	al,[linlen]
	cmp	al,[lincnt]			; Will be equal if just had CR/LF
	jz	mmessage
	invoke	crlf2
	cmp	[fullscr],0			;AN066;IF on last line of screen THEN
	jnz	endif06 			;AN066;   pause before going on
	   call    check_for_P			;AN066;   to number and freespace
	endif06:				;AN066;   displays

mmessage:
	mov	dx,offset trangroup:Dirmes_ptr
	mov	si,[filecnt]
	mov	dir_num,si
	call	std_printf
	mov	ah,Get_Drive_Freespace
	mov	dl,byte ptr DS:[FCB]
	int	int_command
	cmp	ax,-1
	retz
	mul	cx				; AX is bytes per cluster
	mul	bx
	mov	bytes_free,ax			;AC000;
	mov	bytes_free+2,dx 		;AC000;
	MOV	DX,OFFSET TRANGROUP:BYTMES_ptr
	jmp	std_printf

shoname:
	mov	di,offset trangroup:charbuf
	mov	cx,8
	rep	movsb
	mov	al,' '
	stosb
	mov	cx,3
	rep	movsb
	xor	ax,ax
	stosb
	push	dx
	mov	dx,offset trangroup:charbuf
	mov	string_ptr_2,dx
	mov	dx,offset trangroup:string_buf_ptr
	call	std_printf
	pop	DX
	return

check_for_P    PROC  NEAR			;AN066;

test	byte ptr[bits],SwitchP	     ;P switch present?
jz	endif05 				;AN066;
   mov	   ax,linperpag 		   ;AN000;  transfer lines per page
   mov	   [fullscr],ax 		   ;AC000;	to fullscr
   invoke  Pause
endif05:
ret						;AN066;

check_for_P    ENDP				;AN066;

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tcmd2a.asm ===
page ,132
;	SCCSID = @(#)tcmd2a.asm 4.1 85/06/25
;	SCCSID = @(#)tcmd2a.asm 4.1 85/06/25
TITLE	PART5 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;	Revision History
;	================
;	M01	md 7/13/90	Changed CLS to access ROM BIOS data directly
;
;	M013	SR	08/06/90	Changed Version to use new call to
;				get info about DOS in HMA or ROM.
;	M018	md	08/12/90	Increment screen height by 1 when
;					obtained from ROM BIOS.
;	M022	md	08/29/80	Set correct video page in REG_CLS

	INCLUDE comsw.asm

.xlist
.xcref
	include dossym.inc
	include bpb.inc
	include syscall.inc
	include filemode.inc
	include sf.inc
	include comequ.asm
	include comseg.asm
	include ioctl.inc
	include rombios.inc		;M01
.list
.cref


CODERES 	SEGMENT PUBLIC BYTE	;AC000;
CODERES 	ENDS

DATARES 	SEGMENT PUBLIC BYTE	;AC000;
DATARES 	ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg_buf_ptr:word
	EXTRN	BadCurDrv:byte		;AC000;
	EXTRN	clsstring:byte
	EXTRN	dback_ptr:word
	EXTRN	display_ioctl:word	;AN000;
	EXTRN	display_width:word	;AN000;
	EXTRN	DosHma_Ptr:word
	EXTRN	DosLow_Ptr:word
	EXTRN	DosRev_Ptr:word
	EXTRN	DosRom_Ptr:word
	EXTRN	Extend_buf_ptr:word	;AN049;
	EXTRN	linperpag:word		;AN000;
	EXTRN	msg_disp_class:byte	;AN049;
	EXTRN	nulpath_ptr:word
	EXTRN	Parse_Ver:byte
	EXTRN	prompt_table:word
	EXTRN	string_buf_ptr:word	;AC000;
	EXTRN	vermes_ptr:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	Arg_Buf:byte
	EXTRN	bwdbuf:byte
	EXTRN	curdrv:byte
	EXTRN	dirchar:byte
	EXTRN	major_ver_num:word
	EXTRN	minor_ver_num:word
	EXTRN	One_Char_Val:byte
	EXTRN	srcxname:byte		;AN049;
	EXTRN	string_ptr_2:word
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
transpace	ends
;---------------

	EXTRN	cerror:near		;AN049;
	EXTRN	crlf2:near
	EXTRN	drvbad:near
	EXTRN	std_printf:near

	PUBLIC	build_dir_for_chdir
	PUBLIC	build_dir_for_prompt
	PUBLIC	build_dir_string
	PUBLIC	cls
	PUBLIC	path
	PUBLIC	print_char
	PUBLIC	print_drive
	PUBLIC	print_version
	PUBLIC	print_b
	PUBLIC	print_back
	PUBLIC	print_eq
	PUBLIC	print_esc
	PUBLIC	print_g
	PUBLIC	print_l
	PUBLIC	print_prompt
	PUBLIC	version


	break	Version

;***	Version - display DOS version
;
;	SYNTAX	ver [/debug]
;
;		/debug - display additional DOS configuration info
;
;	ENTRY	command-line tail is in PSP
;
;	EXIT	if successful, nothing
;		if parse fails,
;		  parse error message is set up (for Std_EPrintf)
;		    AX = system parser error code
;		    DX = ptr to message block
;		  we jump to CError
;
;	EFFECTS
;	  If parse fails, a parse error message is displayed.
;	  Otherwise, version message is displayed.
;	  If /debug is specified, additional DOS info is displayed.

Version:
	assume	ds:TRANGROUP,es:TRANGROUP

;	Parse command line for /debug switch.

	mov	si,81h				; DS:SI = ptr to command tail
	mov	di,offset TRANGROUP:Parse_Ver	; ES:DI = ptr to parse block
	xor	cx,cx				; CX = # positional param's found
	invoke	Parse_With_Msg

	mov	bl,1			; BL = flag = /debug present
	cmp	ax,RESULT_NO_ERROR
	je	verPrintVer		; something parsed - must be /debug
	dec	bl			; BL = flag = no /debug present
	cmp	ax,END_OF_LINE
	je	verPrintVer		; reached end of line - ok

;	The parse failed.  Error message has been set up.

	jmp	CError

verPrintVer:
	push	bx			; save /debug flag
	call	Crlf2
	call	Print_Version
	call	Crlf2
	pop	bx   			; BL = /debug flag
	or	bl,bl
	jz	verDone			; /debug is false - we're done

;*	For /debug, display DOS internal revision and DOS location
;	(low memory, HMA, or ROM).

;	Bugbug:	use symbols for bitmasks below.

	mov	ax,(SET_CTRL_C_TRAPPING shl 8) + 6 ; M013
	int	21h
	mov	al,dl			;revision number in dl; M013
	mov	bh,dh			;flags in dh now; M013
;M032	and	al,7			; AL = DOS internal revision
	cmp	al,'Z'-'A'	;M032	; revision in A-to-Z range?
	jbe	@f		;M032	; A-to-Z revision ok
	mov	al,'*'-'A'	;M032	; beyond Z, just say revision *
@@:	add	al,'A'			; AL = DOS internal rev letter
	mov	One_Char_Val,al
	mov	dx,offset TRANGROUP:DosRev_Ptr
	invoke	Std_Printf		; print DOS internal revision

	mov	cl,4
	shr	bh,cl			; CY = DOS in ROM
	jc	verRom
	shr	bh,1			; CY = DOS in HMA
	jc	verHma

;	DOS isn't in ROM or HMA, so it must be in lower memory.

	mov	dx,offset TRANGROUP:DosLow_Ptr
	jmp	short verPrintLoc
verRom:	mov	dx,offset TRANGROUP:DosRom_Ptr
	jmp	short verPrintLoc
verHma:	mov	dx,offset TRANGROUP:DosHma_Ptr
verPrintLoc:
	invoke	Std_Printf
verDone:
	jmp	Crlf2

Print_Version:
	mov	ah,GET_VERSION
	int	21h
	push	ax
	xor	ah,ah
	mov	Major_Ver_Num,ax
	pop	ax
	xchg	ah,al
	xor	ah,ah
	mov	Minor_Ver_Num,ax
	mov	dx,offset TRANGROUP:VerMes_Ptr
	jmp	Std_Printf




	assume	ds:TRANGROUP,es:TRANGROUP
print_prompt:
	push	ds
	push	cs
	pop	ds				; MAKE SURE DS IS IN TRANGROUP
	push	es
	invoke	find_prompt			; LOOK FOR PROMPT STRING
	jc	PP0				; CAN'T FIND ONE
	cmp	byte ptr es:[di],0
	jnz	PP1
PP0:
	call	print_drive			; USE DEFAULT PROMPT
	mov	al,sym
	call	print_char
	jmp	short PP5

PP1:
	mov	al,es:[di]			; GET A CHAR
	inc	di
	or	al,al
	jz	PP5				; NUL TERMINATED
	cmp	al,dollar			; META CHARACTER?
	jz	PP2				; NOPE
PPP1:
	call	print_char
	jmp	PP1

PP2:
	mov	al,es:[di]
	inc	di
	mov	bx,offset trangroup:prompt_table-3
	or	al,al
	jz	PP5

PP3:
	add	bx,3
	invoke	upconv
	cmp	al,[bx]
	jz	PP4
	cmp	byte ptr [bx],0
	jnz	PP3
	jmp	PP1

PP4:
	push	es
	push	di
	push	cs
	pop	es
	call	[bx+1]
	pop	di
	pop	es
	jmp	PP1

PP5:
	pop	es				; RESTORE SEGMENTS
	pop	ds
	return


print_back:
	mov	dx,offset trangroup:dback_ptr
	jmp	std_printf

print_EQ:
	mov	al,'='
	jmp	short print_char

print_esc:
	mov	al,1BH
	jmp	short print_char

print_G:
	mov	al,rabracket
	jmp	short print_char

print_L:
	mov	al,labracket
	jmp	short print_char

print_B:
	mov	al,vbar

print_char:

;	Bugbug:	Why bother with ds,es here?

	push	es
	push	ds
	pop	es
	push	di
	push	dx
	mov	dl,al				;AC000; Get char into al
	mov	ah,Std_CON_output		;AC000; print the char to stdout
	int	21h			;AC000;
	pop	dx
	pop	di
	pop	es
	ret

print_drive:
	mov	ah,Get_Default_drive
	int	21h
	add	al,capital_A
	call	print_char
	ret

ASSUME	DS:TRANGROUP,ES:TRANGROUP

build_dir_for_prompt:
	xor	dl,dl
	mov	si,offset trangroup:bwdbuf
	mov	di,SI
	mov	al,CurDrv
	add	al,'A'
	mov	ah,':'
	stosw
	mov	al,[dirchar]
	stosb
	xchg	si,di
	mov	string_ptr_2,di
	mov	ah,Current_dir
	int	21h
	mov	dx,offset trangroup:string_buf_ptr
	jnc	DoPrint
	mov	dx,offset trangroup:BadCurDrv
DoPrint:
	call	std_printf

	ret

build_dir_for_chdir:
	call	build_dir_string
	mov	dx,offset trangroup:bwdbuf
	mov	string_ptr_2,dx
	mov	dx,offset trangroup:string_buf_ptr
	call	std_printf
	ret

build_dir_string:
	mov	dl,ds:[FCB]
	mov	al,DL
	add	al,'@'
	cmp	al,'@'
	jnz	gotdrive
	add	al,[CURDRV]
	inc	al

gotdrive:
	push	ax
	mov	si,offset trangroup:bwdbuf+3
	mov	ah,Current_dir
	int	21h
	jnc	dpbisok
	push	cs
	pop	ds
	jmp	drvbad

dpbisok:
	mov	di,offset trangroup:bwdbuf
	mov	dx,di
	pop	ax
	mov	ah,':'
	stosw
	mov	al,[dirchar]
	stosb

	ret

	break	Path
assume	ds:trangroup,es:trangroup

PATH:
	xor	al,al				;AN049; Set up holding buffer
	mov	di,offset Trangroup:srcxname	;AN049;   for PATH while parsing
	stosb					;AN049; Initialize PATH to null
	dec	di				;AN049; point to the start of buffer
	invoke	PGetarg 			; Pre scan for arguments
	jz	disppath			; Print the current path
	cmp	al,semicolon			;AC049; NUL path argument?
	jnz	pathslp 			;AC049;
	inc	si				;AN049; point past semicolon
	jmp	short scan_white		;AC049; Yes - make sure nothing else on line

pathslp:					; Get the user specified path
	lodsb					; Get a character
	cmp	al,end_of_line_in		;AC049; Is it end of line?
	jz	path_eol			;AC049; yes - end of command

	invoke	testkanj			;See if DBCS
	jz	notkanj2			;No - continue
	stosb					;AC049; Yes - store the first byte
	lodsb					;skip second byte of DBCS

path_hold:					;AN049;
	stosb					;AC049; Store a byte in the PATH buffer
	jmp	short pathslp			;continue parsing

notkanj2:
	invoke	upconv				;upper case the character
	cmp	al,semicolon			;AC049; ';' not a delimiter on PATH
	jz	path_hold			;AC049; go store it
	invoke	delim				;delimiter?
	jnz	path_hold			;AC049; no - go store character

scan_white:					;AN049; make sure were at EOL
	lodsb					;AN049; get a character
	cmp	al,end_of_line_in		;AN049; end of line?
	jz	path_eol			;AN049; yes - go set path
	cmp	al,blank			;AN049; whitespace?
	jz	scan_white			;AN049; yes - continue scanning
	cmp	al,tab_chr			;AN049; whitespace?
	jz	scan_white			;AN049; yes - continue scanning

	mov	dx,offset TranGroup:Extend_Buf_ptr ;AN049; no - set up error message
	mov	Extend_Buf_ptr,MoreArgs_ptr	;AN049; get "Too many parameters" message number
	mov	msg_disp_class,parse_msg_class	;AN049; set up parse error msg class
	jmp	cerror				;AN049;

path_eol:					;AN049; Parsing was clean
	xor	al,al				;AN049; null terminate the PATH
	stosb					;AN049;    buffer
	invoke	find_path			;AN049; Find PATH in environment
	invoke	delete_path			;AC049; Delete any offending name
	invoke	scan_double_null		;AC049; Scan to end of environment
	invoke	move_name			;AC049; move in PATH=
	mov	si,offset Trangroup:srcxname	;AN049; Set up source as PATH buffer

store_path:					;AN049; Store the PATH in the environment
	lodsb					;AN049; Get a character
	cmp	al,end_of_line_out		;AN049; null character?
	jz	got_paths			;AN049; yes - exit
	invoke	store_char			;AN049; no - store character
	jmp	short store_path		;AN049; continue

got_paths:					;AN049; we're finished
	xor	ax,ax				;null terminate the PATH in
	stosw					;    the environment
	return

disppath:
	invoke	find_path			;AN049;
	call	print_path
	call	crlf2
	return

print_path:
	cmp	byte ptr es:[di],0
	jnz	path1

path0:
	mov	dx,offset trangroup:nulpath_ptr
	push	cs
	pop	es
	push	cs
	pop	ds
	jmp	std_printf

path1:
	push	es
	pop	ds
	sub	di,5
	mov	si,di
ASSUME  DS:RESGROUP
        xor     al,al                           ; count str len to copy
        mov     cx,128                          ; up to arg_bug len
        repnz   scasb
        mov     cx,di
        sub     cx,si

        push    cs
	pop	es
	mov	di,offset trangroup:arg_buf
	rep	movsb
	mov	dx,offset trangroup:arg_buf_ptr
	push	cs
	pop	ds
	jmp	std_printf

ASSUME	DS:TRANGROUP

	break	Cls

; ****************************************************************
; *
; * ROUTINE:	 CLS
; *
; * FUNCTION:	 Clear the screen using INT 10h.  If ANSI.SYS is
; *		 installed, send a control string to clear the
; *		 screen.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

ifndef NEC_98
ANSI_installed		equ    0ffh

CLS:
	mov	ah,Mult_ANSI			;AN000; see if ANSI.SYS installed
	mov	al,0				;AN000;
	int	2fh				;AN000;
	cmp	al,ANSI_installed		;AN000;
	jz	ansicls 			;AN000; installed - go do ANSI CLS

check_lines:
	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ;AN000; get lines per page on display
	mov	bx,stdout			;AN000; lines for stdout
	mov	ch,ioc_sc			;AN000; type is display
	mov	cl,get_generic			;AN000; get information
	mov	dx,offset trangroup:display_ioctl ;AN000;
	int	21h			;AN000;
	jc	no_variable			;AN000; function had error, use default
	mov	ax,linperpag			;AN000; get number of rows returned
	mov	dh,al				;AN000; set number of rows
	mov	ax,display_width		;AN000; get number of columns returned
	mov	dl,al				;AN000; set number of columns
	jmp	short regcls			;AN000; go do cls

no_variable:
	mov	bx,stdout			;AC000; set handle as stdout
	mov	ax,IOCTL SHL 8			;AC000; do ioctl - get device
	int	21h			;AC000;    info
	test	dl,devid_ISDEV			;AC000; is handle a device
	jz	ANSICLS 			;AC000; If a file put out ANSI
	test	dl,devid_SPECIAL		;AC000;
	jnz	cls_normal			;AC000; If not special CON, do ANSI

ansicls:
	call	ansi_cls			;AN000; clear the screen
	jmp	short cls_ret			;AN000; exit

;
; Get video mode
;

cls_normal:					;AC000;

	mov	ah,get_video_state		;AC000; set up to get video state
	int	video_io_int			;AC000; do int 10h - BIOS video IO
	cmp	al,video_alpha			;AC000; see if in text mode
	jbe	DoAlpha
	cmp	al,video_bw			;AC000; see if black & white card
	jz	DoAlpha
;
; We are in graphics mode.  Bogus IBM ROM does not scroll correctly.  We will
; be just as bogus and set the mode that we just got.  This will blank the
; screen too.
;
	mov	ah,set_video_mode		;AC000; set video mode call
	int	video_io_int			;AC000; do int 10h - BIOS video IO
	jmp	short cls_ret			;AC000; exit

DoAlpha:
;
; Get video mode and number of columns to scroll
;

;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
;M01   adaptors.  We circumvent this by reaching directly into the BIOS data
;M01   area
;M01   Commented out code here is the original
;M01	mov	ah,get_video_state		;AC000; set up to get current video state
;M01	int	video_io_int			;AC000; do int 10h - BIOS video IO
;M01	mov	dl,ah
;M01	mov	dh,linesperpage 		;AC000; have 25 rows on the screen

;M01   Following code lifted from a fix Compaq applied to ANSI

	push	ds
	MOV	AX,ROMBIOS_DATA 	; GET ROM Data segment	M01
	MOV	DS,AX			;  *			M01
	Assume	DS:ROMBIOS_DATA

	mov	dx,CRT_Cols		; Get Columns - assume < 256 M01
	MOV	dh,CRT_Rows		; GET MAX NUM OF ROWS	M01
	pop	ds			;			M01
	Assume	DS:Trangroup

	or	dh,dh			; Q:ZERO		M01
	jnz	regcls			;  *JMP IF NO		M01

	MOV	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01

regcls:
	inc	dh			; height+1		M018
	call	reg_cls 			; go clear the screen

cls_ret:
	ret					; exit

; ****************************************************************
; *
; * ROUTINE:	 REG_CLS
; *
; * FUNCTION:	 Clear the screen using INT 10H.
; *
; * INPUT:	 DL = NUMBER OF COLUMNS
; *		 DH = NUMBER OF ROWS
; *
; * OUTPUT:	 none
; *
; ****************************************************************

reg_cls proc	near

;
; Set overscan to black.
;

	dec	dh				;  decrement rows and columns
	dec	dl				;     to zero base
	push	dx				;  save rows,columns
	mov	ah,set_color_palette		;  set up to set the color to blank
	xor	bx,bx
	int	video_io_int			; do int 10h - BIOS video IO
	pop	dx				;  retore rows,colums

	xor	ax,ax				;  zero out ax
	mov	CX,ax				;     an cx
;
; Scroll active page
;
	mov	ah,scroll_video_page		; set up to scroll page up
	mov	bh,video_attribute		; attribute for blank line
	xor	bl,bl				; set BL to 0
	int	video_io_int			; do int 10h - BIOS video IO
;
; Seek to cursor to 0,0
;
;M022 following two lines added
	mov	ah,get_video_state		; get current video page in BH
	int	video_io_int
	mov	ah,set_cursor_position		; set up to set cursor position
	xor	dx,dx				; row and column 0
;M022	mov	bh.0
	int	video_io_int			; do into 10h - BIOS video IO

	ret

reg_cls endp



; ****************************************************************
; *
; * ROUTINE:	 ANSI_CLS
; *
; * FUNCTION:	 Clear the screen using by writing a control code
; *		 to STDOUT.
; *
; * INPUT:	 none
; *
; * OUTPUT:	 none
; *
; ****************************************************************

ansi_cls proc	near				;AC000;

	mov	si,offset trangroup:clsstring
	lodsb
	mov	cl,al
	xor	ch,ch
	mov	ah,Raw_CON_IO
clrloop:
	lodsb
	mov	DL,al
	int	21h
	loop	clrloop
	return

ansi_cls	endp				;AC000;
else    ;NEC_98

CLS:

        mov     si,offset trangroup:clsstring
        lodsb
        mov     cl,al
        xor     ch,ch
        mov     ah,Raw_CON_IO
clrloop:
        lodsb
        mov     DL,al
        int     21h
        loop    clrloop
        return
endif   ;NEC_98

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tbatch.asm ===
page ,132
;	SCCSID = @(#)tbatch.asm 4.5 85/10/01
;	SCCSID = @(#)tbatch.asm 4.5 85/10/01
TITLE	Batch processing routines
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M006	SR	07/20/90	Changed BatCom to understand batch
;				segments in UMBs. Check only for 
;				overlap.
;	M017	MD	08/10/90	Eliminate extra DEC, to fix bug #1
;
;	M037	SR	11/1/90	Bug #1745 & #3438 fixed. Fixed ReadBat
;				to check if we have hit EOF on
;				batchfile and if so, just clear everything
;				and return finishing batch processing.
;

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include comseg.asm
	include comequ.asm
	include doscntry.inc		;an000;
	include version.inc
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BATCH:WORD
	EXTRN	Batch_Abort:byte
	EXTRN	call_batch_flag:byte
	EXTRN	ECHOFLAG:BYTE
	EXTRN	forflag:byte
	EXTRN	forptr:word
	EXTRN	IFFlag:BYTE
	EXTRN	In_Batch:byte
	EXTRN	LTPA:WORD
	EXTRN	Nest:word
	EXTRN	next_batch:word
	EXTRN	nullflag:byte
	EXTRN	PIPEFLAG:BYTE
	EXTRN	RES_TPA:WORD
	EXTRN	SINGLECOM:WORD
	EXTRN	SUPPRESS:BYTE		;AC000;
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BADBAT_PTR:WORD
	EXTRN	Extend_buf_ptr:word	;AC000;
	EXTRN	Extend_buf_sub:byte	;AN022;
	EXTRN	msg_disp_class:byte	;AC000;
	EXTRN	NEEDBAT_PTR:WORD
	EXTRN	pausemes_ptr:word	;AC000;
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BatBufPos:WORD
	EXTRN	BATHAND:WORD
	EXTRN	bwdbuf:byte		;AN022;
	EXTRN	BYTCNT:WORD
	EXTRN	COMBUF:BYTE
	EXTRN	EXECPATH:BYTE
	EXTRN	ID:BYTE
	EXTRN	RCH_ADDR:DWORD
	EXTRN	RESSEG:WORD
	EXTRN	string_ptr_2:word	;AC000;
	EXTRN	TPA:WORD
	EXTRN	TRAN_TPA:WORD

	extrn	TranSpaceEnd:byte	; M006
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	cerror:near
	EXTRN	tcommand:near

;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
    extrn   arg:byte			; the arg structure!
transpace   ends
;---------------

Break	<PromptBat - Open or wait for batch file>

;
; Open the batch file.	If we cannot find the batch file.  If the media is
; changeable, we prompt for the change.  Otherwise, we terminate the batch
; file.  Leave segment registers alone.
;

Procedure   PromptBat,NEAR
	ASSUME	DS:ResGroup,ES:NOTHING
	invoke	BATOPEN 			; attempt to open batch file
	retnc
	cmp	dx,error_file_not_found 	;AN022; Ask for diskette if file not found
	jz	Bat_Remcheck			;AN022;
	cmp	dx,error_path_not_found 	;AN022; Ask for diskette if path not found
	jz	Bat_Remcheck			;AN022;    Otherwise, issue message and exit
	invoke	output_batch_name		;AN022; set up batch name in bwdbuf
	jmp	short BatDie			;AN022;

Bat_Remcheck:					;AN022; Go see if media is removable
	CALL	[RCH_ADDR]			; DX has error number
	JZ	AskForBat			; Media is removable
;
; The media is not changeable.	Turn everything off.
;
	invoke	ForOff
	invoke	PipeOff
	MOV	IfFlag,AL			; No If in progress.
	MOV	DX,OFFSET TRANGROUP:BADBAT_ptr

BatDie:
	call	BatchOff
	PUSH	CS
	POP	DS
	ASSUME	DS:TranGroup
	invoke	std_eprintf			;AC022; display message

;
; TCOMMAND resets the stack.  This is the equivalent of a non-local goto.
;
	JMP	TCOMMAND			; he cleans off stack

;
; Ask the user to reinsert the batch file
;
ASKFORBAT:
	ASSUME	DS:ResGroup
	PUSH	DS
	PUSH	CS
	POP	DS
	ASSUME	DS:TranGroup
	MOV	DX,OFFSET TRANGROUP:NEEDBAT_ptr  ;AN022;
	invoke	std_eprintf			 ;Prompt for batch file on stderr
	mov	dx,offset trangroup:pausemes_ptr ;AN000; get second part of message
	invoke	std_eprintf			 ;AN000; print it to stderr
	CALL	GetKeystroke
	POP	DS
	ASSUME	DS:ResGroup
	jmp	PromptBat
EndProc PromptBat

;****************************************************************
;*
;* ROUTINE:	Output_batch_name
;*
;* FUNCTION:	Sets up batch name to be printed on extended error
;*
;* INPUT:	DX - extended error number
;*
;* OUTPUT:	Ready to call print routine
;*
;****************************************************************

public	output_batch_name			;AN022;

Output_batch_name    proc near			;AN022;

	push	ds				;AN022; save resident segment
	mov	ds,[batch]			;AN022; get batch file segment
assume	DS:nothing				;AN022;
	mov	SI,BatFile			;AN022; get offset of batch file
	invoke	dstrlen 			;AN022; get length of string
	mov	di,offset Trangroup:bwdbuf	;AN022; target for batch name
	rep	movsb				;AN022; move the name

	push	cs				;AN022; get local segment
	pop	ds				;AN022;
assume	DS:trangroup				;AN022;
	mov	extend_buf_ptr,dx		;AN022; put message number in block
	mov	msg_disp_class,ext_msg_class	;AN022; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr   ;AN022; get extended message pointer
	mov	string_ptr_2,offset trangroup:bwdbuf ;AN022; point to substitution
	mov	extend_buf_sub,one_subst	;AN022; set up for one subst
	pop	ds				;AN022; restore data segment

	ret					;AN022; return

Output_batch_name    endp			;AN022;

Break	<GetKeystroke - get a keystroke and flush queue>

;
; read the next keystroke.  Since there may be several characters in the queue
; after the one we ask for (function keys/Kanji), we need to flush the queue
; AFTER waiting.
;
Procedure   GetKeyStroke,NEAR
;
; read any character at any mode, interim mode or not.
;
	assume	ds:trangroup

	PUSH	DX					;AN000;  3/3/KK
	MOV	AX,(ECS_call SHL 8) OR GetInterimMode	;AN000;  3/3/KK
	INT	21h				;AN000;  3/3/KK
	PUSH	DX					;AN000;  save interim state 3/3/KK
	MOV	AX,(ECS_call SHL 8) OR SetInterimMode	;AN000;  3/3/KK
	MOV	DL,InterimMode				;AN000;  3/3/KK
	INT	21h				;AN000;  3/3/KK

	MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
	INT	21h		; Get character with KB buffer flush
	MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
	INT	21h

	MOV	AX,(ECS_call SHL 8) OR SetInterimMode	;AN000;  3/3/KK
	POP	DX					;AN000;  restore interim state 3/3/KK
	INT	21h				;AN000;  3/3/KK
	POP	DX					;AN000;  3/3/KK

	return
EndProc GetKeyStroke

Break	<ReadBat - read 1 line from batch file>

;
; ReadBat - read a single line from the batch file.  Perform all substitutions
; as appropriate
;

Procedure   ReadBat,NEAR
	ASSUME	DS:ResGroup,ES:TranGroup
	mov	suppress,yes_echo		;g initialize line suppress status
	test	byte ptr [Batch_Abort],-1
	jnz	Trying_To_Abort
	mov	byte ptr [In_Batch],1		; set flag to indicate batch job
;
;M037; Start of changes
; We check here if we have set the flag indicating that the batchfile is at
;EOF. In this case, we do not want to continue with the normal processing.
;We call GetBatByt once more so that the batch segment gets freed up, the
;batch file gets closed etc. and then return as if everything is done.
;
	push	ds
	mov	ds,Batch
	cmp	ds:BatchEOF,0		; are we at EOF in batchfile
	pop	ds
	jz	contbat		; no, continue normal processing
	invoke	GetBatByt		; frees up batchseg
	mov	es:ComBuf+2,al		; stuff CR into command buffer
					; as a dummy command
	invoke 	CrLf2			; print a CR-LF
	return				; done batch processing
contbat:
;
;M037; End of changes
;

	CALL	PromptBat

Trying_To_Abort:
	MOV	DI,OFFSET TRANGROUP:COMBUF+2

;
; Save position and try to scan for first non delimiter.
;

TESTNOP:
	MOV	AX,DS
	MOV	DS,Batch
	ASSUME	DS:NOTHING
	PUSH	WORD PTR DS:[BatSeek]
	PUSH	WORD PTR DS:[BatSeek+2] 	; save current location.
	MOV	DS,AX
	ASSUME	DS:ResGroup
	invoke	SkipDelim			; skip to first non-delim
;
; If the first non-delimiter is not a :  (label), we reseek back to the
; beginning and read the line.
;
	CMP	AL,':'                          ; is it a label?
	POP	CX
	POP	DX				; restore position in bat file
	JZ	NopLine 			; yes, resync everything.
	TEST	[BATCH],-1			; are we done with the batch file?
	JZ	RdBat

	CMP	AL, NO_ECHO_CHAR		;g see if user wants to suppress line
	JNZ	SET_BAT_POS			;g no - go and set batch file position
	MOV	SUPPRESS, NO_ECHO		;g yes set flag to indicate
	jmp	short Rdbat			;g go read batch file

SET_BAT_POS:					;g
	PUSH	DS
	MOV	DS,Batch
	ASSUME	DS:NOTHING
	MOV	WORD PTR DS:[BatSeek],DX	; reseek back to beginning
	MOV	WORD PTR DS:[BatSeek+2],CX
	POP	DS
	ASSUME	DS:ResGroup
	MOV	AX,(LSEEK SHL 8) + 0		; seek back
	INT	21h
	MOV	BatBufPos,-1			; nuke batch buffer position
	xor	cx,cx				; Initialize line length to zero
	JMP	SHORT RdBat
;
; The first non-delimiter is a :.  This line is not echoed and is ignored.
; We eat characters until a CR is seen.
;

NOPLINE:
	CALL	SkipToEOL
	invoke	GetBatByt			; eat trailing LF
	TEST	[BATCH],-1			; are we done with the batch file?
	JNZ	TESTNOP 			; no, go get another line
	return					; Hit EOF

;
; Read a line into the buffer pointed to by ES:DI.  If any %s are seen in the
; input, we are to consider two special cases:
;
;   %0 to %9	These represent replaceable parameters from the batch segment
;   %sym%	This is a symbol from the environment
;

RDBAT:
	invoke	GetBatByt
	inc	cx				; Inc the line length

	invoke	testkanj		; MSKK04 07/14/89
	jz	rdbat1			;
	cmp	cx, COMBUFLEN-1		;
	jae	TooLong			; can't start DBCS char at last pos'n
	stosb				;
	invoke	GetBatByt		;
	inc	cx			;
	jmp	short SAVBATBYT		;
rdbat1:					;

	cmp	cx,COMBUFLEN			; Is it too long?
	jae	TooLong 			; Yes - handle it, handle it
;
; See if we have a parameter character.
;
	CMP	AL,'%'                          ; Check for parameter
	JZ	NEEDPARM
;
; no parameter character.  Store it as usual and see if we are done.
;

SAVBATBYT:
	STOSB
	CMP	AL,0DH				; End of line found?
	JNZ	RDBAT				; no, go for more
;
; We have read in an entire line.  Decide whether we should echo the command
; line or not.
;

Found_EOL:
	SUB	DI,OFFSET TRANGROUP:COMBUF+3
	MOV	AX,DI				; remember that we've not counted the CR
	MOV	ES:[COMBUF+1],AL		; Set length of line
	invoke	GetBatByt			; Eat linefeed
	invoke	BATCLOSE
	CMP	SUPPRESS, NO_ECHO		;G
	JZ	Reset				;G
	test	[echoflag],1			; To echo or not to echo, that is the
	jnz	try_nextflag

Reset:
	PUSH	CS				;  question.  (Profound, huh?)
	POP	DS				; Go back to local segment
	retz					; no echoing here...
;
; Echo the command line with appropriate CRLF...
;


try_nextflag:
	cmp	nullflag,nullcommand		;G was there a command last time?
	jz	No_crlf_print			;G no - don't print crlf
	invoke	CRLF2				;G  Print out prompt

no_crlf_print:
	invoke	PRINT_PROMPT			;G
	PUSH	CS				;G change data segment
	POP	DS				;G

ASSUME DS:TRANGROUP
	mov	dx,OFFSET TRANGROUP:COMBUF+2	; get command line for echoing
	invoke	CRPRINT
	invoke	CRLF2
	return
;
; The line was too long.  Eat remainder of input text up until the CR
;
TooLong:
	ASSUME	DS:ResGroup
	cmp	al,0dh				; Has the end of the line been reached?
	jz	Ltlcont 			; Yes, continue
	CALL	SkipToEOL			; Eat remainder of line

Ltlcont:
	stosb					; Terminate the command
	jmp	Found_EOL			; Go process the valid part of the line
;
; We have found a parameter lead-in character.	Check for the 0-9 case first
;

NEEDPARM:
	invoke	GetBatByt			; get next character
	CMP	AL,'%'                          ; Check for two consecutive %
	JZ	SAVBATBYT			; if so, replace with a single %
	CMP	AL,0Dh				; Check for end-of-line
	JZ	SAVBATBYT			; yes, treat it normally
;
; We have found %<something>.  If the <something> is in the range 0-9, we
; retrieve the appropriate parameter from the batch segment.  Otherwise we
; see if the <something> has a terminating % and then look up the contents
; in the environment
;
PAROK:
	SUB	AL,'0'
	JB	NEEDENV 			; look for parameter in the environment
	CMP	AL,9
	JA	NEEDENV
;
; We have found %<number>.  This is taken from the parameters in the
; allocated batch area.
;
	CBW
	MOV	BX,AX				; move index into AX
	SHL	BX,1				; convert word index into byte ptr
	SaveReg <ES>
	MOV	ES,Batch
;
; The structure of the batch area is:
;
;   BYTE    type of segment
;   DWORD   offset for next line
;   10 WORD pointers to parameters.  -1 is empty parameter
;   ASCIZ   file name (with . and ..)
;   BYTES   CR-terminated parameters
;   BYTE    0 flag to indicate end of parameters
;
; Get pointer to BX'th argument
;
	MOV	SI,ES:BatParm[BX]
	RestoreReg  <ES>
;
; Is there a parameter here?
;
	CMP	SI,-1				; Check if parameter exists
	JNZ	Yes_there_is			;G Yes go get it
	JMP	RDBAT				; Ignore if it doesn't
;
; Copy in the found parameter from batch segment
;

Yes_there_is:
	PUSH	DS
	MOV	DS,Batch
	ASSUME	DS:NOTHING
	dec	cx				; Don't count '%' in line length

CopyParm:
	LODSB					; From resident segment
	CMP	AL,0DH				; Check for end of parameter
	JZ	EndParam
	inc	cx				; Inc the line length
	cmp	cx,COMBUFLEN			; Is it too long?
	jae	LineTooL			; Yes - handle it, handle it
	STOSB
	JMP	CopyParm
;
; We have copied up to the limit.  Stop copying and eat remainder of batch
; line.  We need to make sure that the tooLong code isn't fooled into
; believing that we are at EOL.  Clobber AL too.
;

LineTooL:
	XOR	AL,AL
	POP	DS
	ASSUME	DS:RESGROUP
	JMP	TooLong
;
; We have copied in an entire parameter.  Go back for more
;

EndParam:
	POP	DS
	JMP	RDBat
;
; We have found % followed by something other than 0-9.  We presume that there
; will be a following % character.  In between is an environment variable that
; we will fetch and replace in the batch line with its value.
;

NEEDENV:
        dec     cx                              ;AN070; Don't count "%"
	SaveReg <DS,DI>
	MOV	DI,OFFSET TRANGROUP:ID		; temp spot for name
	ADD	AL,'0'                          ; reconvert character
	STOSB					; store it in appropriate place
;
; loop getting characters until the next % is found or until EOL
;

GETENV1:
	invoke	GetBatByt			; get the byte
	STOSB					; store it
	CMP	AL,0Dh				; EOL?
	JNZ	GETENV15			; no, see if it the term char
;
; The user entered a string with a % but no trailing %.  We copy the string.
;
	mov	byte ptr es:[di-1],0		; nul terminate the string
	mov	si,offset TranGroup:ID		; point to buffer
	pop	di				; point to line buffer
	push	cs
	pop	ds
	call	StrCpy
	jc	LineTooL
	pop	ds
	jmp	SavBatByt

GETENV15:
	CMP	AL,'%'                          ; terminating %?
	JNZ	GETENV1 			; no, go take out more characters

; M017 - following DEC is wrong, because we replace the % with a = here.
; This was the source of bug #1.
;	dec	cx				;AN070; Don't count "%"

	mov	al,'='                          ; terminate  with =
	MOV	ES:[DI-1],al
;
; ID now either has a =-terminated string which we are to find in the
; environment or a non =-terminated string which will not be found in the
; environment.
;
GETENV2:
	MOV	SI,OFFSET TRANGROUP:ID
	PUSH	CS
	POP	DS				; DS:SI POINTS TO NAME
	ASSUME DS:TRANGROUP
	PUSH	CX
	INVOKE	FIND_NAME_IN_environment
	ASSUME ES:RESGROUP
	POP	CX
	PUSH	ES
	POP	DS
	assume ds:resgroup
	PUSH	CS
	POP	ES
	ASSUME ES:TRANGROUP
	MOV	SI,DI
	POP	DI				; get back pointer to command line
;
; If the parameter was not found,  there is no need to perform any replacement.
; We merely pretend that we've copied the parameter.
;
	JC	GETENV6
;
; ES:DI points to command line being built
; DS:SI points either to nul-terminated environment object AFTER =
;

	ASSUME	ES:NOTHING
	call	StrCpy				; (let RdBat handle overflow)
GETENV6:
	pop	ds
	JMP	RDBAT				; no, go back to batch file

EndProc ReadBat

;
;   SkipToEOL - read from batch file until end of line
;

Procedure   SkipToEOL,NEAR

	ASSUME	DS:ResGroup,ES:NOTHING

	TEST	Batch,-1
	retz					; no batch file in effect
	invoke	GetBatByt
	CMP	AL,0Dh				; eol character?
	JNZ	SkipToEOL			; no, go eat another
	return

EndProc SkipToEOL

Break	<Allocate and deallocate the transient portion>

;
; Free Transient.  Modify ES,AX,flags
;

Procedure   Free_TPA,NEAR

ASSUME	DS:TRANGROUP,ES:RESGROUP

	PUSH	ES
	MOV	ES,[RESSEG]
	MOV	ES,[RES_TPA]
	MOV	AH,DEALLOC
	INT	21h			; Make lots of free memory
	POP	ES

	return

EndProc Free_TPA

;
; Allocate transient.  Modify AX,BX,DX,flags
;

Procedure   Alloc_TPA,NEAR

ASSUME DS:TRANGROUP,ES:RESGROUP

	PUSH	ES
	MOV	ES,[RESSEG]
	MOV	BX,0FFFFH			; Re-allocate the transient
	MOV	AH,ALLOC
	INT	21h
	PUSH	BX				; Save size of block
	MOV	AH,ALLOC
	INT	21h
;
; Attempt to align TPA on 64K boundary
;
	POP	BX				; Restore size of block
	MOV	[RES_TPA], AX			; Save segment to beginning of block
	MOV	[TRAN_TPA], AX
;
; Is the segment already aligned on a 64K boundary
;
	MOV	DX, AX				; Save segment
	AND	AX, 0FFFH			; Test if above boundary
	JNZ	Calc_TPA
	MOV	AX, DX
	AND	AX, 0F000H			; Test if multiple of 64K
	JNZ	NOROUND

Calc_TPA:
	MOV	AX, DX
	AND	AX, 0F000H
	ADD	AX, 01000H			; Round up to next 64K boundary
	JC	NOROUND 			; Memory wrap if carry set
;
; Make sure that new boundary is within allocated range
;
	MOV	DX, [RES_TPA]
	ADD	DX, BX				; Compute maximum address
	CMP	DX, AX				; Is 64K address out of range?
	JB	NOROUND
;
; Make sure that we won't overwrite the transient
;
	MOV	BX, CS				; CS is beginning of transient
	CMP	BX, AX
	JB	NOROUND
;
; The area from the 64K boundary to the beginning of the transient must
; be at least 64K.
;
	SUB	BX, AX
	CMP	BX, 4096			; Size greater than 64K?
	JAE	ROUNDDONE

NOROUND:
	MOV	AX, [RES_TPA]

ROUNDDONE:
	MOV	[LTPA],AX			; Re-compute everything
	MOV	[TPA],AX
	MOV	BX,AX
	MOV	AX,CS
	SUB	AX,BX
	PUSH	BX
	MOV	BX,16
	MUL	BX
	POP	BX
	OR	DX,DX
	JZ	SAVSIZ2
	MOV	AX,-1

SAVSIZ2:
;
; AX is the number of bytes free in the buffer between the resident and the
; transient with a maximum of 64K-1.  We round this down to a multiple of 512.
;
	CMP	AX,512
	JBE	GotSize
	AND	AX,0FE00h			; NOT 511 = NOT 1FF

GotSize:
	MOV	[BYTCNT],AX
	POP	ES

	return

EndProc Alloc_TPA

Break	<BatCom - enter a batch file>

;
; The exec search has determined that the user has requested a batch file for
; execution.  We parse the arguments, create the batch segment, and signal
; batch processing.
;
Procedure   BatCom,NEAR

ASSUME	DS:TRANGROUP, ES:NOTHING

;
; Batch parameters are read with ES set to segment of resident part
;

	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP
	cmp	es:[call_batch_flag],call_in_progress ;AN043; If in CALL,
	jz	skip_ioset			;AN043;   redirection was already set up
	invoke	IOSET				; Set up any redirection

skip_ioset:					;AN043;
	CALL	FREE_TPA			; G
	cmp	es:[call_batch_flag],call_in_progress ;G
	jz	getecho 			; G if we're in a call, don't execute
;
; Since BATCH has lower precedence than PIPE or FOR.  If a new BATCH file is
; being started it MUST be true that no FOR or PIPE is currently in progress.
; Don't execute if in call
;
	invoke	ForOff

getecho:
	invoke	PipeOff
	mov	al,EchoFlag			; preserve echo state for chaining

	and	al, 1				; Save current echo state
	push	ax

	xor	ax,ax				;G
	test	es:[batch],-1			;G  Are we in a batch file?
	jz	leavebat			;G  No, nothing to save
	mov	ax,es:[batch]			;G get current batch segment
	cmp	es:[call_batch_flag],call_in_progress  ;G
	jz	leavebat			;G
;
;  We are in a chained batch file, save batlast from previous batch segment
;  so that if we're in a CALL, we will return to the correct batch file.
;
	push	es				;G
	mov	es,ax				;G get current batch segment
	mov	ax,es:[batlast] 		;G get previous batch segment
	pop	es				;G

leavebat:					;G
	push	ax				;G keep segment until new one created
	cmp	es:[call_batch_flag],call_in_progress  ;G are we in a CALL?
	jz	startbat			;G Yes, keep current batch segment
	call	BatchOff			;G No, deallocate old batch segment

;
; Find length of batch file
;

startbat:					;G
	ASSUME	ES:RESGROUP
	MOV	es:[CALL_BATCH_FLAG], 0 	;G  reset call flag
	mov	SI, OFFSET TRANGROUP:EXECPATH

	mov	ax,AppendTruename		;AN042; Get the real path where the batch file
	int	2fh				;AN042;    was found with APPEND
	mov	ah,Find_First			;AN042; The find_first will return it
	mov	dx,si				;AN042; Get the string
	mov	cx,search_attr			;AN042; filetypes to search for
	int	21h			;AN042;

	invoke	DStrLen
;
; Allocate batch area:
;   BYTE    type of segment
;   WORD    segment of last batch file
;   WORD    segment for FOR command
;   BYTE    FOR flag state on entry to batch file
;   DWORD   offset for next line
;   10 WORD pointers to parameters.  -1 is empty parameter
;   ASCIZ   file name (with . and ..)
;   BYTES   CR-terminated parameters
;   BYTE    0 flag to indicate end of parameters
;
; We allocate the maximum size for the command line and use setblock to shrink
; later when we've squeezed out the extra
;

	MOV	BX,CX				; length of file name.
	ADD	BX,0Fh + (SIZE BatchSegment) + COMBUFLEN + 0Fh
						; structure + max len + round up
	SaveReg <CX>
	MOV	CL,4
	SHR	BX,CL				; convert to paragraphs
	PUSH	BX				;G save size of batch segment
	MOV	AH,ALLOC
	INT	21h			; Allocate batch segment
	POP	BX				;G get size of batch segment
;
; This should *NEVER* return an error.	The transient is MUCH bigger than
; the batch segment.  This may not be true, however, in a multitasking system.
; G This error will occur with nesting of batch files.	We also need to
; G make sure that we don't overlay the transient.
;
	jc	mem_error			;G not enough memory - exit
	push	ax				;G save batch segment
	add	ax,bx				;G get end of batch segment
	add	ax,20h				;G add some tpa work area
	mov	bx,cs				;G get the transient segment
;
; M006; We cant check just for above. If the batchseg goes into a UMB, the
; M006; batchseg is always above the transient. We need to change this code
; M006; to only check for an overlap
;
	mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
	add	dx,15				;round up para; M006
	shr	dx,cl				;para size of transient; M006
	add	dx,bx				;dx = top of transient; M006

	cmp	ax,bx				; M006
	jb	enough_mem			; Batchseg below transient
						; enough memory ; M006
	cmp	ax,dx				; M006
	ja	enough_mem			; Batchseg above transient
						; enough memory ; M006
;
; M006; Batchseg overlaps transient -- insufficient memory
;
	pop	ax				; restore ax; M006

;M006;	cmp	ax,bx				;G do we end before the transient
;M006;	pop	ax				;G get batch segment back
;M006;	jb	enough_mem			;G we have enough memory - continue

	push	es				;G no we're hitting the transient
	mov	es,ax
	mov	ax,DEALLOC SHL 8		;G deallocate the batch segment
	int	21h
	pop	es

mem_error:
	jmp	no_memory			;G Set up for message and exit

enough_mem:
	pop	ax				; restore ax; M006

	MOV	[BATCH],AX
	CALL	ALLOC_TPA
;
; Initialize batch segment
;
	RestoreReg  <DX>			; length of name
	POP	AX				;G  get saved batch segment back
	inc	es:nest 			;G increment # batch files in progress
	PUSH	ES
	MOV	ES,[BATCH]
ASSUME	ES:NOTHING
	MOV	ES:[BatType],BatchType		; signal batch file type
	MOV	ES:[batlast],ax 		;G save segment of last batch file
	push	DS				;G
	mov	DS,[resseg]			;G set to resident data
ASSUME	DS:RESGROUP
	xor	ax,ax				;G
	mov	bl,forflag			;G get the current FOR state
	mov	ES:[batforflag],bl		;G save it in the batch segment
	test	bl,-1				;G are we in a FOR?
	jz	for_not_on			;G no, for segment set to 0
	mov	ax,forptr			;G yes, get current FOR segment
	mov	forflag,0			;G reset forflag

for_not_on:
	mov	ES:[batforptr],ax		;G save FOR segment in batch segment
	XOR	AX,AX
	mov	forptr,ax			;G make sure for segment is not active
	mov	bl,echoflag			;G
	pop	DS				;G

	mov	byte ptr es:[Batechoflag],bl	;G save echo state of parent
;SR;
; Initialize the new BatchEOF flag we have added to 0
;
	mov	es:BatchEOF,0

	MOV	WORD PTR ES:[BatSeek],AX	; point to beginning of file
	MOV	WORD PTR ES:[BatSeek+2],AX
;
; Initialize pointers
;
	DEC	AX				; put -1 into AX
	MOV	DI,BatParm			; point to parm area
	MOV	BX,DI
	MOV	CX,10
	REP	STOSW				; Init to no parms
;
; Move in batch file name
;
	MOV	CX,DX
	rep	movsb				; including NUL.
;
; Now copy the command line into batch segment, parsing the arguments along
; the way.  Segment will look like this:
;
;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
;
; or, in the case of fewer arguments:
;
;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
;
	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	MOV	CX,10				; at most 10 arguments
;
; Look for beginning of next argument
;
EACHPARM:
	invoke	SCANOFF 			; skip to argument
;
; AL is first non-delimiter.  DS:SI points to char = AL
;
	CMP	AL,0DH				; end of road?
	JZ	HAVPARM 			; yes, no more arguments
;
; If CX = 0 then we have stored the most parm we can.  Skip store
;
	JCXZ	MOVPARM 			; Only first 10 parms get pointers
;
; Go into allocated piece and stick in new argument pointer.
;
	MOV	ES:[BX],DI			; store batch pointer
	ADD	BX,2				; advance arg counter
;
; Move the parameter into batch segment
;
MOVPARM:
	LODSB					; get byte
	INVOKE	DELIM				; if delimiter
	JZ	ENDPARM 			; then done with parm
	STOSB					; store byte
	CMP	AL,0DH				; if CR then not delimiter
	JZ	HAVPARM 			; but end of parm list, finish
	JMP	SHORT MOVPARM
;
; We have copied a parameter up until the first separator.  Terminate it with
; CR
;

ENDPARM:
	MOV	AL,0DH
	STOSB
	JCXZ	EACHPARM			; if no parameters, don't dec
	DEC	CX				; remember that we've seen one.
	JMP	SHORT EACHPARM
;
; We have parsed the entire line. Terminate the arg list
;

HAVPARM:
	XOR	AL,AL
	STOSB					; Nul terminate the parms
;
; Now we know EXACTLY how big the BATCH segment is.  Round up size (from DI)
; into paragraphs and setblock to the appropriate size
;
	LEA	BX,[DI+15]
	MOV	CL,4
	SHR	BX,CL
	MOV	AH,SetBlock
	INT	21h

	POP	ES
ASSUME	ES:RESGROUP
	PUSH	ES
	POP	DS				; Simply batch FCB setup
ASSUME	DS:RESGROUP
	CMP	[SINGLECOM],-1
	JNZ	NOBATSING
	MOV	[SINGLECOM],0FFF0H		; Flag single command BATCH job

NOBATSING:
;
; Enter the batch file with the current echo state
;
	pop	ax				; Get original echo state
	mov	echoflag,al			;g restore it
	JMP	TCOMMAND

;
; The following is executed if there isn't enough memory for batch segment
;

NO_MEMORY:
	assume ds:trangroup,es:resgroup
	pop	dx				;g even up our stack
	pop	ax				;g
	pop	ax				;g
	call	Alloc_tpa			;g reallocate memory
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr     ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,error_not_enough_memory ;AN000; get message number in control block
	jmp	cerror				;g print error message and go...

EndProc BatCom

Procedure   BatchOff

	ASSUME	DS:NOTHING,ES:NOTHING

	SaveReg <AX,ES>
	PUSH	DS				;G
	PUSH	BX				;G
	MOV	ES,ResSeg
	MOV	DS,ResSeg			;G
	ASSUME	ES:ResGroup,DS:Resgroup 	;G
	MOV	AX,Batch			; Free the batch segment
	OR	AX,AX
	JZ	nofree

	PUSH	ES
	MOV	ES,AX
	test	[echoflag],1			;G Is echo on?
	jnz	echo_last_line			;G Yes - echo last line in file
	mov	suppress,no_echo		;G no - don't echo last line in file

echo_last_line:
	MOV	BL,ES:[BATECHOFLAG]		;G  Get echo state
	mov	[echoflag],bl			;G     and restore it
	MOV	BX,ES:[BATFORPTR]		;G  Get FOR segment
	MOV	FORPTR,BX			;G     and restore it
	MOV	BL,ES:[BATFORFLAG]		;G  Get FOR flag
	MOV	FORFLAG,BL			;G     and restore it
	MOV	BX,es:[batlast] 		;G  get old batch segment
	MOV	AH,DEALLOC
	INT	21h
	POP	ES
	MOV	Next_BATCH,BX			;G  reset batch segment
	DEC	es:NEST 			;G

	XOR	AX,AX
	MOV	Batch,AX			; No batch in progress

NoFree:
	POP	BX				;G
	pop	ds				;G
	RestoreReg  <ES,AX>

	return

EndProc BatchOff


; StrCpy - copy string, checking count in CX against COMBUFLEN
;	Entry : DS:SI ==> source string
;		ES:DI ==> destination string
;		CX = current length of destination string
;	Exit  : string copied, CX updated, Carry set if length limit exceeded
Procedure StrCpy,NEAR
	push	ax
ccycle:
	lodsb
	inc	cx
	cmp	cx,COMBUFLEN
	jb	ccopy
	stc				; set carry to signal error
	jmp	short ccend
ccopy:
	stosb
	or	al,al
	jnz	ccycle

ccend:
	dec	cx			; discount extra byte
	dec	di			; back up pointer
	pop	ax
	return				; return carry clear
EndProc StrCpy

TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tcmd2b.asm ===
page ,132
;	SCCSID = @(#)tcmd2b.asm 4.1 85/09/22
;	SCCSID = @(#)tcmd2b.asm 4.1 85/09/22
TITLE	PART5 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include pdb.inc
	include mult.inc
	include comseg.asm
	include comequ.asm
	include cmdsvc.inc
.list
.cref


;;CODERES 	SEGMENT PUBLIC BYTE	;AC000;
;;	EXTRN	LODCOM1:NEAR
;;CODERES ENDS

DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	crit_msg_off:word	;AC000;
	EXTRN	crit_msg_seg:word	;AC000;
	EXTRN	IO_SAVE:WORD
	EXTRN	OldTerm:DWORD
	EXTRN	PARENT:WORD
;AD060; EXTRN	pars_msg_off:word	;AC000;
;AD060; EXTRN	pars_msg_seg:word	;AC000;
	EXTRN	PERMCOM:BYTE		;AN045;
	EXTRN	RetCode:WORD
	EXTRN	SingleCom:word

	extrn	TrnLodCom1_Trap:far

DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	ACRLF_PTR:WORD		;AN007;
	EXTRN	baddev_ptr:word
	EXTRN	CP_active_Ptr:word
	EXTRN	CP_not_all_Ptr:word
	EXTRN	CP_not_set_Ptr:word
	EXTRN	Extend_buf_ptr:word	;AN000;
	EXTRN	Extend_buf_sub:byte	;AN000;
	EXTRN	inv_code_page:word	;AC000;
	EXTRN	msg_disp_class:byte	;AN000;
	EXTRN	NLSFUNC_Ptr:word	;AC000;
	EXTRN	parse_chcp:byte 	;AC000;
	EXTRN	parse_chdir:byte	;AC000;
	EXTRN	parse_ctty:byte 	;AC000;
	EXTRN	string_buf_ptr:word	;AC000;

	extrn	NoCntry_Ptr:word	;M045

TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	COMBUF:BYTE
	EXTRN	parse_last:word 	;AN018;
	EXTRN	parse1_addr:dword	;AC000;
	EXTRN	parse1_type:byte	;AC000;
	EXTRN	RESSEG:WORD
	EXTRN	srcbuf:byte
	EXTRN	srcxname:byte		;AC000;
	EXTRN	string_ptr_2:word
	EXTRN	system_cpage:word
	EXTRN	TRAN_TPA:WORD
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
TRANSPACE	ENDS
;---------------

	EXTRN	cerror:near
	extrn	TCommand:near

	PUBLIC	$exit
	PUBLIC	chcp
	PUBLIC	ctty
	PUBLIC	parse_check_eol 	;AN000;
	PUBLIC	parse_with_msg		;AN018;
	PUBLIC	setup_parse_error_msg	;AN018;
	PUBLIC	truename		;AN000;

	break	Ctty
assume	ds:trangroup,es:trangroup

; ****************************************************************
; *
; * ROUTINE:	 CTTY - Change console
; *
; * SYNTAX:	 CTTY device
; *
; * FUNCTION:	 If a valid console device is specified, CTTY will
; *		 duplicate the device handle to STDIN, STDOUT and
; *		 STDERR.  This routine returns to LODCOM1.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

CTTY:
	push	ds				;AN000; Get local ES
	pop	es				;AN000;
	mov	si,81H				;AC000; Get command argument for CTTY

	mov	di,offset trangroup:parse_ctty	;AC000; Get adderss of PARSE_CTTY
	xor	cx,cx				;AC000; clear cx,dx
	xor	dx,dx				;AC000;
	invoke	cmd_parse			;AC000; call parser
	cmp	ax,end_of_line			;AN000; are we at end of line?
	jz	ctty_error			;AN000; yes - error
	cmp	ax,result_no_error		;AN000; did an error occur
	jnz	ctty_error			;AN000; YES -ERROR

	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AN000; get address of filespec
	mov	di,offset trangroup:srcbuf	;AN000; get address of srcbuf

ctty_move_filename:				;AN000; put filespec in srcbuf
	lodsb					;AN000; get a char from buffer
	stosb					;AN000; store in srcbuf
	cmp	al,end_of_line_out		;AN000; it char a terminator?
	jnz	ctty_move_filename		;AN000; no - keep moving
	pop	si				;AN000; get line position back
	mov	di,offset trangroup:parse_ctty	;AC000; Get adderss of PARSE_CTTY
ifndef NEC_98
	call	parse_check_eol 		;AN000; are we at end of line?
else    ;NEC_98
;	call	parse_check_eol 		;AN000; are we at end of line?	; NEC01 91/07/31 Del

	xor	dx,dx				;AN000;				; NEC01 91/07/31
	mov	[parse_last],si 		;AN018; save start of parameter	; NEC01 91/07/31
	invoke	cmd_parse			;AN000; call parser		; NEC01 91/07/31
	cmp	al,end_of_line			;AN000; Are we at end of line?	; NEC01 91/07/31
endif   ;NEC_98
	jz	nocolon 			;AN000; yes - continue

ctty_error:
	jmp	short isbaddev			;AC000; yes - exit

nocolon:
	mov	dx,offset trangroup:srcbuf	;AN000; get address of srcbuf
	MOV	AX,(OPEN SHL 8) OR 2		; Read and write
	INT	21h			; Open new device
	JC	ISBADDEV
	MOV	BX,AX
	MOV	AX,IOCTL SHL 8
	INT	21h
	TEST	DL,80H
	JNZ	DEVISOK

CLOSEDEV:					;AN007;
	MOV	AH,CLOSE			; Close initial handle
	INT	21h

ISBADDEV:
	MOV	DX,OFFSET TRANGROUP:BADDEV_ptr
	invoke	std_printf
	JMP	SHORT RESRET

DEVISOK:
	push	dx				;AN007; save device info
	mov	ax,acrlf_ptr			;AN021; get message number for 0d, 0a
	mov	dh,util_msg_class		;AN021; this is a utility message
	push	bx				;AN021; save handle
	invoke	Tsysgetmsg			;AN021; get the address of the message
	mov	dx,si				;AN021; get address into dx
	mov	ax,(write shl 8)		;AN007; write to device
	mov	cx,2				;AN007; write two bytes
	int	21h			;AN007;
	pop	bx				;AN021; get back handle
	pop	dx				;AN007; get back device info
	jc	closedev			;AN007; if error, quit
	XOR	DH,DH
	OR	DL,3				; Make sure has CON attributes
	MOV	AX,(IOCTL SHL 8) OR 1
	INT	21h
	PUSH	BX				; Save handle
	MOV	CX,3
	XOR	BX,BX

ICLLOOP:					; Close basic handles
	MOV	AH,CLOSE
	INT	21h
	INC	BX
	LOOP	ICLLOOP
	POP	BX				; Get handle
	MOV	AH,XDUP
	INT	21h			; Dup it to 0
	MOV	AH,XDUP
	INT	21h			; Dup to 1
	MOV	AH,XDUP
	INT	21h			; Dup to 2
	MOV	AH,CLOSE			; Close initial handle
	INT	21h

RESRET:
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	PUSH	DS
	MOV	AX,WORD PTR DS:[PDB_JFN_Table]	; Get new 0 and 1
	MOV	[IO_SAVE],AX
	MOV	AX,OFFSET DATARES:TrnLodCom1_Trap
	PUSH	AX

ZMMMM	PROC FAR
	RET					; Force header to be checked
ZMMMM	ENDP

	break	Chcp

;****************************************************************
;*
;* ROUTINE:	CHCP - Change code page internal command
;*		(added DOS 3.30 07/21/86)
;*
;* SYNTAX:	CHCP [xxx]
;*		where xxx is a valid code page
;*
;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
;*		6402H to set the code page to xxxx. If no parameters
;*		are specified, CHCP will use INT 21H function 6401H
;*		to get global code page and display it to the user.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	none
;*
;****************************************************************

NLSFUNC_installed	equ    0ffh
set_global_cp		equ    2
get_global_cp		equ    1

assume	ds:trangroup,es:trangroup

CHCP:
	push	ds				;AN000; Get local ES
	pop	es				;AN000;
	mov	si,81H				;AC000; Get command argument for CHCP

	mov	di,offset trangroup:parse_chcp	;AN000; Get adderss of PARSE_CHCP
	xor	cx,cx				;AC000; clear cx,dx
	xor	dx,dx				;AC000;
	call	parse_with_msg			;AC018; call parser
	cmp	ax,end_of_line			;AN000; are we at end of line?

;;	jnz	setcp				;AC000; no go get number & set code page
	jz	getcp				;AC000; yes - no parm - get code page

setcp:
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	cp_error			;AC018; yes - go issue message

	push	cx				;AN000; save positional count
	mov	bx,offset trangroup:parse1_addr ;AN000; get number returned
	mov	cx,word ptr [bx]		;AN000;     into cx
	mov	system_cpage,cx 		;AN000; save user input number
	pop	cx				;AC000; restore positional count
	mov	di,offset trangroup:parse_chcp	;AN000; Get adderss of PARSE_CHCP
	call	parse_check_eol 		;AN000; are we at end of line?
	jnz	cp_error			;AC000; no - exit

okset:
	mov	ah,NLSFUNC			;AN000; see if NLSFUNC installed
	mov	al,0				;AN000;
	int	2fh				;AN000;
	cmp	al,NLSFUNC_installed		;AN000;
	jz	got_NLS 			;AN000; Yes - continue
	mov	dx,offset trangroup:NLSFUNC_ptr ;AN000; no - set up error message
	jmp	short cp_error			;AN000; error exit

got_NLS:
	mov	bx,system_cpage 		;AN000; get user input code page
	mov	ah,getsetcdpg			;get/set global code page function
	mov	al,set_global_cp		;minor - set
	int	21h
	jnc	chcp_return			;no error - exit
;
;added for p716
;
	cmp	ax,error_file_not_found 	;p716 was the error file not found?
	jnz	chcp_other_error		;no - country.sys was found

	mov	ah,GetExtendedError		;p850 see if error is invalid data
	xor	bx,bx				;  which is file was found but CP
	int	21h			;  information was not found.
	cmp	ax,error_invalid_data		;AC000; invalid code page
	jnz	no_countrysys			;no - use file not found
	mov	dx,offset trangroup:inv_code_page ;AN000; get message
	jmp	short cp_error			;AC000; error exit

no_countrysys:
;M045;	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
;M045;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
;M045;	mov	Extend_Buf_ptr,error_file_not_found ;AN000; get message number in control block
	
	mov	dx,offset TRANGROUP:NoCntry_Ptr	;M045

	jmp	short cp_error			;AC000; error exit

chcp_other_error:
;
; end of p716
;
	mov	ah,GetExtendedError		;error - see what it is
	xor	bx,bx
	int	21h
	cmp	ax,65				;was it access denied?
	jnz	none_set			;no - assume all failed
	mov	dx,offset trangroup:cp_not_all_ptr ;set up message
	jmp	short cp_error			;AC000; error exit

none_set:
	mov	dx,offset trangroup:cp_not_set_ptr ;set up message
cp_error:					;AN000;
	jmp	cerror				;exit

getcp:
	mov	ah,getsetcdpg			;get/set global code page function
	mov	al,get_global_cp		;minor - get
	int	21h
	mov	system_cpage,bx 		;get active cp for output
	mov	dx,offset trangroup:cp_active_ptr
	invoke	std_printf			;print it out

chcp_return:

	RET

	break	TRUENAME			;AN000;


; ****************************************************************
; *
; * ROUTINE:	 TRUENAME
; *
; * FUNCTION:	 Entry point for the internal TRUENAME command.
; *		 Parses the command line. If a path is found, set
; *		 SRCXNAME to path.  If only a drive letter is
; *		 found, set SRCXNAME to the drive letter.  If
; *		 no path is found, set the path of SRCXNAME to
; *		 dot (.) for current directory.  Use the NAME
; *		 TRANSLATE system call to get the real name and
; *		 then display the real name.  If an error occurs
; *		 issue an error message and transfer control to
; *		 CERROR.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup		;AN000;

TRUENAME:					;AN000; TRUENAME entry point
	push	ds				;AN000; Get local ES
	pop	es				;AN000;
	mov	si,81H				;AN000; Get command line
	mov	di,offset trangroup:parse_chdir ;AN000; Get adderss of PARSE_CHDIR
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	call	parse_with_msg			;AC018; call parser

	mov	di,offset trangroup:srcxname	;AN000; get address of srcxname
	cmp	ax,end_of_line			;AN000; are we at end of line?
	je	tn_eol				;AN000; yes - go process
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	tn_parse_error			;AN000; yes - go issue message
	cmp	parse1_type,result_drive	;AN000; was a drive entered?
	je	tn_drive			;AN000; yes - go process
	jmp	short tn_filespec		;AN000; nothing else - must be filespec

tn_eol: 					;AN000; no parameters on line
	mov	ah,end_of_line_out		;AN000; set buffer to .
	mov	al,dot_chr			;AN000;     for current dir
	stosw					;AN000; store in srcxname
	jmp	short tn_doit			;AN000; go do command

tn_drive:					;AN000; a drive was entered
	push	si				;AN000; save position in line
	mov	si,offset trangroup:parse1_addr ;AN000; get address of drive
	lodsb					;AN000; get the drive number
	add	al,"A"-1                        ;AN000; convert it to char
	stosb					;AN000; store it in srcxname
	mov	ax,dot_colon			;AN000; get colon and . and
	stosw					;AN000;    store in srcxname
	mov	al,end_of_line_out		;AN000; put a terminator char
	stosb					;AN000;
	pop	si				;AN000; get line position back
	jmp	short tn_check_eol		;AN000; check to make sure eol

tn_filespec:					;AN000; a filespec was entered
	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AN000; get address of filespec

tn_move_filename:				;AN000; put filespec in srcxname
	lodsb					;AN000; get a char from buffer
	stosb					;AN000; store in srcxname
	cmp	al,end_of_line_out		;AN000; it char a terminator?
	jnz	tn_move_filename		;AN000; no - keep moving
	pop	si				;AN000; get line position back

tn_check_eol:					;AN000; make sure no extra parms
	mov	di,offset trangroup:parse_chdir ;AN000; get address of parse_chdir
	call	parse_check_eol 		;AN000; are we at end of line?
	je	tn_doit 			;AN000; Yes - do the command

tn_parse_error: 				;AN000; A parse error occurred
	jmp	cerror				;AN000; Go to error routine

tn_doit:					;AN000;
	mov	si,offset trangroup:srcxname	;AN000; set up srcxname as source
	mov	di,offset trangroup:combuf	;AN000; set up combuf as target (need big target)
	mov	ah,xnametrans			;AN000; do name translate call
	int	21h			;AN000;
	jnc	tn_print_xname			;AN000; If no error - print result

	invoke	Set_ext_error_msg		;AN000; get extended message
	mov	string_ptr_2,offset trangroup:srcxname ;AN000; get address of failed string
	mov	Extend_buf_sub,one_subst	;AN000; put number of subst in control block
	jmp	cerror				;AN000; Go to error routine

tn_print_xname: 				;AN000;
	mov	string_ptr_2,offset Trangroup:combuf ;AN000; Set up address of combuf
	mov	dx,offset trangroup:string_buf_ptr   ;AN000; Set up address of print control block
	invoke	crlf2				;AN000; print a crlf
	invoke	printf_crlf			;AN000; print it out

	ret					;AN000;

	break	$Exit

assume	ds:trangroup,es:trangroup

$EXIT:
	push	ds				;AN000; save data segment
	mov	ds,[resseg]			;AN000; get resident data segment

assume	ds:resgroup				;AN000;

	cmp	[permcom],0			;AN045; is this a permanent COMMAND?
	jz	free_com			;AN045; no - free everything

;	We're a permanent command.
;	Unless this is a singlecom (int 2Eh), don't deallocate transient.

	cmp	[singlecom],-1		;M034
	je	no_reset		;M034	;exit singlecom

;	jmp	TCommand			;permanent command, recycle

;Sudeepb 05-Jul-1991; Removed above jmp to terminate the top level
;		      command.com.
	CMDSVC	SVC_CMDEXITVDM		; Never returns

;AD060; mov	ah,multdos			;AN000; reset parse message pointers
;AD060; mov	al,message_2f			;AN000; call for message retriever
;AD060; mov	dl,set_parse_msg		;AN000; set up parse message address
;AD060; mov	di,pars_msg_off 		;AN000; old offset of parse messages
;AD060; mov	es,pars_msg_seg 		;AN000; old segment of parse messages
;AD060; int	2fh				;AN000; go set it

;AD060; mov	ah,multdos			;AN000; set up to call DOS through int 2fh
;AD060; mov	al,message_2f			;AN000; call for message retriever

free_com:
	mov	ax,(multdos shl 8 or message_2f);AN060; reset parse message pointers
	mov	dl,set_critical_msg		;AN000; set up critical error message address
	mov	di,crit_msg_off 		;AN000; old offset of critical messages
	mov	es,crit_msg_seg 		;AN000; old segment of critical messages
	int	2fh				;AN000; go set it
no_reset:					;AN045;
	pop	ds				;AN000; restore local data segment

assume	ds:trangroup				;AN000;
;
;M040
; Restore user directory if the restore flag is set. RestUDir1 checks for
;this, restores user dir if flag is set and resets the flag.
;
	invoke	RestUDir1		;restore user dir if needed ;M040
	MOV	ES,[RESSEG]

assume	es:resgroup

	MOV	AX,[PARENT]
	MOV	WORD PTR ES:[PDB_Parent_PID],AX
	MOV	AX,WORD PTR OldTerm
	MOV	WORD PTR ES:[PDB_Exit],AX
	MOV	AX,WORD PTR OldTerm+2
	MOV	WORD PTR ES:[PDB_Exit+2],AX

	PUSH	ES
	MOV	ES,[TRAN_TPA]
	MOV	AH,DEALLOC
	INT	21h			; Now running in "free" space
	POP	ES

	MOV	AH,Exit
	MOV	AL,BYTE PTR RetCode
	INT	21h


; ****************************************************************
; *
; * ROUTINE:	 PARSE_CHECK_EOL
; *
; * FUNCTION:	 Calls parser to see if end of line occurred.
; *		 If not end of line, set up to print parse
; *		 error message.  ASSUMES NO MORE PARAMETERS ARE
; *		 EXPECTED!
; *
; * INPUT:	 DS:SI	  last output from parser
; *		 ES:DI	  points to parse block
; *		 CX	  last output from parser
; *
; * OUTPUT:	 AX	  parser return code
; *
; *		 if end of line found
; *		     zero flag set
; *		 else
; *		     MSG_DISPLAY_CLASS set to parse error
; *
; ****************************************************************

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN000;

parse_check_eol Proc near			;AN000;

	xor	dx,dx				;AN000;
	mov	[parse_last],si 		;AN018; save start of parameter
	invoke	cmd_parse			;AN000; call parser
	cmp	al,end_of_line			;AN000; Are we at end of line?
	jz	parse_good_eol			;AN000; yes - no problem

	cmp	ax,result_no_error		;AN018; was any error found?
	jnz	ok_to_setup_pmsg		;AN018; yes - continue
	inc	ax				;AN018; set AX to 1 and turn off zero flag

ok_to_setup_pmsg:
	call	setup_parse_error_msg		;AN018; go set up error message

parse_good_eol:
	ret					;AN000;

parse_check_eol endp				;AN000;

; ****************************************************************
; *
; * ROUTINE:	 PARSE_WITH_MSG
; *
; * FUNCTION:	 Calls parser.	If an error occurred, the error
; *		 message is set up.
; *
; * INPUT:	 DS:SI	  last output from parser
; *		 ES:DI	  points to parse block
; *		 CX	  last output from parser
; *
; * OUTPUT:	 AX	  parser return code
; *
; *		 if no error
; *		     outputs from parser
; *		 else
; *		     MSG_DISPLAY_CLASS set to parse error
; *		     error message set up for STD_PRINTF
; *
; ****************************************************************

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;

parse_with_msg	Proc near			;AN018;

	mov	[parse_last],si 		;AN018; save start of parameter
	invoke	cmd_parse			;AN018; call parser
	cmp	al,end_of_line			;AN018; Are we at end of line?
	jz	parse_msg_good			;AN018; yes - no problem
	cmp	ax,result_no_error		;AN018; did an error occur
	jz	parse_msg_good			;AN018; yes - no problem

	call	setup_parse_error_msg		;AN018; go set up error message

parse_msg_good:
	ret					;AN018;

parse_with_msg endp				;AN018;

; ****************************************************************
; *
; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
; *
; * FUNCTION:	 Calls parser.	If an error occurred, the error
; *		 message is set up.
; *
; * INPUT:	 AX	     Parse error number
; *		 SI	     Set to past last parameter
; *		 Parse_last  Set to start of last parameter
; *
; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
; *		 error message set up for STD_PRINTF
; *
; ****************************************************************

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;

SETUP_PARSE_ERROR_MSG	Proc near		;AN018;

	mov	msg_disp_class,parse_msg_class	;AC018; Set up parse message class
	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC018; get extended message pointer
	mov	byte ptr [si],end_of_line_out	;AC018; terminate the parameter string
	mov	Extend_Buf_ptr,ax		;AC018; get message number in control block
	cmp	ax,lessargs_ptr 		;AC018; if required parameter missing
	jz	Setup_parse_msg_ret		;AN018;    no subst
	mov	si,[parse_last] 		;AC018; get start of parameter
	mov	string_ptr_2,si 		;AC018; get address of failed string
	mov	Extend_buf_sub,one_subst	;AC018; put number of subst in control block

setup_parse_msg_ret:
	inc	si				;AN018; make sure zero flag not set

	ret					;AC018;

SETUP_PARSE_ERROR_MSG	Endp			;AN018;

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tbatch2.asm ===
page ,132
;	SCCSID = @(#)tbatch2.asm	4.2 85/07/22
;	SCCSID = @(#)tbatch2.asm	4.2 85/07/22
TITLE	Batch processing routines part II
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M020	SR	08/20/89	Changed GetBatByt to check if we
;				already reached EOF before trying
;				to read from batchfile. Also fixed
;				old bug of ds not being setup on an 
;				error while reading the batchfile.
;
;	M037	SR	11/1/90	Bug #1745 & #3438 fixed. On a GOTO, we
;				reseek to the beginning of the
;				batchfile. Clear the BatchEOF flag
;				to indicate that we are no longer at
;				EOF.
;

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BATCH:WORD
	EXTRN	Batch_Abort:byte
	EXTRN	call_batch_flag:byte
	EXTRN	call_flag:byte
	EXTRN	IFFlag:BYTE
	EXTRN	In_Batch:byte
	EXTRN	Nest:word
	EXTRN	PIPEFILES:BYTE
	EXTRN	RETCODE:WORD
	EXTRN	SINGLECOM:WORD

;;;	extrn	BatchEOF:byte
	extrn	EchoFlag:byte
	extrn	Next_Batch:word
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BADLAB_PTR:WORD
	EXTRN	BatBufLen:WORD
	EXTRN	IFTAB:BYTE
	EXTRN	SYNTMES_PTR:WORD
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
	EXTRN	BatBuf:BYTE
	EXTRN	BatBufEnd:WORD
	EXTRN	BatBufPos:WORD
	EXTRN	BATHAND:WORD
	EXTRN	COMBUF:BYTE
	EXTRN	DIRBUF:BYTE
	EXTRN	GOTOLEN:WORD
	EXTRN	if_not_count:word
	EXTRN	IFNOTFLAG:BYTE
	EXTRN	RESSEG:WORD
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	cerror:near
	EXTRN	docom1:near
	EXTRN	tcommand:near

	public	$if,iferlev,goto,shift,ifexists,ifnot,forerror,$call


Break	<GetBatByt - retrieve a byte from the batch file>

; Get one byte from the batch file and return it in AL.  End-of-file returns
; <CR> and ends batch mode.  DS must be set to resident segment.
; AH, DX destroyed.

Procedure   GETBATBYT,NEAR

ASSUME	DS:RESGROUP

	SaveReg <BX,CX,DS>
	test	byte ptr [Batch_Abort],-1
	jz	@f
	jmp	BatEOF
@@:
	TEST	Batch,-1
	JnZ	@f
	jmp	BatEOF
@@:
	PUSH	ES
	MOV	ES,Batch
	ASSUME	ES:NOTHING

;M020;
;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
;try to read from the batchfile again.
;
	cmp	es:BatchEOF,0			;already reached EOF? ;M020
	jz	not_eof			;no, read batch file ;M020
	jmp	At_EOF				;yes, no more reads ;M020
not_eof:						;M020

	ADD	WORD PTR ES:[BatSeek],1
	ADC	WORD PTR ES:[BatSeek+2],0
	POP	ES
;
; See if we have bytes buffered...
;
	MOV	AX,CS
	MOV	DS,AX
	ASSUME	DS:TranGroup
	MOV	BX,BatBufPos
	CMP	BX,-1
	JNZ	UnBuf
;
; There are no bytes in the buffer.  Let's try to fill it up.
;
	MOV	DX,OFFSET TranGROUP:BatBuf
	MOV	CX,BatBufLen			; max to read.
	MOV	BX,BatHand
	MOV	AH,READ
	INT	21h			; Get one more byte from batch file
	jnc	bat_read_ok			;AN022; if no error - continue
	invoke	get_ext_error_number		;AN022; get the error
	push	ds				;AN022; save local segment
	mov	ds,[resseg]			;AN022; get resident segment
assume	ds:resgroup				;AN022;
	mov	dx,ax				;AN022; put error in DX
	invoke	output_batch_name		;AN022; set up to print the error
	pop	ds				;AN022;
assume	ds:trangroup				;AN022;
	invoke	std_eprintf			;AN022; print out the error
	mov	byte ptr combuf+2,end_of_line_in;AN022; terminate the batch line for parsing
	mov	byte ptr combuf+3,end_of_line_out ;AN022; terminate the batch line for output
;M020;
;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
;error is never hit (and it shouldn't be)
;
	mov	ds,ResSeg			; ds = RESGROUP ; M020

	jmp	short bateof			;AN022; terminate the batch file

bat_read_ok:					;AN022;
	MOV	CX,AX
	JCXZ	BATEOFDS
	MOV	BatBufEnd,CX
	XOR	BX,BX
	MOV	BatBufPos,BX
;
; Buffered bytes!
;
UnBuf:
	MOV	AL,BatBuf[BX]			; get next byte
	INC	BX
	CMP	BX,BatBufEnd			; beyond end of buffer?
	JB	SetBufPos
	MOV	BX,-1

SetBufPos:
	MOV	BatBufPos,BX
	CMP	AL,1AH				; ^Z for termination?
	jnz	GetByteDone
;
;We get here only when we hit an EOF
;
BatEOFDS:
;SR;
; HACK!!! A massive hack being put in here to get batch processing to work
;properly on EOF. Previously, a CR was returned and batch processing turned
;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
;batch processing is turned off before the last line is processed and so 
;this line would never be executed. 
;   	To fix this, a new flag BatchEOF has been introduced. This flag is
;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
;at the buffer contents. If there is no LF ( we assume that presence of LF
;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
;fake CR to the caller. This decrements BatchEOF. On the next call to this
;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
;third call, BatchEOF becomes zero and batch processing is turned off,
;now that the last line has been processed. If the EOF is the first char read into the buffer 
;during this call, and there was a CR-LF previously, we are going to fake
;another redundant CR-LF. There is no work-around I can think of.
; 	I would love to restructure this entire routine and its caller to
;make the flow really easy to understand but I guess this will have to wait.
;
	push	es
	mov	es,ResSeg
;SR;
; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
;or BatchEOF == 1 now), then do not do the LF check.
;
	mov	es,es:Batch
	cmp	es:BatchEOF,0
	jnz	crpresent

	inc	es:BatchEOF			;match the dec following
	mov	bx,BatBufEnd
	cmp	BatBuf[bx-1],0ah			;was a LF present?
	je	crpresent			;yes, no need to fake it

	add	es:BatchEOF,3			;BatchEOF == 4 to fake CR-LF

crpresent:
;;;	pop	es

	ASSUME	DS:TranGroup
	MOV	DS,ResSeg
	ASSUME	DS:ResGroup

;SR;
; The shift operation is done here to replace the decrement. This is because
;we can jump to this label directly from above when bogus calls are made to
;this routine even after batch processing is turned off. The shift ensures
;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
;it is used as a decrement and also as a NOP to just fall through on bogus 
;calls.
;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
;turning batch processing off.
;
At_EOF:						;new label added ;M020
	shr	es:BatchEOF,1			;decrement the flag
	jz	turn_off			;zero,turn batch off
	cmp	es:BatchEOF,1				
	jz	ret_lf				;BatchEOF was 2, return LF
;
;BatchEOF == 4, indicates return fake CR now and fake LF next.
;
	mov	al,0dh				;return fake CR.
	pop	es
	jmp	short GetByteDone
ret_lf:
	mov	al,0ah				;return fake LF
	pop	es
	jmp	short	GetByteDone			
turn_off:
	pop	es

BATEOF:
	invoke	BatchOff			;turn batch processing off
	CALL	BATCLOSE
;;;	mov	BatchEOF,0			;make sure BatchEOF = 0

;SR; BugBug
; There is a good reason why this carriage return is being returned here. 
;This was part of the old code. Because,
;of the way the caller is structured, a fake CR has to be returned again on
;EOF to ensure the termination of the caller's loop. If echo is on, this
;results in an extra linefeed after the batchfile is run if the last line of
;the batchfile already had a CR-LF. 
;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
;the end-of-line. This CR is to mark the end-of-file.
;
	MOV	AL,0dH				; If end-of-file, then end of line

	test	byte ptr [Batch_Abort],-1
	mov	byte ptr [Batch_Abort],0
	jz	Cont_Get_Byt
	mov	di,offset TRANGROUP:COMBUF+2	; reset pointer to beginning of buffer
	xor	cx,cx				; zero line length
	jmp	short GetByteDone

Cont_Get_Byt:
	CMP	[SINGLECOM],0FFF0H		; See if we need to set SINGLECOM
	JNZ	GetByteDone
	CMP	NEST,0				;G See if we have nested batch files
	JNZ	GETBYTEDONE			;G Yes - don't exit just yet
	MOV	[SINGLECOM],-1			; Cause termination

GetByteDone:
	RestoreReg  <DS,CX,BX>

	return

EndProc GetBatByt

	break	<$If - conditional execution>
assume	ds:trangroup,es:trangroup

IFERRORP:
	POP	AX
IFERROR:
FORERROR:
	MOV	DX,OFFSET TRANGROUP:SYNTMES_ptr
	JMP	CERROR

$IF:
;
; Turn off any pipes in progress.
;
	push	ds				;AN004; save local DS
	mov	ds,[resseg]			;AN004; get resident segment
	assume	ds:resgroup			;AN004;
	cmp	[PIPEFILES],0			;AN004; Only turn off if present.
	jz	IFNoPipe			;AN004; no pipe - continue
	invoke	PipeDel 			;AN004; turn off piping

IFNoPipe:					;AN004;
	pop	ds				;AN004; get local DS back
	assume	ds:trangroup			;AN004;
	MOV	[IFNOTFLAG],0
	mov	[if_not_count], 0
	MOV	SI,81H

IFREENT:
	invoke	SCANOFF
	CMP	AL,0DH
	JZ	IFERROR
	MOV	BP,SI
	MOV	DI,OFFSET TRANGROUP:IFTAB	; Prepare to search if table
	MOV	CH,0

IFINDCOM:
	MOV	SI,BP
	MOV	CL,[DI]
	INC	DI
	JCXZ	IFSTRING
	JMP	SHORT FIRSTCOMP

IFCOMP:
	JNZ	IF_DIF				;AC000;

FIRSTCOMP:
	LODSB
	MOV	AH,ES:[DI]
	INC	DI
	CMP	AL,AH
	JZ	IFLP
	OR	AH,20H				; Try lower case
	CMP	AL,AH

IFLP:
	LOOP	IFCOMP

IF_DIF: 					;AC000;
	LAHF
	ADD	DI,CX				; Bump to next position without affecting flags
	MOV	BX,[DI] 			; Get handler address
	INC	DI
	INC	DI
	SAHF
	JNZ	IFINDCOM
	LODSB
	CMP	AL,0DH

IFERRORJ:
	JZ	IFERROR
	invoke	DELIM
	JNZ	IFINDCOM
	invoke	SCANOFF
	JMP	BX

IFNOT:
	NOT	[IFNOTFLAG]
	inc	[if_not_count]
	JMP	IFREENT

;
; We are comparing two strings for equality.  First, find the end of the
; first string.
;

IFSTRING:
	PUSH	SI				; save away pointer for later compare
	XOR	CX,CX				; count of chars in first string

FIRST_STRING:
	LODSB					; get character
	CMP	AL,0DH				; end of line?
	JZ	IFERRORP			; yes => error
	invoke	DELIM				; is it a delimiter?
	JZ	EQUAL_CHECK			; yes, go find equal sign
	INC	CX				; remember 1 byte for the length
	JMP	FIRST_STRING			; go back for more
;
; We have found the end of the first string.  Unfortunately, we CANNOT use
; scanoff to find the next token; = is a valid separator and will be skipped
; over.
;

EQUAL_CHECK:
	CMP	AL,'='                          ; is char we have an = sign?
	JZ	EQUAL_CHECK2			; yes, go find second one.
	CMP	AL,0DH				; end of line?
	JZ	IFERRORPj			;AC004; yes, syntax error
	LODSB					; get next char
	JMP	EQUAL_CHECK
;
; The first = has been found.  The next char had better be an = too.
;

EQUAL_CHECK2:
	LODSB					; get potential = char
	CMP	AL,'='                          ; is it good?
	jnz	iferrorpj			; no, error
;
; Find beginning of second string.
;
	invoke	SCANOFF
	CMP	AL,0DH
	jz	iferrorpj
	POP	DI
;
; DS:SI points to second string
; CX has number of chars in first string
; ES:DI points to first string
;
; Perform compare to elicit match
;
	REPE	CMPSB
	JZ	MATCH				; match found!
;
; No match.  Let's find out what was wrong.  The character that did not match
; has been advanced over.  Let's back up to it.
;
	DEC	SI
;
; If it is EOL, then syntax error
;
	CMP	BYTE PTR [SI],0DH
	JZ	IFERRORJ
;
; Advance pointer over remainder of unmatched text to next delimiter
;

SKIPSTRINGEND:
	LODSB

NOTMATCH:
	CMP	AL,0DH

IFERRORJ2:
	JZ	IFERRORJ
	invoke	DELIM
	JNZ	SKIPSTRINGEND
;
; Signal that we did NOT have a match
;
	MOV	AL,-1
	JMP	SHORT IFRET

iferrorpj:
	jmp	iferrorp
;
; The compare succeeded.  Was the second string longer than the first?	We
; do this by seeing if the next char is a delimiter.
;

MATCH:
	LODSB
	invoke	DELIM
	JNZ	NOTMATCH			; not same.
	XOR	AL,AL
	JMP	SHORT IFRET

IFEXISTS:
ifexist_attr	    EQU     attr_hidden+attr_system

moredelim:
	lodsb					; move command line pointer over
	invoke	delim				; pathname -- have to do it ourselves
	jnz	moredelim			; 'cause parse_file_descriptor is dumb
	mov	DX, OFFSET TRANGROUP:dirbuf
	trap	set_dma
	mov	BX, 2				; if(0) [|not](|1) exist[1|2] file(2|3)
	add	BX, [if_not_count]
	mov	AX, OFFSET TRANGROUP:arg.argv
	invoke	argv_calc			; convert arg index to pointer
	mov	DX, [BX].argpointer		; get pointer to supposed filename
	mov	CX, ifexist_attr		; filetypes to search for
	trap	Find_First			; request first match, if any
	jc	if_ex_c 			; carry is how to determine error
	xor	AL, AL
	jmp	short ifret

if_ex_c:
	mov	AL, -1				; false 'n' fall through...

IFRET:
	TEST	[IFNOTFLAG],-1
	JZ	REALTEST
	NOT	AL

REALTEST:
	OR	AL,AL
	JZ	IFTRUE
	JMP	TCOMMAND

IFTRUE:
	invoke	SCANOFF
	MOV	CX,SI
	SUB	CX,81H
	SUB	DS:[80H],CL
	MOV	CL,DS:[80H]
	MOV	[COMBUF+1],CL
	MOV	DI,OFFSET TRANGROUP:COMBUF+2
	CLD
	REP	MOVSB
	MOV	AL,0DH
	STOSB
;
; Signal that an IF was done.  This prevents the redirections from getting
; lost.
;
	PUSH	DS
	MOV	DS,ResSeg
	ASSUME	DS:RESGROUP
	MOV	IFFlag,-1
	POP	DS
	ASSUME	DS:TRANGROUP
;
; Go do the command
;
	JMP	DOCOM1

iferrorj3:
	jmp	iferrorj2

IFERLEV:
	MOV	BH,10
	XOR	BL,BL

GETNUMLP:
	LODSB
	CMP	AL,0DH
	jz	iferrorj3
	invoke	DELIM
	JZ	GOTNUM
	SUB	AL,'0'
	XCHG	AL,BL
	MUL	BH
	ADD	AL,BL
	XCHG	AL,BL
	JMP	SHORT GETNUMLP

GOTNUM:
	PUSH	DS
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	AH,BYTE PTR [RETCODE]
	POP	DS
ASSUME	DS:TRANGROUP
	XOR	AL,AL
	CMP	AH,BL
	JAE	IFRET
	DEC	AL
	JMP	SHORT IFRET


	break	<Shift - advance arguments>

;
; Shift the parameters in the batch structure by 1 and set up the new argument.
; This is a NOP if no batch in progress.
;

Procedure   Shift,NEAR

assume	ds:trangroup,es:trangroup

	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	AX,[BATCH]			; get batch pointer
	OR	AX,AX				; in batch mode?
	retz					; no, done.
	MOV	ES,AX				; operate in batch segment
	MOV	DS,AX

ASSUME	DS:NOTHING,ES:NOTHING

;
; Now move the batch args down by 1 word
;
	MOV	DI,BatParm			; point to parm table
	LEA	SI,[DI+2]			; make source = dest + 2
	MOV	CX,9				; move 9 parameters
	REP	MOVSW				; SHIFT down
;
; If the last parameter (the one not moved) is empty (= -1) then we are done.
; We have copied it into the previous position
;
	CMP	WORD PTR [DI],-1		; if last one was not in use then
	retz					; No new parm
;
; This last pointer is NOT nul.  Get it and scan to find the next argument.
; Assume, first, that there is no next argument
;
	MOV	SI,[DI]
	MOV	WORD PTR [DI],-1		; Assume no parm
;
; The parameters are CR separated.  Scan for end of this parm
;
SKIPCRLP:
	LODSB
	CMP	AL,0DH
	JNZ	SKIPCRLP
;
; We are now pointing at next arg.  If it is 0 (end of original line) then we
; are finished.  There ARE no more parms and the pointer has been previously
; initialized to indicate it.
;
	CMP	BYTE PTR [SI],0
	retz					; End of parms
	MOV	[DI],SI 			; Pointer to next parm as %9

	return

EndProc Shift

;
; Skip delim reads bytes from the batch file until a non-delimiter is seen.
; returns char in AL, carry set -> eof
;

Procedure   SkipDelim,NEAR

	ASSUME	DS:ResGroup,ES:NOTHING
	TEST	Batch,-1
	JZ	SkipErr 			; batch file empty.  OOPS!
	CALL	GetBatByt			; get a char
	invoke	Delim				; check for ignoreable chars
	JZ	SkipDelim			; ignore this char.
	clc
	return

SkipErr:
	stc
	return

EndProc SkipDelim

	break  $Call

;  CALL is an internal command that transfers control to a .bat, .exe, or
;  .com file.  This routine strips the CALL off the command line,  sets
;  the CALL_FLAG to indicate a call in progress, and returns control to
;  DOCOM1 in TCODE to reprocess the command line and execute the file
;  being CALLed.

$CALL:

;  strip off CALL from command line

	ASSUME DS:trangroup,ES:trangroup
	push	si
	push	di
	push	ax
	push	cx
	mov	si,offset trangroup:combuf+2
	invoke	scanoff 			;get to first non-delimeter
	add	si,length_call			;point to char past CALL
	mov	di,offset trangroup:combuf+2
	mov	cx,combuflen-length_call	;get length of buffer
	rep	movsb				;move it
	pop	cx
	pop	ax
	pop	di
	pop	si


;  set call flag to indicate call in progress

	push	ds
	mov	ds,[resseg]
	ASSUME DS:resgroup,ES:resgroup
	mov	call_flag, call_in_progress
	mov	call_batch_flag, call_in_progress
;
; Turn off any pipes in progress.
;
	cmp	[PIPEFILES],0			; Only turn off if present.
	jz	NoPipe
	invoke	PipeDel
NoPipe:
	pop	ds

	ret

	break	Goto

GOTO:

	assume	ds:trangroup,es:trangroup
	MOV	DS,[RESSEG]
	assume	ds:resgroup
	TEST	[BATCH],-1
	retz					; If not in batch mode, a nop
	XOR	DX,DX
	PUSH	DS
	MOV	DS,Batch
	MOV	WORD PTR DS:[BatSeek],DX	; Back to start
	MOV	WORD PTR DS:[BatSeek+2],DX	; Back to start
;M037
; Clear EOF indicator because we have reseeked to the beginning of the file.
;
	mov	ds:BatchEOF,0		; clear eof indicator ;M037

	POP	DS

GotoOpen:
	invoke	promptBat
	MOV	DI,FCB+1			; Get the label
	MOV	CX,11
	MOV	AL,' '
	REPNE	SCASB
	JNZ	NOINC
	INC	CX

NOINC:
	SUB	CX,11
	NEG	CX
	MOV	[GOTOLEN],CX
;
; At beginning of file.  Skip to first non-delimiter char
;
	CALL	SkipDelim
	JC	BadGoto
	CMP	AL,':'
	JZ	CHKLABEL

LABLKLP:					; Look for the label
	CALL	GETBATBYT
	CMP	AL,0AH
	JNZ	LABLKTST
;
; At beginning of line.  Skip to first non-delimiter char
;
	CALL	SkipDelim
	JC	BadGoto
	CMP	AL,':'
	JZ	CHKLABEL

LABLKTST:
	TEST	[BATCH],-1
	JNZ	LABLKLP

BadGoto:
	CALL	BATCLOSE
;SR;
; At this point we are terminating without freeing up any nested batch 
;segments i.e if the error occurred within a called batch file. This routine
;will traverse the linked list of batch segments and free all of them.
;
	call	free_batch		;free up nested batch segments

	PUSH	CS
	POP	DS
	MOV	DX,OFFSET TRANGROUP:BADLAB_ptr
	JMP	CERROR

;
; Found the :.	Skip to first non-delimiter char
;

CHKLABEL:
	CALL	SkipDelim
	JC	BadGoto
	MOV	DI,FCB+1
	MOV	CX,[GOTOLEN]
	JMP	SHORT GotByte

NEXTCHRLP:
	PUSH	CX
	CALL	GETBATBYT
	POP	CX

GotByte:
	INVOKE	TESTKANJ			;AN000;  3/3/KK
	JZ	NOTKANJ1			;AN000;  3/3/KK
	CMP	AL, ES:[DI]			;AN000;  3/3/KK
	JNZ	LABLKTST			;AN000;  3/3/KK
	INC	DI				;AN000;  3/3/KK
	DEC	CX				;AN000;  3/3/KK
	JCXZ	LABLKTST			;AN000;  3/3/KK
	PUSH	CX				;AN000;  3/3/KK
	CALL	GETBATBYT			;AN000;  3/3/KK
	POP	CX				;AN000;  3/3/KK
	CMP	AL, ES:[DI]			;AN000;  3/3/KK
	JMP	SHORT KNEXTLABCHR		;AN000;  3/3/KK

NOTKANJ1:					;AN000;  3/3/KK
	OR	AL,20H
	CMP	AL,ES:[DI]
	JNZ	TRYUPPER
	JMP	SHORT NEXTLABCHR

TRYUPPER:
	SUB	AL,20H
	CMP	AL,ES:[DI]

KNEXTLABCHR:					;AN000;  3/3/KK
	JNZ	LABLKTST

NEXTLABCHR:
	INC	DI
	LOOP	NEXTCHRLP
	CALL	GETBATBYT
	cmp	[GOTOLEN],8			; Is the label atleast 8 chars long?
	jge	gotocont			; Yes, then the next char doesn't matter
	CMP	AL,' '
	JA	LABLKTST

gotocont:
	CMP	AL,0DH
	JZ	SKIPLFEED

TONEXTBATLIN:
	CALL	GETBATBYT
	CMP	AL,0DH
	JNZ	TONEXTBATLIN

SKIPLFEED:
	CALL	GETBATBYT

;SR;
; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
;CR-LF for the last line. On a goto, this flag has to be cleared, because
;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
;to get the EOF has not been made yet because we encountered the Goto. On
;all other cases, EOF will be hit while trying to read the next line and
;we are fine.
;
	push	es
	mov	es,Batch
	mov	es:BatchEOF,0			;invalidate fake CR-LF flag
	pop	es
	CALL	BatClose

	return

Procedure   BatClose,NEAR
	assume	ds:resgroup

	MOV	BX,CS:[BATHAND]
	CMP	BX,5
	JB	CloseReturn
	MOV	AH,CLOSE
	INT	21h

CloseReturn:
	mov	byte ptr [In_Batch],0		; reset flag
	return

EndProc BatClose

;
; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
; Also, fills internal batch buffer.  If access denied, then AX = -1
;

Procedure   BatOpen,NEAR

ASSUME	DS:RESGROUP,ES:TRANGROUP

	PUSH	DS
	MOV	DS,[BATCH]
ASSUME	DS:NOTHING

	MOV	DX,BatFile
	MOV	AX,OPEN SHL 8
	INT	21h			; Open the batch file
	JC	SETERRDL
	MOV	DX,WORD PTR DS:[BatSeek]
	MOV	CX,WORD PTR DS:[BatSeek+2]
	POP	DS
ASSUME	DS:RESGROUP

	MOV	[BATHAND],AX
	MOV	BX,AX
	MOV	AX,LSEEK SHL 8			; Go to the right spot
	INT	21h
	MOV	BatBufPos,-1			; nuke batch buffer position

	return

SETERRDL:
	MOV	BX,DX
	invoke	get_ext_error_number		;AN022; get the extended error
	mov	dx,ax				;AN022; save extended error in DX
	MOV	AL,[BX] 			; Get drive spec
	SUB	AL,'@'                          ; A = 1
	POP	DS
	STC					; SUB mucked over carry

	return

EndProc BatOpen


;
;Free_batch : This routine traverses the linked batch segments freeing all
;the batch and FOR segments until all of them are freed. It also restores
;the old state of the EchoFlag.
;
;	ENTRY:	ds = RESGROUP
;
;	EXIT: 	All batch & FOR segments freed.
;		EchoFlag restored to old state before batch process.
;
;	REGISTERS AFFECTED: bx, cx


free_batch	proc	near
	assume	ds:RESGROUP,es:nothing

	push	es
	mov	bx,Next_Batch
	or	bx,bx
	jz	fb_ret

ClearBatch:
	mov	es,bx			; get batch segment

	mov	bx,es:BatForPtr		; get old FOR segment
	cmp	bx,0			; is a FOR in progress
	je	no_bat_for		; no - don't deallocate
	push	es			;
	mov	es,bx			; yes - free it up...
	mov	ah,DEALLOC		;
	int	21h			;
	pop	es			; restore to batch segment

No_Bat_For:
	mov	cl,es:BatEchoFlag	; get old echo flag
	mov	bx,es:BatLast	 	; get old batch segment
	mov	ah,DEALLOC		; free it up...
	int	21h
	mov	Batch,bx		; get ready to deallocate next batch
	dec	nest			; is there another batch file?
	jnz	ClearBatch		; keep going until no batch file
	
	mov	EchoFlag,cl		;restore echo status
	mov	Batch,0		;no batch process in progress

fb_ret:
	pop	es
	ret

free_batch	endp


TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tcode.asm ===
page ,132
;       SCCSID = @(#)tcode.asm  1.1 85/05/14
;       SCCSID = @(#)tcode.asm  1.1 85/05/14
TITLE   Part1 COMMAND Transient Routines
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;       Revision History
;       ================
;
;       M025    SR      9/12/90         Removed calls to SetStdInOn,SetStdInOff
;                               SetStdOutOn & SetStdOutOff.
;


.xlist
.xcref
        include comsw.asm
        include dossym.inc
        include syscall.inc
        include comseg.asm
        include comequ.asm
        include cmdsvc.inc
        include mult.inc
ifdef NEC_98
        include pdb.inc
endif   ;NEC_98
        include vint.inc
.list
.cref

Prompt32        equ     1
Start16         equ     0
Return16        equ     1
DOSONLY_YES     equ     1
FOR_TSR         equ     0
FOR_SHELLOUT    equ     1


CODERES         SEGMENT PUBLIC BYTE     ;AC000;
        EXTRN   EXEC_WAIT:NEAR
CODERES ENDS

DATARES         SEGMENT PUBLIC BYTE     ;AC000;
        EXTRN   BATCH:WORD
        EXTRN   CALL_BATCH_FLAG:byte
        EXTRN   CALL_FLAG:BYTE
        EXTRN   ECHOFLAG:BYTE
        EXTRN   envirseg:word
        EXTRN   EXTCOM:BYTE
        EXTRN   FORFLAG:BYTE
        EXTRN   IFFLAG:BYTE
        EXTRN   next_batch:word
        EXTRN   nullflag:byte
        EXTRN   PIPEFILES:BYTE
        EXTRN   PIPEFLAG:BYTE
        EXTRN   RE_OUT_APP:BYTE
        EXTRN   RE_OUTSTR:BYTE
        EXTRN   RESTDIR:BYTE
        EXTRN   SINGLECOM:WORD
        EXTRN   KSWITCHFLAG:BYTE
        EXTRN   VERVAL:WORD
    EXTRN   SCS_Is_First:BYTE
    EXTRN   SCS_PAUSE:BYTE
        EXTRN   SCS_REENTERED:BYTE
        EXTRN   SCS_FIRSTCOM:BYTE
        EXTRN   SCS_CMDPROMPT:BYTE
        EXTRN   SCS_DOSONLY:BYTE
        EXTRN   SCS_PROMPT16:BYTE
        EXTRN   SCS_FIRSTTSR:BYTE
        EXTRN   RES_RDRINFO:DWORD
        EXTRN   RES_BATSTATUS:BYTE
        EXTRN   crit_msg_off:word       ;AC000;
        EXTRN   crit_msg_seg:word       ;AC000;
        EXTRN   OldTerm:DWORD
        EXTRN   PARENT:WORD
        extrn   RetCode:word
        extrn   Io_Save:word
        extrn   Io_Stderr:byte
        extrn   RES_TPA:WORD            ; YST
    extrn   LTPA:WORD       ; YST
DATARES ENDS

TRANDATA        SEGMENT PUBLIC BYTE     ;AC000;
        EXTRN   BadNam_Ptr:word         ;AC000;
        EXTRN   comspec:byte
        EXTRN   NT_INTRNL_CMND:byte
TRANDATA        ENDS

TRANSPACE       SEGMENT PUBLIC BYTE     ;AC000;
        EXTRN   APPEND_EXEC:BYTE        ;AN041;
        EXTRN   ARG1S:WORD
        EXTRN   ARG2S:WORD
        EXTRN   ARGTS:WORD
        EXTRN   BYTCNT:WORD
        EXTRN   COMBUF:BYTE
        EXTRN   COMSW:WORD
        EXTRN   CURDRV:BYTE
        EXTRN   HEADCALL:DWORD
        EXTRN   IDLEN:BYTE
        EXTRN   INTERNATVARS:BYTE
        EXTRN   PARM1:BYTE
        EXTRN   PARM2:BYTE
        EXTRN   RE_INSTR:BYTE
        EXTRN   RESSEG:WORD
        EXTRN   SPECDRV:BYTE
        EXTRN   STACK:WORD
        EXTRN   SWITCHAR:BYTE
        EXTRN   TPA:WORD
        EXTRN   UCOMBUF:BYTE
        EXTRN   USERDIR1:BYTE
        IF  IBM
        EXTRN   ROM_CALL:BYTE
        EXTRN   ROM_CS:WORD
        EXTRN   ROM_IP:WORD
        ENDIF
        EXTRN   ENV_PTR_SEG:WORD
        EXTRN   ENV_SIZE:WORD
        EXTRN   SCS_TSREXIT:WORD
        EXTRN   CMD_PTR_SEG:WORD
        EXTRN   CMD_PTR_OFF:WORD
        EXTRN   CMD_SIZE:WORD
        EXTRN   SCS_EXIT_CODE:WORD
        EXTRN   SCS_RDRINFO:DWORD
        EXTRN   SCS_BATSTATUS:DWORD
        EXTRN   SCS_NUM_DRIVES:WORD
        EXTRN   SCS_CUR_DRIVE:WORD
        EXTRN   SCS_CODEPAGE:WORD
        EXTRN   SCS_STD_HANDLE:WORD
        EXTRN   SCS_STD_BITS:BYTE
        EXTRN   EXECPATH_SEG:WORD
        EXTRN   EXECPATH_OFF:WORD
        EXTRN   EXECPATH_SIZE:WORD
        EXTRN   EXECPATH:BYTE

        EXTRN   TRAN_TPA:WORD
        extrn   transpaceend:byte       ; (YST)

TRANSPACE       ENDS

; (YST)
TAIL segment public para
extrn TranStart:word
TAIL ENDS
; End of (YST)


; ********************************************************************
; START OF TRANSIENT PORTION
; This code is loaded at the end of memory and may be overwritten by
; memory-intensive user programs.

TRANCODE        SEGMENT PUBLIC BYTE     ;AC000;

ASSUME  CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

        EXTRN   $EXIT:NEAR
        EXTRN   DRVBAD:NEAR
        EXTRN   EXTERNAL:NEAR
        EXTRN   FNDCOM:NEAR
        EXTRN   FORPROC:NEAR
        EXTRN   PIPEPROC:NEAR
        EXTRN   PIPEPROCSTRT:NEAR
        EXTRN   GETENVSIZ:near

        PUBLIC  COMMAND
        PUBLIC  DOCOM
        PUBLIC  DOCOM1
        PUBLIC  NOPIPEPROC
        PUBLIC  TCOMMAND

        IF  IBM
        PUBLIC  ROM_EXEC
        PUBLIC  ROM_SCAN
        ENDIF


; NTVDM use diff al value so we don't confuse dos 5.0
; NTVDM command.com GET_COMMAND_STATE       equ     5500h
GET_COMMAND_STATE       equ     5501h

NLSFUNC_installed       equ    0ffh
KEYB16_installed        equ    0ffh         ; (YST)
CHECK_KEYB16            equ    0AD80h       ; (YST)
set_global_cp           equ    2
get_global_cp           equ    1


        ORG     0
ZERO    =       $

        ORG     100H                            ; Allow for 100H parameter area

SETDRV:
        MOV     AH,SET_DEFAULT_DRIVE
        INT     21h
;
; TCOMMAND is the recycle point in COMMAND.  Nothing is known here.
; No registers (CS:IP) no flags, nothing.
;

TCOMMAND:
        MOV     DS,[RESSEG]
ASSUME  DS:RESGROUP
        MOV     AX,-1
        XCHG    AX,[VERVAL]
        CMP     AX,-1
        JZ      NOSETVER2
        MOV     AH,SET_VERIFY_ON_WRITE          ; AL has correct value
        INT     21h

NOSETVER2:
        CALL    [HEADCALL]                      ; Make sure header fixed
        XOR     BP,BP                           ; Flag transient not read
        CMP     [SINGLECOM],-1
        JNZ     COMMAND

$EXITPREP:
        PUSH    CS
        POP     DS
        JMP     $EXIT                           ; Have finished the single command
ASSUME  DS:NOTHING
;
; Main entry point from resident portion.
;
;   If BP <> 0, then we have just loaded transient portion otherwise we are
;   just beginning the processing of another command.
;

COMMAND:

;
; We are not always sure of the state of the world at this time.  We presume
; worst case and initialize the relevant registers: segments and stack.
;
        ASSUME  CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
        CLD
        MOV     AX,CS
        FCLI
        MOV     SS,AX
ASSUME  SS:TRANGROUP
        MOV     SP,OFFSET TRANGROUP:STACK
        FSTI
        MOV     ES,AX
        MOV     DS,AX                           ;AN000; set DS to transient
ASSUME  ES:TRANGROUP,DS:TRANGROUP               ;AC000;
        invoke  TSYSLOADMSG                     ;AN000; preload messages
        mov     append_exec,0                   ;AN041; set internal append state off

        MOV     DS,[RESSEG]
ASSUME  DS:RESGROUP

        MOV     [UCOMBUF],COMBUFLEN             ; Init UCOMBUF
        MOV     [COMBUF],COMBUFLEN              ; Init COMBUF (Autoexec doing DATE)

        mov     [EXECPATH_SIZE], 0              ; ntvdm execpath extended

;
; If we have just loaded the transient, then we do NOT need to initialize the
; command buffer.  ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????  I
; guess not:  the only circumstances in which we reload the command processor
; is after a transient program execution.  In this case, we let the current
; directory lie where it may.
;
        OR      BP,BP                           ; See if just read
        JZ      TESTRDIR                        ; Not read, check user directory
        MOV     WORD PTR [UCOMBUF+1],0D01H      ; Reset buffer
        JMP     SHORT NOSETBUF

TESTRDIR:
        CMP     [RESTDIR],0
        JZ      NOSETBUF                        ; User directory OK
        PUSH    DS
;
; We have an unusual situation to handle.  The user *may* have changed his
; directory as a result of an internal command that got aborted.  Restoring it
; twice may not help us:  the problem may never go away.  We just attempt it
; once and give up.
;
        MOV     [RESTDIR],0                     ; Flag users dirs OK
        PUSH    CS
        POP     DS
ASSUME  DS:TRANGROUP
        MOV     DX,OFFSET TRANGROUP:USERDIR1
        MOV     AH,CHDIR
        INT     21h                     ; Restore users directory
        POP     DS
ASSUME  DS:RESGROUP

NOSETBUF:
        CMP     [PIPEFILES],0
        JZ      NOPCLOSE                        ; Don't bother if they don't exist
        CMP     [PIPEFLAG],0
        JNZ     NOPCLOSE                        ; Don't del if still piping
        INVOKE  PIPEDEL

NOPCLOSE:
        MOV     [EXTCOM],0                      ; Flag internal command
        MOV     AX,CS                           ; Get segment we're in
        MOV     DS,AX
ASSUME  DS:TRANGROUP

        PUSH    AX
        MOV     DX,OFFSET TRANGROUP:INTERNATVARS
        MOV     AX,INTERNATIONAL SHL 8
        INT     21H
        POP     AX
        SUB     AX,[TPA]                        ; AX=size of TPA in paragraphs
        PUSH    BX
        MOV     BX,16
        MUL     BX                              ; DX:AX=size of TPA in bytes
        POP     BX
        OR      DX,DX                           ; See if over 64K
        JZ      SAVSIZ                          ; OK if not
        MOV     AX,-1                           ; If so, limit to 65535 bytes

SAVSIZ:
;
; AX is the number of bytes free in the buffer between the resident and the
; transient with a maximum of 64K-1.  We round this down to a multiple of 512.
;
        CMP     AX,512
        JBE     GotSize
        AND     AX,0FE00h                       ; NOT 511 = NOT 1FF

GotSize:
        MOV     [BYTCNT],AX                     ; Max no. of bytes that can be buffered
        MOV     DS,[RESSEG]                     ; All batch work must use resident seg.
ASSUME  DS:RESGROUP

        TEST    [ECHOFLAG],1
        JZ      GETCOM                          ; Don't do the CRLF
        INVOKE  SINGLETEST
        JB      GETCOM
        TEST    [PIPEFLAG],-1
        JNZ     GETCOM
        TEST    [FORFLAG],-1                    ; G  Don't print prompt in FOR
        JNZ     GETCOM                          ; G
        TEST    [BATCH], -1                     ; G  Don't print prompt if in batch
        JNZ     GETCOM                          ; G
;       INVOKE  CRLF2

GETCOM:
        MOV     CALL_FLAG,0                     ; G Reset call flags
        MOV     CALL_BATCH_FLAG,0               ; G
        MOV     AH,GET_DEFAULT_DRIVE
        INT     21h
        MOV     [CURDRV],AL
        TEST    [PIPEFLAG],-1                   ; Pipe has highest presedence
        JZ      NOPIPE
        JMP     PIPEPROC                        ; Continue the pipeline

NOPIPE:
        TEST    [ECHOFLAG],1
        JZ      NOPDRV                          ; No prompt if echo off
        INVOKE  SINGLETEST
        JB      NOPDRV
        TEST    [FORFLAG],-1                    ; G  Don't print prompt in FOR
        JNZ     NOPDRV                          ; G
        TEST    [BATCH], -1                     ; G  Don't print prompt if in batch
        JNZ     TESTFORBAT                      ; G
;       INVOKE  PRINT_PROMPT                    ; Prompt the user

NOPDRV:
        TEST    [FORFLAG],-1                    ; FOR has next highest precedence
        JZ      TESTFORbat
        JMP     FORPROC                         ; Continue the FOR

TESTFORBAT:
        MOV     [RE_INSTR],0                    ; Turn redirection back off
        MOV     [RE_OUTSTR],0
        MOV     [RE_OUT_APP],0
        MOV     IFFlag,0                        ; no more ifs...
        TEST    [BATCH],-1                      ; Batch has lowest precedence
        JZ      ISNOBAT

;       Bugbug:         MULT_SHELL_GET no longer used?
        push    es                              ;AN000; save ES
        push    ds                              ;AN000; save DS
        mov     ax,mult_shell_get               ;AN000; check to see if SHELL has command
        mov     es,[batch]                      ;AN000; get batch segment
        mov     di,batfile                      ;AN000; get batch file name
        push    cs                              ;AN000; get local segment to DS
        pop     ds                              ;AN000;
        mov     dx,offset trangroup:combuf      ;AN000; pass communications buffer
        int     2fh                             ;AN000; call the shell
        cmp     al,shell_action                 ;AN000; does shell have a commmand?
        pop     ds                              ;AN000; restore DS
        pop     es                              ;AN000; restore ES
        jz      jdocom1                         ;AN000; yes - go process command

        PUSH    DS                              ;G
        INVOKE  READBAT                         ; Continue BATCH
        POP     DS                              ;G
        mov     nullflag,0                      ;G reset no command flag
        TEST    [BATCH],-1                      ;G
        JNZ     JDOCOM1                         ;G if batch still in progress continue
        MOV     BX,NEXT_BATCH                   ;G
        CMP     BX,0                            ;G see if there is a new batch file
        JZ      JDOCOM1                         ;G no - go do command
        MOV     BATCH,BX                        ;G get segment of next batch file
        MOV     NEXT_BATCH,0                    ;G reset next batch
JDOCOM1:
        PUSH    CS                              ;G
        POP     DS                              ;G
        JMP     DoCom1                          ; echoing already done

ISNOBAT:
        CMP     [SINGLECOM],0
        JZ      REGCOM
        MOV     SI,-1
        CMP     KSWITCHFLAG,0
        JE      NO_K_SWITCH
        INC     SI
        MOV     KSWITCHFLAG,0
NO_K_SWITCH:
        XCHG    SI,[SINGLECOM]
        MOV     DI,OFFSET TRANGROUP:COMBUF + 2
        XOR     CX,CX

SINGLELOOP:
        LODSB
        STOSB
        INC     CX
        CMP     AL,0DH
        JNZ     SINGLELOOP
        DEC     CX
        PUSH    CS
        POP     DS
ASSUME  DS:TRANGROUP
        MOV     [COMBUF + 1],CL
;
; do NOT issue a trailing CRLF...
;
        JMP     DOCOM1

;
; We have a normal command.
; Printers are a bizarre quantity.  Sometimes they are a stream and
; sometimes they aren't.  At this point, we automatically close all spool
; files and turn on truncation mode.
;

REGCOM:
        MOV     AX,(ServerCall SHL 8) + 9
        INT     21h
        MOV     AX,(ServerCall SHL 8) + 8
        MOV     DL,1
        INT     21h

        MOV     DS,cs:[RESSEG]
        ASSUME  DS:RESGROUP
        cmp     byte ptr [SCS_FIRSTCOM],0
        jnz     first_inst                      ;this is the first instance

        jmp     DoReEnter
DRE_RET:
        MOV     DS,cs:[RESSEG]
        ASSUME  DS:RESGROUP
        xor     ax,ax
    jmp short do_again

first_inst:
    mov [SCS_PAUSE],0           ; yst 4-5-93
        cmp     [SCS_Is_First],1
        jne     cont_scs
        mov     [SCS_Is_First],0

        SAVE    <SI,BP>
        xor     si,si
        xor     bp,bp
        mov     al,2
        mov     ah,setdpb
        int     21h                             ; resets the TSR bit
        RESTORE <BP,SI>
        xor     ax,ax
        jmp     short do_again

cont_scs:
        SAVE    <AX,SI,BP>
        xor     si,si
        xor     bp,bp
        mov     al,2
        mov     ah,setdpb
        int     21h                             ; resets the TSR bit
        RESTORE <BP,SI,AX>
        jnc     cont_scs2

cont_tsr:
        jmp     tsr_loop
tsr_loop_ret:
        jmp     short cont_scs1

cont_scs2:
        cmp     byte ptr [scs_firsttsr],1
        je      cont_scs1
        jmp     short cont_tsr

cont_scs1:
;       call    free_con

        MOV     DS,cs:[RESSEG]
        ASSUME  DS:RESGROUP
    mov ax,[retcode]

do_again:
ifdef NEC_98
        jmp     ClrFky
FKY_OFF DB      1Bh,'[>1h$'                     ;ESC sequence of FKY off
Clrfky: push    ds
        push    cs
        pop     ds
        push    cx
        push    ax
        push    dx
        mov     cl,10H
        mov     ah,01H
        mov     dx,offset FKY_OFF
        int     0DCH                            ;FKY off
        pop     dx
        pop     ax
        pop     cx
        pop     ds
endif   ;NEC_98
        MOV     DS,cs:[RESSEG]
    ASSUME  DS:RESGROUP
    push    es
    mov es,[envirseg]
    mov [ENV_PTR_SEG],es
    call    GETENVSIZ
    pop es
    push    cs
    pop ds
    ASSUME  DS:TRANGROUP
    mov [ENV_SIZE],cx

;; williamh - Jan 11 1993
;; nt expects 16bits exit code while DOS has only 8 bits
;; clear the high byte so that things won't go wrong
    xor ah, ah

        MOV     [SCS_EXIT_CODE],ax
        mov     ah,19h
        int     21h
        xor     ah,ah
        mov     [SCS_CUR_DRIVE], ax     ; a= 0 , b = 1 etc
    mov [CMD_SIZE],COMBUFLEN
    MOV DX,OFFSET TRANGROUP:UCOMBUF

if 0
;       Try to read interactive command line via DOSKey.
;       If that fails, use DOS Buffered Keyboard Input.

        mov     ax,4810h                ; AX = DOSKey Read Line function
        int     2fh
        or      ax,ax
        jz      GotCom                  ; DOSKey gave us a command line
else
        mov     [CMD_PTR_SEG],ds
        mov     [CMD_PTR_OFF],dx

        mov     dx,OFFSET TRANGROUP:EXECPATH
        mov     [EXECPATH_SEG], ds
        mov     [EXECPATH_OFF], dx
        mov     [EXECPATH_SIZE], EXECPATHLEN

        push    es
        mov     es,cs:[RESSEG]
        ASSUME  es:RESGROUP
        mov     dx,word ptr es:[RES_RDRINFO]
        mov     word ptr ds:[SCS_RDRINFO],dx
        mov     dx,word ptr es:[RES_RDRINFO+2]
        mov     word ptr ds:[SCS_RDRINFO+2],dx
        pop     es
        ASSUME  ES:TRANGROUP
        MOV     DX,OFFSET TRANGROUP:ENV_PTR_SEG


        CMDSVC  SVC_CMDGETNEXTCMD               ; DS:DX is the buffer
        jnc     run_cmd

; If carry is set that means our enviornment buffer was smaller. So get
; a big enough buffer and get the command again.
        cmp     ax,32*1024      ; Env size cannot be more than 32k.
        jae     op_fail
        push    ax              ; the new size in bytes for env in bytes
        invoke  FREE_TPA
        pop     bx
        MOV     CL,4
        SHR     BX,CL           ; Convert back to paragraphs
        inc     bx              ; an extra para
        push    es
        push    ds
        MOV     DS,cs:[RESSEG]
        ASSUME  DS:RESGROUP
        mov     es,[envirseg]
        pop     ds
        ASSUME  DS:TRANGROUP
        MOV     CX,ES           ;AN056; Get environment segment
        ADD     CX,BX           ;AN056; Add in size of environment
        ADD     CX,020H         ;AN056; Add in some TPA
        MOV     AX,CS           ;AN056; Get the transient segment
        CMP     CX,AX           ;AN056; Are we hitting the transient?
        JNB     blk_xxx         ;AN056; Yes - don't do it!!!

        push    bx
        MOV     AH,SETBLOCK
        INT     21h
        pop     bx
        jnc     blk_xxx

        mov     ah,ALLOC
        int     21h
        jc      blk_xxx
        push    ax

        mov     ah,DEALLOC
        int     21h

        pop     ax
        push    ds
        MOV     DS,cs:[RESSEG]
        ASSUME  DS:RESGROUP
        mov     [envirseg],ax
        pop     ds
        ASSUME  DS:TRANGROUP
        clc
blk_xxx:
        lahf
        push    ax
        MOV     ES,cs:[RESSEG]
        invoke  ALLOC_TPA
        pop     ax
        sahf
        JC      op_fail1
        pop     es
        xor     ax,ax           ; error code zero, its important
        jmp     do_again
op_fail1:
        pop     es
op_fail:
        mov     ax,error_not_enough_memory
        jmp     do_again

run_cmd:
        push    es
        mov     es,cs:[RESSEG]
        ASSUME  es:RESGROUP
        mov     ax,word ptr ds:[SCS_RDRINFO]
        mov     word ptr es:[RES_RDRINFO],ax
        mov     ax,word ptr ds:[SCS_RDRINFO+2]
        mov     word ptr es:[RES_RDRINFO+2],ax
        mov     ax,word ptr ds:[SCS_BATSTATUS]
        mov     byte ptr es:[RES_BATSTATUS],al
        pop     es
        ASSUME  ES:TRANGROUP
        test    [SCS_STD_HANDLE],ALL_HANDLES
        jz      no_rdr
        test    [SCS_STD_HANDLE],MASK_STDIN
        jz      scs_std_out
        xor     cx,cx                           ; CX = HANDLE_STDIN
        call    alloc_con
        jnc     scs_std_out
rdr_err:
        call    free_con
        mov     ax,error_not_enough_memory
        jmp     do_again

scs_std_out:
        ; Make Sure Stdout is checked before stderr. Its very important.
        test    [SCS_STD_HANDLE],MASK_STDOUT
        jz      scs_std_err
        mov     cx,HANDLE_STDOUT
        call    alloc_con
        jc      rdr_err

scs_std_err:
        test    [SCS_STD_HANDLE],MASK_STDERR
        jz      no_rdr
        mov     cx,HANDLE_STDERR
        call    alloc_con
        jc      rdr_err

no_rdr:
ifdef NEC_98
        push    ds
        push    cx
        push    ax
        push    dx

        CMDSVC  SVC_GETCURSORPOS                ;gets bios cursor position
                                                ;now dx=offset on TEXT VRAM
        mov     ax,dx
        mov     cl,160
        div     cl
        mov     dh,al
        xor     dl,dl
        mov     cl,10h
        mov     ah,03h
        int     0DCH                            ;set cursor position for DOS

        jmp     DspFky
FKY_ON  DB      1Bh,'[>1l$'                     ;ESC sequence of FKY on
Dspfky: push    cs
        pop     ds
        mov     cl,10H
        mov     ah,01H
        mov     dx,offset FKY_ON
        int     0DCH                            ;FKY on

        pop     dx
        pop     ax
        pop     cx
        pop     ds
endif   ;NEC_98
        mov     ah,GetSetCdPg
        mov     al,1
        int     21h
        jc      cdpg_done
        cmp     bx,[SCS_CODEPAGE]
        jz      cdpg_done

        mov     ah,NLSFUNC                      ; see if NLSFUNC installed
        mov     al,0                            ;
        int     2fh                             ;
        cmp     al,NLSFUNC_installed            ;
        jnz     no_nlsf_msg                     ; NO NLSFUNC ; Print message
;       jz      got_nls                         ; Yes - continue
;       mov     dx,offset trangroup:NLSFUNC_ptr ; no - set up error message
;       jmp     short cp_error                  ; error exit

        mov     bx,[SCS_CODEPAGE]               ;SCS Code page
        mov     ah,getsetcdpg                   ;set global code page function
        mov     al,set_global_cp                ;minor - set
        int     21h
        jnc     cdpg_done                       ;no error - exit
nlsf_failed:
; BUGBUG Sudeepb 28-Apr-1992 Putup a message saying NLSFunc failed
no_nlsf_msg:
; BUGBUG Sudeepb 28-Apr-1992 Putup a message saying NLSFunc not installed

cdpg_done:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                ;;
;; (YST) 08-Jan-1993 Checking and installing  16-bit KEYB.COM ;;
;;                                ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

       jmp     YST_beg

;; Data for KB16

KEY_LINE db 128 dup (0)    ; "d:\nt\system32\kb16.com", 0
YST_ARG  db 128 dup (0)    ; 32, " XX,,d:\nt\system32\keyboard.sys", 0DH


YPAR     dw     0
         dd     0
         dw     005ch, 0
         dw     006ch, 0

KEEP_SS  dw     0
KEEP_SP  dw     0

YST_beg:

      SAVE <BX, ES, DS>                ; save all regs for INT 2FH

      mov     ax, CHECK_KEYB16             ; see if KEYB16 installed
      int     2fh
      xor     dx,dx
      cmp     al, KEYB16_installed
      jne     keyb_cont                ; KEYB16 not installed, DX == 0
      inc     dx                   ; installed DX == 1

keyb_cont:
      RESTORE <DS, ES, BX>

      push    ds
      push    cs
      pop     ds

      mov     si, offset KEY_LINE          ; name of KB16.COM
      mov     cx, offset YST_ARG           ; command line

      CMDSVC    SVC_GETKBDLAYOUT    ; Call 32-bit API for checking
                    ; and installing correct layout
      or      dx,dx         ; if DX != 0 after BOP then we need
      pop     ds            ; to install 16-bit KEYB.COM
      jnz     run_keyb

      jmp     End_keyb          ; No installation of KB16.COM

run_keyb:

;; This part run KB16.COM

      SAVE    <DS, BX>

      PUSH    ES            ; free TPA for running KB16
      MOV     ES,[TRAN_TPA]
      MOV     AH,DEALLOC
      INT     21h           ; Now running in "free" space

      push    cs
      pop     ds
      push    cs
      pop     es

      mov     dx, offset KEY_LINE   ; file name
      mov     YPAR+0, 0000H     ; keep current enviroment
      mov     YPAR+2, offset YST_ARG    ; arguments (options) for KB16.COM
      mov     YPAR+4, ds
      mov     bx, offset YPAR

      mov     KEEP_SS, ss       ; Peter Norton suggests to keep
      mov     KEEP_SP, sp       ; SS and SP

      mov     ah, 4bh
      xor     al, al

      int     21h           ; RUN!

      mov     ss, cs:KEEP_SS        ; Restore SS and SP
      mov     sp, cs:KEEP_SP

      POP     ES

      SAVE  <BP>            ; We need to restore TSR bit
      xor   si,si           ; for running next app.
      xor   bp,bp           ; use "undocumented" call.
      mov   al,2
      mov   ah,setdpb
      int   21h         ; resets the TSR bit
      RESTORE   <BP>


; Allocate transient again after runnig KB16.
; Copied from TBATCH.ASM
; Modify AX,BX,DX,flags
;

        ASSUME DS:TRANGROUP,ES:RESGROUP

        PUSH    ES
        MOV     ES,cs:[RESSEG]
        MOV     BX,0FFFFH                       ; Re-allocate the transient
        MOV     AH,ALLOC
        INT     21h
        PUSH    BX                              ; Save size of block
        MOV     AH,ALLOC
        INT     21h
;
; Attempt to align TPA on 64K boundary
;
        POP     BX                              ; Restore size of block
        MOV     [RES_TPA], AX                   ; Save segment to beginning of block
        MOV     [TRAN_TPA], AX
;
; Is the segment already aligned on a 64K boundary
;
        MOV     DX, AX                          ; Save segment
        AND     AX, 0FFFH                       ; Test if above boundary
        JNZ     Calc_TPA
        MOV     AX, DX
        AND     AX, 0F000H                      ; Test if multiple of 64K
        JNZ     NOROUND

Calc_TPA:
        MOV     AX, DX
        AND     AX, 0F000H
        ADD     AX, 01000H                      ; Round up to next 64K boundary
        JC      NOROUND                         ; Memory wrap if carry set
;
; Make sure that new boundary is within allocated range
;
        MOV     DX, [RES_TPA]
        ADD     DX, BX                          ; Compute maximum address
        CMP     DX, AX                          ; Is 64K address out of range?
        JB      NOROUND
;
; Make sure that we won't overwrite the transient
;
        MOV     BX, CS                          ; CS is beginning of transient
        CMP     BX, AX
        JB      NOROUND
;
; The area from the 64K boundary to the beginning of the transient must
; be at least 64K.
;
        SUB     BX, AX
        CMP     BX, 4096                        ; Size greater than 64K?
        JAE     ROUNDDONE

NOROUND:
        MOV     AX, [RES_TPA]

ROUNDDONE:
        MOV     [LTPA],AX                       ; Re-compute everything
        MOV     [TPA],AX
        MOV     BX,AX
        MOV     AX,CS
        SUB     AX,BX
        PUSH    BX
        MOV     BX,16
        MUL     BX
        POP     BX
        OR      DX,DX
        JZ      SAVSIZ2
        MOV     AX,-1

SAVSIZ2:
;
; AX is the number of bytes free in the buffer between the resident and the
; transient with a maximum of 64K-1.  We round this down to a multiple of 512.
;
        CMP     AX,512
        JBE     GotSize1
        AND     AX,0FE00h                       ; NOT 511 = NOT 1FF

GotSize1:
        MOV     [BYTCNT],AX
        POP     ES


; End  Alloc_TPA


        RESTORE <BX, DS>

        CMDSVC  SVC_CMDINITCONSOLE   ; make sure console is turned on

End_keyb:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                  ;;
;; End of (YST) 08-Jan-1993 Checking and installing 16-bit KEYB.COM ;;
;;                                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



        mov     dx,[SCS_CUR_DRIVE]
        mov     [curdrv],dl
        mov     ah,0eh
        int     21h
        push    cs
        pop     ds
        MOV     DX,OFFSET TRANGROUP:UCOMBUF

endif

GotCom:
        MOV     CL,[UCOMBUF]
        XOR     CH,CH
        ADD     CX,3
        MOV     SI,OFFSET TRANGROUP:UCOMBUF
        MOV     DI,OFFSET TRANGROUP:COMBUF
        REP     MOVSB                           ; Transfer it to the cooked buffer

;---------------

transpace   segment
    extrn   arg:byte                            ; the arg structure!
transpace   ends
;---------------


DOCOM:
;       INVOKE  CRLF2

DOCOM1:
        INVOKE  PRESCAN                         ; Cook the input buffer
        JZ      NOPIPEPROC
        JMP     PIPEPROCSTRT                    ; Fire up the pipe

nullcomj:
        jmp     nullcom

NOPIPEPROC:
        invoke  parseline
        jnc     OkParse                         ; user error?  or maybe we goofed?

BadParse:
        PUSH    CS
        POP     DS
        MOV     DX,OFFSET TRANGROUP:BADNAM_ptr
        INVOKE  std_eprintf
        JMP     TCOMMAND

OkParse:
        test    arg.argv[0].argflags, MASK wildcard
        jnz     BadParse                        ; ambiguous commands not allowed
        cmp     arg.argvcnt, 0                  ; there WAS a command, wasn't there?
        jz      nullcomj
        cmp     arg.argv[0].arglen, 0           ; probably an unnecessary check...
        jz      nullcomj                        ; guarantees argv[0] at least x<NULL>

        MOV     SI,OFFSET TRANGROUP:COMBUF+2
        MOV     DI,OFFSET TRANGROUP:IDLEN
        MOV     AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H ; Make FCB with blank scan-off
        INT     21h
        mov     BX, arg.argv[0].argpointer
        cmp     WORD PTR [BX], 05c5ch           ; leading "\\" means UNC name
        je      IsUncName
        cmp     BYTE PTR [BX+1],':'             ; was a drive specified?
        jne     short drvgd                     ; no, use default of zero...

        mov     DL, BYTE PTR [BX]               ; pick-up drive letter
        and     DL, NOT 20H                     ; uppercase it
        sub     DL, capital_A                   ; convert it to a drive number, A=0

        CMP     AL,-1                           ; See what PARSE said about our drive letter.
        JZ      drvbadj2                        ; It was invalid.

IsUncName:
        mov     DI, arg.argv[0].argstartel
        cmp     BYTE PTR [DI], 0                ; is there actually a command there?
        jnz     drvgd                           ; if not, we have:  "d:", "d:\", "d:/"
        jmp     setdrv                          ; and set drive to new drive spec

drvbadj2:
        jmp     drvbad

DRVGD:
        MOV     AL,[DI]
        MOV     [SPECDRV],AL
        MOV     AL,' '
        MOV     CX,9
        INC     DI
        REPNE   SCASB                           ; Count no. of letters in command name
        MOV     AL,8
        SUB     AL,CL
        MOV     [IDLEN],AL                      ; IDLEN is truly the length
        MOV     DI,81H
        PUSH    SI

        mov     si, OFFSET TRANGROUP:COMBUF+2   ; Skip over all leading delims
        invoke  scanoff
;SR;
; We are going to skip over the first char always. The logic is that the
;command tail can never start from the first character. The code below is
;trying to figure out the command tail and copy it to the command line
;buffer in the PSP. However, if the first character happens to be a switch
;character and the user given command line is a full 128 bytes, we try to
;copy 128 bytes to the PSP while it can take only 127 chars. This extra
;char overwrites the code and leads to a crash on future commands.
;

        inc     si

do_skipcom:
        lodsb                                   ; move command line pointer over
        invoke  delim                           ; pathname -- have to do it ourselves
        jz      do_skipped                      ; 'cause parse_file_descriptor is dumb
        cmp     AL, 0DH                         ; can't always depend on argv[0].arglen
        jz      do_skipped                      ; to be the same length as the user-
        cmp     AL, [SWITCHAR]                  ; specified command string
        jnz     do_skipcom

do_skipped:
        dec     SI
; jarbats 11-20-2000
; failing to decrease SI results in missing leading space for command tail
; which upsets many old dos apps which assume there is a space at the beginning and start at the second char
;do_skipped1:
        XOR     CX,CX

COMTAIL:
        LODSB
        STOSB                                   ; Move command tail to 80H
        CMP     AL,13
        LOOPNZ  COMTAIL
        DEC     DI
        MOV     BP,DI
        NOT     CL
        MOV     BYTE PTR DS:[80H],CL
        POP     SI

;-----
; Some of these comments are sadly at odds with this brave new code.
;-----
; If the command has 0 parameters must check here for
; any switches that might be present.
; SI -> first character after the command.

        mov     DI, arg.argv[0].argsw_word
        mov     [COMSW], DI                     ; ah yes, the old addressing mode problem...
        mov     SI, arg.argv[1 * SIZE argv_ele].argpointer  ; s = argv[1];
        OR      SI,SI                           ;   if (s == NULL)
        JNZ     DoParse
        MOV     SI,BP                           ;       s = bp; (buffer end)

DoParse:
        MOV     DI,FCB
        MOV     AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
        INT     21h
        MOV     [PARM1],AL                      ; Save result of parse

        mov     DI, arg.argv[1*SIZE argv_ele].argsw_word
        mov     [ARG1S], DI
        mov     SI, arg.argv[2*SIZE argv_ele].argpointer    ; s = argv[2];
        OR      SI,SI                           ;   if (s == NULL)
        JNZ     DoParse2
        MOV     SI,BP                           ;       s = bp; (bufend)1

DoParse2:
        MOV     DI,FCB+10H
        MOV     AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
        INT     21h                     ; Parse file name
        MOV     [PARM2],AL                      ; Save result

        mov     DI, arg.argv[2*SIZE argv_ele].argsw_word
        mov     [ARG2S], DI
        mov     DI, arg.argv[0].argsw_word
        not     DI                              ; ARGTS doesn't include the flags
        and     DI, arg.argswinfo               ; from COMSW...
        mov     [ARGTS], DI

        MOV     AL,[IDLEN]
        MOV     DL,[SPECDRV]
        or      DL, DL                          ; if a drive was specified...
        jnz     externalj1                      ; it MUST be external, by this time
        dec     al                              ; (I don't know why -- old code did it)
        jmp     fndcom                          ; otherwise, check internal com table

externalj1:
        jmp     external

nullcom:
        mov     [EXECPATH_SIZE], 0
        MOV     DS,cs:[RESSEG]
ASSUME  DS:RESGROUP
        TEST    [BATCH], -1                     ;G Are we in a batch file?
        JZ      nosetflag                       ;G only set flag if in batch
        mov     nullflag,nullcommand            ;G set flag to indicate no command

nosetflag:
        CMP     [SINGLECOM],-1
        JZ      EXITJ
        JMP     GETCOM

EXITJ:
        JMP     $EXITPREP

IF IBM
        include vector.inc
        include pdb.inc
        include arena.inc
        include mshalo.asm
ENDIF

std_invalid macro
        mov     ax,0ffffh
        push    ax
        push    ax
endm

std_valid macro
        push    bx
        push    cx
endm

CleanForStd macro
        add     sp,12
endm

DoReEnter:
        ASSUME  DS:RESGROUP

        cmp     byte ptr [scs_reentered],3
        jne     reent_chk

; Control comes here after command /z ran a non-dos binary and
; we re-entered. We just make scs_reentered as 2 indicating that on next
; time we need to return the exit code to 32bit side.

        mov     byte ptr [scs_reentered],2
        jmp     reent

reent_chk:
        cmp     byte ptr [scs_reentered],2
        jne     reent_cont
        jmp     retcode32

reent_cont:
        cmp     byte ptr [scs_reentered],0
        je      exec_comspec
        jmp     reent_ret

; Control comes here when we have to exec either command.com or
; cmd.exe. This decision depends on scs_cmdprompt. Here we
; mark scs_reentered state as 1 indicating on return to handle
; exit code.

exec_comspec:

        mov     byte ptr [scs_reentered],1
        cmp     byte ptr [scs_cmdprompt],Prompt32
        je      do32bitprompt
        mov     al,Start16      ; parameter to put prompt
        mov     ah,FOR_SHELLOUT
        call    Do16BitPrompt       ; ds is resseg here on return its transseg
        or      al,al               ; return al=0 to run 16bit binary al=1 getnextvdmcommand
        jz      dos_only
        jmp     reent
dos_only:
        jmp     GotCom              ; go run through int21/exec

do32BitPrompt:
        SAVE    <bp,bx,si>
        xor     bx,bx
        mov     si,bx
        mov     bp,bx
        mov     ax,5303h
        int     21h
        jnc     st_stdin
        std_invalid
        jmp     short go_stdout
st_stdin:
        std_valid
go_stdout:
        mov     bx,1
        mov     ax,5303h
        int     21h
        jnc     st_stdout
        std_invalid
        jmp     short go_stderr
st_stdout:
        std_valid
go_stderr:
        mov     bx,2
        mov     ax,5303h
        int     21h
        jnc     st_stderr
        std_invalid
        jmp     short std_done
st_stderr:
        std_valid
std_done:
        mov     bp,sp
        push    es
        mov     es,[envirseg]
        mov     ah,19h
        int     21h
        CMDSVC  SVC_EXECCOMSPEC32
        pop     es
        mov     bp,ax
        lahf
        CleanForStd
        sahf
        mov     ax,bp
        RESTORE <si,bx,bp>

        jc      reent

        jmp     reent_exit

reent_ret:
        ; ds is already set to RESSEG
        cmp     byte ptr [scs_cmdprompt],Prompt32
        je      retcode32
        mov     al,return16
        mov     ah,FOR_SHELLOUT
        call    Do16BitPrompt       ; ds = resseg , on return its transseg
        or      al,al               ; return al=0 to run 16bit binary al=1 getnextvdmcommand
        jnz     reent
        jmp     dos_only

retcode32:
        mov     dx,ds:[retcode]
        mov     ah,19h
        int     21h                             ; al = cur drive
        mov     cx,word ptr ds:[RES_RDRINFO]
        mov     bx,word ptr ds:[RES_RDRINFO+2]  ; bx:cx - rdrinfo
        CMDSVC  SVC_RETURNEXITCODE
        mov     ds:[retcode],0
        jnc     reent_exit
reent:
        push    cs
        pop     ds
        assume  ds:trangroup
        mov     [scs_tsrexit],0
        jmp     DRE_RET

reent_exit:
ASSUME  DS:RESGROUP
        push    ax
        mov     ax,(multdos shl 8 or message_2f);AN060; reset parse message pointers
        mov     dl,set_critical_msg             ;AN000; set up critical error message address
        mov     di,crit_msg_off                 ;AN000; old offset of critical messages
        mov     es,crit_msg_seg                 ;AN000; old segment of critical messages
        int     2fh                             ;AN000; go set it

        push    cs
        pop     ds
assume  ds:trangroup                            ;AN000;

; Restore user directory if the restore flag is set. RestUDir1 checks for
; this, restores user dir if flag is set and resets the flag.

        invoke  RestUDir1               ;restore user dir if needed ;M040
        MOV     ES,cs:[RESSEG]

assume  es:resgroup

        MOV     AX,[PARENT]
        MOV     WORD PTR ES:[PDB_Parent_PID],AX
        MOV     AX,WORD PTR OldTerm
        MOV     WORD PTR ES:[PDB_Exit],AX
        MOV     AX,WORD PTR OldTerm+2
        MOV     WORD PTR ES:[PDB_Exit+2],AX

        PUSH    ES
        MOV     ES,[TRAN_TPA]
        MOV     AH,DEALLOC
        INT     21h                     ; Now running in "free" space
        POP     ES

        pop     ax
        MOV     AH,Exit
        INT     21h

; Entry al = Start16 means  put the command.com prompt, get the command
;            return16 means return the exit code if needed
;       ah = FOR_SHELLOUT means came from shellout code (DoReEnter)
;       ah = FOR_TSR      means came from TSR (tsr_loop)
;
; Exit  al = 0 means run 16bit binary
;       al = 1 means do getnextvdmcommand
;       if came with FOR_TSR, then additionaly
;       ah = 1 means returning on exit command
;       ah = 0 means otherwise

Do16BitPrompt:
        push    es
        push    ax
        mov     es,cs:[RESSEG]                  ; es is resident group
        ASSUME  ES:resgroup
    PUSH    CS
        POP     DS                              ; Need local segment to point to buffer
        assume  ds:trangroup
        cmp     al,Start16
ifdef DBCS
        je      @F
        jmp     d16_ret
@@:
else ; !DBCS
        jne     d16_ret
endif ; !DBCS

d16_loop:
ifdef DBCS
;;; williamh  Sept 24 1993, removed it. Not necessary to show two line feed
;;; for every command.
;;; yasuho 12/9/93  It is necessary. for example, if previous command
;;; didn't follow CR+LF before terminate, prompt will show on the strange
;;; position.
endif ; DBCS
        INVOKE  CRLF2
        INVOKE  PRINT_PROMPT                    ; put the prompt
ifdef DBCS  ;; this should go to US build also
;; reset the title
    xor al, al
    CMDSVC  SVC_SETWINTITLE
endif ; DBCS
    MOV DX,OFFSET TRANGROUP:UCOMBUF

        mov     ah,STD_CON_STRING_INPUT         ; AH = Buffered Keyboard Input
        int     21h                             ; call DOS
ifdef DBCS_NT31J
;; special case for CR was added the original source.
;; this code doesn't need. 04/07/94 (hiroh)
    ;; #3920: CR+LFs are needed when using 32bit command
    ;; 12/9/93 yasuho
    ;; not necessary CR+LF if nothing to do
    push    bx
    mov bx, dx
    cmp byte ptr [bx + 1], 0        ; only CR ?
    pop bx
    je  @F              ; yes. no neccessary CRLF
        INVOKE  CRLF2
@@:
endif ; DBCS_NT31J

        push    si
        mov     si,dx
        inc     si
        inc     si
        INVOKE  SCANOFF                         ; eat leading delimeters

        cmp     byte ptr ds:[si],0dh            ; special case CR
        jne     d16_gotcom
        pop     si
        jmp     d16_loop

d16_gotcom:
ifdef DBCS  ;; this should go to US build also
;; update the new command to the title
    mov al, 1
    CMDSVC  SVC_SETWINTITLE
endif ; DBCS
        INVOKE  CRLF2
        call    check_command                   ; check for exit and cd
        pop     si
        jnc     d16_run

        or      al,al
ifdef DBCS
        jnz @F
    jmp d16_exit
@@:
else ; !DBCS
        jz      d16_exit
endif ; !DBCS

d16_dosonly:
        mov     byte ptr es:[scs_prompt16],0
        pop     ax
        xor     ax,ax           ; go run the command
        pop     es
        ret

d16_run:
        cmp     byte ptr es:[scs_dosonly], DOSONLY_YES
        je      d16_dosonly

        push    es
        push    bp
        push    si
        mov     ax,0ffffh
        push    ax              ; no standard handle to pass
        push    ax
        push    ax
        push    ax
        push    ax
        push    ax
        mov     bp,sp           ; ss:bp is standard handles
        mov     es,es:[envirseg]
        mov     si,dx
        add     si,2            ; first two bytes are the count, after that real command
        mov     ah,19h
        int     21h             ; al = cur drive
ifdef NEC_98
        jmp     Clrfky2
FKY_OFF2        DB      1Bh,'[>1h$'             ;ESC sequence of FKY off
Clrfky2:        push    ds
        push    cs
        pop     ds
        push    cx
        push    ax
        push    dx
        mov     cl,10H
        mov     ah,01H
        mov     dx,offset FKY_OFF2
        int     0DCH                            ;FKY off
        pop     dx
        pop     ax
        pop     cx
        pop     ds
endif   ;NEC_98
        mov     ah,1            ; do cmd /c
        CMDSVC  SVC_CMDEXEC     ; Exec through cmd
ifdef NEC_98
        pushf
        push    ds
        push    cx
        push    ax
        push    dx

        CMDSVC  SVC_GETCURSORPOS                ;gets bios cursor position
                                                ;now dx=offset on TEXT VRAM
        mov     ax,dx
        mov     cl,160
        div     cl
        mov     dh,al
        xor     dl,dl
        mov     cl,10h
        mov     ah,03h
        int     0DCH                            ;set cursor position for DOS

        jmp     Dspfky2
FKY_ON2 DB      1Bh,'[>1l$'                     ;ESC sequence of FKY on
Dspfky2:        push    cs
        pop     ds
        mov     cl,10H
        mov     ah,01H
        mov     dx,offset FKY_ON2
        int     0DCH                            ;FKY on

        pop     dx
        pop     ax
        pop     cx
        pop     ds
        popf
endif   ;NEC_98
        lahf
        add     sp,12           ; recover std handle space
        pop     si
        pop     bp
        pop     es
        sahf

ifndef NEC_98
        jnc    d16_loop         ; command completed, go put the prompt
else    ;NEC_98
        jc      @F
        jmp     d16_loop
@@:
endif   ;NEC_98

        ; carry set means re-entered
d16_retback:
        mov     byte ptr es:[scs_prompt16],1   ; mark that on return we have
                                            ; to go to 32bit with retcode
        pop     ax
        mov     ax,1                        ; go do getnextvdmcommand
        pop     es
        ret

d16_ret:
        cmp     byte ptr es:[scs_prompt16],0   ; mark 0 to mean to come back
                                            ; and put prompt fro next command
ifdef DBCS
        jne @F
        jmp     d16_loop
@@:
else ; !DBCS
        je      d16_loop
endif ; !DBCS


d16_return32:
        push    dx
        mov     dx,es:[retcode]
        mov     ah,19h
        int     21h                             ; al = cur drive
        mov     cx,word ptr es:[RES_RDRINFO]
        mov     bx,word ptr es:[RES_RDRINFO+2]  ; bx:cx - rdrinfo
        CMDSVC  SVC_RETURNEXITCODE
        pop     dx
        mov     es:[retcode],0
        jc      d16_retback
        mov     byte ptr es:[scs_prompt16],0
        jmp     d16_loop


d16_exit:
        ; exit command was given, turn off the lights

        pop     ax
        cmp     ah,FOR_TSR
        je      d16_exittsr
        jmp     reent_exit

d16_exittsr:
        mov     ah,1
        pop     es
        ret


; check if the typed command is one of the commands in NT_INTRL_CMND, if
; so return carry set plus al = 0 if the command was "exit".
;
; input ds:si is the command buffer
; si can be trashed.

check_command:

        SAVE    <CX,DI,ES>

        cmp     byte ptr ds:[si+1],':'      ; special case drive change i.e C:
        jne     cc_0
        mov     al,byte ptr ds:[si+2]
        cmp     al,0dh                      ; DELIM for some reason does'nt
        je      ok_delim                    ; include 0d
        invoke  DELIM
        jnz     no_match
ok_delim:
        mov     al,1                        ; Not exit command
ok_xt:
        stc                                 ; Carry means command found
        jmp     short cc_ret

no_match:
        clc                                 ; Carry clear, command not found
cc_ret:
        RESTORE <ES,DI,CX>
        ret

cc_0:
        push    si
        xor     cx,cx

        ; Convert the source string to upper case and get the length
cc_1:
        mov     al,byte ptr ds:[si]
        invoke  DELIM
        jz      go_look
        invoke  MOREDELIM
        jz      go_look

        INVOKE  UPCONV
        mov     byte ptr ds:[si],al
        inc     si
        inc     cx
        jmp     short cc_1

go_look:
        pop     si
        jcxz    no_match                            ; zero length, go fail
        mov     di, OFFSET TRANGROUP:NT_INTRNL_CMND
        push    cs
        pop     es

        ; search through the commands in the table
cc_5:
        push    si
        push    di
        push    cx
        cmp     cl, byte ptr es:[di]
        jne     try_next
        inc     di
        repz    cmpsb
        jnz     try_next
        jmp     short cc_found

try_next:
        pop     cx
        pop     di
        pop     si
        mov     al,byte ptr es:[di]
        or      al,al
        jz      no_match
        xor     ah,ah
        add     ax,di
        mov     di,ax
        add     di,2
        jmp     short cc_5

cc_found:
        mov     al, byte ptr es:[di]                ; Is it exit command
        pop     cx
        pop     di
        pop     si
        jmp     short ok_xt

;
; Input:    AL is character to classify
; Output:   Z set if delimiter
;       NZ set otherwise
; Registers modified: none
;

MOREDELIM:
        cmp     al,0dh
        retz
        cmp     al,'/'
        retz
        cmp     al,'\'
        retz
        cmp     al,'.'
        retz
        cmp     al,'<'
        retz
        cmp     al,'>'
        retz
        cmp     al,'|'
        retz
        cmp     al,'"'
        retz
        cmp     al,'+'
        retz
        cmp     al,':'
        retz
        cmp     al,';'
        retz
        cmp     al,'['
        retz
        cmp     al,']'
        return



free_con:
        push    ds
        MOV     DS,cs:[RESSEG]
        ASSUME  DS:RESGROUP
        xor     bx,bx                           ; BX = handle = 0
        mov     cx,Io_Save                      ; CX = original stdin, stdout
        mov     dx,word ptr ds:Pdb_Jfn_Table    ; DX = current stdin, stdout
        cmp     cl,dl
        je      Chk1                    ; stdin matches
        mov     ah,CLOSE
        int     21h                     ; close stdin
        mov     ds:Pdb_Jfn_Table,cl     ; restore stdin
Chk1:
        inc     bx                      ; BX = handle = 1
        cmp     ch,dh
        je      Chk2                    ; stdout matches
        mov     ah,CLOSE
        int     21h                     ; close stdout
        mov     ds:Pdb_Jfn_Table+1,ch   ; restore stdout
Chk2:
        inc     bx                      ; BX = handle = 2
        mov     dl,byte ptr ds:[Pdb_Jfn_Table+2]        ; Dl = current stderr
        mov     cl,Io_Stderr            ; Cl = original stderr
        cmp     dl,cl
        je      chk_x                   ; stderr matches
        mov     ah,CLOSE
        int     21h                     ; close stderr
        mov     ds:Pdb_Jfn_Table+2,cl   ; restore stderr
chk_x:
        pop     ds
        ret

alloc_con:
    SAVE    <DX,SI,BP,BX,DS>
        MOV     DS,cs:[RESSEG]
        ASSUME  DS:RESGROUP
        push    cx
        pop     ax
        mov     bx, offset Pdb_Jfn_Table
        add     bx,ax
        mov     al,byte ptr ds:[bx]
        push    ax
        push    bx
        mov     byte ptr ds:[bx],0ffh

        mov     bx,word ptr ds:[RES_RDRINFO]
        mov     ax,word ptr ds:[RES_RDRINFO+2]

        CMDSVC  SVC_GETSTDHANDLE                ; std hanlde in bx:cx
        jc      alloc_err
;; bx:cx  = nt file handle
;; dx:ax = file size
    push    di
    mov di, ax
        xor     si,si
        xor     bp,bp
        mov     al,0                            ; free original console
        mov     ah,setdpb
        int     21h
    pop di
        jc      alloc_err
        pop     bx
        pop     ax
    RESTORE     <DS,BX,BP,SI,DX>
        ret

alloc_err:
        pop     bx
        pop     ax
        mov     byte ptr ds:[bx],al
    RESTORE     <DS,BX,BP,SI,DX>
        ret


; ds for tsr_loop is resseg on entry on exit transseg

        ASSUME  DS:RESGROUP

tsr_loop:
        cmp     byte ptr ds:[scs_cmdprompt],Prompt32
        je      tsr_ret

        cmp     byte ptr ds:[res_batstatus],0
        je      short tsr_nobat
        cmp     byte ptr ds:[scs_firsttsr],1
        jne     short tsr_retcode
        jmp     tsr_ret

tsr_nobat:

        CMDSVC  SVC_GETSTARTINFO     ; return al = 1, if vdm has to
                                    ; terminate on app exit.
        or      al,al
        jne     tsr_ret

        cmp     byte ptr [scs_firsttsr],1
        jne     tsr_retcode

        cmp     word ptr ds:[RES_RDRINFO],0
        je      tsr_nordr
        cmp     word ptr ds:[RES_RDRINFO+2],0
        jne     tsr_ret
tsr_nordr:
        mov     byte ptr ds:[scs_firsttsr],0
        mov     al,Start16          ; parameter to put prompt
        mov     ah,FOR_TSR
        call    Do16BitPrompt       ; ds is resseg here on return its transseg
        or      ah,ah
        jnz     tsr_exit
        or      al,al               ; return al=0 to run 16bit binary al=1 getnextvdmcommand
        jz      tsr_dosonly
        jmp     tsr_ret
tsr_dosonly:
        jmp     GotCom              ; go run through int21/exec

tsr_retcode:
        mov     al,return16         ; parameter to retun exit code if needed
        mov     ah,FOR_TSR
        call    Do16BitPrompt       ; ds = resseg , on return its transseg
        or      ah,ah
        jnz     tsr_exit
        or      al,al               ; return al=0 to run 16bit binary al=1 getnextvdmcommand
        jnz     tsr_ret
        jmp     GotCom

tsr_exit:
        push    cs
        pop     ds
        assume  ds:trangroup
        mov     [scs_tsrexit],1
tsr_ret:
        jmp     tsr_loop_ret


TRANCODE        ENDS
        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tcmd1b.asm ===
page ,132
;	SCCSID = @(#)tcmd1b.asm 1.1 85/05/14
;	SCCSID = @(#)tcmd1b.asm 1.1 85/05/14
TITLE	PART4 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;	Internal commands DIR,PAUSE,ERASE,TYPE,VOL,VER

.xlist
.xcref
	include dossym.inc
	include bpb.inc
	include syscall.inc
	include filemode.inc
	include sf.inc
	include comseg.asm
	include comsw.asm		;ac000;
	include comequ.asm
	include ioctl.inc		;an000;
.list
.cref

DATARES SEGMENT PUBLIC BYTE             ;AN020;AC068;
        EXTRN   append_flag:byte        ;AN020;AC068;
	EXTRN	append_state:word	;AN020;AC068;
	EXTRN	SCS_PAUSE:BYTE		; yst 4-5-93
DATARES ENDS                            ;AN020;AC068;

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	badcpmes_ptr:word	;AC022;
	EXTRN	Extend_buf_ptr:word	;AC000;
	EXTRN	Extend_buf_sub:byte	;AN000;
	EXTRN	inornot_ptr:word
	EXTRN	msg_disp_class:byte	;AC000;
	EXTRN	parse_erase:byte	;AC000;
	EXTRN	parse_mrdir:byte	;AC000;
	EXTRN	parse_rename:byte	;AC000;
	EXTRN	parse_vol:byte		;AC000;
	EXTRN	PauseMes_ptr:word
	EXTRN	renerr_ptr:word
	EXTRN	slash_p_syn:word	;AC000;
	EXTRN	volmes_ptr:word 	;AC000;
	EXTRN	volmes_ptr_2:word	;AC000;
	EXTRN	volsermes_ptr:word	;AC000;
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	bytcnt:word
	EXTRN	charbuf:byte
	EXTRN	comsw:word
	EXTRN	curdrv:byte
	EXTRN	destinfo:byte
	EXTRN	destisdir:byte
	EXTRN	dirbuf:byte
	EXTRN	msg_numb:word		;AN022;
	EXTRN	one_char_val:byte
	EXTRN	parse1_addr:dword	;AN000;
	EXTRN	parse1_syn:word 	;AN000;
        EXTRN   resseg:word             ;AN020;AC068;
	EXTRN	srcbuf:byte		;AN000;
	EXTRN	string_ptr_2:word	;AN000;
	EXTRN	TPA:word
	EXTRN	vol_drv:byte
	EXTRN	vol_ioctl_buf:byte	;AC000;
	EXTRN	vol_label:byte		;AC000;
	EXTRN	vol_serial:dword	;AC000;
	EXTRN	zflag:byte

	extrn	TypeFilSiz:dword
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
transpace   ends
;---------------

	EXTRN	cerror:near
	EXTRN	error_output:near
	EXTRN	notest2:near
	EXTRN	slashp_erase:near	;AN000;
	EXTRN	std_printf:near
	EXTRN	tcommand:near

	PUBLIC	badpath_err		;AN022;
	PUBLIC	crename
	PUBLIC	DisAppend
	PUBLIC	erase
	PUBLIC	extend_setup		;AN022;
	PUBLIC	Get_ext_error_number	;AN022;
	PUBLIC	pause
	PUBLIC	Set_ext_error_msg	;AN000;
	PUBLIC	typefil
	PUBLIC	volume


	break	Pause
PAUSE:
	push	ds
	mov	ds, ResSeg
	assume	ds:resgroup
	cmp	SCS_PAUSE, 0
	pop	ds
	jne	pause_break

assume	ds:trangroup,es:trangroup
	mov	dx,offset trangroup:pausemes_ptr
	call	std_printf
	invoke	GetKeystroke
	invoke	crlf2
pause_break:
	return

	break	Erase

;****************************************************************
;*
;* ROUTINE:	DEL/ERASE - erase file(s)
;*
;* FUNCTION:	PARSE command line for file or path name and /P
;*		and invoke PATHCRUNCH.	If an error occurs, set
;*		up an error message and transfer control to CERROR.
;*		Otherwise, transfer control to NOTEST2 if /P not
;*		entered or SLASHP_ERASE if /P entered.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	if no error:
;*		FCB at 5ch set up with filename(s) entered
;*		Current directory set to entered directory
;*
;****************************************************************

assume	ds:trangroup,es:trangroup

ERASE:
	mov	si,81H				;AC000; get command line
	mov	comsw,0 			;AN000; clear switch indicator
	mov	di,offset trangroup:parse_erase ;AN000; Get adderss of PARSE_erase
	xor	cx,cx				;AN000; clear cx,dx

erase_scan:
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,end_of_line			;AN000; are we at end of line?
	jz	good_line			;AN000; yes - done parsing
	cmp	ax,result_no_error		;AC000; did we have an error?
	jnz	errj2				;AC000; yes exit

	cmp	parse1_syn,offset trangroup:slash_p_syn ;AN000; was /P entered?
	je	set_erase_prompt		;AN000; yes - go set prompt

;
; Must be filespec since no other matches occurred. move filename to srcbuf
;
	push	si				;AC000; save position in line
	lds	si,parse1_addr			;AC000; get address of filespec
	cmp	byte ptr[si+1],colon_char	;AC000; drive specified?
	jnz	Erase_drive_ok			;AC000; no - continue
	cmp	byte ptr[si+2],end_of_line_out	;AC000; was only drive entered?
	jnz	erase_drive_ok			;AC000; no - continue
	mov	ax,error_file_not_found 	;AN022; get message number in control block
	jmp	short extend_setup		;AC000; exit

erase_drive_ok:
	invoke	move_to_srcbuf			;AC000; move to srcbuf
	pop	si				;AC000; get position back
	jmp	short erase_scan		;AN000; continue parsing

set_erase_prompt:
	cmp	comsw,0 			;AN018; was /P already entered?
	jz	ok_to_set_erase_prompt		;AN018; no go set switch
	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
	invoke	setup_parse_error_msg		;AN018; set up an error message
	jmp	short errj2			;AN018; exit

ok_to_set_erase_prompt: 			;AN018;
	inc	comsw				;AN000; indicate /p specified
	jmp	short erase_scan		;AN000; continue parsing

good_line:					;G  We know line is good
	invoke	pathcrunch
	jnc	checkdr
	mov	ax,[msg_numb]			;AN022; get message number
	cmp	ax,0				;AN022; was message flag set?
	jnz	extend_setup			;AN022; yes - print out message
	cmp	[destisdir],0			; No CHDIRs worked
	jnz	badpath_err			;AC022; see if they should have

checkdr:
	cmp	comsw,0 			;AN000; was /p specified
	jz	notest2j			;AN000; no - go to notest2
	jmp	slashp_erase			;AN000; yes - go to slashp_erase

notest2j:
	jmp	notest2

badpath_err:					;AN022; "Path not found" message
	mov	ax,error_path_not_found 	;AN022; set up error number

extend_setup:					;AN022;
	mov	msg_disp_class,ext_msg_class	;AN022; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr ;AC022; get extended message pointer
	mov	Extend_Buf_ptr,ax		;AN022; get message number in control block
errj2:						;AC022; exit jump
	jmp	Cerror				;AN022;

	break	Rename

; ****************************************************************
; *
; * ROUTINE:	 CRENAME - rename file(s)
; *
; * FUNCTION:	 PARSE command line for one full filespec and one
; *		 filename.  Invoke PATHCRUNCH on the full filespec.
; *		 Make sure the second filespec only contains a
; *		 filename.  If both openands are valid, attempt
; *		 to rename the file.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

CRENAME:

	mov	si,81H				;AC000; Point to command line
	mov	di,offset trangroup:parse_rename;AN000; Get adderss of PARSE_RENAME
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,result_no_error		;AC000; did we have an error?
;;	jz	crename_no_parse_error		;AC000; no - continue
	jnz	crename_parse_error		;AC000; Yes, fail. (need long jump)

;
;  Get first file name returned from parse into our buffer
;
crename_no_parse_error:
	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AN000; get address of filespec
	invoke	move_to_srcbuf			;AN000; move to srcbuf
	pop	si				;AN000; restore position in line

	xor	dx,dx				;AN000; clear dx
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,result_no_error		;AN000; did we have an error?
	JNZ	crename_parse_error		;AN000; Yes, fail.

;
;  Check the second file name for drive letter colon
;
	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AC000; get address of path

	mov	al,':'                          ;AC000;
	cmp	[si+1],al			;AC000; Does the 2nd parm have a drive spec?
	jnz	ren_no_drive			;AN000; Yes, error
	mov	msg_disp_class,parse_msg_class	;AN000; set up parse error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,BadParm_ptr	;AN000; get "Invalid parameter" message number

	pop	si				;AN000;
crename_parse_error:				;AC022;
	jmp	short errj			;AC000;

;
;  Get second file name returned from parse into the fCB.  Save
;  character after file name so we can later check to make sure it
;  isn't a path character.
;

ren_no_drive:
	mov	di,FCB+10H			;AC000; set up to parse second file name
	mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
	int	21h			;AC000; do the function
	lodsb					;AC000; Load char after filename
	mov	one_char_val,al 		;AN000; save char after filename
	pop	si				;AN000; get line position back

;
; We have source and target.  See if any args beyond.
;

	mov	di,offset trangroup:parse_rename;AC000; get address of parse_rename
	invoke	parse_check_eol 		;AC000; are we at end of line?
	jnz	crename_parse_error		;AN000; no, fail.

	invoke	pathcrunch
	mov	dx,offset trangroup:badcpmes_ptr
	jz	errj2				; If 1st parm a dir, print error msg
	jnc	notest3
	mov	ax,[msg_numb]			;AN022; get message number
	cmp	ax,0				;AN022; was message flag set?
	jnz	extend_setup			;AN022; yes - print out message
	cmp	[destisdir],0			; No CHDIRs worked
	jz	notest3 			; see if they should have
	Jmp	badpath_err			;AC022; set up error

notest3:
	mov	al,one_char_val 		;AN000; move char into AX
	mov	dx,offset trangroup:inornot_ptr ; Load invalid fname error ptr
	invoke	pathchrcmp			; Is the char in al a path sep?
	jz	errj				; Yes, error - 2nd arg must be
						;  filename only.

	mov	ah,FCB_Rename
	mov	dx,FCB
	int	21h
	cmp	al, 0FFH			; Did an error occur??
	jnz	renameok

	invoke	get_ext_error_number		;AN022; get extended error
	SaveReg <AX>				;AC022; Save results
	mov	al, 0FFH			; Restore original error state

renameok:
	push	ax
	invoke	restudir
	pop	ax
	inc	al
	retnz

	RestoreReg  <AX>			;AC022; get the error number back
	cmp	ax,error_file_not_found 	;AN022; error file not found?
	jz	use_renerr			;AN022; yes - use generic error message
	cmp	ax,error_access_denied		;AN022; error file not found?
	jz	use_renerr			;AN022; yes - use generic error message
	jmp	extend_setup			;AN022; need long jump - use extended error

use_renerr:
	mov	dx,offset trangroup:RenErr_ptr	;AC022;

ERRJ:
	jmp	Cerror

ret56:	ret

	break	Type

;****************************************************************
;*
;* ROUTINE:	TYPEFIL - Display the contents of a file to the
;*		standard output device
;*
;* SYNTAX:	TYPE filespec
;*
;* FUNCTION:	If a valid filespec is found, read the file until
;*		1Ah and display the contents to STDOUT.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	none
;*
;****************************************************************

assume	ds:trangroup,es:trangroup

TYPEFIL:
	mov	si,81H
	mov	di,offset trangroup:parse_mrdir ;AN000; Get adderss of PARSE_MRDIR
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,result_no_error		;AC000; did we have an error?
	jnz	typefil_parse_error		;AN000; yes - issue error message

	push	si				;AC000; save position in line
	lds	si,parse1_addr			;AC000; get address of filespec
	invoke	move_to_srcbuf			;AC000; move to srcbuf
	pop	si				;AC000; get position back
	mov	di,offset trangroup:parse_mrdir ;AC000; get address of parse_mrdir
	invoke	parse_check_eol 		;AC000; are we at end of line?
	jz	gottarg 			;AC000; yes - continue

typefil_parse_error:				;AN000; no - set up error message and exit
	jmp	Cerror

gottarg:
	invoke	setpath
	test	[destinfo],00000010b		; Does the filespec contain wildcards
	jz	nowilds 			; No, continue processing
	mov	dx,offset trangroup:inornot_ptr ; Yes, report error
	jmp	Cerror
nowilds:
	mov	ax,ExtOpen SHL 8		;AC000; open the file
	mov	bx,read_open_mode		;AN000; get open mode for TYPE
	xor	cx,cx				;AN000; no special files
	mov	dx,read_open_flag		;AN000; set up open flags
	mov	si,offset trangroup:srcbuf	;AN030; get file name
	int	21h
	jnc	typecont			; If open worked, continue. Otherwise load

Typerr: 					;AN022;
	push	cs				;AN022; make sure we have local segment
	pop	ds				;AN022;
	invoke	set_ext_error_msg		;AN022;
	mov	string_ptr_2,offset trangroup:srcbuf ;AC022; get address of failed string
	mov	Extend_buf_sub,one_subst	;AC022; put number of subst in control block
	jmp	cerror				;AC022; exit

typecont:
	mov	bx,ax				;AC000; get  Handle
;M043
; We should do the LSEEK for filesize only if this handle belongs to a file
;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
;indicate it is a device.
;
	mov	ax,(IOCTL shl 8) or 0
	int	21h

	test	dl,80h				;is it a device?
	jz	not_device			;no, a file

	mov	word ptr TypeFilSiz+2,-1 		;indicate it is a device
	jmp	short dotype
not_device:

;SR;
; Find the filesize by seeking to the end and then reset file pointer to
;start of file
;
	mov	ax,(LSEEK shl 8) or 2
	xor	dx,dx
	mov	cx,dx				;seek  to end of file
	int	21h

	mov	word ptr TypeFilSiz,ax
	mov	word ptr TypeFilSiz+2,dx		;store filesize

	mov	ax,(LSEEK shl 8) or 0
	xor	dx,dx
	int	21h	              			;reset file pointer to start
dotype:						;M043
	mov	zflag,0 			; Reset ^Z flag
	mov	ds,[TPA]
	xor	dx,dx
ASSUME	DS:NOTHING

typelp:
	cmp	cs:[zflag],0			;AC050; Is the ^Z flag set?
	retnz					; Yes, return
	mov	cx,cs:[bytcnt]			;AC056; No, continue
;
;Update the filesize left to read
;
	cmp	word ptr cs:TypeFilSiz+2,-1	;is it a device? M043
	je	typ_read			;yes, just read from it; M043

	cmp	word ptr cs:TypeFilSiz+2,0		;more than 64K left?
	jz	lt64k				;no, do word subtraction
	sub	word ptr cs:TypeFilSiz, cx
	sbb	word ptr cs:TypeFilSiz+2, 0 	;update filesize
      	jmp	short typ_read			;do the read
lt64k:
	cmp	cx,word ptr cs:TypeFilSiz		;readsize <= buffer?
	jbe	gtbuf				;yes, just update readsize
;
;Buffer size is larger than bytes to read
;
	mov	cx,word ptr cs:TypeFilSiz
	jcxz	typelp_ret
	mov	word ptr cs:TypeFilSiz,0
	jmp	short typ_read
gtbuf:
	sub	word ptr cs:TypeFilSiz,cx	   	;update filesize remaining
typ_read:
	mov	ah,read
	int	21h
	jnc	@f				;M043
	jmp	typerr				;M043
@@:						;M043
;M043;	jc	typerr				;AN022; Exit if error

	mov	cx,ax
	jcxz	typelp_ret			;AC000; exit if nothing read
	push	ds
	pop	es				; Check to see if a ^Z was read.
assume es:nothing
	xor	di,di
	push	ax
	mov	al,1ah
	repnz	scasb
	pop	ax
	xchg	ax,cx
	cmp	ax,0
	jnz	foundz				; Yes, handle it
	cmp	byte ptr [di-1],1ah		; No, double check
	jnz	typecont2			; No ^Z, continue

foundz:
	sub	cx,ax				; Otherwise change cx so that only those
	dec	cx				;  bytes up to but NOT including the ^Z
	push	cs				;  will be typed.
	pop	es
assume es:trangroup
	not	zflag				; Turn on ^Z flag so that the routine

typecont2:					;  will quit after this write.
	push	bx
	mov	bx,1
	mov	ah,write
	int	21h
	pop	bx
	jc	Error_outputj
	cmp	ax,cx
	jnz	@f				;M043
	jmp	typelp				;M043
@@:						;M043
;M043;	jz	typelp
	dec	cx
	cmp	ax,cx
	retz					; One less byte OK (^Z)

Error_outputj:
	mov	bx,1
	mov	ax,IOCTL SHL 8
	int	21h
	test	dl,devid_ISDEV
	retnz					; If device, no error message
	jmp	error_output

typelp_ret:
	ret

	break	Volume
assume	ds:trangroup,es:trangroup

;
; VOLUME command displays the volume ID on the specified drive
;
VOLUME:

	mov	si,81H
	mov	di,offset trangroup:parse_vol	;AN000; Get adderss of PARSE_VOL
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,end_of_line			;AC000; are we at end of line?
	jz	OkVolArg			;AC000; Yes, display default volume ID
	cmp	ax,result_no_error		;AC000; did we have an error?
	jnz	BadVolArg			;AC000; Yes, fail.
;
; We have parsed off the drive.  See if there are any more chars left
;

	mov	di,offset trangroup:parse_vol	;AC000; get address of parse_vol
	xor	dx,dx				;AC000;
	invoke	parse_check_eol 		;AC000; call parser
	jz	OkVolArg			;AC000; yes, end of road
;
; The line was not interpretable.  Report an error.
;
badvolarg:
	jmp	Cerror




;***	DisAppend - disable APPEND
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	AX,BX
;
;	EFFECTS
;
;	  APPEND is disabled.  If it was active, it will be re-enabled
;	  after the command finishes, by the HeadFix routine.
;
;	NOTE
;
;	  This routine must not be called more than once during a single
;	  command cycle.  The second call would permanently disable APPEND.

DisAppend	proc

	assume	ds:TRANGROUP,es:NOTHING

	push	ds			; save DS
	push	es			; save ES
	push	di

	mov	ax,APPENDINSTALL	; AX = Append Installed Check code
	int	2Fh			; talk to APPEND via multiplex
	or	al,al
	jz	daRet			; APPEND not installed, return

	mov	ax,APPENDDOS		; AX = Get Append Version code
	int	2Fh			; talk to APPEND via multiplex
	cmp	ax,0FFFFh
	jne	daRet			; it's not a local version, return

	mov	ax,APPENDGETSTATE	; AX = Get Function State code
	int	2Fh			; talk to APPEND via multiplex

	mov	ds,ResSeg		; DS = resident seg addr

	assume	ds:RESGROUP

	mov	Append_State,bx		; Append_State = saved APPEND state
	mov	Append_Flag,-1		; Append_Flag = true, restore state

	xor	bx,bx			; BX = APPEND state = off
	mov	AX,APPENDSETSTATE	; AX = Set Append State code
	int	2Fh			; talk to APPEND via multiplex

daRet:	pop	di
	pop	es			; restore ES
	pop	ds			; restore DS

	assume	ds:TRANGROUP

	ret

DisAppend	endp



;
; Find the Volume ID on the disk.
;
PUBLIC	OkVolArg
OKVOLARG:
	assume	ds:TRANGROUP,es:TRANGROUP

	call	DisAppend			; disable APPEND
	invoke	crlf2
	mov	al,blank			;AN051; Print out a blank
	invoke	print_char			;AN051;   before volume message
	push	ds
	pop	es
;
; Volume IDs are only findable via extended FCBs or find_first with attributes
; of volume_id ONLY.
;

	mov	di,FCB-7			; Point to extended FCB beginning
	mov	al,-1				; Tag to indicate Extention
	stosb
	xor	ax,ax				; Zero padding to volume label
	stosw
	stosw
	stosb
	mov	al,attr_volume_ID		; Look for volume label
	stosb
	inc	di				; Skip drive byte; it is already set
	mov	cx,11				; fill in remainder of file
	mov	al,'?'
	rep	stosb
;
; Set up transfer address (destination of search first information)
;
	mov	dx,offset trangroup:dirbuf
	mov	ah,set_DMA
	int	21h
;
; Do the search
;
	mov	dx,FCB-7
	mov	ah,Dir_Search_First
	int	21h

;********************************
; Print volume ID info

	push	ax				;AC000; AX return from SEARCH_FIRST for VOL ID
	mov	al,DS:[FCB]			;AC000; get drive letter
	add	al,'@'
	cmp	al,'@'
	jnz	drvok
	mov	al,[curdrv]
	add	al,capital_A
drvok:
	mov	vol_drv,al			;AC000; get drive letter into argument
	pop	ax				;AC000; get return code back
	or	al,al				;AC000; volume label found?
	jz	Get_vol_name			;AC000; volume label exists - go get it
	mov	dx,offset trangroup:VolMes_ptr_2 ;AC000; set up no volume message
	jmp	short print_serial		;AC000; go print it

Get_vol_name:
	mov	di,offset trangroup:charbuf
	mov	dx,di
	mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
	mov	cx,11				;AN000;  3/3/KK
	rep	movsb				;AN000;  3/3/KK

	xor	al,al				;AC000; store a zero to terminate the string
	stosb
	mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message

PRINT_SERIAL:

;
; Attempt to get the volume serial number from the disk.  If an error
; occurs, do not print volume serial number.
;

	push	dx				;AN000; save message offset
	mov	ax,(GetSetMediaID SHL 8)	;AC036; Get the volume serial info
	mov	bl,DS:[FCB]			;AN000; get drive number from FCB
	mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
	int	21h			;AN000; do the call
	pop	dx				;AN000; get message offset back
	jc	printvol_end			;AN000; if error, just go print label
	call	std_printf			;AC000; go print volume message
	mov	al,blank			;AN051; Print out a blank
	invoke	print_char			;AN051;   before volume message
	mov	dx,offset trangroup:VolSerMes_ptr ;AN000; get serial number message

printvol_end:
	jmp	std_printf			;AC000; go print and exit


;****************************************************************
;*
;* ROUTINE:	Set_ext_error_msg
;*
;* FUNCTION:	Sets up extended error message for printing
;*
;* INPUT:	return from INT 21
;*
;* OUTPUT:	extended error message set up in extended error
;*		buffer.
;*
;****************************************************************

Set_ext_error_msg proc near			;AN000;

	call	get_ext_error_number		;AC022; get the extended error
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,ax		;AN000; get message number in control block
	stc					;AN000; make sure carry is set

	ret					;AN000; return

Set_ext_error_msg endp				;AN000;

;****************************************************************
;*
;* ROUTINE:	Get_ext_error_number
;*
;* FUNCTION:	Does get extended error function call
;*
;* INPUT:	return from INT 21
;*
;* OUTPUT:	AX - extended error number
;*
;****************************************************************

Get_ext_error_number proc near			;AN022;

	SaveReg <BX,CX,DX,SI,DI,BP,ES,DS>	;AN022; save registers
	mov	ah,GetExtendedError		;AN022; get extended error
	xor	bx,bx				;AN022; clear BX
	int	21h			;AN022;
	RestoreReg  <DS,ES,BP,DI,SI,DX,CX,BX>	;AN022; restore registers

	ret					;AN022; return

Get_ext_error_number endp			;AN022;

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tenv2.asm ===
page ,132
;	SCCSID = @(#)tenv2.asm	1.1 85/05/14
;	SCCSID = @(#)tenv2.asm	1.1 85/05/14
TITLE	Part6 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;	Environment utilities and misc. routines

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include find.inc
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES SEGMENT PUBLIC BYTE		;AC000;
	EXTRN	pipeflag:byte
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	ACRLF_PTR:WORD
	EXTRN	BadCD_Ptr:WORD
	EXTRN	Badmkd_ptr:word
	EXTRN	BADRMD_PTR:WORD
	EXTRN	Extend_buf_ptr:word	;AN000;
	EXTRN	Extend_buf_sub:byte	;AN022;
	EXTRN	MD_exists_ptr:word	;AN006;
	EXTRN	msg_disp_class:byte	;AC000;
	EXTRN	NOSPACE_PTR:WORD
	EXTRN	parse_chdir:byte	;AC000;
	EXTRN	parse_mrdir:byte	;AC000;
	EXTRN	PIPEEMES_PTR:WORD
	EXTRN	string_buf_ptr:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	CURDRV:BYTE
	EXTRN	DESTINFO:BYTE
	EXTRN	DESTTAIL:WORD
	EXTRN	DIRCHAR:BYTE
	EXTRN	dirflag:byte		;AN015;
	EXTRN	KPARSE:BYTE		;AC000;  3/3/KK
	EXTRN	msg_numb:word		;AN022;
	EXTRN	parse1_addr:dword	;AC000;
	EXTRN	parse1_type:byte	;AC000;
	EXTRN	PATHPOS:WORD
	EXTRN	RESSEG:WORD
	EXTRN	srcxname:byte		;AC000;
	EXTRN	string_ptr_2:word
	EXTRN	SWITCHAR:BYTE
	EXTRN	USERDIR1:BYTE
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC byte

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	cerror:near

	PUBLIC	$chdir
	PUBLIC	$mkdir
	PUBLIC	$rmdir
	PUBLIC	crlf2
	PUBLIC	crprint
	PUBLIC	delim
	PUBLIC	error_output
	PUBLIC	fcb_to_ascz
	PUBLIC	pathchrcmp
	PUBLIC	pathcrunch
	PUBLIC	savudir
	PUBLIC	savudir1
	PUBLIC	scanoff
	PUBLIC	strcomp

break	$Chdir

; ****************************************************************
; *
; * ROUTINE:	 $CHDIR
; *
; * FUNCTION:	 Entry point for CHDIR command. Parse the command
; *		 line. If path is found, CHDIR to path. If a drive
; *		 letter is found, get and display the current dir
; *		 of the specified drive. If nothing is found, get
; *		 and display the current dir of the default drive.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

$CHDIR:

	mov	si,81H
	mov	di,offset trangroup:parse_chdir ;AN000; Get adderss of PARSE_CHDIR
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser

	cmp	ax,end_of_line			;AC000; are we at end of line?
	jz	bwdJ				; No args
	cmp	ax,result_no_error		;AC000; did we have an error?
	jnz	ChDirErr			;AC018; yes - exit

	cmp	parse1_type,result_drive	;AC000; was a drive entered?
	jnz	REALCD				; no
;
; D: was found.  See if there is anything more.
;
	mov	di,offset trangroup:parse_chdir ;AC000; get address of parse_chdir
	xor	dx,dx				;AC000;
	invoke	parse_check_eol 		;AC000; call parser
	jnz	ChDirErr			;AC000;

bwdJ:
	invoke	build_dir_for_chdir		; Drive only specified
	call	crlf2
	return

REALCD:

	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AN000; get address of filespec
	invoke	move_to_srcbuf			;AN000; move to srcbuf
	pop	si				;AN000; restore position in line
	mov	di,offset trangroup:parse_chdir ;AC000; get address of parse_chdir
	xor	dx,dx				;AC000;
	invoke	parse_check_eol 		;AC000; call parser
	jnz	ChDirErr			;AC000;

	invoke	SETPATH
	TEST	[DESTINFO],2
	JNZ	BadChdir
	MOV	AH,CHDIR
	INT	21h
	retnc

	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_path_not_found 	;AN022; see if path not found
	jz	BadChDir			;AN022; yes - issue old message
;SR;
; We want to issue "Invalid Directory" message even if the path is valid
;but is not a directory. The extended error returns "Access denied" which
;is kind of confusing. Issue the old message if access denied error is 
;returned
;
	cmp	ax,error_access_denied
	jz	BadChDir

	call	Set_Ext_Error_Subst		;AN022;
	jmp	short  chdirerr 		;AN022;

BadChDir:
	MOV	DX,OFFSET TRANGROUP:BADCD_ptr

ChDirErr:
	invoke	Std_Eprintf
	return

break	$Mkdir

assume	ds:trangroup,es:trangroup

$MKDIR:
	CALL	SETRMMK
	JC	MkDirErr
	MOV	AH,MKDIR
	INT	21h
	retnc

	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_path_not_found 	;AN022; see if path not found
	jz	MD_other_err			;AN022; yes - issue old message
	cmp	ax,error_access_denied		;AN022; access denied?
	jz	badmderr			;AN022; yes - see if file exists

	call	Set_Ext_Error_Subst		;AN022;
	jmp	short MkDirerr			;AC022; yes - go print it

BADMDERR:
	mov	dx,offset trangroup:srcxname	;AN006; Set Disk transfer address
	mov	ah,Set_DMA			;AN006;
	int	21h			;AN006;
	MOV	AH,Find_First			;AN006; see if file/dir exists
	mov	cx,attr_directory		;AN006;   search for directory
	INT	21h			;AN006;
	jc	MD_other_err			;AN006; doesn't exist - must be something else
	mov	dl,srcxname.find_buf_attr	;AN006; we found a file/dir
	test	dl,attr_directory		;AN006; was it a directory?
	jz	MD_other_err			;AN006; no - must have been a file
	mov	dx,offset trangroup:MD_exists_ptr ;AN006; set up already exists error
	jmp	short MkDirErr			;AN006; make sure we didn't have network error
MD_other_err:					;AN006;
	MOV	DX,OFFSET TRANGROUP:BADMKD_ptr
MkDirErr:
	invoke	Std_Eprintf
	return

Break	<Common MkDir/RmDir set up code>

;****************************************************************
;*
;* ROUTINE:	SETRMMK
;*
;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
;*		commands. Parses the command line for a required
;*		filespec.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	carry clear
;*		    DS:DX points to ASCIIZ argument
;*		carry set
;*		    DS:DX has error message pointer
;*
;****************************************************************

SETRMMK:
	mov	si,81H
	mov	di,offset trangroup:parse_mrdir ;AN000; Get adderss of PARSE_MRDIR
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC000; call parser
	cmp	ax,result_no_error		;AC000; did we have an error?
	jnz	 NOARGERR			;AC000; yes - exit

	mov	di,offset trangroup:srcxname	;AN000; get address of srcxname
	push	di				;AN000; save address
	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AN000; get address of path

mrdir_move_filename:				;AN000; put filespec in srcxname
	lodsb					;get a char from buffer
	stosb					;AN000; store in srcxname
	cmp	al,end_of_line_out		;AC000; it char a terminator?
	jnz	mrdir_move_filename		;AC000; no - keep moving
	pop	si				;AN000; get line position back

;
; we have scanned an argument.	See if any args beyond.
;

	mov	di,offset trangroup:parse_mrdir ;AC000; get address of parse_mrdir
	invoke	parse_check_eol 		;AC000; are we at end of line?
	pop	dx				;AC000; get address of SRCXNAME
	retz					;yes - return no error
NOARGERR:
	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
	XOR	AX,AX
	STC
	return

break	$Rmdir

assume	ds:trangroup,es:trangroup

$RMDIR:
	CALL	SETRMMK
	JC	RmDirErr
	JNZ	BADRDERR
	MOV	AH,RMDIR
	INT	21h
	retnc

	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_path_not_found 	;AN022; see if path not found
	jz	badrderr			;AN022; yes - issue old message
	cmp	ax,error_access_denied		;AN022; access denied?
	jz	badrderr			;AN022; yes - issue old message

	call	Set_Ext_Error_Subst		;AN022;
	jmp	short RmDirerr			;AC022; yes - go print it

BADRDERR:
	MOV	DX,OFFSET TRANGROUP:BADRMD_ptr

RmDirErr:
	invoke	STD_Eprintf
	return

;****************************************************************
;*
;* ROUTINE:	Set_ext_error_subst
;*
;* FUNCTION:	Sets up substitution for extended error
;*
;* INPUT:	AX - extended error number
;*		DX - offset of string
;*
;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
;*
;****************************************************************

Set_ext_error_subst  proc near			;AN022;

	mov	msg_disp_class,ext_msg_class	;AN022; set up extended error msg class
	mov	string_ptr_2,dx 		;AN022; get address of failed string
	mov	Extend_buf_sub,one_subst	;AN022; put number of subst in control block
	mov	dx,offset TranGroup:Extend_Buf_ptr ;AN022; get extended message pointer
	mov	Extend_Buf_ptr,ax		;AN022; get message number in control block

	ret					;AN022; return

Set_ext_error_subst  endp			;AN022;





Break	<SavUDir - preserve the users current directory on a particular drive>

;
; SavUDir - move the user's current directory on a drive into UserDir1
; SavUDir1 - move the user's current directory on a drive into a specified
;   buffer
;
;   Inputs:	DL has 1-based drive number
;		ES:DI has destination buffer (SavUDir1 only)
;   Outputs:	Carry Clear
;		    DS = TranGroup
;		Carry Set
;		    AX has error code
;   Registers Modified: AX, SI
;

SAVUDIR:
	MOV	DI,OFFSET TRANGROUP:USERDIR1

SAVUDIR1:
	MOV	AL,DL
	ADD	AL,'@'
	CMP	AL,'@'
	JNZ	GOTUDRV
	ADD	AL,[CURDRV]
	INC	AL				; A = 1

GOTUDRV:
	STOSB
	MOV	AH,[DIRCHAR]
	MOV	AL,':'
	STOSW
	PUSH	ES
	POP	DS
ASSUME	DS:NOTHING

	MOV	SI,DI
	MOV	AH,CURRENT_DIR			; Get the Directory Text
	INT	21h
	retc
	PUSH	CS
	POP	DS
ASSUME	DS:TRANGROUP

	return


CRLF2:
	PUSH	DX
	MOV	DX,OFFSET TRANGROUP:ACRLF_ptr

PR:
	PUSH	DS
	PUSH	CS
	POP	DS
	invoke	std_printf
	POP	DS
	POP	DX

	return

;
; These routines (SCANOFF, DELIM) are called in batch processing when DS
; may NOT be TRANGROUP
;
ASSUME	DS:NOTHING,ES:NOTHING

SCANOFF:
	LODSB
	CALL	DELIM
	JZ	SCANOFF
	DEC	SI				; Point to first non-delimiter
	return

;
; Input:    AL is character to classify
; Output:   Z set if delimiter
;	    NZ set otherwise
; Registers modified: none
;

DELIM:
	CMP	AL,' '
	retz
	CMP	AL,'='
	retz
	CMP	AL,','
	retz
	CMP	AL,';'
	retz
	CMP	AL,9				; Check for TAB character
	retz
	CMP	AL,0ah				; Check for line feed character - BAS
	return


ASSUME	DS:TRANGROUP,ES:TRANGROUP


FCB_TO_ASCZ:					; Convert DS:SI to ASCIZ ES:DI
	MOV	CX,8

MAINNAME:
	LODSB
	CMP	AL,' '
	JZ	SKIPSPC
	STOSB

SKIPSPC:
	LOOP	MAINNAME
	LODSB
	CMP	AL,' '
	JZ	GOTNAME
	MOV	AH,AL
	MOV	AL,dot_chr
	STOSB
	XCHG	AL,AH
	STOSB
	MOV	CL,2

EXTNAME:
	LODSB
	CMP	AL,' '
	JZ	GOTNAME
	STOSB
	LOOP	EXTNAME

GOTNAME:
	XOR	AL,AL
	STOSB
	return

STRCOMP:
;
; Compare ASCIZ DS:SI with ES:DI.
; SI,DI destroyed.
;
	CMPSB
	retnz					; Strings not equal
	cmp	byte ptr [SI-1],0		; Hit NUL terminator?
	retz					; Yes, strings equal
	jmp	short STRCOMP			; Equal so far, keep going


CRPRINT:
	PUSH	AX
	MOV	AL,13
	PUSH	CX
	PUSH	DI
	MOV	DI,DX
	MOV	CX,-1
	PUSH	ES
	PUSH	DS
	POP	ES

	REPNZ	SCASB				; LOOK FOR TERMINATOR
	mov	byte ptr [di-1],0		; nul terminate the string
	POP	ES
	mov	string_ptr_2,dx
	mov	dx,offset trangroup:string_buf_ptr
	invoke	std_printf
	mov	ds:byte ptr [di-1],13		; now put the CR back
	JC	ERROR_OUTPUT

	POP	DI
	POP	CX
	POP	AX

	return

ERROR_OUTPUT:
	PUSH	CS
	POP	DS
ASSUME	DS:TRANGROUP
	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP

	MOV	DX,OFFSET TRANGROUP:NOSPACE_ptr
	CMP	[PIPEFLAG],0
	JZ	GO_TO_ERROR

	invoke	PipeOff
	MOV	DX,OFFSET TRANGROUP:PIPEEMES_ptr
GO_TO_ERROR:
	JMP	CERROR

ASSUME	DS:TRANGROUP,ES:TRANGROUP

PATHCHRCMP:
;---- Mod for path invocation ----
PUBLIC pathchrcmp
;----

	push	ax
	mov	ah,'/'
	CMP	[SWITCHAR],ah
	JZ	NOSLASHT
	CMP	AL,'/'
	jz	pccont

NOSLASHT:
	CMP	AL,'\'
pccont:
	pop	ax

	return

;
; PATHCRUNCH -
;
; ENTRY FCB (in PSP) contains drive # to crunch on
;       PathPos = ptr to string with pathname in it
;       PathCnt = length of string
;
; EXIT  PathPos = ptr after pathname (w/ NULL) in string
;       PathCnt = length left in string
;       DestIsDir = nonzero if pathname delimiter char's found in pathname
;       DestInfo<bit1> = set if wildcard char's found in pathname
;       If path crunched successfully,
;         CY = clear
;         Current directory is changed to directory in pathname
;         UserDir1 contains previous directory for use by RestUDir
;         RestDir = nonzero to flag later restoration of user's dir
;         DestTail = ptr to beginning of filename
;         If filename found in pathname,
;           ZR = clear
;           FCB filename fields contain filename
;         If filename not found (pure directory path),
;           ZR = set
;           FCB filename fields are wildcarded with ?'s
;       If pathcrunch failed (no ChDir's worked),
;         CY = set
;         Msg_Numb = extended error code
;
; NOTE  DIR asks PathCrunch to forego parsing the filename into the
;       FCB by setting DirFlag.  In this case, the FCB is returned
;       with the filename wildcarded.
;
PATHCRUNCH:
        mov     [msg_numb],0            ;AN022; Set up message flag
        MOV     DL,DS:[FCB]             ; DL = drive # (1 = A)
        CALL    SAVUDIR                 ; save current directory in UserDir1
        jc      pcrunch_cderrJ           ;AN022; if error on current dir - report

        invoke  SETPATH                 ; scan past switches, whitespace

;       DX = ptr to pathname, NULL-terminated
;       PathPos = ptr to byte after NULL at end of pathname

        TEST    [DESTINFO],2            ; test if wildcards (? or *) seen
        JNZ     TRYPEEL                 ; wildcard seen, peel filename

        MOV     AH,CHDIR                ; AH = DOS ChDir function code
        INT     21h             ; call DOS
        jnc     chdir_worked            ;AN022; no error - continue

        invoke  get_ext_error_number    ;AN022; get the extended error
        cmp     ax,error_path_not_found ;AN022; if path not found
        jz      trypeel                 ;AC022;     keep trying
        cmp     ax,error_access_denied  ;AN022; if access denied
        jz      trypeel                 ;AC022;     keep trying
        mov     [msg_numb],ax           ;AN022; set up message flag
        jmp     peelfail                ;AN022; exit with other error

chdir_worked:
        invoke  SETREST1                ; set 'Restore Directory' flag true
        MOV     AL,'?'                  ; if pure dir, wildcard filename in FCB
        MOV     DI,5DH
	MOV	CX,11
        REP     STOSB
        XOR     AL,AL                   ; return carry clear, zero set
        return

pcrunch_cderrj: 				;AN022; need this for long jmp
	jmp	pcrunch_cderr			;AN022;

TRYPEEL:
        MOV     SI,[PATHPOS]
        DEC     SI                      ; SI = ptr to NULL at end of pathname
        MOV     AL,[SI-1]               ; AL = last char of pathname

	CMP	[KPARSE],0
	JNZ	DELSTRT 			; Last char is second KANJI byte, might be '\'

	CALL	PATHCHRCMP
	JZ	PEELFAIL			; Trailing '/'

DELSTRT:
        MOV     CX,SI                   ; CX = ptr to NULL at end of pathname
        MOV     SI,DX                   ; SI = ptr to start of pathname
        PUSH    DX                      ; save ptr to pathname
DELLOOP:
        CMP     SI,CX
        JZ      GOTDELE                 ; no char's left, we have what we have
        LODSB                           ; AL = next char of pathname
        invoke  TESTKANJ
        JZ      NOTKANJ8                ; not Kanji, move along
        INC     SI
	JMP	DELLOOP

NOTKANJ8:
        CALL    PATHCHRCMP
        JNZ     DELLOOP                 ; not a path delimiter, keep looking
        MOV     DX,SI
        DEC     DX                      ; DX = ptr to last delimiter found
        JMP     DELLOOP                 ; go look for more

GOTDELE:
        MOV     SI,DX                   ; SI = ptr to pathname or last delim
        POP     DX                      ; DX = ptr to pathname
        CMP     SI,DX
        JZ      BADRET                  ; didn't find path delim
        MOV     CX,SI                   ; CX = ptr to last path delimiter
        MOV     SI,DX                   ; SI = ptr to pathname

DELLOOP2:                               ; Set value of KPARSE
        CMP     SI,CX
        JZ      TRYCD                   ; roll up till SI meets CX
        MOV     [KPARSE],0
	LODSB
	INVOKE	TESTKANJ
	JZ	DELLOOP2
	INC	SI
	INC	[KPARSE]
	JMP	DELLOOP2

TRYCD:
        push    ax
        mov     al,dot_chr              ; AL = '.'
        CMP     BYTE PTR [SI+1],al      ; check for '.' after path delim
					;M019; allow continuation if '. ' or 
					;M019; '..' is not found.
	jnz	@F			;M019; '.' not found
	cmp	BYTE PTR [SI+2],al	;M019; check for '..'
	jz	@F			;M019; found '..'
	cmp	BYTE PTR [SI+2],0	;M019; check for '. ' (null terminated)
@@:     pop     ax
        JZ      PEELFAIL                ; if . or .., pure cd should have worked
        mov     al,[si-1]
        CMP     al,':'                  ; Special case d:\file
        JZ      BADRET

	CMP	[KPARSE],0
	JNZ	NOTDOUBLESL			; Last char is second KANJI byte, might be '\'

	CALL	PATHCHRCMP
	JNZ	NOTDOUBLESL
PEELFAIL:
	STC					; //
	return
NOTDOUBLESL:
	MOV	BYTE PTR [SI],0
	MOV	AH,CHDIR
	INT	21h
	JNC	CDSUCC
pcrunch_cderr:
	invoke	get_ext_error_number		;AN022; get the extended error
	mov	[msg_numb],ax			;AN022; set up message flag
	or	si,si				;AN022; set up zero flag to not zero
	stc					;AN022; set up carry flag
	return

BADRET:
	MOV	AL,[SI]
	CALL	PATHCHRCMP			; Special case 'DIRCHAR'file
	STC
	retnz
	XOR	BL,BL
	XCHG	BL,[SI+1]
	MOV	AH,CHDIR
	INT	21h
	jc	pcrunch_cderr			;AN022; go to error exit
	MOV	[SI+1],BL
CDSUCC:
	invoke	SETREST1
	INC	SI				; Reset zero
	MOV	[DESTTAIL],SI
	pushf					;AN015; save flags
	cmp	dirflag,-1			;AN015; don't do parse if in DIR
	jz	pcrunch_end			;AN015;
	MOV	DI,FCB
	MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 02H ; Parse with default drive
	INT	21h
pcrunch_end:
	popf					;AN015; get flags back
	return

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tfor.asm ===
page ,132
;	SCCSID = @(#)tfor.asm	4.1 85/09/17
;	SCCSID = @(#)tfor.asm	4.1 85/09/17
TITLE	Part3 COMMAND Transient Routines
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;     For loop processing routines


.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include find.inc
	include devsym.inc
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BATCH:WORD
	EXTRN	ECHOFLAG:BYTE
	EXTRN	FORFLAG:BYTE
	EXTRN	FORPTR:WORD
	EXTRN	NEST:WORD
	EXTRN	NULLFLAG:BYTE
	EXTRN	PIPEFILES:BYTE
	EXTRN	SINGLECOM:WORD
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	Extend_buf_ptr:word	;AN000;
	extrn	fornestmes_ptr:word
	EXTRN	msg_disp_class:byte	;AN000;
	extrn	string_buf_ptr:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	extrn	arg:byte		; the arg structure!
	EXTRN	COMBUF:BYTE
	EXTRN	RESSEG:WORD
	EXTRN	string_ptr_2:word
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	cerror:near
	EXTRN	docom:near
	EXTRN	docom1:near
	EXTRN	forerror:near
	EXTRN	tcommand:near

	PUBLIC	$for
	PUBLIC	forproc


; All batch proccessing has DS set to segment of resident portion
ASSUME	DS:RESGROUP,ES:TRANGROUP


FORTERM:
	push	cs				;AN037; Get local segment into
	pop	ds				;AN037;    DS, ES
	push	cs				;AN037;
	pop	es				;AN037;
	call	ForOff
	mov	ds,ResSeg
ASSUME	DS:RESGROUP
	CMP	[SINGLECOM],0FF00H
	JNZ	BATCRLF
	CMP	NEST,0				;G See if we have nested batch files
	JNZ	BATCRLF 			;G Yes - don't exit just yet
	MOV	[SINGLECOM],-1			; Cause a terminate
	JMP	SHORT NOFORP2

BATCRLF:
	test	[ECHOFLAG],1			;G  Is echo on?
	JZ	NOFORP2 			;G  no - exit
	TEST	[BATCH], -1			;G  print CRLF if in batch
	JZ	NOFORP2 			;G
	invoke	CRLF2

NOFORP2:
	JMP	TCOMMAND


;------
;   For-loop processing.  For loops are of the form:
;	    for %<loop-variable> in (<list>) do <command>
; where <command> may contain references of the form %<variable>, which are
; later substituted with the items in <list>.  The for-loop structure is
; set-up by the procedure '$for'; successive calls to 'forproc' execute
; <command> once for each item in <list>.  All of the information needed for
; loop processing is stored on a piece of memory gotten from 'alloc'.  This
; structure is actually fairly large, on the order of 700 bytes, and includes
; a complete copy of the original command-line structure as parsed by
; 'parseline', loop control variables, and a dma buffer for the
; 'FindFirst/FindNext' expansion of wildcard filenames in <list>.  When loop
; processing has completed, this chunk of memory is returned to the system.
;
;   All of the previously defined variables, in 'datares', used for loop
; processing may be erased.  Only one, (DW) ForPtr, need be allocated.
;
;   The error message, 'for_alloc_mes', should be moved into the file
; containing all of the other error messages.
;
;   Referencing the allocated for-loop structure is a little tricky.
; At the moment, a byte is defined as part of a new segment, 'for_segment'.
; When 'forproc' actually runs, ES and DS are set to point to the base of the
; new chunk of memory.	References to this byte, 'f', thus assemble correctly
; as offsets of ES or DS.  'f' would not be necessary, except that the
; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
; immediate move of the offset of 'for_minarg' into AX.  In other words, in
; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
;	mov	AX, #for_minarg 	; AX := 02CA (for example)
; instead of
;	mov	AX, for_minarg		; AX := [02CA] (contents of 02CA)
; By using 'f', we pretend that we are actually referencing an allocated
; structure, and the assembler coughs up the code we want.  Notice that it
; doesn't matter whether we put brackets around the location or not -- the
; assembler is "smart" enough to know that we want an address instead of the
; contents of that location.
;
;   Finally, there now exists the potential to easily implement nested loops.
; One method would be to have a link field in each for-structure pointing to
; its parent.  Variable references that couldn't be resolved in the local
; frame would cause a search of prior frames.  For-structures would still be
; allocated and released in exactly the same fashion.  The only limit on the
; number of nested loops would be memory size (although at 700 bytes a pop,
; memory wouldn't last THAT long).  Alternately, a small structure could be
; maintained in the resident data area.  This structure would be an array of
; control-variable names and pointers to for-structure blocks.	This would
; greatly speed up the resolution of non-local variable references.  However,
; since space in the resident is precious, we would have to compromise on a
; "reasonable" level of nesting -- 10, 16, 32 levels, whatever.  For-structure
; allocation and de-allocation would have to be modified slightly to take this
; new structure into account.
;
;   Oops, just one more thing.	Forbuf need not be a part of the for-structure.
; It could just as well be one structure allocated in 'transpace'.  Actually,
; it may be easier to allocate it as part of 'for_segment'.
;------

	include fordata.asm

$for_exit:
	jmp	forterm 			; exceeding maxarg means all done

forproc:
assume	DS:resgroup
	mov	AX, [ForPtr]
	mov	DS, AX
	mov	ES, AX				; operate in for-info area
assume	DS:for_segment, ES:for_segment

	mov	DX, fordma
	trap	Set_Dma
for_begin:
	cmp	f.for_expand, 0 		; non-zero for_expand equals FALSE
	je	for_begin1
	inc	f.for_minarg
for_begin1:
	mov	BX, f.for_minarg		; current item in <list> to examine
	cmp	BX, f.for_maxarg
	jg	$for_exit			; exceeding maxarg means all done
	mov	AX, for_args.argv
	invoke	argv_calc			; compute argv[x] address

	mov	CX, [BX].argstartel
	mov	DX, [BX].argpointer
	test	[bx].argflags,00000100b 	; Is there a path separator in this arg?
	jnz	forsub				; Yes, argstartel should be correct
	mov	si, [BX].argpointer
	mov	al,lparen
	cmp	byte ptr [si-1],al		; If the current token is the first
	jnz	forsub				;  one in the list and originally had
	inc	cx				;  the opening paren as its first char,
						;  the argstartel ptr needs to be
						;  advanced passed it before the prefix
						;  length is computed.
	mov	al,':'
	cmp	byte ptr [si+1],al		; If the token begins with "(d:",
	jnz	forsub				;  argstartel has to be moved over the
	add	cx,2				;  rest of the prefix as well.

forsub:
	sub	CX, DX				; compute length of pathname prefix
	cmp	f.for_expand, 0 		; are we still expanding a name?
	je	for_find_next			; if so, get next matching filename

	test	[BX].argflags, MASK wildcard
	jnz	for_find_first			; should we expand THIS (new) arg?
	mov	CX, [BX].arglen 		; else, just copy all of it directly
	jmp	short for_smoosh

for_find_first:
	PUSH	CX
	XOR	CX,CX
	trap	Find_First			; and search for first filename match
	POP	CX
	jmp	short for_result
for_find_next:
	trap	Find_Next			; search for next filename match

for_result:
	mov	AX, -1				; assume worst case
	jc	forCheck
	mov	ax,0
forCheck:					; Find* returns 0 for SUCCESS
	mov	f.FOR_EXPAND, AX		; record success of findfirst/next
	or	AX, AX				; anything out there?
	jnz	for_begin			; if not, try next arg

for_smoosh:
	mov	SI, [BX].argpointer		; copy argv[arg][0,CX] into destbuf
	mov	DI, forbuf			; some days this will be the entire
	rep	movsb				; arg, some days just the path prefix

	cmp	f.FOR_EXPAND, 0 		; if we're not expanding, we can
	jnz	for_make_com			; skip the following

	mov	SI, fordma.find_buf_pname
for_more:					; tack on matching filename
	cmp	BYTE PTR [SI], 0
	je	for_make_com
	movsb
	jnz	for_more

for_make_com:
	xor	AL, AL				; tack a null byte onto the end
	stosb					; of the substitute string

	xor	CX, CX				; character count for command line
	not	CX				; negate it -- take advantage of loopnz
	xor	BX, BX				; argpointer
	mov	DI, OFFSET TRANGROUP:COMBUF+2
	mov	bl, f.FOR_COM_START		; argindex
	mov	DH, f.FOR_VAR			; %<for-var> is replaced by [forbuf]
						; time to form the <command> string
	push	CS
	pop	ES
assume	ES:trangroup

	mov	AX, for_args			; translate offset to pointer
	invoke	argv_calc
	mov	si,[bx].arg_ocomptr
	inc	si				; mov ptr passed beginning space

for_make_loop:
	mov	al,[si] 			; the <command> arg, byte by byte
	inc	si
	cmp	AL,'%'                          ; looking for %<control-variable>
	jne	for_stosb			; no % ... add byte to string
	cmp	BYTE PTR [SI], DH		; got the right <variable>?
	jne	for_stosb			; got a %, but wrong <variable>
	inc	SI				; skip over <for-variable>

	push	SI
	mov	SI, forbuf			; substitute the <item> for <variable>
						; to make a final <command> to execute
sloop:
	lodsb					; grab all those <item> bytes, and
	stosb					; add 'em to the <command> string,
	or	AL, AL				; until we run into a null
	loopnz	sloop
	dec	DI				; adjust length and <command> pointer
	inc	CX				; so we can overwrite the null

	pop	SI
	jmp	for_make_loop			; got back for more <command> bytes
for_stosb:
	stosb					; take a byte from the <command> arg
	dec	CX				; and put it into the <command> to be
						; executed (and note length, too)
	cmp	al,0dh				; If not done, loop.
	jne	for_make_loop

for_made_com:					; finished all the <command> args
	not	CL				; compute and record command length
	mov	[COMBUF+1], CL

	mov	DS, [RESSEG]
assume	DS:resgroup

	test	[ECHOFLAG],1			; shall we echo this <command>, dearie?
	jz	noecho3
	cmp	nullflag,nullcommand		;G was there a command last time?
	jz	No_crlf_pr			;G no - don't print crlf
	invoke	CRLF2				;G  Print out prompt

no_crlf_pr:
	mov	nullflag,0			;G reset no command flag
	push	CS
	pop	DS
	assume	DS:trangroup
	push	di
	invoke	PRINT_PROMPT			;G Prompt the user
	pop	di
	mov	BYTE PTR ES:[DI-1],0		; yeah, PRINT it out...
	mov	string_ptr_2,OFFSET TRANGROUP:COMBUF+2
	mov	dx,offset trangroup:string_buf_ptr
	invoke	std_printf
	mov	BYTE PTR ES:[DI-1], 0DH
	jmp	DoCom
noecho3:					; run silent, run deep...
	assume	DS:resgroup
	mov	nullflag,0			;G reset no command flag
	push	CS
	pop	DS
	assume	DS:trangroup
	jmp	docom1


fornesterrj:					; no multi-loop processing... yet!
assume	ES:resgroup
	call	ForOff
	jmp	fornesterr

forerrorj:
	jmp	forerror

	break	$For
assume	ds:trangroup,es:trangroup

$for:
	mov	ES, [RESSEG]
assume	ES:resgroup

	cmp	ForFlag,0			; is another one already running?
	jnz	fornesterrj			; if flag is set.... boom!

;
; Turn off any pipes in progress.
;
	cmp	[PIPEFILES],0			; Only turn off if present.
	jz	NoPipe
	invoke	PipeDel
NoPipe:
	xor	DX, DX				; counter (0 <= DX < argvcnt)
	call	nextarg 			; move to next argv[n]
	jc	forerrorj			; no more args -- bad forloop
	cmp	AL,'%'                          ; next arg MUST start with '%'...
	jne	forerrorj
	mov	BP, AX				; save forloop variable
	lodsb
	or	AL, AL				; and MUST end immediately...
	jne	forerrorj

	call	nextarg 			; let's make sure the next arg is 'in'
	jc	forerrorj
	and	AX, NOT 2020H			; uppercase the letters
	cmp	AX, in_word
	jne	forerrorj
	lodsb
	or	AL, AL				; it, too, must end right away

; Compaq bug fix -- exit from this loop on error

ifndef NEC_98
	jne	forerrorj			; jump on error

;;	je	CheckLParen
else    ;NEC_98
;;      jne     forerrorj                       ; jump on error ;NEC00

        je      CheckLParen
endif   ;NEC_98
;
; Not null.  Perhaps there are no spaces between this and the (:
;   FOR %i in(foo bar...
; Check for the Lparen here
;
ifndef NEC_98
;;	CMP	AL,lparen
;;	JNZ	forerrorj
else    ;NEC_98
        CMP     AL,lparen
        JNZ     forerrorj
endif   ;NEC_98
;
; The token was in(...	We strip off the "in" part to simulate a separator
; being there in the first place.
;
ifndef NEC_98
;;	ADD	[BX].argpointer,2		; advance source pointer
;;	ADD	[BX].arg_ocomptr,2		; advance original string
;;	SUB	[BX].arglen,2			; decrement the appropriate length
else    ;NEC_98
        ADD     [BX].argpointer,2               ; advance source pointer
        ADD     [BX].arg_ocomptr,2              ; advance original string
        SUB     [BX].arglen,2                   ; decrement the appropriate length
endif   ;NEC_98
;
; SI now points past the in(.  Simulate a nextarg call that results in the
; current value.
;
ifndef NEC_98
;;	MOV	ax,[si-1]			; get lparen and next char
;;	jmp	short lpcheck
else    ;NEC_98
        MOV     ax,[si-1]                       ; get lparen and next char
        jmp     short lpcheck
endif   ;NEC_98
;
;; end of Compaq bug fix

CheckLParen:
	call	nextarg 			; lparen delimits beginning of <list>
	jc	forerrorj
lpcheck:
	cmp	al, lparen
	jne	forerrorj
	cmp	ah,0
	je	for_paren_token

	cmp	ah, rparen			; special case:  null list
	jne	for_list_not_empty
	jmp	forterm

for_list_not_empty:
	inc	[bx].argpointer 		; Advance ptr past "("
						; Adjust the rest of this argv entry
	dec	[bx].arglen			;  to agree.
	inc	si				; Inc si so check for ")" works
	jmp	short for_list

for_paren_token:
	call	nextarg 			; what have we in our <list>?
	jc	forerrorj
	cmp	ax, nullrparen			; special case:  null list
	jne	for_list
	jmp	forterm

forerrorjj:
	jmp	forerror

for_list:					; skip over rest of <list>
	mov	CX, DX				; first arg of <list>
skip_list:
	add	si,[bx].arglen
	sub	si,3				; si = ptr to last char of token
	mov	al,rparen
	cmp	byte ptr [si],al		; Is this the last element in <list>
	je	for_end_list			; Yes, exit loop.
	call	nextarg 			; No, get next arg <list>
	jc	forerrorjj			; If no more and no rparen, error.
	jmp	skip_list
for_end_list:
	mov	DI, DX				; record position of last arg in <list>
	mov	byte ptr [si],0 		; Zap the rparen
	cmp	ax,nullrparen			; Was this token only a rparen
	jz	for_do				; Yes, continue
	inc	di				; No, inc position of last arg

for_do:
	call	nextarg 			; now we had BETTER find a 'do'...
	jc	forerrorjj
	and	AX, NOT 2020H			; uppercase the letters
	cmp	AX, do_word
	jne	forerrorjj
	lodsb
	or	AL, AL				; and it had BETTER be ONLY a 'do'...
	jne	forerrorjj

	call	nextarg 			; on to the beginning of <command>
	jc	forerrorjj			; null <command> not legal

	push	AX
	push	BX
	push	CX
	push	DX				; preserve registers against disaster
	push	DI
	push	SI
	push	BP
	invoke	FREE_TPA			; need to make free memory, first
ASSUME	ES:RESGROUP
	call	ForOff
	mov	BX, SIZE for_info - SIZE arg_unit
	invoke	Save_Args			; extra bytes needed for for-info
	pushf
	mov	[ForPtr], AX
	invoke	ALLOC_TPA			; ALLOC_TPA clobbers registers...
	popf
	pop	BP
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	jc	for_alloc_err

	push	ES				; save resgroup seg...
	push	[ForPtr]
	pop	ES
assume	ES:for_segment				; make references to for-info segment

	dec	CX				; forproc wants min pointing before
	dec	DI				; first arg, max right at last one
	mov	f.for_minarg, CX
	mov	f.for_maxarg, DI
	mov	f.for_com_start, DL
	mov	f.for_expand, -1		; non-zero means FALSE
	mov	AX, BP
	mov	f.for_var, AH
	pop	ES
assume	ES:resgroup

	inc	[FORFLAG]
	cmp	[SINGLECOM], -1
	jnz	for_ret
	mov	[SINGLECOM], 0FF00H
for_ret:
	ret

for_alloc_err:
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr     ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,error_not_enough_memory ;AN000; get message number in control block
	jmp	cerror

nextarg:
	inc	DX				; next argv[n]
	cmp	DX, arg.argvcnt 		; make sure we don't run off end
	jge	nextarg_err			; of argv[]...
	mov	BX, DX
	mov	AX, OFFSET TRANGROUP:arg.argv
	invoke	argv_calc			; convert array index to pointer
	mov	SI, [BX].argpointer		; load pointer to argstring
	lodsw					; and load first two chars
	clc
	ret
nextarg_err:
	stc
	ret


ASSUME	DS:TRANGROUP,ES:TRANGROUP

FORNESTERR:
	PUSH	DS
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	DX,OFFSET TRANGROUP:FORNESTMES_ptr
	CMP	[SINGLECOM],0FF00H
	JNZ	NOFORP3
	MOV	[SINGLECOM],-1			; Cause termination
NOFORP3:
	POP	DS
ASSUME	DS:TRANGROUP
	JMP	CERROR
;
; General routine called to free the for segment.  We also clear the forflag
; too.	Change no registers.
;
PUBLIC ForOff
ForOff:
	assume DS:NOTHING,ES:NOTHING
	SaveReg <AX,ES>
	mov	es,ResSeg
	assume	es:ResGroup
	mov	AX,ForPtr
	or	ax,ax
	jz	FreeDone
	push	es
	mov	es,ax
	mov	ah,dealloc
	int	21h
	pop	es
FreeDone:
	mov	ForPtr,0
	mov	ForFlag,0
	RestoreReg  <ES,AX>
	return

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tmisc1.asm ===
page ,132
;	SCCSID = @(#)tmisc1.asm 4.1 85/09/22
;	SCCSID = @(#)tmisc1.asm 4.1 85/09/22
TITLE	Part7 COMMAND Transient Routines
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;	M003	SR	07/16/90	Made Execute public to jump to it for
;				LoadHigh support
;
;	M025	SR	9/12/90	Removed calls to SetStdInOn,SetStdInOff
;				SetStdOutOn & SetStdOutOff.
;


;	More misc routines

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include comseg.asm
	include comequ.asm
.list
.cref



CODERES 	SEGMENT PUBLIC BYTE	;AC000;
;;	EXTRN	RSTACK:BYTE
CodeRes 	ENDS

DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	CALL_FLAG:BYTE
	EXTRN	EchoFlag:BYTE
	EXTRN	EXEC_BLOCK:BYTE
	EXTRN	EXTCOM:BYTE
	EXTRN	LenMsgOrPathBuf:ABS
	EXTRN	PIPEFLAG:BYTE
	EXTRN	PIPEPTR:WORD
	EXTRN	PIPESTR:BYTE
	EXTRN	RESTDIR:BYTE
	EXTRN	RE_OUT_APP:BYTE
	EXTRN	RE_OUTSTR:BYTE
	EXTRN	SAFEPATHBUFFER:BYTE

	extrn	RStack:word

ifdef	BETA3WARN
	%out	Take this out before we ship
	EXTRN	Beta3Warned:byte
	EXTRN	TrnSeg:word
endif


DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BADDRV_PTR:WORD
	EXTRN	BADNAM_PTR:WORD
	EXTRN	COMTAB:BYTE		;AC000;
	EXTRN	extend_buf_ptr:word	;AN000;
	EXTRN	msg_disp_class:byte	;AN000;

ifdef	BETA3WARN
	%out	Take this out before we ship
	EXTRN	Beta3WarnMsg:byte
endif

TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
	EXTRN	ALLSWITCH:WORD
	EXTRN	APPEND_EXEC:BYTE	;AN041;
	EXTRN	CHKDRV:BYTE
	EXTRN	COMBUF:BYTE
	EXTRN	COMSW:WORD
	EXTRN	EXECPATH:BYTE
	EXTRN	EXEC_ADDR:DWORD
	EXTRN	FILTYP:BYTE
	EXTRN	IDLEN:BYTE
	EXTRN	KPARSE:BYTE		;AC000;
	EXTRN	PARM1:BYTE
	EXTRN	PARM2:BYTE
	EXTRN	PathPos:word
	EXTRN	RESSEG:WORD
	EXTRN	RE_INSTR:BYTE
	EXTRN	SPECDRV:BYTE
	EXTRN	SWITCHAR:BYTE
	EXTRN	switch_list:byte
        EXTRN   TRAN_TPA:WORD

        EXTRN   EXECPATH_SIZE:WORD
	EXTRN	EXECEXT_TYPE:WORD
	IF  IBM
	EXTRN	ROM_CALL:BYTE
	EXTRN	ROM_CS:WORD
	EXTRN	ROM_IP:WORD
	ENDIF

TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC byte

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	APPEND_PARSE:NEAR	;AN010;
	EXTRN	BATCOM:NEAR
	EXTRN	DOCOM1:NEAR
	EXTRN	PIPEERRSYN:NEAR
	EXTRN	TCOMMAND:NEAR

	IF	IBM
	EXTRN	ROM_EXEC:NEAR
	EXTRN	ROM_SCAN:NEAR
	ENDIF

	PUBLIC	CERROR
	PUBLIC	DRVBAD
	PUBLIC	EXTERNAL
	PUBLIC	FNDCOM
	PUBLIC	PRESCAN
	PUBLIC	SWITCH

	public	Lh_Execute			; M051


ASSUME	DS:TRANGROUP

;---------------------------
; We can get rid of this switch processing code if we can take
; care of the remaining two calls to switch, later in the file.
; However, I have not checked whether or not any other files use
; switch -- after all, it IS public!
;---------------------------

SWCOUNT EQU	6				; Length of switch_list

RETSW:
	XCHG	AX,BX				; Put switches in AX
	return

SWITCH:
	XOR	BX,BX				; Initialize - no switches set
SWLOOP:
	INVOKE	SCANOFF 			; Skip any delimiters
	CMP	AL,[SWITCHAR]			; Is it a switch specifier?
	JNZ	RETSW				; No -- we're finished
	OR	BX,fSwitch			; Indicate there is a switch specified
	INC	SI				; Skip over the switch character
	INVOKE	SCANOFF
	CMP	AL,0DH
	JZ	RETSW				; Oops
	INC	SI
; Convert lower case input to upper case
	INVOKE	UPCONV
	MOV	DI,OFFSET TRANGROUP:switch_list
	MOV	CX,SWCOUNT
	REPNE	SCASB				; Look for matching switch
	JNZ	BADSW
	MOV	AX,1
	SHL	AX,CL				; Set a bit for the switch
	OR	BX,AX
	JMP	SHORT SWLOOP

BADSW:
	JMP	SHORT SWLOOP

DRVBAD:
	MOV	DX,OFFSET TRANGROUP:BADDRV_ptr
	JMP	CERROR

externalj:
	jmp	EXTERNAL

fndcom: 					; search the internal command table
    OR	    AL,AL				; Get real length of first arg
    jz	    externalj				; If 0, it must begin with "\" so has
						;  to be external.
; barryf code starts here

ifndef NEC_98
	IF	IBM
	call	test_append			; see if APPEND installed
	je	contcom 			; not loaded

append_internal:
	mov	cl,TRANGROUP:IDLEN
	mov	ch,0
	mov	pathpos,cx
	inc	append_exec			;AN041; set APPEND to ON

	invoke	ioset				; re-direct the o'l io

	mov	SI, offset TRANGROUP:IDLEN	; address command name, DS already set
	mov	DX,-1				; set invoke function
	mov	di,offset TRANGROUP:APPEND_PARSE;AN010; Get the entry point for PARSE for APPEND
	mov	AX,0AE01H
	int	2FH				; execute command
	cmp	TRANGROUP:IDLEN,0		; execute requested
;;	je	Cmd_done
	jne	contcom
	jmp	Cmd_done

contcom:					; continue with internal scan
	ENDIF
else    ;NEC_98
	call	test_append			; see if APPEND installed
	je	contcom 			; not loaded

append_internal:
	mov	cl,TRANGROUP:IDLEN
	mov	ch,0
	mov	pathpos,cx
	inc	append_exec			;AN041; set APPEND to ON

	invoke	ioset				; re-direct the o'l io

	mov	SI, offset TRANGROUP:IDLEN	; address command name, DS already set
	mov	DX,-1				; set invoke function
	mov	di,offset TRANGROUP:APPEND_PARSE;AN010; Get the entry point for PARSE for APPEND
	mov	AX,0AE01H
	int	2FH				; execute command
	cmp	TRANGROUP:IDLEN,0		; execute requested
;;	je	Cmd_done
	jne	contcom
	jmp	Cmd_done

contcom:					; continue with internal scan
endif   ;NEC_98

; barryf code ends here

    mov     DI, OFFSET TRANGROUP:COMTAB
    XOR     CX,CX

findcom:
    mov     SI, offset TRANGROUP:IDLEN+1	; pointer to command argument
    mov     CL, [DI]				; load length of internal command
    inc     di					; advance past length
    jcxz    externalj				; if it's zero, we're out of internals
    cmp     CL, IDLEN				; that of the command argument
    jnz     abcd				; lengths not equal ==> strings not eq
    MOV     PathPos,CX				; store length of command
    repz    cmpsb

abcd:
    lahf					; save the good ol' flags
    add     DI, CX				; skip over remaining internal, if any
    mov     AL, BYTE PTR [DI]			; load drive-check indicator byte (DCIB)
    mov     [CHKDRV], AL			; save command flag byte in chkdrv
    inc     DI					; increment DI (OK, OK, I'll stop)
    mov     BX, WORD PTR [DI]			; load internal command address
    inc     DI					; skip over the puppy
    inc     DI
    mov     DX, WORD PTR [DI]			; load ptr to help msg #s
    inc     DI
    inc     DI
    sahf					; remember those flags?
    jnz     findcom				; well, if all the cmps worked...
;
; All messages get redirected.
;
    cmp     append_exec,0			;AN041; APPEND just executed?
    jnz     dont_set_io 			;AN041; Yes - this junk is already set
    invoke  ioset				; re-direct the ol' i/o

dont_set_io:					;AN041;
;
; Check for /?.  Certain commands, flagged fLimitHelp,
; respond to /? only if it is the only command-line argument.
;
    mov     ax,[COMSW]				; AX = switches after command
    or      ax,[ALLSWITCH]			; AX = all switches
    and     ax,SwitchQues
    jz      drive_check				; /? not in command line

    test    [CHKDRV],fLimitHelp
    jz      do_help				; /? allowed in combination
;
; Make sure /? is the only argument on the command line.
;
    cmp     [arg.argvcnt],2
    jne     drive_check				; /? not only arg - ignore
;
; Note:  this is all the check we need, even against things like /??.
; Our argv parser breaks /?? into two args, /? and ?.
;

do_help:

; DX = ptr to word list of msg #s, terminated by zero word

    mov     si,dx				; SI = ptr to list of msg #s
    mov     ax,NO_SUBST				; AL = no subst's code
    push    ax					; build subst block on stack

next_help_msg:
    lodsw					; AX = help msg # or zero
    or      ax,ax
    jz      help_done
    push    ax					; SS:SP = ptr to subst block
						;  (msg # and no_subst byte)
; We assume DS = SS.

    mov     dx,sp				; DS:DX = ptr to subst block
    invoke  Std_PrintF				; display help message
    pop     ax					; remove msg # from stack
    jmp     next_help_msg

help_done:
    pop     ax					; clean up stack
    jmp     TCommand

drive_check:
    test    [CHKDRV], fCheckDrive		; did we wanna check those drives?
    jz	    nocheck
    mov     AL, [PARM1] 			; parse_file_descriptor results tell
    or	    AL, [PARM2] 			; us whether those drives were OK
    cmp     AL, -1
    jnz     nocheck
    jmp     drvbad


;
; The user may have omitted the space between the command and its arguments.
; We need to copy the remainder of the user's command line into the buffer.
; Note that thisdoes not mess up the arg structure; it points into COMBUF not
; into the command line at 80.
;
nocheck:
    call    cmd_copy

switcheck:
    test    [CHKDRV], fSwitchAllowed		; Does the command take switches
    jnz     realwork				; Yes, process the command
    call    noswit				; No, check to see if any switches
    jnz     realwork				; None, process the command
    mov     msg_disp_class,parse_msg_class	;AN000; set up parse error msg class
    MOV     DX,OFFSET TranGroup:Extend_Buf_ptr	;AC000; get extended message pointer
    mov     Extend_Buf_ptr,BadSwt_ptr		;AN000; get "Invalid switch" message number
    jmp     CERROR				; Print error and chill out...
realwork:
    call    BX					; do some real work, at last

; See if we're in a batch CALL command. If we are, reprocess the command line,
; otherwise, go get another command.

Cmd_done:
    push    cs					; g  restore data segment
    pop     ds					; g
    push    ds					; g  save data segment
    mov     ds,[resseg] 			; g  get segment containing call flag
    ASSUME  ds:resgroup
    cmp     call_flag, call_in_progress 	; G  Is a call in progress?
    mov     call_flag, 0			; G  Either way, reset flag
    pop     ds					; g  get data segment back
    jz	    incall				; G
    jmp     tcommand				; chill out...

incall:
    JMP     DOCOM1

noswit:
    push    di					; Save di
    mov     di,81h				; di = ptr to command args
    mov     si,80h				; Get address of length of command args
    lodsb					; Load length
    mov     cl,al				; Move length to cl
    xor     ch,ch				; Zero ch
    mov     al,[SWITCHAR]			; al = switch character
    cmp     al,0				; Turn off ZF
    repnz   scasb				; Scan for a switch character and return
    pop     di					;  with ZF set if one was found
    ret

EXTERNAL:

ifndef NEC_98
IF IBM
	call	test_append			; check to see if append installed
	je	not_barryf			; no - truly external command
	jmp	append_internal 		; yes - go to Barryf code

not_barryf:

ENDIF
else    ;NEC_98
	call	test_append			; check to see if append installed
	je	not_barryf			; no - truly external command
	jmp	append_internal 		; yes - go to Barryf code

not_barryf:

endif   ;NEC_98

	MOV	[FILTYP],0
	MOV	DL,[SPECDRV]
	MOV	[IDLEN],DL
IF IBM
	MOV	[ROM_CALL],0
	PUSH	DX
	MOV	DX,OFFSET TRANGROUP:IDLEN
	CALL	ROM_SCAN
	POP	DX
	JNC	DO_SCAN
	INC	[ROM_CALL]
	JMP	short PostSave
DO_SCAN:
ENDIF
IF IBM
PostSave:
ENDIF

        ;
        ; when ntvdm execs via GetNextVdmCommand, execpath is already
        ; fully qualified application name. We know this because the
        ; vdminfo is filled
        ;
	; Note that EXECPATH_SIZE is used only once(the one we got it from
	; CMDGETNEXTCMD bop). And that is why we reset it everytime after
	; we have accessed it. For other executables, we do the regular
	; search(processing a batch file, for example).
	;
	; Two pieces of information we got from 32bits:
	; (1). the application full path name(in EXECPATH)
	; (2). the application file extention type(in EXECEXT_TYPE)
	;      EXECEXT_TYPE	2	-> .BAT
	;			4	-> .EXE
	;			8	-> .COM
	;			>8	-> unknown
	; for unknown extention type, we simply launch it because
	; (1). DOS doesn't impose any extention on program file.
	; (2). If we ever get here, we are sure that the program file
	;      is a valid DOS executable(otherwise, CreateProcess would
	;      have failed and we won't have any file to execute).
	;
	;

	xor	ax, ax
	xchg	ax, [EXECPATH_SIZE]		;get and set
	or	ax, ax				;do we have appname already?
	mov	ax, [EXECEXT_TYPE]		;
	jnz	execute_with_type		;yes, No search

        MOV     DI,OFFSET TRANGROUP:EXECPATH
	MOV	BYTE PTR [DI],0 		; Initialize to current directory
IF IBM
	CMP	[ROM_CALL],0
	JNZ	NeoExecute
ENDIF
	invoke	path_search			; find the mother (result in execpath)

execute_with_type:
	or	AX, AX				; did we find anything?
	je	badcomj45			; null means no (sob)
	cmp	AX, 04H 			; 04H and 08H are .exe and .com
                                                ; sixteen-bit machine ought
	jnl	execute 			; to be able to handle a SIXTEEN-BIT
						; DISPLACEMENT!!
	jmp	batcom				; 02H is .bat
BADCOMJ45:
ifdef	BETA3WARN
	JMP	BADCOM
else
	JMP	short BADCOM
endif

ASSUME	DS:TRANGROUP,ES:TRANGROUP

EXECUTE:
NeoExecute:
	invoke	IOSET
;M051
; Previously LoadHigh was jumping to the execute label above. This was wrong
;because IOSET was getting invoked twice resulting in 2 sets of redirections.
;After a close, this would still leave one open active resulting in sharing
;errors on subsequent opens of the redirected file.
;
Lh_Execute:				;M051

	MOV	ES,[TRAN_TPA]
	MOV	AH,DEALLOC
	INT	21h			; Now running in "free" space
	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP
	INC	[EXTCOM]		; Indicate external command
	MOV	[RESTDIR],0		; Since USERDIR1 is in transient, insure
					;  this flag value for re-entry to COMMAND
	MOV	SI,OFFSET TRANGROUP:EXECPATH
	MOV	DI,OFFSET RESGROUP:SAFEPATHBUFFER
	MOV	CX,LenMsgOrPathBuf
	CLD
LE_copy_loop:
	lodsb
	stosb
	cmp	al, 0
	je	LE_copy_done
	loop	LE_copy_loop
;; the program name is too long, terminate it with
;; null character. The Exec call will fail and we will print out error message
;; see command1.asm
	mov	byte ptr es:[di - 1], 0
LE_copy_done:

        MOV     DI,FCB
	MOV	SI,DI
	MOV	CX,052H 		; moving (100h-5Ch)/2 = 80h-2Eh
	REP	MOVSW			; Transfer parameters to resident header
	MOV	DX,OFFSET RESGROUP:SAFEPATHBUFFER
	PUSH	ES
	POP	DS
	ASSUME	DS:RESGROUP
	MOV	BX,OFFSET RESGROUP:EXEC_BLOCK
	MOV	AX,EXEC SHL 8
IF IBM
	TEST	[ROM_CALL],-1
	JZ	OK_EXEC
	JMP	ROM_EXEC
OK_EXEC:
ENDIF
;
; we are now running in free space.  anything we do from here on may get
; trashed.  Move the stack (also in free space) to allocated space because
; since EXEC restores the stack, somebody may trash what is on the stack.
;
	MOV	CX,ES
	MOV	SS,CX
	MOV	SP,OFFSET DATARES:RStack

ifdef	BETA3WARN
	%out	Take this out before we ship

	cmp	Beta3Warned, 0
	jne	NoWarning
	mov	Beta3Warned, 0ffh
	push	ax
	push	cx
	push	dx
	push	ds

	mov	ah, 2ah				; get date
	int	21h
	cmp	cx, 1991
	jb	nwx
	ja	bwarn

	cmp	dh, 4
	jb	nwx
bwarn:
	mov	ds, trnseg
	assume	ds:trangroup
	mov	dx, offset trangroup:Beta3WarnMsg
	mov	ah, 9
	int	21h

;	wait till a key is hit

@@:
	mov	ah, 6				; console I/O
	mov	dl, 0ffh			; Read
	int	21h
	jz	@b
nwx:
	pop	ds
	assume	ds:resgroup
	pop	dx
	pop	cx
	pop	ax
NoWarning:
endif
	JMP	[EXEC_ADDR]			; Jmp to the EXEC in the resident

	ASSUME	DS:TRANGROUP
BADCOM:
	PUSH	CS
	POP	DS
	MOV	DX,OFFSET TRANGROUP:BADNAM_ptr

CERROR:
	INVOKE	std_eprintf
	JMP	TCOMMAND

;
; Prescan converts the input buffer into a canonicalized form.	All
; redirections and pipes are removed.
;
PRESCAN:					; Cook the input buffer

ASSUME	DS:TRANGROUP,ES:TRANGROUP

	XOR	CX,CX
	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP
	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	MOV	DI,SI

CountQuotes:
	LODSB					; get a byte
	CMP	AL,22h				; is it a quote?
	JNZ	CountEnd			; no, try for end of road
	INC	CH				; bump count
	JMP	CountQuotes			; go get next char

CountEnd:
	CMP	AL,13				; end of road?
	JNZ	CountQuotes			; no, go back for next char

;;;;	IFDEF	DBCS		3/3/KK
	PUSH	CX				; save count
	MOV	SI,DI				; get back beginning of buffer

KanjiScan:
	LODSB					; get a byte
	INVOKE	TestKanj			; is it a leadin byte
	JZ	KanjiQuote			; no, check for quotes
ifdef NEC_98
if BUGFIX
        cmp     byte ptr [si],' '
        jb      kanjiQuote
endif
endif   ;NEC_98
	MOV	AH,AL				; save leadin
	LODSB					; get trailing byte
	CMP	AX,DB_SPACE			; is it Kanji space
	JNZ	KanjiScan			; no, go get next
	MOV	[SI-2],2020h			; replace with spaces
	JMP	KanjiScan			; go get next char

KanjiQuote:
	CMP	AL,22h				; beginning of quoted string
	JNZ	KanjiEnd			; no, check for end
	DEC	CH				; drop count
	JZ	KanjiScan			; if count is zero, no quoting

KanjiQuoteLoop:
	LODSB					; get next byte
	CMP	AL,22h				; is it another quote
	JNZ	KanjiQuoteLoop			; no, get another
	DEC	CH				; yes, drop count
	JMP	KanjiScan			; go get next char

KanjiEnd:
	CMP	AL,13				; end of line character?
	JNZ	KanjiScan			; go back to beginning
	POP	CX				; get back original count
;;;;	ENDIF		3/3/KK

	MOV	SI,DI				; restore pointer to begining

PRESCANLP:
	LODSB

;;;;	IFDEF	DBCS		3/3/KK
	INVOKE	TESTKANJ
	JZ	NOTKANJ6
ifdef NEC_98
if BUGFIX
        cmp     byte ptr [si],' '
        jb      NOTKANJ6
endif
endif   ;NEC_98
	MOV	[DI],AL
	INC	DI				; fake STOSB into DS
	LODSB					; grab second byte
	MOV	[DI],AL 			; fake stosb into DS
	INC	DI
	INC	CL
	INC	CL
	JMP	PRESCANLP

NOTKANJ6:
;;;;	ENDIF			3/3/KK

	CMP	AL,'"'                          ; " character
	JNZ	TRYGREATER
	DEC	CH
	JZ	TRYGREATER

QLOOP:
	MOV	[DI],AL
	INC	DI
	INC	CL
	LODSB
	CMP	AL,'"'                          ; " character
	JNZ	QLOOP
	DEC	CH

TRYGREATER:
	CMP	AL,rabracket
	JNZ	NOOUT
;
; We have found a ">" char.  We need to see if there is another ">"
; following it.
;
	CMP	BYTE PTR [SI],al
	JNZ	NOAPPND
	LODSB
	INC	[RE_OUT_APP]			; Flag >>

NOAPPND:
;
; Now we attempt to find the file name.  First, scan off all whitespace
;
	INVOKE	SCANOFF
	CMP	AL,labracket			;AN040; was there no filename?
	JZ	REOUT_ERRSET			;AN040; yes - set up error
	CMP	AL,0DH
	JNZ	GOTREOFIL
;
; There was no file present.  Set us up at end-of-line.
;
REOUT_ERRSET:					;AN040; set up for an error
	mov	byte ptr [di], 0dh		; Clobber first ">"
	MOV	WORD PTR [RE_OUTSTR],09H	; Cause an error later
	JMP	PRESCANEND

GOTREOFIL:
	PUSH	DI
	MOV	DI,OFFSET RESGROUP:RE_OUTSTR
	MOV	BX,DI
	PUSH	ES

SETREOUTSTR:					; Get the output redirection name

						; MSKK06 07/14/89
	push	cx				; save cx
	mov	cx,64+13			; CX = max string length

SETREOUTSTR_LOOP:

	LODSB
	CMP	AL,0DH
	JZ	GOTRESTR_J
	INVOKE	DELIM
	JZ	GOTRESTR_J
	CMP	AL,[SWITCHAR]
	JZ	GOTRESTR_J
	CMP	AL,'"'                          ;AN033; Is the character a quote?
	JZ	PIPEERRSYNJ5_J			;AN033; Yes - get out quick - or system crashes
	CMP	AL,labracket			;AN002; Is char for input redirection
	JZ	ABRACKET_TERM			;AN002; yes - end of string
	CMP	AL,rabracket			;AN002; Is char for output redirection
	JNZ	NO_ABRACKET			;AN002; no - not end of string

ABRACKET_TERM:					;AN002; have end of string by < or >
	DEC	SI				;AN002; back up over symbol
	MOV	AL,BLANK			;AN002; show delimiter as char
GOTRESTR_J:
	pop	cx				; MSKK06 07/14/89
	JMP	SHORT GOTRESTR			;AN002; go process it

NO_ABRACKET:					;AN002; NOT AT END OF STRING
	STOSB					; store it into resgroup

ifdef DBCS
	invoke	testkanj
	jz	@f				; if not lead byte of DBCS
	jcxz	gotrestr_j			; if no tail byte
	lodsb
	cmp	al,0dh
	jz	gotrestr_j			; if tail byte does't come and ends
	stosb					; copy tail byte
	dec	cx
@@:
endif

	LOOP	SETREOUTSTR_LOOP		; MSKK06 07/14/89
	jmp	GOTRESTR_j

PIPEERRSYNJ5_J:
	pop	cx				; recover CX
	jmp	short PIPEERRSYNJ5

NOOUT:
	CMP	AL,labracket
	JNZ	CHKPIPE
	mov	bx,si				; Save loc of "<"
	INVOKE	SCANOFF
	CMP	AL,rabracket			;AN040; was there no filename?
	JZ	REIN_ERRSET			;AN040; yes - set up error
	CMP	AL,0DH
	JNZ	GOTREIFIL

REIN_ERRSET:					;AN040; set up for error
	mov	byte ptr [di],0dh		; Clobber "<"
	MOV	WORD PTR [RE_INSTR],09H 	; Cause an error later
	JMP	SHORT PRESCANEND

GOTREIFIL:
	PUSH	DI
	MOV	DI,OFFSET TranGROUP:RE_INSTR
	MOV	BX,DI
	PUSH	ES
	PUSH	CS
	POP	ES				; store in TRANGROUP
	JMP	SHORT SETREOUTSTR		; Get the input redirection name

CHKPIPE:
	MOV	AH,AL
	CMP	AH,AltPipeChr
	JZ	IsPipe3
	CMP	AH,vbar
	JNZ	CONTPRESCAN

IsPipe3:
;
; Only push the echo flag if we are entering the pipe for the first time.
;
	CMP	PipeFlag,0
	JNZ	NoEchoPush
	SHL	EchoFlag,1			; push echo state and turn it off
NoEchoPush:
	INC	[PIPEFLAG]
	INVOKE	SCANOFF
	CMP	AL,0DH
	JZ	PIPEERRSYNJ5
	CMP	AL,AltPipeChr
	JZ	PIPEERRSYNJ5
	CMP	AL,vbar 			; Double '|'?
	JNZ	CONTPRESCAN

PIPEERRSYNJ5:
	PUSH	ES
	POP	DS				; DS->RESGROUP
	JMP	PIPEERRSYN

;
; Trailing :s are allowed on devices.  Check to be sure that there is more
; than just a :  in the redir string.
;
GOTRESTR:
	XCHG	AH,AL
	mov	al,':'
	SUB	BX,DI				; compute negatinve of number of chars
	CMP	BX,-1				; is there just a :?
	JZ	NotTrailCol			; yep, don't change
	CMP	BYTE PTR ES:[DI-1],al		; Trailing ':' OK on devices
	JNZ	NOTTRAILCOL
	DEC	DI				; Back up over trailing ':'

NOTTRAILCOL:
	XOR	AL,AL
	STOSB					; NUL terminate the string
	POP	ES
	POP	DI				; Remember the start

CONTPRESCAN:
	MOV	[DI],AH 			; "delete" the redirection string
	INC	DI
	CMP	AH,0DH
	JZ	PRESCANEND
	INC	CL
	JMP	PRESCANLP

PRESCANEND:
	CMP	[PIPEFLAG],0
	JZ	ISNOPIPE
	MOV	DI,OFFSET RESGROUP:PIPESTR
	MOV	[PIPEPTR],DI
	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	INVOKE	SCANOFF

PIPESETLP:					; Transfer the pipe into the resident
	LODSB					; pipe buffer
	STOSB
	CMP	AL,0DH
	JNZ	PIPESETLP

ISNOPIPE:
	MOV	[COMBUF+1],CL
	CMP	[PIPEFLAG],0
	PUSH	CS
	POP	ES
	return

cmd_copy  proc near

	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	INVOKE	Scanoff 			; advance past separators...
	add	si,PathPos
	mov	di,81h
	xor	cx,cx

CmdCopy:
	lodsb
	stosb
	cmp	al,0dh
	jz	CopyDone
	inc	cx
	jmp	CmdCopy

CopyDone:
	 mov	 byte ptr ds:[80h],cl		; Store count

	 ret
cmd_copy  endp


test_append	proc near

	mov	BX,offset TRANGROUP:COMBUF	;   barry can address
	mov	SI, offset TRANGROUP:IDLEN	; address command name, DS already set
	mov	DX,-1				; set install check function
	mov	AX,0AE00H
	int	2FH				; see if loaded
	cmp	AL,00H

	ret

test_append	endp

TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tmisc2.asm ===
page ,132
;	SCCSID = @(#)tmisc2.asm 4.3 85/06/25
;	SCCSID = @(#)tmisc2.asm 4.3 85/06/25
TITLE	Part7 COMMAND Transient Routines
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;	More misc routines


.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include pdb.inc
	include bpb.inc
	include sf.inc
	include comseg.asm
	include comequ.asm
	include ioctl.inc
.list
.cref


CODERES 	SEGMENT PUBLIC BYTE	;AC000;
CodeRes 	ENDS

DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	IFFlag:BYTE
	EXTRN	PIPEFLAG:BYTE
	EXTRN	RE_OUTSTR:BYTE
	EXTRN	RE_OUT_APP:BYTE
DATARES 	ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	AccDen_PTR:WORD
	EXTRN	Extend_buf_ptr:word	;AN000;
	EXTRN	FULDIR_PTR:WORD
	EXTRN	msg_disp_class:byte	;AN000;
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	DESTINFO:BYTE
	EXTRN	DESTISDIR:BYTE
	EXTRN	KPARSE:BYTE		;AC000;
	EXTRN	ONE_CHAR_VAL:BYTE	;AN011;
	EXTRN	PATHCNT:WORD
	EXTRN	PATHPOS:WORD
	EXTRN	PATHSW:WORD
	EXTRN	RE_INSTR:BYTE
	EXTRN	RESSEG:WORD
	EXTRN	SRCBUF:BYTE
	EXTRN	SWITCHAR:BYTE

	IF  IBM
	EXTRN	ROM_CALL:BYTE
	EXTRN	ROM_CS:WORD
	EXTRN	ROM_IP:WORD
	ENDIF

TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC byte

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	CERROR:NEAR

	IF	IBM
	EXTRN	ROM_EXEC:NEAR
	EXTRN	ROM_SCAN:NEAR
	ENDIF

	PUBLIC	IOSET
	PUBLIC	MOVE_TO_SRCBUF		;AN000;
	PUBLIC	PGETARG
	PUBLIC	SETPATH
	PUBLIC	TESTDOREIN
	PUBLIC	TESTDOREOUT


ASSUME	DS:TRANGROUP

SETPATH:
;
; ENTRY PathPos = ptr to string
;       PathCnt = length of string
;
; EXIT  PathPos = ptr to string after pathname
;       PathCnt = length of rest of string
;       DX = ptr to pathname in string, made ASCIIZ
;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
;
;       A null character is dropped at the end of the pathname.  If the
;       character in that spot previously was CR, it is copied into the
;       following byte.  So there must be at least two two character 
;       positions in the buffer following the pathname.
;
        MOV     AX,[PATHCNT]            ;AC000; get length of string
        MOV     SI,[PATHPOS]            ;AC000; get start of source buffer

GETPATH:
	MOV	[DESTINFO],0
        MOV     [DESTISDIR],0
        MOV     SI,[PATHPOS]            ; SI = ptr to string
        MOV     CX,[PATHCNT]            ; CX = string length
        MOV     DX,SI                   ; DX = ptr to string
        JCXZ    PATHDONE                ; string length is zero, we're done
        PUSH    CX                      ; save string length
        PUSH    SI                      ; save ptr to string
        INVOKE  SWITCH

;       After Switch, SI has been scanned past any switches, and
;       switches that COMMAND intrinsically recognizes are recorded in AX.

        MOV     [PATHSW],AX             ; PathSw = switch occurrence mask
        POP     BX                      ; BX = ptr to original string
        SUB     BX,SI                   ; BX = -(# chars scanned by Switch)
        POP     CX                      ; CX = string length
        ADD     CX,BX                   ; CX = string length from current SI
        MOV     DX,SI                   ; DX = ptr to current string

SKIPPATH:

;;;;	IFDEF	DBCS	3/3/KK
	MOV	[KPARSE],0

SKIPPATH2:
;;;;	ENDIF		3/3/KK

        JCXZ    PATHDONE                ; string length is zero, we're done
        DEC     CX                      ; CX = length left after next char
        LODSB                           ; AL = next char of string
                                        ; SI = ptr to char after this one

;;;;	IFDEF	DBCS	3/3/KK
	INVOKE	TESTKANJ
        JZ      TESTPPSEP               ; no Kanji, move along
	DEC	CX
	INC	SI
	INC	[KPARSE]
	JMP	SKIPPATH2

TESTPPSEP:
;;;;	ENDIF		3/3/KK

        INVOKE  PATHCHRCMP              ; compare AL to path delimiter char
        JNZ     TESTPMETA               ; it's not a path delim
        INC     [DESTISDIR]             ; DestIsDir = 1, signalling path char

TESTPMETA:
        CMP     AL,'?'
        JNZ     TESTPSTAR               ; char is not '?'
        OR      [DESTINFO],2            ; DestInfo = 2, signalling wildcard

TESTPSTAR:
        CMP     AL,star
        JNZ     TESTPDELIM              ; char is not '*'
        OR      [DESTINFO],2            ; DestInfo = 2, signalling wildcard

TESTPDELIM:
        INVOKE  DELIM                   ; compare AL to all delimiters
        JZ      PATHDONEDEC             ; delimiter found, back up & leave
        CMP     AL,[SWITCHAR]
        JNZ     SKIPPATH                ; char isn't switch, go get next char

PATHDONEDEC:
        DEC     SI                      ; SI = ptr to char after pathname

PATHDONE:
        XOR     AL,AL                   ; AL = NULL
        XCHG    AL,[SI]                 ; place NULL after pathname
        INC     SI                      ; SI = ptr to byte after NULL
        CMP     AL,0DH                  ; were we at end of line?
        JNZ     NOPSTORE                ; not EOL, finish up
        MOV     [SI],AL                 ; save EOL after NULL

NOPSTORE:
        MOV     [PATHPOS],SI            ; PathPos = ptr to char after NULL
        MOV     [PATHCNT],CX            ; PathCnt = length of string left
        return

PGETARG:
	MOV	SI,80H
	LODSB
	OR	AL,AL
	retz
	CALL	PSCANOFF
	CMP	AL,13
	return

PSCANOFF:
	LODSB
	INVOKE	DELIM
	JNZ	PSCANOFFD
	CMP	AL,';'
	JNZ	PSCANOFF			; ';' is not a delimiter

PSCANOFFD:
	DEC	SI				; Point to first non-delimiter
	return

IOSET:
;
; ALL REGISTERS PRESERVED
;
ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	PUSH	DS
	PUSH	DX
	PUSH	AX
	PUSH	BX
	PUSH	CX
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP

	CMP	[PIPEFLAG],0
	JNZ	NOREDIR 			; Don't muck up the pipe
	TEST	IFFlag,-1
	JNZ	NoRedir
	CALL	TESTDOREIN
	CALL	TESTDOREOUT

NOREDIR:
	POP	CX
	POP	BX
	POP	AX
	POP	DX
	POP	DS
ASSUME	DS:NOTHING
	return

TESTDOREIN:

ASSUME	DS:RESGROUP

	CMP	[RE_INSTR],0
	retz
	PUSH	DS
	PUSH	CS
	POP	DS
	MOV	DX,OFFSET tranGROUP:RE_INSTR
	MOV	AX,(OPEN SHL 8)
	MOV	BX,AX
	INT	21h
	POP	DS
	JC	REDIRERR
	MOV	BX,AX
	MOV	AL,0FFH
;
; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
; spot.  We invalidate the new JFN we got.
;
	XCHG	AL,[BX.PDB_JFN_Table]
	MOV	DS:[PDB_JFN_Table],AL

	return
;
; We had some kind of error on the redirection.  Figure out what the
; appropriate message should be; BX has the system call that failed
;
REDIRERR:
	PUSH	CS
	POP	DS
	Call	TriageError
;
; At this point, we have recognized the network-generated access denied error.
; The correct message is in DX
;
	CMP	AX,65
	JZ	CERRORJ 			;AC000; just issue message returned
	CMP	BH,OPEN
	JZ	OpenError
;
; The error was for a create operation.  Report the error as a creation error.
;
	MOV	DX,OFFSET TranGroup:FULDIR_PTR

CERRORJ:
	JMP	CERROR
;
; The system call was an OPEN.	Report either file not found or path not found.
;

OpenError:
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,ax		;AN000; get message number in control block
	JMP	CERROR

TESTDOREOUT:

ASSUME	DS:RESGROUP

	CMP	[RE_OUTSTR],0
	JNZ	REOUTEXISTS			;AN017; need long jump
	JMP	NOREOUT 			;AN017;

REOUTEXISTS:
	CMP	[RE_OUT_APP],0
	JZ	REOUTCRT
;
; The output redirection was for append.  We open for write and seek to the
; end.
;
	MOV	DX,OFFSET RESGROUP:RE_OUTSTR
	MOV	AX,(OPEN SHL 8) OR 2		;AC011; Open for read/write
	PUSH	AX
	INT	21h
	POP	BX
	JC	OpenWriteError

	MOV	BX,AX
	MOV	AX,IOCTL SHL 8			;AN035; Get attributes of handle
	INT	21h			;AN035;
	TEST	DL,devid_ISDEV			;AN035; Is it a device?
	JNZ	SET_REOUT			;AN035; Yes, don't read from it

	MOV	AX,(LSEEK SHL 8) OR 2
	MOV	CX,-1				;AC011; MOVE TO EOF -1
	MOV	DX,CX				;AC011;
	INT	21h
	PUSH	CS				;AN011; Get transient seg to DS
	POP	DS				;AN011;
	assume	DS:Trangroup			;AN011;
	MOV	AX,(READ SHL 8) 		;AN011; Read one byte from the
	MOV	CX,1				;AN011;   file into one_char_val
	MOV	DX,OFFSET Trangroup:ONE_CHAR_VAL;AN011;
	INT	21h			;AN011;
	JC	OpenWriteError			;AN011; If error, exit
	cmp	ax,cx				;AN017; Did we read 1 byte?
	jnz	reout_0_length			;AN017; No - file must be 0 length

	cmp	one_char_val,01ah		;AN011; Was char an eof mark?
	mov	DS,[resseg]			;AN011; Get resident segment back
	assume	DS:Resgroup			;AN011;
	JNZ	SET_REOUT			;AN011; No, just continue
	MOV	AX,(LSEEK SHL 8) OR 1		;AN011; EOF mark found
	MOV	CX,-1				;AN011; LSEEK back one byte
	MOV	DX,CX				;AN011;
	INT	21h			;AN011;
	JMP	SHORT SET_REOUT

reout_0_length: 				;AN017; We have a 0 length file
	mov	DS,[resseg]			;AN017; Get resident segment back
	assume	DS:Resgroup			;AN017;
	MOV	AX,(LSEEK SHL 8)		;AN017; Move to beginning of file
	XOR	CX,CX				;AN017; Offset is 0
	MOV	DX,CX				;AN017;
	INT	21h			;AN017;
	JMP	SHORT SET_REOUT 		;AN017; now finish setting up redirection

OpenWriteError:
	CMP	AX,error_access_denied
	STC					; preserve error
	JNZ	REOUTCRT			;AN017; need long jump
	JMP	REDIRERR			;AN017;

REOUTCRT:
	MOV	DX,OFFSET RESGROUP:RE_OUTSTR
	XOR	CX,CX
	MOV	AH,CREAT
	PUSH	AX
	INT	21h
	POP	BX
	JNC	NOREDIRERR			;AC011;
	JMP	REDIRERR			;AC011;

NOREDIRERR:					;AN011;
	MOV	BX,AX

SET_REOUT:
;
; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
; spot.  We invalidate the new JFN we got.
;
	MOV	AL,0FFH
	XCHG	AL,[BX.PDB_JFN_Table]
	MOV	DS:[PDB_JFN_Table+1],AL

NOREOUT:
	return

;
; Compute length of string (including NUL) in DS:SI into CX.  Change no other
; registers
;
Procedure   DSTRLEN,NEAR

	SaveReg <AX>
	XOR	CX,CX
	CLD

DLoop:	LODSB
	INC	CX
	OR	AL,AL
	JNZ	DLoop
	SUB	SI,CX
	RestoreReg  <AX>
	return

EndProc DSTRLEN

Break	<Extended error support>

;
; TriageError will examine the return from a carry-set system call and
; return the correct error if applicable.
;
;   Inputs:	outputs from a carry-settable system call
;		No system calls may be done in the interrim
;   Outputs:	If carry was set on input
;		    carry set on output
;		    DX contains trangroup offset to printf message
;		else
;		    No registers changed
;

Procedure TriageError,NEAR

	retnc					; no carry => do nothing...
	PUSHF
	SaveReg <BX,CX,SI,DI,BP,ES,DS,AX,DX>
	MOV	AH,GetExtendedError
	INT	21h
	RestoreReg  <CX,BX>			; restore original AX
	MOV	DX,OFFSET TranGroup:AccDen_PTR
	CMP	AX,65				; network access denied?
	JZ	NoMove				; Yes, return it.
	MOV	AX,BX
	MOV	DX,CX

NoMove:
	RestoreReg  <DS,ES,BP,DI,SI,CX,BX>
	popf
	return

EndProc TriageError

PUBLIC Triage_Init
Triage_Init proc FAR
	call	TriageError
	ret
Triage_Init endp


; ****************************************************************
; *
; * ROUTINE:	 MOVE_TO_SRCBUF
; *
; * FUNCTION:	 Move ASCIIZ string from DS:SI to SRCBUF.  Change
; *		 terminating 0 to 0dH.	Set PATHCNT to length of
; *		 string.  Set PATHPOS to start of SRCBUF.
; *
; * INPUT:	 DS:SI points to ASCIIZ string
; *		 ES    points to TRANGROUP
; *
; * OUTPUT:	 SRCBUF filled in with string terminated by 0dH
; *		 PATHCNT set to length of string
; *		 PATHPOS set to start of SRCBUF
; *		 CX,AX	 changed
; *
; ****************************************************************

assume	es:trangroup,ds:nothing 		;AN000;

MOVE_TO_SRCBUF	PROC	NEAR			;AN000;

	push	si				;AN000;  save si,di
	push	di				;AN000;
	push	cx				;AN000;
	mov	di,offset TRANGROUP:srcbuf	;AN000;  set ES:DI to srcbuf
	xor	cx,cx				;AN000; clear cx for counint
	mov	ax,cx				;AN000; clear ax
	push	di				;AN000; save start of srcbuf
	lodsb					;AN000; get a character from DS:SI

mts_get_chars:					;AN000;
	cmp	al,0				;AN000; was it a null char?
	jz	mts_end_string			;AN000; yes - exit
	stosb					;AN000; no - store it in srcbuf
	inc	cx				;AN000; increment length count
	lodsb					;AN000; get a character from DS:SI
	jmp	short mts_get_chars		;AN000; go check it

mts_end_string: 				;AN000; we've reached the end of line
	mov	al,end_of_line_in		;AN000; store 0dH in srcbuf
	stosb					;AN000;
	pop	di				;AN000; restore start of srcbuf

	push	cs				;AN000; set DS to local segment
	pop	ds				;AN000;
assume	ds:trangroup				;AN000;
	mov	[pathcnt],cx			;AN000; set patchcnt to length count
	mov	[pathpos],di			;AN000; set pathpos to start of srcbuf
	pop	cx				;AN000; restore cx,di,si
	pop	di				;AN000;
	pop	si				;AN000;

	RET					;AN000; exit

MOVE_TO_SRCBUF	ENDP				;AN000;

TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tparse.asm ===
page ,132
;	SCCSID = @(#)tparse.asm 4.1 87/04/28
;	SCCSID = @(#)tparse.asm 4.1 87/04/28
TITLE	COMMAND interface to SYSPARSE
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

.xlist
.xcref
	include comsw.asm
	include comseg.asm		;an000;
.list
.cref

TRANSPACE	SEGMENT PUBLIC BYTE	;AN000;

	CmpxSW	equ	0		;AN000; do not check complex list
	KeySW	equ	0		;AN000; do not support keywords
	Val2SW	equ	0		;AN000; do not Support value definition 2
	IncSW	equ	0		;AN000; do not include psdata.inc
	QusSW	equ	0		;AN025; do not include quoted string
	LFEOLSW equ	0		;AN044; do not use 0ah as line terminator

.xlist
.xcref

include psdata.inc			;AN000;

.list
.cref

TRANSPACE	ENDS			;AN000;

TRANCODE	SEGMENT PUBLIC BYTE	;AN000;

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING	 ;AN054;

; ****************************************************************
; *
; * ROUTINE:	 CMD_PARSE
; *
; * FUNCTION:	 Interface for transient COMMAND to invoke
; *		 SYSPARSE.
; *
; * INPUT:	 inputs to SYSPARSE
; *
; * OUTPUT:	 outputs from SYSPARSE
; *
; ****************************************************************

	public	Cmd_parse		;AN000;

.xlist
.xcref
	INCLUDE parse.asm		;AN000;
.list
.cref

Cmd_parse	Proc  near		;AN000;

	call	sysparse		;AN000;

	ret				;AN000;

Cmd_parse	endp			;AN000;

	public	Append_parse		;AN010;

Append_parse	Proc  Far		;AN010;

	call	sysparse		;AN010;

	ret				;AN010;

Append_parse	endp			;AN010;

trancode    ends			;AN000;
	    end 			;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tdata.asm ===
page ,132
;	SCCSID = @(#)tdata.asm	4.3 85/05/17
;	SCCSID = @(#)tdata.asm	4.3 85/05/17
TITLE	COMMAND Transient Initialized DATA
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

; MODIFICATION HISTORY
;
;	EE 10-20-83	Changed the drive check indicator bytes (DCIB's) in
;			COMTAB to be a flag byte in which bit 0 is now the
;			DCIB(bit) and bit 1 is on if the command can take
;			switches.
;
;	M003	SR	07/16/90 	Added LoadHigh to command table, added
;					parse control block for LoadHigh
;
;	M008	SA	8/1/90		Remove /h parameter. Eliminate code to
;					internally handle /? message.
;
;	M010	SA	8/5/90		Add support for /l (lowercase) option.
;
;	M016	SR	08/09/90	Added public statements for new error
;				messages for LoadHigh.
;



comment %

The TRANDATA segment contains data that is assumed to have predefined
initial values at the beginning of each command cycle.  It is
included in the transient checksum area.  If values in TRANDATA
change, the transient will be reloaded for the next command cycle.

Modification History
--------------------

8/12/89         DBO     History resumes after six years.

8/12/89         DBO     Added for new DIR:
-8/14/89                DirEnvVar, AttrLtrs, OrderLtrs;
                        New PARSE_DIR and subordinate parse blocks
                        (called PARSE_DIR_E for now);

%




fmt macro   name,string,args
	local	a
a	db  string
PUBLIC	name
name	dw  offset trangroup:a
irp val,<args>
	dw  offset trangroup:val
endm
endm

btab	macro	b,sym
    db	b
    dw	    offset trangroup:sym
    endm

.xlist
.xcref
	INCLUDE comsw.asm				;AC000;
	INCLUDE comseg.asm
	INCLUDE dirent.inc				;AN042;
.list
.cref

BREAK	MACRO	subtitle
	SUBTTL	subtitle
	PAGE
ENDM

;
; WARNING: DO NOT INCLUDE DOSSYM.INC BECAUSE IT DESTROYS THE MACRO 'FMT' THAT
; has been defined above - RS.
;
	INCLUDE ERROR.INC
	INCLUDE ifequ.asm
	INCLUDE comequ.asm
;	Note curdir.inc is included by comequ.asm

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg_buf:BYTE
	EXTRN	bwdbuf:byte
	EXTRN	bytes_free:WORD
	EXTRN	charbuf:byte
	EXTRN	copy_Num:WORD
	EXTRN	DATE_OUTPUT:BYTE	;AC000;
	EXTRN	Dir_Num:WORD
	EXTRN	DRIVE_OUTPUT:BYTE	;AC000;
	EXTRN	file_size_high:WORD
	EXTRN	file_size_low:WORD
        EXTRN   FileSiz:DWORD           ; accumulated file size for DIR
	EXTRN	major_ver_num:WORD
	EXTRN	minor_ver_num:WORD
	EXTRN	one_char_val:BYTE
	EXTRN	PARSE1_OUTPUT:BYTE	;AC000;
	EXTRN	srcbuf:byte
	EXTRN	string_ptr_2:WORD
	EXTRN	system_cpage:word
	EXTRN	TIME_OUTPUT:BYTE	;AC000;
	EXTRN	vol_drv:BYTE
	EXTRN	vol_serial:dword	;AN000;
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	$CALL:NEAR
	EXTRN	$CHDIR:NEAR
	EXTRN	$EXIT:NEAR
	EXTRN	$FOR:NEAR
	EXTRN	$IF:NEAR
	EXTRN	$MKDIR:NEAR
	EXTRN	$RMDIR:NEAR
	EXTRN	ADD_NAME_TO_ENVIRONMENT:NEAR
	EXTRN	ADD_PROMPT:NEAR
	EXTRN	build_dir_for_prompt:near
	EXTRN	CATALOG:NEAR
	EXTRN	CHCP:NEAR
	EXTRN	CLS:NEAR
	EXTRN	CNTRLC:NEAR
	EXTRN	COPY:NEAR
	EXTRN	CRENAME:NEAR
	EXTRN	CRLF2:NEAR
	EXTRN	CTIME:NEAR
	EXTRN	CTTY:NEAR
	EXTRN	DATE:NEAR
	EXTRN	ECHO:NEAR
	EXTRN	ERASE:NEAR
	EXTRN	GOTO:NEAR
	EXTRN	IFERLEV:NEAR
	EXTRN	IFEXISTS:NEAR
	EXTRN	IFNOT:NEAR
	EXTRN	PATH:NEAR
	EXTRN	PAUSE:NEAR
	EXTRN	PRINT_B:NEAR
	EXTRN	PRINT_BACK:NEAR
	EXTRN	PRINT_DATE:NEAR
	EXTRN	PRINT_CHAR:NEAR
	EXTRN	PRINT_DRIVE:NEAR
	EXTRN	PRINT_EQ:NEAR
	EXTRN	PRINT_ESC:NEAR
	EXTRN	PRINT_G:NEAR
	EXTRN	PRINT_L:NEAR
	EXTRN	PRINT_TIME:NEAR
	EXTRN	PRINT_VERSION:NEAR
	EXTRN	SHIFT:NEAR
	EXTRN	TCOMMAND:NEAR
	EXTRN	TRUENAME:NEAR		;AN000;
	EXTRN	TYPEFIL:NEAR
	EXTRN	VERSION:NEAR
	EXTRN	VOLUME:NEAR
	EXTRN	VERIFY:NEAR

	extrn	LoadHigh:NEAR		; M003
;
; WARNING!!! No code may appear after this label!!!!
;
;
; Bugbug:
;   8/12/89 Looks like somebody ignored/missed this warning.  TRANCODE
;           is added to at the end of this file.  Fortunately, it looks
;           like no modules refer to this label.
;
PUBLIC	TranCodeLast
TranCodeLast	LABEL	BYTE
TRANCODE	ENDS

; Data for transient portion

TRANDATA	SEGMENT PUBLIC BYTE

	PUBLIC	accden_ptr		;AN000;
	PUBLIC	acrlf_ptr		;AN000;
	PUBLIC	arg_buf_ptr		;AN000;
        PUBLIC  AttrLtrs
	PUBLIC	badbat_ptr		;AN000;
	PUBLIC	badcd_ptr		;AN000;
	PUBLIC	badCPmes_ptr		;AN000;
	PUBLIC	badcurdrv		;AN000;
	PUBLIC	baddat_ptr		;AN000;
	PUBLIC	baddev_ptr		;AN000;
	PUBLIC	baddrv_ptr		;AN000;
	PUBLIC	badlab_ptr		;AN000;
	PUBLIC	badmkd_ptr		;AN000;
	PUBLIC	badnam_ptr		;AN000;
	PUBLIC	bad_on_off_ptr		;AN000;
	PUBLIC	badPmes_ptr		;AN000;
	PUBLIC	badrmd_ptr		;AN000;
	PUBLIC	badtim_ptr		;AN000;
	PUBLIC	batext
        PUBLIC  bytes_ptr
	PUBLIC	bytmes_ptr		;AN000;
	PUBLIC	CLSSTRING
	PUBLIC	comext
        PUBLIC  comspec_flag            ;AN071;
	PUBLIC	COMSPECSTR
	PUBLIC	COMTAB
	PUBLIC	copied_ptr		;AN000;
	PUBLIC	cp_active_ptr		;AN000;
	PUBLIC	cp_not_all_ptr		;AN000;
	PUBLIC	cp_not_set_ptr		;AN000;
	PUBLIC	ctrlcmes_ptr		;AN000;
	PUBLIC	curdat_mo_day		;AN000;
	PUBLIC	curdat_ptr		;AN000;
	PUBLIC	curdat_yr		;AN000;
	PUBLIC	curtim_hr_min		;AN000;
	PUBLIC	curtim_ptr		;AN000;
	PUBLIC	curtim_sec_hn		;AN000;
	PUBLIC	dback_ptr		;AN000;
	PUBLIC	del_Y_N_ptr		;AN000;
	PUBLIC	devwmes_ptr		;AN000;
        PUBLIC  dircont_ptr
	PUBLIC	dirdattim_ptr		;AN000;
	PUBLIC	dirdat_mo_day		;AN000;
	PUBLIC	dirdat_yr		;AN000;
        PUBLIC  DirEnvVar
	PUBLIC	dirhead_ptr		;AN000;
	PUBLIC	dirmes_ptr		;AN000;
	PUBLIC	dirtim_hr_min		;AN000;
	PUBLIC	dirtim_sec_hn		;AN000;
        PUBLIC  DIR_SW_PTRS
	PUBLIC	disp_file_size_ptr	;AN000;
	PUBLIC	DosHma_Ptr
	PUBLIC	DosLow_Ptr
	PUBLIC	DosRev_Ptr
	PUBLIC	DosRom_Ptr
	PUBLIC	dmes_ptr		;AN000;
	PUBLIC	echomes_ptr		;AN000;
	PUBLIC	enverr_ptr		;AN000;
        PUBLIC  errparsenv_ptr
	PUBLIC	eurdat_ptr		;AN000;
	PUBLIC	exeext
	PUBLIC	extend_buf_off		;AN000;
	PUBLIC	extend_buf_ptr		;AN000;
	PUBLIC	extend_buf_seg		;AN000;
	PUBLIC	extend_buf_sub		;AN000;
	PUBLIC	file_name_ptr		;AN000;
	PUBLIC	fornestmes_ptr		;AN000;
	PUBLIC	fuldir_ptr		;AN000;
	PUBLIC	IFTAB
	PUBLIC	inBdev_ptr		;AN000;
	PUBLIC	inornot_ptr		;AN000;
	PUBLIC	Inv_code_page		;AN000;
	PUBLIC	inval_path_ptr		;AN000;
	PUBLIC	japdat_ptr		;AN000;
	PUBLIC	Losterr_ptr		;AN000;
	PUBLIC	md_exists_ptr		;AN006;
	PUBLIC	msg_cont_flag		;AN000;
	PUBLIC	msg_disp_class		;AN000;
	PUBLIC	needbat_ptr		;AN000;
	PUBLIC	newdat_format		;AN000;
	PUBLIC	newdat_ptr		;AN000;
	PUBLIC	newtim_ptr		;AN000;
	PUBLIC	NLSFUNC_ptr		;AN000;
	PUBLIC	nospace_ptr		;AN000;
	PUBLIC	no_values		;AN000;
	PUBLIC	nulpath_ptr		;AN000;
	PUBLIC	offmes_ptr		;AN000;
	PUBLIC	onmes_ptr		;AN000;
        PUBLIC  OrderLtrs               ; list of sort order letters for DIR
	PUBLIC	overwr_ptr		;AN000;
	PUBLIC	PARSE_BREAK		;AN000;
	PUBLIC	PARSE_CHCP		;AN000;
	PUBLIC	PARSE_CHDIR		;AN000;
	PUBLIC	PARSE_CTTY		;AN000;
	PUBLIC	PARSE_DATE		;AN000;
	PUBLIC	PARSE_DIR		;AN000;
	PUBLIC	PARSE_ERASE		;AN000;
	PUBLIC	PARSE_MRDIR		;AN000;
	PUBLIC	PARSE_RENAME		;AN000;
	PUBLIC	PARSE_TIME		;AN000;
	PUBLIC	PARSE_VER
	PUBLIC	PARSE_VOL		;AN000;

	public	Parse_LoadHi		; Parse block for LoadHigh; M003

	PUBLIC	PATH_TEXT
	PUBLIC	pausemes_ptr		;AN000;
	PUBLIC	pipeEmes_ptr		;AN000;
	PUBLIC	promptdat_moday 	;AN000;
	PUBLIC	promptdat_ptr		;AN000;
	PUBLIC	promptdat_yr		;AN000;
	PUBLIC	PROMPT_TABLE
	PUBLIC	PROMPT_TEXT
	PUBLIC	promtim_hr_min		;AN000;
	PUBLIC	promtim_ptr		;AN000;
	PUBLIC	promtim_sec_hn		;AN000;
	PUBLIC	renerr_ptr		;AN000;
	PUBLIC	SLASH_P_SYN		;AN000;
	PUBLIC	string_buf_ptr		;AN000;
	PUBLIC	suremes_ptr		;AN000;
	PUBLIC	switch_list
	PUBLIC	syntmes_ptr		;AN000;
	PUBLIC	tab_ptr 		;AN000;
        PUBLIC  total_ptr
	PUBLIC	TRANDATAEND
	PUBLIC	usadat_ptr		;AN000;
	PUBLIC	verimes_ptr		;AN000;
	PUBLIC	vermes_ptr		;AN000;
	PUBLIC	volmes_ptr		;AN000;
	PUBLIC	volmes_ptr_2		;AN000;
	PUBLIC	volsermes_ptr		;AN000;
	PUBLIC	WEEKTAB

	public	NoExecBat_Ptr		; M016
	public	LhInvFil_Ptr		; M016
	public	NoCntry_Ptr		; M045

INCLUDE tranmsg.asm

; Lists of help message numbers for internal commands and /?

;;NoHelpMsgs	dw	1200,0		;M014
BreakHelpMsgs	dw	1300,0
ChcpHelpMsgs	dw	1320,1321,0
CdHelpMsgs	dw	1340,1341,1342,0
ClsHelpMsgs	dw	1360,0
CopyHelpMsgs	dw	1400,1401,1402,1403,1404,0
CttyHelpMsgs	dw	1420,0
DateHelpMsgs	dw	1440,1441,0
DelHelpMsgs	dw	1460,1461,1462,0
DirHelpMsgs	dw	1480,1481,1482,1483,1484,1485,1486,1487,1488,0
ExitHelpMsgs	dw	1500,0
MdHelpMsgs	dw	1520,0
PathHelpMsgs	dw	1540,1541,1542,0
PromptHelpMsgs	dw	1560,1561,1562,1563,1564,1565,1566,1567,1568,0
RdHelpMsgs	dw	1580,0
RenHelpMsgs	dw	1600,1601,1602,0
SetHelpMsgs	dw	1620,1621,1622,0
TimeHelpMsgs	dw	1640,1641,0
TypeHelpMsgs	dw	1660,0
VerHelpMsgs	dw	1680,0
VerifyHelpMsgs	dw	1700,0
VolHelpMsgs	dw	1720,0

CallHelpMsgs	dw	1740,1741,0	;M014
RemHelpMsgs	dw	1760,0		;M014
PauseHelpMsgs	dw	1780,0		;M014
EchoHelpMsgs	dw	1800,1801,0	;M014
GotoHelpMsgs	dw	1820,1821,0	;M014
ShiftHelpMsgs	dw	1840,0		;M014
IfHelpMsgs	dw	1860,1861,1862,1863,1864,1865,1866,0	;M014
ForHelpMsgs	dw	1880,1881,1882,1883,0	;M014
TruenameHelpMsgs dw	1900,0			;M014
LoadhighHelpMsgs dw	1920,1921,1922,0	;M014


CLSSTRING DB	4,01BH,"[2J"            ; ANSI Clear screen

PROMPT_TABLE LABEL BYTE
	btab	"B",Print_B
	btab	"D",PRINT_DATE
	btab	"E",PRINT_ESC
	btab	"G",PRINT_G
	btab	"H",PRINT_BACK
	btab	"L",PRINT_L
	btab	"N",PRINT_DRIVE
	btab	"P",build_dir_for_prompt
	btab	"Q",PRINT_EQ
	btab	"T",PRINT_TIME
	btab	"V",PRINT_VERSION
	btab	"_",CRLF2
	btab	"$",PRINT_CHAR
	DB	0				; NUL TERMINATED

IFTAB	LABEL	BYTE				; Table of IF conditionals
	DB	3,"NOT"                         ; First byte is count
	DW	OFFSET TRANGROUP:IFNOT
	DB	10,"ERRORLEVEL"
	DW	OFFSET TRANGROUP:IFERLEV
	DB	5,"EXIST"
	DW	OFFSET TRANGROUP:IFEXISTS
	DB	0

; Table for internal command names
COMTAB	DB	3,"DIR",fSwitchAllowed+fCheckDrive
	DW	OFFSET TRANGROUP:CATALOG	; In TCMD1.ASM
	DW	TRANGROUP:DirHelpMsgs
	DB	4,"CALL",fSwitchAllowed
	DW	OFFSET TRANGROUP:$CALL		; In TBATCH2.ASM
	DW	TRANGROUP:CallHelpMsgs
ifndef NEC_98
	DB	4,"CHCP",fSwitchAllowed
else    ;NEC_98
        DB      4,"    ",fSwitchAllowed         ; NEC01 91/07/29 CHCP Command DEL
endif   ;NEC_98
	DW	OFFSET TRANGROUP:CHCP		; In TCMD2B.ASM
	DW	TRANGROUP:ChcpHelpMsgs
	DB	6,"RENAME",fSwitchAllowed+fCheckDrive  ;AC018; P3903
	DW	OFFSET TRANGROUP:CRENAME	; In TCMD1.ASM
	DW	TRANGROUP:RenHelpMsgs
	DB	3,"REN",fSwitchAllowed+fCheckDrive     ;AC018; P3903
	DW	OFFSET TRANGROUP:CRENAME	; In TCMD1.ASM
	DW	TRANGROUP:RenHelpMsgs
	DB	5,"ERASE",fSwitchAllowed+fCheckDrive
	DW	OFFSET TRANGROUP:ERASE		; In TCMD1.ASM
	DW	TRANGROUP:DelHelpMsgs
	DB	3,"DEL",fSwitchAllowed+fCheckDrive
	DW	OFFSET TRANGROUP:ERASE		; In TCMD1.ASM
	DW	TRANGROUP:DelHelpMsgs
	DB	4,"TYPE",fSwitchAllowed+fCheckDrive  ;AC018; P3903
	DW	OFFSET TRANGROUP:TYPEFIL	; In TCMD1.ASM
	DW	TRANGROUP:TypeHelpMsgs
	DB	3,"REM",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:TCOMMAND	; In TCODE.ASM
	DW	TRANGROUP:RemHelpMsgs
	DB	4,"COPY",fSwitchAllowed+fCheckDrive
	DW	OFFSET TRANGROUP:COPY		; In COPY.ASM
	DW	TRANGROUP:CopyHelpMsgs
	DB	5,"PAUSE",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:PAUSE		; In TCMD1.ASM
	DW	TRANGROUP:PauseHelpMsgs
	DB	4,"DATE",fSwitchAllowed
	DW	OFFSET TRANGROUP:DATE		; In TPIPE.ASM
	DW	TRANGROUP:DateHelpMsgs
	DB	4,"TIME",fSwitchAllowed         ;AC018; P3903
	DW	OFFSET TRANGROUP:CTIME		; In TPIPE.ASM
	DW	TRANGROUP:TimeHelpMsgs
	DB	3,"VER",fSwitchAllowed
	DW	OFFSET TRANGROUP:VERSION	; In TCMD2.ASM
	DW	TRANGROUP:VerHelpMsgs
	DB	3,"VOL",fSwitchAllowed+fCheckDrive   ;AC018; P3903
	DW	OFFSET TRANGROUP:VOLUME 	; In TCMD1.ASM
	DW	TRANGROUP:VolHelpMsgs
	DB	2,"CD",fSwitchAllowed+fCheckDrive    ;AC018; P3903
	DW	OFFSET TRANGROUP:$CHDIR 	; In TENV.ASM
	DW	TRANGROUP:CdHelpMsgs
	DB	5,"CHDIR",fSwitchAllowed+fCheckDrive ;AC018; P3903
	DW	OFFSET TRANGROUP:$CHDIR 	; In TENV.ASM
	DW	TRANGROUP:CdHelpMsgs
	DB	2,"MD",fSwitchAllowed+fCheckDrive    ;AC018; P3903
	DW	OFFSET TRANGROUP:$MKDIR 	; In TENV.ASM
	DW	TRANGROUP:MdHelpMsgs
	DB	5,"MKDIR",fSwitchAllowed+fCheckDrive ;AC018; P3903
	DW	OFFSET TRANGROUP:$MKDIR 	; In TENV.ASM
	DW	TRANGROUP:MdHelpMsgs
	DB	2,"RD",fSwitchAllowed+fCheckDrive    ;AC018; P3903
	DW	OFFSET TRANGROUP:$RMDIR 	; In TENV.ASM
	DW	TRANGROUP:RdHelpMsgs
	DB	5,"RMDIR",fSwitchAllowed+fCheckDrive ;AC018; P3903
	DW	OFFSET TRANGROUP:$RMDIR 	; In TENV.ASM
	DW	TRANGROUP:RdHelpMsgs
	DB	5,"BREAK",fSwitchAllowed        ;AC018; P3903
	DW	OFFSET TRANGROUP:CNTRLC 	; In TUCODE.ASM
	DW	TRANGROUP:BreakHelpMsgs
	DB	6,"VERIFY",fSwitchAllowed       ;AC018; P3903
	DW	OFFSET TRANGROUP:VERIFY 	; In TUCODE.ASM
	DW	TRANGROUP:VerifyHelpMsgs
	DB	3,"SET",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:ADD_NAME_TO_ENVIRONMENT; In TENV.ASM
	DW	TRANGROUP:SetHelpMsgs
	DB	6,"PROMPT",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:ADD_PROMPT	; In TENV.ASM
	DW	TRANGROUP:PromptHelpMsgs
	DB	4,"PATH",fSwitchAllowed
	DW	OFFSET TRANGROUP:PATH		; In TCMD2.ASM
	DW	TRANGROUP:PathHelpMsgs
	DB	4,"EXIT",0
	DW	OFFSET TRANGROUP:$EXIT		; In TCMD2.ASM
	DW	TRANGROUP:ExitHelpMsgs
	DB	4,"CTTY",fCheckDrive+fSwitchAllowed
	DW	OFFSET TRANGROUP:CTTY		; In TCMD2.ASM
	DW	TRANGROUP:CttyHelpMsgs
	DB	4,"ECHO",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:ECHO		; In TUCODE.ASM
	DW	TRANGROUP:EchoHelpMsgs
	DB	4,"GOTO",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:GOTO		; In TBATCH.ASM
	DW	TRANGROUP:GotoHelpMsgs
	DB	5,"SHIFT",fSwitchAllowed
	DW	OFFSET TRANGROUP:SHIFT		; In TBATCH.ASM
	DW	TRANGROUP:ShiftHelpMsgs
	DB	2,"IF",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:$IF		; In TBATCH.ASM
	DW	TRANGROUP:IfHelpMsgs
	DB	3,"FOR",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:$FOR		; In TBATCH.ASM
	DW	TRANGROUP:ForHelpMsgs
	DB	3,"CLS",0
	DW	OFFSET TRANGROUP:CLS		; In TCMD2.ASM
	DW	TRANGROUP:ClsHelpMsgs
	DB	8,"TRUENAME",fSwitchAllowed+fCheckDrive  ;AN000; P3903 changed
	DW	OFFSET TRANGROUP:TRUENAME	;AN000;
	DW	TRANGROUP:TruenameHelpMsgs
	DB	8,"LOADHIGH",fSwitchAllowed	; M003
	DW	OFFSET TRANGROUP:LoadHigh		; In loadhi.asm ; M003
	DW	TRANGROUP:LoadhighHelpMsgs	; M003
	DB	2,"LH",fSwitchAllowed			; Short form; M003
	DW	OFFSET TRANGROUP:LoadHigh		; In loadhi.asm ; M003
	DW	TRANGROUP:LoadhighHelpMsgs	; M003
	DB	0				; Terminate command table


comext	dB	".COM"
exeext	dB	".EXE"
batext	dB	".BAT"

switch_list	DB	"?VBAPW"                ; flags we can recognize

AttrLtrs        DB      "RHSvDA"                ; attribute letters for DIR

;               Attribute letters in AttrLtrs must appear in the order that
;               attribute bits occur in the attribute byte returned by
;               directory searches, starting with bit 0.
;               The volume label attribute is lowercased to keep it from
;               being matched (by an uppercase comparison).

OrderLtrs       DB      "NEDSG"                 ; sort order letters for DIR

;               Sort order letters stand for file name, extension,
;               date/time, size, and grouped (directory files before others).  
;               DIR routines rely on the specific order of the
;               letters in this list.

comspec_flag    db      0                       ;AN071;



PUBLIC	BatBufLen
BatBufLen   DW	BatLen

; *****************************************************
; EMG 4.00
; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
; *****************************************************

;
; COMMON PARSE BLOCKS
;

;
; Indicates no value list for PARSE.
;

NO_VALUES	DW	0			;AN000;  no values

NULL_VALUE_LIST LABEL   BYTE                    ; for unvalidated value
                DB      0                       ; no value lists

;
; PARSE control block for a required file specification (upper cased)
;

FILE_REQUIRED	LABEL	BYTE			;AN000;
		DW	0200H			;AN000;  filespec - required
		DW	1			;AN000;  capitalize - file table
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE control block for an optional file specification (upper cased)
; or drive number
;

FILE_OPTIONAL	LABEL	BYTE			;AN000;
		DW	0301H			;AN000;  filespec or drive number
						;	 optional
		DW	1			;AN000;  capitalize - file table
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE control block for an optional file specification (upper cased)
;

FILE_OPTIONAL2  LABEL   BYTE                    ;AN000;
                DW      0201H                   ;AN000;  filespec optional
                DW      1                       ;AN000;  capitalize - file table
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE control block for an optional /P switch
;

SLASH_P_SWITCH	LABEL	BYTE			;AN000;
		DW	0			;AN000;  no match flags
		DW	2			;AN000;  capitalize - char table
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	1			;AN000;  1 keyword
SLASH_P_SYN	DB	"/P",0                  ;AN000;  /P switch



; PARSE BLOCK FOR BREAK, VERIFY, ECHO

;
; The following parse control block can be used for any command which
; needs only the optional "ON" and "OFF" keywords as operands.  Allows
; the equal sign as an additional delimiter.  Returns verified result
; in PARSE1_OUTPUT.  Currently used for the BREAK, VERIFY, and	ECHO
; internal commands.
;

PARSE_BREAK	LABEL	BYTE			;AN000;
		DW	TRANGROUP:BREAK_PARMS	;AN000;
		DB	0			;AN032; no extra delimiter

BREAK_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:BREAK_CONTROL1;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

BREAK_CONTROL1	LABEL	BYTE			;AN000;
		DW	2001H			;AN000;  string value - optional
		DW	2			;AN000;  capitalize - char table
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:BREAK_VALUES	;AN000;
		DB	0			;AN000;  no keywords

BREAK_VALUES	LABEL	BYTE			;AN000;
		DB	3			;AN000;
		DB	0			;AN000;  no ranges
		DB	0			;AN000;  no numeric values
		DB	2			;AN000;  2 string values
		DB	0			;AN000;  returned if ON
		DW	TRANGROUP:BREAK_ON	;AN000;  point to ON string
		DB	'f'                     ;AN000;  returned if OFF
		DW	TRANGROUP:BREAK_OFF	;AN000;  point to OFF string

BREAK_ON	DB	"ON",0                  ;AN000;
BREAK_OFF	DB	"OFF",0                 ;AN000;

;
; PARSE BLOCK FOR CHCP
;

;
; The following parse control block can be used for any command which
; needs only one optional three digit decimal parameter for operands.
; Returns verified result in PARSE1_OUTPUT.  Currently used for the
; CHCP internal command.
;
CHCP_MINVAL	EQU	100			;AN000;
CHCP_MAXVAL	EQU	999			;AN000;

PARSE_CHCP	LABEL	BYTE			;AN000;
		DW	TRANGROUP:CHCP_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

CHCP_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:CHCP_CONTROL1 ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

CHCP_CONTROL1	LABEL	BYTE			;AN000;
		DW	8001H			;AN000;  numeric value - optional
		DW	0			;AN000;  no function flags
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:CHCP_VALUES	;AN000;
		DB	0			;AN000;  no keywords

CHCP_VALUES	LABEL	BYTE			;AN000;
		DB	1			;AN000;
		DB	1			;AN000;  1 range
		DB	1			;AN000;  returned if result
		DD	CHCP_MINVAL,CHCP_MAXVAL ;AN000;  minimum & maximum value
		DB	0			;AN000;  no numeric values
		DB	0			;AN000;  no string values


;
; PARSE BLOCK FOR DATE
;

;
; The following parse control block can be used for any command which
; needs only an optional date string as an operand.  Returns unverified
; result in DATE_OUTPUT.  Currently used for the DATE internal command.
;

PARSE_DATE	LABEL	BYTE			;AN000;
		DW	TRANGROUP:DATE_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

DATE_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:DATE_CONTROL1 ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

DATE_CONTROL1	LABEL	BYTE			;AN000;
		DW	1001H			;AN000;  date - optional
		DW	0			;AN000;  no function flags
		DW	TRANGROUP:DATE_OUTPUT	;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR TIME
;

;
; The following parse control block can be used for any command which
; needs only an optional time string as an operand.  Returns unverified
; result in TIME_OUTPUT.  Currently used for the TIME internal command.
;

PARSE_TIME	LABEL	BYTE			;AN000;
		DW	TRANGROUP:TIME_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

TIME_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:TIME_CONTROL1 ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

TIME_CONTROL1	LABEL	BYTE			;AN000;
		DW	0801H			;AN000;  TIME - optional
		DW	0			;AN000;  no function flags
		DW	TRANGROUP:TIME_OUTPUT	;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords


;
; PARSE BLOCK FOR VOL
;

;
; The following parse control block can be used for any command which
; needs only an optional drive letter as an operand.  Returns unverified
; drive number (one based) in DRIVE_OUTPUT.  Currently used for the VOL
; internal command.
;

PARSE_VOL	LABEL	BYTE			;AN000;
		DW	TRANGROUP:VOL_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

VOL_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:DRIVE_CONTROL1;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

DRIVE_CONTROL1	LABEL	BYTE			;AN000;
		DW	0101H			;AN000;  DRIVE - optional
		DW	1			;AN000;  capitalize - file table
		DW	TRANGROUP:DRIVE_OUTPUT	;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords


;
; PARSE BLOCK FOR MKDIR, RMDIR, TYPE
;

;
; The following parse control block can be used for any command which
; needs only one required file specification as an operand.  Returns a
; pointer to the unverified string in PARSE1_OUTPUT.  Currently used
; for the MKDIR, RMDIR, and TYPE internal commands.
;

PARSE_MRDIR	LABEL	BYTE			;AN000;
		DW	TRANGROUP:MRDIR_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

MRDIR_PARMS	LABEL	BYTE			;AN000;
		DB	1,1			;AN000;  1 positional parm
		DW	TRANGROUP:FILE_REQUIRED ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR CHDIR, TRUENAME
;

;
; The following parse control block can be used for any command which
; needs only one optional file specification an operand.  Returns a
; pointer to the unverified string in PARSE1_OUTPUT.  Currently used
; for the CHDIR and TRUENAME internal commands.
;

PARSE_CHDIR	LABEL	BYTE			;AN000;
		DW	TRANGROUP:CHDIR_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

CHDIR_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:FILE_OPTIONAL ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR ERASE
;

;
; The following parse control block is used for the DEL/ERASE internal
; commands.  This command has one required file specification and an
; optional switch (/p) as operands. The verified switch or unverified
; file specification is returned in PARSE1_OUTPUT.
;

PARSE_ERASE	LABEL	BYTE			;AN000;
		DW	TRANGROUP:ERASE_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

ERASE_PARMS	LABEL	BYTE			;AN000;
		DB	1,1			;AN000;  1 positional parm
		DW	TRANGROUP:FILE_REQUIRED ;AN000;
		DB	1			;AN000;  1 switch
		DW	TRANGROUP:SLASH_P_SWITCH;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR DIR
;

;
; The following parse control block is used for the DIR internal command.
; This command has one optional file specification and several optional
; switches.  Switches, switch values, and the filespec are returned in 
; PARSE1_OUTPUT.
;
; Switches are /a[value], /-a, /o[value], /-o, /s, /-s, /?, /b, /-b,
; /w, /-w, /p, and /-p.  The string values for /a and /o are optional,
; do not require colons, and are not checked against a value list.
;
; Switch /h has been removed from the DIR command	;M008
; Switch /? is no longer handled internally		;M008
;
; A list of pointers to all the switch synonyms is provided here to
; help identify which switch has been matched.
;

PARSE_DIR	LABEL	BYTE
		DW	TRANGROUP:DIR_PARMS
		DB	0			; no extra delimiters

DIR_PARMS	LABEL	BYTE
		DB	0,1			; 1 optional positional param
		DW	TRANGROUP:FILE_OPTIONAL2
		DB	2			; 2 kinds of switches
		DW	TRANGROUP:DIR_SW_VALUED
		DW	TRANGROUP:DIR_SW_UNVALUED
		DB	0			; no keywords

DIR_SW_VALUED	LABEL	BYTE
		DW	2001H			  ; optional string value
		DW	21H			  ; optional colon; capitalize 
		DW	TRANGROUP:PARSE1_OUTPUT   ; result buffer
		DW	TRANGROUP:NULL_VALUE_LIST ; don't validate value
		DB	2			  ; 2 'synonyms'
DIR_SW_A	DB	"/A",0
DIR_SW_O	DB	"/O",0

DIR_SW_UNVALUED	LABEL	BYTE
		DW	0			  ; no value
		DW	0			  ; no format functions
		DW	TRANGROUP:PARSE1_OUTPUT   ; result buffer
		DW	TRANGROUP:NO_VALUES
		DB	14			  ; 14 'synonyms'
DIR_SW_NEG_A	DB	"/-A",0
DIR_SW_NEG_O	DB	"/-O",0
DIR_SW_S	DB	"/S",0
DIR_SW_NEG_S	DB	"/-S",0
DIR_SW_B	DB	"/B",0
DIR_SW_NEG_B	DB	"/-B",0
DIR_SW_W	DB	"/W",0
DIR_SW_NEG_W	DB	"/-W",0
DIR_SW_P	DB	"/P",0
DIR_SW_NEG_P	DB	"/-P",0
DIR_SW_L	DB	"/L",0			;M010
DIR_SW_NEG_L	DB	"/-L",0			;M010

;
; Here's a list of pointers to DIR's switch synonyms, for easier
; identification.  Order is critical - DIR routines rely on the
; specific order in this list.  Negated options appear at odd 
; positions in the list, and simple on/off options appear first.
;

DIR_SW_PTRS	LABEL	WORD		; list of ptrs to switch synonyms
		DW	TRANGROUP:DIR_SW_NEG_W
		DW	TRANGROUP:DIR_SW_W
		DW	TRANGROUP:DIR_SW_NEG_P
		DW	TRANGROUP:DIR_SW_P
		DW	TRANGROUP:DIR_SW_NEG_S
		DW	TRANGROUP:DIR_SW_S
		DW	TRANGROUP:DIR_SW_NEG_B
		DW	TRANGROUP:DIR_SW_B
		DW	TRANGROUP:DIR_SW_NEG_L	;M010
		DW	TRANGROUP:DIR_SW_L	;M010
		DW	TRANGROUP:DIR_SW_NEG_O
		DW	TRANGROUP:DIR_SW_O
		DW	TRANGROUP:DIR_SW_NEG_A
		DW	TRANGROUP:DIR_SW_A

;
; PARSE BLOCK FOR RENAME
;

;
; The following parse control block can be used for any command which
; needs only two required file specifications as operands.  Returns
; pointers to the unverified string in PARSE1_OUTPUT.
; Currently used for the RENAME internal command.
;

PARSE_RENAME	LABEL	BYTE			;AN000;
		DW	TRANGROUP:RENAME_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

RENAME_PARMS	LABEL	BYTE			;AN000;
		DB	2,2			;AN000;  2 positional parms
		DW	TRANGROUP:FILE_REQUIRED ;AN000;
		DW	TRANGROUP:FILE_REQUIRED ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR CTTY
;

;
; The following parse control block can be used for any command which
; needs one required device name as an operand.  Returns a pointer to
; unverified string in PARSE1_OUTPUT. Currently used for the CTTY
; internal command.
;

PARSE_CTTY	LABEL	BYTE			;AN000;
		DW	TRANGROUP:CTTY_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

CTTY_PARMS	LABEL	BYTE			;AN000;
		DB	1,1			;AN000;  1 positional parm
		DW	TRANGROUP:CTTY_CONTROL1 ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

CTTY_CONTROL1	LABEL	BYTE			;AN000;
		DW	2000H			;AN000;  string value - required
		DW	11H			;AN000;  capitalize - file table
						;AN000;  remove colon at end
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR VER
;

;
; The following parse control block can be used for any command which
; needs an optional switch "/debug".  Currently used for the VER command.
;

PARSE_VER	LABEL	BYTE
		DW	TRANGROUP:VER_PARMS
		DB	0			; no extra delimiters

VER_PARMS	LABEL	BYTE
		DB	0,0			; no positional parameters
		DB	1			; one switch
		DW	TRANGROUP:SLASH_R
		DB	0			; no keywords

SLASH_R		LABEL	BYTE
		DW	0			; no values
		DW	2			; capitalize by filename table
		DW	TRANGROUP:PARSE1_OUTPUT	; result buffer
		DW	TRANGROUP:NO_VALUES	; no values
		DB	1			; one synonym
SLASH_R_SYN	DB	"/R",0

;
; M003 ; Start of changes for LoadHigh support
;

;
;Parse Control Block for LOADHIGH command
;

Parse_LoadHi	label	byte
	dw	TRANGROUP:LoadHi_Parms	;extended parm table
	db	0			;no extra delimiters

LoadHi_Parms	label	byte
	db	1,1			;min. 1 parm, max. 1 parm
	dw	TRANGROUP:File_Required	;control struc for filename
	db	0			;no switches
	db	0			;no keywords
;
; M003 ; End of changes for LoadHigh support
;

; Table of internal command which have special meaning under NT while at
; command.com prompt. First field is the command name length. Second is the
; command name. Third is only 1 for exit command, rest are all 0. This field
; is returned in al.

    public  NT_INTRNL_CMND

NT_INTRNL_CMND  label byte
    db      4,"EXIT",0
    db      6,"PROMPT",1
    db      3,"SET",1
    db      4,"PATH",1
    db      2,"CD",1
    db      5,"CHDIR",1
    db      0



public TempVarName
TempVarName	db	"TEMP=",0

ifdef	BETA3WARN
%out	Take this out before we ship
public Beta3WarnMsg
Beta3WarnMsg	label	byte

  db      '+--------------------- WARNING! ------------------------+', 0dh, 0ah
  db      '|                                                       |', 0dh, 0ah
  db      '|                                                       |', 0dh, 0ah
  db      '|  The license for this pre-release version of MS-DOS   |', 0dh, 0ah
  db      '|  5.0 has expired.  Please replace it with an updated  |', 0dh, 0ah
  db      '|  version of MS-DOS 5.0 immediately.                   |', 0dh, 0ah
  db      '|                                                       |', 0dh, 0ah
  db      '|                                                       |', 0dh, 0ah
  db      '|          <Press any key to continue>                  |', 0dh, 0ah
  db      '|                                                       |', 0dh, 0ah
  db      '+-------------------------------------------------------+', 0dh, 0ah
  db	  '$'
endif


TRANDATA	ENDS

TRANCODE	SEGMENT PUBLIC BYTE		;AN000;

.xlist
.xcref

INCLUDE SYSMSG.INC				;AN000;

.list
.cref

ASSUME DS:TRANGROUP,ES:TRANGROUP,CS:TRANGROUP

MSG_UTILNAME <COMMAND>				;AN000; define utility name

MSG_SERVICES <COMT,COMMAND.CLF,COMMAND.CL1,COMMAND.CL2> ;AN000; The transient messages

include msgdcl.inc

TRANCODE	ENDS				;AN000;

TRANDATA	SEGMENT PUBLIC BYTE

TRANDATAEND	LABEL	BYTE

TRANDATA	ENDS				;AN000;

	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tenv.asm ===
page ,132
;	SCCSID = @(#)tenv.asm	4.2 85/08/16
;	SCCSID = @(#)tenv.asm	4.2 85/08/16
TITLE	Part6 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;	Environment utilities and misc. routines
;
;	Revision History
;	================
;
;	M024	SR	9/5/90	Zero out comspec_flag to fix bug
;				#710 about comspec getting trashed.
;



	INCLUDE comsw.asm

.xlist
.xcref
	include dossym.inc
	include syscall.inc
	include arena.inc
	include comseg.asm
	include comequ.asm
	include doscntry.inc		;an000;
	include	resmsg.equ
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	comdrv:byte
	EXTRN	comspec_end:word
	EXTRN	dbcs_vector_addr:dword	;AN000;
	EXTRN	ENVIRSEG:WORD
	EXTRN	fucase_addr:word	;AC000;
	EXTRN	PutBackDrv:byte
	EXTRN	PutBackComSpec:byte
	EXTRN	RESTDIR:BYTE
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg_buf_ptr:word
	EXTRN	comspec:byte
	EXTRN	comspec_flag:byte
	EXTRN	comspecstr:byte
	EXTRN	ENVERR_PTR:WORD
	EXTRN	PATH_TEXT:byte
	EXTRN	PROMPT_TEXT:byte
	EXTRN	SYNTMES_PTR:WORD
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	Arg_Buf:BYTE
	EXTRN	RESSEG:WORD
	EXTRN	USERDIR1:BYTE
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC byte

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	cerror:near

	PUBLIC	add_name_to_environment
	PUBLIC	add_prompt
	PUBLIC	delete_path
	PUBLIC	find_name_in_environment
	PUBLIC	find_path
	PUBLIC	find_prompt
	PUBLIC	move_name
	PUBLIC	restudir
	PUBLIC	restudir1
	PUBLIC	scan_double_null
	PUBLIC	scasb2
	PUBLIC	store_char
	PUBLIC	Testkanj		;AN000;  3/3/KK
	PUBLIC	upconv
	PUBLIC	GETENVSIZ

BREAK	<Environment utilities>
ASSUME DS:TRANGROUP

	break	Prompt command
assume	ds:trangroup,es:trangroup

ADD_PROMPT:
	CALL	DELETE_PROMPT			; DELETE ANY EXISTING PROMPT
	CALL	SCAN_DOUBLE_NULL

ADD_PROMPT2:
	PUSH	SI
	CALL	GETARG
	POP	SI
	retz					; PRE SCAN FOR ARGUMENTS
	CALL	MOVE_NAME			; MOVE IN NAME
	CALL	GETARG
	PUSH	SI
	JMP	SHORT ADD_NAME


	break	The SET command
assume	ds:trangroup,es:trangroup

;
; Input: DS:SI points to a CR terminated string
; Output: carry flag is set if no room
;	  otherwise name is added to environment
;

DISP_ENVj:
	jmp	DISP_ENV

ADD_NAME_TO_ENVIRONMENT:
	CALL	GETARG
	JZ	DISP_ENVj
;
; check if line contains exactly one equals sign
;
	XOR	BX,BX				;= COUNT IS 0
	PUSH	SI				;SAVE POINTER TO BEGINNING OF LINE

EQLP:
	LODSB					;GET A CHAR
	CMP	AL,13				;IF CR WE'RE ALL DONE
	JZ	QUEQ
	CMP	AL,'='                          ;LOOK FOR = SIGN
	JNZ	EQLP				;NOT THERE, GET NEXT CHAR
	INC	BL				;OTHERWISE INCREMENT EQ COUNT
	CMP	BYTE PTR [SI],13		;LOOK FOR CR FOLLOWING = SIGN
	JNZ	EQLP
	INC	BH				;SET BH=1 MEANS NO PARAMETERS
	JMP	EQLP				;AND LOOK FOR MORE

QUEQ:
	POP	SI				;RESTORE BEGINNING OF LINE
	DEC	BL				;ZERO FLAG MEANS ONLY ONE EQ
	JZ	ONEQ				;GOOD LINE
	MOV	DX,OFFSET TRANGROUP:SYNTMES_ptr
	JMP	CERROR

ONEQ:
	PUSH	BX
	CALL	DELETE_NAME_IN_ENVIRONMENT
	POP	BX
	DEC	BH
	retz

	CALL	SCAN_DOUBLE_NULL
	mov	bx,di				; Save ptr to beginning of env var name
	CALL	MOVE_NAME
	push	si
	xchg	bx,di				; Switch ptrs to beginning and end of
						;  env var name
;
; We want to special-case COMSPEC.  This is to reduce the amount of code
; necessary in the resident for re-reading the transient.  Let's look for
; COMSPEC=
;
	mov	comspec_flag,0			; clear flag ; M024
	mov	si,offset trangroup:comspecstr	; Load ptr to string "COMSPEC"
	mov	cx,4				; If the new env var is comspec, set
	repz	cmpsw				;  the comspec_flag
;
; Zero set => exact match
;
	jnz	not_comspec
	inc	comspec_flag			; comspec is changing ; M024

not_comspec:
	mov	di,bx				; Load ptr to end of env var name

ADD_NAME:					; Add the value of the new env var
	pop	si				;  to the environment.
	push	si

add_name1:
	LODSB
	CMP	AL,13
	jz	add_name_ret
	CALL	STORE_CHAR
	JMP	ADD_NAME1

add_name_ret:
	pop	si
	cmp	comspec_flag,0			; If the new env var is comspec,
	retz					;  copy the value into the
;
; We have changed the COMSPEC variable.  We need to update the resident
; pieces necessary to reread in the info.  First, skip all delimiters
;
	invoke	ScanOff
	mov	es,[resseg]			;  comspec var in the resident
	assume	es:resgroup
;
; Make sure that the printer knows where the beginning of the string is
;
	mov	di,offset resgroup:comspec
	mov	bx,di
;
; Generate drive letter for display
;
	xor	ax,ax				;g assume no drive first
	mov	comdrv,al			;g
	push	ax				;AN000;  3/3/KK
	mov	al,[si] 			;AN000;  3/3/KK
	call	testkanj			;AN000;  3/3/KK
	pop	ax				;AN000;  3/3/KK
	jnz	GotDrive
	cmp	byte ptr [si+1],':'             ; drive specified?
	jnz	GotDrive
	mov	al,[si] 			; get his specified drive
	call	UpConv				; convert to uppercase
	sub	al,'A'                          ; convert to 0-based
	add	di,2
	inc	al				; convert to 1-based number
	mov	comdrv,al
;
; Stick the drive letter in the prompt message.  Nothing special needs to be
; done here..
;

	add	al,'A'-1

GotDrive:					;g
	mov	PutBackComSpec.SubstPtr,di	;g point to beginning of name after drive
	mov	es:PutBackDrv,al
;
; Copy chars until delim
;

	mov	di,bx

copy_comspec:
	lodsb
	invoke	Delim
	jz	CopyDone
	cmp	al,13
	jz	CopyDone
	stosb
	jmp	short copy_comspec

CopyDone:
	xor	al,al				; Null terminate the string and quit
	stosb
	mov	comspec_flag,0
	dec	di
	mov	comspec_end,di

	ret

DISP_ENV:
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	DS,[ENVIRSEG]
ASSUME	DS:NOTHING
	XOR	SI,SI

PENVLP:
	CMP	BYTE PTR [SI],0
	retz
	mov	di,offset trangroup:arg_buf

PENVLP2:
	LODSB
	stosb
	OR	AL,AL
	JNZ	PENVLP2
	mov	dx,offset trangroup:arg_buf_ptr
	push	ds
	push	es
	pop	ds
	invoke	printf_crlf
	pop	ds
	JMP	PENVLP

ASSUME	DS:TRANGROUP

DELETE_PATH:
	MOV	SI,OFFSET TRANGROUP:PATH_TEXT
	JMP	SHORT DELETE_NAME_IN_environment

DELETE_PROMPT:
	MOV	SI,OFFSET TRANGROUP:PROMPT_TEXT

DELETE_NAME_IN_environment:
;
; Input: DS:SI points to a "=" terminated string
; Output: carry flag is set if name not found
;	  otherwise name is deleted
;
	PUSH	SI
	PUSH	DS
	CALL	FIND				; ES:DI POINTS TO NAME
	JC	DEL1
	MOV	SI,DI				; SAVE IT
	CALL	SCASB2				; SCAN FOR THE NUL
	XCHG	SI,DI
;SR;
; If we have only one env string, then the double null is lost when the last
;string is deleted and we have an invalid empty environment with only a 
;single null. To avoid this, we will look for the double null case and then
;move an extra null char.
; Bugbug: The only possible problem is that the last pathstring 
;will be followed by a triple null. Is this really a problem?
;
	cmp	byte ptr es:[si],0			;null char?
	jnz	not_dnull			;no, we are at a double null
	dec	si				;point at the double null
not_dnull:

	CALL	GETENVSIZ
	SUB	CX,SI
	PUSH	ES
	POP	DS				; ES:DI POINTS TO NAME, DS:SI POINTS TO NEXT NAME
	REP	MOVSB				; DELETE THE NAME

DEL1:
	POP	DS
	POP	SI
	return

FIND_PATH:
	MOV	SI,OFFSET TRANGROUP:PATH_TEXT
	JMP	SHORT FIND_NAME_IN_environment

FIND_PROMPT:
	MOV	SI,OFFSET TRANGROUP:PROMPT_TEXT

FIND_NAME_IN_environment:
;
; Input: DS:SI points to a "=" terminated string
; Output: ES:DI points to the arguments in the environment
;	  zero is set if name not found
;	  carry flag is set if name not valid format
;
	CALL	FIND				; FIND THE NAME
	retc					; CARRY MEANS NOT FOUND
	JMP	SCASB1				; SCAN FOR = SIGN
;
; On return of FIND1, ES:DI points to beginning of name
;
FIND:
	CLD
	CALL	COUNT0				; CX = LENGTH OF NAME
	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP
	MOV	ES,[ENVIRSEG]
ASSUME	ES:NOTHING
	XOR	DI,DI

FIND1:
	PUSH	CX
	PUSH	SI
	PUSH	DI

FIND11:
	LODSB
	CALL	TESTKANJ
	JZ	NOTKANJ3
	DEC	SI
	LODSW
	INC	DI
	INC	DI
	CMP	AX,ES:[DI-2]
	JNZ	FIND12
	DEC	CX
	LOOP	FIND11
	JMP	SHORT FIND12

NOTKANJ3:
	CALL	UPCONV
	INC	DI
	CMP	AL,ES:[DI-1]
	JNZ	FIND12
	LOOP	FIND11

FIND12:
	POP	DI
	POP	SI
	POP	CX
	retz
	PUSH	CX
	CALL	SCASB2				; SCAN FOR A NUL
	POP	CX
	CMP	BYTE PTR ES:[DI],0
	JNZ	FIND1
	STC					; INDICATE NOT FOUND
	return

COUNT0:
	PUSH	DS
	POP	ES
	MOV	DI,SI

COUNT1:
	PUSH	DI				; COUNT NUMBER OF CHARS UNTIL "="
	CALL	SCASB1
	JMP	SHORT COUNTX

COUNT2:
	PUSH	DI				; COUNT NUMBER OF CHARS UNTIL NUL
	CALL	SCASB2

COUNTX:
	POP	CX
	SUB	DI,CX
	XCHG	DI,CX
	return

MOVE_NAME:
	CMP	BYTE PTR DS:[SI],13
	retz
	LODSB

;;;;	IFDEF	DBCS			3/3/KK
	CALL	TESTKANJ
	JZ	NOTKANJ1
	CALL	STORE_CHAR
	LODSB
	CALL	STORE_CHAR
	JMP	SHORT MOVE_NAME

NOTKANJ1:
;;;;	ENDIF				3/3/KK

	CALL	UPCONV
	CALL	STORE_CHAR
	CMP	AL,'='
	JNZ	MOVE_NAME
	return

GETARG:
	MOV	SI,80H
	LODSB
	OR	AL,AL
	retz
	invoke	SCANOFF
	CMP	AL,13
	return

;
; Point ES:DI to the final NULL string.  Note that in an empty environment,
; there is NO double NULL, merely a string that is empty.
;
SCAN_DOUBLE_NULL:
	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP
	MOV	ES,[ENVIRSEG]
ASSUME	ES:NOTHING
	XOR	DI,DI
;
; Top cycle-point.  If the string here is empty, then we are done
;
SDN1:
	cmp	byte ptr es:[di],0		; nul string?
	retz					; yep, all done
	CALL	SCASB2
	JMP	SDN1

SCASB1:
	MOV	AL,'='                          ; SCAN FOR AN =
	JMP	SHORT SCASBX
SCASB2:
	XOR	AL,AL				; SCAN FOR A NUL
SCASBX:
        MOV     CX,1000H
	REPNZ	SCASB
	return
;Bugbug: This is Kanji stuff - put it in conditionals

TESTKANJ:
	push	ds				;AN000;  3/3/KK
	push	si				;AN000;  3/3/KK
	push	ax				;AN000;  3/3/KK
	mov	ds,cs:[resseg]			;AN000;  Get resident segment
	assume	ds:resgroup			;AN000;
	lds	si,dbcs_vector_addr		;AN000;  get DBCS vector
ktlop:						;AN000;  3/3/KK
	cmp	word ptr ds:[si],0		;AN000;  end of Table	3/3/KK
	je	notlead 			;AN000;  3/3/KK
	pop	ax				;AN000;  3/3/KK
	push	ax				;AN000;  3/3/KK
	cmp	al, byte ptr ds:[si]		;AN000;  3/3/KK
	jb	notlead 			;AN000;  3/3/KK
	inc	si				;AN000;  3/3/KK
	cmp	al, byte ptr ds:[si]		;AN000;  3/3/KK
	jbe	islead				;AN000;  3/3/KK
	inc	si				;AN000;  3/3/KK
	jmp	short ktlop			;AN000;  try another range ; 3/3/KK
Notlead:					;AN000;  3/3/KK
	xor	ax,ax				;AN000;  set zero 3/3/KK
	jmp	short ktret			;AN000;  3/3/KK
Islead: 					;AN000;  3/3/KK
	xor	ax,ax				;AN000;  reset zero  3/3/KK
	inc	ax				;AN000;  3/3/KK
ktret:						;AN000;  3/3/KK
	pop	ax				;AN000;  3/3/KK
	pop	si				;AN000;  3/3/KK
	pop	ds				;AN000;  3/3/KK
	return					;AN000;  3/3/KK
;-------------------------------------		;3/3/KK


; ****************************************************************
; *
; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
; *
; * FUNCTION:	 This routine returns the upper case equivalent of
; *		 the character in AL from the file upper case table
; *		 in DOS if character if above  ascii 128, else
; *		 subtracts 20H if between "a" and "z".
; *
; * INPUT:	 AL	      char to be upper cased
; *		 FUCASE_ADDR  set to the file upper case table
; *
; * OUTPUT:	 AL	      upper cased character
; *
; ****************************************************************

assume	ds:trangroup				;AN000;

upconv	proc	near				;AN000;

	cmp	al,80h				;AN000;  see if char is > ascii 128
	jb	oth_fucase			;AN000;  no - upper case math
	sub	al,80h				;AN000;  only upper 128 chars in table
	push	ds				;AN000;
	push	bx				;AN000;
	mov	ds,[resseg]			;AN000;  get resident data segment
assume	ds:resgroup				;AN000;
	lds	bx,dword ptr fucase_addr+1	;AN000;  get table address
	add	bx,2				;AN000;  skip over first word
	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
	pop	bx				;AN000;
	pop	ds				;AN000;
assume	ds:trangroup				;AN000;
	jmp	short upconv_end		;AN000;  we finished - exit

oth_fucase:					;AN000;
	cmp	al,small_a			;AC000; if between "a" and "z",
	jb	upconv_end			;AC000;     subtract 20h to get
	cmp	al,small_z			;AC000;    upper case equivalent.
	ja	upconv_end			;AC000;
	sub	al,20h				;AC000; Change lower-case to upper

upconv_end:					;AN000;
	ret

upconv	endp					;AN000;


;
; STORE A CHAR IN environment, GROWING IT IF NECESSARY
;
STORE_CHAR:
	PUSH	CX
	PUSH	BX
	PUSH	ES				;AN056;
	PUSH	DS				;AN056; Save local DS
	MOV	DS,[RESSEG]			;AN056; Get resident segment
	ASSUME	DS:RESGROUP			;AN056;
	MOV	ES,[ENVIRSEG]			;AN056; Get environment segment
	ASSUME	ES:NOTHING			;AN056;
	POP	DS				;AN056; Get local segment back
	ASSUME	DS:TRANGROUP			;AN056;
	CALL	GETENVSIZ
	MOV	BX,CX
	SUB	BX,2				; SAVE ROOM FOR DOUBLE NULL
	CMP	DI,BX
	JB	STORE1

	PUSH	AX
	PUSH	CX
	PUSH	BX				; Save Size of environment
	invoke	FREE_TPA
	POP	BX
	ADD	BX,2				; Recover true environment size

	CMP	BX, 8000H			; Don't let environment grow > 32K
	JB	ENVSIZ_OK
BAD_ENV_SIZE:					;AN056;
	STC
	JMP	SHORT ENVNOSET
ENVSIZ_OK:

	MOV	CL,4
	SHR	BX,CL				; Convert back to paragraphs
	INC	BX				; Try to grow environment by one para
	MOV	CX,ES				;AN056; Get environment segment
	ADD	CX,BX				;AN056; Add in size of environment
	ADD	CX,020H 			;AN056; Add in some TPA
	MOV	AX,CS				;AN056; Get the transient segment
	CMP	CX,AX				;AN056; Are we hitting the transient?
	JNB	BAD_ENV_SIZE			;AN056; Yes - don't do it!!!
	MOV	AH,SETBLOCK
	INT	21h
ENVNOSET:
	PUSHF
	PUSH	ES
	MOV	ES,[RESSEG]
	invoke	ALLOC_TPA
	POP	ES
	POPF
	POP	CX
	POP	AX
	JNC	STORE1
	POP	ES				;AN056;
	MOV	DX,OFFSET TRANGROUP:ENVERR_ptr
	JMP	CERROR
STORE1:
	STOSB
	MOV	WORD PTR ES:[DI],0		; NULL IS AT END
	POP	ES				;AN056;
	POP	BX
	POP	CX
	return

GETENVSIZ:
;Get size of environment in bytes, rounded up to paragraph boundry
;ES has environment segment
;Size returned in CX, all other registers preserved

	PUSH	ES
	PUSH	AX
	MOV	AX,ES
	DEC	AX				;Point at arena
	MOV	ES,AX
	MOV	AX,ES:[arena_size]
	MOV	CL,4
	SHL	AX,CL				;Convert to bytes
	MOV	CX,AX
	POP	AX
	POP	ES
	return


ASSUME	DS:TRANGROUP


RESTUDIR1:
	PUSH	DS
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	CMP	[RESTDIR],0
	POP	DS
ASSUME	DS:TRANGROUP
	retz

RESTUDIR:
	MOV	DX,OFFSET TRANGROUP:USERDIR1
	MOV	AH,CHDIR
	INT	21h			; Restore users DIR
	XOR	AL,AL
	invoke	SETREST
RET56:
	return

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tpipe.asm ===
page ,132
;	SCCSID = @(#)tpipe.asm	1.1 85/05/14
;	SCCSID = @(#)tpipe.asm	1.1 85/05/14
TITLE	PART8 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M025	SR	9/12/90	Removed calls to SetStdInOn,SetStdInOff
;				SetStdOutOn & SetStdOutOff.
;

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include pdb.inc
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	ECHOFLAG:BYTE
	EXTRN	InitFlag:byte
	EXTRN	INPIPEPTR:WORD
	EXTRN	OUTPIPEPTR:WORD
	EXTRN	PIPE1:BYTE
;;;	EXTRN	PIPE1T:BYTE
	EXTRN	PIPE2:BYTE
;;;	EXTRN	PIPE2T:BYTE
	EXTRN	PIPEFILES:BYTE
	EXTRN	PIPEFLAG:BYTE
	EXTRN	PIPEPTR:WORD
	EXTRN	RESTDIR:BYTE
	EXTRN	SINGLECOM:WORD

DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BADDAT_PTR:WORD
	EXTRN	BADTIM_PTR:WORD
	EXTRN	curdat_mo_day:word	;AN000;
	EXTRN	CURDAT_PTR:WORD
	EXTRN	curdat_yr:word		;AN000;
	EXTRN	curtim_hr_min:word	;AN000;
	EXTRN	CURTIM_PTR:WORD
	EXTRN	curtim_sec_hn:word	;AN000;
	EXTRN	eurdat_ptr:word
	EXTRN	japdat_ptr:word
	EXTRN	newdat_format:word	;AN000;
	EXTRN	NEWDAT_PTR:WORD
	EXTRN	NEWTIM_PTR:WORD
	EXTRN	parse_date:byte 	;AN000;
	EXTRN	parse_time:byte 	;AN000;
	EXTRN	PIPEEMES_PTR:WORD
	EXTRN	promtim_hr_min:word	;AN000;
	EXTRN	promtim_ptr:word	;AN000;
	EXTRN	promtim_sec_hn:word	;AN000;
	EXTRN	STRING_BUF_PTR:WORD	;AC000;
	EXTRN	SYNTMES_PTR:WORD
	EXTRN	usadat_ptr:word

	extrn	TempVarName:byte

TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	COMBUF:BYTE
	EXTRN	date_day:byte		;AN000;
	EXTRN	date_month:byte 	;AN000;
	EXTRN	date_year:word		;AN000;
	EXTRN	INTERNATVARS:BYTE
	EXTRN	RESSEG:WORD
	EXTRN	time_fraction:byte	;AN000;
	EXTRN	time_hour:byte		;AN000;
	EXTRN	time_minutes:byte	;AN000;
	EXTRN	time_seconds:byte	;AN000;
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE
ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	CERROR:NEAR
	EXTRN	NOPIPEPROC:NEAR
	EXTRN	STD_PRINTF:NEAR
	EXTRN	TCOMMAND:NEAR
	EXTRN	TESTDOREIN:NEAR
	EXTRN	TESTDOREOUT:NEAR
	EXTRN	TESTKANJ:NEAR		;AN000;3/3/KK
	EXTRN	TSYSGETMSG:NEAR 	;AN000;

	extrn	Find_Name_In_Environment:near

	PUBLIC	CTIME
	PUBLIC	DATE
	PUBLIC	DATINIT
	PUBLIC	PIPEDEL
	PUBLIC	PIPEERRSYN
	PUBLIC	PIPEPROC
	PUBLIC	PIPEPROCSTRT
	PUBLIC	PRINT_TIME
	PUBLIC	SETREST
	PUBLIC	SETREST1
	PUBLIC	SINGLETEST

SINGLETEST:
	ASSUME	DS:NOTHING
	push	ds
	MOV	DS,ResSeg
	ASSUME	DS:ResGroup
	CMP	[SINGLECOM],0
	JZ	TestDone
	CMP	[SINGLECOM],0EFFFH
TestDone:
	pop	ds
	return


ASSUME	DS:TRANGROUP
SETREST1:
	MOV	AL,1
SETREST:
	PUSH	DS
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	[RESTDIR],AL
	POP	DS
ASSUME	DS:TRANGROUP
	return

ASSUME	DS:RESGROUP

;
; Note that we need to handle the same thing that RestDir handles:  the
; requirement that we try only once to restore the user's environment after
; and INT 24 or the like.  If the condition that causes the INT 24 does not
; disappear, we just give up.
;

PIPEDEL:
	assume	ds:nothing
	push	ds
	PUSH	DX
	mov	ds,ResSeg
	assume	ds:ResGroup
	mov	DX,OFFSET RESGROUP:PIPE1	; Clean up in case ^C
	MOV	AH,UNLINK
	INT	21h
	MOV	DX,OFFSET RESGROUP:PIPE2
	MOV	AH,UNLINK
	INT	21h
	POP	DX
	call	PipeOff
	mov	PipeFiles,0
	pop	ds
	return

PIPEERRSYN:
	MOV	DX,OFFSET TRANGROUP:SYNTMES_ptr
	CALL	PIPEDEL
	PUSH	CS
	POP	DS
	JMP	CERROR
PIPEERR:
	pushf
	invoke	triageError
	SaveReg    <AX,DX>			; Save results from TriageError
	MOV	DX,OFFSET TRANGROUP:PIPEEMES_ptr
	CALL	PIPEDEL
	PUSH	CS
	POP	DS
	invoke	std_eprintf
	RestoreReg <DX,AX>			; Restore results from TriageError
	popf
	cmp	ax, 65
	jnz	tcommandj
	JMP	CERROR
tcommandj:
	jmp	tcommand

PIPEPROCSTRT:
ASSUME	DS:TRANGROUP,ES:TRANGROUP
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	INC	[PIPEFILES]			; Flag that the pipe files exist

	push	es
	push	di
	push	ds
	push	si

	push	ds
	push	es
	pop	ds				;ds = TRANGROUP
	mov	si,offset TRANGROUP:TempVarName	;ds:si = "TEMP="
;
;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
;so the routine is not really general
;
	call	Find_Name_In_Environment		;es:di points at path
	pop	ds				;ds = DATARES again
	jc	no_temp_path

	push	ds
	push	es
	pop	ds
	pop	es				;swap ds and es
	mov	si,di				;ds:si points at path

	call	skip_white			;skip white space chars
;
;This copies the path into both buffers -- Pipe1 & Pipe2
;
	call	copy_pipe_path			;copy the pipe path


;
;Check if the TEMP path is valid
;
	push	es
	pop	ds				;ds = DATARES
	mov	dx,offset DATARES:Pipe1		;ds:dx = path to look for
	mov	ax, (CHMOD shl 8) or 0
	int	21h
	jc	no_temp_path

	test	cx,10h				;is it a directory?
	jnz	no_temp_path			;yes, continue (carry clear)

	stc					;no, indicate fail

no_temp_path:
	pop	si
	pop	ds
	pop	di
	pop	es
	jnc	crt_temp			;path found, create tempfiles
;;;;
;;;;Invalid or no TEMP path, default to root of current drive
;;;;

;;;	MOV	AH,Get_Default_Drive		; Get current drive
;;;	INT	21h
;;;	ADD	AL,capital_A
;;;	MOV	PIPE2,AL			; Make pipe files in root of def drv
;;;	MOV	Pipe1,AL
;;;	mov	al,':'
;;;	mov	ah,'\'
;;;	mov	word ptr Pipe1+1,ax
;;;	mov	word ptr Pipe2+1,ax			;store ':\'
;;;
;;;	xor	ah,ah				; nul terminate path names
;;;	mov	Pipe1+3,ah
;;;	mov	Pipe2+3,ah

;SR;
; We want to create temp files in the current directory rather than in the 
;root of the drive. This is because the number of files that can be present
;in the root directory is fixed, whereas it is not so in subdirectories.
;
	mov	ah,'.'
	mov	Pipe1,ah
	mov	Pipe2,ah
	xor	ah,ah
	mov	Pipe1+1,ah
	mov	Pipe2+1,ah			;create files in current dir

crt_temp:
	MOV	DX,offset DATARES:Pipe1
	XOR	CX,CX
	mov	ah,CreateTempFile		; the CreateTemp call
	INT	21h
	JnC	@f
	jmp	PIPEERR 			; Couldn't create
@@:
	MOV	BX,AX
	MOV	AH,CLOSE			; Don't proliferate handles
	INT	21h

	MOV	DX,OFFSET RESGROUP:PIPE2
	mov	ah,createTempFile		; the CreateTemp call
	INT	21h
	JnC	@f
	jmp	PIPEERR
@@:
	MOV	BX,AX
	MOV	AH,CLOSE
	INT	21h

	CALL	TESTDOREIN			; Set up a redirection if specified
	MOV	SI,[PIPEPTR]
	CMP	[SINGLECOM],-1
	JNZ	NOSINGP
	MOV	[SINGLECOM],0F000H		; Flag single command pipe
NOSINGP:
	JMP	SHORT FIRSTPIPE

PIPEPROC:
ASSUME	DS:RESGROUP
	AND	[ECHOFLAG],0FEh 		; force current echo to be off
	MOV	SI,[PIPEPTR]
	LODSB
	CMP	AL,AltPipeChr			; Alternate pipe char?
	JZ	IsPipe1 			; Yes
	CMP	AL,vbar
	jz	IsPipe1
	jmp	PIPEEND 			; Pipe done
IsPipe1:
	MOV	DX,[INPIPEPTR]			; Get the input file name
	MOV	AX,(OPEN SHL 8)
	INT	21h
PIPEERRJ:
	jnc	no_pipeerr
	JMP	PIPEERR 			; Lost the pipe file
no_pipeerr:
	MOV	BX,AX
	MOV	AL,0FFH
	XCHG	AL,[BX.PDB_JFN_Table]
	MOV	DS:[PDB_JFN_Table],AL		; Redirect

FIRSTPIPE:
	MOV	DI,OFFSET TRANGROUP:COMBUF + 2
	XOR	CX,CX
	CMP	BYTE PTR [SI],0DH		; '|<CR>'
	JNZ	PIPEOK1
PIPEERRSYNJ:
	JMP	PIPEERRSYN
PIPEOK1:
	mov	al,vbar
	CMP	BYTE PTR [SI],al		; '||'
	JZ	PIPEERRSYNJ
	CMP	BYTE PTR [SI],AltPipeChr	; '##' or '|#'?
	JZ	PipeErrSynJ			; Yes, Error
PIPECOMLP:
	LODSB
	STOSB

;;;;	IFDEF	DBCS		3/3/KK
	CALL	TESTKANJ
	JZ	NOTKANJ5
	MOVSB
;
;  Added following 2 commands to the fix pipe bug.
;
	inc	cx				;AN000;  3/3/KK
	inc	cx				;AN000;  3/3/KK
;
	JMP	PIPECOMLP

NOTKANJ5:
;;;;	ENDIF			; 3/3/KK

	CMP	AL,0DH
	JZ	LASTPIPE
	INC	CX
	CMP	AL,AltPipeChr
	JZ	IsPipe2
	CMP	AL,vbar
	JNZ	PIPECOMLP
IsPipe2:
	MOV	BYTE PTR ES:[DI-1],0DH
	DEC	CX
	MOV	[COMBUF+1],CL
	DEC	SI
	MOV	[PIPEPTR],SI			; On to next pipe element
	MOV	DX,[OUTPIPEPTR]
	PUSH	CX
	XOR	CX,CX
	MOV	AX,(CREAT SHL 8)
	INT	21h
	POP	CX
	JC	PIPEERRJ			; Lost the file
	MOV	BX,AX
	MOV	AL,0FFH
	XCHG	AL,[BX.PDB_JFN_Table]
	MOV	DS:[PDB_JFN_Table+1],AL
	XCHG	DX,[INPIPEPTR]			; Swap for next element of pipe
	MOV	[OUTPIPEPTR],DX
	JMP	SHORT PIPECOM

LASTPIPE:
	MOV	[COMBUF+1],CL
	DEC	SI
	MOV	[PIPEPTR],SI			; Point at the CR (anything not '|' will do)
	CALL	TESTDOREOUT			; Set up the redirection if specified
PIPECOM:
	PUSH	CS
	POP	DS
	JMP	NOPIPEPROC			; Process the pipe element

PIPEEND:
	CALL	PIPEDEL
	CMP	[SINGLECOM],0F000H
	JNZ	NOSINGP2
	MOV	[SINGLECOM],-1			; Make it return
NOSINGP2:
	JMP	TCOMMAND

ASSUME	DS:TRANGROUP,ES:TRANGROUP

; Date and time are set during initialization and use
; this routines since they need to do a long return

DATINIT PROC	FAR
	mov	cs:[resseg],ds			; SetInitFlag needs resseg initialized
	PUSH	ES
	PUSH	DS				; Going to use the previous stack
	MOV	AX,CS				; Set up the appropriate segment registers
	MOV	ES,AX
	MOV	DS,AX
	invoke	TSYSLOADMSG			;AN000; preload messages
	MOV	DX,OFFSET TRANGROUP:INTERNATVARS;Set up internat vars
	MOV	AX,INTERNATIONAL SHL 8
	INT	21H
	MOV	WORD PTR DS:[81H],13		; Want to prompt for date during initialization
	MOV	[COMBUF],COMBUFLEN		; Init COMBUF
	MOV	WORD PTR [COMBUF+1],0D01H
	CALL	DATE
	CALL	CTIME
	POP	DS
	POP	ES
	RET
DATINIT ENDP

; DATE - Gets and sets the time


	break	Date


; ****************************************************************
; *
; * ROUTINE:	 DATE - Set system date
; *
; * FUNCTION:	 If a date is specified, set the system date,
; *		 otherwise display the current system date and
; *		 prompt the user for a new date.  If an invalid
; *		 date is specified, issue an error message and
; *		 prompt for a new date.  If the user enters
; *		 nothing when prompted for a date, terminate.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

DATE:
	MOV	SI,81H				; Accepting argument for date inline
	mov	di,offset trangroup:parse_date	;AN000; Get adderss of PARSE_DATE
	xor	cx,cx				;AN000; clear counter for positionals
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AC000; call parser
	cmp	ax,end_of_line			;AC000; are we at end of line?
	JZ	PRMTDAT 			;AC000; yes - go ask for date
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	daterr				;AN000; yes - go issue message
	JMP	short COMDAT			;AC000; we have a date

PRMTDAT:
	; Print "Current date is

	invoke	GetDate 			;AN000; get date  for output
	xchg	dh,dl				;AN000; switch month & day
	mov	CurDat_yr,cx			;AC000; put year into message control block
	mov	CurDat_mo_day,dx		;AC000; put month and day into message control block
	mov	dx,offset trangroup:CurDat_ptr	;AC000; set up message for output
	invoke	std_printf
;AD061; mov	CurDat_yr,0			;AC000; reset year, month and day
;AD061; mov	CurDat_mo_day,0 		;AC000;     pointers in control block

GET_NEW_DATE:					;AN000;
	call	getdat				;AC000; prompt user for date
	cmp	ax,end_of_line			;AC000; are we at end of line?
	jz	date_end			;AC000; yes - exit
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	daterr				;AN000; yes - go issue message
COMDAT:
	mov	cx,date_year			;AC000; get parts of date in
	mov	dh,date_month			;AC000;    cx and dx for set
	mov	dl,date_day			;AC000;    date function call.
	push	cx				;AC000; save date
	push	dx				;AC000;
	mov	cx,1				;AC000; set 1 positional entered
	xor	dx,dx				;AN029;
	invoke	cmd_parse			;AN029; call parser
	cmp	al,end_of_line			;AN029; Are we at end of line?
	pop	dx				;AC000; retrieve date
	pop	cx				;AC000;
	jnz	daterr				;AC000; extra stuff on line - try again
	MOV	AH,SET_DATE			;yes - set date
	INT	21h
	OR	AL,AL
	JNZ	DATERR
date_end:
	ret

DATERR:
	invoke	crlf2				;AN028; print out a blank line
	MOV	DX,OFFSET TRANGROUP:BADDAT_ptr
	invoke	std_printf
	JMP	GET_NEW_DATE			;AC000; get date again


; TIME gets and sets the time

	break	Time

; ****************************************************************
; *
; * ROUTINE:	 TIME - Set system time
; *
; * FUNCTION:	 If a time is specified, set the system time,
; *		 otherwise display the current system time and
; *		 prompt the user for a new time.  If an invalid
; *		 time is specified, issue an error message and
; *		 prompt for a new time.  If the user enters
; *		 nothing when prompted for a time, terminate.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

CTIME:
	MOV	SI,81H				; Accepting argument for time inline
	mov	di,offset trangroup:parse_time	;AN000; Get adderss of PARSE_time
	xor	cx,cx				;AN000; clear counter for positionals
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AC000; call parser
	cmp	ax,end_of_line			;AC000; are we at end of line?
	JZ	PRMTTIM 			;AC000; yes - prompt for time
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	timerr				;AN000; yes - go issue message
	JMP	short COMTIM			;AC000; we have a time

PRMTTIM:
	;Printf "Current time is ... "

	MOV	AH,GET_TIME			;AC000; get the current time
	INT	21h			;AC000;    Get time in CX:DX
	xchg	ch,cl				;AN000; switch hours & minutes
	xchg	dh,dl				;AN000; switch seconds & hundredths
	mov	CurTim_hr_min,cx		;AC000; put hours and minutes into message subst block
	mov	CurTim_sec_hn,dx		;AC000; put seconds and hundredths into message subst block
	mov	dx,offset trangroup:CurTim_ptr	;AC000; set up message for output
	invoke	std_printf
;AD061; mov	CurTim_hr_min,0 		;AC000; reset hour, minutes, seconds, and hundredths
;AD061; mov	CurTim_sec_hn,0 		;AC000;     pointers in control block

GET_NEW_TIME:
	call	gettim				;AC000;
	cmp	ax,end_of_line			;AC000; are we at end of line?
	jz	time_end			;AC000;
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	timerr				;AN000; yes - go issue message

COMTIM:
	mov	ch,time_hour			;AC000; get parts of time in
	mov	cl,time_minutes 		;AC000;    cx and dx for set
	mov	dh,time_seconds 		;AC000;    time function call
	mov	dl,time_fraction		;AC000;
	push	cx				;AC000; save time
	push	dx				;AC000;
	mov	cx,1				;AC000; set 1 positional parm entered
	xor	dx,dx				;AN029;
	invoke	cmd_parse			;AN029; call parser
	cmp	al,end_of_line			;AN029; Are we at end of line?
	pop	dx				;AC000; retieve time
	pop	cx				;AC000;
	jnz	timerr				;AC000; extra stuff on line - try again

SAVTIM:
	MOV	AH,SET_TIME
	INT	21h
	OR	AL,AL
	JNZ	TIMERR				;AC000; if an error occured, try again

TIME_END:

	ret

TIMERR:
	invoke	crlf2				;AN028; print out a blank line
	MOV	DX,OFFSET TRANGROUP:BADTIM_ptr
	invoke	std_printf			; Print error message
	JMP	GET_NEW_TIME			;AC000; Try again


;
; Set the special flag in the INIT flag to the value in CX.
;
SetInitFlag:
	mov	ds,[RESSEG]
assume ds:resgroup
	and	InitFlag,NOT initSpecial
	or	InitFlag,cL
	push	cs
	pop	ds
	return

Public	PipeOff
PipeOff:
	ASSUME	DS:NOTHING,ES:NOTHING
	SaveReg <DS,AX>
	MOV	DS,ResSeg
	ASSUME	DS:RESGroup
	XOR	AL,AL
	XCHG	PipeFlag,AL
	OR	AL,AL
	JZ	PipeOffDone
	SHR	EchoFlag,1
PipeOffDone:
	RestoreReg  <AX,DS>
	return


PRINT_TIME:

	MOV	AH,GET_TIME
	INT	21h			; Get time in CX:DX

	PUSH	ES
	PUSH	CS
	POP	ES
	xchg	ch,cl				;AN000; switch hours & minutes
	xchg	dh,dl				;AN000; switch seconds & hundredths
	mov	promTim_hr_min,cx		;AC000; put hours and minutes into message subst block
	mov	promTim_sec_hn,dx		;AC000; put seconds and hundredths into message subst block
	mov	dx,offset trangroup:promTim_ptr ;AC000; set up message for output
	invoke	std_printf
;AD061; mov	promTim_hr_min,0		;AC000; reset hour, minutes, seconds, and hundredths
;AD061; mov	promTim_sec_hn,0		;AC000;     pointers in control block

	POP	ES
	return


; ****************************************************************
; *
; * ROUTINE:	 GETDAT - Prompt user for date
; *
; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
; *		 INFORMATION and issues the "Enter new date"
; *		 message with the proper date format.  COMBUF
; *		 is reset to get a date from the command line.
; *		 The PARSE_DATE blocks are then reset and the
; *		 PARSE function call is issued.
; *
; * INPUT:	 NONE
; *
; * OUTPUT:	 COMBUF
; *		 PARSER RETURN CODES
; *
; ****************************************************************


GETDAT	proc	near				;AC000;

	mov	ax,(International SHL 8)	; Determine what format the date
	mov	dx,5ch				;  should be entered in and
	int	21h			;  print a message describing it
	mov	si,dx
	lodsw
	mov	dx,usadat_ptr			;AC000; get mm-dd-yy
	dec	ax
	js	printformat
	mov	dx,eurdat_ptr			;AC000; get dd-mm-yy
	jz	printformat
	mov	dx,japdat_ptr			;AC000; get yy-mm-dd
printformat:
	mov	ax,dx				;AN000; get message number of format
	mov	dh,util_msg_class		;AN000; this is a utility message
	call	Tsysgetmsg			;AN000; get the address of the message
	mov	newdat_format,si		;AN000; put the address in subst block
	MOV	DX,OFFSET TRANGROUP:NEWDAT_ptr	;AC000; get address of message to print
	invoke	std_printf
	mov	newdat_format,no_subst		;AN000; reset subst block

	MOV	AH,STD_CON_STRING_INPUT
	MOV	DX,OFFSET TRANGROUP:COMBUF
	mov	cx,initSpecial			; Set bit in InitFlag that indicates
	call	SetInitFlag			;  prompting for date.
	INT	21h			; Get input line
	xor	cx,cx				; Reset bit in InitFlag that indicates
	call	SetInitFlag			;  prompting for date.
	invoke	CRLF2
	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	mov	di,offset trangroup:parse_date	;AN000; Get adderss of PARSE_DATE
	xor	cx,cx				;AN000; clear counter for positionals
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AC000; call parser

	ret

GETDAT	endp					;AC000;


; ****************************************************************
; *
; * ROUTINE:	 GETTIME - Prompt user for time
; *
; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
; *		 INFORMATION and issues the "Enter new time"
; *		 message. COMBUF is reset to get a time from the
; *		 command line.	The PARSE_TIME blocks are then
; *		 reset and the PARSE function call is issued.
; *
; * INPUT:	 NONE
; *
; * OUTPUT:	 COMBUF
; *		 PARSER RETURN CODES
; *
; ****************************************************************


GETTIM	proc	near				;AC000;

	XOR	CX,CX				; Initialize hours and minutes to zero
	MOV	DX,OFFSET TRANGROUP:NEWTIM_ptr
	invoke	std_printf
	MOV	AH,STD_CON_STRING_INPUT
	MOV	DX,OFFSET TRANGROUP:COMBUF
	mov	cx,initSpecial			; Set bit in InitFlag that indicates
	call	SetInitFlag			;  prompting for time.
	INT	21h			; Get input line
	xor	cx,cx				; Reset bit in InitFlag that indicates
	call	SetInitFlag			;  prompting for time.
	invoke	CRLF2
	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	mov	di,offset trangroup:parse_time	;AN000; Get adderss of PARSE_TIME
	xor	cx,cx				;AN000; clear counter for positionals
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AC000; call parser

	ret

GETTIM	endp					;AC000;

;
;Skip_white: Skips over the whitespace chars that could be present after
;the '=' sign in the environment variable before the actual path.
;
;	ENTRY:	ds:si = arguments of the environment variable
;
;	EXIT:	ds:si = start of the path
;
;	REGISTERS AFFECTED: ax
;

Skip_white	proc	near

	cld
skw_lp:
	lodsb
	cmp	al,' '				;blank char?
	jz	skw_lp				;yes, skip it
	cmp	al,09				;tab char?
	jz	skw_lp				;yes, skip it

	dec	si				;point at first non-white

	ret

Skip_white	endp

;
;Copy_pipe_path:	This routine copies the path from the TEMP environment
;variable into the path buffers Pipe1 & Pipe2.
;
;	ENTRY:	ds:si = path to be copied
;		es = RESGROUP
;
;	EXIT:	Path copied into Pipe1 and Pipe2.
;
;	REGISTERS AFFECTED: si, di, cx, ax
;

Copy_pipe_path	proc	near

	mov	cx,0ffffh
	xor	al,al

	mov	di,si
	push	es			;save es
	push	ds
	pop	es			;es:di = path to be copied
	
	cld
	push	di
	repnz	scasb			;look for the null char
	pop	di

	pop	es			;es = RESGROUP again

	not	cx			;length including the null

	mov	di,offset DATARES:Pipe1	
	push	di
	push	cx			
	rep	movsb			;copy path into Pipe1
	pop	cx
	pop	di

	push	ds
	push	es
	pop	ds			;ds:si = Pipe1
	mov	si,di
	mov	di,offset DATARES:Pipe2	;es:di = Pipe2
	rep	movsb			;copy path into Pipe2
	pop	ds

	ret				;

Copy_pipe_path	endp


TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\br\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR       "        DB      \"Erro de anlise %%1\"\x0d\x0a"
#define EXTENDED_STR    "        DB      \"Erro estendido %%1\"\x0d\x0a"
char    *ExtendedErrorText999 =  "\"Erro estendido %1\"";       /* Mar 88, SWN */
char    *ParserErrorText999 =  "\"Erro de anlise %1\"";    /* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tspc.asm ===
page ,132
;	SCCSID = @(#)tspc.asm	4.1 85/09/22
;	SCCSID = @(#)tspc.asm	4.1 85/09/22
TITLE	COMMAND Transient Uninitialized DATA
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

comment %

The TRANSPACE segment contains variable data that is considered
volatile between command cycles, and therefore is not included in the
transient checksum area.  Contents of these variables MUST be
initialized before use, and must not be relied upon from command
cycle to command cycle.

No constant data values should be stored here.

%
        



.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include find.inc
	include intnat.inc
	include comequ.asm
	include comseg.asm
.list
.cref

; Uninitialized transient data
TRANSPACE	SEGMENT PUBLIC BYTE

	PUBLIC	ALLSWITCH
	PUBLIC	append_exec		;AN041;
	PUBLIC	arg
	PUBLIC	argbufptr
	PUBLIC	ARGC
	PUBLIC	ARG1S
	PUBLIC	ARG2S
	PUBLIC	ARGTS
	PUBLIC	arg_buf
	PUBLIC	ASCII
        PUBLIC  AttrSelect
        PUBLIC  AttrSpecified
	PUBLIC	BatBuf
	PUBLIC	BatBufEnd
	PUBLIC	BatBufPos
	PUBLIC	BATHAND
	PUBLIC	BINARY
	PUBLIC	BITS
	PUBLIC	BWDBUF
	PUBLIC	BYTCNT
	PUBLIC	bytes_free
	PUBLIC	CFLAG
	PUBLIC	CHARBUF
	PUBLIC	CHKDRV
	PUBLIC	COM
	PUBLIC	COMBUF
	PUBLIC	comma
	PUBLIC	comptr
	PUBLIC	COMSW
	PUBLIC	CONCAT
	PUBLIC	copy_Num
	PUBLIC	CountryPtrInfo
	PUBLIC	CountryPtrId
	PUBLIC	CountryPtr
	PUBLIC	CPDATE
	PUBLIC	CPTIME
	PUBLIC	cpyflag
	PUBLIC	CURDRV
	PUBLIC	DATE_DAY		;AN000;
	PUBLIC	DATE_MONTH		;AN000;
	PUBLIC	DATE_OUTPUT		;AN000;
	PUBLIC	DATE_TYPE		;AN000;
	PUBLIC	DATE_YEAR		;AN000;
	PUBLIC	DEST
	PUBLIC	DESTBUF
	PUBLIC	DestClosed
	PUBLIC	DESTDIR
	PUBLIC	DESTFCB
	PUBLIC	DESTFCB2
	PUBLIC	DESTHAND
	PUBLIC	DESTINFO
	PUBLIC	DESTISDEV
	PUBLIC	DESTISDIR
	PUBLIC	DESTNAME
	PUBLIC	DESTSIZ
	PUBLIC	DESTSWITCH
	PUBLIC	DESTTAIL
	PUBLIC	DESTVARS
	PUBLIC	DIRBUF
	PUBLIC	DIRCHAR
	PUBLIC	dirflag 		;AN015;
	PUBLIC	Dir_Num
	PUBLIC	display_ioctl		;AN000;
	PUBLIC	display_mode		;AN000;
	PUBLIC	display_width		;AN000;
	PUBLIC	DRIVE_NUMBER		;AN000;
	PUBLIC	DRIVE_OUTPUT		;AN000;
	PUBLIC	DRIVE_TYPE		;AN000;
	PUBLIC	DRIVE_VALUE		;AN000;
	PUBLIC	ELCNT
	PUBLIC	ELPOS
	PUBLIC	ENDDESTBUF
	PUBLIC	EXECPATH
	PUBLIC	EXEC_ADDR
	PUBLIC	EXEFCB
	PUBLIC	expand_star
	PUBLIC	ext_entered		;AN005;
	PUBLIC	FBUF
        PUBLIC  FileCnt
        PUBLIC  FileCntTotal
        PUBLIC  FileSiz
        PUBLIC  FileSizTotal
	PUBLIC	file_size_high
	PUBLIC	file_size_low
	PUBLIC	FILTYP
	PUBLIC	FIRSTDEST
	PUBLIC	FRSTSRCH
	PUBLIC	GOTOLEN
	PUBLIC	HEADCALL
	PUBLIC	ID
	PUBLIC	IDLEN
	PUBLIC	IFNOTFLAG
	PUBLIC	if_not_count
	PUBLIC	INEXACT
	PUBLIC	INTERNATVARS
	PUBLIC	KPARSE
	PUBLIC	last_arg
        PUBLIC  PerLine
        PUBLIC  LeftOnLine
        PUBLIC  LeftOnPage
	PUBLIC	linperpag		;AN000;
	PUBLIC	major_ver_num
	PUBLIC	MELCOPY
	PUBLIC	MELSTART
	PUBLIC	minor_ver_num
	PUBLIC	msg_flag		;AN022;
	PUBLIC	msg_numb		;AN022;
	PUBLIC	NOWRITE
	PUBLIC	NXTADD
	PUBLIC	objcnt
	PUBLIC	OCtrlZ
	PUBLIC	OFilePtr_Hi
	PUBLIC	OFilePtr_Lo
	PUBLIC	OldCtrlCHandler
	PUBLIC	one_char_val
	PUBLIC	PARM1
	PUBLIC	PARM2
	PUBLIC	parse_last		;AN018;
	PUBLIC	PARSE1_ADDR		;AN000;
	PUBLIC	PARSE1_CODE		;AN000;
	PUBLIC	PARSE1_OUTPUT		;AN000;
	PUBLIC	PARSE1_SYN		;AN000;
	PUBLIC	PARSE1_TYPE		;AN000;
	PUBLIC	PATHCNT
	PUBLIC	pathinfo
	PUBLIC	PATHPOS
	PUBLIC	PATHSW
	PUBLIC	PLUS
	PUBLIC	plus_comma
	PUBLIC	print_err_flag		;AN000;
	PUBLIC	psep_char
	PUBLIC	RCH_ADDR
	PUBLIC	RDEOF
	PUBLIC	RE_INSTR
	PUBLIC	RESSEG
	PUBLIC	SCANBUF
	PUBLIC	SDIRBUF
	PUBLIC	search_best
	PUBLIC	search_best_buf
	PUBLIC	search_curdir_buf
	PUBLIC	search_error
	PUBLIC	SKPDEL
	PUBLIC	SOURCE
	PUBLIC	SPECDRV
	PUBLIC	SRCBUF
	PUBLIC	SRCHAND
	PUBLIC	SRCINFO
	PUBLIC	SRCISDEV
	PUBLIC	SRCISDIR
	PUBLIC	SRCPT
	PUBLIC	SRCSIZ
	PUBLIC	SRCTAIL
	PUBLIC	SRCVARS
	PUBLIC	srcxname
	PUBLIC	STACK
	PUBLIC	STARTEL
	PUBLIC	string_ptr_2
;AD061; PUBLIC	string_ptr_2_sb 	;AN000;
	PUBLIC	subst_buffer		;AN061;
	PUBLIC	SWITCHAR
	PUBLIC	system_cpage
	PUBLIC	TERMREAD
	PUBLIC	TIME_FRACTION		;AN000;
	PUBLIC	TIME_HOUR		;AN000;
	PUBLIC	TIME_MINUTES		;AN000;
	PUBLIC	TIME_OUTPUT		;AN000;
	PUBLIC	TIME_SECONDS		;AN000;
	PUBLIC	TIME_TYPE		;AN000;
	PUBLIC	TPA
	PUBLIC	tpbuf
	PUBLIC	TRANSPACEEND
	PUBLIC	TRAN_TPA
	PUBLIC	trgxname
	PUBLIC	UCOMBUF
	PUBLIC	USERDIR1
	PUBLIC	vol_drv
	PUBLIC	vol_ioctl_buf		;AC030;
	PUBLIC	vol_serial		;AC030;
	PUBLIC	vol_label		;AC030;
	PUBLIC	WRITTEN
	PUBLIC	zflag
	PUBLIC	ENV_PTR_SEG
	PUBLIC	ENV_SIZE
	PUBLIC	CMD_PTR_SEG
	PUBLIC	CMD_PTR_OFF
        PUBLIC  CMD_SIZE
        PUBLIC  SCS_EXIT_CODE
	PUBLIC	SCS_CUR_DRIVE
	PUBLIC	SCS_NUM_DRIVES
	PUBLIC	SCS_STD_HANDLE
	PUBLIC	SCS_STD_BITS
        PUBLIC  SCS_CODEPAGE
        PUBLIC  SCS_TSREXIT
        PUBLIC  SCS_BATSTATUS
        PUBLIC  SCS_RDRINFO
        PUBLIC  EXECPATH_SEG
        PUBLIC  EXECPATH_OFF
        PUBLIC  EXECPATH_SIZE
	PUBLIC	EXECEXT_TYPE

	Public	TypeFilSiz		;stores size of file to be typed

	IF  IBM
	PUBLIC	ROM_CALL
	PUBLIC	ROM_CS
	PUBLIC	ROM_IP
	ENDIF


	ORG	0
ZERO	=	$
SRCXNAME	DB	DIRSTRLEN + 20 DUP (?)	;g buffer for name translate
TRGXNAME	DB	DIRSTRLEN + 20 DUP (?)	;g buffer for name translate
JUNK1		DB	2(?)
FOO_JUNK	DB	2 (?)
UCOMBUF 	DB	COMBUFLEN+3 DUP(?)	; Raw console buffer
COMBUF		DB	COMBUFLEN+3 DUP(?)	; Cooked console buffer
USERDIR1	DB	DIRSTRLEN+3 DUP(?)	; Storage for users current directory
;EXECPATH        DB      COMBUFLEN+3 DUP(?)      ; Path for external command
EXECPATH        DB      EXECPATHLEN DUP(?)       ; ntvdm MAX_PATH+13 extended
RE_INSTR        DB      DIRSTRLEN+3+13 DUP (?)  ; path for input to redirection


; sudeepb - start of cmdinfo structure (it should always match cmdsvc.h
; definition of cmdinfo.

ENV_PTR_SEG	DW	?
ENV_SIZE	DW	?
SCS_CUR_DRIVE	DW	?
SCS_NUM_DRIVES	DW	?
CMD_PTR_SEG	DW	?
CMD_PTR_OFF	DW	?
CMD_SIZE        DW      ?
SCS_EXIT_CODE   DW      ?
SCS_STD_HANDLE	DW	0
SCS_RDRINFO     DD      0
SCS_CODEPAGE    DW      ?
SCS_TSREXIT     DW      0
SCS_BATSTATUS   DW      0
EXECPATH_SEG    DW      0
EXECPATH_OFF    DW      0
EXECPATH_SIZE   DW      0
EXECEXT_TYPE	DW	0

; end of cmdinfo

SCS_STD_BITS    DB      0

; Variables passed up from resident
HEADCALL	LABEL	DWORD
		DW	?
RESSEG		DW	?
TPA		DW	?
SWITCHAR	DB	?
DIRCHAR 	DB	?
EXEC_ADDR	DD	?
RCH_ADDR	DD	?
fTest		DW	?
TRAN_TPA	DW	?

CHKDRV		DB	?
RDEOF		LABEL	BYTE			; Misc flags
IFNOTFLAG	LABEL	BYTE
FILTYP		DB	?
CURDRV		DB	?
CONCAT		LABEL	BYTE
PARM1		DB	?
ARGC		LABEL	BYTE
PARM2		DB	?
COMSW		DW	?			; Switches between command and 1st arg
ARG1S		DW	?			; Switches between 1st and 2nd arg
DESTSWITCH	LABEL	WORD
ARG2S		DW	?			; Switches after 2nd arg
ALLSWITCH	LABEL	WORD
ARGTS		DW	?			; ALL switches except for COMSW
CFLAG		DB	?
DESTCLOSED	LABEL	BYTE
SPECDRV 	DB	?
BYTCNT		DW	?			; Size of buffer between RES and TRANS
NXTADD		DW	?
FRSTSRCH	DB	?
LeftOnLine      DB      ?                       ; entries left on line u.b. DIR
PerLine         DB      ?                       ; entries/line u.b. DIR
LeftOnPage      DW      ?                       ; lines left on page u.b. DIR
FileCnt         DW      ?                       ; file count u.b. DIR
FileSiz         DD      ?                       ; file size u.b. DIR

;               Note:  keep FileCntTotal & FileSizTotal adjacent.

FileCntTotal    DD      ?                       ; total file count u.b. DIR
FileSizTotal    DD      ?                       ; total file size u.b. DIR
CHARBUF 	DB	80 DUP (?)		;line byte character buffer for xenix write
DESTFCB2	LABEL	BYTE
IDLEN		DB	?
ID		DB	8 DUP(?)
COM		DB	3 DUP(?)
DEST		DB	37 DUP(?)
DESTNAME	DB	11 DUP(?)
DESTFCB 	LABEL	BYTE
DESTDIR 	DB	DIRSTRLEN DUP(?)	; Directory for PATH searches
GOTOLEN 	LABEL	WORD
BWDBUF		LABEL	BYTE
EXEFCB		LABEL	WORD
DIRBUF		DB	DIRSTRLEN+3 DUP(?)
SDIRBUF 	DB	12 DUP(?)
BITS		DW	?
PATHCNT 	DW	?
PATHPOS 	DW	?
PATHSW		DW	?
AttrSpecified   db      ?                       ; attribute bits u.b. DIR
AttrSelect      db      ?                       ; attribute bits u.b. DIR
comma		db	0			;g flag set if +,, occurs
plus_comma	db	0			;g flag set if +,, occurs
dirflag 	db	0			;AN015; set when pathcrunch called from DIR
parse_last	dw	0			;AN018; used to hold parsing position

system_cpage	DW	0			;AC001; used for CHCP variable



arg_buf 	db	128 dup (?)
file_size_low	dw	?			;AC000;
file_size_high	dw	?			;AC000;
string_ptr_2	dw	?
;AD061;string_ptr_2_sb dw      ?
copy_Num	dw	?
cpyflag 	db	?
Dir_Num 	DW	?
bytes_free	dw	?
		dw	?
major_ver_num	dw	?
minor_ver_num	dw	?
one_char_val	db	?,0
vol_drv 	db	?

IF  IBM
ROM_CALL	DB	?			; flag for rom function
ROM_IP		DW	?
ROM_CS		DW	?
ENDIF

DESTVARS	LABEL	BYTE
DESTISDIR	DB	?
DESTSIZ 	DB	?
DESTTAIL	DW	?
DESTINFO	DB	?
DESTBUF 	DB	DIRSTRLEN + 20 DUP (?)
ENDDESTBUF	LABEL	BYTE

DESTHAND	DW	?
DESTISDEV	DB	?
FIRSTDEST	DB	?
MELCOPY 	DB	?
MELSTART	DW	?

SRCVARS 	LABEL	BYTE
SRCISDIR	DB	?
SRCSIZ		DB	?
SRCTAIL 	DW	?
SRCINFO 	DB	?
SRCBUF		DB	DIRSTRLEN + 20 DUP (?)

SRCHAND 	DW	?
SRCISDEV	DB	?

SCANBUF 	DB	DIRSTRLEN + 20 DUP (?)

SRCPT		DW	?
INEXACT 	DB	?
NOWRITE 	DB	?
BINARY		DB	?
WRITTEN 	DW	?
TERMREAD	DB	?
ASCII		DB	?
PLUS		DB	?
objcnt		db	?		; Used in copy
CPDATE		DW	?
CPTIME		DW	?

OFilePtr_Lo	DW	?		; original file ptr for COPY when
OFilePtr_Hi	DW	?		; 1st source is also destination
OCtrlZ		DB	?		; original ctrl+Z for COPY when ditto

BATHAND 	DW	?		; Batch handle
STARTEL 	DW	?
ELCNT		DB	?
ELPOS		DB	?
SKPDEL		DB	?
SOURCE		DB	11 DUP(?)

ext_entered	db	0			;AN005;

display_ioctl	db	0			;AN000; info level
		db	0			;AN000; reserved
		dw	crt_ioctl_ln		;AN000; length of data
		dw	?			;AN000; control flags
display_mode	db	?			;AN000; display mode, colors
		db	0			;AN000; reserved
		dw	?			;AN023; colors
		dw	?			;AN000; display width (PELS)
		dw	?			;AN000; display length (PELS)
display_width	dw	?			;AN000; display width
linperpag	dw	linesperpage		;AN000; display length (default to linesperpage)

vol_ioctl_buf	label	byte			;AN000; buffer for ioctl volume label/serial call
		dw	0			;AN000; info level
vol_serial	dd	0			;AN000; volume serial number
vol_label	db	11 dup (" ")            ;AN000; volume label - init to blanks
		db	8  dup (" ")            ;AN000; file system type

expand_star	db	?
msg_flag	db	?			;AN022; flag set if non-utility message issued
msg_numb	dw	0			;AN022; set with extended error message issued
append_exec	db	0			;AN041; set if internal append executed
print_err_flag	dw	0			;AN000; flag set if error during sysdispmsg
subst_buffer	db	parm_block_size*2 dup (0);AN061;

;;;;	IFDEF	DBCS		3/3/KK
KPARSE		DB	?
;;;;	ENDIF			3/3/KK

; Data declarations taken out of parse.asm

arg	arg_unit	<>			; pointers, arg count, string buffer
argbufptr	DW	?			; index for argv[].argpointer
tpbuf		DB	128   DUP (?)		; temporary buffer
LAST_ARG	DW	?			; point at which to accumulate switch info
comptr		dw	?			; ptr into combuf

; Data declarations taken out of path.asm
fbuf	find_buf	<>			; dma buffer for findfirst/findnext
pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
psep_char	DB	?			; '/' or '\'
search_best	DB	(?)			; best code, best filename so far
fname_max_len	equ	13
search_best_buf DB	fname_max_len DUP (?)
search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
search_error	DW	(?)			; address of error message to be printed

; Data declarations taken out of tbatch.asm
if_not_count	DW	?

zflag		db	?			; Used by typefil to indicate ^Z's

		DW	80H DUP(0)		; Init to 0 to make sure the linker is not fooled
STACK		LABEL	WORD

INTERNATVARS	internat_block <>
		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)

;		Buffer for DOS function 64h (Get extended country information)
;		subfunctions 2, 4, 6, or 7:

CountryPtrInfo	label	byte
CountryPtrId	db	?
CountryPtr	dd	?
		.erre	(($ - CountryPtrInfo) GE 5)

OldCtrlCHandler	dd	?			; previous int 23 vector


BatBufPos	DW	?			; integer position in buffer of next byte
BatBuf		DB	BatLen DUP (?)
BatBufEnd	DW	?

TypeFilSiz	dd	?		;stores size of file to be typed

; *****************************************************
; EMG 4.00
; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
; *****************************************************
;
; COMMON PARSE OUTPUT BLOCKS
;


;
; Common output blocks for PARSE number, complex, or string values.
;

PARSE1_OUTPUT	LABEL	BYTE			;AN000;
PARSE1_TYPE	DB	0			;AN000;  type
PARSE1_CODE	DB	0			;AN000;  return value
PARSE1_SYN	DW	0			;AN000;  es offset of synonym
PARSE1_ADDR	DD	0			;AN000;  numeric value / address
						;	 of string value

;
;  Common output block for PARSE date strings.
;

DATE_OUTPUT	LABEL	BYTE			;AN000;
DATE_TYPE	DB	0			;AN000;  type
		DB	0			;AN000;  return value
		DW	0			;AN000;  es offset of synonym
DATE_YEAR	DW	0			;AN000;  year
DATE_MONTH	DB	0			;AN000;  month
DATE_DAY	DB	0			;AN000;  day

;
;  Common output block for PARSE time strings.
;

TIME_OUTPUT	LABEL	BYTE			;AN000;
TIME_TYPE	DB	0			;AN000;  type
		DB	0			;AN000;  return value
		DW	0			;AN000;  es offset of synonym
TIME_HOUR	DB	0			;AN000;  hour
TIME_MINUTES	DB	0			;AN000;  minutes
TIME_SECONDS	DB	0			;AN000;  seconds
TIME_FRACTION	DB	0			;AN000;  hundredths

;
;  Common output block for PARSE drive specifier (one based drive number).
;

DRIVE_OUTPUT	LABEL	BYTE			;AN000;
DRIVE_TYPE	DB	0			;AN000;  type
DRIVE_VALUE	DB	0			;AN000;  return value
		DW	0			;AN000;  es offset of synonym
DRIVE_NUMBER	DB	0			;AN000;  drive number
		DB	0,0,0			;AN000;  reserved

TRANSPACEEND	LABEL	BYTE

TRANSPACE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tprintf.asm ===
page ,132
;	SCCSID = @(#)tprintf.asm	4.3 85/07/02
;	SCCSID = @(#)tprintf.asm	4.3 85/07/02
TITLE	COMMAND Transient Printf routine
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M025	SR	9/12/90	Removed calls to SetStdInOn,SetStdInOff
;				SetStdOutOn & SetStdOutOff.
;


;****************************************************************
;*
;* ROUTINE:	STD_PRINTF/STD_EPRINTF
;*
;* FUNCTION:	Set up to print out a message using SYSDISPMSG.
;*		Set up substitutions if utility message.  Make
;*		sure any changes to message variables in TDATA
;*		are reset to avoid reloading the transient.
;*
;* INPUT:	Msg_Disp_Class	-  set to message class
;*		Msg_Cont_Flag	-  set to control flags
;*		DS	points to transient segment
;*
;*		if utility message:
;*		DX	points to a block with message number
;*			(word), number of substitutions (byte),
;*			followed by substitution list if there
;*			are substitutions.  If substitutions
;*			are not in transient segment they must
;*			be set.
;*		else
;*		AX	set to message number
;*
;* OUTPUT:	none
;*
;****************************************************************

.xlist
.xcref
	INCLUDE comsw.asm		;AC000;
	INCLUDE DOSSYM.INC
	INCLUDE comseg.asm
	INCLUDE comequ.asm		;AN000;
	INCLUDE SYSMSG.INC		;AN000;
.list
.cref

datares segment public
	extrn	pipeflag:byte
datares ends

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	extend_buf_off:word	;AN000;
	EXTRN	Extend_Buf_ptr:word	;AN000;
	EXTRN	Extend_Buf_seg:word	;AN000;
	EXTRN	Msg_Cont_Flag:byte	;AN000;
	EXTRN	Msg_disp_Class:byte	;AN000;
	EXTRN	pipeemes_ptr:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	msg_flag:byte		;AN022;
	EXTRN	print_err_flag:word	;AN000;
	EXTRN	RESSEG:WORD
	EXTRN	String_ptr_2:word	;AC000;
	EXTRN	Subst_buffer:byte	;AN061;
;AD061; EXTRN	String_ptr_2_sb:word	;AN000;

	; include data area for message services

	MSG_UTILNAME <COMMAND>		;AN000; define utility name

	MSG_SERVICES <MSGDATA>		;AN000;

PRINTF_HANDLE	DW  ?			;AC000;

TRANSPACE	ENDS			;AC000;

TRANCODE	SEGMENT PUBLIC BYTE	;AC000;

	EXTRN	cerror:near
	EXTRN	crlf2:near
	EXTRN	tcommand:near		;AN026;

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING,SS:NOTHING ;AC000;

	PUBLIC	TSYSGETMSG		;AN000;
	PUBLIC	TSYSLOADMSG		;AN000;

PUBLIC Printf_Init
printf_init proc far
	call	std_printf
	ret
printf_init endp

Public	Printf_Crlf
PRINTF_CRLF:
	CALL	STD_PRINTF
	CALL	CRLF2
	RET

PUBLIC	Std_EPrintf
STD_EPRINTF:
	mov	Printf_Handle,2 		;AC000;Print to STDERR
	jmp	short NEW_PRINTF		;AC000;
PUBLIC	Std_Printf
STD_PRINTF:
	mov	Printf_Handle,1 		;AC000;Print to STDOUT

NEW_PRINTF:
	push	ax				;AN000;save registers
	push	bx				;AN000;
	push	cx				;AN000;
	push	es				;AN000;get local ES
	push	ds				;AN000;
	pop	es				;AN000;
	push	di				;AN000;
	push	si				;AN000;
	push	dx				;AN000;
	assume	es:trangroup			;AN000;
;AD061; mov	string_ptr_2_sb,0		;AN000;initialize
	mov	print_err_flag,0		;AN000;

UTILITY_SETUP:
	mov	si,dx				;AN000;Get offset of message number
	lodsw					;AN000;load message number
	push	ax				;AN000;save it
	lodsb					;AN000;get number of substitutions
	mov	cl,al				;AN000;set up CX as # of subst
	xor	ch,ch				;AN000;   SI now points to subst list
	pop	ax				;AN000;get message number back
	cmp	cx,0				;AN000;Any substitutions?
	jz	READY_TO_PRINT			;AN000;No - continue

;AD061;  add	 dx,Ptr_Seg_Pos 		 ;AN000;Point to position of first segment
;AD061;  push	 cx				 ;AN000;save substitution count

;AD061;SET_SUBST:
;AD061;  mov	 bx,dx				 ;AN000;get dx into base register
;AD061;  cmp	 word ptr [bx],0		 ;AN000;has segment been set?
;AD061;  jnz	 SUBST_SEG_SET			 ;AN000;if not 0, don't replace it
;AD061;  test	 word ptr [bx+3],date_type	 ;AN000;if date or time - don't set segment
;AD061;  jnz	 subst_seg_set			 ;AN000;yes - skip it
;AD061;  mov	 word ptr [bx],cs		 ;AN000;put segment of subst parm in list

;AD061;SUBST_SEG_SET:
;AD061;  add	 dx,Parm_Block_Size		 ;AN000;point to position of next segment
;AD061;  loop	 SET_SUBST			 ;AN000;keep replacing until complete
;AD061;  pop	 cx				 ;AN000;

;AD061;NO_REPLACEMENT:
;AD061;  mov	 bx,parm_off_pos [si]		 ;AN000;get subst offset
;AD061;  cmp	 bx,offset trangroup:string_ptr_2 ;AN000;this is used for double indirection
;AD061;  jnz	 ready_to_print 		 ;AN000;we already have address
;AD061;  mov	 dx,string_ptr_2		 ;AN000;get address in string_ptr_2
;AD061;  mov	 parm_off_pos [si],dx		 ;AN000;put proper address in table
;AD061;  mov	 string_ptr_2_sb,si		 ;AN000;save block changed

	mov	di,offset trangroup:subst_buffer;AN061; Get address of message subst buffer
	push	di				;AN061; save it
	push	cx				;AN061; save number of subst

MOVE_SUBST:
	push	cx				;AN061;save number of subst
	mov	bx,si				;AN061;save start of sublist
	mov	cx,parm_block_size		;AN061;get size of sublist
	rep	movsb				;AN061;move sublist
	test	byte ptr [bx.$M_S_FLAG],date_type ;AN061;are we doing date/time?
	jz	move_subst_cont 		;AN061;no - no need to reset
	mov	word ptr [bx.$M_S_VALUE],0	;AN061;reset original date or time to 0
	mov	word ptr [bx.$M_S_VALUE+2],0	;AN061;

MOVE_SUBST_CONT:				;AN061;
	pop	cx				;AN061;get number of subst back
	loop	move_subst			;AN061;move cx sublists

	pop	cx				;AN061;get number of subst
	push	ax				;AN061;save message number
	cmp	Msg_Disp_Class,Util_Msg_Class	;AN061;Is this a utility message
	jz	CHECK_FIX			;AN061;YES - go see if substitutions
	mov	msg_flag,ext_msg_class		;AN061;set message flag
	mov	di,offset trangroup:extend_buf_ptr ;AN061; Get address of extended message block
	xor	ax,ax				;AN061;clear ax register
	stosw					;AN061;clear out message number
	stosb					;AN061;clear out subst count

CHECK_FIX:					;AN061;
	pop	ax				;AN061;get message number back
	pop	di				;AN061;get start of sublists
	mov	si,di				;AN061;get into SI for msgserv
	mov	bx,si				;AN061;get into BX for addressing
	push	cx				;AN061;save number of subst

SET_SUBST:					;AN061;store the segment of the subst
	cmp	word ptr [bx.$M_S_VALUE+2],0	;AN061;was it set already?
	jnz	subst_seg_set			;AN061;if not 0, don't replace it
	test	byte ptr [bx.$M_S_FLAG],date_type ;AN061;don't replace if date or time
	jnz	subst_seg_set			;AN061;yes - skip it
	mov	word ptr [bx.$M_S_VALUE+2],cs	;AN061;set segment value

SUBST_SEG_SET:					;AN061;
	add	bx,parm_block_size		;AN061;go to next sublist
	loop	set_subst			;AN061;loop CX times
	pop	cx				;AN061;get number of subst back

	mov	bx,si				;AN061;get start of sublist to BX
	cmp	word ptr [bx.$M_S_VALUE],offset trangroup:string_ptr_2 ;AN061;are we using double indirection?
	jnz	ready_to_print			;AN061;no - we already have address
	mov	dx,string_ptr_2 		;AN061;get address in string_ptr_2
	mov	word ptr [bx.$M_S_VALUE],dx	;AN061;put it into the subst block

READY_TO_PRINT:
	mov	bx,Printf_Handle		;AN000;get print handle
	mov	dl,Msg_Cont_Flag		;AN000;set up control flag
	mov	dh,Msg_Disp_Class		;AN000;set up display class
	mov	Msg_Cont_Flag,No_Cont_Flag	;AN061;reset flags to avoid
	mov	Msg_Disp_Class,Util_Msg_Class	;AN061;   transient reload

;AD061; push	bx				;AN026; save registers
;AD061; push	cx				;AN026;
;AD061; push	dx				;AN026;
;AD061; push	si				;AN026;
;AD061; push	di				;AN026;
	push	ds				;AN026;
	push	es				;AN026;


	call	SYSDISPMSG			;AN000;call Rod

	pop	es				;AN026; restore registers
	pop	ds				;AN026;
;AD061; pop	di				;AN026;
;AD061; pop	si				;AN026;
;AD061; pop	dx				;AN026;
;AD061; pop	cx				;AN026;
;AD061; pop	bx				;AN026;

	jnc	Print_success			;AN000; everything went okay
	mov	print_err_flag,ax		;AN000;

print_success:
;AD061; cmp	Msg_Disp_Class,Util_Msg_Class	;AN000;Is this a utility message
;AD061; jz	CHECK_FIX			;AN000;YES - go see if substitutions
;AD061; mov	msg_flag,ext_msg_class		;AN022;set message flag
;AD061; mov	di,offset trangroup:extend_buf_ptr ;AN000; Get address of extended message block
;AD061; xor	ax,ax				;AN000;clear ax register
;AD061; stosw					;AN000;clear out message number
;AD061; stosb					;AN000;clear out subst count

;AD061;  CHECK_FIX:
;AD061;  pop	 dx				 ;AN000;restore dx
;AD061;  cmp	 cx,0				 ;AN000;Any substitutions?
;AD061;  jz	 NO_FIXUP			 ;AN000;No - leave

;AD061;  mov	 si,dx				 ;AN000;Reset changes so transient won't reload
;AD061;  add	 si,Ptr_Seg_Pos 		 ;AN000;Point to position of first segment

;AD061;FIX_SUBST:
;AD061;  mov	 word ptr [si],0		 ;AN000;reset segment to 0
;AD061;  add	 si,Parm_Block_Size		 ;AN000;point to position of next segment
;AD061;  loop	 FIX_SUBST			 ;AN000;keep replacing until complete
;AD061;  cmp	 string_ptr_2_sb,no_subst	 ;AN000;was double indirection used?
;AD061;  jz	 no_fixup			 ;AN000;no - we're finished
;AD061;  mov	 si,string_ptr_2_sb		 ;AN000;get offset changed
;AD061;  mov	 parm_off_pos [si],offset trangroup:string_ptr_2 ;AN000; set address back to string_ptr_2

;AD061;NO_FIXUP:
;AD061; mov	Msg_Cont_Flag,No_Cont_Flag	;AN000;reset flags to avoid
;AD061; mov	Msg_Disp_Class,Util_Msg_Class	;AN000;   transient reload
	pop	dx				;AN061;restore dx
	pop	si				;AN000;restore registers
	pop	di				;AN000;
	pop	es				;AN000;restore registers
	pop	cx				;AN000;
	pop	bx				;AN000;
	pop	ax				;AN000;
	cmp	print_err_flag,0		;AN000; if an error occurred - handle it
	jnz	print_err			;AN000;

	ret					;AC000;

print_err:
	push	cs
	pop	es
	cmp	Printf_Handle,2 		;AN026;Print to STDERR?
	jnz	not_stderr			;AN026;no - continue
	jmp	tcommand			;AN026;Yes - hopless - just exit

not_stderr:
	mov	ax,print_err_flag		;AN026;get extended error number back
	mov	es,[resseg]			; No, set up for error, load the
assume	es:resgroup				;  right error msg, and jmp to cerror.
	test	PipeFlag,-1
	jz	go_to_error
	invoke	PipeOff
	mov	dx,offset trangroup:pipeemes_ptr
	jmp	short print_err_exit			;AC000;

go_to_error:
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,ax		;AN000; get message number in control block

PRINT_ERR_EXIT: 				;AC000;
	push	cs
	pop	es
	JMP	CERROR

;****************************************************************
;*
;* ROUTINE:	TSYSLOADMSG
;*
;* FUNCTION:	Interface to call SYSLOADMSG to avoid duplicate
;*		names since these routines are also used in the
;*		resident.
;*
;* INPUT:	Inputs to SYSLOADMSG
;*
;* OUTPUT:	Outputs from SYSLOADMSG
;*
;****************************************************************


TSYSLOADMSG	PROC	NEAR			;AN000;

	push	bx				;AN000;
	call sysloadmsg 			;AN000; call routine
	pop	bx				;AN000;
	ret					;AN000; exit

TSYSLOADMSG	ENDP				;AN000;

;****************************************************************
;*
;* ROUTINE:	TSYSGETMSG
;*
;* FUNCTION:	Interface to call SYSGETMSG to avoid duplicate
;*		names since these routines are also used in the
;*		resident.
;*
;* INPUT:	Inputs to SYSGETMSG
;*
;* OUTPUT:	Outputs from SYSGETMSG
;*
;****************************************************************


TSYSGETMSG	PROC	NEAR			;AN000;

	push	cx				;AN000;
	call sysgetmsg				;AN000; call routine
	pop	cx				;AN000;
	ret					;AN000; exit

TSYSGETMSG	ENDP				;AN000;

MSG_SERVICES <COMT,NOVERCHECKmsg,NEARmsg,LOADmsg,NOCHECKSTDIN,NOCHECKSTDOUT,GETmsg> ;AC026; The message services
MSG_SERVICES <COMT,NEARmsg,SETSTDIO,DISPLAYmsg,CHARmsg,NUMmsg,TIMEmsg,DATEmsg>	    ;AC026; The message services

PRINTF_LAST LABEL   WORD

include msgdcl.inc


TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tranmsg.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
include version.inc

;
;	Revision History
;	================
;
;	M016	SR 	08/09/90	Added 2 error messages for LoadHigh
;
;



;****************************************************
;* TRANSIENT MESSAGE POINTERS & SUBSTITUTION BLOCKS *
;****************************************************

msg_disp_class	db	Util_msg_class
msg_cont_flag	db	No_cont_flag

;  extended error string output
;
Extend_Buf_ptr	dw	0				;AN000;set to no message
Extend_Buf_sub	db	0				;AN000;set to no substitutions
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
Extend_Buf_off	dw	OFFSET	TranGroup:String_ptr_2	;AN000;offset of arg
Extend_Buf_seg	dw	0				;AN000;segment of arg
		db	0				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	0				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Duplicate file name or file not found"
;
Renerr_Ptr	dw	1002				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid path or file name"
;
BadCPMes_Ptr	dw	1003				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Insufficient disk space"
;
NoSpace_Ptr	dw	1004				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Out of environment space"
;
EnvErr_Ptr	dw	1007				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "File creation error"
;
FulDir_Ptr	dw	1008				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Batch file missing",13,10
;
BadBat_Ptr	dw	1009				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Insert disk with batch file",13,10
;
NeedBat_Ptr	dw	1010				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Bad command or file name",13,10
;
BadNam_Ptr	dw	1011				;AN000;message number
		db	no_subst			;AN000;number of subst


;  "Access denied",13,10
;
AccDen_Ptr	dw	1014				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "File cannot be copied onto itself",13,10
;
OverWr_Ptr	dw	1015				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Content of destination lost before copy",13,10
;
LostErr_Ptr	dw	1016				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid filename or file not found",13,10
;
InOrNot_Ptr	dw	1017				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "%1 File(s) copied",13,10
;
Copied_Ptr	dw	1018				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Copy_num	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	9				;AN000;maximum width
		db	9				;AN000;minimum width
		db	blank				;AN000;pad character

;  "%1 File(s) "
;
DirMes_Ptr	dw	1019				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Dir_num	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	9				;AN000;maximum width
		db	9				;AN000;minimum width
		db	blank				;AN000;pad character

;  "%1 bytes free",13,10
;
BytMes_Ptr	dw	1020				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Bytes_Free	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_DWord	;AN000;long binary to decimal
ifdef   KOREA
                db      11                              ; <MSCH>
                db      11                              ; <MSCH>
else
		db	28				;AN000;maximum width
		db	28				;AN000;minimum width
endif   ; KOREA
		db	blank				;AN000;pad character

;  "Invalid drive specification",13,10
;
BadDrv_Ptr	dw	1021				;AN000;message number
		db	no_subst			;AN000;number of subst


;  "Code page %1 not prepared for system",13,10
;
CP_not_set_Ptr	dw	1022				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:System_cpage	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	5				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Code page %1 not prepared for all devices",13,10
;
CP_not_all_Ptr	dw	1023				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:System_cpage	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	5				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Active code page: %1",13,10
;
CP_active_Ptr	dw	1024				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:System_cpage	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	5				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "NLSFUNC not installed",13,10
;
NLSFUNC_Ptr	dw	1025				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid code page",13,10
;
Inv_Code_Page	dw	1026				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Current drive is no longer valid"
;
BadCurDrv	dw	1027				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Press any key to continue"
;
PauseMes_Ptr	dw	1028				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Label not found",13,10
;
BadLab_Ptr	dw	1029				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Syntax error",13,10
;
SyntMes_Ptr	dw	1030				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid date",13,10
;
BadDat_Ptr	dw	1031				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Current date is %1 %2",13,10
;
CurDat_Ptr	dw	1032				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Arg_Buf	;AN000;offset of arg
		dw	0				;AN000;segment of arg
IFNDEF DBCS						; MSKK03 07/14/89
		db	1				;AN000;first subst
  ELSE
    IFDEF JAPAN
		db	2				;AN000;first subst
    ELSE
		db	1				;AN000;first subst
    ENDIF
ENDIF
		db	Char_field_ASCIIZ		;AN000;character string
IFNDEF DBCS
		db	3				;AN000;maximum width
		db	3				;AN000;minimum width
  ELSE
    IFDEF JAPAN						; MSKK02 07/14/89
		db	4				;AN000;maximum width
		db	4				;AN000;minimum width
    ENDIF
    IFDEF TAIWAN
		db	6				;AN000;maximum width
		db	6				;AN000;minimum width
    ENDIF
    IFDEF KOREA
                db      2               ;3 Keyl               ;AN000;maximum width
                db      2               ;3 Keyl               ;AN000;minimum width
    ENDIF
ENDIF
		db	blank				;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
CurDat_yr	dw	0				;AN000;year
CurDat_mo_day	dw	0				;AN000;month,day
IFNDEF DBCS						; MSKK03 07/14/89
		db	2				;AN000;second subst
  ELSE
    IFDEF JAPAN
		db	1				;AN000;second subst
    ELSE
		db	2				;AN000;second subst
    ENDIF
ENDIF

		db	DATE_MDY_4			;AN000;date
		db	10				;AN000;maximum width
		db	10				;AN000;minimum width
		db	blank				;AN000;pad character


;  "SunMonTueWedThuFriSat"
;
WeekTab 	dw	1033				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Enter new date (%1):"
;
NewDat_Ptr	dw	1034				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
NewDat_Format	dw	0				;AN000;offset of replacement
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	8				;AN000;maximum width
		db	8				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Invalid time",13,10
;
BadTim_Ptr	dw	1035				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Current time is %1",13,10
;
CurTim_Ptr	dw	1036				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
CurTim_hr_min	dw	0				;AN000;hours,minutes
CurTim_Sec_hn	dw	0				;AN000;seconds,hundredths
		db	1				;AN000;first subst
		db	Right_Align+TIME_HHMMSSHH_Cty	;AC059;time
		db	12				;AC059;maximum width
		db	12				;AC059;minimum width
		db	blank				;AN000;pad character

;  "Enter new time:"
;
NewTim_Ptr	dw	1037				;AN000;message number
		db	no_subst			;AN000;number of subst

;  ",    Delete (Y/N)?",13,10
;
Del_Y_N_Ptr	dw	1038				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "All files in directory will be deleted!",13,10
;  "Are you sure (Y/N)?",13,10
;
SureMes_Ptr	dw	1039				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Microsoft DOS Version %1.%2",13,10
;
VerMes_Ptr	dw	1040				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Major_Ver_Num ;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
ifndef NEC_98
		db	2				;AN000;maximum width
else    ;NEC_98
                db      1                               ;AN000;maximum width
endif   ;NEC_98
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Minor_Ver_Num ;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	2				;AN000;second subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	2				;AN000;maximum width
		db	2				;AN000;minimum width
		db	"0"                             ;AN000;pad character

;  "Volume in drive %1 has no label",13,10
;
VolMes_Ptr_2	dw	1041				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:vol_drv	;AN000;offset of drive
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_Char 		;AN000;character
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Volume in drive %1 is %2",13,10
;
VolMes_Ptr	dw	1042				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:vol_drv	;AN000;offset of drive
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	00000000b			;AN000;character
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:CHARBUF	;AN000;offset of string
		dw	0				;AN000;segment of arg
		db	2				;AN000;second subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Volume Serial Number is %1-%2",13,10
;
VolSerMes_Ptr	dw	1043				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:vol_serial+2	;AN000;offset of serial
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Bin_Hex_Word	;AN000;binary to hex
		db	4				;AN000;maximum width
		db	4				;AN000;minimum width
		db	"0"                             ;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:vol_serial	;AN000;offset of serial
		dw	0				;AN000;segment of arg
		db	2				;AN000;second subst
		db	Right_Align+Bin_Hex_Word	;AN000;binary to hex
		db	4				;AN000;maximum width
		db	4				;AN000;minimum width
		db	"0"                             ;AN000;pad character

;  "Invalid directory",13,10
;
BadCD_Ptr	dw	1044				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Unable to create directory",13,10
;
BadMkD_Ptr	dw	1045				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid path, not directory,",13,10
;  "or directory not empty",13,10
;
BadRmD_Ptr	dw	1046				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Must specify ON or OFF",13,10
;
Bad_ON_OFF_Ptr	dw	1047				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Directory of %1",13,10
;
DirHead_Ptr	dw	1048				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:BWDBUF	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	0				;AN000;minimum width
		db	blank				;AN000;pad character

;  "No Path",13,10
;
NulPath_Ptr	dw	1049				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid drive in search path",13,10
;
BadPMes_Ptr	dw	1050				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid device",13,10
;
BadDev_Ptr	dw	1051				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "FOR cannot be nested",13,10
;
ForNestMes_Ptr	dw	1052				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Intermediate file error during pipe",13,10
;
PipeEMes_Ptr	dw	1053				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Cannot do binary reads from a device",13,10
;
InBDev_Ptr	dw	1054				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "BREAK is %1",13,10
;
CtrlcMes_Ptr	dw	1055				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	0				;AN000;offset of on/off (new)
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "VERIFY is %1",13,10
;
VeriMes_Ptr	dw	1056				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	0				;AN000;offset of on/off (new)
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "ECHO is %1",13,10
;
EchoMes_Ptr	dw	1057				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	0				;AN000;offset of on/off (new)
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "off"
;
OffMes_Ptr	dw	1059				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "on"
;
OnMes_Ptr	dw	1060				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Error writing to device",13,10
;
DevWMes_Ptr	dw	1061				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid path",13,10
;
Inval_Path_Ptr	dw	1062				;AN000;message number
		db	no_subst			;AN000;number of subst

;  unformatted string output
;
arg_Buf_Ptr	dw	1063				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Arg_Buf	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	0				;AN000;minimum width
		db	blank				;AN000;pad character

;  file name output
;
File_Name_Ptr	dw	1064				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:SRCBUF	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	0				;AN000;minimum width
		db	blank				;AN000;pad character

;  file size output for dir
;
Disp_File_Size_Ptr dw	1065				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:File_size_low ;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_DWord	;AN000;long binary to decimal
		db	10				;AN000;maximum width
		db	10				;AN000;minimum width
		db	blank				;AN000;pad character

;  unformatted string output
; %s
String_Buf_Ptr	dw	1066				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:String_ptr_2	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	0				;AN000;minimum width
		db	blank				;AN000;pad character
		db	0				;AN000;

;  tab character
;
Tab_ptr 	dw	1067				;AN000;message number
		db	no_subst			;AN000;number of subst

;  " <DIR>   "
;
DMes_Ptr	dw	1068				;AN000;message number
		db	no_subst			;AN000;number of subst

;  destructive back space
;
Dback_Ptr	dw	1069				;AN000;message number
		db	no_subst			;AN000;number of subst

;  carriage return / line feed
;
ACRLF_Ptr	dw	1070				;AN000;message number
		db	no_subst			;AN000;number of subst

;  output a single character
;
;One_Char_Buf_Ptr dw	 1071				 ;AN000;message number
;		 db	 1				 ;AN000;number of subst
;		 db	 parm_block_size		 ;AN000;size of sublist
;		 db	 0				 ;AN000;reserved
;		 dw	 OFFSET  TranGroup:One_Char_Val  ;AN000;offset of charcacter
;		 dw	 0				 ;AN000;segment of arg
;		 db	 1				 ;AN000;first subst
;		 db	 Char_field_Char		 ;AN000;character
;		 db	 1				 ;AN000;maximum width
;		 db	 1				 ;AN000;minimum width
;		 db	 blank				 ;AN000;pad character

;  "mm-dd-yy"
;
USADat_Ptr	dw	1072				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "dd-mm-yy"
;
EurDat_Ptr	dw	1073				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "yy-mm-dd"
;
JapDat_Ptr	dw	1074				;AN000;message number
		db	no_subst			;AN000;number of subst

;  date string for prompt
;
promptDat_Ptr	dw	1075				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Arg_Buf	;AN000;offset of arg
		dw	0				;AN000;segment of arg
IFNDEF DBCS						; MSKK03 07/14/89
		db	1				;AN000;first subst
  ELSE
    IFDEF JAPAN
		db	2				;AN000;first subst
    ELSE
		db	1				;AN000;first subst
    ENDIF
ENDIF

		db	Char_field_ASCIIZ		;AN000;character string
IFNDEF DBCS
		db	3				;AN000;maximum width
		db	3				;AN000;minimum width
  ELSE
    IFDEF JAPAN						; MSKK02 07/14/89
		db	4				;AN000;maximum width
		db	4				;AN000;minimum width
    ENDIF
    IFDEF TAIWAN
		db	6				;AN000;maximum width
		db	6				;AN000;minimum width
    ENDIF
    IFDEF KOREA
                db      2               ;3 Keyl                ;AN000;maximum width
                db      2               ;3 Keyl                ;AN000;minimum width
    ENDIF
ENDIF
		db	blank				;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
promptDat_yr	dw	0				;AN000;year
promptDat_moday dw	0				;AN000;month,day
IFNDEF DBCS						; MSKK03 07/14/89
		db	2				;AN000;second subst
  ELSE
    IFDEF JAPAN
		db	1				;AN000;second subst
    ELSE
		db	2				;AN000;second subst
    ENDIF
ENDIF
		db	DATE_MDY_4			;AN000;date
		db	10				;AN000;maximum width
		db	8				;AN000;minimum width
		db	blank				;AN000;pad character


;  Time for prompt
;
promTim_Ptr	dw	1076				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
PromTim_hr_min	dw	0				;AN000;hours,minutes
PromTim_Sec_hn	dw	0				;AN000;seconds,hundredths
		db	1				;AN000;first subst
		db	Right_Align+TIME_HHMMSSHH_24	;AC013;time
		db	11				;AN000;maximum width
		db	11				;AC013;minimum width
		db	blank				;AN000;pad character

;  Date and time for DIR
;
DirDatTim_Ptr	dw	1077				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
DirDat_yr	dw	0				;AN000;year
DirDat_mo_day	dw	0				;AN000;month,day
		db	1				;AN000;first subst
		db	Right_Align+DATE_MDY_2		;AN000;date
		db	10				;AN000;maximum width
		db	8				;AN000;minimum width
		db	blank				;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
DirTim_hr_min	dw	0				;AN000;hours,minutes
DirTim_Sec_hn	dw	0				;AN000;seconds,hundredths
		db	2				;AN000;second subst
		db	Right_align+TIME_HHMM_Cty	;AN000;time
		db	6				;AN000;maximum width
		db	6				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Directory already exists"
;
MD_exists_ptr	dw	1078				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "%1 bytes",13,10
;
Bytes_Ptr       dw      1079                            ; message number
                db      1                               ; number of subst
                db      parm_block_size                 ; size of sublist
                db      0                               ; reserved
                dw      OFFSET  TranGroup:FileSiz       ; offset of arg
                dw      0                               ; segment of arg
                db      1                               ; first subst
                db      Right_Align+Unsgn_Bin_DWord     ; long binary to decimal
                db      10                              ; maximum width
                db      10                              ; minimum width
                db      blank                           ; pad character

;  "Total:",13,10
;
Total_ptr       dw      1080                            ; message number
                db      no_subst                        ; number of subst

;  "Error parsing environment variable:",13,10
;
ErrParsEnv_ptr  dw      1081                            ; message number
                db      no_subst                        ; number of subst

;  "(continuing %1)",13,10
;
DirCont_Ptr     dw      1084                            ;AN000;message number
                db      1                               ;AN000;number of subst
                db      parm_block_size                 ;AN000;size of sublist
                db      0                               ;AN000;reserved
                dw      OFFSET  TranGroup:BWDBUF        ;AN000;offset of arg
                dw      0                               ;AN000;segment of arg
                db      1                               ;AN000;first subst
                db      Char_field_ASCIIZ               ;AN000;character string
                db      128                             ;AN000;maximum width
                db      0                               ;AN000;minimum width
                db      blank                           ;AN000;pad character

;  "Revision %1",CR,LF
;
DosRev_Ptr	dw	1090
		db	1				; one substitution
		db	PARM_BLOCK_SIZE
		db	0
		dw	offset TRANGROUP:One_Char_Val	; ptr to char
		dw	0				; segment addr?
		db	1				; 1st substitution
		db	CHAR_FIELD_CHAR			; character
		db	1				; max width
		db	1				; min width
		db	BLANK				; pad char

;  "DOS is in ROM"
;
DosRom_Ptr	dw	1091
		db	NO_SUBST

;  "DOS is in HMA"
;
DosHma_Ptr	dw	1092
		db	NO_SUBST

;  "DOS is in low memory"
;
DosLow_Ptr	dw	1093
		db	NO_SUBST

;  "Cannot Loadhigh batch file" ;M016
;
NoExecBat_Ptr	dw	1094			; M016
		db	NO_SUBST			; M016

;  "LoadHigh: Invalid filename" ; M016
;
LhInvFil_Ptr	dw	1095			; M016
		db	NO_SUBST			; M016

;  "Could not open specified country information file" ;M045
;
NoCntry_Ptr	dw	1096			;M045
		db	NO_SUBST			;M045


PATH_TEXT       DB      "PATH="
PROMPT_TEXT     DB      "PROMPT="
COMSPECSTR      DB      "COMSPEC="
DirEnvVar       DB      "DIRCMD="               ; DIR's environment variable

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\uinit.asm ===
page ,132
;   SCCSID = @(#)uinit.asm  4.5 85/12/04
;   SCCSID = @(#)uinit.asm  4.5 85/12/04
TITLE   COMMAND Initialization messages
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;   Revision History
;   ================
;   M003    SR  07/16/90    Added Lh_OffUnlink to the offset
;               patch table (Reloc_Table) for UMB
;               support
;

.XCREF
.XLIST
include comsw.asm
include comseg.asm
include ifequ.asm
.LIST
.CREF

addr macro sym,name
     public name
     ifidn <name>,<>

        dw offset resgroup:sym
     else

name        dw  offset resgroup:sym
     endif
     endm

CODERES segment

    extrn   ContC       :near
    extrn   DskErr      :near
    extrn   Int_2e      :near
    extrn   MsgInt2fHandler :near
    extrn   Exec_Ret    :near
    extrn   TRemCheck   :far
    extrn   TrnLodCom1  :near
    extrn   MsgRetriever    :near
    extrn   LodCom      :near
    extrn   THeadFix    :far
    extrn   Lh_OffUnlink    :far    ; M003

CODERES ends


;;ENVIRONMENT   SEGMENT PUBLIC PARA     ;AC000;
;;  EXTRN   ECOMSPEC:BYTE
;;ENVIRONMENT ENDS

TRANCODE    SEGMENT PUBLIC BYTE     ;AC000;
    extrn   Printf_init:FAR
    extrn   Triage_Init:FAR
    extrn   append_parse:FAR        ;AN054;
TranCode    ENDS

INIT        SEGMENT PUBLIC PARA     ;AC000;


    public  icondev
    public  BADCSPFL
    public  COMSPECT
; NTVDM not used public  AUTOBAT
    public  space
    public  PRDATTM
    public  INITADD
    public  print_add
    public  CHUCKENV
    public  scswitch
    public  skswitch
    public  ucasea
;;  public  ECOMLOC
    public  equalsign
    public  lcasea
    public  lcasez
    public  comspstring
    public  EnvSiz
    public  EnvMax
    public  initend
    public  trnsize
    public  resetenv            ;AC000;
    public  ext_msg             ;AC000;
    public  num_positionals
    public  internat_info
    public  parsemes_ptr

    PUBLIC  triage_add
    PUBLIC  oldenv
    PUBLIC  usedenv
; NTVDM not used PUBLIC  KAUTOBAT               ;AN000;  3/3/KK
    public  eswitch             ;AN018;
    public  dswitch             ;AN018;
    public  init_parse          ;AN054;
    public  old_parse_ptr           ;AN057;
    PUBLIC  pars_msg_off            ;AN060;
    PUBLIC  pars_msg_seg            ;AN060;

    public  PathString
    public  Reloc_Table
    public  ResJmpTable
    public  FirstCom

    public  DevFlag
    public  PathFlag


include resmsg.equ              ;AC000;


ICONDEV LABEL BYTE
        DB  "/DEV/"
        DB  "CON",0,0,0,0,0,0               ; Room for 8 char device
BADCSPFL    DB  0
COMSPECT    DB  "\COMMAND.COM",0,0
;NTVDM not used AUTOBAT         DB      0,":\AUTOEXEC.BAT",0,0DH              ;AC027;
;NTVDM not used KAUTOBAT        DB      0,":\KAUTOEXE.BAT",0,0DH        ;AC027;  3/3/KK

PRDATTM     DB  -1              ;Init not to prompt for date time
INITADD     DD  ?
print_add   LABEL   DWORD
        DW  OFFSET TranGroup:Printf_INIT
        DW  0
triage_add  LABEL   DWORD
        DW  OFFSET TranGroup:Triage_Init
        DW  0
CHUCKENV    DB  0
;eg ECOMLOC DW  OFFSET ENVIRONMENT:ECOMSPEC-10H
;;ECOMLOC   DW  OFFSET ENVIRONMENT:ECOMSPEC ;eg

PathString  db  "PATH=",0
ComspString db  "COMSPEC=\COMMAND.COM",0

;;COMSPSTRING   DB  "COMSPEC="

equalsign   db  "="
lcasea      db  "a"
lcasez      db  "z"
space       db  " "
scswitch    db  "C"                             ; Single command
skswitch    db  "K"                             ; Single command
ucasea      db  "A"

EnvSiz      DW  0               ; size user wants to allocate
EnvMax      DW  0               ; maximum size allowed.
oldenv      DW  0               ; envirseg at initialization
usedenv     DW  0               ; amount of envirseg used
PARS_MSG_OFF    DW  0               ;AN060;  SAVED PARSE ERROR MESSAGE OFFSET
PARS_MSG_SEG    DW  0               ;AN060;  SAVED PARSE ERROR MESSAGE SEGMENT

;Do not separate the following two words.  Used to call transient PARSE routine

init_parse  label   dword               ;AN054;
init_p      DW  TRANGROUP:APPEND_PARSE      ;AN054;
initend     DW  0               ;eg segment address of end of init

;End of data that shouldn't be separated.

trnsize     DW  0               ;eg size of transient in paragraphs
resetenv    DB  0               ;eg set if we need to setblck env at endinit
ext_msg     DB  0               ;AN000; set if /MSG switch entered
eswitch     db  0               ;AN018; set if /e was entered
dswitch     db  0               ;AN018; set if /d was entered
parsemes_ptr    dw  0           ;AN000; word to store parse error number

;
; PARSE BLOCK FOR COMMAND
;
PUBLIC  PARSE_COMMAND               ;AN000;
PUBLIC  COMND1_OUTPUT               ;AN000;
PUBLIC  COMND1_TYPE             ;AN000;
PUBLIC  COMND1_CODE             ;AN000;
PUBLIC  COMND1_SYN              ;AN000;
PUBLIC  COMND1_ADDR             ;AN000;
PUBLIC  COMMAND_F_SYN               ;AN000;
PUBLIC  COMMAND_P_SYN               ;AN000;
PUBLIC  COMMAND_C_SYN               ;AN000;
PUBLIC  COMMAND_D_SYN               ;AN000;
PUBLIC  COMMAND_E_SYN               ;AN000;
PUBLIC  COMMAND_K_SYN               ;AN000;
PUBLIC  COMMAND_L2_SYN
PUBLIC  COMMAND_L_SYN
PUBLIC  COMMAND_M_SYN               ;AN000;
PUBLIC  COMMAND_U_SYN
PUBLIC  COMMAND_?_SYN
PUBLIC  COMMAND_Y_SYN
PUBLIC  COMMAND_Z_SYN

;
;  The following parse control block is used for COMMAND.  This block is
;  used for parsing during initialization.  The sytax for COMMAND is:
;  COMMAND [/?] [d:][path][/P][/F][/D][/E:xxxxx][/MSG][/C executable][/K executable]
;
;  Anything on the command line after the /C or /K switch will be passed to the
;  executable command, so if /C or /K is used, it must be specified last. The
;  /MSG switch can only be specified if the /P switch is specified.
;
;  The /? switch causes help text to be displayed.  Any other options
;  on the command line are ignored.  Command.com will not load if /?
;  is specified.
;

ENVBIG  EQU 32768               ;AN000; maximum environment size
ENVSML  EQU 160             ;AN000; minimum environment size



INTERNAT_INFO   LABEL   BYTE            ;AN000; used for country info after parsing is completed
PARSE_COMMAND   LABEL   BYTE            ;AN000;
        DW  RESGROUP:COMMAND_PARMS  ;AN000;
        DB  0           ;AN000; no extra delimiter

COMMAND_PARMS   LABEL   BYTE            ;AN000;
        DB  0,2         ;AN000; 1 positional parm
        DW  RESGROUP:COMMAND_FILE   ;AN000;
        dw  RESGROUP:Command_File
        DB  13            ;AN000; 13 switches
        DW  RESGROUP:COMMAND_SWITCH1 ;AN000;
        DW  RESGROUP:COMMAND_SWITCH2 ;AN000;
        DW  RESGROUP:COMMAND_SWITCH3 ;AN000;
        DW  RESGROUP:COMMAND_SWITCH4 ;AN000;
        DW  RESGROUP:COMMAND_SWITCH5 ;AN000;
        DW  RESGROUP:COMMAND_SWITCH6 ;AN000;
        DW  RESGROUP:COMMAND_SWITCH7
        DW  RESGROUP:COMMAND_SWITCH8
        DW  RESGROUP:COMMAND_SWITCH9
        DW  RESGROUP:COMMAND_SWITCH10
        DW  RESGROUP:COMMAND_SWITCH11
        DW  RESGROUP:COMMAND_SWITCH12
        DW  RESGROUP:COMMAND_SWITCH13
        DB  0           ;AN000; no keywords

COMMAND_FILE    LABEL   BYTE            ;AN000;
        DW  0201H           ;AN000; filespec - optional
        DW  1           ;AN000; capitalize - file table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  0           ;AN000; no keywords

COMMAND_SWITCH1 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_P_SYN   DB  "/P",0                  ;AN000; /P switch

COMMAND_SWITCH2 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_F_SYN   DB  "/F",0                  ;AN000; /F switch

COMMAND_SWITCH3 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_D_SYN   DB  "/D",0                  ;AN000; /D switch

COMMAND_SWITCH4 LABEL   BYTE            ;AN000;
        DW  8000H           ;AN000; numeric value - required
        DW  0           ;AN000; no function flags
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:COMMAND_E_VAL  ;AN000; pointer to value list
        DB  1           ;AN000; 1 keyword
COMMAND_E_SYN   DB  "/E",0                  ;AN000; /E switch

COMMAND_E_VAL   LABEL   BYTE            ;AN000;
        DB  1           ;AN000;
        DB  1           ;AN000; 1 range
        DB  1           ;AN000; returned if result
        DD  ENVSML,ENVBIG       ;AN000; minimum & maximum value
        DB  0           ;AN000; no numeric values
        DB  0           ;AN000; no string values

COMMAND_SWITCH5 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_C_SYN   DB  "/C",0                  ;AN000; /C switch

COMMAND_SWITCH6 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_M_SYN   DB  "/MSG",0                ;AN000; /MSG switch

COMMAND_SWITCH7 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_?_SYN   DB  "/?",0                  ;AN000; /? switch

COMMAND_SWITCH8 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_Z_SYN   DB  "/Z",0          ;AN000; /Z switch

COMMAND_SWITCH9 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_K_SYN   DB  "/K",0                  ;AN000; /K switch

COMMAND_SWITCH10 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_Y_SYN   DB  "/Y",0                  ;AN000; /Y switch

COMMAND_SWITCH11 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_L_SYN   DB  "/LOW",0                ;AN000; /LOW switch

COMMAND_SWITCH12 LABEL   BYTE            ;AN000;
        DW  8000H           ;AN000; numeric value - required
        DW  0           ;AN000; no function flags
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:COMMAND_L2_VAL  ;AN000; pointer to value list
        DB  1           ;AN000; 1 keyword
COMMAND_L2_SYN   DB  "/L",0                  ;AN000; /L switch

COMMAND_L2_VAL   LABEL   BYTE            ;AN000;
        DB  1           ;AN000;
        DB  1           ;AN000; 1 range
        DB  1           ;AN000; returned if result
        DD  0,ENVBIG       ;AN000; minimum & maximum value
        DB  0           ;AN000; no numeric values
        DB  0           ;AN000; no string values

COMMAND_SWITCH13 LABEL   BYTE            ;AN000;
        DW  8000H           ;AN000; numeric value - required
        DW  0           ;AN000; no function flags
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:COMMAND_U_VAL  ;AN000; pointer to value list
        DB  1           ;AN000; 1 keyword
COMMAND_U_SYN   DB  "/U",0                  ;AN000; /U switch

COMMAND_U_VAL   LABEL   BYTE            ;AN000;
        DB  1           ;AN000;
        DB  1           ;AN000; 1 range
        DB  1           ;AN000; returned if result
        DD  0,ENVBIG       ;AN000; minimum & maximum value
        DB  0           ;AN000; no numeric values
        DB  0           ;AN000; no string values


COMND1_OUTPUT   LABEL   BYTE            ;AN000;
COMND1_TYPE DB  0           ;AN000; type
COMND1_CODE DB  0           ;AN000; return value
COMND1_SYN  DW  0           ;AN000; synonym pointer
COMND1_ADDR DD  0           ;AN000; numeric value / address
                        ;   of string value

NO_VAL      DB  0           ;AN000; no values
num_positionals DW  0           ;AN000; counter for positionals
old_parse_ptr   DW  0           ;AN057; SI position before calling parser



;***    INITIALIZATION MESSAGES

    include comimsg.inc     ;M00


;SR;
; This table of offsets is used by the init code to calculate the new offsets
;for these labels after the resident code has been relocated
;

Reloc_Table dw  offset CODERES:MsgInt2fHandler
        dw  offset CODERES:Int_2e
        dw  offset CODERES:ContC
        dw  offset CODERES:DskErr
        dw  offset CODERES:Exec_Ret
        dw  offset CODERES:TRemCheck
        dw  offset CODERES:TrnLodCom1
        dw  offset CODERES:LodCom
        dw  offset CODERES:MsgRetriever
        dw  offset CODERES:THeadFix
        dw  offset CODERES:Lh_OffUnlink ; M003

NUM_RELOC_ENTRIES   equ  ($ - Reloc_Table) / 2
public  NUM_RELOC_ENTRIES

ResJmpTable dd  ?       ;stores prev stub jump table addr
FirstCom        db  0       ;flag set if first command.com

DevFlag     db  0
PathFlag        db  0

INIT    ends

    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tucode.asm ===
page ,132
;	SCCSID = @(#)tucode.asm 4.2 85/05/31
;	SCCSID = @(#)tucode.asm 4.2 85/05/31
Title	COMMAND Language midifiable Code Transient
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


.xlist
.xcref
	include dossym.inc
	include syscall.inc
	include comsw.asm
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	ECHOFLAG:BYTE
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BAD_ON_OFF_ptr:word
	EXTRN	ctrlcmes_ptr:word
	EXTRN	DEL_Y_N_PTR:WORD
	EXTRN	ECHOMES_ptr:word
	EXTRN	extend_buf_ptr:word	;AC000;
	EXTRN	offmes_ptr:word
	EXTRN	onmes_ptr:word
	EXTRN	PARSE_BREAK:BYTE	;AN000;
	EXTRN	promptdat_moday:word	;AC000;
	EXTRN	promptdat_ptr:word	;AC000;
	EXTRN	promptdat_yr:word	;AC000;
	EXTRN	string_buf_ptr:word
	EXTRN	SUREMES_ptr:word
	EXTRN	VERIMES_ptr:BYTE
	EXTRN	WeekTab:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg_buf:byte
	EXTRN	BWDBUF:BYTE
	EXTRN	DEST:BYTE
	EXTRN	destdir:byte
	EXTRN	dirchar:byte
	EXTRN	PARSE1_CODE:BYTE	;AN000;
	EXTRN	RESSEG:WORD
	EXTRN	string_ptr_2:word

TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

	EXTRN	CERROR:NEAR
	EXTRN	CRLF2:NEAR
	EXTRN	extend_setup:near	;AN022;

	PUBLIC	CNTRLC
	PUBLIC	ECHO
	PUBLIC	GetDate
	PUBLIC	NOTEST2
	PUBLIC	PRINT_DATE
	PUBLIC	SLASHP_ERASE		;AN000;
	PUBLIC	VERIFY

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:TRANGROUP,SS:NOTHING

; ****************************************************************
; *
; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
; *
; * FUNCTION:	 Delete files based on user parsed input.  Prompt
; *		 user for Y/N if necessary.  If an error occurs,
; *		 set up an error message and go to CERROR.
; *
; * INPUT:	 FCB at 5ch set up with filename(s) entered
; *		 Current directory set to entered directory
; *
; * OUTPUT:	 none
; *
; ****************************************************************
;
; ARE YOU SURE prompt when deleting *.*

NOTEST2:
	MOV	CX,11
	MOV	SI,FCB+1

AMBSPEC:
	LODSB
	CMP	AL,'?'
	JNZ	ALLFIL
	LOOP	AMBSPEC

ALLFIL:
	CMP	CX,0
	JNZ	NOPRMPT

ASKAGN:
	MOV	DX,OFFSET TRANGROUP:SUREMES_ptr ; "Are you sure (Y/N)?"
	invoke	std_printf
	MOV	SI,80H
	MOV	DX,SI
	MOV	WORD PTR [SI],120		; zero length
	MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_STRING_INPUT
	INT	21H
	LODSW
	OR	AH,AH
	JZ	ASKAGN
	INVOKE	SCANOFF
	call	char_in_xlat			;G Convert to upper case
	retc					;AN000; return if function not supported
	CMP	AL,CAPITAL_N			;G
	retz
	CMP	AL,CAPITAL_Y			;G
	PUSHF
	CALL	CRLF2
	POPF
	JNZ	ASKAGN

NOPRMPT:
	MOV	AH,FCB_DELETE
	MOV	DX,FCB
	INT	21H
	INC	AL
	jz	eraerr
	invoke	RESTUDIR
	ret					; If no error, return

eraerr:
	invoke	set_ext_error_msg		;AN022; set up the extended error
	push	dx				;AN022; save message
	invoke	RESTUDIR
	pop	dx				;AN022; restore message

	cmp	word ptr extend_buf_ptr,error_no_more_files ;AN022; convert no more files to
	jnz	cerrorj2			;AN022; 	file not found
	mov	Extend_Buf_ptr,error_file_not_found  ;AN000; get message number in control block

cerrorj2:
	jmp	cerror


; ****************************************************************
; *
; * ROUTINE:	 SLASHP_ERASE  - execution of DEL/ERASE /P
; *
; * FUNCTION:	 Delete files based on user parsed input.  Prompt
; *		 user for Y/N where necessary.	If an error occurs
; *		 set up and error message and transfer control
; *		 to CERROR.
; *
; * INPUT:	 FCB at 5ch set up with filename(s) entered
; *		 Current directory set to entered directory
; *
; * OUTPUT:	 none
; *
; ****************************************************************

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:TRANGROUP,SS:NOTHING

SLASHP_ERASE:					;AN000; entry point
	invoke	build_dir_string		;AN000; set up current directory string for output
	mov	ah,Set_DMA			;AN000; issue set dta int 21h
	mov	dx,offset trangroup:destdir	;AN000; use Destdir for target
	int	21H				;AN000;
	mov	ah,Dir_Search_First		;AN000; do dir search first int 21h
	mov	dx,FCB				;AN000; use FCB at 5Ch for target
	int	21H				;AN000;
	inc	al				;AN000; did an error occur
	jz	eraerr				;AN022; go to error exit

delete_prompt_loop:				;AN000;
	mov	si,offset trangroup:destdir+1	;AN000; set up FCB as source
	mov	di,offset trangroup:dest	;AN000; set up dest as target
	mov	al,dirchar			;AN000; store a "\" in the first char
	stosb					;AN000;     of DEST
	invoke	fcb_to_ascz			;AN000; convert filename from FCB to ASCIIZ string

slashp_askagn:					;AN000;
	call	crlf2				;AN000; print out carriage return, line feed
	mov	dx,offset trangroup:bwdbuf	;AN000; print out current directory string
	mov	bx,dx				;AN000; get string pointer in bx
	cmp	byte ptr [bx+3],end_of_line_out ;AN000; see if only D:\,0
	jnz	not_del_root			;AN000; no continue
	mov	byte ptr [bx+2],end_of_line_out ;AN000; yes, get rid of \

Not_del_root:					;AN000;
	mov	string_ptr_2,dx 		;AN000;
	mov	dx,offset trangroup:string_buf_ptr ;AN000;
	invoke	std_printf			;AN000;
	mov	dx,offset trangroup:dest	;AN000; print out file name string
	mov	string_ptr_2,dx 		;AN000;
	mov	dx,offset trangroup:string_buf_ptr ;AN000;
	invoke	std_printf			;AN000;
	mov	dx,offset trangroup:Del_Y_N_Ptr ;AN000; issue ",    Delete (Y/N)?" message
	invoke	std_printf			;AN000;
;;M029	mov	si,80H				;AN000; set up buffer for input
;;M029	mov	dx,si				;AN000;
;;M029	mov	word ptr [si],combuflen 	;AN000;
;;M029	mov	ax,(std_con_input_flush shl 8) or std_con_string_input	 ;AN000;
;;M029	int	21h			;AN000; get input from the user
;;M029	lodsw					;AN000;
;;M029	or	ah,ah				;AN000; was a character entered?
;;M029	jz	slashp_askagn			;AN000; no - ask again
;;M029	invoke	scanoff 			;AN000; scan off leading delimiters

;	Get a single character input.

	mov	ax,(std_con_input_flush shl 8) or std_con_input	;M029
	int	21h						;M029

	call	char_in_xlat			;AN000; yes - upper case it
	retc					;AN000; return if function not supported
	cmp	al,capital_n			;AN000; was it no?
	jz	next_del_file			;AN000; yes - don't delete file
	cmp	al,capital_y			;AN000; was it yes?
	jz	delete_this_file		;AN000; yes - delete the file
	jmp	short slashp_askagn		;AN000; it was neither - ask again

delete_this_file:				;AN000;
	mov	ah,fcb_delete			;AN000; delete the file
	mov	dx,offset trangroup:destdir	;AN000; use Destdir for target
	int	21h			;AN000;
	inc	al				;AN000; did an error occur?
	jnz	next_del_file			;AN000; no - get next file
;
;M041; Begin changes
; We got an error deleting the file. If this is access denied, we can go on
;to the next file after printing an error message.
;
	invoke	Get_ext_error_number			;see what error we got
	cmp	ax,error_access_denied		;is it access denied?
	jne	stop_del			;no, some other error
	invoke	CrLf2				;print a CR-LF
	invoke 	set_ext_error_msg			;error message
	invoke	std_eprintf			;"Access denied"
	jmp	short next_del_file			;try next file
stop_del:
;
;M041; End changes
;
	jmp	eraerr				;AN022; go to error exit - need long jmp

next_del_file:					;AN000;
;
; M050 - begin
; 	Norton Utilities 5.0 has a bug. DiskMon when invoked
;       with /protect+ and /light+ makes it intercept all
;       deletes. This hook does not save and restore the DTA correctly.
;       They save the DWORD in a WORD by mistake! They save both the
;       segment and the offset in the SAME variable (WORD)!!!
;
	mov	ah,Set_DMA
	mov	dx,offset trangroup:destdir
	int	21H
;
; M050 - end

	mov	ah,dir_search_next		;AN000; search for another file
	mov	dx,FCB				;AN000;
	int	21h			;AN000;
	inc	al				;AN000; was a file found?
	jz	slash_p_exit			;AN000; no - exit
	jmp	delete_prompt_loop		;AN000; yes - continue (need long jump)

slash_p_exit:
	invoke	get_ext_error_number		;AN022; get the extended error number
	cmp	ax,error_no_more_files		;AN022; was error file not found?
	jz	good_erase_exit 		;AN022; yes - clean exit
	jmp	extend_setup			;AN022; go issue error message

good_erase_exit:
	invoke	restudir			;AN000; we're finished - restore user's dir
	call	crlf2				;AN000; print out carriage return, line feed
	ret					;AN000; exit


;************************************************
; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"

	break	Echo

assume	ds:trangroup,es:trangroup

ECHO:
	CALL	ON_OFF
	JC	DOEMES
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	JNZ	ECH_OFF
	OR	[ECHOFLAG],1
	RET
ECH_OFF:
	AND	[ECHOFLAG],NOT 1
	RET


CERRORJ:
	JMP	CERROR

;
; There was no discrenable ON or OFF after the ECHO.  If there is nothing but
; delimiters on the command line, we issue the ECHO is ON/OFF message.
;

ASSUME	DS:TRANGROUP

DOEMES:
	cmp	cl,0				;AC000; was anything on the line?
	jz	PEcho				; just display current state.
	MOV	DX,82H				; Skip one char after "ECHO"
	invoke	CRPRINT
	JMP	CRLF2

PECHO:
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	BL,[ECHOFLAG]
	PUSH	CS
	POP	DS
ASSUME	DS:TRANGROUP
	AND	BL,1
	MOV	DX,OFFSET TRANGROUP:ECHOMES_ptr
	JMP	SHORT PYN

	break	Break
assume	ds:trangroup,es:trangroup

CNTRLC:
	CALL	ON_OFF
	MOV	AX,(SET_CTRL_C_TRAPPING SHL 8) OR 1
	JC	PCNTRLC
	JNZ	CNTRLC_OFF
	MOV	DL,1
	INT	21H				; Set ^C
	RET

CNTRLC_OFF:
	XOR	DL,DL
	INT	21H				; Turn off ^C check
	RET

PCNTRLC:
	CMP	CL,0				;AC000; rest of line blank?
	JNZ	CERRORJ 			; no, oops!

pccont:
	XOR	AL,AL
	INT	21H
	MOV	BL,DL
	MOV	DX,OFFSET TRANGROUP:CTRLCMES_ptr

PYN:
	mov	si,offset trangroup:onmes_ptr	;AC000; get ON pointer
	OR	BL,BL
	JNZ	PRINTVAL
	mov	si,offset trangroup:offmes_ptr	;AC000; get OFF pointer

PRINTVAL:
	push	dx				;AN000; save offset of message block
	mov	bx,dx				;AN000; save offset value
	lodsw					;AN000; get message number of on or off
	mov	dh,util_msg_class		;AN000; this is a utility message
	invoke	Tsysgetmsg			;AN000; get the address of the message
	add	bx,ptr_off_pos			;AN000; point to offset of ON/OFF
	mov	word ptr [bx],si		;AN000; put the offset in the message block
	pop	dx				;AN000; get message back
	invoke	std_printf			;AC000; go print message
	mov	word ptr [bx],0 		;AN000; zero out message pointer

	ret					;AN000; exit

	break	Verify
assume	ds:trangroup,es:trangroup

VERIFY:
	CALL	ON_OFF
	MOV	AX,(SET_VERIFY_ON_WRITE SHL 8) OR 1
	JC	PVERIFY
	JNZ	VER_OFF
	INT	21H				; Set verify
	RET

VER_OFF:
	DEC	AL
	INT	21H				; Turn off verify after write
	RET

PVERIFY:
	CMP	CL,0				;AC000; is rest of line blank?
	JNZ	CERRORJ 			; nope...
	MOV	AH,GET_VERIFY_ON_WRITE
	INT	21H
	MOV	BL,AL
	MOV	DX,OFFSET TRANGROUP:VERIMES_ptr
	JMP	PYN

; ****************************************************************
; *
; * ROUTINE:	 ON_OFF
; *
; * FUNCTION:	 Parse the command line for an optional ON or
; *		 OFF string for the BREAK, VERIFY, and ECHO
; *		 routines.
; *
; * INPUT:	 command line at offset 81H
; *		 PARSE_BREAK control block
; *
; * OUTPUT:	 If carry is clear
; *		    If ON is found
; *		       Zero flag set
; *		    If OFF is found
; *		       Zero flag clear
; *		 If carry set
; *		    If nothing on command line
; *		       CL set to zero
; *		    If error
; *		       CL contains error value from parse
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

ON_OFF:
	MOV	SI,81h

scan_on_off:					;AN032; scan off leading blanks & equal
	lodsb					;AN032; get a char
	cmp	al,blank			;AN032; if whitespace
	jz	scan_on_off			;AN032;    keep scanning
	cmp	al,tab_chr			;AN032; if tab
	jz	scan_on_off			;AN032;    keep scanning
	cmp	al,equal_chr			;AN032; if equal char
	jz	parse_on_off			;AN032;    start parsing
	dec	si				;AN032; if none of above - back up

parse_on_off:					;AN032;    and start parsing
	mov	di,offset trangroup:parse_break ;AN000; Get adderss of PARSE_BREAK
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AC000; call parser
	cmp	ax,end_of_line			;AC000; are we at end of line?
	jz	BADONF				;AC000; yes, return error
	cmp	ax,result_no_error		;AN000; did an error occur
	jz	on_off_there			;AN000; no - continue
	mov	cx,ax				;AN000; yes - set cl to error code
	jmp	short BADONF			;AN000; return error

on_off_there:
	cmp	parse1_code,-1			;AN014; was a valid positional present?
	jnz	good_on_off			;AN014; yes - continue
	mov	cx,badparm_ptr			;AN014; something other than ON/OFF
	jmp	short BADONF			;AN014; return error

good_on_off:					;AN014;
	xor	ax,ax				;AC000; set up return code for
	or	al,parse1_code			;AC000;    ON or OFF in AX
	pushf					;AN000; save flags
	mov	di,offset trangroup:parse_break ;AN000; Get adderss of PARSE_BREAK
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AN000; call parser
	cmp	ax,end_of_line			;AN000; are we at end of line?
	jnz	BADONF_flags			;AN000; NO, return error
	popf					;AN000; restore flags
	clc					;AC000; no error
	jmp	short on_off_end		;AN000; return to caller

BADONF_flags:
	mov	cx,ax
	popf

;
; No discernable ON or OFF has been found. Put an error message pointer in DX
; and return the error
;
BADONF:
	MOV	DX,OFFSET TRANGROUP:BAD_ON_OFF_ptr
	STC

ON_OFF_END:

	RET



;*************************************************************************
; print date

PRINT_DATE:
	PUSH	ES
	PUSH	DI
	PUSH	CS
	POP	ES
	CALL	GetDate 			; get date
	xchg	dh,dl				;AN000; switch month & day
	mov	promptDat_yr,cx 		;AC000; put year into message control block
	mov	promptDat_moday,dx		;AC000; put month and day into message control block
	mov	dx,offset trangroup:promptDat_ptr ;AC000; set up message for output
	invoke	std_printf
;AD061; mov	promptDat_yr,0			;AC000; reset year, month and day
;AD061; mov	promptDat_moday,0		;AC000;     pointers in control block
	POP	DI				;AC000; restore di,es
	POP	ES				;AC000;
	return
;
; Do GET DATE system call and set up 3 character day of week in ARG_BUF
; for output.  Date will be returned in CX,DX.
;

GetDate:
	mov	di,offset trangroup:arg_buf	;AC000; target for day of week
	MOV	AH,GET_DATE			;AC000; get current date
	INT	21h			;AC000; Get date in CX:DX
	CBW					;AC000;

	push	cx				;AN000; save date returned in
	push	dx				;AN000;      CX:DX
	MOV	SI,AX
IFNDEF DBCS
	SHL	SI,1
	ADD	SI,AX				; SI=AX*3
  ELSE
    ifdef JAPAN					; MSKK01 07/14/89
	shl	si,1
	shl	si,1				; SI=AX*4
    endif
    IFDEF TAIWAN
	SHL	SI,1
	ADD	SI,AX
	SHL	SI,1				; SI=AX*6
    ENDIF
    ifdef KOREA
        shl     si,1
    endif
ENDIF
	mov	cx,si				;AN000; save si
	mov	ax,weektab			;AN000; get message number of weektab
	mov	dh,util_msg_class		;AN000; this is a utility message
	push	di				;AN000; save argument buffer
	invoke	Tsysgetmsg			;AN000; get the address of the message
	pop	di				;AN000; retrieve argument buffer
	add	si,cx				;AC000; get day of week
IFNDEF DBCS
	MOV	CX,3
  ELSE
    ifdef JAPAN					; MSKK01 07/14/89
	mov	cx,4
    endif
    IFDEF TAIWAN
	MOV	CX,6
    ENDIF
    ifdef KOREA
        mov     cx,2                            ; MSCH 90/9/6
    endif
ENDIF
	REP	MOVSB
	mov	al,end_of_line_out		;AC000; terminate the string
	stosb
	pop	dx				;AN000; get back date
	pop	cx				;AN000;

	return
;g
;g   This routine determines whether the character in AL is a
;g   Yes or No character.  On return, if AL=0, the character is
;g   No, if AL=1, the character is Yes.
;g

assume	ds:trangroup

char_in_xlat	proc	near

	mov	dl,al				;AC000; get character into DX
	xor	dh,dh				;AC000;
	mov	ax,(getextcntry SHL 8) + 35	;AC000; Yes/No char call
	int	21h			;AC000;

	ret

char_in_xlat	endp

TRANCODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\chp\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\chs\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\cht\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\fi\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\da\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\cs\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR       "        DB      \"Chyba pi rozboru %%1\"\x0d\x0a"
#define EXTENDED_STR    "        DB      \"Chyba %%1\"\x0d\x0a"
char    *ExtendedErrorText999 =  "\"Chyba %1\"";       /* Mar 88, SWN */
char    *ParserErrorText999 =  "\"Chyba pi rozboru %1\"";    /* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\el\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\jpn\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\es\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Error de anlisis %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Error extendido %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Error extendido %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Error de anlisis %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\kor\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\hu\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Feldolgozsi hiba: %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Kiterjesztett hiba: %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Feldolgozsi hiba: %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Kiterjesztett hiba: %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\no\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\fr\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Erreur d'analyse %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Erreur tendue %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Erreur tendue %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Erreur d'analyse %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\ger\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parserfehler %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Erweiterter Fehler %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Erweiterter Fehler %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parserfehler %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\psu\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\it\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Errore di analisi %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Errore esteso %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Errore esteso %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Errore di analisi %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tst\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\pl\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR       "        DB      \"Bd analizy skadni %%1\"\x0d\x0a"
#define EXTENDED_STR    "        DB      \"Bd rozszerzony %%1\"\x0d\x0a"
char    *ExtendedErrorText999 =  "\"Bd rozszerzony %1\"";     /* Mar 88, SWN */
char    *ParserErrorText999 =  "\"Bd analizy skadni %1\"";   /* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\nl\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR       "        DB      \"Parseringsfout %%1\"\x0d\x0a"
#define EXTENDED_STR    "        DB      \"Uitgebreide fout %%1\"\x0d\x0a"
char    *ExtendedErrorText999 =  "\"Uitgebreide fout %1\"";       /* Mar 88, SWN */
char    *ParserErrorText999 =  "\"Parseringsfout %1\"";    /* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\usa\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\pt\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Erro de anlise %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Erro de extenso %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Erro de extenso %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Erro de anlise %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\sv\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Syntaxfel %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Utkat fel %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Utkat fel %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Syntaxfel %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\ru\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR       "        DB      \"訡 ࠧ %%1\"\x0d\x0a"
#define EXTENDED_STR    "        DB      \"७ 訡 %%1\"\x0d\x0a"
char    *ExtendedErrorText999 =  "\"७ 訡 %1\"";       /* Mar 88, SWN */
char    *ParserErrorText999 =  "\"訡 ࠧ %1\"";    /* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\tr\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"zmleme Hatas %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Uzatlm Hata %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\" Uzatlm Hata %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\" zmleme Hatas %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\debcom3.asm ===
PAGE	80,132 ;
	TITLE	DEBCOM3.ASM - PART3 DEBUGGER COMMANDS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; ROUTINES TO PERFORM DEBUGGER COMMANDS

	IF1
	    %OUT COMPONENT=DEBUG, MODULE=DEBCOM3
	ENDIF
.XLIST
.XCREF
	include	mi.inc			; cas -- missing equates
	include	version.inc		; cas -- missing equates
	include	syscall.inc		; cas -- missing equates
	INCLUDE DOSSYM.INC
        INCLUDE debug.inc
	INCLUDE DPL.ASM
.CREF
.LIST
CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
	EXTRN	USER_PROC_PDB:WORD,RSTACK:WORD,STACK:BYTE
	EXTRN	DSSAVE:WORD,CSSAVE:WORD,IPSAVE:WORD,axSAVE:WORD,dxSAVE:WORD
	EXTRN	SSSAVE:WORD,SPSAVE:WORD,FLSAVE:WORD
	EXTRN	NEXTCS:WORD,NEXTIP:WORD, RSETFLAG:BYTE
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE
	EXTRN	BRKCNT:WORD,TCOUNT:WORD,SWITCHAR:BYTE,BPTAB:BYTE
	EXTRN	BP_ERROR:BYTE,COMP_ARG1:WORD,COMP_ARG2:WORD,COMP_ARG3:WORD
	EXTRN	COMP_ARG4:WORD,COMP_ARG5:WORD,COMP_ARG6:WORD,COMP_PTR:BYTE
	EXTRN	ARG_BUF:BYTE,ARG_BUF_PTR:BYTE
	EXTRN	FZTRACE:BYTE, SYNERR_PTR:BYTE
	EXTRN	BEGSEG:WORD
	IF	IBMVER
	    EXTRN   cpu_not_8088:byte
	    EXTRN   OLD_MASK:BYTE
	ENDIF
	EXTRN	SAVESTATE:BYTE
DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG
	PUBLIC	COMPARE,INPUT,OUTPUT,GO
	PUBLIC	TRACE,ZTRACE,SKIP_FILE
	EXTRN	GETHEX:NEAR,GETEOL:NEAR,CRLF:NEAR,ERR:NEAR, PERR:NEAR
	EXTRN	HEX:NEAR,DIGIT:NEAR,SCANP:NEAR,DISPREG:NEAR
	EXTRN	COMMAND:NEAR,DABORT:NEAR,DELIM1:NEAR,DELIM2:NEAR
	EXTRN	NMIINT:NEAR,NMIINTEND:NEAR,PRINTF_CRLF:NEAR
	EXTRN	ADDRESS:NEAR,HEXIN:NEAR,DSRANGE:NEAR
; just like trace except skips OVER next INT or CALL.
DEBCOM3:
ZTRACE:
	MOV	FZTRACE,-1
	CALL	SETADD
	CALL	SCANP
	CALL	HEXIN
	MOV	DX,1
	JC	ZSTOCNT
	MOV	CX,4
	CALL	GETHEX
	CALL	CHECKNONE
ZSTOCNT:
	MOV	[TCOUNT],DX
	CALL	GETEOL
	MOV	DX,NEXTCS
	MOV	CSSAVE,DX
	MOV	DX,NEXTIP
	MOV	IPSAVE,DX
ZSTEP:
	MOV	ES,[CSSAVE]		; point to instruction to execute
	MOV	DI,[IPSAVE]		; include offset in segment
	XOR	DX,DX			; where to place breakpoint
get_opcode:
	MOV	AL,ES:[DI]		; get the opcode
	cmp	al,0f0h 		; lock
	je	is_override
	cmp	al,26h			; es:
	je	is_override
	cmp	al,2eh			; cs:
	je	is_override
	cmp	al,36h			; ss:
	je	is_override
	cmp	al,3eh			; ds:
	jne	not_override
Is_override:
;	inc	dx			; this seemed to put us in an endless
	inc	di			; loop, try this.
	jmp	get_opcode
Not_override:
	CMP	AL,11101000B		; direct intra call
	JZ	ZTRACE3 		; yes, 3 bytes
	CMP	AL,10011010B		; direct inter call
	JZ	ZTRACE5 		; yes, 5 bytes
	CMP	AL,11111111B		; indirect?
	JZ	ZTRACEMODRM		; yes, go figure length
	CMP	AL,11001100B		; short interrupt?
	JZ	ZTRACE1 		; yes, 1 byte
	CMP	AL,11001101B		; long interrupt?
	JZ	ZTRACE2 		; yes, 2 bytes
	CMP	AL,11100010B		; loop
	JZ	ZTRACE2 		; 2 byter
	CMP	AL,11100001B		; loopz/loope
	JZ	ZTRACE2 		; 2 byter
	CMP	AL,11100000B		; loopnz/loopne
	JZ	ZTRACE2 		; 2 byter
	AND	AL,11111110B		; check for rep
	CMP	AL,11110010B		; perhaps?
	JZ	FOO1
	JMP	STEP			; can't do anything special, step
FOO1:
	MOV	AL,ES:[DI+1]		; next instruction
	AND	AL,11111110B		; ignore w bit
	CMP	AL,10100100B		; MOVS
	JZ	ZTRACE2 		; two byte
	CMP	AL,10100110B		; CMPS
	JZ	ZTRACE2 		; two byte
	CMP	AL,10101110B		; SCAS
	JZ	ZTRACE2 		; two byte
	CMP	AL,10101100B		; LODS
	JZ	ZTRACE2 		; two byte
	CMP	AL,10101010B		; STOS
	JZ	ZTRACE2 		; two byte
	JMP	short STEP		; bogus, do single step

ZTRACEMODRM:
	MOV	AL,ES:[DI+1]		; get next byte
	AND	AL,11111000B		; get mod and type
	CMP	AL,01010000B		; indirect intra 8 bit offset?
	JZ	ZTRACE3 		; yes, three byte whammy
	CMP	AL,01011000B		; indirect inter 8 bit offset
	JZ	ZTRACE3 		; yes, three byte guy
	CMP	AL,10010000B		; indirect intra 16 bit offset?
	JZ	ZTRACE4 		; four byte offset
	CMP	AL,10011000B		; indirect inter 16 bit offset?
	JZ	ZTRACE4 		; four bytes
	CMP	AL,11010000B		; indirect through reg?
	JZ	ZTRACE2 		; two byte instruction
	JMP	short STEP		; can't figger out what this is!
ZTRACE5:
	INC	DX
ZTRACE4:
	INC	DX
ZTRACE3:
	INC	DX
ZTRACE2:
	INC	DX
ZTRACE1:
	INC	DX
	ADD	DI,DX			; offset to breakpoint instruction
	MOV	WORD PTR [BPTAB],DI	; save offset
	MOV	WORD PTR [BPTAB+2],ES	; save segment
	MOV	AL,ES:[DI]		; get next opcode byte
	MOV	BYTE PTR [BPTAB+4],AL	; save it
	MOV	BYTE PTR ES:[DI],0CCH	; break point it
	MOV	[BRKCNT],1		; only this breakpoint
	JMP	DEXIT			; start the operation!

; Trace 1 instruction or the number of instruction specified
; by the parameter using 8086 trace mode. Registers are all
; set according to values in save area
TRACE:
	MOV	FZTRACE,0
	CALL	SETADD
	CALL	SCANP
	CALL	HEXIN
	MOV	DX,1
	JC	STOCNT
	MOV	CX,4
	CALL	GETHEX
	CALL	CHECKNONE
STOCNT:
	MOV	[TCOUNT],DX
	CALL	GETEOL
	MOV	DX,NEXTCS
	MOV	CSSAVE,DX
	MOV	DX,NEXTIP
	MOV	IPSAVE,DX
STEP:
	MOV	[BRKCNT],0
; The 286 has a problem with trace mode and software interrupt instructions;
; it treats them as atomic operations.	We simulate the operation in software.
	MOV	ES,[CSSAVE]		; Get next instruction pointer
	MOV	DI,[IPSAVE]
	MOV	AL,ES:[DI]		; get next opcode
	cmp	al,0e4h 		; check for 'IN' opcode
	jne	not_inal_op
	cmp	es:byte ptr[di+1],21h
	jne	not_mask_op
	add	[ipsave],2
	JMP	short SETalmask

not_inal_op:
	cmp	al,0ech 		; in al,DX ?
	jne	not_mask_op
	cmp	dxsave,21h
	jne	not_mask_op
	add	[ipsave],1
SETalmask:
	mov	ax,[axsave]
	in	al,21h
	mov	[axsave],ax
	JMP	SETENVIRON

not_mask_op:
	CMP	AL,0CDH 		; trace over an interrupt?
	JZ	DOINT			; no, check for other special cases
	CMP	AL,0CEH 		; how about int overflow
	JNZ	CHECKCC
	TEST	FLSAVE,F_OVERFLOW	 ; see it overflow is present
	JZ	CHECKOP
	MOV	BX,4			; INTO = INT 4
	DEC	IPSAVE			; INTO is a singel byte
	JMP	SHORT DOVAL
CHECKCC:
	CMP	AL,0CCH
	JNZ	CHECKOP
	MOV	BX,3			; INT 3 = CC
	DEC	IPSAVE
	JMP	SHORT DOVAL
DOINT:
; We have a software interrupt.  Get destination vector
	MOV	BL,BYTE PTR ES:[DI+1]	; get vector number
	XOR	BH,BH			; clear out upper
DOVAL:
	SHL	BX,1			; word index
	SHL	BX,1			; dword index
	XOR	DI,DI			; interrupt table
	MOV	ES,DI
	MOV	AX,ES:[BX]		; point to vector
	MOV	BX,ES:[BX+2]		; point to vector
; AX:BX is the vector.	Swap it with currect CS:IP
	XCHG	AX,IPSAVE		; new CS:IP
	XCHG	BX,CSSAVE
; AX:BX is old CS:IP.  We 'PUSH' flags, oldCS and oldIP, reset flags (ifl) and
; set CS:IP to point to interrupt instruction.
	MOV	ES,SSSAVE		; point to user stack
	MOV	DI,SPSAVE
; Take old flags and PUSH the flags.
	MOV	CX,FLSAVE		 ; get flags
	SUB	DI,2			; PUSHF
	MOV	ES:[DI],CX		; rest of push
; Push the old CS
	SUB	DI,2			; PUSH CS
	MOV	ES:[DI],BX		; rest of push
; Push the old IP
	SUB	DI,2			; PUSH IP
	ADD	AX,2			; increment IP
	MOV	ES:[DI],AX		; rest of push
; Update stack
	MOV	SPSAVE,DI		; store
; Take flags and turn interrupts off and trace mode off
	AND	CX,NOT F_INTERRUPT	; CLI
	AND	CX,NOT F_TRACE		; no trace
	MOV	FLSAVE,CX		 ; rest of CLI
; Set up correct process and go to normal reentry code.
	IF	NOT SYSVER
	    MOV     BX,[USER_PROC_PDB]
	    MOV     AH,SET_CURRENT_PDB
	    INT     21H
	ENDIF
	JMP	SETENVIRON
; We need to special case the following instructions that may push a TRACE bit
; on the stack:  PUSHF (9C)

; Save the opcode in A Special place
CHECKOP:
	MOV	RSETFLAG,AL		; no bits to turn off
SETTRACE:
	OR	FLSAVE,F_TRACE		 ; Turn on trace bit
	IF	IBMVER
;
;	the following stuff can be inhibited on 286/386/etc CPUs.  The
;	  designers of the later chips added logic to enhance trace
;	  mode operation.  The reason why we just don't run it all of
;	  the time is that it can cause a system crash if the instruction
;	  being traced causes an overflow condition because nobody will
;	  turn interrupts back on.

	test	cpu_not_8088,1		; see if 8088/8086
	jnz	no_fix_8088

	    CLI
	    IN	    AL,MASK_PORT	; Get current mask
	    JMP     SHORT FOO
FOO:
	    MOV     [OLD_MASK],AL	; Save it
	    MOV     AL,INT_MASK 	; New mask
	    OUT     MASK_PORT,AL	; Set it
	    STI

no_fix_8088:

	ENDIF
DEXIT:
	IF	NOT SYSVER
	    MOV     BX,[USER_PROC_PDB]
	    MOV     AH,SET_CURRENT_PDB
	    INT     21H
	ENDIF
; Unfortunately, any system call we issue will muck with the current extended
; errors.  Here we must restore the extended error state so that if the user
; program gets it, we do not interfere.
	MOV	AX,(SERVERCALL SHL 8) + 10
	MOV	DX,OFFSET DG:SAVESTATE
	INT	21H
	PUSH	DS
	XOR	AX,AX
	MOV	DS,AX
	MOV	WORD PTR DS:[12],OFFSET DG:BREAKFIX ; Set vector 3--breakpoint instruction
	MOV	WORD PTR DS:[14],CS
	MOV	WORD PTR DS:[4],OFFSET DG:REENTER ; Set vector 1--Single step
	MOV	WORD PTR DS:[6],CS
	CLI
	IF	SETCNTC
	    MOV     WORD PTR DS:[8CH],OFFSET DG:CONTC ; Set vector 23H (CTRL-C)
	    MOV     WORD PTR DS:[8EH],CS
	ENDIF
	POP	DS
	MOV	SP,OFFSET DG:STACK
	POP	AX
	POP	BX
	POP	CX
	POP	DX
	POP	BP
	POP	BP
	POP	SI
	POP	DI
	POP	ES
	POP	ES
	POP	SS
	MOV	SP,[SPSAVE]
	PUSH	[FLSAVE]
	PUSH	[CSSAVE]
	PUSH	[IPSAVE]
	MOV	DS,[DSSAVE]
	IRET
STEP1:
	CALL	CRLF
	CALL	DISPREG
	TEST	FZTRACE,-1
	JNZ	STEPZ
	JMP	STEP
STEPZ:	JMP	ZSTEP

; Re-entry point from CTRL-C. Top of stack has address in 86-DOS for
; continuing, so we must pop that off.
CONTC:
	ADD	SP,6
	JMP	SHORT REENTERREAL

; Re-entry point from breakpoint. Need to decrement instruction
; pointer so it points to location where breakpoint actually
; occured.
BREAKFIX:
	PUSH	BP
	MOV	BP,SP
	DEC	WORD PTR [BP].OLDIP
	POP	BP
	JMP	short REENTERREAL

; Re-entry point from trace mode or interrupt during execution.  All registers
; are saved so they can be displayed or modified.
INTERRUPT_FRAME STRUC
OLDBP	DW	?
OLDIP	DW	?
OLDCS	DW	?
OLDF	DW	?
OLDERIP DW	?
OLDERCS DW	?
OLDERF	DW	?
INTERRUPT_FRAME ENDS

ASSUME	CS:DG,DS:NOTHING,ES:NOTHING,SS:NOTHING
; ReEnter is the main entry point for breakpoint interrupts and for trace mode
; interrupts.  We treat both of these cases identically:  save state, display
; registers and go for another command.  If we get NMI's, we skip them or if
; it turns out that we are debugging ourselves, we skip them.

; Due to bogosities in the 808x chip, Consider tracing over an interrupt and
; then setting a breakpoint to where the interrupt returns.  You get the INT 3
; and then trace mode gets invoked!  This is why we ignore interrupts within
; ourselves.
REENTER:
	PUSH	BP
	MOV	BP,SP			; get a frame to address from
	PUSH	AX
;	MOV	AX,CS
;	CMP	AX,[BP].OLDCS		; Did we interrupt ourselves?
;	JNZ	GOREENTER		; no, go reenter
	IF	IBMJAPAN
	    MOV     AX,[BP].OLDIP
	    CMP     AX,OFFSET DG:NMIINT ; interrupt below NMI interrupt?
	    JB	    GOREENTER		; yes, go reenter
	    CMP     [BP].OLDIP,OFFSET DG:NMIINTEND
	    JAE     GOREENTER		; interrupt above NMI interrupt?
	    POP     AX			; restore state
	    POP     BP
	    SUB     SP,6		; switch TRACE and NMI stack frames
	    PUSH    BP
	    MOV     BP,SP		; set up frame
	    PUSH    AX			; get temp variable
	    MOV     AX,[BP].OLDERIP	; get NMI Vector
	    MOV     [BP].OLDIP,AX	; stuff in new NMI vector
	    MOV     AX,[BP].OLDERCS	; get NMI Vector
	    MOV     [BP].OLDCS,AX	; stuff in new NMI vector
	    MOV     AX,[BP].OLDERF	; get NMI Vector
	    AND     AH,0FEH		; turn off Trace if present
	    MOV     [BP].OLDF,AX	; stuff in new NMI vector
	    MOV     [BP].OLDERF,AX
	    MOV     [BP].OLDERIP,OFFSET DG:REENTER ; offset of routine
	    MOV     [BP].OLDERCS,CS	; and CS
	    POP     AX
	    POP     BP
	    IRET			; go try again
	ENDIF
GOREENTER:
	IF	IBMVER
	test	cpu_not_8088,1
	jnz	no_restore_pic_mask
	    MOV     AL,CS:[OLD_MASK]	; Recover Old mask
	    OUT     MASK_PORT,AL	; Restore it
no_restore_pic_mask:
	ENDIF

	MOV	AL,CS:[RSETFLAG]
; Determine, based on the previous instruction, what we are supposed to do
; to flags on the users stack.
	CMP	AL,09CH 		; PUSHF
	JNZ	NOFIX
; OlderIP = flags.  Turn off trace bit
	AND	[BP].OLDERIP,NOT F_TRACE
NOFIX:
	POP	AX
	POP	BP
REENTERREAL:
	MOV	CS:[SPSAVE+SEGDIF],SP
	MOV	CS:[SSSAVE+SEGDIF],SS
	MOV	CS:[FLSAVE],CS
	MOV	SS,CS:[FLSAVE]
	MOV	SP,OFFSET DG:RSTACK
	ASSUME	SS:DG

	PUSH	ES
	PUSH	DS
	PUSH	DI
	PUSH	SI
	PUSH	BP
	DEC	SP
	DEC	SP
	PUSH	DX
	PUSH	CX
	PUSH	BX
	PUSH	AX
	PUSH	SS
	POP	DS
	ASSUME	DS:DG

	MOV	SS,[SSSAVE]
	MOV	SP,[SPSAVE]
	ASSUME	SS:NOTHING

	POP	[IPSAVE]
	POP	[CSSAVE]
	POP	AX
	AND	AX,NOT F_TRACE		; TURN OFf trace mode bit
	MOV	[FLSAVE],AX
	MOV	[SPSAVE],SP
SETENVIRON:
	PUSH	DS
	POP	ES
	ASSUME	ES:DG

	PUSH	DS
	POP	SS
	ASSUME	SS:DG

	MOV	SP,OFFSET DG:STACK
	PUSH	DS
	XOR	AX,AX
	MOV	DS,AX
	ASSUME	DS:NOTHING

	IF	SETCNTC
	    MOV     WORD PTR DS:[8CH],OFFSET DG:DABORT ; Set Ctrl-C vector
	    MOV     WORD PTR DS:[8EH],CS
	ENDIF
	POP	DS
	ASSUME	DS:DG

	STI
	CLD
; Since we are about to issue system calls, let's grab the current user's
; extended error info.
	MOV	AH,GETEXTENDEDERROR
	INT	21H
	ASSUME	DS:NOTHING,ES:NOTHING

	MOV	SAVESTATE.DPL_AX,AX
	MOV	SAVESTATE.DPL_BX,BX
	MOV	SAVESTATE.DPL_CX,CX
	MOV	SAVESTATE.DPL_DX,DX
	MOV	SAVESTATE.DPL_SI,SI
	MOV	SAVESTATE.DPL_DI,DI
	MOV	SAVESTATE.DPL_DS,DS
	MOV	SAVESTATE.DPL_ES,ES
	MOV	AX,CS
	MOV	DS,AX
	MOV	ES,AX
	ASSUME	DS:DG,ES:DG

	IF	NOT SYSVER
	    MOV     AH,GET_CURRENT_PDB
	    INT     21H
	    MOV     [USER_PROC_PDB],BX
	    MOV     BX,BEGSEG
	    MOV     AH,SET_CURRENT_PDB
	    INT     21H
	ENDIF
	MOV	SI,OFFSET DG:BPTAB
	MOV	CX,[BRKCNT]
	JCXZ	SHOREG
	PUSH	ES
CLEARBP:
	LES	DI,DWORD PTR [SI]
	ADD	SI,4
	MOVSB
	LOOP	CLEARBP
	POP	ES
SHOREG:
	DEC	[TCOUNT]
	JZ	CHECKDISP
	JMP	STEP1
CHECKDISP:
	CALL	CRLF
	CALL	DISPREG
	JMP	COMMAND

; Input from the specified port and display result
INPUT:
	MOV	CX,4			; Port may have 4 digits
	CALL	GETHEX			; Get port number in DX
	CALL	GETEOL

	IN	AL,DX			; Variable port input

	PUSH	CS
	POP	ES
	MOV	DI,OFFSET DG:ARG_BUF
	CALL	HEX			; And display

	XOR	AL,AL
	STOSB
	MOV	DX,OFFSET DG:ARG_BUF_PTR
	JMP	PRINTF_CRLF

; Output a value to specified port.
OUTPUT:
	MOV	CX,4			; Port may have 4 digits
	CALL	GETHEX			; Get port number
	PUSH	DX			; Save while we get data
	MOV	CX,2			; Byte output only
	CALL	GETHEX			; Get data to output
	CALL	GETEOL
	XCHG	AX,DX			; Output data in AL
	POP	DX			; Port in DX

	OUT	DX,AL			; Variable port output

	RETURN

SETADD:
	MOV	DX,CSSAVE		; set up start addresses
	MOV	NEXTCS,DX
	MOV	DX,IPSAVE
	MOV	NEXTIP,DX
	MOV	BP,[CSSAVE]
	CALL	SCANP
	CMP	BYTE PTR [SI],"="
	RETNZ
	INC	SI
	CALL	ADDRESS
	MOV	NEXTCS,AX
	MOV	NEXTIP,DX
	RETURN

; Jump to program, setting up registers according to the
; save area. up to 10 breakpoint addresses may be specified.
GO:
	MOV	RSETFLAG,0
	CALL	SETADD
	XOR	BX,BX
	MOV	DI,OFFSET DG:BPTAB
GO1:
	CALL	SCANP
	JZ	DEXEC
	MOV	BP,[CSSAVE]
	PUSH	DI
	PUSH	BX			;AN000; DMS;SAVE BX - ADDRESS KILLS IT
	CALL	ADDRESS
	POP	BX			;AN000; DMS;RESTORE BX
	POP	DI
	MOV	[DI],DX 		; Save offset
	MOV	[DI+2],AX		; Save segment
	ADD	DI,5			; Leave a little room
	INC	BX
	CMP	BX,1+BPMAX
	JNZ	GO1
	MOV	DX,OFFSET DG:BP_ERROR	; BP ERROR
	JMP	ERR
DEXEC:
	MOV	[BRKCNT],BX
	MOV	CX,BX
	JCXZ	NOBP
	MOV	DI,OFFSET DG:BPTAB
	PUSH	DS
SETBP:
	LDS	SI,ES:DWORD PTR [DI]
	ADD	DI,4
	MOVSB
	MOV	BYTE PTR [SI-1],0CCH
	LOOP	SETBP
	POP	DS
NOBP:
	MOV	DX,NEXTCS
	MOV	CSSAVE,DX
	MOV	DX,NEXTIP
	MOV	IPSAVE,DX
	MOV	[TCOUNT],1
	JMP	DEXIT

SKIP_FILE:
	MOV	AH,CHAR_OPER
	XOR	AL,AL			; Get switch char subfunction
	INT	21H
	MOV	CS:[SWITCHAR],DL	; GET THE CURRENT SWITCH CHARACTER
FIND_DELIM:
	LODSB
	CALL	DELIM1
	JZ	GOTDELIM
	CALL	DELIM2
	JNZ	FIND_DELIM
GOTDELIM:
	DEC	SI
	RETURN

COMPARE:
	CALL	DSRANGE
	PUSH	CX
	PUSH	AX
	PUSH	DX
	CALL	ADDRESS 		; Same segment
	CALL	GETEOL
	POP	SI
	MOV	DI,DX
	MOV	ES,AX
	POP	DS
	POP	CX			; Length
	DEC	CX
	CALL	COMP			; Do one less than total
	INC	CX			; CX=1 (do last one)
COMP:
	REPE	CMPSB
	RETZ
; Compare error. Print address, value; value, address.
	DEC	SI
	MOV	CS:COMP_ARG1,DS
	MOV	CS:COMP_ARG2,SI
	XOR	AH,AH
	LODSB
	MOV	CS:COMP_ARG3,AX
	DEC	DI
	MOV	AL,ES:[DI]
	MOV	CS:COMP_ARG4,AX
	MOV	CS:COMP_ARG5,ES
	MOV	CS:COMP_ARG6,DI
	INC	DI
	PUSH	DS
	PUSH	CS
	POP	DS
	MOV	DX,OFFSET DG:COMP_PTR
	CALL	PRINTF_CRLF
	POP	DS
	XOR	AL,AL
	JMP	SHORT COMP

	PROCEDURE CHECKNONE,NEAR
	OR	DX,DX
	RETNZ
	MOV	DX,OFFSET DG:SYNERR_PTR ; ERROR MESSAGE
	JMP	PERR
	ENDPROC CHECKNONE

CODE	ENDS
	END	DEBCOM3

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\debdata.asm ===
PAGE    60,132 ;
	   TITLE DEBDATA.ASM
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DEBDATA.ASM
;
; DESCRIPTIVE NAME: DATA SEGMENT VALUE DEFINITION
;
; FUNCTION: PROVIDES ALL DATA SEGMENT DEFINITIONS.
;
; ENTRY POINT: NA
;
; INPUT: ANY VALUE IN DATA SEGMENT
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES: NA
;
; EXTERNAL REFERENCES: NA
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT DBCS HANDLING	DMS:6/17/87
;				- IMPLEMENT MESSAGE RETRIEVER	DMS:6/17/87
;				- > 32 MB SUPPORT		DMS:6/17/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;======================= END OF SPECIFICATIONS ===========================
;
;   Change Log:
;
;     Date    Who   #			Description
;   --------  ---  ---	------------------------------------------------------
;   03/21/90  DIC  C04	Fixed Microsoft Bug #744 - A problem involving a
;			limitation on the total number of requested EMS memory
;			pages to 255.  This limit is now a 4-digit hexadecimal
;			number.
;
;=============================================================================

.XLIST
.XCREF
	   include version.inc		; cas -- missing equates
	   INCLUDE DOSSYM.INC
           INCLUDE debug.inc
	   INCLUDE DPL.ASM
.LIST
.CREF
CODE	   SEGMENT PUBLIC BYTE
CODE	   ENDS

CONST	   SEGMENT PUBLIC BYTE
CONST	   ENDS

DATA	   SEGMENT PUBLIC BYTE
DATA	   ENDS

CSTACK	   SEGMENT STACK
CSTACK	   ENDS

DG	   GROUP CODE,CONST,CSTACK,DATA

DATA	   SEGMENT PUBLIC BYTE
	   PUBLIC PARITYFLAG,XNXOPT,XNXCMD,SWITCHAR,EXTPTR,HANDLE,TRANSADD
	   PUBLIC PARSERR,ASMADD,DISADD,DISCNT,ASMSP,INDEX,DEFDUMP,DEFLEN
	   PUBLIC REGSAVE,SEGSAVE,OFFSAVE,TEMP,BUFFER,BYTCNT,OPCODE,AWORD
	   PUBLIC REGMEM,MIDFLD,MODE,NSEG,BRKCNT,TCOUNT,ASSEM_CNT
	   PUBLIC ASSEM1,ASSEM2,ASSEM3,ASSEM4,ASSEM5,ASSEM6,BYTEBUF,BPTAB
	   PUBLIC DIFLG,SIFLG,BXFLG,BPFLG,NEGFLG,NUMFLG,MEMFLG,REGFLG
	   PUBLIC MOVFLG,TSTFLG,SEGFLG,LOWNUM,HINUM,F8087,DIRFLG,DATAEND
	   PUBLIC BEGSEG,CREATE_LONG,ARG_BUF_INDEX
	   PUBLIC FILEEND,FILESTRT,SSINTSAV,BPINTSAV
	   PUBLIC FZTRACE, PREV24, FIN24

	   public rel_read_write_tab		;an000;relative read/write
						;      table
	   public rel_low_sec			;an000;sector add. low word
	   public rel_high_sec			;an000;sector add. high word
	   public rel_sec_num			;an000;# of sectors to access
	   public rel_rw_add			;an000;transfer address

	   public lbtbl 			;an000;lead byte table pointer

	public xm_page				;an000;
	public xm_log				;an000;
	public xm_phy				;an000;
	public xm_handle			;an000;
	public xm_handle_ret			;an000;
	public xm_page_cnt			;an000;
	public xm_handle_pages_buf		;an000;
	public xm_frame 			;an000;
	public xm_deall_han			;an000;
	public xm_alloc_pg			;an000;
	public xm_total_pg			;an000;
	public xm_han_total			;an000;
	public xm_han_alloc			;an000;

;=========================================================================
; REL_READ_WRITE_TAB : This table provides the new generic IOCTL primitive
;		       read/write with its values.
;
;	Date	  : 6/17/87
;=========================================================================

REL_READ_WRITE_TAB	label	dword		;an000;relative read/write
						;      table
	rel_low_sec	dw	?		;an000;sector add. low word
	rel_high_sec	dw	?		;an000;sector add. high word
	rel_sec_num	dw	?		;an000;# of sectors to write
	rel_rw_add	dd	?		;an000;holds the segment
						;      & offset of the
						;      transfer address

;=========================================================================

lbtbl		dd	?			;an000;lead byte table pointer

;C04	xm_page        db   ?			;an000;page count to allocate
	xm_page        dw   ?	;page count to allocate - raised to 64K    ;C04
	xm_log	       db   ?			;an000;log. page to map
	xm_phy	       db   ?			;an000;phy. page to map
	xm_deall_han   dw   ?			;an000;handle to deallocate
	xm_handle      dw   ?			;an000;handle to map
	xm_handle_ret  dw   ?			;an000;handle created


	xm_page_cnt    dw   ?			;an000;current page count

	xm_handle_pages_buf db	 1024 dup(0)	;an000;hold handle pages

	xm_frame	dw  ?			;an000;holds frame segment

	xm_alloc_pg	dw  ?			;an000;active page count

	xm_total_pg	dw  ?			;an000;total possible page cnt.

	xm_han_total	dw  ?			;an000;total possible handles

	xm_han_alloc	dw  ?			;an000;handles allocated

	   IF	IBMVER
	       PUBLIC OLD_MASK
OLD_MASK       DB   ?
		public	cpu_not_8088
cpu_not_8088	db	?			; true if not 8088/8086
	   ENDIF

PREV24	   DD	?			; prevvious INT 24 handler
FIN24	   DB	0			; TRUE => in the process of cleaning up
FZTRACE    DB	0			; TRUE => in a Ztrace
FILEEND    DW	?			; ARR 2.4
FILESTRT   DW	?			; ARR 2.4
SSINTSAV   DD	?			; ARR 2.4
BPINTSAV   DD	?			; ARR 2.4

PARITYFLAG DB	0

PUBLIC	   SAVESTATE
SAVESTATE  DPL	<>			; storage for extended error info

XNXOPT	   DB	?			; AL OPTION FOR DOS COMMAND
XNXCMD	   DB	?			; DOS COMMAND FOR OPEN_A_FILE TO PERFORM
SWITCHAR   DB	?			; CURRENT SWITCH CHARACTER
EXTPTR	   DW	?			; POINTER TO FILE EXTENSION
HANDLE	   DW	?			; CURRENT HANDLE
TRANSADD   DD	?			; TRANSFER ADDRESS

PARSERR    DB	?
ASMADD	   DB	4 DUP (?)
DISADD	   DB	4 DUP (?)
DISCNT	   DW	?
ASMSP	   DW	?			; SP AT ENTRY TO ASM
INDEX	   DW	?
DEFDUMP    DB	4 DUP (?)
DEFLEN	   DW	?
REGSAVE    DW	?
SEGSAVE    DW	?
OFFSAVE    DW	?

;Do NOT move this dword variable - it sets up a long call for
;a Create_process_data_block call issued in DEBUG
CREATE_LONG LABEL DWORD
	   DW	100H
BEGSEG	   DW	?

; The following data areas are destroyed during hex file read
TEMP	   DB	4 DUP(?)
BUFFER	   LABEL BYTE
BYTCNT	   DB	?
ARG_BUF_INDEX DW ?
OPCODE	   DW	?
AWORD	   DB	?
REGMEM	   DB	?
MIDFLD	   DB	?
MODE	   DB	?
NSEG	   DW	?
BRKCNT	   DW	?			; Number of breakpoints
TCOUNT	   DW	?			; Number of steps to trace
ASSEM_CNT  DB	?			; preserve order of assem_cnt and assem1
ASSEM1	   DB	?
ASSEM2	   DB	?
ASSEM3	   DB	?
ASSEM4	   DB	?
ASSEM5	   DB	?
ASSEM6	   DB	?			; preserve order of assemx and bytebuf
BYTEBUF    DB	BUFLEN	DUP (?) 	; Table used by LIST
BPTAB	   DB	BPLEN	DUP (?) 	; Breakpoint table
DIFLG	   DB	?
SIFLG	   DB	?
BXFLG	   DB	?
BPFLG	   DB	?
NEGFLG	   DB	?
NUMFLG	   DB	?			; ZERO MEANS NO NUMBER SEEN
MEMFLG	   DB	?
REGFLG	   DB	?
MOVFLG	   DB	?
TSTFLG	   DB	?
SEGFLG	   DB	?
LOWNUM	   DW	?
HINUM	   DW	?
F8087	   DB	?
DIRFLG	   DB	?
	   DB	BUFFER+BUFSIZ-$ DUP (?)

DATAEND    LABEL WORD

DATA	   ENDS
	   END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\debconst.asm ===
;**************************************************************************
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;   Change Log:
;
;     Date    Who   #                   Description
;   --------  ---  ---  ------------------------------------------------------
;   04/01/90  DIC  C01  These variables are used to determine if enough memory
;                       is available to write a file out to disk. (Compaq STR
;                       #1889) (MS Bug #774)
;*****************************************************************************/
           PAGE    80,132 ;
	   TITLE DEBCONST.ASM
	   IF1
	       %OUT COMPONENT=DEBUG, MODULE=DEBCONST
	   ENDIF
.XLIST
.XCREF
include	version.inc		; cas -- missing equates
include	syscall.inc		; cas -- missing equates
INCLUDE    DOSSYM.INC
INCLUDE    debug.inc
.LIST
.CREF

CODE	   SEGMENT PUBLIC BYTE
CODE	   ENDS

CONST	   SEGMENT PUBLIC BYTE
CONST	   ENDS

CSTACK	   SEGMENT STACK
CSTACK	   ENDS

DATA	   SEGMENT PUBLIC BYTE
DATA	   ENDS

DG	   GROUP CODE,CONST,CSTACK,DATA

CODE	   SEGMENT PUBLIC  BYTE

	   EXTRN ALUFROMREG:NEAR, ALUTOREG:NEAR, ACCIMM:NEAR, SEGOP:NEAR
	   EXTRN ESPRE:NEAR, SSPRE:NEAR, CSPRE:NEAR, DSPRE:NEAR
	   EXTRN REGOP:NEAR, NOOPERANDS:NEAR, SAVHEX:NEAR, SHORTJMP:NEAR
	   EXTRN MOVSEGTO:NEAR, WORDTOALU:NEAR, MOVSEGFROM:NEAR
	   EXTRN GETADDR:NEAR, XCHGAX:NEAR, LONGJMP:NEAR, LOADACC:NEAR
	   EXTRN STOREACC:NEAR, REGIMMB:NEAR, SAV16:NEAR, MEMIMM:NEAR
	   EXTRN INT3:NEAR, SAV8:NEAR, CHK10:NEAR, M8087:NEAR
	   EXTRN M8087_D9:NEAR, M8087_DB:NEAR, M8087_DD:NEAR
	   EXTRN M8087_DF:NEAR, INFIXB:NEAR, INFIXW:NEAR, OUTFIXB:NEAR
	   EXTRN OUTFIXW:NEAR, JMPCALL:NEAR, INVARB:NEAR, INVARW:NEAR
	   EXTRN OUTVARB:NEAR, OUTVARW:NEAR, PREFIX:NEAR, IMMED:NEAR
	   EXTRN SIGNIMM:NEAR, SHIFT:NEAR, SHIFTV:NEAR, GRP1:NEAR
	   EXTRN GRP2:NEAR, REGIMMW:NEAR, DOORG:NEAR


	   EXTRN DB_OPER:NEAR, DW_OPER:NEAR, ASSEMLOOP:NEAR, GROUP2:NEAR
	   EXTRN NO_OPER:NEAR, GROUP1:NEAR, FGROUPP:NEAR, FGROUPX:NEAR
	   EXTRN FGROUPZ:NEAR, FD9_OPER:NEAR, FGROUPB:NEAR, FGROUP:NEAR
	   EXTRN FGROUPDS:NEAR, DCINC_OPER:NEAR, INT_OPER:NEAR
	   EXTRN IN_OPER:NEAR, DISP8_OPER:NEAR, JMP_OPER:NEAR, L_OPER:NEAR
	   EXTRN MOV_OPER:NEAR, OUT_OPER:NEAR, PUSH_OPER:NEAR
	   EXTRN GET_DATA16:NEAR, FGROUP3:NEAR, FGROUP3W:NEAR
	   EXTRN FDE_OPER:NEAR, ESC_OPER:NEAR, AA_OPER:NEAR
	   EXTRN CALL_OPER:NEAR, FDB_OPER:NEAR, POP_OPER:NEAR, ROTOP:NEAR
	   EXTRN TST_OPER:NEAR, EX_OPER:NEAR

CODE	   ENDS

CONST	   SEGMENT PUBLIC BYTE

	   PUBLIC REG8, REG16, SREG, SIZ8, DISTAB, DBMN, ADDMN, ADCMN, SUBMN
	   PUBLIC SBBMN, XORMN, ORMN, ANDMN, AAAMN, AADMN, AASMN, CALLMN, CBWMN
	   PUBLIC UPMN, DIMN, CMCMN, CMPMN, CWDMN, DAAMN, DASMN, DECMN, DIVMN
	   PUBLIC ESCMN, HLTMN, IDIVMN, IMULMN, INCMN, INTOMN, INTMN, INMN
	   PUBLIC IRETMN, JAMN, JCXZMN, JNCMN, JBEMN, JZMN, JGEMN, JGMN, JLEMN
	   PUBLIC JLMN, JMPMN, JNZMN, JPEMN, JNZMN, JPEMN, JPOMN, JNSMN, JNOMN
	   PUBLIC JOMN, JSMN, LAHFMN, LDSMN, LEAMN, LESMN, LOCKMN, LODBMN
	   PUBLIC LODWMN, LOOPNZMN, LOOPZMN, LOOPMN, MOVBMN, MOVWMN, MOVMN
	   PUBLIC MULMN, NEGMN, NOPMN, NOTMN, OUTMN, POPFMN, POPMN, PUSHFMN
	   PUBLIC PUSHMN, RCLMN, RCRMN, REPZMN, REPNZMN, RETFMN, RETMN, ROLMN
	   PUBLIC RORMN, SAHFMN, SARMN, SCABMN, SCAWMN, SHLMN, SHRMN, STCMN
	   PUBLIC DOWNMN, EIMN, STOBMN, STOWMN, TESTMN, WAITMN, XCHGMN, XLATMN
	   PUBLIC ESSEGMN, CSSEGMN, SSSEGMN, DSSEGMN, BADMN

	   PUBLIC M8087_TAB, FI_TAB, SIZE_TAB, MD9_TAB, MD9_TAB2, MDB_TAB
	   PUBLIC MDB_TAB2, MDD_TAB, MDD_TAB2, MDF_TAB, OPTAB, MAXOP, SHFTAB
	   PUBLIC IMMTAB, GRP1TAB, GRP2TAB, SEGTAB, REGTAB, REGTABEND, FLAGTAB
	   PUBLIC STACK

           PUBLIC DriveOfFile,FileSizeHB,FileSizeLB,TempLB,TempHB     ;C01

	   PUBLIC AXSAVE, BXSAVE, CXSAVE, DXSAVE, BPSAVE, SPSAVE, SISAVE
	   PUBLIC DISAVE, DSSAVE, ESSAVE, SSSAVE, CSSAVE, IPSAVE, FLSAVE, RSTACK
	   PUBLIC REGDIF, RDFLG, TOTREG, DSIZ, NOREGL, DISPB, LBUFSIZ, LBUFFCNT
	   PUBLIC LINEBUF, PFLAG, COLPOS, RSETFLAG

	   IF	SYSVER
	   PUBLIC CONFCB, POUT, COUT, CIN, IOBUFF, IOADDR, IOCALL, IOCOM
	   PUBLIC IOSTAT, IOCHRET, IOSEG, IOCNT
	   ENDIF

	   PUBLIC QFLAG, NEWEXEC, RETSAVE, USER_PROC_PDB, HEADSAVE, EXEC_BLOCK
	   PUBLIC COM_LINE, COM_FCB1, COM_FCB2, COM_SSSP, COM_CSIP, NEXTCS
	   PUBLIC NEXTIP, NAMESPEC

REG8	   DB	"ALCLDLBLAHCHDHBH"
REG16	   DB	"AXCXDXBXSPBPSIDI"
SREG	   DB	"ESCSSSDS",0,0
SIZ8	   DB	"BYWODWQWTB",0,0
; 0
DISTAB	   DW	OFFSET DG:ADDMN,ALUFROMREG
	   DW	OFFSET DG:ADDMN,ALUFROMREG
	   DW	OFFSET DG:ADDMN,ALUTOREG
	   DW	OFFSET DG:ADDMN,ALUTOREG
	   DW	OFFSET DG:ADDMN,ACCIMM
	   DW	OFFSET DG:ADDMN,ACCIMM
	   DW	OFFSET DG:PUSHMN,SEGOP
	   DW	OFFSET DG:POPMN,SEGOP
	   DW	OFFSET DG:ORMN,ALUFROMREG
	   DW	OFFSET DG:ORMN,ALUFROMREG
	   DW	OFFSET DG:ORMN,ALUTOREG
	   DW	OFFSET DG:ORMN,ALUTOREG
	   DW	OFFSET DG:ORMN,ACCIMM
	   DW	OFFSET DG:ORMN,ACCIMM
	   DW	OFFSET DG:PUSHMN,SEGOP
	   DW	OFFSET DG:DBMN,SAVHEX		; cas -- this has always been
;						; disassembled as a POP CS,
;						; which doesn't really exist.
;						; It is now a 386 prefix, but
;						; we don't know about 386
;						; instructions, so we'll put
;						; out a DB
; 10H
	   DW	OFFSET DG:ADCMN,ALUFROMREG
	   DW	OFFSET DG:ADCMN,ALUFROMREG
	   DW	OFFSET DG:ADCMN,ALUTOREG
	   DW	OFFSET DG:ADCMN,ALUTOREG
	   DW	OFFSET DG:ADCMN,ACCIMM
	   DW	OFFSET DG:ADCMN,ACCIMM
	   DW	OFFSET DG:PUSHMN,SEGOP
	   DW	OFFSET DG:POPMN,SEGOP
	   DW	OFFSET DG:SBBMN,ALUFROMREG
	   DW	OFFSET DG:SBBMN,ALUFROMREG
	   DW	OFFSET DG:SBBMN,ALUTOREG
	   DW	OFFSET DG:SBBMN,ALUTOREG
	   DW	OFFSET DG:SBBMN,ACCIMM
	   DW	OFFSET DG:SBBMN,ACCIMM
	   DW	OFFSET DG:PUSHMN,SEGOP
	   DW	OFFSET DG:POPMN,SEGOP
; 20H
	   DW	OFFSET DG:ANDMN,ALUFROMREG
	   DW	OFFSET DG:ANDMN,ALUFROMREG
	   DW	OFFSET DG:ANDMN,ALUTOREG
	   DW	OFFSET DG:ANDMN,ALUTOREG
	   DW	OFFSET DG:ANDMN,ACCIMM
	   DW	OFFSET DG:ANDMN,ACCIMM
	   DW	OFFSET DG:ESSEGMN,ESPRE
	   DW	OFFSET DG:DAAMN,NOOPERANDS
	   DW	OFFSET DG:SUBMN,ALUFROMREG
	   DW	OFFSET DG:SUBMN,ALUFROMREG
	   DW	OFFSET DG:SUBMN,ALUTOREG
	   DW	OFFSET DG:SUBMN,ALUTOREG
	   DW	OFFSET DG:SUBMN,ACCIMM
	   DW	OFFSET DG:SUBMN,ACCIMM
	   DW	OFFSET DG:CSSEGMN,CSPRE
	   DW	OFFSET DG:DASMN,NOOPERANDS
; 30H
	   DW	OFFSET DG:XORMN,ALUFROMREG
	   DW	OFFSET DG:XORMN,ALUFROMREG
	   DW	OFFSET DG:XORMN,ALUTOREG
	   DW	OFFSET DG:XORMN,ALUTOREG
	   DW	OFFSET DG:XORMN,ACCIMM
	   DW	OFFSET DG:XORMN,ACCIMM
	   DW	OFFSET DG:SSSEGMN,SSPRE
	   DW	OFFSET DG:AAAMN,NOOPERANDS
	   DW	OFFSET DG:CMPMN,ALUFROMREG
	   DW	OFFSET DG:CMPMN,ALUFROMREG
	   DW	OFFSET DG:CMPMN,ALUTOREG
	   DW	OFFSET DG:CMPMN,ALUTOREG
	   DW	OFFSET DG:CMPMN,ACCIMM
	   DW	OFFSET DG:CMPMN,ACCIMM
	   DW	OFFSET DG:DSSEGMN,DSPRE
	   DW	OFFSET DG:AASMN,NOOPERANDS
; 40H
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
; 50H
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
; 60H
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
; 70H
	   DW	OFFSET DG:JOMN,SHORTJMP
	   DW	OFFSET DG:JNOMN,SHORTJMP
	   DW	OFFSET DG:JCMN,SHORTJMP
	   DW	OFFSET DG:JNCMN,SHORTJMP
	   DW	OFFSET DG:JZMN,SHORTJMP
	   DW	OFFSET DG:JNZMN,SHORTJMP
	   DW	OFFSET DG:JBEMN,SHORTJMP
	   DW	OFFSET DG:JAMN,SHORTJMP
	   DW	OFFSET DG:JSMN,SHORTJMP
	   DW	OFFSET DG:JNSMN,SHORTJMP
	   DW	OFFSET DG:JPEMN,SHORTJMP
	   DW	OFFSET DG:JPOMN,SHORTJMP
	   DW	OFFSET DG:JLMN,SHORTJMP
	   DW	OFFSET DG:JGEMN,SHORTJMP
	   DW	OFFSET DG:JLEMN,SHORTJMP
	   DW	OFFSET DG:JGMN,SHORTJMP
; 80H
	   DW	0,IMMED
	   DW	0,IMMED
	   DW	0,IMMED
	   DW	0,SIGNIMM
	   DW	OFFSET DG:TESTMN,ALUTOREG ;ARR 2.4
	   DW	OFFSET DG:TESTMN,ALUTOREG ;ARR 2.4
	   DW	OFFSET DG:XCHGMN,ALUTOREG ;ARR 2.4
	   DW	OFFSET DG:XCHGMN,ALUTOREG ;ARR 2.4
	   DW	OFFSET DG:MOVMN,ALUFROMREG
	   DW	OFFSET DG:MOVMN,ALUFROMREG
	   DW	OFFSET DG:MOVMN,ALUTOREG
	   DW	OFFSET DG:MOVMN,ALUTOREG
	   DW	OFFSET DG:MOVMN,MOVSEGTO
	   DW	OFFSET DG:LEAMN,WORDTOALU
	   DW	OFFSET DG:MOVMN,MOVSEGFROM
	   DW	OFFSET DG:POPMN,GETADDR
; 90H
	   DW	OFFSET DG:NOPMN,NOOPERANDS
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:CBWMN,NOOPERANDS
	   DW	OFFSET DG:CWDMN,NOOPERANDS
	   DW	OFFSET DG:CALLMN,LONGJMP
	   DW	OFFSET DG:WAITMN,NOOPERANDS
	   DW	OFFSET DG:PUSHFMN,NOOPERANDS
	   DW	OFFSET DG:POPFMN,NOOPERANDS
	   DW	OFFSET DG:SAHFMN,NOOPERANDS
	   DW	OFFSET DG:LAHFMN,NOOPERANDS
; A0H
	   DW	OFFSET DG:MOVMN,LOADACC
	   DW	OFFSET DG:MOVMN,LOADACC
	   DW	OFFSET DG:MOVMN,STOREACC
	   DW	OFFSET DG:MOVMN,STOREACC
	   DW	OFFSET DG:MOVBMN,NOOPERANDS
	   DW	OFFSET DG:MOVWMN,NOOPERANDS
	   DW	OFFSET DG:CMPBMN,NOOPERANDS
	   DW	OFFSET DG:CMPWMN,NOOPERANDS
	   DW	OFFSET DG:TESTMN,ACCIMM
	   DW	OFFSET DG:TESTMN,ACCIMM
	   DW	OFFSET DG:STOBMN,NOOPERANDS
	   DW	OFFSET DG:STOWMN,NOOPERANDS
	   DW	OFFSET DG:LODBMN,NOOPERANDS
	   DW	OFFSET DG:LODWMN,NOOPERANDS
	   DW	OFFSET DG:SCABMN,NOOPERANDS
	   DW	OFFSET DG:SCAWMN,NOOPERANDS
; B0H
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
; C0H
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:RETMN,SAV16
	   DW	OFFSET DG:RETMN,NOOPERANDS
	   DW	OFFSET DG:LESMN,WORDTOALU
	   DW	OFFSET DG:LDSMN,WORDTOALU
	   DW	OFFSET DG:MOVMN,MEMIMM
	   DW	OFFSET DG:MOVMN,MEMIMM
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:RETFMN,SAV16
	   DW	OFFSET DG:RETFMN,NOOPERANDS
	   DW	OFFSET DG:INTMN,INT3
	   DW	OFFSET DG:INTMN,SAV8
	   DW	OFFSET DG:INTOMN,NOOPERANDS
	   DW	OFFSET DG:IRETMN,NOOPERANDS
; D0H
	   DW	0,SHIFT
	   DW	0,SHIFT
	   DW	0,SHIFTV
	   DW	0,SHIFTV
	   DW	OFFSET DG:AAMMN,CHK10
	   DW	OFFSET DG:AADMN,CHK10
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:XLATMN,NOOPERANDS
	   DW	0,M8087 		; d8
	   DW	0,M8087_D9		; d9
	   DW	0,M8087 		; da
	   DW	0,M8087_DB		; db
	   DW	0,M8087 		; dc
	   DW	0,M8087_DD		; dd
	   DW	0,M8087 		; de
	   DW	0,M8087_DF		; df
; E0H
	   DW	OFFSET DG:LOOPNZMN,SHORTJMP
	   DW	OFFSET DG:LOOPZMN,SHORTJMP
	   DW	OFFSET DG:LOOPMN,SHORTJMP
	   DW	OFFSET DG:JCXZMN,SHORTJMP
	   DW	OFFSET DG:INMN,INFIXB
	   DW	OFFSET DG:INMN,INFIXW
	   DW	OFFSET DG:OUTMN,OUTFIXB
	   DW	OFFSET DG:OUTMN,OUTFIXW
	   DW	OFFSET DG:CALLMN,JMPCALL
	   DW	OFFSET DG:JMPMN,JMPCALL
	   DW	OFFSET DG:JMPMN,LONGJMP
	   DW	OFFSET DG:JMPMN,SHORTJMP
	   DW	OFFSET DG:INMN,INVARB
	   DW	OFFSET DG:INMN,INVARW
	   DW	OFFSET DG:OUTMN,OUTVARB
	   DW	OFFSET DG:OUTMN,OUTVARW
; F0H
	   DW	OFFSET DG:LOCKMN,PREFIX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:REPNZMN,PREFIX
	   DW	OFFSET DG:REPZMN,PREFIX
	   DW	OFFSET DG:HLTMN,NOOPERANDS
	   DW	OFFSET DG:CMCMN,NOOPERANDS
	   DW	0,GRP1
	   DW	0,GRP1
	   DW	OFFSET DG:CLCMN,NOOPERANDS
	   DW	OFFSET DG:STCMN,NOOPERANDS
	   DW	OFFSET DG:DIMN,NOOPERANDS
	   DW	OFFSET DG:EIMN,NOOPERANDS
	   DW	OFFSET DG:UPMN,NOOPERANDS
	   DW	OFFSET DG:DOWNMN,NOOPERANDS
	   DW	0,GRP2
	   DW	0,GRP2

DBMN	   DB	"DB",0
	   DB	"DW",0
	   DB	";",0
ORGMN	   DB	"ORG",0
ADDMN	   DB	"ADD",0
ADCMN	   DB	"ADC",0
SUBMN	   DB	"SUB",0
SBBMN	   DB	"SBB",0
XORMN	   DB	"XOR",0
ORMN	   DB	"OR",0
ANDMN	   DB	"AND",0
AAAMN	   DB	"AAA",0
AADMN	   DB	"AAD",0
AAMMN	   DB	"AAM",0
AASMN	   DB	"AAS",0
CALLMN	   DB	"CALL",0
CBWMN	   DB	"CBW",0
CLCMN	   DB	"CLC",0
UPMN	   DB	"CLD",0                 ; CLD,0
DIMN	   DB	"CLI",0
CMCMN	   DB	"CMC",0
CMPBMN	   DB	"CMPSB",0               ; CMPSB
CMPWMN	   DB	"CMPSW",0               ; CMPSW,0
CMPMN	   DB	"CMP",0
CWDMN	   DB	"CWD",0
DAAMN	   DB	"DAA",0
DASMN	   DB	"DAS",0
DECMN	   DB	"DEC",0
DIVMN	   DB	"DIV",0
ESCMN	   DB	"ESC",0
	   DB	"FXCH",0
	   DB	"FFREE",0
	   DB	"FCOMPP",0
	   DB	"FCOMP",0
	   DB	"FCOM",0
	   DB	"FICOMP",0
	   DB	"FICOM",0
	   DB	"FNOP",0
	   DB	"FCHS",0
	   DB	"FABS",0
	   DB	"FTST",0
	   DB	"FXAM",0
	   DB	"FLDL2T",0
	   DB	"FLDL2E",0
	   DB	"FLDLG2",0
	   DB	"FLDLN2",0
	   DB	"FLDPI",0
	   DB	"FLD1",0
	   DB	"FLDZ",0
	   DB	"F2XM1",0
	   DB	"FYL2XP1",0
	   DB	"FYL2X",0
	   DB	"FPTAN",0
	   DB	"FPATAN",0
	   DB	"FXTRACT",0
	   DB	"FDECSTP",0
	   DB	"FINCSTP",0
	   DB	"FPREM",0
	   DB	"FSQRT",0
	   DB	"FRNDINT",0
	   DB	"FSCALE",0
	   DB	"FINIT",0
	   DB	"FDISI",0
	   DB	"FENI",0
	   DB	"FCLEX",0
	   DB	"FBLD",0
	   DB	"FBSTP",0
	   DB	"FLDCW",0
	   DB	"FSTCW",0
	   DB	"FSTSW",0
	   DB	"FSTENV",0
	   DB	"FLDENV",0
	   DB	"FSAVE",0
	   DB	"FRSTOR",0
	   DB	"FADDP",0
	   DB	"FADD",0
	   DB	"FIADD",0
	   DB	"FSUBRP",0
	   DB	"FSUBR",0
	   DB	"FSUBP",0
	   DB	"FSUB",0
	   DB	"FISUBR",0
	   DB	"FISUB",0
	   DB	"FMULP",0
	   DB	"FMUL",0
	   DB	"FIMUL",0
	   DB	"FDIVRP",0
	   DB	"FDIVR",0
	   DB	"FDIVP",0
	   DB	"FDIV",0
	   DB	"FIDIVR",0
	   DB	"FIDIV",0
	   DB	"FWAIT",0
	   DB	"FILD",0
	   DB	"FLD",0
	   DB	"FSTP",0
	   DB	"FST",0
	   DB	"FISTP",0
	   DB	"FIST",0
HLTMN	   DB	"HLT",0
IDIVMN	   DB	"IDIV",0
IMULMN	   DB	"IMUL",0
INCMN	   DB	"INC",0
INTOMN	   DB	"INTO",0
INTMN	   DB	"INT",0
INMN	   DB	"IN",0                  ; IN
IRETMN	   DB	"IRET",0
	   DB	"JNBE",0
	   DB	"JAE",0
JAMN	   DB	"JA",0
JCXZMN	   DB	"JCXZ",0
JNCMN	   DB	"JNB",0
JBEMN	   DB	"JBE",0
JCMN	   DB	"JB",0
	   DB	"JNC",0
	   DB	"JC",0
	   DB	"JNAE",0
	   DB	"JNA",0
JZMN	   DB	"JZ",0
	   DB	"JE",0
JGEMN	   DB	"JGE",0
JGMN	   DB	"JG",0
	   DB	"JNLE",0
	   DB	"JNL",0
JLEMN	   DB	"JLE",0
JLMN	   DB	"JL",0
	   DB	"JNGE",0
	   DB	"JNG",0
JMPMN	   DB	"JMP",0
JNZMN	   DB	"JNZ",0
	   DB	"JNE",0
JPEMN	   DB	"JPE",0
JPOMN	   DB	"JPO",0
	   DB	"JNP",0
JNSMN	   DB	"JNS",0
JNOMN	   DB	"JNO",0
JOMN	   DB	"JO",0
JSMN	   DB	"JS",0
	   DB	"JP",0
LAHFMN	   DB	"LAHF",0
LDSMN	   DB	"LDS",0
LEAMN	   DB	"LEA",0
LESMN	   DB	"LES",0
LOCKMN	   DB	"LOCK",0
LODBMN	   DB	"LODSB",0               ; LODSB
LODWMN	   DB	"LODSW",0               ; LODSW,0
LOOPNZMN   DB	"LOOPNZ",0
LOOPZMN    DB	"LOOPZ",0
	   DB	"LOOPNE",0
	   DB	"LOOPE",0
LOOPMN	   DB	"LOOP",0
MOVBMN	   DB	"MOVSB",0               ; MOVSB
MOVWMN	   DB	"MOVSW",0               ; MOVSW,0
MOVMN	   DB	"MOV",0
MULMN	   DB	"MUL",0
NEGMN	   DB	"NEG",0
NOPMN	   DB	"NOP",0
NOTMN	   DB	"NOT",0
OUTMN	   DB	"OUT",0                 ; OUT
POPFMN	   DB	"POPF",0
POPMN	   DB	"POP",0
PUSHFMN    DB	"PUSHF",0
PUSHMN	   DB	"PUSH",0
RCLMN	   DB	"RCL",0
RCRMN	   DB	"RCR",0
REPZMN	   DB	"REPZ",0
REPNZMN    DB	"REPNZ",0
	   DB	"REPE",0
	   DB	"REPNE",0
	   DB	"REP",0
RETFMN	   DB	"RETF",0
RETMN	   DB	"RET",0
ROLMN	   DB	"ROL",0
RORMN	   DB	"ROR",0
SAHFMN	   DB	"SAHF",0
SARMN	   DB	"SAR",0
SCABMN	   DB	"SCASB",0               ; SCASB
SCAWMN	   DB	"SCASW",0               ; SCASW,0
SHLMN	   DB	"SHL",0
SHRMN	   DB	"SHR",0
STCMN	   DB	"STC",0
DOWNMN	   DB	"STD",0                 ; STD
EIMN	   DB	"STI",0                 ; STI
STOBMN	   DB	"STOSB",0               ; STOSB
STOWMN	   DB	"STOSW",0               ; STOSW,0
TESTMN	   DB	"TEST",0
WAITMN	   DB	"WAIT",0
XCHGMN	   DB	"XCHG",0
XLATMN	   DB	"XLAT",0
ESSEGMN    DB	"ES:",0
CSSEGMN    DB	"CS:",0
SSSEGMN    DB	"SS:",0
DSSEGMN    DB	"DS:",0
BADMN	   DB	"???",0

M8087_TAB  DB	"ADD$MUL$COM$COMP$SUB$SUBR$DIV$DIVR$"
FI_TAB	   DB	"F$FI$F$FI$"
SIZE_TAB   DB	"DWORD PTR $DWORD PTR $QWORD PTR $WORD PTR $"
	   DB	"BYTE PTR $TBYTE PTR $"

MD9_TAB    DB	"LD$@$ST$STP$LDENV$LDCW$STENV$STCW$"
MD9_TAB2   DB	"CHS$ABS$@$@$TST$XAM$@$@$LD1$LDL2T$LDL2E$"
	   DB	"LDPI$LDLG2$LDLN2$LDZ$@$2XM1$YL2X$PTAN$PATAN$XTRACT$"
	   DB	"@$DECSTP$INCSTP$PREM$YL2XP1$SQRT$@$RNDINT$SCALE$@$@$"

MDB_TAB    DB	"ILD$@$IST$ISTP$@$LD$@$STP$"
MDB_TAB2   DB	"ENI$DISI$CLEX$INIT$"

MDD_TAB    DB	"LD$@$ST$STP$RSTOR$@$SAVE$STSW$"
MDD_TAB2   DB	"FREE$XCH$ST$STP$"

MDF_TAB    DB	"ILD$@$IST$ISTP$BLD$ILD$BSTP$ISTP$"


OPTAB	   DB	11111111B		; DB
	   DW	DB_OPER
	   DB	11111111B		; DW
	   DW	DW_OPER
	   DB	11111111B		; COMMENT
	   DW	ASSEMLOOP
	   DB	11111111B		; ORG
	   DW	DOORG
	   DB	0 * 8			; ADD
	   DW	GROUP2
	   DB	2 * 8			; ADC
	   DW	GROUP2
	   DB	5 * 8			; SUB
	   DW	GROUP2
	   DB	3 * 8			; SBB
	   DW	GROUP2
	   DB	6 * 8			; XOR
	   DW	GROUP2
	   DB	1 * 8			; OR
	   DW	GROUP2
	   DB	4 * 8			; AND
	   DW	GROUP2
	   DB	00110111B		; AAA
	   DW	NO_OPER
	   DB	11010101B		; AAD
	   DW	AA_OPER
	   DB	11010100B		; AAM
	   DW	AA_OPER
	   DB	00111111B		; AAS
	   DW	NO_OPER
	   DB	2 * 8			; CALL
	   DW	CALL_OPER
	   DB	10011000B		; CBW
	   DW	NO_OPER
	   DB	11111000B		; CLC
	   DW	NO_OPER
	   DB	11111100B		; CLD
	   DW	NO_OPER
	   DB	11111010B		; DIM
	   DW	NO_OPER
	   DB	11110101B		; CMC
	   DW	NO_OPER
	   DB	10100110B		; CMPB
	   DW	NO_OPER
	   DB	10100111B		; CMPW
	   DW	NO_OPER
	   DB	7 * 8			; CMP
	   DW	GROUP2
	   DB	10011001B		; CWD
	   DW	NO_OPER
	   DB	00100111B		; DAA
	   DW	NO_OPER
	   DB	00101111B		; DAS
	   DW	NO_OPER
	   DB	1 * 8			; DEC
	   DW	DCINC_OPER
	   DB	6 * 8			; DIV
	   DW	GROUP1
	   DB	11011000B		; ESC
	   DW	ESC_OPER
	   DB	00001001B		; FXCH
	   DW	FGROUPP
	   DB	00101000B		; FFREE
	   DW	FGROUPP
	   DB	11011001B		; FCOMPP
	   DW	FDE_OPER
	   DB	00000011B		; FCOMP
	   DW	FGROUPX 		; Exception to normal P instructions
	   DB	00000010B		; FCOM
	   DW	FGROUPX
	   DB	00010011B		; FICOMP
	   DW	FGROUPZ
	   DB	00010010B		; FICOM
	   DW	FGROUPZ
	   DB	11010000B		; FNOP
	   DW	FD9_OPER
	   DB	11100000B		; FCHS
	   DW	FD9_OPER
	   DB	11100001B		; FABS
	   DW	FD9_OPER
	   DB	11100100B		; FTST
	   DW	FD9_OPER
	   DB	11100101B		; FXAM
	   DW	FD9_OPER
	   DB	11101001B		; FLDL2T
	   DW	FD9_OPER
	   DB	11101010B		; FLDL2E
	   DW	FD9_OPER
	   DB	11101100B		; FLDLG2
	   DW	FD9_OPER
	   DB	11101101B		; FLDLN2
	   DW	FD9_OPER
	   DB	11101011B		; FLDPI
	   DW	FD9_OPER
	   DB	11101000B		; FLD1
	   DW	FD9_OPER
	   DB	11101110B		; FLDZ
	   DW	FD9_OPER
	   DB	11110000B		; F2XM1
	   DW	FD9_OPER
	   DB	11111001B		; FYL2XP1
	   DW	FD9_OPER
	   DB	11110001B		; FYL2X
	   DW	FD9_OPER
	   DB	11110010B		; FPTAN
	   DW	FD9_OPER
	   DB	11110011B		; FPATAN
	   DW	FD9_OPER
	   DB	11110100B		; FXTRACT
	   DW	FD9_OPER
	   DB	11110110B		; FDECSTP
	   DW	FD9_OPER
	   DB	11110111B		; FINCSTP
	   DW	FD9_OPER
	   DB	11111000B		; FPREM
	   DW	FD9_OPER
	   DB	11111010B		; FSQRT
	   DW	FD9_OPER
	   DB	11111100B		; FRNDINT
	   DW	FD9_OPER
	   DB	11111101B		; FSCALE
	   DW	FD9_OPER
	   DB	11100011B		; FINIT
	   DW	FDB_OPER
	   DB	11100001B		; FDISI
	   DW	FDB_OPER
	   DB	11100000B		; FENI
	   DW	FDB_OPER
	   DB	11100010B		; FCLEX
	   DW	FDB_OPER
	   DB	00111100B		; FBLD
	   DW	FGROUPB
	   DB	00111110B		; FBSTP
	   DW	FGROUPB
	   DB	00001101B		; FLDCW
	   DW	FGROUP3W
	   DB	00001111B		; FSTCW
	   DW	FGROUP3W
	   DB	00101111B		; FSTSW
	   DW	FGROUP3W
	   DB	00001110B		; FSTENV
	   DW	FGROUP3
	   DB	00001100B		; FLDENV
	   DW	FGROUP3
	   DB	00101110B		; FSAVE
	   DW	FGROUP3
	   DB	00101100B		; FRSTOR
	   DW	FGROUP3
	   DB	00110000B		; FADDP
	   DW	FGROUPP
	   DB	00000000B		; FADD
	   DW	FGROUP
	   DB	00010000B		; FIADD
	   DW	FGROUPZ
	   DB	00110100B		; FSUBRP
	   DW	FGROUPP
	   DB	00000101B		; FSUBR
	   DW	FGROUPDS
	   DB	00110101B		; FSUBP
	   DW	FGROUPP
	   DB	00000100B		; FSUB
	   DW	FGROUPDS
	   DB	00010101B		; FISUBR
	   DW	FGROUPZ
	   DB	00010100B		; FISUB
	   DW	FGROUPZ
	   DB	00110001B		; FMULP
	   DW	FGROUPP
	   DB	00000001B		; FMUL
	   DW	FGROUP
	   DB	00010001B		; FIMUL
	   DW	FGROUPZ
	   DB	00110110B		; FDIVRP
	   DW	FGROUPP
	   DB	00000111B		; FDIVR
	   DW	FGROUPDS
	   DB	00110111B		; FDIVP
	   DW	FGROUPP
	   DB	00000110B		; FDIV
	   DW	FGROUPDS
	   DB	00010111B		; FIDIVR
	   DW	FGROUPZ
	   DB	00010110B		; FIDIV
	   DW	FGROUPZ
	   DB	10011011B		; FWAIT
	   DW	NO_OPER
	   DB	00011000B		; FILD
	   DW	FGROUPZ
	   DB	00001000B		; FLD
	   DW	FGROUPX
	   DB	00001011B		; FSTP
	   DW	FGROUP			;an000; dms;
	   DB	00101010B		; FST
	   DW	FGROUPX
	   DB	00011011B		; FISTP
	   DW	FGROUPZ
	   DB	00011010B		; FIST
	   DW	FGROUPZ
	   DB	11110100B		; HLT
	   DW	NO_OPER
	   DB	7 * 8			; IDIV
	   DW	GROUP1
	   DB	5 * 8			; IMUL
	   DW	GROUP1
	   DB	0 * 8			; INC
	   DW	DCINC_OPER
	   DB	11001110B		; INTO
	   DW	NO_OPER
	   DB	11001100B		; INTM
	   DW	INT_OPER
	   DB	11101100B		; IN
	   DW	IN_OPER
	   DB	11001111B		; IRET
	   DW	NO_OPER
	   DB	01110111B		; JNBE
	   DW	DISP8_OPER
	   DB	01110011B		; JAE
	   DW	DISP8_OPER
	   DB	01110111B		; JA
	   DW	DISP8_OPER
	   DB	11100011B		; JCXZ
	   DW	DISP8_OPER
	   DB	01110011B		; JNB
	   DW	DISP8_OPER
	   DB	01110110B		; JBE
	   DW	DISP8_OPER
	   DB	01110010B		; JB
	   DW	DISP8_OPER
	   DB	01110011B		; JNC
	   DW	DISP8_OPER
	   DB	01110010B		; JC
	   DW	DISP8_OPER
	   DB	01110010B		; JNAE
	   DW	DISP8_OPER
	   DB	01110110B		; JNA
	   DW	DISP8_OPER
	   DB	01110100B		; JZ
	   DW	DISP8_OPER
	   DB	01110100B		; JE
	   DW	DISP8_OPER
	   DB	01111101B		; JGE
	   DW	DISP8_OPER
	   DB	01111111B		; JG
	   DW	DISP8_OPER
	   DB	01111111B		; JNLE
	   DW	DISP8_OPER
	   DB	01111101B		; JNL
	   DW	DISP8_OPER
	   DB	01111110B		; JLE
	   DW	DISP8_OPER
	   DB	01111100B		; JL
	   DW	DISP8_OPER
	   DB	01111100B		; JNGE
	   DW	DISP8_OPER
	   DB	01111110B		; JNG
	   DW	DISP8_OPER
	   DB	4 * 8			; JMP
	   DW	JMP_OPER
	   DB	01110101B		; JNZ
	   DW	DISP8_OPER
	   DB	01110101B		; JNE
	   DW	DISP8_OPER
	   DB	01111010B		; JPE
	   DW	DISP8_OPER
	   DB	01111011B		; JPO
	   DW	DISP8_OPER
	   DB	01111011B		; JNP
	   DW	DISP8_OPER
	   DB	01111001B		; JNS
	   DW	DISP8_OPER
	   DB	01110001B		; JNO
	   DW	DISP8_OPER
	   DB	01110000B		; JO
	   DW	DISP8_OPER
	   DB	01111000B		; JS
	   DW	DISP8_OPER
	   DB	01111010B		; JP
	   DW	DISP8_OPER
	   DB	10011111B		; LAHF
	   DW	NO_OPER
	   DB	11000101B		; LDS
	   DW	L_OPER
	   DB	10001101B		; LEA
	   DW	L_OPER
	   DB	11000100B		; LES
	   DW	L_OPER
	   DB	11110000B		; LOCK
	   DW	NO_OPER
	   DB	10101100B		; LODB
	   DW	NO_OPER
	   DB	10101101B		; LODW
	   DW	NO_OPER
	   DB	11100000B		; LOOPNZ
	   DW	DISP8_OPER
	   DB	11100001B		; LOOPZ
	   DW	DISP8_OPER
	   DB	11100000B		; LOOPNE
	   DW	DISP8_OPER
	   DB	11100001B		; LOOPE
	   DW	DISP8_OPER
	   DB	11100010B		; LOOP
	   DW	DISP8_OPER
	   DB	10100100B		; MOVB
	   DW	NO_OPER
	   DB	10100101B		; MOVW
	   DW	NO_OPER
	   DB	11000110B		; MOV
	   DW	MOV_OPER
	   DB	4 * 8			; MUL
	   DW	GROUP1
	   DB	3 * 8			; NEG
	   DW	GROUP1
	   DB	10010000B		; NOP
	   DW	NO_OPER
	   DB	2 * 8			; NOT
	   DW	GROUP1
	   DB	11101110B		; OUT
	   DW	OUT_OPER
	   DB	10011101B		; POPF
	   DW	NO_OPER
	   DB	0 * 8			; POP
	   DW	POP_OPER
	   DB	10011100B		; PUSHF
	   DW	NO_OPER
	   DB	6 * 8			; PUSH
	   DW	PUSH_OPER
	   DB	2 * 8			; RCL
	   DW	ROTOP
	   DB	3 * 8			; RCR
	   DW	ROTOP
	   DB	11110011B		; REPZ
	   DW	NO_OPER
	   DB	11110010B		; REPNZ
	   DW	NO_OPER
	   DB	11110011B		; REPE
	   DW	NO_OPER
	   DB	11110010B		; REPNE
	   DW	NO_OPER
	   DB	11110011B		; REP
	   DW	NO_OPER
	   DB	11001011B		; RETF
	   DW	GET_DATA16
	   DB	11000011B		; RET
	   DW	GET_DATA16
	   DB	0 * 8			; ROL
	   DW	ROTOP
	   DB	1 * 8			; ROR
	   DW	ROTOP
	   DB	10011110B		; SAHF
	   DW	NO_OPER
	   DB	7 * 8			; SAR
	   DW	ROTOP
	   DB	10101110B		; SCAB
	   DW	NO_OPER
	   DB	10101111B		; SCAW
	   DW	NO_OPER
	   DB	4 * 8			; SHL
	   DW	ROTOP
	   DB	5 * 8			; SHR
	   DW	ROTOP
	   DB	11111001B		; STC
	   DW	NO_OPER
	   DB	11111101B		; STD
	   DW	NO_OPER
	   DB	11111011B		; EI
	   DW	NO_OPER
	   DB	10101010B		; STOB
	   DW	NO_OPER
	   DB	10101011B		; STOW
	   DW	NO_OPER
	   DB	11110110B		; TEST
	   DW	TST_OPER
	   DB	10011011B		; WAIT
	   DW	NO_OPER
	   DB	10000110B		; XCHG
	   DW	EX_OPER
	   DB	11010111B		; XLAT
	   DW	NO_OPER
	   DB	00100110B		; ESSEG
	   DW	NO_OPER
	   DB	00101110B		; CSSEG
	   DW	NO_OPER
	   DB	00110110B		; SSSEG
	   DW	NO_OPER
	   DB	00111110B		; DSSEG
	   DW	NO_OPER

ZZOPCODE   LABEL BYTE
MAXOP	   =	(ZZOPCODE-OPTAB)/3

SHFTAB	   DW	OFFSET DG:ROLMN,OFFSET DG:RORMN,OFFSET DG:RCLMN
	   DW	OFFSET DG:RCRMN,OFFSET DG:SHLMN,OFFSET DG:SHRMN
	   DW	OFFSET DG:BADMN,OFFSET DG:SARMN

IMMTAB	   DW	OFFSET DG:ADDMN,OFFSET DG:ORMN,OFFSET DG:ADCMN
	   DW	OFFSET DG:SBBMN,OFFSET DG:ANDMN,OFFSET DG:SUBMN
	   DW	OFFSET DG:XORMN,OFFSET DG:CMPMN

GRP1TAB    DW	OFFSET DG:TESTMN,OFFSET DG:BADMN,OFFSET DG:NOTMN
	   DW	OFFSET DG:NEGMN,OFFSET DG:MULMN,OFFSET DG:IMULMN
	   DW	OFFSET DG:DIVMN,OFFSET DG:IDIVMN

GRP2TAB    DW	OFFSET DG:INCMN,OFFSET DG:DECMN,OFFSET DG:CALLMN
	   DW	OFFSET DG:CALLMN,OFFSET DG:JMPMN,OFFSET DG:JMPMN
	   DW	OFFSET DG:PUSHMN,OFFSET DG:BADMN

SEGTAB	   DW	OFFSET DG:ESSAVE,OFFSET DG:CSSAVE,OFFSET DG:SSSAVE
	   DW	OFFSET DG:DSSAVE

REGTAB	   DB	"AX",0,"BX",0,"CX",0,"DX",0,"SP",0,"BP",0
	   DB	"SI",0,"DI",0,"DS",0,"ES",0,"SS",0,"CS",0,"IP",0,"PC",0
REGTABEND  LABEL WORD

; Flags are ordered to correspond with the bits of the flag
; register, most significant bit first, zero if bit is not
; a flag. First 16 entries are for bit set, second 16 for
; bit reset.

FLAGTAB    DW	0
	   DW	0
	   DW	0
	   DW	0
	   DB	"OV"
	   DB	"DN"
	   DB	"EI"                    ; "STI"
	   DW	0
	   DB	"NG"
	   DB	"ZR"
	   DW	0
	   DB	"AC"
	   DW	0
	   DB	"PE"
	   DW	0
	   DB	"CY"
	   DW	0
	   DW	0
	   DW	0
	   DW	0
	   DB	"NV"
	   DB	"UP"                    ; "CLD"
	   DB	"DI"
	   DW	0
	   DB	"PL"
	   DB	"NZ"
	   DW	0
	   DB	"NA"
	   DW	0
	   DB	"PO"
	   DW	0
	   DB	"NC"

	   DW	80H DUP(?)
STACK	   LABEL BYTE


; Register save area

AXSAVE	   DW	0
BXSAVE	   DW	0
CXSAVE	   DW	0
DXSAVE	   DW	0
SPSAVE	   DW	5AH
BPSAVE	   DW	0
SISAVE	   DW	0
DISAVE	   DW	0
DSSAVE	   DW	0
ESSAVE	   DW	0
RSTACK	   LABEL WORD			; Stack set here so registers can be saved by pushing
SSSAVE	   DW	0
CSSAVE	   DW	0
IPSAVE	   DW	100H
FLSAVE	    DW	 0F202H

RSETFLAG   DB	0

;  These variables used to determine if the file is larget than the   ;C01
;  amount of disk space available whenever a write occurs.            ;C01
								      ;C01
FileSizeLB DW   0                                                     ;C01
FileSizeHB DW   0                                                     ;C01
TempHB     DW   0                                                     ;C01
TempLB     DW   0                                                     ;C01
DriveOfFile DB  ?                                                     ;C01

REGDIF	   EQU	AXSAVE-REGTAB

; This value is initially 0, it is set to non-zero if a file is specified
;  either at debug invokation, or via the (N)ame command. It is used to
;  control the printing of the NONAMESPEC message for the (W)rite command.
NAMESPEC   DB	0

; RAM area.

RDFLG	   DB	READ
TOTREG	   DB	13
DSIZ	   DB	0FH			;changed to 7 if screen 40 col mode
NOREGL	   DB	8			;changed to 4 if screen 40 col mode
DISPB	   DW	128			;changed to 64 if screen 40 col mode

LBUFSIZ    DB	BUFLEN
LBUFFCNT   DB	0
LINEBUF    DB	0DH
	   DB	BUFLEN DUP (?)
PFLAG	   DB	0
COLPOS	   DB	0

	   IF	SYSVER
CONFCB	   DB	0
	   DB	"PRN        "
	   DB	25 DUP(0)

POUT	   DD	?
COUT	   DD	?
CIN	   DD	?
IOBUFF	   DB	3 DUP (?)
IOADDR	   DD	?

IOCALL	   DB	22
	   DB	0
IOCOM	   DB	0
IOSTAT	   DW	0
	   DB	8 DUP (0)
IOCHRET    DB	0
	   DW	OFFSET DG:IOBUFF
IOSEG	   DW	?
IOCNT	   DW	1
	   DW	0
	   ENDIF

QFLAG	   DB	0
NEWEXEC    DB	0
RETSAVE    DW	?

USER_PROC_PDB DW ?
NextCS	   DW	?
NextIP	   DW	?

HEADSAVE   DW	?

EXEC_BLOCK LABEL BYTE
	   DW	0
COM_LINE   LABEL DWORD
	   DW	80H
	   DW	?
COM_FCB1   LABEL DWORD
	   DW	FCB
	   DW	?
COM_FCB2   LABEL DWORD
	   DW	FCB + 10H
	   DW	?
COM_SSSP   DD	?
COM_CSIP   DD	?

CONST	   ENDS
	   END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\debasm.asm ===
PAGE	80,132 ;
	TITLE	DEBASM.ASM
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; CODE FOR THE ASSEMBLE COMMAND IN THE DEBUGGER

	IF1
	    %OUT COMPONENT=DEBUG, MODULE=DEBASM
	ENDIF
.XLIST
.XCREF
	include	version.inc		; cas -- missing equates
	INCLUDE DOSSYM.INC
        INCLUDE debug.inc
.CREF
.LIST


CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE

	EXTRN	DBMN:BYTE,CSSAVE:WORD,REG8:BYTE,REG16:BYTE,SIZ8:BYTE
	EXTRN	SYNERR_PTR:BYTE,OPTAB:BYTE,MAXOP:ABS

CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE

	EXTRN	HINUM:WORD,LOWNUM:WORD,ASSEM_CNT:BYTE
	EXTRN	ASSEM1:BYTE,ASSEM2:BYTE,ASSEM3:BYTE,ASSEM4:BYTE,ASSEM5:BYTE
	EXTRN	ASSEM6:BYTE,OPBUF:BYTE,OPCODE:WORD,REGMEM:BYTE,INDEX:WORD
	EXTRN	ASMADD:BYTE,ASMSP:WORD,MOVFLG:BYTE,SEGFLG:BYTE,TSTFLG:BYTE
	EXTRN	NUMFLG:BYTE,DIRFLG:BYTE,BYTEBUF:BYTE,F8087:BYTE,DIFLG:BYTE
	EXTRN	SIFLG:BYTE,BXFLG:BYTE,BPFLG:BYTE,NEGFLG:BYTE,MEMFLG:BYTE
	EXTRN	REGFLG:BYTE,AWORD:BYTE,MIDFLD:BYTE,MODE:BYTE
	EXTRN	ARG_BUF:BYTE,HEX_PTR:BYTE

DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG

	PUBLIC	ASSEM
	PUBLIC	DB_OPER,DW_OPER,ASSEMLOOP,GROUP2,AA_OPER,DCINC_OPER
	PUBLIC	GROUP1,ESC_OPER,FGROUPP,FGROUPX,FDE_OPER,FGROUPZ
	PUBLIC	FD9_OPER,FGROUP,FDB_OPER,FGROUPB,FGROUP3,FGROUP3W
	PUBLIC	FGROUPDS,INT_OPER,IN_OPER,DISP8_OPER,JMP_OPER,NO_OPER
	PUBLIC	OUT_OPER,L_OPER,MOV_OPER,POP_OPER,PUSH_OPER,ROTOP
	PUBLIC	TST_OPER,EX_OPER,GET_DATA16,CALL_OPER, DOORG

	EXTRN	INBUF:NEAR,SCANB:NEAR,SCANP:NEAR,GETHX:NEAR,GET_ADDRESS:NEAR
	EXTRN	DEFAULT:NEAR,OUTDI:NEAR,BLANK:NEAR,TAB:NEAR
	EXTRN	STD_PRINTF:NEAR,PRINTF_CRLF:NEAR

;	Line by line assembler

MASKMOD EQU	11000000B
SHMOD	EQU	6
MASKREG EQU	00111000B
SHREG	EQU	3
MASKRM	EQU	00000111B
SHRM	EQU	0

ASSEM:
	MOV	BP,[CSSAVE]		; Default code segment
	MOV	DI,OFFSET DG:ASMADD	; Default address
	CALL	DEFAULT
	MOV	WORD PTR [ASMADD],DX	; Displacement of disassembly
	MOV	WORD PTR [ASMADD+2],AX	; Segment
	MOV	[ASMSP],SP		; Save sp in case of error

ASSEMLOOP:
	MOV	SP,[ASMSP]		; Restore sp in case of error
	LES	DI,DWORD PTR ASMADD	; GET PC
	CALL	OUTDI			; OUTPUT ADDRESS
	PUSH	CS
	POP	ES
	PUSH	DI
	MOV	DI,OFFSET DG:ARG_BUF
; No spacing is needed.  The format string already has one.
;	CALL	BLANK			; SKIP A SPACE
	XOR	AL,AL
	STOSB
	MOV	DX,OFFSET DG:HEX_PTR
	CALL	STD_PRINTF
	POP	DI
	CALL	INBUF			; GET A BUFFER
	CALL	SCANB
	JNZ	OPLOOK
	RET				; if empty just return

;  At this point ds:si points to the opcode mnemonic...
OPLOOK:
	XOR	CX,CX			; OP-CODE COUNT = 0
	MOV	DI,OFFSET DG:DBMN
OPSCAN:
	XOR	BX,BX
OPLOOP:
	MOV	AL,[DI+BX]
	CMP	AL,[SI+BX]
	JZ	OPMATCH
	INC	CX			; INCREMENT OP-CODE COUNT
	CMP	CX,MAXOP		; CHECK FOR END OF LIST
	JB	OP1
	JMP	ASMERR
OP1:
	INC	DI			; SCAN FOR NEXT OP-CODE...
	CMP	BYTE PTR [DI-1],0
	JNZ	OP1
	JMP	OPSCAN

OPMATCH:
	INC	BX			; COMPARE NEXT CHAR
	CMP	BYTE PTR [DI+BX],0	; ARE WE DONE?
	JNZ	OPLOOP			; ..IF NOT KEEP COMPARING
	XCHG	BX,CX
	MOV	AX,BX
	SHL	AX,1
	ADD	AX,BX
	ADD	AX,OFFSET DG:OPTAB
	MOV	BX,AX

; CX = COUNT OF CHARS IN OPCODE
; BX = POINTER INTO OPCODE TABLE

	XOR	AX,AX
	MOV	BYTE PTR [AWORD],AL
	MOV	WORD PTR [MOVFLG],AX	; MOVFLG + TSTFLG
	MOV	BYTE PTR [SEGFLG],AL	; ZERO SEGMENT REGISTER FLAG
	MOV	AH,00001010B		; SET UP FOR AA_OPER
	MOV	AL,BYTE PTR [BX]
	MOV	WORD PTR [ASSEM1],AX
	MOV	BYTE PTR [ASSEM_CNT],1

	ADD	SI,CX			; SI POINTS TO OPERAND
	JMP	WORD PTR [BX+1]

; 8087 INSTRUCTIONS WITH NO OPERANDS

FDE_OPER:
	MOV	AH,0DEH
	JMP	SHORT FDX_OPER
FDB_OPER:
	MOV	AH,0DBH
	JMP	SHORT FDX_OPER
FD9_OPER:
	MOV	AH,0D9H
FDX_OPER:
	XCHG	AL,AH
	MOV	WORD PTR [ASSEM1],AX

;  AAD AND AAM INSTRUCIONS

AA_OPER:
	INC	BYTE PTR [ASSEM_CNT]

;  INSTRUCTIONS WITH NO OPERANDS

NO_OPER:
	CALL	STUFF_BYTES
	CALL	SCANP
	PUSH	CS
	POP	ES
	JNZ	OPLOOK
	JMP	ASSEMLOOP

;  PUSH INSTRUCTION

PUSH_OPER:
	MOV	AH,11111111B
	JMP	SHORT POP1

;  POP INSTRUCTION

POP_OPER:
	MOV	AH,10001111B
POP1:
	MOV	[ASSEM1],AH
	MOV	[MIDFLD],AL
	INC	BYTE PTR [MOVFLG]	; ALLOW SEGMENT REGISTERS
	MOV	BYTE PTR [AWORD],2	; MUST BE 16 BITS
	CALL	GETREGMEM
	CALL	BUILDIT
	MOV	AL,[DI+2]
	CMP	AL,11000000B
	JB	DATRET
	MOV	BYTE PTR [DI],1
	CMP	BYTE PTR [MOVFLG],2
	JNZ	POP2
	AND	AL,00011000B
	OR	AL,00000110B
	CMP	BYTE PTR [MIDFLD],0
	JNZ	POP3
	OR	AL,00000001B
	JMP	SHORT POP3

POP2:
	AND	AL,MASKRM
	OR	AL,01010000B
	CMP	BYTE PTR [MIDFLD],0
	JNZ	POP3
	OR	AL,01011000B
POP3:
	MOV	BYTE PTR [DI+1],AL
	JMP	ASSEM_EXIT

; RET AND RETF INSTRUCTIONS

GET_DATA16:
	CALL	SCANB
	MOV	CX,4
	CALL	GETHX
	JC	DATRET
	DEC	BYTE PTR [ASSEM1]	; CHANGE OP-CODE
	ADD	BYTE PTR [ASSEM_CNT],2	; UPDATE LENGTH
	MOV	WORD PTR [ASSEM2],DX	; SAVE OFFSET
DATRET:
	JMP	ASSEM_EXIT


;  INT INSTRUCTION

INT_OPER:
	CALL	SCANB
	MOV	CX,2
	CALL	GETHX
	JC	ERRV1
	MOV	AL,DL
	CMP	AL,3
	JZ	DATRET
	INC	BYTE PTR [ASSEM1]
	JMP	DISPX

;  IN INSTRUCTION

IN_OPER:
	CALL	SCANB
	LODSW
	CMP	AX,'A'+4C00H            ; "AL"
	JZ	IN_1
	CMP	AX,'A'+5800H            ; "AX"
	JZ	IN_0
ERRV1:
	JMP	ASMERR
IN_0:
	INC	BYTE PTR [ASSEM1]
IN_1:
	CALL	SCANP
	CMP	WORD PTR [SI],'D'+5800H ; "DX"
	JZ	DATRET
	MOV	CX,2
	CALL	GETHX
	JC	ERRV1
	AND	BYTE PTR [ASSEM1],11110111B
	MOV	AL,DL
	JMP	DISPX

;  OUT INSTRUCTION

OUT_OPER:
	CALL	SCANB
	CMP	WORD PTR [SI],'D'+5800H ; "DX"
	JNZ	OUT_0
	INC	SI
	INC	SI
	JMP	SHORT OUT_1
OUT_0:
	AND	BYTE PTR [ASSEM1],11110111B
	MOV	CX,2
	CALL	GETHX
	JC	ERRV1
	INC	BYTE PTR [ASSEM_CNT]
	MOV	BYTE PTR [ASSEM2],DL
OUT_1:
	CALL	SCANP
	LODSW
	CMP	AX,'A'+4C00H            ; "AL"
	JZ	DATRET
	CMP	AX,'A'+5800H            ; "AX"
	JNZ	ERRV1
	INC	BYTE PTR [ASSEM1]
	JMP	DATRET


;  JUMP INSTRUCTION

JMP_OPER:
	INC	BYTE PTR [TSTFLG]

;  CALL INSTRUCTION

CALL_OPER:
	MOV	BYTE PTR [ASSEM1],11111111B
	MOV	BYTE PTR [MIDFLD],AL
	CALL	GETREGMEM
	CALL	BUILD3
	CMP	BYTE PTR [MEMFLG],0
	JNZ	CALLJ1
	CMP	BYTE PTR [REGMEM],-1
	JZ	CALLJ2

;  INDIRECT JUMPS OR CALLS

CALLJ1:
	CMP	BYTE PTR [AWORD],1
ERRZ4:
	JZ	ERRV1
	CMP	BYTE PTR [AWORD],4
	JNZ	ASMEX4
	OR	BYTE PTR [DI+2],1000B
	JMP	SHORT ASMEX4

;   DIRECT JUMPS OR CALLS

CALLJ2:
	MOV	AX,[LOWNUM]
	MOV	DX,[HINUM]
	MOV	BL,[AWORD]
	CMP	BYTE PTR [NUMFLG],0
	JZ	ERRZ4

;  BL = NUMBER OF BYTES IN JUMP
;  DX = OFFSET
;  AX = SEGMENT

CALLJ3:
	MOV	BYTE PTR [DI],5
	MOV	[DI+2],AX
	MOV	[DI+4],DX

	MOV	AL,10011010B		; SET UP INTER SEGMENT CALL
	CMP	BYTE PTR [TSTFLG],0
	JZ	CALLJ5
	MOV	AL,11101010B		; FIX UP FOR JUMP
CALLJ5:
	MOV	BYTE PTR [DI+1],AL
	CMP	BL,4			; FAR SPECIFIED?
	JZ	ASMEX4
	OR	BL,BL
	JNZ	CALLJ6
	CMP	DX,WORD PTR [ASMADD+2]	; DIFFERENT SEGMENT?
	JNZ	ASMEX4

CALLJ6:
	MOV	BYTE PTR [DI],3
	MOV	AL,11101000B		; SET UP FOR INTRASEGMENT
	OR	AL,[TSTFLG]
	MOV	BYTE PTR [DI+1],AL

	MOV	AX,[LOWNUM]
	SUB	AX,WORD PTR [ASMADD]
	SUB	AX,3
	MOV	[DI+2],AX
	CMP	BYTE PTR [TSTFLG],0
	JZ	ASMEX4
	CMP	BL,2
	JZ	ASMEX4

	INC	AX
	MOV	CX,AX
	CBW
	CMP	AX,CX
	JNZ	ASMEX3
	MOV	BYTE PTR [DI+1],11101011B
	MOV	[DI+2],AX
	DEC	BYTE PTR [DI]
ASMEX4:
	JMP	ASSEM_EXIT

;  CONDITIONAL JUMPS AND LOOP INSTRUCTIONS

DISP8_OPER:
	MOV	BP,WORD PTR [ASMADD+2]	; GET DEFAULT DISPLACEMENT
	CALL	GET_ADDRESS
	SUB	DX,WORD PTR [ASMADD]
	DEC	DX
	DEC	DX
	CALL	CHKSIZ
	CMP	CL,1
	JNZ	ERRV2
DISPX:
	INC	[ASSEM_CNT]
	MOV	BYTE PTR [ASSEM2],AL
ASMEX3:
	JMP	ASSEM_EXIT

;  LDS, LES, AND LEA INSTRUCTIONS

L_OPER:
	CALL	SCANB
	LODSW
	MOV	CX,8
	MOV	DI,OFFSET DG:REG16
	CALL	CHKREG
	JZ	ERRV2			; CX = 0 MEANS NO REGISTER
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
	MOV	BYTE PTR [MIDFLD],AL
	CALL	SCANP
	CALL	GETREGMEM
	CMP	BYTE PTR [AWORD],0
	JNZ	ERRV2
	CALL	BUILD2
	JMP	SHORT ASEXV

;  DEC AND INC INSTRUCTIONS

DCINC_OPER:
	MOV	BYTE PTR [ASSEM1],11111110B
	MOV	BYTE PTR [MIDFLD],AL
	CALL	GETREGMEM
	CALL	BUILDIT
	TEST	BYTE PTR [DI+1],1
	JZ	ASEXV
	MOV	AL,[DI+2]
	CMP	AL,MASKMOD
	JB	ASEXV
	AND	AL,1111B
	OR	AL,01000000B
	MOV	[DI+1],AL
	DEC	BYTE PTR [DI]
ASEXV:
	JMP	ASSEM_EXIT

ERRV2:
	JMP	ASMERR

; ESC INSTRUCTION

ESC_OPER:
	INC	BYTE PTR [AWORD]
	CALL	SCANB
	MOV	CX,2
	CALL	GETHX
	CMP	DX,64
	JAE	ERRV2
	CALL	SCANP
	MOV	AX,DX
	MOV	CL,3
	SHR	DX,CL
	OR	[ASSEM1],DL
	AND	AL,111B
	SHL	AL,CL
	JMP	GROUPE

; 8087 ARITHMETIC INSTUCTIONS

;  OPERANDS THAT ALLOW THE REVERSE BIT

FGROUPDS:
	CALL	SETMID
	CALL	GETREGMEM2
	CALL	BUILD3
	CMP	BYTE PTR [MODE],11000000B
	JNZ	FGROUP1
	MOV	AL,[DIRFLG]
	OR	AL,AL
	JZ	FEXIT
	OR	[DI+1],AL		; IF D=1...
	XOR	BYTE PTR [DI+2],00001000B ; ...REVERSE THE SENSE OF R
	JMP	SHORT FEXIT

;  HERE WHEN INSTRUCTION COULD HAVE MEMORY OR REGISTER OPERAND

FGROUPX:
	CALL	SETMID			; THIS ENTRY POINT FOR 1 MEM OPER
	MOV	BYTE PTR [DIRFLG],0
	JMP	SHORT FGRP2
FGROUP:
	CALL	SETMID
FGRP2:
	CALL	GETREGMEM2
	CALL	BUILD3
	CMP	BYTE PTR [MODE],11000000B
	JNZ	FGROUP1
	MOV	AL,[DIRFLG]
	OR	[DI+1],AL
	JMP	SHORT FEXIT
FGROUP1:
	CALL	SETMF
FEXIT:
	JMP	ASSEM_EXIT

; THESE 8087 INSTRUCTIONS REQUIRE A MEMORY OPERAND
FGROUPB:
	MOV	AH,5			; MUST BE TBYTE
	JMP	SHORT FGROUP3E
FGROUP3W:
	MOV	AH,2			; MUST BE WORD
	JMP	SHORT FGROUP3E
FGROUP3:
	MOV	AH,-1			; SIZE CANNOT BE SPECIFIED
FGROUP3E:
	MOV	[AWORD],AH
	CALL	SETMID
	CALL	GETREGMEM
	CMP	BYTE PTR [MODE],11000000B
	JZ	FGRPERR
FGRP:
	CALL	BUILD3
	JMP	FEXIT

; THESE 8087 INSTRUCTIONS REQUIRE A REGISTER OPERAND
FGROUPP:				; 8087 POP OPERANDS
	MOV	BYTE PTR [AWORD],-1
	CALL	SETMID
	CALL	GETREGMEM2
	CMP	BYTE PTR [DIRFLG],0
	JNZ	FGRP
FGRPERR:
	JMP	ASMERR

FGROUPZ:				; ENTRY POINT WHERE ARG MUST BE MEM
	CALL	SETMID
	MOV	BYTE PTR [DIRFLG],0
	CALL	GETREGMEM
	CMP	BYTE PTR [MODE],11000000B
	JZ	FGRPERR
	CALL	BUILD3
	CALL	SETMF
	JMP	FEXIT

; NOT, NEG, MUL, IMUL, DIV, AND IDIV INSTRUCTIONS

GROUP1:
	MOV	[ASSEM1],11110110B
GROUPE:
	MOV	BYTE PTR [MIDFLD],AL
	CALL	GETREGMEM
	CALL	BUILDIT
	JMP	FEXIT

;  SHIFT AND ROTATE INSTRUCTIONS

ROTOP:
	MOV	[ASSEM1],11010000B
	MOV	BYTE PTR [MIDFLD],AL
	CALL	GETREGMEM
	CALL	BUILDIT
	CALL	SCANP
	CMP	BYTE PTR [SI],'1'
	JZ	ASMEXV1
	CMP	WORD PTR [SI],"LC"      ; CL
	JZ	ROTOP1
ROTERR:
	JMP	ASMERR
ROTOP1:
	OR	BYTE PTR [ASSEM1],10B
ASMEXV1:
	JMP	ASSEM_EXIT

;  XCHG INSTRUCTION

EX_OPER:
	INC	BYTE PTR [TSTFLG]

;   TEST INSTRUCTION

TST_OPER:
	INC	BYTE PTR [TSTFLG]
	JMP	SHORT MOVOP

;    MOV INSTRUCTION

MOV_OPER:
	INC	BYTE PTR [MOVFLG]
MOVOP:
	XOR	AX,AX
	JMP	SHORT GROUPM

;   ADD, ADC, SUB, SBB, CMP, AND, OR, XOR instructions

GROUP2:
	MOV	BYTE PTR [ASSEM1],10000000B
GROUPM:
	MOV	BYTE PTR [MIDFLD],AL

	PUSH	AX
	CALL	GETREGMEM
	CALL	BUILD2
	CALL	SCANP			; POINT TO NEXT OPERAND
	MOV	AL,BYTE PTR [ASSEM_CNT]
	PUSH	AX
	CALL	GETREGMEM
	POP	AX
	MOV	BYTE PTR [DI],AL
	POP	AX
	MOV	BL,BYTE PTR [AWORD]
	OR	BL,BL
	JZ	ERRV5
	DEC	BL
	AND	BL,1
	OR	BYTE PTR [DI+1],BL

	CMP	BYTE PTR [MEMFLG],0
	JNZ	G21V
	CMP	BYTE PTR [NUMFLG],0	; TEST FOR IMMEDIATE DATA
	JZ	G21V
	CMP	BYTE PTR [SEGFLG],0
	JNZ	ERRV5
	CMP	BYTE PTR [TSTFLG],2	; XCHG?
	JNZ	IMMED1
ERRV5:
	JMP	ASMERR
G21V:
	JMP	GRP21

;  SECOND OPERAND WAS IMMEDIATE

IMMED1:
	MOV	AL,BYTE PTR [DI+2]
	CMP	BYTE PTR [MOVFLG],0
	JZ	NOTMOV1
	AND	AL,11000000B
	CMP	AL,11000000B
	JNZ	GRP23			; not to a register
					; MOVE IMMEDIATE TO REGISTER
	MOV	AL,BYTE PTR [DI+1]
	AND	AL,1			; SET SIZE
	PUSHF
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
	OR	AL,BYTE PTR [DI+2]	; SET REGISTER
	AND	AL,00001111B
	OR	AL,10110000B
	MOV	BYTE PTR [DI+1],AL
	MOV	AX,WORD PTR [LOWNUM]
	MOV	WORD PTR [DI+2],AX
	POPF
	JZ	EXVEC
	INC	BYTE PTR [DI]
EXVEC:
	JMP	GRPEX

NOTMOV1:
	AND	AL,11000111B
	CMP	AL,11000000B
	JZ	IMMACC			; IMMEDIATE TO ACC

	CMP	BYTE PTR [TSTFLG],0
	JNZ	GRP23
	CMP	BYTE PTR [MIDFLD],1*8	; OR?
	JZ	GRP23
	CMP	BYTE PTR [MIDFLD],4*8	; AND?
	JZ	GRP23
	CMP	BYTE PTR [MIDFLD],6*8	; XOR?
	JZ	GRP23
	TEST	BYTE PTR [DI+1],1	; TEST IF BYTE OPCODE
	JZ	GRP23

	MOV	AX,[LOWNUM]
	MOV	BX,AX
	CBW
	CMP	AX,BX
	JNZ	GRP23			; SMALL ENOUGH?

	MOV	BL,[DI]
	DEC	BYTE PTR [DI]
	OR	BYTE PTR [DI+1],10B
	JMP	SHORT GRP23X

IMMACC:
	MOV	AL,BYTE PTR [DI+1]
	AND	AL,1
	CMP	BYTE PTR [TSTFLG],0
	JZ	NOTTST
	OR	AL,10101000B
	JMP	SHORT TEST1
NOTTST:
	OR	AL,BYTE PTR [MIDFLD]
	OR	AL,100B
TEST1:
	MOV	BYTE PTR [DI+1],AL
	DEC	BYTE PTR [DI]

GRP23:
	MOV	BL,BYTE PTR [DI]
GRP23X:
	XOR	BH,BH
	ADD	BX,DI
	INC	BX
	MOV	AX,WORD PTR [LOWNUM]
	MOV	WORD PTR [BX],AX
	INC	BYTE PTR [DI]
	TEST	BYTE PTR [DI+1],1
	JZ	GRPEX1
	INC	BYTE PTR [DI]
GRPEX1:
	JMP	GRPEX

;	SECOND OPERAND WAS MEMORY OR REGISTER

GRP21:
	CMP	BYTE PTR [SEGFLG],0
	JZ	GRP28			; FIRST OPERAND WAS A SEGMENT REG
	MOV	AL,BYTE PTR [REGMEM]
	TEST	AL,10000B
	JZ	NOTSEG1
ERRV3:
	JMP	ASMERR
NOTSEG1:
	AND	AL,111B
	OR	BYTE PTR [DI+2],AL
	AND	BYTE PTR [DI+1],11111110B
	CMP	BYTE PTR [MEMFLG],0
	JNZ	G22V
	JMP	GRPEX

GRP28:
	AND	BYTE PTR [DI+2],11000111B
	MOV	AL,BYTE PTR [DI+1]	; GET FIRST OPCODE
	AND	AL,1B
	CMP	BYTE PTR [MOVFLG],0
	JZ	NOTMOV2
	OR	AL,10001000B
	JMP	SHORT MOV1
NOTMOV2:
	CMP	BYTE PTR [TSTFLG],0
	JZ	NOTTST2
	OR	AL,10000100B
	CMP	BYTE PTR [TSTFLG],2
	JNZ	NOTTST2
	OR	AL,10B
NOTTST2:
	OR	AL,BYTE PTR [MIDFLD]	; MIDFLD IS ZERO FOR TST
MOV1:
	MOV	BYTE PTR [DI+1],AL
	CMP	BYTE PTR [MEMFLG],0
G22V:
	JZ	NotGRP22
	JMP	GRP22
NotGRP22:

;	SECOND OPERAND WAS A REGISTER

	MOV	AL,BYTE PTR [REGMEM]
	TEST	AL,10000B		; SEGMENT REGISTER?
	JZ	NOTSEG
	CMP	BYTE PTR [MOVFLG],0
	JZ	ERRV3
	MOV	BYTE PTR [DI+1],10001100B

NOTSEG:
	AND	AL,111B
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
	OR	BYTE PTR [DI+2],AL
; ARR 2.4
; In the case of the XCHG reg,reg and TEST reg,reg we have just built the
; instruction backwards.  This is because these two instructions do not have
; the D bit.  We need to switch R/S and REG
;
; Good comment Aaron, except that we do NOT switch if a memory operand was
; present for precisely the reason that the D bit is not present
;
	CMP	BYTE PTR [TSTFLG],0
	JZ	NOSWITCH		; Not XCHG or TEST
;
; See if there is a memory operand specified.  If the MOD field is 11, then
; we do perform the exchange.
;
	MOV	AH,[DI+2]
	AND	AH,MASKMOD
	CMP	AH,MASKMOD
	JNZ	NOSWITCH
	MOV	AH,BYTE PTR [DI+2]
	AND	AH,MASKRM
	SHL	AH,1			; Low three bits to middle three
	SHL	AH,1
	SHL	AH,1
	MOV	AL,BYTE PTR [DI+2]
	AND	AL,MASKREG
	SHR	AL,1			; Middle three to low three
	SHR	AL,1
	SHR	AL,1
	OR	AL,AH			; Re combine
	AND	BYTE PTR [DI+2],MASKMOD ; Zap original
	OR	BYTE PTR [DI+2],AL	; New low 6 bits
NOSWITCH:


; SPECIAL FORM OF THE EXCHANGE COMMAND

	CMP	BYTE PTR [TSTFLG],2
	JNZ	GRPEX
	TEST	BYTE PTR [DI+1],1
	JZ	GRPEX
	PUSH	AX
	MOV	AL,BYTE PTR [DI+2]
	AND	AL,MASKMOD
	CMP	AL,MASKMOD		; MUST BE REGISTER TO REGISTER
	POP	AX
	JB	GRPEX
	OR	AL,AL
	JZ	SPECX
	MOV	AL,[DI+2]
	AND	AL,MASKRM
	JNZ	GRPEX
	MOV	CL,3
	SHR	BYTE PTR [DI+2],CL
SPECX:
	MOV	AL,[DI+2]
	AND	AL,MASKRM
	OR	AL,10010000B
	MOV	BYTE PTR [DI+1],AL
	DEC	BYTE PTR [DI]
	JMP	SHORT GRPEX

;  SECOND OPERAND WAS A MEMORY REFERENCE

GRP22:
	CMP	BYTE PTR [TSTFLG],0
	JNZ	TST2
	OR	BYTE PTR [DI+1],10B
TST2:
	MOV	AL,BYTE PTR [DI+2]
	CMP	AL,MASKMOD		; MUST BE A REGISTER
	JB	ASMERR
	CMP	BYTE PTR [SEGFLG],0
	JZ	GRP223
	AND	AL,00011000B
	JMP	SHORT GRP222
GRP223:
	AND	AL,MASKRM
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
GRP222:
	OR	AL,BYTE PTR [MODE]
	OR	AL,BYTE PTR [REGMEM]
	MOV	BYTE PTR [DI+2],AL
	MOV	AX,WORD PTR [LOWNUM]
	MOV	WORD PTR [DI+3],AX
GRPSIZ:
	MOV	BYTE PTR [DI],2
	MOV	AL,BYTE PTR [DI+2]
	AND	AL,11000111B
	CMP	AL,00000110B
	JZ	GRP24
	AND	AL,MASKMOD
	CMP	AL,01000000B
	JZ	GRP25
	CMP	AL,10000000B
	JNZ	GRPEX
GRP24:
	INC	BYTE PTR [DI]
GRP25:
	INC	BYTE PTR [DI]

GRPEX:
	CMP	BYTE PTR [MOVFLG],0
	JZ	ASSEM_EXIT

;	TEST FOR SPECIAL FORM OF MOV AX,[MEM] OR MOV [MEM],AX

	MOV	AL,[DI+1]		; GET OP-CODE
	AND	AL,11111100B
	CMP	AL,10001000B
	JNZ	ASSEM_EXIT
	CMP	BYTE PTR [DI+2],00000110B ; MEM TO AX OR AX TO MEM
	JNZ	ASSEM_EXIT
	MOV	AL,BYTE PTR [DI+1]
	AND	AL,11B
	XOR	AL,10B
	OR	AL,10100000B
	MOV	BYTE PTR [DI+1],AL
	DEC	BYTE PTR [DI]
	MOV	AX,[DI+3]
	MOV	WORD PTR [DI+2],AX

ASSEM_EXIT:
	CALL	STUFF_BYTES
	JMP	ASSEMLOOP

; Assem error. SI points to character in the input buffer
; which caused error. By subtracting from start of buffer,
; we will know how far to tab over to appear directly below
; it on the terminal. Then print "^ Error".

ASMERR:
	SUB	SI,OFFSET DG:(BYTEBUF-10) ; How many char processed so far?
	MOV	CX,SI			; Parameter for TAB in CX
	MOV	DI,OFFSET DG:ARG_BUF
	CALL	TAB			; Directly below bad char
	MOV	BYTE PTR [DI],0
	MOV	DX,OFFSET DG:SYNERR_PTR ; Error message
	CALL	PRINTF_CRLF
	JMP	ASSEMLOOP
;
;  assemble the different parts into an instruction
;
BUILDIT:
	MOV	AL,BYTE PTR [AWORD]
	OR	AL,AL
	JNZ	BUILD1
BLDERR:
	JMP	ASMERR

BUILD1:
	DEC	AL
	OR	BYTE PTR [DI+1],AL	; SET THE SIZE

BUILD2:
	CMP	BYTE PTR [NUMFLG],0	; TEST FOR IMMEDIATE DATA
	JZ	BUILD3
	CMP	BYTE PTR [MEMFLG],0
	JZ	BLDERR

BUILD3:
	MOV	AL,BYTE PTR [REGMEM]
	CMP	AL,-1
	JZ	BLD1
	TEST	AL,10000B		; TEST IF SEGMENT REGISTER
	JZ	BLD1
	CMP	BYTE PTR [MOVFLG],0
	JZ	BLDERR
	MOV	WORD PTR [DI+1],10001110B
	INC	BYTE PTR [MOVFLG]
	INC	BYTE PTR [SEGFLG]
	AND	AL,00000011B
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
	OR	AL,MASKMOD
	MOV	BYTE PTR [DI+2],AL
	RET

BLD1:
	AND	AL,00000111B
BLD4:
	OR	AL,BYTE PTR [MODE]
	OR	AL,BYTE PTR [MIDFLD]
	MOV	BYTE PTR [DI+2],AL
	MOV	AX,WORD PTR [LOWNUM]
	MOV	WORD PTR [DI+3],AX
	RET

GETREGMEM:
	MOV	BYTE PTR [F8087],0
GETREGMEM2:
	CALL	SCANP
	XOR	AX,AX
	MOV	WORD PTR [LOWNUM],AX	; OFFSET
	MOV	WORD PTR [DIFLG],AX	; DIFLG+SIFLG
	MOV	WORD PTR [BXFLG],AX	; BXFLG+BPFLG
	MOV	WORD PTR [NEGFLG],AX	; NEGFLG+NUMFLG
	MOV	WORD PTR [MEMFLG],AX	; MEMFLG+REGFLG
	DEC	AL
	CMP	BYTE PTR [F8087],0
	JZ	PUTREG
	MOV	AL,1			; DEFAULT 8087 REG IS 1
PUTREG:
	MOV	BYTE PTR [REGMEM],AL

GETLOOP:
	MOV	BYTE PTR [NEGFLG],0
GETLOOP1:
	MOV	AX,WORD PTR [SI]
	CMP	AL,','
	JZ	GOMODE
	CMP	AL,13
	JZ	GOMODE
	CMP	AL,';'
	JZ	GOMODE
	CMP	AL,9
	JZ	GETTB
	CMP	AL,' '
	JNZ	GOGET
GETTB:
	INC	SI
	JMP	GETLOOP1
GOGET:
	JMP	GETINFO

;  DETERMINE THE MODE BITS

GOMODE:
	MOV	DI,OFFSET DG:ASSEM_CNT
	MOV	BYTE PTR [MODE],11000000B
	MOV	BYTE PTR [ASSEM_CNT],2
	CMP	BYTE PTR [MEMFLG],0
	JNZ	GOMODE1
	MOV	AL,[NUMFLG]
	OR	AL,[REGFLG]
	JNZ	MORET
	OR	AL,[F8087]
	JZ	ERRET
	MOV	AL,[DI+1]
	OR	AL,[DIRFLG]
	CMP	AL,0DCH 		; ARITHMETIC?
	JNZ	MORET
	MOV	BYTE PTR [DI+1],0DEH	; ADD POP TO NULL ARG 8087
MORET:
	RET
ERRET:
	JMP	ASMERR

GOMODE1:
	MOV	BYTE PTR [MODE],0
	CMP	BYTE PTR [NUMFLG],0
	JZ	GOREGMEM

	MOV	BYTE PTR [DI],4
	MOV	AX,WORD PTR [DIFLG]
	OR	AX,WORD PTR [BXFLG]
	JNZ	GOMODE2
	MOV	BYTE PTR [REGMEM],00000110B
	RET

GOMODE2:
	MOV	BYTE PTR [MODE],10000000B
	CALL	CHKSIZ1
	CMP	CL,2
	JZ	GOREGMEM
	DEC	BYTE PTR [DI]
	MOV	BYTE PTR [MODE],01000000B

;  DETERMINE THE REG-MEM BITS

GOREGMEM:
	MOV	BX,WORD PTR [BXFLG]
	MOV	CX,WORD PTR [DIFLG]
	XOR	DX,DX
GOREG0:
	MOV	AL,BL			; BX
	ADD	AL,CH			; SI
	CMP	AL,2
	JZ	GOGO
	INC	DL
	MOV	AL,BL
	ADD	AL,CL
	CMP	AL,2
	JZ	GOGO
	INC	DL
	MOV	AL,BH
	ADD	AL,CH
	CMP	AL,2
	JZ	GOGO
	INC	DL
	MOV	AL,BH
	ADD	AL,CL
	CMP	AL,2
	JZ	GOGO
	INC	DL
	OR	CH,CH
	JNZ	GOGO
	INC	DL
	OR	CL,CL
	JNZ	GOGO
	INC	DL			; BP+DISP
	OR	BH,BH
	JZ	GOREG1
	CMP	BYTE PTR [MODE],0
	JNZ	GOGO
	MOV	BYTE PTR [MODE],01000000B
	INC	BYTE PTR [DI]
	DEC	DL
GOREG1:
	INC	DL			; BX+DISP
GOGO:
	MOV	BYTE PTR [REGMEM],DL
	RET

GETINFO:
	CMP	AX,'EN'                 ; NEAR
	JNZ	GETREG3
GETREG0:
	MOV	DL,2
GETRG01:
	CALL	SETSIZ1
GETREG1:
	CALL	SCANS
	MOV	AX,WORD PTR [SI]
	CMP	AX,"TP"                 ; PTR
	JZ	GETREG1
	JMP	GETLOOP

GETREG3:
	MOV	CX,5
	MOV	DI,OFFSET DG:SIZ8
	CALL	CHKREG			; LOOK FOR BYTE, WORD, DWORD, ETC.
	JZ	GETREG41
	INC	AL
	MOV	DL,AL
	JMP	GETRG01

GETREG41:
	MOV	AX,[SI]
	CMP	BYTE PTR [F8087],0
	JZ	GETREG5
	CMP	AX,"TS"                 ; 8087 STACK OPERAND
	JNZ	GETREG5
	CMP	BYTE PTR [SI+2],','
	JNZ	GETREG5
	MOV	BYTE PTR [DIRFLG],0
	ADD	SI,3
	JMP	GETLOOP

GETREG5:
	CMP	AX,"HS"                 ; SHORT
	JZ	GETREG1

	CMP	AX,"AF"                 ; FAR
	JNZ	GETRG51
	CMP	BYTE PTR [SI+2],'R'
	JNZ	GETRG51
	ADD	SI,3
	MOV	DL,4
	JMP	GETRG01

GETRG51:
	CMP	AL,'['
	JNZ	GETREG7
GETREG6:
	INC	BYTE PTR [MEMFLG]
GETREGADD:
	INC	SI
	JMP	GETLOOP

GETREG7:
	CMP	AL,']'
	JZ	GETREG6
	CMP	AL,'.'
	JZ	GETREG6
	CMP	AL,'+'
	JZ	GETREGAdd
	CMP	AL,'-'
	JNZ	GETREG8
	INC	BYTE PTR [NEGFLG]
	INC	SI
	JMP	GETLOOP1

GETREG8:				; LOOK FOR A REGISTER
	CMP	BYTE PTR [F8087],0
	JZ	GETREGREG
	CMP	AX,"TS"
	JNZ	GETREGREG
	CMP	BYTE PTR [SI+2],'('
	JNZ	GETREGREG
	CMP	BYTE PTR [SI+4],')'
	JNZ	ASMPOP
	MOV	AL,[SI+3]
	SUB	AL,'0'
	JB	ASMPOP
	CMP	AL,7
	JA	ASMPOP
	MOV	[REGMEM],AL
	INC	BYTE PTR [REGFLG]
	ADD	SI,5
	CMP	WORD PTR [SI],"S,"
	JNZ	ZLOOP
	CMP	BYTE PTR [SI+2],'T'
	JNZ	ZLOOP
	ADD	SI,3
ZLOOP:
	JMP	GETLOOP

GETREGREG:
	MOV	CX,20
	MOV	DI,OFFSET DG:REG8
	CALL	CHKREG
	JZ	GETREG12		; CX = 0 MEANS NO REGISTER
	MOV	BYTE PTR [REGMEM],AL
	INC	BYTE PTR [REGFLG]	; TELL EVERYONE WE FOUND A REG
	CMP	BYTE PTR [MEMFLG],0
	JNZ	NOSIZE
	CALL	SETSIZ
INCSI2:
	ADD	SI,2
	JMP	GETLOOP

NOSIZE:
	CMP	AL,11			; BX REGISTER?
	JNZ	GETREG9
	CMP	WORD PTR [BXFLG],0
	JZ	GETOK
ASMPOP:
	JMP	ASMERR

GETOK:
	INC	BYTE PTR [BXFLG]
	JMP	INCSI2
GETREG9:
	CMP	AL,13			; BP REGISTER?
	JNZ	GETREG10
	CMP	WORD PTR [BXFLG],0
	JNZ	ASMPOP
	INC	BYTE PTR [BPFLG]
	JMP	INCSI2
GETREG10:
	CMP	AL,14			; SI REGISTER?
	JNZ	GETREG11
	CMP	WORD PTR [DIFLG],0
	JNZ	ASMPOP
	INC	BYTE PTR [SIFLG]
	JMP	INCSI2
GETREG11:
	CMP	AL,15			; DI REGISTER?
	JNZ	ASMPOP			; *** error
	CMP	WORD PTR [DIFLG],0
	JNZ	ASMPOP
	INC	BYTE PTR [DIFLG]
	JMP	INCSI2

GETREG12:				; BETTER BE A NUMBER!
	MOV	BP,WORD PTR [ASMADD+2]
	CMP	BYTE PTR [MEMFLG],0
	JZ	GTRG121
GTRG119:
	MOV	CX,4
GTRG120:
	CALL	GETHX
	JMP	SHORT GTRG122
GTRG121:
	MOV	CX,2
	CMP	BYTE PTR [AWORD],1
	JZ	GTRG120
	CMP	BYTE PTR [AWORD],CL
	JZ	GTRG119
	CALL	GET_ADDRESS
GTRG122:
	JC	ASMPOP
	MOV	[HINUM],AX
	CMP	BYTE PTR [NEGFLG],0
	JZ	GETREG13
	NEG	DX
GETREG13:
	ADD	WORD PTR [LOWNUM],DX
	INC	BYTE PTR [NUMFLG]
GETLOOPV:
	JMP	GETLOOP

CHKREG:
	PUSH	CX
	INC	CX
	REPNZ	SCASW
	POP	AX
	SUB	AX,CX
	OR	CX,CX
	RET

STUFF_BYTES:
	PUSH	SI
	LES	DI,DWORD PTR ASMADD
	MOV	SI,OFFSET DG:ASSEM_CNT
	XOR	AX,AX
	LODSB
	MOV	CX,AX
	JCXZ	STUFFRET
	REP	MOVSB
	MOV	WORD PTR [ASMADD],DI
STUFFRET:
	POP	SI
	RET

SETSIZ:
	MOV	DL,1
	TEST	AL,11000B		; 16 BIT OR SEGMENT REGISTER?
	JZ	SETSIZ1
	INC	DL
SETSIZ1:
	CMP	BYTE PTR [AWORD],0
	JZ	SETSIZ2
	CMP	BYTE PTR [AWORD],DL
	JZ	SETSIZ2
SETERR:
	POP	DX
	JMP	ASMPOP
SETSIZ2:
	MOV	BYTE PTR [AWORD],DL
	RET

;  DETERMINE IF NUMBER IN AX:DX IS 8 BITS, 16 BITS, OR 32 BITS

CHKSIZ:
	MOV	CL,4
	CMP	AX,BP
	JNZ	RETCHK
CHKSIZ1:
	MOV	CL,2
	MOV	AX,DX
	CBW
	CMP	AX,DX
	JNZ	RETCHK
	DEC	CL
RETCHK:
	RET

;  get first character after first space

SCANS:
	CMP	BYTE PTR [SI],13
	JZ	RETCHK
	CMP	BYTE PTR [SI],'['
	JZ	RETCHK
	LODSB
	CMP	AL,' '
	JZ	SCANBV
	CMP	AL,9
	JNZ	SCANS
SCANBV:
	JMP	SCANB

; Set up for 8087 op-codes

SETMID:
	MOV	BYTE PTR [ASSEM1],0D8H
	MOV	AH,AL
	AND	AL,111B 		; SET MIDDLE BITS OF SECOND BYTE
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
	MOV	[MIDFLD],AL
	MOV	AL,AH			; SET LOWER BITS OF FIRST BYTE
	SHR	AL,1
	SHR	AL,1
	SHR	AL,1
	OR	[ASSEM1],AL
	MOV	BYTE PTR [F8087],1	; INDICATE 8087 OPERAND
	MOV	BYTE PTR [DIRFLG],100B
	RET

; Set MF bits for 8087 op-codes

SETMF:
	MOV	AL,[AWORD]
	TEST	BYTE PTR [DI+1],10B
	JNZ	SETMFI
	AND	BYTE PTR [DI+1],11111001B ; CLEAR MF BITS
	CMP	AL,3			; DWORD?
	JZ	SETMFRET
	CMP	AL,4			; QWORD?
	JZ	SETMFRET2
	TEST	BYTE PTR [DI+1],1
	JZ	SETMFERR
	CMP	AL,5			; TBYTE?
	JZ	SETMFRET3
	JMP	SHORT SETMFERR

SETMFI:
	CMP	AL,3			; DWORD?
	JZ	SETMFRET
	CMP	AL,2			; WORD?
	JZ	SETMFRET2
	TEST	BYTE PTR [DI+1],1
	JZ	SETMFERR
	CMP	AL,4			; QWORD?
	JNZ	SETMFERR
	OR	BYTE PTR [DI+1],111B
SETMFRET3:
	OR	BYTE PTR [DI+1],011B
	OR	BYTE PTR [DI+2],101000B
	JMP	SHORT SETMFRET
SETMFRET2:
	OR	BYTE PTR [DI+1],100B
SETMFRET:
	RET

SETMFERR:
	JMP	ASMPOP


DW_OPER:
	MOV	BP,1
	JMP	SHORT DBEN

DB_OPER:
	XOR	BP,BP
DBEN:
	MOV	DI,OFFSET DG:ASSEM_CNT
	DEC	BYTE PTR [DI]
	INC	DI
DB0:
	XOR	BL,BL
	CALL	SCANP
	JNZ	DB1
DBEX:
	JMP	ASSEM_EXIT
DB1:
	OR	BL,BL
	JNZ	DB3
	MOV	BH,BYTE PTR [SI]
	CMP	BH,"'"
	JZ	DB2
	CMP	BH,'"'
	JNZ	DB4
DB2:
	INC	SI
	INC	BL
DB3:
	LODSB
	CMP	AL,13
	JZ	DBEX
	CMP	AL,BH
	JZ	DB0
	STOSB
	INC	BYTE PTR [ASSEM_CNT]
	JMP	DB3
DB4:
	MOV	CX,2
	CMP	BP,0
	JZ	DB41
	MOV	CL,4
DB41:
	PUSH	BX
	CALL	GETHX
	POP	BX
	JNC	DB5
	JMP	ASMERR
DB5:
	MOV	AX,DX
	CMP	BP,0
	JZ	DB6
	STOSW
	INC	BYTE PTR [ASSEM_CNT]
	JMP	SHORT DB7
DB6:
	STOSB
DB7:
	INC	BYTE PTR [ASSEM_CNT]
	JMP	DB0

; ORG pseudo op

DOORG:
	MOV	BP,WORD PTR ASMADD+2
	CALL	GET_ADDRESS
	MOV	WORD PTR ASMADD,DX
	MOV	WORD PTR ASMADD+2,AX
	JMP	ASSEMLOOP

CODE	ENDS
	END	ASSEM

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\debcom2.asm ===
PAGE	60,132 ;
	TITLE	DEBCOM2.ASM - PART2 DEBUGGER COMMANDS	PC DOS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DECOM2.ASM
;
; DESCRIPTIVE NAME: DEBUGGING TOOL
;
; FUNCTION: PROVIDES USERS WITH A TOOL FOR DEBUGGING PROGRAMS.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; INPUT: NA
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: DEBCOM1 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBCOM3 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBASM  - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBUASM - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBMES  - CONTAINS ROUTINES CALLED BY DEBUG
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;	AC000	VERSION 4.00 -
;
;				- IMPLEMENT DBCS HANDLING	DMS:6/17/87
;				- IMPLEMENT MESSAGE RETRIEVER	DMS:6/17/87
;				- IMPLEMENT > 32MB SUPPORT	DMS:6/17/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;======================= END OF SPECIFICATIONS ===========================
;
;	Change Log:
;
;     Date    WHO   #		  Description
;   --------  ---  ---	----------------------------------------------------
;   04/01/90  DIC  C01	Problem fixed - When writing a file to a full disk,
;			file would be deleted if there wasn't enough space.
;			Fix checks to make sure there is enough space.
;			(Compaq STR #1889) (Microsoft Bug #774)
;
;   05/25/90  AKM  C08	Problem fixed - Added code to limit the file size
;                       for the write command.  Size check code changed
;                       because of divide overflow error.
;			(Microsoft Bug #1157)
;
;   07/31/90  AKM  C09	Problem fixed - The fix for C08 broke C01.  Took out
;                       C08 and changed to two divides to a multiply and
;                       a divide (divide by BytesPerClust).  Also, the
;                       volume freee space was not added to the file free
;                       space when overwriting a file.
;
;===========================================================================
; Routines to perform debugger commands except ASSEMble and UASSEMble

	IF1
	    %OUT COMPONENT=DEBUG, MODULE=DEBCOM2
	ENDIF
.XLIST
.XCREF
	include syscall.inc		; cas -- missing equates
	include version.inc		; cas -- missing equates
	include pdb.inc 		; cas -- missing equates
	INCLUDE DOSSYM.INC
        INCLUDE debug.inc
.CREF
.LIST
CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
	EXTRN	NOTFND_PTR:BYTE,NOROOM_PTR:BYTE,DRVLET:BYTE,ERRMES_PTR:BYTE
	EXTRN	NAMBAD_PTR:BYTE,NOSPACE_PTR:BYTE,TOOBIG_PTR:BYTE
	EXTRN	HEXERR_PTR:BYTE,HEXWRT_PTR:BYTE,ACCMES_PTR:BYTE
	EXTRN	EXEBAD_PTR:BYTE,EXEWRT_PTR:BYTE
	EXTRN	EXECEMES_PTR:BYTE,NONAMESPEC_PTR:BYTE

	EXTRN	FLAGTAB:WORD,EXEC_BLOCK:BYTE,COM_LINE:DWORD,COM_FCB1:DWORD
	EXTRN	COM_FCB2:DWORD,COM_SSSP:DWORD,COM_CSIP:DWORD,RETSAVE:WORD
	EXTRN	NEWEXEC:BYTE,HEADSAVE:WORD
	EXTRN	REGTAB:BYTE,TOTREG:BYTE,NOREGL:BYTE
	EXTRN	USER_PROC_PDB:WORD,STACK:BYTE,RSTACK:WORD,AXSAVE:WORD
	EXTRN	BXSAVE:WORD,DSSAVE:WORD,ESSAVE:WORD,CSSAVE:WORD,IPSAVE:WORD
	EXTRN	SSSAVE:WORD,CXSAVE:WORD,SPSAVE:WORD,FLSAVE:WORD
	EXTRN	SREG:BYTE,SEGTAB:WORD,REGDIF:ABS,RDFLG:BYTE
	EXTRN	REGTABEND:WORD
	EXTRN	NAMESPEC:BYTE

	EXTRN	FileSizeLB:WORD,FileSizeHB:WORD,TempHB:WORD,TempLB:WORD   ;C01
	EXTRN	DriveOfFile:WORD					  ;C01

CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE
	EXTRN	DEFDUMP:BYTE,TRANSADD:DWORD,INDEX:WORD,BUFFER:BYTE
	EXTRN	ASMADD:BYTE,DISADD:BYTE,NSEG:WORD
	EXTRN	SWITCHAR:BYTE,XNXCMD:BYTE,XNXOPT:BYTE
	EXTRN	AWORD:BYTE,EXTPTR:WORD,HANDLE:WORD,PARSERR:BYTE
	EXTRN	REG_NAME:WORD,REG_CONTENTS:WORD,REGISTER_PTR:BYTE
	EXTRN	ARG_BUF:BYTE,ARG_BUF_PTR:BYTE,LOC_ADD:WORD,LOC_PTR:BYTE
	EXTRN	BIG_CONTENTS:WORD,BIG_PTR:BYTE,LITTLE_CONTENTS:WORD,LITTLE_PTR:BYTE
	EXTRN	SINGLE_REG_ARG:WORD,CHANGE_FLAG_PTR:BYTE,DF_ERROR:BYTE
	EXTRN	BR_ERROR:BYTE,BF_ERROR:BYTE,SINGLE_REG_PTR:WORD
	EXTRN	WRT_ARG1:WORD,WRT_ARG2:WORD,WRTMES_PTR:BYTE,BEGSEG:WORD
	EXTRN	FILESTRT:WORD,FILEEND:WORD
	EXTRN	ERR_TYPE:BYTE			;ac000;converted to buffer

	extrn	rel_read_write_tab:dword		;an000;primitive I/O
	extrn	rel_rw_add:dword			;an000;transfer address
	extrn	rel_low_sec:word			;an000;low sector word
	extrn	rel_high_sec:word			;an000;high sector word
	extrn	rel_sec_num:word			;an000;# of sectors

fnd_dbcs db    0
DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG
	PUBLIC	DEFIO,PREPNAME,DEBUG_FOUND
	PUBLIC	REG,LOAD
	PUBLIC	NAMED,DWRITE
	PUBLIC	DISPREG,ERR,DELIM1,DELIM2,delim0
	public	getchrup,open1,open2,open3,open4,oc_file,opnret 		;an001;bgb
	public	delete_a_file, parse_a_file, exec_a_file, open_a_file, create_a_file ;an001;bgb
	public	gcur,ifhex							;an001;bgb
	public	comtail 							;an001;bgb
	extrn	test_lead:near							;an001;bgb
	EXTRN	OUTSI:NEAR,OUTDI:NEAR,INBUF:NEAR,SCANB:NEAR,SCANP:NEAR
	EXTRN	COMMAND:NEAR,DISASLN:NEAR,SET_TERMINATE_VECTOR:NEAR
	EXTRN	RESTART:NEAR,TERMINATE:NEAR,DRVERR:NEAR
	EXTRN	GETHEX:NEAR,GETEOL:NEAR,SKIP_FILE:NEAR
	EXTRN	HEXCHK:NEAR,GETHEX1:NEAR,PRINT:NEAR
	EXTRN	CRLF:NEAR,BLANK:NEAR
	EXTRN	HEX:NEAR,DIGIT:NEAR
	EXTRN	FIND_DEBUG:NEAR
	EXTRN	ADDRESS:NEAR,PERROR:NEAR
	EXTRN	STD_PRINTF:NEAR,PRINTF_CRLF:NEAR
DEBCOM2:
DISPLAY_LINE:
	mov	ax,word ptr [si]		;an000;move reg name to ax
	MOV	[REG_NAME],ax			;ac000;save it in reg_name
	ADD	SI,3
	MOV	AX,[BX]
	ADD	BX,2
	MOV	[REG_CONTENTS],AX
	MOV	DX,OFFSET DG:REGISTER_PTR
	CALL	STD_PRINTF

	LOOP	DISPLAY_LINE

	RETURN

DISPLAY_FLAGS:
	MOV	DI,OFFSET DG:ARG_BUF
	MOV	AL,CHAR_BLANK
	STOSB
DISPLAY_FLAGS_2:
	MOV	SI,OFFSET DG:FLAGTAB
	MOV	CX,16
	MOV	DX,[FLSAVE]
DFLAGS:
	LODS	CS:WORD PTR [SI]
	SHL	DX,1
	JC	FLAGSET

	MOV	AX,CS:[SI+30]
FLAGSET:
	OR	AX,AX
	JZ	NEXT_FLAG

	STOSW
	MOV	AL,CHAR_BLANK
	STOSB
NEXT_FLAG:
	LOOP	DFLAGS
	XOR	AL,AL
	STOSB
	RETURN

DISPREG:
	MOV	SI,OFFSET DG:REGTAB
	MOV	DI,OFFSET DG:ARG_BUF
	MOV	BX,OFFSET DG:AXSAVE
	MOV	BYTE PTR TOTREG,CR
	MOV	CH,0
	MOV	CL,NOREGL
SET_DISPLAY:
REPEAT_DISPLAY:
	SUB	TOTREG,CL
	CALL	DISPLAY_LINE

	CALL	CRLF

	XOR	CH,CH
	MOV	CL,NOREGL
	CMP	CL,TOTREG
	JB	REPEAT_DISPLAY

	MOV	CL,TOTREG
	CALL	DISPLAY_LINE

	CALL	DISPLAY_FLAGS

	MOV	DX,OFFSET DG:ARG_BUF_PTR
	CALL	PRINTF_CRLF

	MOV	AX,[IPSAVE]
	MOV	WORD PTR [DISADD],AX
	PUSH	AX
	MOV	AX,[CSSAVE]
	MOV	WORD PTR [DISADD+WORD],AX
	PUSH	AX
	MOV	[NSEG],-1
	CALL	DISASLN

	POP	WORD PTR DISADD+WORD
	POP	WORD PTR DISADD
	MOV	AX,[NSEG]
	CMP	AL,-1
	JNZ	ASSEM_LIN_CONT

	JMP	CRLF

ASSEM_LIN_CONT:
	CMP	AH,-1
	JZ	NOOVER

	XCHG	AL,AH
NOOVER:
	CBW
	MOV	BX,AX
	SHL	BX,1
	MOV	AX,WORD PTR [BX+SREG]
	MOV	DI,OFFSET DG:ARG_BUF
	STOSB
	XCHG	AL,AH
	STOSB
	XOR	AL,AL
	STOSB
	MOV	DX,[INDEX]
	MOV	LOC_ADD,DX
	MOV	DX,OFFSET DG:LOC_PTR
	CALL	STD_PRINTF

	MOV	BX,[BX+SEGTAB]
	PUSH	DS
	MOV	DS,[BX]
	MOV	BX,CS:[INDEX]

;	M000 -- begin changes.
;
;	  When we're running a '386 CPU, fetching from word [ffff] causes
;	  a CPU fault, which causes a fatal fault on Win 3 enhanced or EMM386,
;	  and on some machines (like COMPAQs) even in real mode.  Therefore,
;	  we'll replace the word fetch with a byte fetch.  Notice that the
;	  new code trashes AL.  The subroutines in the vicinity preserve
;	  it, it was left zeroed when most recently used, and does not have
;	  a guaranteed value on return from this subroutine.
;
;	  Notice that the ACTUAL value we display on word [ffff]
;	  references will be the same as an 8088 would use for that
;	  operation.  If the user goes ahead and executes said
;	  instruction on a 386, it will fault!
;
;	MOV	BX,[BX]			; old code used word fetch

	mov	al,[bx]			; get low byte
	mov	bh,1[bx]		; get high byte
	mov	bl,al			; get both into bx

;	M000 -- end changes.

	POP	DS
	MOV	BIG_CONTENTS,BX
	MOV	DX,OFFSET DG:BIG_PTR
	TEST	BYTE PTR [AWORD],-1
	JNZ	SHOW_CHARS

	XOR	BH,BH
	MOV	LITTLE_CONTENTS,BX
	MOV	DX,OFFSET DG:LITTLE_PTR
SHOW_CHARS:
	CALL	PRINTF_CRLF

	RETURN

DISPREGJ:
	JMP	DISPREG

; Perform register dump if no parameters or set register if a
; register designation is a parameter.
REG:
	CALL	SCANP

	JZ	DISPREGJ

	MOV	DL,[SI]
	INC	SI
	MOV	DH,[SI]
	CMP	DH,CR
	JZ	FLAG

	INC	SI
	CALL	GETEOL

	CMP	DH,CHAR_BLANK
	JZ	FLAG

	MOV	DI,OFFSET DG:REGTAB
	XCHG	AX,DX
	PUSH	CS
	POP	ES
	XOR	CX,CX
CHECK_NEXT_REG:
	CMP	AX,WORD PTR[ DI]
	JZ	REG_FOUND

	ADD	DI,3
	INC	CX
	CMP	DI,OFFSET DG:REGTABEND
	JB	CHECK_NEXT_REG

	JMP	short BADREG

REG_FOUND:
	CMP	DI,OFFSET DG:REGTABEND
	JNZ	NOTPC

	DEC	DI
	DEC	DI
	DEC	DI
	MOV	AX,CS:[DI-WORD]
NOTPC:
	PUSH	DI
	MOV	DI,OFFSET DG:ARG_BUF
	STOSB
	XCHG	AL,AH
	STOSB
	XOR	AL,AL
	STOSB
	POP	DI
	PUSH	DS
	POP	ES
	LEA	BX,[DI+REGDIF]
	SUB	BX,CX
	MOV	DX,[BX]
	MOV	SINGLE_REG_ARG,DX
	MOV	DX,OFFSET DG:SINGLE_REG_PTR
	CALL	STD_PRINTF

	CALL	INBUF

	CALL	SCANB

	RETZ

	push	bx				;an000;save bx - we stomp it
	MOV	CX,4
	CALL	GETHEX1
	pop	bx				;an000;restore it

	CALL	GETEOL

	MOV	[BX],DX
	RETURN
BADREG:
	MOV	DX,OFFSET DG:BR_ERROR	; BR ERROR
	JMP	short ERR

FLAG:
	CMP	DL,UPPER_F
	JNZ	BADREG

	MOV	DI,OFFSET DG:ARG_BUF
	CALL	DISPLAY_FLAGS_2

	MOV	DX,OFFSET DG:CHANGE_FLAG_PTR
	CALL	STD_PRINTF

	CALL	INBUF

	CALL	SCANB

	XOR	BX,BX
	MOV	DX,[FLSAVE]
GETFLG:
	LODSW
	CMP	AL,CR
	JZ	SAVCHG

	CMP	AH,CR
	JZ	FLGERR

	MOV	DI,OFFSET DG:FLAGTAB
	MOV	CX,32
	PUSH	CS
	POP	ES
	REPNE	SCASW
	JNZ	FLGERR

	MOV	CH,CL
	AND	CL,0FH
	MOV	AX,1
	ROL	AX,CL
	TEST	AX,BX
	JNZ	REPFLG

	OR	BX,AX
	OR	DX,AX
	TEST	CH,16
	JNZ	NEXFLG

	XOR	DX,AX
NEXFLG:
	CALL	SCANP

	JMP	SHORT GETFLG

REPFLG:
	MOV	DX,OFFSET DG:DF_ERROR	; DF ERROR
FERR:
	CALL	SAVCHG
ERR:
	push	si				;an000;save affected registers
	push	di				;an000;
	push	cx				;an000;
	mov	cx,03h				;an000;move only three bytes
	mov	di,offset dg:err_type		;an000;point to buffer
	mov	si,dx				;an000;dx holds the string
	rep	movsb				;an000;fill up the buffer
	pop	cx				;an000;restore registers
	pop	di				;an000;
	pop	si				;an000;
	MOV	DX,OFFSET DG:ERRMES_PTR
	JMP	PRINT

SAVCHG:
	MOV	[FLSAVE],DX
	RETURN

FLGERR:
	MOV	DX,OFFSET DG:BF_ERROR	; BF ERROR
	JMP	SHORT FERR

PREPNAME:
	MOV	ES,DSSAVE
	PUSH	SI
	MOV	DI,81H
COMTAIL:
	LODSB
	STOSB
	CMP	AL,CR
	JNZ	COMTAIL

	SUB	DI,82H
	XCHG	AX,DI
	MOV	ES:(BYTE PTR [80H]),AL
	POP	SI
	MOV	DI,FCB			;05cH
	MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR SET_DRIVEID_OPTION ;AL=01H
	INT	21H

	MOV	BYTE PTR [AXSAVE],AL	; Indicate analysis of first parm
	CALL	SKIP_FILE

	MOV	DI,6CH
	MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR SET_DRIVEID_OPTION ;AL=01H
	INT	21H

	MOV	BYTE PTR [AXSAVE+1],AL	; Indicate analysis of second parm
	RETURN

;  OPENS A XENIX PATHNAME SPECIFIED IN THE UNFORMATTED PARAMETERS
;  VARIABLE [XNXCMD] SPECIFIES WHICH COMMAND TO OPEN IT WITH

;  VARIABLE [HANDLE] CONTAINS THE HANDLE
;  VARIABLE [EXTPTR] POINTS TO THE FILES EXTENSION
DELETE_A_FILE:
	MOV	BYTE PTR [XNXCMD],UNLINK
	JMP	SHORT OC_FILE

PARSE_A_FILE:
	MOV	BYTE PTR [XNXCMD],0
	JMP	SHORT OC_FILE

EXEC_A_FILE:
	MOV	BYTE PTR CS:[XNXCMD],EXEC
	MOV	BYTE PTR CS:[XNXOPT],1
	JMP	SHORT OC_FILE

OPEN_A_FILE:
	MOV	BYTE PTR [XNXCMD],OPEN
	MOV	BYTE PTR [XNXOPT],2	; Try read write
	CALL	OC_FILE

	RETNC
	MOV	BYTE PTR [XNXCMD],OPEN
	MOV	BYTE PTR [XNXOPT],0	; Try read only
	JMP	SHORT OC_FILE

CREATE_A_FILE:
	MOV	BYTE PTR [XNXCMD],CREAT
OC_FILE:
	PUSH	DS
	PUSH	ES
	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	SI
	XOR	AX,AX
	MOV	CS:[EXTPTR],AX		; INITIALIZE POINTER TO EXTENSIONS
	MOV	AH,CHAR_OPER
	INT	21H

	MOV	CS:[SWITCHAR],DL	; GET THE CURRENT SWITCH CHARACTER
	MOV	SI,81H

open1:	CALL	GETCHRUP		;convert 1 byte to uppercase
	CALL	DELIM2			; END OF LINE?
	JZ	OPEN4

	CALL	DELIM1			; SKIP LEADING DELIMITERS
	JZ	OPEN1

	MOV	DX,SI			; SAVE POINTER TO BEGINNING
	cmp	fnd_dbcs,1
;	$if	z
	JNZ $$IF1
	    dec   dx			;dec it twice if dbcs
;	$endif
$$IF1:
	DEC	DX
open2:	CMP	AL,CHAR_PERIOD		; LAST CHAR A "."?
	JNZ	OPEN3

	MOV	CS:[EXTPTR],SI		; SAVE POINTER TO THE EXTENSION
OPEN3:
	CALL	GETCHRUP

	CALL	DELIM1			; LOOK FOR END OF PATHNAME

	JZ	OPEN4

	CALL	DELIM2

	JNZ	OPEN2

OPEN4:	DEC	SI			; POINT BACK TO LAST CHAR
	PUSH	[SI]			; SAVE TERMINATION CHAR
	MOV	BYTE PTR [SI],0 	; NULL TERMINATE THE STRING
	MOV	AL,CS:[XNXOPT]
	MOV	AH,CS:[XNXCMD]		; OPEN OR CREATE FILE
	OR	AH,AH
	JZ	OPNRET

	MOV	CS:[FILESTRT],DX	; Set values for later call on this file
	MOV	CS:[FILEEND],SI
	PUSH	CS
	POP	ES			; Set ES seg for EXEC_BLOCK
	MOV	BX,OFFSET DG:EXEC_BLOCK
	XOR	CX,CX
	INT	21H

	MOV	CS:[HANDLE],AX		; SAVE ERROR CODE OR HANDLE
OPNRET:
	POP	[SI]
	POP	SI
	POP	DX
	POP	CX
	POP	BX
	POP	AX			; blow away error code...
	POP	ES
	POP	DS
	RETURN

GETCHRUP:									;an001;bgb
	lodsb				;get the character from [si]		;an001;bgb
	call	test_lead		;is it a dbcs lead byte?		;an001;bgb
;	$IF	C			;yes					;an001;bgb
	JNC $$IF3
	    inc     si			;bump ptr to past 2nd dbcs byte 	;an001;bgb
	    mov     fnd_dbcs,1		;found a dbcs char
	    jmp     short gcur		;dont capitalize it			;an001;bgb
;	$ENDIF									;an001;bgb
$$IF3:
					;					;an001;bgb
	mov	fnd_dbcs,0		;did not find a dbcs char
	cmp	al,lower_a		;is it >= "a" ? 			;an001;bgb
	jb	gcur			;no - exit				;an001;bgb
										;an001;bgb
	cmp	al,lower_z		;is it =< "z" ? 			;an001;bgb
	ja	gcur			;no - exit				;an001;bgb
										;an001;bgb
;if we get here, the char is lowercase, so change it				;an001;bgb
	sub	al,32			;convert to uppercase			;an001;bgb
	mov	[si-1],al		;move it back (si points 1 past)	;an001;bgb
gcur:	return									;an001;bgb

DELIM0:
	CMP	AL,CHAR_LEFT_BRACKET
	RETZ
DELIM1:
	CMP	AL,CHAR_BLANK		; SKIP THESE GUYS
	RETZ

	CMP	AL,CHAR_SEMICOLON
	RETZ

	CMP	AL,CHAR_EQUAL
	RETZ

	CMP	AL,CHAR_TAB
	RETZ

	CMP	AL,CHAR_COMMA
	RETURN

DELIM2:
	CMP	AL,CS:[SWITCHAR]	; STOP ON THESE GUYS
	RETZ

	CMP	AL,CR
	RETURN

NAMED:
	OR	[NAMESPEC],1		; Flag a name command executed
	CALL	PREPNAME

	MOV	AL,BYTE PTR AXSAVE
	MOV	PARSERR,AL
	PUSH	ES
	POP	DS
	PUSH	CS
	POP	ES
	MOV	SI,FCB			; DS:SI points to user FCB
	MOV	DI,SI			; ES:DI points to DEBUG FCB
	MOV	CX,82
	REP	MOVSW
	RETURN

BADNAM:
	MOV	DX,OFFSET DG:NAMBAD_PTR
	JMP	RESTART

IFHEX:
	CMP	BYTE PTR [PARSERR],-1	; Invalid drive specification?
	JZ	BADNAM

	CALL	PARSE_A_FILE

	MOV	BX,[EXTPTR]
	CMP	WORD PTR DS:[BX],"EH"	; "HE"
	RETNZ

	CMP	BYTE PTR DS:[BX+WORD],UPPER_X
	RETURN

IFEXE:
	PUSH	BX
	MOV	BX,[EXTPTR]
	CMP	WORD PTR DS:[BX],"XE"	; "EX"
	JNZ	RETIF

	CMP	BYTE PTR DS:[BX+WORD],UPPER_E
RETIF:
	POP	BX
	RETURN

LOAD:
	MOV	BYTE PTR [RDFLG],READ
	JMP	SHORT DSKIO

DWRITE:
	MOV	BYTE PTR [RDFLG],WRITE
DSKIO:
	MOV	BP,[CSSAVE]
	CALL	SCANB

	jz	DEFIO

	CALL	ADDRESS

	CALL	SCANB

	jz	FILEIO

;=========================================================================
; PRMIO:	This routine builds the necessary table for the new
;		generic IOCtl primitive read/write logical sector function.
;
;	Inputs : Binary addresses and values converted by GETHEX
;
;	Outputs: REL_READ_WRITE_TAB -	Table needed by IOCtl function to
;					perform 32 bit sector addressing.
;
;	Date	   : 6/17/87
;=========================================================================

	mov	word ptr dg:[rel_rw_add],dx	;ac000;save transfer address
						;      in table
	mov	word ptr dg:[rel_rw_add+2],ax	;ac000;save segment of transfer
						;      address
	MOV	CX,2
	CALL	GETHEX			; Drive number must be 2 digits or less

	PUSH	DX			;save drive number
	MOV	CX,8			;ac000;allow 32 bit addressibilty
	CALL	GETHEX			; Logical record number
	mov	word ptr dg:[rel_low_sec],dx	;ac000;save low word of logical
						;      sector address
	mov	word ptr dg:[rel_high_sec],bx	;ac000;save high word of
						;      logical sector address

	MOV	CX,3
	CALL	GETHEX			; Number of records
	mov	word ptr dg:[rel_sec_num],dx	;ac000;save number of sectors
						;      to read/write

	CALL	GETEOL

	POP	BX			;ac000;drive number
	CBW				; Turn off verify after write
	MOV	BYTE PTR DRVLET,bl	;ac000;save drive in case of error
	PUSH	BX
	MOV	DL,bL			;ac000;move drive to dl
; Clean off the buffer cache for physical I/O
	push	ds
	MOV	AH,DISK_RESET
	INT	21H

	INC	DL
	MOV	AH,GET_DPB
	INT	21H
	pop	ds

	or	al,al			;ac000;see if an error occurred
	pop	ax			;ac000;restore drive

	JNZ	DRVERRJ

	CMP	CS:BYTE PTR [RDFLG],WRITE
;	$if	z			;an000;we will write to sector(s)
	JNZ $$IF5
		call ABSWRT		;an000;logical sector write
;	$else				;an000;
	JMP SHORT $$EN5
$$IF5:
		call ABSREAD		;an000;we will read sector(s)
;	$endif				;an000;
$$EN5:


ENDABS:
	JNC	RET0

DRVERRJ:
	JMP	DRVERR

RET0:
; Clean cache again...
	MOV	AH,DISK_RESET
	INT	21H

	RETURN


;called from debug.asm
DEFIO:
	MOV	AX,[CSSAVE]		; Default segment
	MOV	DX,100H 		; Default file I/O offset
	CALL	IFHEX
	JNZ	EXECHK
	XOR	DX,DX			; If HEX file, default OFFSET is zero
HEX2BINJ:
	JMP	HEX2BIN

FILEIO:
; AX and DX have segment and offset of transfer, respectively
	CALL	IFHEX
	JZ	HEX2BINJ

EXECHK:
	CALL	IFEXE
	JNZ	BINFIL
	CMP	BYTE PTR [RDFLG],READ
	JZ	EXELJ
	MOV	DX,OFFSET DG:EXEWRT_PTR
	JMP	RESTART 		; Can't write .EXE files

BINFIL:
	CMP	BYTE PTR [RDFLG],WRITE
	JZ	BINLOAD
	CMP	WORD PTR DS:[BX],4F00H + UPPER_C ;"CO"
	JNZ	BINLOAD
	CMP	BYTE PTR DS:[BX+WORD],UPPER_M
	JNZ	BINLOAD

EXELJ:
	DEC	SI
	CMP	DX,100H
	JNZ	PRER

	CMP	AX,[CSSAVE]
	JZ	OAF

PRER:
	JMP	PERROR

OAF:
	CALL	OPEN_A_FILE

	JNC	GDOPEN

	MOV	AX,ERROR_FILE_NOT_FOUND
	JMP	EXECERR

GDOPEN:
	XOR	DX,DX
	XOR	CX,CX
	MOV	BX,[HANDLE]
	MOV	AL,2
	MOV	AH,LSEEK
	INT	21H

	CALL	IFEXE			; SUBTRACT 512 BYTES FOR EXE

	JNZ	BIN2			; FILE LENGTH BECAUSE OF

	SUB	AX,512			; THE HEADER
	SBB	DX,0			; reflect borrow, if any

BIN2:
	MOV	[BXSAVE],DX		; SET UP FILE SIZE IN DX:AX
	MOV	[CXSAVE],AX
	MOV	AH,CLOSE
	INT	21H

	JMP	EXELOAD

NO_MEM_ERR:
	MOV	DX,OFFSET DG:TOOBIG_PTR
	CALL	PRINTF_CRLF

	JMP	COMMAND

WRTFILEJ:
	JMP	WRTFILE
NOFILEJ:
	MOV	FileSizeLB,0		;save low value of file size   ;C01
	MOV	FileSizeHB,0		;save high value of file size  ;C01
	JMP	NOFILE

BINLOAD:
	PUSH	AX
	PUSH	DX
	CMP	BYTE PTR [RDFLG],WRITE
	JZ	WRTFILEJ

	CALL	OPEN_A_FILE

	JC	NOFILEJ

	MOV	BX,[HANDLE]
	MOV	AX,(LSEEK SHL 8) OR LSEEK_EOF_OPTION
	XOR	DX,DX			;CX:DX=DISTANCE (OFFSET) TO MOVE IN BYTES
	MOV	CX,DX
	INT	21H			; GET SIZE OF FILE

	MOV	FileSizeLB,ax		; save low value of file size	;C01
	MOV	FileSizeHB,dx		; save high value of file size	;C01
	MOV	TempLB,ax		; save low value of file size	;C01
	MOV	TempHB,dx		; save high value of file size	;C01

	MOV	SI,DX
	MOV	DI,AX			; SIZE TO SI:DI
	MOV	AX,(LSEEK SHL 8) OR LSEEK_FROM_START
	XOR	DX,DX
	MOV	CX,DX
	INT	21H			; RESET POINTER BACK TO BEGINNING

	POP	AX
	POP	BX
	PUSH	BX
	PUSH	AX			; TRANS ADDR TO BX:AX
	ADD	AX,15
	RCR	AX,1
	MOV	CL,3
	MOV	CL,4
	SHR	AX,CL
	ADD	BX,AX			; Start of transfer rounded up to seg
	MOV	DX,SI
	MOV	AX,DI			; DX:AX is size
	cmp	dx,10h
	jnc	no_mem_err
	MOV	CX,16
	DIV	CX
	OR	DX,DX
	JZ	NOREM

	INC	AX
NOREM:					; AX is number of paras in transfer
	ADD	AX,BX			; AX is first seg that need not exist
	jc	no_mem_err
	CMP	AX,CS:[PDB_BLOCK_LEN]
	JA	NO_MEM_ERR

	MOV	CXSAVE,DI
	MOV	BXSAVE,SI
	POP	DX
	POP	AX
; AX:DX is disk transfer address (segment:offset)
; SI:DI is length (32-bit number)
RDWR:
RDWRLOOP:
	MOV	BX,DX			; Make a copy of the offset
	AND	DX,000FH		; Establish the offset in 0H-FH range
	MOV	CL,4
	SHR	BX,CL			; Shift offset and
	ADD	AX,BX			; Add to segment register to get new Seg:offset
	PUSH	AX
	PUSH	DX			; Save AX,DX register pair
	MOV	WORD PTR [TRANSADD],DX
	MOV	WORD PTR [TRANSADD+WORD],AX
	MOV	CX,0FFF0H		; Keep request in segment
	OR	SI,SI			; Need > 64K?
	JNZ	BIGRDWR

	MOV	CX,DI			; Limit to amount requested
BIGRDWR:
	PUSH	DS
	PUSH	BX
	MOV	BX,[HANDLE]
	MOV	AH,[RDFLG]
	LDS	DX,[TRANSADD]
	INT	21H			; Perform read or write

	POP	BX
	POP	DS
	JC	BADWR

	CMP	BYTE PTR [RDFLG],WRITE
	JNZ	GOODR

	CMP	CX,AX
	JZ	GOODR

BADWR:
	MOV	CX,AX
	STC
	POP	DX			; READ OR WRITE BOMBED OUT
	POP	AX
	RETURN

GOODR:
	MOV	CX,AX
	SUB	DI,CX			; Request minus amount transferred
	SBB	SI,0			; Ripple carry
	OR	CX,CX			; End-of-file?

	mov	ax,TempHB		; new file size value high byte  ;C01
	mov	FileSizeHB,ax		; if write was successful	 ;C01
	mov	ax,TempLB		; new file size value low byte	 ;C01
	mov	FileSizeLB,ax		; if write was successful	 ;C01

	POP	DX			; Restore DMA address
	POP	AX
	JZ	DOCLOSE

	ADD	DX,CX			; Bump DMA address by transfer length
	MOV	BX,SI
	OR	BX,DI			; Finished with request
	JNZ	RDWRLOOP

DOCLOSE:
	SAVEREG <AX,BX>
	MOV	BX,HANDLE
	MOV	AH,CLOSE
	INT	21H

	RESTOREREG <BX,AX>
	RETURN

NOFILE:
	MOV	DX,OFFSET DG:NOTFND_PTR
	JMP	RESTART

NO_NAME_GIVEN:
	MOV	DX,OFFSET DG:NONAMESPEC_PTR
RESTARTJMP:
	JMP	RESTART

WRTFILE:
	CMP	[NAMESPEC],0
	JZ	NO_NAME_GIVEN		; Hey User, you forgot to specify a name

	CALL	ChkFileSz		;C01

	CALL	CREATE_A_FILE		; Create file we want to write to

	JC	CHECKREADONLY		; ARR 2.4

	MOV	SI,BXSAVE		; Get high order number of bytes to transfer
;C08    CMP	SI,000FH
;C08    JLE	WRTSIZE 		; Is bx less than or equal to FH
;C08
;C08    XOR	SI,SI			; Ignore BX if greater than FH - set to zero
	MOV	DI,CXSAVE                                                 ;C08
	CMP	SI,7FFFH                                                  ;C08
	JBE	WRTSIZE 		; Is bx less than or equal to 7FFF;C08
                                        ; Limit fsize to 2GB              ;C08
        MOV     SI,7FFFH                ; Setup maximum file size.        ;C08
        MOV     DI,0FFFFH                                                 ;C08
WRTSIZE:
	MOV	WRT_ARG2,SI
;C08    MOV	DI,CXSAVE
	MOV	WRT_ARG1,DI
	MOV	DX,OFFSET DG:WRTMES_PTR
	CALL	PRINTF_CRLF

	POP	DX
	POP	AX
	CALL	RDWR

	JNC	CLSFLE

	CALL	CLSFLE

	CALL	DELETE_A_FILE

	MOV	DX,OFFSET DG:NOSPACE_PTR
	JMP	RESTARTJMP

	CALL	CLSFLE			;is this dead code? - edk

	JMP	COMMAND

CHECKREADONLY:				; ARR 2.4
	MOV	DX,[FILESTRT]
	MOV	SI,[FILEEND]
	PUSH	[SI]
	MOV	BYTE PTR [SI],0
	MOV	AX,CHMOD SHL 8		;AL=0,REQUEST FILE'S CURRENT
					;  ATTRIBUTE BE RETURNED IN CX
	INT	21H

	POP	[SI]
	MOV	DX,OFFSET DG:NOROOM_PTR ; Creation error - report error
	JC	RESTARTJMP

	TEST	CX,ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM
	JZ	RESTARTJMP

	MOV	DX,OFFSET DG:ACCMES_PTR ; Write on read only file
	JMP	RESTARTJMP

CLSFLE:
	MOV	AH,CLOSE
	MOV	BX,[HANDLE]
	INT	21H

	RETURN

EXELOAD:
	POP	[RETSAVE]		; pull up return addr
	INC	BYTE PTR [NEWEXEC]
	MOV	BX,[USER_PROC_PDB]
	MOV	AX,BEGSEG
	MOV	DS,AX
	ASSUME	DS:NOTHING

	CMP	AX,BX
	JZ	DEBUG_CURRENT

	JMP	FIND_DEBUG

DEBUG_CURRENT:
	MOV	AX,CS:[DSSAVE]
DEBUG_FOUND:
	MOV	CS:BYTE PTR [NEWEXEC],0
	MOV	CS:[HEADSAVE],AX
	PUSH	CS:[RETSAVE]		; Get the return address back
	PUSH	AX
	MOV	BX,CS
	SUB	AX,BX
	PUSH	ES
	MOV	ES,CS:BEGSEG
	ASSUME	ES:NOTHING

	MOV	BX,AX			; size of debug in para.
	ADD	BX,10H
	MOV	AX,CS			; and the size of printf in para.
	SUB	AX,CS:BEGSEG
	ADD	BX,AX
	MOV	AH,SETBLOCK
	INT	21H

	POP	ES
	POP	AX
	MOV	CS:WORD PTR [COM_LINE+WORD],AX
	MOV	CS:WORD PTR [COM_FCB1+WORD],AX
	MOV	CS:WORD PTR [COM_FCB2+WORD],AX
	PUSH	DS
	PUSH	CS
	POP	DS
	CALL	EXEC_A_FILE

	POP	DS
	MOV	AX,CS:[HANDLE]
	JC	EXECERR

	CALL	SET_TERMINATE_VECTOR	; Reset int 22

	MOV	AH,GET_CURRENT_PDB
	INT	21H

	MOV	CS:[USER_PROC_PDB],BX
	MOV	CS:[DSSAVE],BX
	MOV	CS:[ESSAVE],BX
	MOV	ES,BX
	MOV	WORD PTR ES:[PDB_EXIT],OFFSET DG:TERMINATE
	MOV	WORD PTR ES:[PDB_EXIT+WORD],CS
	LES	DI,CS:[COM_CSIP]
	MOV	CS:[CSSAVE],ES
	MOV	CS:[IPSAVE],DI
	MOV	CS:WORD PTR [DISADD+WORD],ES
	MOV	CS:WORD PTR [DISADD],DI
	MOV	CS:WORD PTR [ASMADD+WORD],ES
	MOV	CS:WORD PTR [ASMADD],DI
	MOV	CS:WORD PTR [DEFDUMP+WORD],ES
	MOV	CS:WORD PTR [DEFDUMP],DI
	MOV	BX,DS
	MOV	AH,SET_CURRENT_PDB
	INT	21H

	LES	DI,CS:[COM_SSSP]
	MOV	AX,ES:[DI]
	INC	DI
	INC	DI
	MOV	CS:[AXSAVE],AX
	MOV	CS:[SSSAVE],ES
	MOV	CS:[SPSAVE],DI
	RETURN

EXECERR:
	PUSH	CS
	POP	DS
	MOV	DX,OFFSET DG:NOTFND_PTR
	CMP	AX,ERROR_FILE_NOT_FOUND
	JZ	GOTEXECEMES

	MOV	DX,OFFSET DG:ACCMES_PTR
	CMP	AX,ERROR_ACCESS_DENIED
	JZ	GOTEXECEMES

	MOV	DX,OFFSET DG:TOOBIG_PTR
	CMP	AX,ERROR_NOT_ENOUGH_MEMORY
	JZ	GOTEXECEMES

	MOV	DX,OFFSET DG:EXEBAD_PTR
	CMP	AX,ERROR_BAD_FORMAT
	JZ	GOTEXECEMES

	MOV	DX,OFFSET DG:EXECEMES_PTR
GOTEXECEMES:
	CALL	PRINTF_CRLF

	JMP	COMMAND

HEX2BIN:
	MOV	[INDEX],DX
	MOV	DX,OFFSET DG:HEXWRT_PTR
	CMP	BYTE PTR [RDFLG],WRITE
	JNZ	RDHEX

	JMP	RESTARTJ2

RDHEX:
	MOV	ES,AX
	CALL	OPEN_A_FILE

	MOV	DX,OFFSET DG:NOTFND_PTR
	JNC	HEXFND

	JMP	RESTART

HEXFND:
	XOR	BP,BP
	MOV	SI,OFFSET DG:(BUFFER+BUFSIZ) ; Flag input buffer as empty
READHEX:
	CALL	GETCH

	CMP	AL,CHAR_COLON		; Search for : to start line
	JNZ	READHEX

	CALL	GETBYT			; Get byte count

	MOV	CL,AL
	MOV	CH,0
	JCXZ	HEXDONE

	CALL	GETBYT			; Get high byte of load address

	MOV	BH,AL
	CALL	GETBYT			; Get low byte of load address

	MOV	BL,AL
	ADD	BX,[INDEX]		; Add in offset
	MOV	DI,BX
	CALL	GETBYT			; Throw away type byte

READLN:
	CALL	GETBYT			; Get data byte

	STOSB
	CMP	DI,BP			; Check if this is the largest address so far
	JBE	HAVBIG

	MOV	BP,DI			; Save new largest
HAVBIG:
	LOOP	READLN

	JMP	SHORT READHEX

GETCH:
	CMP	SI,OFFSET DG:(BUFFER+BUFSIZ)
	JNZ	NOREAD

	MOV	DX,OFFSET DG:BUFFER
	MOV	SI,DX
	MOV	AH,READ
	PUSH	BX
	PUSH	CX
	MOV	CX,BUFSIZ
	MOV	BX,cs:[HANDLE]
	INT	21H

	POP	CX
	POP	BX
	OR	AX,AX
	JZ	HEXDONE

NOREAD:
	LODSB
	CMP	AL,CHAR_EOF
	JZ	HEXDONE

	OR	AL,AL
	RETNZ

HEXDONE:
	MOV	[CXSAVE],BP
	MOV	BXSAVE,0
	RETURN

HEXDIG:
	CALL	GETCH

	CALL	HEXCHK

	RETNC

	MOV	DX,OFFSET DG:HEXERR_PTR
RESTARTJ2:
	JMP	RESTART

GETBYT:
	CALL	HEXDIG

	MOV	BL,AL
	CALL	HEXDIG

	SHL	BL,1
	SHL	BL,1
	SHL	BL,1
	SHL	BL,1
	OR	AL,BL
	RETURN

;=========================================================================
; ABSREAD:	This routine performs a primitive logical sector read of
;		the specified drive.  This routine replaces the old
;		INT 25h function which only allowed 16 bit addressibility.
;		The new generic IOCtl logical sector read will permit
;		32 bit addressibility on a disk device.
;
;	Inputs : REL_READ_WRITE_TAB	- Table provides dword sector
;					  addressibility.
;
;	Outputs: Data located at specified transfer address.
;
;	Error  : Carry is set on error.
;
;	Date	  : 6/17/87
;=========================================================================

ABSREAD 	proc	near		;an000;read logical sector(s)

	push	ds			;an000;save affected regs
	push	cx			;an000;save affected regs
	push	bx			;an000;

	mov	cx,-1			;an000;extended format
	mov	bx,offset dg:rel_read_write_tab  ;an000;point to read/write table
	int	25h			;an000;invoke relative sector read
	pop	bx			;an000;discard stack word

	pop	bx			;an000;restore regs
	pop	cx			;an000;
	pop	ds			;an000;

	ret				;an000;return to caller

ABSREAD 	endp			;an000;end proc


;=========================================================================
; ABSWRT:	This routine performs a primitive logical sector write of
;		the specified drive.  This routine replaces the old
;		INT 26h function which only allowed 16 bit addressibility.
;		The new generic IOCtl logical sector write will permit
;		32 bit addressibility on a disk device.
;
;	Inputs : REL_READ_WRITE_TAB	- Table provides dword sector
;					  addressibility.
;
;	Outputs: Data moved from transfer address to applicable sector(s).
;
;	Error  : Carry is set on error.
;
;	Date	  : 6/17/87
;=========================================================================

ABSWRT		proc	near		;an000;write logical sector(s)

	push	ds			;an000;save affected regs
	push	cx			;an000;
	push	bx			;an000;

	mov	cx,-1			;an000;extended format
	mov	bx,offset dg:rel_read_write_tab  ;an000;point to read/write table
	int	26h			;an000;invoke relative sector write
	pop	bx			;an000;discard stack word

	pop	bx			;an000;restore regs
	pop	cx			;an000;
	pop	ds			;an000;

	ret				;an000;return to caller

ABSWRT		endp			;an000;end proc

;*************************************************************************;C01
;This function is designed to test the size of any file being written to  ;C01
;disk or diskette.  If the file wanting to be written is larger than space;C01
;available on disk or diskette then the write will not occur.  This will  ;C01
;prevent the file from being deleted when "insufficient memory" is present;C01
									  ;C01
ChkFileSz   PROC    NEAR						  ;C01
	mov	bx,DriveOfFile		;get drive number of file	  ;C01
	mov	dl,bl			;				  ;C01
	mov	ah,36h			;DOS Function call		  ;C01
	int	21h			;get drive allocation information ;C01
	cmp	ax,0FFFFh		;Q: Was there an error?		  ;C01
	je	RSJMP			;  Y: yes			  ;C01
	mov	cs:AvailClusts,bx	;save # of avail. clusters	  ;C01
	mov	cs:SectsPerClust,ax	;save sectors per cluster	  ;C01
	mov	cs:BytesPerSect,cx	;save bytes per sector		  ;C01

	mul	cs:BytesPerSect						  ;C09
	mov	cs:BytesPerClust,ax	;Compute & save bytes per cluster ;C09

									  ;C01
;Determine how many clusters the new file would have to use.  This value  ;C01
;must be less than the number of available clusters, AvailClusts, or	  ;C01
;the write will have further tests made before executing.		  ;C01
									  ;C01
	mov	dx,BXSAVE	     ;get high order file size		  ;C01
	mov	TempHB,dx						  ;C01
	mov	ax,CXSAVE	     ;get low order file size		  ;C01
	mov	TempLB,ax						  ;C01

;C09	mov	ax,cs:SectsPerClust					  ;C08
;C09	mul	cs:BytesPerSect		;dx:ax = max file size available  ;C08
;C09	mul	cs:AvailClusts						  ;C08
;C09	cmp	dx,cs:TempHB		;Q: Is high word of free space	  ;C08
;C09					;  > size of file?		  ;C08
;C09	ja	CONT5			;  Y: yes, do write		  ;C08
;C09	je	TRY_LOW			;Q: Equal? Y: Try lower word	  ;C08
;C09	jmp	RSJMP			; must be greater, issue error	  ;C08
;C09TRY_LOW:								  ;C08
;C09	cmp	ax,cs:TempLB		;Q: Is low word of free space	  ;C08
;C09					;  > size of file?		  ;C08
;C09	jae	CONT5			;  Y: yes, don't write		  ;C08
;C09RSJMP:								  ;C08
;C09	mov	dx,OFFSET DG:NOSPACE_PTR				  ;C08
;C09	jmp	RESTARTJMP						  ;C08
;C09cont5	label	near						  ;C08
;C09		ret							  ;C08


;C09	div	cs:BytesPerSect		;compute # of sects. for new file ;C01
;C09	cmp	dx,0			;Q: Was there a remainder?	  ;C01
;C09	je	cont1			;  A:no, don't do anything	  ;C01
;C09	inc	ax			;    yes, incr. # of sectors	  ;C01
;C09	xor	dx,dx			;prepare for next divide	  ;C01
;C09cont1	label	near						  ;C01
;C09	div	cs:SectsPerClust	;compute # of clusts for new file ;C01

;	if the count is absurdly large (# clusters > 0ffffh), then
;	  we have to check for the overflow as a special case before
;	  doing the divide.  This is actually quite likely when
;	  people do this command without knowing that the user bx register
;	  contains one of the parameters.

	cmp	dx,cs:BytesPerClust	; see if we're going to get an overflow
	jnb	RSJMP			;  give error if we would've

	div	cs:BytesPerClust	;compute # of clusts for new file ;C09
	or	dx,dx			;Q: Was there a remainder?
	je	cont2			;  A: no, don't do anything	  ;C01
	inc	ax			;     yes, incr. # of clusters	  ;C01
	jz	RSJMP			; give error if rounded to 0
cont2	label	near							  ;C01
	cmp	cs:AvailClusts,ax	;Q: Are there enough disk clusts  ;C01
					;  for the write to occur	  ;C01
	jae	cont5			;  A: yes, write to disk	  ;C01
	mov	cs:FileSzInClusts,ax	;save # of clusters of new file	  ;C01
									  ;C01
;Determine how many clusters the given file now occupies on the disk or	  ;C01
;diskette for comparison with the # of clusters of the new file		  ;C01
									  ;C01
	mov	dx,FileSizeHB	     ;Set up DX:AX with current file	  ;C01
	mov	ax,FileSizeLB	     ;	size				  ;C01
;C09	div	cs:BytesPerSect		;compute # of sects. used by file ;C01
;C09	cmp	dx,0			;Q: Was there a remainder?	  ;C01
;C09	je	cont3			;  A:no, don't do anything	  ;C01
;C09	inc	ax			;    yes, incr. # of sectors	  ;C01
;C09	xor	dx,dx			;prepare for next divide	  ;C01
;C09cont3	label	near						  ;C01
	div	cs:BytesPerClust	;compute # of clusts used by file ;C09
	cmp	dx,0			;Q: Was there a remainder?	  ;C01
	je	cont4			;  A: no, don't do anything	  ;C01
	inc	ax			;     yes, incr. # of clusters	  ;C01
cont4	label	near							  ;C01
	add	ax,cs:AvailClusts	;Get total of file and available  ;C09
	cmp	cs:FileSzInClusts,ax	;Q: Is cluster size of new file	  ;C01
					;  > cluster size of file?	  ;C01
	jna	cont5			;  A: no, go ahead and write
									  ;C01
RSJMP:									  ;C01
	mov	dx,OFFSET DG:NOSPACE_PTR				  ;C01
	jmp	RESTARTJMP						  ;C01
cont5	label	near							  ;C01
		ret							  ;C01
									  ;C01
;   These variables used to determine if the file is larger than the	  ;C01
;   amount of disk space available whenever a write occurs.		  ;C01
									  ;C01
AvailClusts	    DW	?						  ;C01
SectsPerClust	    DW	?						  ;C01
BytesPerSect	    DW	?						  ;C01
FileSzInClusts	    DW	?						  ;C01
MaxBytesInFClust    DW	?						  ;C01
BytesPerClust	    DW	?						  ;C09
ChkFileSz endp								  ;C01

CODE	ENDS
	END	DEBCOM2

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\deberr.asm ===
PAGE	80,132 ;
	TITLE	DEBERR.ASM - DEBUGGER DISK ERROR HANDLER
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;******************* START OF SPECIFICATIONS *****************************
;
; MODULE NAME:DEBERR.ASM
;
; DESCRIPTIVE NAME: DISK ERROR HANDLER
;
; FUNCTION: THIS ROUTINE IS A CATCHALL ERROR HANDLER.  IT PRIMARILY
;	    HANDLES DISK ERROR.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; INPUT: NA
;
; EXIT-NORMAL: NA
;
; EXIT-ERROR: NA
;
; INTERNAL REFERENCES:
;
;
; EXTERNAL REFERENCES:
;
; NOTES: THIS MODULE SHOULD BE PROCESSED WITH THE SALUT PRE-PROCESSOR
;	 WITH OPTIONS "PR".
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+DEBCONST+
;	      DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION DOS 4.0 - MESSAGE RETRIEVER IMPLEMENTED.  DMS:6/17/87
;
;
; COPYRIGHT: "MS DOS DEBUG Utility"
;	     "Version 4.00 (C) Copyright 1988 Microsoft"
;	     "Licensed Material - Property of Microsoft  "
;
;******************** END OF SPECIFICATIONS ******************************
;
;   Change Log:
;
;     Date    Who   #			Description
;   --------  ---  ---	------------------------------------------------------
;   03/27/90  DIC  C03	MSFT # 696 - DEBUG seemed to be reporting the wrong
;                      error after	attempting to reading logical sector zero
;                      on an SCO-XENIX boot diskette.  The message "Write
;                      Protect Error	Reading drive A." was displayed.
;*****************************************************************************

.XLIST
.XCREF
	include version.inc		; cas -- missing equates
	include syscall.inc		; cas -- missing equates
	INCLUDE DOSSYM.INC
.CREF
.LIST

        INCLUDE debug.inc

FIRSTDRV EQU	"A"

CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
	EXTRN	RDFLG:BYTE
	EXTRN	DRVLET:BYTE
	EXTRN	dr1_ptr:word,dr2_ptr:word,dr3_ptr:word,dr4_ptr:word ;ac000
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE
	EXTRN	PARITYFLAG:BYTE
DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
	ASSUME	CS:DG,DS:DG,ES:DG,SS:DG

	EXTRN	RESTART:NEAR
	PUBLIC	DRVERR, TRAPPARITY, RELEASEPARITY, NMIINT, NMIINTEND

TRAPPARITY:
	IF	IBMJAPAN
	    PUSH    BX
	    PUSH    ES
	    PUSH    DX			; save location of new offset
	    MOV     DX,OFFSET DG:NMIINT ; DS:DX has new interrupt vector
	    CALL    SWAPINT		; diddle interrupts
	    ASSUME  ES:NOTHING

	    MOV     WORD PTR [NMIPTR],BX ; save old offset
	    MOV     WORD PTR [NMIPTR+2],ES ; save old segment
	    POP     DX			; get old regs back
	    POP     ES			; restore old values
	    ASSUME  ES:DG

	    POP     BX
	    MOV     BYTE PTR [PARITYFLAG],0 ; no interrupts detected yet!
	    RET

SWAPINT:
	    PUSH    AX
	    MOV     AX,(GET_INTERRUPT_VECTOR SHL 8) + 2
	    INT     21H 		; Get old NMI Vector
	    MOV     AX,(SET_INTERRUPT_VECTOR SHL 8) + 2
	    INT     21h 		; let OS set new vector
	    POP     AX
	ENDIF
	RET

RELEASEPARITY:
	IF	IBMJAPAN
	    PUSH    DX
	    PUSH    DS
	    PUSH    BX
	    PUSH    ES
	    LDS     DX,DWORD PTR [NMIPtr] ; get old vector
	    CALL    SwapInt		; diddle back to original
	    POP     ES
	    POP     BX
	    POP     DS
	    POP     DX
	    MOV     [PARITYFLAG],0	; no interrupts possible!
	ENDIF
	RET

NMIInt:
	IF	IBMJAPAN
	    PUSH    AX			; save AX
	    IN	    AL,0A0H		; get status register
	    OR	    AL,1		; was there parity check?
	    POP     AX			; get old AX back
	    JZ	    NMICHAIN		; no, go chain interrupt
	    OUT     0A2H,AL		; reset NMI detector
	    MOV     CS:[PARITYFLAG],1	; signal detection
	    IRET
NMICHAIN:
	    JMP     DWORD PTR CS:[NMIPTR] ; chain the vectors
NMIPTR	    DD	    ?			; where old NMI gets stashed
	ENDIF
NMIINTEND:

DRVERR:

	or	al,al				;ac000;see if drive specified
;	$if	nz				;an000;drive specified
	JZ $$IF1
		add	byte ptr drvlet,firstdrv;ac000;determine drive letter
		cmp	byte ptr rdflg,write	;ac000;see if it is read/write
;		$if	z			;an000;it is write
		JNZ $$IF2
			mov	dx,offset dg:dr2_ptr	;an000;message
;		$else				;an000;it is read
		JMP SHORT $$EN2
$$IF2:
			mov	dx,offset dg:dr1_ptr	;an000;message
;		$endif				;an000;
$$EN2:
;	$else					;an000;write protect error
	JMP SHORT $$EN1
$$IF1:
		add	byte ptr drvlet,firstdrv;ac000;determine drive letter
		cmp	byte ptr rdflg,write	;ac000;see if it is read/write
;		$if	z			;an000;it is write
		JNZ $$IF6
			mov	dx,offset dg:dr4_ptr	;an000;message
;		$else				;an000;it is read
		JMP SHORT $$EN6
$$IF6:
			mov	dx,offset dg:dr1_ptr	;an000;message ;C03
;		$endif				;an000;
$$EN6:
;	$endif					;an000;
$$EN1:

; CLEAN OUT THE DISK...
	MOV	AH,DISK_RESET
	INT	21H

	JMP	RESTART
CODEEND:

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\debems.asm ===
PAGE	60,132 ;
	TITLE	DEBEMS.ASM - EMS DEBUGGER COMMANDS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DEBEMS.ASM
;
; DESCRIPTIVE NAME: DEBUGGING TOOL
;
; FUNCTION: PROVIDES USERS WITH ACCESS TO RUDIMENTARY EMS FACILITIES.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; INPUT: NA
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: DEBCOM2 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBCOM3 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBASM  - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBUASM - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBMES  - CONTAINS ROUTINES CALLED BY DEBUG
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT EMS FUNCTIONS	DSM:6/24/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;======================= END OF SPECIFICATIONS ===========================
;
;   Change Log:
;
;     Date    Who   #			Description
;   --------  ---  ---	------------------------------------------------------
;   03/21/90  DIC  C04	Fixed Microsoft Bug #744 - A problem involving a
;                   			limitation on the total number of requested EMS memory
;                   			pages to 255.  This limit is now a 4-digit hexadecimal
;                   			number.
;   04/05/90  DIC  C05 MSFT #990 - "XS" command in debug always displays the
;                      default total handle of "FF" instead of the actual
;                      number.  This fix uses  func-54h, sub-func: 02h via
;                      EMS V4.0.
;   04/30/90  DIC  C06 MSFT # 994 - Debug does not use the "approved" means
;                      of checking EMS status.  This version uses a more
;                      traditional method of: (1) Attempting an OPEN on the
;                      guaranteed resource name of: EMMXXXX0 and (2) using
;                      IOCTL sub-functions (0) and (7) to determine if the
;                      name EMMXXXX0 actually represents a file or not.
;
;==============================================================================
INCLUDE DOSSYM.INC
include version.inc		; cas -- missing equates
include debug.inc


CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE

	extrn xm_page:word		   ;an000;page count to allocate  ;C04
		      ; allow max of 64K pages to allocate.		  ;C04
		      ; "xm_page" was an 8-bit quantity.		  ;C04

	extrn xm_log:byte			;an000;log. page to map
	extrn xm_phy:byte			;an000;phy. page to map
	extrn xm_handle:word			;an000;handle to map
	extrn xm_handle_ret:word		;an000;handle created

	extrn xm_page_cnt:word			;an000;page count
	extrn xm_handle_pages_buf:byte		;an000;holds handles and pages
	extrn xm_frame:word			;an000;EMS frame value
	extrn xm_deall_han:word 		;an000;handle to deallocate
	extrn xm_alloc_pg:word			;an000;pages allocated
	extrn xm_total_pg:word			;an000;total pages possible
	extrn xm_han_alloc:word 		;an000;handles allocated
	extrn xm_han_total:word 		;an000;total handles possible

	extrn	  xm_han_ret_ptr:word		;an000;prints handle created
	extrn	  xm_mapped_ptr:word		;an000;prints log/phy pages
	extrn	  xm_page_seg_ptr:word		;an000;Frame seg status
	extrn	  xm_deall_ptr:word		;an000;Handle deallocation
	extrn	  xm_unall_ptr:word		;an000;prints page status
	extrn	  xm_han_alloc_ptr:word 	;an000;print handle status

	extrn	  xm_err80_ptr:word		;an000;ems error message
	extrn	  xm_err83_ptr:word		;an000;ems error message
	extrn	  xm_err84_ptr:word		;an000;ems error message
	extrn	  xm_err85_ptr:word		;an000;ems error message
	extrn	  xm_err86_ptr:word		;an000;ems error message
	extrn	  xm_err87_ptr:word		;an000;ems error message
	extrn	  xm_err88_ptr:word		;an000;ems error message
	extrn	  xm_err89_ptr:word		;an000;ems error message
	extrn	  xm_err8a_ptr:word		;an000;ems error message
	extrn	  xm_err8b_ptr:word		;an000;ems error message
	extrn	  xm_err8d_ptr:word		;an000;ems error message
	extrn	  xm_err8e_ptr:word		;an000;ems error message
	extrn	  xm_errff_ptr:word		;an000;ems error message
	extrn	  xm_err_gen_ptr:word		;an000;ems error message
	extrn	  xm_parse_err_ptr:word 	;an000;input error message
	extrn	  xm_status_ptr:word		;an000;prints status of EMS

DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG

	public	  debems			;an000;entry point
	extrn	  std_printf:near		;an000;message retriever
	extrn	  gethx:near			;an000;ASCII to bin conversion
	extrn	  inbuf:near			;an000;input command line
	extrn	  scanb:near			;an000;scan off blanks
	extrn	  scanp:near			;an000;scan for parm
	extrn	  perr:near			;an000;print ^ error
	extrn	  geteol:near
	extrn	  crlf:near			;an000;prints a cr,lf

	IF	SYSVER
	ENDIF

DEBEMS: 					;an000;entry to module

	call SCANP				;an000;scan for M or S parm
;	$if  z					;an000;no parms found
	JNZ $$IF1
	     call XM_PARSE_ERROR		;an000;tell user of error
;	$else					;an000;
	JMP SHORT $$EN1
$$IF1:
	     mov  al,[si]			;an000;grab parm
	     cmp  al,"M"			;an000;is it MAP?
;	     $if  e				;an000;yes
	     JNE $$IF3
		  inc  si			;an000;point to next byte
		  call XM_EMS_MAP		;an000;
;	     $else				;an000;
	     JMP SHORT $$EN3
$$IF3:
		  cmp  al,"S"			;an000;is it a status check?
;		  $if  e			;an000;yes
		  JNE $$IF5
		       inc  si			;an000;point to next byte
		       call XM_EMS_STATUS	;an000;
;		  $else 			;an000;
		  JMP SHORT $$EN5
$$IF5:
		       cmp  al,"D"		;an000;Deallocate pages?
;		       $if  e			;an000;yes
		       JNE $$IF7
			    inc   si		;an000;point to next byte
			    call  XM_EMS_DEALL	;an000;
;		       $else			;an000;
		       JMP SHORT $$EN7
$$IF7:
			    cmp  al,"A" 	;an000;Allocate pages?
;			    $if  e		;an000;yes
			    JNE $$IF9
				 inc  si	;an000;point to next byte
				 call XM_EMS_ALLOC    ;an000;
;			    $else		;an000;
			    JMP SHORT $$EN9
$$IF9:
				call GETEOL	;an000;check out parm
;			    $endif		;an000;
$$EN9:
;		       $endif			;an000;
$$EN7:
;		  $endif			;an000;
$$EN5:
;	    $endif				;an000;
$$EN3:
;	$endif					;an000;
$$EN1:

	ret					;an000;return to caller



;=========================================================================
; XM_EMS_ALLOC	  :    This function will provide the user the
;		       capability to set and change EMS logical and
;		       physical pages within page frame 0.
;
;	Inputs:   none
;
;	Outputs:  EMS page frames set or altered
;
;	Date:	  6/24/87
;=========================================================================

XM_EMS_ALLOC	proc	near			;an000;XM functions

	call XM_GET_MAN_STATUS			;an000;see if EMS active
;	$if  nc 				;an000;EMS active
	JC $$IF16
	     call XM_PAGE_PROMPT		;an000;get pages to allocate
	     call XM_GET_HAN_ALLOC		;an000;allocate pages
	     mov  dg:XM_HANDLE_RET,dx		;an000;save handle returned
;	     $if  z				;an000;good return
	     JNZ $$IF17
		  pushf 			;an000;save our flags
		  call XM_DISP1 		;an000;tell user results
		  popf				;an000;restore our flags
;	     $else				;an000;
	     JMP SHORT $$EN17
$$IF17:
		  call XM_ERROR 		;an000;print error message
;	     $endif				;an000;
$$EN17:
;	$else					;an000;EMS not active
	JMP SHORT $$EN16
$$IF16:
	     call XM_ERROR			;an000;say why not active
;	$endif					;an000;
$$EN16:

	ret					;an000;return to caller

XM_EMS_ALLOC	  endp				;an000;


;=========================================================================
; XM_EMS_MAP	  :    This function will provide the user the
;		       capability to set and change EMS logical and
;		       physical pages within page frame 0.
;
;	Inputs:   none
;
;	Outputs:  EMS page frames set or altered
;
;	Date:	  6/24/87
;=========================================================================

XM_EMS_MAP	proc	near			;an000;XM functions

	call XM_GET_MAN_STATUS			;an000;see if EMS active
;	$if  nc 				;an000;EMS active
	JC $$IF22
	     call XM_LOG_PROMPT 		;an000;get logical page
	     call XM_PHY_PROMPT 		;an000;get physical page
	     call XM_HAN_PROMPT 		;an000;get handle
	     call XM_MAP_MEMORY 		;an000;map the page
;	     $if  z				;an000;good return
	     JNZ $$IF23
		  pushf 			;an000;save our flags
		  call XM_DISP2 		;an000;tell user results
		  popf				;an000;restore our flags
;	     $else				;an000;
	     JMP SHORT $$EN23
$$IF23:
		   call XM_ERROR		;an000;tell error
;	     $endif				;an000;
$$EN23:
;	$else					;an000;EMS not active
	JMP SHORT $$EN22
$$IF22:
	     call XM_ERROR			;an000;say why not active
;	$endif					;an000;
$$EN22:

	ret					;an000;return to caller

XM_EMS_MAP	  endp				;an000;

;=========================================================================
; XM_GET_MAN_STATUS :  This routine will determine if EMS is active for
;		       this session.
;
;	Called Procs:  none
;
;	Inputs:        none
;
;	Outputs:       Z  - no error
;		       NZ - error
;		       AH - error message number
;
;	Date:	       6/24/87
; C06 - DIC    4/30/90 This routine has been updated in order to employ
;                      a slightly more traditional method to determine the
;                      existence or absence of EMS.
;=========================================================================

std_emm_name   db      "EMMXXXX0",0     ;  C06 - Standard device name for the
                                        ;  C06 - Expanded Memory Manager.

XM_GET_MAN_STATUS proc near			;an000;see if EMS active

;   C06   	push	ds				;an000;save ds - we stomp it
;   C06   	mov	ax,00h				;an000;set ax to 0
;   C06   	mov	ds,ax				;an000;set ds to 0
;   C06   	cmp	ds:word ptr[067h*4+0],0 	;an000;see if int 67h is there
;   C06   	pop	ds				;an000;restore ds
;   C06   ;	$if	e				;an000;EMS not installed
;   C06   	JNE $$IF28
;   C06   		stc				;an000;flag no ems
;   C06   		mov	ah,XM_NOT_INST		;an000;signal EMS not installed
;   C06   ;	$else					;an000;
;   C06   	JMP SHORT $$EN28
;   C06   $$IF28:
;   C06   		call	XM_INSTALL_CHECK	;an000;see if EMS installed
;   C06   ;		$if	z			;AN000;IS EMS INSTALLED
;   C06   		JNZ $$IF30
;   C06   			clc			;AN000;EMS INSTALLED - FLAG IT
;   C06   ;		$else				;an000;
;   C06   		JMP SHORT $$EN30
;   C06   $$IF30:
;   C06   			stc			;AN000;FLAG EMS NOT INSTALLED
;   C06   			mov  ah,XM_NOT_INST	;an000;signal EMS not installed
;   C06   ;		$endif				;an000;
;   C06   $$EN30:
;   C06   ;	$endif					;an000;
;   C06   $$EN28:
;   C06   
;   C06   	RET					;AN000;RETURN TO CALLER

           push    ds                        ;  C06
           push    cs                        ;  C06
           pop     ds                        ;  C06
           mov     dx,offset std_emm_name    ;  C06 - Attempt to OPEN the 
           mov     ax,3d00h                  ;  C06 - Standard (guaranteed) EMM driver
           int     21h                       ;  C06 - name.  It might actually be a file.
           jc      emm_not_present           ;  C06 - If EMM driver is not present.
           
           ;  Otherwise, the name: EMMXXXX0 does exist, but it might turn out   C06
           ;  to be a file instead of the name of a device driver.              C06

           mov     bx,ax                     ;  C06 - Handle from the OPEN operation.
           mov     ax,4400h                  ;  C06 - Get device information
           int     21h                       ;  C06 - using traditional MSDOS method.
           jc      emm_not_present           ;  C06 - If error, then assume EMM does not exist.
           and     dx,80h                    ;  C06 - Is it a character device ?
           jz      emm_not_present           ;  C06 - NO--> Assume EMM is not present
           mov     ax,4407h                  ;  C06 - Request OUTPUT status
           int     21h                       ;  C06 - via traditional MSDOS method.
           jc      emm_not_present           ;  C06 - interpret as EMM-not-present.
           or      al,al                     ;  C06 - Device status ?
           jz      emm_not_present           ;  C06 - if EMM is not available
           
           ; since these tests have been passed, we can assume            C06
           ; that the EMMXXXX0 drive does indeed exist.                   C06

           mov     ah,03eh                   ;  C06 - Close out the EMM device handle
           int     21h                       ;  C06
           jc      emm_not_present           ;  C06 - Failure here is interpreted as:
                                             ;  C06 - EMM not available.
           call    XM_INSTALL_CHECK          ;  C06 - Do std EMS installation check.
           jnz     emm_not_present           ;  C06 - If EMS does not exist.
           clc                               ;  C06 - Successful return
           pop     ds                        ;  C06 - He gets restored.
           ret                               ;  C06

emm_not_present:

           stc                               ;  C06
           mov     ah,XM_NOT_INST            ;  C06 - error number
           pop     ds                        ;  C06
           ret                               ;  C06

XM_GET_MAN_STATUS endp				;an000;

;=========================================================================
; XM_PAGE_PROMPT :     This routine prompts the user for the number of
;		       pages to be allocated, if he desires a new handle.
;		       This routine will determine whether or not the other
;		       prompt messages will be displayed.
;
;	Called Procs:  STD_PRINTF
;		       XM_PARSE
;
;	Inputs:        none
;
;	Outputs:       XM_PAGE_FLAG
;		       XM_PAGE_BUF
;		       XM_PAGE
;
;	Date:	       6/24/87
;=========================================================================

XM_PAGE_PROMPT	  proc near			;an000;prompt user for number
						;      of pages to allocate
	call SCANB				;an000;see if parm entered
;	$if  nz 				;an000;if parm found
	JZ $$IF34
;C04	     mov  cx,02 			;an000;bytes to parse
	     mov  cx,04 			;an000;bytes to parse	   ;C04
						;   (maximum entry of 64K) ;C04
	     call GETHX 			;an000;get hex value
;	     $if  c				;an000;no an error occurred
	     JNC $$IF35
		  call PERR			;an000;display ^ error
;	     $else				;an000;
	     JMP SHORT $$EN35
$$IF35:
;C04		  mov  dg:XM_PAGE,dl		;an000;save page count
		  mov  word ptr dg:XM_PAGE,dx	;save page cnt (max=64K)  ;C04
;	     $endif				;an000;
$$EN35:
;	$else					;an000;
	JMP SHORT $$EN34
$$IF34:
	     call PERR				;an000;display ^ error
;	$endif					;an000;
$$EN34:

	ret					;an000;return to caller

XM_PAGE_PROMPT	  endp				;an000;


;=========================================================================
; XM_LOG_PROMPT :      This routine prompts the user for the number of the
;		       logical page that is to be mapped in EMS.  This
;		       routine will not be performed if a page count
;		       was specified.
;
;	Called Procs:  STD_PRINTF
;		       XM_PARSE
;
;	Inputs:        none
;
;	Outputs:       XM_LOG_BUF
;		       XM_LOG
;
;	Date:	       6/24/87
;=========================================================================


XM_LOG_PROMPT	  proc near			;an000;prompt user for the
						;      logical page to be
						;      mapped
	call SCANB				;an000;see if parm entered
;	$if  nz 				;an000;parm entered
	JZ $$IF40
	     mov  cx,02 			;an000;bytes to parse
	     call GETHX 			;an000;get hex value
;	     $if  c				;an000;no an error occurred
	     JNC $$IF41
		  call PERR			;an000;display ^ error
;	     $else				;an000;
	     JMP SHORT $$EN41
$$IF41:
		  mov  dg:XM_LOG,dl		;an000;save logical page
;	     $endif				;an000;
$$EN41:
;	$else					;an000;
	JMP SHORT $$EN40
$$IF40:
	     call PERR				;an000;display ^ error
;	$endif					;an000;
$$EN40:

	ret					;an000;return to caller

XM_LOG_PROMPT	  endp				;an000;


;=========================================================================
; XM_PHY_PROMPT :      This routine prompts the user for the number of the
;		       physical page that is to be mapped in EMS.  This
;		       routine will not be performed if a page count
;		       was specified.
;
;	Called Procs:  STD_PRINTF
;		       XM_PARSE
;
;	Inputs:        none
;
;	Outputs:       XM_PHY_BUF
;		       XM_PHY
;
;	Date:	       6/24/87
;=========================================================================


XM_PHY_PROMPT	  proc near			;an000;prompt user for the
						;      physical page to be
						;      mapped
	call SCANB				;an000;see if parm entered
;	$if  nz 				;an000;parm found
	JZ $$IF46
	     mov  cx,02 			;an000;bytes to parse
	     call GETHX 			;an000;get hex value
;	     $if  c				;an000;no an error occurred
	     JNC $$IF47
		  call PERR			;an000;display ^ error
;	     $else				;an000;
	     JMP SHORT $$EN47
$$IF47:
		  mov  dg:XM_PHY,dl		;an000;save logical page
;	     $endif				;an000;
$$EN47:
;	$else					;an000;
	JMP SHORT $$EN46
$$IF46:
	     call PERR				;an000;
;	$endif					;an000;
$$EN46:

	ret					;an000;return to caller

XM_PHY_PROMPT	  endp				;an000;


;=========================================================================
; XM_HAN_PROMPT :      This routine prompts the user for the number of the
;		       handle that the mapping is to occur on. This
;		       routine will not be performed if a page count
;		       was specified.
;
;	Called Procs:  STD_PRINTF
;		       XM_PARSE
;
;	Inputs:        none
;
;	Outputs:       XM_HAN_BUF
;		       XM_HAN
;
;	Date:	       6/24/87
;=========================================================================


XM_HAN_PROMPT	  proc near			;an000;prompt user for the
						;      handle to be mapped
	call SCANB				;an000;see if parm entered
;	$if  nz 				;an000;prompt found
	JZ $$IF52
	     mov  cx,04 			;an000;bytes to parse
	     call GETHX 			;an000;get hex value
;	     $if  c				;an000;no an error occurred
	     JNC $$IF53
		  call PERR			;an000;display ^ error
;	     $else				;an000;
	     JMP SHORT $$EN53
$$IF53:
		  mov  dg:XM_HANDLE,dx		;an000;save logical page
;	     $endif				;an000;
$$EN53:
;	$else					;an000;
	JMP SHORT $$EN52
$$IF52:
	     call PERR				;an000;display ^ error
;	$endif					;an000;
$$EN52:

	ret					;an000;return to caller

XM_HAN_PROMPT	  endp				;an000;



;=========================================================================
; XM_GET_HAN_ALLOC :   This routine will get a handle and allocate the
;		       requested number of pages to that handle.
;
;	Called Procs:  none
;
;	Inputs:        XM_PAGE - number of pages to allocate to handle
;
;	Outputs:       Z  - no error
;		       NZ - error
;		       DX - handle allocated
;
;	Date:	       6/24/87
;=========================================================================

XM_GET_HAN_ALLOC  proc near			;an000;create handle and alloc.
						;      requested pages.
	push bx 				;an000;save regs.
	mov  ah,EMS_HAN_ALLOC			;an000;function 43h
;C04	xor  bh,bh				;an000;clear byte
;C04	mov  bl,dg:XM_PAGE			;an000;number of pages to
	mov  bx,word ptr dg:XM_PAGE		;num of pages (64K limit) to;C04
						;      allocate
	int  67h				;an000;call EMS
	or   ah,ah				;an000;was there an error
	pop  bx 				;an000;restore regs.

	ret					;an000;return to caller

XM_GET_HAN_ALLOC  endp				;an000;

;=========================================================================
; XM_MAP_MEMORY :      This routine will map the requested logical page
;		       to the requested physical page in EMS.
;
;	Called Procs:  none
;
;	Inputs:        XM_PHY - physical page to map to
;		       XM_HAN - logical page to map
;
;	Outputs:       Z  - no error
;		       NZ - error
;		       page mapped
;
;	Date:	       6/24/87
;=========================================================================

XM_MAP_MEMORY	  proc near			;an000;map a logical page to
						;      a physical page in
						;      EMS
	push bx 				;an000;save regs.
	push dx 				;an000;
	mov  ah,EMS_MAP_MEMORY			;an000;function 44h
	mov  al,dg:XM_PHY			;an000;physical page to map
	xor  bh,bh				;an000;zero byte
	mov  bl,dg:XM_LOG			;an000;logical page to map
	mov  dx,dg:XM_HANDLE			;an000;handle to map page to
	int  67h				;an000;call EMS
	or   ah,ah				;an000;was there an error
	pop  dx 				;an000;restore regs.
	pop  bx 				;an000;

	ret					;an000;return to caller

XM_MAP_MEMORY	  endp				;an000;


;=========================================================================
; XM_DISP1 :	       This routine displays the current page frame and
;		       the handle created as a result of the allocate pages.
;
;	Called Procs:  STD_PRINTF
;
;	Inputs:        XM_FRAME_SEG	- page frame segment
;		       XM_HANDLE_RET	- created handle
;		       XM_PG_FRAME_PTR	- pointer to message
;		       XM_HAN_RET_PTR	- pointer to message
;
;	Outputs:       "Page Frame Segment : %1",0d,0a
;		       "Handle Created     : %1",0d,0a
;
;	Date:	       6/24/87
;=========================================================================

XM_DISP1	  proc near			;an000;display messages

	mov  dx,offset dg:XM_HAN_RET_PTR	;an000;"Handle Created    : "
	call STD_PRINTF 			;an000;call message ret.

	ret					;an000;return to caller

XM_DISP1	  endp				;an000;


;=========================================================================
; XM_DISP2 :	       This routine displays the logical page mapped and
;		       the physical page it was mapped to.
;
;	Called Procs:  STD_PRINTF
;
;	Inputs:        XM_MAPPED_PTR	- pointer to message
;		       XM_LOG		- logical page mapped
;		       XM_PHY		- physical page mapped
;
;	Outputs:       "Logical page %1 mapped to physical page %2",0d0a
;
;	Date:	       6/24/87
;=========================================================================

XM_DISP2	  proc near			;an000;display messages

	mov  dx,offset dg:XM_MAPPED_PTR 	;an000;"Logical page %1 mapped
						;	to physical page %2"
	call STD_PRINTF 			;an000;call message ret.

	ret					;an000;return to caller

XM_DISP2	  endp				;an000;

;=========================================================================
; XM_ERROR:	  This routine will determine what error we have by
;		  querying the result in the AH register.  It will then
;		  report the error to the user through STD_PRINTF
;
;	Called Procs:  STD_PRINTF
;
;	Inputs:        AH - error code
;
;	Outputs:       error message
;
;	Date:	       6/24/87
;=========================================================================

XM_ERROR	  proc near			;an000;error message printer

	mov	dx,offset dg:XM_ERR80_PTR	;an000;point to message
	cmp	ah,XM_ERR80			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR83_PTR	;an000;point to message
	cmp	ah,XM_ERR83			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR84_PTR	;an000;point to message
	cmp	ah,XM_ERR84			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR85_PTR	;an000;point to message
	cmp	ah,XM_ERR85			;an000;error message
	je	XM_ERROR_CONT			; print error


	mov	dx,offset dg:XM_ERR86_PTR	;an000;point to message
	cmp	ah,XM_ERR86			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR87_PTR	;an000;point to message
	cmp	ah,XM_ERR87			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR88_PTR	;an000;point to message
	cmp	ah,XM_ERR88			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR89_PTR	;an000;point to message
	cmp	ah,XM_ERR89			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR8A_PTR	;an000;point to message
	cmp	ah,XM_ERR8A			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR8B_PTR	;an000;point to message
	cmp	ah,XM_ERR8B			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR8D_PTR	;an000;point to message
	cmp	ah,XM_ERR8D			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR8E_PTR	;an000;point to message
	cmp	ah,XM_ERR8E			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERRFF_PTR	;an000;point to message
	cmp	ah,XM_NOT_INST			;an000;EMS not installed
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR_GEN_PTR	;an000;general error message

XM_ERROR_CONT:

	jmp STD_PRINTF 				;an000;call message ret.


XM_ERROR	  endp				;an000;

;=========================================================================
; XM_PARSE_ERROR :     This routine will display that an error has occurred
;		       on the input of the requested data.
;
;	Called Procs:  STD_PRINTF
;
;	Inputs:        XM_PARSE_ERR_PTR - error message
;
;	Outputs:       "Invalid value for parameter",0d,0a
;
;	Date:	       6/24/87
;=========================================================================

XM_PARSE_ERROR	  proc near			;an000;input error message

	mov  dx,offset dg:XM_PARSE_ERR_PTR	;an000;error message
	call STD_PRINTF 			;an000;call message ret.
	ret					;an000;return to caller

XM_PARSE_ERROR	  endp				;an000;



;=========================================================================
; XM_EMS_STATUS   :    This function will provide the user with
;		       a report the the current status of EMS.
;
;	Inputs:   none
;
;	Outputs:  EMS page frames set or altered
;
;	Date:	  6/24/87
;=========================================================================

XM_EMS_STATUS	proc	near			;an000;XM functions

	call XM_GET_MAN_STATUS			;an000;see if EMS active
;	$if  nc 				;an000;EMS active
	JC $$IF84
	     call XM_CURR_STATUS		;an000;current status of EMS
;	$else					;an000;EMS not active
	JMP SHORT $$EN84
$$IF84:
	     call XM_ERROR			;an000;say why not active
;	$endif					;an000;
$$EN84:

	ret					;an000;return to caller

XM_EMS_STATUS	  endp				;an000;


;=========================================================================
; XM_CURR_STATUS :	This routine will display the current status of
;			all active EMS handles.
;
;	Inputs	 :	none
;
;	Outputs  :	Current status of all active EMS handles
;			"Handle %1 has %2 pages allocated"
;
;			Physical page with it associated frame segment
;			"Physical page %1 = Frame segment %2"
;
;	Date:	       8/05/86
;=========================================================================

XM_CURR_STATUS		proc	near		;an000;current EMS status

	mov  ah,EMS_HANDLE_PAGES		;an000;get handle pages
	mov  di,offset dg:XM_HANDLE_PAGES_BUF	;an000;point to the buffer
	int  67h				;an000;

	or   ah,ah				;an000;see if an error occurred
;	$if  z					;an000;no error
	JNZ $$IF87
;	     $do				;an000;do while data in buffer
$$DO88:
		  cmp  bx,0			;an000;end of buffer?
;		  $leave  e			;an000;yes
		  JE $$EN88
		       mov  ax,word ptr es:[di] ;an000;page handle
		       mov  dg:XM_HANDLE_RET,ax ;an000;save in var
		       mov  ax,word ptr es:[di+02];an000;page count
		       mov  dg:XM_PAGE_CNT,ax	;an000;save in var
		       mov  dx,offset dg:XM_STATUS_PTR ;an000;point to message
		       call STD_PRINTF		;an000;print it
		       add  di,04h		;an000;next record
		       dec  bx			;an000;decrement counter
;	     $enddo				;an000;
	     JMP SHORT $$DO88
$$EN88:

	     call  CRLF 			;an000;place a blank line
						;      between reports

	     call  XM_FRAME_BUFFER		;an000;get frame buffer
						;ES:DI points to frame buffer
;	     $do				;an000;while cx not = 0
$$DO91:
		  cmp  cx,00			;an000;at end?
;		  $leave e			;an000;yes
		  JE $$EN91
		       call  XM_GET_FRAME_SEG	;an000;obtain page and seg
		       mov   dx,offset dg:XM_PAGE_SEG_PTR  ;an000;message
		       call  STD_PRINTF 	;an000;print it
		       dec   cx 		;an000;decrease counter
		       add   di,04		;an000;adjust pointer
;	     $enddo				;an000;
	     JMP SHORT $$DO91
$$EN91:

	     call  XM_UNALL_COUNT		;an000;display page status
	     call  XM_HANDLE_COUNT		;an000;display handle status

;	$else
	JMP SHORT $$EN87
$$IF87:
	     call  XM_ERROR			;an000;display the error
;	$endif					;an000;
$$EN87:
	ret					;an000;

XM_CURR_STATUS		endp			;an000;

;=========================================================================
; XM_UNALL_COUNT :	This routine generates a line of the status report
;			displaying the number of pages allocated out of
;			the total possible
;
;	Inputs	 :	none
;
;	Outputs  :	Current status of allocated pages
;			"%1 of a total %2 EMS pages have been allocated"
;
;	Date:	       8/05/86
;=========================================================================

XM_UNALL_COUNT		proc	near		;an000;

	mov	ah,EMS_UNALL_PG_CNT		;an000;see how many pages
						;      remaining
	int	67h				;an000;
	or	ah,ah				;an000;see if error

;	$if	z				;an000;no error
	JNZ $$IF96
		push	bx			;an000;save bx
		push	dx			;an000;save dx
		call	CRLF			;an000;
		pop	dx			;an000;restore dx
		pop	bx			;an000;restore bx
		mov	ax,dx			;an000;total page count
		sub	ax,bx			;an000;get pages allocated
		mov	dg:XM_ALLOC_PG,ax	;an000;save allocated pages
		mov	dg:XM_TOTAL_PG,dx	;an000;save total page count
		mov	dx,offset dg:XM_UNALL_PTR ;an000;"%1 of a total %2 EMS
						;      pages have been allocated",cr,lf
		call	STD_PRINTF		;an000;print it
;	$endif					;an000;
$$IF96:

	ret					;an000;

XM_UNALL_COUNT		endp			;an000;


;=========================================================================
; XM_HANDLE_COUNT:	This routine generates a line of the status report
;			displaying the number of handles allocated out of
;			the total possible.
;
;	Inputs	 :	none
;
;	Outputs  :	Current status of allocated pages
;			"%1 of a total %2 EMS handles have been allocated"
;
;	Date:	       8/05/86
;=========================================================================

XM_HANDLE_COUNT 	proc	near		;an000;

	mov	ah,EMS_HANDLE_CNT		;an000;see how many handles
                  						;      possible
 int 67h                ; C05 - Request total currently allocated.
 or  ah,ah              ; C05 - 
 jnz $$IF98             ; C05 - If error
 mov word ptr dg:XM_HAN_ALLOC,bx ; C05 - save total number of active handles.
 mov ax,EMS_TOT_HANDLES         ; C05 - Request total handles possible for
                                ; C05 - EMS 4.0
	int	67h				;an000;
	or	ah,ah				;an000;see if error

;	$if	z				;an000;no error
	JNZ $$IF98
;C05      		mov	ax,EMS_HANDLE_TOTAL	;an000;total possible handles
  mov ax,bx                     ;C05 - Total possible handles for EMS 4.0

		mov	dg:XM_HAN_TOTAL,ax	;an000;save total page count
;C05      		mov	dg:XM_HAN_ALLOC,bx	;an000;save allocated pages
  mov bx,dg:XM_HAN_ALLOC           ; C05 - This may not be needed.
		mov	dx,offset dg:XM_HAN_ALLOC_PTR
						;an000;"%1 of a total %2 EMS
						;      handles have been allocated",cr,lf
		call	STD_PRINTF		;an000;print it
;	$endif					;an000;
$$IF98:

	ret					;an000;

XM_HANDLE_COUNT 	endp			;an000;


;=========================================================================
; XM_FRAME_SEG	 :	This routine accesses the vector created by
;			function 58h, int 67h.	It obtains a physical
;			page of EMS and its segment from this vector
;
;	Inputs	 :	ES:DI - points to frame buffer
;
;	Outputs  :	XM_PHY - a physical page in EMS
;			XM_FRAME - segment corresponding to the physical page
;
;	Date:	       8/05/86
;=========================================================================


XM_GET_FRAME_SEG	proc	near		;an000;find the frame segment

	mov	al,byte ptr es:[di+2]		;an000;get physical page
	mov	dg:XM_PHY,al			;an000;place in print var
	mov	ax,word ptr es:[di]		;an000;get frame segment
	mov	dg:XM_FRAME,ax			;an000;place in print var

	ret					;an000;

XM_GET_FRAME_SEG	endp			;an000;

;=========================================================================
; XM_INSTALL_CHECK:	This routine performs function 51h, int 67h to
;			determine if EMS is indeed active.
;
;	Inputs	 :	XM_FRAME_BUFFER - used to receive physical page
;					  and segment data for EMS.
;
;	Outputs  :	XM_FRAME_BUFFER - buffer holds physical page
;					  and segment data for EMS.
;
;	Date:	       8/05/86
;=========================================================================

XM_INSTALL_CHECK	proc	near		;an000;see if EMS installed

	MOV	AH,EMS_GET_MAN_STAT		;AN000;GET EMS STATUS
	XOR	AL,AL				;an000;clear low byte
	INT	67h				;an000;
	OR	AH,AH				;an000;check for error
;	$IF	Z				;an000;no error
	JNZ $$IF100
		MOV	AH,EMS_VERSION		;an000;get version number
		INT	67h			;an000;
		CMP	AL,EMS_LIM_40		;an000;LIM 4.0 ?
;		$IF	AE			;an000;4.0 or greater
		JNAE $$IF101
			MOV	AH,00h		;an000;set up for flag pass
			OR	AH,AH		;an000;set flag to ZR
;		$ELSE				;an000;below 4.0
		JMP SHORT $$EN101
$$IF101:
			MOV	AH,01h		;an000;set up for flag pass
			OR	AH,AH		;an000;set flag to NZ
;		$ENDIF				;an000;
$$EN101:
;	$ENDIF					;an000;
$$IF100:

	ret					;an000;

XM_INSTALL_CHECK	endp			;an000;




;=========================================================================
; XM_EMS_DEALL	:	This routine deallocates handles from EMS.
;
;	Inputs	 :	DX - Handle supplied by XM_DEALL_PROMPT
;
;	Outputs  :	Good return - "Handle %1 deallocated"
;			Bad return  - message describing error
;
;	Date:	       8/05/86
;=========================================================================

XM_EMS_DEALL		proc	near		;an000;deallocate EMS pages

	call XM_GET_MAN_STATUS			;an000;see if EMS installed
;	$if  nc 				;an000;error?
	JC $$IF105
	     call XM_DEALL_PROMPT		;an000;prompt user for handle
	     mov  ah,EMS_PAGE_DEALL		;an000;function 45h, int 67h
	     int  67h				;an000;

	     or   ah,ah 			;an000;error?
;	     $if  nz				;an000;yes
	     JZ $$IF106
		  call XM_ERROR 		;an000;say why
;	     $else				;an000;
	     JMP SHORT $$EN106
$$IF106:
		  mov  dx,offset dg:XM_DEALL_PTR;an000;"Handle %1 deallocated"
		  call STD_PRINTF		;an000;print message
;	     $endif				;an000;
$$EN106:
;	$else					;an000;
	JMP SHORT $$EN105
$$IF105:
	     call XM_ERROR			;an000;print type of error
;	$endif					;an000;
$$EN105:

	ret					;an000;

XM_EMS_DEALL		endp			;an000;

;=========================================================================
; XM_DEALL_PROMPT :	This routine prompts the user for the handle to be
;			deallocated.  It converts the handle entered to
;			binary and passes it back to the caller in DX.
;
;	Inputs	 :	none
;
;	Outputs  :	DX - Handle to be deallocated.
;
;	Date:	       8/05/86
;=========================================================================

XM_DEALL_PROMPT 	proc	near		;an000;prompt user for handle
						;      to deallocate
	call SCANB				;an000;see if parm entered
;	$if  nz 				;an000;parm found
	JZ $$IF111
	     mov  cx,04 			;an000;bytes to parse
	     call GETHX 			;an000;get hex value
;	     $if  c				;an000;no an error occurred
	     JNC $$IF112
		  call PERR			;an000;display ^ error
;	     $else				;an000;
	     JMP SHORT $$EN112
$$IF112:
		  mov  dg:XM_DEALL_HAN,dx	;an000;save handle to deallocate
;	     $endif				;an000;
$$EN112:
;	$else					;an000;
	JMP SHORT $$EN111
$$IF111:
	     call PERR				;an000;display ^ error
;	$endif					;an000;
$$EN111:

	ret					;an000;return to caller

XM_DEALL_PROMPT 	endp			;an000;


;=========================================================================
; XM_FRAME_BUFFER	:	This routine obtains the frame buffer
;				of EMS pages.
;
;	Inputs	:	none
;
;	Outputs :	ES:DI - Pointer to frame array
;			CX    - Number of elements in array
;=========================================================================

XM_FRAME_BUFFER 	proc	near		;an000;

	mov	ax,EMS_PG_FRAME 		;an000;get frame buffer
	int	67h				;an000;

	ret					;an000;

XM_FRAME_BUFFER 	endp			;an000;


CODE	ENDS
	END	DEBEMS

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\debcom1.asm ===
PAGE    60,132
	TITLE	DEBCOM1.ASM - PART1 DEBUGGER COMMANDS	PC DOS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DECOM1.asm
;
; DESCRIPTIVE NAME: DEBUGGING TOOL
;
; FUNCTION: PROVIDES USERS WITH A TOOL FOR DEBUGGING PROGRAMS.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; INPUT: NA
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: DEBCOM2 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBCOM3 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBASM  - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBUASM - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBMES  - CONTAINS ROUTINES CALLED BY DEBUG
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT DBCS HANDLING	DMS:6/17/87
;				- IMPLEMENT MESSAGE RETRIEVER	DMS:6/17/87
;				- IMPLEMENT > 32MB SUPPORT	DMS:6/17/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;======================= END OF SPECIFICATIONS ===========================

; Routines to perform debugger commands except ASSEMble and UASSEMble

	IF1
           ;%out COMPONENT=DEBUG, MODULE=DEBCOM1
	ENDIF
.XLIST
.XCREF
	include syscall.inc		; cas -- missing equates
	include version.inc		; cas -- missing equates
	INCLUDE DOSSYM.INC
        INCLUDE debug.inc
.CREF
.LIST

CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
	EXTRN	SYNERR_PTR:BYTE
	EXTRN	DISPB:WORD,DSIZ:BYTE,DSSAVE:WORD
	IF	SYSVER
	    EXTRN   CIN:DWORD,PFLAG:BYTE
	ENDIF
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE
	EXTRN	DEFLEN:WORD,BYTEBUF:BYTE,DEFDUMP:BYTE
	EXTRN	ARG_BUF:BYTE,ARG_BUF_PTR:BYTE
	EXTRN	ONE_CHAR_BUF:BYTE,ONE_CHAR_BUF_PTR:WORD
DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG
	PUBLIC	HEXCHK,GETHEX1,PRINT,DSRANGE,ADDRESS,HEXIN,PERROR
	PUBLIC	GETHEX,GET_ADDRESS,GETEOL,GETHX,PERR
	PUBLIC	PERR,MOVE,DUMP,ENTERDATA,FILL,SEARCH,DEFAULT
ifdef JAPAN
	public	SETDUMPMODE
	extrn	test_lead:near
endif
	IF	SYSVER
	    PUBLIC  IN
	    EXTRN   DISPREG:NEAR,DEVIOCALL:NEAR
	ENDIF
	EXTRN	CRLF:NEAR,OUTDI:NEAR,OUTSI:NEAR,SCANP:NEAR
	EXTRN	SCANB:NEAR,BLANK:NEAR,TAB:NEAR,COMMAND:NEAR
	EXTRN	HEX:NEAR,BACKUP:NEAR
	EXTRN	PRINTF_CRLF:NEAR,HEX_ADDRESS_ONLY:NEAR,HEX_ADDRESS_STR:NEAR
	EXTRN	STD_PRINTF:NEAR
DEBCOM1:
; RANGE - Looks for parameters defining an address range.
; The first parameter is the starting address. The second parameter
; may specify the ending address, or it may be preceded by
; "L" and specify a length (4 digits max), or it may be
; omitted and a length of 128 bytes is assumed. Returns with
; segment in AX, displacement in DX, and length in CX.
DSRANGE:
	MOV	BP,[DSSAVE]		; Set default segment to DS
	MOV	[DEFLEN],128		; And default length to 128 bytes
RANGE:
	CALL	ADDRESS

	PUSH	AX			; Save segment
	PUSH	DX			; Save offset
	CALL	SCANP			; Get to next parameter

	MOV	AL,[SI]
	CMP	AL,UPPER_L		; Length indicator?
	JE	GETLEN

	MOV	DX,[DEFLEN]		; Default length
	CALL	HEXIN			; Second parameter present?

	JC	GETDEF			; If not, use default

	MOV	CX,4
	CALL	GETHEX			; Get ending address (same segment)

	MOV	CX,DX			; Low 16 bits of ending addr.
	POP	DX			; Low 16 bits of starting addr.
	SUB	CX,DX			; Compute range
	JAE	DSRNG2

DSRNG1:
	JMP	PERROR			; Negative range
DSRNG2:
	INC	CX			; Include last location
;	JCXZ	DSRNG1			; Wrap around error
;	Removing this instruction allows 0 FFFF to valid range
	POP	AX			; Restore segment
	RET
GETDEF:
	POP	CX			; get original offset
	PUSH	CX			; save it
	NEG	CX			; rest of segment
	JZ	RNGRET			; use default

	CMP	CX,DX			; more room in segment?
	JAE	RNGRET			; yes, use default

	JMP	short RNGRET1 		; no, length is in CX

GETLEN:
	INC	SI			; Skip over "L" to length
	MOV	CX,4			; Length may have 4 digits
	CALL	GETHEX			; Get the range

RNGRET:
	MOV	CX,DX			; Length
RNGRET1:
	POP	DX			; Offset
	MOV	AX,CX
	ADD	AX,DX
	JNC	OKRET

	CMP	AX,1
	JAE	DSRNG1			; Look for wrap error

OKRET:
	POP	AX			; Segment
	RET
DEFAULT:
; DI points to default address and CX has default length
	CALL	SCANP

	JZ	USEDEF			; Use default if no parameters

	MOV	[DEFLEN],CX
	CALL	RANGE

	JMP	GETEOL

USEDEF:
	MOV	SI,DI
	LODSW				; Get default displacement
	MOV	DX,AX
	LODSW				; Get default segment
	RET

ifdef JAPAN
;
;	Set Dump mode to Kanji or Ascii
;
dump_mode	db	0
dbcs_flag	db	0
dbcs_adj	db	0

SETDUMPMODE:
	call	scanp			; get parameter
	jz	dm_err			; if none
	lodsb
	cmp	al,'K'			; is it for Kanji mode
	jnz	@f			; no
	call	geteol
	mov	cs:dump_mode,1		; set Kanji mode
	jmp	short dm_ret
@@:
	cmp	al,'A'			; is it for Ascii mode
	jnz	@f			; no
	call	geteol
	mov	cs:dump_mode,0		; set Ascii mode
	jmp	short dm_ret
@@:
dm_err:
	jmp	PERR
dm_ret:
	ret
endif

; Dump an area of memory in both hex and ASCII
DUMP:
ifdef JAPAN
	mov	cs:dbcs_flag,0
	mov	cs:dbcs_adj,0
endif

	MOV	BP,[DSSAVE]
	MOV	CX,DISPB
	MOV	DI,OFFSET DG:DEFDUMP
	CALL	DEFAULT 		; Get range if specified

	MOV	DS,AX			; Set segment
	ASSUME	DS:NOTHING

	MOV	SI,DX			; SI has displacement in segment
	PUSH	SI			; save SI away
	MOV	AL,DSIZ
	XOR	AH,AH
	XOR	AX,-1
	AND	SI,AX			; convert to para number
	MOV	DI,OFFSET DG:ARG_BUF	; Build the output str in arg_buf
	CALL	OUTSI			; display location

	POP	SI			; get SI back
; Determine where the registers display should begin.
	MOV	AX,SI			; move offset
	MOV	AH,3			; spaces per byte
	AND	AL,DSIZ 		; convert to real offset
	MUL	AH			; 3 char positions per byte of output
	OR	AL,AL			; at beginning?
	JZ	INROW			; if so, then no movement.

	PUSH	CX
	MOV	CX,AX
	CALL	TAB

	POP	CX
INROW:
	PUSH	SI			; Save address for ASCII dump
BYTE0:
	CALL	BLANK			; Space between bytes
BYTE1:
	LODSB				; Get byte to dump
	CALL	HEX			; and display it

	POP	DX			; DX has start addr. for ASCII dump
	DEC	CX			; Drop loop count
	JZ	ASCII			; If through do ASCII dump

	MOV	AX,SI
	TEST	AL,DSIZ 		; On row boundary?
	JZ	ENDROW

	PUSH	DX			; Didn't need ASCII addr. yet
	TEST	AL,7			; On 8-byte boundary?
	JNZ	BYTE0

	MOV	AL,CHAR_MINUS		; Mark every 8 bytes with "-"
	STOSB
	JMP	SHORT BYTE1

ENDROW:
	CALL	ASCII			; Show it in ASCII

	MOV	DI,OFFSET DG:ARG_BUF	; Build the output str in arg_buf
	CALL	OUTSI			; Get the address at start of line

	JMP	INROW			; Loop until count is zero

; Produce a dump of the ascii text characters.	We take the current SI which
; contains the byte after the last one dumped.	From this we determine how
; many spaces we need to output to get to the ascii column.  Then we look at
; the beginning address of the dump to tsee how many spaces we need to indent.
ASCII:
	PUSH	CX			; Save count of remaining bytes
; Determine how many spaces to go until the ASCII column.
	MOV	AX,SI			; get offset of next byte
	DEC	AL
	AND	AL,DSIZ
	INC	AL
; AX now has the number of bytes that we have displayed:  1 to Dsiz+1.
; Compute characters remaining to be displayed.  We *always* put the ASCII
; dump in column 51 (or whereever)
	SUB	AL,10H			; get negative of number
	DEC	AL			;
	NEG	AL			; convert to positive
	CBW				; convert to word
; 3 character positions for each byte displayed.
	MOV	CX,AX
	SHL	AX,1
	ADD	CX,AX
; Compute indent for ascii dump
	MOV	AX,DX
	AND	AL,DSIZ
	XOR	AH,AH
	ADD	CX,AX
; Tab over
	CALL	TAB

; Set up for true dump
	MOV	CX,SI
	MOV	SI,DX
	SUB	CX,SI
ASCDMP:
	LODSB				; Get ASCII byte to dump

ifdef JAPAN
	cmp	cs:dbcs_flag,1
	jz	set_dbcs		; if it was lead byte
	cmp	cs:dbcs_flag,2
	jnz	@f			; if it was not tail byte
	mov	cs:dbcs_flag,0		; reset
@@:
	call	test_lead
	jnc	@f			; if this is not lead byte
	cmp	byte ptr [si],CHAR_BLANK
	jae	set_dbcs		; if tail byte is not control corde
	mov	al,CHAR_PERIOD
	jmp	short @f
set_dbcs:
	inc	cs:dbcs_flag
@@:
	cmp	cs:dump_mode,1
	jnz	@f			; if not Kanji mode
	cmp	cs:dbcs_adj,1
	jnz	kanjiprt		; if no need to adjust
	mov	al,' '			; tail byte is displayed already
	mov	cs:dbcs_adj,0
	jmp	short kanjiprt
@@:
endif

	CMP	AL,CHAR_RUBOUT
	JAE	NOPRT			; Don't print RUBOUT or above

ifdef JAPAN
kanjiprt:
endif

	CMP	AL,CHAR_BLANK
	JAE	PRIN			; print space through RUBOUT-1

NOPRT:
	MOV	AL,CHAR_PERIOD		; If unprintable character
PRIN:
	STOSB
	LOOP	ASCDMP			; CX times

ifdef JAPAN
	cmp	cs:dump_mode,1
	jnz	@f			; if not Kanji mode
	cmp	cs:dbcs_flag,1
	jnz	@f			; if not ended with lead byte
	mov	al,[si]			; get tail byte
	stosb
	mov	cs:dbcs_adj,1
@@:
endif

	MOV	AL,0
	STOSB
	PUSH	DS
	PUSH	CS
	POP	DS
	ASSUME	DS:DG

	CALL	HEX_ADDRESS_STR

	CALL	CRLF

	POP	DS
	ASSUME	DS:NOTHING

	POP	CX			; Restore overall dump len
	MOV	WORD PTR [DEFDUMP],SI
	MOV	WORD PTR [DEFDUMP+WORD],DS ; Save last address as def
	RET

	ASSUME	DS:DG
; Block move one area of memory to another Overlapping moves are performed
; correctly, i.e., so that a source byte is not overwritten until after it has
; been moved.
MOVE:
	CALL	DSRANGE 		; Get range of source area

	PUSH	CX			; Save length
	PUSH	AX			; Save segment
	PUSH	DX			; Save source displacement
	CALL	ADDRESS 		; Get destination address (sam

	CALL	GETEOL			; Check for errors

	POP	SI
	MOV	DI,DX			; Set dest. displacement
	POP	BX			; Source segment
	MOV	DS,BX
	MOV	ES,AX			; Destination segment
	POP	CX			; Length
	CMP	DI,SI			; Check direction of move
	SBB	AX,BX			; Extend the CMP to 32 bits
	JB	COPYLIST		; Move forward into lower mem.

; Otherwise, move backward. Figure end of source and destination
; areas and flip direction flag.
	DEC	CX
	ADD	SI,CX			; End of source area
	ADD	DI,CX			; End of destination area
	STD				; Reverse direction
	INC	CX
COPYLIST:
	MOVSB				; Do at least 1 - Range is 1-1
	DEC	CX
	REP	MOVSB			; Block move
RET1:
	RET

; Fill an area of memory with a list values. If the list
; is bigger than the area, don't use the whole list. If the
; list is smaller, repeat it as many times as necessary.
FILL:
	CALL	DSRANGE 		; Get range to fill

	PUSH	CX			; Save length
	PUSH	AX			; Save segment number
	PUSH	DX			; Save displacement
	CALL	LIST			; Get list of values to fill w

	POP	DI			; Displacement in segment
	POP	ES			; Segment
	POP	CX			; Length
	CMP	BX,CX			; BX is length of fill list
	MOV	SI,OFFSET DG:BYTEBUF	; List is in byte buffer
	JCXZ	BIGRNG

	JAE	COPYLIST		; If list is big, copy part of

BIGRNG:
	SUB	CX,BX			; How much bigger is area than
	XCHG	CX,BX			; CX=length of list
	PUSH	DI			; Save starting addr. of area
	REP	MOVSB			; Move list into area
	POP	SI
; The list has been copied into the beginning of the
; specified area of memory. SI is the first address
; of that area, DI is the end of the copy of the list
; plus one, which is where the list will begin to repeat.
; All we need to do now is copy [SI] to [DI] until the
; end of the memory area is reached. This will cause the
; list to repeat as many times as necessary.
	MOV	CX,BX			; Length of area minus list
	PUSH	ES			; Different index register
	POP	DS			; requires different segment r
	JMP	SHORT COPYLIST		; Do the block move

; Search a specified area of memory for given list of bytes.
; Print address of first byte of each match.
SEARCH:
	CALL	DSRANGE 		; Get area to be searched

	PUSH	CX			; Save count
	PUSH	AX			; Save segment number
	PUSH	DX			; Save displacement
	CALL	LIST			; Get search list

	DEC	BX			; No. of bytes in list-1
	POP	DI			; Displacement within segment
	POP	ES			; Segment
	POP	CX			; Length to be searched
	SUB	CX,BX			;  minus length of list
SCAN:
	MOV	SI,OFFSET DG:BYTEBUF	; List kept in byte buffer
	LODSB				; Bring first byte into AL
DOSCAN:
	SCASB				; Search for first byte
	LOOPNE	DOSCAN			; Do at least once by using LO

	JNZ	RET1			; Exit if not found

	PUSH	BX			; Length of list minus 1
	XCHG	BX,CX
	PUSH	DI			; Will resume search here
	REPE	CMPSB			; Compare rest of string
	MOV	CX,BX			; Area length back in CX
	POP	DI			; Next search location
	POP	BX			; Restore list length
	JNZ	TTEST			 ; Continue search if no match

	DEC	DI			; Match address
	CALL	OUTDI			; Print it

	INC	DI			; Restore search address
	CALL	HEX_ADDRESS_ONLY	; Print the addresss

	CALL	CRLF

TTEST:
	JCXZ	RET1

	JMP	SHORT SCAN		; Look for next occurrence

; Get the next parameter, which must be a hex number.
; CX is maximum number of digits the number may have.

;=========================================================================
; GETHX: This routine calculates the binary representation of an address
;	 entered in ASCII by a user.  GETHX has been modified to provide
;	 support for sector addresses > 32mb.  To do this the bx register
;	 has been added to provide a 32 bit address.  BX is the high word
;	 and DX is the low word.  For routines that rely on DX for a 16
;	 bit address, the use of BX will have no effect.
;
;	Date	   : 6/16/87
;=========================================================================

GETHX:
	CALL	SCANP
GETHX1:
	XOR	DX,DX			; Initialize the number
	xor	bx,bx			;an000;initialize high word for
					;      sector address
	CALL	HEXIN			; Get a hex digit

	JC	HXERR			; Must be one valid digit

	MOV	DL,AL			; First 4 bits in position
GETLP:
	INC	SI			; Next char in buffer
	DEC	CX			; Digit count
	CALL	HEXIN			; Get another hex digit?

	JC	RETHX			; All done if no more digits

	STC
	JCXZ	HXERR			; Too many digits?


	call	ADDRESS_32_BIT		;an000;multiply by 32
	JMP	SHORT GETLP		; Get more digits

GETHEX:
	CALL	GETHX			; Scan to next parameter

	JMP	SHORT GETHX2

GETHEX1:
	CALL	GETHX1
GETHX2:
	JC	PERROR
RETHX:
	CLC
HXERR:
	RET

; Check if next character in the input buffer is a hex digit
; and convert it to binary if it is. Carry set if not.
HEXIN:
	MOV	AL,[SI]
; Check if AL  is a hex digit and convert it to binary if it
; is. Carry set if not.
HEXCHK:
	SUB	AL,CHAR_ZERO		; Kill ASCII numeric bias
	JC	RET2

	CMP	AL,10
	CMC
	JNC	RET2			; OK if 0-9

	AND	AL,5FH
	SUB	AL,7			; Kill A-F bias
	CMP	AL,10
	JC	RET2

	CMP	AL,16
	CMC
RET2:
	RET

; Process one parameter when a list of bytes is
; required. Carry set if parameter bad. Called by LIST.
LISTITEM:
	CALL	SCANP			; Scan to parameter

	CALL	HEXIN			; Is it in hex?

	JC	STRINGCHK		; If not, could be a string

	MOV	CX,2			; Only 2 hex digits for bytes
	push	bx			;an000;save it - we stomp it
	CALL	GETHEX			; Get the byte value
	pop	bx			;an000;restore it

	MOV	[BX],DL 		; Add to list
	INC	BX
GRET:
	CLC				; Parameter was OK
	RET

STRINGCHK:
	MOV	AL,[SI] 		; Get first character of param
	CMP	AL,SINGLE_QUOTE 	; String?
	JZ	STRING

	CMP	AL,DOUBLE_QUOTE 	; Either quote is all right
	JZ	STRING

	STC				; Not string, not hex - bad
	RET
STRING:
	MOV	AH,AL			; Save for closing quote
	INC	SI
STRNGLP:
	LODSB				; Next char of string
	CMP	AL,CR			; Check for end of line
	JZ	PERR			; Must find a close quote

	CMP	AL,AH			; Check for close quote
	JNZ	STOSTRG 		; Add new character to list

	CMP	AH,[SI] 		; Two quotes in a row?
	JNZ	GRET			; If not, we're done

	INC	SI			; Yes - skip second one
STOSTRG:
	MOV	[BX],AL 		; Put new char in list
	INC	BX
	JMP	SHORT STRNGLP		; Get more characters

; Get a byte list for ENTER, FILL or SEARCH. Accepts any number
; of 2-digit hex values or character strings in either single
; (') or double (") quotes.
LIST:
	MOV	BX,OFFSET DG:BYTEBUF	; Put byte list in the byte buffer
LISTLP:
	CALL	LISTITEM		; Process a parameter

	JNC	LISTLP			; If OK, try for more

	SUB	BX,OFFSET DG:BYTEBUF	; BX now has no. of bytes in list
	JZ	PERROR			; List must not be empty

; Make sure there is nothing more on the line except for
; blanks and carriage return. If there is, it is an
; unrecognized parameter and an error.
GETEOL:
	CALL	SCANB			; Skip blanks

	JNZ	PERROR			; Better be a RETURN
RET3:
	RET

; Command error.  SI has been incremented beyond the command letter so it must
; decremented for the error pointer to work.
PERR:
	DEC	SI
; Syntax error.  SI points to character in the input buffer which caused
; error.  By subtracting from start of buffer, we will know how far to tab
; over to appear directly below it on the terminal.  Then print "^ Error".
PERROR:
	SUB	SI,OFFSET DG:(BYTEBUF-1) ; How many char processed so far?
	MOV	CX,SI			; Parameter for TAB in CX
	MOV	DI,OFFSET DG:ARG_BUF	;
	CALL	TAB			; Directly below bad char

	MOV	BYTE PTR [DI],0 	; nul terminate the tab
	MOV	DX,OFFSET DG:SYNERR_PTR ; Error message
; Print error message and abort to command level
PRINT:
	CALL	PRINTF_CRLF

	JMP	COMMAND

; Gets an address in Segment:Displacement format. Segment may be omitted
; and a default (kept in BP) will be used, or it may be a segment
; register (DS, ES, SS, CS). Returns with segment in AX, OFFSET in DX.
ADDRESS:
	CALL	GET_ADDRESS

	JC	PERROR

ADRERR:
	STC
	RET

GET_ADDRESS:
	CALL	SCANP

	MOV	AL,[SI+1]
	CMP	AL,UPPER_S
	JZ	SEGREG

	MOV	CX,4
	CALL	GETHX

	JC	ADRERR

	MOV	AX,BP			; Get default segment
	CMP	BYTE PTR [SI],CHAR_COLON
	JNZ	GETRET

	PUSH	DX
GETDISP:
	INC	SI			; Skip over ":"
	MOV	CX,4
	CALL	GETHX

	POP	AX
	JC	ADRERR

GETRET:
	CLC
	RET

SEGREG:
	MOV	AL,[SI]
	MOV	DI,OFFSET DG:SEGLET	; SEGLET  DB  "CSED"
	MOV	CX,4
	REPNE	SCASB
	JNZ	ADRERR

	INC	SI
	INC	SI
	SHL	CX,1
	MOV	BX,CX
	CMP	BYTE PTR [SI],CHAR_COLON
	JNZ	ADRERR

	PUSH	[BX+DSSAVE]
	JMP	SHORT GETDISP

SEGLET	DB	"CSED"			; First letter of each of the segregs: CS,SS,ES,DS

; Short form of ENTER command. A list of values from the
; command line are put into memory without using normal
; ENTER mode.
GETLIST:
	CALL	LIST			; Get the bytes to enter

	POP	DI			; Displacement within segment
	POP	ES			; Segment to enter into
	MOV	SI,OFFSET DG:BYTEBUF	; List of bytes is in byte buffer
	MOV	CX,BX			; Count of bytes
	REP	MOVSB			; Enter that byte list
	RET

; Enter values into memory at a specified address.  If the line contains
; nothing but the address we go into "enter mode", where the address and its
; current value are printed and the user may change it if desired.  To change,
; type in new value in hex.  Backspace works to correct errors.  If an illegal
; hex digit or too many digits are typed, the bell is sounded but it is
; otherwise ignored.  To go to the next byte (with or without change), hit
; space bar.  To back CLDto a previous address, type "-".  On every 8-byte
; boundary a new line is started and the address is printed.  To terminate
; command, type carriage return.
;  Alternatively, the list of bytes to be entered may be included on the
; original command line immediately following the address.  This is in regular
; LIST format so any number of hex values or strings in quotes may be entered.
ENTERDATA:
	MOV	BP,[DSSAVE]		; Set default segment to DS
	CALL	ADDRESS

	PUSH	AX			; Save for later
	PUSH	DX
	CALL	SCANB			; Any more parameters?

	JNZ	GETLIST 		; If not end-of-line get list

	POP	DI			; Displacement of ENTER
	POP	ES			; Segment
GETROW:
	CALL	OUTDI			; Print address of entry

	PUSH	DI
	PUSH	ES
	PUSH	DS
	POP	ES
	MOV	DI,OFFSET DG:ARG_BUF
	CALL	BLANK

	XOR	AL,AL
	STOSB
	CALL	HEX_ADDRESS_STR

	POP	ES
	POP	DI
GETBYTE:
	MOV	AL,ES:[DI]		; Get current value
	PUSH	DI
	PUSH	ES
	PUSH	DS
	POP	ES
	MOV	DI,OFFSET DG:ARG_BUF
	CALL	HEX			; And display it

	MOV	AL,CHAR_PERIOD
	STOSB
	XOR	AL,AL
	STOSB
	MOV	DX,OFFSET DG:ARG_BUF_PTR
	CALL	STD_PRINTF

	POP	ES
	POP	DI
LOOK_AGAIN:
	MOV	CX,2			; Max of 2 digits in new value
	MOV	DX,0			; Intial new value
GETDIG:
	CALL	INPT			; Get digit from user

	MOV	AH,AL			; Save
	CALL	HEXCHK			; Hex digit?

	XCHG	AH,AL			; Need original for echo
	JC	NOHEX			; If not, try special command

	MOV	DH,DL			; Rotate new value
	MOV	DL,AH			; And include new digit
	LOOP	GETDIG			; At most 2 digits

; We have two digits, so all we will accept now is a command.
DWAIT:
	CALL	INPT			; Get command character
NOHEX:
	CMP	AL,CHAR_BACKSPACE	; Backspace
	JZ	BS

	CMP	AL,CHAR_RUBOUT		; RUBOUT
	JZ	RUB

	CMP	AL,CHAR_MINUS		; Back up to previous address
	JZ	PREV

	CMP	AL,CR			; All done with command?
	JZ	EOL

	CMP	AL,CHAR_BLANK		; Go to next address
	JZ	NEXT

	MOV	AL,CHAR_BACKSPACE
	CALL	OUT_CHAR		; Back up over illegal character

	CALL	BACKUP

	JCXZ	DWAIT

	JMP	SHORT GETDIG

RUB:
	MOV	AL,CHAR_BACKSPACE
	CALL	OUT_char
BS:
	CMP	CL,2			; CX=2 means nothing typed yet
	JZ	PUTDOT			; Put back the dot we backed up over

	INC	CL			; Accept one more character
	MOV	DL,DH			; Rotate out last digit
	MOV	DH,CH			; Zero this digit
	CALL	BACKUP			; Physical backspace

	JMP	SHORT GETDIG		; Get more digits

PUTDOT:
	MOV	AL,CHAR_PERIOD
	CALL	OUT_CHAR

	JMP	LOOK_AGAIN

; If new value has been entered, convert it to binary and
; put into memory. Always bump pointer to next location
STORE:
	CMP	CL,2			; CX=2 means nothing typed yet
	JZ	NOSTO			; So no new value to store

; Rotate DH left 4 bits to combine with DL and make a byte value
	PUSH	CX
	MOV	CL,4
	SHL	DH,CL
	POP	CX
	OR	DL,DH			; Hex is now converted to binary
	MOV	ES:[DI],DL		; Store new value
NOSTO:
	INC	DI			; Prepare for next location
	RET

NEXT:
	CALL	STORE			; Enter new value

	INC	CX			; Leave a space plus two for
	INC	CX			;  each digit not entered
	PUSH	DI
	MOV	DI,OFFSET DG:ARG_BUF
	PUSH	ES
	PUSH	DS
	POP	ES
	CALL	TAB

	XOR	AL,AL
	STOSB
	MOV	DX,OFFSET DG:ARG_BUF_PTR
	CALL	STD_PRINTF

	POP	ES
	POP	DI
	MOV	AX,DI			; Next memory address
	AND	AL,7			; Check for 8-byte boundary
	JZ	NEWROW			; Take 8 per line

	JMP	GETBYTE

NEWROW:
	CALL	CRLF			; Terminate line

	JMP	GETROW			; Print address on new line

PREV:
	CALL	STORE			; Enter the new value

; DI has been bumped to next byte. Drop it 2 to go to previous addr
	DEC	DI
	DEC	DI
	JMP	SHORT NEWROW		; Terminate line after backing	 CLD

EOL:
	CALL	STORE			; Enter the new value

	JMP	CRLF			; CR/LF and terminate

; Console input of single character
	IF	SYSVER
INPT:					  ;*** change for build - label to inpt
	    PUSH    DS
	    PUSH    SI
	    LDS     SI,CS:[CIN]
	    MOV     AH,4
	    CALL    DEVIOCALL

	    POP     SI
	    POP     DS
	    CMP     AL,3
	    JNZ     NOTCNTC

	    INT     VEC_CTRL_BREAK	;23H

NOTCNTC:
	    CMP     AL,UPPER_P - CHAR_AT_SIGN
	    JZ	    PRINTON

	    CMP     AL,UPPER_N - CHAR_AT_SIGN
	    JZ	    PRINTOFF

	    CALL    OUT_CHAR

	    RET

PRINTOFF:
PRINTON:
	    NOT     [PFLAG]
	    JMP     SHORT IN

	ELSE
INPT:				; Change label for build
	    MOV     AH,Std_Con_Input ;OPTION=1, STANDARD CONSOLE INPUT
	    INT     21H

	    RET

	ENDIF
OUT_CHAR:
	PUSH	DI
	PUSH	DX
	PUSH	ES
	PUSH	DS
	POP	ES
	MOV	DI,OFFSET DG:ONE_CHAR_BUF
	STOSB
	MOV	AL,0
	STOSB
	MOV	DX,OFFSET DG:ONE_CHAR_BUF_PTR
	CALL	STD_PRINTF

	POP	ES
	POP	DX
	POP	DI
	RET

;=========================================================================
; ADDRESS_32_BIT: This routine will build an address for 32bit sector
;		  addressibility.  BX will be the high word, with DX being
;		  the low word.
;
;	Inputs : DX/BX - registers to contain 32bit sector address
;		 DX & BX are both initialized to 0 on first call to routine.
;
;	Outputs: DX/BX - registers to contain 32bit sector address
;
;	Date	  : 6/16/87
;=========================================================================

ADDRESS_32_BIT	proc	near			;an000;perform 32 bit address
						;      creation
	push	cx				;an000;save affected regs.
	mov	cx,04h				;an000;initialize to
						;      nibble shift
;	$do					;an000;while cx not= 0
$$DO1:
		cmp	cx,00h			;an000;are we done?
;		$leave	e			;an000;yes, quit loop
		JE $$EN1
		shl	bx,1			;an000;shift bx 1 bit
		shl	dx,1			;an000;shift dx 1 bit
;		$if	c			;an000;did low word carry
		JNC $$IF3
			or	bx,01h		;an000;set bit 0 of high word
;		$endif				;an000;
$$IF3:
		dec	cx			;an000;decrease counter
;	$enddo					;an000;end while loop
	JMP SHORT $$DO1
$$EN1:
	or	dl,	al			;an000;overlay low word
						;      bits 0-3 with next
						;      portion of the address
	pop	cx				;an000;restore affected regs.

	ret					;an000;return to caller

ADDRESS_32_BIT	endp				;an000;end proc



CODE	ENDS
	END	DEBCOM1

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\sysver.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


		   IF1
                       %OUT Including ..SYSVER.FAL..
		   ENDIF

SYSVER		   EQU	FALSE		; if true, i/o direct to bios
					; so DOS can be debugged


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\debuasm.asm ===
PAGE    80,132 ;
	   TITLE DEBUASM.ASM
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; Code for the UASSEMble command in the debugger

	    IF1
		%OUT COMPONENT=DEBUG, MODULE=DEBUASM
	    ENDIF
.XLIST
.XCREF
	   include version.inc		; cas -- missing equates
	   INCLUDE DOSSYM.INC
           INCLUDE debug.inc
.CREF
.LIST
CODE	   SEGMENT PUBLIC BYTE
CODE	   ENDS

CONST	   SEGMENT PUBLIC BYTE
	   EXTRN SYNERR_PTR:BYTE,UNASSEM_LN_PTR:WORD
	   EXTRN NSEG:WORD,SISAVE:WORD,BPSAVE:WORD,DISAVE:WORD
	   EXTRN BXSAVE:WORD,DSSAVE:WORD,ESSAVE:WORD,CSSAVE:WORD,IPSAVE:WORD
	   EXTRN SSSAVE:WORD,CXSAVE:WORD,SPSAVE:WORD,FLSAVE:WORD
	   EXTRN DISTAB:WORD,SHFTAB:WORD,IMMTAB:WORD,GRP1TAB:WORD,GRP2TAB:WORD
	   EXTRN DBMN:BYTE,ESCMN:BYTE,DISPB:WORD,STACK:BYTE,REG8:BYTE
	   EXTRN REG16:BYTE,SREG:BYTE,SIZ8:BYTE,SEGTAB:WORD,M8087_TAB:BYTE
	   EXTRN FI_TAB:BYTE,SIZE_TAB:BYTE,MD9_TAB:BYTE,MD9_TAB2:BYTE
	   EXTRN MDB_TAB:BYTE,MDB_TAB2:BYTE,MDD_TAB:BYTE,MDD_TAB2:BYTE
	   EXTRN MDF_TAB:BYTE
CONST	   ENDS

CSTACK	   SEGMENT STACK
CSTACK	   ENDS

DATA	   SEGMENT PUBLIC BYTE
	   EXTRN DISADD:BYTE,DISCNT:WORD,BYTCNT:BYTE,TEMP:BYTE,AWORD:BYTE
	   EXTRN MIDFLD:BYTE,MODE:BYTE,REGMEM:BYTE,OPCODE:WORD,OPBUF:BYTE
	   EXTRN INDEX:WORD,ARG_BUF:BYTE,ARG_BUF_PTR:BYTE,ARG_BUF_INDEX:WORD
	   EXTRN OPBUF:BYTE,OPCODE:WORD
DATA	   ENDS

DG	   GROUP CODE,CONST,CSTACK,DATA

CODE	   SEGMENT PUBLIC BYTE
	   ASSUME CS:DG,DS:DG,ES:DG,SS:DG

	   PUBLIC UNASSEM
	   PUBLIC DISASLN,MEMIMM,JMPCALL,SIGNIMM,ALUFROMREG,WORDTOALU
	   PUBLIC GRP2,PREFIX,OUTVARW,GRP1,SSPRE,MOVSEGTO,DSPRE,SHIFT
	   PUBLIC ESPRE,IMMED,CSPRE,OUTVARB,CHK10,ACCIMM,INT3,INVARB
	   PUBLIC MOVSEGFROM,LOADACC,OUTFIXB,XCHGAX,REGIMMW,SHORTJMP
	   PUBLIC SAV8,M8087,M8087_DB,M8087_DF,M8087_D9,M8087_DD
	   PUBLIC SAV16,SAVHEX,INFIXW,REGIMMB,OUTFIXW,SHIFTV,LONGJMP
	   PUBLIC INVARW,STOREACC,INFIXB,NOOPERANDS,ALUTOREG
	   PUBLIC SEGOP,REGOP,GETADDR

	   EXTRN CRLF:NEAR,BLANK:NEAR,TAB:NEAR,STD_PRINTF:NEAR
	   EXTRN HEX:NEAR,DEFAULT:NEAR,OUTSI:NEAR,OUTDI:NEAR
	   EXTRN HEX_ADDRESS_ONLY:NEAR

UNASSEM:
	   MOV	BP,[CSSAVE]		; Default code segment
	   MOV	DI,OFFSET DG:DISADD	; Default address
	   MOV	CX,DISPB		; Default length
	   SHR	CX,1
	   SHR	CX,1
	   CALL DEFAULT
	   MOV	WORD PTR [DISADD],DX	; Displacement of disassembly
	   MOV	WORD PTR [DISADD+2],AX	; Segment
	   MOV	WORD PTR [DISCNT],CX	; No. of bytes (but whole instructions)
DISLP:
	   CALL DISASLN 		; Disassemble one line
	   CALL CRLF
	   TEST [DISCNT],-1		; See if we've used up the range
	   JNZ	DISLP
	   RET

GOTDIS:
	   PUSH DS			; RE-GET LAST BYTE
	   PUSH SI
	   LDS	SI,DWORD PTR [DISADD]
	   MOV	AL,[SI-1]
	   POP	SI
	   POP	DS
	   RET

GETDIS:
	   PUSH DS
	   LDS	SI,DWORD PTR [DISADD]
	   LODSB			; Get the next byte of code
	   POP	DS
	   MOV	WORD PTR [DISADD],SI	; Update pointer
	   PUSH AX
	   PUSH DI
	   MOV	DI,[ARG_BUF_INDEX]
	   CALL HEX			; Display each code byte
	   MOV	[ARG_BUF_INDEX],DI
	   POP	DI
	   MOV	SI,[DISCNT]
	   OR	SI,SI			; Check if range exhausted
	   JZ	ENDRNG			; If so, don't wrap around
	   DEC	SI			; Count off the bytes
	   MOV	[DISCNT],SI
ENDRNG:
	   INC	BYTE PTR[BYTCNT]	; Keep track of no. of bytes per line
	   POP	AX
	   RET

DSPRE:
	   INC	BYTE PTR [NSEG+1]
SSPRE:
	   INC	BYTE PTR [NSEG+1]
CSPRE:
	   INC	BYTE PTR [NSEG+1]
ESPRE:
	   INC	BYTE PTR [NSEG+1]

PREFIX:
	   POP	BX			; Dump off return address
	   CALL FINLN
	   CALL CRLF
DISASLN:
	   PUSH DS
	   LDS	SI,DWORD PTR [DISADD]
	   CALL OUTSI			; Show disassembly address
	   POP	DS
	   CALL HEX_ADDRESS_ONLY
DISASLN1:
	   MOV	BYTE PTR [BYTCNT],0	; Count of code bytes per line
; Fill overflow area with zeros
	   MOV	DI,OFFSET DG:OPBUF
	   MOV	CX,50
	   MOV	AL,0
	   REP	STOSB
; fill buffer with spaces
	   MOV	DI,OFFSET DG:OPBUF
	   MOV	CX,OPBUFLEN
	   MOV	AL," "
	   REP	STOSB
	   MOV	DI,OFFSET DG:ARG_BUF
	   MOV	[ARG_BUF_INDEX],DI
	   CALL GETDIS			; Get opcode
	   MOV	DI,[ARG_BUF_INDEX]
	   MOV	AH,0
	   MOV	BX,AX
	   AND	AL,1			; Mask to "W" bit
	   MOV	[AWORD],AL
	   MOV	AL,BL			; Restore opcode
	   SHL	BX,1
	   SHL	BX,1			; Multiply opcode by 4
	   ADD	BX,OFFSET DG:DISTAB
	   MOV	DX,[BX] 		; Get pointer to mnemonic from table
	   MOV	[OPCODE],DX
	   MOV	[ARG_BUF_INDEX],DI
	   MOV	DI,OFFSET DG:OPBUF
	   CALL WORD PTR [BX+2]
FINLN:
	   MOV	AH,[BYTCNT]		; See how many bytes in this instruction
	   ADD	AH,AH			; Each uses two characters
	   MOV	AL,14			; Amount of space we want to use
	   SUB	AL,AH			; See how many fill characters needed
	   CBW
	   XCHG CX,AX			; Parameter for TAB needed in CX
	   MOV	DI,[ARG_BUF_INDEX]
	   CALL TAB
	   MOV	SI,[OPCODE]
	   OR	SI,SI
	   JZ	GET_TAB
GET_OPCODE:
	   LODSB
	   OR	AL,AL
	   JZ	GET_TAB
	   STOSB
	   JMP	GET_OPCODE

GET_TAB:
	   MOV	AL,9
	   STOSB
	   MOV	BYTE PTR [DI],0 	; nul terminate address buffer
	   MOV	DX,OFFSET DG:UNASSEM_LN_PTR
	   CALL STD_PRINTF
	   RET

GETMODE:
	   CALL GETDIS			; Get the address mode byte
	   MOV	AH,AL
	   AND	AL,7			; Mask to "r/m" field
	   MOV	[REGMEM],AL
	   SHR	AH,1
	   SHR	AH,1
	   SHR	AH,1
	   MOV	AL,AH
	   AND	AL,7			; Mask to center 3-bit field
	   MOV	[MIDFLD],AL
	   SHR	AH,1
	   SHR	AH,1
	   SHR	AH,1
	   MOV	[MODE],AH		; Leaving 2-bit "MOD" field
	   RET

IMMED:
	   MOV	BX,OFFSET DG:IMMTAB
	   CALL GETMNE
FINIMM:
	   CALL TESTREG
	   JMP	SHORT IMM

MEMIMM:
	   CALL GETMODE
	   JMP	SHORT FINIMM

ACCIMM:
	   XOR	AL,AL
IMM1:
	   CALL SAVREG
IMM:
	   MOV	AL,","
	   STOSB
	   TEST BYTE PTR [AWORD],-1
	   JNZ	SAV16
SAV8:
	   CALL GETDIS
	   JMP	SHORT SAVHEX

LONGJMP:
	   PUSH DI
	   MOV	DI,OFFSET DG:TEMP
	   CALL SAV16
	   POP	DI
	   CALL SAV16
	   MOV	AL,":"
	   STOSB
	   MOV	SI,OFFSET DG:TEMP
	   MOV	CX,4
MOVDIG:
	   LODSB
	   STOSB
	   LOOP MOVDIG
	   RET

SAV16:
	   CALL GETDIS			; Get low byte
	   MOV	DL,AL
	   CALL GETDIS			; Get high byte
	   MOV	DH,AL
	   CALL SAVHEX			; Convert and store high byte
	   MOV	AL,DL
SAVHEX:
	   MOV	AH,AL
	   SHR	AL,1
	   SHR	AL,1
	   SHR	AL,1
	   SHR	AL,1
	   CALL SAVDIG
	   MOV	AL,AH
SAVDIG:
	   AND	AL,0FH
	   ADD	AL,90H
	   DAA
	   ADC	AL,40H
	   DAA
	   STOSB
	   RET

CHK10:
	   CALL GETDIS
	   CMP	AL,10
	   JNZ	SAVHEX
	   RET

SIGNIMM:
	   MOV	BX,OFFSET DG:IMMTAB
	   CALL GETMNE
	   CALL TESTREG
	   MOV	AL,","
	   STOSB
SAVD8:
	   CALL GETDIS			; Get signed 8-bit number
	   CBW
	   MOV	DX,AX			; Save true 16-bit value in DX
	   MOV	AH,AL
	   MOV	AL,"+"
	   OR	AH,AH
;	JZ	NOSIGN
	   JNS	POSITIV 		; OK if positive
	   MOV	AL,"-"
	   NEG	AH			; Get magnitude if negative
POSITIV:
	   STOSB
; NOSIGN:
	   MOV	AL,AH
	   JMP	SHORT SAVHEX

ALUFROMREG:
	   CALL GETADDR
	   MOV	AL,","
	   STOSB
REGFLD:
	   MOV	AL,[MIDFLD]
SAVREG:
	   MOV	SI,OFFSET DG:REG8
	   CMP	BYTE PTR [AWORD],1
	   JNE	FNDREG
SAVREG16:
	   MOV	SI,OFFSET DG:REG16
FNDREG:
	   CBW
	   ADD	SI,AX
	   ADD	SI,AX
	   MOVSW
	   RET

SEGOP:
	   SHR	AL,1
	   SHR	AL,1
	   SHR	AL,1
SAVSEG:
	   AND	AL,3
	   MOV	SI,OFFSET DG:SREG
	   JMP	SHORT FNDREG

REGOP:
	   AND	AL,7
	   JMP	SHORT SAVREG16

MOVSEGTO:
	   MOV	BYTE PTR [AWORD],1
	   CALL GETADDR
	   MOV	AL,","
	   STOSB
	   MOV	AL,[MIDFLD]
	   JMP	SHORT SAVSEG

MOVSEGFROM:
	   CALL GETMODE
	   CALL SAVSEG
	   MOV	BYTE PTR [AWORD],1
	   JMP	SHORT MEMOP2

GETADDR:
	   CALL GETMODE
	   JMP	SHORT ADDRMOD

WORDTOALU:
	   MOV	BYTE PTR [AWORD],1
ALUTOREG:
	   CALL GETMODE
	   CALL REGFLD
MEMOP2:
	   MOV	AL,","
	   STOSB
ADDRMOD:
	   CMP	BYTE PTR [MODE],3
	   MOV	AL,[REGMEM]
	   JE	SAVREG
	   XOR	BX,BX
	   MOV	BYTE PTR [NSEG],3
	   MOV	BYTE PTR [DI],"["
	   INC	DI
	   CMP	AL,6
	   JNE	NODRCT
	   CMP	BYTE PTR [MODE],0
	   JE	DIRECT			; Mode=0 and R/M=6 means direct addr.
NODRCT:
	   MOV	DL,AL
	   CMP	AL,1
	   JBE	USEBX
	   CMP	AL,7
	   JE	USEBX
	   CMP	AL,3
	   JBE	USEBP
	   CMP	AL,6
	   JNE	CHKPLS
USEBP:
	   MOV	BX,[BPSAVE]
	   MOV	BYTE PTR [NSEG],2	; Change default to Stack Segment
	   MOV	AX,BPREG
SAVBASE:
	   STOSW
CHKPLS:
	   CMP	DL,4
	   JAE	NOPLUS
	   MOV	AL,"+"
	   STOSB
NOPLUS:
	   CMP	DL,6
	   JAE	DOMODE			; No index register
	   AND	DL,1			; Even for SI, odd for DI
	   JZ	USESI
	   ADD	BX,[DISAVE]
	   MOV	AX,DIREG
SAVINDX:
	   STOSW
DOMODE:
	   MOV	AL,[MODE]
	   OR	AL,AL
	   JZ	CLOSADD 		; If no displacement, then done
	   CMP	AL,2
	   JZ	ADDDIR
	   CALL SAVD8			; Signed 8-bit displacement
ADDCLOS:
	   ADD	BX,DX
CLOSADD:
	   MOV	AL,"]"
	   STOSB
	   MOV	[INDEX],BX
NOOPERANDS:
	   RET

ADDDIR:
	   MOV	AL,"+"
	   STOSB
DIRECT:
	   CALL SAV16
	   JMP	SHORT ADDCLOS

USEBX:
	   MOV	BX,[BXSAVE]
	   MOV	AX,BXREG
	   JMP	SHORT SAVBASE

USESI:
	   ADD	BX,[SISAVE]
	   MOV	AX,SIREG
	   JMP	SHORT SAVINDX

SHORTJMP:
	   CALL GETDIS
	   CBW
	   ADD	AX,WORD PTR [DISADD]
	   XCHG DX,AX
SAVJMP:
	   MOV	AL,DH
	   CALL SAVHEX
	   MOV	AL,DL
	   JMP	SAVHEX

JMPCALL:
	   CALL GETDIS
	   MOV	DL,AL
	   CALL GETDIS
	   MOV	DH,AL
	   ADD	DX,WORD PTR [DISADD]
	   JMP	SHORT SAVJMP

XCHGAX:
	   AND	AL,7
	   CALL SAVREG16
	   MOV	AL,","
	   STOSB
	   XOR	AL,AL
	   JMP	SAVREG16

LOADACC:
	   XOR	AL,AL
	   CALL SAVREG
	   MOV	AL,","
	   STOSB
MEMDIR:
	   MOV	AL,"["
	   STOSB
	   XOR	BX,BX
	   MOV	BYTE PTR [NSEG],3
	   JMP	DIRECT

STOREACC:
	   CALL MEMDIR
	   MOV	AL,","
	   STOSB
	   XOR	AL,AL
	   JMP	SAVREG

REGIMMB:
	   MOV	BYTE PTR [AWORD],0
	   JMP	SHORT REGIMM

REGIMMW:
	   MOV	BYTE PTR [AWORD],1
REGIMM:
	   AND	AL,7
	   JMP	IMM1

INT3:
	   MOV	BYTE PTR [DI],"3"
	   INC	DI
	   RET

;  8087 instructions whose first byte is 0dfh
M8087_DF:
	   CALL GET64F
	   JZ	ISDD3
	   MOV	SI,OFFSET DG:MDF_TAB
	   JMP	short NODB3

;  8087 instructions whose first byte is 0ddh
M8087_DD:
	   CALL GET64F
	   JZ	ISDD3
	   MOV	SI,OFFSET DG:MDD_TAB
	   JMP	short NOD93

ISDD3:
	   MOV	AL,DL
	   TEST AL,100B
	   JZ	ISSTI
	   JMP	ESC0

ISSTI:
	   AND	AL,11B
	   MOV	SI,OFFSET DG:MDD_TAB2
	   MOV	CL,AL
	   CALL MOVBYT
	   JMP	short PUTRST

;  8087 instructions whose first byte is 0dbh
M8087_DB:
	   CALL GET64F
	   JZ	ISDB3
	   MOV	SI,OFFSET DG:MDB_TAB
NODB3:
	   CALL PUTOP
	   CALL PUTSIZE
	   JMP	ADDRMOD

ISDB3:
	   MOV	AL,DL
	   TEST AL,100B
	   JNZ	ISDBIG
ESC0V:
	   JMP	ESC0

ISDBIG:
	   CALL GOTDIS
	   AND	AL,11111B
	   CMP	AL,4
	   JAE	ESC0V
	   MOV	SI,OFFSET DG:MDB_TAB2
	   JMP	short DOBIG

;  8087 instructions whose first byte is 0d9h
M8087_D9:
	   CALL GET64F
	   JZ	ISD93

	   MOV	SI,OFFSET DG:MD9_TAB
NOD93:
	   CALL PUTOP
	   AND	AL,111B
	   CMP	AL,3
	   JA	NOSHO
	   MOV	AL,DL
	   CALL PUTSIZE
NOSHO:
	   JMP	ADDRMOD

ISD93:
	   MOV	AL,DL
	   TEST AL,100B
	   JNZ	ISD9BIG
	   AND	AL,111B
	   OR	AL,AL
	   JNZ	NOTFLD
	   MOV	AX,"DL"
	   STOSW
	   JMP	SHORT PUTRST

NOTFLD:
	   CMP	AL,1
	   JNZ	NOTFXCH
	   MOV	AX,"CX"
	   STOSW
	   MOV	AL,"H"
	   JMP	SHORT PUTRST1

NOTFXCH:
	   CMP	AL,3
	   JNZ	NOTFSTP
	   MOV	AX,"TS"
	   STOSW
	   MOV	AL,"P"
PUTRST1:
	   STOSB
PUTRST:
	   MOV	AL,9
	   STOSB
	   JMP	short PUTST0

NOTFSTP:
	   CALL GOTDIS
	   CMP	AL,11010000B		; CHECK FOR FNOP
	   JZ	GOTFNOP
	   JMP	ESC0

GOTFNOP:
	   MOV	AX,"ON"
	   STOSW
	   MOV	AL,"P"
	   STOSB
	   RET

ISD9BIG:
	   CALL GOTDIS			; GET THE MODE BYTE
	   MOV	SI,OFFSET DG:MD9_TAB2
DOBIG:
	   AND	AL,11111B
	   MOV	CL,AL
	   JMP	MOVBYT

; entry point for the remaining 8087 instructions
M8087:
	   CALL GET64
	   CALL PUTFI			; PUT FIRST PART OF OPCODE
	   MOV	AL,DL
	   CMP	BYTE PTR [MODE],11B	; CHECK FOR REGISTER MODE
	   JZ	MODEIS3
	   CALL PUTMN			; PUT MIDDLE PART OF OPCODE
NO3:
	   MOV	AL,9			; OUTPUT A TAB
	   STOSB
	   MOV	AL,DL
	   CALL PUTSIZE 		; OUTPUT THE OPERAND SIZE
	   JMP	ADDRMOD

MODEIS3:
	   TEST AL,100000B		; D BIT SET?
	   JZ	MPUT			; NOPE...
	   TEST AL,000100B		; FDIV OR FSUB?
	   JZ	MPUT			; NOPE...
	   XOR	AL,1			; REVERSE SENSE OF R
	   MOV	DL,AL			; SAVE CHANGE
MPUT:
	   CALL PUTMN			; PUT MIDDLE PART OF OPCODE
	   MOV	AL,DL
	   TEST AL,010000B
	   JZ	NOPSH
	   MOV	AL,"P"
	   STOSB
NOPSH:
	   MOV	AL,9
	   STOSB
	   MOV	AL,DL
	   AND	AL,00000111B
	   CMP	AL,2			; FCOM
	   JZ	PUTST0
	   CMP	AL,3			; FCOMP
	   JZ	PUTST0
	   MOV	AL,DL
	   TEST AL,100000B
	   JZ	PUTSTST0

; output 8087 registers in the form st(n),st
PUTST0ST:
	   CALL PUTST0
	   MOV	AL,','
ISCOMP:
	   STOSB

PUTST:
	   MOV	AX,"TS"
	   STOSW
	   RET

; output 8087 registers in the form st,st(n)
PUTSTST0:
	   CALL PUTST
	   MOV	AL,','
	   STOSB

PUTST0:
	   CALL PUTST
	   MOV	AL,"("
	   STOSB
	   MOV	AL,[REGMEM]
	   ADD	AL,"0"
	   STOSB
	   MOV	AL,")"
	   STOSB
	   RET

; output an 8087 mnemonic
PUTMN:
	   MOV	SI,OFFSET DG:M8087_TAB
	   MOV	CL,AL
	   AND	CL,00000111B
	   JMP	SHORT MOVBYT

; output either 'FI' or 'F' for first byte of opcode
PUTFI:
	   MOV	SI,OFFSET DG:FI_TAB
	   JMP	SHORT PUTFI2

; output size (dword, tbyte, etc.)
PUTSIZE:
	   MOV	SI,OFFSET DG:SIZE_TAB
PUTFI2:
	   CMP	BYTE PTR [MODE],11B	; check if 8087 register
	   JNZ	PUTFI3
	   AND	AL,111000B		; LOOK FOR INVALID FORM OF 0DAH OPERANDS
	   CMP	AL,010000B
	JZ	ESC0PJ
	   MOV	AL,DL
	   CMP	AL,110011B		; FCOMPP
	   JNZ	GOFI
	   CMP	BYTE PTR [REGMEM],1
	JZ	GOFI
ESC0PJ:
	jmp	short ESC0P		; we could've reached without a
;					; double branch here, but we needed
;					; a bridge for ESC0PJ
GOFI:
	   XOR	CL,CL
	   JMP	SHORT MOVBYT

;  Look for qword
PUTFI3:
	   CMP	AL,111101B
	   JZ	GOTQU
	   CMP	AL,111111B
	   JNZ	NOTQU
GOTQU:
	   MOV	CL,2
	   JMP	SHORT MOVBYT

;  look for tbyte
NOTQU:
	   CMP	AL,011101B
	   JZ	GOTTB
	   CMP	AL,111100B
	   JZ	GOTTB
	   CMP	AL,111110B
	   JZ	GOTTB
	   CMP	AL,011111B
	   JNZ	NOTTB
GOTTB:
	   MOV	CL,5
	   JMP	SHORT MOVBYT

NOTTB:
	   MOV	CL,4
	   SHR	AL,CL
	   MOV	CL,AL
; SI POINTS TO A TABLE OF TEXT SEPARATED BY "$"
; CL = WHICH ELEMENT IN THE TABLE YOU WISH TO COPY TO [DI]
MOVBYT:
	   PUSH AX
	   INC	CL
MOVBYT1:
	   DEC	CL
	   JZ	MOVBYT3
MOVBYT2:
	   LODSB
	   CMP	AL,"$"
	   JZ	MOVBYT1
	   JMP	MOVBYT2

MOVBYT3:
	   LODSB
	   CMP	AL,'$'
	   JZ	MOVBYT5
	   CMP	AL,'@'                  ; THIS MEANS RESVERED OP-CODE
	   JNZ	MOVBYT4
	   POP	AX
	   JMP	SHORT ESC0P		; GO DO AN ESCAPE COMMAND

MOVBYT4:
	   STOSB
	   JMP	MOVBYT3

MOVBYT5:
	   POP	AX
	   RET

PUTOP:
	   AND	AL,111B
	   MOV	CL,AL
	   CALL MOVBYT
	   MOV	AL,9
	   STOSB
	   MOV	AL,DL
	   RET

GET64F:
	   CALL GET64
	   MOV	AL,"F"
	   STOSB
	   CMP	BYTE PTR [MODE],3
	   MOV	AL,DL
	   RET

GET64:
	   AND	AL,7
	   MOV	DL,AL
	   CALL GETMODE
	   SHL	DL,1
	   SHL	DL,1
	   SHL	DL,1
	   OR	AL,DL
	   MOV	DL,AL			; SAVE RESULT
	   RET

ESC0P:
	   POP	DI			; CLEAN UP STACK
ESC0:
	   MOV	WORD PTR [OPCODE],OFFSET DG:ESCMN
	   MOV	AL,DL
	   MOV	DI,OFFSET DG:OPBUF
	   JMP	SHORT ESC1

ESCP:
	   CALL GET64
ESC1:
	   CALL SAVHEX
	   CMP	BYTE PTR [MODE],3
	   JZ	SHRTESC
	   MOV	BYTE PTR  [AWORD],1
	   JMP	MEMOP2

SHRTESC:
	   MOV	AL,","
	   STOSB
	   MOV	AL,[REGMEM]
	   AND	AL,7
	   JMP	SAVREG

INVARW:
	   CALL PUTAX
	   JMP	SHORT INVAR

INVARB:
	   CALL PUTAL
INVAR:
	   MOV	AL,','
	   STOSB
	   JMP	short PUTDX

INFIXW:
	   CALL PUTAX
	   JMP	SHORT INFIX

INFIXB:
	   CALL PUTAL
INFIX:
	   MOV	AL,','
	   STOSB
	   JMP	SAV8

	   STOSW			;IS THIS DEAD CODE? EMK
	   RET

OUTVARB:
	   MOV	BX,"LA"
	   JMP	SHORT OUTVAR

OUTVARW:
	   MOV	BX,"XA"
OUTVAR:
	   CALL PUTDX
OUTFV:
	   MOV	AL,','
	   STOSB
	   MOV	AX,BX
	   STOSW
	   RET

OUTFIXB:
	   MOV	BX,"LA"
	   JMP	SHORT OUTFIX

OUTFIXW:
	   MOV	BX,"XA"
OUTFIX:
	   CALL SAV8
	   JMP	OUTFV

PUTAL:
	   MOV	AX,"A"+4C00H            ; "AL"
	   JMP	SHORT PUTX

PUTAX:
	   MOV	AX,"A"+5800H            ; "AX"
	   JMP	SHORT PUTX

PUTDX:
	   MOV	AX,"D"+5800H            ; "DX"
PUTX:
	   STOSW
	   RET

SHFT:
	   MOV	BX,OFFSET DG:SHFTAB
	   CALL GETMNE
TESTREG:
	   CMP	BYTE PTR [MODE],3
	   JZ	NOFLG
	   MOV	SI,OFFSET DG:SIZE_TAB
	   MOV	CL,3
	   TEST BYTE PTR [AWORD],-1
	   JNZ	TEST_1
	   INC	CL
TEST_1:
	   CALL MOVBYT
NOFLG:
	   JMP	ADDRMOD

SHIFTV:
	   CALL SHFT
	   MOV	AL,","
	   STOSB
	   MOV	WORD PTR [DI],"C"+4C00H ; "CL"
	   ADD	DI,2
	   RET

SHIFT:
	   CALL SHFT
	   MOV	AX,"1,"
	   STOSW
	   RET

GETMNE:
	   CALL GETMODE
	   MOV	DL,AL
	   CBW
	   SHL	AX,1
	   ADD	BX,AX
	   MOV	AX,[BX]
	   MOV	[OPCODE],AX
	   MOV	AL,DL
	   RET

GRP1:
	   MOV	BX,OFFSET DG:GRP1TAB
	   CALL GETMNE
	   OR	AL,AL
	   JZ	FINIMMJ
	   JMP	TESTREG
FINIMMJ:
	   JMP	FINIMM

GRP2:
	   MOV	BX,OFFSET DG:GRP2TAB
	   CALL GETMNE
	   CMP	AL,2
	   JB	TESTREG
	   CMP	AL,6
	   JAE	INDIRECT
	   TEST AL,1
	   JZ	INDIRECT
	   MOV	AX,"AF"                 ; "FAR"
	   STOSW
	   MOV	AX," R"
	   STOSW
INDIRECT:
	   JMP	ADDRMOD

CODE	   ENDS
	   END	UNASSEM

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\debug.asm ===
PAGE	60,132			;
	TITLE	DEBUG.ASM - DEBUGger for MS-DOS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DEBUG.ASM
;
; DESCRIPTIVE NAME: DEBUGGING TOOL
;
; FUNCTION: PROVIDES USERS WITH A TOOL FOR DEBUGGING PROGRAMS.
;
; ENTRY POINT: START
;
; INPUT: DOS COMMAND LINE
;	 DEBUG COMMANDS
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: DEBCOM1 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBCOM2 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBCOM3 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBASM  - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBUASM - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBMES  - CONTAINS MESSAGE RETRIEVER ROUTINES
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT DBCS HANDLING	DMS:6/17/87
;				- IMPLEMENT DBCS HANDLING	bgb:5/03/88	;an001;bgb
;				- IMPLEMENT MESSAGE RETRIEVER	DMS:6/17/87
;				- > 32 MB SUPPORT		DMS:6/17/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;	MICROSOFT REVISION HISTORY:
;
; Modified 5/4/82 by AaronR to do all I/O direct to devices
; Runs on MS-DOS 1.28 and above
;
; REV 1.20
;	Tab expansion
;	New device interface (1.29 and above)
; REV 2.0
;	line by line assembler added by C. P.
; REV 2.1
;	Uses EXEC system call
; REV 2.2
;	Ztrace mode by zibo.
;	Fix dump display to indent properly
;	Parity nonsense by zibo
;
; REV 2.3 NP
;	Use Printf for all standard output.
;	Change to EXE file
; REV 2.4 ARR
;	Bug fixes. TEST, XCHG instructions reg order reversed.
;	Single step, break point interrupts saved and restored.
;	Access denied given on W to read only file.
;======================= END OF SPECIFICATIONS ===========================
;   Change Log:
;
;     Date    Who   #			Description
;   --------  ---  ---	------------------------------------------------------
;   04/01/90  DIC  C01	This information on the drive containing the file is
;			used within DEBCOM2.ASM for determining if enough
;			memory is available to write a file out to disk.
;			(Compaq STR #1889) (MS Bug #774)
;
;   09/xx/90   CAS	Fixed divide overflow problem when trying to
;			write ridiculously large files
;
;   10/18/90   CAS      Changed "POP CS" to DB 0F
;			Added code to override 8086/8088 Trace PIC mask
;			stuff on later CPUs to avoid crashing after
;			tracing through divide overflows.
;			Eliminated most Long Branch warnings
;
;=============================================================================

.XLIST
.XCREF
	include version.inc		; cas -- missing equates
	include syscall.inc		; cas -- missing equates
	INCLUDE DOSSYM.INC		; ALSO VERSION NUMBER
.CREF
.LIST
        INCLUDE debug.inc
	IF	SYSVER
; Structure for system call 72
SYSINITVAR  STRUC
DPBHEAD     DD	    ?			; Pointer to head of DPB-FAT list
SFT_ADDR    DD	    ?			; Pointer to first FCB table
; The following address points to the CLOCK device
BCLOCK	    DD	    ?
; The following address is used by DISKSTATCHK it is always
; points to the console input device header
BCON	    DD	    ?			; Console device entry points
MAXSEC	    DW	    0			; Maximum allowed sector size
BUFFHEAD    DD	    ?
CDS	    DD	    ?
SFTFCB	    DD	    ?
KEEP	    DW	    ?
NUMIO	    DB	    0			; Number of disk tables
NCDS	    DB	    ?
DEVHEAD     DD	    ?
SYSINITVAR  ENDS

	ENDIF


;======================= macro equates ===================================

dbcs_delim equ	81h			;an000;delimits dbcs char
asian_blk equ	40h			;an000;asian blank
amer_blk equ	20h			;an000;american blank
quote_char equ	22h			;an000;quote delim "

;======================= end macro equates ===============================


;This segment must be the first loaded since we are using it to make
;a CREATE_PROCESS_DATA_BLOCK system call a la 1.0 and .COM files.
;For this system call CS must point to the Program Prefix Header, so
;by setting up a seperate segment just after the header we can issue
;an INT 21H via a long call.  So don't move this guy around!

A_CREATE_BLOCK SEGMENT

	PUBLIC	CREATE_CALL

;The other arguements to this system call have been set up
;by the caller.

CREATE_CALL PROC FAR
	MOV	AH,CREATE_PROCESS_DATA_BLOCK
	INT	21H
	RET

CREATE_CALL ENDP

A_CREATE_BLOCK ENDS


CODE	SEGMENT PUBLIC
CODE	ENDS

CONST	SEGMENT PUBLIC
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC
DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CONST	SEGMENT PUBLIC BYTE
	EXTRN	BADVER:BYTE,ENDMES_PTR:BYTE,CRLF_PTR:BYTE
	IF	IBMJAPAN
	    EXTRN   PARITYMES_PTR:BYTE
	ENDIF
	EXTRN	PROMPT_PTR:BYTE,ADD_PTR:BYTE,HEX_PTR:BYTE
	EXTRN	USER_PROC_PDB:WORD,CSSAVE:WORD,DSSAVE:WORD
	EXTRN	SPSAVE:WORD,IPSAVE:WORD,LINEBUF:BYTE,QFLAG:BYTE
	EXTRN	NEWEXEC:BYTE,HEADSAVE:WORD,LBUFSIZ:BYTE,BACMES_PTR:WORD
	EXTRN	QMES_1:BYTE
	EXTRN	QMES_2:BYTE
	EXTRN	QMES_3:BYTE
	EXTRN	QMES_4:BYTE
	EXTRN	QMES_5:BYTE
	EXTRN	HELP_TEXT1:BYTE
	EXTRN	HELP_TEXT2:BYTE
	EXTRN	HELP_TEXT3:BYTE
	EXTRN	HELP_TEXT4:BYTE
	EXTRN	HELP_TEXT5:BYTE
	EXTRN	HELP_TEXT6:BYTE

	IF	IBMVER
	    EXTRN   DSIZ:BYTE,NOREGL:BYTE,DISPB:WORD
	ENDIF

	IF	SYSVER
	    EXTRN   CONFCB:BYTE,POUT:DWORD,COUT:DWORD,CIN:DWORD,IOBUFF:BYTE
	    EXTRN   IOADDR:DWORD,IOCALL:BYTE,IOCOM:BYTE,IOSTAT:WORD,IOCNT:WORD
	    EXTRN   IOSEG:WORD,COLPOS:BYTE,BADDEV_PTR:BYTE,BADLSTMES_PTR:BYTE
	    EXTRN   LBUFFCNT:BYTE,PFLAG:BYTE
	ENDIF

	EXTRN	NAMESPEC:BYTE
	EXTRN	DriveOfFile:WORD       ; save default drive of file   ;C01

CONST	ENDS

CSTACK	SEGMENT STACK
	DB	(362 - 80H) + 80H DUP(?) ; (362 - 80H) == IBM'S ROM REQUIREMENTS
					; (NEW - OLD) == SIZE TO GROW STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE
	EXTRN	ARG_BUF:BYTE,ADD_ARG:WORD,SUB_ARG:WORD,HEX_ARG1:WORD
	EXTRN	HEX_ARG2:WORD,STACK:BYTE, PREV24:DWORD, FIN24:BYTE
	EXTRN	PARSERR:BYTE,DATAEND:WORD,PARITYFLAG:BYTE,DISADD:BYTE
	EXTRN	ASMADD:BYTE,DEFDUMP:BYTE,BYTEBUF:BYTE,BEGSEG:WORD
	EXTRN	BPINTSAV:DWORD,SSINTSAV:DWORD ;ARR 2.4
	EXTRN	CREATE_LONG:DWORD

	extrn	lbtbl:dword		;an000;lead byte table pointer

DATA	ENDS

	EXTRN	PRINTF:NEAR		;ac000;changed to NEAR call

CODE	SEGMENT PUBLIC
	ASSUME	CS:DG,DS:NOTHING,ES:NOTHING,SS:CSTACK

	PUBLIC	RESTART
	PUBLIC	STD_PRINTF,PRINTF_CRLF
	PUBLIC	HEX_ADDRESS_ONLY,HEX_ADDRESS_STR
	PUBLIC	RESTART,SET_TERMINATE_VECTOR,DABORT,TERMINATE,COMMAND
	PUBLIC	FIND_DEBUG,CRLF,BLANK,TAB,INBUF,SCANB,SCANP
	PUBLIC	HEX,OUTSI,OUTDI,DIGIT,BACKUP,RBUFIN
	public	test_lead							;an001;bgb
	public	test1								;an001;bgb

	IF	SYSVER
;	    PUBLIC  SETUDEV,DEVIOCALL				; kwc 12/10/86
	    PUBLIC  SETUDEV		; kwc 12/10/86
	    EXTRN   DISPREG:NEAR,INPT:NEAR
	ENDIF

	EXTRN	PERR:NEAR,COMPARE:NEAR,DUMP:NEAR,ENTERDATA:NEAR,FILL:NEAR
	EXTRN	GO:NEAR,INPUT:NEAR,LOAD:NEAR,MOVE:NEAR,NAMED:NEAR
	EXTRN	REG:NEAR,SEARCH:NEAR,DWRITE:NEAR,UNASSEM:NEAR,ASSEM:NEAR
	EXTRN	OUTPUT:NEAR,ZTRACE:NEAR,TRACE:NEAR,GETHEX:NEAR,GETEOL:NEAR
	EXTRN	PREPNAME:NEAR,DEFIO:NEAR,SKIP_FILE:NEAR,DEBUG_FOUND:NEAR
	EXTRN	TRAPPARITY:NEAR,RELEASEPARITY:NEAR
	extrn	pre_load_message:near	;an000;load messages
	extrn	debems:near		;an000;ems support
ifdef JAPAN
	extrn	SETDUMPMODE:near
endif


	DB	100H DUP (?)

START:
	JMP	SHORT DSTRT

HEADER	DB	"Vers 2.40"

DSTRT:
;=========================================================================
; invoke PRE_LOAD_MESSAGE here.  If the messages were not loaded we will
; exit with an appropriate error message.
;
;	Date	   : 6/14/87
;=========================================================================

	push	ds			;an000;save regs
	push	es			;an000;save resg

	push	cs			;an000;transfer cs
	pop	ds			;an000;    to ds

	push	cs			;an000;transfer cs
	pop	es			;an000;    to es
	assume	ds:dg,es:dg		;an000;assume them
	call	PRE_LOAD_MESSAGE	;an000;invoke SYSLOADMSG
;	$if	c			;an000;if the load was unsuccessful
	JNC $$IF1
	    mov     ax,(exit shl 8)	;an000;exit EDLIN.  PRE_LOAD_MESSAGE
					;      has already said why
	    int     21h 		;an000;exit
;	$endif				;an000;
$$IF1:

	pop	es			;an000;restore regs.
	pop	ds			;an000;
	assume	ds:nothing,es:nothing	;an000;back to original

	MOV	AX,(GET_INTERRUPT_VECTOR SHL 8) OR VEC_BREAKPOINT ;get original contents
	INT	21H			;  of the BREAKPOINT vector

	MOV	WORD PTR [BPINTSAV],BX	;  and save that vector for later
	MOV	WORD PTR [BPINTSAV+WORD],ES ; restoration

	MOV	AX,(GET_INTERRUPT_VECTOR SHL 8) OR VEC_SING_STEP ;get original contents
	INT	21H			;  of the SINGLE STEP vector

	MOV	WORD PTR [SSINTSAV],BX	;  and save that vector for later
	MOV	WORD PTR [SSINTSAV+WORD],ES ; restoration

	MOV	BEGSEG,DS		; save beginning DS
	PUSH	CS			; repair damaged ES to be
	POP	ES			;  back to just like CS
	XOR	SI,SI			; set source and destination
	XOR	DI,DI			;  indices both to zero
	MOV	CX,256			; set count to size of PSP
	REP	MOVSB			; move to es:[di] from ds:[si]
	PUSH	CS			; set up DS to be just like CS
	POP	DS			;  to match .COM rules of addressability
	ASSUME	DS:DG,ES:DG		; like CS, also have DS and DS as bases

	if	IBMVER

;	on IBM compatibles, we need to know whether we have a pre-286, so
;	  we can invoke special PIC mask code during tracing.

	extrn	cpu_not_8088:byte
	pushf				; save flags
	pushf				; copy to ax
	pop	ax
	and	ax,0fffh		; try to reset first 4 to zero
	push	ax
	popf
	pushf				; write it to flags and get it back
	pop	ax			; and back into ax
	cmp	ah,0f0h			; if all 4 are ones, then 8088/8086
;					;  otherwise, set carry (later cpu)
	sbb	al,al			; propagate carry across al
	mov	cpu_not_8088,al		; and save it for future reference
	popf				; restore flags
	endif

	CALL	TRAPPARITY		; scarf up those parity guys
	MOV	AH,GET_CURRENT_PDB	;(undocumented function call - 51h)
	INT	21H

	MOV	[USER_PROC_PDB],BX	; Initially set to DEBUG

	IF	SYSVER
	    MOV     [IOSEG],CS
	ENDIF

	MOV	[PARSERR],0


	IF	SYSVER
	    MOV     AH,GET_IN_VARS	;(undocumented function call - 52h)
	    INT     21H

	    LDS     SI,ES:[BX.BCON]	; get system console device
	    ASSUME  DS:NOTHING

	    MOV     WORD PTR CS:[CIN+WORD],DS ;save vector to console input device
	    MOV     WORD PTR CS:[CIN],SI
	    MOV     WORD PTR CS:[COUT+WORD],DS ;save vector to console output device
	    MOV     WORD PTR CS:[COUT],SI
	    PUSH    CS			; restore DS to be
	    POP     DS			;  just like CS, as before
	    ASSUME  DS:DG

	    MOV     DX,OFFSET DG:CONFCB ; get system printer device
	    MOV     AH,FCB_OPEN 	; open system printer "PRN"
	    INT     21H

	    OR	    AL,AL		; open ok?
	    JZ	    GOTLIST		; yes, it was there

	    MOV     DX,OFFSET DG:BADLSTMES_ptr ; no list file found...
	    CALL    STD_PRINTF		; tell user

	    CALL    RBUFIN		; ask for a new one

	    CALL    CRLF

	    MOV     CL,[LBUFFCNT]
	    OR	    CL,CL
	    JZ	    NOLIST1		; User didn't specify one

	    XOR     CH,CH
	    MOV     DI,OFFSET DG:(CONFCB + BYTE)
	    MOV     SI,OFFSET DG:LINEBUF ; get one from input line
	    REP     MOVSB
	    MOV     DX,OFFSET DG:CONFCB
	    MOV     AH,FCB_OPEN 	; try to open it
	    INT     21H

	    OR	    AL,AL
	    JZ	    GOTLIST		; yep, use it...

	    MOV     DX,OFFSET DG:BADDEV_Ptr ; complain again
	    CALL    STD_PRINTF
NOLIST1:				; kwc 12/10/86
	    MOV     WORD PTR [POUT+WORD],CS ; use null device for printer
	    MOV     WORD PTR [POUT],OFFSET DG:LONGRET
	    JMP     NOLIST

XXX	    PROC    FAR
LONGRET:
	    RET
XXX	    ENDP
	ENDIF

GOTLIST:
;DX = OFFSET OF 'CONFCB', WHICH HAS JUST BEEN OPENED OK
	IF	SYSVER
	    MOV     SI,DX
;	    LDS     SI,DWORD PTR DS:[SI.FCB_FIRCLUS]		; KWC 12/10/86
	    LDS     SI,DWORD PTR DS:[SI.FCB_NSLD_DRVPTR] ; KWC 12/10/86
	    ASSUME  DS:NOTHING

	    MOV     WORD PTR CS:[POUT+WORD],DS
	    MOV     WORD PTR CS:[POUT],SI
	ENDIF
NOLIST:
	MOV	AX,CS			;restore the DS and ES segregs
	MOV	DS,AX			; to become once again just like CS
	MOV	ES,AX
	ASSUME	DS:DG,ES:DG

; Code to print header
;	MOV	DX,OFFSET DG:HEADER_PTR
;	CALL	STD_PRINTF

	CALL	SET_TERMINATE_VECTOR

; Save the current INT 24 vector.  We will need this to link to the previous
; handler for handling of int 24 output.
	PUSH	ES			; save it, about to clobber it...
	MOV	AX,(GET_INTERRUPT_VECTOR SHL 8) + VEC_CRIT_ERR ; get original contents
	INT	21H			; of the int 24h vector

	MOV	WORD PTR PREV24,BX	; remember what int 24h used to
	MOV	WORD PTR PREV24+WORD,ES ;  point to
	POP	ES			; restore ES to be like CS and DS

	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) + VEC_CRIT_ERR ; change int 24h to
	MOV	DX,OFFSET DG:MY24	; point to my own int 24h handler
	INT	21H

	IF	SETCNTC
	    MOV     AL,VEC_CTRL_BREAK	; Set vector 23H
	    MOV     DX,OFFSET DG:DABORT
	    INT     21H
	ENDIF

	MOV	DX,CS			;get para of where this pgm starts
	MOV	AX,OFFSET DG:DATAEND+15 ;get offset of end of this program
	MOV	CL,4			; (plus 15 padding for rounding)
	SHR	AX,CL			; adjusted to number of paragraphs
	ADD	DX,AX			;get para of where this pgm ends
	MOV	AX,CS
	SUB	AX,BEGSEG		; add in size of printf
	ADD	DX,AX			; create program segment here
	CALL	[CREATE_LONG]		; and call special routine

	MOV	AX,DX
; Initialize the segments
	MOV	DI,OFFSET DG:DSSAVE
	CLD
	STOSW
	STOSW
	STOSW
	STOSW
	MOV	WORD PTR [DISADD+WORD],AX
	MOV	WORD PTR [ASMADD+WORD],AX
	MOV	WORD PTR [DEFDUMP+WORD],AX

	MOV	AX,100H
	MOV	WORD PTR[DISADD],AX
	MOV	WORD PTR[ASMADD],AX
	MOV	WORD PTR [DEFDUMP],AX

	MOV	DS,DX
	MOV	ES,DX
	ASSUME	DS:NOTHING,ES:NOTHING

	MOV	DX,80H
	MOV	AH,SET_DMA
	INT	21H			; Set default DMA address to 80H
; Set up initial stack.  We already have a 'good' stack set up already.  DS:6
; has the number of bytes remaining in the segment.  We should take this
; value, add 100h and use it as the Stack pointer.
	MOV	AX,WORD PTR DS:[6]	; get bytes remaining
	MOV	BX,AX
	ADD	AX,100h

;	MOV	BX,AX
;	CMP	AX,0FFF0H
;	PUSH	CS
;	POP	DS
;	JAE	SAVSTK
;	MOV	AX,WORD PTR DS:[6]
;	PUSH	BX
;	MOV	BX,OFFSET DG:DATAEND + 15
;	AND	BX,0FFF0H		; Size of DEBUG in bytes (rounded up to PARA)
;	SUB	AX,BX
;	POP	BX
;SAVSTK:
	PUSH	CS
	POP	DS
	ASSUME	DS:DG
	PUSH	BX			; bx is no. bytes remaining from PSP+6
	DEC	AX			; ax was no. bytes remaining +100h
	DEC	AX			; back up one word from end of new stack
	MOV	BX,AX			; set base to point to last word in new stack
	MOV	WORD PTR ES:[BX],0	; set final word in new stack to zero
	POP	BX			; back to beginning of new stack area
	MOV	SPSAVE,AX		; remember where new stack is
	DEC	AH
	MOV	ES:WORD PTR [6],AX	; change PSP to show usage of
	SUB	BX,AX			; new stack area
	MOV	CL,4
	SHR	BX,CL
	ADD	ES:WORD PTR [8],BX

	IF	IBMVER
; Get screen size and initialize display related variables
	    MOV     AH,15		;function = "request current video state"
	    INT     10H 		;set al=screen mode
					;    ah=no. char cols on screen
					;    bh=current active display page
	    CMP     AH,40		;is screen in 40 col mode?
	    JNZ     PARSCHK		; no, skip
					; yes, 40 col, continue
					;next fields defined in 'debconst.asm'
	    MOV     BYTE PTR DSIZ,7	; originally assembled as 0fh
	    MOV     BYTE PTR NOREGL,4	; originally assembled as 8
	    MOV     DISPB,64		; originally assembled as 128
	ENDIF

PARSCHK:


	call	DEBUG_LEAD_BYTE 	;an000;build the dbcs env. table
					;      of valid dbcs lead bytes

;=========================================================================
; prep_command_line requires the use of ds:si.	ds is left intact for
; the call.  si is initialized to point to the command line input buffer.
; ds and si are saved since we stomp all over them in prep_command_line.
;=========================================================================

	push	si			;an000;save si

	mov	si,81h			;an000;point to command line
	call	prep_command_line	;an000;invoke command line conversion

	pop	si			;an000;restore si

;=========================================================================
; we have prepped the command line for dbcs.  we can now enter the old
; routines.
;=========================================================================

; Copy rest of command line to test program's parameter area
	MOV	DI,FCB			;es[di]=to be filled with unopened FCB
	MOV	SI,80H			;ds[si]=command line to parse

; see if /? is the first argument in the command tail
NCHAR:	INC	SI
	CMP	BYTE PTR [SI], CHAR_BLANK
	JE	NCHAR
	CMP	BYTE PTR [SI], FOR_SLASH    ; are we looking at an '/' 
	JNE	NOQST                       ; if not, get out
	CMP	BYTE PTR [SI+1], Q_MARK     ;   else is the next char a '?' 
	JNE	NOQST                   

;print out /? help text
	MOV	DX, OFFSET DG:QMES_1
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:QMES_2
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:QMES_3
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:QMES_4
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:QMES_5
	CALL	STD_PRINTF
	JMP	QUITING

NOQST:  MOV	SI, 81H                 ; restore SI to what it should be
	MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR SET_DRIVEID_OPTION
					;func=29H, option al=1, which
					; says, drive id byte in fcb is set
					; only if drive specified in command
					; line being parsed.
	INT	21H			;parse filename from command to fcb
					; ds:si=points to first char AFTER parsed filename
					; es:di=points to first byte of formatted FCB

	mov	di,FCB			; get addr of FCB1	     ;C01
	mov	bx,[di] 		; get default drive of file  ;C01
	xor	bh,bh			; zero out high byte	     ;C01
	mov	DriveOfFile,bx		; save drive letter	     ;C01

	CALL	SKIP_FILE		; Make sure si points to delimiter
test1:					;for testing only - u can remove this
	CALL	PREPNAME

	PUSH	CS			;restore ES to point to the
	POP	ES			;  common group
FILECHK:
	MOV	DI,80H			;point to byte in PSP defining parm length
	CMP	BYTE PTR ES:[DI],0	; ANY STUFF FOUND?
	JZ	COMMAND 		; no parms, skip
					; yes parms, continue
FILOOP:
	INC	DI			;set index to first/next char in parm text
	CMP	BYTE PTR ES:[DI],CR	; carriage return? (at end of parms)
	JZ	COMMAND 		; yes, at end of parms
					; no, not at end of parms yet, continue
	CMP	BYTE PTR ES:[DI],CHAR_BLANK ; is this parm text char a blank?
	JZ	FILOOP			; yes, a blank, skip
					; no, not a blank, continue
	CMP	BYTE PTR ES:[DI],CHAR_TAB ; is this parm text char a tab?
	JZ	FILOOP			; yes, a tab, skip
					; no, not a tab, continue
	OR	[NAMESPEC],1		; set flag to indicate
					;  we have a specified file
					; (this could be set by "N" command also)
	CALL	DEFIO			; READ in the specified file

	PUSH	CS			;restore DS to point to the
	POP	DS			; common group

					;perform self-relocation on some internal vectors:
	MOV	AX,CSSAVE		; pick up the seg id to go to vectors
	MOV	WORD PTR DISADD+WORD,AX ;  shove it into the segid portion
	MOV	WORD PTR ASMADD+WORD,AX ;  of these two vectors
	MOV	AX,IPSAVE		; pick up the offset to go to vectors
	MOV	WORD PTR DISADD,AX	;  shove it into the offset portion
	MOV	WORD PTR ASMADD,AX	;  of these two vectors
COMMAND:
	CLD
	MOV	AX,CS
	MOV	DS,AX
	MOV	ES,AX
	cli				;disable before setting up the stack - EMK
	MOV	SS,AX			;now everything points to the same group
	ASSUME	SS:DG

	MOV	SP,OFFSET DG:STACK
	STI				;re-enable
	CMP	[PARITYFLAG],0		; did we detect a parity error?
	JZ	GOPROMPT		; no, go prompt
					; yes, parity error, continue
	MOV	[PARITYFLAG],0		; reset flag
	IF	IBMJAPAN
	    MOV     DX,OFFSET DG:PARITYMES_PTR
	    CALL    STD_PRINTF		;display msg about parity error
	ENDIF
GOPROMPT:
	MOV	DX,OFFSET DG:PROMPT_PTR ;display the user prompt request
	CALL	STD_PRINTF

	CALL	INBUF			; Get command line
; From now and throughout command line processing, DI points
; to next character in command line to be processed.
	CALL	SCANB			; Scan off leading blanks

	JZ	COMMAND 		; if zero, Null command, go get another
					; nonzero, got something in response
	LODSB				; AL=first non-blank character
; Prepare command letter for table lookup
; converts the first non-blank (assumed to be the command letter)
; to in index in the "comtab" array.
	SUB	AL,'?'			; Low end range check
	JB	ERR1

	CMP	AL,'Z'-'?'		; Upper end range check
	JA	ERR1

	SHL	AL,1			; Times two
	CBW				; Now a 16-bit quantity
	XCHG	BX,AX			; In BX we can address with it
	CALL	CS:[BX+COMTAB]		; Execute command

	JMP	SHORT COMMAND		; Get next command
ERR1:
	JMP	PERR

SET_TERMINATE_VECTOR:
	PUSH	DS
	PUSH	CS
	POP	DS
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR VEC_TERM_ADDR ; Set vector 22H
	MOV	DX,OFFSET DG:TERMINATE
	INT	21H

	POP	DS
	RET

RESTORE_DEB_VECT:
	PUSH	DS
	PUSH	DX
	PUSH	AX
	LDS	DX,CS:[BPINTSAV]
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR VEC_BREAKPOINT ;Vector 3
	INT	21H

	LDS	DX,CS:[SSINTSAV]
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR VEC_SING_STEP ;Vector 1
	INT	21H

	POP	AX
	POP	DX
	POP	DS
	RET

; Internal INT 24 handler.  We allow our parent's handler to decide what to do
; and how to prompt.  When our parent returns, we note the return in AL.  If
; he said ABORT, we need to see if we are aborting ourselves.  If so, we
; cannot turn it into fail; we may get a cascade of errors due to the original
; cause.  Instead, we do the ol' disk-reset hack to clean up.  This involves
; issuing a disk-reset, ignoring all errors, and then returning to the caller.
MY24:
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

; If we are already inside an INT 24, just ignore this error
	TEST	FIN24,-1
	JZ	DO24

	MOV	AL,0			; signal ignore
	IRET

; Let the user decide what to do
DO24:
	PUSHF
	CALL	PREV24			; simulate INT 24 to him

	CMP	AL,2			; was it ABORT?
	JNZ	DOIRET			; no, let it happen

	PUSH	AX
	PUSH	BX
	MOV	AH,GET_CURRENT_PDB	; find out who's terminating
	INT	21H

	CMP	BX,BEGSEG		; is it us?
	POP	BX
	POP	AX
	JZ	DORESET 		; no, let it happen

DOIRET:
	IRET

; We have been instructed to abort ourselves.  Since we can't do this, we will
; perform a disk reset to flush out all buffers and then ignore the errors we
; get.
DORESET:
	MOV	FIN24,-1		; signal that we ignore errors
	MOV	AH,DISK_RESET
	INT	21H			; clean out cache

	MOV	FIN24,0 		; reset flag
	JMP	COMMAND

TERMINATE:
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	CMP	QFLAG,0
	JNZ	QUITING

	MOV	AX,BEGSEG
	MOV	USER_PROC_PDB,AX
	CMP	NEWEXEC,0
	JZ	NORMTERM

	MOV	AX,CS
	MOV	DS,AX
	ASSUME	DS:DG
					;is CLI/STI needed here ? - emk
	CLI
	MOV	SS,AX
	ASSUME	SS:DG

	MOV	SP,OFFSET DG:STACK
	STI
	MOV	AX,HEADSAVE
	JMP	DEBUG_FOUND

NORMTERM:
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	PUSH	CS
	POP	DS
	ASSUME	DS:DG

	MOV	DX,OFFSET DG:ENDMES_PTR
	JMP	SHORT RESTART

QUITING:
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	CALL	RESTORE_DEB_VECT

	MOV	AX,(EXIT SHL 8)
	INT	21H

RESTART:
	CALL	STD_PRINTF
DABORT:
	MOV	AX,CS
	MOV	DS,AX
	ASSUME	DS:DG

					;is CLI\STI needed here? - emk
	CLI
	MOV	SS,AX
	ASSUME	SS:DG

	MOV	SP,OFFSET DG:STACK
	STI
;;;;;;	CALL	CRLF

	JMP	COMMAND

	IF	SYSVER
SETUDEV:
	    MOV     DI,OFFSET DG:CONFCB
	    MOV     AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR SET_DRIVEID_OPTION
	    INT     21H

	    CALL    USERDEV

	    JMP     DISPREG

USERDEV:
	    MOV     DX,OFFSET DG:CONFCB
	    MOV     AH,FCB_OPEN
	    INT     21H

	    OR	    AL,AL
	    JNZ     OPENERR

	    MOV     SI,DX
;	    TEST    BYTE PTR [SI.FCB_DEVID],080H ; Device?	; KWC 12/10/86
;	    JZ	    OPENERR		; NO			; KWC 12/10/86
	    MOV     AL,BYTE PTR [SI.FCB_NSL_DRIVE] ; KWC 12/10/86
	    AND     AL,NOT FCBMASK	; KWC 12/10/86
	    CMP     AL,0C0H		; KWC 12/10/86
	    JNE     OPENERR		; KWC 12/10/86
	    XOR     AL,AL		; KWC 12/10/86

;	    LDS     SI,DWORD PTR [CONFCB.FCB_FIRCLUS]		; KWC 12/10/86
	    LDS     SI,DWORD PTR [CONFCB.FCB_NSLD_DRVPTR] ; KWC 12/10/86
	    MOV     WORD PTR CS:[CIN],SI
	    MOV     WORD PTR CS:[CIN+WORD],DS

	    MOV     WORD PTR CS:[COUT],SI
	    MOV     WORD PTR CS:[COUT+WORD],DS
	    PUSH    CS
	    POP     DS
	    RET

OPENERR:
	    MOV     DX,OFFSET DG:BADDEV_PTR
	    CALL    STD_PRINTF

	    RET
	ENDIF
; Get input line. Convert all characters NOT in quotes to upper case.
INBUF:
	CALL	RBUFIN

;=========================================================================
; prep_command_line requires the use of ds:si.	ds is left intact for
; the call.  si is initialized to point to the command line input buffer.
; ds and si are saved since we stomp all over them in prep_command_line.
;=========================================================================

	push	si			;an000;save si

	mov	si,offset dg:linebuf	;an000;point to command line
	call	prep_command_line	;an000;invoke command line conversion

	pop	si			;an000;restore si

;=========================================================================
; we have prepped the command line for dbcs.  we can now enter the old
; routines.
;=========================================================================

	MOV	SI,OFFSET DG:LINEBUF
	MOV	DI,OFFSET DG:BYTEBUF

CASECHK:

	LODSB

	call	Test_Lead			;DBCS lead byte 		;an000; dms;
;	$if	c				;yes - ignore 2nd. byte 	;an000; dms;
	JNC $$IF3
		stosb				;save the byte			;an000; dms;
		lodsb				;pick up the 2nd. character	;an000; dms;
		stosb				;save it also			;an000; dms;
		jmp	CaseChk 		;read next character		;an000; dms;
;	$endif					;				;an000; dms;
$$IF3:

	CMP	AL,LOWER_A
	JB	NOCONV

	CMP	AL,LOWER_Z
	JA	NOCONV

	ADD	AL,UPPER_A - LOWER_A	; Convert to upper case
NOCONV:
	STOSB
	CMP	AL,CR
	JZ	INDONE

	CMP	AL,DOUBLE_QUOTE
	JZ	QUOTSCAN

	CMP	AL,SINGLE_QUOTE
	JNZ	CASECHK

QUOTSCAN:
	MOV	AH,AL
KILLSTR:
	LODSB
	STOSB
	CMP	AL,CR			;CARRIAGE RETURN?
	JZ	INDONE

	CMP	AL,AH
	JNZ	KILLSTR

	JMP	SHORT CASECHK

INDONE:
	MOV	SI,OFFSET DG:BYTEBUF
	CALL	CRLF

	RET

; Physical backspace - blank, backspace, blank
BACKUP:
	PUSH	DX
	MOV	DX,OFFSET DG:BACMES_PTR
	CALL	STD_PRINTF

	POP	DX
	RET

; Scan for parameters of a command
SCANP:
	CALL	SCANB			; Get first non-blank

	CMP	BYTE PTR [SI],CHAR_COMMA ; One comma between params OK
	JNE	EOLCHK			; If not comma, we found param

	INC	SI			; Skip over comma
; Scan command line for next non-blank character
SCANB:
	PUSH	AX
SCANNEXT:
	LODSB
	CMP	AL,CHAR_BLANK		;is this char a "blank"?
	JZ	SCANNEXT

	CMP	AL,CHAR_TAB		;is this char a "tab"?
	JZ	SCANNEXT

	DEC	SI			; Back to first non-blank
	POP	AX
EOLCHK:
	CMP	BYTE PTR [SI],CR	;CARRIAGE RETURN
	RET

; Hex addition and subtraction
HEXADD:
	MOV	CX,4
	CALL	GETHEX

	MOV	DI,DX
	MOV	CX,4
	CALL	GETHEX

	CALL	GETEOL

	PUSH	DX
	ADD	DX,DI
	MOV	[ADD_ARG],DX
	POP	DX
	SUB	DI,DX
	MOV	[SUB_ARG],DI
	MOV	DX,OFFSET DG:ADD_PTR
	CALL	PRINTF_CRLF

	RET

; Put the hex address in DS:SI in the argument list for a call to printf
OUTSI:
	MOV	CS:[HEX_ARG1],DS
	MOV	CS:[HEX_ARG2],SI
	RET

;Put the hex address in ES:DI in the argument list for a call to printf
OUTDI:
	MOV	[HEX_ARG1],ES
	MOV	[HEX_ARG2],DI
	RET

HEX_ADDRESS_ONLY:
	MOV	BYTE PTR [ARG_BUF],0
HEX_ADDRESS_STR:
	MOV	DX,OFFSET DG:HEX_PTR
STD_PRINTF:
	PUSH	DX
	CALL	PRINTF
	POP	DX			;ac000;restore dx

	RET

PRINTF_CRLF:
	PUSH	DX
	CALL	PRINTF
	POP	DX			;ac000;restore dx
CRLF:
	MOV	DX,OFFSET DG:CRLF_PTR
	PUSH	DX
	CALL	PRINTF
	POP	DX			;ac000;restore dx

	RET

HEX:
	MOV	AH,AL			; Save for second digit
	PUSH	CX
	MOV	CL,4
	SHR	AL,CL
	POP	CX

	CALL	DIGIT			; First digit

	MOV	AL,AH			; Now do digit saved in AH
DIGIT:
	AND	AL,0FH			; Mask to 4 bits
	ADD	AL,90H
	DAA
	ADC	AL,40H
	DAA
	AND	AL,7FH
	STOSB
	RET

RBUFIN:
	PUSH	AX
	PUSH	DX
	MOV	AH,STD_CON_STRING_INPUT
	MOV	DX,OFFSET DG:LBUFSIZ
	INT	21H

	POP	DX
	POP	AX
	RET

; Put one space in the printf output uffer
BLANK:
	MOV	AL,CHAR_BLANK
	STOSB
	RET

; Put CX spaces in the printf output buffer
TAB:
	JCXZ	TAB_RET

	CALL	BLANK

	LOOP	TAB
TAB_RET:
	RET

; Command Table. Command letter indexes into table to get
; address of command. PERR prints error for no such command.

COMTAB	DW	QUESTION_HELP		; ?
	DW	PERR			; @
	DW	ASSEM			; A
	DW	PERR			; B
	DW	COMPARE 		; C
	DW	DUMP			; D
	DW	ENTERDATA		; E
	DW	FILL			; F
	DW	GO			; G
	DW	HEXADD			; H
	DW	INPUT			; I
	DW	PERR			; J
ifdef JAPAN
	DW	SETDUMPMODE		; K
else
	DW	PERR			; K
endif
	DW	LOAD			; L
	DW	MOVE			; M
	DW	NAMED			; N
	DW	OUTPUT			; O
	DW	ZTRACE			; P
	DW	QUIT			; Q (QUIT)
	DW	REG			; R
	DW	SEARCH			; S
	DW	TRACE			; T
	DW	UNASSEM 		; U
	DW	PERR			; V
	DW	DWRITE			; W
	IF	SYSVER
	    DW	    SETUDEV		; X
	ELSE
	    DW	    DEBEMS
	ENDIF
	DW	PERR			; Y
	DW	PERR			; Z

QUESTION_HELP:
	MOV	DX, OFFSET DG:HELP_TEXT1
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:HELP_TEXT2
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:HELP_TEXT3
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:HELP_TEXT4
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:HELP_TEXT5
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:HELP_TEXT6
	JMP	STD_PRINTF


QUIT:
	INC	BYTE PTR [QFLAG]
	MOV	BX,[USER_PROC_PDB]
FIND_DEBUG:
	IF	NOT SYSVER
	    MOV     AH,SET_CURRENT_PDB
	    INT     21H
	ENDIF
	CALL	RELEASEPARITY		; let system do normal parity stuff

	CALL	RESTORE_DEB_VECT

	MOV	AX,(EXIT SHL 8)
	INT	21H

;======================= proc  prep_command_line =========================
; prep_command_line: This proc converts a Asian DBCS space delimiter (DB_SPACE)
;		     into 2 20h values.  In this way we can pass command
;		     lines throughout DEBUG without major modification
;		     to the source code.  This proc is invoked anywhere
;		     a command line is initially accessed.  In the case
;		     of DEBUG it is used in PARSCHK and INBUF.
;		     Any quoted string, a string delimited by ("), will
;		     be ignored.
;
;	input: ds - segment of command line
;	       si - offset of command line
;
;	output: command line with Asian blanks (DB_SPACE) converted to
;		2020h.
;
;=========================================================================

prep_command_line proc near		;command line conversion
    push    ax				;save affected regs.
    push    bx				;
    push    si				;

    mov     bl,00h			;initialize flag
					;bl is used to signal
					;  a quote delimiter
;   $DO 				;do while not CR
$$DO5:
	mov	al,[si] 		;move char from cmd line for compare
	cmp	al,CR			;is it a CR ?
;   $LEAVE  E				;if CR exit
    JE $$EN5

	cmp	al,quote_char		;is it a quote ?
;	$IF	Z			;if it is a quote
	JNZ $$IF7
	    xor     bl,01h		;set or reset the flag
;	$ENDIF
$$IF7:

	cmp	bl,01h			;is 1st quote set ?
;	$IF	NZ			;if not continue
	JZ $$IF9
	    call    TEST_LEAD		;test for dbcs lead byte
;	    $IF     C			;we have a lead byte
	    JNC $$IF10
		cmp	al,DB_SP_HI	;is it a dbcs char?
;		$IF	Z		;if a dbcs char
		JNZ $$IF11
		    mov     al,[si+1]	    ;move next char al
		    cmp     al,DB_SP_LO     ;is it an Asian blank?
;		    $IF     Z		    ;if an Asian blank
		    JNZ $$IF12
			mov	al,amer_blk ;set up moves
			mov	[si],al     ;  to replace
			mov	[si+1],al   ;  Asian blank w/20h
			inc	si	    ;point to si+1
;		    $ELSE		;if not an asian blank
		    JMP SHORT $$EN12
$$IF12:
			inc	si	;point to dbcs char
;		    $ENDIF		;
$$EN12:
;		$ENDIF			;
$$IF11:
;	    $ENDIF			;end lead byte test
$$IF10:
;	$ENDIF				;
$$IF9:
	inc	si			;point to si+1
;   $ENDDO				;end do while
    JMP SHORT $$DO5
$$EN5:
    pop     si				;restore affected regs.
    pop     bx				;
    pop     ax				;
    ret 				;return to caller
prep_command_line endp			;end proc


;=========================================================================
; DEBUG_LEAD_BYTE - This routine sets the lead-byte-pointers to point
;		    to the dbcs environmental vector table of lead bytes.
;		    This table will be used to determine if we have a
;		    dbcs lead byte.
;
;	Inputs - none
;
;	Outputs- pointer to dbcs environmental vector table of lead bytes
;		 LBTBL DD ?
;
;	Date	  : 6/16/87
;=========================================================================

DEBUG_LEAD_BYTE proc near		;an000;get lead byte vector

	push	ds			;an000;save affected regs
	push	es			;an000;
	push	si			;an000;

	mov	ax,(ECS_call shl 8) or 00h ;an000;get dbcs env. vector
	int	21h			;an000;invoke function

	assume	ds:nothing

	mov	word ptr cs:lbtbl[0],si ;an000;move offset of table
	mov	word ptr cs:lbtbl[2],ds ;an000;move segment of table

	pop	si			;an000;restore affected regs
	pop	es			;an000;
	pop	ds			;an000;

	ret				;an000;return to caller

DEBUG_LEAD_BYTE endp			;an000;end proc

;=========================================================================
; TEST_LEAD - This routine will determine whether or not we have a valid
;	      lead byte for a DBCS character.
;
;	Inputs : AL - Holds the byte to compare.  Passed by POP.		;an001;bgb
;
;	Outputs: Carry set if lead byte
;		 No carry if not lead byte
;
;	Date	  : 6/16/87
;=========================================================================

TEST_LEAD proc	near			;an000;check for dbcs lead byte

	push	ds			;an000;save affected regs
	push	si			;an000;
	push	ax			;an000;

	xchg	ah,al			;an000;ah used for compare
	mov	si,word ptr cs:lbtbl[2] ;an000;get segment of table
	mov	ds,si			;an000;
	mov	si,word ptr cs:lbtbl[0] ;an000;get offset of table

ck_next:

	lodsb				;an000;load al with byte table
	or	al,al			;an000;end of table?
;	$IF	z			;an000;yes, end of table
	jz	lead_exit		; exit with clear carry
	    cmp     al,ah		;an000;start > character?
;	    $IF     a			;an000;it is above
	    JNA $$IF21
		clc			;an000;clear carry flag
		jmp	short lead_exit	;an000;exit with clear carry
;	    $ELSE			;an000;
	    JMP SHORT $$EN21
$$IF21:
		lodsb			;an000;load al with byte table
		cmp	ah,al		;an000;character > end range
;		$IF	a		;an000;not a lead
		JNA $$IF23
		    jmp     ck_next	;an000;check next range
;		$ELSE			;an000;lead byte found
		JMP SHORT $$EN23
$$IF23:
		    stc 		;an000;set carry flag
;		$ENDIF			;an000;
$$EN23:
;	    $ENDIF			;an000;
$$EN21:
;	$ENDIF				;an000;

lead_exit:				;an000;exit from check

	pop	ax			;an000;
	pop	si			;an000;restore affected regs.
	pop	ds			;an000;

	ret				;an000;return to caller

TEST_LEAD endp				;an000;end proc



CODE	ENDS
	END	START

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\debmes.asm ===
PAGE	60,132				;
	TITLE	DEBMES.ASM - DEBUGGER MESSAGES PC DOS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
	IF1
	    %OUT    COMPONENT=DEBUG, MODULE=DEBMES
	ENDIF

;******************* START OF SPECIFICATIONS *****************************
;
; MODULE NAME:DEBMES.ASM
;
; DESCRIPTIVE NAME: SUPPLIES APPLICABLE MESSAGES TO DEBUG.ASM
;
; FUNCTION: THIS ROUTINE PROVIDES A MEANS BY WHICH MESSAGES MAY BE
;	    OUTPUT FOR DEBUG.  THIS IS HANDLED THROUGH THE MESSAGE
;	    RETRIEVER FUNCTION SYSDISPMSG.  TO
;	    FACILITATE MIGRATION AWAY FROM THE PRINTF UTILITY
;	    THE INTERFACE FOR INVOKING MESSAGES HAS REMAINED THE SAME.
;	    THIS IS ACCOMPLISHED THROUGH THE USE OF MACROS AND TABLES.
;	    EACH MESSAGE HAS A TABLE OF VALUES REQUIRED BY THE MESSAGE
;	    RETRIEVER UTILITIES.  THE MACROS OPERATE ON THESE TABLES
;	    TO SUPPLY SYSDISPMSG WITH THE VALUES NECESSARY
;	    TO PRINT A MESSAGE.
;
; ENTRY POINT: PRINTF
;
; INPUT: PRINTF IS INVOKED AS IT HAS ALWAYS BEEN INVOKED.  DX MUST
;	 POINT TO THE OFFSET OF A MESSAGE TABLE.  THE TABLE POINTED TO
;	 BY DX CONTAINS ALL THE NECESSARY INFORMATION FOR THAT MESSAGE
;	 TO BE PRINTED.
;
; EXIT-NORMAL: NO CARRY
;
; EXIT-ERROR: CARRY SET - EITHER MESSAGE NOT FOUND OR UNABLE TO BE DISPLAYED
;
; INTERNAL REFERENCES:
;
;	ROUTINE:DISP_MESSAGE - THIS MACRO IS USED TO DIPLAY A MESSAGE
;			       VIA SYSDISPMSG.	IT TAKES AS INPUT A POINTER
;			       IN DX.  THIS POINTER POINTS TO A TABLE OF
;			       VALUES FOR THE REQUESTED MESSAGE.
;			       DISP_MESSAGE OBTAINS THE VALUES IT NEEDS TO
;			       TO INVOKE SYSDISPMSG FROM THIS TABLE.
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: SYSMSG.INC  - THIS ROUTINE IS SUPPLIED TO INTERFACE THE
;			       MESSAGE RETRIEVER SERVICES.
;
; NOTES: THIS MODULE SHOULD BE PROCESSED WITH THE SALUT PRE-PROCESSOR
;	 WITH OPTIONS "PR".
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+DEBCONST+
;	      DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION DOS 4.0 - MESSAGE RETRIEVER IMPLEMENTED.  DMS:6/17/87
;
;
; COPYRIGHT: "MS DOS DEBUG Utility"
;	     "Version 4.00 (C) Copyright 1988 Microsoft"
;	     "Licensed Material - Property of Microsoft  "
;
;******************** END OF SPECIFICATIONS ******************************
;
;  CHANGE LOG:
;
;     DATE    WHO   #		       DESCRIPTION
;   --------  ---  ---	---------------------------------------------------
;   04/01/90  DIC  C02	Message was only printing first parameter, not
;			first and second.  I made the BX:CX message print
;			1 byte for BX and left CX at 4 bytes. Corresponding
;			change in message file, DEBUG line 38. (Compaq STR
;			#1804) (MS Bug #338)
;
;   05/25/90  AKM  C07	Problem fixed - Number of bytes writtem message
;                       was being printed with the wrong alignment &
;                       precision.
;			(Microsoft Bug #1156)
;
;============================================================================
.xlist

	include sysmsg.inc		;an000;message retriever

.list

msg_utilname <DEBUG>			;an000;DEBUG messages

;=========================================================================
;revised debmes.asm
;=========================================================================

fatal_error	equ	45		;fatal message handler error
unlim_width	equ	00h		;unlimited output width
pad_blank	equ	20h		;blank pad
pre_load	equ	00h		;an000;normal pre-load
pad_zero	equ	30h		;an000;zero pad


FALSE	EQU	0
TRUE	EQU	NOT FALSE

;SYSVER 	 EQU FALSE		 ;if true, i/o direct to bios
	INCLUDE SYSVER.INC

;=========================================================================
; macro disp_message: the macro takes the message obtained in get_message
;		      and displays it to the applicable screen device.
;=========================================================================

disp_message macro tbl			;an000;display message macro

	push	si			;an000;save affected reg
	push	di			;an000;
	push	ax			;an000;
	push	bx			;an000;
	push	cx			;an000;
	push	dx			;an000;

	push	tbl			;an000;exchange tbl with si
	pop	si			;an000;

	mov	ax,[si] 		;an000;move message number to ax
	mov	bx,[si+3]		;an000;display handle
	mov	cx,[si+7]		;an000;number of subs
	mov	dl,[si+9]		;an000;function type
	mov	di,[si+10]		;an000;input buffer if appl.
	mov	dh,[si+2]		;an000;message type
	mov	si,[si+5]		;an000;sublist

	call	sysdispmsg		;an000;display the message

	pop	dx			;an000;restore affected reg
	pop	cx			;an000;
	pop	bx			;an000;
	pop	ax			;an000;
	pop	di			;an000;
	pop	si			;an000;


endm					;an000;end macro disp_message

;=========================================================================
; macro disp_message: end macro
;=========================================================================



CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE

DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA


code	segment public byte		;an000;code segment
	assume	cs:dg,ds:dg,ss:dg,es:dg ;an000;

	public	printf			;an000;share printf
;;	public	disp_fatal		;an000;fatal error display
	public	pre_load_message	;an000;message pre load

.xlist

msg_services <MSGDATA>

.list

;=========================================================================
;	  include sysmsg.inc - message retriever services
;options selected:
;		   NEARmsg
;		   DISPLAYmsg
;		   LOADmsg
;		   INPUTmsg
;		   CHARmsg
;		   NUMmsg
;		   CLSAmsg
;		   CLSBmsg
;		   CLSCmsg
;		   CLSDmsg
;=========================================================================

.xlist

msg_services <LOADmsg>			;an000;load the messages
msg_services <DISPLAYmsg,CHARmsg,NUMmsg>;an000;get and display messages
msg_services <INPUTmsg> 		;an000;input from keyboard
msg_services <DEBUG.CLA,DEBUG.CLB>	;an000;message types
msg_services <DEBUG.CLC,DEBUG.CLD>	;an000;
msg_services <DEBUG.CL1,DEBUG.CL2>	;an000;

.list

;=========================================================================
; printf: printf is a replacement of the printf procedure used in DOS
;	  releases prior 4.00.	printf invokes the macros get_message and
;	  disp_message to invoke the new message handler.  the interface
;	  into printf will continue to be a pointer to a message passed
;	  in DX.  the pointer is pointing to more than a message now.  it
;	  is pointing to a table for that message containing all relevant
;	  information for retieving and printing the message.  the macros
;	  get_message and disp_message operate on these tables.
;=========================================================================

printf	proc	near			;an000;printf procedure

	disp_message dx 		;an000;display a message
;;	$if	c			;an000;if an error occurred
;;		call disp_fatal 	;an000;display the fatal error
;;	$endif				;an000;

	ret				;an000;return to caller

printf	endp				;an000;end printf


;=========================================================================
; disp_fatal: this routine displays a fatal error message in the event
;	      an error occurred in disp_message.
;=========================================================================

;;disp_fatal	  proc	  near		  ;an000;fatal error message
;;
;;	  mov	  ax,fatal_error	  ;an000;fatal_error number
;;	  mov	  bx,stdout		  ;an000;print to console
;;	  mov	  cx,0			  ;an000;no parameters
;;	  mov	  dl,no_input		  ;an000;no input will be coming
;;	  mov	  dh,UTILITY_MSG_CLASS	     ;an000;utility messages
;;	  call	  sysdispmsg		  ;an000;dispaly fatal error
;;	  ret				  ;an000;return to caller
;;
;;disp_fatal	  endp			  ;an000;end disp_fatal


;=========================================================================
; PRE_LOAD_MESSAGE : This routine provides access to the messages required
;		     by DEBUG.	This routine will report if the load was
;		     successful.  An unsuccessful load will cause DEBUG
;		     to terminate with an appropriate error message.
;
;	Date	  : 6/15/87
;=========================================================================

PRE_LOAD_MESSAGE	proc	near		;an000;pre-load messages

	call	SYSLOADMSG			;an000;invoke loader

;	$if	c				;an000;if an error
	JNC $$IF1
		pushf				;an000;save flags
		call	SYSDISPMSG		;an000;let him say why
		popf				;an000;restore flags
;	$endif					;an000;
$$IF1:

	ret					;an000;return to caller

PRE_LOAD_MESSAGE	endp			;an000;end proc

include msgdcl.inc

code	ends				;an000;end code segment


CONST	SEGMENT PUBLIC BYTE

	PUBLIC	ENDMES_PTR,CRLF_PTR,NAMBAD_PTR
	PUBLIC	NOTFND_PTR,NOROOM_PTR,BADVER
	PUBLIC	NOSPACE_PTR,DRVLET
	PUBLIC	ACCMES_PTR,PROMPT_PTR
	PUBLIC	TOOBIG_PTR,SYNERR_PTR,BACMES_PTR
	PUBLIC	HEXERR_PTR,HEXWRT_PTR,WRTMES_PTR,EXEBAD_PTR,EXEWRT_PTR
	PUBLIC	EXECEMES_PTR, PARITYMES_PTR, NONAMESPEC_PTR
	PUBLIC	dr1_ptr,dr2_ptr,dr3_ptr,dr4_ptr 	;ac000;new messages
	PUBLIC	CHANGE_FLAG_PTR,DF_ERROR,BF_ERROR,BR_ERROR,BP_ERROR
	PUBLIC	CONSTEND

;======================= TABLE STRUCTURE =================================
;
;	byte 1	-	message number of message to be displayed
;	byte 2	-	message type to be used, i.e.;class 1, utility, etc.
;	byte 3	-	display handle, i.e.; console, printer, etc.
;	byte 4	-	pointer to substitution list, if any.
;	byte 6	-	number of replaceable parameters, if any.
;	byte 7	-	type of input from keyboard, if any.
;	byte 8	-	pointer to buffer for keyboard input, if any.
;
;=========================================================================

	IF	SYSVER

	    PUBLIC  BADDEV_PTR,BADLSTMES_PTR


baddev_ptr  label   word		;an000;"Bad device name",0
	    dw	    0006		;an000;message number 6
	    db	    UTILITY_MSG_CLASS	   ;an000;utility message
	    dw	    stdout		;an000;display handle
	    dw	    00			;an000;sublist
	    dw	    00			;an000;no subs
	    db	    no_input		;an000;no keyboard input
	    dw	    00			;an000;no keyboard buffer

badlstmes_ptr label word		;an000;"Couldn't open list device
					;      PRN","Enter name of list
					;      device?"
	    dw	    0007		;an000;message number 7
	    db	    UTILITY_MSG_CLASS	   ;an000;utility message
	    dw	    stdout		;an000;display handle
	    dw	    00			;an000;sublist
	    dw	    00			;an000;no subs
	    db	    DOS_KEYB_INP	;an000;keyboard input
	    dw	    00			;an000;no keyboard buffer


	ENDIF

;================= REPLACEABLE PARAMETER SUBLIST STRUCTURE ===============
;
;	byte 1	-	substitution list size, always 11
;	byte 2	-	reserved for use by message handler
;	byte 3	-	pointer to parameter to be used as a substitution
;	byte 7	-	which parameter is this to replace, %1, %2, etc.
;	byte 8	-	determines how the parameter is to be output
;	byte 9	-	determines the maximum width of the parameter string
;	byte 10 -	determines the minimum width of the parameter string
;	byte 11 -	define what is to be used as a pad character
;
;=========================================================================


;=========================================================================
;		replaceable parameter sublists
;=========================================================================

db_synerr_sub label dword		;an000;synerr parameters
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum width
	db	pad_blank		;an000;blank pad

db_change_sub label dword		;an000;synerr parameters
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum width
	db	pad_blank		;an000;blank pad

db_drive_error label dword		;an000;drive error parameters
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:drvlet		;an000;point to drive letter
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	01			;an000;1 byte
	db	01			;an000;1 byte
	db	pad_blank		;an000;blank pad



;=========================================================================
;		end replaceable parameter sublists
;=========================================================================


crlf_ptr label	word			;an000;13,10,0
	dw	0008			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


bacmes_ptr label word			;an000;32,8,0
	dw	0044			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


badver	label	word			;an000;"Incorrect DOS version"
	dw	0001			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

endmes_ptr label word			;an000;13,10,"Program terminated
					;	      normally",0
	dw	0009			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


nambad_ptr label word			;an000;"Invalid drive specification",0
	dw	0010			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


notfnd_ptr label word			;an000;"File not found",0
	dw	0002			;an000;message number
	db	Ext_Err_Class		;an000;extended error
	dw	stderr			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


noroom_ptr label word			;an000;"File creation error",0
	dw	0012			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


nospace_ptr label word			;an000;"Insufficient space on disk",0
	dw	0013			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


dr1_ptr label	word			;an000;"Disk error reading drive %1"
	dw	0014			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_drive_error	;an000;sublist
	dw	01			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


dr2_ptr label	word			;an000;"Disk error writing drive %1"
	dw	0015			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_drive_error	;an000;sublist
	dw	01			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


dr3_ptr label	word			;an000;"Write protect error reading
					;	drive %1"
	dw	0016			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_drive_error	;an000;sublist
	dw	01			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


dr4_ptr label	word			;an000;"Write protect error writing
					;	drive %1"
	dw	0017			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_drive_error	;an000;sublist
	dw	01			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


toobig_ptr label word			;an000;"Insufficient memory",0
	dw	0008			;an000;message number
	db	Ext_Err_Class		;an000;utility message
	dw	stderr			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

synerr_ptr label word			;an000;"%1^Error",0
	dw	0019			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_synerr_sub	;an000;sublist
	dw	01			;an000;1 sub - leading spaces
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


hexerr_ptr label word			;an000;"Error in EXE or HEX file",0
	dw	0020			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

exebad_ptr label word			;an000;"Error in EXE or HEX file",0
	dw	0020			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


hexwrt_ptr label word			;an000;"EXE and HEX files cannot be
					;	written",0
	dw	0021			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

exewrt_ptr label word			;an000;"EXE and HEX files cannot be
					;	written",0
	dw	0021			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


execemes_ptr label word 		;an000;"EXEC failure",0
	dw	0022			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


nonamespec_ptr label word		;an000;"(W)rite error, no destination
					;	defined",0
	dw	0023			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

accmes_ptr label word			;an000;Access denied",0
	dw	0024			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


paritymes_ptr label word		;an000;"Parity error or nonexistant
					;	memory error detected",0
	dw	0025			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


prompt_ptr label word			;an000;"-",0
	dw	0026			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


change_flag_ptr label word		;an000;"%1 -",0
	dw	0027			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_change_sub	;an000;sublist
	dw	01			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

df_error	db	"df",0
bf_error	db	"bf",0
br_error	db	"br",0
bp_error	db	"bp",0
drvlet		db	"A",0

CONSTEND LABEL	BYTE

CONST	ENDS

DATA	SEGMENT PUBLIC BYTE

	PUBLIC	HEX_ARG1,HEX_ARG2,HEX_PTR,ARG_BUF
	PUBLIC	ARG_BUF_PTR,ADD_PTR,ERR_TYPE
	PUBLIC	CRLF_PTR,ADD_ARG,SUB_ARG,PROMPT_PTR
	PUBLIC	REGISTER_PTR,REG_NAME,REG_CONTENTS
	PUBLIC	SINGLE_REG_PTR,SINGLE_REG_ARG
	PUBLIC	ERRMES_PTR,LOC_PTR,LOC_ADD
	PUBLIC	LITTLE_PTR,BIG_PTR,LITTLE_CONTENTS
	PUBLIC	BIG_CONTENTS,COMP_PTR,COMP_ARG1,COMP_ARG2
	PUBLIC	COMP_ARG3,COMP_ARG4,COMP_ARG5,COMP_ARG6
	PUBLIC	WRTMES_PTR,WRT_ARG1,WRT_ARG2
	PUBLIC	IOTYP,MESTYP
	PUBLIC	ONE_CHAR_BUF,ONE_CHAR_BUF_PTR
	PUBLIC	OPBUF,UNASSEM_LN_PTR
	PUBLIC  QMES_1
	PUBLIC	QMES_2
	PUBLIC  QMES_3
	PUBLIC  QMES_4
	PUBLIC  QMES_5
	PUBLIC	HELP_TEXT1
	PUBLIC	HELP_TEXT2
	PUBLIC	HELP_TEXT3
	PUBLIC	HELP_TEXT4
	PUBLIC	HELP_TEXT5
	PUBLIC	HELP_TEXT6

	PUBLIC	xm_han_ret_ptr
	PUBLIC	xm_mapped_ptr
	PUBLIC	xm_err80_ptr
	PUBLIC	xm_err83_ptr
	PUBLIC	xm_err84_ptr
	PUBLIC	xm_err85_ptr
	PUBLIC	xm_err86_ptr
	PUBLIC	xm_err87_ptr
	PUBLIC	xm_err88_ptr
	PUBLIC	xm_err89_ptr
	PUBLIC	xm_err8a_ptr
	PUBLIC	xm_err8b_ptr
	PUBLIC	xm_err8d_ptr
	PUBLIC	xm_err8e_ptr
	PUBLIC	xm_err_gen_ptr
	PUBLIC	xm_parse_err_ptr
	PUBLIC	xm_status_ptr
	PUBLIC	xm_page_seg_ptr
	PUBLIC	xm_deall_ptr
	PUBLIC	xm_errff_ptr
	PUBLIC	xm_unall_ptr
	PUBLIC	xm_han_alloc_ptr

	EXTRN	XM_HANDLE_RET:word
	EXTRN	XM_LOG:byte
	EXTRN	XM_PHY:byte
	EXTRN	XM_PAGE_CNT:word
	EXTRN	XM_FRAME:word
	EXTRN	XM_DEALL_HAN:word
	EXTRN	XM_ALLOC_PG:word
	EXTRN	XM_TOTAL_PG:word
	EXTRN	XM_HAN_ALLOC:word
	EXTRN	XM_HAN_TOTAL:word

;=========================================================================
;		    begin parameter sublists
;=========================================================================

;======================= unassemble parameter sublists ===================

db_unassem_sb1 label dword		;an000;unassemble parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum width
	db	pad_blank		;an000;blank pad

db_unassem_sb2 label dword		;an000;unassemble parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:opbuf		;an000;point to argument buffer
	db	02			;an000;parameter two
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum width
	db	pad_blank		;an000;blank pad


;================== hex argument parameter sublists ======================

db_hexarg_sb1 label dword		;an000;hex argument parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:hex_arg1		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	right_align+bin_hex_word
					;an000;right align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_hexarg_sb2 label dword		;an000;hex argument parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:hex_arg2		;an000;point to argument buffer
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_hexarg_sb3 label dword		;an000;hex argument parameter 3
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	03			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum width
	db	pad_blank		;an000;blank pad


;================== hex add parameter sublists ===========================

db_hexadd_sb1 label dword		;an000;hex add parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:add_arg		;an000;point to add_arg
	db	01			;an000;parameter one
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_hexadd_sb2 label dword		;an000;hex argument parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:sub_arg		;an000;point to sub_arg
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;================== end hex add parameter sublists =======================

;================== single register parameter sublists ===================
;string: "%1 %2",13,10,":",0

db_singrg_sb1 label dword		;an000;single register parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

db_singrg_sb2 label dword		;an000;single register parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:single_reg_arg	;an000;point single_reg_arg
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;================== register parameter sublists ==========================
;string: "%1=%2  ",0

db_regist_sb1 label dword		;an000;register parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:reg_name		;an000;point to reg_name
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	02			;an000;unlimited width
	db	02			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

db_regist_sb2 label dword		;an000;register parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:reg_contents 	;an000;point to reg_contents
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;================== error message parameter sublists =====================
;string: "%1 Error",0

db_error_sb1 label dword		;an000;error message parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:err_type		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

;================== writing message parameter sublists ===================
;string: "Writing %1%2 bytes",0

db_wrtmes_sb1 label dword		;an000;wrtmes parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:wrt_arg1		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	right_align+bin_hex_word
					;an000;right align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_wrtmes_sb2 label dword		;an000;wrtmes parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:wrt_arg2		;an000;point to argument buffer
	db	02			;an000;parameter two
;C07	db	left_align+bin_hex_word
	db	right_align+bin_hex_word                                  ;C07
					;an000;left align/word/hexadecimal
;C02	db	04			;an000;maximum of 4 bytes
;C02	db	04			;an000;minimum of 4 bytes
;C07	db	01			;an000;maximum of 4 bytes	    ;C02
;C07	db	00			;an000;minimum of 4 bytes	    ;C02
	db	04			;an000;maximum of 4 bytes	  ;C07
	db	01			;an000;minimum of 4 bytes         ;C07
	db	pad_zero		;an000;blank pad

;================== loc address parameter sublists =======================
;string: "%1:%2=",0

db_locadd_sb1 label dword		;an000;loc address parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	right_align+Char_field_ASCIIZ
					;an000;left align/ASCIZZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

db_locadd_sb2 label dword		;an000;loc address parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:loc_add		;an000;point to loc_add
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;================== little contents parameter sublists ===================
;string "%1",0

db_little_sb1 label dword		;an000;one byte output parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:little_contents	;an000;point to little_contents
	db	01			;an000;parameter one
	db	right_align+bin_hex_byte
					;an000;left align/byte/hexadecimal
	db	02			;an000;maximum of 2 bytes
	db	02			;an000;minimum of 2 bytes
	db	pad_zero		;an000;blank pad

;================== big argument parameter sublists ======================
;string: "%1",0

db_big_sb1 label dword			;an000;word argument parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:big_contents 	;an000;point to big_contents
	db	01			;an000;parameter one
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;======================= comp argument parameter sublists ================
;string "%1:%2  %3  %4  %5:%6",0

db_comp_sb1 label dword 		;an000;comp argument parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg1		;an000;point to comp_arg1
	db	01			;an000;parameter one
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_comp_sb2 label dword 		;an000;comp argument parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg2		;an000;point to comp_arg2
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_comp_sb3 label dword 		;an000;comp argument parameter 3
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg3		;an000;point to comp_arg3
	db	03			;an000;parameter three
	db	right_align+bin_hex_byte
					;an000;left align/byte/hexadecimal
	db	02			;an000;maximum of 2 bytes
	db	02			;an000;minimum of 2 bytes
	db	pad_zero		;an000;blank pad

db_comp_sb4 label dword 		;an000;comp argument parameter 4
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg4		;an000;point to comp_arg4
	db	04			;an000;parameter four
	db	right_align+bin_hex_byte
					;an000;left align/byte/hexadecimal
	db	02			;an000;maximum of 2 bytes
	db	02			;an000;minimum of 2 bytes
	db	pad_zero		;an000;blank pad

db_comp_sb5 label dword 		;an000;comp argument parameter 5
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg5		;an000;point to comp_arg5
	db	05			;an000;parameter five
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_comp_sb6 label dword 		;an000;comp argument parameter 6
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg6		;an000;
	db	06			;an000;parameter 6
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;======================= disk error parameter sublists ===================
;string: "%1 error %2 drive %3",0

db_disk_sb1 label dword 		;an000;disk argument parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:mestyp		;an000;point to mestyp
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

db_disk_sb2 label dword 		;an000;disk argument parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:iotyp		;an000;point to iotyp
	db	02			;an000;parameter two
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

db_disk_sb3 label dword 		;an000;disk argument parameter 3
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:drive		;an000;point to drive
	db	03			;an000;parameter three
	db	left_align+char_field_char
					;an000;left align/character/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

arg_buf_sb1 label dword 		;an000;argument sublist
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_Field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

one_char_sb1 label dword		;an000;character buffer sublist
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:one_char_buf 	;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_Field_Char
					;an000;left align/character/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

xm_han_sub	label	dword		;an000;sublist for handles
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_HANDLE_RET	;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	30h			;an000;pad with zeros

xm_map_sub	label	dword		;an000;sublist for mappings
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_LOG		;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Byte;an000;
	db	02			;an000;maximum width
	db	02			;an000;minimum width
	db	30h			;an000;pad with zeros

	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_PHY		;an000;parameter 2
	db	02			;an000;parameter 2
	db	right_align+Bin_Hex_Byte;an000;
	db	02			;an000;maximum width
	db	02			;an000;minimum width
	db	30h			;an000;pad with zeros

xm_sta_sub	label	word		;an000;sublist for status
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_HANDLE_RET	;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	30h			;an000;pad with zeros

	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_PAGE_CNT		;an000;parameter 2
	db	02			;an000;parameter 2
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	30h			;an000;pad with zeros

xm_page_seg_sub label	word		;an000;sublist for frame seg status
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_PHY		;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Byte;an000;
	db	02			;an000;maximum width
	db	02			;an000;minimum width
	db	30h			;an000;pad with zeros

	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_FRAME		;an000;parameter 2
	db	02			;an000;parameter 2
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	30h			;an000;pad with zeros

xm_deall_sub	label	word		;an000;sublist for handle deallocation
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_DEALL_HAN 	;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Byte;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	30h			;an000;pad with zeros

xm_unall_sub	label	word		;an000;sublist unallocated page report
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_ALLOC_PG		;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	20h			;an000;pad with blanks

	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_TOTAL_PG		;an000;parameter 1
	db	02			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	20h			;an000;pad with zeros


xm_han_alloc_sub label	 word		 ;an000;sublist unallocated page report
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_HAN_ALLOC 	;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	20h			;an000;pad with blanks

	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_HAN_TOTAL 	;an000;parameter 1
	db	02			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	20h			;an000;pad with zeros
;=========================================================================
;		    end parameter sublists
;=========================================================================


unassem_ln_ptr label word		;an000;"%1%2",0
	dw	0032			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_unassem_sb1	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


hex_ptr label	word			;an000;"%1:%2 %3",0
	dw	0033			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_hexarg_sb1	;an000;sublist
	dw	03			;an000;3 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


add_ptr label	word			;an000;"%1  %2",0
	dw	0034			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_hexadd_sb1	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer



single_reg_ptr label word		;an000;"%1 %2",13,10,":",0
	dw	0035			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_singrg_sb1	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer



register_ptr label word 		;an000;"%1=%2  ",0 ex: AX=FFFF
	dw	0036			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_regist_sb1	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


errmes_ptr label word			;an000;"%1 Error",0
	dw	0037			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_error_sb1 	;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


wrtmes_ptr label word			;an000;"Writing %1 bytes",0
	dw	0038			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_wrtmes_sb1	;an000;sublist
;C02	dw	01			;an000;1 sub
	dw	02			;an000;1 sub			   ;C02
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


loc_ptr label	word			;an000:"%1;%2=",0 ex:CX:0000
	dw	0039			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_locadd_sb1	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


little_ptr label word			;an000;"%1",0 ex:FF
	dw	0040			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_little_sb1	;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


big_ptr label	word			;an000;"%1",0
	dw	0041			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_big_sb1		;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


comp_ptr label	word			;an000;"%1:%2  %3  %4  %5:%6",0
	dw	0042			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_comp_sb1		;an000;sublist
	dw	06			;an000;6 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


arg_buf_ptr label	word		;an000;"%1"
	dw	0046			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:arg_buf_sb1		;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


one_char_buf_ptr label	word		;an000;"%1"
	dw	0047			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:one_char_sb1 	;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_unall_ptr	label	word		;an000;unallocated message report
	dw	0050			;an000;"%1 of a total %2 EMS pages
					;      have been allocated",cr,lf
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_UNALL_SUB 	;an000;sublist
	dw	02			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_han_alloc_ptr label	 word		;an000;unallocated message report
	dw	0051			;an000;"%1 of a total %2 EMS handles
					;      have been allocated",cr,lf
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_HAN_ALLOC_SUB	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_han_ret_ptr	label	word		;an000;prints handle created
	dw	0055			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_HAN_SUB		;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_mapped_ptr	label	word		;an000;prints log/phy pages
	dw	0056			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_MAP_SUB		;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err80_ptr	label	word		;an000;ems error message
	dw	0057			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err83_ptr	label	word		;an000;ems error message
	dw	0058			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err84_ptr	label	word		;an000;ems error message
	dw	0059			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err85_ptr	label	word		;an000;ems error message
	dw	0060			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err86_ptr	label	word		;an000;ems error message
	dw	0061			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err87_ptr	label	word		;an000;ems error message
	dw	0062			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err88_ptr	label	word		;an000;ems error message
	dw	0063			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err89_ptr	label	word		;an000;ems error message
	dw	0064			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err8a_ptr	label	word		;an000;ems error message
	dw	0065			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err8b_ptr	label	word		;an000;ems error message
	dw	0066			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err8d_ptr	label	word		;an000;ems error message
	dw	0067			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err8e_ptr	label	word		;an000;ems error message
	dw	0068			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err_gen_ptr	label	word		;an000;ems error message
	dw	0070			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_parse_err_ptr label	word		;an000;input error message
	dw	0071			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_status_ptr	label	word		;an000;prints status of EMS
	dw	0072			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_STA_SUB		;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_page_seg_ptr label	word		;an000;"Physical page %1 = Frame
					;	segment %2"
	dw	0075			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_PAGE_SEG_SUB	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_deall_ptr	label	word		;an000;"Handle %1 deallocated"

	dw	0076			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_DEALL_SUB 	;an000;sublist
	dw	01			;an000;1 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_errff_ptr	    label word		;an000;"EMS not installed"

	dw	0078			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;0 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

qmes_1 label	word			;
	dw	0090			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

qmes_2 label	word			;
	dw	0091			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

qmes_3 label	word			;
	dw	0092			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00
			;an000;no keyboard buffer
qmes_4 label	word			;
	dw	0093			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

qmes_5 label	word			;
	dw	0094			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text1	label	word
	dw	0100			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text2	label	word
	dw	0101			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text3	label	word
	dw	0102			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text4	label	word
	dw	0103			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text5	label	word
	dw	0104			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text6	label	word
	dw	0105			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

arg_buf 	db   80 dup (?) 	;an000;argument buffer
one_char_buf	db   ?			;an000;character buffer

opbuf	db	51h dup (?)

hex_arg1 dw	?
hex_arg2 dw	?

add_arg dw	?
sub_arg dw	?

single_reg_arg dw ?

reg_name dw	?
reg_contents dw ?

err_type db	3	dup(0)		;ac000;changed to hold bf,bp,etc.

wrt_arg1 dw	?
wrt_arg2 dw	?

loc_add dw	?

little_contents dw ?
big_contents dw ?

comp_arg1 dw	?
comp_arg2 dw	?
comp_arg3 dw	?
comp_arg4 dw	?
comp_arg5 dw	?
comp_arg6 dw	?

mestyp	dw	?
iotyp	dw	?
drive	db	?


DATA	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\debug.inc ===
;**************************************************************************
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;*									                                                               * 
;*  Change History:							                                                *
;*									                                                               *
;*  DATE   ID	MSFT#  STR#	      Descripton			                             *
;* ------ ----	----- -----  --------------------------------------------  *
;* 05APR90 C05	 990  ????   The XS command always returned a value of	    *
;*	                  		     (FF) for the total number of handles that	    *
;*                  			     are supported.  Now, for EMS V4.0, the	       *
;*			                       actual # of total handles will be displayed.  *
;*                  			     See also: DEBEMS.SAL module.		                *
;**************************************************************************

;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DEBEQU.SAL
;
; DESCRIPTIVE NAME: EQUATES NEEDED BY DEBUG
;
; FUNCTION: PROVIDES EQUATES NEEDED BY DEBUG
;
; ENTRY POINT: NA
;
; INPUT: NA
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES: NA
;
; EXTERNAL REFERENCES: NA
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT DBCS HANDLING	DMS:6/17/87
;				- IMPLEMENT MESSAGE RETRIEVER	DMS:6/17/87
;				- > 32 MB SUPPORT		DMS:6/17/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;======================= END OF SPECIFICATIONS ===========================


; Version control switches moved to VERSION.INC

	INCLUDE SYSVER.INC

SETCNTC EQU	TRUE			; If this is FALSE, DEBUG will not set
					; the Control C int vector

PROMPT	EQU	"-"
FCB	EQU	5CH
EXEFCB	EQU	FCB
BUFLEN	EQU	80			; Maximum length of line input buffer
BPMAX	EQU	10			; Maximum number of breakpoints
BPLEN	EQU	5*BPMAX 		; Length of breakpoint table
REGTABLEN EQU	14			; Number of registers
SEGDIF	EQU	0
BUFSIZ	EQU	512

BXREG	EQU	"B"+5800H		; "BX"
BPREG	EQU	"B"+5000H		; "BP"
SIREG	EQU	"S"+4900H		; "SI"
DIREG	EQU	"D"+4900H		; "DI"
COMMA	EQU	2C00H
OPBUFLEN EQU	35

	IF	IBMVER
MASK_PORT   EQU     21H 		; 8259 interrupt control register
INT_MASK    EQU     11111111B		; Disable ALL interrupts
	ENDIF

CR	EQU	13			;CARRIAGE RETURN
LF	EQU	10			;LINE FEED
CHAR_TAB EQU	9			;TAB
CHAR_BACKSPACE EQU 8			;BACKSPACE CHARACTER
CHAR_EOF EQU	1AH			;END OF FILE CHARACTER
CHAR_RUBOUT EQU 7FH			;RUBOUT CHARACTER

CHAR_EQUAL EQU	"="			;CHARACTER EQUAL
CHAR_MINUS EQU	"-"			;MINUS CHARACTER
CHAR_BLANK EQU	" "			;BLANK CHARACTER
DOUBLE_QUOTE EQU '"'			;DOUBLE QUOTE CHARACTER
SINGLE_QUOTE EQU "'"			;SINGLE QUOTE CHARACTER
CHAR_COMMA EQU	","			;CHARACTER COMMA
CHAR_PERIOD EQU "."			;CHARACTER PERIOD
CHAR_COLON EQU	":"			;CHARACTER COLON
CHAR_SEMICOLON EQU ";"			;CHARACTER SEMICOLON
CHAR_LEFT_BRACKET EQU "["		;CHARACTER LEFT BRACKET
CHAR_AT_SIGN EQU "@"			;CHARACTER "AT" SIGN
CHAR_ZERO EQU	"0"			;CHARACTER ZERO

LOWER_A EQU	"a"			;LOWER CASE CHARACTER "a"
LOWER_Z EQU	"z"			;LOWER CASE CHARACTER "z"

UPPER_A EQU	"A"			;UPPER CASE CHARACTER "A"
UPPER_C EQU	"C"			;UPPER CASE CHARACTER "C"
UPPER_E EQU	"E"			;UPPER CASE CHARACTER "E"
UPPER_F EQU	"F"			;UPPER CASE CHARACTER "F"
UPPER_L EQU	"L"			;UPPER CASE CHARACTER "L"
UPPER_M EQU	"M"			;UPPER CASE CHARACTER "M"
UPPER_N EQU	"N"			;UPPER CASE CHARACTER "N"
UPPER_P EQU	"P"			;UPPER CASE CHARACTER "P"
UPPER_S EQU	"S"			;UPPER CASE CHARACTER "S"
UPPER_X EQU	"X"			;UPPER CASE CHARACTER "X"
UPPER_Z EQU	"Z"			;UPPER CASE CHARACTER "Z"
FOR_SLASH  EQU	'/'
Q_MARK	EQU	'?'

VEC_SING_STEP EQU 1			;ID OF THE SINGLE STEP VECTOR
VEC_BREAKPOINT EQU 3			;ID OF THE BREAKPOINT VECTOR
VEC_TERM_ADDR EQU 22H			;ID OF THE TERMINATE ADDRESS VECTOR
VEC_CTRL_BREAK EQU 23H			;ID OF THE CTRL BREAK EXIT ADDRESS VECTOR
VEC_CRIT_ERR EQU 24H			;ID OF THE CRITICAL ERROR HANDLER VECTOR
VEC_PRIMITIVE_DISK_READ EQU 25H 	;ID OF THE PRIMITAVE DISK READ VECTOR
VEC_PRIMITIVE_DISK_WRITE EQU 26H	;ID OF THE PRIMITAVE DISK WRITE VECTOR
GENERIC_IOCTL EQU 440DH 		;an000;Generic IOCtl function
READ_WRITE EQU	08H			;an000;read/write relative sectors
READ_SECTOR EQU 00H			;an000;currently unknown value
WRITE_SECTOR EQU 00H			;an000;currently unknown value

SET_DRIVEID_OPTION EQU 1		;AL VALUE FOR "PARSE FILENAME" FUNCTION
LSEEK_FROM_START EQU 0			;AL VALUE FOR "LSEEK" FUNCTION
LSEEK_EOF_OPTION EQU 2			;AL VALUE FOR "LSEEK" FUNCTION

;======================= EMS Equates Begin ===============================

EMS_GET_MAN_STAT equ 40h		;an000;function 40h, int 67h
EMS_UNALL_PG_CNT equ 42h		;an000;funciton 42h, int 67h
EMS_HAN_ALLOC equ 43h			;an000;function 43h, int 67h
EMS_MAP_MEMORY equ 44h			;an000;function 44h, int 67h
EMS_PAGE_DEALL equ 45h			;an000;function 45h, int 67h
EMS_VERSION equ 46h			;an000;function 46h, int 67h
EMS_SAVE_PAGE_MAP equ 47h		;an000;function 47h, int 67h
EMS_REST_PAGE_MAP equ 48h		;an000;function 48h, int 67h
EMS_HANDLE_CNT equ 4bh			;an000;function 4bh, int 67h
EMS_HANDLE_PAGES equ 4dh		;an000;function 4dh, int 67h
EMS_GET_SET_PG_MP equ 4eh		;an000;function 4eh, int 67h
EMS_TOT_HANDLES   equ 5402h ;  Function 54h, sub-func:02 Get total handles  ; C05
EMS_GET_PAGE_MAP equ 00h		;an000;sub function 00h of
EMS_PG_FRAME equ 5800h			;an000;function 58h, int 67h
					;      function 4eh, int 67h
EMS_SET_PAGE_MAP equ 01h		;an000;sub function 01h of
					;      function 4eh, int 67h
EMS_HANDLE_TOTAL equ 0ffh		;an000;total possible handles

EMS_LIM_40 equ	040h			;an000;LIM 4.0 I.D.

XM_ERR80 equ	80h			;an000;error message type
XM_ERR83 equ	83h			;an000;error message type
XM_ERR84 equ	84h			;an000;error message type
XM_ERR85 equ	85h			;an000;error message type
XM_ERR86 equ	86h			;an000;error message type
XM_ERR87 equ	87h			;an000;error message type
XM_ERR88 equ	88h			;an000;error message type
XM_ERR89 equ	89h			;an000;error message type
XM_ERR8A equ	8Ah			;an000;error message type
XM_ERR8B equ	8Bh			;an000;error message type
XM_ERR8D equ	8Dh			;an000;error message type
XM_ERR8E equ	8Eh			;an000;error message type
XM_ERR8F equ	8Fh			;an000;error message type
XM_NOT_INST equ 0ffh			;an000;EMS not inst

;======================= EMS Equates End =================================

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edit\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edit\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\debug\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\edlstdsw.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)stdsw.asm	1.1 85/04/10
; Use the switches below to produce the standard Microsoft version or the IBM
; version of the operating system


;include EDLVERS.INC			;IBM/MSVER/JAPVER switches


WANG	EQU	FALSE
Rainbow EQU	FALSE


; Set this switch to cause DOS to move itself to the end of memory
HIGHMEM EQU	FALSE

	IF	IBM
ESCCH	EQU	0			; character to begin escape seq.
CANCEL	EQU	27			;Cancel with ESCAPE
TOGLPRN EQU	TRUE			;One key toggles printer echo
ZEROEXT EQU	TRUE
	ELSE
	IF	WANG			;Are we assembling for WANG?
ESCCH	EQU	1FH			;Yes. Use 1FH for escape character
	ELSE
ESCCH	EQU	1BH
	ENDIF
CANCEL	EQU	"X"-"@"                 ;Cancel with Ctrl-X
TOGLPRN EQU	FALSE			;Separate keys for printer echo on
					;and off
ZEROEXT EQU	TRUE
	ENDIF


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\edlmes.asm ===
PAGE	60,132;
	title	EDLIN Messages
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: EDLMES.SAL
;
; DESCRIPTIVE NAME: MESSAGE RETRIEVER INTERFACE MODULE
;
; FUNCTION: THIS MODULE PROVIDES AN INTERFACE FOR THE MODULES THAT ARE
;	    NEEDED TO INVOKE THE MESSAGE RETRIEVER.
;
; ENTRY POINT: PRINTF
;
; INPUT: OFFSET CARRIED IN DX TO APPLICABLE MESSAGE TABLE
;
; EXIT NORMAL: NO CARRY
;
; EXIT ERROR : CARRY
;
; INTERNAL REFERENCES:
;
;	ROUTINE: PRINTF - PROVIDES THE ORIGINAL INTERFACE FOR THE ORIGINAL
;			  PRINTF USED PRIOR TO VERSION 4.00.  PRINTS MESSAGES.
;
;		 DISP_MESSAGE - BUILDS THE REGISTERS NECESSARY FOR INVOCATION
;			  OF THE MESSAGE RETRIEVER, BASED ON THE TABLE
;			  POINTED TO BY DX.
;
;		 DISP_FATAL - INVOKED IF AN ERROR OCCURS (CARRY) IN THE
;			  MESSAGE RETRIEVER.  IT DISPLAYS THE APPROPRIATE
;			  MESSAGE.
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: SYSLOADMSG - LOAD MESSAGES FOR THE MESSAGE RETRIEVER
;		 SYSDISPMSG - DISPLAYS THE REQUESTED MESSAGE
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
; REVISION HISTORY:
;
;	AN000	VERSION DOS 4.00 - IMPLEMENTATION OF MESSAGE RETRIEVER
;
; COPYRIGHT: "MS DOS EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
; MICROSOFT REVISION HISTORY
;
;	 MODIFIED BY: AARON R
;		      M.A. U
;		      N. P
;======================= END OF SPECIFICATIONS ===========================

.xlist

include sysmsg.inc				;an000;message retriever

msg_utilname <EDLIN>				;an000;EDLIN messages
.list
;-----------------------------------------------------------------------;
;									;
;	Done for Vers 2.00 (rev 9) by Aaron R				;
;	Update for rev. 11 by M.A. U					;
;	Printf for 2.5 by Nancy P					;
;									;
;-----------------------------------------------------------------------;

;=========================================================================
; revised edlmes.asm
;=========================================================================

fatal_error	equ	30			;an000;fatal message handler
unlim_width	equ	00h			;an000;unlimited output width
pad_blank	equ	20h			;an000;blank pad
pre_load	equ	00h			;an000;normal pre-load




message_table	struc				;an000;struc for message table

	entry1	dw	0			;an000;message number
	entry2	db	0			;an000;message type
	entry3	dw	0			;an000;display handle
	entry4	dw	0			;an000;pointer to sublist
	entry5	dw	0			;an000;substitution count
	entry6	db	0			;an000;use keyb input?
	entry7	dw	0			;an000;keyb buffer to use

message_table	ends				;an000;end struc

;=========================================================================
; macro disp_message: this macro takes a pointer to a message table
;		      and displays the applicable message based on
;		      the table's contents.
;		      this is to provide an interface into the module
;		      of the message retriever, SYSDISPMSG.
;
;	Date	  : 6/11/87
;=========================================================================

disp_message	macro	tbl			;an000;display message macro

	push	bx				;an000;
	push	cx				;an000;
	push	dx				;an000;
	push	di				;an000;
	push	si				;an000;

	push	tbl				;an000;exchange tbl with si
	pop	si				;an000;exchanged

	mov	ax,[si].entry1			;an000;move message number
	mov	bx,[si].entry3			;an000;display handle
	mov	cx,[si].entry5			;an000;number of subs
	mov	dl,[si].entry6			;an000;function type
	mov	di,[si].entry7			;an000;input buffer if appl.
	mov	dh,[si].entry2			;an000;message type
	mov	si,[si].entry4			;an000;sublist

	call	sysdispmsg			;an000;display the message

	pop	si				;an000;restore affected regs
	pop	di				;an000;
	pop	dx				;an000;
	pop	cx				;an000;
	pop	bx				;an000;

endm						;an000;end macro disp_message

;=========================================================================
; macro disp_message: end macro
;=========================================================================

CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC BYTE

	extrn	path_name:byte

DATA	ENDS

DG	GROUP	CODE,CONST,cstack,DATA

code	segment public	byte			;an000;code segment
	assume cs:dg,ds:dg,es:dg,ss:CStack	;an000;

	public	printf				;an000;share printf
	public	disp_fatal			;an000;fatal error display
	public	pre_load_message		;an000;message loader

.xlist
msg_services <MSGDATA>				;an000;
.list

;======================= sysmsg.inc invocation ===========================
;
;	include sysmsg.inc - message retriever services
;
;
; options selected:
;		    NEARmsg
;		    DISPLAYmsg
;		    LOADmsg
;		    CHARmsg
;		    NUMmsg
;		    CLSAmsg
;		    CLSBmsg
;		    CLSCmsg
;
;=========================================================================

.xlist

 msg_services <LOADmsg> 			;an000;no version check
 msg_services <DISPLAYmsg,CHARmsg,NUMmsg,INPUTmsg>  ;an000;display messages
 msg_services <EDLIN.CLA,EDLIN.CLB,EDLIN.CLC>	;an000;message types
 msg_services <EDLIN.CL1,EDLIN.CL2>		;an000;message types
 msg_services <EDLIN.CTL>			;an000;

.list

;=========================================================================
; printf: printf is a replacement of the printf procedure used in DOS
;	  releases prior to 4.00.  printf invokes the macro disp_message
;	  to display a message through the new message handler.  the
;	  interface into printf will continue to be a pointer to a message
;	  passed in DX.  the pointer is pointing to more than a message
;	  now.	it is pointing to a table for that message containing
;	  all relevant information for printing the message.  the macro
;	  disp_message operates on these tables.
;
;	Date	  : 6/11/87
;=========================================================================

printf	proc	near				;an000;printf procedure

	disp_message	dx			;an000;display a message
;	$if	c				;an000;if an error occurred
	JNC $$IF1
		call	disp_fatal		;an000;display the fatal error
;	$endif					;an000;
$$IF1:

	ret					;an000;return to caller

printf	endp					;an000;end printf proc


;=========================================================================
; disp_fatal: this routine displays a fatal error message in the event
;	      an error occurred in disp_message.
;
;	Date	  : 6/11/87
;=========================================================================

disp_fatal proc near				;an000;fatal error message

	mov	ax,fatal_error			;an000;fatal_error number
	mov	bx,stdout			;an000;print to console
	mov	cx,0				;an000;no parameters
	mov	dl,no_input			;an000;no keyboard input
	mov	dh,UTILITY_MSG_CLASS		   ;an000;utility messages

	call	sysdispmsg			;an000;display fatal error

	ret					;an000;return to caller

disp_fatal endp 				;an000;end disp_fatal proc

;=========================================================================
; PRE_LOAD_MESSAGE : This routine provides access to the messages required
;		     by EDLIN.	This routine will report if the load was
;		     successful.  An unsuccessful load will cause EDLIN
;		     to terminate with an appropriate error message.
;
;	Date	  : 6/11/87
;=========================================================================

PRE_LOAD_MESSAGE	proc	near		;an000;pre-load messages


	call	SYSLOADMSG			;an000;invoke loader

;	$if	c				;an000;if an error
	JNC $$IF3
		pushf				;an000;save flags
		call	SYSDISPMSG		;an000;let him say why
		popf				;an000;restore flags
;	$endif					;an000;
$$IF3:

	ret					;an000;return to caller

PRE_LOAD_MESSAGE	endp			;an000;end proc

include msgdcl.inc

code	ends					;an000;end code segment




CONST	SEGMENT PUBLIC BYTE

	extrn	arg_buf:byte			;an000;
	extrn	line_num:byte			;an000;
	extrn	line_flag:byte			;an000;
	extrn	Temp_Path:byte			;an000;

	public	baddrv,opt_err_ptr,nobak
	public	simple_msg
	public	msg_too_many,dskful,memful_ptr,badcom
	public	nodir,filenm_ptr,newfil,read_err_ptr
	public	nosuch,toolng,eof,dest
	public	mrgerr,ro_err,bcreat,ndname
	public	dsp_options,dsp_help,num_help_msgs
	public	ask_ptr,qmes_ptr,msg_crlf,msg_lf
	public	prompt
	public	line_num_buf_ptr		;an000;DMS:6/15/87
	public	arg_buf_ptr			;an000;DMS:6/15/87
	public	cont_ptr			;an000;DMS:6/18/87
	public	cp_err				;an000;DMS:6/22/87
	public	Del_Bak_Ptr			;an000;dms;

;============== REPLACEABLE PARAMETER SUBLIST STRUCTURE ==================
;
;	byte 1	-	substitution list size, always 11
;	byte 2	-	reserved for use by message handler
;	byte 3	-	pointer to parameter to be used as a substitution
;	byte 7	-	which parameter is this to replace, %1, %2, etc.
;	byte 8	-	determines how the parameter is to be output
;	byte 9	-	determines the maximum width of the parameter string
;	byte 10 -	determines the minimum width of the parameter string
;	byte 11 -	define what is to be used as a pad character
;
;=========================================================================

;=========================================================================
;	     replaceable parameter sublists
;=========================================================================

ed_read_sub	label	dword			;an000;a read error occurred

	db	11				;an000;sublist size
	db	00				;an000;reserved
	dd	dg:path_name			   ;an000;pointer to parameter
	db	01				;an000;parm 1
	db	Char_Field_ASCIIZ		;an000;left align/asciiz/char.
	db	unlim_width			;an000;unlimited width
	db	00				;an000;minimum width of 0
	db	pad_blank			;an000;pad with blanks

arg_sub 	label	dword			;an000;line output buffer

	db	11				;an000;sublist size
	db	00				;an000;reserved
	dd	dg:arg_buf			   ;an000;pointer to parameter
	db	01				;an000;parm 1
	db	Char_Field_ASCIIZ		;an000;left align/asciiz/char.
	db	unlim_width			;an000;unlimited width
	db	00				;an000;minimum width of 0
	db	pad_blank			;an000;pad with blank

num_sub 	label	dword			;an000;line number

	db	11				;an000;sublist size
	db	00				;an000;reserved
	dd	dg:line_num			   ;an000;pointer to parameter
	db	01				;an000;parm 1
	db	Right_Align+Unsgn_Bin_Word	;an000;right align/decimal
	db	08				;an000;maximum width
	db	08				;an000;minimum width of 0
	db	pad_blank			;an000;pad with blank

	db	11				;an000;optional flag
	db	00				;an000;reserved
	dd	dg:line_flag			   ;an000;pointer to parameter
	db	02				;an000;parm 2
	db	Char_Field_Char 		;an000;character
	db	01				;an000;minimum width of 1
	db	01				;an000;maximum width of 1
	db	pad_blank			;an000;pad with blank

BAK_Sub 	label	dword			;an000;line output buffer

	db	11				;an000;sublist size
	db	00				;an000;reserved
	dd	dg:Temp_Path			;an000;pointer to parameter
	db	00				;an000;parm 0
	db	Char_Field_ASCIIZ		;an000;left align/asciiz/char.
	db	unlim_width			;an000;unlimited width
	db	00				;an000;minimum width of 0
	db	pad_blank			;an000;pad with blank


;=========================================================================
;	     end replaceable parameter sublists
;=========================================================================

;======================= TABLE STRUCTURE =================================
;
;	bute 1-2  :	message number of message to be displayed
;	byte 3	  :	message type to be used, i.e.;class 1, utility, etc.
;	byte 4-5  :	display handle, i.e.; console, printer, etc.
;	byte 6-7  :	pointer to substitution list, if any.
;	byte 8-9  :	number of replaceable parameters, if any.
;	byte 10   :	type of input from keyboard, if any.
;	byte 11-12:	pointer to buffer for keyboard input, if any.
;
;=========================================================================

;	a bunch of common messages (class=UTILITY_MSG_CLASS, dest=stdout,
;				    no inputs or sublists) are passed
;				    through absolute message numbers rather
;				    than duplicating the data structure for
;				    each one.

prompt		=	0006	; "*"
baddrv		=	0007	; "Invalid drive or file name"
ndname		=	0008	;"File name must be
				;specified",0d,0a,0
ro_err		=	0010	;"File is READ-ONLY",0d,0a,0
bcreat		=	0011	;"File Creation Error",0d,0a,0
msg_too_many	=	0012	;"Too many files open",0d,0a,0
nobak		=	0014	;"Cannot edit .BAK file
				;--rename file",0d,0a,0
nodir		=	0015	;"No room in directory
				;for file",0d,0d,0
dskful		=	0016	;"Disk full. Edits lost.",0d,0a,0
badcom		=	0018	;"Entry error",0d,0a,0
newfil		=	0019	;"New file",0d,0a,0
nosuch		=	0020	;"Not found",0d,0a,0
toolng		=	0022	;"Line too long",0d,0a,0
eof	 	=	0023	;"End of input file",0d,0a,0
dest		=	0025	;"Must specify destination
				;line number",0d,0a,0
mrgerr		=	0026	;"Not enough room to
				;merge the entire file",0d,0a,0
msg_crlf	=	0027	;0d,0a,0
msg_lf		=	0028	;0a,0
cp_err		=	0033	;"Cannot merge - Code page
				;	mismatch",0d,0a
dsp_options	=	0300	; display options
dsp_help	=	0301	; display help
num_help_msgs	=	7

simple_msg	label	word
		dw	0000  		; message number (supplied as used)
		db	UTILITY_MSG_CLASS  ; utility message
		dw	stdout		; display handle
		dw	00		; no sublist
		dw	00		; no sub
		db	no_input	; no keyboard input
		dw	00		; no keyboard buffer


opt_err_ptr	label	word		;an000;"Invalid parameter",0d,0a,0
		dw	0010		;an000;message number
		db	Parse_Err_Class ;an000;utility message
		dw	StdErr		;an000;display handle
		dw	00		;an000;no sublist
		dw	00		;an000;no sub
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

read_err_ptr	label	word		;an000;"Read error in:",
					;an000;0d,0a,"%1",0d,0a,0
		dw	0013		;an000;message number
		db	UTILITY_MSG_CLASS  ;an000;utility message
		dw	stdout		;an000;display handle
		dw	dg:ed_read_sub	;an000;point to sublist
		dw	0001		;an000;1 sub
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

memful_ptr	label	word		;an000;"Insufficient memory",0d,0a,0
		dw	0008		;an000;message number
		db	Ext_Err_Class	;an000;extended error
		dw	stderr		;an000;display handle
		dw	00		;an000;no sublist
		dw	00		;an000;no sub
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

filenm_ptr	label	word		;an000;"File not found",0d,0a
		dw	0002		;an000;message number
		db	Ext_Err_Class	;an000;utility message
		dw	stderr		;an000;display handle
		dw	00		;an000;no sublist
		dw	00		;an000;no sub
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

ask_ptr 	label	word		;an000;"O.K.? ",0
		dw	0021		;an000;message number
		db	UTILITY_MSG_CLASS  ;an000;utility message
		dw	stdout		;an000;display handle
		dw	00		;an000;no sub
		dw	00		; no sublist
		db	DOS_KEYB_INP	;an000;keyboard input - AX
		dw	00		;an000;no keyboard buffer

qmes_ptr	label	word		;an000;"Abort edit (Y/N)? ",0
		dw	0024		;an000;message number
		db	UTILITY_MSG_CLASS  ;an000;utility message
		dw	stdout		;an000;display handle
		dw	00		;an000;no sublist
		dw	00		;an000;no sub
		db	DOS_KEYB_INP	;an000;keyboard input - AX
		dw	00		;an000;no keyboard buffer

cont_ptr	label	word		;an000;"Continue (Y/N)?"
		dw	0029		;an000;message number
		db	UTILITY_MSG_CLASS  ;an000;utility message
		dw	stdout		;an000;display handle
		dw	00		;an000;no sublist
		dw	00		;an000;no sub
		db	DOS_KEYB_INP	;an000;keyboard input
		dw	00		;an000;no keyboard buffer

arg_buf_ptr	label	word		;an000;argument buffer for
					;      line output
		dw	0031		;an000;message number
		db	UTILITY_MSG_CLASS     ;an000;utility message
		dw	stdout		;an000;display handle
		dw	dg:arg_sub	;an000;argument sublist
		dw	01		;an000;1 sub
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

line_num_buf_ptr label	word		;an000;holds line numbers
		dw	0032		;an000;message number
		db	UTILITY_MSG_CLASS     ;an000;utility message
		dw	stdout		;an000;display handle
		dw	dg:num_sub	;an000;argument sublist
		dw	02		;an000;2 subs
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

del_bak_ptr	label	word		;an000;"Access Denied - xxxxxxxx.BAK"
		dw	0005		;an000;message number
		db	Ext_Err_Class	;an000;utility message
		dw	stderr		;an000;display handle
		dw	dg:BAK_Sub	;an000;no sublist
		dw	01		;an000;no subs
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

CONST	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\edlcmd1.asm ===
PAGE 60,132;
	TITLE EDLCMD1.ASM
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: EDLCMD1.SAL
;
; DESCRIPTIVE NAME: EDLIN ROUTINES
;
; FUNCTION: THIS MODULE PROVIDES ROUTINES NEEDED FOR EDLIN'S EXECUTION.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; EXIT NORMAL: NA
;
; EXIT ERROR : NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: EDLCMD2 - ROUTINES MAY BE CALLED FROM EDLCMD2
;		 EDLMES  - ROUTINES MAY BE CALLED FROM EDLMES
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
; REVISION HISTORY:
;
;	AN000	VERSION DOS 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;					- IMPLEMENT SYSPARSE
;					- IMPLEMENT MESSAGE RETRIEVER
;					- IMPLEMENT DBCS ENABLING
;					- ENHANCED VIDEO SUPPORT
;					- EXTENDED OPENS
;					- SCROLLING ERROR
;
; COPYRIGHT: "MS DOS EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;
;======================= END OF SPECIFICATIONS ===========================

include syscall.inc
include edlequ.asm

SUBTTL	Contants and Data areas
PAGE


CODE	SEGMENT PUBLIC
CODE	ENDS

CONST	SEGMENT PUBLIC WORD
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC WORD
DATA	ENDS

DG	GROUP	CODE,CONST,cstack,DATA

CONST	SEGMENT PUBLIC WORD
	EXTRN	DSKFUL:abs,READ_ERR_PTR:word
	EXTRN	NOSUCH:abs,TOOLNG:abs,EOF:abs
	extrn	txt1:byte,txt2:byte
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC WORD
	extrn	ParamCt:WORD
	extrn	current:word,pointer:word,start:word,endtxt:word
	extrn	wrt_handle:word,editbuf:byte,path_name:byte,fname_len:word
	extrn	arg_buf:byte,arg_buf_ptr:word
	extrn	olddat:byte,oldlen:word,newlen:word,param1:word,param2:word
	extrn	srchflg:byte,srchmod:byte,comline:word,lstfnd:word,numpos:word
	extrn	lstnum:word,srchcnt:word,amnt_req:word,delflg:byte,lastlin:word
	extrn	three4th:word,one4th:word,last_mem:word,rd_handle:word,ending:byte
	extrn	haveof:byte
	extrn	Disp_Len:Byte

DATA	ENDS

CODE SEGMENT PUBLIC
ASSUME	CS:DG,DS:DG,SS:CStack,ES:DG

	extrn	findlin:near,shownum:near,loadbuf:near
	extrn	delbak:near,unquote:near,lf:near
	extrn	dispone:near,display:near,query:near
	extrn	quit:near,scanln:near,scaneof:near
	extrn	fndfirst:near,fndnext:near,replace:near,memerr:near
	extrn	std_printf:near,chkrange:near,comerr:near
	extrn	display_message:near

	public	zerror
	public	xerror,bad_read,append,nocom,pager,list
	public	delete,replac_from_curr,search_from_curr,ewrite,wrt

NOMOREJ:JMP	NOMORE

APPEND:
	CMP	ParamCt,1
	JZ	AppendOK
	JMP	ComErr
AppendOK:
	TEST	BYTE PTR [HAVEOF],-1
	JNZ	NOMOREJ
	MOV	DX,[ENDTXT]
	CMP	[PARAM1],0	;See if parameter is missing
	JNZ	PARMAPP
	CMP	DX,[THREE4TH]	;See if already 3/4ths full
	jb	parmapp
	return			;If so, then done already
PARMAPP:
	MOV	DI,DX
	MOV	CX,[LAST_MEM]
	SUB	CX,DX		;Amount of memory available
	jnz	sj53
	jmp	memerr
sj53:
	MOV	DX,[ENDTXT]
	MOV	BX,[RD_HANDLE]
	mov	[amnt_req],cx	;Save number of chars requested
	MOV	AH,READ
	INT	21H		;Fill memory with file data
	CMP	CX,AX		;Did we read less than we asked for?
	JZ	SJ55
; Make sure this is an end-of-file by trying to read more
	PUSH	AX		;Save old byte count
	ADD	DX,AX		;Point to next open space in buffer
	MOV	CX,1		;Just one character past EOF
	MOV	AH,READ
	INT	21H
	CMP	AX,0		      ;Is it EOF?
	POP	AX
	JNZ	SJ54		      ;No -- we have one more character
	MOV	BYTE PTR [HAVEOF],1   ;Yes - set old style system call flag
	JMP	SHORT SJ55
SJ54:
	INC	AX		      ;Include one more char in byte count
sj55:
	MOV	CX,AX		      ;Want byte count in CX
	PUSH	CX		      ;Save actual byte count
	CALL	SCANEOF
	JNZ	NOTEND
	MOV	BYTE PTR [HAVEOF],1	;Set flag if 1AH found in file
NOTEND:
	XOR	DX,DX
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	COUNTLN
	MOV	AX,DI
	ADD	AX,CX		;First byte after loaded text
	CMP	AX,[THREE4TH]	;See if we made 3/4 full
	JBE	COUNTLN
	MOV	DI,[THREE4TH]
	MOV	CX,AX
	SUB	CX,DI		;Length remaining over 3/4
	MOV	BX,1		;Look for one more line
COUNTLN:
	CALL	SCANLN		;Look for BX lines
	CMP	[DI-1],AL	;Check for full line
	JZ	FULLN
	CMP	HavEof,1
	JNZ	DoBackScan
;
; We have an incomplete line in the buffer at end of file.  Fix it up to be
; pretty.
;
	MOV	BYTE PTR [DI],13	; CR
	MOV	BYTE PTR [DI+1],10	; LF
	ADD	DI,2			; length is 2 greater
	POP	CX
	ADD	CX,2
	PUSH	CX
	JMP	SHORT FULLN

DoBackScan:
	DEC	DI
	MOV	CX,[LAST_MEM]
	STD
	REPNE	SCASB			;Scan backwards for last line
	CLD
	INC	DI
	INC	DI
	DEC	DX
FULLN:
	POP	CX				    ;Actual amount read
	MOV	WORD PTR [DI],1AH		    ;Place EOF after last line
	SUB	CX,DI
	XCHG	DI,[ENDTXT]
	ADD	DI,CX				    ;Amount of file read but not used
; Must seek for old partial line
	OR	DI,DI
	JZ	FULLN1
	PUSH	DX
	PUSH	BX
	MOV	BX,[RD_HANDLE]
	MOV	DX,DI
	NEG	DX
	MOV	CX,-1
	MOV	AL,1
	MOV	AH,LSEEK
	INT	21H
	POP	BX
	POP	DX
	JC	BAD_READ
FULLN1:
	CMP	BX,DX
	JNZ	EOFCHK
	MOV	BYTE PTR [HAVEOF],0
	return
NOMORE:
	mov	ax,EOF
	call	display_message
ret3:	return

BAD_READ:
	MOV	DX,OFFSET DG:READ_ERR_ptr
	MOV	DI,offset dg:path_name
	ADD	DI,[FNAME_LEN]
	MOV	AL,0
	STOSB
	JMP	XERROR

EOFCHK:
	TEST	BYTE PTR [HAVEOF],-1
	JNZ	NOMORE
	TEST	BYTE PTR [ENDING],-1
	retnz			;Suppress memory error during End
	JMP	MEMERR

EWRITE:
	CMP	ParamCt,1
	JBE	EWriteOK
	JMP	ComErr
EWriteOK:
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	WRT
	MOV	CX,[ONE4TH]
	MOV	DI,[ENDTXT]
	SUB	DI,CX		;Write everything in front of here
	JBE	RET3
	CMP	DI,OFFSET DG:START	;See if there's anything to write
	JBE	RET3
	XOR	DX,DX
	MOV	BX,1		;Look for one more line
	CALL	SCANLN
	JMP	SHORT WRTADD
WRT:
	INC	BX
	CALL	FINDLIN
WRTADD:
	CMP	BYTE PTR [DELFLG],0
	JNZ	WRTADD1
	PUSH	DI
	CALL	DELBAK			;Want to delete the .BAK file
					;as soon as the first write occurs
	POP	DI
WRTADD1:
	MOV	CX,DI
	MOV	DX,OFFSET DG:START
	SUB	CX,DX			;Amount to write
	retz
	MOV	BX,[WRT_HANDLE]
	MOV	AH,WRITE
	INT	21H
	JC	WRTERR
	CMP	AX,CX			; MZ correct full disk detection
	JNZ	WRTERR			; MZ correct full disk detection
	MOV	SI,DI
	MOV	DI,OFFSET DG:START
	MOV	[POINTER],DI
	MOV	CX,[ENDTXT]
	SUB	CX,SI
	INC	CX			;Amount of text remaining
	CLD
	REP	MOVSB
	DEC	DI			;Point to EOF
	MOV	[ENDTXT],DI
	MOV	[CURRENT],1
	return

WRTERR:
	MOV	BX,[WRT_HANDLE]
	MOV	AH,CLOSE
	INT	21H
	mov	ax,DSKFUL
zerror:
	push	cs
	pop	ds
	call	display_message
xerror1111:
	mov	al,0ffh
	mov	ah,exit
	int	21h

xERROR:
	push	cs
	pop	ds
	call	std_printf
	jmp	xerror1111

NOTFNDJ:JMP	NOTFND

replac_from_curr:
	CMP	ParamCt,2
	JBE	Replace1
	JMP	ComErr
Replace1:
	mov	byte ptr [srchmod],1   ;search from curr+1 line
	jmp	short sj6

REPLAC:
	mov	byte ptr [srchmod],0   ;search from beg of buffer
sj6:
	MOV	BYTE PTR [SRCHFLG],0
	CALL	FNDFIRST
	JNZ	NOTFNDJ
REPLP:
	MOV	SI,[NUMPOS]
	CALL	LOADBUF 	;Count length of line
	SUB	DX,[OLDLEN]
	MOV	CX,[NEWLEN]
	ADD	DX,CX		;Length of new line
	CMP	DX,254
;	jbe	len_ok
;	Jmp	TOOLONG
	ja	toolong
len_ok:
	MOV	BX,[LSTNUM]
	PUSH	DX
	CALL	SHOWNUM
	POP	DX
	MOV	CX,[LSTFND]
	MOV	SI,[NUMPOS]
	SUB	CX,SI		;Get no. of char on line before change
	DEC	CX
	mov	di,offset dg:arg_buf	;Initialize the output string buffer
	CALL	OUTCNT		;Output first part of line
	PUSH	SI
	MOV	SI,1+ OFFSET DG:TXT2
	MOV	CX,[NEWLEN]
	CALL	OUTCNT		;Output change
	POP	SI
	ADD	SI,[OLDLEN]	;Skip over old stuff in line
	MOV	CX,DX		;DX=no. of char left in line
	ADD	CX,2		;Include CR/LF
	CALL	OUTCNT		;Output last part of line
	xor	al,al
	stosb
	mov	dx,offset dg:arg_buf_ptr
	call	std_printf
	CALL	QUERY		;Check if change OK
	JNZ	REPNXT
	CALL	PUTCURS
	MOV	DI,[LSTFND]
	DEC	DI
	MOV	SI,1+ OFFSET DG:TXT2
	MOV	DX,[OLDLEN]
	MOV	CX,[NEWLEN]
	DEC	CX
	ADD	[LSTFND],CX	;Bump pointer beyond new text
	INC	CX
	DEC	DX
	SUB	[SRCHCNT],DX	;Old text will not be searched
	JAE	SOMELEFT
	MOV	[SRCHCNT],0
SOMELEFT:
	INC	DX
	CALL	REPLACE
REPNXT:
	CALL	FNDNEXT
	retnz
	JMP	REPLP

OUTCNT:
	JCXZ	RET8
OUTLP:
	LODSB
	stosb
	DEC	DX
	LOOP	OUTLP
RET8:	return

TOOLONG:
	mov	ax,TOOLNG
	JMP	SHORT PERR

search_from_curr:
	CMP	ParamCt,2
	JBE	Search1
	JMP	ComErr
Search1:
	mov	byte ptr [srchmod],1   ;search from curr+1 line
	jmp	short sj7

SEARCH:
	mov	byte ptr [srchmod],0   ;search from beg of buffer
sj7:
	MOV	BYTE PTR [SRCHFLG],1
	CALL	FNDFIRST
	JNZ	NOTFND
SRCH:
	MOV	BX,[LSTNUM]
	MOV	SI,[NUMPOS]
	CALL	DISPONE
	MOV	DI,[LSTFND]
	MOV	CX,[SRCHCNT]
	MOV	AL,10
	CLD
	REPNE	SCASB
	JNZ	NOTFND
	MOV	[LSTFND],DI
	MOV	[NUMPOS],DI
	MOV	[SRCHCNT],CX
	INC	[LSTNUM]
	CALL	QUERY
	JZ	PUTCURS1
	CALL	FNDNEXT
	JZ	SRCH
NOTFND:
	mov	ax,NOSUCH
PERR:
	jmp	display_message

;
; Replace enters here with LSTNUM pointing to the correct line.
;
PUTCURS:
	MOV	BX,[LSTNUM]
	jmp	short putcursor
;
; Search enters here with LSTNUM pointing AFTER the correct line
;
putcurs1:
	MOV	BX,[LSTNUM]
	DEC	BX			;Current <= Last matched line

putcursor:
	CALL	FINDLIN
	MOV	[CURRENT],DX
	MOV	[POINTER],DI
	return

;
; n,mD	    deletes a range of lines.  Allowable values for n are:
;   1 ... LAST_MEM.  Allowable values for m are:
;   1 ... LAST_MEM.
; nD	    deletes a single line
; D	    deletes the current line
;
DELETE:
	CMP	ParamCt,2		; at most two parameters specified.
	JA	ComErrJ
	MOV	BX,Param1
	OR	BX,BX			; default first arg?
	JNZ	DelParm2
	MOV	BX,Current		; use current as default
	MOV	Param1,BX
DelParm2:
	MOV	BX,Param2		; did we default second arg?
	OR	BX,BX
	JNZ	DelCheck		; no, use it.
	MOV	BX,Param1		; use param1 as default
	MOV	Param2,BX
DelCheck:
	MOV	BX,Param1
	CALL	ChkRange		; returns by itself if bad range
;
; BX is first line of range to be deleted. Param2 is last line in range to
; be deleted.  Get pointer to beginning of block.  Save location
;
	CALL	FINDLIN 		; Grab line
	retnz				; If not found => return
	PUSH	BX
	PUSH	DI
;
; Get pointer past end of block (Param2+1).
;
	MOV	BX,Param2
	INC	BX
	CALL	FINDLIN
;
; Set up pointers.  Compute number of chars to move.
;
	MOV	SI,DI			; move from second line+1
	POP	DI			; restore destination (first line)
	POP	Current 		; Current line is first param
	MOV	Pointer,DI		; internal current line
	MOV	CX,EndTxt		; compute count
	SUB	CX,SI
	JB	ComErrJ 		; should never occur: ChkRange
	INC	CX			; remember ^Z at end
	CLD
	REP	MOVSB			; move data
	DEC	DI
	MOV	EndTxt,DI		; reset end pointer
	return

COMERRJ:
	JMP	COMERR

PAGER:
	CMP	ParamCt,2
	JA	ComErrJ
	xor	bx,bx		;get last line in the buffer
	call	findlin
	mov	[lastlin],dx

	mov	bx,[param1]
	or	bx,bx		;was it specified?
	jnz	frstok		;yes, use it
	mov	bx,[current]
	cmp	bx,1		;if current line =1 start from there
	je	frstok
	inc	bx		;start from current+1 line
frstok:
	cmp	bx,[lastlin]	;check that we are in the buffer
	jbe	frstok1
	return			;if not just quit
frstok1:
	mov	dx,[param2]
	or	dx,dx		;was param2 specified?
	jnz	scndok		;yes,....
	mov	dx,bx		;no, take the end line to be the
				;    start line + length of active display

;=========================================================================
; This modification is to provide support for screens larger than
; 24 lines.
;
;	Date	   : 6/10/87
;=========================================================================

	push	ax		;an000;save affected registers

	mov	ah,00h		;an000;zero out high byte
	mov	al,dg:disp_len	;an000;set ax to active display length
	sub	ax,2		;an000;adjust for length of screen & current
				;      line
	add	dx,ax		;an000;this gives us the last line to be
				;      printed
	pop	ax		;an000;restore affected registers

;=========================================================================

scndok:
	inc	dx
	cmp	dx,[lastlin]	;check that we are in the buffer
	jbe	infile
	mov	dx,[lastlin]	;we are not, take the last line as end
infile:
	cmp	dx,bx		;is param1 < param2 ?
	retz
	ja	sj33
	jmp	comerr		;yes, no backwards listing, print error
sj33:
	push	dx		;save the end line
	push	bx		;save start line
	mov	bx,dx		;set the current line
	dec	bx
	call	findlin
	mov	[pointer],di
	mov	[current],dx
	pop	bx		;restore start line
	call	findlin 	;get pointer to start line
	mov	si,di		;save pointer
	pop	di		;get end line
	sub	di,bx		;number of lines
	jmp	short display_lines


LIST:
	CMP	ParamCt,2
	JBE	ListOK
	JMP	ComERR
ListOK:
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	CHKP2
	MOV	BX,[CURRENT]
	SUB	BX,11
	JA	CHKP2
	MOV	BX,1
CHKP2:
	CALL	FINDLIN
	retnz
	MOV	SI,DI
	MOV	DI,[PARAM2]
	INC	DI
	SUB	DI,BX
	JA	DISPLAY_lines

;=========================================================================
; This modification is to provide support for screens larger than
; 24 lines.
;
;	Date	   : 6/10/87
;=========================================================================

	push	ax			;an000;save affected registers

	mov	ah,00h			;an000;zero out high byte
	mov	al,dg:disp_len		;an000;set ax to active display length	       dec     ax		       ;an000;allow room at bottom for
					;      messages
	mov	di,ax			;an000;number of lines to print an
					;      entire screen less 1.
	pop	ax			;an000;restore affected registers

;=========================================================================

display_lines:
	call	DISPLAY
	return

Break <NOCOM - edit a single line>

;
; NOCOM is called when there is a single line being edited.  This occurs when
; the command letter is CR or is ;.
;
NOCOM:
	CMP	ParamCt,2
	JB	NoComOK
	JMP	ComErr
NoComOK:
	DEC	[COMLINE]
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	HAVLIN
	MOV	BX,[CURRENT]
	INC	BX	;Default is current line plus one
	CALL	CHKRANGE
HAVLIN:
	CALL	FINDLIN
	MOV	SI,DI
	MOV	[CURRENT],DX
	MOV	[POINTER],SI
	jz	sj12
ret12:	return
sj12:
	CMP	SI,[ENDTXT]
	retz
	CALL	LOADBUF
	MOV	[OLDLEN],DX
	MOV	SI,[POINTER]
	CALL	DISPONE
	CALL	SHOWNUM
	MOV	AH,STD_CON_STRING_INPUT 	  ;Get input buffer
	MOV	DX,OFFSET DG:EDITBUF
	INT	21H
	CALL	lf
	MOV	CL,[EDITBUF+1]
	MOV	CH,0
	JCXZ	RET12
	MOV	DX,[OLDLEN]
	MOV	SI,2 + OFFSET DG:EDITBUF
;-----------------------------------------------------------------------
	call	unquote 		;scan for quote chars if any
;-----------------------------------------------------------------------
	mov	cl,[EditBuf+1]		;an000; dms;get new line length
	mov	ch,0			;an000; dms;clear high byte
	MOV	DI,[POINTER]
	JMP	Replace 		; MZ 11/30

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\edlcmd2.asm ===
PAGE 60,132
TITLE Edlcmd2 - PART2 procedures called from EDLIN
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: EDLCMD2.SAL
;
; DESCRIPTIVE NAME: EDLIN ROUTINES
;
; FUNCTION: THIS MODULE PROVIDES ROUTINES NEEDED FOR EDLIN'S EXECUTION.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; EXIT NORMAL: NA
;
; EXIT ERROR : NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: EDLCMD1 - ROUTINES MAY BE CALLED FROM EDLCMD1
;		 EDLMES  - ROUTINES MAY BE CALLED FROM EDLMES
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
;
; REVISION HISTORY:
;
;	AN000	VERSION DOS 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				    - IMPLEMENT SYSPARSE
;				    - IMPLEMENT MESSAGE RETRIEVER
;				    - IMPLEMENT DBCS ENABLING
;				    - ENHANCED VIDEO SUPPORT
;				    - EXTENDED OPENS
;				    - SCROLLING ERROR
;
; COPYRIGHT: "MS DOS EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;
;======================= END OF SPECIFICATIONS ===========================

include edlequ.asm
include syscall.inc

CODE	SEGMENT PUBLIC
CODE	ENDS

CONST	SEGMENT PUBLIC WORD
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC WORD
DATA	ENDS


DG	GROUP	CODE,CONST,cstack,DATA

CONST	SEGMENT PUBLIC WORD
	extrn	msg_crlf:abs,msg_lf:abs,qmes_ptr:byte,ask_ptr:byte
	extrn	bak:byte,$$$file:byte,delflg:byte,loadmod:byte,txt1:byte
	extrn	txt2:byte,memful_ptr:word

	extrn	Del_Bak_Ptr:byte		;an000;dms;
	extrn	cont_ptr:byte			;an000;dms:6/10/87

CONST	ENDS

DATA	SEGMENT PUBLIC WORD
	extrn	ParamCt:WORD
	extrn	current:word,pointer:word,start:word,endtxt:word
	extrn	wrt_handle:word,editbuf:byte,ext_ptr:word,qflg:byte
	extrn	temp_path:byte,line_num:word,line_flag:byte
	extrn	line_num_buf_ptr:byte,arg_buf:byte,arg_buf_ptr:word
	extrn	olddat:byte,oldlen:word,newlen:word,param1:word,param2:word
	extrn	srchflg:byte,srchmod:byte,comline:word,lstfnd:word,numpos:word
	extrn	lstnum:word,last_mem:word,srchcnt:word,amnt_req:word

	extrn	lc_adj:byte			;an000;dms:6/10/87
	extrn	continue:byte			;an000;dms:6/10/87
	extrn	pg_count:byte			;an000;dms:6/10/87
	extrn	Disp_Len:byte			;an000;dms;
	extrn	Disp_Width:byte 		;an000;dms;
	extrn	lc_flag:byte			;an000;dms:6/10/87

	ifdef	DBCS
	extrn	lbtbl:dword
	endif

DATA	ENDS

CODE SEGMENT PUBLIC

ASSUME	CS:DG,DS:DG,SS:CStack,ES:DG

	public	findlin,shownum,loadbuf,crlf,lf,abortcom,unquote
	public	kill_bl,make_caps,display,dispone,make_cntrl
	public	query,quit,scanln,delbak,scaneof,memerr
	public	fndfirst,fndnext,replace
	ifdef	DBCS
	public	testkanj
	endif
	extrn	std_printf:near,command:near,chkrange:near,ComErr:NEAR
	extrn	Xerror:near
	extrn	display_message:near


FINDLIN:

; Inputs
;	BX = Line number to be located in buffer (0 means last line+1)
; Outputs:
;	DX = Actual line found
;	DI = Pointer to start of line DX
;	Zero set if BX = DX (if specified line found)
; AL,CX destroyed. No other registers affected.

	MOV	DX,[CURRENT]
	MOV	DI,[POINTER]
	CMP	BX,DX			; fast find.  Current = requested
	retz
	JA	FINDIT			; start scanning at current?
	OR	BX,BX			; special case of EOF?
	JZ	FINDIT			; yes
	MOV	DX,1			; set up for scan at beginning
	MOV	DI,OFFSET DG:START
	CMP	BX,DX			; at beginning?
	retz
FINDIT:
	MOV	CX,[ENDTXT]		; count of bytes in buffer
	SUB	CX,DI			; for scan
SCANLN:
	MOV	AL,10			; LF is what we look for.
	OR	AL,AL			; Clear zero flag for JCXZ
FINLIN:
	JCXZ	RET4			; at end? Yes, no skip.
	REPNE	SCASB			; find EOL
	INC	DX			; increment count
	CMP	BX,DX			; find correct line?
	JNZ	FINLIN			; no, try again.
RET4:	return

; Inputs:
;	BX = Line number to be displayed
; Function:
;	Displays line number on terminal in 8-character
;	format, suppressing leading zeros.
; AX, CX, DX destroyed. No other registers affected.

SHOWNUM:
	mov	dx,offset dg:line_num_buf_ptr
	mov	line_num,bx
	MOV	line_flag,"*"
	CMP	BX,[CURRENT]
	JZ	STARLIN
	MOV	line_flag," "
STARLIN:
	call	std_printf
ret5:	return


DISPONE:
	MOV	DI,1

DISPLAY:

; Inputs:
;	BX = Line number
;	SI = Pointer to text buffer
;	DI = No. of lines
; Function:
;	Ouputs specified no. of line to terminal, each
;	with leading line number.
; Outputs:
;	BX = Last line output.
; All registers destroyed.

	MOV	CX,[ENDTXT]
	SUB	CX,SI
	retz				; no lines to display
;=========================================================================
; Initialize screen size and line counts for use by display.
;
;	Date	   : 6/10/87
;=========================================================================

	push	ax				;an000;save affected regs

	mov	al,dg:disp_len			;an000;length of video display
	mov	pg_count,al			;an000;init. screen size ctr.

	pop	ax				;an000;restore affected regs

;=========================================================================

	mov	dx,di				;number of lines to print
;
; CX is the number of bytes in the buffer
; dx is the number of lines to be output
;
DISPLN:
	SaveReg <CX,DX>
	CALL	SHOWNUM
	RestoreReg  <DX,CX>
	mov	di,offset dg:arg_buf
;
; Copy chars until CR/LF or end of line hit
;
OUTLN:
	LODSB
	CMP	DI,254+offset dg:arg_buf ; are we at end of buffer?
	JAE	StoreDone		; Yes, do NOT store
	CMP	AL," "
	JAE	SEND
	CMP	AL,10
	JZ	SEND
	CMP	AL,13
	JZ	SEND
	CMP	AL,9
	JZ	SEND
	MOV	AH,"^"
	OR	AL,40h
	XCHG	AL,AH
	STOSW
	JMP	short StoreDone
SEND:
	stosb
StoreDone:
	CMP	AL,10			; perform copy until LF is seen
	LOOPNZ	OUTLN
;
; Make sure buffer ends with CRLF
;
	cmp	byte ptr [di-1],10
	jz	Terminate
;
; No LF seen.  See if CR
;
	cmp	byte ptr [di-1],CR
	jz	StoreLF
	mov	al,CR
	stosb
StoreLF:
	mov	al,10
	stosb
Terminate:
	mov	byte ptr [di],0

	call	EDLIN_DISP_COUNT		;an000;determine lines printed
						;      DMS:6/10/87
	push	dx
	mov	dx,offset dg:arg_buf_ptr
	call	std_printf
	pop	dx
	JCXZ	ret7
	INC	BX

	call	EDLIN_PG_COUNT			;an000;adjust screen line count
						;      DMS:6/10/87
	cmp	lc_flag,false			;an000;continue DISPLAY?
						;      DMS:6/10/87
	JNZ	DISPLN
	DEC	BX
ret7:	return

FNDFIRST:
	MOV	DI,1+OFFSET DG:TXT1
	mov	byte ptr[olddat],1     ;replace with old value if none new
	CALL	GETTEXT
	OR	AL,AL		;Reset zero flag in case CX is zero
	JCXZ	RET7
	cmp	al,1ah		;terminated with a ^Z ?
	jne	sj8
	mov	byte ptr[olddat],0     ;do not replace with old value
sj8:
	MOV	[OLDLEN],CX
	XOR	CX,CX
	CMP	AL,0DH
	JZ	SETBUF
	CMP	BYTE PTR [SRCHFLG],0
	JZ	NXTBUF
SETBUF:
	DEC	SI
NXTBUF:
	MOV	[COMLINE],SI
	MOV	DI,1+OFFSET DG:TXT2
	CALL	GETTEXT
	CMP	BYTE PTR [SRCHFLG],0
	JNZ	NOTREPL
	CMP	AL,0DH
	JNZ	HAVCHR
	DEC	SI
HAVCHR:
	MOV	[COMLINE],SI
NOTREPL:
	MOV	[NEWLEN],CX
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	CALLER
	cmp	byte ptr[srchmod],0
	jne	sj9
	mov	bx,1	 ;start from line number 1
	jmp	short sj9a
sj9:
	MOV	BX,[CURRENT]
	INC	BX	;Default search and replace to current+1
sj9a:
	CALL	CHKRANGE
CALLER:
	CALL	FINDLIN
	MOV	[LSTFND],DI
	MOV	[NUMPOS],DI
	MOV	[LSTNUM],DX
	MOV	BX,[PARAM2]
	CMP	BX,1
	SBB	BX,-1	;Decrement everything except zero
	CALL	FINDLIN
	MOV	CX,DI
	SUB	CX,[LSTFND]
	OR	AL,-1
	JCXZ	aret
	CMP	CX,[OLDLEN]
	jae	sj10
aret:	return
sj10:
	MOV	[SRCHCNT],CX

FNDNEXT:

; Inputs:
;	[TXT1+1] has string to search for
;	[OLDLEN] has length of the string
;	[LSTFND] has starting position of search in text buffer
;	[LSTNUM] has line number which has [LSTFND]
;	[SRCHCNT] has length to be searched
;	[NUMPOS] has beginning of line which has [LSTFND]
; Outputs:
;	Zero flag set if match found
;	[LSTFND],[LSTNUM],[SRCHCNT] updated for continuing the search
;	[NUMPOS] has beginning of line in which match was made

	MOV	AL,[TXT1+1]
	MOV	CX,[SRCHCNT]
	MOV	DI,[LSTFND]
SCAN:
	OR	DI,DI		;Clear zero flag in case CX=0
	REPNE	SCASB		;look for first byte of string

	retnz			;return if you don't find
ifdef	DBCS
	call	kanji_check	;see if the found byte is on a character boundary
	jnz	scan
endif
	MOV	DX,CX
	MOV	BX,DI		;Save search position
	MOV	CX,[OLDLEN]
	DEC	CX
	MOV	SI,2 + OFFSET DG:TXT1
	CMP	AL,AL		;Set zero flag in case CX=0
	REPE	CMPSB
	MOV	CX,DX
	MOV	DI,BX
	JNZ	SCAN
	MOV	[SRCHCNT],CX
	MOV	CX,DI
	MOV	[LSTFND],DI
	MOV	DI,[NUMPOS]
	SUB	CX,DI
	MOV	AL,10
	MOV	DX,[LSTNUM]
;Determine line number of match
GETLIN:
	INC	DX
	MOV	BX,DI
	REPNE	SCASB
	JZ	GETLIN
	DEC	DX
	MOV	[LSTNUM],DX
	MOV	[NUMPOS],BX
	XOR	AL,AL
	return

ifdef	DBCS

;Kanji_check		idea is to scan backwards to the first
;			character which can't be a kanji or part of one
;			(.lt. DB_SP_LO) then scan forward to see if the
;			current byte is on character boundary
;
;Output 	ZR <==> we're on a character boundary
;		NZ <==> we're not on character boundary i.e. No Match
kanji_check:
	push	ax			;save search character
	push	di
	dec	di			;point to the character we found
	mov	si,di			;start searching bakwards from there
	std
srch_loop:
	lodsb
	cmp	al,DB_SP_LO
	jae	srch_loop
	inc	si			;point to first non-kanji
	cld				;forward search
kan_loop:
	cmp	si,di			;are we at current byte?
	jae	passed_char		;if we are, or are passed it, exit
	call	next_char		;otherwise advance si to next char
	jmp	short kan_loop		;and loop
passed_char:
	pop	di
	pop	ax
	ret

;Next_char		si points to a character boundary
;			advance si to point to the beginning of the next char
;
;
next_char:
	push	ax
	lodsb
	call	testkanj
	jz	not_kanj
	inc	si
not_kanj:
	pop	ax
	ret

;--------------------------------------------------------------------;
; TESTKANJ ~ FIND OUT IS THE BYTE IS A KANJI PREFIX		     ;
;								     ;
; entry:  AL	byte to test					     ;
;								     ;
; exit:   NZ if lead byte ortherwise  ZR			     ;
;								     ;
; modifies:	AX						     ;
;								     ;
;--------------------------------------------------------------------;

testkanj:
	push	ax
	xchg	ah,al		    ;put byte in ah
	push	ds
	push	si
	lds	si,cs:[lbtbl]	       ;get pointer to lead byte table
ktlop:
	lodsb			    ;direction flag should be OK
	or	al,al		    ;are we at the end of table?
	jz	notlead 	    ;brif so
	cmp	al,ah		    ;is START RANGE > CHARACTER?
	ja	notlead 	    ;brif so, not a lead character (carry clear)
	lodsb			    ;get second range byte
	cmp	ah,al		    ;is CHARACTER > END RANGE
	ja	ktlop		    ;brif so, not a lead character (check next range)
	or	al,al		    ;make NZ
notl_exit:
	pop	si
	pop	ds
	pop	ax
	ret
notlead:
	cmp	al,al
	jmp	notl_exit

endif

GETTEXT:

; Inputs:
;	SI points into command line buffer
;	DI points to result buffer
; Function:
;	Moves [SI] to [DI] until ctrl-Z (1AH) or
;	RETURN (0DH) is found. Termination char not moved.
; Outputs:
;	AL = Termination character
;	CX = No of characters moved.
;	SI points one past termination character
;	DI points to next free location

	XOR	CX,CX

GETIT:
	LODSB
;-----------------------------------------------------------------------
	cmp	al,quote_char	;a quote character?
	jne	sj101		;no, skip....
	lodsb			;yes, get quoted character
	call	make_cntrl
	jmp	short sj102
;-----------------------------------------------------------------------
sj101:
	CMP	AL,1AH
	JZ	DEFCHK
sj102:
	CMP	AL,0DH
	JZ	DEFCHK
	STOSB
	INC	CX
	JMP	SHORT GETIT

DEFCHK:
	OR	CX,CX
	JZ	OLDTXT
	PUSH	DI
	SUB	DI,CX
	MOV	BYTE PTR [DI-1],cl
	POP	DI
	return

OLDTXT:
	cmp	byte ptr[olddat],1	;replace with old text?
	je	sj11			;yes...
	mov	byte ptr[di-1],cl	;zero text buffer char count
	return

sj11:
	MOV	CL,BYTE PTR [DI-1]
	ADD	DI,CX
	return

REPLACE:

; Inputs:
;	CX = Length of new text
;	DX = Length of original text
;	SI = Pointer to new text
;	DI = Pointer to old text in buffer
; Function:
;	New text replaces old text in buffer and buffer
;	size is adjusted. CX or DX may be zero.
; CX, SI, DI all destroyed. No other registers affected.

	CMP	CX,DX
	JZ	COPYIN
	PUSH	SI
	PUSH	DI
	PUSH	CX
	MOV	SI,DI
	ADD	SI,DX
	ADD	DI,CX
	MOV	AX,[ENDTXT]
	SUB	AX,DX
	ADD	AX,CX
	CMP	AX,[LAST_MEM]
	JAE	MEMERR
	XCHG	AX,[ENDTXT]
	MOV	CX,AX
	SUB	CX,SI
	CMP	SI,DI
	JA	DOMOV
	ADD	SI,CX
	ADD	DI,CX
	STD
DOMOV:
	INC	CX

	REP	MOVSB
	CLD
	POP	CX
	POP	DI
	POP	SI
COPYIN:
	REP	MOVSB
	return

MEMERR:
	MOV	DX,OFFSET DG:MEMFUL_ptr
	call	std_printf
	JMP	COMMAND


LOADBUF:
	MOV	DI,2 + OFFSET DG:EDITBUF
	MOV	CX,255
	MOV	DX,-1
LOADLP:
	LODSB
	STOSB
	INC	DX
	CMP	AL,13
	LOOPNZ	LOADLP
	MOV	[EDITBUF+1],DL
	retz
TRUNCLP:
	LODSB
	INC	DX
	CMP	AL,13
	JNZ	TRUNCLP
	DEC	DI
	STOSB
	return

SCANEOF:
	cmp	[loadmod],0
	je	sj52

;----- Load till physical end of file

	cmp	cx,word ptr[amnt_req]
	jb	sj51
	xor	al,al
	inc	al		;reset zero flag
	return
sj51:
	jcxz	sj51b
	push	di		;get rid of any ^Z at the end of the file
	add	di,cx
	dec	di		;points to last char
	cmp	byte ptr [di],1ah
	pop	di
	jne	sj51b
	dec	cx
sj51b:
	xor	al,al		;set zero flag
	call	check_end	;check that we have a CRLF pair at the end
	return

;----- Load till first ^Z is found

sj52:
	PUSH	DI
	PUSH	CX
	MOV	AL,1AH
	or	cx,cx
	jz	not_found	;skip with zero flag set
	REPNE	SCASB		;Scan for end of file mark
	jnz	not_found
	LAHF				;Save flags momentarily
	inc	cx			;include the ^Z
	SAHF				;Restore flags
not_found:
	mov	di,cx			;not found at the end
	POP	CX
	LAHF				;Save flags momentarily
	SUB	CX,DI			;Reduce byte count if EOF found
	SAHF				;Restore flags
	POP	DI
	call	check_end		;check that we have a CRLF pair at the end

	return


;-----------------------------------------------------------------------
;	If the end of file was found, then check that the last character
; in the file is a LF. If not put a CRLF pair in.

check_end:
	jnz	not_end 		;end was not reached
	pushf				;save return flag
	push	di			;save pointer to buffer
	add	di,cx			;points to one past end on text
	dec	di			;points to last character
	cmp	di,offset dg:start
	je	check_no
	cmp	byte ptr[di],0ah	;is a LF the last character?
	je	check_done		;yes, exit
check_no:
	mov	byte ptr[di+1],0dh	;no, put a CR
	inc	cx			;one more char in text
	mov	byte ptr[di+2],0ah	;put a LF
	inc	cx			;another character at the end
check_done:
	pop	di
	popf
not_end:
	return

CRLF:
	push	dx
	mov	ax,msg_crlf
	call	display_message
	pop	dx
	return
LF:
	mov	ax,msg_lf
	jmp	display_message

ABORTCOM:
	MOV	AX,CS
	MOV	DS,AX
	MOV	ES,AX
	MOV	AX,cstack
	MOV	SS,AX
	MOV	SP,STACK
	STI
	CALL	CRLF
	JMP	COMMAND

DELBAK:
	;Delete old backup file (.BAK)

	MOV	BYTE PTR [DELFLG],1
	MOV	DI,[EXT_PTR]
	MOV	SI,OFFSET DG:BAK
	MOVSW
	MOVSW
	MOVSB
	MOV	AH,UNLINK
	MOV	DX,OFFSET DG:TEMP_PATH
	INT	21H
;	$if	c					;error ?		;an000; dms;
	JNC $$IF1
		cmp	ax,Access_Denied		;file read only?	;an000; dms;
;		$if	e				;yes			;an000; dms;
		JNE $$IF2
			mov	bx,[Wrt_Handle] 	;close .$$$ file	;an000; dms;
			mov	ah,Close		;close function 	;an000; dms;
			int	21h			;close it		;an000; dms;

			mov	di,[Ext_Ptr]		;point to extension	;an000; dms;
			mov	si,offset dg:$$$File	;point to .$$$ extension;an000; dms;
			movsw				;get .$$$ extension	;an000; dms;
			movsw				;			;an000; dms;
			movsb				;			;an000; dms;
			mov	dx,offset dg:Temp_Path	;point to .$$$ file	;an000; dms;
			mov	ah,Unlink		;delete it		;an000; dms;
			int	21h			;			;an000; dms;

			mov	di,[Ext_Ptr]		;point to extension	;an000; dms;
			mov	si,offset dg:BAK	;point to .BAK extension;an000; dms;
			movsw				;get .BAK extension	;an000; dms;
			movsw				;			;an000; dms;
			movsb				;			;an000; dms;
			mov	dx,offset dg:Del_Bak_Ptr;point to error message ;an000; dms;
			jmp	Xerror			;display message & exit ;an000; dms;
;		$endif
$$IF2:
;	$endif
$$IF1:

	MOV	DI,[EXT_PTR]
	MOV	SI,OFFSET DG:$$$FILE
	MOVSW
	MOVSW
	MOVSB
	return


;-----------------------------------------------------------------------;
; Will scan buffer given pointed to by SI and get rid of quote
;characters, compressing the line and adjusting the length at the
;begining of the line.
; Preserves al registers except flags and AX .

unquote:
	push	cx
	push	di
	push	si
	mov	di,si
	mov	cl,[si-1]	;length of buffer
	xor	ch,ch
	mov	al,quote_char
	cld
unq_loop:
	jcxz	unq_done	;no more chars in the buffer, exit
	repnz	scasb		;search for quote character
	jnz	unq_done	;none found, exit
	push	cx		;save chars left in buffer
	push	di		;save pointer to quoted character
	push	ax		;save quote character
	mov	al,byte ptr[di] ;get quoted character
	call	make_cntrl
	mov	byte ptr[di],al
	pop	ax		;restore quote character
	mov	si,di
	dec	di		;points to the quote character
	inc	cx		;include the carriage return also
	rep	movsb		;compact line
	pop	di		;now points to after quoted character
	pop	cx
	jcxz	sj13		;if quote char was last of line do not adjust
	dec	cx		;one less char left in the buffer
sj13:	pop	si
	dec	byte ptr[si-1]	;one less character in total buffer count also
	push	si
	jmp	short unq_loop

unq_done:
	pop	si
	pop	di
	pop	cx
	return


;-----------------------------------------------------------------------;
;	Convert the character in AL to the corresponding control
; character. AL has to be between @ and _ to be converted. That is,
; it has to be a capital letter. All other letters are left unchanged.

make_cntrl:
	push	ax
	and	ax,11100000b
	cmp	ax,01000000b
	pop	ax
	jne	sj14
	and	ax,00011111b
sj14:
	return


;---- Kill spaces in buffer --------------------------------------------;
;=========================================================================
; kill_bl : Parses over spaces in a buffer.
;
;	Date	   : 6/10/86
;=========================================================================
kill_bl:

	push	bx			;an000;save affected reg.
kill_bl_cont:

	lodsb				;get rid of blanks
	    cmp al,9
	    je	kill_bl_cont		;an000;it is a tab

	    cmp al,10
	    je	kill_bl_cont		;an000;if LF

	    cmp al,' '
	    je	kill_bl_cont		;an000;we have a space

	ifdef DBCS			;an000;is this a kanji assembly
	     call testkanj		;an000;do we have a dbcs lead byte
;	     $if  nz			;an000;yes, we have a lead byte
	     JZ $$IF5
		  cmp  al,DB_SP_HI	;an000;is it DB_SP_HI
;		  $if  z		;an000;it is DB_SP_HI
		  JNZ $$IF6
		       mov  bl,ds:[si]	;an000;set up for compare
		       cmp  bl,DB_SP_LO ;an000;is it DB_SP_LO
;		       $if  z		;an000;we have an asian blank
		       JNZ $$IF7
			    lodsb	;an000;skip byte containing 81h
			    jmp kill_bl_cont
;		       $endif		;an000;
$$IF7:
;		  $endif		;an000;fall through no delim
$$IF6:
					;      found
;	     $endif			;an000;end test for dbcs lead byte
$$IF5:
	endif				;an000;end conditional assembly

	pop	bx			;an000;restore affected reg.
	return

;----- Capitalize the character in AL ----------------------------------;
;									;
;   Input:								;
;									;
;	    AL	    contains a character to capitalize			;
;									;
;   Output:								;
;									;
;	    AL	    contains a capitalized character			;
;									;
;-----------------------------------------------------------------------;

MAKE_CAPS:
	CMP	AL,"a"
	JB	CAPS1
	CMP	AL,"z"
ifdef DBCS
	JA	CAPS1		; M003 MSKK TAR 476, kana chars
else
	JG	CAPS1
endif
	AND	AL,0DFH
CAPS1:
	return

QUIT:
	CMP	ParamCt,1
	JZ	Quit1
CERR:	JMP	ComErr
Quit1:	CMP	Param1,0
	JNZ	CERR
	MOV	DX,OFFSET DG:QMES_ptr
	call	std_printf

IFDEF	DBCS
	CALL	TESTKANJ
	JZ	ASCII
	MOV	AX, (STD_CON_INPUT_FLUSH SHL 8) + 0
	INT	21H		; Eat the trailing byte.
	JMP	CRLF
ASCII:
ENDIF
;=========================================================================
; We are invoking the VAL_YN proc here.  This will replace the
; method of Y/N validation used prior to DOS 4.00.
;
;	Date	   : 6/10/87
;=========================================================================

	call	val_yn		;an000;pass Y/N byte in AL to macro
	cmp	ax,yes		;an000;did we return a Y
	jz	NoCRLF		;an000; dms; close the file
	cmp	ax,no		;an000; dms; return N?
;	$if	ne		;an000; dms; neither N or Y - reprompt
	JE $$IF11
		call	crlf			; spit out crlf
		jmp	Quit1			;an000; dms; reprompt
;	$endif			;an000; dms;
$$IF11:
	call	crlf			; spit out CRLF
	return				;an000; dms;

;=========================================================================
; End of Y/N validation check for qmes_ptr
;=========================================================================

NOCRLF:
	MOV	BX,[WRT_HANDLE]
	MOV	AH,CLOSE
	INT	21H
	MOV	DX,OFFSET DG:TEMP_PATH
	MOV	AH,UNLINK
	INT	21H
	mov	ah,exit
	xor	al,al
	INT	21H

QUERY:
	TEST	BYTE PTR [QFLG],-1
	retz
	MOV	DX,OFFSET DG:ASK_ptr
	call	std_printf
	PUSH	AX
	CALL	CRLF
	POP	AX
IFDEF	DBCS
	CALL	TESTKANJ
	JZ	ASCII1
	PUSH	AX
	MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
	INT	21H		;Eat the trailing byte
	XOR	AX,AX
	INC	AX		; non zero flag
	POP	AX
	return
ASCII1:
ENDIF
	CMP	AL,13		;Carriage return means yes
	retz
;=========================================================================
; We are invoking the VAL_YN proc here.  This will replace the
; method of Y/N validation used prior to DOS 4.00.
; This invocation of val_yn will return ZR if Y is found, otherwise
; it will return NZ.
;
;	Date	   : 6/10/87
;=========================================================================

	call	val_yn		;an000;pass Y/N byte in AL to macro
	cmp	ax,yes		;an000;did we return a Y
	je	Query_Exit	;an000; dms; exit Y/N validation
	cmp	ax,no		;an000; dms; N response?
	jne	Query		;an000; dms; no - reprompt user
	cmp	ax,yes		;an000; dms; must have N response - force
				;	     NZ flag
Query_Exit:


;=========================================================================
; End of Y/N validation check for ask_ptr
;=========================================================================

	return

;=========================================================================
; EDLIN_DISP_COUNT: This routine will determine the number of lines
;		    actually displayed to the screen.  Lines displayed to
;		    the screen for one EDLIN line printed will be calculated
;		    by the following formula:
;
;		LINES_PRINTED = (LINE_LEN + 10) / SCREEN_WIDTH
;
;		LINES_PRINTED - Actual number of lines printed on screen
;				for one EDLIN line.  If LINES_PRINTED has
;				a remainder, it will be rounded up.
;
;		LINE_LEN      - The length, in bytes, of the EDLIN line
;				printed.
;
;		SCREEN_WIDTH  - The width in bytes of the current display.
;
;	Inputs : DI - offset into buffer containing line printed
;		 DISP_WIDTH  - width of current video output
;
;	Outputs: LC_ADJ - factor to adjust line counter by
;
;	Date	   : 6/10/87
;=========================================================================

EDLIN_DISP_COUNT	proc	near		;an000;lines printed

	push	dx				;an000;save affected regs
	push	di				;an000;
	push	ax				;an000;
	push	bx				;an000;
	push	cx				;an000;

	mov	bx,offset dg:arg_buf		;an000;arg_buf holds line
						;      printed
	mov	ax,di				;an000;where print line ends
	sub	ax,bx				;an000;diff = line's length
	add	ax,10				;an000;adjust for leading blks
	mov	cl,dg:disp_width		;an000;set up for division
	div	cl				;an000;divide AX by the
						;      width of the console
	cmp	ah,0				;an000;see if a remainder
;	$if	nz				;an000;if a remainder
	JZ $$IF13
		add al,1			;an000;increment AL 1
						;      to round upward
;	$endif					;an000;
$$IF13:

	mov	lc_adj,al			;an000;number of lines printed
						;      on console
	pop	cx				;an000;restore affected regs
	pop	bx				;an000;
	pop	ax				;an000;
	pop	di				;an000;
	pop	dx				;an000;

	ret					;an000;return to caller

EDLIN_DISP_COUNT	endp			;an000;end proc

;=========================================================================
; EDLIN_PG_COUNT : This routine determines whether or not we will continue
;		   displaying text lines based on the count of lines that
;		   can be output to the current video screen.
;
;	Inputs : LC_ADJ    - adjustment factor for number of lines printed
;		 PG_COUNT  - number of lines remaining on current video
;			     display
;		 DX	   - holds the total number of lines to print
;		 CONTINUE  - signals if the user wants to continue
;			     printing lines.
;
;	Outputs: LC_FLAG   - used to signal completion of print
;
;	Date	   : 6/10/87
;=========================================================================

EDLIN_PG_COUNT		proc	near		;an000;track remaining lines

	push	ax				;an000;save affected regs

	mov	lc_flag,true			;an000;init. flag to signal
						;      continue printing

	mov	al,pg_count			;an000;set up for page adj.
	cmp	al,lc_adj			;an000;see if we are at end
;	$if	be				;an000
	JNBE $$IF15
		mov	pg_count,0		;an000;set pg_count to 0
;	$else
	JMP SHORT $$EN15
$$IF15:
		sub	al,lc_adj		;an000;adjust number of lines
		mov	pg_count,al		;an000;save remaining line ct.
;	$endif					;an000;
$$EN15:

	dec	dx				;an000;decrease total number
						;      of lines to print by 1
;	$if	nz				;an000;more lines to print
	JZ $$IF18
	    cmp    pg_count,0			;an000;have we printed screen
;	    $if    be				;an000;we have printed screen
	    JNBE $$IF19
		   call    EDLIN_PG_PROMPT	;an000;prompt the user to
						;      "Continue(Y/N)?"
		   cmp	  continue,true 	;an000;did user say continue
;		   $if	  z			;an000;continue
		   JNZ $$IF20
			  mov	al,dg:disp_len	;an000;begin init of screen
;			  dec	al		;an000;    length
			  mov	pg_count,al	;an000;
;		   $else			;an000;do not continue
		   JMP SHORT $$EN20
$$IF20:
			  mov	lc_flag,false	;an000;signal no more to print
;		   $endif			;an000;
$$EN20:
;	    $endif				;an000;
$$IF19:
;	$else					;an000;total lines printed
	JMP SHORT $$EN18
$$IF18:
	    mov    lc_flag,false		;an000;signal no more to print
;	$endif					;an000;
$$EN18:

	pop	ax				;an000;restore affected regs

	ret					;an000;return to caller

EDLIN_PG_COUNT		endp			;an000;end procedure

;=========================================================================
; EDLIN_PG_PROMPT : This routine prompts the user as to whether or not to
;		    continue printing lines to the video display, if lines
;		    are still present for printing.
;
;	Inputs : none
;
;	Outputs: CONTINUE - flag that signals other routines whether or
;			    not to continue printing.
;
;	Date	   : 6/10/87
;=========================================================================

EDLIN_PG_PROMPT 	proc	near		;an000;ask user to continue?

	push	dx				;an000;save affected regs.
	push	ax				;an000;

EPP_Reprompt:

	mov	dx,offset dg:cont_ptr		;an000;point to Continue msg.
	call	std_printf			;an000;invoke message ret.

	push	ax				;an000;save affected regs.
	call	crlf				;an000;send crlf
	pop	ax				;an000;restore affected regs.

	call	val_yn				;an000;Y/N validation

	cmp	ax,yes				;an000;did we have a Y
	jz	EPP_True_Exit			;an000;we had a Y
	cmp	ax,no				;an000;did we have a N
	jz	EPP_False_Exit			;an000;yes
	jmp	EPP_Reprompt			;an000;neither Y or N - reprompt

EPP_True_Exit:

	mov	Continue,True			;an000;flag Y found
	jmp	short EPP_Exit			;an000;exit routine

EPP_False_Exit:

	mov	Continue,False			;an000;flag N found

EPP_Exit:

	pop	ax				;an000;restore affected regs.
	pop	dx				;an000;

	ret					;an000;return to caller

EDLIN_PG_PROMPT 	endp			;an000;end procedure

;=========================================================================
; val_yn: This proc validates a Y/N response entered by the user.  The
;	  routine uses the new functionality of "GET EXTENDED COUNTRY
;	  INFORMATION" being implemented in DOS 4.00.
;
; Inputs : AL - character to be validated for Y/N response
;
; Outputs: AX - 00h = "N"o
;	      - 01h = "Y"es
;=========================================================================

val_yn	proc	near		;an000;validate Y/N response

	push	dx		;an000;save affected registers
	push	cx		;an000;
	push	bx		;an000;

	mov	dl,al		;an000;character to be checked for Y/N
	mov	ah,GetExtCntry	;an000;get extended country information
	mov	al,yn_chk	;an000;perform Y/N checking
	mov	cx,max_len	;an000;max. len. of Y/N char.
	int	21h		;an000;invoke function

	pop	bx		;an000;restore affected registers
	pop	cx		;an000;
	pop	dx		;an000;

	ret			;an000;return to caller

val_yn	endp			;an000;end proc



code	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\edlin.asm ===
PAGE	60,132;
	TITLE	EDLIN
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: EDLIN.SAL
;
; DESCRIPTIVE NAME: LINE TEXT EDITOR
;
; FUNCTION: EDLIN IS A SIMPLE, LINE ORIENTED TEXT EDITOR.  IT PROVIDES
;	    USERS OF DOS THE ABILITY TO CREATE AND EDIT TEXT FILES.
;
; ENTRY POINT: EDLIN
;
; INPUT: DOS COMMAND LINE
;	 EDLIN COMMANDS
;	 TEXT
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: EDLCMD1 - CONTAINS ROUTINES CALLED BY EDLIN
;		 EDLCMD1 - CONTAINS ROUTINES CALLED BY EDLIN
;		 EDLMES  - CONTAINS ROUTINES CALLED BY EDLIN
;
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT SYSPARSE
;				- IMPLEMENT MESSAGE RETRIEVER
;				- IMPLEMENT DBCS ENABLING
;				- ENHANCED VIDEO SUPPORT
;				- EXTENDED OPENS
;				- SCROLLING ERROR
;
; COPYRIGHT: "MS DOS EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft"
;
;
;	MICROSOFT REVISION HISTORY:
;									;
;	V1.02										;
;									;
;	V2.00	9/13/82  M.A.U						;
;									;
;		2/23/82  Rev. 13	N. P					;
;		    Changed to 2.0 system calls.				;
;		    Added an error message for READ-ONLY files		;
;									;
;		11/7/83  Rev. 14	N. P					;
;		    Changed to .EXE format and added Printf		;
;									;
;	V2.50	11/15/83 Rev. 1 	M.A. U					;
;		    Official dos 2.50 version. Some random bug		;
;		fixes and message changes.					;
;									;
;		11/30/83 Rev. 2 	MZ						;
;		    Close input file before rename.				;
;		    Jmp to replace after line edit				;
;									;
;		02/01/84 Rev. 3 	M.A. U			;
;		    Now it is called 3.00 dos. Repaired problem 	;
;		with using printf and having %'s as data.                       ;
;									;
;		02/15/84 MZ make out of space a fatal error with output;
;									;
;		03/28/84 MZ fixes bogus (totally) code in MOVE/COPY	;
;									;
;		04/02/84 MZ fixes DELETE and changes MOVE/COPY/EDIT	;
;									;
;	V3.20 08/29/86 Rev. 1 S.M. G					;
;									;
;		08/29/86 M001 MSKK TAR 593, TAB MOVEMENT		;
;									;
;		08/29/86 M002 MSKK TAR 157, BLKMOVE 1,1,1m, 1,3,1m	;
;									;
;		08/29/86 M003 MSKK TAR 476, EDLCMD2,MAKECAPS,kana char	;
;									;
;		08/29/86 M004 MSKK TAR 191, Append load size		;
;									;
;		08/29/86 M005 IBMJ TAR Transfer Load command		;
;									;
;	04/17/90 c-PaulB						;
;		Added /? switch to display options			;
;		Files changed: edlin.asm, edlparse.asm, edlmes.asm,	;
;		edlin.skl.						;
;									;
;======================= END OF SPECIFICATIONS ===========================									;

include version.inc
include intnat.inc
include syscall.inc
include edlequ.asm


SUBTTL	Contants and Data areas
PAGE
	extrn	parser_command:near		;an000;SYSPARSE

CODE	SEGMENT PUBLIC
CODE	ENDS

CONST	SEGMENT PUBLIC WORD
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC WORD
DATA	ENDS

DG	GROUP	CODE,CONST,cstack,DATA

CONST	SEGMENT PUBLIC WORD

	public	bak,$$$file,delflg,loadmod,txt1,txt2

	EXTRN	BADDRV:abs,NDNAME:abs
	EXTRN	opt_err_ptr:word,NOBAK:abs,BADCOM:abs
	EXTRN	NEWFIL:abs,DEST:abs,MRGERR:abs
	EXTRN	NODIR:abs,FILENM_ptr:word,ro_err:abs
	EXTRN	bcreat:abs,msg_too_many:abs,msg_lf:abs
	EXTRN	prompt:abs,MemFul_Ptr:word,simple_msg:word
	extrn	dsp_options:abs
	extrn	dsp_help:abs,num_help_msgs:abs

BAK	DB	".BAK",0

$$$FILE DB	".$$$",0

fourth	db	0			;fourth parameter flag

loadmod db	0			;Load mode flag, 0 = ^Z marks the
					; end of a file, 1 = viceversa.
optchar db	"-"

TXT1	DB	0,80H DUP (?)
TXT2	DB	0,80H DUP (?)
DELFLG	DB	0
fNew	DB	0			; old file
HAVEOF	DB	0

CONST	ENDS

cstack	segment stack
	db  stksiz dup (?)
cstack	ends

DATA	SEGMENT PUBLIC WORD

	extrn	arg_buf_ptr:word		;an000;
	extrn	line_num_buf_ptr:word		;an000;

	public	path_name,ext_ptr,start,line_num,line_flag
	public	arg_buf,wrt_handle,temp_path
	public	current,pointer,qflg,editbuf,amnt_req,fname_len,delflg,lastlin
	public	olddat,oldlen,newlen,srchflg,srchmod
	public	comline,lstfnd,numpos,lstnum,last_mem,srchcnt
	public	rd_handle,haveof,ending,three4th,one4th

	public	lc_adj				;an000;page length adj. factor
	public	lc_flag 			;an000;display cont. flag
	public	pg_count			;an000;lines left on screen
	public	Disp_Len			;an000;display length
	public	Disp_Width			;an000;display width
	public	continue			;an000;boolean T/F
	public	temp_path			;an000;pointer to filespec buf

Video_Buffer	label	word			;an000;buffer for video attr
	db	0				;an000;dms;
	db	0				;an000;dms;
	dw	14				;an000;dms;
	dw	0				;an000;dms;
	db	?				;an000;dms;
	db	0				;an000;dms;
	dw	?				;an000;dms;# of colors
	dw	?				;an000;dms;# of pixels in width
	dw	?				;an000;dms;# of pixels in len.
	dw	?				;an000;dms;# of chars in width
	dw	?				;an000;dms;# of chars in length


video_org	db	?			;an000;original video mode on
						;      entry to EDLIN.
lc_adj		db	?			;an000;page length adj. factor
lc_flag 	db	?			;an000;display cont. flag
pg_count	db	?			;an000;lines left on screen
Disp_Len	db	?			;an000;display length
Disp_Width	db	?			;an000;display width
continue	db	?			;an000;boolean T/F


;-----------------------------------------------------------------------;
; This is a table that is sequentially filled via GetNum.  Any additions to it
; must be placed in the correct position.  Currently Param4 is known to be a
; count and thus is treated specially.

	public	param1,param2,Param3,param4,ParamCt
PARAM1	DW	?
PARAM2	DW	?
PARAM3	DW	?
PARAM4	DW	?
ParamCt DW	?			; count of passed parameters
	ifdef	DBCS			; Used in TESTKANJ:
LBTbl	dd	?			;  long pointer to lead byte table
	endif				;  in the dos (from syscall 63H)

;-----------------------------------------------------------------------;

PUBLIC PTR_1, PTR_2, PTR_3, OLDLEN, NEWLEN, LSTFND, LSTNUM, NUMPOS, SRCHCNT
PUBLIC CURRENT, POINTER, ONE4TH, THREE4TH, LAST_MEM, ENDTXT, COPYSIZ
PUBLIC COMLINE, LASTLIN, COMBUF, EDITBUF, EOL, QFLG, ENDING, SRCHFLG
PUBLIC PATH_NAME, FNAME_LEN, RD_HANDLE, TEMP_PATH, WRT_HANDLE, EXT_PTR
PUBLIC MRG_PATH_NAME, MRG_HANDLE, amnt_req, olddat, srchmod, MOVFLG, org_ds
ifdef	DBCS
public	lbtbl
endif

;
; These comprise the known state of the internal buffer.  All editing
; functions must preserve these values.
;
CURRENT     DW	    ?			; the 1-based index of the current line
POINTER     DW	    ?			; pointer to the current line
ENDTXT	    DW	    ?			; pointer to end of buffer. (at ^Z)
LAST_MEM    DW	    ?			; offset of last byte of memory
;
; The label Start is the beginning of the in-core buffer.
;

;
; Internal temporary pointers
;
PTR_1		DW	    ?
PTR_2		DW	    ?
PTR_3		DW	    ?

QFLG		DB	    ?			; TRUE => query for replacement
OLDLEN	DW	    ?
NEWLEN	DW	    ?
LSTFND	DW	    ?
LSTNUM	DW	    ?
NUMPOS	DW	    ?
SRCHCNT     DW	    ?
ONE4TH	DW	    ?
THREE4TH    DW	    ?
COPYSIZ     DW	    ?			; total length to copy
COPYLEN     DW	    ?			; single copy length
COMLINE     DW	    ?
LASTLIN     DW	    ?
COMBUF	DB	    82H DUP (?)
EDITBUF     DB	    258 DUP (?)
EOL		DB	    ?
ENDING	DB	    ?
SRCHFLG     DB	    ?
PATH_NAME   DB	    128 DUP(0)
FNAME_LEN   DW	    ?
RD_HANDLE   DW	    ?
TEMP_PATH   DB	    128 DUP(?)
WRT_HANDLE  DW	    ?
EXT_PTR     DW	    ?
MRG_PATH_NAME DB    128 DUP(?)
MRG_HANDLE  DW	    ?
amnt_req    dw	    ?			; amount of bytes requested to read
olddat	db	    ?			; Used in replace and search, replace
					; by old data flag (1=yes)
srchmod     db	    ?			; Search mode:	1=from current+1 to
					; end of buffer, 0=from beg.  of
					; buffer to the end (old way).
MOVFLG	    DB	    ?
org_ds	    dw	    ?			;Orginal ds points to header block

arg_buf db	258 dup (?)

EA_Flag 	db	False		;an000; dms;set to false

EA_Buffer_Size	dw	?		;an000; dms;EA buffer's size

EA_Parm_List	label	word		;an000; dms;EA parms
		dd	dg:Start	;an000; dms;ptr to EA's
		dw	0001h		;an000; dms;additional parms
		db	06h		;an000; dms;
		dw	0002h		;an000; dms;iomode


line_num    dw	?

line_flag   db	?,0
	EVEN			;align on word boundaries
;
; Byte before start of data buffer must be < 40H  !!!!!!
;
	    dw	0		;we scan backwards looking for
				;a character which can't be part
				;of a two-byte seqence.  This
				;double byte sequence will cause the back
				;scan to stop here.
START	LABEL	WORD

DATA	ENDS


CODE SEGMENT PUBLIC

ASSUME	CS:DG,DS:NOTHING,ES:NOTHING,SS:CStack



	extrn	pre_load_message:near		;an000;message loader
	extrn	disp_fatal:near 		;an000;fatal message
	extrn	printf:near			;an000;new PRINTF routine

	extrn	findlin:near,shownum:near,loadbuf:near,crlf:near,lf:near
	extrn	abortcom:near,delbak:near,unquote:near,kill_bl:near
	extrn	make_caps:near,dispone:near,display:near,query:near
	extrn	quit:near,make_cntrl:near,scanln:near,scaneof:near
	extrn	fndfirst:near,fndnext:near,replace:near,memerr:near
	extrn	xerror:near
	extrn	zerror:near
	extrn	bad_read:near,append:near
	extrn	nocom:near,pager:near,list:near,search_from_curr:near
	extrn	replac_from_curr:near,ewrite:near,wrt:near,delete:near


	extrn	filespec:byte			;an000;parser's filespec
	extrn	parse_switch_b:byte		;an000;result of switch scan
	extrn	parse_switch_?:byte		;      result of switch scan

	public	std_printf,command,chkrange,comerr
	public	display_message
						;      exit from EDLIN

	IFDEF	DBCS
	extrn	testkanj:near
	ENDIF

EDLIN:
	JMP	SHORT SIMPED

std_printf	proc	near			;ac000;convert to proc

	push	dx
	call	printf
	pop	dx				;an000;balance the push
	ret

std_printf	endp				;ac000;end proc

Break	<Dispatch Table>

;-----------------------------------------------------------------------;
;   Careful changing the order of the next two tables.	They are linked and
;   changes should be be to both.

COMTAB	DB	13,";ACDEILMPQRSTW"
NUMCOM	EQU	$-COMTAB

TABLE	DW	BLANKLINE		; Blank line
	DW	NOCOM			; ;
	DW	APPEND			; A(ppend)
	DW	COPY			; C(opy)
	DW	DELETE			; D(elete)
	DW	ENDED			; E(xit)
	DW	INSERT			; I(nsert)
	DW	LIST			; L(ist)
	DW	MOVE			; M(ove)
	DW	PAGER			; P(age)
	DW	QUIT			; Q(uit)
	dw	replac_from_curr	; R(eplace)
	dw	search_from_curr	; S(earch)
	DW	MERGE			; T(merge)
	DW	EWRITE			; W(rite)

Break	<Initialization Code>

NONAME:
	mov	ax,NDNAME
	jmp	zerror

SIMPED:
	mov	org_ds,DS
	push	ax			;ac000;save for drive compare

	push	cs			;an000;exchange cs/es
	pop	es			;an000;

	push	cs			;an000;exchange cs/ds
	pop	ds			;an000;
	assume	ds:dg,es:dg		;an000;establish addressibility

	MOV	dg:ENDING,0
	mov	sp,stack
	call	EDLIN_DISP_GET			;an000;get current video
						;      mode & set it to
						;      text

;=========================================================================
; invoke PRE_LOAD_MESSAGE here.  If the messages were not loaded we will
; exit with an appropriate error message.
;
;	Date	   : 6/14/87
;=========================================================================

	call	PRE_LOAD_MESSAGE	;an000;invoke SYSLOADMSG
;	$if	c			;an000;if the load was unsuccessful
	JNC $$IF1
		mov ah,exit		;an000;exit EDLIN. PRE_LOAD_MESSAGE
					;      has said why we are exiting
		mov al,00h		;an000
		int 21h 		;an000;exit
;	$endif				;an000;
$$IF1:



VERS_OK:
;----- Check for valid drive specifier --------------------------------;

	pop	ax
	OR	AL,AL
	JZ	get_switch_char
	mov	ax,BADDRV
	jmp	zerror
get_switch_char:
	MOV	AX,(CHAR_OPER SHL 8)	;GET SWITCH CHARACTER
	INT	21H
	CMP	DL,"/"
	JNZ	CMD_LINE		;IF NOT / , THEN NOT PC
	MOV	OPTCHAR,"/"		;IN PC, OPTION CHAR = /

	IFDEF	DBCS
	push	ds			; SAVE! all regs destroyed on this
	push	es
	push	si			; call !!
	mov	ax,(ECS_call shl 8) or 00h  ; get kanji lead tbl
	int	21h
assume	ds:nothing
assume	es:nothing
	mov	word ptr [LBTbl],si
	mov	word ptr [LBTbl+2],ds
	pop	si
	pop	es
	pop	ds
assume	ds:dg
assume	es:dg
	ENDIF


CMD_LINE:
	push	cs
	pop	es
	ASSUME	ES:DG

;----- Process any options ------------------------------------------;

;=========================================================================
;  The system parser, called through PARSER_COMMAND, parses external
;  command lines.  In the case of EDLIN we are looking for two parameters
;  on the command line.
;
;  Parameter 1 - Filespec (REQUIRED)
;  Parameter 2 - \B switch (OPTIONAL)
;
;  PARSER_COMMAND  -  exit_normal : ffffh
;		      exit_error  : not = ffffh
;=========================================================================


	call	PARSER_COMMAND		;an000;invoke sysparse
					;      DMS:6/11/87

	; Check for /? switch.
	; If so, display the options
	; and exit.
	;
	; This is done first so that if the user typed
	; /? along with unknown commands, they can get
	; a coherent message without being over-errored.
	;
	; 4/17/90 c-PaulB

	cmp	[parse_switch_?], true	; is the /? switch on?
	jne	CheckOptionsDone	;  skip the rest of this if not

	mov	ax,dsp_options
	call	display_message

	mov	al, 0			; get an okay exit code
	mov	ah, exit		;  and
	int	21h			;   bail out.

CheckOptionsDone:

	cmp	ax,nrm_parse_exit	;an000;was it a good parse
;	$if	z			;an000;it was a good parse
	JNZ $$IF3
		call EDLIN_COMMAND	;an000;interface results
					;      into EDLIN
;	$else				;an000;
	JMP SHORT $$EN3
$$IF3:
		cmp ax,too_many 	;an000;too many operands
;		$if z			;an000;we have too many
		JNZ $$IF5
		    jmp short badopt	;an000;say why and exit
;		$endif
$$IF5:

		cmp ax,op_missing	;an000;required parm missing
;		$if z			;an000;missing parm
		JNZ $$IF7
ifdef DBCS
		    jmp noname		;an000;say why and exit
else
		    jmp short noname	;an000;say why and exit
endif
;		$endif			;an000;
$$IF7:

		cmp ax,sw_missing	;an000;is it an invalid switch
;		$if z			;an000;invalid switch
		JNZ $$IF9
		    jmp short badopt	;an000;say why and exit
;		$endif			;an000;
$$IF9:

;	$endif				;an000;
$$EN3:

;=========================================================================
;======================= begin .BAK check ================================
; Check for .BAK extension on the filename

	push	ds			;an000;save reg.
	push	cs			;an000;set up addressibility
	pop	ds			;an000;
	assume	ds:dg			;an000;

	push	ax			;an000;save reg.
	mov	ax,offset dg:path_name	;an000;point to path_name
	add	ax,[fname_len]		;an000;calculate end of path_name
	mov	si,ax			;an000;point to end of path_name
	pop	ax			;an000;restore reg.

	MOV	CX,4			;compare 4 bytes
	SUB	SI,4			;Point 4th to last char
	MOV	DI,OFFSET DG:BAK	;Point to string ".BAK"
	REPE	CMPSB			;Compare the two strings
	pop	ds
	ASSUME	DS:NOTHING
	JNZ	NOTBAK
	JMP	HAVBAK

;======================= end .BAK check ==================================

;======================= begin NOTBAK ====================================
; we have a file without a .BAK extension, try to open it

NOTBAK:
	push	ds
	push	cs
	pop	ds
	ASSUME	DS:DG

;=========================================================================
; implement EXTENDED OPEN
;=========================================================================

	push	es			;an000;save reg.
	mov	bx,RW			;an000;open for read/write
	mov	cx,ATTR 		;an000;file attributes
	mov	dx,RW_FLAG		;an000;action to take on open
	mov	di,0ffffh		;an000;nul parm list

	call	EXT_OPEN1		;an000;open for R/W;DMS:6/10/87
	pop	es			;an000;restore reg.

;=========================================================================
	pop	ds
	ASSUME	DS:NOTHING
	JC	CHK_OPEN_ERR		;an open error occurred
	MOV	RD_HANDLE,AX		;Save the handle

	Jmp	HavFil			;work with the opened file

;======================= end NOTBAK ======================================

Badopt:
	MOV	DX,OFFSET DG:OPT_ERR_ptr;Bad option specified
	JMP	XERROR

;=========================================================================
;
; The open of the file failed.	We need to figure out why and report the
; correct message. The circumstances we can handle are:
;
;   open returns pathnotfound => bad drive or file name
;   open returns toomanyopenfiles => too many open files
;   open returns access denied =>
;	chmod indicates read-only => cannot edit read only file
;	else => file creation error
;   open returns filenotfound =>
;	creat ok => close, delete, new file
;	creat fails => file creation error
;   else => file cre
;

CHK_OPEN_ERR:
	cmp	ax,error_path_not_found
	jz	BadDriveError
	cmp	ax,error_too_many_open_files
	jz	TooManyError
	cmp	ax,error_access_denied
	jnz	CheckFNF
	push	ds
	push	cs
	pop	ds
	assume	ds:dg
	mov	ax,(chmod shl 8)
	MOV	DX,OFFSET DG:PATH_NAME
	int	21h
	jc	FileCreationError
	test	cx,attr_read_only
	jz	FileCreationError
	jmp	short ReadOnlyError

CheckFNF:
	cmp	ax,error_file_not_found
	jnz	FileCreationError
;
; Try to create the file to see if it is OK.
;
	push	ds
	push	cs
	pop	ds
	assume ds:dg
;=========================================================================
; implement EXTENDED OPEN
;=========================================================================

	mov	bx,RW			;an000;open for read/write
	mov	cx,ATTR 		;an000;file attributes
	mov	dx,CREAT_FLAG		;an000;action to take on open
	mov	di,0ffffh		;an000;null parm list
	call	EXT_OPEN1		;an000;create file;DMS:6/10/87

;=========================================================================

	pop	ds
	assume	ds:nothing
	jc	CreateCheck
	mov	bx,ax
	mov	ah,close
	int	21h
	push	ds
	push	cs
	pop	ds
	assume	ds:dg
	mov	ah,unlink
	MOV	DX,OFFSET DG:PATH_NAME
	int	21h
	pop	ds
	assume	ds:nothing
	jc	FileCreationError	; This should NEVER be taken!!!
	MOV	HAVEOF,0FFH		; Flag from a system 1.xx call
	MOV	fNew,-1
	JMP	short HAVFIL

CreateCheck:
	cmp	ax,error_access_denied
	jnz	BadDriveError
DiskFull:
	mov	ax,NODIR
	jmp	zerror

FileCreationError:
	mov	ax,bcreat
	jmp	zerror

ReadOnlyError:
	mov	ax,RO_ERR
	jmp	zerror

BadDriveError:
	mov	ax,BADDRV
	jmp	zerror

TooManyError:
	mov	ax,msg_too_many
	jmp	zerror


CREAT_ERR:
	CMP	DELFLG,0
	JNZ	DiskFull
	push	cs
	pop	ds
	CALL	DELBAK
	JMP	short MAKFIL

HAVBAK:
	mov	ax,NOBAK
	jmp	zerror

HAVFIL:
	push	cs
	pop	ds
	ASSUME	DS:DG
	CMP	fNew,0
	JZ	MakeBak
	mov	ax,newfil
	call	display_message
MakeBak:
	MOV	SI,OFFSET DG:PATH_NAME
	MOV	CX,[FNAME_LEN]
	PUSH	CX
	MOV	DI,OFFSET DG:TEMP_PATH
	REP	MOVSB
	DEC	DI
	MOV	DX,DI
	POP	CX
	MOV	AL,"."
	STD
	REPNE	SCASB
	JZ	FOUND_EXT
	MOV	DI,DX			;Point to last char in filename
FOUND_EXT:
	CLD
	INC	DI
	MOV	[EXT_PTR],DI
	MOV	SI,OFFSET DG:$$$FILE
	MOV	CX,5
	REP	MOVSB

;Create .$$$ file to make sure directory has room
MAKFIL:

;=========================================================================
; implement EXTENDED OPEN
;=========================================================================

	mov	bx,RW			;an000;open for read/write
	mov	cx,ATTR 		;an000;file attributes
	mov	dx,Creat_Open_Flag	;an000;action to take on open
	cmp	EA_Flag,True		;an000;EA_Buffer used?
;	$if	e			;an000;yes
	JNE $$IF12
		mov	di,offset dg:EA_Parm_List ;an000; point to buffer
;	$else				;an000;
	JMP SHORT $$EN12
$$IF12:
		mov	di,0ffffh	;an000;nul parm list
;	$endif				;an000;
$$EN12:
	call	EXT_OPEN2		;an000;create file;DMS:6/10/87

;=========================================================================

	JC	CREAT_ERR
	MOV	[WRT_HANDLE],AX
;
; We determine the size of the available memory.  Use the word in the PDB at
; [2] to determine the number of paragraphs.  Then truncate this to 64K at
; most.
;
	push	ds				;save ds for size calc
	mov	ds,[org_ds]
	MOV	CX,DS:[2]
	MOV	DI,CS
	SUB	CX,DI
	CMP	CX,1000h
	JBE	GotSize
	MOV	CX,0FFFh
GotSize:
	SHL	CX,1
	SHL	CX,1
	SHL	CX,1
	SHL	CX,1
	pop	ds				;restore ds after size calc
	DEC	CX
	MOV	[LAST_MEM],CX
	MOV	DI,OFFSET DG:START
	TEST	fNew,-1
	JNZ	SAVEND
	SUB	CX,OFFSET DG:START	;Available memory
	SHR	CX,1			;1/2 of available memory
	MOV	AX,CX
	SHR	CX,1			;1/4 of available memory
	MOV	[ONE4TH],CX		;Save amount of 1/4 full
	ADD	CX,AX			;3/4 of available memory
	MOV	DX,CX
	ADD	DX,OFFSET DG:START
	MOV	[THREE4TH],DX		;Save pointer to 3/4 full
	MOV	DX,OFFSET DG:START
SAVEND:
	CLD
	MOV	BYTE PTR [DI],1AH
	MOV	[ENDTXT],DI
	MOV	BYTE PTR [COMBUF],128
	MOV	BYTE PTR [EDITBUF],255
	MOV	BYTE PTR [EOL],10
	MOV	[POINTER],OFFSET DG:START
	MOV	[CURRENT],1
	MOV	ParamCt,1
	MOV	[PARAM1],0		;M004 Leave room in memory, was -1
	TEST	fNew,-1
	JNZ	COMMAND
;
; The above setting of PARAM1 to -1 causes this call to APPEND to try to read
;  in as many lines that will fit, BUT.... What we are doing is simulating
;  the user issuing an APPEND command, and if the user asks for more lines
;  than we get then an "Insufficient memory" error occurs. In this case we
;  DO NOT want this error, we just want as many lines as possible read in.
;  The twiddle of ENDING suppresses the memory error
;
	MOV	BYTE PTR [ENDING],1	;Suppress memory errors
	CALL	APPEND
	MOV	ENDING,0		; restore correct initial value

Break	<Main command loop>

;
; Main read/parse/execute loop.  We reset the stack all the time as there
; are routines that JMP back here.  Don't blame me; Tim Paterson write this.
;
COMMAND:
	push	cs				;an000;set up addressibility
	pop	ds				;an000;
	push	cs				;an000;
	pop	es				;an000;
	assume	ds:dg,es:dg			;an000;

	MOV	SP, STACK
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR 23H
	MOV	DX,OFFSET DG:ABORTCOM
	INT	21H
	mov	ax,prompt
	call	display_message

	MOV	DX,OFFSET DG:COMBUF
	MOV	AH,STD_CON_STRING_INPUT
	INT	21H
	MOV	[COMLINE],OFFSET DG:COMBUF + 2

	mov	ax,msg_lf
	call	display_message

PARSE:
	MOV	[PARAM2],0
	MOV	[PARAM3],0
	MOV	[PARAM4],0
	mov	[fourth],0		;reset the fourth parameter flag
	MOV	QFLG,0
	MOV	SI,[COMLINE]
	MOV	BP,OFFSET DG:PARAM1
	XOR	DI,DI
CHKLP:
	CALL	GETNUM
;
; AL has first char after arg
;
	MOV	ds:[BP+DI],DX
	ADD	DI,2

	MOV	ParamCt,DI		; set up count of parameters
	SHR	ParamCt,1		; convert to index (1-based)

	CALL	SKIP1			; skip to next parameter
	CMP	AL,","			; is there a comma?
	jnz	NOT_COMMA		; if not, then done with arguments

	cmp	di,8			; **** maximum size of PARAM array!
	jb	CHKLP			;  continue scanning if <4 PARAMS
	jmp	short COMERR

NOT_COMMA:
	DEC	SI			; point at char next
	CALL	Kill_BL 		; skip all blanks
	CMP	AL,"?"			; is there a ?
	JNZ	DISPATCH		; no, got command letter
	MOV	QFLG,-1 		; signal query
	CALL	Kill_BL
DISPATCH:
	CMP	AL,5FH
	JBE	UPCASE
	cmp	al,"z"
	ja	upcase
	AND	AL,5FH
UPCASE:
	MOV	DI,OFFSET DG:COMTAB
	mov	cx,NUMCOM
	REPNE	SCASB
	JNZ	COMERR

	SUB	DI,1+OFFSET DG:COMTAB	; convert to index
	MOV	BX,DI
	MOV	AX,[PARAM2]
	OR	AX,AX
	JZ	PARMOK
	CMP	AX,[PARAM1]
	JB	COMERR			; Param. 2 must be >= param 1
PARMOK:
	MOV	[COMLINE],SI
	SHL	BX,1
	CALL	[BX+TABLE]
COMOVER:
	MOV	SI,[COMLINE]
	CALL	Kill_BL
	CMP	AL,0DH
	JZ	COMMANDJ
	CMP	AL,1AH
	JZ	DELIM
	CMP	AL,";"
	JNZ	NODELIM
DELIM:
	INC	SI
NODELIM:
	DEC	SI
	MOV	[COMLINE],SI
	JMP	PARSE

COMMANDJ:
	JMP	COMMAND

SKIP1:
	DEC	SI
	CALL	Kill_BL
ret1:	return

Break	<Range Checking and argument parsing>

;
; People call here.  we need to reset the stack.
;   Inputs: BX has param1
;   Outputs: Returns if BX <= Param2
;

CHKRANGE:
	CMP	[PARAM2],0
	retz
	CMP	BX,[PARAM2]
	JBE	RET1
	POP	DX			; clean up return address
COMERR:
	mov	ax,BADCOM
zcomerr1:
	call	display_message
	jmp	command

COMERR1:
	call	std_printf
	JMP	COMMAND

;
; GetNum parses off 1 argument from the command line.  Argument forms are:
;   nnn     a number < 65536
;   +nnn    current line + number
;   -nnn    current line - number
;   .	    current line
;   #	    lastline + 1
;
;

GETNUM:
	CALL	Kill_BL
	cmp	di,6			;Is this the fourth parameter?
	jne	sk1
	mov	[fourth],1		;yes, set the flag
sk1:
	CMP	AL,"."
	JZ	CURLIN
	CMP	AL,"#"
	JZ	MAXLIN
	CMP	AL,"+"
	JZ	FORLIN
	CMP	AL,"-"
	JZ	BACKLIN
	MOV	DX,0
	MOV	CL,0			;Flag no parameter seen yet
NUMLP:
	CMP	AL,"0"
	JB	NUMCHK
	CMP	AL,"9"
	JA	NUMCHK
	CMP	DX,6553 		;Max line/10
	JAE	COMERR			;Ten times this is too big
	MOV	CL,1			;Parameter digit has been found
	SUB	AL,"0"
	MOV	BX,DX
	SHL	DX,1
	SHL	DX,1
	ADD	DX,BX
	SHL	DX,1
	CBW
	ADD	DX,AX
	LODSB
	JMP	SHORT NUMLP
NUMCHK:
	CMP	CL,0
	retz
	OR	DX,DX
	JZ	COMERR			;Don't allow zero as a parameter
	return

CURLIN:
	cmp	[fourth],1		;the fourth parameter?
	je	comerra 		;yes, an error
	MOV	DX,[CURRENT]
	LODSB
	return
MAXLIN:
	cmp	[fourth],1		;the fourth parameter?
	je	comerra 		;yes, an error
	MOV	DX,1
	MOV	AL,0Ah
	PUSH	DI
	MOV	DI,OFFSET DG:START
	MOV	CX,EndTxt
	SUB	CX,DI
MLoop:
	JCXZ	MDone
	REPNZ	SCASB
	JNZ	MDone
	INC	DX
	JMP	MLoop
MDone:
	POP	DI
	LODSB
	return
FORLIN:
	cmp	[fourth],1		;the fourth parameter?
	je	comerra 		;yes, an error
	CALL	GETNUM
	ADD	DX,[CURRENT]
	return
BACKLIN:
	cmp	[fourth],1		;the fourth parameter?
	je	comerra 		;yes, an error
	CALL	GETNUM
	MOV	BX,[CURRENT]
	SUB	BX,DX
	JA	OkLin			; if negative or zero
	MOV	BX,1			; use first line
OkLin:
	MOV	DX,BX
	return

comerra:
	jmp	comerr


ERRORJ:
	JMP	COMERR
ERROR1J:
	JMP	zcomerr1

BLANKLINE:
	cmp	QFLG,0
	jnz	SHOWHELP		; if ? at front of blank line, do HELP
	jmp	NOCOM			; ignore blank line otherwise

SHOWHELP:
	dec	[COMLINE]		; point back to <cr>
	mov	cx,num_help_msgs-1
	mov	ax,dsp_help
SHOWHELP1:
	call	display_message
	inc	ax
	loop	SHOWHELP1

;	fall into display_message for last message and return

;=========================================================================
; display_message	: Displays a simple common message through the
;			;  message retriever, using a common parameter
;			;  block.

;	Inputs	: ax = message number to display
;
;=========================================================================

display_message	proc	near

	mov	dg:[simple_msg],ax
	mov	dx,offset dg:simple_msg
	jmp	printf			; display it

display_message	endp



Break	<Move and Copy commands>

PUBLIC MOVE
MOVE:
	CMP	ParamCt,3
	JNZ	ERRORJ
	MOV	BYTE PTR [MOVFLG],1
	JMP	SHORT BLKMOVE

PUBLIC COPY
COPY:
	CMP	ParamCt,3
	JB	ERRORJ
	MOV	BYTE PTR [MOVFLG],0
;
; We are to move/copy a number of lines from one range to another.
;
; Memory looks like this:
;
;   START:	line 1
;		...
;   pointer->	line n		Current has n in it
;		...
;		line m
;   endtxt->	^Z
;
; The algoritm is:
;
;   Bounds check on args.
;   set ptr1 and ptr2 to range before move
;   set copysiz to number to move
;   open up copysize * count for destination
;   if destination is before ptr1 then
;	add copysize * count to both ptrs
;   while count > 0 do
;	move from ptr1 to destination for copysize bytes
;	count --
;   if moving then
;	move from ptr2 through end to ptr1
;   set endtxt to last byte moved.
;   set current, pointer to original destination
;

BLKMOVE:
;
; Make sure that all correct arguments are specified.
;
	MOV	BX,[PARAM3]		; get destination of move/copy
	OR	BX,BX			; must be specified (non-0)
	mov	ax,DEST
	JZ	ERROR1J 		; is 0 => error
;
; get arg 1 (defaulting if necessary) and range check it.
;
	MOV	BX,[PARAM1]		; get first argument
	OR	BX,BX			; do we default it?
	JNZ	NXTARG			; no, assume it is OK.
	MOV	BX,[CURRENT]		; Defaults to the current line
	CALL	CHKRANGE		; Make sure it is good.
	MOV	[PARAM1],BX		; set it
NXTARG:
	CALL	FINDLIN 		; find first argument line
	JNZ	ErrorJ			; line not found
	MOV	[PTR_1],DI
;
; get arg 2 (defaulting if necessary) and range check it.
;
	MOV	BX,[PARAM2]		; Get the second parameter
	OR	BX,BX			; do we default it too?
	JNZ	HAVARGS 		; Nope.
	MOV	BX,[CURRENT]		; Defaults to the current line
	MOV	[PARAM2],BX		; Stash it away
HAVARGS:
	CALL	FindLin
	JNZ	ErrorJ			; line not found
	MOV	BX,Param2
	INC	BX			;Get pointer to line Param2+1
	CALL	FINDLIN
	MOV	[PTR_2],DI		;Save it
;
; We now have true line number arguments and pointers to the relevant places.
; ptr_1 points to beginning of region and ptr_2 points to first byte beyond
; that region.
;
; Check args for correct ordering of first two arguments
;
	mov	dx,[param1]
	cmp	dx,[param2]
	jbe	havargs1		; first must be <= second
	jmp	comerr
havargs1:
;
; make sure that the third argument is not contained in the first range
;
	MOV	DX,[PARAM3]
	CMP	DX,[PARAM1]		; third must be <= first or
	JBE	NOERROR
	CMP	DX,[PARAM2]
	JA	NoError 		; third must be > last
	JMP	ComErr
NOERROR:
;
; Determine number to move
;
	MOV	CX,Ptr_2
	SUB	CX,Ptr_1		; Calculate number of bytes to copy
	MOV	CopySiz,CX
	MOV	CopyLen,CX		; Save for individual move.
	MOV	AX,[PARAM4]		; Was count defaulted?
	OR	AX,AX
	JZ	SizeOk			; yes, CX has correct value
	MUL	[COPYSIZ]		; convert to true size
	MOV	CX,AX			; move to count register
	OR	DX,DX			; overflow?
	JZ	SizeOK			; no
	JMP	MEMERR			; yes, bomb.
SizeOK:
	MOV	[COPYSIZ],CX
;
; Check to see that we have room to grow by copysiz
;
	MOV	AX,[ENDTXT]		; get pointer to last byte
	MOV	DI,[LAST_MEM]		; get offset of last location in memory
	SUB	DI,AX			; remainder of space
	CMP	DI,CX			; is there at least copysiz room?
	JAE	HAV_ROOM		; yes
	JMP	MEMERR
HAV_ROOM:
;
; Find destination of move/copy
;
	MOV	BX,[PARAM3]
	CALL	FINDLIN
	MOV	[PTR_3],DI
;
; open up copysiz bytes of space at destination
;
;	move (p3, p3+copysiz, endtxt-p3);
;
	MOV	SI,EndTxt		; get source pointer to end
	MOV	CX,SI
	SUB	CX,DI			; number of bytes from here to end
	INC	CX			; remember ^Z at end
	MOV	DI,SI			; destination starts at end
	ADD	DI,[COPYSIZ]		; plus size we are opening
	MOV	[ENDTXT],DI		; new end point
	STD				; go backwards
	REP	MOVSB			; and store everything
	CLD				; go forward
;
; relocate ptr_1 and ptr_2 if we moved them
;
	MOV	BX,Ptr_3
	CMP	BX,Ptr_1		; was dest before source?
	JA	NoReloc 		; no, above. no relocation
	MOV	BX,CopySiz
	ADD	Ptr_1,BX
	ADD	Ptr_2,BX		; relocate pointers
NoReloc:
;
; Now we copy for count times copylen bytes from ptr_1 to ptr_3
;
;	move (ptr_1, ptr_3, copylen);
;
	MOV	BX,Param4		; count (0 and 1 are both 1)
	MOV	DI,Ptr_3		; destination
CopyText:
	MOV	CX,CopyLen		; number to move
	MOV	SI,Ptr_1		; start point
	REP	MOVSB			; move the bytes
	SUB	BX,1			; exhaust count?
	JG	CopyText		; no, go for more
;
; If we are moving
;
	CMP	BYTE PTR MovFlg,0
	JZ	CopyDone
;
; Delete the source text between ptr_1 and ptr_2
;
;	move (ptr_2, ptr_1, endtxt-ptr_2);
;
	MOV	DI,Ptr_1		; destination
	MOV	SI,Ptr_2		; source
	MOV	CX,EndTxt		; pointer to end
	SUB	CX,SI			; number of bytes to move
	CLD				; forwards
	REP	MOVSB
	MOV	BYTE PTR ES:[DI],1Ah	; remember ^Z terminate
	MOV	EndTxt,DI		; new end of file
;
; May need to relocate current line (parameter 3).
;
	MOV	BX,Param3		; get new current line
	CMP	BX,Param1		; do we need to relocate
	JBE	CopyDone		; no, current line is before removed M002
	ADD	BX,Param1		; add in first
	SUB	BX,Param2		; current += first-last - 1;
	DEC	BX
	MOV	Param3,BX
CopyDone:
;
; we are done.	Make current line the destination
;
	MOV	BX,Param3		; set parameter 3 to be current
	CALL	FINDLIN
	MOV	[POINTER],DI
	MOV	[CURRENT],BX
	return

Break	<MoveFile - open up a hole in the internal file>

;
;   MoveFile moves the text in the buffer to create a hole
;
;   Inputs:	DX is spot in buffer for destination
;		DI is spot in buffer for source
MOVEFILE:
	MOV	CX,[ENDTXT]		;Get End-of-text marker
	MOV	SI,CX
	SUB	CX,DI			;Calculate number of bytes to copy
	INC	CX			; remember ^Z
	MOV	DI,DX
	STD
	REP	MOVSB			;Copy CX bytes
	XCHG	SI,DI
	CLD
	INC	DI
	MOV	BP,SI
SETPTS:
	MOV	[POINTER],DI		;Current line is first free loc
	MOV	[CURRENT],BX		;   in the file
	MOV	[ENDTXT],BP		;End-of-text is last free loc before
	return

NAMERR:
	cmp	ax,error_file_not_found
	jne	otherMergeErr
	MOV	DX,OFFSET DG:FILENM_ptr
	JMP	COMERR1

otherMergeErr:
	mov	ax,BADDRV
	jmp	zcomerr1

PUBLIC MERGE
MERGE:
	CMP	ParamCt,1
	JZ	MergeOK
	JMP	Comerr
MergeOK:
	CALL	KILL_BL
	DEC	SI
	MOV	DI,OFFSET DG:MRG_PATH_NAME
	XOR	CX,CX
	CLD
MRG1:
	LODSB
	CMP	AL," "
	JE	MRG2
	CMP	AL,9
	JE	MRG2
	CMP	AL,CR
	JE	MRG2
	CMP	AL,";"
	JE	MRG2
	STOSB
	JMP	SHORT MRG1
MRG2:
	MOV	BYTE PTR[DI],0
	DEC	SI
	MOV	[COMLINE],SI

;=========================================================================
; implement EXTENDED OPEN
;=========================================================================

	push	es			;an000;save reg.
	mov	bx,ext_read		;an000;open for read
	mov	cx,ATTR 		;an000;file attributes
	mov	dx,OPEN_FLAG		;an000;action to take on open
	mov	di,0ffffh		;an000;null parm list
	call	EXT_OPEN3		;an000;create file;DMS:6/10/87
	pop	es			;an000;restore reg.

;=========================================================================

	JC	NAMERR

	MOV	[MRG_HANDLE],AX
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR 23H
	MOV	DX,OFFSET DG:ABORTMERGE
	INT	21H
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	MRG
	MOV	BX,[CURRENT]
	CALL	CHKRANGE
MRG:
	CALL	FINDLIN
	MOV	BX,DX
	MOV	DX,[LAST_MEM]
	CALL	MOVEFILE
	MOV	DX,[POINTER]
	MOV	CX,[ENDTXT]
	SUB	CX,[POINTER]
	PUSH	CX
	MOV	BX,[MRG_HANDLE]
	MOV	AH,READ
	INT	21H
	POP	DX
	MOV	CX,AX
	CMP	DX,CX
	JA	FILEMRG 			; M005
	mov	ax,mrgerr
	call	display_message
	MOV	CX,[POINTER]
	JMP	SHORT RESTORE_Z
FILEMRG:
	ADD	CX,[POINTER]
	MOV	SI,CX
	dec	si
	LODSB
	CMP	AL,1AH
	JNZ	RESTORE_Z
	dec	cx
RESTORE_Z:
	MOV	DI,CX
	MOV	SI,[ENDTXT]
	INC	SI
	MOV	CX,[LAST_MEM]
	SUB	CX,SI
	inc	cx			; remember ^Z
	REP	MOVSB
	dec	di			; unremember ^Z
	MOV	[ENDTXT],DI
	MOV	BX,[MRG_HANDLE]
	MOV	AH,CLOSE
	INT	21H
	return

PUBLIC INSERT
INSERT:
	CMP	ParamCt,1
	JBE	OKIns
	JMP	ComErr
OKIns:
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR 23H	;Set vector 23H
	MOV	DX,OFFSET DG:ABORTINS
	INT	21H
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	INS
	MOV	BX,[CURRENT]
	CALL	CHKRANGE
INS:
	CALL	FINDLIN
	MOV	BX,DX
	MOV	DX,[LAST_MEM]
	CALL	MOVEFILE
INLP:
	CALL	SETPTS			;Update the pointers into file
	CALL	SHOWNUM
	MOV	DX,OFFSET DG:EDITBUF
	MOV	AH,STD_CON_STRING_INPUT
	INT	21H
	CALL	LF
	MOV	SI,2 + OFFSET DG:EDITBUF
	CMP	BYTE PTR [SI],1AH
	JZ	ENDINS
;-----------------------------------------------------------------------
	call	unquote 		;scan for quote chars if any
;-----------------------------------------------------------------------
	MOV	CL,[SI-1]
	MOV	CH,0
	MOV	DX,DI
	INC	CX
	ADD	DX,CX
	JC	MEMERRJ1
	JZ	MEMERRJ1
	CMP	DX,BP
	JB	MEMOK
MEMERRJ1:
	CALL	END_INS
	JMP	MEMERR
MEMOK:
	REP	MOVSB
	MOV	AL,10
	STOSB
	INC	BX
	JMP	SHORT INLP

ABORTMERGE:
	MOV	DX,OFFSET DG:START
	MOV	AH,SET_DMA
	INT	21H

ABORTINS:
	MOV	AX,CS			;Restore segment registers
	MOV	DS,AX
	MOV	ES,AX
	MOV	AX,CSTACK
	MOV	SS,AX
	MOV	SP,STACK
	STI
	CALL	CRLF
	CALL	ENDINS
	JMP	COMOVER

ENDINS:
	CALL	END_INS
	return

END_INS:
	MOV	BP,[ENDTXT]
	MOV	DI,[POINTER]
	MOV	SI,BP
	INC	SI
	MOV	CX,[LAST_MEM]
	SUB	CX,BP
	REP	MOVSB
	DEC	DI
	MOV	[ENDTXT],DI
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR 23H
	MOV	DX,OFFSET DG:ABORTCOM
	INT	21H
	return


FILLBUF:
	MOV	[PARAM1],-1		;Read in max. no of lines
	MOV	ParamCt,1
	CALL	APPEND
	MOV	Param1,0
PUBLIC ENDED
ENDED:

;Write text out to .$$$ file

	CMP	ParamCt,1
	JZ	ENDED1
CERR:	JMP	ComErr
Ended1:
	CMP	Param1,0
	JNZ	Cerr
	MOV	BYTE PTR [ENDING],1	;Suppress memory errors
	MOV	BX,-1			;Write max. no of lines
	CALL	WRT
	TEST	BYTE PTR [HAVEOF],-1
	JZ	FILLBUF
	MOV	DX,[ENDTXT]
	MOV	CX,1
	MOV	BX,[WRT_HANDLE]
	MOV	AH,WRITE
	INT	21H			;Write end-of-file byte

;Close input file			; MZ 11/30
					; MZ 11/30
	MOV	BX,[RD_HANDLE]		; MZ 11/30
	MOV	AH,CLOSE		; MZ 11/30
	INT	21H			; MZ 11/30

;Close .$$$ file

	MOV	BX,[WRT_HANDLE]
	MOV	AH,CLOSE
	INT	21H

;Rename original file .BAK

	MOV	DI,[EXT_PTR]
	MOV	SI,OFFSET DG:BAK
	MOVSW
	MOVSW
	MOVSB
	MOV	DX,OFFSET DG:PATH_NAME
	MOV	DI,OFFSET DG:TEMP_PATH
	MOV	AH,RENAME
	INT	21H
	MOV	DI,[EXT_PTR]
	MOV	SI,OFFSET DG:$$$FILE
	MOVSW
	MOVSW
	MOVSB

;Rename .$$$ file to original name

	MOV	DX,OFFSET DG:TEMP_PATH
	MOV	DI,OFFSET DG:PATH_NAME
	MOV	AH,RENAME
	INT	21H
						;      mode
	mov	ah,exit
	xor	al,al
	int	21h

;=========================================================================
; EDLIN_DISP_GET: This routine will give us the attributes of the
;		  current display, which are to be used to restore the screen
;		  back to its original state on exit from EDLIN.  We also
;		  set the screen to a text mode here with an 80 X 25 color
;		  format.
;
;	Inputs	: VIDEO_GET - 0fH (get current video mode)
;		  VIDEO_SET - 00h (set video mode)
;		  VIDEO_TEXT- 03h (80 X 25 color mode)
;
;	Outputs : VIDEO_ORG - Original video attributes on entry to EDLIN
;
;=========================================================================

EDLIN_DISP_GET	proc	near			;an000;video attributes

	push	ax				;an000;save affected regs.
	push	bx				;an000;
	push	cx				;an000;
	push	dx				;an000;
	push	si				;an000;
	push	ds				;an000;

	push	cs				;an000;exchange cs/ds
	pop	ds				;an000;

	mov	ax,440Ch			;an000;generic ioctl
	mov	bx,Std_Out			;an000;Console
	mov	cx,(Display_Attr shl 8) or Get_Display ;an000;get display
	mov	dx,offset dg:Video_Buffer	;an000;buffer for video attr.
	int	21h				;an000;
;	$if	nc				;an000;function returned a
	JC $$IF15
						;      buffer
		mov	si,dx			;an000;get pointer
		mov	ax,word ptr dg:[si].Display_Length_Char  ;an000;get video len.
		dec	ax			;an000;allow room for message
		mov	dg:Disp_Len,al		;an000;put it into var.
		mov	ax,word ptr dg:[si].Display_Width_Char ;an000;get video width
		mov	dg:Disp_Width,al	;an000;put it into var.
;	$else					;an000;function failed use
	JMP SHORT $$EN15
$$IF15:
						;      default values
		mov	al,Def_Disp_Len 	;an000;get default length
		dec	al			;an000;leave room for messages
		mov	dg:Disp_Len,al		;an000;use default length
		mov	dg:Disp_Width,Def_Disp_Width;an000;use default width
;	$endif					;an000;
$$EN15:

	pop	ds				;an000;restore affected regs.
	pop	si				;an000;
	pop	dx				;an000;
	pop	cx				;an000;
	pop	bx				;an000;
	pop	ax				;an000;

	ret					;an000;return to caller

EDLIN_DISP_GET	endp				;an000;end proc.


;=========================================================================
; EXT_OPEN1 : This routine opens a file for read/write access.	If the file
;	      if not present for opening the open will fail and return with a
;	      carry set.
;
;	Inputs : BX - Open mode
;		 CX - File attributes
;		 DX - Open action
;
;	Outputs: CY - If error
;
;	Date	   : 6/10/87
;=========================================================================

EXT_OPEN1	proc	near			;an000;open for R/W

	assume	ds:dg
	push	ds				;an000;save regs
	push	si				;an000;

	mov	ah,ExtOpen			;an000;extended open
	mov	al,0				;an000;reserved by system
	mov	si,offset dg:path_name		;an000;point to PATH_NAME

	int	21h				;an000;invoke function
	pop	si				;an000;restore regs
	pop	ds				;an000;

	ret					;an000;return to caller

EXT_OPEN1	endp				;an000;end proc.

;=========================================================================
; EXT_OPEN2  : This routine will attempt to create a file for read/write
;	       access.	If the files exists the create will fail and return
;	       with the carry set.
;
;	Inputs : BX - Open mode
;		 CX - File attributes
;		 DX - Open action
;
;	Outputs: CY - If error
;
;	Date	   : 6/10/87
;=========================================================================

EXT_OPEN2	proc	near			;an000;create a file

	assume	ds:dg
	push	ds				;an000;save regs
	push	si				;an000;

	mov	ah,ExtOpen			;an000;extended open
	mov	al,0				;an000;reserved by system
	mov	si,offset dg:temp_path		;an000;point to TEMP_PATH

	int	21h				;an000;invoke function

	pop	si				;an000;restore regs
	pop	ds				;an000;

	ret					;an000;return to caller

EXT_OPEN2	endp				;an000;end proc.

;=========================================================================
; EXT_OPEN3  : This routine will attempt to create a file for read
;	       access.	If the files exists the create will fail and return
;	       with the carry set.
;
;	Inputs : BX - Open mode
;		 CX - File attributes
;		 DX - Open action
;
;	Outputs: CY - If error
;
;	Date	   : 6/10/87
;=========================================================================

EXT_OPEN3	proc	near			;an000;create a file

	assume	ds:dg
	push	ds				;an000;save regs
	push	si				;an000;

	mov	ah,ExtOpen			;an000;extended open
	mov	al,0				;an000;reserved by system
	mov	si,offset dg:mrg_path_name	;an000;point to mrg_path_name

	int	21h				;an000;invoke function

	pop	si				;an000;restore regs
	pop	ds				;an000;

	ret					;an000;return to caller

EXT_OPEN3	endp				;an000;end proc.


;=========================================================================
; EDLIN_COMMAND : This routine provides an interface between the new
;		  parser and the existing logic of EDLIN.  We will be
;		  interfacing the parser with three existing variables.
;
;	Inputs : FILESPEC - Filespec entered by the user and passed by
;			    the parser.
;
;		 PARSE_SWITCH_B - Contains the result of the parse for the
;				/B switch.  This is passed by the parser.
;
;	Outputs: PATH_NAME - Filespec
;		 LOADMOD   - Flag for /B switch
;		 FNAME_LEN - Length of filespec
;
;	Date	   : 6/11/87
;=========================================================================

EDLIN_COMMAND		proc	near		;an000;interface parser

	push	ax				;an000;save regs.
	push	cx				;an000;
	push	di				;an000
	push	si				;an000;

	mov	si,offset dg:filespec		;an000;get its offset
	mov	di,offset dg:path_name		;an000;get its offset

	mov	cx,00h				;an000;cx will count filespec
						;      length
	cmp	parse_switch_b,true		;an000;do we have /B switch
;	$if	z				;an000;we have the switch
	JNZ $$IF18
		mov	[LOADMOD],01h		;an000;signal switch found
;	$endif					;an000
$$IF18:

;	$do					;an000;while we have filespec
$$DO20:
		lodsb				;an000;move byte to al
		cmp	al,nul			;an000;see if we are at
						;      the end of the
						;      filespec
;		$leave	e			;an000;exit while loop
		JE $$EN20
		stosb				;an000;move byte to path_name
		inc	cx			;an000;increment the length
						;      of the filespec
;	$enddo					;an000;end do while
	JMP SHORT $$DO20
$$EN20:

	mov	[FNAME_LEN],cx			;an000;save filespec's length

	pop	si				;an000; restore regs
	pop	di				;an000;
	pop	cx				;an000;
	pop	ax				;an000;

	ret					;an000;return to caller

EDLIN_COMMAND		endp			;an000;end proc


;=========================================================================
; Calc_Memory_Avail	: This routine will calculate the memory
;			  available for use by EDLIN.
;
;	Inputs	: ORG_DS - DS of PSP
;
;	Outputs : DX	 - paras available
;=========================================================================

Calc_Memory_Avail	proc	near		;an000; dms;

	push	ds				;save ds for size calc
	push	cx				;an000; dms;
	push	di				;an000; dms;

	mov	ds,cs:[org_ds]
	MOV	CX,DS:[2]
	MOV	DI,CS
	SUB	CX,DI
	mov	dx,cx				;an000; dms;put paras in DX

	pop	di				;an000; dms;
	pop	cx				;an000; dms;
	pop	ds				;an000; dms;

	ret					;an000; dms;

Calc_Memory_Avail	endp			;an000; dms;

;=========================================================================
; EA_Fail_Exit		: This routine tells the user that there was
;			  Insufficient memory and exits EDLIN.
;
;	Inputs	: MemFul_Ptr - "Insufficient memory"
;
;	Outputs : message
;=========================================================================

EA_Fail_Exit		proc	near		;an000; dms;

	mov	dx,offset dg:MemFul_Ptr 	;an000; dms;"Insufficient

	push	cs				;an000; dms;xchange ds/cs
	pop	ds				;an000; dms;
						;	     memory"
	call	Std_Printf			;an000; dms;print message
	mov	ah,exit 			;an000; dms;exit
	xor	al,al				;an000; dms;clear al
	int	21h				;an000; dms;
	ret					;an000; dms;

EA_Fail_Exit		endp			;an000; dms;

CODE	ENDS
	END	EDLIN


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\edlequ.asm ===
page	60,132			;
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

	.xlist
	include version.inc
	include DOSSYM.INC
	include EDLSTDSW.INC
	.list

;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: EDLEQU.SAL
;
; DESCRIPTIVE NAME: EQUATES FOR EDLIN
;
; FUNCTION: PROVIDES EQUATES FOR EDLIN.  IT ALSO PROVIDES THE MACRO
;	    VAL_YN.
;
; ENTRY POINT: NA
;
; INPUT: NA
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
;	ROUTINE: VAL_YN - VALIDATES Y/N RESPONSES FROM THE KEYBOARD
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: NA
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT SYSPARSE
;				- IMPLEMENT MESSAGE RETRIEVER
;				- IMPLEMENT DBCS ENABLING
;				- ENHANCED VIDEO SUPPORT
;				- EXTENDED OPENS
;				- SCROLLING ERROR
;
; COPYRIGHT: "MS DOS EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;
;======================= END OF SPECIFICATIONS ===========================






COMAND_LINE_LENGTH EQU 128
QUOTE_CHAR EQU	16H			;Quote character = ^V
CR	EQU	13
STKSIZ	EQU	200h
STACK	equ	stksiz

asian_blk      equ DB_SP_LO		;an000;asian blank 2nd. byte
dbcs_lead_byte equ DB_SP_HI		;an000;asian blank lead byte
nul	equ	00h			;an000;nul character
Access_Denied equ 0005h 		;an000;extended error code for access denied

;======== Y/N validation equates =========================================

yn_chk	equ	23h			;an000;check for Y/N response
max_len equ	01h			;an000;max. len. for Y/N char.
yes	equ	01h			;an000;boolean yes value
no	equ	00h			;an000;boolean no value

;======== text display values for initialization =========================

video_get equ	0fh			;an000;int 10 get video attributes
video_set equ	00h			;an000;int 10 set video attributes
video_text equ	03h			;an000;80 X 25 color monitor

;======== code page values for functions =================================

get_set_cp equ	66h			;an000;get or set code page
get_cp	equ	01h			;an000;get active code page
set_cp	equ	02h			;an000;set active code page

;======== screen length & width defaults =================================

std_out equ	01h			;an000;console output
display_attr equ 03h			;an000;display for IOCTL
Get_Display equ 7fh			;an000;Get display for IOCTL
ifndef JAPAN
Def_Disp_Len equ 25			;an000;default display length
else					; if JAPAN
Def_Disp_Len equ 24
endif
Def_Disp_Width equ 80			;an000;default display width

;======== extended open equates ==========================================

rw	equ	0082h			;an000;read/write
					;      compatibility
					;      noinherit
					;      int 24h handler
					;      no commit

ext_read equ	0080h			;an000;read
					;      compatibility
					;      noinherit
					;      int 24h handler
					;      no commit

rw_flag equ	0101h			;an000;fail if file not exist
					;      open if file exists
					;      don't validate code page

creat_flag equ	0110h			;an000;create if file does not exist
					;      fail if file exists
					;      don't validate code page

open_flag equ	0101h			;an000;fail if file not exist
					;      open if file exists
					;      don't validate code page

creat_open_flag equ 0112h		;an000;create if file does not exist
					;      open/replace if file exists
					;      don't validate code page

attr	equ	00h			;an000;attributes set to 0

;======== parse value equates ============================================

nrm_parse_exit equ 0ffffh		;an000;normal exit from sysparse
too_many equ	01h			;an000;too many parms entered
op_missing equ	02h			;an000;required operand missing
sw_missing equ	03h			;an000;not a valid switch


;======== Strucs =========================================================

Display_Buffer_Struc Struc		;an000;dms;

	Display_Info_Level db	   ?	;an000;dms;
	Display_Reserved db	 ?	;an000;dms;
	Display_Buffer_Size dw	    ?	;an000;dms;
	Display_Flags dw      ? 	;an000;dms;
	Display_Mode db      ?		;an000;dms;
					;  TEXT=01
					;  APA =02
	Display_Mode_Reserved db      ? ;an000;dms;
	Display_Colors dw      ?	;an000;dms;# of colors
	Display_Width_Pixels dw      ?	;an000;dms;# of pixels in width
	Display_Length_Pixels dw      ? ;an000;dms;# of pixels in len.
	Display_Width_Char dw	   ?	;an000;dms;# of chars in width
	Display_Length_Char dw	    ?	;an000;dms;# of chars in length

Display_Buffer_Struc ends		;an000;dms;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\edlparse.asm ===
page	60,132;
	title	EDLPARSE for EDLIN
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


;******************* START OF SPECIFICATIONS *****************************
;
; MODULE NAME: EDLPARSE.SAL
;
; DESCRIPTIVE NAME: PARSES THE EXTERNAL COMMAND LINE FOR EDLIN
;
; FUNCTION: THIS ROUTINE PROVIDES PARSING CAPABILITIES FOR THE
;	    EXTERNAL COMMAND LINE OF EDLIN.  IT PARSES FOR THE PRESENCE
;	    OF A REQUIRED FILESPEC AND AN OPTIONAL SWITCH (/B).
;
; ENTRY POINT: PARSER_COMMAND
;
; INPUT: DOS COMMAND LINE
;
; EXIT NORMAL: AX = 0FFH    - VALID SWITCH AND FILESPEC SPECIFIED
;
; EXIT ERROR:  AX NOT= 0FFH - INVALID SWITCH OR NO FILESPEC SPECIFIED
;
; INTERNAL REFERENCES
;
;	ROUTINE: PARSER_COMMAND - THIS ROUTINE PARSES FOR THE PRESENCE
;				  OF THE /B SWITCH AND A FILESPEC.  THE
;				  FILEPSEC IS REQUIRED, WHILE THE SWITCH
;				  IS OPTIONAL.
;
; EXTERNAL REFERENCES:
;
;     ROUTINE: PARSE.ASM - THIS IS THE PARSER CODE.
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - IMPLEMENTS THE SYSTEM PARSER (SYSPARSE)
;
; COPYRIGHT: "THE IBM PERSONAL COMPUTER EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft"
;
;
;******************** END OF SPECIFICATIONS ******************************


;======================= equates for edlparse ============================

parse_ok	equ	0			;an000;good parse return
parse_command	equ	081h			;an000;offset of command line
nul		equ	0			;an000;nul
fs_flag 	equ	05h			;an000;filespec found
sw_flag 	equ	03h			;an000;switch found
true		equ	0ffffh			;an000;true
false		equ	00h			;an000;false
too_many	equ	01h			;an000;too many parms

;======================= end equates =====================================


CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC BYTE

	extrn	path_name:byte
	extrn	org_ds:word			;an000; dms;

	public	parse_switch_b			;an000;parse switch result
	public	parse_switch_?			;      parse switch result
	public	filespec			;an000;actual filespec

;======================= input parameters control blocks =================
; these control blocks are used by sysparse and must be pointed to by
; es:di on invocation.

		public	parms			;an000;share parms
parms		label	byte			;an000;parms control block
		dw	dg:parmsx		;an000;point to parms structure
		db	00h			;an000;no additional delims.

parmsx		label	byte			;an000;parameter types
		db	1,1			;an000;must have filespec
		dw	dg:fs_pos		;an000;filespec control block
		db	2			;an000;max. number of switches
		dw	dg:sw_b 		;an000;/b switch control block
		dw	dg:sw_? 		;an000;/? switch control block
		db	00h			;an000;no keywords

;======================= filespec positional tables ======================

fs_pos		label	byte			;an000;filespec positional
		dw	0200h			;an000;filespec/not optional
		dw	0001h			;an000;cap
		dw	dg:filespec_res 	;an000;filespec result table
		dw	dg:noval		;an000;value list/none
		db	0			;an000;no keyword/switch syns.

filespec_res	label	byte			;an000;filespec result table
parse_fs_res	db	?			;an000;must be filespec (05)
parse_fs_tag	db	?			;an000;item tag
parse_fs_syn	dw	?			;an000;synonym pointer
parse_fs_off	dw	?			;an000;offset to filespec
parse_fs_seg	dw	?			;an000;segment of filespec

;======================= switch tables /b ================================

sw_b		label	byte			;an000;/b switch
		dw	0000h			;an000;no match flags
		dw	0000h			;an000;no cap
		dw	dg:switch_res		;an000;result buffer
		dw	dg:noval		;an000;value list/none
		db	1			;an000;1 switch
sw_b_switch	db	"/B",0			;an000;/B means ignore CTL-Z

sw_?		label	byte			;an000;/b switch
		dw	0000h			;an000;no match flags
		dw	0000h			;an000;no cap
		dw	dg:switch_res		;an000;result buffer
		dw	dg:noval		;an000;value list/none
		db	1			;an000;1 switch
sw_?_switch	db	"/?",0			;an000;/B means ignore CTL-Z
	PUBLIC sw_?_switch
switch_res	label	byte			;an000;switch result table
parse_sw_res	db	?			;an000;must be string (03)
parse_sw_tag	db	?			;an000;item tag
parse_sw_syn	dw	?			;an000;synonym pointer
parse_sw_ptr	dd	?			;an000;pointer to result

noval		label	byte			;an000;value table
		db	0			;an000;no values


;======================= end input parameter control blocks ==============

filespec	db	128 dup (0)		;an000;holds filespec
parse_switch_b	db	false			;an000;hold boolean result
						;      of /b parse
parse_switch_?	db	false			; true if /? found
parse_sw_b	db	"/B"			;an000;comparison switch

DATA	ENDS

DG	GROUP	CODE,CONST,cstack,DATA

code	segment public	byte			;an000;code segment
	assume cs:dg,ds:dg,es:dg,ss:CStack	;an000;

	public	parser_command			;an000;share this routine



;======================= begin main routine ==============================
.xlist

include version.inc  ; parse.asm include psdata.inc which needs defs from here
include parse.asm				;an000;parser

.list

parser_command	proc	near			;an000;parse routine

	push	es				;an000;save registers
	push	ds				;an000;
	push	di				;an000;
	push	si				;an000;

	mov	dg:parse_switch_b,false 	;an000;init. to false
	xor	cx,cx				;an000;set cx to 0
	xor	dx,dx				;an000;set dx to 0
	mov	di,offset dg:parms		;an000;point to parms
	mov	si,parse_command		;an000;point to ds:81h
	mov	ds,dg:org_ds			;an000;get ds at entry
	assume	ds:nothing			;an000;

parse_continue: 				;an000;loop return point

	call	sysparse			;an000;invoke parser
	cmp	ax,parse_ok			;an000;is it a good parse
	jne	parse_end			;an000;continue on good parse
	push	si
	mov	si,dx
	cmp	byte ptr es:[si],fs_flag	;an000;do we have a filespec
;	$if	e				;an000;yes we do
	JNE $$IF1
		call build_fs			;an000;save filespec
;	$else					;an000;
	JMP SHORT $$EN1
$$IF1:
	; A switch was found.
	; See which one it was.

	  call	val_sw				;an000;see which switch

;	$endif					;an000;
$$EN1:

	pop	si
	jmp	parse_continue			;an000;continue parsing

parse_end:					;an000;end parse routine

	pop	si				;an000;restore registers
	pop	di				;an000; for return to caller
	pop	ds				;an000;
	assume	ds:dg				;an000;
	pop	es				;an000;

	ret					;an000;return to caller

parser_command	endp				;an000;end parser_command


;======================= subroutine area =================================


;=========================================================================
; build_fs: This routine saves the filespec for use by the calling program.
;=========================================================================

build_fs	proc	near			;an000;save filespec

	push	ax				;an000;save affected regs.
	push	di				;an000;
	push	si				;an000;
	push	ds				;an000;
	push	es				;an000;

	mov	di,offset dg:filespec		;an000;point to filespec buffer
	lds	si,dword ptr es:parse_fs_off	;an000;get offset

build_cont:					;an000;continue routine

	lodsb					;an000;mov ds:si to al
	cmp	al,nul				;an000;is it end of filespec
;	$if	nz				;an000;if not
	JZ $$IF7
		stosb				;an000;move byte to filespec
		jmp build_cont			;an000;continue buffer fill
;	$endif					;an000;
$$IF7:
	stosb					;an000;save nul

	pop	es				;an000;restore regs
	pop	ds				;an000;
	pop	si				;an000;
	pop	di				;an000;
	pop	ax				;an000;

	ret					;an000;return to caller

build_fs	endp				;an000;end proc

;=========================================================================
; val_sw : determines which switch we have.
;=========================================================================

val_sw		proc	near			;an000;switch determination

	; Check for /B

	cmp	es:[parse_sw_syn], offset es:sw_b_switch
	jne	ValSwitchBDone
	cmp	es:[parse_switch_b], true	; see if already given
	jne	ValSwitchBOkay			; jump if not
	mov	ax, too_many			; set error level
	jmp	parse_end			;  and exit parser
ValSwitchBOkay:
	mov	es:[parse_switch_b], true	; set the flag on
	jmp	short ValSwitchExit		;  and done
ValSwitchBDone:

	; Check for /?

	cmp	es:[parse_sw_syn], offset es:sw_?_switch
	jne	ValSwitch?Done
	mov	es:[parse_switch_?], true	; set the flag on
	jmp	short ValSwitchExit		;  and done
ValSwitch?Done:

ValSwitchExit:

	ret					;an000;return to caller

val_sw		endp				;an000;end proc


code	ends					;an000;end segment
	end					;an000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\edlin\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\e2binit.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

Title	E2BINIT(EXE2BIN)

;*****************************************************************************
;   Loader for EXE files under 86-DOS
;   VER 1.5
;	05/21/82   Added rev number
;   VER 1.6
;	07/01/82   A little less choosy about size matches
;   VER 2.0  M.A.U
;	10/08/82   Modified to use new 2.0 system calls for file i/o
;   Ver 2.1  M.A.U
;	10/27/82   Added the DOS version check
;   Ver 2.2  MZ
;	8/30/83     Fixed command line parsing
;   Ver 2.3  EE
;	10-12-83    More fixes to command line parsing
;   Ver 2.4  NP
;	10/17/83    Use Printf for messages
;   Ver 2.5  MZ     Fix LOCATE sss D: problem
;	04/09/87    Add PARSER and MESSAGE RETRIEVER
;   Ver 4.00  DRM
;
;       M001    MD      12/27/90        Removed special checks for ambiguous
;                                       file names
;*****************************************************************************


INCLUDE SYSMSG.INC
MSG_UTILNAME <EXE2BIN>							;AN000;

	subttl	Main Code Area						;AN000;
	page


; The following switch allows use with the "old linker", which put a version
; number where the new linker puts the number of bytes used in the last page.
; If enabled, this will cause a test for 0004 at this location (the old linker
; version number), and if equal, change it to 200H so all of the last page
; will be used.

OLDLINK EQU	0			;1 to enable, 0 to disable

CODE	SEGMENT PARA PUBLIC 'CODE'					;AN000;
CODE	ENDS								;AN000;
DATA	SEGMENT PARA PUBLIC 'DATA'					;AN000;
DATA	ENDS								;AN000;
STACK	SEGMENT PARA PUBLIC 'STACK'					;AN000;
STACK	ENDS								;AN000;
ZLOAD	SEGMENT PARA PUBLIC 'ZLOAD'					;AN000;
ZLOAD	ENDS								;AN000;

DATA	SEGMENT PARA PUBLIC 'DATA'					;AN000;

MSG_SERVICES <MSGDATA>							;AN000;

Command_Line_Buffer db 128 dup(0)					;AN000;
Command_Line_Length equ $ - Command_Line_Buffer 			;AN000;

Fatal_Error db	0							;AN000;

Command_Line db NO



rev	db	"2.4"


file1_ext db	".EXE",00h
file2_ext db	".BIN",00h

per11	db	0							;AN000;
per2	db	0
per22	db	0							;AN000;

update	equ	0							;AN000;
noupdate equ	-1							;AN000;

file1	db	(64+13) dup(?)
fnptr	dw	offset file1		; Ptr to filename in file1
handle1 dw	1 dup(?)

file2	db	(64+13) dup(?)
f2cspot dw	offset file2		; Ptr to spot in file2, file1 maybe added

name2_given	db	1		;1-> atleast the file2 name is present
ext2_given	db	0		;1-> full file2 spec given
file2_given	db	0		; is TRUE if user specified atleast a 
					; drive, or path (or full name)
handle2 dw	1 dup(?)

dma_buf db	80h dup(0)		; DMA transfer buffer

INBUF	DB	5,0
	DB	5 DUP(?)

;The following locations must be defined for storing the header:

RUNVAR	LABEL	BYTE			;Start of RUN variables
RELPT	DW	?
LASTP	LABEL	WORD
RELSEG	DW	?
SIZ	LABEL	WORD			;Share these locations
PAGES	DW	?
RELCNT	DW	?
HEADSIZ DW	?
	DW	?
LOADLOW DW	?
INITSS	DW	?
INITSP	DW	?
	DW	?
INITIP	DW	?
INITCS	DW	?
RELTAB	DW	?
RUNVARSIZ EQU	$-RUNVAR

DBCS_Vector_Off dw 0							;AN000;
DBCS_Vector_Seg dw 0							;AN000;

parse_ptr DW	?

DATA	ENDS


STACK	SEGMENT PARA PUBLIC 'STACK'
	DB	(362 - 80h) + 80H DUP (?) ; (362 - 80h) is IBMs ROM requirement
					; (New - Old) == size of growth
STACK	ENDS
;



ZLOAD	SEGMENT PARA PUBLIC 'ZLOAD'
	db	?
ZLOAD	ENDS
LOAD	EQU	ZLOAD
;



;
;*****************************************************************************
; Include files
;*****************************************************************************
;

.xlist
INCLUDE DOSSYM.INC			; also versiona.inc		;AN000;
INCLUDE SYSCALL.INC							;AN000;
INCLUDE E2BMACRO.INC							;AN000;
INCLUDE E2BEQU.INC							;AN000;
INCLUDE E2BTABLE.INC							;AN000;
INCLUDE E2BPARSE.INC							;AN000;
include version.inc
.list



CODE	SEGMENT PARA PUBLIC 'CODE'
	assume	cs:CODE,ds:DATA,es:NOTHING,SS:STACK			;AN000;

psp_ptr dw	1 dup(?)						;AN000;
;
;*****************************************************************************
; SysDisplayMsg Declarations
;*****************************************************************************
;
.xlist
MSG_SERVICES <LOADmsg>							;AN000;
MSG_SERVICES <DISPLAYmsg,CHARmsg>					;AN000;
MSG_SERVICES <EXE2BIN.CLA,EXE2BIN.CLB>					;AN000;
MSG_SERVICES <EXE2BIN.CL1,EXE2BIN.CL2>					;AN000;
MSG_SERVICES <EXE2BIN.CTL>						;AN000;


.list

;
;*****************************************************************************
; External Routine Declarations
;*****************************************************************************
;

	public	SysDispMsg						;AN000;
	public	SysLoadMsg						;AN000;


;*****************************************************************************
;Routine name:	Main_Init
;*****************************************************************************
;
;Description: Main control routine for init section
;
;Called Procedures: Message (macro)
;		    Check_DOS_Version
;		    Init_Input_Output
;		    Validate_Target_Drive
;		    Hook_CNTRL_C
;
;Input: None
;
;Output: None
;
;Change History: Created	6/22/87 	DM
;
;*****************************************************************************

procedure Main_Init near		;				;AN000;

	ASSUME	DS:NOTHING		; THIS IS WHAT dos GIVES YOU	;AN000;
	ASSUME	ES:NOTHING						;AN000;

	PUSH	DS							;AN000;
	mov	psp_ptr,ds						;AN000;
	XOR	AX,AX							;AN000;
	PUSH	AX			;Push return address to DS:0	;AN000;

	MOV	AX,SEG DATA		;SET UP ADDRESSABILITY TO	;AN000;
	MOV	DS,AX			; THE DATA SEGMENT		;AN000;
	ASSUME	DS:DATA 		;TELL ASSEMBLER WHAT I JUST DID ;AN000;

	mov	Fatal_Error,No		;Init the error flag		;AN000;
	call	Init_Input_Output	;Setup messages and parse	;AN000;
	cmp	Fatal_Error,Yes 	;Error occur?			;AN000;
;	$IF	NE			;Nope, keep going		;AN000;
	JE $$IF1
	    call    LOCATE		;Go do the real program 	;AN000;
;	$ENDIF								;AN000;
$$IF1:
	xor	al,al							;AN000;
	Dos_call Exit							;AN000;
	int	20h			;If other exit fails		;AN000;

Main_Init endp								;AN000;

;*****************************************************************************
;Routine name: Init_Input_Output
;*****************************************************************************
;
;Description: Initialize messages, Parse command line, allocate memory as
;	      needed. If there is a /FS switch, go handle it first as
;	      syntax of IFS format may be different from FAT format.
;
;Called Procedures: Preload_Messages
;		    Parse_For_FS_Switch
;		    Parse_Command_Line
;		    Interpret_Parse
;
;Change History: Created	6/22/87 	DM
;
;Input: PSP command line at 81h and length at 80h
;	Fatal_Error  = No
;
;Output: Fatal_Error = YES/NO
;
;*****************************************************************************

procedure Init_Input_Output near					;AN000;

	call	Preload_Messages	;Load up message retriever	;AN000;
	cmp	Fatal_Error,YES 	;Quit?				;AN000;
;	$IF	NE			;Nope, keep going		;AN000;
	JE $$IF3
	    call    Parse_Command_Line	;Parse in command line input	;AN000;
;	$ENDIF								;AN000;
$$IF3:
	ret								;AN000;

Init_Input_Output endp							;AN000;

;*****************************************************************************
;Routine name: Preload_Messages
;*****************************************************************************
;
;Description: Preload messages using common message retriever routines.
;
;Called Procedures: SysLoadMsg
;
;
;Change History: Created	6/22/87 	DM
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;*****************************************************************************

procedure Preload_Messages near 					;AN000;

	call	SYSLOADMSG		;Preload the messages		;AN000;
;	$IF	C			;Error? 			;AN000;
	JNC $$IF5
	    call    SYSDISPMSG						;AN000;
	    mov     fatal_error, YES					;AN000;
;	$ENDIF								;AN000;
$$IF5:
	ret								;AN000;
Preload_Messages endp							;AN000;


;*****************************************************************************
;Routine name: Parse_Command_Line
;*****************************************************************************
;
;Description: Parses command line.
;
;Called Procedures: Message (macro)
;		    Sysparse
;
;Change History: Created	6/22/87 	DM
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;*****************************************************************************


Procedure Parse_Command_Line						;AN000;

	push	ds							;AN000;
	mov	ds,psp_ptr						;AN000;
	ASSUME	DS:NOTHING						;AN000;
	mov	si,Command_Line_Parms					;AN000;
	mov	ax,seg command_line_table				;AN000;
	push	es							;AN000;
	mov	es,ax							;AN000;
	ASSUME	ES:NOTHING						;AN000;
	mov	di,offset Command_Line_Table				;AN000;
	xor	cx,cx							;AN000;

	PUBLIC	MainParseLoop
MainParseLoop:

;	$DO								;AN000;
$$DO7:
	    xor     dx,dx						;AN000;
	    mov     es:parse_ptr,si
	    call    Sysparse						;AN000;
	    cmp     ax,No_Error 					;AN000;

;	    $IF     E							;AN000;
	    JNE $$IF8

	        ; Check if /? switch entered.
		; If so, display the options help message
		; and set for exit.
		;
		; This gives the user the info they want,
		; without all the other possible error messages.
		;
		; 4/18/90 c-PaulB

		cmp	es:[sw_synonym1], offset sw1_s1	; /?
		jne	CheckSW1Done			;  skip this if not
		call	DisplayOptions			; else display msg
		mov	es:[Fatal_Error], YES		; set flag to stop
		jmp	ParseCLExit			;  and bail out now
CheckSW1Done:

		push	ax						;AN000;
		push	bx						;AN000;
		push	ds						;AN000;
		push	es						;AN000;
		push	si						;AN000;
		push	di						;AN000;

		cmp	cx,1						;AN000;

;		$IF	E						;AN000;
		JNE $$IF9

		    mov     ax,seg rb_string1_off			;AN000;
		    mov     ds,ax					;AN000;
		    ASSUME  DS:NOTHING					;AN000;
		    mov     si,offset rb_string1_off			;AN000;
		    mov     ax,ds:[si]					;AN000;
		    mov     bx,ax					;AN000;


		    mov     ax,ds:[si+2]				;AN000;
		    mov     ds,ax					;AN000;
		    ASSUME  DS:NOTHING					;AN000;
		    mov     si,bx					;AN000;

		    mov     ax,seg file1				;AN000;
		    mov     es,ax					;AN000;
		    ASSUME  ES:NOTHING					;AN000;
		    mov     di,offset file1				;AN000;
		    call    copyfs					;AN000;

;		$ELSE							;AN000;
		JMP SHORT $$EN9
$$IF9:

		    mov     ax,seg rb_string2_off			;AN000;
		    mov     ds,ax					;AN000;
		    ASSUME  DS:NOTHING					;AN000;
		    mov     si,offset rb_string2_off			;AN000;
		    mov     ax,ds:[si]					;AN000;
		    mov     bx,ax					;AN000;


		    mov     ax,ds:[si+2]				;AN000;
		    mov     ds,ax					;AN000;
		    ASSUME  DS:NOTHING					;AN000;
		    mov     si,bx					;AN000;

		    mov     ax,seg file2				;AN000;
		    mov     es,ax					;AN000;
		    ASSUME  ES:NOTHING					;AN000;
		    mov     di,offset file2				;AN000;
		    call    copyfs					;AN000;

;		$ENDIF							;AN000;
$$EN9:

		pop	di						;AN000;
		pop	si						;AN000;
		pop	es						;AN000;
		ASSUME	ES:NOTHING					;AN000;
		pop	ds						;AN000;
		ASSUME	DS:NOTHING					;AN000;
		pop	bx						;AN000;
		pop	ax						;AN000;

;	    $ENDIF							;AN000;
$$IF8:

	    cmp     ax,No_Error 					;AN000;

;	$ENDDO	NE							;AN000;
	JE $$DO7

	cmp	ax,End_of_Parse 	;Check for parse error		;AN000;
;	$IF	NE							;AN000;
	JE $$IF14
		push	ax						;AN001;
		mov	ax,es:parse_ptr 				;AN001;
		mov	es:parsoff,ax					;AN001;
		mov	es:parseg,ds					;AN001;
		mov	byte ptr ds:[si],0				;AN001;
		pop	ax						;AN001;
		parse_message		       ;Must enter file name	;AN000;
		mov	es:Fatal_Error,YES     ;Indicate death! 	;AN000;
;	$ENDIF								;AN000;
$$IF14:
ParseCLExit:
	pop	es							;AN000;
	ASSUME	ES:NOTHING						;AN000;
	pop	ds							;AN000;
	ASSUME	DS:DATA 						;AN000;

	ret								;AN000;

Parse_Command_Line endp 						;AN000;

;*****************************************************************************
;Routine name: Parse_Command_Line
;*****************************************************************************
;
;Description:       Displays options help message lines.
;
;Called Procedures: Display_Interface
;
;Change History:    Created 5/2/90 c-PaulB
;
;Input:             No value passed.
;
;Output:            No value returned.
;
;*****************************************************************************


Procedure DisplayOptions

	mov     dx, offset msgOptions		; get options msg
DO_Loop:
	call    Display_Interface		;  and show it
	cmp	word ptr es:[msgOptions], MSG_OPTIONS_LAST	; last msg?
	je	DO_Done				; done if so
	inc	word ptr es:[msgOptions]		; else get next msg
	jmp	short DO_Loop			;  and go do it
DO_Done:
	ret

DisplayOptions	endp

;*****************************************************************************

INCLUDE PARSE.ASM

;*****************************************************************************


procedure LOCATE near

	push	ds							;AN000;
	ASSUME	ES:NOTHING		; THIS IS THE WAY IT GETS HERE! ;AN000;
	mov	ax,es			; ES -> PSP			;AN000;
	mov	ds,ax			; DS -> PSP			;AN000;
	ASSUME	DS:NOTHING						;AN000;

	MOV	SI,offset file1
	MOV	BX,SEG DATA
	MOV	ES,BX
	assume	es:data 						;AN000;

	MOV	BX,WORD PTR DS:[2]	;Get size of memory


;-----------------------------------------------------------------------;

;
; The rules for the arguments are:
;   File 1:
;	If no extention is present, .EXE is used.
;   File 2:
;	If no drive is present in file2, use the one from file1
;	If no path is specified, then use current dir
;	If no filename is specified, use the filename from file1
;	If no extention is present in file2, .BIN is used
;


;----- Get the first file name
	push	ds							;AN000;
	push	es							;AN000;
	ASSUME	ES:DATA 						;AN000;
	pop	ds							;AN000;
	ASSUME	DS:DATA 						;AN000;

sj01:
	mov	si,offset file1 	;   d = file1;
	mov	per11,0 		;   assume no extension on file1;AC000;

;******************************************************************************

sj0:
	lodsb				;   while (!IsBlank(c=*p++)) {
	cmp	al,0
	JE	SJ2
	call	dbcs_check		; see if a dbcs character	;AN000;
	jc	dbcs_1			; dbcs character, go load another char ;AN000;
	cmp	al,'\'			;	if (c == '\\' || c == ':') {
	jnz	sj05
	mov	per11,update						;AC000;
	mov	fnptr,si		;	    fnptr = ptr to slash
sj05:
	cmp	al,':'			;	if (c == '\\' || c == ':') {
	jnz	checkper1
	mov	per11,update						;AC000;
	mov	fnptr,si		;	    fnptr = ptr to slash
checkper1:
	cmp	al,'.'			;	if (c == '.')
	jne	sj0                     ;                               ;M001
	mov	per11,noupdate		;   set file1 to have extension ;AN000;
        jmp     short sj0               ;                               ;M001
                                        ;M001 - code removed
dbcs_1: 				;				;AN000;
	lodsb				; load another character and got to ;AN000;
	jmp	short sj0		; the start again.		;AN000;

;******************************************************************************

sj2:
get_second:
;----- Get the second file name
; Initially we assume that user has not given any file2 spec. Then if we find
; that user has entered something, then file2_given is made to TRUE;
; Once file2_given is TRUE, then we assume that user has given atleast a name
; i.e. name2_given = 1 but ext2_given = 0;
; if we find that user has given just a drive: then name2_given is made to FALSE
; The logic then simplifies to :
;	if (!file2_given) 
;		copy file1 and add .BIN ext and try to open
; 	else { /* file2 given */
;		if (!name2_given) 
;			copy name from file1 and .BIN as extn ; try to open
;		else { /* name2 also given */
;			do find_first		
;			if (file_not_found) 
;				add extn .BIN if needed and try to open
;			else if (it is subdir)  {
;				add '\' to it;
;				add the file1 name and .BIN 
;				go for file open
;			}	
;		} /* else name2 given*/
;	} /* else file2 given */

	MOV	SI,offset file1
	mov	di,offset file2 	;   d = file2

;******************************************************************************

sj3:
	cmp	word ptr [di],00	;   check to see if first character of
	je	sj32			;   file2 is a null.		;AN000;
	mov	file2_given,1		;   user has given atleast a partial
					;    spec for file2
	mov	si,offset file2 	;   set pointer to file2

;******************************************************************************

sj31:
	lodsb				;   If file2 first character is not a
	mov	f2cspot,si
	cmp	al,0			;   null, this loop will check to see
	JZ	maycopy 		;   the file has an extension assigned;AN000;
	call	dbcs_check		; to it.  If not it will set per2 to  ;AN000;
	jc	dbcs_2			; go load another byte		      ;AN000;
	cmp	al,'\'			
	jnz	checkper6	
	cmp	byte ptr [si],0		;   end of file2 spec ?
	jne	sj31			;  no, go get next char
	mov	name2_given,0		; copy from file1
checkper6:
	cmp	al,':'			;	if (c == '\\' || c == ':') {
	jnz	checkper4
	cmp	byte ptr [si],0		; end of file2 spec ?
	jne	sj31			; no, go get next char
	mov	name2_given,0		; no name; copy from file1
checkper4:				;   there is an extension already.
	cmp	al,'.'			;
	jne	sj31			;       M001
	mov	ext2_given,1		;       M001 - code removed
	jmp	short sj31		;       M001
                                        ;       M001 - code removed
dbcs_2:                                 ;
	lodsb				;load another character and got to    ;AN000;
	jmp	short sj31		;the start again.		      ;AN000;

;******************************************************************************

; we get here only if user specified something - a drive, just a name or
; even the full spec
; check if we have to copy the name 

maycopy:				
	cmp	name2_given,1		; did the user give a name
	je	sj5			; yes, go check for the existence 
	
	dec	f2cspot 						      
	mov	di,f2cspot						     

sj32:
					;   There is no second filename so
	mov	si,fnptr						      ;AN000;

;******************************************************************************

copy1to2:								      ;AN000;
	lodsb				; This loop is executed when there is ;AN000;
	cmp	al,0			; no file2 specified on the command   ;AN000;
	JZ	SJ5			; line.  It will copy the file1 name  ;AN000;
	call	dbcs_check		; check for dbcs character	      ;AN000;
	jc	dbcs_3			; got a dbcs character, go copy.      ;AN000;
	cmp	al,'.'			; extension.  The defult extension    ;AN000;
	je	sj5			; of .BIN will be added in check_ext. ;AN000;
	stosb								      ;AN000;
	jmp	short copy1to2						      ;AN000;
dbcs_3:
	stosb				; Got a dbcs character. Copy	      ;AN000;
	lodsb				; two characters and then go to       ;AN000;
	stosb				; next character in filename.	      ;AN000;
	jmp	short copy1to2						      ;AN000;	     ;AN000;

;******************************************************************************

sj5:
;	mov	byte ptr es:[di],00h	;   *d = 0;
	cmp	file2_given,1		; if the user specified some path
	jne	check_ext		; we need to check it; else 
	cmp	name2_given,1		; add .BIN and try to open file2
	jne	check_ext		; (at this point we have the name)
	mov	ah,Set_DMA		; Use find_first to see if file2 is
	mov	dx,offset dma_buf	; a directory.	If it isn't, go to
	int	21h			; set f2cspot to point to the spot
	mov	ah,Find_First		; right after the backslash, and
	mov	dx,offset file2 	; fall through to no_second so that
	mov	cx,-1			; file1's name will be added to file2.
	int	21h
	jc	check_ext
	test	dma_buf+21,00010000b
	jNZ	DoDirectory
	jmp	short Check_Ext
DoDirectory:
	mov	AL,'\'
	mov	di,f2cspot
	dec	di
	stosb
	inc	f2cspot
	mov	name2_given,0		; so that we will copy file1.ext to
	mov	ext2_given,0		; file2; we also have to copy ext
	jmp	maycopy			; 


;----- Check that files have an extension, otherwise set default
check_ext:
	cmp	per11,noupdate		;   if (ext2_given == NULL) { 	;AC000;
	jz	file1_ok
	mov	di,offset file1 	;	d = file1;
	mov	si,offset file1_ext	;	s = ".EXE";
	call	strcat			;	strcat (d, s);
file1_ok:				;	}
	cmp	ext2_given,1		;   if (ext2_given == NULL) { 	;AC000;
	je	file2_ok
	mov	di,offset file2 	;	d = file2;
	mov	si,offset file2_ext	;	s = ".BIN";
	call	strcat			;	strcat (d, s);
	jmp	short file2_ok		;	}

;-----------------------------------------------------------------------;
file2_ok:
	mov	dx,offset file1
	mov	ax,(open SHL 8) + 0	;for reading only
	INT	21H			;Open input file
	jc	bad_file
	mov	[handle1],ax
	jmp	short exeload

bad_file:
	jmp	DosError

BADEXE:
	pop	ds
	ASSUME	DS:nothing						;AN000;
	MESSAGE msgNoConvert						;AC000;
	jmp	getout							;AN000;

ReadError:
	jmp	DosError

EXELOAD:
	ASSUME	DS:DATA 						;AN000;
	MOV	DX,OFFSET RUNVAR	;Read header in here
	MOV	CX,RUNVARSIZ		;Amount of header info we need
	push	bx
	mov	bx,[handle1]
	MOV	AH,read
	INT	21H			;Read in header
	pop	bx
	jc	ReadError
	CMP	[RELPT],5A4DH		;Check signature word
	JNZ	BADEXE
	MOV	AX,[HEADSIZ]		;size of header in paragraphs
	ADD	AX,31			;Round up first
	CMP	AX,1000H		;Must not be >=64K
	JAE	TOOBIG
	AND	AX,NOT 31
	MOV	CL,4
	SHL	AX,CL			;Header size in bytes

	push	dx
	push	cx
	push	ax
	push	bx
	mov	dx,ax
	xor	cx,cx
	mov	al,0
	mov	bx,[handle1]
	mov	ah,lseek
	int	21h
	jc	LseekError
	pop	bx
	pop	ax
	pop	cx
	pop	dx

	XCHG	AL,AH
	SHR	AX,1			;Convert to pages
	MOV	DX,[PAGES]		;Total size of file in 512-byte pages
	SUB	DX,AX			;Size of program in pages
	CMP	DX,80H			;Fit in 64K? (128 * 512 = 64k)
	JAE	TOOBIG
	XCHG	DH,DL
	SHL	DX,1			;Convert pages to bytes
	MOV	AX,[LASTP]		;Get count of bytes in last page
	OR	AX,AX			;If zero, use all of last page
	JZ	WHOLEP

	IF	OLDLINK
	    CMP     AX,4		;Produced by old linker?
	    JZ	    WHOLEP		;If so, use all of last page too
	ENDIF

	SUB	DX,200H 		;Subtract last page
	ADD	DX,AX			;Add in byte count for last page
WHOLEP:
	MOV	[SIZ],DX
	ADD	DX,15
	SHR	DX,CL			;Convert bytes to paragraphs
	MOV	BP,SEG LOAD
	ADD	DX,BP			;Size + start = minimum memory (paragr.)
	CMP	DX,BX			;Enough memory?
	JA	TOOBIG
	MOV	AX,[INITSS]
	OR	AX,[INITSP]
	OR	AX,[INITCS]
	JMP	short ERRORNZ

TOOBIG:
	pop	ds
	ASSUME	DS:NOTHING						;AN000;
	MESSAGE msgOutOfMemory						;AN000;
	jmp	getout							;AN000;

LseekError:
	jmp	DosError


ERRORNZ:
	ASSUME	DS:DATA 						;AN000;
	jz	xj
	JMP	BADEXE			;AC000; For ptm P475;
xj:	MOV	AX,[INITIP]
	OR	AX,AX			;If IP=0, do binary fix
	JZ	BINFIX
	CMP	AX,100H 		;COM file must be set up for CS:100
	JNZ	ERRORNZ

	push	dx
	push	cx
	push	ax
	push	bx
	mov	dx,100h 		;chop off first 100h
	xor	cx,cx
	mov	al,1			;seek from current position
	mov	bx,[handle1]
	mov	ah,lseek
	int	21h
	jc	LseekError
	pop	bx
	pop	ax
	pop	cx
	pop	dx

	SUB	[SIZ],AX		;And count decreased size
	CMP	[RELCNT],0		;Must have no fixups
	JNZ	ERRORNZ
BINFIX:
	XOR	BX,BX			;Initialize fixup segment
;See if segment fixups needed
	CMP	[RELCNT],0
	JZ	LOADEXE
GETSEG:
	pop	ds
	ASSUME	DS:NOTHING						;AN000;
	MESSAGE msgFixUp						;AN000;
	PUSH	DS
	PUSH	ES
	POP	DS
	ASSUME	DS:DATA 						;AN000;
	MOV	AH,STD_CON_STRING_INPUT
	MOV	DX,OFFSET INBUF
	INT	21H			;Get user response
	MOV	SI,OFFSET INBUF+2
;;dcl;; MOV	BYTE PTR [SI-1],0	;Any digits?
	cmp	BYTE PTR [SI-1],0	;Any digits?			;AC000;
	JZ	GETSEG
DIGLP:
	LODSB
	SUB	AL,"0"
	JC	DIGERR
	CMP	AL,10
	JB	HAVDIG
	AND	AL,5FH			;Convert to upper case
	SUB	AL,7
	CMP	AL,10
	JB	DIGERR
	CMP	AL,10H
	JAE	DIGERR
HAVDIG:
	SHL	BX,1
	SHL	BX,1
	SHL	BX,1
	SHL	BX,1
	OR	BL,AL
	JMP	DIGLP

DIGERR:
	CMP	BYTE PTR [SI-1],0DH	;Is last char. a CR?
	JNZ	GETSEG
LOADEXE:
	XCHG	BX,BP			;BX has LOAD, BP has fixup

	MOV	CX,[SIZ]
	MOV	AH,read
	push	di
	mov	di,[handle1]
	PUSH	DS
	MOV	DS,BX
	ASSUME	DS:NOTHING						;AN000;
	XOR	DX,DX
	push	bx
	mov	bx,di
	INT	21H			;Read in up to 64K
	pop	bx
	POP	DS
	ASSUME	DS:DATA 						;AN000;
	pop	di
	Jnc	HAVEXE			;Did we get it all?

	jmp	DosError

LseekError2:
	jmp	DosError

HAVEXE:
	ASSUME	DS:DATA 						;AN000;
	CMP	[RELCNT],0		;Any fixups to do?
	JZ	STORE
	MOV	AX,[RELTAB]		;Get position of table

	push	dx
	push	cx
	push	ax
	push	bx
	mov	dx,ax
	xor	cx,cx
	mov	al,0
	mov	bx,[handle1]
	mov	ah,lseek
	int	21h
	jc	LseekError2
	pop	bx
	pop	ax
	pop	cx
	pop	dx

	MOV	DX,OFFSET RELPT 	;4-byte buffer for relocation address
RELOC:
	MOV	DX,OFFSET RELPT 	;4-byte buffer for relocation address
	MOV	CX,4
	MOV	AH,read
	push	bx
	mov	bx,[handle1]
	INT	21H			;Read in one relocation pointer
	pop	bx
	Jnc	RDCMP
	jmp	short DosError
RDCMP:
	MOV	DI,[RELPT]		;Get offset of relocation pointer
	MOV	AX,[RELSEG]		;Get segment
	ADD	AX,BX			;Bias segment with actual load segment
	MOV	ES,AX
	ASSUME	ES:NOTHING						;AN000;
	ADD	ES:[DI],BP		;Relocate
	DEC	[RELCNT]		;Count off
	JNZ	RELOC
STORE:
	MOV	AH,CREAT
	MOV	DX,OFFSET file2
	xor	cx,cx
	INT	21H
	Jc	MKERR
	mov	[handle2],ax
	MOV	CX,[SIZ]
	MOV	AH,write
	push	di
	mov	di,[handle2]
	PUSH	DS
	MOV	DS,BX
	ASSUME	DS:NOTHING						;AN000;
	XOR	DX,DX			;Address 0 in segment
	push	bx
	mov	bx,di
	INT	21H
	pop	bx
	POP	DS
	ASSUME	DS:DATA 						;AN000;
	pop	di
	Jc	WRTERR			;Must be zero if more to come
	cmp	AX,CX
	jnz	NOROOM
	MOV	AH,CLOSE
	push	bx
	mov	bx,[handle2]
	INT	21H
	jc	CloseError
	pop	bx
	pop	ds
	pop	ds
	ASSUME	DS:NOTHING						;AN000;

	RET

;*******************************************************************************

NOROOM: 				;				     ;AN000;
	ASSUME	DS:DATA 						;AN000;
	MOV	AH,CLOSE		; Close the file here		     ;AN000;
	push	bx			;				     ;AN000;
	mov	bx,[handle2]		;				     ;AN000;
	INT	21H			;				     ;AN000;
	jc	CloseError		; If error let extend messages get it;AN000;
	pop	bx			;				     ;AN000;
	mov	ah,UNLINK		; Delete the file because it did     ;AN000;
	MOV	DX,OFFSET file2 	; not get written correctly.	     ;AN000;
	INT	21H			;				     ;AN000;
	jc	CloseError		; If error let extend messages get it;AN000;
	pop	ds			;				     ;AN000;
	ASSUME	DS:NOTHING		;				     ;AN000;
	message msgNoDiskSpace		; Put out insufficient disk space    ;AN000;
	jmp	short getout		; message			     ;AN000;
	RET				; return to main_init		     ;AN000;

;*******************************************************************************

WRTERR: 								;AN000;
MKERR:									;AN000;
CloseError:								;AN000;

	public	DosError						;AN000;
DosError:								;AN000;
	mov	es:FileNameSegment,ds	   ; save for opens, creates,	;AN000;
	mov	es:FileNameOffset,dx					;AN000;

	mov	bx,0			; get the extended error code	;AN000;
	mov	ah,059h 						;AN000;
	int	21h							;AN000;

	mov	si,offset ds:Sublist_msg_exterror			;AC001;
	extend_message							;AN001;
	pop	ds							;AN001;

getout: 								;AN000;
	pop	ds							;AN000;
	ASSUME	DS:NOTHING						;AN000;

	ret								;AN000;


LOCATE	ENDP

;----- concatenate two strings
strcat	proc	near			;   while (*d)
	cmp	byte ptr [di],0
	jz	atend
	inc	di			;	d++;
	jmp	strcat
atend:					;   while (*d++ = *s++)
	lodsb
	stosb
	or	al,al			;	;
	jnz	atend
	ret
strcat	endp

;----- Find the first non-ignorable char, return carry if CR found
kill_bl proc	near
	cld
sj10:					;   while ( *p != 13 &&
	lodsb
	CMP	AL,13			;	    IsBlank (*p++))
	JZ	BreakOut
	CALL	IsBlank
	JZ	SJ10			;	;
BreakOut:
	dec	si			;   p--;
	cmp	al,0dh			;   return *p == 13;
	clc
	jne	sj11
	stc
sj11:
	ret
kill_bl endp

IsBlank proc	near
	cmp	al,00							;AN000;
	retz								;AN000;
	cmp	al,13
	retz
	cmp	al,' '			; space
	retz
	cmp	al,9			; tab
	retz
	cmp	al,','			; comma
	retz
	cmp	al,';'			; semicolon
	retz
	cmp	al,'+'			; plus
	retz
	cmp	al,10			; line feed
	retz
	cmp	al,'='			; equal sign
	return
IsBlank Endp


procedure copyfs near

	push	ax							;AN000;

;	$do				; while we have filespec	;AN000;
$$DO16:
	    lodsb			; move byte to al		;AN000;
	    cmp     al,0		; see if we are at		;AN000;
					; the end of the
					; filespec
;	$leave	e			; exit while loop		;AN000;
	JE $$EN16
	    stosb			; move byte to path_name	;AN000;
;	$enddo				; end do while			;AN000;
	JMP SHORT $$DO16
$$EN16:
	stosb								;AN000;
	pop	ax							;AN000;

	ret								;AN000;
copyfs	endp								;AN000;


procedure dbcs_check near

	push	ds				;Save registers 	;AC000;
	push	si				; "  "	  "  "		;AC000;
	push	ax				; "  "	  "  "		;AC000;
	push	ds				; "  "	  "  "		;AC000;
	pop	es				;Establish addressability;AC000;
	cmp	byte ptr es:DBCS_VECTOR,Yes	;Have we set this yet?	;AC000;
	push	ax				;Save input character	;AC000;
;	$IF	NE				;Nope			;AN000;
	JE $$IF19
	   mov	   al,0 			;Get DBCS environment vectors;AC000;
	   DOS_Call Hongeul			;  "  "    "  " 	;AC000;
	   mov	   byte ptr es:DBCS_VECTOR,YES	;Indicate we've got vector;AC000;
	   mov	   es:DBCS_Vector_Off,si	;Save the vector	;AC000;
	   mov	   ax,ds			;			;AC000;
	   mov	   es:DBCS_Vector_Seg,ax	;			;AC000;
;	$ENDIF					; for next time in	;AC000;
$$IF19:
	pop	ax				;Restore input character;AC000;
	mov	si,es:DBCS_Vector_Seg		;Get saved vector pointer;AC000;
	mov	ds,si				;			;AC000;
	mov	si,es:DBCS_Vector_Off		;			;AC000;
;	$SEARCH 				;Check all the vectors	;AC000;
$$DO21:
	   cmp	   word ptr ds:[si],End_Of_Vector ;End of vector table? ;AC000;
;	$LEAVE	E				;Yes, done		;AC000;
	JE $$EN21
	   cmp	   al,ds:[si]			;See if char is in vector;AC000;
;	$EXITIF AE,AND				;If >= to lower, and	;AC000;
	JNAE $$IF21
	   cmp	   al,ds:[si+1] 		; =< than higher range	;AC000;
;	$EXITIF BE				; then DBCS character	;AC000;
	JNBE $$IF21
	   stc					;Set CY to indicate DBCS;AC000;
;	$ORELSE 				;Not in range, check next;AC000;
	JMP SHORT $$SR21
$$IF21:
	   add	   si,DBCS_Vector_Size		;Get next DBCS vector	;AC000;
;	$ENDLOOP				;We didn't find DBCS chaR;AC000;
	JMP SHORT $$DO21
$$EN21:
	   clc					;Clear CY for exit	;AC000;
;	$ENDSRCH				;			;AC000;
$$SR21:
	pop	ax				;Restore registers	;AC000;
	pop	si				; "  "	  "  "		;AC000;
	pop	ds				;Restore data segment	;AC000;
	ret					;			;AC000;

	ret								;AN000;
dbcs_check  endp							;AN000;



CODE	ends


	end	main_init						;AC000;


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\e2bchng.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
.xlist
;
;
;*****************************************************************************
;*                                                                           *
;* Change list to EXE2BIN modules                                            *
;*                                                                           *
;* Lines are tagged ANxxx for new, ACxxx for changed                         *
;* --------------------------------------------------------------------------*
;*  000 - DOS 4.00 Spec additions and DCR's thru unit/function test          *
;*         Date: 12/31/87  Developer: Dennis M	                             *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  001 - DOS 4.00 PTM P3964 Pass invalid parameter to message retriever for *
;*         replacement in error message.                                     *
;*         Date: 03/24/88  Developer: Dennis M	                             *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*****************************************************************************
;* Note: This is file E2BCHNG.INC for updating purposes                      *
;*****************************************************************************
.list


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\e2bequ.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
                                                ;                               ;     ;

NO      equ     0
YES     equ     not NO


DOS_Found equ   0

INIT    equ     0


Net_Check equ   1200h
Assign_Check equ 8000h

Found_Yes equ   1
Found_No equ    0

Asciiz_End equ  0
;DBCS_Blank_hi    equ     81h
DBCS_Blank equ	DB_SP_LO
DBCS_Vector_Size equ 2
End_Of_Vector equ 0


Blank   equ     " "

Label_Length equ 11
CR      equ     13

DBCS_VECTOR equ NO

;-------------------------------------------------------------------------------





DRNUM   EQU     5CH



; Exit status defines
ExitOK  equ     0


;-------------------------------------------------------------------------------
; These are the data structures which we will need



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\display.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


CODE    SEGMENT PARA PUBLIC 'CODE'
CODE    ENDS
DATA    SEGMENT PARA PUBLIC 'DATA'
DATA    ENDS
STACK   SEGMENT PARA STACK  'STACK'
STACK   ENDS
ZLOAD   SEGMENT PARA PUBLIC 'ZLOAD'
ZLOAD   ENDS

CODE    SEGMENT PARA PUBLIC 'CODE'
        assume  cs:code,ds:data
;
;*****************************************************************************
; External Declarations
;*****************************************************************************
;

        extrn   SysDispMsg:near

;
;***************************************************************************
; Message Structures
;***************************************************************************
;


Message_Table struc                             ;                               ;AN000;
                                                ;
Entry1  dw      0                               ;                               ;AN000;
Entry2  dw      0                               ;                               ;AN000;
Entry3  dw      0                               ;                               ;AN000;
Entry4  dw      0                               ;                               ;AN000;
Entry5  db      0                               ;                               ;AN000;
Entry6  db      0                               ;                               ;AN000;
Entry7  dw      0                               ;                               ;AN000;
                                                ;
Message_Table ends                              ;                               ;AN000;



;*****************************************************************************
;Routine name&gml Display_Interface
;*****************************************************************************
;
;DescriptioN&gml Save all registers, set up registers required for SysDispMsg
;             routine. This information is contained in a message description
;             table pointed to by the DX register. Call SysDispMsg, then
;             restore registers. This routine assumes that the only time an
;             error will be returned is if an extended error message was
;             requested, so it will ignore error returns
;
;Called Procedures: Message (macro)
;
;Change History&gml Created        4/22/87         MT
;
;Input&gml ES&gmlDX = pointer to message description
;
;Output&gml None
;
;Psuedocode
;----------
;
;       Save all registers
;       Setup registers for SysDispMsg from Message Description Tables
;       CALL SysDispMsg
;       Restore registers
;       ret
;*****************************************************************************

Public  Display_Interface
Display_Interface   proc                        ;                               ;AN000;

        push    ds                              ;                               ;AN000;
        push    es                              ;                               ;AN000;
        push    ax                              ;Save registers                 ;AN000;
        push    bx                              ; "  "    "  "                  ;AN000;
        push    cx                              ; "  "    "  "                  ;AN000;
        push    dx                              ; "  "    "  "                  ;AN000;
        push    si                              ; "  "    "  "                  ;AN000;
        push    di                              ; "  "    "  "                  ;AN000;
        mov     di,dx                           ;Change pointer to table        ;AN000;
        mov     dx,SEG data                     ;Point to data segment
        mov     ds,dx                           ;
        mov     es,dx
        mov     ax,[di].Entry1                  ;Message number                 ;AN000;
        mov     bx,[di].Entry2                  ;Handle                         ;AN000;
        mov     si,[di].Entry3                  ;Sublist                        ;AN000;
        mov     cx,[di].Entry4                  ;Count                          ;AN000;
        mov     dh,[di].Entry5                  ;Class                          ;AN000;
        mov     dl,[di].Entry6                  ;Function                       ;AN000;
        mov     di,[di].Entry7                  ;Input                          ;AN000;
        call    SysDispMsg                      ;Display the message            ;AN000;
        pop     di                              ;Restore registers              ;AN000;
        pop     si                              ; "  "    "  "                  ;AN000;
        pop     dx                              ; "  "    "  "                  ;AN000;
        pop     cx                              ; "  "    "  "                  ;AN000;
        pop     bx                              ; "  "    "  "                  ;AN000;
        pop     ax                              ; "  "    "  "                  ;AN000;
        pop     es                              ;                               ;AN000;
        pop     ds                              ;                               ;AN000;
        ret                                     ;All done                       ;AN000;

Display_Interface      endp                     ;                               ;AN000;
code    ends


        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\e2bmacro.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */



;
;******************************************************************************
; Message Macro Definitions
;******************************************************************************
;

      EXTRN Display_Interface:near


;-----------------------------------------------------------------------------

MESSAGE macro   Message_Name                    ;                               ;AN000;
                                                ;
        mov     dx,offset Message_Name          ;                               ;AN000;
        call    Display_Interface               ;                               ;AN000;
                                                ;
        endm                                    ;                               ;AN000;


;
;*****************************************************************************
; General Macro's
;*****************************************************************************
;

Procedure       macro   Proc_Name

Public  Proc_Name
Proc_Name    proc

        endm
;-----------------------------------------------------------------------------

DOS_Call        macro   Function

        mov     ah,Function
        int     21h

        endm
;-----------------------------------------------------------------------------

Parse_Message macro                                                             ;AN000;


        push    ds                                                              ;AN000;
        mov     dx,SEG parse_ptr                                                ;AN000;
        mov     ds,dx                                                           ;AN000;
        ASSUME  DS:DATA                                                         ;AN000;
        ASSUME  ES:DATA                                                         ;AN000;
        mov     word ptr Parse_Error_Msg,ax                                     ;AN000;
        mov     dx,offset Parse_Error_Msg       ;                               ;AN000;
        call    Display_Interface               ;                               ;AN000;
        pop     ds
        endm                                    ;                               ;AN000;

;-----------------------------------------------------------------------------

Extend_Message macro                            ;                               ;AN001;

                                                ;
        push    ds                                                              ;AN001;
        mov     dx,SEG parse_ptr                                                ;AN001;
        mov     ds,dx                                                           ;AN001;
        ASSUME  DS:DATA                                                         ;AN001;
        ASSUME  ES:DATA                                                         ;AN001;
        mov     word ptr Extend_Error_Msg,ax     ;                              ;AN001;
        mov     dx,offset Extend_Error_Msg       ;                              ;AN001;
        call    Display_Interface               ;                               ;AN001;
        pop     ds                                                              ;AN001;
        endm                                    ;                               ;AN001;

;-----------------------------------------------------------------------------

; macros to declare messages

addr macro sym,name
    public name
    ifidn <name>,<>
	dw offset sym
    else
    public name
name    dw  offset sym
    endif
endm


defmsg	macro	sym, name, str1, str2, str3, str4, str5
	sym	db	str1
	ifnb	<str2>
		db	str2
	endif
	ifnb	<str3>
		db	str3
	endif
	ifnb	<str4>
		db	str4
	endif
	ifnb	<str5>
		db	str5
	endif
	ifnb	<name>
	addr	sym, name
	endif
endm

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\e2bparse.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
data    segment public 'DATA'



;
;***************************************************************************
; Equates
;***************************************************************************
;

;Match Flags

Numeric_Value           equ     8000h           ;                               ;AN000;
Signed_Numeric_Value    equ     4000h           ;                               ;AN000;
Simple_String           equ     2000h           ;                               ;AN000;
Date_String             equ     1000h           ;                               ;AN000;
Time_String             equ     0800h           ;                               ;AN000;
Complex_List            equ     0400h           ;                               ;AN000;
Filespec                equ     0200h           ;                               ;AN000;
Drive_Only              equ     0100h           ;                               ;AN000;
Quoted_String           equ     0080h           ;                               ;AN000;
Ignore_Colon            equ     0010h           ;                               ;AN000;
Repeats_Allowed         equ     0002h           ;                               ;AN000;
Optional                equ     0001h           ;                               ;AN000;

;Function_Flags

File_Table_Capitalize   equ     1               ;                               ;AN000;

;Result buffer type returned
rb_Number               equ     1
rb_List_Index           equ     2
rb_String               equ     3
rb_Complex              equ     4
rb_Filespec             equ     5
rb_Drive                equ     6
rb_Date                 equ     7
rb_Time                 equ     8
rb_Quoted_String        equ     9


;Extra delimeters and EOL

Delimiters_Only         equ     1               ;                               ;AN000;
EOL_Or_Delimiters       equ     2               ;                               ;AN000;

Semi_Colon              equ     ";"             ;                               ;AN000;
Tab                     equ     09h             ;                               ;AN000;
Colon1                  equ     ":"             ;                               ;AN000;
NUL                     equ     "0"

;Parse Errors

No_Error                equ     0               ;                               ;AN000;
Too_Many_Operands       equ     1               ;                               ;AN000;
Operand_Missing         equ     2               ;                               ;AN000;
Not_In_Switch_List      equ     3               ;                               ;AN000;
Not_In_Keyword_List     equ     4               ;                               ;AN000;
Out_Of_Range            equ     6               ;                               ;AN000;
Not_In_Value_List       equ     7               ;                               ;AN000;
Not_In_String_List      equ     8               ;                               ;AN000;
Syntax_Error            equ     9               ;                               ;AN000;
End_Of_Parse            equ     -1              ;                               ;AN000;

;Other

None                    equ     0               ;                               ;AN000;
No_Error                equ     0               ;                               ;AN000;
Switch_Found            equ     0FFFFh          ;                               ;AN000;
Range_Ok                equ     1               ;                               ;AN000;
Command_Line_Parms      equ     81h             ;                               ;AN000;

;
;*****************************************************************************
; Parse Structures
;*****************************************************************************
;

Control          struc

Match_Flags     dw      ?
Function_Flags  dw      ?
Result          dw      ?
Values          dw      ?
Num_Keywords    db      ?
Keyword         db      ?

Control         ends

File_Name_Return        struc                   ;                               ;AN000;

Drive_Type      db      0                       ;                               ;AN000;
Drive_Item_Tag  db      0                       ;                               ;AN000;
Synonym         dw      0                       ;                               ;AN000;
String_Value_ptr db     0                       ;File Name                      ;AN000;

File_Name_Return     ends                       ;                               ;AN000;


;
;**************************************************************************
; Parse tables
;**************************************************************************
;

Command_Line_Table label byte                      ;                               ;AN000;

        dw      Command_Control                 ;Point to next level            ;AN000;
        db      Delimiters_Only                 ;                               ;AN000;
        db      1                               ;                               ;AN000;
        db      Semi_Colon                      ;                               ;AN000;


;
;**************************************************************************
; Define Positionals, Switches and Keywords
;**************************************************************************
;

Command_Control label byte                      ;                               ;AN000;

        db      1,2                             ;File names Positional (1 required) ;AN000;
        dw      Positional_Control1             ;Pointer to control table       ;AN000;
        dw      Positional_Control2             ;Pointer to control table       ;AN000;
        db      1                               ; 1 switch
	dw	Switch_Control1			; Pointer to control table
        db      None                            ;No Keywords (maxk)             ;AN000;

;
;**************************************************************************
;Control Tables
;**************************************************************************
;

Positional_Control1 label byte                  ;                               ;AN000;

        dw      Filespec                        ;Match_Flag                     ;AN000;
        dw      File_Table_Capitalize           ;No function flags              ;AN000;
        dw      File_Name_Buffer1               ;Where it will be returned      ;AN000;
        dw      No_Value                        ;No value ranges defined        ;AN000;
        db      None                            ;No defined switches/keywords   ;AN000;

Positional_Control2 label byte                  ;                               ;AN000;

        dw      Filespec+Optional               ;Match_Flag                     ;AN000;

        dw      File_Table_Capitalize           ;No function flags              ;AN000;
        dw      File_Name_Buffer2               ;Where it will be returned      ;AN000;
        dw      No_Value                        ;No value ranges defined        ;AN000;
        db      None                            ;No defined switches/keywords   ;AN000;

Switch_Control1	label byte			; used by /?

	dw	0				; Match Mask
	dw	0				; Func Mask
	dw	Switch_Buffer1			; ptr to Results
	dw	No_Value			; ptr to Value
	db	1				; # of synonyms
sw1_s1	db	"/?",0				; 1st synonym

No_Value        label   byte                    ;                               ;AN000;
        db      0                               ;                               ;AN000;

;
;************************************************************************
; PARSE Return Buffers
;************************************************************************
;
File_name_Buffer1   label  byte                 ;                               ;AN000;

rb_type1       db      0                        ;type returned                  ;AN000;
rb_item_tag1   db      0                        ;matched item tag               ;AN000;
rb_synonym1    dw      0                        ;found synonyms                 ;AN000;
rb_string1_off dw      0                        ;Offset of string               ;AN000;
rb_string1_seg dw      0                        ;Offset of string               ;AN000;

File_name_Buffer2   label  byte                 ;                               ;AN000;

rb_type2       db      0                        ;type returned                  ;AN000;
rb_item_tag2   db      0                        ;matched item tag               ;AN000;
rb_synonym2    dw      0                        ;found synonyms                 ;AN000;
rb_string2_off dw      0                        ;Offset of string               ;AN000;
rb_string2_seg dw      0                        ;Offset of string               ;AN000;

Switch_Buffer1	label byte			; used by /?

sw_type1	db	0			; type returned
sw_tag1		db	0			; matched item tag
sw_synonym1	dw	0			; found synonym
sw_padding1	dd	0			; pad it out

data    ends


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\e2btable.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
data    segment

;
;*****************************************************************************
; Macro's
;*****************************************************************************
;


Define_Msg macro Message_Name                   ;                               ;AN000;
                                                ;
Create_Msg Message_Name,Message_Number,Handle,Sublist,Count,Class,Function,Input;AN000;
                                                ;
        endm                                    ;                               ;AN000;

;-----------------------------------------------------------------------------

Create_Msg macro Parm1,Parm2,Parm3,Parm4,Parm5,Parm6,Parm7,Parm8;               ;AN000;

Parm1   label   word                            ;                               ;AN000;
        dw      Parm2                           ;                               ;AN000;
        dw      Parm3                           ;                               ;AN000;
        dw      Parm4                           ;                               ;AN000;
        dw      Parm5                           ;                               ;AN000;
        db      Parm6                           ;                               ;AN000;
        db      Parm7                           ;                               ;AN000;
        dw      Parm8                           ;                               ;AN000;
        endm                                    ;                               ;AN000;


;---------------------------                    ;                               ;AN001;
Sublist_msg_parserr     label   dword           ;                               ;AN001;
                                                                                ;AN001;
        db              Sublist_Length          ;11                             ;AN001;
        db              Reserved                ;0                              ;AN001;
parsoff dw              ?                       ;off                            ;AN001;
parseg  dw              ?                       ;                               ;AN001;
        db              0                       ;USE PERCENT ZERO               ;AN001;
        db              Left_Align+Char_Field_ASCIIZ ;type of data              ;AN001;
        db              128                     ;max width                      ;AN001;
        db              1                       ;min width                      ;AN001;
        db              Blank                   ;pad char                       ;AN001;
;---------------------------                    ;                               ;AN001;

Sublist_msg_exterror label word                                                 ;AN001;

        db              Sublist_Length                                          ;AN001;
        db              Reserved                                                ;AN001;
FileNamePointer         label dword                                             ;AN001;
FileNameOffset  dw      ?                                                       ;AN001;
FileNameSegment dw      ?                                                       ;AN001;
        db              0                              ; SPECIAL %0 - Extended Errors only ;AN001;
        db              Left_Align+Char_Field_ASCIIZ                            ;AN001;
        db              132                                                     ;AN001;
        db              0                                                       ;AN001;
        db              Blank                                                   ;AN001;
;-----------------------------------------------------------------------------
;
;*****************************************************************************
; Message Retriever equates
;*****************************************************************************
;

Format_Msg              equ     'C'

N_A                     equ     0

Blank                   equ     " "
No_Function             equ     0

No_Input                equ     0


;
;*****************************************************************************
; Message Description Tables
;*****************************************************************************
;

MSG_OPTIONS_FIRST	equ	300
MSG_OPTIONS_LAST        equ     303

;----------------------                         ;
Message_Number  = 1                             ;                               ;AN000;
Handle          = No_Handle                     ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgBadDOSVersion        ;                               ;AN000;
;----------------------                         ;
Message_Number  = 2                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgOutOfMemory          ;                               ;AN000;
;----------------------                         ;
Message_Number  = 3                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgLoadFailure          ;                               ;AN000;
;----------------------                         ;
Message_Number  = 4                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgNoAccess             ;                               ;AN000;
;----------------------                         ;
Message_Number  = 5                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgNoConvert            ;                               ;AN000;
;----------------------                         ;
Message_Number  = 6                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgNoFile               ;                               ;AN000;
;----------------------                         ;
Message_Number  = 7                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgFileCreateError      ;                               ;AN000;
;----------------------                         ;
Message_Number  = 8                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = DOS_BUF_KEYB_INP              ;                               ;AN000;
Input           = INBUF                         ;                               ;AN000;
        Define_Msg      msgFixUp                ;                               ;AN000;
;----------------------                         ;
Message_Number  = 0                             ;                               ;AN001;
Handle          = STDERR                        ;                               ;AN001;
Sublist         = ds:sublist_msg_parserr        ;                               ;AN001;
Count           = 1                             ;                               ;AN001;
Class           = Parse_Err_Class               ;                               ;AN001;
Function        = No_Input                      ;                               ;AN001;
Input           = N_A                           ;                               ;AN001;
        Define_Msg      parse_error_msg         ;                               ;AN001;
;----------------------                         ;
Message_Number  = 0                             ;                               ;AN001;
Handle          = STDERR                        ;                               ;AN001;
Sublist         = ds:sublist_msg_exterror       ;                               ;AN001;
Count           = 1                             ;                               ;AN001;
Class           = ext_Err_Class                 ;                               ;AN001;
Function        = No_Input                      ;                               ;AN001;
Input           = N_A                           ;                               ;AN001;
        Define_Msg      extend_error_msg        ;                               ;AN001;
;----------------------                         ;
Message_Number  = 10                            ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgNoDiskSpace          ;                               ;AN000;
;----------------------                         ;
Message_Number  = 12                            ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgNoFileName           ;                               ;AN000;
;----------------------                         ;
Message_Number  = MSG_OPTIONS_FIRST             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgOptions              ;                               ;AN000;
;----------------------                         ;

data ends

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\exe2bin\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\fastopen\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\fastopen\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\fastopen\fastopen.asm ===
; fastopen.asm
;
; Copyright (c) 1991, Microsoft Corporation
;
; History:
;   13-Apr-1992 Sudeep Bharati (sudeepb)
;   Created.
;
;   On NT this utility is just a stub which does nothing.
;

code	segment byte public 'CODE'
	assume	cs:code, ds:code, es:code

	org	100h
public	start
start:
	mov	ah,4ch
	xor	al,al
	int	21h
	ret

code	ends
	end	start
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\grctrl.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:   I  fixed  a  MS bug.  MS did  not  initialize  the  variable 
;**                 ROTATE_SW.  Consequently, if you do a non-rotate after doing 
;**                 a  rotate,  the picture would be printed  incorrectly  as  a 
;**                 rotated picture.  Note this bug was in Q.01.01 and fixed for 
;**                 Q.01.02.
;**  
;**  NOTES:    The   following  bug  was  fixed  for  the  pre-release   version 
;**            Q.01.02.
;**  
;**  BUG (mda004)
;**  ------------
;**  
;**  NAME:     After  GRAPHICS prints a rotated  picture  it will print pictures 
;**            which are not supposed to be rotated as rotated junk.
;**  
;**  FILES AFFECTED:     GRCTRL.ASM
;**  
;**  CAUSE:    MicroSoft  was  failing to initialize the variable  ROTATE_SW  to 
;**            OFF.  Consequently, if you printed a picture whose  corresponding 
;**            printbox did NOT specify a rotate after printing a picture  whose 
;**            corresponding  printbox did specify a rotate, the  picture  would 
;**            print as rotated junk.
;**  
;**  FIX:      Initialize the variable ROTATE_SW  to OFF right before going into 
;**            the print procedure Print_Color or Print_BW_APA.
;**  
;**  DOCUMENTATION NOTES:  This version of GRCTRL.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE	,132								
										
	TITLE	DOS GRAPHICS Command  -	Print screen Control module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;; DOS - GRAPHICS Command
;;                                 
;;										
;; File Name:  GRCTRL.ASM							
;; ----------									
;;										
;; Description: 								
;; ------------ 								
;;	 This file contains the code for the Print Screen control module.	
;;										
;; Documentation Reference:							
;; ------------------------							
;;	 OASIS High Level Design						
;;	 OASIS GRAPHICS I1 Overview						
;;										
;; Procedures Contained in This File:						
;; ----------------------------------						
;;	PRT_SCR 								
;;	  DET_HW_CONFIG 							
;;	  DET_MODE_STATE							
;;	  GET_MODE_ATTR 							
;;	  SET_UP_XLT_TAB							
;;	    SET_CGA_XLT_TAB							
;;	      CGA_COL2RGB							
;;	      RGB2XLT_TAB							
;;	    SET_EGA_XLT_TAB							
;;	      EGA_COL2RGB							
;;	    SET_MODE_F_XLT_TAB							
;;	    SET_MODE_13H_XLT_TAB						
;;	    SET_ROUNDUP_XLT_TAB 						
;;	 SET_BACKG_IN_XLT_TAB							
;;	 RGB2BAND								
;;	 RGB2INT								
;;										
;;										
;; Include Files Required:							
;; -----------------------							
;;	 GRINST.EXT - Externals for GRINST.ASM					
;;										
;;										
;; External Procedure References:						
;; ------------------------------						
;;	 FROM FILE  GRINST.ASM: 						
;;	      GRAPHICS_INSTALL - Main module for installation.			
;;										
;; Linkage Instructions:							
;; -------------------- 							
;;	 Refer to GRAPHICS.ASM							
;;										
;; Change History:								
;; ---------------								
;;  M001	NSM	1/30/91		New var to store the old int 10 handler
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
CODE	SEGMENT PUBLIC 'CODE'                                                   
	ASSUME		CS:CODE,DS:CODE 					
										
.XLIST										
INCLUDE GRINT2FH.EXT								
INCLUDE GRBWPRT.EXT								
INCLUDE GRCOLPRT.EXT								
INCLUDE GRSHAR.STR								
INCLUDE GRPATTRN.STR								
INCLUDE GRPATTRN.EXT								
INCLUDE STRUC.INC								
.LIST										
PRT_SCR PROC NEAR								
	JMP PRT_SCR_BEGIN							
PAGE										
;===============================================================================
;										
; GRAPHICS INTERRUPT DRIVER'S DATA:                                             
;										
;===============================================================================
.xlist										
PUBLIC PRT_SCR,ERROR_CODE,XLT_TAB,MODE_TYPE					
PUBLIC CUR_MODE_PTR,CUR_MODE,NB_COLORS,SCREEN_HEIGHT,SCREEN_WIDTH		
PUBLIC CUR_PAGE,CUR_COLUMN,CUR_ROW,NB_SCAN_LINES,SCAN_LINE_MAX_LENGTH		
PUBLIC CUR_SCAN_LNE_LENGTH							
PUBLIC PRT_BUF,NB_BOXES_PER_PRT_BUF,CUR_BOX,BOX_H,BOX_W 			
PUBLIC PRINT_SCREEN_ALLOWED,RGB 						
PUBLIC BIOS_INT_5H								
PUBLIC OLD_INT_10H			; /* M001 */
PUBLIC ROTATE_SW								
PUBLIC DET_HW_CONFIG								
PUBLIC NB_CHAR_COLUMNS								
PUBLIC RGB2INT									
PUBLIC RGB2BAND 								
.list										
INCLUDE GRCTRL.STR								
;-------------------------------------------------------------------------------
;										
; ENTRY POINT TO BIOS HARDWARE INTERRUPT 5 HANDLER				
;										
;-------------------------------------------------------------------------------
BIOS_INT_5H	DW	?		; Pointer to BIOS int 5h		
		DW	?							
										
;/* M001 BEGIN */ --------------------------------------------------------------
;										
; ENTRY POINT TO BIOS HARDWARE INTERRUPT 10 HANDLER				
;										
;-------------------------------------------------------------------------------
OLD_INT_10H	DW	?		; Pointer to BIOS int 10h		
		DW	?							
; /* M001 END */ 
;-------------------------------------------------------------------------------
;										
; PRINT SCREEN ERROR CODE (Used at print screen time, see GRCTRL.STR for	
;			   error codes allowed) 				
;										
;-------------------------------------------------------------------------------
ERROR_CODE	DB	0		; ERROR CODE 0 = NO ERROR		
										
;-------------------------------------------------------------------------------
;										
; SCREEN PIXEL: INTERNAL REPRESENTATION 					
;										
;-------------------------------------------------------------------------------
RGB	PIXEL_STR < , , >	  ; PIXEL := RED, GREEN, BLUE Values		
										
;-------------------------------------------------------------------------------
;										
; COLOR TRANSLATION TABLE:							
;										
; This table is used to translate the color numbers returned by 		
; Interrupt 10H Read Dot and Read Character calls into print			
; information.	The table consists of 256 entries, one byte each,		
; indexed by color number.							
; In the case of black and white printing, the table				
; entries are grey scale intensities from 0 to 63.  In the case 		
; of color printing each table entry contains a "band mask" indicating          
; which color print bands are required to generate the required color.		
; The band masks are simply bit masks where each bit corresponds to one 	
; of the printer bands. 							
;										
; The table is set up at the beginning of the print screen processing,		
; before any data is read from the screen.  From then on, translating		
; from screen information into print information is done quickly by		
; accessing this table.  Not all 256 entries are initialized for each		
; screen print.  The number of entries used is equal to the number		
; of colors available concurrently with the given display mode. 		
;-------------------------------------------------------------------------------
XLT_TAB DB	  256 DUP(32)  ; COLOR TRANSLATION TABLE			
			       ; This table is used to translate the Color Dot	
			       ; or Byte Attribute to a Band Mask for color	
			       ; printing or to a Grey Intensity for Mono-	
			       ; chrome printing.				
										
;-------------------------------------------------------------------------------
;										
; CURRENT VIDEO MODE ATTRIBUTES 						
;										
;-------------------------------------------------------------------------------
MODE_TYPE	DB	?	; Mode types (bit mask) APA or TXT		
										
CUR_MODE_PTR	DW	?	; DISPLAYMODE INFO RECORD for the current	
				;   mode (defined in the shared data area).	
CUR_MODE	DB	?	; Current video mode number			
NB_COLORS	DW	?	; Number of colors supported by this mode	
SCREEN_HEIGHT	DW	?	; Number of rows on the screen (chars or pixels)
SCREEN_WIDTH	DW	?	; Number of columns on the screen (chars/pixels)
				;  (for text modes is equal to NB_CHAR_COLUMNS) 
NB_CHAR_COLUMNS DB	?	; Number of columns on the screen if in txt mode
CUR_PAGE	DB	?	; Active page number				
ROTATE_SW	DB	?	; Switch: if "ON" then, must print sideways     
										
;-------------------------------------------------------------------------------
;										
; ACTIVE SCREEN ATTRIBUTES							
;										
;-------------------------------------------------------------------------------
CUR_COLUMN	DW	?	; Current pixel/char column number		
CUR_ROW 	DW	?	; Current pixel/char row number 		
NB_SCAN_LINES	DW	?	; Number of screen scan lines			
SCAN_LINE_MAX_LENGTH DW ?	; Maximum number of dots/chars per scan line	
CUR_SCAN_LNE_LENGTH DW	?	; Length in pels/chars of the current scan line 
										
;-------------------------------------------------------------------------------
;										
; PRINTER VARIABLES								
;										
;-------------------------------------------------------------------------------
PRT_BUF DB	?,?,?,? 	; PRINT BUFFER					
NB_BOXES_PER_PRT_BUF DB ?	; Number of boxes fitting in the print buffer	
CUR_BOX DB	?,?,?,? 	; BOX = PRINTER REPRESENTATION OF 1 PIXEL	
BOX_H	DB	?		; HEIGHT OF THE BOX				
BOX_W	DB	?		; WIDTH OF THE BOX				
										
;-------------------------------------------------------------------------------
;										
; CONTROL VARIABLES:								
;										
; This data is used to communicate between the Installation Modules		
; and the Resident Print Screen Modules.					
;-------------------------------------------------------------------------------
PRINT_SCREEN_ALLOWED	DB   YES; Used to avoid print screens			
				;  while the GRAPHICS installation		
				;   (or re-install) is in progress		
				; Set by GRAPHICS_INSTALL module.		
										
										
PAGE										
;===============================================================================
;										
; INTERRUPT 5 DRIVER'S CODE:                                                    
;										
;-------------------------------------------------------------------------------
;===============================================================================
;										
; PRT_SCR : PRINT THE ACTIVE SCREEN						
;										
;-------------------------------------------------------------------------------
;										
;	INPUT: SHARED_DATA_AREA_PTR = Offset of the data area used for		
;				      passing data between the			
;				      Installation process and the Print	
;				      Screen process.				
;	      PRINT_SCREEN_ALLOWED  = Switch. Set to "No" if currently          
;				      installing GRAPHICS.COM			
;										
;				NOTE: These 2 variables are declared within	
;				      PRT_SCR but initialized by the		
;				      Installation process GRAPHICS_INIT	
;	OUTPUT: PRINTER 							
;										
;	CALLED BY: INTERRUPT 5							
;										
;										
;-------------------------------------------------------------------------------
;										
; DESCRIPTION:									
;										
; PRINT THE ACTIVE SCREEN for all TEXT and  All Points Addressable (APA)	
; display modes  available  with  either  a MONO, CGA, EGA, or VGA video	
; adapter on a Black and White or Color printer.				
;										
; INITIALIZATION:								
;										
; Each pixel  or  character  on the screen has a color attribute.  These	
; colors must be translated into different internal representations:		
;										
;	For printing in colors, each color is translated to a BAND MASK.	
;	The Band Mask indicates how to obtain this color on the printer.	
;										
;	For printing  in  Black and White, each color is translated to a	
;	GREY INTENSITY number between 0 (black) and 63 (white). 		
;										
; The  BAND  MASK  or  the  GREY INTENSITIES  are  found  in  the  COLOR	
; TRANSLATION TABLE.  This  table is initialized  before  calling any of	
; the print screen modules.							
;										
; PRINT SCREEN TIME:								
;										
; When a pixel or character  is read  off the screen by one of the print	
; screen modules, its  color is  used as  an index  into the translation	
; table.									
;										
;										
; LOGIC:									
;										
; IF SCREEN_PRINTS_ALLOWED=NO	; Block print screens until Installation	
;   THEN IRET			;  Process (or re-install!) is finished.	
; ELSE										
;										
;   CALL DET_HW_CONFIG		  ; Determine hardware configuration		
;   CALL DET_MODE_STATE 	  ; Determine video mode and active page	
;   CALL GET_MODE_ATTR		  ; Get video attributes (TXT or APA, etc)	
;										
;  IF MODE_TYPE = TXT AND Number of colors = 0					
;    THEN Invoke BIOS INTERRUPT 5						
;  ELSE 									
;    IF PRINTER_TYPE = BLACK_WHITE						
;      THEN									
;      IF MODE_TYPE = TXT							
;	 THEN Invoke BIOS INTERRUPT 5						
;      ELSE ; Mode is APA							
;	 CALL SET_UP_XLT_TAB	 ; Set up the color translation table		
;	 CALL PRINT_BW_APA	 ; Print the active screen on a B&W printer	
;    ELSE ; Color printer attached						
;      CALL SET_UP_XLT_TAB	 ; Set up the color translation table		
;      CALL PRINT_COLOR 	 ; Print the active screen on a Color prt.	
;    IRET									
;										
PRT_SCR_BEGIN:									
  PUSH	  AX		  ; Save Registers					
  PUSH	  BX		  ;							
  PUSH	  CX		  ;							
  PUSH	  DX		  ;							
  PUSH	  SI		  ;							
  PUSH	  DI		  ;							
  PUSH	  BP		  ;							
  PUSH	  DS		  ;							
  PUSH	  ES		  ;							
			  ;							
  CLD			  ; Clear direction flag				
  PUSH	  CS		  ; DS := CS						
  POP	  DS									
										
;-------------------------------------------------------------------------------
; Verify if we are allowed to print (not allowed if currently installing	
; GRAPHICS or printing a screen):						
;-------------------------------------------------------------------------------
  CMP	  PRINT_SCREEN_ALLOWED,NO	  ; IF not allowed to print		
  JE	  PRT_SCR_RETURN		  ; THEN quit				
					  ; ELSE print the screen:		
;-------------------------------------------------------------------------------
; INITIALIZATION:								
;-------------------------------------------------------------------------------
PRT_SCR_INIT:				  ; Disable print screen while		
  MOV	  PRINT_SCREEN_ALLOWED,NO	  ;  we are printing the current	
					  ;   screen.				
  MOV	  BP,SHARED_DATA_AREA_PTR	  ; BP := Offset Shared Data Area	
  MOV	  ERROR_CODE,NO_ERROR		  ; No error so far.			
  CALL	  DET_HW_CONFIG   ; Determine the type of display adapter		
  CALL	  DET_MODE_STATE  ; Init CUR_PAGE, CUR_MODE				
  CALL	  GET_MODE_ATTR   ; Determine if APA or TXT, nb. of colors,		
			  ;  and screen dimensions in pels or characters.	
 ;										
 ; Test the error code returned by GET_MODE_ATTR:				
 ;										
  TEST	  ERROR_CODE,MODE_NOT_SUPPORTED    ;If mode not supported then, 	
  JNZ	  DO_BEEP			   ; let BIOS give it a try.		
										
 ;------------------------------------------------------------------------------
 ; Check the printer type:							
 ;------------------------------------------------------------------------------
 .IF <DS:[BP].PRINTER_TYPE EQ BLACK_WHITE> ; Is a black and white printer	
 .THEN					   ;  attached ?			
 ;------------------------------------------------------------------------------
 ; A Black and White printer is attached					
 ;------------------------------------------------------------------------------
   CMP	   MODE_TYPE,TXT	   ; Is the screen in text mode ?		
   JNE	   INVOKE_PRINT_ROUTINE    ; No, call GRAPHICS B&W routine		
   JMP	   SHORT EXIT_TO_BIOS	   ; Yes, give control to BIOS INTERRUPT 5	
 .ELSE										
 ;------------------------------------------------------------------------------
 ; A Color printer is attached							
 ;------------------------------------------------------------------------------
   CMP	   NB_COLORS,0		   ; Is the screen in a Monochrome		
   JNE	   INVOKE_PRINT_ROUTINE 						
   TEST    MODE_TYPE,TXT	   ;   text mode ?				
   JNZ	   INVOKE_PRINT_ROUTINE 						
   JMP	   SHORT EXIT_TO_BIOS	   ; Yes, let BIOS INTERRUPT 5 handle it	
				   ; No, we handle it.				
.ENDIF				   ; ENDIF black and white or color printer	
;-------------------------------------------------------------------------------
;										
; Call the print routine (which is either PRINT_COLOR or PRINT_BW_APA)		
;										
;-------------------------------------------------------------------------------
INVOKE_PRINT_ROUTINE:								
   CALL    SET_UP_XLT_TAB	   ; Set up the color translation table 	
; \/ ~~mda(004) ----------------------------------------------------------------
;               The following fixes a MS bug.  MS was failing to initialize
;               the variable ROTATE_SW to off.  Consequently, if you printed a
;               picture whose corresponding printbox did NOT specify a rotate
;               after printing a picture whose corresponding printbox did 
;               specify a rotate, the picture would print rotated.
   MOV     ROTATE_SW,OFF           ; Set printing to standard unless otherwise
                                   ; set to rotate via PRINT_OPTIONS.
; /\ ~~mda(004) ----------------------------------------------------------------
   CALL    PRINT_MODULE_START	   ; Call the print modules that were		
				   ;  made resident at Install time.		
   MOV	   PRINT_SCREEN_ALLOWED,YES; Enable PrtScr for next calls		
  ;-----------------------------------------------------------------------------
  ; Test the error code returned by either PRINT_COLOR or PRT_BW_APA		
  ;-----------------------------------------------------------------------------
   TEST    ERROR_CODE,UNABLE_TO_PRINT ; If unable to print the screen		
   JNZ	   SHORT EXIT_TO_BIOS	      ; then, let BIOS give it a try		
										
PRT_SCR_RETURN: 								
				   ; Restore registers				
  POP	  ES			   ;						
  POP	  DS			   ;						
  POP	  BP			   ;						
  POP	  DI			   ;						
  POP	  SI			   ;						
  POP	  DX			   ;						
  POP	  CX			   ;						
  POP	  BX			   ;						
  POP	  AX			   ;						
				   ;						
  IRET				   ; Return control to interrupted		
				   ;  process					

; give a beep for modes not supported by graphics

DO_BEEP:
  mov	ah,2			   ; console output
  mov	dx,7			   ; ^G - beep  for modes not supported
  int	21h			

EXIT_TO_BIOS:									
				   ; Restore registers				
  POP	  ES			   ;						
  POP	  DS			   ;						
  POP	  BP			   ;						
  POP	  DI			   ;						
  POP	  SI			   ;						
  POP	  DX			   ;						
  POP	  CX			   ;						
  POP	  BX			   ;						
  POP	  AX			   ;						
  CLI				   ; Disable interrupts 			
  MOV	  CS:PRINT_SCREEN_ALLOWED,YES ; Enable PrtScr for next calls		
  JMP	  DWORD PTR CS:BIOS_INT_5H ; Exit to BIOS INTERRUPT 5			
										
PRT_SCR ENDP									
										
										
;===============================================================================
;										
; PRT_SCR MODULES:								
;										
;-------------------------------------------------------------------------------
PAGE										
;===============================================================================
;										
; DET_HW_CONFIG : DETERMINE WHAT TYPE OF VIDEO HARDWARE IS PRESENT		
;										
;-------------------------------------------------------------------------------
;										
;	INPUT:	   BP		   = Offset of the shared data area		
;										
;	OUTPUT:    HARDWARE_CONFIG is updated in the shared data area		
;										
;	CALLED BY: PRT_SCR							
;										
;	EXTERNAL CALLS: BIOS INT 10H						
;										
;-------------------------------------------------------------------------------
;										
; LOGIC:									
;    Issue BIOS INT10H Get Display Configuration Code (AX=1A00H)		
;    IF AL = 1AH THEN	 /* VGA (PS/2 OR BRECON-B)	  */			
;	/* BL = active DCC				  */			
;	/* BH = alternate DCC				  */			
;	/* Display Code:				  */			
;	/*   1 - Mono Adapter				  */			
;	/*   2 - CGA					  */			
;	/*   4 - EGA with Mono Display			  */			
;	/*   5 - EGA with Color Display 		  */			
;	/*   7 - PS/2 Mod 50,60,80 OR BRECON-B with Mono Display */		
;	/*   8 - PS/2 Mod 50,60,80 OR BRECON-B with Color Display */		
;	/*   B - PS/2 Mod 30 with Mono Display		  */			
;	/*   C - PS/2 Mod 30 with Color Display 	  */			
;    IF AL = 1AH THEN	 /* Call is supported */				
;	Set HARDWARE_CONFIG byte based on DCC returned in DL			
;    ELSE									
;	Issue INT 10H EGA Info (AH=12H BL=10H)					
;	IF BL <> 10H  THEN     /* EGA  */					
;	   Set EGA bit in HARDWARE_CONFIG					
;	ELSE		  /* CGA or */						
;	  Issue INT 10H PC CONVERTIBLE Physical display description param.	
;	  request. (AH=15H)							
;	  IF ES:[DI] = 5140H							
;	  THEN									
;	   Set PC_CONVERTIBLE bit in HARDWARE_CONFIG				
;	  ELSE									
;	   Set OLD_ADAPTER bit in HARDWARE_CONFIG				
;	  ENDIF 								
;	ENDIF									
;    ENDIF									
;    RETURN									
;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
DET_HW_CONFIG PROC NEAR 							
										
;-------------------------------------------------------------------------------
;										
; Try to read display combination code (PS/2 call):				
;										
;-------------------------------------------------------------------------------
	MOV	AX,READ_CONFIG_CALL						
	INT	10H			; Call video BIOS			
										
       .IF <AL EQ 1AH>			; If call is supported			
       .THEN									
;-------------------------------------------------------------------------------
;										
; Call is supported, PS/2 BIOS is present (Model 39,50,60,80 or BRECON-B card), 
; Determine what is the primary video adapter:					
;										
;-------------------------------------------------------------------------------
	 .SELECT								
	   .WHEN    <BL EQ 1> OR	    ; MONO or				
	   .WHEN    <BL EQ 2>		    ; CGA				
	      MOV     DS:[BP].HARDWARE_CONFIG,OLD_ADAPTER			
	   .WHEN    <BL EQ 4> OR	    ; EGA with Mono or			
	   .WHEN    <BL EQ 5>		    ; EGA with Color			
	      MOV     DS:[BP].HARDWARE_CONFIG,EGA				
	   .WHEN    <BL EQ 7> OR	    ; BRECON-B with Mono or		
	   .WHEN    <BL EQ 8>		    ; BRECON-B with Color		
	      MOV     DS:[BP].HARDWARE_CONFIG,ROUNDUP				
	   .WHEN    <BL EQ 0Bh> OR	    ; PS/2 Model 30 with Mono or	
	   .WHEN    <BL EQ 0Ch> 	    ; PS/2 Model 30 with Color		
	      MOV     DS:[BP].HARDWARE_CONFIG,PALACE				
	 .ENDSELECT								
;-------------------------------------------------------------------------------
;										
; PS/2 call is not supported, try the EGA info call:				
;										
;-------------------------------------------------------------------------------
       .ELSE									
	  MOV	  AH,ALT_SELECT_CALL	  ; Request Alternate select's          
	  MOV	  BL,EGA_INFO_CALL	  ;  "return EGA information call"      
	  INT	  10H			  ; Call video BIOS			
	 .IF	  <BL NE EGA_INFO_CALL>   ; If a memory value is returned	
	 .THEN				  ; then, there is an EGA		
	    MOV     DS:[BP].HARDWARE_CONFIG,EGA 				
	 .ELSE				  ; else, call is not supported:	
;-------------------------------------------------------------------------------
;										
; EGA call is not supported, try the PC CONVERTIBLE display description call:	
;										
;-------------------------------------------------------------------------------
	    MOV     AH,DISP_DESC_CALL						
	    INT     10H 		    ; Call BIOS, ES:DI :=Offset of parms
	   .IF	    <ES:[DI] EQ 5140H>	    ; If LCD display type,		
	   .THEN			    ;	set LCD bit in Shared Data area 
	      MOV     DS:[BP].HARDWARE_CONFIG,PC_CONVERTIBLE			
	   .ELSE			    ; else, we have an old adapter.	
	      MOV     DS:[BP].HARDWARE_CONFIG,OLD_ADAPTER ; (either MONO or CGA)
	   .ENDIF   ; Display type is LCD					
	 .ENDIF ; EGA BIOS is present						
       .ENDIF ; PS/2 BIOS is present						
	RET									
DET_HW_CONFIG ENDP								
PAGE										
;=======================================================================	
;										
; DET_MODE_STATE : Determine the current video mode and the active page.	
;										
;-----------------------------------------------------------------------	
;										
;	INPUT:	HARDWARE_CONFIG = Type of video hardware attached		
;										
;	OUTPUT: CUR_MODE = Video mode number (0-13H)				
;		CUR_PAGE = Video page number (0-8)				
;		NB_CHAR_COLUMNS = Number of columns if in a text mode.		
;										
;										
;	CALLED BY: PRT_SCR							
;										
;										
;-------------------------------------------------------------------------------
;										
; DESCRIPTION:	Use the BIOS interface to					
; obtain the current mode and active page.					
;										
; LOGIC:									
;										
;   Call BIOS INTERRUPT 10H: "Return current video state" (AH = 0fh)            
;										
DET_MODE_STATE PROC NEAR							
	PUSH	AX								
	PUSH	BX								
	MOV	AH,GET_STATE_CALL						
	INT	10H			; CALL BIOS				
	MOV	CUR_MODE,AL							
	MOV	NB_CHAR_COLUMNS,AH						
	MOV	CUR_PAGE,BH							
										
	POP	BX								
	POP	AX								
	RET									
DET_MODE_STATE ENDP								
										
PAGE										
;=======================================================================	
;										
; GET_MODE_ATTR: Obtain attributes of current video mode.			
;										
;-----------------------------------------------------------------------	
;										
;	INPUT:	CUR_MODE   = Current video mode (1 BYTE)			
;										
;	OUTPUT: MODE_TYPE  = Video mode type (TXT or APA)			
;		NB_COLORS  = Maximum number of colors (0-256) (0=B&W)		
;		ERROR_CODE = Error code if error occurred.			
;		SCREEN_HEIGHT= Number of rows (in pixels if APA or char if TEXT)
;		SCREEN_WIDTH = Number of columns (in pixels/char)		
;										
;	CALLED BY: PRT_SCR							
;										
;										
;-----------------------------------------------------------------------	
;										
; DESCRIPTION: Scan the 2 local video mode attribute tables until the		
; current mode is located.  Return the attributes.				
; For APA modes SCREEN_HEIGHT and SCREEN_WIDTH are in pixels,			
; for TEXT modes they are in characters.					
;										
;										
; LOGIC:									
;										
; Scan the APA_ATTR_TABLE							
; IF FOUND									
;   MODE_TYPE  := APA								
;   NB_COLORS  := mode.MAX_COLORS						
;   SCREEN_HEIGHT := mode.NB_L							
;   SCREEN_WIDTH  := mode.NB_C							
; ELSE										
;   Scan the TXT_ATTR_TABLE							
;   When FOUND									
;     MODE_TYPE := TXT								
;     NB_COLORS := mode.NUM_COLORS						
;     SCREEN_WIDTH := NB_CHAR_COLUMNS						
;     SCREEN_HEIGHT := Byte in ROM BIOS at 40:84				
;										
;-----------------------------------------------------------------------	
GET_MODE_ATTR	PROC	NEAR							
	JMP	SHORT GET_MODE_ATTR_BEGIN					
;-----------------------------------------------------------------------	
;										
; LOCAL DATA									
;										
;-----------------------------------------------------------------------	
										
APA_ATTR   STRUC      ; ATTRIBUTES FOR APA MODES:				
  APA_MODE   DB ?     ;   Mode number						
  NB_C	     DW ?     ;   Number of columns					
  NB_L	     DW ?     ;   Number of lines					
  MAX_COLORS DW ?     ;   Maximum number of colors available (0=B&W)		
APA_ATTR   ENDS 								
										
TXT_ATTR   STRUC      ; ATTRIBUTES FOR TXT MODES:				
  TXT_MODE   DB ?     ;   Mode number						
  NUM_COLORS DB ?     ;   Number of colors					
TXT_ATTR   ENDS 								
										
;-----------------------------------------------------------------------	
;										
; APA MODE ATTRIBUTES:								
;										
;-----------------------------------------------------------------------	
NB_APA_MODES	DW  10								
APA_ATTR_TABLE LABEL WORD							
MODE04	APA_ATTR <  4,320,200,	4>						
MODE05	APA_ATTR <  5,320,200,	4>						
MODE06	APA_ATTR <  6,640,200,	2>						
MODE0D	APA_ATTR <0DH,320,200, 16>						
MODE0E	APA_ATTR <0EH,640,200, 16>						
MODE0F	APA_ATTR <0FH,640,350,	4>						
MODE10H APA_ATTR <10H,640,350, 16>						
MODE11H APA_ATTR <11H,640,480,	2>						
MODE12H APA_ATTR <12H,640,480, 16>						
MODE13H APA_ATTR <13H,320,200,256>						
										
;-----------------------------------------------------------------------	
;										
; TXT MODE ATTRIBUTES:								
;										
;-----------------------------------------------------------------------	
NB_TXT_MODES	DW  5								
TXT_ATTR_TABLE LABEL WORD							
MODE00 TXT_ATTR <  0, 16>							
MODE01 TXT_ATTR <  1, 16>							
MODE02 TXT_ATTR <  2, 16>							
MODE03 TXT_ATTR <  3, 16>							
MODE07 TXT_ATTR <  7,  0>							
										
;-----------------------------------------------------------------------	
;										
; BEGIN OF GET_MODE_ATTR							
;										
;-----------------------------------------------------------------------	
GET_MODE_ATTR_BEGIN:								
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
	MOV	DL,CUR_MODE		; DL = CURRENT MODE			
;										
; Scan the APA_ATTR_TABLE							
;										
	MOV	CX,NB_APA_MODES 	; CS <-- Number of APA modes		
	MOV	BX,OFFSET APA_ATTR_TABLE; BX <-- Offset of APA mode table	
      SCAN_APA: 								
	CMP	DL,[BX].APA_MODE	; IF mode found 			
	JE	SHORT ITS_APA		; THEN get its attributes		
	ADD	BX,SIZE APA_ATTR						
      LOOP    SCAN_APA			; ELSE keep scanning			
	JMP	SHORT SCAN_TXT_INIT	; NOT in this table: scan txt modes	
ITS_APA:									
	MOV	MODE_TYPE,APA		; MODE = APA				
	MOV	AX,[BX].MAX_COLORS						
	MOV	NB_COLORS,AX		; Get number of colors			
	MOV	AX,[BX].NB_L							
	MOV	SCREEN_HEIGHT,AX	; Get number of lines			
	MOV	AX,[BX].NB_C							
	MOV	SCREEN_WIDTH,AX 	; Get number of columns 		
	JMP	SHORT GET_MODE_ATTR_END 					
										
;										
; Scan the TXT_ATTR_TABLE							
;										
SCAN_TXT_INIT:									
	MOV	CX,NB_TXT_MODES 	; CX <-- Number of TXT modes		
	MOV	BX,OFFSET TXT_ATTR_TABLE; BX <-- Offset of TXT mode table	
      SCAN_TXT: 								
	CMP	DL,[BX].TXT_MODE	; IF mode found 			
	JE	SHORT ITS_TXT		; THEN get its attributes		
	ADD	BX,SIZE TXT_ATTR						
      LOOP    SCAN_TXT			; ELSE keep scanning			
ITS_TXT:									
	MOV	MODE_TYPE,TXT		; MODE = TXT				
	MOV	AL,[BX].NUM_COLORS						
	CBW									
	MOV	NB_COLORS,AX		; Get number of colors			
	MOV	AL,NB_CHAR_COLUMNS	; Get number of columns 		
	CBW									
	MOV	SCREEN_WIDTH,AX 						
       .IF  <DS:[BP].HARDWARE_CONFIG EQ OLD_ADAPTER>; If an old adapter is there
       .THEN ; The number of lines is 25					
	  MOV	  SCREEN_HEIGHT,25						
       .ELSE									
	  MOV	  AX,BIOS_SEG		; Get number of rows			
	  MOV	  ES,AX 		;  from BIOS Data Area			
	  MOV	  BX,NB_ROWS_OFFSET	;   at 0040:0084			
	  MOV	  AL,ES:[BX]							
	  CBW									
	  INC	  AX								
	  MOV	  SCREEN_HEIGHT,AX						
       .ENDIF									
	JMP	SHORT GET_MODE_ATTR_END 					
										
;										
; The current mode was not found in any of the tables				
;										
	MOV	ERROR_CODE,MODE_NOT_SUPPORTED					
										
GET_MODE_ATTR_END:								
	POP	AX								
	POP	BX								
	POP	CX								
	POP	DX								
	RET									
GET_MODE_ATTR ENDP								
PAGE										
;=======================================================================	
;										
; SET_UP_XLT_TABLE : SET UP A COLOR MAPPING FOR EACH COLOR AVAILABLE		
;		     WITH THE CURRENT MODE					
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: CUR_MODE        = Current video mode.				
;	       HARDWARE_CONFIG = Type of display adapter.			
;	       PRINTER_TYPE    = Type of printer attached (Color or B&W)	
;	       XLT_TAB	       = Color translation table.			
;	       CUR_PAGE        = Active page number				
;	       BP	       = Offset of the shared data area 		
;										
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: PRT_SCR							
;										
;-----------------------------------------------------------------------	
;										
; DESCRIPTION: The table is updated to hold a mapping for each color		
; available in the current video mode either TEXT or APA.			
;										
; For example, if the current mode supports 16 colors then the first		
; sixteen bytes of the table will hold the corresponding Color printer		
; or Black and White printer mappings for these colors. 			
;										
;										
; LOGIC:									
;										
; IF HARDWARE_CONFIG = CGA OR HARDWARE_CONFIG = PC_CONVERTIBLE			
; THEN										
;   CALL SET_CGA_XLT_TAB							
;										
; ELSE IF HARDWARE_CONFIG = EGA 						
;   THEN									
;   CALL SET_EGA_XLT_TAB							
;										
; ELSE IF CUR_MODE = 0FH							
;   THEN									
;   CALL SET_MODE_F_XLT_TAB							
;										
; ELSE IF CUR_MODE = 19 							
;   THEN									
;   CALL SET_MODE_13H_XLT_TAB							
;										
; ELSE										
;   CALL SET_ROUNDUP_XLT_TAB							
;										
; CALL SET_BACKG_IN_XLT_TAB   ; Update the background in the translation table	
;										
SET_UP_XLT_TAB PROC NEAR							
;-------------------------------------------------------------------------------
; For old display modes: set up translation table as for a Color Graphics Adapt.
; Either 4 or 16 colors are set up depending if the mode is an APA or text mode.
;										
; NOTE: SET_UP_XLT_TAB cannot be invoked if the display adater is a Monochrome	
;	display adater. (When a Mono. adapter is attached, a jump is made to	
;	the ROM BIOS for printing the screen, and no translation table is set). 
;-------------------------------------------------------------------------------
.IF <BIT DS:[BP].HARDWARE_CONFIG  NZ OLD_ADAPTER> OR ; IF it is a CGA		
.IF <BIT DS:[BP].HARDWARE_CONFIG  NZ PC_CONVERTIBLE> ; or a PC convertible	
.THEN						     ; THEN set up CGA colors	
   CALL    SET_CGA_XLT_TAB			     ;				
.ELSEIF <BIT DS:[BP].HARDWARE_CONFIG NZ EGA>	     ; ELSEIF it is an EGA	
   CALL    SET_EGA_XLT_TAB			     ;	  set up EGA colors.	
.ELSEIF <CUR_MODE EQ 0FH>			     ; ELSEIF we are in mode 15 
   CALL    SET_MODE_F_XLT_TAB			     ;	  set up its 4 shades	
;-------------------------------------------------------------------------------
; A PS/2 system is attached: (we either have a PALACE [Model 30] or a ROUNDUP)	
;-------------------------------------------------------------------------------
.ELSEIF <CUR_MODE EQ 13H>			    ; ELSEIF current mode is 13h
   CALL    SET_MODE_13H_XLT_TAB 		    ;	  set up 256 colors	
.ELSEIF <BIT DS:[BP].HARDWARE_CONFIG NZ PALACE>     ; ELSEIF PS/2 Model 30(MCGA)
   CALL    SET_CGA_XLT_TAB			    ;	  handle it like a CGA	
.ELSE						    ; ELSE we have a ROUNDUP	
;-------------------------------------------------------------------------------
; A PS/2 model 50, 60 or 80 or an ADA 'B' card is attached (in 16 color mode):  
;-------------------------------------------------------------------------------
   CALL    SET_ROUNDUP_XLT_TAB			;   set up 16 colors		
.ENDIF										
;-------------------------------------------------------------------------------
; Finish setting up the translation table:					
;-------------------------------------------------------------------------------
										
CALL SET_BACKG_IN_XLT_TAB   ; Update the background in the translation table	
			    ;  according to the command line switch setting	
			    ;	(i.e.,/R /B)					
   RET										
SET_UP_XLT_TAB ENDP								
PAGE										
;===============================================================================
;										
; SET_BACKG_IN_XLT_TAB : ADJUST THE MAPPING FOR THE BACKGROUND COLOR IN THE	
;			 XLT_TAB ACCORDING TO PRINTER TYPE AND /R /B.		
;										
;										
;-------------------------------------------------------------------------------
;										
; INPUT:  BP = Offset of shared data area  (SWITCHES)				
;	  XLT_TAB = The color translation table.				
;										
; OUTPUT: XLT_TAB IS UPDATED							
;										
;-------------------------------------------------------------------------------
;										
; DESCRIPTION: If there is a black and white printer and /R is NOT specified	
; then the background color should not be printed and it is replaced in the	
; translation table by the Intensity for white (will print nothing).		
;										
; If a color printer is attached and /B is not specified then the background	
; color is replaced by the Print Band mask for white.				
;										
; LOGIC:									
; IF  (a black and white printer is attached) AND (/R is OFF)			
; THEN										
;   MOV 	XLT_TAB, WHITE_INT	; Store white in translation table	
; ELSE (a color printer is attached)						
;   IF (/B is ON)								
;   THEN									
;      RGB.R := MAX_INT 							
;      RGB.G := MAX_INT 							
;      RGB.B := MAX_INT 							
;      CALL RGB2BAND			; Convert RGB for white to a Band Mask	
;      MOV	XLT_TAB,AL		; Store the band mask in the xlt table	
;										
;										
;-------------------------------------------------------------------------------
SET_BACKG_IN_XLT_TAB PROC NEAR							
;-------------------------------------------------------------------------------
;										
; Test if a black and white printer is attached.				
;										
;-------------------------------------------------------------------------------
.IF <BIT DS:[BP].PRINTER_TYPE NZ BLACK_WHITE> AND    ; IF black and white	
.IF <BIT DS:[BP].SWITCHES Z REVERSE_SW> 	     ;	   printer and not /R	
.THEN						     ; then, map background	
	MOV	XLT_TAB,WHITE_INT		     ;	   to white.		
;-------------------------------------------------------------------------------
;										
; A Color printer is attached:							
;										
;-------------------------------------------------------------------------------
.ELSEIF <BIT DS:[BP].PRINTER_TYPE NZ COLOR> AND      ; else, if color printer	
.IF <BIT DS:[BP].SWITCHES Z BACKGROUND_SW>	     ;	      and  /B if OFF	
.THEN						     ;				
						     ; Store a null band mask	
	MOV	XLT_TAB,0			     ;	the translation table.	
.ENDIF										
	RET									
SET_BACKG_IN_XLT_TAB  ENDP							
PAGE										
;=======================================================================	
;										
; SET_EGA_XLT_TAB : SET UP COLOR TRANSLATION TABLE FOR ENHANCED GRAPHIC 	
;		    ADAPTER							
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: XLT_TAB = Color translation table.				
;	       PRINTER_TYPE    = Type of printer attached (Color or B&W)	
;	       SWITCHES        = GRAPHICS command line parameters.		
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: SET_UP_XLT_TABLE						
;										
;-----------------------------------------------------------------------	
;										
; NOTES: With the EGA, "VIDEO BIOS READ DOT call" returns an index into         
; the 16 EGA palette registers. 						
;										
; These registers contain the actual colors stored as rgbRGB components 	
; (see EGA_COL2RGB for details) for mode hex 10.  Under mode hex E these	
; registers contain the actual colors as I0RGB components (see CGA_COL2RGB	
; for details). 								
;										
; These registers can be Revised by the user but, are 'WRITE ONLY'.            
; However, it is possible to define a SAVE AREA where BIOS will maintain	
; a copy of the palette registers.						
;										
; This area is called the "DYNAMIC SAVE AREA" and is defined via the            
; BIOS EGA SAVE_PTR AREA. Whenever the palette registers are changed by 	
; the user, BIOS updates the EGA_SAVE_AREA.					
;										
; The 16 palette registers are the first 16 bytes of the DYNAMIC SAVE AREA.	
;										
; This program takes advantage of this feature and consults the EGA DYNAMIC	
; SAVE AREA in order to obtain the colors used in the active screen.		
;										
;										
; DESCRIPTION: Obtain each color available with an EGA by reading its		
; palette register in the EGA_SAVE_AREA:					
;										
; Calculate the mapping for this color, either a BAND_MASK or a 		
; GREY INTENSITY and store it in the color translation table.			
;										
;										
; LOGIC:									
;										
; Obtain the DYNAMIC EGA SAVE AREA offset from the BIOS SAVE_PTR_AREA.		
;										
; If current mode is either 4,5 or 6						
; Then, 									
;   CALL SET_CGA_XLT_TAB							
;   Get the background color by reading palette register number 0		
; Else, 									
;   For each register number (0 to 15): 					
;     Get the register contents (rgbRGB values) from the EGA SAVE AREA		
;     CALL EGA_COL2RGB		  ; Obtain the Red, Green, Blue values		
;     CALL RGB2XLT_TAB		  ; Obtain a Band Mask or a Grey Intensity	
;				  ; and store the result in the XLT_TAB 	
;										
SET_EGA_XLT_TAB PROC NEAR							
	PUSH	AX			; Save the registers used		
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
	PUSH	DI								
										
;-------------------------------------------------------------------------------
;										
; Obtain the pointer to the DYNAMIC SAVE AREA from the SAVE AREA POINTER TABLE: 
;										
;-------------------------------------------------------------------------------
EGA_SAVE_PTR	EQU	4A8H		; EGA BIOS pointer to table of		
					; pointer to save areas.		
	XOR	AX,AX			; ES segment := paragraph 0		
	MOV	ES,AX								
										
	LES	BX,ES:DWORD PTR EGA_SAVE_PTR ; ES:BX := Pointer to ptr table	
	LES	BX,ES:[BX]+4		; ES:BX :=  Pointer to dynamic save area
					;  (NOTE: It is the second pointer in	
					;   the table)				
										
;-------------------------------------------------------------------------------
;										
; Set up one entry in the translation table for each color available.		
;										
;-------------------------------------------------------------------------------
.IF <CUR_MODE EQ 4> OR			; If the current mode is an old CGA	
.IF <CUR_MODE EQ 5> OR			;  GRAPHICS mode:			
.IF <CUR_MODE EQ 6>								
.THEN										
;-------------------------------------------------------------------------------
; Current mode is either mode 4, 5 or 6;					
; Store each color of the old CGA All Points Addressable mode:			
;-------------------------------------------------------------------------------
	CALL	SET_CGA_XLT_TAB 	; Set up  colors in the translation	
					;  table, NOTE: The background color	
					;   will not be set properly since the	
					;    EGA BIOS does not update memory	
					;     location 40:66 with the value	
					;      of the background color as CGA	
					;	does.				
;------Adjust the background color in the translation table:			
;------The background color is obtained from the EGA DYNAMIC SAVE AREA		
;------ES:BX = Address of the EGA DYNAMIC SAVE AREA				
;------NOTE : For CGA compatible modes EGA BIOS stores the color in the 	
;------DYNAMIC SAVE AREA as a I0RGB value.					
	XOR	DI,DI			; DI:=register number = index in XLT_TAB
	MOV	AL,ES:[BX][DI]		; AL:=Palette register 0 = Back. color	
	MOV	AH,AL			;  Convert I0RGB to IRGB (CGA color)	
	AND	AL,111B 		;    Isolate RGB bits			
	AND	AH,10000B		;    Isolate I bit			
	SHR	AH,1			;    Move I bit from position 5 to 4	
	OR	AL,AH			;    Get IRGB byte.			
	CALL	CGA_COL2RGB		; Convert IRGB to R,G,B values		
	CALL	RGB2XLT_TAB		; Convert RGB to an entry in XLT_TAB	
										
.ELSE					; ELSE, we have an EGA graphics mode:	
;-------------------------------------------------------------------------------
; The current mode is a either a text mode or one of the EGA enhanced mode;	
; Store in the translation table each color available (these modes have 16 col.)
;-------------------------------------------------------------------------------
	MOV	CX,16			; CX := Number of palette registers	
					;	to read 			
	XOR	DI,DI			; DI := Palette register number 	
					;  and index in the translation table	
STORE_1_EGA_COLOR:								
	MOV	AL,ES:[BX][DI]		; AL := Palette register		
       .IF   <CUR_MODE EQ 14> OR	; If mode E (hex) OR mode D (hex)	
       .IF   <CUR_MODE EQ 13>		; the colors are			
       .THEN				;  stored as I0CGA colors		
	  MOV	  AH,AL 		;  Convert I0RGB to IRGB (CGA color)	
	  AND	  AL,111B		;    Isolate RGB bits			
	  AND	  AH,10000B		;    Isolate I bit			
	  SHR	  AH,1			;    Move I bit from position 5 to 4	
	  OR	  AL,AH 		;    Get IRGB byte.			
	  CALL	  CGA_COL2RGB		;  Convert IRGB to R,G,B values 	
       .ELSE				; Else, they are stored as (rgbRGB);	
	  CALL	  EGA_COL2RGB		;   Convert register to R,G,B values	
       .ENDIF									
	CALL	RGB2XLT_TAB		; Convert RGB to an entry in XLT_TAB	
	INC	DI			; Get next palette register number	
	LOOP	STORE_1_EGA_COLOR						
.ENDIF					; ENDIF 4 colors or 16 colors		
										
	POP	DI			; Restore the registers 		
	POP	DX								
	POP	CX								
	POP	BX								
	POP	AX								
	RET									
SET_EGA_XLT_TAB ENDP								
PAGE										
;=======================================================================	
;										
; SET_CGA_XLT_TAB : SET UP COLOR TRANSLATION TABLE FOR COLOR GRAPHIC		
;		    ADAPTER							
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: XLT_TAB	       = Color translation table.			
;	       PRINTER_TYPE    = Type of printer attached (Color or B&W)	
;	       SWITCHES        = GRAPHICS command line parameters.		
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: SET_UP_XLT_TABLE						
;										
;-----------------------------------------------------------------------	
;										
; NOTES: With the CGA, the "VIDEO BIOS READ DOT call" returns a number          
; from 0 to 3. A dot of value 0 is of the background color.			
;										
; The actual value of the background color is stored in BIOS VIDEO		
; DISPLAY DATA AREA as a PIIRGB value (see CGA_COL2RGB for details) and 	
; can be any of 16 colors.							
;										
; A dot of value 1,2, or 3 represents any of 2 specific colors depending	
; on the current color palette. 						
;										
; The palette number is obtained from the BIOS VIDEO DISPLAY DATA AREA		
; (It is the "P" bit or bit number 5)                                           
;										
; The dot values 1,2,3 expressed in binary actually represent the RG		
; (Red, Green) components of the color. 					
;										
; The palette number represents the B (Blue) component therefore, when		
; the palette number is appended to the color number we obtain the RGB		
; components for that color.							
;										
;  (E.G.,  COLOR  =  010	; COLOR # 2					
;	   PALETTE=    0	; PALETTE # 0					
;										
;	   IRGB   =  0100	; Intensity = 0  Ŀ				
;				; Red	    = 1   > color = Red		
;				; Green     = 0   				
;				; Blue	    = 0  				
;										
;										
; DESCRIPTION:									
;										
; For each color available with a CGA:						
;	 Calculate the color mapping, either a BAND_MASK or a GREY		
;	 INTENSITY and store it in the color translation table. 		
;										
; LOGIC:									
;										
; ; Obtain the background color from VIDEO BIOS DATA AREA			
; ;  and the paletter number							
;										
; ; Store the Background color: 						
; CALL CGA_COL2RGB		  ; Convert IRGB components to RGB values	
; CALL RGB2XLT_TAB		  ; Convert RGB to an entry in the translation	
;				  ; table					
; ; Store all other colors:							
; FOR IRG := 1 TO 3		  ; Obtain the color number			
;   Append palette number (B) to IRG						
;   CALL CGA_COL2RGB		  ; Convert color to RGB values 		
;   CALL RGB2XLT_TAB		  ; Convert RGB to an entry in the translation	
;				  ; table					
;										
SET_CGA_XLT_TAB  PROC NEAR							
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DI								
	PUSH	ES								
										
.IF <CUR_MODE EQ 4> OR								
.IF <CUR_MODE EQ 5>								
;===============================================================================
;										
; THE CURRENT MODE IS MODE 4 OR 5						
;										
;-------------------------------------------------------------------------------
.THEN										
;-------------------------------------------------------------------------------
; Read the CRT palette from the BIOS ROM to obtain the background color and	
; the current palette number; store the palette number in BL			
;-------------------------------------------------------------------------------
ROM_BIOS_SEG	EQU 40H    ; CGA BIOS SEGMENT					
CRT_PALETTE_OFF EQU 66H    ; BIOS Current palette setting			
P_BIT_MASK   EQU 100000B   ;   bit 5 = Current palette				
I_BIT_MASK   EQU   1000B   ;   bit 4 = Intensity bit				
R_BIT_MASK   EQU    100B   ;   bit 2 = Red bit					
G_BIT_MASK   EQU     10B   ;   bit 1 = Green bit				
B_BIT_MASK   EQU      1B   ;   bit 0 = Blue bit 				
										
	MOV	AX,ROM_BIOS_SEG      ; ES := ROM BIOS SEGMENT			
	PUSH	AX								
	POP	ES								
										
	MOV	AL,ES:CRT_PALETTE_OFF; AL := CRT Palette  (00PIIRGB)		
	MOV	BL,P_BIT_MASK	     ; LOW NIBBLE = BACKGROUND COLOR		
	AND	BL,AL		     ; BL := Palette number			
	MOV	CL,5								
	SHR	BL,CL								
										
	XOR	DI,DI		     ; DI := Index in the XLT_TAB		
;-------------------------------------------------------------------------------
; Store the background color, (obtained from low 4 bits of the byte at 40:66)	
;-------------------------------------------------------------------------------
	CALL	CGA_COL2RGB	     ; Convert color (in AL) to R, G, B values	
	CALL	RGB2XLT_TAB	     ; Convert RGB to an entry in XLT_TAB	
;-------------------------------------------------------------------------------
; Store the 3 foreground colors for mode 4 and 5				
;-------------------------------------------------------------------------------
	MOV	CX,3		     ; For each color, but the background:	
STORE_1_CGA_MODE4_COLOR:							
	INC	DI		     ; Increment index in the translation table 
	MOV	AX,DI		     ; AL := IRG				
	SHL	AL,1								
	OR	AL,BL		     ; AL := IRGB				
	CALL	CGA_COL2RGB	     ; Convert color (in AL) to R, G, B values	
	CALL	RGB2XLT_TAB	     ; Convert RGB to an entry in XLT_TAB	
	LOOP	STORE_1_CGA_MODE4_COLOR 					
.ELSEIF <CUR_MODE EQ 6> 							
;===============================================================================
;										
; THE CURRENT MODE IS MODE 6							
;										
;-------------------------------------------------------------------------------
.THEN										
;-------------------------------------------------------------------------------
; Store background color for mode 6 (mode 6 is a 2 colors, APA mode)		
; Background is stored as BLACK 						
;-------------------------------------------------------------------------------
	XOR	DI,DI		  ; DI := Index of color in translation table	
	MOV	RGB.R,BLACK_INT   ; Foreground color is white			
	MOV	RGB.G,BLACK_INT   ; RGB := RGB of white 			
	MOV	RGB.B,BLACK_INT   ;						
	CALL	RGB2XLT_TAB	  ; Convert RGB to an entry in XLT_TAB		
;-------------------------------------------------------------------------------
; Store foreground color for mode 6 (mode 6 is a 2 colors, APA mode)		
;-------------------------------------------------------------------------------
	INC	DI		  ; DI := Index of color in translation table	
	MOV	RGB.R,WHITE_INT   ; Background color is BLACK			
	MOV	RGB.G,WHITE_INT   ; RGB := RGB of BLACK 			
	MOV	RGB.B,WHITE_INT   ;						
	CALL	RGB2XLT_TAB	  ; Convert RGB to an entry in XLT_TAB		
.ELSE										
;===============================================================================
;										
; THE CURRENT MODE IS A TEXT MODE:						
;										
;-------------------------------------------------------------------------------
	XOR	DI,DI		  ; DI := Index in the translation table	
	MOV	CX,16		  ; For each of the 16 colors:			
STORE_1_CGA_TEXT_COLOR: 							
	MOV	AX,DI		  ; AL := IRGB					
	CALL	CGA_COL2RGB	  ; Convert color (in AL) to R, G, B values	
	CALL	RGB2XLT_TAB	  ; Convert RGB to an entry in XLT_TAB		
	INC	DI		  ; Increment index in the translation table	
	LOOP	STORE_1_CGA_TEXT_COLOR						
.ENDIF				  ;						
										
	POP	ES								
	POP	DI								
	POP	CX								
	POP	BX								
	POP	AX								
										
	RET									
SET_CGA_XLT_TAB  ENDP								
PAGE										
;===============================================================================
;										
; RGB2XLT_TAB: CONVERT R,G,B VALUES TO EITHER A BAND MASK OR AN INTENSITY	
;	   STORE THE RESULT IN THE TRANSLATION TABLE				
;										
;-------------------------------------------------------------------------------
;										
;	INPUT:	 DI  = Index in the translation table				
;		 RGB = Red Green Blue values of the color to be stored. 	
;										
;	OUTPUT:  XLT_TAB is updated						
;										
;-------------------------------------------------------------------------------
; DESCRIPTION: Convert the RGB values to either a Band mask or an intensity	
; depending on the printer type; store the result in the translation table.	
;										
; LOGIC:									
;   IF PRINTER_TYPE = COLOR							
;     THEN									
;     CALL RGB2BAND		  ; Obtain a Band Mask				
;   ELSE ; Printer is Monochrome						
;     CALL RGB2INT		  ; Obtain a Grey Intensity			
;   Store the result in the XLT_TAB						
;										
RGB2XLT_TAB PROC NEAR								
       .IF <DS:[BP].PRINTER_TYPE EQ COLOR>; Color printer ?			
       .THEN									
;-------A color printer is attached:						
	  CALL	  RGB2BAND		; Yes, convert RGB to color band (in AL)
       .ELSE									
;-------A black and white printer is attached:					
	  CALL	  RGB2INT		; No, RGB to an intensity in AL 	
       .ENDIF									
;-------Store the result							
	MOV	XLT_TAB[DI],AL							
       RET									
RGB2XLT_TAB ENDP								
PAGE										
;===============================================================================
;										
; CGA_COL2RGB : CONVERT A COLOR FROM THE CGA TO RED GREEN BLUE VALUES		
;										
;-------------------------------------------------------------------------------
;										
;	INPUT: AL      = 0000IRGB    ONE BYTE WHERE BIT:			
;										
;					I = Intensity bit			
;					R = Red component			
;					G = Green component			
;					B = Blue component			
;										
;										
;	OUTPUT: RGB.R	    = RED   component (0-63)				
;		RGB.G	    = GREEN component (0-63)				
;		RGB.B	    = BLUE  component (0-63)				
;										
;	CALLED BY: SET_UP_CGA_XLT_TABLE 					
;										
;-----------------------------------------------------------------------	
;										
; DESCRIPTION: If either the RED, GREEN, or BLUE bit is on (in an IRGB		
; byte) then, the corresponding color gun on the display is firing 2/3		
; of its capacity, giving a color intensity of "2/3".                           
;										
; If the INTENSITY bit is on, then 1/3 is added to EACH color.			
;										
; (E.G.,		       IRGB		 R    G    B			
;	   BLACK	 = 00000000	      (  0,   0,   0)			
;	   WHITE	 = 00001111	      (3/3, 3/3, 3/3)			
;	   RED		 = 00000100	      (2/3,   0,   0)			
;	   HIGH INT. RED = 00001100	      (3/3, 1/3, 1/3)			
;										
; Since we want an intensity from 0 to 63,					
; "2/3" of RED means:                                                           
;		       2/3 * 63 = 42						
;										
;										
; LOGIC:									
; Get the intensity.								
; Get the red component 							
; Get the green component							
; Get the blue component							
;										
CGA_COL2RGB PROC NEAR								
;-----------------------------------------------------------------------	
;										
; Init the R,G,B values:							
;										
;-----------------------------------------------------------------------	
	MOV	RGB.R,0 							
	MOV	RGB.G,0 							
	MOV	RGB.B,0 							
;-----------------------------------------------------------------------	
;										
; Test the Intensity bit:							
;										
;-----------------------------------------------------------------------	
       .IF <BIT AL AND I_BIT_MASK>	; IF, I is on				
       .THEN									
	  ADD	  RGB.R,ONE_THIRD	; Then, add one third to each		
	  ADD	  RGB.G,ONE_THIRD	; color.				
	  ADD	  RGB.B,ONE_THIRD						
       .ENDIF									
;-----------------------------------------------------------------------	
;										
; Test the RGB bits:								
;										
;-----------------------------------------------------------------------	
       .IF <BIT AL AND R_BIT_MASK>	; If, Red is on 			
       .THEN									
	  ADD	  RGB.R,TWO_THIRD	; then, add two third RED		
       .ENDIF									
										
       .IF <BIT AL AND G_BIT_MASK>	; If, Green is on			
       .THEN									
	  ADD	  RGB.G,TWO_THIRD	; then, add two third GREEN		
       .ENDIF									
										
       .IF <BIT AL AND B_BIT_MASK>	; If, Blue is on			
       .THEN									
	  ADD	  RGB.B,TWO_THIRD	; then, add two third BLUE		
       .ENDIF									
										
	RET									
CGA_COL2RGB ENDP								
PAGE										
;=======================================================================	
;										
; SET_MODE_F_XLT_TAB: SET UP COLOR TRANSLATION TABLE FOR MONOCHROME		
;		      MODE "F"                                                  
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: XLT_TAB	     = Color translation table. 			
;	       PRINTER_TYPE  = Type of printer attached (Color or B&W)		
;	       SWITCHES      = GRAPHICS command line parameters.		
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: SET_UP_XLT_TABLE						
;										
;-------------------------------------------------------------------------------
;										
; NOTES: In mode F the "VIDEO BIOS READ DOT call" returns a byte where          
; bit 1 and 3 represent the value of plane 1 and 3.				
; The following colors are available using this mode:				
;										
;		plane 2:   plane 0:	   color:				
;		   0	      0 	   black				
;		   0	      1 	   white				
;		   1	      0 	   blinking white			
;		   1	      1 	   high-intensity white 		
;										
;										
; DESCRIPTION: A local table holds the Red, Green, Blue values for each of	
; the 4 Mono colors available in Mode Fh.					
; Each color is stored as either a Grey intensity if printing in Monochrome	
; or as a Band Mask if printing in color.					
; Black is stored as black.							
; White is stored as a light gray						
; High-intensity white and blinking white are stored as white.			
;										
;										
; LOGIC:									
; FOR EACH "COLOR" AVAILABLE WITH MODE F                                        
; GET ITS R,G,B VALUES								
; CALL RGB2XLT_TAB		; Convert RGB to an entry in the translation	
;				; table 					
;										
SET_MODE_F_XLT_TAB PROC NEAR							
	PUSH	AX								
	PUSH	SI								
	PUSH	DI								
	JMP	SHORT SET_MODE_F_BEGIN						
;-------------------------------------------------------------------------------
;										
; TABLE OF R,G,B VALUES WE ASSIGN TO THE 4 COLORS AVAILABLE IN MODE F:		
;										
;-------------------------------------------------------------------------------
MODE_F_RGB	LABEL	BYTE							
	DB	BLACK_INT,BLACK_INT,BLACK_INT ; Black is mapped to black.	
	DB	TWO_THIRD,TWO_THIRD,TWO_THIRD ; White		--> light grey	
	DB	WHITE_INT,WHITE_INT,WHITE_INT ; Blinking	--> white	
	DB	WHITE_INT,WHITE_INT,WHITE_INT ; High-int. White --> white	
;-------------------------------------------------------------------------------
;										
; STORE THE COLORS AVAILABLE WITH MODE F					
;										
;-------------------------------------------------------------------------------
SET_MODE_F_BEGIN:								
	MOV	SI,OFFSET MODE_F_RGB	; SI <-- Offset of RGB table		
	XOR	DI,DI			; DI <-- Index into translation table	
										
;-------For each color available in mode F:					
STORE_1_MODE_F_COLOR:								
	MOV	AL,[SI] 		; Get the Red component 		
	MOV	RGB.R,AL							
	MOV	AL,[SI]+1		; Get the Green component		
	MOV	RGB.G,AL							
	MOV	AL,[SI]+2		; Get the Blue component		
	MOV	RGB.B,AL							
										
;-------Convert pixel to either a Color band or an Intensity:			
	CALL	RGB2XLT_TAB		; Convert and store in the xlt table	
										
	ADD	SI,3			; Get next R,G,B values 		
	INC	DI			; One more color has been stored	
	CMP	DI,NB_COLORS		; All stored ?				
	JL	STORE_1_MODE_F_COLOR						
										
	POP	DI								
	POP	SI								
	POP	AX								
	RET									
SET_MODE_F_XLT_TAB ENDP 							
PAGE										
;=======================================================================	
;										
; SET_MODE_13H_XLT_TAB: SET UP COLOR TRANSLATION TABLE FOR PALACE VIDEO 	
;		      ADAPTER IN MODE 13H					
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: XLT_TAB	      = Color translation table.			
;	       PRINTER_TYPE   = Type of printer attached (Color or B&W) 	
;	       SWITCHES       = GRAPHICS command line parameters.		
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: SET_UP_XLT_TABLE						
;										
;-----------------------------------------------------------------------	
;										
; NOTES: With the PALACE the "VIDEO BIOS READ DOT call" returns a direct        
; index to the 256 COLOR REGISTERS.						
;										
; These COLORS REGISTERS hold the R,G,B (Red, Green, Blue) values for		
; each of the 256 colors available at the same time on the screen.		
; Color register number 0 holds the background color.				
;										
; DESCRIPTION: Store a color mapping for each color register.			
; If the REVERSE_SW is off,  exchange white and black.				
;										
; LOGIC:									
;										
; For each color (0 to 255)							
;   Read the color register	; get the RGB values for this color num.	
;   Store the result in the XLT_TAB						
;										
SET_MODE_13H_XLT_TAB PROC NEAR							
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
	PUSH	DI								
										
	MOV	NB_COLORS_TO_READ,256	; Read 256 color registers		
										
;-------------------------------------------------------------------------------
;										
; Store in the translation table each color available for mode 13h:		
;										
;-------------------------------------------------------------------------------
	XOR	DI,DI			; DI := Palette register number 	
					;  and index in the translation table	
STORE_1_M13H_COLOR:								
	MOV	BX,DI			; BX := Color register to be read	
	MOV	AX,GET_C_REG_CALL	; AX := BIOS Get color register call	
	INT	10H			; Call BIOS				
	MOV	RGB.R,DH		; Get Red value 			
	MOV	RGB.G,CH		; Get Green value			
	MOV	RGB.B,CL		; Get Blue value			
	CALL	RGB2XLT_TAB		; Convert RGB to an entry in XLT_TAB	
	INC	DI			; Get next palette register number	
	CMP	DI,NB_COLORS_TO_READ	; All colors stored ?			
	JL	STORE_1_M13H_COLOR	; No, get next one			
										
										
	POP	DI								
	POP	DX								
	POP	CX								
	POP	BX								
	POP	AX								
	RET									
NB_COLORS_TO_READ DW ?		; Number of colors registers to read with a PS/2
SET_MODE_13H_XLT_TAB ENDP							
PAGE										
;===============================================================================
;										
; SET_ROUNDUP_XLT_TAB: SET UP COLOR TRANSLATION TABLE FOR ROUNDUP VIDEO 	
;		       ADAPTER							
;										
;-------------------------------------------------------------------------------
;										
;	INPUT: XLT_TAB	       = Color translation table.			
;	       PRINTER_TYPE    = Type of printer attached (Color or B&W)	
;	       SWITCHES        = GRAPHICS command line parameters.		
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: SET_UP_XLT_TABLE						
;										
;-------------------------------------------------------------------------------
;										
; NOTES: With the ROUNDUP the "VIDEO BIOS READ DOT call" returns an             
; index into the 16 PALETTE REGISTERS.						
;										
; Each palette register holds an index into the current "color page"            
; within the 256 COLOR REGISTERS.						
;										
; These "color pages" represent all the colors from WHICH TO CHOOSE the         
; screen colors for an active page; 16 colors can be displayed at the		
; same time on the screen.							
;										
; There are 2 paging modes: either 64 color pages or 16 color pages:		
;										
; In 64 color mode, there are 4 color pages available (the 256 palette		
; registers are partitioned in 4 blocks of 64 colors).				
;										
; The 16 screen colors for the active page are selected from these 64		
; color registers.								
;										
; This scheme allows for quickly changing the contents of the screen by 	
; changing the active page.							
;										
; The COLOR REGISTERS contains the color information stored as RGB (Red,	
; Green, Blue) components. There is one byte for each of these 3		
; components.  The value for each component ranges from 0 to 63 (where		
; 0 = color not present).							
;										
;										
; DESCRIPTION: Determine the paging mode and the active color page.		
; For each color available with the current mode, get the palette		
; register and then, read the corresponding color register in order to		
; obtain its RGB components.							
;										
; For mode 11h, 2 colors only are available. These colors are obtained from	
; palette register 0 (background) and 7 (foreground color). The contents	
; of these 2 palette registers is also used as an index within the color	
; registers.									
;										
; If printing is Monochrome, map the RGB to a Grey Intensity.			
; If printing is in colors, map the RGB to a Band Mask. 			
; Store the result in the translation table					
;										
; LOGIC:									
;										
; Read color page state (BIOS INT 10H - AL = 1AH)				
;										
; If mode 4,5 or 6								
; Then										
;   CALL SET_CGA_XLT_TAB							
;   Adjust the background color.						
; else										
; If mode 11h									
; then										
; For PALETTE_INDEX := 0 to 15							
; IF PAGE_MODE = PAGE_64_REGISTERS						
;   THEN									
;   Read the palette register number "PALETTE_INDEX"                            
;   COLOR_INDEX := Palette register contents					
;   COLOR_INDEX := (CUR_PAGE_NUM * 64) + COLOR_INDEX				
;   Read color register number "COLOR_INDEX"    ; Obtain R,G,B values.          
;   CALL    RGB2XLT_TAB       ; Convert RGB to an entry in XLT_TAB		
;										
; ELSE IF PAGE_MODE = PAGE_16_REGISTERS 					
;   COLOR_INDEX := (CUR_PAGE_NUM * 16) + PALETTE_INDEX				
;   Read color register number "COLOR_INDEX"                                    
;   CALL    RGB2XLT_TAB       ; Convert RGB to an entry in XLT_TAB		
;										
;										
SET_ROUNDUP_XLT_TAB PROC NEAR							
PAGING_MODE_64 EQU 0								
										
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DI								
										
;-------------------------------------------------------------------------------
; Obtain the color page state							
;-------------------------------------------------------------------------------
	MOV	AX,PAGE_STATE_CALL	  ; Call BIOS				
	INT	10H			  ;  BL := Paging mode			
					  ;  BH := Current page 		
										
;-------------------------------------------------------------------------------
; Check the video mode: 							
;-------------------------------------------------------------------------------
.SELECT 									
.WHEN <CUR_MODE EQ 4> OR		  ; If the current mode is an old CGA	
.WHEN <CUR_MODE EQ 5> OR		  ;  mode:				
.WHEN <CUR_MODE EQ 6>			  ;					
;-------------------------------------------------------------------------------
;										
; Old CGA graphics mode (mode 4, 5 or 6)					
;										
;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
; Store colors of the old CGA modes:						
;-------------------------------------------------------------------------------
	CALL	SET_CGA_XLT_TAB 	; Set up colors in the translation	
					;  table, NOTE: The background color	
					;   will not be set properly since the	
					;    PS/2 BIOS does not update memory	
					;     location 40:66 with the value	
					;      of the background color as CGA	
					;	does for modes 4 and 5. However 
					;	 40:66 holds the current palette
					;	  selected.			
;-------------------------------------------------------------------------------
; Adjust the background color for modes 4,5 or 6				
;-------------------------------------------------------------------------------
	MOV	PAL_REGISTER_NB,0	; Read the palette register number 0	
	CALL	GET_PALETTE_RGB 	;  this register points to the color	
					;   register that contains the RGB	
					;    values of the BACKGROUND color.	
	MOV	DI,0			; DI := Index in the translation table	
	CALL	RGB2XLT_TAB		; Store mapping in the translation table
										
.WHEN  <CUR_MODE EQ 11H>							
;-------------------------------------------------------------------------------
;										
; Mode 11h (2 colors out of 256,000 colors)					
;										
;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
; Get the background color:							
;-------------------------------------------------------------------------------
	MOV	PAL_REGISTER_NB,0	; Read the palette register number 0	
	CALL	GET_PALETTE_RGB 	; Get the RGB values for this color	
	MOV	DI,0			; DI := Index in translation table	
	CALL	RGB2XLT_TAB		; Store mapping in the translation table
;-------------------------------------------------------------------------------
; Get the foreground color:							
;-------------------------------------------------------------------------------
	MOV	PAL_REGISTER_NB,7	; Read the palette register for the	
					;  FOREGROUND color (palette register 7)
	CALL	GET_PALETTE_RGB 	; Get the RGB values for this color	
	MOV	DI,1			; DI := Index in translation table	
	CALL	RGB2XLT_TAB		; Store mapping in the translation table
.OTHERWISE									
;-------------------------------------------------------------------------------
;										
; The current mode is a 16 color mode						
;										
;-------------------------------------------------------------------------------
	XOR	DI,DI			; DI := Index in translation table	
	MOV	CX,16			; 16 colors to read and store		
	MOV	PAL_REGISTER_NB,0	; Palette register to read		
STORE_1_PS2_COLOR:								
	CALL	GET_PALETTE_RGB 	; Get the RGB values for this color	
;										
;-------Convert the RGB values to band mask or intensity and store in XLT_TAB:	
										
	CALL	RGB2XLT_TAB		; Store mapping in the translation table
	INC	DI			; Get next palette register number	
	INC	PAL_REGISTER_NB 	;					
	LOOP	STORE_1_PS2_COLOR	; Read it.				
.ENDSELECT									
										
	POP	DI								
	POP	CX								
	POP	BX								
	POP	AX								
	RET									
PAL_REGISTER_NB DB  ?			; Number of the palette register to read
SET_ROUNDUP_XLT_TAB ENDP							
										
PAGE										
;===============================================================================
;										
; GET_PALETTE_RGB:  ON THE PS/2 MODEL 50, 60 AND 80, GET THE RGB VALUES FOR A	
;		    PALETTE REGISTER BY READING THE CORRESPONDING COLOR REGISTER
;										
;-------------------------------------------------------------------------------
;										
;      INPUT:  PAL_REGISTER_NB = Palette register number			
;	       BH	       = Current page number				
;	       BL	       = Current paging mode				
;										
;      OUTPUT: RGB.R	       = The RGB values obtained from the color register
;	       RGB.G		 corresponding to the palette register specified
;	       RGB.B								
;										
;      CALLED BY: SET_ROUNDUP_XLT_TAB						
;										
;-------------------------------------------------------------------------------
GET_PALETTE_RGB PROC								
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
	PUSH	SI								
										
	MOV	AL,BH			;  SI := Current page number		
	CBW				;					
	MOV	SI,AX			;					
;-------------------------------------------------------------------------------
;										
; Calculte the absolute number of the first Color Register for the current page:
; (calculated in SI)								
;										
;-------------------------------------------------------------------------------
.IF <BL EQ PAGING_MODE_64>		; If mode is 64 Color page		
.THEN					; then					
	MOV	CL,6			;    SI := Current page num * 64	
	SHL	SI,CL			;					
.ELSE					; else, Mode is 16 Color page		
	MOV	CL,4			;    SI := Current page num * 16	
	SHL	SI,CL			;					
.ENDIF										
										
;										
;-------Read the PALETTE REGISTER						
	MOV	BL,PAL_REGISTER_NB	; BL := Palette register to be read	
	MOV	AX,GET_P_REG_CALL	; Read palette register call		
	INT	10H			; Call BIOS,				
					;   BH := Color register index		
					;	  WITHIN the current page and is
					;	  either (0-15) or (0-63)	
					;  NOTE: SI = Absolute index (0-255) to 
					;  the first color register of the	
					;   current page and is a multiple of	
					;    either 16 or 64			
	MOV	BL,BH			; BX := Index within current color page 
	XOR	BH,BH			;					
										
;										
;-------Read the Color register:						
	OR	BX,SI			; BX := Index of Color register to read 
	MOV	AX,GET_C_REG_CALL	; Read the color register		
	INT	10H			; Call BIOS,				
	MOV	RGB.R,DH		; DH := Red value read			
	MOV	RGB.G,CH		; CH := Green value read		
	MOV	RGB.B,CL		; CL := Blue value read 		
										
	POP	SI								
	POP	DX								
	POP	CX								
	POP	BX								
	POP	AX								
	RET									
GET_PALETTE_RGB ENDP								
PAGE										
;=======================================================================	
;										
; EGA_COL2RGB : CONVERT A COLOR FROM THE EGA TO RED GREEN BLUE VALUES		
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: AL      = 00rgbRGB    ONE BYTE WHERE BIT:			
;										
;					r = 1/3 of Red component		
;					g = 1/3 of Green component		
;					b = 1/3 of Blue component		
;					R = 2/3 of Red component		
;					G = 2/3 of Green component		
;					B = 3/3 of Blue component		
;										
;										
;	OUTPUT: RGB.R	    = RED   component (0-63)				
;		RGB.G	    = GREEN component (0-63)				
;		RGB.B	    = BLUE  component (0-63)				
;										
;	CALLED BY: SET_UP_EGA_XLT_TABLE 					
;										
;-----------------------------------------------------------------------	
;										
; DESCRIPTION: Sums up the values for each color component.			
; "2/3 of RED" means that the red gun in the display attached to the EGA        
; is firing at 2/3 of full intensity.						
;										
; Since the color intensities range from 0 to 63, "1/3" means an                
; intensity of: 								
;		 1/3 * 63 = 21							
;										
; LOGIC:									
;										
; Get the red component 							
; Get the green component							
; Get the blue component							
;										
EGA_COL2RGB PROC NEAR								
;										
;-------Get the RED component	(bit 5 and 2)					
;										
;-------Check bit 2								
	MOV	RGB.R,0 							
	TEST	AL,100B 		; "R" is on ?                           
	JZ	CHECK_BIT_5		; No, check "r"                         
	ADD	RGB.R,TWO_THIRD 	; Yes, add 2/3 RED			
CHECK_BIT_5:									
	TEST	AL,100000B		; "r" is on ?                           
	JZ	CHECK_BIT_1		; No, check Green			
	ADD	RGB.R,ONE_THIRD 	; Yes, add 1/3 RED			
;										
;-------Get the GREEN component (bit 4 and 1)					
;										
CHECK_BIT_1:									
	MOV	RGB.G,0 							
	TEST	AL,10B			; "G" is on ?                           
	JZ	CHECK_BIT_4		; No, check "g"                         
	ADD	RGB.G,TWO_THIRD 	; Yes, add 2/3 GREEN			
CHECK_BIT_4:									
	TEST	AL,10000B		; "g" is on ?                           
	JZ	CHECK_BIT_0		; No, check for Blue			
	ADD	RGB.G,ONE_THIRD 	; Yes, add 1/3 GREEN			
;										
;-------Get the BLUE component (bit 3 and 0)					
;										
CHECK_BIT_0:									
	MOV	RGB.B,0 							
	TEST	AL,1B			; "B" is on ?                           
	JZ	CHECK_BIT_3		; No, check "b"                         
	ADD	RGB.B,TWO_THIRD 	; Yes, add 2/3 BLUE			
CHECK_BIT_3:									
	TEST	AL,1000B		; "b" is on ?                           
	JZ	EGA_COL2RGB_RETURN	; No, return				
	ADD	RGB.B,ONE_THIRD 	; Yes, add 1/3 BLUE			
EGA_COL2RGB_RETURN:								
	RET									
EGA_COL2RGB ENDP								
										
PAGE										
;===============================================================================
;										
; RGB2INT : MAP RED GREEN BLUE VALUES TO AN INTENSITY.				
;										
;-------------------------------------------------------------------------------
;										
;	INPUT:	RGB.R		= A RED value (0-63)				
;		RGB.G		= A GREEN value (0-63)				
;		RGB.B		= A BLUE value (0-63)				
;		DARKADJUST_VALUE= THE DARKNESS VALUE (In shared data area).	
;		SWITCHES	= Command line switches 			
;										
;	OUTPUT: AL  = THE INTENSITY  (0-63)  NOTE: 0  = BLACK			
;						   63 = BRIGHT WHITE		
;										
;	WARNING: AH IS LOST							
;										
;-------------------------------------------------------------------------------
;										
; DESCRIPTION: When the RGB values for a pixel are at their maximum		
; value, what we obtain is a bright white pixel on the screen; this is		
; the brightest color achievable and therefore, its intensity is 63.		
;										
; When no color gun is firing on the display: RGB values are 0,0,0 this 	
; is no color at all and therefore maps to intensity 0. 			
;										
; For intermediate colors, experimentation has shown that the eye will		
; see blue as darker than red and red as darker than green.			
;										
; On a grey rainbow from 0 - 10  where 0 is black and 10 is white:		
;										
;     Blue  corresponds to a grey of intensity 1				
;     Red   corresponds to a grey of intensity 3				
;     Green corresponds to a grey of intensity 6				
;										
; Therefore, if we mix all 3 colors we obtain a grey of 			
; intensity 1 + 3 + 6 = 10 (i.e.,white).					
;										
;										
; LOGIC:									
;										
; Calculate the intensity							
;										
;   AL = (.6 * G) + (.3 * R) + (.1 * B) 					
;										
; Adjust Darkness								
;										
;   AL = AL + DARKADJUST_VALUE							
;										
RGB2INT PROC NEAR								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
										
	XOR	AX,AX			; AL := Current component intensity	
	XOR	BX,BX			; BX is used for calculations		
	XOR	DX,DX			; DL := Running sum for grey intensity	
										
;-------Process /R   (Reverse black and white)					
.IF <BIT DS:[BP].SWITCHES Z REVERSE_SW>  ; IF reverse is OFF			
.THEN					 ; THEN REVERSE BLACK AND WHITE:	
;-------Test if the color is BLACK						
       .IF     <RGB.R EQ BLACK_INT> AND ; If black				
       .IF     <RGB.G EQ BLACK_INT> AND ;					
       .IF     <RGB.B EQ BLACK_INT>	;					
       .THEN				; then, replace it with white		
	  MOV	  AL,WHITE_INT							
	  JMP	  SHORT RGB2INT_END						
       .ELSEIF <RGB.R EQ WHITE_INT> AND ; else if, high-intensity white 	
       .IF     <RGB.G EQ WHITE_INT> AND ;					
       .IF     <RGB.B EQ WHITE_INT>	;					
       .THEN				; then, replace it with black		
	  MOV	  AL,BLACK_INT							
	  JMP	  SHORT RGB2INT_END						
       .ELSEIF <RGB.R EQ TWO_THIRD> AND ; else if, white			
       .IF     <RGB.G EQ TWO_THIRD> AND ;					
       .IF     <RGB.B EQ TWO_THIRD>	;					
       .THEN				; then, replace it with black		
	  MOV	  AL,BLACK_INT							
	  JMP	  SHORT RGB2INT_END						
       .ENDIF									
.ENDIF										
										
;-------Calculate Green component						
	MOV	AL,RGB.G		; AL := Green component 		
	MOV	BH,6			;					
	MUL	BH			; AX := Green * 6			
	MOV	BH,10			;					
	DIV	BH			; AL := (GREEN * 6) /  10		
	ADD	DL,AL			; DL := Cumulative intensity		
	MOV	CH,AH			; CH := Cumulative remainder		
										
;-------Calculate Red component 						
	MOV	AL,RGB.R		; AL := Red component			
	MOV	BH,3			;					
	MUL	BH			; AX := Red * 3 			
	MOV	BH,10			;					
	DIV	BH			; AL := (RED * 3) /  10 		
	ADD	DL,AL			; DL := Cumulative intensity		
	ADD	CH,AH			; CH := Cumulative remainder		
										
;-------Calculate Blue component						
	MOV	AL,RGB.B		; AX := Blue component			
	XOR	AH,AH			;					
	DIV	BH			; AL := BLUE / 10			
	ADD	DL,AL			; DL := Cumulative intensity		
	ADD	CH,AH			; CH := Cumulative remainder		
										
;-------Adjust intensity with cumulative remainder				
	XOR	AX,AX								
	MOV	AL,CH			; AX := Cumulative remainder		
	MOV	BH,10			; BH := 10				
	DIV	BH			; AL := Total remainder / 10		
	ADD	DL,AL			; DL := Cumulative intensity		
       .IF <AH GT 4>			; If remainder > 4			
       .THEN				; Then, add 1				
	INC	DL			;  to the intensity			
       .ENDIF									
										
;-------Adjust darkness 							
	ADD	DL,DS:[BP].DARKADJUST_VALUE					
										
;-------Return result								
	MOV	AL,DL			; AL := sum of R,G,B intensities	
										
RGB2INT_END:									
	POP	DX								
	POP	CX								
	POP	BX								
	RET									
RGB2INT ENDP									
										
PAGE										
;============================================================================== 
;										
; RGB2BAND: MAP RED GREEN BLUE VALUES TO A "SELECT COLOR BAND" MASK FOR         
;	    THE COLOR PRINTER.							
;										
;------------------------------------------------------------------------------ 
;										
;	INPUT:	RGB.R		= A RED value (0-63)				
;		RGB.G		= A GREEN value (0-63)				
;		RGB.B		= A BLUE value (0-63)				
;		BP		= Offset of the Shared Data Area.		
;										
;	OUTPUT: AL = Th