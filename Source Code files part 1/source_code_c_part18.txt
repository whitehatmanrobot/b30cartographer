in the result block

$P_EOL		   equ	0		;AN000; End of line
$P_Number	   equ	1		;AN000; Number
$P_List_Idx	   equ	2		;AN000; List Index
$P_String	   equ	3		;AN000; String
$P_Complex	   equ	4		;AN000; Complex
$P_File_Spec	   equ	5		;AN000; File Spec
$P_Drive	   equ	6		;AN000; Drive
$P_Date_F	   equ	7		;AN000; Date
$P_Time_F	   equ	8		;AN000; Time
$P_Quoted_String   equ	9		;AN000; Quoted String

$P_No_Tag	   equ	0FFH		;AN000; No ITEM_TAG found
;**** Return code
;
; following return code will be returned in the AX register.

$P_No_Error	   equ	0		;AN000; No error
$P_Too_Many	   equ	1		;AN000; Too many operands
$P_Op_Missing	   equ	2		;AN000; Required operand missing
$P_Not_In_SW	   equ	3		;AN000; Not in switch list provided
$P_Not_In_Key	   equ	4		;AN000; Not in keyword list provided
$P_Out_Of_Range    equ	6		;AN000; Out of range specified
$P_Not_In_Val	   equ	7		;AN000; Not in value list provided
$P_Not_In_Str	   equ	8		;AN000; Not in string list provided
$P_Syntax	   equ	9		;AN000; Syntax error
$P_RC_EOL	   equ	-1		;AN000; End of command line

		   PAGE 		;AN000;
;********************** Local Data *************************************
$P_ORDINAL	   dw	0		;AN000; Operand ordinal save area
$P_RC		   dw	0		;AN000; Return code from parser
$P_SI_Save	   dw	0		;AN000; Pointer of command buffer
$P_DX		   dw	0		;AN000; Return result buffer address
$P_Terminator	   db	0		;AN000; Terminator code (ASCII)
$P_DBCSEV_OFF	   dw	0		;AN000; Offset of DBCS EV
$P_DBCSEV_SEG	   dw	0		;AN000; Segment of DBCS EV
$P_Flags	   dw	0		;AN000; Parser internal flags
$P_Flags1	   equ	byte ptr $P_Flags ;AN038; to reference first byte flags
$P_Flags2	   equ	byte ptr $P_Flags+1 ;AN038; to reference second byte flags only

;in second byte of $P_Flags, referenced as $P_Flags2:
$P_equ		   equ	01h	      ;AN000; "=" packed in string buffet
$P_Neg		   equ	02h	      ;AN000; Negative value
$P_Time12	   equ	04h	      ;AN000; set when PM is specified
$P_Key_Cmp	   equ	08h	      ;AN000; set when keyword compare
$P_SW_Cmp	   equ	10h	      ;AN000; set when switch compare
$P_Extra	   equ	20h	      ;AN000; set when extra delimiter found
$P_SW		   equ	40h	      ;AN000; set when switch found (tm08)
$P_Signed	   equ	80h	      ;AN000; signed numeric specified

;in first byte of $P_Flags, referenced as $P_Flags1:
$P_time12am	   equ	01h	      ;AN038; set when AM is specified on time
$P_TIME_AGAIN	   EQU	02H	      ;AN039; SET WHEN READY TO RE-PARSE TIME

$P_SaveSI_Cmpx	   dw	0		;AN000; save si for later use by complex
$P_KEYorSW_Ptr	   dw	0		;AN000; points next to "=" or ":" code
$P_Save_EOB	   dw	0		;AN000; save pointer to EOB
$P_Found_SYNONYM   dw	0		;AN000; es:@ points to found synonym

$P_STRING_BUF	   db	128 dup(0)	;AN000; Pick a operand from command line
$P_STRING_BUF_END  equ	$		;AN000;
IF		   TimeSw		;AN039; For TIME only
$P_ORIG_ORD	   DW	0		;AN039; ORIGINAL ORDINAL FROM CX
$P_ORIG_STACK	   DW	0		;AN039; ORIGINAL VALUE OF STACK FROM SP
$P_ORIG_SI	   DW	0		;AN039; ORIGINAL START PARSE POINTER FROM SI
ENDIF					;AN039;
IF		   DateSw+TimeSw	;AN000;(Check if date or time format is supported)
;------------------------------
;
$P_Got_Time	   db	0		;AN023; if 1, use Time delimiters
$P_NeedToBeRead    equ	0ffffh		;AN000;

$P_COUNTRY_INFO    $P_CDI <$P_NeedToBeRead> ;AN000;
;
$P_1st_Val	   dw	0		;AN000; used when process date or time
$P_2nd_Val	   dw	0		;AN000; used when process date or time
$P_3rd_Val	   dw	0		;AN000; used when process date or time
$P_4th_Val	   dw	0		;AN000; used when process date or time
;------------------------------
ENDIF					;AN000;(of DateSW+TimeSW)
$P_Char_CAP_Ptr    db	0ffh		;AN000; info id
		   dw	0		;AN000; offset	of char case map table
		   dw	0		;AN000; segment of char case map table
IF		   CAPSW		;AN000;(Check if uppercase conversion is supported)
$P_File_CAP_Ptr    db	0ffh		;AN000; info id
		   dw	0		;AN000; offset	of file case map table
		   dw	0		;AN000; segment of file case map table
ENDIF					;AN000;(of CAPSW)
; (tm06) IF	   FileSW		;AN000;(Check if file spec is supported)
;

;M029
;!!!WARNING!!!
; In routine SYSPARSE (parse.asm), $P_FileSp_Char is reinitialized using 
;hardcoded strings. If the chars in the string are changed here, corresponding
;changes need to be made in SYSPARSE
;
IF		   FileSW+DrvSW 	;AN000;(Check if file spec is supported)
$P_FileSp_Char	   db	'[]|<>+=;"'     ;AN000; delimitter of file spec
$P_FileSp_Len	   equ	$-$P_FileSp_Char ;AN000;
ENDIF					;AN000;(of FileSW)
; (tm05) IF	   QusSW		;AN000;(Check if quoted string is supported)
;(deleted ;AN025;) IF		      QusSW+CmpxSW	   ; (tm05) ;AN000;(Check if quoted string is supported)
;(deleted ;AN025;) $P_SorD_Quote      db   0		   ;AN000; keep double or single quote
;(deleted ;AN025;) ENDIF				   ;AN000;(of QueSW)
IF		   KeySW		;AN029; if keywords supported
$P_count_to_eol    dw	0		;AN029; count of chars not including EOL
;	REGISTER EQUATES - SPECIAL USAGE FOR REGISTERS
$P_REG_BH_CG_SW    EQU	BH		;AN029;0="NO CHANGES MADE", FF=CHANGES MADE
$P_REG_BL_DQ_SW    EQU	BL		;AN029;0=NOT IN QUOTES,FF=IN QUOTES

$P_DOUBLE_QUOTE    EQU	""""            ;AN029;
$P_BL_EQ	   EQU	" ="            ;AN029;
$P_EQ_BL	   EQU	"= "            ;AN029;
$P_TB_EQ	   EQU	093DH		;AN029; ;"<TAB>="
$P_EQ_TB	   EQU	3D09H		;AN029; ;"=<TAB>"
ENDIF					;AN029; IF KeySW Supported

; delimiter parsing
$P_colon_period    equ	01		;AN032; check for colon & period
$P_period_only	   equ	02		;AN032; check only for period

;filespec error flag
$P_err_flag	   db	00		;AN033; flag set if filespec parsing error
					;AN033;  was detected.
$P_error_filespec  equ	01		;AN033; mask to set flag
;***********************************************************************


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\sf.inc ===
BREAK <Internal system file table format>

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	SF.INC - System File Table
;
;   AN000   version 4.00   Jan. 1988
;   AN003   PTM 3680 --  make NAME offset the same as before (<=3.30)
;   AN009   PTM 3839	 reorder SFT for MS WINDOWS


;**	System File Table SuperStructure
;
;	The system file table entries are allocated in contiguous groups.
;	There may be more than one such groups; the SF "superstructure"
;	tracks the groups.

SF		STRUC
SFLink		DD	?
SFCount 	DW	?		; number of entries
SFTable 	DW	?		; beginning of array of the following
SF		ENDS


;**	System file table entry
;
;	These are the structures which are at SFTABLE in the SF structure.

sf_entry	STRUC
sf_ref_count	DW	?		; number of processes sharing entry
					;   if FCB then ref count
sf_mode 	DW	?		; mode of access or high bit on if FCB
sf_attr 	DB	?		; attribute of file
sf_flags	DW	?		;Bits 8-15
					; Bit 15 = 1 if remote file
					;	 = 0 if local file or device
					; Bit 14 = 1 if date/time is not to be
					;   set from clock at CLOSE.  Set by
					;   FILETIMES and FCB_CLOSE.  Reset by
					;   other reseters of the dirty bit
					;   (WRITE)
					; Bit 13 = Pipe bit (reserved)
					;
					; Bits 0-7 (old FCB_devid bits)
					; If remote file or local file, bit
					; 6=0 if dirty Device ID number, bits
					; 0-5 if local file.
					; bit 7=0 for local file, bit 7
					;      =1 for local I/O device
					; If local I/O device, bit 6=0 if EOF (input)
					;		Bit 5=1 if Raw mode
					;		Bit 0=1 if console input device
					;		Bit 1=1 if console output device
					;		Bit 2=1 if null device
					;		Bit 3=1 if clock device
sf_devptr	DD	?		; Points to DPB if local file, points
					; to device header if local device,
					; points to net device header if
					; remote
sf_firclus	DW	?		; First cluster of file (bit 15 = 0)
sf_time 	DW	?		; Time associated with file
sf_date 	DW	?		; Date associated with file
sf_size 	DD	?		; Size associated with file
sf_position	DD	?		; Read/Write pointer or LRU count for FCBs
;
; Starting here, the next 7 bytes may be used by the file system to store an
; ID
;
sf_cluspos	DW	?		; Position of last cluster accessed
sf_dirsec	DD	?		; Sector number of directory sector for
					; for this file
sf_dirpos	DB	?		; Offset of this entry in the above
;
; End of 7 bytes of file-system specific info.
;
sf_name 	DB	11 DUP (?)	; 11 character name that is in the
					; directory entry.  This is used by
					; close to detect file deleted and
					; disk changed errors.

; SHARING INFO
sf_chain	DD	?		; link to next SF
sf_UID		DW	?
sf_PID		DW	?
sf_MFT		DW	?
sf_lstclus	DW	?		;AN009; Last cluster accessed
sf_IFS_HDR	DD	?
sf_entry	ENDS

sf_fsda 	EQU	BYTE PTR sf_cluspos	     ;DOS 4.00
sf_serial_ID	EQU	WORD PTR sf_firclus	     ;DOS 4.00
sf_netid	EQU	BYTE PTR sf_cluspos
sf_OpenAge	EQU	WORD PTR sf_position+2
sf_LRU		EQU	WORD PTR sf_position

sf_default_number   EQU     5h

;
; Note that we need to mark an SFT as being busy for OPEN/CREATE.  This is
; because an INT 24 may prevent us from 'freeing' it.  We mark this as such
; by placing a -1 in the ref_count field.
;

sf_busy EQU -1


; mode mask for FCB detection
sf_isfcb		EQU	1000000000000000B

; Flag word masks
sf_isnet		EQU	1000000000000000B
sf_close_nodate 	EQU	0100000000000000B
sf_pipe 		EQU	0010000000000000B
sf_no_inherit		EQU	0001000000000000B
sf_net_spool		EQU	0000100000000000B

;**RMFHFE** Handle_Fail_I24 	EQU	0000000100000000B  ;BIT 8 - DISK FULL I24 ERROR


; Local file/device flag masks
devid_file_clean	EQU	40h	; true if file and not written
devid_file_mask_drive	EQU	3Fh	; mask for drive number

devid_device		EQU	80h	; true if a device
devid_device_EOF	EQU	40h	; true if end of file reached
devid_device_raw	EQU	20h	; true if in raw mode
devid_device_special	EQU	10h	; true if special device
devid_device_clock	EQU	08h	; true if clock device
devid_device_null	EQU	04h	; true if null device
devid_device_con_out	EQU	02h	; true if console output
devid_device_con_in	EQU	01h	; true if consle input

;
; structure of devid field as returned by IOCTL is:
;
;	BIT	7   6	5   4	3   2	1   0
;	      |---|---|---|---|---|---|---|---|
;	      | I | E | R | S | I | I | I | I |
;	      | S | O | A | P | S | S | S | S |
;	      | D | F | W | E | C | N | C | C |
;	      | E |   |   | C | L | U | O | I |
;	      | V |   |   | L | K | L | T | N |
;	      |---|---|---|---|---|---|---|---|
;	ISDEV = 1 if this channel is a device
;	      = 0 if this channel is a disk file
;
;	If ISDEV = 1
;
;	      EOF = 0 if End Of File on input
;	      RAW = 1 if this device is in Raw mode
;		  = 0 if this device is cooked
;	      ISCLK = 1 if this device is the clock device
;	      ISNUL = 1 if this device is the null device
;	      ISCOT = 1 if this device is the console output
;	      ISCIN = 1 if this device is the console input
;
;	If ISDEV = 0
;	      EOF = 0 if channel has been written
;	      Bits 0-5	are  the  block  device  number  for
;		  the channel (0 = A, 1 = B, ...)
;
devid_ISDEV	EQU	80h
devid_EOF	EQU	40h
devid_RAW	EQU	20h
devid_SPECIAL	EQU	10H
devid_ISCLK	EQU	08h
devid_ISNUL	EQU	04h
devid_ISCOT	EQU	02h
devid_ISCIN	EQU	01h

devid_block_dev EQU	1Fh		; mask for block device number

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\smdossym.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;	SCCSID = @(#)dossym.asm 1.1 85/04/10
;	SCCSID = @(#)dossym.asm 1.1 85/04/10

	ERROR - who uses this?	Not DOS and kernel.  Whoever uses this
		should use DOSSYM instead.  See JGL if there's a problem

;	PAGE 80,132
TRUE	    EQU 0FFFFh
FALSE	    EQU 0

Installed   = TRUE
IFNDEF	DEBUG
    DEBUG	= FALSE
ENDIF

include dosmac.INC
INCLUDE VERSIONA.INC		;DEFINE THE MAJOR AND MINOR VERSION NUMBERS

IF2
;    %OUT    DOSSYM in Pass 2
ENDIF

BREAK <Control character definitions>

c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
c_BS	    EQU     08h 		; ^H ASCII backspace
c_CR	    EQU     0Dh 		; ^M ASCII carriage return
c_LF	    EQU     0Ah 		; ^J ASCII linefeed
c_ETB	    EQU     17h 		; ^W ASCII end of transmission
c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
c_ETX	    EQU     03h 		; ^C ASCII end of text
c_HT	    EQU     09h 		; ^I ASCII tab

BREAK <Read This and Weep>

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
; Certain structures, constants and system  calls  below  are  private	to ;
; the DOS  and	are  extremely	version-dependent.  They may change at any ;
; time at  the	implementors'  whim.   As  a  result,  they  must  not  be ;
; documented to  the  general  public.	 If  an  extreme case arises, they ;
; must be documented with this warning. 				   ;
;									   ;
; Those structures and constants that are subject to  the  above  will	be ;
; marked and bracketed with the flag:					   ;
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

include bpb.INC

include buffer.INC

BREAK <User stack inside of system call and SysVars>
; Location of user registers relative user stack pointer

user_environ	STRUC
user_AX     DW	    ?
user_BX     DW	    ?
user_CX     DW	    ?
user_DX     DW	    ?
user_SI     DW	    ?
user_DI     DW	    ?
user_BP     DW	    ?
user_DS     DW	    ?
user_ES     DW	    ?
user_IP     DW	    ?
user_CS     DW	    ?
user_F	    DW	    ?
user_environ	ENDS

include sysvar.INC

include vector.INC

;include mult.INC

BREAK <Disk map>
;  MSDOS partitions the disk into 4 sections:
;
;  phys sector 0:   +-------------------+
;	|	    | boot/reserved	|
;	|	    +-------------------+
;	|	    |  File allocation	|
;	v	    |	   table(s)	|
;		    |  (multiple copies |
;		    |	  are kept)	|
;		    +-------------------+
;		    |	  Directory	|
;		    +-------------------+
;		    |	  File space	|
;		    +-------------------+
;		    |	Unaddressable	|
;		    |  (to end of disk) |
;		    +-------------------+
;
; All partition boundaries are sector boundaries.  The size of the FAT is
; adjusted to maximize the file space addressable.

include dirent.INC

BREAK <File allocation Table information>
;
; The File Allocation Table uses a 12-bit entry for each allocation unit on
; the disk.  These entries are packed, two for every three bytes.  The contents
; of entry number N is found by 1) multiplying N by 1.5; 2) adding the result
; to the base address of the Allocation Table; 3) fetching the 16-bit word
; at this address; 4) If N was odd (so that N*1.5 was not an integer), shift
; the word right four bits; 5) mask to 12 bits (AND with 0FFF hex).  Entry
; number zero is used as an end-of-file trap in the OS and is passed to the
; BIOS to help determine disk format.  Entry 1 is reserved for future use.
; The first available allocation unit is assigned entry number two, and even
; though it is the first, is called cluster 2.	Entries greater than 0FF8H
; (12-bit fats) or 0FFF8H (16-bit fats) are end of file marks; entries of zero
; are unallocated.  Otherwise, the contents of a FAT entry is the number of
; the next cluster in the file.
;
; Clusters with bad sectors are tagged with FF7H.  Any non-zero number would
; do because these clusters show as allocated, but are not part of any
; allocation chain and thus will never be allocated to a file.	A particular
; number is selected so that disk checking programs know what to do (ie.  a
; cluster with entry FF7H which is not in a chain is not an error).

include dpb.INC

include curdir.INC

;include cpmfcb.INC

;include find.INC

include pdb.INC

include exe.INC

include sf.INC

include arena.INC

include intnat.INC

include mi.INC

fChk	equ 1
fDelim	equ 2
fSpChk	equ 4
fFCB	equ 8

;include filemode.INC

;include error.INC

include syscall.INC

include doscntry.inc		;J.K. 5/26/86

SUBTTL


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\smifssym.inc ===
;	PAGE	60,132
;	SCCSID = @(#)smifssym.inc 1.0 87/05/11

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;
;   Modification history:
;	Created: May 11 1987 
;
;	SMifssym is only for IBMBIO.  It will only has definitions
;	for IFSHEADER, IFSRH of INIT function.
;	When ifssym.inc is Revised, make sure that SMifssym.inc
;	is also correct. - JK.
;

;==================
;IFS drive header
;=================

    IFSDEVICE	EQU	8000H	;  Supports single device/file functions
    IFSDISK	EQU	4000H	;  Supports multi-file functions
    IFSUNC	EQU	2000H	;  Support UNC (nameless) connection
    IFSREMOTE	EQU	0800H	;  File system is remote
    IFSFILTER	EQU	0400H	;  FS will filter (if off, use DOS
				;    standard, cap & 8.3)
    IFSIOCTL	EQU	0002H	;  Supports IOCTL functions
    IFSUSESHARE EQU	0001H	;  Uses DOS share support (vs own share)

IFSHEADER	STRUC
IFS_NEXT	DD	-1	; Next header in list (-1=end)
IFS_NAME	DB	"        " ; IFS name
IFS_ATTRIBUTE	DW	?	; Attributes
IFS_VERSION	DW	0	; Request level supported
IFS_DOSCALL@	DD	?	; DOS interface routine
				;   (set by TUPPER before the init call)
IFS_CALL@	DW	?	; Function entry point
IFSHEADER	ENDS

;=====================
; IFS Request Header
;=====================

IFSRH		STRUC
IFSR_LENGTH	DW    ? 		; Total length of request
IFSR_FUNCTION	DB    ? 		; Requested function
IFSR_RETCODE	DB    ? 		; Explicit error
IFSR_RETCLASS	DB    ? 		; Error class
IFSR_RESV1	DB    17 DUP(0) 	; DOS reserved
IFSR_FCN_PARMS	DB    38 DUP(0) 	; Additional parameters
IFSRH		ENDS

; IFSR_FUNCTION codes
;	Control requests:
IFSINIT        EQU     1
IFSATTSTART    EQU     2
IFSATTEND      EQU     3
IFSEXECAPI     EQU     4
IFSCRITMSG     EQU     5
IFSCBUPDATE    EQU     6
; INIT function.
IFSR_PARMS@	   =  DWORD PTR  IFSR_FCN_PARMS    ; command parameters
IFSR_RESSIZE	   =  WORD  PTR  IFSR_FCN_PARMS+4  ; driver total size
LENGTH_INIT	   EQU IFSR_RESSIZE-IFSRH+2


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\sysvar.inc ===
;	SCCSID = @(#)sysvar.asm 1.1 85/04/10

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

SysInitVars STRUC
SYSI_DPB	    DD	    ?		; DPB chain
SYSI_SFT	    DD	    ?		; SFT chain
SYSI_CLOCK	    DD	    ?		; CLOCK device
SYSI_CON	    DD	    ?		; CON device
SYSI_MAXSEC	    DW	    ?		; maximum sector size
SYSI_BUF	    DD	    ?		; points to Hashinitvar
SYSI_CDS	    DD	    ?		; CDS list
SYSI_FCB	    DD	    ?		; FCB chain
SYSI_Keep	    DW	    ?		; keep count
SYSI_NUMIO	    DB	    ?		; Number of block devices
SYSI_NCDS	    DB	    ?		; number of CDS's
SYSI_DEV	    DD	    ?		; device list
SYSI_ATTR	    DW	    ?		; null device attribute word
SYSI_STRAT	    DW	    ?		; null device strategy entry point
SYSI_INTER	    DW	    ?		; null device interrupt entry point
SYSI_NAME	    DB	 8 DUP(?)	; null device name
SYSI_SPLICE	    DB	    0		; TRUE -> splicees being done
SYSI_IBMDOS_SIZE    DW	    ?		; DOS size in paragraphs
SYSI_IFS_DOSCALL@   DD	    ?		; IFS DOS service rountine entry
SYSI_IFS	    DD	    ?		; IFS header chain
SYSI_BUFFERS	    DW	    ?,0 	; BUFFERS= values (m,n)
SYSI_BOOT_DRIVE     DB	    ?		; boot drive A=1 B=2,..
SYSI_DWMOVE	    DB	    0		; 1 if 386 machine
SYSI_EXT_MEM	    DW	    0		; Extended memory size in KB.
SysInitVars ENDS

;This is added for more information exchage between DOS, BIOS.
;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86
SysInitVars_Ext struc
SYSI_InitVars		DD	0	; Points to the above structure.
SYSI_Country_Tab	DD	0	; DOS_Country_cdpg_info
SysInitVars_Ext ends

;The SYSI_BUF of SysInitVars points to the follwong structure
EMS_MAP_BUFF_SIZE      EQU	12	; EMS map buffer size

Buffinfo    STRUC
Buff_Queue	 DD	 ?		     ; Head of list of buffers
Dirty_Buff_Count DW	 ?		     ; number of dirty buffers in list
Cache_ptr	 DD	 ?		     ; pointer to secondary cache
Cache_count	 DW	 0		     ; number of secondary cache entries

Buff_In_HMA	db	0		     ; flag to indicate that buffers
					     ; are in HMA
Lo_Mem_Buff	dd	0		     ; Ptr to scratch buff in Low Mem
					     ;  used to read/write on disks

;smr; removal of BUFFERFLAG; IF	BUFFERFLAG

UU_EMS_FIRST_PAGE	DW	0, 0
UU_EMS_NPA640	DW	0

;smr; removal of BUFFERFLAG; ENDIF

UU_EMS_mode	 DB	 -1		     ; no EMS = -1
UU_EMS_handle	 DW	 ?		     ; EMS handle for buffers
UU_EMS_PageFrame_Number	DW   -1 	     ; EMS page frame number
UU_EMS_Seg_Cnt	 DW	 1		     ; EMS segment count
UU_EMS_Page_Frame	 DW	 -1		     ; EMS page frame segment address
UU_EMS_reserved	 DW	 0		     ; EMS segment count

;smr; removal of BUFFERFLAG; IF	BUFFERFLAG
UU_EMS_Map_Buff	 DB	 0  ; map buffer
;smr; removal of BUFFERFLAG; ELSE
;smr; removal of BUFFERFLAG; EMS_Map_Buff	DB	12 dup(0)
;smr; removal of BUFFERFLAG; ENDIF

Buffinfo    ENDS

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\sysmsg.inc ===
;	PAGE	,132
	SUBTTL	DOS - Message Retriever - SYSTEM CONTROL file

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DOS -- Message Retriever
;; (c) Copyright 1988 Microsoft
;;
;; File Name:	SYSMSG.INC
;; ----------
;;
;; Description: Message retriever functions are included into source code
;; ------------ by referencing a MSG_SERVICES macro. That macro is defined
;;		here as well as the logic to include necessary .ASM and .INC
;;		files.
;;
;;
;; Documentation Reference:
;; ------------------------
;;		DOS -Message Retriever I0 Document - Feb. ?? 1987
;;		DOS -Message Retriever I1 Document - Mar. ?? 1987
;;		DOS -Message Retriever I2 Document - Mar. ?? 1987
;;		DOS -Final Functional Specification Document - Mar ?? 1987
;;
;; Procedures Contained in This File:
;; ---------------------------------
;;		None
;;
;; Include Files Required:
;; -----------------------
;;		MSGSERV.INC	   := All message services
;;		????		   := ????
;;
;; External Procedure References:
;; ------------------------------
;;		None
;;
;; Linkage Instructions:
;; --------------------
;;		None
;;
;; Change History:
;; ---------------
;;		CREATED 	March, 1987	RPS
;;
;; Psuedocode:
;; -----------
;;		None
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
INCLUDE        VERSIONA.INC	       ;;AN003;;

FALSE	       = 0		       ;;
TRUE	       = NOT FALSE	       ;;    List message services and flags
				       ;;

; Control Characters For Message Skeleton file

NULL			EQU	00H    ;; Null
BELL			EQU	07H    ;; Bell
TAB			EQU	09H    ;; Tab
LF			EQU	0AH    ;; Line Feed
HOME			EQU	0BH    ;; Home
FORMFD			EQU	0CH    ;; Form Feed
CR			EQU	0DH    ;; Carriage Return
COLON			EQU	3AH    ;; Colon

; SYSDISPMSG and SYSGETMSG Equates

MSG_SER_CLASS		EQU	00H    ;; Message Service Class (reserved)
EXT_ERR_CLASS		EQU	01H    ;; DOS Extended error class
PARSE_ERR_CLASS 	EQU	02H    ;; Parse error class
UTILITY_MSG_CLASS	EQU	0FFH   ;; Utility message class

NO_HANDLE		EQU	0FFFFH ;; No handle specified (Use DOS functions 01H-09H only)

NO_REPLACE		EQU	0000H  ;; No replacable parameters

; SUBLIST Equates

  Sublist_Length	EQU	11     ;; Length of sublist structure
  Reserved		EQU	0      ;; Reserved byte field

  Left_Align		EQU	0      ;;00xxxxxx
  Right_Align		EQU	80h    ;;10xxxxxx

  Char_type		EQU	0      ;;axxx0000 - Character type
  Char_Field_Char	EQU	0      ;;a0000000
  Char_Field_ASCIIZ	EQU	10h    ;;a0010000

  Unsgn_Bin_Type	EQU	01h    ;;axxx0001 - Unsigned Binary to Decimal character
  Unsgn_Bin_Byte	EQU	11h    ;;a0010001
  Unsgn_Bin_Word	EQU	21h    ;;a0100001
  Unsgn_Bin_DWord	EQU	31h    ;;a0110001

  Sgn_Bin_Type		EQU	02h    ;;axxx0010 - Signed Binary to Decimal character
  Sgn_Bin_Byte		EQU	12h    ;;a0010010
  Sgn_Bin_Word		EQU	22h    ;;a0100010
  Sgn_Bin_DWord 	EQU	32h    ;;a0110010

  Bin_Hex_Type		EQU	03h    ;;axxx0011 - Unsigned Binary to Hexidecimal character
  Bin_Hex_Byte		EQU	13h    ;;a0010011
  Bin_Hex_Word		EQU	23h    ;;a0100011
  Bin_Hex_DWord 	EQU	33h    ;;a0110011

  Date_Type		EQU	04h    ;;axxx0100 - Date to character using current country format
  Date_MD		EQU	14h    ;;a0010100
  Date_MDY_2		EQU	24h    ;;a0100100
  Date_MDY_4		EQU	34h    ;;a0110100

  Time_Cty_Type 	EQU	05h    ;;axxx0101 - Time to character using current country format
  Time_HHMM_Cty 	EQU	05h    ;;a0000101
  Time_HHMMSS_Cty	EQU	15h    ;;a0010101
  Time_HHMMSSHH_Cty	EQU	25h    ;;a0100101

  Time_24_Type		EQU	06h    ;;axxx0110 - Time to character using 24 hour format
  Time_HHMM_24		EQU	06h    ;;a0000110
  Time_HHMMSS_24	EQU	16h    ;;a0010110
  Time_HHMMSSHH_24	EQU	26h    ;;a0100110

  $M_EXTPAR_Type	EQU	08h    ;;axxx1000 - Special case for extended parse replace format

NO_INPUT		EQU	00H    ;; No input characters
DOS_KEYB_INP		EQU	01H    ;; DOS INT 21H - AH=01H := Keyboard Input
DOS_DIR_CON_INP 	EQU	07H    ;; DOS INT 21H - AH=07H := Direct Console Input Without Echo
DOS_CON_INP		EQU	08H    ;; DOS INT 21H - AH=08H := Console Input Without Echo (Check CTL-BK)
DOS_BUF_KEYB_INP	EQU	0AH    ;; DOS INT 21H - AH=0AH := Buffered Keyboard Input
DOS_CLR_KEYB_BUF	EQU	0CH    ;; DOS INT 21H - AH=0CH := Clear keyboard buffer
DOS_WRITE_HANDLE	EQU	40H    ;; DOS INT 21H - AH=40H := Write to a DOS handle
DOS_DISP_STRING 	EQU	09H    ;; DOS INT 21H - AH=09H := Display $ terminated string
DOS_DISP_CHAR		EQU	02H    ;; DOS INT 21H - AH=02H := Display Character
LOWEST_4CH_VERSION	EQU	0002H  ;; First DOS version to allow AH = 4CH Exit (VERSION 2.00)

DOS_GET_DBCS_INFO	EQU   6300H    ;; DOS INT 21H - AX=6507H := Get DBCS Vector Table
DOS_GET_EXT_ERROR	EQU	59H    ;; DOS INT 21H - AH=59H := Get Extended Error
DOS_GET_EXT_ERROR_BX	EQU	00H    ;; DOS INT 21H - BX=0000H := Version 0

DOS_EXTENDED_OPEN	EQU   6C00H    ;AN003; DOS INT 21H - AX=6C00H := Extended Open
NO_CRIT_OPEN		EQU   2000H    ;AN003; Extended Open Mode bit
NOT_EX_FAIL_EX_OPEN	EQU   0101H    ;AN003; Extended Open Flag
DOS_LSEEK_FILE		EQU   4200H    ;AN003; DOS INT 21H - AX=4200H := LSEEK file
DOS_READ_BYTE		EQU	3FH    ;AN003; DOS INT 21H - AH=3FH   := Read byte block
DOS_CLOSE_FILE		EQU	3EH    ;AN003; DOS INT 21H - AH=3EH   := Close file handle

IFSFUNC_INSTALL_CHECK	EQU   0500H    ;AN006; IFSFUNC Installation Check
IFS_GET_ERR_TEXT	EQU   0502H    ;AN006; IFSFUNC Get Extended Error Text
IFSFUNC_INSTALLED	EQU    0FFH    ;AN006; Return code if IFSFUNC is installed

EXT_ERR_39		EQU	39     ;; Insufficent Disk Space EXTENDED ERROR (changed from hex to decimal - eg d201)
ERROR_CLASS_39		EQU	01H    ;;   Error Class = 1
ACTION_39		EQU	04H    ;;   Suggested Action = 4
LOCUS_39		EQU	01H    ;;   Locus = 1

DOS_GET_COUNTRY 	EQU	38H    ;; DOS INT 21H - AH=38H := Get Country Dependant Information
DOS_GET_VERSION 	EQU	30H    ;; DOS INT 21H - AH=30H := Get DOS Version number
DOS_IOCTL_GET_INFO	EQU	4400H  ;; DOS INT 21H - AH=4400H := I/O control for devices
DOS_IOCTL_SET_INFO	EQU	4401H  ;; DOS INT 21H - AH=4401H := I/O control for devices
DOS_GET_EXT_PARSE_ADD	EQU	122EH  ;; DOS INT 2FH - AX=122EH := Get Extended/Parse error address
DOS_GET_EXTENDED	EQU	00     ;; DOS INT 2FH - AX=122EH - DL=00 := Get Extended address
DOS_GET_PARSE		EQU	02     ;; DOS INT 2FH - AX=122EH - DL=02 := Get Parse address
DOS_GET_CRITICAL	EQU	04     ;; DOS INT 2FH - AX=122EH - DL=04 := Get Critical address
DOS_GET_FILE		EQU	06     ;; DOS INT 2FH - AX=122EH - DL=06 := Get File system dependant
DOS_GET_ADDR		EQU	08     ;; DOS INT 2FH - AX=122EH - DL=08 := Get Address of READ_DISK_PROC
DOS_SET_ADDR		EQU	09     ;; DOS INT 2FH - AX=122EH - DL=09 := Set Address of READ_DISK_PROC
LOW_NIB_MASK		EQU	0FH    ;; Mask out the high byte
DOS_CLR_KEYB_BUF_MASK	EQU	0C0H   ;; Check if high nibble is C Hex
$M_CON_INP		EQU	-1     ;; If DOS INT 21H Function 06H - DL := 0FFH for input
$M_CRIT_LO		EQU	19     ;; First Extended Error considered CRITICAL
$M_CRIT_HI		EQU	39     ;; Last Extended Error considered CRITICAL (EG - D191)
$M_AM			EQU	"a"    ;; Time format AM indicator
$M_PM			EQU	"p"    ;; Time format PM indicator
$M_NEG_SIGN		EQU	"-"    ;; Signed decimal number format negative indicator
$M_DEF_TIME_FORM	EQU	 1     ;; Default Time format - 24 hour
$M_DEF_DATE_FORM	EQU	 0     ;; Default Time format - 0 := USA format
$M_DEF_TIME_SEP 	EQU	":"    ;; Default Time separator - ":"
$M_DEF_DATE_SEP 	EQU	"-"    ;; Default Time separator - "-"
$M_DEF_DECI_SEP 	EQU	"."    ;; Default Time hundreds separator - "."
$M_TIMEDATE_PAD 	EQU	"0"    ;; Time/Date PAD character - "0" (ie 12:03p)
$M_MAX_2_YEAR		EQU	99     ;; Maximum 2 digit year
$M_SINGLE_CHAR		EQU	1      ;; A single character is this long      ^
$M_SPECIAL_CASE 	EQU	30H    ;; Special case for replacable parameters %0
$M_UNLIM_W		EQU	0      ;; Unlimited width character
$M_COMMA		EQU	","    ;; Default Thousand separate
$M_CR_LF		EQU	0A0DH  ;; Default CR/LF
$M_SPACE_HYP		EQU	"- "   ;; Default Space/Hyphan
$M_SPACE		EQU	" "    ;; Default Space
$M_NULL 		EQU	0      ;; Null
$M_FIRST_THOU		EQU	3      ;; Location of first thousand separator
$M_SECOND_THOU		EQU	6      ;; Location of second thousand separator
$M_THIRD_THOU		EQU	9      ;; Location of third thousand separator
$M_BASE10		EQU	10     ;; Base 10 for arthmetic
$M_BASE16		EQU	16     ;; Base 16 for arthmetic
$M_CLASS_NOT_EXIST	EQU	 0     ;; Does class exist?
$M_TERMINATING_FLAG	EQU	-1     ;; Is there any more classes?
$M_ADDR_SZ_NEAR 	EQU	2      ;; Size to increment if NEAR
$M_ADDR_SZ_FAR		EQU	4      ;; Size to increment if FAR
$M_SL			EQU   DS:[SI]  ;; Refer to SUBLIST as $M_SL
$M_NO_HANDLE		EQU	-1     ;; No handle flag
$M_TEMP_BUF_SZ		EQU	64     ;; Size of temporary buffer	 ;AN003;
$M_NEXT_DBCS_VECTOR	EQU	2      ;; Amount to increment to get next vector
$M_DBCS_TERM		EQU    0000    ;; DBCS vector table terminating flag
$M_SPECIAL_MSG_NUM	EQU    0FFFFH  ;; Special generic message number
$M_CRLF_SIZE		EQU    2       ;; Size of the CR LF message
$M_NO_CRLF_MASK 	EQU  10000000B ;; Mask to supress CR LF
$M_ONE_REPLACE		EQU    1       ;; Indicate one replacement
$M_CRIT_ERR_MASK	EQU  00000001B ;; Mask to allow EOF/EOI Crit error
				       ;;
$M_ALIGN_MASK		EQU  10000000b ;; Mask for align
$M_TYPE_MASK		EQU  00001111b ;; Mask for types
$M_SIZE_MASK		EQU  00110000b ;; Mask for types
$M_TIME_MASK		EQU  00000001b ;; Mask for TIME
$M_DATE_MASK		EQU  00010000b ;; Mask for TIME
$M_BYTE 		EQU  00010000b ;; BYTE indicator
$M_WORD 		EQU  00100000b ;; WORD indicator
$M_DWORD		EQU  00110000b ;; DWORD indicator

; Standard reserved DOS handles

STDIN			EQU	0000H  ;; Standard Input device handle
STDOUT			EQU	0001H  ;; Standard Output device handle
STDERR			EQU	0002H  ;; Standard Error Output device handle
STDAUX			EQU	0003H  ;; Standard Auxiliary device handle
STDPRN			EQU	0004H  ;; Standard Printer device handle

; Reserved Message Service equates

NEARmsg 		 =	TRUE   ;; \
NOVERCHECKmsg		 =	FALSE  ;;  |
MSGDATA 		 =	FALSE  ;;  |
FARmsg			 =	FALSE  ;;  |
GETmsg			 =	FALSE  ;;  |
LOADmsg 		 =	FALSE  ;;  |
DISPLAYmsg		 =	FALSE  ;;   } Set default cases
SETSTDIO		 =	FALSE  ;;  |
NOCHECKSTDIN		 =	FALSE  ;;  |
NOCHECKSTDOUT		 =	FALSE  ;;  |
DISK_PROC		 =	FALSE  ;;  |			       ;AN003;
INPUTmsg		 =	FALSE  ;;  |
CHARmsg 		 =	FALSE  ;;  |
NUMmsg			 =	FALSE  ;;  |
TIMEmsg 		 =	FALSE  ;;  |
DATEmsg 		 =	FALSE  ;; /

IF1				       ;;
COMR			 =	FALSE  ;;  COMMAND.COM Cases (resident)
COMT			 =	FALSE  ;;		     (transient)
ENDIF				       ;;

$M_STRUC		 =	TRUE   ;; Internal message service defaults
$M_LOAD 		 =	TRUE   ;;
$M_SUBS 		 =	TRUE   ;;
$M_REPLACE		 =	TRUE   ;;
$M_REPL_DONE		 =	FALSE  ;;
$M_CHAR_ONLY		 =	TRUE   ;;
$M_PARSE_FLAG		 =	TRUE   ;;
$M_EXT_ERR_FLAG 	 =	TRUE   ;;
$M_MSGDATA_ONLY 	 =	TRUE   ;;
$M_END			 =	FALSE  ;;
$M_EXT_CLS		 =	TRUE   ;;
$M_PAR_CLS		 =	TRUE   ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	$M_POPF 	     Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

$M_POPF    MACRO
	   LOCAL   $M_MYRET
	   JMP	   $+3
$M_MYRET   LABEL   NEAR
	   IRET
	   PUSH    CS
	   CALL    $M_MYRET
ENDM

; This Macro was removed from sysmsg.inc. We had to remove this
; macro and put it into it's own include file in order to clear up
; some assembly errors. MS MASM will not allow a public declaration
; during the second pass of the assembler. IBM MASM will allow this.
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	$M_DECLARE	     Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				       ;
;$M_DECLARE    macro	numcls	       ;
;   $M_DCOUNT = 0		       ;
;   REPT  numcls 		       ;
;     $M_DCOUNT =  $M_DCOUNT + 1        ;
;     $M_DECLARE2  %$M_DCOUNT	       ;
;   ENDM 			       ;
;
;  IF COMR
;    IFNDEF $M_RT2			;  If Resident table is not in this assembly,
;	EXTRN	$M_RT2:BYTE		;     Must be external
;    ELSE
;	PUBLIC	$M_RT2
;    ENDIF				;
;  ELSE
;    IFNDEF $M_RT			;  If Resident table is not in this assembly,
;	EXTRN	$M_RT:BYTE		;     Must be external
;    ELSE
;	PUBLIC	$M_RT
;    ENDIF				;
;  ENDIF
;
;  $M_CHECK $M_GET_MSG_ADDRESS	      ;  If this subroutine is not in this assembly,
;  $M_CHECK $M_MSGSERV_1 	      ;  If this subroutine is not in this assembly,
;  $M_CHECK $M_MSGSERV_2 	      ;  If this subroutine is not in this assembly,
;
;ENDM				       ;
;				       ;
;$M_DECLARE2   macro   innum	       ;
;  IF NOT COMR			       ; IF Not resident COMMAND.COM
;    IF NOT COMT 			 ; IF Not transient COMMAND.COM
;      IFNDEF  $M_CLS_&innum		 ; IF class is not in this assembly,
;	IF	FARmsg			 ;
;	  EXTRN   $M_CLS_&innum:FAR	 ;    Must be external
;	ELSE				 ;
;	  EXTRN   $M_CLS_&innum:NEAR	 ;    Must be external
;	ENDIF				 ;
;      ELSE				 ; ELSE
;	PUBLIC	$M_CLS_&innum		 ;    Label PUBLIC
;      ENDIF				 ;
;    ELSE				 ; ELSE
;      IFDIF  <$M_CLS_&innum>,<$M_CLS_1>  ; IF NOT $M_CLS_1 or
;	IFDIF <$M_CLS_&innum>,<$M_CLS_2> ;   IF NOT $M_CLS_2 then
;	  IFNDEF  $M_CLS_&innum 	 ;     IF class is not in this assembly,
;	    IF	    FARmsg		 ;
;	      EXTRN   $M_CLS_&innum:FAR  ;	 Must be external
;	    ELSE			 ;
;	      EXTRN   $M_CLS_&innum:NEAR ;	 Must be external
;	    ENDIF			 ;
;	  ELSE				 ;     ELSE
;	    PUBLIC  $M_CLS_&innum	 ;	 Label PUBLIC
;	  ENDIF 			 ;
;	ENDIF				 ;
;      ENDIF				 ;
;    ENDIF				 ;
;  ELSE					 ; ELSE
;    IFDIF  <$M_CLS_&innum>,<$M_CLS_1>	 ; IF NOT $M_CLS_1 or
;      IFDIF <$M_CLS_&innum>,<$M_CLS_2>	 ;   IF NOT $M_CLS_2 then
;	IFNDEF	$M_CLS_&innum		 ;     IF class is not in this assembly,
;	  IF	  FARmsg		 ;
;	    EXTRN   $M_CLS_&innum:FAR	 ;	 Must be external
;	  ELSE				 ;
;	    EXTRN   $M_CLS_&innum:NEAR	 ;	 Must be external
;	  ENDIF 			 ;
;	ELSE				 ;     ELSE
;	  PUBLIC  $M_CLS_&innum 	 ;	 Label PUBLIC
;	ENDIF				 ;
;      ENDIF				 ;
;    ENDIF				 ;
;  ENDIF 			       ;
;ENDM				       ;
;				       ;
;$M_CHECK      macro   parm	       ;
;  IFNDEF  parm			       ; IF class is not in this assembly,
;    IF	    FARmsg		       ;
;      EXTRN   parm:FAR		       ;    Must be external
;    ELSE			       ;
;      EXTRN   parm:NEAR 	       ;    Must be external
;    ENDIF			       ;
;  ELSE
;    IF COMR
;    ELSE
;      PUBLIC parm
;    ENDIF
;  ENDIF 			       ;
;ENDM				       ;
;				       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				       ;
;IF2				       ;
;  $M_DECLARE %$M_NUM_CLS	       ;  Declare any class not in this assembly
;ENDIF				       ;
;				       ;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Message Retreiver requests
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;
MSG_UTILNAME  Macro   utilname	       ;
				       ;
   INCLUDE &utilname.CTL	       ;  Include the control file for the utility
   $M_STRUC = TRUE		       ;
   INCLUDE MSGSERV.ASM		       ;  Get structure definitions
				       ;
ENDM				       ;
				       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	MSG_SERVICES		Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					  ;
MSG_SERVICES Macro   varlist		  ;  MACRO used in source routine
					  ;
   $M_SERVICE = FALSE			  ;  Reset service flag
   IRP	   var,<varlist>		  ;  FOR each variable in the list
     $M_INCLUDE = TRUE			  ;  Reset include flag
					  ;	For each service predefined

IRP  serv,<MSGDATA,LOADmsg,NOVERCHECKmsg,DISPLAYmsg,GETmsg,INPUTmsg,CHARmsg,NUMmsg,TIMEmsg,DATEmsg,NEARmsg,FARmsg,COMR,COMT>

	 IFDIF <var>,<serv>		  ;	  IF it IS a service (defined above)
	 ELSE				  ;
	   IFDIF <var>,<MSGDATA>	  ;	    IF it is NOT the message data space request
	     $M_MSGDATA_ONLY = FALSE	  ;	       Instruct the assembler to include all services
	   ENDIF			  ;	    ENDIF
	   IRP	repl,<CHARmsg,NUMmsg,TIMEmsg,DATEmsg>  ; IF it is a replace service
	     IFIDN  <var>,<repl>	  ;
	       $M_REPLACE = TRUE	  ;	       Set replace flag
	     ENDIF			  ;
	   ENDM 			  ;
	   serv = TRUE			  ;	    Let the assembler know about the service
	   $M_SERVICE = TRUE		  ;	    Let the macro know it was a service
	   $M_INCLUDE = FALSE		  ;	    Let the macro know it wasn't a class
	 ENDIF				  ;	  ENDIF
      ENDM				  ;	NEXT service

MSG_SERVICES2  <varlist>
					  ; Continue further checks (If we add any more predefined
					  ;  function to the above IRP command, it generates a
					  ;  syntax error. We must continue the processing in another
					  ;  MACRO called MSG_SERVICES2)

      IF $M_INCLUDE			  ;	IF message class was requested
	 $M_INC var			  ;	   Include it as a message class
      ENDIF				  ;	ENDIF
   ENDM 				  ;  NEXT variable
					  ;
   IF $M_SERVICE			  ;	IF it any services were requested THEN
     INCLUDE MSGSERV.ASM		  ;	   THEN include module to get service
   ENDIF				  ;	ENDIF

ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	MSG_SERVICES2		Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					  ;
MSG_SERVICES2 Macro   varlist2		  ;  MACRO used in source routine
					  ;
					    ;  FOR each variable in the list
   IRP	   var2,<varlist2>
						       ; For each service predefined
      IRP  serv2,<SETSTDIO,NOCHECKSTDIN,NOCHECKSTDOUT,DISK_PROC>
					    ;AN003; IF it IS a service (defined above)
	 IFDIF <var2>,<serv2>
	 ELSE				  ;
	   serv2 = TRUE 		   ;	     Let the assembler know about the service
	   $M_SERVICE = TRUE		  ;	    Let the macro know it was a service
	   $M_INCLUDE = FALSE		  ;	    Let the macro know it wasn't a class
	 ENDIF				  ;	  ENDIF
      ENDM				  ;	NEXT service
   ENDM 				  ;  NEXT variable
ENDM					  ;
					  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; $M_INC		Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
						 ;
$M_INC	Macro	ext				 ;
						 ;
INCLUDE &ext					 ;
						 ;
ENDM						 ;
						 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; $M_BUILD_PTRS	Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
						 ;
$M_BUILD_PTRS Macro nummsg			 ;
						 ;
    $M_INDEX =	    0				 ;
IF COMR 				     ; IF this is resident COMMAND.COM
    $M_MAKE_COMR			     ;
ELSE						 ; ELSE
  IF COMT				     ;	 IF this is transient COMMAND.COM
    $M_MAKE_COMT			     ;
  ELSE						 ;   ELSE
						 ;
    $M_INDEX =	    0				 ;
    $M_COUNT =	    0				 ;     Build normal utilities
						 ;
    REPT    nummsg				 ;
    $M_COUNT =	    $M_COUNT + 1		 ;
    $M_MAKE %$M_COUNT				 ;
    ENDM					 ;
  ENDIF 					 ;
ENDIF						 ;
ENDM						 ;
						 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; $M_MAKE		Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
						 ;
$M_MAKE Macro $m_append 			 ;
IF  FARmsg					 ;
    CALL    FAR PTR $M_CLS_&$m_append		 ;  Get addressibilty to class &$M_APPEND (ES:DI)
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX+2,ES ;  Move into first avaliable table location
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX,DI ;
ELSE						 ;
    CALL    $M_CLS_&$m_append			 ;  Get addressibilty to class &$M_APPEND (ES:DI)
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX,DI ;
ENDIF						 ;
$M_INDEX =  $M_INDEX + 4			 ;  Set next available table location
						 ;
ENDM						 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; $M_MAKE_COMR     Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
						 ;
$M_MAKE_COMR   macro			     ;
						 ;
    CALL    $M_CLS_3				 ;  Get addressibilty to class A
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX,DI ;
$M_INDEX =  $M_INDEX + 4			 ;  Set next available table location
						 ;
    CALL    $M_CLS_4				 ;  Get addressibilty to class B
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX,DI ;
$M_INDEX =  $M_INDEX + 4			 ;  Set next available table location
						 ;
    CALL    $M_CLS_5				 ;  Get addressibilty to class C
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX,DI ;
$M_INDEX =  $M_INDEX + 4			 ;  Set next available table location
						 ;
    CALL    $M_CLS_6				 ;  Get addressibilty to class D
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX,DI ;
$M_INDEX =  $M_INDEX + 4			 ;  Set next available table location
						 ;
    CALL    $M_CLS_7				 ;  Get addressibilty to class E
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX,DI ;
$M_INDEX =  $M_INDEX + 4			 ;  Set next available table location
						 ;
ENDM						 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; $M_MAKE_COMT     Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
						 ;
$M_MAKE_COMT  macro			     ;
						 ;
;;    CALL    $M_CLS_8				 ;  Get addressibilty to class A
    CALL    $M_CLS_3				 ;  Get addressibilty to class F
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX,DI ;
$M_INDEX =  $M_INDEX + 4			 ;  Set next available table location
						 ;
ENDM						 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\syscall.inc ===
;	SCCSID = @(#)syscall.asm	1.1 85/04/10
;BREAK <system call definitions>

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

SUBTTL	system call definitions
PAGE

Abort				EQU 0	;  0	  0
Std_Con_Input			EQU 1	;  1	  1
Std_Con_Output			EQU 2	;  2	  2
Std_Aux_Input			EQU 3	;  3	  3
Std_Aux_Output			EQU 4	;  4	  4
Std_Printer_Output		EQU 5	;  5	  5
Raw_Con_IO			EQU 6	;  6	  6
Raw_Con_Input			EQU 7	;  7	  7
Std_Con_Input_No_Echo		EQU 8	;  8	  8
Std_Con_String_Output		EQU 9	;  9	  9
Std_Con_String_Input		EQU 10	; 10	  A
Std_Con_Input_Status		EQU 11	; 11	  B
Std_Con_Input_Flush		EQU 12	; 12	  C
Disk_Reset			EQU 13	; 13	  D
Set_Default_Drive		EQU 14	; 14	  E
FCB_Open			EQU 15	; 15	  F
FCB_Close			EQU 16	; 16	 10
Dir_Search_First		EQU 17	; 17	 11
Dir_Search_Next 		EQU 18	; 18	 12
FCB_Delete			EQU 19	; 19	 13
FCB_Seq_Read			EQU 20	; 20	 14
FCB_Seq_Write			EQU 21	; 21	 15
FCB_Create			EQU 22	; 22	 16
FCB_Rename			EQU 23	; 23	 17
Get_Default_Drive		EQU 25	; 25	 19
Set_DMA 			EQU 26	; 26	 1A
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Get_Default_DPB 		EQU 31	; 31	 1F
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
FCB_Random_Read 		EQU 33	; 33	 21
FCB_Random_Write		EQU 34	; 34	 22
Get_FCB_File_Length		EQU 35	; 35	 23
Get_FCB_Position		EQU 36	; 36	 24
Set_Interrupt_Vector		EQU 37	; 37	 25
Create_Process_Data_Block	EQU 38	; 38	 26
FCB_Random_Read_Block		EQU 39	; 39	 27
FCB_Random_Write_Block		EQU 40	; 40	 28
Parse_File_Descriptor		EQU 41	; 41	 29
Get_Date			EQU 42	; 42	 2A
Set_Date			EQU 43	; 43	 2B
Get_Time			EQU 44	; 44	 2C
Set_Time			EQU 45	; 45	 2D
Set_Verify_On_Write		EQU 46	; 46	 2E
; Extended functionality group
Get_DMA 			EQU 47	; 47	 2F
Get_Version			EQU 48	; 48	 30
Keep_Process			EQU 49	; 49	 31
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Get_DPB 			EQU 50	; 50	 32
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
Set_CTRL_C_Trapping		EQU 51	; 51	 33
Get_InDOS_Flag			EQU 52	; 52	 34
Get_Interrupt_Vector		EQU 53	; 53	 35
Get_Drive_Freespace		EQU 54	; 54	 36
Char_Oper			EQU 55	; 55	 37
International			EQU 56	; 56	 38
;   Directory Group
MKDir				EQU 57	; 57	 39
RMDir				EQU 58	; 58	 3A
CHDir				EQU 59	; 59	 3B
;   File Group
Creat				EQU 60	; 60	 3C
Open				EQU 61	; 61	 3D
Close				EQU 62	; 62	 3E
Read				EQU 63	; 63	 3F
Write				EQU 64	; 64	 40
Unlink				EQU 65	; 65	 41
LSeek				EQU 66	; 66	 42
CHMod				EQU 67	; 67	 43
IOCtl				EQU 68	; 68	 44
XDup				EQU 69	; 69	 45
XDup2				EQU 70	; 70	 46
Current_Dir			EQU 71	; 71	 47
;    Memory Group
Alloc				EQU 72	; 72	 48
Dealloc 			EQU 73	; 73	 49
Setblock			EQU 74	; 74	 4A
;    Process Group
Exec				EQU 75	; 75	 4B
Exit				EQU 76	; 76	 4C
WaitProcess			EQU 77	; 77	 4D
Find_First			EQU 78	; 78	 4E
;   Special Group
Find_Next			EQU 79	; 79	 4F
; SPECIAL SYSTEM GROUP
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Set_Current_PDB 		EQU 80	; 80	 50
Get_Current_PDB 		EQU 81	; 81	 51
Get_In_Vars			EQU 82	; 82	 52
SetDPB				EQU 83	; 83	 53
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
Get_Verify_On_Write		EQU 84	; 84	 54
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Dup_PDB 			EQU 85	; 85	 55
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
Rename				EQU 86	; 86	 56
File_Times			EQU 87	; 87	 57
AllocOper			EQU 88	; 88	 58
; Network extention system calls
GetExtendedError		EQU 89	; 89	 59
CreateTempFile			EQU 90	; 90	 5A
CreateNewFile			EQU 91	; 91	 5B
LockOper			EQU 92	; 92	 5C Lock and Unlock
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
					;	    CloseByName, CloseUser,
					;	    CloseUserProcess,
					;	    GetOpenFileList
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
UserOper			EQU 94	; 94	 5E Get and Set
AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
xNameTrans			EQU 96	; 96	 60
PathParse			EQU 97	; 97	 61
GetCurrentPSP			EQU 98	; 98	 62
Hongeul 			EQU 99	; 99	 63
ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Set_Printer_Flag		EQU 100 ; 100	 64
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
GetExtCntry			EQU 101 ; 101	 65
GetSetCdPg			EQU 102 ; 102	 66
ExtHandle			EQU 103 ; 103	 67
Commit				EQU 104 ; 104	 68
GetSetMediaID			EQU 105 ; 105	 69
IFS_IOCTL			EQU 107 ; 107	 6B
ExtOpen 			EQU 108 ; 108	 6C
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
ifdef ROMEXEC
ROM_FIND_FIRST			EQU 109 ; 109    6D
ROM_FIND_NEXT			EQU 110 ; 110    6E
ROM_EXCLUDE			EQU 111 ; 111	 6F			; M035
endif
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;
;
Set_Oem_Handler 		EQU 248 ; 248	 F8
OEM_C1				EQU 249 ; 249	 F9
OEM_C2				EQU 250 ; 250	 FA
OEM_C3				EQU 251 ; 251	 FB
OEM_C4				EQU 252 ; 252	 FC
OEM_C5				EQU 253 ; 253	 FD
OEM_C6				EQU 254 ; 254	 FE
OEM_C7				EQU 255 ; 255	 FF

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\struc.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;;STRUC--Stucture Macro Library
;;Optimizing Version 2.30  03/31/87

if1
$NoConj 	equ	0
$And		equ	1
$Or		equ	2
$Short		equ	3
$Near		equ	4
$NearToShort	equ	5
$ncxz		equ	6
$AndOr		=	0
$Temp		=	0
$Temp2		=	0
$Dist		=	0

$NoType 	equ	10
$ConjIfType	equ	11
$IfType 	equ	12
$ElseType	equ	13
$WhileType	equ	14
$ConjWhileType	equ	15
$RepeatType	equ	16
$ConjUntilType	equ	17
$ForType	equ	18
$ConjLeaveType	equ	19
$SelectType	equ	20
$WhenType	equ	21
$ConjWhenType	equ	22
$OtherwiseType	equ	$ElseType

$StrucError macro text
					Structure error -- text
endm

J	macro
endm
JN	macro
endm

$BuildJump   macro   j1,j2
	j1  macro   t
	    .xcref  j1
					j2 t
	endm
endm

irp	x,<<jeq,je>,<jlt,jl>,<jgt,jg>,<jneq,jne>,<jnlt,jnl>,<jngt,jng>,<jnpe,jpo>,<jnpo,jpe>>
	$BuildJump x
endm
irp	x,<<jzero,jz>,<jnzero,jnz>,<jnonzero,jnz>,<jnnonzero,jz>,<jand,jnz>,<jnand,jz>,<jnnand,jnz>>
	$BuildJump x
endm
irp	x,<a,ae,b,be,c,e,g,ge,l,le,o,p,s,z,cxz>
	$BuildJump jnn&x,j&x
endm

jncxz	macro	t
	if	$Dist eq $NearToShort
					jcxz $+5
					jmp t
	else
					jcxz $+4
					jmp short t
	endif
endm

purge	$BuildJump

$GetConj macro	p1,p2
	$AndOr	= $NoConj
	irp	parm,<p1,p2>
	    ifnb    <&parm>
		irp	x,<and,AND,or,OR>
		    ifidn   <parm>,<x>
			 $AndOr = $&&&x
			 exitm
		    endif
		endm
	    endif
	endm
endm

$GetDist macro	p1,p2
	irp	parm,<p1,p2>
	    ifnb    <parm>
		irp	x,<short,SHORT,near,NEAR>
		    ifidn   <parm>,<x>
			$Dist	= $&&&x
			 exitm
		     endif
		endm
	    endif
	endm
endm


$Poke	macro	n,m
	$st&n	= m
.xcref	$st&n
endm

$Peek	macro	x,n
	x	= $st&n
endm

$Push	macro	n
	$st	= $st+1
	$Poke	%$st,n
endm

$Pop	macro	x
	if	$st gt 0
	    $Peek   x,%$st
	    $st     = $st-1
	else
	    $StrucError <open structure>
	endif
endm

$EquateLabel macro last,this
	if	$LastLabelOrg eq $
	    $ll&last = this
	    .xcref  $ll&last
	endif
endm

$TraceLabel macro n,a,b
	if	$ll&a eq $ll&b
	    $ll&n   = b
	    .xcref  $ll&n
	else
	    $TraceLabel n,%$ll&a,%$ll&b
	endif
endm

$Label	 macro	 n
	if1
	    $EquateLabel %$LastLabel,n
	    $ll&n   = n
	    .xcref  $ll&n
	    $LastLabel = n
	    $LastLabelOrg = $
$l&n:
	else
	    if	    $ll&n eq n
$l&n:
	    else
		.xcref	$l&n
		.xcref	$ll&n
	    endif
	endif
endm

$CondJump macro l,tf,c
	if1
	    ifb     <c>
		$EquateLabel %$LastLabel,l
	    endif
	    ifndef  <$ll&l>
		$ll&l	= l
		.xcref	$ll&l
	    endif
	else
	    $TraceLabel l,l,%$ll&l
	endif
	$CondJump2 %$ll&l,tf,c
endm

$CondJump2 macro l,tf,c
	if	$Dist eq $Short
	    ifb     <c>
					jmp short $l&l
	    else
		ifidn <tf>,<f>
					jn&c $l&l
		else
					j&c $l&l
		endif
	    endif
	else
	    ifnb    <c>
		ifdef	$l&l
		    if	    (($ - $l&l) le 126) and (($l&l - $) le 129)
			$Dist	= $NearToShort
			$nops	= 3
			ifidn <tf>,<f>
					jn&c $l&l
			    ifdef   $n&c
				if	$n&c eq $ncxz
				    $nops = 0
				endif
			    endif
			    ifdef   $&c
				if	$&c eq $ncxz
				    $nops = 5
				endif
			    endif
			else
					j&c $l&l
			    ifdef   $n&c
				if	$n&c eq $ncxz
				    $nops = 5
				endif
			    endif
			    ifdef   $&c
				if	$&c eq $ncxz
				    $nops = 0
				endif
			    endif
			endif
			    rept $nops
				nop
			    endm
		    else
			ifidn <tf>,<f>
					j&c $+5
			else
					jn&c $+5
			endif
					jmp $l&l
		    endif
		else
		    ifidn <tf>,<f>
					j&c $+5
		    else
					jn&c $+5
		    endif
					jmp $l&l
		endif
	    else
		ifdef	$l&l
		    ifidn   <tf>,<NoFold>
					jmp $l&l
		    else
			if	(($ - $l&l) le 126) and (($l&l - $) le 129)
					jmp short $l&l
					nop
			else
					jmp $l&l
			endif
		    endif
		else
					jmp $l&l
		endif
	    endif
	endif
endm


$CondLoop macro l,c
					loop&c $l&l
endm

$Test	macro	tgt,a1,a2,a3,a4,x
	ifb	<a1>
	    $StrucError <invalid condition>
	else
	ifb	<a2>
	    $CondJump %&tgt,a1
	else
	ifb	<a3>
	    ifdif   <a1>,<zero>
	    ifdif   <a1>,<nonzero>
	    ifdif   <a1>,<ZERO>
	    ifdif   <a1>,<NONZERO>
		$StrucError <invalid condition>
		exitm
	    endif
	    endif
	    endif
	    endif
					or a2,a2
	    $CondJump %&tgt,a1
	else
	ifb	<a4>
					cmp a1,a3
	    $CondJump %&tgt,a2
	else
	ifb	<x>
	    ifdif   <a1>,<bit>
	    ifdif   <a1>,<BIT>
		$StrucError <invalid condition>
		exitm
	    endif
	    endif
					test a2,a4
	    $CondJump %&tgt,a3
	else
	    $StrucError <invalid condition>
	endif
	endif
	endif
	endif
	endif
endm

$TopTest macro	args,n,c,p4,p5
	$GetConj p4,p5
	$Dist	= $DefDist
	$GetDist p4,p5
	if	$AndOr eq $NoConj
	    $Test   <$sn-1,f>,args
	    $Pop    $Temp
	    if	    $OrFound
		$Label	%$Temp
	    endif
	    $Push   n
	else
	    if	    $AndOr eq $And
		$Test	<$sn-1,f>,args
	    else
		$OrFound = 1
		$Test	<$sn,t>,args
	    endif
	    $Push   c
	endif
endm
;;*****************************************************************************
.if	macro	t,p2,p3
	$Peek	$Temp,%$st
	if	$Temp eq $ConjIfType
	    $Pop    $Temp
	else
	    $OrFound = 0
	    $sn     = $sn+1
	    $Push   $sn
	    $sn     = $sn+1
	    $Push   $sn
	    $sn     = $sn+1
	    $Push   $sn
	endif
	$TopTest <t>,$IfType,$ConjIfType,p2,p3
endm
;;*****************************************************************************
.then	macro
	$Peek	$Temp,%$st
	if	$Temp ne $IfType
	if	$Temp ne $WhenType
	    $StrucError <then without if or when>
	endif
	endif
endm
;;*****************************************************************************
.elseif macro	t,p2,p3
	$Pop	$Temp
	if	$Temp ne $IfType
	    $StrucError <elseif without if>
	    exitm
	endif
	$OrFound = 0
	$Pop	$Temp
	$Peek	$Temp2,%$st
	$Dist	= $Near
	$CondJump %$Temp2
	$Label	%$Temp
	$sn	= $sn+1
	$Push	$sn
	$sn	= $sn+1
	$Push	$sn
	$TopTest <t>,$IfType,$ConjIfType,p2,p3
endm
;;*****************************************************************************
.else	macro	dist
	$Pop	$Temp
	if	$Temp ne $IfType
	if	$Temp ne $WhenType
	if	$Temp ne $SelectType
	    $StrucError <else without if, when or select>
	    exitm
	endif
	endif
	endif
	$sn	= $sn+1
	if	$Temp eq $SelectType
	    $Push   $sn
	else
	    $Dist   = $DefDist
	    $GetDist dist
	    $CondJump %$sn
	    $Pop    $Temp
	    $Label  %$Temp
	    $Push   $sn
	endif
	$push	$ElseType
endm
;;*****************************************************************************
.endif	macro
	$Pop	$Temp
	if	$Temp ne $IfType
	    if	    $Temp ne $ElseType
		$StrucError <endif without if>
		exitm
	    endif
	endif
	$Pop	$Temp
	$Label	%$Temp
	$Pop	$Temp
	$Label	%$Temp
endm
;;*****************************************************************************
.select macro	x
	$OrFound = 0
	$sn	= $sn+1
	$Push	$sn
	$Push	$SelectType
endm
;;*****************************************************************************
.when	macro	tst,p2,p3
	$Pop	$Temp
	if	$Temp ne $SelectType
	if	$Temp ne $WhenType
	if	$Temp ne $ConjWhenType
	    $StrucError <when without select>
	    exitm
	endif
	endif
	endif
	if	$Temp ne $ConjWhenType
	    $Dist   = $Near
	    $OrFound = 0
	    if	    $Temp eq $WhenType
		$Pop	$Temp2
		$Peek	$Temp,%$st
		$CondJump %$Temp
		$Label	 %$Temp2
	    endif
	    $sn     = $sn+1
	    $Push   $sn
	    $sn     = $sn+1
	    $Push   $sn
	endif
	$TopTest <tst>,$WhenType,$ConjWhenType,p2,p3
endm
;;*****************************************************************************
.otherwise	macro	dist
	$Pop	$Temp
	if	$Temp ne $WhenType
	if	$Temp ne $SelectType
	if	$Temp ne $IfType
	    $StrucError <otherwise without if, when or select>
	    exitm
	endif
	endif
	endif
	$sn	= $sn+1
	if	$Temp eq $SelectType
	    $Push   $sn
	else
	    $Dist   = $DefDist
	    $GetDist dist
	    $CondJump %$sn
	    $Pop    $Temp
	    $Label  %$Temp
	    $Push   $sn
	endif
	$push	$OtherwiseType
endm
;;*****************************************************************************
.endselect	macro
	$Pop	$Temp
	if	$Temp ne $WhenType
	if	$Temp ne $OtherwiseType
	if	$Temp ne $SelectType
	    $StrucError <endselect without select>
	    exitm
	endif
	endif
	endif
	$pop	$Temp2
	if	$Temp ne $SelectType
	    $Label  %$Temp2
	    $Pop    $Temp2
	    $Label  %$Temp2
	endif
endm
;;*****************************************************************************
.while	macro	t,p2,p3
	$Peek	$Temp,%$st
	if	$Temp eq $ConjWhileType
	    $Pop    $Temp
	else
	    $Push   $LoopEnd
	    $OrFound = 0
	    $sn     = $sn + 1
	    $Push   $sn
	    $Label  %$sn
	    $sn     = $sn + 2
	    $Push   $sn
	    $LoopEnd = $sn - 1
	endif
	$TopTest <t>,$WhileType,$ConjWhileType,p2,p3
endm
;;*****************************************************************************
.endwhile macro p1
	$Pop	$Temp
	if	$Temp ne $WhileType
	    $StrucError <endwhile without while>
	    exitm
	endif
	$Dist	= $Near
	$Pop	$Temp
	$CondJump %$Temp,NoFold
	$Label	%$Temp+1
	$Pop	$LoopEnd
endm
;;*****************************************************************************
.repeat macro
	$Push	$LoopEnd
	$Push	$LeaveFound
	$sn	= $sn+1
	$Label	%$sn
	$Push	$sn
	$Push	$RepeatType
	$sn	= $sn+1
	$LoopEnd = $sn
	$LeaveFound = 0
endm
;;*****************************************************************************
.until	macro	t,p2,p3
	$until2 p2,p3,t
endm
$until2 macro	p2,p3,a1,a2,a3,a4,x
	$Pop	$Temp
	if	$Temp ne $RepeatType
	    if	    $Temp ne $ConjUntilType
		$StrucError <until without repeat>
		exitm
	    endif
	else
	    $OrFound = 0
	endif
	$Dist	= $DefDist
	$GetDist p2,p3
	$GetConj p2,p3

	if	$AndOr eq $NoConj
	    $Pop    $Temp
	    ifb     <a1>
		$Dist	= $Near
		$CondJump %$Temp,NoFold
	    else
		$Test	 <$Temp,f>,<a1>,<a2>,<a3>,<a4>,<x>
	    endif
	    if	    $OrFound or $LeaveFound
		$Label	 %$Temp+1
	    endif
	    $Pop    $LeaveFound
	    $Pop    $LoopEnd
	else
	    $Peek   $Temp,%$st
	    if	    $AndOr eq $And
		$Test	 <$Temp,f>,<a1>,<a2>,<a3>,<a4>,<x>
	    else
		$OrFound = 1
		$Test	 <$Temp+1,t>,<a1>,<a2>,<a3>,<a4>,<x>
	    endif
	    $Push   $ConjUntilType
	endif
endm
;;*****************************************************************************
.loop	macro	cond
	$Pop	$Temp
	if	$Temp ne $RepeatType
	    $StrucError <loop without repeat>
	    exitm
	endif
	$Pop	$Temp
	$CondLoop %$Temp,cond
	if	$LeaveFound
	    $Label  %$Temp+1
	endif
	$Pop	$LeaveFound
	$Pop	$LoopEnd
endm
;;*****************************************************************************
.for	macro	index,equals,start,to,stop,by,step,dist
					mov index,start
	$Push	$LoopEnd
	$sn	= $sn+1
	$Push	$sn
	$Label	%$sn
	$sn	= $sn+1
	$LoopEnd = $sn
					cmp index,stop
	$Dist	= $DefDist
	ifb	<step>
	    $Push   1
	    $GetDist by
	    $CondJump %$sn,t,gt
	else
	    $GetDist dist
	    $Push   %(step)
	    if	    step lt 0
		$CondJump %$sn,t,lt
	    else
		$CondJump %$sn,t,gt
	    endif
	endif
	$Push	$ForType
endm
;;*****************************************************************************
.next	macro	index,dist
	$Pop	$Temp
	if	$Temp ne $ForType
	    $StrucError <next without for>
	    exitm
	endif
	$Pop	$Temp
	if	$Temp eq 1
					inc index
	else
	    if	    $Temp eq -1
					dec index
	    else
					add index,$Temp
	    endif
	endif
	$Pop	$Temp
	$Dist	= $Near
	$CondJump %$Temp,NoFold
	$Label	%$Temp+1
	$Pop	$LoopEnd
endm
;;*****************************************************************************
.leave	macro	t,p2,p3
	$leave2 p2,p3,t
endm
$leave2 macro  p2,p3,a1,a2,a3,a4,x
	ife	$LoopEnd
	    $StrucError <leave outside a loop>
	    exitm
	endif
	$LeaveFound = 1
	$Peek	$Temp,%$st
	if	$Temp eq $ConjLeaveType
	    $Pop    $Temp
	else
	    $OrFound = 0
	    $sn     = $sn + 1
	endif
	$Dist	= 0
	$GetDist <a1>
	if	$Dist
	    $CondJump %$LoopEnd
	    if	    $OrFound
		$Label	%$sn
	    endif
	else
	    $Dist   = $DefDist
	    $GetDist p2,p3
	    $GetConj p2,p3
	    if	    $AndOr eq $NoConj
		ifb	<a1>
		    $CondJump %$LoopEnd,t
		else
		    $Test   <$LoopEnd,t>,<a1>,<a2>,<a3>,<a4>,<x>
		endif
		if	$OrFound
		    $Label  %$sn
		endif
	    else
		if	$AndOr eq $And
		    $OrFound = 1
		    $Test   <$sn,f>,<a1>,<a2>,<a3>,<a4>,<x>
		else
		    $Test   <$LoopEnd,t>,<a1>,<a2>,<a3>,<a4>,<x>
		endif
		$Push	$ConjLeaveType
	    endif
	endif
endm
;;*****************************************************************************
else	       ;else for if1
$Pop	$Temp
;;if	   $Temp ne $NoType
if	$st ne 0
     $StrucError <open structure(s)>
endif
.xcref $NoConj,$And,$Or,$Short,$Near,$NearToShort,$AndOr,$Temp,$Temp2,$Dist
.xcref $NoType,$ConjIfType,$IfType,$ElseType,$WhileType,$ConjWhileType
.xcref $RepeatType,$ConjUntilType,$ForType,$ConjLeaveType,jncxz
.xcref $SelectType,$WhenType,$OtherwiseType,$ConjWhenType
.xcref jeq,jgt,jlt,jneq,jngt,jnlt,jnna,jnnae,jnnb,jnnbe,jnnc,jnncxz
.xcref jnne,jnng,jnnge,jnnl,jnnle,jnno,jnnp,jnns,jnnz,jnpe,jnpo,$BuildJump
.xcref $GetConj,$GetDist,$Poke,$Peek,$Push,$Pop,$Label,$CondJump,$CondLoop,$Test
.xcref $TopTest,$leave2,$until2,$StrucError,j,jn,jand,jnand,jnnand
.xcref jnnonzero,jnonzero,jnzero,jzero
.xcref $st,$sn,$OrFound,$LoopEnd,$LeaveFound,$DefDist
.xcref $LastLabel,$LastLabelOrg,$EquateLabel,$TraceLabel,$CondJump2,$ncxz
endif


$st	= 0
$sn	= 0
$OrFound = 0
$LoopEnd = 0
$LeaveFound = 0
$LastLabel = -1
$LastLabelOrg = $
$DefDist= $Short
$Push	%$NoType

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\vector.inc ===
;	SCCSID = @(#)vector.asm	1.1 85/04/10
BREAK <interrupt definitions>
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

Asmvar	AltVect

INTTAB		EQU	20H
INTBASE 	EQU	4 * inttab
ENTRYPOINT	EQU	INTBASE+40H

	IF	ALTVECT
ALTTAB	EQU	0F0H
ALTBASE EQU	4 * ALTTAB
	ENDIF

;
; interrupt assignments
;
	IF	NOT ALTVECT
int_abort	    EQU     INTTAB	; abort process
int_command	    EQU     int_abort+1 ; call MSDOS
int_terminate	    EQU     int_abort+2 ; int to terminate address
int_ctrl_c	    EQU     int_abort+3 ; ^c trapper
int_fatal_abort     EQU     int_abort+4 ; hard disk error
int_disk_read	    EQU     int_abort+5 ; logical sector disk read
int_disk_write	    EQU     int_abort+6 ; logical sector disk write
int_keep_process    EQU     int_abort+7 ; terminate program and stay
					; resident
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
int_spooler	    EQU     int_abort+8 ; spooler call
int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
int_IBM 	    EQU     int_abort+10; critical section maintenance
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
	ELSE
int_abort	    EQU     INTTAB	; abort process
int_command	    EQU     int_abort+1 ; call MSDOS
int_terminate	    EQU     ALTTAB	; int to terminate address
int_ctrl_c	    EQU     int_terminate+1 ; ^c trapper
int_fatal_abort     EQU     int_terminate+2 ; hard disk error
int_disk_read	    EQU     int_abort+5 ; logical sector disk read
int_disk_write	    EQU     int_abort+6 ; logical sector disk write
int_keep_process    EQU     int_abort+7 ; terminate program and stay resident
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
int_spooler	    EQU     int_terminate+3 ; spooler call
int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
	ENDIF

addr_int_abort		EQU    4 * int_abort
addr_int_command	EQU    4 * int_command
addr_int_terminate	EQU    4 * int_terminate
addr_int_ctrl_c 	EQU    4 * int_ctrl_c
addr_int_fatal_abort	EQU    4 * int_fatal_abort
addr_int_disk_read	EQU    4 * int_disk_read
addr_int_disk_write	EQU    4 * int_disk_write
addr_int_keep_process	EQU    4 * int_keep_process
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
addr_int_spooler	EQU    4 * int_spooler
addr_int_fastcon	EQU    4 * int_fastcon
addr_int_IBM		EQU    4 * int_IBM
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\versiona.inc ===
;
;       Microsoft Confidential
;       Copyright (C) Microsoft Corporation 1991
;       All Rights Reserved.
;


major_version       equ     6       ;Major DOS version
minor_version       equ     00      ;Minor DOS Version

expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION

; m033 DOSREVNM equ     00000000B       ; bits 0-2 = revision number of DOS
; m033                                  ; currently 0.

; m037 DOSREVNM equ     00000001B       ; m033 - bits 0-2 = revision number of DOS
; m037                                          ; m033 - currently 1.

DOSREVNM        equ     00000000B       ; m037 - bits 0-2 = revision number of DOS
					; currently 0.


DOSINROM        equ     00001000B       ; bit 3 of ver flags returned in BH
DOSINHMA        equ     00010000B       ; bit 4 of ver flags 


;      if1
;      %OUT  ... for DOS Version 5.00 ...
;      endif

       ;******************************
       ;Each assembler program should:
       ;  mov ah,030h                   ;DOS Get Version function
       ;  int 021h                      ;Version ret. in AX,minor version first
       ;  cmp ax,expected_version       ;ALL utilities should check for an
       ;  jne error_handler             ; EXACT version match.
       ;******************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\umb.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1989-1991
;
;   Module:   UMB.INC - Definitions for link umb utility
;
;   Version:  0.01
;
;   Date:     Jun. 26, 1990
;
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   06/26/90  Original
;
;******************************************************************************

XMM_MULTIPLEX		equ	43h	; XMM multiplex number of INT 2Fh
XMM_INSTALL_CHECK	equ	00h	; install check call
XMM_FUNCTION_ADDR	equ	10h	; get control function address call
;
; XMM functions
;
XMM_GET_VERSION		equ	00h
XMM_REQUEST_UMB		equ	10h
XMM_RELEASE_UMB		equ	11h
;
; All error codes has this bit on.
; Used for test sucess of XMM_QUERY_FREE_EXTMEM
;
XMM_ERROR_BIT		equ	80h

;
;  Previous HIMEM.SYS versions are not reliable
;
GOOD_HIMEM_VERSION	equ	208h


;**	Arena Header
;

arena	STRUC
arena_signature     DB	?		; 4D for valid item, 5A for last item
arena_owner	    DW	?		; owner of arena item
arena_size	    DW	?		; size in paragraphs of item
arena_reserved	    DB	3 DUP(?)	; reserved
arena_name	    DB	8 DUP(?)	; owner file name
arena	ENDS

arena_owner_system	EQU 0		; free block indication

arena_signature_normal	EQU 4Dh 	; valid signature, not end of arena
arena_signature_end	EQU 5Ah 	; valid signature, last block in arena

DOS_ARENA		EQU 24H		; offset of arena_head var in DOS 
					; data segment
UMB_ARENA		EQU 8CH		; offset of umb_head in DOS data

.list		; end of UMB.INC

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\version.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

ifndef    TRUE              ; Some modules may want TRUE = 0FFH.
TRUE      EQU 0FFFFh
endif

ifndef    TRUEBYTE
TRUEBYTE  EQU 0FFh
endif

ifndef    FALSE
FALSE     EQU 0
endif

;----------------------------------------------------------------------------
; CONDITIONAL ASSEMBLY OPTIONS
;
; The following assembly variables should be defined to enable
; the corresponding options, or left undefined to disable the
; corresponding options.  Place a semicolon ";" at the beginning
; of the definition line to leave a variable undefined.

; This flag should be defined to include the DblSpace hooks in the
; build of IO.SYS.  It should be undefined for OEMs who choose not
; to purchase DblSpace.

IFNDEF OEMBASE
IFNDEF DBLSPACE_HOOKS
dblspace_hooks equ TRUE
ENDIF
ENDIF

; This flag should be defined to create the ROM executable version of DOS.
; To build the regular version, it should be UNDEFINED.
;
;ROMDOS  equ TRUE

; This flag should be defined to build power management into the DOS BIOS.
;
;POWER	equ TRUE

; This flag should be defined to build the ROMDRIVE driver into the DOS BIOS.
;
;ROMDRIVE equ TRUE

; This flag should be defined to enable support for CMOS boot options.
;
;CMOS    equ TRUE

; This flag should be defined to include the CONFIG.SYS processing code
; in DOS.  Remove this definition to build DOS without the config.sys
; processing code.
;
CONFIGPROC equ TRUE

; This flag should be defined to keep the data stored in the CDS
; created at startup.  The default behaviour is to rebuild the CDS
; when each device is initialized.  Defining this allows device drivers
; to make lasting changes to the CDS structure.
;
;	BUGBUG -- 16 Nov 92 -- chuckst -- COPYCDS was desirable for
;	DblSpace, but it broke SuperStore (DR) compression's SWAP
;	function, since it didn't take CDSs into account in its
;	swapping.  It is hereby removed.
;
;COPYCDS equ TRUE

; END OF CONDITIONAL ASSEMBLY OPTIONS
;----------------------------------------------------------------------------


if1
	ifdef romdos
		%out ***** BUILDING ROM EXECUTABLE DOS *****
	endif
endif


; This flag should be defined to enable a special version of the EXEC
; function that will find and execute ROM executable programs.
; For our purposes it is always set the same as ROMDOS
;
ifdef ROMDOS
ROMEXEC equ	TRUE
endif

;
; Use the following switches to control cmacros.inc
;
?PLM       =       0
?WIN       =       0

memS       EQU     1			; Small model
;
; Use the switches below to produce the standard Microsoft version or the IBM
; version of the operating system
;
; The below chart will indicate how to set the switches to build the various
; versions
;
;                     IBMVER          IBMCOPYRIGHT
; --------------------------------------------------------
;  IBM Version     |   TRUE              TRUE
; --------------------------------------------------------
;  ISA Version     |   TRUE              FALSE
; --------------------------------------------------------
;  non ISA Version |   FALSE             FALSE
;
IBMVER          EQU     TRUE
IBMCOPYRIGHT    EQU     FALSE

;smr; removal of bufferflag; BUFFERFLAG	EQU	NOT IBMCOPYRIGHT

;mw 8/23/90 ; removal of ROMVER, superceded by ROMDOS and ROMEXEC, above...
; ROMVER		EQU	FALSE

CPU8086		EQU	FALSE

ifndef	MSVER	
MSVER           EQU     NOT IBMVER
endif
IBM             EQU     IBMVER
;
;
  IF1
	IF IBMVER
	    IF IBMCOPYRIGHT
              %OUT ... IBM version build switch on ...
	    ELSE
              ; %OUT ... ISA version build switch on ...
	    ENDIF
	ELSE
	    IF NOT IBMCOPYRIGHT
              %OUT ... non ISA version build switch on ...
	    ELSE
	      %OUT !!!!!!!!!  VERSION SWITCHES SET INCORECTLY  !!!!!!!!!
	      %OUT !!!!!!!!! CHECK SETTINGS IN INC\VERSION.INC !!!!!!!!!
	    ENDIF
	ENDIF
	IF CPU8086
	    %OUT !!!!!!! 8080 / 8086 Version !!!!!!!
	ENDIF
  ENDIF

;****************************************************************************
;
;		<<< Followings are the DBCS relating Definition >>>
;
;
;	To build DBCS version, Define DBCS by using MASM option via
;	Dos environment.
;
;	ex.		set MASM=-DDBCS
;
;
;
;	To build Country depend version, Define JAPAN, KOREA or TAIWAN
;	by using MASM option via Dos environment.
;
;	ex.		set MASM=-DJAPAN
;			set MASM=-DKOREA
;			set MASM=-DTAIWAN
;
;****************************************************************************


BUGFIX	   EQU	   TRUE


IBMJAPVER  EQU	   FALSE		; if TRUE define DBCS also
IBMJAPAN   EQU	   FALSE		; if TRUE define DBCS also


	ifdef TAIWAN
CSIBIOS    EQU	   FALSE		; BIOS	       CSI
CSIDRV	   EQU	   TRUE 		; Device Drive CSI
CSITSR	   EQU	   FALSE		; TSR	       CSI
	else
CSIBIOS    EQU	   FALSE
CSIDRV	   EQU	   FALSE
CSITSR	   EQU	   FALSE
	endif

;
; Set DBCS Blank constant
;
	ifndef DBCS
DB_SPACE EQU	 2020h
DB_SP_HI EQU	 20h
DB_SP_LO EQU	 20h
	else

	ifdef JAPAN
DB_SPACE EQU	 8140h
DB_SP_HI EQU	 81h
DB_SP_LO EQU	 40h
	endif

	ifdef TAIWAN
DB_SPACE EQU	 8130h
DB_SP_HI EQU	 81h
DB_SP_LO EQU	 30h
	endif

	ifdef KOREA
DB_SPACE EQU	 0A1A1h
DB_SP_HI EQU	 0A1h
DB_SP_LO EQU	 0A1h
	endif

	endif

ifndef altvect				; avoid jerking off vector.inc
ALTVECT    EQU	   FALSE		;Switch to build ALTVECT version
endif

;
	IF1

	ifdef DBCS
%OUT    DBCS Version Build Switch ON

	ifdef JAPAN
%OUT    JAPAN Version Build Switch ON
	endif

	ifdef TAIWAN
%OUT    TAIWAN Version Build Switch ON
	endif

	ifdef KOREA
%OUT    KOREA Version Build Switch ON
	endif

	endif

	ENDIF

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\win386.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;
; WIN386.INC
;
;  Symbols and structures relating to WIN386 support.
;
;  Used by files in both the DOS and the BIOS.
;
;  Created: 7-13-89 by MRW
;

;
; WIN386 broadcast int 2fh multiplex number and subfunction numbers
;

MultWin386		equ     16H	; Int 2f multiplex number

Win386_Init		equ	05H	; Win386 initialization
Win386_Exit		equ	06H	; Win386 exit
Win386_Devcall		equ	07H	; Win386 device call out
Win386_InitDone		equ	08H	; Win386 initialization is complete

;
; When Win386_Devcall is broadcast, BX is the Device ID.  DOS must 
; answer call outs from the DOSMGR
;

Win386_DOSMGR		equ	15H

;
; The following structures are used to communicate instance data to 
; Win386 from the DOS and the BIOS.  See Win386 API documentation
; (chapter 3, "Call Out Interfaces") for further description.
;

Win386_SIS		struc		; Startup Info Structure
SIS_Version		db	3, 0
SIS_Next_Dev_Ptr	dd	0	; pointer to next SIS in list
SIS_Virt_Dev_File_Ptr	dd	0
SIS_Reference_Data	dd	0
SIS_Instance_Data_Ptr	dd	0	; pointer to instance data array
Win386_SIS		ends

Win386_IIS		struc		; Instance Item Structure
IIS_Ptr			dd	?	; pointer to an instance item
IIS_Size		dw	?	; size of an instance item
Win386_IIS		ends

;
;Win386 DOSMGR function return values to indicate operation done
;

WIN_OP_DONE		equ	0b97cH	; 
DOSMGR_OP_DONE		equ	0a2abH	;

;M021
; WInoldap callout multiplex number
;
WINOLDAP		equ	46h	;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\wordout.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1989-1991
;
;   Module:   WORDOUT.INC - Basically code for debugging; displays data.
;
;   Version:  0.01
;
;   Date:     May 14, 1992
;
;******************************************************************************
;
;   Modification log:
;
;     DATE    WHO  REVISION  DESCRIPTION
;   --------  ---  --------  --------------------------------------------------
;   05/14/92  RPJ    0.01    Original
;
;******************************************************************************

; -----------------------------------------------------------------------------
; charout is a macro that accepts one argument to print; charout al/charout 'X'
; printcr prints CR/LF
; printtab prints a TAB character
; getchar waits for a keypress, any keypress
; -----------------------------------------------------------------------------
; nibout prints AL's lowest four bits as one hex digit
; byteout prints AL as two hex digits
; wordout prints AX as four hex digits, in proper word-order
; -----------------------------------------------------------------------------
; Examples:
;	dec	ax	; Prepare to load
;	charout	'L'	; DEBUG
;	charout	':'	; DEBUG
;	call	wordout	; DEBUG
;	printcr		; DEBUG -- displays "L:01F8", depending on AX.
;	
; -----------------------------------------------------------------------------

charout	macro	chr
	push	ax
	push	dx
	mov	dl, chr
	mov	ah, 2
	int	21h
	pop	dx
	pop	ax
	endm

printcr	macro
	push	ax
	push	dx
	mov	dl, 13
	mov	ah, 2
	int	21h
	mov	dl, 10
	mov	ah, 2
	int	21h
	pop	dx
	pop	ax
	endm

printtab macro
	charout	9
	endm

getchar	macro
	push	ax
	mov	ah, 8
	int	21h
	pop	ax
	endm

public	nibout
public	byteout
public	wordout

nibout	proc	near
	push	ax
	push	dx

	cmp	al, 0Ah
	jge	no_hex
	add	al, '0'
	mov	dl, al
	mov	ah, 2
	int	21h
	jmp short no_done

no_hex:
	add	al, 'A'-0Ah
	mov	dl, al
	mov	ah, 2
	int	21h

no_done:
	pop	dx
	pop	ax
	ret
nibout	endp

byteout	proc	near
	push	ax
	push	ax

	push	cx
	mov	cl, 4	; four-bit shift
	shr	al, cl	; right here.
	pop	cx
	call	nibout
	pop	ax

	and	al, 0Fh
	call	nibout
	pop	ax

	ret
byteout	endp

wordout	proc	near
	push	ax
	push	ax
	mov	al, ah
	call	byteout
	pop	ax
	call	byteout
	pop	ax
	ret
wordout endp
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\wpatch.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


DOSDATA	Segment

;
; first and second DOS patches
;	Non-console device read/write (system calls 3Fh and 40h)
;
; Code in disk.asm, 2 locations, one for read, one for write
;	DVRDLP:
;	DVWRTLP:
;
;
; 036h	lds	si,SS:[????]				  ; ThisSFT
;	lds	si,si+7 				  ; sf_devptr
; 0E8h	call	????		<- "simulate" int28 event ; DSKSTATCHK
;
;
DOSP1_ID	db	036h,0C5h,036h
DOSP1_THISSFT	db	036h,005h,0C5h,074h,007h,0E8h
DOSP1_ID_LEN	equ	$-DOSP1_ID

		db	90h, 90h

DOSP12_ID	db	036h,0C5h,036h
DOSP12_THISSFT	db	036h,005h,0C5h,074h,007h,0E8h
DOSP12_ID_LEN	equ	$-DOSP1_ID


;
; Third/Fourth DOS patch - System call 3Fh (Read) from console
;
; Code in disk.asm, 1 location
;	GETBUF:
;
; 051h	push	cx	<- begin special int28 mode
;	push	es
;	push	di
;	mov	dx,???? ; offset dosgroup:CONBUF
;	call	????	; $STD_CON_STRING_INPUT
;	pop	di
;	pop	es
; 059h	pop	cx	<- end special int28 mode
;
DOSP3_ID	db	051h,006h,057h,0BAh
DOSP3_CONBUF	db	029h,002h,0E8h
DOSP3_ID_LEN	equ	$-DOSP3_ID
		db	09Ah,0E3h,05Fh,007h	; ???? , pop di, pop es
DOSP4_ID	db	059h			; pop cx
DOSP4_ID_OFF	equ	(DOSP4_ID - DOSP3_ID)
	
;
; Fifth DOS patch - System call 40h (Write) to console
;
;
; Code in disk.asm, 1 location
;
;		push	cx
;      WRCONLP: lodsb
;		cmp	al,1Ah
;		jz	????
;		call	????	<- "simulate" int28 event
;		loop	WRCONLP
;      CONEOF:	pop	ax
;
DOSP5_ID	db	051h			; push cx
		db	0ACh,03Ch,01Ah,074h,005h
		db	0E8h			; call
DOSP5_ID_LEN	equ	$-DOSP5_ID

;
; Seventh DOS patch - System call entry, patch USER_ID with VMid for share
;
; Code in disp.asm, 1 location
;
;
;	mov [SaveDS],ds
;	mov [SaveBX],bx
;	mov bx,cs
;	mov ds,bx
;	inc [indos]
;	xor ax,ax
;	mov [USER_ID],AX	<- Patch to set USER_ID to VMID
;
;
DOSP7_ID	db	02Eh,08Ch,01Eh
DOSP7_SAVEDS	db	07Eh,05h		; mov [SaveDS],ds
		db	02Eh,089h,01Eh
DOSP7_SAVEBX	db	07Ch,05h		; mov [SaveBX],bx
		db	08Ch,0CBh		; mov bx,cs
		db	08Eh,0DBh		; mov ds,bx
		db	0FEh,006h
DOSP7_INDOS	db	0CFh,002h		; inc [indos]
		db	033h,0C0h		; xor ax,ax
DOSP7_ID_LEN	equ	$-DOSP7_ID

;
; Eighth DOS patch - OWNER check in handle calls. For share, need to NOP test
;
; Code in handle.asm, 1 location in routine CheckOwner
;
;
;
;	push	ax
;	mov	ax,ss:[USER_ID]     <- patch to XOR AX,AX to set zero
;	cmp	ax,es:[di.sf_UID]   <- NOP
;	pop	ax
;	jz	????
;
;
;
DOSP8_ID	db	050h			; push ax
		db	036h,0A1h
DOSP8_USER_ID	db	0EAh,002h		; mov  ax,ss:[USER_ID]
		db	026h,03Bh,045h		; cmp  ax,es:[di+2F]
DOSP8_ID_LEN	equ	$-DOSP8_ID
		db	02Fh,058h		; pop  ax


;
; 10th, 11th, 12th DOS patch - System call 3Fh (Read) in raw mode
;
;   Take RAW read to STDIN SFT and turn it into a polling loop doing
;   a yeild when a character is not ready to be read.
;
; Code in disk.asm, 3 locations
;
;   DVRDRAW:
;	    PUSH    ES
;	    POP     DS
;   ReadRawRetry:				<- Patch 10
;	    MOV     BX,DI
;	    XOR     AX,AX			<- Reenter #2
;	    MOV     DX,AX
;	    call    SETREAD
;	    PUSH    DS				<- Reenter #1
;	    LDS     SI,[THISSFT]
;	    call    DEVIOCALL
;	    MOV     DX,DI
;	    MOV     AH,86H
;	    MOV     DI,[DEVCALL.REQSTAT]
;	    TEST    DI,STERR
;	    JZ	    CRDROK
;	    call    CHARHARD
;	    MOV     DI,DX
;	    OR	    AL,AL
;	    JZ	    CRDROK
;	    CMP     AL,3
;	    JZ	    CRDFERR
;	    POP     DS
;	    JMP     ReadRawRetry
;
;   CRDFERR:
;	    POP     DI				<- Patch 11
;   DEVIOFERR:
;	    LES     DI,[THISSFT]
;	    jmp     SET_ACC_ERR_DS
;
;   CRDROK:
;	    POP     DI				<- Patch 12
;	    MOV     DI,DX
;	    ADD     DI,[CALLSCNT]
;	    JMP     SHORT ENDRDDEVJ3
;
;
DOSP10_ID		db	006H,01FH
DOSP10_LOC_OFFSET	equ	$-DOSP10_ID
DOSP10_LOC		db	08BH,0DFH
DOSP10_REENT2_OFFSET	equ	$-DOSP10_LOC
			db	033H,0C0H,08BH,0D0H,0E8H
DOSP10_ID_LEN		equ	$-DOSP10_ID
			db	0DFH,00EH
DOSP10_REENT1_OFFSET	equ	$-DOSP10_LOC
			db	01EH,036H,0C5H,036H,036H,005H,0E8H,0AFH,00EH
			db	08BH,0D7H,0B4H,086H,036H,08BH,03EH
DOSP10_PACKVAL_OFFSET	equ	$-DOSP10_ID
			db	009H,003H
			db	0F7H,0C7H,000H,080H,074H,019H,0E8H,047H,017H
			db	08BH,0FAH,00AH,0C0H,074H,010H,03CH,003H,074H,003H
			db	01FH,0EBH,0CFH
DOSP11_LOC_OFFSET	equ	$-DOSP10_ID
			db	05FH
DOSP11_REENT_OFFSET	equ	$-DOSP10_LOC
			db	036H,0C4H,03EH,036H,005H,0E9H,0A1H,004H

DOSP12_LOC_OFFSET	equ	$-DOSP10_ID
			db	05FH,08BH,0FAH


;
; 13th DOS patch - Actually a SYSINIT patch. Patches the stack fault code
;		which prints the fatal stack fault error on DOS >= 3.20.
;
;	    Sets focus to current VM so user can see fatal message.
;
;
;	l0: lodsb		<- Setfocus here
;	    cmp al, '$'
;	    je l1
;	    mov bl, 7
;	    mov ah, 0Eh
;	    int 10h
;	    jmp l0
;	l1: jmp $
;
;
;
DOSP13_ID	db	0ACh			; l0: lodsb
		db	03Ch,024h		;     cmp al, '$'
		db	074h,008h		;     je l1
		db	0B3h,007h		;     mov bl, 7
		db	0B4h,00Eh		;     mov ah, 0Eh
		db	0CDh,010h		;     int 10h
		db	0EBh,0F3h		;     jmp l0
		db	0EBh,0FEh		; l1: jmp $
DOSP13_ID_LEN	equ	$-DOSP13_ID


DOSDATA	ends


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\yesno.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

; This is for contry Yes and No
  PUBLIC NLS_YES,NLS_yes2,NLS_NO,NLS_no2
include msdos.cl3

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\xmm.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1989-1991
;
;   Title:    EMM386 - MICROSOFT Expanded Memory Manager 386
;
;   Module:   XMM.INC - Definitions for extended memory manger (XMM)
;
;   Version:  0.01
;
;   Date:     Feb. 15, 1989
;
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   02/15/89  Original
;   02/19/89  pc	add other struct and equ
;
;******************************************************************************

XMM_MULTIPLEX						equ	43h	; XMM multiplex number of INT 2Fh
XMM_INSTALL_CHECK				equ	00h	; install check call
XMM_FUNCTION_ADDR				equ	10h	; get control function address call
;
; XMM functions
;
XMM_GET_VERSION					equ	00h
XMM_REQUEST_HMA					equ	01h
XMM_RELEASE_HMA					equ	02h
XMM_GLOBAL_ENABLE_A20		equ	03h
XMM_GLOBAL_DISABLE_A20	equ	04h
XMM_LOCAL_ENABLE_A20		equ	05h
XMM_LOCAL_DISABLE_A20		equ	06h
XMM_QUERY_A20						equ	07h
XMM_QUERY_FREE_EXTMEM		equ	08h
XMM_ALLOC_EMB						equ	09h
XMM_FREE_EMB						equ	0Ah
XMM_MOVE_EMB						equ	0Bh
XMM_LOCK_EMB						equ	0Ch
XMM_UNLOCK_EMB					equ	0Dh
XMM_GET_EMB_INFO				equ	0Eh
XMM_REALLOC_EMB					equ	0Fh
XMM_REQUEST_UMB					equ	10h
XMM_RELEASE_UMB					equ	11h
;
; All error codes has this bit on.
; Used for test sucess of XMM_QUERY_FREE_EXTMEM
;
XMM_ERROR_BIT						equ	80h

;
;  Previous HIMEM.SYS versions are not reliable
;
GOOD_HIMEM_VERSION			equ	208h

;
; struct pass to XMM_MOVE_EMB in DS:SI
;
ExtMemMoveStruct	struc
	mov_length	dd	?	; 32 bit number of bytes to transfer
	src_handle	dw	?	; handle of source block
	src_offset	dd	?	; 32 bit offset into source
	dst_handle	dw	?	; handle of destination block
	dst_offset	dd	?	; 32 bit offset into destination
ExtMemMoveStruct	ends

.list		; end of XMM.INC

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\backup\backup.h ===
/***************************************************************************/
/* 																								*/
/* BACKUP.H																						*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* Include file with definitions for RUP backup utility. These structures	*/
/* follow the standard backup layout of MS-DOS 3.30 backup and restore.		*/
/*																									*/
/* Created 07-13-89 johnhe																	*/
/*																									*/
/***************************************************************************/


#define		MALLOC_MEMORY			20000L	/* Max size for malloc()	*/
#define		MIN_COPY_BUFFER		5000L		/* Min size for cpy buffer	*/

#define		READ						0
#define		WRITE						1

#define		BACKUP					0			/* Backup modes */
#define		CONTROL					1
#define		COUNT						2

#define		ESC						0x1b		/* Ascii ESC character	*/

#define		ABORT						-1			/* Misc error codes */
#define		OK							0
#define		ERROR						-1
#define		BAD_MEDIA				1
#define		BAD_HARDWARE			2
#define		BAD_SOURCE				3
#define		DOOR_OPENED				4
#define		LAST_DISK				256
#define		REDO_DISK				257
#define		NOT_FOUND				258

#define		PLEASE_WAIT				64

#define		CLUSTERS_360K			512 * 2		/* Clusters on a 360K disk	*/
#define		MAX_DIR_DEPTH			33				/* Really 32 */

#define		DISK_REC_LEN			sizeof( struct Disk_Header )
#define		DIR_REC_LEN				sizeof( struct Dir_Block )
#define 		FILE_REC_LEN			sizeof( struct File_Header )

#define		RECS_LEN					sizeof( struct RECORDS )
#define		STATE_LEN				sizeof( struct INFO_STATE )

													/* Find all files */
#define		_A_FILE 					( _A_HIDDEN | _A_SYSTEM  )
													/* Find all files and subdirs */
#define		_A_ALLDIR				(_A_FILE | _A_SUBDIR)

#define		DOS_O_RDWR 				2	/* DOS create for read and write */


#define		LAST_TARGET				0xFF			/* -1 ==  Last disk */
#define		NOT_LAST_TARGET		0x00			/*  0 ==  !Last disk */
#define		LAST_DB					0xFFFFFFFF	/* -1L == Last dir block */

#define		LASTPART					1		/* Flags used in file headers */
#define		NOTSUCCESSFUL			0
#define		SUCCESSFUL				2
#define		NOTLASTPART				0

#define		MAX_DOS_DRIVES			26

#define		ROOTDIR					0		/* Level of root directory */

#define		BYTE						unsigned char
#define		WORD						unsigned short
#define		DWORD						unsigned long

#define		FAR						far
typedef		void						VOID;

/***************************************************************************/
/*                                                             				*/
/*    CONTROL BLOCK FOR EACH BACKUP DISKETTE		       							*/
/*                                                             				*/
/*    THIS STRUCTURE WILL MAKE UP THE FIRST DH_DHLength BYTES  				*/
/*    OF THE control.xxx FILE ON THE BACKUP TARGET.	       					*/
/*    IT IDENTIFIES THE DISK AS BEING A BACKUP, AND INCLUDES   				*/
/*    DISKETTE SEQUENCE NUMBER, PLACE FOR ORIGINAL PARAMETERS  				*/
/*    ENTERED FROM THE COMMAND LINE, AND A BYTE INDICATING THE					*/
/*    LAST TARGET, AND LENGTHS OF OTHER DATA STRUCTURES.       				*/
/*                                                             				*/
/***************************************************************************/

struct Disk_Header
{
	UCHAR		Len;						/* Length, in bytes, of disk header	*/
	UCHAR		Id[8];					/* Identifies disk as a backup	   */
	UCHAR		Seq;						/* Backup diskette sequence num    	*/
											/*    (binary 1 255)		   			*/

	UCHAR		CmdLine[128];			/* Save area for command line	   	*/
											/*     parameters.		   			*/

	UCHAR		IsLast; 					/* Indicates if this is last target */
											/* 0xFF if last target, 0 otherwise	*/
};


/***************************************************************************/
/*                                                                      	*/
/*    DIRECTORY BLOCK																		*/
/*                                                                      	*/
/*  THIS STRUCTURE IS WRITTEN TO THE control.xxx FILE AT LEAST ONCE			*/
/*  FOR EACH SUBDIRECTORY, INCLUDING THE ROOT, BACKED UP. IT SAVES			*/
/*  THE PATH TO THAT DIRECTORY, THE NUMBER OF FILES FROM THAT					*/
/*  DIRECTORY THAT ARE BACKED UP ON THE TARGET, AND A POINTER 					*/
/*  TO THE NEXT DIRECTORY BLOCK ON THAT DISKETTE, IF ONE EXISTS.				*/
/*  IF THERE IS NO OTHER DIRECTORY BLOCK, IT EQUALS  1. THERE IS ALSO A		*/
/*  RESERVED AREA FOR FUTURE POSSIBLE EXPANSION. AFTER THE RESERVED AREA	*/
/*  COMES AN ARRAY OF db_num_entries FileHeaders, DESCRIBED BELOW.			*/
/*                                                                     		*/
/***************************************************************************/

struct Dir_Block
{
	UCHAR		Len;				/* Length, in bytes, of dir block */
	UCHAR		Path[63];
									/* ASCII path of this directory,  */
									/* drive letter omitted 	  */
	UINT		Entries;			/* # of filenames in list for this disk */
	LONG		NextDir;			/* Offset of next directory block on this disk */
};									/* =0xffffffff if last dir block on this disk  */


/***************************************************************************/
/*                                                                    		*/
/*    CONTROL BLOCK FOR EACH BACKED UP FILE			      						*/
/*                                                                    		*/
/*  THIS STRUCTURE WILL BE REPEATED AFTER THE DIRECTORYBLOCK ONCE     		*/
/*  FOR EACH FILE BACKED UP FROM THAT DIRECTORY. IT CONTAINS THE      		*/
/*  FILENAME, DIRECTORY INFORMATION, AND OTHER NECESSARY INFORMATION. 		*/
/*                                                                    		*/
/***************************************************************************/

struct File_Header
{
	UCHAR		HeadLen;				/* length, in bytes, of file header			*/
	UCHAR		Name[12];			/* ascii file name		   					*/
	UCHAR		Flags;				/* bit 0=1 if last part of file    			*/
										/* bit 1=1 if it is backed  up successfully*/
	LONG		FileLen;				/* length of the file		   				*/
	UINT		Seq;					/* sequence #, files that span disks  		*/
	LONG		Offset;				/* offset of this file in BACKUP.???		*/
	LONG		PartSize; 			/* length of this part of file	   		*/
	UINT		Attrib;				/* file attribute from directory   			*/
	struct TIME	Time;				/* time when file was created	   			*/
	struct DATE	Date;				/* date when file was created	   			*/
};

/***************************************************************************/
/*                                                                    		*/
/*	CURRENT_DISK																				*/
/*                                                                    		*/
/* Structure to hold all current information about the disk being backed	*/
/* up.																							*/
/*                                                                    		*/
/***************************************************************************/

struct CURRENT_DISK
{
	UCHAR		Seq;					/* Backup diskette sequence number 	*/
	UINT		Flags; 				/*												*/
	UCHAR		Type; 				/* Type of disk from format table	*/
	LONG		DiskSize;			/* Total bytes on empty disk			*/
	LONG		Written; 			/* Total bytes already written		*/
	LONG		Free; 				/* Total bytes still available		*/
	LONG		OffsetDir;		  	/* Offset in file of last DIR record */
};

/***************************************************************************/
/*                                                                    		*/
/*	CTRL_FILE																					*/
/*                                                                    		*/
/* Structure to hold all current information about the control file being	*/
/* built.																						*/
/*                                                                    		*/
/***************************************************************************/

struct CTRL_FILE
{
	LONG		Offset;				/* Total current offset in the file */
	LONG		DirRecOffset;		/* Offset of current DIR entry in the file */
	LONG		DiskUsed;			/* Total disk space used by this file */
	LONG		FileRecOffset;		/* Offset of current FILE entry in the file */
};


/***************************************************************************/
/*                                                                    		*/
/*	BKUP_FILE																					*/
/*                                                                    		*/
/*	Structure to hold all current information about the backup file being	*/
/* built.																						*/
/*                                                                    		*/
/***************************************************************************/

struct BKUP_FILE
{
	LONG		Offset;				/* Total current offset in the file */
	LONG		DiskUse;				/* Total disk space used by this file */
};
	
	
/***************************************************************************/
/*                                                                    		*/
/*	WR_BUF_INFO																					*/
/*																									*/
/* Status structure which contains the currents status of the disk			*/
/* write buffer.																				*/
/*                                                                    		*/
/***************************************************************************/

struct WR_BUF_INFO
{
	UCHAR huge	*Start;			/* Far ptr to start of buffer */
	UCHAR huge	*Next;

	LONG			BufOffset;		/* Current offset for appending to file */
	LONG			FileOffset;		/* Offset in file where start of buffer is */

	LONG			BufLen;			/* Total length of the buffer */
	LONG			BytesFree;		/* Number free  bytes left in the buffer */
};

/***************************************************************************/
/*                                                                    		*/
/* Structure used for 2 work areas during backup. The second work area		*/
/* will be a duplicate of the first at the start of a disk copy so it can	*/
/* be used if it is necessary to redo an unuse-able diskette.					*/
/* 																								*/
/*                                                                    		*/
/***************************************************************************/

struct INFO_STATE
{
	char						Path[ MAX_PATH_LEN ];		/* Current search path	*/
	struct find_t			Info[ MAX_DIR_DEPTH + 1 ];	/* Directory FCBs			*/
};

struct RECORDS
{
	struct Disk_Header	Header;							/* Current disk header	*/
	struct Dir_Block		Dir;								/* Current dir struct	*/
	struct File_Header	File;								/* Current file struct	*/
	struct File_Header	pPrevFile;						/* Previous file struct	*/
};																	/* from previous disk	*/

/***************************************************************************/
/* Function prototypes for all extern functions in  BACKUP.C					*/
/***************************************************************************/

extern int	Backup			( char chSourceDrv, char chDestDrv );
extern long	GetMaxHugeSize	( void );
extern int	CloseFile		( int *iFileHandle, int iStatus );
extern long	GetDiskFree		( int DrvLetter );
extern long	CalcDiskFree	( void );
extern int	InitCpyBuffer	( void );

/***************************************************************************/
/* Function prototypes for all static functions in  BACKUP.C					*/
/***************************************************************************/

static int	DoBackup			( int DiskNum, int IsBackup );
static int	MainBkupLoop	( int iTotalDisks );
static int	InitBkupDisk	( int DiskNum );
static void	IncPath			( void );
static void	DecPath			( void );
static void	InitGlobals		( void );
static void SaveState		( void );
static void RestoreState	( void );
static int	GetNextFile		( void );
static int	IsValidName		( void );
static int	FindFirst		( void );
static int	FindNext			( void );
static void SetPathName		( void );
static void	InitBkupFileName( int DiskNum );
static void	CreatNewDirRec	( void );
static int	AddCtrlHeader	( int DiskNum, int iMode );
static int	AddDirRec		( void );
static int	UpdateDirRec	( int iIsLastDirRec );
static int	AddFileRec		( void );
static int	BuildFileRec	( void );
static void GetFileRec		( void );
static int	ProcessNextFile( void );
static int	CloseOutDisk	( int iLastDisk, int IsLastDisk );
static int	ExtendBkFile	( int DiskNum );
static int	OpenDest			( int *iFile, int DiskNum, char *szFileName,
									  int iAttrib );

/***************************************************************************/
/* Function prototypes for all functions in  BUFFER.C								*/
/***************************************************************************/

extern INT	BufAppend			( VOID FAR *vPtr, UINT uBytes );
extern INT	BufSeekWrite		( VOID *vPtr, UINT uBytes, LONG lOffset );
extern INT	DoWrite				( VOID *vPtr, LONG lOffset, UINT Bytes );
extern INT	DoSeek				( LONG Offset );
extern INT	BufFlush				( VOID );
extern VOID	BufInit				( VOID );
extern INT	BufCopyFile			( char *szPath, LONG lOffset, LONG lBytes );
extern CHAR	FAR *NormalizePtr	( char far *Ptr );

/***************************************************************************/
/* Function prototypes for extern functions found in misc other modules		*/
/***************************************************************************/

extern void		ShowFileStatus( char *szFileName, int ReadWrite );
extern int		GetCurrentFileStr	( char *szStr );
extern void		NoFilesPrompt		( void );
extern int		CalcPrompt			( void );
extern int		PrepBkupDsk			( int DiskNum );
extern void		NotFormattedPrompt( void );
extern int		ProcDiskErr			( int ErrorType );

void	ProgramCleanUp		( int );
void	ProgramAbort		( void );

/***************************************************************************/
/* End of file BACKUP.H																		*/
/***************************************************************************/


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\_parse.asm ===
page           60,132
name           _parse
title          C to PARSER interface

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;-------------------------------------------------------------------
;
;       MODULE:         _parse
;
;       PURPOSE:        Supplies an interface between C programs and
;                       the DOS 3.30 parser
;
;       CALLING FORMAT:
;                       parse(&inregs,&outregs);
;
;       DATE:           5-21-87
;
;-------------------------------------------------------------------

;       extrn   sysparse:far

        public  _parse

;-------------------------------------------------------------------

; SET FOR SUBST
; -------------

FarSW   equ     0       ; make sysparse be a NEAR proc
TimeSW  equ     0       ; Check time format
FileSW  equ     1       ; Check file specification
CAPSW   equ     1       ; Perform CAPS if specified
CmpxSW  equ     0       ; Check complex list
NumSW   equ     0       ; Check numeric value
KeySW   equ     0       ; Support keywords
SwSW    equ     1       ; Support switches
Val1SW  equ     0       ; Support value definition 1
Val2SW  equ     0       ; Support value definition 2
Val3SW  equ     0       ; Support value definition 3
DrvSW   equ     1       ; Support drive only format
QusSW   equ     0       ; Support quoted string format
;-------------------------------------------------------------------

_DATA   segment byte public 'DATA'
_DATA   ends

_TEXT   segment byte public 'CODE'

        ASSUME  CS: _TEXT
        ASSUME  DS: _DATA

;-------------------------------------------------------------------
include parse.asm               ; include the parser
;-------------------------------------------------------------------

_parse  proc    near

        push    bp              ; save user's base pointer
        mov     bp,sp           ; set bp to current sp
        push    di              ; save some registers
        push    si

;       copy C inregs into proper registers

        mov     di,[bp+4]       ; fix di (arg 0)

;-------------------------------------------------------------------

        mov     ax,[di+0ah]     ; load di
        push    ax              ; the di value from inregs is now on stack

        mov     ax,[di+00]      ; get inregs.x.ax
        mov     bx,[di+02]      ; get inregs.x.bx
        mov     cx,[di+04]      ; get inregs.x.cx
        mov     dx,[di+06]      ; get inregs.x.dx
        mov     si,[di+08]      ; get inregs.x.si
        pop     di              ; get inregs.x.di from stack

        push    bp              ; save base pointer

;        int     3               ; debugger

;-------------------------------------------------------------------
        call    sysparse        ; call the parser
;-------------------------------------------------------------------

;        int     3               ; debugger

        pop     bp              ; restore base pointer
        push    di              ; the di value from call is now on stack
        mov     di,[bp+6]       ; fix di (arg 1)

        mov     [di+00],ax      ; load outregs.x.ax
        mov     [di+02],bx      ; load outregs.x.bx
        mov     [di+04],cx      ; load outregs.x.cx
        mov     [di+06],dx      ; load outregs.x.dx
        mov     [di+08],si      ; load outregs.x.si

        xor     ax,ax           ; clear ax
        lahf                    ; get flags into ax
        mov     [di+0ch],ax     ; load outregs.x.cflag

        pop     ax              ; get di from stack
        mov     [di+0ah],ax     ; load outregs.x.di

;-------------------------------------------------------------------

        pop     si              ; restore registers
        pop     di
        mov     sp,bp           ; restore sp
        pop     bp              ; restore user's bp
        ret

_parse  endp

_TEXT   ends                    ; end code segment
        end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\backup\backup.c ===
/***************************************************************************/
/*																									*/
/* BACKUP.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* Backup utility for the MS-DOS 4.0 retail upgrade. These functions will	*/
/* backup a specified disk to another specified disk. Then entry point to	*/
/* the utiltity is BackUp(). The file copying is buffered using an area of	*/
/* memory which as allocated previously by a call to InitCpyBuffer().		*/
/* Most functions communicate via a group of static global variables to		*/
/* keep the size of code to a mininum. 												*/
/*																									*/
/* All code is written so that it will run under MS-DOS version 2.11 and	*/
/* above. The backup format is restorable with versions of DOS 3.3 and		*/
/* above.																						*/
/* 																								*/
/* Created 07-12-89 johnhe																	*/
/***************************************************************************/

#include		<stdio.h>
#include		<stdlib.h>
#include		<malloc.h>
#include 	<dos.h>
#include 	<fcntl.h>
#include		<io.h>
#include 	<string.h>
#include		<ctype.h>
#include		<bios.h>
#include		<sys\\types.h>
#include		<sys\\stat.h>

#include		<alias.h>
#include		<strlib.h>
#include		<disk_io.h>
#include		<fmt_io.h>
#include		<hdisk.h>
#include 	<window.h>
#include		<backup.h>

/***************************************************************************/
/* Static globals for this module.														*/
/* 																								*/
/* NOTE: pchCpyBuffer must be allocated at program initialization being		*/
/*			sure to leave enough DOS memory for the the rest of the program	*/
/*			to use through malloc. This is necessary because malloc doesn't	*/
/*			release DOS memory allocations until the end of the program and	*/
/*			this can cause large chunks for non-contiguous block which aren't	*/
/*			suitable for use by this module's file copy functions.				*/
/*																									*/
/***************************************************************************/


char huge			*pchCpyBuffer;			/* Huge buffer for files				*/
long					lBufSize;				/* Number of bytes int pchCpyBuffer */

char					chDestin;				/* Destination drive character		*/
char					chSource;				/* Destination drive character		*/

		/* Info will be allocated as an array of FCB structures for use		*/
		/* while transversing the levels of the disk directory. iDepth will	*/
		/* always indice the current directory level									*/

static struct INFO_STATE	*InfoState;	/* Buffer for current search states */
static struct find_t	*Info;				/* Array of FCB structures				*/
static char			*szPath;					/* Current DOS find search path		*/


static int			iDepth;					/* Info structure indice				*/
static int			iAttrib;					/* Current search attribute			*/

static int			OldDepth; 				/* Hold depth at start of disk 		*/
static int			OldAttrib; 				/* Holds attrib at start of disk		*/
static long			lOldFileOffset;		/* File offset at start of disk		*/

static int			iCtrlHandle = -1;		/* Control file handle					*/
static int			iBkupHandle = -1;		/* Backup file handle					*/

char					*szCtrlFile = "X:\\CONTROL.XXX      ";	/* File names */
char					*szBkupFile = "X:\\BACKUP.XXX       ";
char					*szDiskLabel= "BACKUP  000          ";	/* Disk label */


static struct RECORDS		*Records; 	/* Buffer for all the records */

static struct Disk_Header	*pHeader; 	/* The current ctrl file records */
static struct Dir_Block		*pDir;
static struct File_Header	*pFile;
static struct File_Header	*pPrevFile;

int					iBkupMode;				/* May be CONTROL, BACKUP or COUNT	*/
LONG					lDiskSize;				/* Bytes available on current disk	*/
int					iCount;					/*	Current disk number					*/


static int			iNewPath;				/* Flags that dir just changed		*/
static int			iDiskFull; 				/* Flags that disk is full				*/

static long			lCtrlOffset;			/* Current offset in Control file	*/
static long			lBkupOffset;			/* Current offset in Backup file		*/
static long			lFileOffset;			/* Offset in file being backed up	*/

static int			iBytesPerClus = CLUSTERS_360K; /* Default for 360K disk	*/

unsigned long	StartTime;					/* Time and date of first disk used	*/
unsigned long	LastTime;					/* Time and date of last disk used	*/


static int			iDskFmtType;			/* Default disk format, set by user	*/


/***************************************************************************/
/* Entry point for RUP backup function. Accepts a source and destination	*/
/* drive character and then proceeds to backup all files on the source to	*/
/* the destination drive, first prompting the user to insert the proper		*/
/* disks and formating any disk which is not formatted. Is responsible for	*/
/* allocating all buffers and initializing all static globals for this 		*/
/* modules but it is assumed that pchCpyBuffer has already been allocated.	*/
/* After intialization a loop gets the next filename on the hard disk and	*/
/* then calls CopyFile() to copy the file. After completion all buffers		*/
/* are freed. NOTE: pchCpyBuffer must never be freed.								*/
/*																									*/
/* void Backup( char chSourceDrv, char chDestDrv )									*/
/*																									*/
/*	ARGUMENTS:	chSource	 - Source drive letter.										*/
/*					chDestDrv -	Destination drive letter.								*/
/*	RETURNS:		void																			*/
/*																									*/
/*	GLOBALS:		iDepth	- Initializes to -1											*/
/*					szPath	- Allocates and initializes to "X:\", deallocates	*/
/*					chSource	- Initializes to source drive character				*/
/*					chDestin	- Initializes to destination drive characater		*/
/*					Info		- Allocates and deallocates memory for this buffer	*/
/*																									*/
/***************************************************************************/

int Backup( char chSourceDrv, char chDestDrv )
{
	register		iStatus;					/* Return status	*/
	register		i;							/* Loop counter	*/
	extern char	FmtDrvLst[];

	if ( !FmtDrvLst[ chSourceDrv - 'A'] )
	{
		NotFormattedPrompt();
		return( OK );
	}
										/* Set source and destination drives */
	chSource = chSourceDrv;
	chDestin = chDestDrv;

	InitGlobals();					/* Allocate buffers and initialize statics */
	lDiskSize = 362496L;			/* Base on 360K disk and then convert later */
	SaveState();					/* Save starting search state	*/
	CalcPrompt();					/* Display please wait prompt */

 										/*	Count the need 360K disks	*/
	for( i = 1, iStatus = OK; iStatus == OK; i++ )
		iStatus = DoBackup( i, COUNT );

	i--;								/* Ajust for starting at disk 1 */
	RestoreState();				/* Restore the find first state to root dir	*/

										/* Make sure first disk contains some files	*/
										/* by checking the length of the ctrl file	*/
	if ( i == 1 && lCtrlOffset <= (long)(DISK_REC_LEN)  )
		NoFilesPrompt();

 										/* See if user has enough disks */
	else if ( (iStatus = DisplayDiskTotals( i )) == OK )
		iStatus = MainBkupLoop( i );				/* Do the backup */

	FreeMemory( InfoState );	/* Clean up */
	FreeMemory( Records );

	return( iStatus == NOT_FOUND ? OK : iStatus );
}

/***************************************************************************/
/* Main loop to backup a hard drive. Prompt user to insert a disk and then	*/
/* backs up to the disk and then updates the gas gage. The backup loop 		*/
/* first builds the control file on the disk and then builds the backup		*/
/* file. On entry to the function the directory search state must be			*/
/* setup for starting at the directory depth where the backup is to start.	*/
/*																									*/
/*	int MainBkupLoop( int iTotalDisks )													*/
/*																									*/
/*	ARGUMENTS:	iTotalDisks	- Total number of disks to fill gas gage.			*/
/*																									*/
/*	RETURNS:		int			- NOT_FOUND if complete else error code			*/
/*																									*/
/***************************************************************************/

static int MainBkupLoop( int iTotalDisks )
{
	register	i;							/* Loop counter					*/
	register	iStatus;					/* Return value					*/
	extern long		lTotalBytes;

	lTotalBytes	= iTotalDisks * 362496L;
	DisplayGage();
	UpdateByteCount( -1L );
											/* Loop until all disk have been */
											/* done or an error is detected	*/
	for( i = 1, iStatus = OK; iStatus == OK; i++ )
	{
											/* Loop to allow re-doing a disk	*/
		do
		{
			if ( iStatus == REDO_DISK )
				RestoreState();		/* Restore state to re-do the disk	*/
			else
				SaveState();			/* Else save the current state		*/

											/* Initialize the next disk			*/
			if ( (iStatus = InitBkupDisk( i )) == OK )
			{
				HelpLine( PLEASE_WAIT );				/* Update help line	*/
				iStatus = DoBackup( i, CONTROL );	/* Create ctrl file	*/
				if ( iStatus == OK || iStatus == NOT_FOUND )
				{
					RestoreState();	/* Reset state and create backup file */
					iStatus = DoBackup( i, BACKUP );
				}
			}

			DisplayFileStatus( "", CLEAR );
		}
		while( iStatus == REDO_DISK );
	}

	return( iStatus );
}

/***************************************************************************/
/* Saves the current state of the directory search by coping the current	*/
/*	FCB structures	and current indices to the structures. Must also save		*/
/* the name of the last file that was found to allow continuing with a		*/
/* file that 																					*/
/* is spread across backup disks.														*/
/*																									*/
/*	void SaveState( void )																	*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/* RETURNS:		void																			*/
/*																									*/
/***************************************************************************/
static void SaveState( void )
{
	OldDepth = iDepth;
	OldAttrib = iAttrib;
	lOldFileOffset = lFileOffset;
	memcpy( InfoState + 1, InfoState, STATE_LEN );
	memcpy( pPrevFile, pFile, FILE_REC_LEN );
}

/***************************************************************************/
/* Restores the current state of the directory search by coping the current*/
/*	FCB structures	and current indices to the structures. Must also restore	*/
/* the name of	the last file that was found to allow continuing with a		*/
/*	file that is spread across backup disks.											*/
/*																									*/
/*	void RestoreState( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/* RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

static void RestoreState( void )
{
	iDepth = OldDepth;
	iAttrib = OldAttrib;
	lFileOffset = lOldFileOffset;
	memcpy( InfoState, InfoState + 1, STATE_LEN );
	memcpy( pFile, pPrevFile, FILE_REC_LEN );
}

/***************************************************************************/
/* Finds the next file on the source disk. Uses the DOS findfirst-findnext	*/
/* functions to find the next file in the current directory. If the next	*/
/* file name is a directory entry the function will appened this name to	*/
/* search path in "szPath" and then does an call to findfirst to get the	*/
/* next file name from this new directory level. If a call to FindNext()	*/
/* returns an error it signals there are no more files in the current		*/
/* directory so the last level directory name is striped from szPath and	*/
/* the search continues on the previous level. iDepth will always index		*/
/* the current directory level in the Info structures. If iDepth == -1 on	*/
/* the function will start the search in the root directory.					*/
/*																									*/
/*	static int GetNextFile( void )														*/
/*																									*/
/*	ARGUMENTS:	void																			*/
/*	GLOBALS:		iDepth	- Must contain current directory level	or -1			*/
/*					szPath	- Must contain current directory search string		*/
/*					iAttrib	- If not first call to the function it must be 		*/
/*								  be initialize to _A_FILE or _A_ALLDIR				*/
/*																									*/
/* RETURNS:		int		- OK if a filename was found. Upon return the		*/
/*								  file name will be in Info[iDepth].name and the	*/
/*								  directory will be the base part of szPath.			*/
/*								  ELSE !OK														*/
/*	GLOBALS:		iDepth	- Updates value to current directory level			*/
/*					szPath	- Updates string to current directory path			*/
/*					Info		- Updates Info[iDepth] with file info					*/
/*					iAttrib	- Is updated based on the current search 				*/
/*																									*/
/***************************************************************************/

static int GetNextFile( void )
{
	register		iStatus;		/* Return status */

					/* See if first call */
	if ( iDepth != -1 )
		iStatus = FindNext();
	else
	{
		iDepth = 0;
		iAttrib = _A_FILE;
		iStatus = FindFirst();
	}
						
				/* Check for need to move to another directory level */
	while( (iStatus == OK && iAttrib == _A_ALLDIR) ||
			 (iStatus != OK && iDepth > 0 ) )
	{
		if ( iStatus == OK )
		{ 									/* Move down a level */
			IncPath();
			iStatus = FindFirst();
		}
		else
		{ 									/* Move back up a level */
			DecPath();
			iStatus = FindNext();
		}
	}

	return( iStatus == OK ? iStatus : NOT_FOUND );
}

/***************************************************************************/
/* Finds the first valid file name or directory name in a directory. Will	*/
/* skip over the current or parent directory entry. 								*/
/*																									*/
/*	static int FindFirst( void )															*/
/*																									*/
/*	ARGUMENTS:	void																			*/
/*	GLOBALS:		iDepth	- Must contain current directory level	or -1			*/
/*					szPath	- Must contain current directory search string		*/
/*																									*/
/* RETURNS:		int		- OK if a filename was found. Upon return the		*/
/*								  file name will be in Info[iDepth].name ELSE !OK	*/
/*	GLOBALS:		Info		- Updates Info[iDepth] with file info					*/
/*					iAttrib	- Is updated based on the current search 				*/
/* 																								*/
/***************************************************************************/

static int FindFirst( void )
{
	int		iStatus;

					/* Get the first file name in this directory if		*/
					/* search for file fails then try for subdirectory	*/
	iStatus = _dos_findfirst( szPath, iAttrib, &Info[iDepth] );
	if ( iStatus != OK && iAttrib == _A_FILE )
	{
		iAttrib = _A_ALLDIR;
		iStatus = _dos_findfirst( szPath, iAttrib, &Info[iDepth] );
	}

					/* If not a valid file name then get the first valid one */
	if ( iStatus == OK && !IsValidName() )
		iStatus = FindNext();

	return( iStatus );
}

/***************************************************************************/
/* Finds the next valid file name or directory name in a directory. Will	*/
/* skip over the current or parent directory entry. 								*/
/*																									*/
/*	static int FindNext( void )															*/
/*																									*/
/*	ARGUMENTS:	void																			*/
/*	GLOBALS:		iDepth	- Must contain current directory level					*/
/*					szPath	- Must contain current directory search string		*/
/*					iAttrib	- Must be initialize to _A_FILE or _A_ALLDIR			*/
/*																									*/
/* RETURNS:		int		- OK if a filename was found. Upon return the		*/
/*								  file name will be in Info[iDepth].name ELSE !OK	*/
/*	GLOBALS:		Info		- Updates Info[iDepth] with file info					*/
/*					iAttrib	- Is updated based on the current search 				*/
/* 																								*/
/***************************************************************************/

static int FindNext( void )
{
	int		iStatus;

			/* Loop until a valid file name or no more files	*/
			/* If find next fails for file call FindFirst to	*/
			/* see if any directories are in the path.			*/
	do
	{
		if ( (iStatus = _dos_findnext( &Info[iDepth] )) != OK &&
				iAttrib == _A_FILE )
		{
			iAttrib = _A_ALLDIR;
			iStatus = FindFirst();
		}
	}
	while ( iStatus == OK && !IsValidName() );

	return( iStatus );
}

/***************************************************************************/
/* Check the name in Info[iDept] and returns TRUE if the name is not a the	*/
/* current or parent directory entry and not a volume label and iAttrib	is	*/
/* set to _A_SUBDIR. If iAttrib == _A_FILE then only the file's attribute	*/
/* bit is checked to be sure it's not a subdirectory.								*/
/* 																								*/
/*	int IsValidName( void )																	*/
/*																									*/
/*																									*/
/*	ARGUMENTS:	void																			*/
/*	GLOBALS:		iDepth	- Must contain current directory level					*/
/*					Info		- Must be initialized at iDepth level					*/
/*					iAttrib	- Must be initialize to _A_FILE or _A_ALLDIR			*/
/*																									*/
/* RETURNS:		int		- TRUE if a valid file name in Info[iDepth]			*/
/*								  else FALSE													*/
/* 																								*/
/***************************************************************************/

static int IsValidName( void )
{
	int		iStatus;

	iStatus = FALSE;

	if ( iAttrib == _A_ALLDIR )
	{
		if ( strcmp( Info[iDepth].name, "." ) != 0 )
			if ( strcmp( Info[iDepth].name, ".." ) != 0 )
				if ( (Info[iDepth].attrib & _A_SUBDIR ) != 0 )
						iStatus = TRUE;
	}
	else if ( (Info[iDepth].attrib & (_A_SUBDIR | _A_VOLID)) == 0 )
		iStatus = TRUE;

	return( iStatus );
}

/***************************************************************************/
/* Creats a new search path and increments the search level by appends the	*/
/* name in Info[iDepth].name to the current search path and then				*/
/* incrementing iDepth.																		*/
/*																									*/
/* static void IncPath( void )															*/
/*																									*/
/* ARGUMENTS:	void																			*/
/*	GLOBALS:		iDepth	- Must contain current directory level					*/
/*					szPath	- Must contain current directory search string		*/
/*																									*/
/* RETURNS:		void																			*/
/*	GLOBALS:		szPath	- Updates string to next directory level path		*/
/*					iDepth	- Increments to next directory level					*/
/*					iNewPath - Set this flag to TRUE										*/
/*																									*/
/***************************************************************************/
static void IncPath( void )
{

	*(ParseFileName( szPath )) = EOL;
	strcat( szPath, Info[iDepth].name );
	strcat( szPath, "\\*.*" );
	iDepth++;
	iAttrib = _A_FILE;
	iNewPath = TRUE;
}


/***************************************************************************/
/* Creats a new search path and decrements the search level by parsing out	*/
/* the last directory name in the path part of the string and then			*/
/* decrementing iDepth.																		*/
/*																									*/
/* static void IncPath( void )															*/
/*																									*/
/* ARGUMENTS:	void																			*/
/*	GLOBALS:		iDepth	- Must contain current directory level					*/
/*					szPath	- Must contain current directory search string		*/
/*																									*/
/* RETURNS:		void																			*/
/*	GLOBALS:		szPath	- Updates string to previous directory level path	*/
/*					iDepth	- Decrements to previous directory level				*/
/*					iNewPath - Set this flag to TRUE										*/
/*																									*/
/***************************************************************************/

static void DecPath( void )
{
	*(ParseFileName( szPath ) - 1) = EOL;
	*(ParseFileName( szPath )) = EOL;
 	strcat( szPath, "*.*" );
	iDepth--;
	iAttrib = _A_ALLDIR;
	iNewPath = TRUE;
}

/***************************************************************************/
/* Initializes all global variables to set the search state to the root		*/
/* directory of the drive specified in chSource. Allocates all FCB buffers,*/
/* path string buffers and ctrl file field buffers and then builds the 		*/
/* starting path string to "X:*.*"														*/
/*																									*/
/*	void InitGlobals( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/* RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

static void InitGlobals( void )
{
			/* Allocate memory for assign all static global pointers */

	InfoState = GetMemory( STATE_LEN * 2 );
	Records   = GetMemory( RECS_LEN );

	szPath	= &(InfoState[0].Path[0]);
	Info		= &(InfoState[0].Info[0]); 

	pHeader	= &(Records->Header);
	pDir		= &(Records->Dir);
	pFile		= &(Records->File);
	pPrevFile= &(Records->pPrevFile);

							/* Signal first call to GetNexFile() */
	iDepth = -1;
							/* Initialize the path buffer */
	BuildPath( szPath, chSource, "\\", "*.*" );

							/* Initialize the control file record */
	pHeader->Len = sizeof ( struct Disk_Header );
   strcpy( pHeader->Id, "BACKUP  " );
   pHeader->Seq = 0;
   memset( pHeader->CmdLine, 0, sizeof( pHeader->CmdLine ) );
   pHeader->IsLast = FALSE;

							/* Initialize directory block record */
	pDir->Len = sizeof( struct Dir_Block );
	pDir->Entries = 0;
	pDir->NextDir = -1L;

							/* Initialize file block record */
	pFile->HeadLen = sizeof( struct File_Header );
	pFile->FileLen = -1L;		/* Mark the record as never been used */
	pFile->PartSize = 0L;

	lFileOffset = 0L;				/* Set offset into current file */
}


/***************************************************************************/
/* 																								*/
/***************************************************************************/

static int DoBackup( int DiskNum, int iMode )
{
	register			iStatus;
	register			iCloseStatus;
	extern int		iHandle;

	BufInit();				/* Get ready to write new file */
	
			/* Set file handle for BACKUP.??? or CONTROL.??? depending */
			/* whether we're creating the control file or coping files */
	iHandle = (iMode == BACKUP ? iBkupHandle : iCtrlHandle);

	iBkupMode = iMode;	/* Set global to show if ctrl file or file copy		*/
	iNewPath	= TRUE;		/* Need to force creation of the first DIR record	*/
	iDiskFull = FALSE;	/* Disk isn't full, it should be blank					*/
	pDir->Entries = -1;	/* Tell UpdateDirRec() that 1st rec not created yet*/
	lCtrlOffset = 0L;		/* Reset Ctrl file offset indice */
	lBkupOffset	= 0L;		/* Reset Backup file offset indice */

					/* Write the backup control file header */
	iStatus = AddCtrlHeader( DiskNum, FALSE );

 					/* Loop while no errors and disk has free space */
	while( iStatus == OK  && !iDiskFull )
		iStatus = ProcessNextFile();

					/* Update last dir header and disk header */
	if ( iStatus == OK || iStatus == NOT_FOUND )
		if ( (iCloseStatus = CloseOutDisk( DiskNum, iStatus )) != OK )
			iStatus = iCloseStatus;

					/* Make sure both files are closed on error */
	if ( iStatus != OK && iStatus != NOT_FOUND )
	{
		iStatus = CloseFile( &iCtrlHandle, iStatus );
		iStatus = CloseFile( &iBkupHandle, iStatus );
	}

	return( iStatus );
}

/***************************************************************************/
/*																									*/
/***************************************************************************/

static int ProcessNextFile( void )
{
	int	iStatus;
	
	if ( (iStatus = BuildFileRec()) == OK )
	{
					/* If szPath has changed then update old DIR rec	*/
					/* and then create a new DIR rec							*/

		if ( iNewPath && (iStatus = UpdateDirRec( FALSE )) == OK )
			iStatus = AddDirRec();

	 					/* Add a new file rec and inc dir entry count */

		if ( iStatus == OK && (iStatus = AddFileRec()) == OK )
			pDir->Entries++;	/* Update files in this dir */
	}

	return( iStatus );
}

/***************************************************************************/
/* Finished with a disk so if no errors we have to update the last DIR		*/
/* record and if no more files to  be copied need to mark the disk header	*/
/* If argument iLastDisk == TRUE the disk header will be flagged as the		*/
/* last disk.																					*/
/***************************************************************************/

static int CloseOutDisk( int DiskNum, int iLastDisk )
{
	int				iStatus;
	extern int		iHandle;

	iStatus = OK;

	if ( iBkupMode == CONTROL )
	{
		iStatus = UpdateDirRec( TRUE );
		if ( iLastDisk )
			iStatus = AddCtrlHeader( DiskNum, iLastDisk );
	}

	if ( iBkupMode != COUNT )
	{
		if ( iStatus == OK )
			iStatus = BufFlush(); 				/* Flush disk buffer */

		if ( iBkupMode == CONTROL )
			iStatus = CloseFile( &iCtrlHandle, iStatus );
		else
			iStatus = CloseFile( &iBkupHandle, iStatus );
	}

	return( iStatus );
}

/***************************************************************************/
/*																									*/
/***************************************************************************/

static int AddDirRec( void )
{
	char	*szTmp;
	int	iStatus;
	int	iStrLen;

	iNewPath = FALSE;					/* Clear the new directory flag */
	iStatus = OK;
	
	if ( iBkupMode != COUNT )
	{
							/* Copy path name less the drive and first backslash	*/
		szTmp = GetMemory( MAX_PATH_LEN );
		strcpy( szTmp, szPath + 3 );

										/* Remove file name and trailing backslash	*/
		*(ParseFileName( szTmp )) = EOL;
		iStrLen = RemoveTrailing( szTmp, '\\' );

														/* Padd end of name with zeros	*/
		memcpy( pDir->Path, szTmp, iStrLen );
		memset( pDir->Path + iStrLen, EOL, sizeof( pDir->Path ) - iStrLen );

		pDir->Entries = 0;
		pDir->NextDir = lCtrlOffset;

		if ( iBkupMode == CONTROL )
			iStatus = BufAppend( pDir, DIR_REC_LEN );

		FreeMemory( szTmp );
	}

	lCtrlOffset += (LONG)(DIR_REC_LEN);
	return( iStatus );
}

/***************************************************************************/

static int UpdateDirRec( int iIsLast )
{
	int	iStatus;
	long	lOffset;

 			/* See if doing file copy or if DIR record not created yet */

	if ( iBkupMode == CONTROL  && pDir->Entries != -1 )
	{
		lOffset = pDir->NextDir;			/* Find this record's offset */

	 			/* Set it to the new offset or -1 if last dir record on disk */
		pDir->NextDir = iIsLast ? -1L : lCtrlOffset;
		iStatus = BufSeekWrite( pDir, DIR_REC_LEN, lOffset	);
	}
	else
		iStatus = OK;

	return( iStatus );
}

/***************************************************************************/

static int AddCtrlHeader( int DiskNum, int IsLastDisk )
{
	int 	iStatus;

	if ( iBkupMode == CONTROL )
	{
		pHeader->Seq = (UCHAR)(DiskNum);

		if ( IsLastDisk == FALSE )		/* Not marking last backup disk */
			iStatus = BufAppend( pHeader, DISK_REC_LEN );
		else
		{ 									/* Marks last backup disk */
			pHeader->IsLast = 0xff;
			iStatus =  BufSeekWrite( pHeader, DISK_REC_LEN, 0L );
		}
	}
	else
		iStatus = OK;

	if ( !IsLastDisk )
		lCtrlOffset	+=  (LONG)(DISK_REC_LEN);

	return( iStatus );
}

/***************************************************************************/

static int AddFileRec( void )
{
	char		*szFullPath;
	char		*szDir;
	int		iStatus;

	if ( iBkupMode == CONTROL )
		iStatus = BufAppend( pFile, FILE_REC_LEN );
	else if ( iBkupMode == BACKUP )
	{
		szFullPath = GetMemory( 200 );
		szDir = szFullPath + 100;
		strncpy( szDir, pDir->Path + (pDir->Path[0] == '\\' ? 1 : 0), 63 );
		*(szDir + 63) = EOL;

		BuildPath( szFullPath, chSource, szDir, Info[iDepth].name );

		ShowFileStatus( Info[iDepth].name, READ );

		iStatus = BufCopyFile( szFullPath, lFileOffset, pFile->PartSize );
		FreeMemory( szFullPath );
	}
	else
		iStatus = OK;

	lCtrlOffset +=  (LONG)(FILE_REC_LEN);
	lBkupOffset += pFile->PartSize;

	return( iStatus );
}

/***************************************************************************/
/* NOTE: if pFile->FileLen == -1 it means this is the first file to be 		*/
/*			processed so force the action of getting the next file.				*/
/***************************************************************************/

static int BuildFileRec( void )
{
	int		iStatus = OK;
	long		lDiskFree;
	long		lToWrite;

	lDiskFree =  CalcDiskFree();

	if ( lDiskFree > 0 )
	{
						/* Find out how much of last file has been written */
		lFileOffset += pFile->PartSize;

						/* See if need to process a file spanning disks */
		if ( pFile->FileLen != -1L && lFileOffset < pFile->FileLen )
		{	
			pFile->Seq++;
			pFile->Offset = 0L;
			lToWrite = pFile->FileLen - lFileOffset;
			iStatus = OK;
		}
		else if ( (iStatus = GetNextFile()) != NOT_FOUND )
		{
			GetFileRec();
			lToWrite = pFile->FileLen;
			lFileOffset = 0L;			/* Reset file offset pointer */
		}
						/* See if remaining block of file can be written 	*/
						/* and if not write remaining disk size and set 	*/
						/* disk full flag												*/
		if ( lToWrite > lDiskFree )
		{
			pFile->PartSize = lDiskFree;
			pFile->Flags = 2;					/* Not last part of file */
			iDiskFull = TRUE;
		}
		else
		{
			pFile->PartSize = lToWrite;
			pFile->Flags = 3;					/* Is last part of file */
		}
						/* Increment offset in backup file */
	}
	else
		iDiskFull = TRUE;

	return( iStatus );
}

/***************************************************************************/
/*																									*/
/***************************************************************************/

static void GetFileRec( void )
{
	int		iStrLen;

				/* Get the file name and padd the end of the name with 0's */
	memcpy( pFile->Name, Info[iDepth].name, sizeof( pFile->Name )  );
	iStrLen = strlen( pFile->Name );
	while( iStrLen < sizeof( pFile->Name )	)
		pFile->Name[ iStrLen++ ] = 0;

	pFile->Flags = 3;
	pFile->FileLen	= Info[iDepth].size;
	pFile->Seq = 1;
	pFile->Offset = lBkupOffset;
	pFile->PartSize = Info[iDepth].size;
	pFile->Attrib = Info[iDepth].attrib;
	*((unsigned *)(&pFile->Time))	= Info[iDepth]. wr_time;
	*((unsigned *)(&pFile->Date)) = Info[iDepth].wr_date;
}

/***************************************************************************/
/* Calculates the number of bytes free on the destination disk based on		*/
/* how much has already been written to it and it's original free space.	*/
/* The returned size takes into account the fact that the disk is				*/
/* allocated in clusters and will round to the end of the current cluster.	*/
/*																									*/
/*	long CalcDiskFree( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/* RETURNS:		long		- Number of bytes which can still be allocated to	*/
/*								  any file on the disk.										*/
/*																									*/
/*	GLOBALS:		iBytesPerCluster	-	Must have already been set by a			*/
/*												previous a call to GetDiskFree			*/
/*																									*/
/***************************************************************************/

long CalcDiskFree( void )
{
	long		lDiskUsed;


		/* Disk space used = lBkupOffset + (lCtrloffset padded to 512 bound) */
		/* lCtrloffset must also include 1 file rec and 1 possible DIR rec	*/

	lDiskUsed = (lCtrlOffset + FILE_REC_LEN + DIR_REC_LEN);
	lDiskUsed +=  (iBytesPerClus - (lDiskUsed % iBytesPerClus));
	lDiskUsed += lBkupOffset;

	return( lDiskSize - lDiskUsed );
}

/***************************************************************************/
/*	Closes the passed file handle if it is opened. The passed file handle	*/
/* will be -1 if it is not open. The argument iStatus is used to signal		*/
/* that the file is being closed because of a previous disk error so we		*/
/* don't want to inform the user if the close fails. This will keep from	*/
/* getting multiple error messages when there is error closing a file		*/
/* on a disk which is already known to be un-useable. The return value		*/
/* will be either the orignal value of the iStatus argument or an error		*/
/* code from error handler if there was an error closing the file and 		*/
/* and iStatus was OK on entry.															*/
/*																									*/
/*	int CloseFile( int *iFileHandle, int iStatus )									*/
/*																									*/
/*	ARGUMENTS:	iFileHandle	- File handle to be closed.							*/
/*					iStatus		- Current error status of the file being closed	*/
/*	RETURNS:		int			- See above description									*/
/*																									*/
/***************************************************************************/

int CloseFile( int *iFileHandle, int iStatus )
{

	if ( *iFileHandle != -1 )
		if (  _dos_close( *iFileHandle ) != OK && iStatus == OK )
			iStatus = ProcDiskErr( BAD_MEDIA );

	*iFileHandle = -1;
	return( iStatus );
}

/***************************************************************************/
/*	Prepare a floppy disk to be used as a backup disk. First checks to see	*/
/* if the disk is formatted and if not it formats it. If the disk is			*/
/*	already formatted the root directory and FAT are wiped out (bad cluster	*/
/*	are retained in the new FAT) and then a label is put on the disk in the	*/
/* form of "BACKUP  XXX" where XXX is the sequence number. The Ctrl and 	*/
/* BACKUP files are then created and left open and ready to write to. If	*/
/* there is an error the disk will be considered un-useable and the user	*/
/* will be prompt to insert another disk.												*/
/*																									*/
/*	int InitBkupDisk( int Num )															*/
/*																									*/
/*	ARGUMENTS:	Num	-	The disk sequence number									*/
/*	RETURNS:		int	-	OK or ABORT if user selected to stop the backup		*/
/*																									*/
/*	GLOBALS:		szDiskLabel	- Sequence number is appended							*/
/*					iCtrlHandle	- Set to open control file handle					*/
/*					iBkupHandle	- Set to open backup file handle						*/
/*																									*/
/***************************************************************************/

static int InitBkupDisk( int Num )
{
	register				iStatus;			/* Return status		*/
	char					*szPtr;			/* Ptr to disk label */

												/* Create the disk label string */
	szPtr = szDiskLabel + 8;
	if ( Num < 100 )
	  *(szPtr++) = '0';
	if ( Num < 10 )	
	  *(szPtr++) = '0';
	itoa( Num, szPtr, 10 );

												/* Loop until good disk or user aborts */
	do
	{		
		if ( (iStatus = PrepBkupDsk( Num )) != OK ||
			  (iStatus = OpenDest( &iCtrlHandle, Num, szCtrlFile, 0 )) != OK ||
			  (iStatus = OpenDest( &iBkupHandle, Num, szBkupFile, 0 )) != OK )
		{
			CloseFile ( &iCtrlHandle, iStatus );	/* Error so close files */
			CloseFile ( &iBkupHandle, iStatus );
			iStatus = ProcDiskErr( iStatus );	/* Prompt the user		*/
		}
	}
	while( iStatus != ABORT && iStatus != OK );

	return( iStatus );
}

/***************************************************************************/
/* Appends an numeric extension to a file name and then creates the			*/
/* specified file on the destination disk. The attributes for the file can	*/
/* be specified in the arguments. Returns OK if successfull else a DOS		*/
/* error code.																					*/
/*																									*/
/*	int OpenDest( int *iFile, int DiskNum, char *szFileName, int iAttrib )	*/
/*																									*/
/*	ARGUMENTS:	iFile		- Ptr to file handle to be initialized					*/
/*					DiskNum	- Backup disk seq. number									*/
/*					szFileName - Path and base part of file name						*/
/*																									*/
/* GLOBALS:		chDestin	- Should be initialized to the destin drive letter	*/
/*																									*/
/***************************************************************************/

static int OpenDest( int *iFile, int DiskNum, char *szFileName, int iAttrib )
{
	char		szExt[10]; 					/* File name extension */
	int		iStatus;

	itoa( DiskNum, szExt, 10 ); 		/* Create the ascii file extension */
	while( strlen( szExt ) < 3 )
		InsertChar( szExt, '0' ); 		/* Prefix with ascii zeros */

	*szFileName = chDestin;
												/* Append the file extensions */
	strcpy( strchr( szFileName, '.' ) + 1, szExt );

	if	( _dos_creat( szFileName,  iAttrib, iFile ) == OK )
		iStatus = OK;
	else
	{
		*iFile = -1;
		iStatus = BAD_MEDIA;
	}

	return( iStatus );
}

/***************************************************************************/
/* Initializes the copy buffer to max available memory less 20K bytes. If	*/
/* there is less than 5K of memory available for use the program is			*/
/* with a call to FatalError(). The static global pchCpyBuffer is set to	*/
/* point to the successfully allocated buffer.										*/
/*																									*/
/*	void InitCpyBuffer( void )																*/
/*																									*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS:		void																			*/
/*																									*/
/* GLOBALS:		lBufSize	- Set to size of allocated buffer						*/
/*					pchCpyBuffer - Pointed to allocated buffer						*/
/*																									*/
/***************************************************************************/

int InitCpyBuffer( void )
{
	register	iStatus;

	iStatus = ERROR;		/* Assume may not have enough memory */

						/* Find out how much memory we can get */
	lBufSize = GetMaxHugeSize() - MALLOC_MEMORY;

	if ( lBufSize >= MIN_COPY_BUFFER )
		if ( (pchCpyBuffer = halloc( lBufSize, 1)) != NULL )
			iStatus = OK;

	return( iStatus );
}

/***************************************************************************/
/* Returns the size of the max block of huge memory that is available. The	*/
/* amount available is determined doing a DOS call to allocate the largest	*/
/* block avaliable and then freeing the allocated block and returning the	*/
/* the size of the block that was allocated.											*/
/*																									*/
/*	long GetMaxHugeSize( void )															*/
/*																									*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS:		long		-	Number of bytes of huge memory avaiable			*/
/*																									*/
/***************************************************************************/

long GetMaxHugeSize( void )
{
	unsigned		uNumParagraphs;

					/* Request more than is possible to get the max size  */
	_dos_allocmem( 0xffff, &uNumParagraphs );

					/* Return paragraphs converted to bytes */
	return( ((unsigned long) uNumParagraphs) << 4);
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\backup\boot.asm ===
; ========================================================

COMMENT #

	BOOT.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	File to include partition and master
	boot records.

	johnhe - 02-14-90

END COMMENT #

;========================================================

DOSSEG
.Model	  COMPACT,C

;========================================================

.DATA

		PUBLIC NewBootRec
NewBootRec LABEL BYTE

INCLUDE	BOOT.INC

;========================================================

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\backup\extern.c ===
/***************************************************************************/
/*                                                                         */
/*	EXTERN.C																						*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* johnhe - 12/29/89																			*/
/***************************************************************************/

#include <message.h>

unsigned	ErrorMessageText	= ERROR_MESSAGE_TEXT;
unsigned HelpHeaderText		= HELP_HEADER_TEXT;
unsigned HeaderText			= HEADER_TEXT;
unsigned HelpMemErrText		= HLP_MEM_ERR_TEXT;

unsigned	AcceptText			= ACCEPT_TEXT;
unsigned SetDefaultText 	= SET_DEFAULT_TEXT;

unsigned DiskErrorText		= DISK_ERROR_TEXT;

unsigned Type525Text 		= TYPE_525_TEXT;
unsigned Type35Text			= TYPE_35_TEXT;
unsigned DskFmtText			= DSK_FMT_TEXT;

unsigned FmtStatText 		= FMT_STAT_TEXT;

unsigned HelpLineText		= HELP_LINE_TEXT;

unsigned CopyText				= COPY_TEXT;
unsigned PercentComplete	= PERCENT_COMPLETE_TEXT;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\backup\buffer.c ===
/***************************************************************************/
/*																									*/
/* BUFFER.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* Bufffered disk output functions for the RUP backup functions.				*/
/* 																								*/
/* Created 07-14-89 johnhe																	*/
/***************************************************************************/


#include		<stdio.h>
#include		<stdlib.h>
#include		<malloc.h>
#include		<dos.h>
#include		<string.h>
#include 	<fcntl.h>

#include		<alias.h>
#include		<disk_io.h>
#include		<backup.h>
#include		<window.h>

/***************************************************************************/
/* Function prototypes for all functions in this module.							*/
/***************************************************************************/


/***************************************************************************/
/* Globals for this module																	*/
/***************************************************************************/

int								iHandle;		/* DOS handle for buffered file */

static struct WR_BUF_INFO	Buf;


extern int						iBkupMode;
extern char						*szBkupFile;
extern char						*szCtrlFile;


/***************************************************************************/
/* Appends data to a file using a buffer to speed things up. The buffer is	*/
/* is flushed as many times as necessary until all bytes have been 			*/
/* appended.																					*/
/*																									*/
/* int BufAppend( void far *vPtr, unsigned uBytes )								*/
/*																									*/
/* ARGUMENTS:	vPtr		- Ptr to buffer holding data to be appended			*/
/*					uBytes	- Number of bytes to append.								*/
/*	GLOBALS:		Buf		- Struct must have been initialized						*/
/*																									*/
/*																									*/
/* RETURNS:		int		- OK if success else disk error from BufFlush()		*/
/*	GLOBALS:		Buf		- Updates struct about this append						*/
/*																									*/
/***************************************************************************/

int BufAppend( VOID FAR *vPtr, UINT uBytes )
{
	unsigned		uToMove;			/* Count of bytes move in the loop */
	int			iStatus;			/* Return status							*/

				/* Keep appending and flushing until all requested */
				/* bytes have been appended or error is detected	*/
	iStatus = OK;
	while ( uBytes > 0 && iStatus == OK )
	{
					/* Find out how many bytes we can put in the buffer */
		uToMove = Buf.BytesFree >= (LONG) uBytes  ? 
					 uBytes : (unsigned)(Buf.BytesFree);

		Buf.Next = NormalizePtr( Buf.Next );
		memcpy( Buf.Next, vPtr, uToMove );

					/* Update information about the buffer */
		Buf.Next += uToMove;
		Buf.BytesFree -= (LONG)(uToMove);
		uBytes -= uToMove;
		Buf.BufOffset += (LONG)(uToMove);

					/* If vPtr is full we need to flush it. */
		if ( Buf.BytesFree == 0 )
			iStatus = BufFlush();
	}
	return( iStatus );
}

/***************************************************************************/
/* Seeks to the specified offset in the buffered file and writes the 		*/
/* the specified number of bytes to the file. If the seek offset in the		*/
/* file is located in the current buffer the buffer will be updated and		*/
/* no physical write will take place. If a physical seek is done a seek		*/
/* is done to restore the original position in the file so that the next	*/
/* append will not be affected.															*/
/* 																								*/
/* INT BufSeekWrite( VOID *vPtr, UINT uBytes, LONG lOffset )					*/
/*																									*/
/* ARGUMENTS:	vPtr		- Ptr to buffer holding data to be written			*/
/*					uBytes	- Number of bytes to write									*/
/*					lOffset	- Offset from begining of file to begin write		*/
/*	GLOBALS:		Buf		- Struct must have been initialized						*/
/*																									*/
/*																									*/
/* RETURNS:		int		- OK if success else disk error code					*/
/*	GLOBALS:		Buf		- Updates struct if write affects the buffer			*/
/*																									*/
/* NOTE: IT IS ALWAYS ASSUMED THAT THE SEEK AND WRITE WILL ALWAYS BE AT		*/
/*			AN OFFSET BEFORE THE CURRENT APPEND POSITION AND THE THE BUFFER	*/
/*			WILL NEVER BE FLUSHED BY A CALL TO THIS FUNCTION.						*/
/***************************************************************************/

INT BufSeekWrite( VOID *vPtr, UINT uBytes, LONG lOffset )
{
	int			iStatus;		/* Return status						*/
	unsigned		uToMove;		/* Number of bytes being moved	*/
	char huge	*hPtr;
	LONG			BufOffset;

	if ( lOffset >= Buf.FileOffset && lOffset < (Buf.FileOffset + Buf.BufLen) )
	{
					/* Find out how many bytes we can put in the buffer */
		uToMove = 	Buf.BytesFree >= (LONG)uBytes ? 
						  uBytes : (unsigned)(Buf.BytesFree);

		BufOffset = (lOffset - Buf.FileOffset);
	
		hPtr = NormalizePtr( Buf.Start +  BufOffset );
		memcpy( hPtr, vPtr, uToMove );	/* Move the bytes */
		iStatus = OK;
	}

	else
	{
		if ( (iStatus = DoWrite( vPtr, lOffset, uBytes )) == OK )
			iStatus = DoSeek( Buf.FileOffset );
	}
	return( iStatus );
}

/***************************************************************************/
/* Writes the specfified bytes to the current file associated with the		*/
/* file buffer at the specified location. After writing to file the file	*/
/* pointer will be reset to the offset in the file that corresponds to the	*/
/* the start of the file's append buffer in memory so that the next call	*/
/* to flush buffer will not have to do a seek. If there is a disk error		*/
/* detected the function ProcDiskErr() will be called and the return	*/
/* status will be the valued returned from this function call.					*/
/* 																								*/
/*	INT DoWrite( VOID *vPtr, LONG lOffset, UINT uBytes )							*/
/*																									*/
/* ARGUMENTS:	vPtr		- Ptr to buffer holding data to be written			*/
/*					uToWrite	- Number of bytes to write									*/
/*					lOffset	- Offset from begining of file to begin write		*/
/*	GLOBALS:		Buf		- Struct must have been initialized						*/
/*																									*/
/*																									*/
/* RETURNS:		int		- OK if success else disk error code					*/
/*																									*/
/***************************************************************************/

INT DoWrite( VOID *vPtr, LONG lOffset, UINT uToWrite )
{
	int			iStatus;
	unsigned		uWritten;
	char			szOldFile[25];
	int			OldReadWrite;

	OldReadWrite = GetCurrentFileStr( szOldFile );
	ShowFileStatus( iBkupMode == BACKUP ? szBkupFile+3 : szCtrlFile+3,
						   WRITE );

	vPtr = NormalizePtr( vPtr );
	if ( _dos_seek( iHandle, lOffset, SEEK_SET ) == lOffset &&
		  _dos_write( iHandle, vPtr, uToWrite, &uWritten ) == OK &&
		  uWritten == uToWrite &&
		  _dos_seek( iHandle, Buf.FileOffset, SEEK_SET ) == lOffset )
	{
		UpdateByteCount( (long)uWritten );
		iStatus = OK;
	}
	else
		iStatus = ProcDiskErr( BAD_MEDIA );

	ShowFileStatus( szOldFile, OldReadWrite );
	return( iStatus );
}

/***************************************************************************/
/* Seeks to the specified offset in the open file associated with the disk	*/
/* buffer. If an error is detected the function will return the value 		*/
/* which is returned by a call to ProcDiskErr().								*/
/* 																								*/
/* INT DoSeek( LONG Offset )																*/
/*																									*/
/* ARGUMENTS:	lOffset	- Offset from begining of file to begin write		*/
/*	GLOBALS:		Buf		- Struct must have been initialized						*/
/*																									*/
/*																									*/
/* RETURNS:		int		- OK if success else disk error code					*/
/*																									*/
/***************************************************************************/

INT DoSeek( LONG lOffset )
{
	int		iStatus;

	if ( _dos_seek( iHandle, lOffset, SEEK_SET ) == lOffset )
		iStatus = OK;
	else
		iStatus = ProcDiskErr( BAD_MEDIA );

	return( iStatus );
}

/***************************************************************************/
/* Flushes the write buffer by writing it's contents to the disk and then	*/
/* updates the buffer structure to show the new status. This function		*/
/* assumes the file pointer is already at the correct place and that no		*/
/* seek is necessary. If an error is detected the function will return the	*/
/* value which is returned by a call to ProcDiskErr().						*/
/* 																								*/
/* INT BufFlush( VOID )																		*/
/*																									*/
/*																									*/
/* ARGUMENTS:	VOID																			*/
/*	GLOBALS:		Buf		- Struct must have been initialized						*/
/*																									*/
/*																									*/
/* RETURNS:		int		- OK if success else disk error code					*/
/*	GLOBALS:		Buf		- Updates values to reflect the flushed buffer		*/
/*								  and new file offset										*/
/*																									*/
/***************************************************************************/

INT BufFlush( VOID )
{
	unsigned		uToWrite, uWritten;
	int			iStatus;
	UCHAR			*Ptr;
	LONG			lTotal;
	char			szOldFile[25];
	int			OldReadWrite;

	iStatus	= OK;
	Ptr		= Buf.Start;
	lTotal = 0L;

	OldReadWrite = GetCurrentFileStr( szOldFile );
	ShowFileStatus( iBkupMode == BACKUP ? szBkupFile+3 : szCtrlFile+3,
						   WRITE );

					/* Keep writing max possible blocks size to disk		*/
					/* until all blocks are written or error is detected	*/
	while (  lTotal < Buf.BufOffset  && iStatus == OK )
	{
					/* Calc max bytes we can write to disk */
		uToWrite = ((Buf.BufOffset - lTotal) > 0xfff0L) ?
						0xfff0 :	(unsigned)(Buf.BufOffset - lTotal);

		Ptr = NormalizePtr( Ptr );
		if ( _dos_write( iHandle, Ptr, uToWrite, &uWritten ) == OK &&
			  uWritten == uToWrite )
		{ 											/* Setup to write next block */
			Ptr += (LONG)uWritten;
			lTotal += (LONG)uWritten;
			UpdateByteCount( (long)uWritten );
		} 			
		else
			iStatus = ProcDiskErr( BAD_MEDIA );
	}
	if ( iStatus == OK )
	{
		Buf.Next = Buf.Start;
		Buf.BufOffset = 0L;
		Buf.BytesFree = Buf.BufLen;
		Buf.FileOffset += lTotal;
	}

	ShowFileStatus( szOldFile, OldReadWrite );
	return( iStatus );
}

/***************************************************************************/

VOID BufInit( VOID )
{
	extern char huge	*pchCpyBuffer;	/* Huge buffer for files				*/
	extern long			lBufSize;		/* Number of bytes in pchCpyBuffer	*/


	Buf.Start = pchCpyBuffer;
	Buf.Next = pchCpyBuffer;

	Buf.BufOffset = 0L;
	Buf.FileOffset = 0L;

	Buf.BufLen = lBufSize;
	Buf.BytesFree = Buf.BufLen;
}


/***************************************************************************/
/* Reads a specified file and appends it to the copy buffer. The copy		*/
/* buffer is flushed to disk as often as necessary.								*/
/*																									*/
/* int BufCopyFile( char *szPath, LONG lOffset, LONG lBytes )					*/
/*																									*/
/* ARGUMENTS:	szPath	- Ptr to full path name for file to be read.			*/
/*					lOffset	- Offset in the file where read is to start			*/
/*					lBytes	- Number of bytes to append.								*/
/*	GLOBALS:		Buf		- Struct must have been initialized						*/
/*																									*/
/*																									*/
/* RETURNS:		int		- OK if success else disk error from BufFlush()		*/
/*	GLOBALS:		Buf		- Updates struct about this append						*/
/*																									*/
/***************************************************************************/

int BufCopyFile( char *szPath, LONG lOffset, LONG lBytes )
{
	unsigned		uToRead;			/* Count of bytes move in the loop */
	int			iFile;			/* Open file handle */
	int			iStatus;			/* Return status							*/

	unsigned		uRead;

					/* Open file and seek to specified offset */
	if ( _dos_open( szPath, O_RDONLY, &iFile ) == OK &&
				( (lOffset != 0L &&
		  				_dos_seek( iFile, lOffset, SEEK_SET ) == lOffset) ||
					lOffset == 0L ) )
		iStatus = OK;

	else
		iStatus = ProcDiskErr( BAD_SOURCE );

				/* Keep appending and flushing until all requested */
				/* bytes have been appended or error is detected	*/
	while ( iStatus == OK && lBytes > 0  )
	{
		Buf.Next = NormalizePtr( Buf.Next );

				/* Max bytes that can be read from file is 64K - 16 */

		uToRead = (unsigned)( Buf.BytesFree >= 0xfff0L ) ? 
						  0xfff0 : (unsigned)(Buf.BytesFree);

				/* Use smaller of uToRead and lBytes */

		if ( (LONG)uToRead > lBytes )
			uToRead = (unsigned)(lBytes);;

		if ( _dos_read( iFile, Buf.Next, uToRead, &uRead ) == OK &&
			  uRead == uToRead )
			;
		else
			iStatus = ProcDiskErr( BAD_SOURCE );

					/* Update information about the buffer */

		Buf.Next += (LONG)uRead;
		Buf.BytesFree -= (LONG)(uRead);
		lBytes -= (LONG)(uToRead);
		Buf.BufOffset += (LONG)(uRead);

					/* If vPtr is full we need to flush it. */
		if ( Buf.BytesFree == 0 )
			iStatus = BufFlush();
	}

	iStatus = CloseFile( &iFile, iStatus );

	return( iStatus );
}

/***************************************************************************/
/*																									*/
/***************************************************************************/

char far *NormalizePtr( char far *Ptr )
{
	LONG		lAddr;

	lAddr = ((LONG)Ptr & 0xffff0000L) >> 12;	/* Convert seg to real 20 bit */
	lAddr += (LONG)Ptr & 0xffffL;					/* Add offset to 20 bit addr */
	
	Ptr = (char far *)((lAddr & 0xfffffff0L) << 12);/* Creat ptr segment	*/
	Ptr += lAddr & 0xf;										/* Add ptr offset		*/

	return( Ptr );
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\backup\fmt_io.h ===
/***************************************************************************/
/* 																								*/
/* FMT_IO.H																						*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* Include file with definitions for RUP upgrade utility.						*/
/* They are used by the functions in FMT_IO.C										*/
/*																									*/
/* Created 07-13-89 johnhe																	*/
/*																									*/
/***************************************************************************/


/***************************************************************************/

#define		DOS_O_RDWR 				2

#define		LAST_DISK				256
#define		REDO_DISK				257
#define		NOT_FOUND				258


/***************************************************************************/
/* Function prototypes for all functions in  FMT_IO.C								*/
/***************************************************************************/

void	DispInsertUserDisk	( int UserDisk, char chDrive );

long	CalcDiskFree			( void );
int	PrepNewDsk				( void );
int	IsNewDisk				( int iDrv );

int	FormatNewDsk			( void );
int	FoundUsedDiskPrompt	( void );
int	FormatErrorPrompt		( void );
/* int	PromptForDiskFmt		( int iDrvType );	*/
int	PromptForDefault		( void );

int	FormatNewDsk			( void );
int	DisplayDiskTotals		( int iTotal );
void	BkupCompletePrompt( void );
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\backup\global.h ===
/*********************************** GET.H *********************************/
/*                                                                         */
/*	GLOBAL.H																						*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Global variables and macros for all modules										*/
/*                                                                         */
/* Created 880305 - johnhe                                                 */
/***************************************************************************/

                                                                  //IPG- changed to ipg constants
#define EXIT_RESPONSE_TEXT	{ UCASE_REPEAT, LCASE_REPEAT, \
				  UCASE_YES, LCASE_YES, CR, 0 }   //     defined in window.h
#define	CR_RESPONSE_TEXT  	{ CR, 0 }
int		CR_Response[];


/***************************************************************************/


#define		READ					0
#define		WRITE					1
#define 		DELETE				2
#define		RENAME				3

#define		REBOOT				1

#define     LEAVE_SCREEN      0           /* Don't cleanup screen on exit  */
#define     RESTORE_SCREEN    1           /* Cleanup screen on exit        */

/***************************************************************************/

#define		BAD_MEDIA				1
#define		DISK_USED				2
#define		DIST_DISK				3

#define		FATAL_NO_HARD_ERROR		8

#define		SECTOR_SIZE				512

/************************************************************************/

	/* Flag manipulation macros */

#define	SetFlag( Flags, BitValue )			(Flags |= BitValue)
#define	ClearFlag( Flags, BitValue )		(Flags &= (~BitValue))
#define	ToggleFlag( Flags, BitValue )		(Flags ^= BitValue )
#define	GetFlag( Flags, BitValue )			(Flags &  BitValue)

/***************************************************************************/

/* Program switch flags	*/

#define			ALLOW_IBM			1			/* Flag to allow upgrade on IBM */
#define			FORCE_FLOPPY		2			/* Flag to force floppy upgrade */
#define			BACKUP_DONE			4			/* Flag if spawned by backup	  */
#define			HARD_DISK			8			/* Flag if doing a hard upgrade */

/***************************************************************************/

char			*ErrorBuffer;
void 			*GetMemory( unsigned int Bytes );

/***************************************************************************/

#define		GetErrorBuffer()		ErrorBuffer
#define		SetErrorBuffer( x )  ErrorBuffer = x

/***************************************************************************/

void	AllowAbort( void );
void	ProgramAbort();

/***************************************************************************/


/***************************************************************************/
/* This is a structure containing all of the information needed to perform */
/* a recovery of the user's original operating system. It is saved in the	*/
/* file GLOBAL.H on the recovery disk and is used allow with the some other*/
/* files on the recovery disk to restore the user's original operating		*/
/* system.																						*/
/***************************************************************************/

/***************************************************************************/

typedef struct CurrentFile CF;

struct _INFO	
{
	CF				CurrentFile;			/* Current File structure from above */
	char				chSource;				/* Source drive character */
	char				chDestin;				/* Destination drive character */
	unsigned char	uchVersMajor;			/* Major version number */
	unsigned char	uchVersMinor;			/* Minor version number */
	char				chNumFloppy;			/* Number of floppy drives */
	char				Is720K;
	char				szPath[128];
	char				chFirstHd;
	struct _BIT_FL
	{
		unsigned		fFloppyBoot:1;			/* Booted from Floppy Disk */
	} Flag;
	struct _ARGS
	{
		unsigned		fIsMono		:1;		/* Force to run in mono colors /B	*/
		unsigned		fDoneBackup	:1;		/* Program returned from backup /D	*/
		unsigned		fFloppy		:1;		/* Force a floppy upgrade		 /F	*/
		unsigned		fHardDisk	:1;		/* Is hard disk upgrade			 /H	*/
		unsigned		fNewSysFiles:1;		/* New autoexec & config.sys	 /N	*/
		unsigned		fHelp			:1;		/* Help switch 					 /?	*/
		unsigned		fAllowBadPart:1;		/* Allow upgrading funy partitions	*/
		unsigned		fQuickUp		:1;		/* Only make hard disk bootable		*/
		unsigned		fNoBernoulli:1;		/* Don't set bernoulli int 13h		*/
		unsigned		fRootChkDone:1;
		unsigned		fNoVideoChk	:1;		/* M100 - Disable the video check	*/
	} Args;
}	vInfo;



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\backup\fmt_io.c ===
/***************************************************************************/
/*																									*/
/* FMT_IO.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* Backup utility for the MS-DOS 4.0 retail upgrade. These functions will	*/
/* backup a specified disk to another specified disk. Then entry point to	*/
/* the utiltity is BackUp(). The file coping is buffered using an area of	*/
/* memory which as allocated previously by a call to InitCpyBuffer().		*/
/* Most functions comminuicate via a group of static global variables to	*/
/* keep the size of code to a mininum. 												*/
/*																									*/
/* The backup format is restorable with most versions of DOS 2.x and above.*/
/* 																								*/
/* Created 07-12-89 johnhe																	*/
/* TABS = 3																						*/
/***************************************************************************/

#include		<stdio.h>
#include		<malloc.h>
#include 	<string.h>
#include 	<dos.h>
#include		<stdlib.h>
#include		<ctype.h>

#include		<alias.h>
#include		<bios_io.h>
#include		<disk_io.h>
#include		<strlib.h>
#include		<message.h>
#include		<fmt_io.h>
#include		<window.h>
#include		<global.h>

extern int	ProcDiskErr		( int ErrorType );
extern int	GetChar			( void );
extern int	FormatFloppy	( unsigned uDrive, int iFormat,
						  			  void (*vStatus)( unsigned int, unsigned ) );
static void		BkupDskPrompt( int DiskNum );

/***************************************************************************/

int					iDskFmtType =  0;			/* Default format type				*/
int					DiskNum;						/* User disk number					*/

static struct BPB	Bpb;							/* Bpb from current disk		 	*/
int					iDrv;							/* Destination physical number 	*/
char					szOldFileName[25];
int					IsReadWrite;

extern int			CR_Response[];
int					ExitResponse[] = EXIT_RESPONSE_TEXT;

/***************************************************************************/
/* Prepares a diskette as user diskette. First prompts user for a disk		*/
/* and loops until a disk has been inserted. Then checks to see if disk 	*/
/* is formatted and if not formats the disk. If the disk is formatted a		*/
/* check is made to be sure the user hasn't inserted a disk which was 		*/
/* previously used during this backup session. If the disk is useable		*/
/* a call is do to CleanFatDir() which will clear the FAT and root			*/
/* directory to free all of the disk for use. If there are errors the 		*/
/* function will continue to loop until a valid disk is inserted or the		*/
/* user elects to abort the backup.														*/
/*																									*/
/*	int PrepBkupDsk( void )																	*/
/*																									*/
/* ARGUMENTS:	NONE																			*/
/*	RETURNS:		int		OK is disk is ready to use or ABORT if user elects	*/
/*																									*/
/***************************************************************************/

int PrepBkupDsk( int DiskNum )
{
	extern unsigned char	chDestin;
	extern char				*szDiskLabel;
	char						*pchBuffer;
	int						iStatus;
	extern long				lDiskSize;
	UL							ulTmp;
	extern UL				LastTime;
	extern UL				StartTime;

	pchBuffer = GetMemory( SECTOR_SIZE );
	iDrv = chDestin - 'A';					/* Find bios disk number			*/
	do
	{
		iStatus = OK;							/* No errors as of yet				*/

		do											/* Wait until disk is present 	*/
			BkupDskPrompt( DiskNum );
		while( !IsDiskReady( iDrv ) );

													/* See if we need to format disk */
		if ( IsFormatted( iDrv, &Bpb, pchBuffer ) == FALSE )
		{
			if ( FormatNewDsk() != OK )
			iStatus = BAD_MEDIA;				/* Can't use this disk */
		}
													/* Make sure not a previous disk */
													/* and then srub the disk			*/

		else if ( (iStatus = IsNewDisk( DiskNum )) == OK )
			iStatus = ScrubFatRoot( iDrv, &Bpb );

		if ( iStatus == OK )					/* Disk seems ok so label it	*/
		{
			if ( (lDiskSize = GetDiskFree( chDestin )) >= 100000L &&
				  (ulTmp = SetDiskLabel( iDrv, szDiskLabel, &Bpb )) != (UL)(-1L) )
			{
				LastTime = ulTmp;
				if ( StartTime == 0L )				/* If this is first disk	*/
					StartTime = ulTmp;				/* need to set first time	*/
				_dos_dskreset();
			}
			else
				iStatus = BAD_MEDIA;					/* Can't use this disk */
		}

		if ( iStatus != OK )
			iStatus = ProcDiskErr( iStatus );

	}
	while( iStatus == REDO_DISK );

	FreeMemory( pchBuffer );
	return( iStatus );
}

/***************************************************************************/
/* Determines if the format type has been set and if not does a call to 	*/
/* the the format layout and then call the FormatFloopy function to do the	*/
/* format.																						*/
/*																									*/
/*	int FormatBkupDsk( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/* RETURNS:		int	- OK if disk is formatted successfull else and error	*/
/*							  code from the format function or ABORT if the user	*/
/*							  chooses this at on of the prompts.						*/
/*																									*/
/*	GLOBALS:		chDestin	-	Should contain the DOS drive letter on entry		*/
/*																									*/
/***************************************************************************/

int FormatNewDsk( void )
{
	extern unsigned char	chDestin;
	int						iStatus;
	int						iDskType;
	int						iDrv;
	extern struct BPB		DskBpb[];


	iDrv = chDestin - 'A';

	if ( iDskFmtType == 0 )
	{
		if ( (iDskType = GetDskFmtType()) == ABORT )
			iStatus = ABORT;
	}
	else
		iDskType = iDskFmtType;

	if ( iStatus != ABORT )
		if ( (iStatus = FormatFloppy( iDrv, iDskType, FmtStat )) == OK )
			memcpy( &Bpb, DskBpb + iDskType, sizeof( struct BPB ) );
	
	return( iStatus );
}

/***************************************************************************/
/*																									*/
/***************************************************************************/

int GetDskFmtType( void )
{
	char			*pchBuf;
	int			iDrvType;
	int			iDskIndex;
	int			iFmtType;
	int			iSaveDefault;
	static unsigned char	DrvOpts[4][2] = {	{ 3,0 },		/* 360K	*/
														{ 3,5 },		/* 1.2M	*/
														{ 4,0 },		/* 720K	*/
														{ 4,6 }};	/* 1.44M	*/

	pchBuf = GetMemory( 100 );							/* Ioctl work buffer		*/
	iDrvType = (int)GetDriveType( (UCHAR)iDrv, pchBuf );
	iDrvType--;												/* Convert to zero base	*/

								/* 360k or 720k only allow a single disk type	*/

	if ( iDrvType == 0 || iDrvType == 2 )
	{
		iDskIndex = 0;
		iSaveDefault = TRUE;					/* Only 1 type so make it default */
	}

							/* Let user choose the format type */
	else if ( (iDskIndex = PromptForDiskFmt( iDrvType >> 1 )) != -1 )
	{
		if ( PromptForDefault() == TRUE ) 	/* Does user want to make 		*/
			iSaveDefault = TRUE;					/* this the default format?	*/
		else
			iSaveDefault = FALSE;
	}

	if ( iDskIndex != -1 )
	{
		iFmtType = DrvOpts[iDrvType][iDskIndex];
		if ( iSaveDefault == TRUE )
				iDskFmtType	= iFmtType;				/* Save global default */
	}

	FreeMemory( pchBuf );
	return( iDskIndex == -1 ? ABORT : iFmtType );
}


/***************************************************************************/
/*																									*/
/***************************************************************************/

int ProcDiskErr( int ErrorType )
{
	static char		*szText[3] = { NULL, NULL, NULL };
	char				*szError[ DISK_ERROR_LINES ];

	GetMessage( szError, DISK_ERROR_TEXT );
	szText[ 0 ] = szError[ ErrorType ];
	szText[ 1 ] = szError[ 0 ];
	Error( szText );
	return( REDO_DISK );
}

/***************************************************************************/
/*																									*/
/***************************************************************************/

void BkupDskPrompt( int DiskNum )
{
	extern unsigned char	chDestin;
	char						*szText[ DISK_LABEL_LINES ];
	char						szLabel[ 20 ];

	GetMessage( szText, DISK_LABEL_TEXT );
	strcpy( szLabel, szText[0] );
	itoa( DiskNum, strchr( szLabel, EOL ), 10 );
	
	PromptForDisk( szLabel, chDestin, TRUE );
}

/***************************************************************************/
/* Determines if a disk has already been used during the current backup		*/
/* seqence. Each backup disk has a label and the time and date on the		*/
/* along with the label sequence number to see if the label was created		*/
/* during the current 																		*/
/*																									*/
/***************************************************************************/

int IsNewDisk( int DiskNum )
{
	extern unsigned char	chDestin;

	char				szLabel[15];				/* Disk label string 	*/
	int				iStatus;						/* Return value			*/
	int				VolNum;						/* Decimal disk number	*/
	long				lTime;						/* Label creation time	*/
	extern unsigned long	StartTime;			/* Time-date of first disk	*/
	extern unsigned long	LastTime;			/* Time-date of last disk	*/

	iStatus = OK;

	if ( (lTime = GetDiskLabel( chDestin - 'A', szLabel, &Bpb )) != 0L &&
		  lTime != -1L )
	{
		if ( (VolNum = atoi( szLabel + 8 )) > 0 )
			if ( VolNum < DiskNum )
			{
				if ( lTime >= StartTime && lTime <= LastTime )
						iStatus = DISK_USED;
			}
	}
	else if ( lTime == -1 )
		iStatus = BAD_MEDIA;

	return( iStatus );
}


/***************************************************************************/
/*																									*/
/***************************************************************************/

int DisplayDiskTotals( int iTotal )
{
	#define		BOX_TOP			(TITLE_ROW + CONF_BKUP1_LINES - 1)
	#define		BOX_BOT			(BOX_TOP + TOTALS_LINES - 2)
	#define		BOT_ROW			(BOX_BOT + 1 )

	int			c;
   char			*apszText[ MAX_STRINGS ];
	char			*szTmpLine, *szPtr;
	int			i;
	int			Totals[ 4 ];
	long			lTmp;

	szTmpLine = GetMemory( 120 );

	Totals[0] = iTotal;
	Totals[1] = (iTotal + 1) / 2;

	lTmp = (long)iTotal;
	lTmp *= 362496L;
	lTmp += 1213951L;
	lTmp /= 1213952L;
	Totals[2] = (int)( lTmp );

	Totals[3] = (iTotal + 3) / 4;

	PushHelp( CONF_BKUP1_HELP_TEXT );
	WorkAreaCls();

	HelpLine( CONT_HLP | F1_HLP | EXIT_HLP | PREV_HLP );

	GetMessage( apszText, CONF_BKUP1_TEXT );
	DisplayText( apszText, TITLE_ROW );

	GetMessage( apszText, TOTALS_TEXT );

	szPtr = szTmpLine + TOTALS_TEXT_OFFSET; // IPG- Defined in window.h
	for ( i = 0; i < (TOTALS_LINES - 1); i++ )
	{
		strcpy( szTmpLine, apszText[i] );
		itoa( Totals[i], szPtr, 10 );
		VideoPutsRowCol( BOX_TOP + i, START_COL, szTmpLine );
	}

	do
		c = GetChar();
	while ( c != CR && c != ESC );

	PopHelp();
	FreeMemory( szTmpLine );
	return( c == CR ? OK : PREVIOUS );
}

/***************************************************************************/
/*																									*/
/***************************************************************************/

void CalcPrompt( void )
{
	char	*szText[ CALCULATE_LINES ];

	WorkAreaCls();
	HelpLine( 0 );
	GetMessage( szText, CALCULATE_TEXT );
	PromptWindow( szText, NULL, GetPromptColor(), NULL );
}

/***************************************************************************/
/*																									*/
/***************************************************************************/

void NoFilesPrompt( void )
{
	char	 		*szText[ NO_FILES_LINES ];
	
	GetMessage( szText, NO_FILES_TEXT );
	PromptWindow( szText, CR_Response, GetPromptColor(), NULL );
}

/***************************************************************************/
/*																									*/
/***************************************************************************/

int GetCurrentFileStr( char *szStr )
{
	strcpy( szStr, szOldFileName );
	return( IsReadWrite );
}
/***************************************************************************/
/*																									*/
/***************************************************************************/

void ShowFileStatus( char *szFileName, int ReadWrite )

{
	IsReadWrite = ReadWrite;
	strcpy( szOldFileName, szFileName );

	DisplayFileStatus( szFileName, ReadWrite );
}

/***************************************************************************/
/*																									*/
/***************************************************************************/

void NotFormattedPrompt( void )
{
	char	 		*szText[ NO_FORMAT_LINES ];
	
	GetMessage( szText, NO_FORMAT_TEXT );
	PromptWindow( szText, CR_Response, GetPromptColor(), NULL );
}

/***************************************************************************/
/*																									*/
/***************************************************************************/

int WantToExit( void )
{
	char			*szText[ WANT_TO_EXIT_LINES ];

	int			Input;

	GetMessage( szText, WANT_TO_EXIT_TEXT );
	Input = PromptWindow( szText, ExitResponse, GetPromptColor(), NULL );

	Input = toupper( Input );
	return( Input == UCASE_REPEAT ? -1 : OK ); // IPG- changed UCASE_R
                                                    // IPG_ to UCASE_REPEAT
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\backup\main.c ===
/***************************************************************************/
/*																									*/
/* MAIN.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* Entry point for the DOS 4.x retail upgrade package. The functions in		*/
/* this module decide if an upgrade can be done and what type of disk		*/
/* is being upgraded and then call the appropriate functions to begin		*/
/* letting the user determine the new configuration.								*/
/*																									*/
/* Created 03-01-89 - johnhe																*/
/***************************************************************************/

#include		<stdio.h>
#include		<stdlib.h>
#include    <malloc.h>
#include		<dos.h>
#include		<message.h>
#include		<malloc.h>
#include		<string.h>
#include		<process.h>

#include		<alias.h>
#include		<bios_io.h>
#include		<disk_io.h>
#include		<window.h>
#include		<global.h>
#include		<backup.h>
#include		<install.h>

/************************************************************************/

#define		MIN_PARAGRAPHS		4096		/* Need this much memory to run */

/************************************************************************/

void	main					( int argc, char **argv );

void	ProgramInitialize	( void );
void	SpawnUpgrade		( void );
void	UpgradeReturnPrompt( void );

int	IsEnoughMemory		( void );
int	IsDiskSizeOk		( void );
int	IsVersionOk			( void );
int	InitCpyBuffer		( void );
static void ZenithBugCheck( void );

int	GetDestFloppy		( void );
int	GetHardDrive		( int iStatus );
int	DisplayTotals		( void );

unsigned	GetMemoryFree	( void );
int	GetDosDataVersion	( void );

char 	*ParseFileName		( char *szPath );

char far *DosInstallData( void );

/************************************************************************/

INSTALL far 		*lpInstall = NULL;		/* Address of Dos Setup resident
														 * data.
														 */

static unsigned	fInit;						/* Global flags for this module */

static char			**Args;						/* Command line arguments */

static char			*szPath;

/************************************************************************/
/* Entry function for DOS 4.0 Retail Upgrade. This function will first	*/
/* see if the system is upgrade-able and then initialize the video and	*/
/* interrutp handlers before allowing either a hard or floppy disk		*/
/* upgrade to be performed. 															*/
/* 																							*/
/* void main( int argc, char **argv )												*/
/*																								*/
/* ARGUMENTS: 	argc  - 	Number of command line switches.						*/
/*				  	argv  -	Array of ptrs to command line switch strings		*/
/* RETURNS	:	void																		*/
/*																								*/
/************************************************************************/

void	main( int argc, char **argv )
{
	register				iBkUpStatus;
	extern char	huge	*pchCpyBuffer;
	static char			*szInstall = IPG_SZINSTALL; // IPG - this string moved to window.h
	char					*apszText[ INIT_ERROR_LINES ];

	if ( (ErrorBuffer = malloc( 2000 )) == NULL ||
			(szPath = GetMemory( 80 )) == NULL )
	{
		GetMessage( apszText, INIT_ERROR_TEXT );
		puts( apszText[0] );				/* Display issuficient memory error	*/
		exit( -1 );
	}
	szPath = GetMemory( 80 );

	if ( _osmajor < 3 )
		strcpy( szPath, "A:\\" );
	else
		strcpy( szPath, argv[0] );

	strcpy( ParseFileName( szPath ), szInstall );

	/* Check if we've been spawned by Dos Setup */

	if ( ((lpInstall = (INSTALL far *)DosInstallData()) == NULL) ||
		  (strcmp(lpInstall->szSignature, SIGNATURE) != 0) )
		lpInstall = NULL;

	argc = argc;
	Args = argv;

	if ( argc > 1 )
	{
		strupr( Args[1] );
		if ( strchr( Args[1], 'B' ) )
			vInfo.Args.fIsMono = TRUE;
		if ( strchr( Args[1], 'I' ) )										/* m100	*/
			vInfo.Args.fNoVideoChk = TRUE;								/* m100	*/
	}

	ProgramInitialize();				/* Initialize video & interrupts */

	if ( InitCpyBuffer() == OK )
	{
		while ( GetDestFloppy() != PREVIOUS )
		{
			iBkUpStatus = OK;
			while ( GetHardDrive( iBkUpStatus ) != PREVIOUS )
				iBkUpStatus = Backup( vInfo.chSource, vInfo.chDestin );
		}
		hfree( pchCpyBuffer );
	}
	else
		FatalError( FATAL_MEMORY_ERROR );

	SpawnUpgrade();
}

/************************************************************************/
/*																								*/
/************************************************************************/

void SpawnUpgrade( void )
{
	struct find_t	Buf;

#if 0	/* This is only needed if we are going to respawn Setup. */
	ZenithBugCheck();
#endif

	HelpLine( CONT_HLP | EXIT_HLP );

	if ( szPath[0] <  vInfo.chFirstHd )
	{
		do
		{
			WorkAreaCls();
			UpgradeReturnPrompt();
		}
		while ( _dos_findfirst( szPath, _A_NORMAL, &Buf ) != OK );
	}
	else
		WorkAreaCls();

#if 1
	ProgramCleanUp( TRUE );
	exit( 0 );											/* Return to parent process */
#else
/* BUGBUG: Should we restore video also before returning to SETUP? */
	ProgramCleanUp( FALSE ); 						/* Restore interrupts only */
	WaitPrompt ( SETUP_WAIT );
	execl( szPath, szPath, Args[ 1 ], NULL );
	VideoCleanup();
	exit( -1 );
#endif
}

/************************************************************************/
/*																								*/
/************************************************************************/

void UpgradeReturnPrompt( void )
{
	char			*apszText[ UPGRADE_LINES ];
	char			*DrvPos;

	GetMessage( apszText, UPGRADE_TEXT );

	if ( (DrvPos = strchr( apszText[2], ':' )) != NULL )
		*(DrvPos-1) = szPath[0];

	PromptWindow( apszText, CR_Response, GetPromptColor(), NULL );
}

#if 0
/************************************************************************/
/* This function checks for a system running MS-DOS 2.x on a Zenith		*/
/* computer by checking the version number and then looking for a 'ZDS'	*/
/* string at memory location f000:800c. If both checks pass the user    */
/* will need to restart Setup because of a bug in Zenith DOS 2.11.   	*/
/* (The bug was such that the re-spawn of Setup would fail.)				*/
/* A dialog will instruct the user what to do and then the program will */
/* cleanup and exit, leaving the user at the DOS prompt. If either of	*/
/* the tests fail the function will just return to the caller.				*/
/*																								*/
/*	void ZenithBugCheck( void )														*/
/*																								*/
/*	ARGUMENTS:	NONE																		*/
/*	RETURNS:		void																		*/
/*																								*/
/************************************************************************/

void ZenithBugCheck( void )
{
	char					*apszText[ ZENITH_BUG_LINES ];
	static char far	*ZenithSig = (char far *)(0xf000800cL);

	if ( _osmajor == 2 && strncmp( ZenithSig, "ZDS", 3 ) == OK )
	{
		HelpLine( CONT_HLP );							/* Set help line			*/
		PushHelp( 0xffff );								/* Disable help system	*/
		WorkAreaCls();

		GetMessage( apszText, ZENITH_BUG_TEXT );
		PromptWindow( apszText, CR_Response, GetPromptColor(), NULL );

		ProgramCleanUp( TRUE );			/* Cleanup int vectors and screen	*/
		exit( 0 );
	}
	else
		return;
}
#endif


/***************************************************************************
 * char far * DosInstallData(void);
 *
 * Use our reserved Int2Fh function (INT2F_INSTALL_DATA) to get a pointer
 * to resident data structures.  Will return NULL if the function is not
 * being serviced (i.e. no one has previously hooked Int2Fh to service this
 * function).
 * 
 *
 * ENTRY: void
 * EXIT : Address of resident data structures,
 *			 else NULL
 *
 * HISTORY: M200: Created.
 *
 ***************************************************************************/

char far * DosInstallData( void )
{
	int 				i;
	char far 		*lpData = NULL;
	union REGS 		inregs, outregs;
	struct SREGS 	segregs;

	inregs.x.ax = INT2F_INSTALL_DATA;

	segread( &segregs );

	i = int86x( INT2F, &inregs, &outregs, &segregs );

	if( outregs.x.ax == 0xFFFF && ((outregs.x.bx | segregs.es) != 0))
	{
		FP_SEG(lpData) = segregs.es;
		FP_OFF(lpData) = outregs.x.bx;
	}

	return( lpData );
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\backup\initial.c ===
/***************************************************************************/
/*                                                                      	*/
/* INITIAL.C																					*/
/*                                                                      	*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                      	*/
/* Functions for initializing the program video interface and misc.			*/
/* interrupt handlers.																		*/
/*                                                                      	*/
/* Created 07-05-89 - johnhe                                            	*/
/***************************************************************************/

#include		<stdio.h>
#include		<stdlib.h>
#include		<string.h>
#include		<bios.h>
#include		<dos.h>
#include    <io.h>
#include    <sys\types.h>
#include    <sys\stat.h>
#include    <fcntl.h>

#include		<alias.h>
#include		<bios_io.h>
#include		<disk_io.h>
#include		<hdisk.h>
#include		<window.h>
#include		<message.h>
#include		<global.h>
#include		<backup.h>

/************************************************************************/
/* Function prototypes																	*/
/************************************************************************/
void	ProgramInitialize		( void );

void	SystemRestore			( void );
int	DriveReady				( char chDrive );

static void	ToggleTsrs		( int State );
static int 	IsFloppyBoot	( void );

char	FmtDrvLst[ MAX_DOS_DRIVES ];

/************************************************************************/
/* Global variables for this module													*/
/************************************************************************/
static void 	(interrupt far *OldInt1e)();	/* Original int 1eh addr.	*/
static void 	(interrupt far *OldInt1b)();	/* Original int 1bh addr.	*/
static void 	(interrupt far *OldInt23)();	/* Original int 23h addr.	*/
static void 	(interrupt far *OldInt24)();	/* Original int 23h addr.	*/
static int		DosBreak;			/* Ctrl Break setting at program start */

char		*apszReadWriteError[ READ_WRITE_LINES ];

/************************************************************************/
/* Initializes the program by disabling the DOS control C function, 		*/
/* BIOS control break functions and then initialize the video library.	*/
/* Program colors are turned on if a color card is active.					*/
/************************************************************************/
void ProgramInitialize( void )
{
	extern unsigned	*HelpStack;
	extern unsigned	*HelpStackPtr;
	char					*Buf;
	int					Drv;	

	ToggleTsrs( OFF );
												/* Initialize disk error messages */
	GetMessage( apszReadWriteError, READ_WRITE_TEXT );

	vInfo.chNumFloppy = (char)GetNumberOfDrives();
	if ( _osmajor >= 4 && vInfo.chNumFloppy > 2 )
		vInfo.chNumFloppy = 2;

	vInfo.chDestin = 'A';

	DosBreak = GetBreakSetting();		/* Save DOS break setting */
	UpdateBreakSetting( OFF );			/* Turn break check off */

	OldInt1e = _dos_getvect( 0x1e );	/* Save int 1eh vector */
	OldInt1b = _dos_getvect( 0x1b );	/* Save int 1bh vector */
	OldInt23 = _dos_getvect( 0x23 );	/* Save int 23h vector */
	OldInt24 = _dos_getvect( 0x24 );	/* Save int 24h vector */

	_dos_setvect( 0x1b, NewInt1b );	/* Set new int 1bh vector */
	_dos_setvect( 0x23, NewInt23 );	/* Set new int 23h vector */
	_dos_setvect( 0x24, NewInt24 ); 	/* Set new int 24h vector */
	InitNew13( GetErrorBuffer() );	

	if ( vInfo.Args.fNoVideoChk )		/* m100	*/
		MinVideoInitial();				/* m100	*/
	else										/* m100	*/
		VideoInitial();					/* m100 Initialize the video library */

	// m100 VideoInitial();				/* Initialize the video library */

	VideoCursOff();
	SetDefaultColors( (VideoIsColor() && !vInfo.Args.fIsMono) ? TRUE : FALSE );
	VideoCls( GetBackGroundColor() );
	DisplayScreenHeader( 0 );
	HelpLine( 0 );
												/* Initialize the help system */
	HelpStackPtr = HelpStack = GetMemory( 100 * sizeof( unsigned ) );
	PushHelp( 0xffff );						/* No help is set yet */


	Buf = GetMemory( GetMaxSectorSize() );
	if ( (vInfo.chFirstHd = (char)FindFirstHd( Buf )) == (char)(0xff) )
		vInfo.chFirstHd = 'C';

	for ( Drv = (vInfo.chFirstHd - 'A');
		   Drv < MAX_DOS_DRIVES &&
			IsValidDrive( (char)Drv + 'A' ) &&
			IsLocalDrive( (char)Drv + 1 );
			Drv++ )
	{
		FmtDrvLst[ Drv ] = (char)(ReadWriteBoot( Drv, Buf, READ ) == OK &&
   							        IsFmtedBoot( Buf ));
	}

	FreeMemory( Buf );

	/* Set flag which determines Abort Exit Prompt */

	vInfo.Flag.fFloppyBoot = IsFloppyBoot();
}	

/************************************************************************/
/* Restores the system the way it was found. Restores all interrupt 		*/
/* vectors which were replaced. Restores the DOS break check to it's 	*/
/* initial setting, clears the screen and homes the cursor.					*/
/************************************************************************/

void	ProgramCleanUp( int RestoreScreen )
{
	extern unsigned	*HelpStack;


	if (RestoreScreen )
		VideoCleanup();

	if ( OldInt1b != NULL )
	{
		RestoreOld13();
		_dos_setvect( 0x1e, OldInt1e );	/* Restore original int 1eh vector 	*/
		_dos_setvect( 0x1b, OldInt1b );	/* Restore original int 1bh vector 	*/
		_dos_setvect( 0x23, OldInt23 );	/* Restore original int 23h vector 	*/
		_dos_setvect( 0x24, OldInt24 );	/* Restore original int 24h vector 	*/
		UpdateBreakSetting( DosBreak );

		OldInt1b = NULL;						/* Mark that memory is released */
	}

	ToggleTsrs( ON );
}

/************************************************************************/
void ToggleTsrs( int State )
{
	if ( _osmajor >= 3 )
	{
		if ( State == OFF )
			DisableAppend();
		else
			EnableAppend();

		ToggleAssign();					/* Toggle assign if it's installed */
	}
}

/***************************************************************************
 * Returns TRUE if the boot drive is physical floppy drive 0. Else
 * returns FALSE.																				
 *																									
 * int IsFloppyBoot( void )																
 *																									
 * ARGUMENTS:	NONE																			
 * RETURNS:		TRUE if boot drive is drive A: else FALSE
 *
 *	NOTES: If DOS version is < 4.0, returns FALSE. (In fact, we should only
 *			 be booting from Setup floppy (DOS version == 5.0).)
 *																									
 ***************************************************************************/

int IsFloppyBoot( void )
{
	int iRet = FALSE;
	union REGS inregs, outregs;

	if ( _osmajor >= 4 )
	{
		inregs.x.ax = 0x3305;	/* Get boot drive */
		intdos( &inregs, &outregs );

		iRet = (outregs.h.dl == 1 ? TRUE : FALSE);
	}
	
	return( iRet );
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\backup\work.c ===
/***************************************************************************/
/*																									*/
/*	WORK.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/*	Functions used by the backup program to display the user menus and get	*/
/* the user's selections.																	*/
/*																									*/
/*	johnhe 07-05-91																			*/
/***************************************************************************/

#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>
#include		<malloc.h>
#include		<dos.h>

#include		<alias.h>
#include    <bios_io.h>
#include		<disk_io.h>
#include		<hdisk.h>
#include		<strlib.h>
#include		<window.h>
#include		<message.h>
#include		<backup.h>
#include		<global.h>
#include		<install.h>

/************************************************************************/


void		GetDrvList		( char *DrvList );
void		BuildDrvList	( char *DrvList, char *DrvText[] );
int		HardDriveMenu	( unsigned char *apszDrvText[], int LastDrv );
void		SpawnUpgrade	( void );
int		WantToExit		( void );

extern int GetSelection( char **apszList, struct InputDef *NewDef  );

/************************************************************************/
/* GetDestFloppy() 																		*/
/*																								*/
/* Displays the drive letter for each floppy drive in the system and		*/
/* allows the user to use the cursor keys to select one of the drives	*/
/* to be used for the upgrade. If the system only contain 1 floppy		*/
/* drive the drive A: is automatically selected with no input from the	*/
/* the user and no prompt displayed. vinfo.chDestin is set to the			*/
/* selected letter and then path string vinfo.szPath is updated unless	*/
/* the user presses ESC to return to the previous slection screen. If	*/
/* only 1 floppy drive is installed in the system the prompt won't be	*/
/* shown and the destination path will be set to "A:\".						*/
/*																								*/
/* Arguments:	NONE																		*/
/* Returns:		void																		*/
/*																								*/
/************************************************************************/

int GetDestFloppy( void )
{

	#define		BOX_TOP			(TITLE_ROW + FD_DRIVE1_LINES - 1)
	#define		BOX_BOT			(BOX_TOP +  FD_DRVS_LINES - 2)
	#define		BOT_ROW			(BOX_BOT + 1 )

	char			chDrive;
   char			*apszText[ MAX_STRINGS ];

	static struct InputDef Def = { BOX_TOP, BOX_BOT, START_COL2,
											 END_COL2, -1, 0, 0, 0 };


	PushHelp( SEL_DRV_HELP_TEXT );
	WorkAreaCls();
	GetMessage( apszText, FD_DRIVE1_TEXT );
	DisplayText( apszText, TITLE_ROW );

	GetMessage( apszText, FD_DRIVE2_TEXT );
	DisplayText( apszText, BOT_ROW );

	GetMessage( apszText, FD_DRVS_TEXT );
	apszText[vInfo.chNumFloppy] = NULL;
	Def.Bottom = Def.Top + vInfo.chNumFloppy - 1;
											/* Get the drive number */
	Def.Current = 	vInfo.chDestin - 'A';

	if ( lpInstall )
	{
		HelpLine( CONT_HLP | F1_HLP | EXIT_HLP | (PREV_HLP << 1) );

		chDrive = (char)GetSelection( apszText, &Def );
	}
	else
	{
		HelpLine( CONT_HLP | F1_HLP | EXIT_HLP );

		while ( (chDrive = (char)GetSelection( apszText, &Def )) == PREVIOUS )
			;
	}

	PopHelp();

	if ( chDrive != PREVIOUS )
	{
		vInfo.chDestin = chDrive + 'A';		/* Set drive letter */

		*(vInfo.szPath) = vInfo.chDestin;	/* Construct the path string */
		*(vInfo.szPath + 1) = ':';
		*(vInfo.szPath + 2) = EOL;
	}

	return( chDrive != PREVIOUS ? OK : PREVIOUS );
}

/************************************************************************/
/* Prompts the user to select a hard drive letter using a sroll bar		*/
/* menu. Each hard drive which has already been selected and backed up	*/
/* are marked on the menu with a check to show they have already been	*/
/* completed. Returns the drive letter of the selected drive.				*/
/*																								*/
/*	int GetHardDrive( int iLastStatus )												*/ 
/*																								*/
/*	ARGUMENTS:	iLastStatus	- Status of last hard drive backup attempt	*/
/*	RETURNS:		int	- Drive letter of selected drive or -1 if abort		*/
/*																								*/
/************************************************************************/

int GetHardDrive( int iLastStatus )
{
	static char					DrvList[ 27 ];
	static unsigned char		*apszDrvText[ 27 ];
	static int					LastDrv = -1;
	static int					ThisDrv = -100;
	
								/* If ThisDrv == -100 it means this is the	*/
								/* the first call to this function so the		*/
								/* lists of hard drives must be built			*/

	if ( ThisDrv == -100 )
	{
 		GetDrvList( DrvList );
		BuildDrvList( DrvList, apszDrvText );
		ThisDrv = -1;
	}
								/* Else see if we need to mark the last hard	*/
								/* that was selected as having been backed 	*/
								/* up successfully.									*/

	else if ( iLastStatus == OK )
	{
		LastDrv = ThisDrv;
		apszDrvText[LastDrv][0] = (char)('*');	/* Add check mark to menu	*/
	}


	if ( DrvList[0] == 0 )
		FatalError( FATAL_NO_HARD_ERROR );

								/* Set the global source drive letter			*/
	do
	{
		ThisDrv = HardDriveMenu( apszDrvText, LastDrv );

		if ( ThisDrv != PREVIOUS )
			vInfo.chSource = vInfo.chFirstHd + (char)ThisDrv;
	}
	while ( ThisDrv == ERROR );

	return( ThisDrv );
}

/************************************************************************/
/* Displays the text and allows menu selection for hard drive selection	*/
/* base on list of drives past as the parameter. Will determine the 		*/
/* drive to highlight base on the parameter LastDrv which is the int		*/
/* offset in the array of total hard drive of the last drive backed up.	*/
/* If this value is -1 it mean no drives have been done.						*/
/*																								*/
/*	int HardDriveMenu( char *apszDrvText[], int LastDrv );					*/
/*																								*/
/*	ARGUMENTS:	apszDrvText	-	Array of pointers to the menu text			*/
/*					LastDrv		-	Last drive in the array to be backedup		*/
/*	RETURNS:		int			-	User's selection or PREVIOUS if ESC			*/
/*																								*/
/* NOTE:			This function follows the following logic when deciding	*/
/*					which drive letter should be highlighted.						*/
/*																								*/
/*					DRIVE = LAST DRIVE DONE + 1										*/
/*					IF ( DRIVE IS ALREADY DONE )										*/
/*						DRIVE = NEXT DRIVE NOT DONE									*/
/*					IF ( DRIVE > MAX DRIVES )											*/
/*						DRIVE = FIRST DRIVE NOT DONE									*/
/*					IF ( DRIVE > MAX DRIVES )											*/
/*							DRIVE = 0														*/
/************************************************************************/

int HardDriveMenu( unsigned char *apszDrvText[], int LastDrv )
{

	#define		BOX2_TOP			(TITLE_ROW + CHOOSE_HD1_LINES - 1)
	#define		BOX2_BOT			21

   char			*apszText[ MAX_STRINGS ];
	int			i;
	int			iDrive;
	int			TotalStrs;


	static struct InputDef Def = { BOX2_TOP, BOX2_BOT, START_COL2,
											 END_COL2, -1, 0, 0, 0 };

	PushHelp( SEL_HD_HELP_TEXT );
	WorkAreaCls();
	GetMessage( apszText, CHOOSE_HD1_TEXT );
	DisplayText( apszText, TITLE_ROW );

	HelpLine( CONT_HLP | F1_HLP | EXIT_HLP | PREV_HLP );

	Def.Current = 	(UCHAR)(LastDrv + 1); /* Determine next drive to backup	*/
	TotalStrs = GetNumberStrings( apszDrvText );

	Def.Bottom = Def.Top + TotalStrs - 1;
	if ( Def.Bottom > BOX2_BOT )
		Def.Bottom = BOX2_BOT;	

	if ( Def.Current >= (UCHAR)TotalStrs ||
		  apszDrvText[Def.Current][0] == '*' )  /* IPG changed to Asterick */
	{
		for ( i = 0, Def.Current = 0; i < TotalStrs; i++ )
		{
			if ( apszDrvText[i][0] != '*' ) /* IPG changed to Asterick */
			{
				Def.Current = (UCHAR)i;
				break;
			}
		}
		if ( i == TotalStrs &&				/* See if all are backed up	*/
			  WantToExit() == OK )			/* Offer to exit program */
		{
			SpawnUpgrade();					/* Spawn the upgrade program */
		}
	}

	iDrive = GetSelection( apszDrvText, &Def );

	PopHelp();

	return( iDrive );
}

/************************************************************************/
/*	Fills in a an array with all valid drive letters which are not			*/
/* floppy disk supported by the ROM BIOS.											*/
/*																								*/
/*	void GetDrvList( char *DrvList )													*/
/*																								*/
/*	ARGUMENTS:	DrvList	- Array of chars to be filled in. (Max 27 chars)*/
/*	RETURNS:		void																		*/
/*																								*/
/************************************************************************/

void GetDrvList( char *DrvList )
{
	register	i;
	register	ThisDrv;
	
	ThisDrv = (int)vInfo.chFirstHd - ('A' - 1);

	for( i = 0; IsValidHardDrive( (char)(ThisDrv - 1) + 'A' ); ThisDrv++ )
		DrvList[i++] = (char)(ThisDrv - 1);
	DrvList[i] = 0;									/* Mark end of list				*/
}


/************************************************************************/
/* Uses the drive letters in the array DrvList to build an array of		*/
/* strings to be displayed in the hard disk selection menu. The bits		*/
/* in BitMap will be checked and any bits that are set will cause the	*/
/* corresponding drive to be marked as having already been backuped.		*/
/*																								*/
/*	void BuildDrvList( char *DrvList, int LastDrv, char *DrvText[],		*/
/*						 char *BitMap[] )													*/
/*																								*/
/*	ARGUMENTS:	DrvList	- Array of drive format of A=0, B=1, C=2, etc.	*/
/*					DrvText	- Array to be filled with ptrs to strings which	*/
/*								  will be displayed in the HD selection menu.	*/
/*	RETURNS:		void																		*/
/*																								*/
/************************************************************************/

void BuildDrvList( char *DrvList, char *DrvText[] )
{
	char			*apszText[ HD_DRVS_LINES ];
	int			i;

	GetMessage( apszText, HD_DRVS_TEXT );

	for ( i = 0; DrvList[i] != 0; i++ )
		DrvText[ i ] = apszText[ DrvList[i] ];

	DrvText[ i ] = NULL;

}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\cleanup\extern.c ===
/***************************************************************************
 *	EXTERN.C 
 *
 *		Copyright (c) 1991 - Microsoft Corp.
 *		All rights reserved.
 *		Microsoft Confidential
 *                                                                         
 * johnhe - 12/29/89												
 *								
 *	t-gerrit 08/23/90 incorperated into Cleanup program
 *
 ***************************************************************************/

#include <message.h>

unsigned	ErrorMessageText	= ERROR_MESSAGE_TEXT;
unsigned HelpHeaderText		= HELP_HEADER_TEXT;
unsigned HeaderText			= HEADER_TEXT;
unsigned HelpMemErrText		= HLP_MEM_ERR_TEXT;

unsigned HelpLineText		= HELP_LINE_TEXT;

char	/*bogus*/ NewBootRec	= 92;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\cleanup\cleanup.c ===
/*****************************************************************************
 *	CLEANUP.C
 *
 *		Copyright (c) 1991 - Microsoft Corp.
 *		All rights reserved.
 *		Microsoft Confidential
 *
 *	Provides the functions for DELOLDOS running in cleanup mode.
 *
 *	t-gerrit	08/23/90	
 *
 ****************************************************************************/

#include <alias.h>
#include <bios_io.h>
#include <ctype.h>
#include <direct.h>
#include <dos.h>
#include <fcntl.h>
#include <io.h>
#include <stdio.h>
#include <string.h>
#include <strlib.h>
#include <window.h>


#include "global.h"
#include "intrface.h"
#include "message.h"

/*****************************************************************************
 *	int DoCleanUp ( void )
 *
 *	If DELOLDOS is run with the cleanup option then DoCleanUp gets called.  
 *	First	it prompts the user to make sure he/she wants to do the cleanup.  
 *	Then it performs the cleanup.
 *
 *	EXIT
 *		returns TRUE if user chose to cleanup, FALSE otherwise
 *
 ****************************************************************************/	

int DoCleanUp ( void )
{
	char *apszText[ MAX (CLEANUP_PROMPT_LINES, MAX (CLEANUP1_LINES, CLEANUP2_LINES))];
	int response = 0;
#ifdef POSTPONE_501
	int count;
#endif

	vCurrentFile.chValidErrors = REBOOT;

	HelpLine( KILL_COLOR );
	PushHelp (0xffff);
	GetMessage (apszText, CLEANUP_PROMPT_TEXT );
	response = PromptWindow ( apszText, &response, GetPromptColor(), GlobalBuf);
	HelpLine( 0 );

// BEGIN IPG - Change UCASE_Y to UCASE_YES
	if ( toupper ( response ) != UCASE_YES )
// END IPG   - Change UCASE_Y to UCASE_YES
          	return ( FALSE );

	/* Prepare for the case where target files different names than */
	/* source file.*/

#ifdef POSTPONE_501
	for ( count = 0; INFData[count].NetString != EOL; 
		  	MakeSourceEntry (INFData[count++].Target));

	DoSearchWindow ();
#endif

	GetMessage ( apszText, CLEANUP1_TEXT );

	DisplayText ( apszText, TEXT_TOP );

	DoDriveSearch ( CLEANUP, COM_MASK | NET_MASK );

	WorkAreaCls();

	GetMessage ( apszText, CLEANUP2_TEXT );

	DisplayText ( apszText, TEXT_TOP );

	while ( GetChar() != CR );

	return ( TRUE );
}


#if 0

/*****************************************************************************
 *	void CleanUpFile ( char *path )
 *
 *	Takes a path that specifies a file (w/o an exetension), searches for
 *	all files that have packets and match (ie the file with 0-999 as an 
 *	extension and erases them.
 *
 *	ENTRY
 *	  path -- file to search for
 *	EXIT
 *	  returns nothing
 *
 ****************************************************************************/

void CleanUpFile ( char *path )
{

	struct find_t fileinfo;
	FILE_PACKET apacket;


	AddExtension ( path, "*" );

	if ( !_dos_findfirst ( path, _A_NORMAL | _A_SYSTEM | _A_HIDDEN, &fileinfo))
	{
		do 
		{

			RemovePath ( path );
			AddPath ( path, fileinfo.name );

			if ( GetPacket ( &apacket, path ))
			{
				DisplayFileStatus ( ParseFileName ( path ), DELETE );
				_dos_setfileattr ( path, 0 );
				remove ( path );
			}

		} while ( !_dos_findnext ( &fileinfo ) );
	}

}
#endif

/*****************************************************************************
 *	void RemOldDos ( char *path )
 *
 *	Given a path, it searches for the presence of all "OLD_DOS.*" directories 
 *	that contain a "DISk*.NUL" file and, deletes all such directories and
 *	their contents.
 *
 *	ENTRY
 *	  path -- path in which to search for directory
 *
 ****************************************************************************/

void RemOldDos ( char *path )
{
	struct find_t fileinfo, fileinfo2;
#ifdef POSTPONE_501
	int	result;
#endif

	AddPath ( path, "OLD_DOS.*" );

	if ( !_dos_findfirst  ( path, _A_SUBDIR, &fileinfo ) )
 	{
     	DoDirectoryWindow( TRUE );        /* show directory window */
		do 
		{
			RemovePath ( path );
			AddPath ( path, fileinfo.name );
			AddPath ( path, "README.NOW" );
			if (!_dos_findfirst ( path, _A_NORMAL, &fileinfo2 ))
			{
				RemovePath ( path );
				DisplayDirStatus ( ParseFileName ( path ), DELETE );
				RemoveDir ( path );
                                DisplayDirStatus ( "", CLEAR );
			}
			else
				RemovePath ( path );
		}
		while ( !(_dos_findnext ( &fileinfo )) );
     	DoDirectoryWindow( FALSE );        /* erase directory window */
	 }
	RemovePath ( path );
}

/*****************************************************************************
 *	void DoDriveSearch ( int restore, char searchflag );
 *
 *	Searches all the hard disk for upgradable or restoreable files and makes
 *	TargetStack entries for the upgradable files if restore is false, or 
 *	restores the restoreable files if restore is TRUE.
 *
 *	ENTRY
 *		restore -- type of operation to perform: CLEANUP, RESTORE, UPGRADE
 *
 ****************************************************************************/

void DoDriveSearch ( int restore, char searchflag )
{
	char path[MAX_PATH_LEN + FILE_SIZE + 4];

	restore = searchflag;

	strcpy (path, "C:\\");
	RemOldDos ( path );
}

/*****************************************************************************
 *	void DoDirectoryWindow ( void )
 *
 *	Displays the directory search window.
 *	If IfShow is TRUE, then it displays the window in the "error" color.
 *      If IfShow is FALSE, then it displays the window in the background
 *      color (ie. erases the window).
 *
 ****************************************************************************/

void DoDirectoryWindow ( int IfShow )
{
	WINDOW box;
	
	box.Top = DIR_STAT_ROW - 1;
	box.Bottom = DIR_STAT_ROW + 1;
#ifdef JAPAN
	box.Left =  DIR_STAT_COL - 1 - 1;
	box.Right = DIR_STAT_COL + DIR_STAT_LEN + 1;
#else
	box.Left =  DIR_STAT_COL - 1;
	box.Right = DIR_STAT_COL + DIR_STAT_LEN;
#endif
        if (IfShow)               /* show the window */
        {
		box.Type = 1;
		box.Color = GetErrorColor();
		box.BorderColor = GetErrorColor();
		box.IsShadow = 0;
	
		PutWindow ( &box );
        }
        else                      /* erase the window */
        {
            	VideoScrollDn( box.Top, box.Left, box.Bottom, box.Right, 0,
                               GetBackGroundColor() );
        }
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\cleanup\intrface.h ===
/***************************************************************************/
/*																									*/
/*	INTRFACE.H																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/***************************************************************************/

#define	SEL_WIDTH		55
#define	NUM_SELECTIONS		6
#define	SEL_START_ROW		10
#define	SEL_BOX_TOP		7

#define	TEXT_TOP		4
#define	TEXT_BOTTOM		19

#define	SEARCH_STAT_ROW		11
#define	SEARCH_STAT_COL		3
#define SEARCH_STAT_LEN		74

#define	NET_COM_BOX_TOP		11
#define	END_TEXT_TOP		10
#define	NON_UPGRADE		10	                      
#define	MAX_MESSAGE_FILES	8

#define DIR_STAT_ROW		19
#define DIR_STAT_COL            24
#define DIR_STAT_LEN		31
#define DIR_STAT_INDENT		5


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\cleanup\menu.c ===
/***************************************************************************/
/* 																								*/
/*	MENU.C																						*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* DOS 5.00 OEM install highlighted data selection functions					*/
/* 																								*/
/* Created 02-21-90 - johnhe																*/
/***************************************************************************/

#include		<stdio.h>
#include		<malloc.h>

#include		<alias.h>
#include		<bios_io.h>
#include		<window.h>
#include		<strlib.h>

#include		"global.h"

/***************************************************************************/

extern int	GetChar				( void );
extern int	GetCharExtension	( void );

/***************************************************************************/

static void InitMenu 		( int WindowTop );
static void HiLite			( int Option, int fOn );
static void OptionUp 		( void );
static void OptionDown		( void );
static void OptionLeft		( void );
static void OptionRight 	( void );
static int 	MyGetSelection	( int Top, int Cols, int DefaultOpt, char **apszList );

/***************************************************************************/

static char			**apszText;					/* Array of menu option strings	*/
static WINDOW		Win;							/* Menu window structure			*/
static int			Columns;						/* Number of option columns		*/
static int			StrsPerCol;					/* Number of strs in each column	*/
static int			ColWidth;					/* Number of chrs in each column	*/
static int			TotalStrs;					/* Total number of option strs	*/
static int			MaxOpt;						/* Max option number based 0		*/
static int			Current;						/* Current hi-lited option 		*/
static int			AddShadow = TRUE;			/* Used by MyPromptSelect() to	*/
														/* signal not a shadow window		*/

/***************************************************************************/
/* Allows the user to select an option from a menu by using the scroll		*/
/* bar. Blank entries can be included in the menu in which case the menu	*/
/* bar will skip over the blank selection.											*/
/* 																								*/
/*	int MyGetSelection( int Top, int Cols, int DefaultOpt, char **apszList )*/
/*																									*/
/*	ARGUMENTS:	Top		- Row on screen where top of menu window should be	*/
/*					DefaultOpt- The option number to hi-lite as the default		*/
/*					apszList	- Ptr to array of strings to display in the menu	*/
/* RETURNS: 	int	- selected option number, PREVIOUS or ABORT				*/
/* 																								*/
/***************************************************************************/

int MyGetSelection( int Top, int Cols, int DefaultOpt, char **apszList )
{
	#define			NO_SELECTION	-100		/* Arbitrary non-ascii char value*/

	register			Previous;					/* Last option highlighted			*/
	register			UserSelection;				/* Menu option selected				*/

	apszText = apszList;							/* in this module can access them*/
	Columns = Cols;
	Current = DefaultOpt;
	InitMenu( Top );

	VideoCursOff();
	Previous = Current;							/* Don't have a previous HiLite	*/
	HiLite( Current, ON );						/* HiLite the current option		*/

					/* Keep looping until user presses the <RETURN> key to make	*/
					/* a selection or <ESC> to abort the selection.					*/

	UserSelection = NO_SELECTION;
	do
	{
		if ( Previous != Current )
		{														/* HiLite proper selection */
			HiLite( Previous, OFF );
			HiLite( Current, ON );
			Previous = Current;
		}

		switch( GetChar() )								/* Get input from user	*/
		{

			case	ESC:											/* <ESC> key pressed		*/
				UserSelection = PREVIOUS;
				break;

			case CR:												/* <RETURN> key pressed	*/
				UserSelection = Current;
				break;

			case '\0':											/* Was an extended char	*/
				switch( GetCharExtension() )
				{
					case	UP:									/* Move up 1 row			*/
						OptionUp();
						break;

					case	DOWN:									/* Move down 1 row		*/
						OptionDown();
						break;

					case	LEFT:									/* Move left 1 column	*/
						OptionLeft();
						break;

					case	RIGHT:								/* Move right 1 column	*/
						OptionRight();
						break;

					default:
						break;									/* No exted char match	*/
				}
				break;

			default:												/* No reg char match 	*/
				break;
		}
	}
	while( UserSelection == NO_SELECTION  );			/* See if finished		*/

	VideoScrollDn ( Win.Top, Win.Left, Win.Bottom+1, Win.Right+2, 0 , GetBoxColor());
	
	return( UserSelection );
}

/***************************************************************************/
/* Initializes the menu window structure and displays the menu it on the	*/
/* screen. This function should only be called by MyGetSelection() because	*/
/* it relies on static globals which are initialized by MyGetSelection().	*/
/*																									*/
/*	static void InitMenu( int WindowTop )												*/
/*																									*/
/*	ARGUMENTS:	WindowTop	- Screen row where top of window should be		*/
/* RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

static void InitMenu( int WindowTop )
{
	register		Row;												/* Screen row			*/
	register		Col;												/* Screen col			*/
	int			i; 												/* Array indice		*/
	int			TotalWidth; 									/* Total wind width	*/

	ColWidth = (int)MaxStrLen( apszText ) + 2;
	TotalStrs = GetNumberStrings( apszText );
	MaxOpt = TotalStrs - 1;

	StrsPerCol = TotalStrs / Columns;
	TotalWidth = ColWidth * Columns;

#ifdef JAPAN
	TotalWidth += (TotalWidth & (UCHAR)1) ? (UCHAR)3 : (UCHAR)2;
#endif

	Win.Top = (char)WindowTop;
	Win.Bottom = (char)(WindowTop + StrsPerCol + 1);
	Win.Left = (char)CenterLength( TotalWidth + 2 );
	Win.Right = Win.Left + (char)TotalWidth + 1;

	Win.Color = Win.BorderColor = (char)GetBoxColor();
	Win.Type = 1;
	Win.IsShadow = (char)(AddShadow ? 1 : 0);

	PutWindow( &Win );

	for ( i = 0, Col = Win.Left + 2; Col < Win.Right; Col += ColWidth )
		for ( Row = WindowTop + 1;	Row < Win.Bottom && i < TotalStrs; Row++ )
#ifdef JAPAN
			VideoPutsRowCol( Row, Col+1, apszText[ i++ ] );
#else
			VideoPutsRowCol( Row, Col, apszText[ i++ ] );
#endif
						/* Need to be sure that default option not a 0 len str	*/

	if ( *(apszText[ Current ]) == EOL )
	{
		Current = 0;
		while( Current < TotalStrs && *(apszText[ Current ]) == EOL )
			Current++;
	}
}

/***************************************************************************/
/* Function to turn on or off the hi-lite on a specified option in the		*/
/* menu window. This function should only be called by MyGetSelection()		*/
/* because it relies on static globals which are initialized by				*/
/* MyGetSelection().																			*/
/*																									*/
/*	static void HiLite( int Option, int fOn )											*/
/*																									*/
/*	ARGUMENTS:	Option	- The option to apply the hi-lite to (options are	*/
/*								  base 0)														*/
/*					fOn		- If TRUE specifies the function should turn the	*/
/*								  hi-lite on else turns it off							*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

static void HiLite( int Option, int fOn )
{
	register		Row;												/* Screen row			*/
	register		Col;												/* Screen column		*/

															/* Get pos relative to window	*/
	if ( Option == 0 )								
		Row = Col = 0;												/* Divid by 0 check	*/
	else
	{
		Row = Option % StrsPerCol;
		Col = Option / StrsPerCol;
	}

	Row += Win.Top + 1;								/* Get pos relative to display*/
	Col *= ColWidth;

#ifdef JAPAN
	Col += Win.Left + 2;
#else
	Col += Win.Left + 1;
#endif

	VideoDupAttr( Row, Col,
					  fOn == ON ? GetBarColor() : GetBoxColor(),
					  ColWidth );
}

/***************************************************************************/
/* These functions handle the movement of the currently selected option.	*/
/*																									*/
/* NOTE: These functions call each other and will be come endlessly			*/
/*			recursive if all option strings are  0 lenght or if the current	*/
/*			option is on a row where all the options in the row are 0 lenght.	*/
/*			The only way this will happen is if the call of MyGetSelection()	*/
/*			specifies a row such as this, and a check is done for this			*/
/*			condition in InitMenu() and the default is changed to avoid the	*/
/*			problem. So there will only be a problem if all options are 0		*/
/*			length strings.																	*/
/*																									*/
/*	void OptionUp( void )																	*/
/*	void OptionDown( void )																	*/
/*	void OptionLeft( void )																	*/
/*	void OptionRight( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void OptionUp( void )
{
	if ( Current > 0 )
	{
		do
			Current--;
		while( Current > 0 && *(apszText[ Current ]) == EOL );
	}
}

void OptionDown( void )
{
	if ( Current < MaxOpt )
	{
		do
			Current++;
		while( Current < MaxOpt && *(apszText[ Current ]) == EOL );
	}
}

void OptionLeft( void )
{
	register		Tmp;

	Tmp = Current - StrsPerCol;
	if ( Columns > 1 && Tmp >= 0 )
		Current = Tmp;
}

void OptionRight( void )
{
	register		Tmp;

	Tmp = Current + StrsPerCol;
	if ( Columns > 1 && Tmp <= MaxOpt )
		Current = Tmp;
}

/***************************************************************************/
/* Displays a prompt window on the screen which contains text and a			*/
/* selection box with a variable number of options. The selection box is	*/
/* within the prompt window with the prompt window centered vertically and	*/
/* horizonally on the screen.																*/
/*																									*/
/*	int MyPromptSelect( char *szStrings[], char *szOpts[], int optdflt )		*/
/*																									*/
/*	ARGUMENTS:	szStrings	- Array of ptrs to prompt strings					*/
/*					szOpts		- Array of ptrs to options for selection box		*/
/*	RETURNS:		int			- User selection based 0 or PREVIOUS is <ESC>	*/
/*																									*/
/***************************************************************************/

int MyPromptSelect( char *szStrings[], char *szOpts[], int optdflt )
{
	static char		*szNull = ""; 						/* Zero length string		*/
	char				*szText[ MAX_STRINGS ];			/* Prompt window strs		*/
	char				*OldScrn;							/* Buf to hold orig scrn	*/
	register			i;										/* General purpose			*/
	unsigned char	OldBoxColor;						/* Orig box color				*/
	unsigned char	OldBarColor;						/* Orig bar color				*/
	unsigned long	Cursor;								/* Orig cusor size & pos	*/
	WINDOW			Window;								/* Prompt window structure	*/

	for ( i = 0; i < MAX_STRINGS; i++ )				/* Build array of ptrs to	*/
		szText[i] = szNull;								/* zero length strs			*/

	for ( i = 0; szStrings[i] != NULL; i++ )		/* Copy the prompt strings */
		szText[i] = szStrings[i];

						
						
	i++;								/* After this point i + top of prompt window	*/
	i++;								/* will be top of the selection box				*/

	szText[ GetNumberStrings( szOpts ) + i + 2 ] = NULL;

								/* Determine prompt wind size and allocate a scrn	*/
								/* buffer, save old scrn and display the prompt		*/

	GetWindowInfo( szText, &Window );
	OldScrn = GetMemory( (UINT)((Window.Bottom - Window.Top + 2 ) *
								(Window.Right - Window.Left + 3) * 2 ));
	Cursor = SaveCursor();
	VideoCursOff();

   WindowSave( &Window, OldScrn );
	PromptWindow( szText, NULL, GetPromptColor(), NULL );

												/* Selection box doesn't need a shadow	*/
	AddShadow = FALSE;					/* but the color has to be changed to	*/
	OldBoxColor = GetBoxColor();		/* to match the prompt window color		*/
	SetBoxColor( GetPromptColor() );

	OldBarColor = GetBarColor();
	SetBarColor( GetStatusColor() );
	
	i = MyGetSelection( Window.Top + i, 1, optdflt, szOpts );

	SetBarColor( OldBarColor );
	SetBoxColor( OldBoxColor );
	AddShadow = TRUE;

   WindowRestore( &Window, OldScrn );
	RestoreCursor( Cursor );
	FreeMemory( OldScrn );

	return( i );										/* Return user's selection		*/
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\cleanup\global.h ===
/***************************************************************************/
/*	GLOBAL.H																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/***************************************************************************/


/* "Strings" */

#define	COMMAND_COM			(apszGlobal[ 0 ])
#define	COMMAND_PROCESSOR	(apszGlobal[ 1 ])
#define	NEXT_SCREEN			(apszGlobal[ 2 ])
#define	PREVIOUS_SCREEN	(apszGlobal[ 3 ])
#define	UPGRADE_STR			(apszGlobal[ 4 ])


#define	RESTORE_ARG			"/RESTORE"
#define	UPGRADE_ARG			"/UPGRADE" 
#define	MONO_ARG				"/B"
#define	HELP_ARG				"/?"


#define	RESTORE_SCREEN 	1
#define	NET_STRING_SIZE	20
#define	FILE_SIZE			12		
#define	LABEL_SIZE			11
#define	VERSION_SIZE		5
#define	MAX_PATH_SIZE		67
#define	INF_ARRAY_SIZE		20
#define	MAX_NETWORK_TYPES	20
#define	MAX_TARGET_FILES	20
#define	MAX_SOURCE_NAMES	MAX_TARGET_FILES*2
#define	ID_STR_LEN			20
#define	MAX_DISTRIB_DISK	1
#define	MAX_REQUEST			20		
#define	DO_COM				0
#define	DO_NET				1
#define	FROM_END				2		
#define	FROM_FRONT			0
#define	SEEK_ERROR			-1l
#define	NO_COMPRESSION		0
#define	SPACE					32
#define	SECTOR_SIZE			512
#define	NOT_REMOVEABLE 	16
#define	IS_DIR 				(char ) 0x10
#define	RENAME				3
#define	COM_MASK				0x01
#define	NET_MASK				0x02
#define	NUM_MESSAGES		8
#define	MESSAGE_SIZE		8
#define	MAX_H_DRIVES		24
#define	SIGNATURE			"GBW614"
#define	UPGRADE				0
#define	RESTORE				1
#define	CLEANUP				2

		/*Fatal Error Codes.*/
#define	AUTO_EXEC_ERR		7
#define	LIE_TABLE_ERR		6
#define	CORRUPT_INF_FILE	5
#define	INF_READ_ERR		4
#define	TOO_MANY_FILES		2


#ifndef		TRUE
	#define	TRUE	1
#endif

#ifndef		FALSE
	#define	FALSE	0
#endif

#ifndef    OK
   #define		OK			      0
#endif
#ifndef	EOL
	#define	EOL		0
#endif

#ifndef	_A_ALLFILES
	#define	_A_ALLFILES			_A_SUBDIR | _A_HIDDEN | _A_SYSTEM
#endif

#ifndef	UCHAR
	#define	UCHAR	unsigned char
#endif
#ifndef UL
	#define	UL unsigned long
#endif
#ifndef    ABORT
   #define		ABORT			   -1
#endif
#ifndef    ERROR
   #define		ERROR			   -1
#endif

#ifndef    ESC
	#define	  ESC				  	0x1b
#endif

#ifndef    PREVIOUS
	#define	  PREVIOUS			-2
#endif




#define	MAX(x,y)	((x) > (y)) ? (x) : (y)
#define	MIN(x,y)	((x) > (y)) ? (y) : (x)
#define	NetworkUpgrade() ( toupper (*FilesPath) > 'B')

  									 
typedef struct {
	char		*NetString;
	int		SourceIndex;				/*Index to old RDR name.*/
	char		Target[FILE_SIZE+1];		/*New RDR name.*/
	char		Distrib[FILE_SIZE+1];
	long		Length;						/*Decompressed length of target file.*/
	char		IDString[ID_STR_LEN+1];
	char		IDString2[ID_STR_LEN+1];
	char		IDString3[ID_STR_LEN+1];
	char		IDString4[ID_STR_LEN+1];
	int		Message;
	char		Version[VERSION_SIZE+1];								
	char		DistribDisk;  /*Number of disk with new RDR on it.*/
} INF_ENTRY;



typedef struct {
	char	Path[MAX_PATH_SIZE+1];
	int	Index;
	char	Update;	  /*Flag set by user to determine whether or not to update.*/
} TARGET_ENTRY;
	


typedef struct {
	char		Signature[7];
	char		Extension[4];
	char		NewFile[FILE_SIZE + 1];
	unsigned	Time;
	unsigned	Date;
} FILE_PACKET;


struct INFO	
{
	struct ARGS
	{
		unsigned		fIsMono		:1;		/* Force to run in mono colors /B	*/
		unsigned		fDoneBackup	:1;		/* Program returned from backup /D	*/
		unsigned		fFloppy		:1;		/* Force a floppy upgrade		 /F	*/
		unsigned		fHardDisk	:1;		/* Is hard disk upgrade			 /H	*/
		unsigned		fNewSysFiles:1;		/* New autoexec & config.sys	 /N	*/
		unsigned		fHelp			:1;		/* Help switch 					 /?	*/
	} Args;
}	vInfo;




	/*Globals variables used by all modules.*/


INF_ENTRY		INFData [MAX_NETWORK_TYPES+1];
TARGET_ENTRY	TargetStack [MAX_TARGET_FILES];
char				SourceFiles [MAX_SOURCE_NAMES][FILE_SIZE + 1];
char				DistribDisks [MAX_DISTRIB_DISK][LABEL_SIZE +1];
int				NumTargets;
int				IsRestore;		
char				*ComPath;		/*Points to path with valid COMMAND.COM*/
char				*FilesPath;		/*Location of redirector files.*/
char				*GlobalBuf;
unsigned			GlobalBufSize;	/*Must be an even number.*/
char far			*ErrorBuffer;
char				*HelpText[NUM_MESSAGES][MESSAGE_SIZE+1];

char				*apszGlobal[];

	/*Globals defined in COMMON.LIB (\PROMPTS\GAGE.C)*/

extern	long	lByteCount;
extern	long	lTotalBytes;



	/*Functions defined in CLEANUP.C*/

extern	int	DoCleanUp ( void );
extern	void 	CleanUpFile ( char *path );
extern	void 	RemOldDos ( char *path );


	/*Function defined in FINDSTR.C*/

extern	int MultStrMatch( char *szPath, char *apszText[4][MAX_NETWORK_TYPES]);



	/*GETCHAR.C */

extern	int	GetChar ( void );


	/* INITIAL.C */

extern	int  DriveReady(char chDrive);
extern	void ProgramCleanUp( int RestoreScreen );
extern	void ProgramInitialize(void );


	/* INTRFACE.C  */

extern	void 	DispInsertDisk ( int DiskNum );
extern	char 	DoComNetPrompt ( void );
extern	int 	DoDiskSearch ( char searchflag );
extern	void	DoDone ( void );
extern	void	DoIntro ( void );
extern	void 	DoMessages ( void );
extern	void 	DoNoFiles ( void );
extern	void 	DoNonUpgradable ( void );
extern	void 	DoSearchWindow ( void );
extern	void 	DoDirectoryWindow ( int IfShow );
extern	int 	NumNonUpgradable ( void );
extern	void 	ShowSearchStatus ( char *path );
extern	void 	UserSelect ( int start, int end );


	/*MEMORY.C  */

extern	void	ProgramAbort( void );


	/* MENU.C  */ 

extern	int 	MyPromptSelect( char *szStrings[], char *szOpts[], int optdflt );

					

	/*Functions defined in NETSET.C.*/

extern	void 	DoDriveSearch ( int restore, char searchflag );
extern	void 	FixAutoExec ( char drive );
extern	int 	MakeSourceEntry ( char *sourcename );
extern	void 	ReadCommandCom ( char *path );
extern	void	ReadINF ( char *path );
extern	void 	UpdateVersionTable ( void );


	/*RESTORE.C*/

void 	RestoreFile ( char *path, char *buffer );


	/*Functions defined in UPDATE.C.*/

extern	void	MakeTargetEntry ( int index, char *path );
extern	void 	ReplaceFiles ( int start, int end);
extern	void 	UpdateStack ( void );
extern	int 	UpgradeStart ( void );



	/*Functions defined in UTILITY.C*/

extern	void 	AddPath (char *path, char *extension);
extern	void 	AddExtension ( char *path, char *extension );
extern	int 	CheckSum ( char *path, int *checksum );
extern	int 	CheckSumBuffer ( int *buffer, unsigned size );
extern	char 	*FileExtension ( char *path );
extern	long 	FileSize ( char *path );
extern	int 	FileNameCompare ( char *file1, char *file2 );
extern	void 	GetDrvList ( char *DrvList );
extern	int 	GetPacket ( FILE_PACKET *apacket, char *path );
extern	char 	*MakeBufCString ( char **buffer );
extern	void 	MakeOptionString ( char *target, char *source, int upgrade );
extern	void 	MyPuts (char *str);
extern	void	RemovePath (char *path);
extern	void 	RemoveDir ( char *path );



	/*Functions defined in WINDOW.C*/

extern	void	DisplayDirStatus( char *szFileName, int Type );



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\cleanup\initial.c ===
/************************************************************************/
/*	INITIAL.C																				*/
/*																								*/
/*		Copyright (c) 1991 - Microsoft Corp.										*/
/*		All rights reserved.																*/
/*		Microsoft Confidential															*/
/*                                                                      */
/* DOS %.0 network upgrade. Functions for initializing the program      */
/* video interface and misc. interrupt handlers.                        */
/*                                                                      */
/* Created 890305 - johnhe    														*/
/* Modified for use with DOS 5.0 cleanup progra  08/06/90 t-gerrit		*/
/************************************************************************/

#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>
#include    <bios.h>
#include    <dos.h>
#include    <io.h>
#include    <sys\types.h>
#include    <sys\stat.h>
#include    <fcntl.h>

#include    <alias.h>
#include    <disk_io.h>
#include    <bios_io.h>
#include    <data.h>
#include    <global.h>
#include    <hdisk.h>
#include    <message.h>
#include    <strlib.h>
#include    <window.h>

/************************************************************************/
/* Function prototypes                                                  */
/************************************************************************/

void interrupt cdecl far NewInt24 (unsigned es, unsigned ds,
			unsigned di, unsigned si, unsigned bp, unsigned sp,
			unsigned bx, unsigned dx, unsigned cx, unsigned ax );


/************************************************************************/
/* Global variables for this module					*/
/************************************************************************/

static void 	(interrupt far *OldInt1e)();	/* Original int 1eh addr. */
static void 	(interrupt far *OldInt1b)();	/* Original int 1bh addr. */
static void 	(interrupt far *OldInt23)();	/* Original int 23h addr. */
static void 	(interrupt far *OldInt24)();	/* Original int 23h addr. */

static void	ToggleTsrs ( int State );


static int	DosBreak;	/* Ctrl Break setting at program start */

char		*apszReadWriteError[ READ_WRITE_LINES ];
static char	*szDosDataPath;
char		*apszGlobal[ GLOBAL_LINES ];


/************************************************************************/
/* Initializes the program by disabling the DOS control C function,     */
/* BIOS control break functions and then initialize the video library.	*/
/* Program colors are turned on if a color card is active.              */
/************************************************************************/

void ProgramInitialize( void )
{
	extern unsigned	*HelpStack;
	extern unsigned	*HelpStackPtr;


	ToggleTsrs( OFF );

	/* Get disk error messages */
	GetMessage( apszReadWriteError, READ_WRITE_TEXT );
	GetMessage( apszGlobal, GLOBAL_TEXT );

	DosBreak = GetBreakSetting();		/* Save DOS break setting */
	UpdateBreakSetting( OFF );              /* Turn break check off */
	OldInt1b = _dos_getvect( 0x1b );	/* Save int 1bh vector */
	OldInt23 = _dos_getvect( 0x23 );	/* Save int 23h vector */
	OldInt24 = _dos_getvect( 0x24 );	/* Save int 24h vector */

	_dos_setvect( 0x1b, NewInt1b );	/* Set new int 1bh vector */
	_dos_setvect( 0x23, NewInt23 );	/* Set new int 23h vector */
	_dos_setvect( 0x24, NewInt24 );	/* Set new int 24h vector */

	VideoSaveMode();			/* Save the initial state */
	VideoInitial();				/* Initialize the video library */
	VideoCursOff();
	SetDefaultColors( VideoIsColor() && !vInfo.Args.fIsMono );
	VideoCls( GetBackGroundColor() );
	DisplayScreenHeader( 0 );
	HelpLine( 0 );

	HelpStackPtr = HelpStack = GetMemory( 100 * sizeof( unsigned ) );
	PushHelp( 0xffff );			/* No help is set yet */
}

/************************************************************************/
/* Restores the system the way it was found. Restores all interrupt     */
/* vectors which were replaced. Restores the DOS break check to it's 	*/
/* initial setting, clears the screen and homes the cursor.		*/
/************************************************************************/

void ProgramCleanUp( int RestoreScreen )
{
	if ( RestoreScreen )
        {
		VideoCleanup();
		VideoRestoreMode();
        }

	if ( OldInt1b != NULL )
	{
		_dos_setvect( 0x1b, OldInt1b );	/* Restore original int 1bh vector 	*/
		_dos_setvect( 0x23, OldInt23 );	/* Restore original int 23h vector 	*/
		_dos_setvect( 0x24, OldInt24 );	/* Restore original int 24h vector 	*/
		UpdateBreakSetting( DosBreak );

		OldInt1b = NULL;	/* Mark that memory is released */
	}
	ToggleTsrs( ON );
}


/************************************************************************/
/* Toggles the state of the TSRs.                                       */
/************************************************************************/

void ToggleTsrs( int State )
{
	if ( _osmajor >= 3 )
	{
		if ( State == OFF )
			DisableAppend();
		else
			EnableAppend();

		ToggleAssign();		/* Toggle assign if it's installed */
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\cleanup\ncfind.c ===
/***************************************************************************/
/* 																								*/
/*	NCFIND.C																						*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/***************************************************************************/

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

/************************************************************************/

#include <alias.h>
#include <bios_io.h>
#include <strlib.h>
#include <dos.h>

#include "global.h"
#include "message.h"


/************************************************************************/

int  main( int argc, char *argv[] );
int  ParseSwitches( int argc, char *argv[] );
void Initialize( void );
static void CommandHelp( void );
static void PrintLine(int handle, char *string, int len);

static char newline[2] = {0xd,0xa};
#define NEWLINE_LEN   2
#define STDOUT        1


/************************************************************************/

int main (int argc, char *argv[]) 
{
	int	aswitch;

 	aswitch = ParseSwitches ( argc, argv );	

	Initialize ( );

	switch ( aswitch )
	{
		case CLEANUP:
			if ( DoCleanUp() )
			{
				remove ( argv[0] );
				strcpy ( FileExtension (argv[0]), "EXE" );
				remove ( argv[0] );
			}
			ProgramCleanUp ( TRUE );
			break;

#ifdef POSTPONE_501
		case UPGRADE:
			IsRestore = FALSE;
			FixAutoExec ( *ComPath );
			FilesPath = strupr (argv[1]);
			DoIntro ();
			if ( DoDiskSearch ( DoComNetPrompt() ) )
				UpdateStack();
#if 0			
			if ( NetworkUpgrade () )
				RemoveDir ( FilesPath );
			/*  DoNonUpgradable();  For now don't do */
#endif			
			DoMessages();
			DoDone();
			ProgramCleanUp ( TRUE );
			break;
		
		case RESTORE:
			IsRestore = TRUE;
			FilesPath = NULL;
			DoSearchWindow ();
			DoDriveSearch (RESTORE, NET_MASK | COM_MASK );
			ProgramCleanUp ( FALSE );
			break;
#endif
	}
   return( 0 );
}

/*****************************************************************************
 *	void Initialize ( void )
 *
 *	Initializes the video display, allocates memory and read in the INF data
 *	file.
 *
 *	ENTRY  void
 *
 ****************************************************************************/

void Initialize ( void )
{

	ProgramInitialize ();


#ifdef POSTPONE_501
	GlobalBufSize = 0xF000;
	GlobalBuf = GetMemory ( GlobalBufSize );
	ErrorBuffer = GetMemory ( (size_t) 2000);
	lByteCount = 0l;
	lTotalBytes = 0l;
	
	strcpy ( FileExtension (infpath), "INF" );
	ReadINF ( infpath );
	ComPath = NULL;

	if ( argc != 1 )
	{
		RemovePath ( infpath );
		ComPath = strupr ( infpath );
	}					

	ReadCommandCom ( ComPath );
#endif
}

/*****************************************************************************
 *	int ParseSwitches ( int argc, char *argv )
 *
 *	Parse the command line switches and returns the appropriate action
 *	to take.  If the "/?" is specified it display help and exits.
 *	
 *	ENTRY
 *		argc -- command line argument count
 *		argv -- command line argument strings
 *	EXIT
 *		returns either UPGRADE, CLEANUP, or RESTORE
 *
 ****************************************************************************/

int ParseSwitches ( int argc, char *argv[] )
{
	register		i;
	int			iStatus;

	iStatus = CLEANUP;

	for ( i = 1; i < argc; i++ )
	{
		if ( !stricmp( argv[i], MONO_ARG ) )
			vInfo.Args.fIsMono = TRUE;

		else if ( !stricmp (argv[1], HELP_ARG ) )
			CommandHelp();

#ifdef POSTPONE_501
		else	if ( !stricmp( argv[i], RESTORE_ARG ) )
			iStatus = RESTORE;
		
		else if ( !stricmp (argv[i], UPGRADE_ARG ) )
			iStatus = UPGRADE;
#endif

	}
	return( iStatus );
}


/************************************************************************/
/* Displays the command line help and then exits to DOS.						*/
/*																								*/
/*	void CommandHelp( void )															*/
/*																								*/
/*	ARGUMENTS:	NONE																		*/
/*	RETURNS:		void																		*/
/*																								*/
/************************************************************************/

void CommandHelp( void )
{
    register i;
    char *apszText[ HELP_SWITCH_LINES ];

    GetMessage( apszText, HELP_SWITCH_TEXT );

    for ( i = 0; apszText[ i ] != NULL; i++ )
    {
      /* print help message to STDOUT */
      PrintLine( STDOUT, apszText[i], strlen(apszText[i]) );
      PrintLine( STDOUT, newline, NEWLINE_LEN);
    }
    exit( 0 );
}


/************************************************************************/
/* Prints one line to the handle given (stdout, stderr).                */
/*									*/
/*	void PrintLine( int handle, char string[], int len )            */
/*									*/
/*	ARGUMENTS:	handle - where to print (stdout, stderr)        */
/*                      string - string to print                        */
/*                      len    - length of string to print              */
/*	RETURNS:	void					        */
/*									*/
/************************************************************************/

void PrintLine(int handle, char string[], int len)
{
    union REGS reg;

    reg.h.ah = 0x40;
    reg.x.bx = handle;
    reg.x.cx = len;
    reg.x.dx = (unsigned)string;
    intdos(&reg, &reg);
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\cleanup\utility.c ===
/***************************************************************************/
/* 																								*/
/*	UTILITY.C																					*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/***************************************************************************/

#include <direct.h>
#include <disk_io.h>
#include <dos.h>
#include <fcntl.h>
#include <message.h>
#include <stdio.h>
#include <string.h>
#include <strlib.h>
#include <window.h>
#include <alias.h>

#include "global.h"



/*****************************************************************************
 *	void AddExtension ( char *path, char *extension )
 *
 *	Takes a string with a path and changes the extension of the file in the
 *	path ( in the string only, not on disk.)
 *
 *	ENTRY
 *		path -- path string to be changed
 *		extension -- new extension to be added, if NULL the functions returns
 *						 without doing anything
 *	EXIT
 *		returns nothing
 *
 ****************************************************************************/

void AddExtension ( char *path, char *extension )
{

	if ( FileExtension ( path ) == NULL )
		strcat (path, ".");

	strcpy ( FileExtension ( path ), extension );

}




/*****************************************************************************	
 *		AddPath -- add extension to a path string
 *
 *		Adds an extension to a path string.  If the path isn't the root 
 *		directory then a '\' is added to seperate the path and extension.
 *
 *		void AddPath (char *path, char *extension)	
 *
 *		ENTRY
 *			path -- string of path to be appended to
 *			extension -- string of extension to append onto path
 *		EXIT
 *			path -- path has extension appended to it
 *
 *		WARNINGS
 *			Assumes that there is enough free memory at the end of the path
 *			string to accomodate the extension.		
 *	
 ****************************************************************************/





void AddPath (char *path, char *extension)
{
	
#ifdef DBCS
	if (path [strlen (path) - 1] != '\\' || CheckDBCSTailByte(path,&path [strlen(path)-1]))
#else
	if (path [strlen (path) - 1] != '\\')
#endif
		strcat (path, "\\");
	strcat (path, extension);
}



#if 0

/*****************************************************************************
 *	int CheckSum ( char *path, int *checksum );
 *
 *	Does all checksum by adding up all the bytes in a file one word at a time
 *	into an integer and ignoring carries.  If the file is of odd length the 
 * first byte is treated as a word with a clear low byte and added into
 * the checksum.
 *
 *	ENTRY
 *		path -- string containing the complete path of the file to checksum
 *		checksum - ptr to int in which to put checksum
 *	EXIT
 *		0 if succesful, !0 otherwise
 *
 *	GLOBALS
 *		GlobalBuf is used to read in the file.
 *
 *	WARNING
 *		checksum relies on GlobalBufSize being an even number
 *
 ****************************************************************************/
 

int CheckSum ( char *path, int *checksum )
{
	int file, count2;
	int status = 0;
	int sum = 0;
	long size = FileSize ( path );
	unsigned	readsize;
	long	count1;

	
		/* If we have an odd file size, add in the first byte separately.*/


	if (_dos_open ( path, O_RDONLY, &file ))
		return 0;
		
	if ( size & (long) 0x01 )
	{
		status = _dos_read ( file, (char *) &sum, (unsigned ) 1, &count2 );
	 	size --;
	}

	for (count1 = 0l; count1 <  size && !status; count1 += GlobalBufSize)
	{
	 /*	readsize = (unsigned ) (MIN ((long) GlobalBufSize, size - count1));*/
	
		status = _dos_read ( file, GlobalBuf, GlobalBufSize , &readsize);
		
	   sum += CheckSumBuffer ( (int *) GlobalBuf, readsize / 2 );
		
  	}

	_dos_close ( file );

	*checksum =	sum;

	return status;

}

/*****************************************************************************
 *	int	CheckSumBuffer ( int *buffer, unsigned size )
 *
 *	Adds the contents of a buffer one word at a time to an integer and
 *	returns the result.
 *
 *	ENTRY
 *		buffer - pointer to buffer to sum up
 *		size - size of buffer in words
 *	EXIT
 *		sum of buffer
 *
 ****************************************************************************/

int CheckSumBuffer ( int *buffer, unsigned size )
{
	register int sum = 0;
	register unsigned count;
	int *bufcount = buffer;

	for ( count = 0; count < size; count++, sum += *bufcount++ );

	return sum;

}

#endif


/*****************************************************************************
 *
 *	char *FileExtension ( char *path )
 *
 *	FileExtension returns a pointer to the extension of a file.  If the
 *	file has no extension it returns NULL.
 *
 *	ENTRY
 *		path -- path of file
 *	EXIT
 *		ptr to extension of file or null
 *
 ****************************************************************************/
																								 
char *FileExtension ( char *path )
{
	char *extension = (char *) strchr ( ParseFileName ( path ), '.' );

	if (extension == NULL)
		return NULL;
	
	return ++extension;
}

#if 0

/*****************************************************************************
 *	long FileSize ( char *path )
 *
 *	Uses the find_t struct set by _dos_findfirst to determine the size of a
 *	specified file.
 *
 *	ENTRY
 *		path -- path of file whose size is to be checked.
 *	EXIT
 *		size of file 0 if ther is an error openning the file
 *
 ****************************************************************************/

long FileSize ( char *path ) 
{
	struct find_t fileinfo;

	if (_dos_findfirst ( path, _A_ALLFILES, &fileinfo ))
		return 0l;

	return fileinfo.size;
}



/*****************************************************************************
 *	int FileNameCompare ( char *file1, char *file2 )
 *
 *	Compares two file names ( ignoring their extensions) and returns 0 if
 *	they are the same or !0 otherwise.
 *
 *	ENTRY
 *		file1 -- string of first file to compare
 *		file2 -- string of second file to compare
 *	EXIT
 *		0 if the names are same, !0 otherwise
 *	
 ****************************************************************************/	
	
int FileNameCompare ( char *file1, char *file2 )
{
	int	result = 0 ;

 	result = *file1 - *file2;
	
	while ( (*file1 != '.')  && (*file2	!= '.') && (result == 0 ))
		result = *(++file1) - *(++file2);

	return *file1 - *file2;

}

/************************************************************************/
/*	Fills in a an array with all valid drive letters which are not			*/
/* floppy disk supported by the ROM BIOS.											*/
/*																								*/
/*	void GetDrvList( char *DrvList )													*/
/*																								*/
/*	ARGUMENTS:	DrvList	- Array of chars to be filled in. (Max 27 chars)*/
/*	RETURNS:		void																		*/
/*																								*/
/************************************************************************/

void GetDrvList( char *DrvList )
{
	int		CurrentDrv;
	int		scratch;
	int		ThisDrv;
	int		TmpDrv;
	int		i;
	
								/* Find first hard drive number 
	ThisDrv = GetNumberOfDrives() + 1;
	if ( ThisDrv < 3 )	 */
		ThisDrv  = 3;

	_dos_getdrive( &CurrentDrv );

	for( i = 0; i <= MAX_H_DRIVES; ThisDrv++ )
	{
		_dos_setdrive( ThisDrv, &scratch );			/* Try to set to next drive*/
		_dos_getdrive( &TmpDrv );		/* See if successfull			*/
		if ( TmpDrv != ThisDrv )
			break;								/* No more hard drive letters	*/
		else if ( IsRemoveable( (char ) ThisDrv ) != 1 &&
					 IsLocalDrive( (char ) ThisDrv ) != 0 )
			DrvList[i++] = (char ) ThisDrv - 1;
		else
			; 										/* Don't add to the list */

	}
	DrvList[i] = 0;							/* Mark end of list				*/

	_dos_setdrive( CurrentDrv, &scratch );		/* Restore original setting	*/
}

/*****************************************************************************
 *	int GetPacket ( FILE_PACKET *apacket, char *path )
 *
 *	Gets the packet on a file specified by path.  If the file has no packet
 * it does nothing and returns false.
 *
 *	ENTRY
 *		apacket -- ptr to packet to read info into
 *		path -- path of paket from which to get the packet
 *	EXIT
 *		FALSE if the file has no packet, TRUE otherwise
 *
 ****************************************************************************/
 
int GetPacket ( FILE_PACKET *apacket, char *path )
{
	int filehandle;
	unsigned scratch;

	if ( _dos_open ( path, O_RDONLY, &filehandle ))
		return FALSE;

	if ((_dos_seek (filehandle, - (long) sizeof (FILE_PACKET), FROM_END ) == -1) ||
		 (_dos_read (filehandle, (char *)apacket,sizeof (FILE_PACKET),&scratch)) ||
		 (_dos_close ( filehandle )))
		  return FALSE;
	
	return !(strcmp (SIGNATURE, apacket->Signature) );

}

/*****************************************************************************
 *	char *MakeBufCString ( char *buffer )
 *
 *	Takes a pointer to a buffer scans until it ecounters a CR or LF and converts
 *	it to an EOL ( \0 ) and returns a pointer to the original buffer (which
 *	now points to a newly exctracted C string.  The original pointer to
 *	the buffer will point to the location immediately after the new string.
 *	If the first character(s) of the buffer are CR's or LF's they will be skipped
 *	over, having the effect of skipping blank lines.	
 *
 *
 *	ENTRY
 *		buffer -- ptr to a ptr to a buffer from which to make strings
 * EXIT
 *		returns -- location in buffer immediately following newly created C string.
 *		buffer -- now points to location immediately following newly extracted
 *					 string.
 *
 ****************************************************************************/

char *MakeBufCString ( char **buffer )
{
	char	*base;
		
			
	while (1)
	{
			/*Skip over leading \n's and spaces.*/

		while ( (**buffer == CR) || (**buffer == LF) || (**buffer == SPACE ) )
			(*buffer)++; 

			/*Skip over comments.*/
	
		if (**buffer == ';')
			while (**buffer != CR)
				(*buffer)++;
		else
			break;
	}

	base = *buffer;

	while ( (**buffer != CR) && (**buffer != LF) )
		(*buffer)++;

	*((*buffer)++) = EOL;

	return base;
}

/*****************************************************************************
 *	void MakeOptionString ( char *target, char *source, int upgrade )
 *
 *	Prefixes a string with either "UPGRADE" or "DO NOT UPGRADE" and copies
 *	the new string to a buffer.  
 *
 *	ENTRY
 *		source -- source string 
 *		target -- buffer to copy new string to
 *		upgrade -- if !0 add the "UPGRADE" prefix otherwise add the
 *					  "DO NOT UPGRADE" prefix.
 *	EXIT
 *		returns nothing
 *
 ****************************************************************************/

void MakeOptionString ( char *target, char *source, int upgrade )
{
	char *apszText[3];
	
	GetMessage ( apszText, UPGRADE_PREFIXES );

	strcpy ( target, apszText[ ( upgrade != 0 )] );

	strcat ( target, source );

	GetMessage ( apszText, UPGRADE_SUFFIXES );

	strcat ( target, apszText[ ( upgrade != 0 )] );
	
}

#endif

/***************************************************************************** 	
 *	void MyPuts (char *str)
 *
 *	Writes a string to stdout.
 *		
 *	ENTRY
 *	 str -- the string to write
 *	EXIT
 *	returns nothing
 *
 ****************************************************************************/



void MyPuts (char *str)
{
	for (; *str; putchar (*str++));
	putchar ( CR );
}





/*****************************************************************************
 *	void RemoveDir ( char *path )
 *
 *	Removes all files and directories in a directory and the directory itself.  
 *	If RemoveDir is called to delete the root it will fail.
 *
 *	ENTRY
 *	 	path -- path of the directory to delete
 *	EXIT
 *		nothing
 *
 ****************************************************************************/



void RemoveDir ( char *path )
{
	struct find_t fileinfo;

	/* If this is the root delete it under no circumstances.*/

	if ( strlen ( path ) < 4 )
		return;

	AddPath ( path, "*.*" );

	/*First skip "." and ".." directories.*/

	_dos_findfirst ( path, _A_NORMAL | _A_HIDDEN | _A_SUBDIR, &fileinfo );
 	_dos_findnext ( &fileinfo );

	if ( !_dos_findnext (&fileinfo))
        {
		do 
		{
			RemovePath ( path );
			AddPath ( path, fileinfo.name );
		  	  
			if ( IS_DIR & fileinfo.attrib )
				RemoveDir ( path );
			else
			{
				/*Clear read only.*/
				_dos_setfileattr ( path, 0 );
                                DisplayFileStatus ( ParseFileName ( path ), DELETE );
				remove ( path );
			}
		} while (!_dos_findnext ( &fileinfo ) );
                DisplayFileStatus ( "", CLEAR );
        }
	RemovePath ( path );
	rmdir ( path );
}



/*****************************************************************************	
 *		RemovePath -- removes tail of path
 *																									  
 *		Removes the tail file name/subdirectory from a path string.
 *
 *		void removePath (char *path)
 *
 *		ENTRY
 *			path -- string of path to be shortened
 *		EXIT
 *			path -- tail is removed
 *
 ****************************************************************************/

						



void RemovePath (char *path) {
	char 	*count;

#ifdef DBCS
	for (count = &path[strlen (path) - 1]; *count != '\\' || CheckDBCSTailByte(path,count); count --);
#else
	for (count = &path[strlen (path) - 1]; *count != '\\'; count --);
#endif
	if ((*(count - 1) == ':') || (count == path ))
		count++;	  /*If root directory then don't remove "\" */
	*count = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\cleanup\window.c ===
/********************************* WINDOW.C ********************************/
/*	WINDOW.C																						*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* General windowing functions for the DOS 4.x retail upgrade install 		*/
/* program.																						*/
/*                                                                         */
/* Created 890306 - johnhe																	*/
/***************************************************************************/

#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>

#include    <alias.h>
#include    <bios_io.h>
#include    <strlib.h>
#include    <window.h>
#include    <disk_io.h>

#include    "global.h"
#include    "message.h"		/* Must be in current directory */
#include    "intrface.h"


/***************************************************************************/

// BEGIN IPG - Change ?CASE_Y to ?CASE_YES
int		YesNoResponse[] = { UCASE_YES, LCASE_YES, CR, 0 };
// END IPG   - Change ?CASE_Y to ?CASE_YES

/***************************************************************************/
/* Fatal error function will display an error message detailing the error  */
/* and warning that program is being aborted and then wait for any key to  */
/* be pressed. After a key a general cleanup is done by closing open       */
/* file, restoring all of the original interrupt handlers, cleaning up the */
/* video and then return to DOS with the error number set                  */
/*                                                                         */
/* ErrorNumber - An error number corresponding to the fatal error type     */
/* RETURNS: Does not return to caller, exits to DOS                        */
/***************************************************************************/

void FatalError( int ErrorNumber)
{
	char		*apszMessage[ FATAL_MESSAGE_LINES ];
	char		*apszExit[ ERROR_EXIT_LINES ];
	char		*apszText[ FATAL_LINES ];
	static int	Response[] = {CR, 0};

	GetMessage( apszMessage, FATAL_MESSAGE_TEXT );
	GetMessage( apszExit, ERROR_EXIT_TEXT );
	GetMessage( apszText, FATAL_TEXT );


	apszMessage[2] = apszText[ErrorNumber];
	apszMessage[3] = apszExit[vCurrentFile.chValidErrors];

	if ( vCurrentFile.chValidErrors != REBOOT )
		HelpLine ( EXIT_HLP | CONT_HLP );
	
	PromptWindow( apszMessage, Response, GetErrorColor(), GetErrorBuffer() );
	ProgramCleanUp( RESTORE_SCREEN );	/* Restore video & interrupts */

	if (!IsRestore)
   {
		VideoCleanup();
		VideoRestoreMode();
   }
	exit( ErrorNumber );       /* Exit to DOS with error code set */
}      

/***************************************************************************/
/* Displays a window with the status of files being copied. It uses the	   */
/* global structure "vinfo" to get the name of the file and whether it is  */
/* is being read or written.						   */
/* 									   */
/* void FileStatusUpdate( void ) 					   */
/*                                                                         */
/* ARGUMENTS:	NONE                                                       */
/* RETURNS: 	void                                                       */
/*                                                                         */
/***************************************************************************/

void FileStatusUpdate( void )
{
	char		*apszStatus[ STATUS_LINES ];
	char		szStr[25];


	GetMessage( apszStatus, STATUS_TEXT );

	strcpy( szStr, apszStatus[vCurrentFile.chReadWrite] );
	strcpy( szStr + 9, vCurrentFile.szFileName );
	PadStr( szStr, SPC, 21 );

	VideoPutsRowCol( 24, 58, szStr );
}

/***************************************************************************/
/* Sets up the current file structure and then calls FileStatusUpdate to   */
/* display the read-write message and file name on the screen's current    */
/* status line.                                                            */
/*                                                                         */
/* void DisplayFileStatus( char *szFileName, int Type )                    */
/*                                                                         */
/* ARGUMENTS:	szFileName - Name of current file in the form "NAME.EXT"   */
/*		Type       - Flag access type of READ or WRITE             */
/* RETURNS: 	void                                                       */
/***************************************************************************/

void DisplayFileStatus( char *szFileName, int Type )
{
	vCurrentFile.chReadWrite = (unsigned char)Type;
	strcpy( vCurrentFile.szFileName, szFileName );
	FileStatusUpdate();
}

/***************************************************************************/
/* Displays a window with the status of directories being copied. It uses  */
/* the global structure "vinfo" to get the name of the directory and       */
/* whether it is being read or written.                                    */
/* 									   */
/* void DirStatusUpdate( void )                                            */
/*                                                                         */
/* ARGUMENTS:	NONE                                                       */
/* RETURNS: 	void                                                       */
/*                                                                         */
/***************************************************************************/

void DirStatusUpdate( void )
{
	char		*apszStatus[ STATUS_LINES ];
	char		szStr[25];


	GetMessage( apszStatus, STATUS_TEXT );

	strcpy( szStr, apszStatus[vCurrentFile.chReadWrite] );
	strcpy( szStr + 9, vCurrentFile.szFileName );
	PadStr( szStr, SPC, 21 );

	VideoPutsRowCol( DIR_STAT_ROW, DIR_STAT_COL + DIR_STAT_INDENT, szStr );
}

/***************************************************************************/
/* Sets up the current file structure and then calls DirStatusUpdate to	   */
/* display the	read-write message and file name on the screen's current   */
/* status line.								   */
/*                                                                         */
/* void DisplayDirStatus( char *szDirName, int Type )                      */
/*                                                                         */
/* ARGUMENTS:	szDirName - Name of current directory in form "NAME.EXT"   */
/*		Type       - Flag access type of READ or WRITE             */
/* RETURNS: 	void                                                       */
/***************************************************************************/

void DisplayDirStatus( char *szDirName, int Type )
{
	vCurrentFile.chReadWrite = (unsigned char)Type;
	strcpy( vCurrentFile.szFileName, szDirName );
	DirStatusUpdate();
}

/************************************************************************/
/* This function should be called if the user presses a key which 		*/
/* causes the program to end. It will prompt the user to confirm that	*/
/* they wish to end the program and if the user confirms it will call	*/
/* ProgramAbort().																		*/
/*																								*/
/* void AllowAbort( void )																*/
/*																								*/
/* ARGUMENTS:	NONE																		*/
/*	RETURNS:		void																		*/
/*																								*/
/************************************************************************/
void AllowAbort( void )
{
/*
	For cleanup program we don't need to support the F3 key so this
   function just needs to return.

	if ( AbortPrompt() == UCASE_Y )
		ProgramAbort();
*/
}

/************************************************************************/
/* Allows the program to abort gracefully by checking to see if a			*/
/* return to DOS can be done or if a re-boot is necessary. If a there	*/
/* has to be a re-boot it can be done without any cleanup but if there	*/
/* there is going to be a return to DOS all interrupt handlers must be	*/
/* removed and if debugging all allocated memory must be freed.			*/
/*																								*/
/* void ProgramAbort( void )															*/
/*																								*/
/* ARGUMENTS:	NONE																		*/
/* RETURNS:		void																		*/
/*																								*/
/************************************************************************/

void ProgramAbort( void )
{
		/*Only restore screen if we're not restroing old files.*/
	ProgramCleanUp( !IsRestore );
	exit( 0 );
}	

/************************************************************************/

void FatalDiskError( char Disk )
{
	int			AnyChar = { CR, 0 };
	char			*apszText[ FATAL_DISK_LINES ];
	char			*apszMessage[ MAX_STRINGS ];
	extern char *apszReadWriteError[];

	GetMessage( apszText, FATAL_DISK_TEXT );

	GetMessage( apszMessage, RESTART_TEXT );

	apszText[4] = apszMessage[0];
	apszText[5] = apszMessage[1];

	apszText[0] = apszReadWriteError[ 2 ];
	apszText[2][6] = Disk;
	PromptWindow( apszText, &AnyChar, GetErrorColor(), GetErrorBuffer() );

	ProgramAbort();
}

/***************************************************************************/
/* Removes the color the current screen display.									*/
/*																									*/
/*	void StripScreenColor( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void StripScreenColor( void )
{
	register			i;
	char				*Buf;
	char				*Ptr;
	static WINDOW	Win = { 0, 24, 0, 79, 0, 0, 0, 0 };

	Ptr = Buf = GetMemory( 25 * 80 * 2 );
	WindowMove( &Win, Buf, SAVE );
	
	for ( i = 0, Ptr++ ; i < (25 * 80 * 2); i += 2, Ptr += 2 )
		*Ptr = *Ptr >= (char)0x30 ? (char)0x70 : (char)0x07;						

 	WindowMove( &Win, Buf, RESTORE );
	FreeMemory( Buf );
	vInfo.Args.fIsMono = TRUE;
}


int Int24DiskError( char Disk )
{
	char			*apszText[ INT_24_LINES ];
	char			*apszOptions[ INT_24_EXIT_LINES ];

	GetMessage( apszText, INT_24_TEXT );
	GetMessage( apszOptions, INT_24_EXIT_TEXT );
 	*(apszText[4]) = Disk;

	return( MyPromptSelect( apszText, apszOptions, 0 ) );
}

/*****************************************************************************
 *	void WriteProtectPrompt ( char Disk )
 *
 *	Does nothing but satisfy the linker.  Since a library routine references
 *	it but doesn't use it ( we're only writing to a harddisk in NCFIND).
 *	The "Disk = Disk" is there to shut up the compiler which would otherwise
 *	warn "Unreferenced formal paramter line XXX..."
 *
 ****************************************************************************/


void WriteProtectPrompt( char Disk )
{
		/*Do nothing.*/
	Disk = Disk;

}


/***************************************************************************/
/*                                                                         */
/*	void Help( void )																			*/
/*                                                                         */
/* ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*                                                                         */
/***************************************************************************/

void Help( void )
{
	;	/* Do nothing: help disabled */
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\common\data.c ===
/***************************************************************************/
/* 																								*/
/* DATA.C																						*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* Functions for accessing the data in DOSDATA.DAT. The functions 			*/
/* InitDosData() must be called before any other functions in this			*/
/* module are called.																		*/
/*																									*/
/* Created 11-11-89 - johnhe																*/
/***************************************************************************/

#include		<stdio.h>
#include		<stdlib.h>
#include 	<string.h>
#include		<dos.h>
#include 	<fcntl.h>
#include 	<io.h>
#include		<share.h>
#include 	<sys\\types.h>
#include 	<sys\\stat.h>

#include		<alias.h>
#include 	<disk_io.h>
#include 	<data.h>
#include 	<strlib.h>
#include	<window.h>
#include	<dosonly.h>
#include	<install.h>
#include 	<message.h>

#ifdef	OEM_PROGRAM
#include		<oem.h>
#else
#include		<global.h>
#endif

char ***ppszBanners = NULL;

void DosUnreadLine (char *szBuffer);
int DosReadChar (int iFile);
void DosUnreadChar (char ch);

/***************************************************************************/

#define	USIZE					sizeof( unsigned )	/* Size of unsigne value	*/
#define	RELOC_LEN			(1024 * 2)				/* Size of relocate buffer */

/***************************************************************************/

							/* Class is an array of ptrs to the different labels	*/
							/* indentifing a specific class in dosdata.dat			*/

static char *Class[] = {		"[lie-to]", "[rename]", "[delete]",
										"[device]", "[drivparm]", "[rem-device]",
										"[no-install]", "[dif-file]",

											/* Start of nonOEM sepecific data classes	*/

										"[dif-disk]", "[bios]",

											/* Distribution disk label strings */
										"[dist_label]",

											/* User disk label strings */
										"[user_label]",

											/* Compression ratio values */
										"[compression-ratio]",

											/* Distribution disk prompts */
										"[user_prompt]", "[prompt]",

										"[dif-path]", "[global-rename]", "[upd-device]",
										"[video-list]", "[video-drv]", "[disk-bytes]",
										"[disk-type]",	"[video-grb]", "[netfiles]",
										"[drv-vers]", "[del-driver]",
										"[component-bytes]", "[total-bytes]",

										"[backup-windos]",
										"[backup-win]",
										"[backup-dos]",
										"[undelete-windos]",
										"[undelete-win]",
										"[undelete-dos]",
                              "[optcomp-undelete]",
										"[antivirus-windos]",
										"[antivirus-win]",
										"[antivirus-dos]",
                              "[optcomp-antivirus]",

                                 /* Emergency-floppy layouts */
                              "[dos360]", "[dos720]", "[dos120]",

                                 /* 3rd party disk caching */
                              "[caches]",

                                 /* Utilities that won't run with smartdrv */
                              "[conflicts-smartdrv]",

                                 /* Drivers we can't add files before */
                              "[LoadAfter]",

											/* Distribution disk file layouts */
										"[distr-0]", "[distr-1]", "[distr-2]",
										"[distr-3]", "[distr-4]", "[distr-5]",
										"[distr-6]", "[distr-7]", "[distr-8]",
                              "[distr-9]", "[distr-10]","[distr-11]",
                              "[distr-12]","[distr-13]","[distr-14]",

											/* User disk file layouts */
										"[disk-0]", "[disk-1]", "[disk-2]",
										"[disk-3]", "[disk-4]", "[disk-5]",
										"[disk-6]", "[disk-7]", "[disk-8]",
										"[disk-9]",

										"OEMTABLE" };

							/* Data is an array of ptrs to the arrays of strings	*/
							/* for each of the different classes listed by label	*/
							/*	above. To access a specific string in one of the	*/
							/* class use the method:										*/
							/*			szStr = *(Data[ ENUM_CLASS ] + Index)			*/
							/* Where Index is the string in the array you need.	*/

static char			**Data[ END_CLASS ];

static char			*szDosDataFile;

static char			*szUpgrade = "INSTALL"; 	/* Label for upgrade data		*/
static char 		*szSearch  = "OEMTABLE";	/* Label for search data		*/

static char			*pchStringBuf;		/* Flat buffer to hold the data text	*/
static struct DDR	*OemList;			/* Array of DDR structures					*/

static unsigned	MaxOem;				/* Number of DDR structs in OEM list	*/
static unsigned	StrListLen; 		/* Number of bytes in string buffer 	*/
static long			lDataOffset;		/* Ptr offset in file to data area		*/

static unsigned	*RelocBuf;			/* Ptr to buffer for relocating data	*/

static int			iDiskType;			/* Distribution diskette type 1=360K,	*/
												/* 2 = 720K, 3 = 1.2meg, 4 = 1.44meg	*/

static unsigned	ShareAccess;



/***************************************************************************/
/* Initializes the data from the DOSDATA file. Allocates buffers and data	*/
/* lengths and then reads in the OEM list and the string buffer and then	*/
/* initializes the disk labels and list of files from each disk.				*/
/* 																								*/
/* void InitDosData( char *szFile )														*/
/* 																								*/
/* ARGUMENTS:	szFile	- Ptr to complete dosdata.dat file						*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void InitDosData( char *szFile )
{
	register 	i;
	char			*szTmp;
	int			iFile;
	struct DDR	*Oem;

	if ( _osmajor < 3  || (_osmajor == 3 && _osminor < 10) )
		ShareAccess = O_RDONLY;
	else
		ShareAccess = SH_DENYWR;

										/* Start with NULL ptr for all data classes	*/
	szDosDataFile = szFile;
	for ( i = 0; i < END_CLASS; i++ )
		Data[ i ] = NULL;

	RelocBuf = GetMemory( RELOC_LEN );		/* Allocate a relocation buffer	*/

										/* Allocate buffers for and read in the list */
										/* of OEM structures and the data area which */
										/* contains all of the data strings 			*/

	if ( _dos_open( szDosDataFile, ShareAccess, &iFile	) == OK )
	{
		MaxOem = GetNextDataBlock( iFile, &OemList ) / sizeof( struct DDR );
		StrListLen = GetNextDataBlock( iFile, &pchStringBuf );

															/* Save start of OEM data area */

		lDataOffset = _dos_seek( iFile, 0L, SEEK_CUR ) + (long)USIZE;
		_dos_close( iFile );
														/* Load non-OEM specific data */
		if ( (Oem = GetOemRecord( szUpgrade, 0, 0 )) == NULL )
			FatalError( CORRUPT_DATA_ERROR );

		LoadOemData( Oem );
	}
	else
		FatalError( FATAL_DATA_READ_ERROR );

	szTmp = GetDataString( DISK_TYPE, 0 );
	if ( szTmp == NULL )
		FatalError( FATAL_DATA_READ_ERROR );
	else
		iDiskType = atoi( szTmp );
}


#if defined (UPGRADE_PROGRAM) || defined (OEM_PROGRAM)
/***************************************************************************/
/* Reads and stores the advertising banner strings in the DOSMSG file.     */
/* 																								*/
/* void InitBannerData (char *szFile)												   */
/* 																								*/
/* ARGUMENTS:	szFile	- Ptr to SETUP.MSG file                            */
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/
void InitBannerData( char *szFile )
{
	register 	i, u;         /* Index variables               */
	char		*szBuffer;    /* Input line                    */
	int			iFile;        /* DOS file handle               */
   char *aszDefault[DEFAULT_BANNER_LINES];


   GetMessage (aszDefault, DEFAULT_BANNER_TEXT);
   ppszBanners = GetMemory (MAX_BANNER_SCREENS * sizeof (char **));

	if (_osmajor < 3  || (_osmajor == 3 && _osminor < 10))
      ShareAccess = O_RDONLY;
	else
	  ShareAccess = SH_DENYWR;

	if (_dos_open (szFile, ShareAccess, &iFile) != OK)
      {
        /* If the banner file isn't there, indiciate that there */
        /*   are no banners to display.                         */
        ppszBanners[0] = GetMemory (DEFAULT_BANNER_LINES * sizeof (char *));
        for (i=0; i < DEFAULT_BANNER_LINES-1; ++i)
          ppszBanners[0][i] = aszDefault[i];

        ppszBanners[1] = GetMemory (sizeof (char *));
        ppszBanners[1][0] = NULL;
        return;
      }

    szBuffer = GetMemory (MAX_SCRN_LINE_LEN + 1);

    /* Initalize the banner screen number */
    i = 0;

    /* Find the section */
    while (i < MAX_BANNER_SCREENS - 1 &&
           MyFindSection (BANNER_SECTION, iFile, (int) NULL) != TRUE)
      {
        /* Initialize the banner lines */
        ppszBanners[i] = GetMemory (MAX_BANNER_LINES * sizeof (char *));
        u = 0;

        while ((DosReadLine (szBuffer, MAX_SCRN_LINE_LEN, iFile)) == FALSE &&
               szBuffer[0] != '[')
          {
            /* Ignore lines beginning with a semi-colon */
            if (szBuffer[0] == ';')
              continue;

            if (u < MAX_BANNER_LINES - 1)
              {
                ppszBanners[i][u] = GetMemory (strlen (szBuffer) + 1);
                strcpy (ppszBanners[i][u++], szBuffer);
              }
          }

        /* Unread this line if it was a [section] so */
        /*   that MyFindSection can find it          */
        if (szBuffer[0] == '[')
          DosUnreadLine (szBuffer);

        /* NULL out this screen's last pointer */
        if (u < MAX_BANNER_LINES)
          ppszBanners[i][u] = NULL;

        /* Bump i */
        ++i;
      }

    /* NULL out the next screen's first pointer */
    if (i < MAX_BANNER_SCREENS)
      {
        ppszBanners[i] = GetMemory (sizeof (char *));
        ppszBanners[i][0] = NULL;
      }

    /* Close the message file */
    _dos_close (iFile);
}
#endif


/*********************************************************************
 * MyFindSection - Finds the specified section entry in fpInsertFile.
 *                 All information with fpInsertFile up to and including
 *                 the section line are written to fpOutputFile.
 *
 * szSection   - Section to search for.
 * iFileIn     - DOS filehandle to read.
 * iFileOut    - DOS filehandle to write, NULL if write is not required.
 *
 * Returns:  TRUE if an error occured, or the section was not found.
 *           FALSE if the section was found.
 *********************************************************************/

int MyFindSection (char *szSection, int iFileIn, int iFileOut)
{
  char *szBuffer;  /* Input buffer     */
  register int i;  /* Looping variable */


  /* Allocate sufficient space for szBuffer */
  szBuffer = GetMemory (MAX_SYSTEM_INI_LINE_LEN + 1);

  /* Read the line */
  while (DosReadLine (szBuffer, MAX_SYSTEM_INI_LINE_LEN, iFileIn) != TRUE)
    {
      /* Write the line out to the output file */
      if (iFileOut)
        DosWriteLine (szBuffer, iFileOut);

      /* Skip whitespace at beginning of szBuffer */
      for (i = 0; i < MAX_SYSTEM_INI_LINE_LEN && szBuffer[i] != '\0' &&
                   (szBuffer[i] == ' ' || szBuffer[i] == '\t');  ++i)
        ;

      /* Do we have a match */
      if (strnicmp (szSection, &szBuffer[i], strlen (szSection)) == 0)
        {
          FreeMemory (szBuffer);
          return (FALSE);
        }
    }

  /* Section was not found */
  FreeMemory (szBuffer);
  return (TRUE);
}

char *szUnreadLine = NULL;  /* Stores the unread line */
int iUnread = -1;           /* Index to the unread line */

/*********************************************************************
 * DosUnreadLine - Stores a line of text to pass out of DosReadLine.
 *
 * szBuffer - String is to be stored
 *
 * Returns:  Nothing.
 *********************************************************************/

void DosUnreadLine (char *szBuffer)
{
  szUnreadLine = GetMemory (strlen (szBuffer) + 1);
  strcpy (szUnreadLine, szBuffer);
  iUnread = 0;
}

/*********************************************************************
 * DosReadLine - Reads a single text line from disk using _dos_read.
 *
 * szBuffer - String is stored here
 * iLength  - Maximum number of characters to read
 * iFile    - DOS file handle
 *
 * Returns:  TRUE at end of file, FALSE otherwise.
 *********************************************************************/

int DosReadLine (char *szBuffer, int iLength, int iFile)
{
  int  i = 0;                 /* Index for szBuffer                 */
  int  c = 0x7F;              /* Character read in from disk        */
  int  iNext;                 /* Next Character read in from disk   */

  /* BUGBUG 27-Feb-1993 bens Bogus input routine
   *
   * The following loop is not very graceful about handling long lines.
   * Current behavior with the "--iLength" in the for loop causes us to
   * read n-1 characters into the buffer, and then stop, leaving room
   * to put the null terminator.
   *
   * The "feature" of this loop is that lines longer than iLength will
   * be split into two or more lines.
   */

  while (--iLength && c != '\0')
    {
      /* Pull from the "unread" data first */
      if (iUnread != -1)
        {
          if ((c = (int) szUnreadLine[iUnread++]) == '\0' || c == '\r')
            {
              /* Nothing left in the "unread" buffer */
              FreeMemory (szUnreadLine);
              iUnread = -1;
            }
        }
      else
        {
          /* Read from the disk if there's no "unread" data */
          if ((c = DosReadChar (iFile)) == -1)
            {
              /* Error or EOF */
              szBuffer[i] = '\0';
              // If a Ctr-Z at end of file, remove it.
              if (i > 0 && szBuffer[i-1] == 26)
                 szBuffer[--i] = 0;

              // If this line had any chars, then pretend the line was cr/lf
              // terminated.  Since we're now at end of file, the next call
              // will have i=0, so will return TRUE (EOF).
              return ((i == 0) ? TRUE : FALSE);
            }
        }

      /* Newlines are ignored */
      if (c == '\n')
        {
          ++iLength;
          continue;
        }

      /* Carriage returns mark the end of the line */
      if (c == '\r')
        {
          c = '\0';

          /* Check to see if the next character is a linefeed */
          if ((iNext = DosReadChar (iFile)) != '\n')
            {
              /* Corrupt file -- simulate EOF */
              szBuffer[0] = '\0';
              return (TRUE);
            }
          else
            DosUnreadChar ((char) iNext);
        }

      /* Store the character */
      szBuffer[i++] = (char) c;
    }

  /* Put a zero byte at the end of the string, if necessary */
  if (c)
    szBuffer[i] = '\0';

  return (FALSE);
}


char chUnreadChar;        /* Stores unread character */
int fUnreadChar = FALSE;  /* TRUE when chUnreadChar stores a character */

/*********************************************************************
 * DosReadChar - Reads a single character from the disk.
 *
 * iFile - DOS file handle.
 *
 * RETURNS: -1 if EOF or error, character otherwise.
 *********************************************************************/

int DosReadChar (int iFile)
{
  char c;                     /* Character read in from disk        */
  int  iNumRead;              /* Number of characters actually read */


  /* Check the unread character */
  if (fUnreadChar)
    {
      fUnreadChar = FALSE;
      return (chUnreadChar);
    }

  /* Read the character from the disk */
  if (_dos_read (iFile, (char far *) &c, 1, &iNumRead) != 0 || iNumRead == 0)
    {
      /* Error or EOF */
      return (-1);
    }
  else
    return ((int) c);
}


/*********************************************************************
 * DosUnreadChar - Stores a single character from the disk.
 *
 * iFile - DOS file handle.
 *
 * RETURNS: -1 if EOF or error, character otherwise.
 *********************************************************************/

void DosUnreadChar (char ch)
{
  chUnreadChar = ch;
  fUnreadChar = TRUE;
}


/*********************************************************************
 * DosWriteLine - Writes a single text line from disk using _dos_write.
 *
 * szBuffer - String is stored here
 * iFile    - DOS file handle
 *
 * Returns:  ERROR if out of disk space, OK otherwise.
 *********************************************************************/

int DosWriteLine (char *szBuffer, int iFile)
{
  unsigned fReturnValue = 0;    /* Return value from _dos_write    */
  unsigned uNmbrToWrite;        /* Actual number of bytes to write */
  unsigned uNmbrWritten;        /* Actual number of bytes written  */


  /* Write the line */
  if (szBuffer)
    {
      uNmbrToWrite = strlen (szBuffer);
      fReturnValue = _dos_write (iFile, szBuffer, uNmbrToWrite,
                             &uNmbrWritten);
      if (fReturnValue)
        FatalError (FATAL_DISK_ERROR);
    }
  else
    {  // Safe simulation of write of blank line
      uNmbrToWrite = 0;
      uNmbrWritten = 0;
    }

  /* If we weren't out of disk space */
  if (uNmbrToWrite == uNmbrWritten)
    {
      /* Write the carriage return/line feed */
      uNmbrToWrite = 2;
      fReturnValue = _dos_write (iFile, "\r\n", uNmbrToWrite, &uNmbrWritten);

      if (fReturnValue)
        FatalError (FATAL_DISK_ERROR);
    }

  /* Return an error if out of disk space */
  return ((uNmbrToWrite != uNmbrWritten) ? ERROR : OK);
}


/***************************************************************************/
/* Cleanup function to free all memory allocated by any of the database 	*/
/* management functions. This is needed for debugging purposes only and 	*/
/* MEM_BUG should not be defined in the distribution build. 					*/
/* 																								*/
/* void FreeDataMemory( void )															*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

#ifdef	MEM_BUG

void FreeDataMemory( void )
{
	register		i;

	for ( i = 0; i < END_CLASS; i++ )
		if ( Data[ i ] != NULL )
			FreeMemory( Data[ i ] );

	if ( RelocBuf != NULL )
		FreeMemory( RelocBuf );

	if ( OemList != NULL )
		FreeMemory( OemList );

	if ( pchStringBuf != NULL )
		FreeMemory( pchStringBuf );
}
#endif

/***************************************************************************/
/* Initializes the Data[] array with arrays of pointers to strings for		*/
/* each class specifed in the dosdata.dat file associated with this OEM.	*/
/* This function is also used to load the non OEM specific data specified	*/
/* by the "UPGRADE 0.0" area in dosdata.dat. 										*/
/* 																								*/
/* void LoadOemData( struct DDR *Oem ) 												*/
/* 																								*/
/* ARGUMENTS:	Oem	- Ptr to DDR struct with name an version number 		*/
/* RETURNS: 	struct DDR *- Ptr to DDR structure for specifed OEM			*/
/* 																								*/
/***************************************************************************/

void LoadOemData( struct DDR *Oem )
{
	register 	i;
	char			**apszArray;

	ReadOemData( Oem->uDataOffset );
	for ( i = 0; i < END_CLASS; i++ )
		if ( (apszArray = GetClassData( Class[ i ] )) != NULL )
			Data[ i ] = apszArray;
}

/***************************************************************************/
/* Reads in a block of data from the DOSDATA.DAT file. First reads a 2		*/
/* byte value at the start of the block which contains the size of the		*/
/* block and then allocates a buffer the proper size and reads the data 	*/
/* into the allocated memory area. If there is an error the FatalError()	*/
/* function is called to abort the program. It is assumed that the file 	*/
/* pointer's position in the data file is already pointing at the first    */
/* 2 bytes at the start of the buffer. 												*/
/* 																								*/
/* unsigned GetNextDataBlock( int iFile, void **DataBuf )						*/
/* 																								*/
/* ARGUMENTS:	iFile 		- Open file handle to the data file 				*/
/* 				DataBuf		- Ptr to the data buffer ptr							*/
/* 																								*/
/***************************************************************************/

static unsigned GetNextDataBlock( int iFile, void **DataBuf )
{
	register		iStatus;
	unsigned 	uBufLen;
	unsigned 	uRead;

	iStatus = ERROR;							/* Assume there may be an error	*/

	if ( _dos_read( iFile, &uBufLen, USIZE, &uRead ) == OK &&
			  uRead == USIZE )
	{
		*DataBuf = GetMemory( uBufLen );
		if ( _dos_read( iFile, *DataBuf, uBufLen, &uRead ) == OK )
			if (uRead == uBufLen )
				iStatus = OK;
	}

	if ( iStatus != OK )
		FatalError( FATAL_DATA_READ_ERROR );

	return( uBufLen	);
}

/***************************************************************************/
/* Reads in a block of data into the relocation buffer. The read starts at */
/* the begining of the dosdata file data area + the specified offset.		*/
/* 																								*/
/* void ReadOemData( unsigned uDataOffset )											*/
/* 																								*/
/* ARGUMENTS:	uDataOffset - Offset of data from an OEM DDR structure		*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

static void ReadOemData( unsigned uDataOffset )
{
	register		iStatus; 				/* Keeps track of error conditions		*/
	int			iFile;					/* DOS file handle							*/

	unsigned 	uRead;					/* Number of bytes read by a dos_read	*/
	long			lOffset; 				/* Offset in file to start read at		*/

	lOffset = (long)uDataOffset + lDataOffset;
	iStatus = ERROR;

	if ( _dos_open( szDosDataFile, ShareAccess, &iFile	) == OK )
	{
		if ( _dos_seek( iFile, lOffset, SEEK_SET ) == lOffset )
			if ( _dos_read( iFile, RelocBuf, RELOC_LEN, &uRead ) == OK )
				if ( uRead > 0 )
					iStatus = OK;

		_dos_close( iFile );
	}

	if ( iStatus != OK )
		FatalError( FATAL_DATA_READ_ERROR );
}

/***************************************************************************/
/* Scans through the array of OEM DDR structures looking for a structure	*/
/* in which the OEM name field matchs the argument string. Returns a ptr	*/
/* to the first matching DDR structure or NULL if no match is found. 		*/
/* 																								*/
/* struct DDR *GetOemRecord( char *szOemName, int MajorVer, int MinorVer ) */
/* 																								*/
/* ARGUMENTS:	char *szOem 	-	Ptr to OEM name string							*/
/* 				MajorVer 		-	DOS major version number						*/
/* 				MinorVer 		-	DSO minor version number						*/
/* RETURNS: 	struct DDR *	-	Ptr to ddr struct for specifed OEM if the */
/* 										OEM is not found returns NULL ptr			*/
/* 																								*/
/***************************************************************************/

struct DDR *GetOemRecord( char *szOemName, int MajorVer, int MinorVer )
{
	register 	i;
	struct DDR	*Oem;

	Oem = NULL; 							/* Returns NULL if can't find match */

	for ( i = 0; i < (int)MaxOem; i++ )
	{
		if ( (int)OemList[ i ].MajorVer == MajorVer &&
			  (int)OemList[ i ].MinorVer == MinorVer &&
			  strcmpi( OemList[ i ].szOemName, szOemName ) == OK )
		{
			Oem = &(OemList[ i ]);
			break;
		}
	}

	return( Oem );
}

/***************************************************************************/
/* Scans through the relocation buffer and builds an array of pointers to	*/
/* to all of the strings in the specified class. The array is dynamically	*/
/* allocated after the total number of strings in the class is determined. */
/* An error check is done to be sure this function is only called once for */
/* any specified class of data															*/
/* 																								*/
/* char **GetClassData( char *InfoClass ) 											*/
/* 																								*/
/* ARGUMENTS:	InfoClass	- Ptr to data class string 							*/
/* RETURNS: 	char **		- Array of pointers to strings in this class 	*/
/* 								  or NULL if the class wasn't found             */
/* 																								*/
/***************************************************************************/

static char **GetClassData( char *InfoClass )
{
	register 	uFirst;					/* First entry for specified class	*/
	register 	uLast;					/* Last entry for specified class	*/
	char			**szStrings;			/* Array of ptrs to strings			*/
	int			i; 						/* Indice for array of ptrs			*/
	unsigned 	uArraySize;

	szStrings = NULL; 					/* Just in case class isn't found	*/

												/* Locate the specified class 		*/
	for ( uFirst = 0;
			uFirst < RELOC_LEN && RelocBuf[ uFirst ] != EOC_MARKER;
			uFirst++ )
		if ( strcmpi( (pchStringBuf + RelocBuf[ uFirst ]), InfoClass ) == OK )
			break;

	if ( RelocBuf[ uFirst ] != EOC_MARKER )	/* May not have found class*/
	{
		uFirst++;							/* Skip over class label */

												/* Locate end of this class */
		for ( uLast = uFirst;
				uLast < RELOC_LEN &&
				RelocBuf[ uLast ] != EOC_MARKER	&&
			  *(pchStringBuf + RelocBuf[ uLast ]) != '[';
				uLast++ )
			;
							/* Determine num class entries + end of array marker	*/
		uArraySize = (unsigned)(uLast - uFirst) + 1;

		if ( uArraySize > 1 )
		{
			szStrings = GetMemory( uArraySize * sizeof(char *) );

												/* Fill in array with ptrs to strings */
			for ( i = 0; uFirst < uLast; uFirst++, i++ )
				szStrings[ i ] = pchStringBuf + RelocBuf[ uFirst ];

			szStrings[ i ] = NULL;			/* Mark end of array with NULL ptr	*/
		}
	}

	return( szStrings );
}

/***************************************************************************/
/* Returns a ptr to a string of the specified type which is from the list	*/
/* of strings for that type. The argument Index specifies which string		*/
/* in the array for that type is returned. If the specified type is ivalid */
/* a NULL ptr will be returned but there is no error checking on the Index */
/* value but if the caller makes calls using a sequence of values the end	*/
/* end of the data for that type will be signaled when a NULL ptr is 		*/
/* returned.																					*/
/* 																								*/
/* Valid type are the enunerated values defined by "UpgradeData". 			*/
/* 																								*/
/* char *GetDataString( int Type, int Index )										*/
/* 																								*/
/* ARGUMENTS:	Type		- Specifies the data array to look in					*/
/* 				Index		- String in the list to be returned 					*/
/* RETURNS: 	char *	- Ptr to sting or NULL if no more strings 			*/
/* 																								*/
/***************************************************************************/

char *GetDataString( int Type, int Index )
{
	return ( (Type < 0 || Type >= END_CLASS || Data[ Type ] == NULL) ?
				NULL : *(Data[ Type ] + Index) );
}

/***************************************************************************/
/* Returns an array of ptrs to all of the strings in the specified class.	*/
/* Returns NULL ptr if argument is not a valid class. 							*/
/* 																								*/
/* Valid class type are the enunerated values defined by "UpgradeData".		*/
/* 																								*/
/* char **GetClassList( int Type )														*/
/* 																								*/
/* ARGUMENTS:	Type		- Specifies the data class to array to return		*/
/* RETURNS: 	char **	- Array of ptrs to strings in the specified class	*/
/* 																								*/
/***************************************************************************/

char **GetClassList( int Type )
{
	return ( (Type < 0 || Type >= END_CLASS || Data[ Type ] == NULL) ?
				NULL : Data[ Type ] );
}

/***************************************************************************/
/* Returns the distribution disk type where 1=360K, 2 = 720K, 3 = 1.2meg,	*/
/* 4 = 1.44meg																					*/
/* 																								*/
/* void GetDistrDiskType( int iType )													*/
/* 																								*/
/* ARGUMENTS:	void																			*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

int GetDistrDiskType( void )
{
	return( iDiskType );
}

/***************************************************************************/
/* Returns the total number of distrubution disks for the upgrade.			*/
/* 																								*/
/* int GetNumberDisks( void )																*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	int	-	Total number of distribution disks						*/
/* 																								*/
/***************************************************************************/

int GetNumberDisks( void )
{

	return ( GetNumberStrings( Data[ USER_LABEL ] ) );

}

/***************************************************************************/
/* Returns a ptr to a disk label string for the specified disk. No error	*/
/* checking is done for disk number.													*/
/* 																								*/
/* char *GetDiskLabel( int iDiskNum )													*/
/* 																								*/
/* ARGUMENTS:	iDiskNum 	- File seqence number									*/
/* RETURNS: 	char *		- Ptr to label string									*/
/* 																								*/
/***************************************************************************/

char *GetDistribLabel( int iDiskNum )
{
	return( GetDataString( DIST_LABEL, iDiskNum) );
}

/***************************************************************************/
/* Returns a ptr to a prompt string for the specified distribution disk.	*/
/*	No error checking is done for disk type or prompt number.					*/
/* 																								*/
/* char *GetDiskPrompt( int iDiskNum )													*/
/* 																								*/
/* ARGUMENTS:	iDiskNum 	- File seqence number									*/
/* RETURNS: 	char *		- Ptr to prompt string									*/
/* 																								*/
/***************************************************************************/

char *GetDistribPrompt( int iDiskNum )
{
	return( GetDataString( PROMPT, iDiskNum) );
}

/***************************************************************************/
/* Returns a ptr to a prompt string for the specified user supplied disk.	*/
/*	No error checking is done for disk type or prompt number.					*/
/* 																								*/
/* char *GetDiskPrompt( int iDiskNum )													*/
/* 																								*/
/* ARGUMENTS:	iDiskNum 	- File seqence number									*/
/* RETURNS: 	char *		- Ptr to prompt string									*/
/* 																								*/
/***************************************************************************/

char *GetUserPrompt( int iDiskNum )
{
	return( GetDataString( USER_PROMPT, iDiskNum) );
}

/***************************************************************************/
/* Returns a ptr to a prompt string for the specified disk. No error 		*/
/* checking is done for disk number.													*/
/* 																								*/
/* char *GetUserLabel( int iDiskNum )													*/
/* 																								*/
/* ARGUMENTS:	iDiskNum 	- File seqence number									*/
/* RETURNS: 	char *		- Ptr to label string									*/
/* 																								*/
/***************************************************************************/

char *GetUserLabel( int iDiskNum )
{
	return( GetDataString( USER_LABEL, iDiskNum ) );
}

/***************************************************************************/
/* Returns a ptr to the specified file on the specified disk. The name is	*/
/* directly from the DosData file and is not translated. Error checking 	*/
/* is done to be sure the disk number is valid but there is no checking 	*/
/* done on the file number but if caller gets the files name using a valid */
/* sequence a NULL ptr will be returned to signal the end of the list.		*/
/* 																								*/
/* char *GetFileName( int iDisk, iFile )												*/
/* 																								*/
/* ARGUMENTS:	Disk			- Distribution disk number 							*/
/* 				iFile 		- File seqence number									*/
/* RETURNS: 	char *		- Ptr to file name or NULL if invalid file # 	*/
/* 																								*/
/***************************************************************************/

char *GetFileName( int iDisk, int iFile )
{
  if (iDisk < 0)
    {
      /* This is maintenance mode -- get the file */
      /*   from the optional components list.     */
      /*   No error checking is performed.        */
      return (GetDataString (-iDisk, iFile));
    }
  else
    {
      /* This is for non-maintenance mode */
      iDisk += DISK_0;

      return ((iDisk >= DISK_0 && iDisk < END_CLASS) ?
               GetDataString (iDisk, iFile) : NULL);
    }
}

/***************************************************************************/
/* Translates a file name based on the content of the data field RENAME 	*/
/* and NO_COPY from the data file. The return ptr will be the correct name */
/* to be used when creating it on the user's disk. If the file is marked   */
/* don't copy a NULL ptr will be returned. The order of precedence is		*/
/* NO_COPY then GLOBAL_RENAME.															*/
/*																									*/
/* Updated 08/21/90 to return NULL if floppy upgrade and the file is a net	*/
/* upgrade file.																				*/
/*																									*/
/* char *GetRealDestName ( char *szFileName )										*/
/* 																								*/
/* ARGUMENTS:	szFileName	- Ptr to name of file to translate					*/
/* RETURNS: 	char *		- Ptr to correct file name for destination file	*/
/* 																								*/
/***************************************************************************/

char *GetRealDestName( char *szFileName )
{
	register		i;
	char			*szString;

												/* See if file in in the NO_COPY list	*/
	if ( FindDataMatch( szFileName, NO_INSTALL ) )
		return( NULL );
												/* Now check for drivers which may not	*/
												/* need copying and net update files	*/
	if ( Data[ DRIVER_VERSION ] != NULL &&
		  ((i = StrSearch( szFileName, Data[ DRIVER_VERSION ] )) != -1 &&
			vInfo.NoCopy[ (UINT)i >> 1 ] == TRUE) )
   {

#if defined(UPGRADE_PROGRAM) || defined(RECOVERY_PROGRAM)
      // If HIMEM.SYS, check if we copy it anyway even though there's already
      // an existing XMS driver active (we won't update CONFIG.SYS though).
      //
      if ((i>>1) != NO_HIMEM && (i>>1) != NO_EMM386)
         return ( NULL );
#else
      return (NULL);
#endif
   }

#if defined(UPGRADE_PROGRAM) || defined(RECOVERY_PROGRAM)
	/* Update only Microsoft DOS Mouse drivers */
   /* BUGBUG - this should be handled via the vInfo.NoCopy array in        */
   /* the future.                                                          */
	if (vInfo.Flag.fMouse == FALSE &&
		 stricmp (szFileName, "MOUSE.COM") == 0)
		return (NULL);
#endif

#ifndef	OEM_PROGRAM
	if ( (!vInfo.Flag.fHardInstall || vInfo.chSource < vInfo.chFirstHd)
		  && FindDataMatch( szFileName, NET_FILES ) )
		return( NULL );
#endif

												/* Now see if it get's renamed 			*/
	if ( (szString = TranslateString( GLOBAL_RENAME, szFileName )) != NULL )
		return( szString );
	else
		return( szFileName );
}


/***************************************************************************/
/* Scans the DIF_PATH class to see if the specified file name is in the 	*/
/*	list. If the file name is found the new path associated with the			*/
/*	file name is returned. If the file name is not found in the list the 	*/
/* ptr to the default path is returned.												*/
/*																									*/
/* Updated 09/21/90 to support a different path for network files which		*/
/* will be copied to a new directory in OLD_DOS.xxx.								*/
/* 																								*/
/* char *GetRealPath( char *szFile, char *szOldPath )								*/
/* 																								*/
/* ARGUMENTS:	szFile	-	Ptr to file name string 								*/
/* 				szOldPath-	Ptr to default path										*/
/* RETURNS: 	char *	-	Ptr to real path for specified file 				*/
/* 																								*/
/***************************************************************************/

char *GetRealDestPath( char *szFile, char *szOldPath )
{
	char		*szNewPath;

	szNewPath = TranslateString( DIF_PATH, szFile );

#ifndef	OEM_PROGRAM
	if ( szNewPath == NULL && vInfo.Flag.fHardInstall &&
		  FindDataMatch( szFile, NET_FILES ) )
		szNewPath = vInfo.szNetDir + 3;
#endif

	return( szNewPath != NULL ? szNewPath : szOldPath );
}

/***************************************************************************/
/* Scans the DISTRIB_X classes to see if the specified file name is in the	*/
/*	list. If the file name is found the disk number associated with this 	*/
/*	file name is returned. If the file name is not found in the list the 	*/
/*	orignal disk number is returned. 													*/
/* 																								*/
/* int GetRealDisk( char *szFile, int iDiskNum )									*/
/* 																								*/
/* ARGUMENTS:	szFile	-	Ptr to file name string 								*/
/* 				iDiskNum -	Default disk number										*/
/* RETURNS: 	int		-	Disk number for this disk or -1 if not found 	*/
/* 																								*/
/***************************************************************************/

int GetRealSrcDisk( char *szFile, int iDiskNum )
{
	register 	i;
	register		iEnd;

	iEnd = DISTR_0 + MAX_NUM_DISKS;

	for ( i = DISTR_0; i < iEnd && Data[ i ] != NULL; i++ )
	{
		if ( StrSearch( szFile, Data[ i ] ) != -1 )
		{
			iDiskNum = i - DISTR_0;
			break;
		}
	}

	return( iDiskNum );
}

/***************************************************************************/
/* Scans the specified class of translation strings for a string matching	*/
/* the arugment szString. If a match is found a ptr to the string 			*/
/* associated with the matched string is return. If a match is not found	*/
/* a NULL ptr is returned. 																*/
/* 																								*/
/* char *TranslateString( int Type, char *szString )								*/
/* 																								*/
/* ARGUMENTS:	Type		-	Specifies the data class to scan						*/
/* 				szString -	Ptr to string to be translated						*/
/* RETURNS: 	char *	-	Ptr to new string if argument string was found	*/
/* 								in specified class else NULL ptr						*/
/* 																								*/
/***************************************************************************/

char *TranslateString( int Type, char *szString )
{
	register 	i;
	char			*szMatch;

	for( i = 0; (szMatch = GetDataString( Type, i)) != NULL; i += 2 )
		if ( strcmpi( szMatch, szString ) == OK )
		{
			szMatch = GetDataString( Type, ++i );
			break;
		}

	return( szMatch );
}

/***************************************************************************/
/* Checks for a matching string in the specified OEM information class. 	*/
/* 																								*/
/* int FindOemInfo( char *szString, int Type )										*/
/* 																								*/
/* ARGUMENTS:	szString -	Ptr to a string											*/
/* RETURNS: 	int		-	TRUE	string exists in the specifed class			*/
/* 								else FALSE													*/
/* 																								*/
/***************************************************************************/

int FindDataMatch( char *szString, int Type )
{
	if ( Data[ Type ] == NULL )
		return( FALSE );
	else
		return( StrSearch( szString, Data[ Type ] ) == -1 ? FALSE : TRUE );
}

/***************************************************************************/
/* Returns the total bytes that would be read plus bytes written when		*/
/* the specified disk is copied.															*/
/*																									*/
/*	long GetDiskBytes( iDiskNum )															*/
/*																									*/
/*	ARGUMENTS:	iDiskNum -	Disk number to get bytes on (0 based)				*/
/*	RETURNS:		long		-	Total bytes													*/
/*																									*/
/***************************************************************************/

long	GetDiskBytes( int iDiskNum )
{
	char		*szByteStr;

	szByteStr = GetDataString( DISK_BYTES, iDiskNum);

	if ( szByteStr != NULL )
		return( atol( szByteStr ) );
	else
		return( 0L );
}

/***************************************************************************/

#ifndef	OEM_PROGRAM

/***************************************************************************/
/* Initializes the Data[ OEM_TABLE ] array with arrays of pointers to		*/
/*	strings which describe all the information needed to search a series of */
/* files for a specific string to determine the user's OEM. Returns an     */
/* array of pointers to the strings that specify this information.			*/
/* 																								*/
/* char **InitSearchData( int MajorVer, int	MinorVer )							*/
/* 																								*/
/* ARGUMENTS:	MajorVer -	DOS major version number								*/
/* 				MinorVer -	DOS minor verison number								*/
/* RETURNS: 	char **	-	Array of pointer to file,search,OEM strings		*/
/* 								or NULL if no information for this version		*/
/* 																								*/
/* Array format:																				*/
/* 																								*/
/* "FILENAME.EXT" 																			*/
/* "string" 																					*/
/* "OEMNAME"																					*/
/* "string" 																					*/
/* "OEMNAME                                                                */
/* "&&"																							*/
/* "FILENAME.EXT" 																			*/
/* "string1"																					*/
/* "OEMNAME"																					*/
/* "string" 																					*/
/* "OEMNAME"																					*/
/* NULL																							*/
/* 																								*/
/***************************************************************************/

char **InitSearchData( int MajorVer, int	MinorVer )
{
	static char		*szVer = "[0.00]";
	struct DDR		*Oem;

	itoa( MajorVer, szVer + 1, 10 );				/* Make version string [0.00] */
	szVer[2] = '.';
	szVer[3] = '0';
	itoa( MinorVer, szVer + (MinorVer > 9 ? 3 : 4), 10 );
	szVer[5] = ']';
	szVer[6] = EOL;

	if ( (Oem = GetOemRecord( szSearch, 0, 0 )) != NULL )
	{
		ReadOemData( Oem->uDataOffset );
		Data[ OEM_TABLE ] = GetClassData( szVer );
	}
	else
		Data[ OEM_TABLE ] = NULL;

	return( Data[ OEM_TABLE ] );
}

/***************************************************************************/
/* Frees the memory allocated to OEM_TABLE array. This can be called as 	*/
/* soon as the OEM has been identified since the search list is only used	*/
/* the initial time the OEM is determined.											*/
/* 																								*/
/* void FreeSearchData( void )															*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void FreeSearchData( void )
{
	if ( Data[ OEM_TABLE ] != NULL )
	{
		FreeMemory( Data[ OEM_TABLE ] );
		Data[ OEM_TABLE ] = NULL;
	}
}

/***************************************************************************/
/* Builds a list of ptrs to all of the OEM vender names for the specifed	*/
/* DOS version. The total number of names in the list is returned and the	*/
/* a NULL ptr will be added to mark the end of the list. 						*/
/* 																								*/
/* int BuildOemList( char *apszList, int MajorVer, int MinorVer )				*/
/* 																								*/
/* ARGUMENTS:	apszList		-	Arary to hold ptrs to oem names					*/
/* 				MajorVer 	-	DOS major version number							*/
/* 				MinorVer 	-	DSO minor version number							*/
/* RETURNS: 	int			-	Total names added to the list 					*/
/* 																								*/
/***************************************************************************/

int BuildOemList( char **apszList, int MajorVer, int MinorVer )
{
	register 	i;
	register 	iCount;

	for ( i = iCount = 0; i < (int)MaxOem; i++ )
		if ( (int)OemList[ i ].MajorVer == MajorVer &&
			  (int)OemList[ i ].MinorVer == MinorVer )
			apszList[ iCount++ ] = OemList[ i ].szOemName;

	apszList[ iCount ] = NULL;

	return( iCount	);
}

/***************************************************************************/
/* Returns a ptr to the string indexed by the argument StrNum in the list	*/
/*	of search strings for the search file specified by FileNum. 				*/
/* 																								*/
/* char	*GetOemStr( int FileNum, int StrNum )										*/
/* 																								*/
/* ARGUMENTS:	FileNum	- Search file sequence number 							*/
/* 				StrNum	- Search string sequence # for specified search 	*/
/* 							  file.															*/
/* RETURNS: 	char *	- Ptr to search string or NULL if invalid file or	*/
/* 							  string sequence number									*/
/* 																								*/
/***************************************************************************/

char *GetSearchStr( int FileNum, int StrNum )
{
	register 	i;
	register 	iStrCount;
	int			iFileCount;
	char			*szString;

	for ( i = iFileCount = 0; iFileCount < FileNum; i++ )
	{
		if ( (szString = GetDataString( OEM_TABLE, i )) == NULL )
			break;
		else
			if ( szString[0] == '&' )
				iFileCount++;
	}

	for ( iStrCount = 0;
			iStrCount <= StrNum && szString != NULL;
			iStrCount++, i++ )
	{
		if ( (szString = GetDataString( OEM_TABLE, i )) != NULL )
			if ( szString[0] == '&' )
				szString = NULL;
	}

	return( szString );
}

/***************************************************************************/
/* Returns the distribution version number for the specified device driver	*/
/* which is in the data file.																*/
/*																									*/
/* NOTE:																							*/
/* 	See the file "retail\global.h" for the number assigned to each			*/
/*		of the distributed device drivers.												*/
/*																									*/
/*	unsigned GetDriverVersion( int iDriverNum )										*/
/*																									*/
/*	ARGUMENTS:	iDriverNum - Driver number to get the version for				*/
/*	RETURNS:		unsigned	  - The specified driver's internal revision #		*/
/*																									*/
/***************************************************************************/

unsigned GetDriverVersion( int iDriverNum )
{
	char		*szVersion;

	szVersion = GetDataString( DRIVER_VERSION, (iDriverNum * 2) + 1);

	if ( szVersion != NULL )
		return( (unsigned)atoi( szVersion ) );
	else
		return( 0 );
}

/***************************************************************************/
/* Checks a filename to see if it's a file the gets copied from the			*/
/* distribution disks.																		*/
/*																									*/
/*	int IsDistrFile( char *szFile )														*/
/*																									*/
/*	ARGUMENTS:	szFile	- Ptr to file name to check for							*/
/*	RETURNS:		int		- TRUE if file is to be copied else FALSE				*/
/*																									*/
/***************************************************************************/

int IsDistrFile( char *szFile )
{
	unsigned register		iDisk;
	register		iFile;
	char			*szTmp;

	for ( iDisk = FIRST_USER_DISK; iDisk < vInfo.uchNumDisks; iDisk++ )
	{
		for ( iFile = 0;
				(szTmp = GetFileName( iDisk, iFile )) != NULL;
				iFile++ )
		{
			if ( (szTmp = GetRealDestName( szTmp )) != NULL &&
				  strcmpi( szFile, szTmp ) == OK )
				return( TRUE );
		}
	}
	return( FALSE );
}

/***************************************************************************/
/* Enumerates the distribution files.													*/
/*																									*/
/* char * EnumDistrFiles( unsigned fCont )											*/
/*																									*/
/* ARGUMENTS:	fCont 	- 0 if start new enumeration, !0 if continue 		*/
/* RETURNS: 	char *	- ptr to first/next distribution file name			*/
/* 							  NULL if no more names 									*/
/*																									*/
/***************************************************************************/

char * EnumDistrFiles(unsigned fCont)
{
	static unsigned iDisk;
	static int		 iFile;
	char	 *szTmp;

	if (fCont == 0) { 									/* initialize counters if	*/
		iDisk = FIRST_USER_DISK;						/*   starting a new enum	*/
		iFile = 0;
	}

	while (iDisk < vInfo.uchNumDisks)
	{
		if ((szTmp = GetFileName(iDisk, iFile++)) != NULL)
		{
			if ((szTmp = GetRealDestName(szTmp)) != NULL)
				return(szTmp);

		} else {

			iFile = 0;										/* switch to next disk */
			iDisk++;
		}
	}

	return(NULL);
}

/***************************************************************************/

#endif

/***************************************************************************/
/* Scans the DIF_FILE class in the data list	to see if the specified file	*/
/*	name is in the	list. If the file name is found the new file name			*/
/*	associated with the specified	file name is returned. If the file name	*/
/*	is not found in the list the original default file name is returned.		*/
/* 																								*/
/* char *GetRealSrcName( char *szFile )												*/
/* 																								*/
/* ARGUMENTS:	szFile	-	Ptr to file name string 								*/
/* RETURNS: 	char *	-	Ptr to new path or if not in list arg string		*/
/* 																								*/
/*	Video Types:																				*/
/*			0 = MONO																				*/
/*			1 = CGA																				*/
/*			2 = EGA																				*/
/*			3 = VGA																				*/
/*			4 = HERCULES																		*/
/***************************************************************************/

char *GetRealSrcName( char *szFile )
{
	char		*szString;
	char		**apszFiles;
	static char	szSourceGrpName[13] = { '\0' };
#ifndef RECOVERY_PROGRAM
	char		szPath[MAX_PATH];    /* Used in checking for existing */
                                     /*   windows utilities.          */
#endif

#ifndef OEM_PROGRAM
	extern char *gszWNToolsGrp;
#endif

	szString = NULL;

	if ( strcmpi( szFile, "DOSSHELL.VID" ) == OK )		/* Video driver chk		*/
	{
		if ( vInfo.Hw.VideoType == 0 )		/* Don't need a driver if mono	*/
			return( NULL );

		if ( (apszFiles = GetClassList( VIDEO_DRIVER )) != NULL )
			szString = apszFiles[ vInfo.Hw.VideoType ];
	}

	else 	if ( strcmpi( szFile, "DOSSHELL.INI" ) == OK )	/* .INI file chk	*/
	{
		if ( (apszFiles = GetClassList( VIDEO_LIST )) != NULL )
			szString = apszFiles[ vInfo.Hw.VideoType ];
	}		

	else 	if ( strcmpi( szFile, "DOSSHELL.GRB" ) == OK )	/* .GRB file chk	*/
	{
		if ( (apszFiles = GetClassList( GRABBER_DRIVER )) != NULL )
			szString = apszFiles[ vInfo.Hw.VideoType ];
	}		
#ifndef OEM_PROGRAM
	else 	if ( strcmpi( szFile, gszWNToolsGrp ) == OK )	/* .GRP file chk	*/
	{
        /* If there is no source .GRP filename, create one */
        if (szSourceGrpName[0] == '\0')
          {
            /* Create the name of the source group file:     */
            /*   BK = Backup, UD = Undelete, AV = Anti-Virus */

            /* Is there, or will there be a Windows Backup utiltity */

#ifdef RECOVERY_PROGRAM
            if (vInfo.OptComp.BackupChoice    == WINDOWS_AND_DOS_COMPONENT ||
                vInfo.OptComp.BackupChoice    == WINDOWS_COMPONENT)
#else
            if (Install.Flags.fMaintenance)
              {
                strcpy (szPath, vInfo.szPath);
                mycatpath (szPath, "MWBACKUP.EXE");
              }

            if (vInfo.OptComp.BackupChoice    == WINDOWS_AND_DOS_COMPONENT ||
                vInfo.OptComp.BackupChoice    == WINDOWS_COMPONENT         ||
                (Install.Flags.fMaintenance && access (szPath, 0) != -1))
#endif
              strcat (szSourceGrpName, "bk");


            /* Is there, or will there be a Windows Undelete utility */

#ifdef RECOVERY_PROGRAM
            if (vInfo.OptComp.UndeleteChoice  == WINDOWS_AND_DOS_COMPONENT ||
                vInfo.OptComp.UndeleteChoice  == WINDOWS_COMPONENT)
#else
            if (Install.Flags.fMaintenance)
              {
                strcpy (szPath, vInfo.szPath);
                mycatpath (szPath, "WNUNDEL.EXE");
              }

            if (vInfo.OptComp.UndeleteChoice  == WINDOWS_AND_DOS_COMPONENT ||
                vInfo.OptComp.UndeleteChoice  == WINDOWS_COMPONENT         ||
                (Install.Flags.fMaintenance && access (szPath, 0) != -1))
#endif
              strcat (szSourceGrpName, "ud");


            /* Is there, or will there be a Windows Anti-Virus utility */

#ifdef RECOVERY_PROGRAM
            if (vInfo.OptComp.AntiVirusChoice == WINDOWS_AND_DOS_COMPONENT ||
                vInfo.OptComp.AntiVirusChoice == WINDOWS_COMPONENT)
#else
            if (Install.Flags.fMaintenance)
              {
                strcpy (szPath, vInfo.szPath);
                mycatpath (szPath, "MWAV.EXE");
              }

            if (vInfo.OptComp.AntiVirusChoice == WINDOWS_AND_DOS_COMPONENT ||
                vInfo.OptComp.AntiVirusChoice == WINDOWS_COMPONENT         ||
                (Install.Flags.fMaintenance && access (szPath, 0) != -1))
#endif
              strcat (szSourceGrpName, "av");

            strcat (szSourceGrpName, ".grp");
          }

        szString = szSourceGrpName;
	}
#endif
	else if ( (szString = TranslateString( DIF_FILE, szFile )) == NULL )
		szString = szFile;

	return( szString  );
}


/***************************************************************************/
/*   void ReplaceParam()                                                   */
/*                                                                         */
/*   Useful for replaceable parameters in setup screens.  It allows the    */
/*   parameter to be on any line in the screen.                            */
/*   In its current incarnation, you have to call it once for each         */
/*   replaceable param.                                                    */
/*                                                                         */
/*   ARGUMENTS:   apszScreen  - array of strings (from GetMessage).        */
/*                pszOld      - pattern to look for.                       */
/*                pszNew      - pattern to replace it with.                */
/*                pszBuf      - buffer to return modified line in. Buffer  */
/*                              will be inserted in apszScreen[] array     */
/*                fKeepLength - TRUE if line length must remain the same   */
/*   RETURNS:     NOTHING.                                                 */
/***************************************************************************/
void ReplaceParam (char **apszScreen, char *pszOld, char *pszNew,
                   char *pszBuf, int fKeepLength)
{
   char     *psz;
   unsigned  i, cbOld;
   int       delta;

   while (*apszScreen != NULL)
   {
      if ((psz = strstr(*apszScreen, pszOld)) != NULL)
      {
         cbOld = strlen(pszOld);
         i = psz-*apszScreen;

         strncpy (pszBuf, *apszScreen, i);
         strcpy (pszBuf+i, pszNew);
         strcat (pszBuf, psz+cbOld);

         if (fKeepLength)
         {
            delta = (int)((int)strlen(pszNew) - (int)cbOld);
            i     = strlen(pszBuf);

            if (delta > 0)
               pszBuf[ i-(unsigned)delta ] = 0;
            else if (delta < 0)
            {
               psz = i+pszBuf;
               for (i=0, delta=-(delta); i<(unsigned)delta; i++)
                  *(psz+i) = ' ';
               *(psz+i) = 0;
            }
         }

         *apszScreen = pszBuf;
      }
      apszScreen++;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\common\getchar.c ===
/***************************************************************************/
/*                                                                         */
/*	GETCHAR.C																					*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Misc. input functions																	*/
/*                                                                         */
/* johnhe - 12/01/89																			*/
/***************************************************************************/

#include    <stdio.h>
#include    <stdlib.h>

#include		<alias.h>
#include		<bios_io.h>
#include		<window.h>

/***************************************************************************
 * Globals
 ***************************************************************************/

int					AbortEnabled = TRUE;

/***************************************************************************/
/* Functions for getting input from the keyboard.                          */
/***************************************************************************/

static int			Extension;			/* Scan code for last char from GetChar*/
static int			UnGottenChar;		/* Place to stuff an UnGet() character */
static int			IsWaiting;			/* TRUE if UnGottenChar is valid 		*/

extern void			Help( void );
extern void			ProgramAbort( void );

/***************************************************************************/
/* The argument will be returned by the next call to GetChar(). Similar to */
/* stuffing a character into the keyboard buffer. The function does not 	*/
/* que the ungotten characters so this character is lost if another call	*/
/* to the function is done before a call to GetChar().							*/
/* 																								*/
/* void UnGetChar( int Char ) 															*/
/* 																								*/
/* ARGUMENTS:	Char	- Character to return on next call to GetChar() 		*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void UnGetChar( int Char )
{
	UnGottenChar = Char;
   IsWaiting = TRUE;
}

/***************************************************************************/
/* Returns the scan code for the last character returned by GetChar()      */
/* 																								*/
/* int GetCharExtension( void )															*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	int	- Scan code for last charcter returned by GetChar()	*/
/* 																								*/
/***************************************************************************/

int GetCharExtension( void )
{
	return( (int)Extension );
}

/***************************************************************************/
/* Flushes the keyboard buffer.															*/
/* 																								*/
/* void KbdFlush( void )																	*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void KbdFlush( void )
{
	while( KbdIsWaiting() )
		KbdGetKey();
}

/***************************************************************************/
/* Waits for a character to be entered at the keyboard. Returns the ascii  */
/* value of the character entered and saves the scan code for the next     */
/* call GetCharExtension(). If a character has been returned with          */
/* UnGetChar() it will be the one returned. Also does a check for F3			*/
/* and if abort is allowed will offer the option to the user. Always 		*/
/* flushes the keyboard buffer before getting a character.						*/
/* 																								*/
/* int GetChar( void )																		*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	int	- Low byte of word returned by int 16h function 0.		*/
/* 																								*/
/***************************************************************************/

int GetChar( void )
{
															/*lint -e727						*/
	int				Char;								/* Char from the keyboard		*/
	static int		IsF3;								/* Prevents recursive F3		*/
	static int		IsHelp;

   if ( IsWaiting == TRUE )
	{														/* See if a char was ungotten */
		Char = UnGottenChar;
      IsWaiting = FALSE;
   }
   else
   {
#ifndef DBCS
		KbdFlush();										/* Flush the keyboard buffer	*/
#endif
		do
		{
			Char = KbdGetKey();

			if ( Char == (F1 << 8) )
			{
				IsHelp = TRUE;
				Help();
				IsHelp = FALSE;
			}
#ifndef	HD_BACKUP
			else if ( Char == (F5 << 8) && !IsHelp && !IsF3 )
			{
				if ( GetBackGroundColor() != 0x07 )
				{
					SetDefaultColors( 0 );
					StripScreenColor();
				}
			}
#endif

			if ( Char == (F3 << 8) )
			{
				if ( !AbortEnabled )
					break;

				/* 1st F3 displays confirmation prompt; 2nd F3 aborts. */
				if ( IsF3 == FALSE )
				{
					IsF3 = TRUE;
					AllowAbort();
					IsF3 = FALSE;
				}
				else
					ProgramAbort();
			}	
		}
		while( Char == (F1 << 8) || Char == (F3 << 8) );

		Extension = (int)((unsigned)(Char) >> 8);
	
   }
	return( (Char & 0xff) );
															/*lint +e727 */
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\common\resident.asm ===
;***************************************************************************
;*
;*  RESIDENT.ASM   - Resident code and data used for passing information
;*                   from one executable to another.
;*
;*	Copyright (c) 1991 - Microsoft Corp.
;*	All rights reserved.
;*	Microsoft Confidential
;*
;*
;*  NOTE this segment MUST be first!!!
;*
;***************************************************************************

ifndef	UPGRADE

KB_INTERCEPT	EQU	4fh

DEL_KEY		EQU	53h
ALT_SHIFT	EQU	08h
CTL_SHIFT	EQU	04h

WARM_BOOT_CODE	EQU	1234h	

;-----------------------------------------------------------------------------;
;	BIOS DATA AREA LOCATED AT 40:00
;-----------------------------------------------------------------------------;

ROM_DATA SEGMENT AT 040h

	org	17h
KB_FLAG		LABEL BYTE

	org	072h
WarmBootFlag	LABEL WORD

ROM_DATA ENDS

;-----------------------------------------------------------------------------;
;	CPU POWER-ON STARTUP LOCATION AT ffff:00
;-----------------------------------------------------------------------------;

ROM_BIOS SEGMENT AT 0ffffh
	org	0

PowerOnReset	LABEL FAR

ROM_BIOS ENDS

endif

.MODEL LARGE,C

.XLIST
include install.inc

ifdef UPGRADE
include global.inc
FIRST_HARD_DISK		EQU	80h
extrn	IOMEGA_END:word
extrn	IOMREM:far
endif
.LIST

;***************************************************************************

MAX_CMD_TAIL_LEN equ 126d       ; Used to check for overflow when appending
                                ; switches to Setup's command line.


STACKSIZE        = 2048d

WriteAux    macro   dstr
        local WriteAuxStr, WriteAuxStrLen

ifdef   DEBUG

        jmp     short @F

WriteAuxStr     db  dstr, 10, 13
WriteAuxStrLen  equ $-WriteAuxStr

@@:
        push    ax
        push    bx
        push    cx
        push    dx
        push    ds

        mov     ax, cs                  ;Get segment of string into ds
        mov     ds, ax
        lea     dx, WriteAuxStr
        mov     cx, WriteAuxStrLen
        mov     bx, 0003h               ;standard aux device
        mov     ah, 040h                ;Write String
        int     21h

        pop     ds
        pop     dx
        pop     cx
        pop     bx
        pop     ax
endif
        endm

MYFARPTR      STRUC
        off     dw      ?
        sel     dw      ?
MYFARPTR      ENDS

SLOADPARAMS  STRUC
        segEnv      dw 0        ; WORD  segEnv
        lpCmdLine   dd 0        ; LPSTR lpCmdLine
        lpFCB1      dd 0        ; LPSTR lpFCB1
        lpFCB2      dd 0        ; LPSTR lpFCB2
SLOADPARAMS   ENDS

arena   struc
        sig     db      0       ; 'M' or 'Z' for last block
        own     dw      0       ; PSP value of owner process or 0 if free
        asiz    dw      0       ; size of block (not including header)
arena   ends

codeOFFSET equ OFFSET _TEXT:

;***************************************************************************


.DATA

EXTRN _psp:WORD, _osmajor:WORD


;***************************************************************************
;***************************************************************************

.CODE _TEXT
	ASSUME CS:_TEXT, DS:DGROUP

;********************** BEGIN CONTIGUOUS BLOCK ******************************
;The Install and vInfo structures must be contiguous.  Note that the
;vInfo structure is omitted in the non-upgrade case.

	PUBLIC Install
Install db SIZE INSTALL dup (?)  ; Global state structure

ifdef UPGRADE
	PUBLIC vInfo
vInfo 	db SIZE INFO dup (?)	 ; Global information structure.

DiskChange	db	0

	include	newint13.asm
endif

;********************** END CONTIGUOUS BLOCK ********************************

szCopyCmdLine  db 128 dup (?)    ; save copies to use after DS is gone
szCopyProgName db 128 dup (?) 

loadparams    db SIZE SLOADPARAMS dup (?) ; Exec block info struct.
MyPSP         dw ?                        ; Need stroage for PSP.

OldInt2Fh	dd	0	 ; Original Int 2Fh address.

ifndef	UPGRADE

;
; This is a 2 dimensional buffer of width MAX_SCRN_LINE_LEN=76+3(for a CR,LF
; and '$') and length MAX_STRINGS=26. This buffer is filled in by the 
; message WINSETUP_EXIT_TEXT defined in nudoswin.txt by programinitialize 
; in initial.c. This message is printed if control is returned to ResExec
; in the non-upgrade case.
;
	PUBLIC	ExitMsg
ExitMsg	LABEL 	BYTE
	REPT	26
	DB	79 dup(0)
	ENDM
endif


;****************************************************************************
;
; BOOL FAR ResExec(char far *szProgName,char far *szCmdLine)
;
; Start program with the command line we were passed.
;
;****************************************************************************

ResExec PROC FAR USES DS SI DI, szProgName:FAR PTR, szCmdLine:FAR PTR

    mov     ax, _psp           	; Save pointer to PSP, we may need it later.
    mov     MyPSP, ax

    call    FAR PTR InitNewInt2Fh ; Init. Int 2Fh vector if not done yet.

    ;
    ; Free all of our memory.
    ;

    WriteAux 'Calling Fremem Now !!'

    call   FreeMem

    WriteAux 'We have returned from fremem'

    ;Copy input parameters into code segment before changing stack.

    mov     es, szCmdLine.sel
    mov     di, szCmdLine.off     ;es:di -> szCmdLine (cmd line for exec)
    call    CopyCmd		  ;szCopyCmdLine now contains cmd line.

    mov     ds, szProgName.sel
    mov     dx, szProgName.off    ;ds:dx -> szProgName (program name to exec)
    call    CopyProgName	  ;ds:dx -> szCopyProgName

    ; DS == CS beyond this point!

    ;
    ;   Change to the NEW stack.
    ;

    mov	    cx, codeOFFSET resize
ifdef	UPGRADE
    cmp	    cs:[vInfo].info_chBernoulliDrv, 0
    je	    ResNoBern1
    mov	    cx, codeOFFSET IOMEGA_END
ResNoBern1:
endif
    
    cli
    mov     ax, cs
    mov     ss, ax
    mov     sp, STACKSIZE
    add	    sp, cx
    sti

    ;
    ; Init an execblock structure.
    ;

    mov     ax, cs
    mov     es, ax

    mov     di, codeOFFSET szCopyCmdLine ; es:di --> command line for Init

    call    Init
    push    es                          ; Save the return params from Init.
    push    bx


    ;
    ;    Shrink OUR program to include ONLY PSP + EXEC + STACK.
    ;

    mov     ax, cs:MyPSP                ; Blow away all memory beyond resize.
    mov     es, ax
    mov	    bx, cx
    add     bx, 100h + STACKSIZE
    mov     cl, 4
    shr     bx, cl
    inc     bx
    mov     ah, 4Ah
    int     21h                         ; Everything in your DS is now gone.

    pop     bx                          ; Restore exec parameters.
    pop     es

restart:

    WriteAux 'About to exec!'

    mov     ax, 4b00h                   ; DOS exec call
    int     21h

    WriteAux 'Back from the exec!'

    mov     ah, 4Dh		; Get exit code.
    int     21h
    push    ax

    call    FAR PTR RestoreOldInt2Fh ; Clean-up Int 2Fh vector

ifdef UPGRADE
    cmp	    cs:[vInfo].info_chBernoulliDrv, 0
    je	    ResNoBern2
    call    IOMREM
ResNoBern2:
    call    RestoreOld13
else
    call    PrintMsgAndReboot    ; Never returns.
endif

; Clear bottom 2 lines of display (assume 25 lines: numbered 0 to 24) and
; position cursor there. (By placing cursor on line 23, COMMAND.COM will
; do a line feed and place it on next line, line 24.)

    mov     ax,0602h             ; Scroll up 2 lines.
    mov     bh,07h               ; Normal video.
    mov     cx,1700h             ; Scroll last 2 lines.
    mov     dx,184fh
    int     10h

    mov     ah,0fh               ; Get Video mode.
    int     10h                  ; BH = current page.
    mov     ah,02h               ; Set cursor position.
    mov     dx,1700h             ; Next to last line.
    int     10h

    mov     ah,01h               ; Set Cursor type
    mov     cx,0607h             ; Assume text mode.
    int     10h

    pop     ax                   ; AL = WINSETUP return value
    mov     ah, 4ch              ; Terminate
    test    cs:[Install.inst_Flags],flag_fINT2FChained ; Q: INT 2F chained?
    jz      SHORT RE_Exit        ; No, go ahead and exit

; We have hooked INT 2F and cannot unhook since XMSMMGR has hooked
; it after us so we must terminate and stay resident to maintain INT 2F chain.
    mov     bx, codeOFFSET resize
ifdef	UPGRADE
    cmp	    cs:[vInfo].info_chBernoulliDrv, 0
    je      SHORT ResNoBern3
    mov     bx, codeOFFSET IOMEGA_END
ResNoBern3:
endif
    add     bx, 100h + STACKSIZE
    mov     cl, 4
    shr     bx, cl
    inc     bx

    or      cs:[Install.inst_Flags],flag_fINT2FOrphan  ; We are INT 2F orphan
    mov     dx,bx                ; DX = # of para.
    mov     ah, 31h              ; Terminate and stay resident (INT 2F chained)

RE_Exit:

    int     21h

    ret

ResExec ENDP


;****************************************************************************
;
; FAR NewInt2Fh()
;
; Int 2Fh, function INT2F_INSTALL_DATA -- Get pointer to resident
; installation data.
;
; Entry: AX = INT2F_INSTALL_DATA (constant)
;
; Exit:  ES:BX -> _Install structure
;
;****************************************************************************

NewInt2Fh PROC FAR
        test    cs:[Install.inst_Flags],flag_fINT2FOrphan  ; We are INT 2F orphan
        jnz     SHORT n2f40
	cmp	ax,INT2F_INSTALL_DATA	;My function?
	je	n2f50			; -yes, jump.
n2f40:
        jmp     DWORD PTR cs:OldInt2Fh	; -no, chain to original handler.

n2f50:	mov	ax,cs
	mov	es,ax
	mov	bx,codeOFFSET Install	;es:bx -> Install.
	mov	ax,0FFFFh		;Indicate presence.

	iret
NewInt2Fh ENDP


;****************************************************************************
;
; FAR InitNewInt2Fh()
;
; Hook Int 2Fh vector.
;
; Entry: none
;
; Exit:  none
;
;****************************************************************************

InitNewInt2Fh PROC FAR USES DS ES,

	mov	ax,WORD PTR CS:OldInt2Fh.off	
	or	ax,WORD PTR CS:OldInt2Fh.sel	;Already initialized?
	jnz	i2f50				; -yes, don't re-init.

	mov	ax,352Fh			;Get vector 2Fh
	int	21h
	mov	WORD PTR CS:OldInt2Fh.off,BX	;Save the offset
	mov	WORD PTR CS:OldInt2Fh.sel,ES 	;Save the segment

	mov	dx,codeOFFSET NewInt2Fh	
	push	cs			
	pop	ds				;ds:dx -> NewInt2Fh
	mov	ax,252Fh			;Set vector 2Fh
	int	21h

i2f50:	ret
InitNewInt2Fh ENDP


;****************************************************************************
;
; FAR RestoreOldInt2Fh()
;
; Restore Int 2Fh vector to its original value.
;
; Entry: none
;
; Exit:  none
;
;****************************************************************************

RestoreOldInt2Fh PROC FAR USES DS CX,

	mov	dx,WORD PTR CS:OldInt2Fh.off	
	mov	ax,WORD PTR CS:OldInt2Fh.sel
	mov	cx,ax
        or      cx,dx                   ;Did we hook INT 2F?
	jz	r2f50			; -no, don't restore.

        push    ax
        push    dx
        mov     ax,352Fh                ;Get current vector 2Fh
        int     21h                     ; ES:BX = current INT 2Fh
        pop     dx
        pop     ax
        cmp     bx,codeOFFSET NewInt2Fh ; Q: Did INT 2Fh change?
        jnz     SHORT r2F_Chained       ;    Y: set flag and don't restore
        push    cs
        pop     cx
        push    es
        pop     bx
        cmp     cx,bx                   ; Q: Did segment change?
        jnz     SHORT r2F_Chained       ;    Y: set flag and don't restore

r2f_Restore:
	mov	ds,ax			;ds:dx -> Original Int 2Fh handler.
	mov	ax,252Fh		;Set vector 2Fh
	int	21h

	xor	ax,ax			;Reset vector copy.
        and     cs:[Install.inst_Flags],NOT flag_fINT2FChained
	mov	WORD PTR CS:OldInt2Fh.off,ax
	mov	WORD PTR CS:OldInt2Fh.sel,ax
r2f50:	ret

r2F_Chained:
        or      cs:[Install.inst_Flags],flag_fINT2FChained ; INT 2F chained
        jmp     SHORT r2f50


RestoreOldInt2Fh ENDP


ifdef UPGRADE
;****************************************************************************
;
; FAR RealModeInt13h()
;
; Real-mode Int 13h buffer and function for use by GUI Dos Setup;
; called via DPMI.  The 512-byte buffer is immediately followed by the
; Int 13h function; there can be no intervening pad.
;
; Entry: Setup up by DPMI server.
;
; Exit:  Far return back to DPMI application.
;
;****************************************************************************

	ALIGN 4			;Ensure RMInt13hFunc is on WORD boundary.
	PUBLIC RealModeInt13h

RealModeInt13h db 512 dup (?)

RMInt13hFunc PROC FAR		;Must immediately follow buffer -- NO PAD.
	int	13h
	retf
RMInt13hFunc ENDP
endif


ifndef	UPGRADE
;****************************************************************************
;
;	Proc	:	PrintMsgAndReboot	
;
;	Description:
;		Prints out each string in the 2D buffer ExitMsg. Then waits
;	for a keyboard input and then reboots.
;
;****************************************************************************
PrintMsgAndReboot	proc	near

	mov	dx, offset ExitMsg
	mov	ax, cs
	mov	ds, ax


PEMGetNext:
	mov	si, dx
	cmp	byte ptr [si], 0
	je  	PEMdone
	mov	ah, 09h
	int	21h
	add	dx, 80
	jmp	PEMGetNext

PEMdone:
	mov	ah, 07h		; wait for keyboard input
	int	21h

	;
	; On PS/2 machines just doing a reset here brings up some 
	; mouse errors when the machine reboots. So we'll try and reset
	; the pointing device before we proceed with the reboot.
	;
	mov	cx, 5			; let's do it a max of 5 times
PEMresetmouse:
	mov	ax, 0C201h
	int	15h
	jnc	PEMcont			; mouse successfully reset
	dec	cx
	jcxz	PEMcont		
	cmp	ah, 04h			; Q: was the error a resend
	je	PEMresetmouse		; Y: try again

PEMcont:

	;
	; BUGBUG: This code is taken from reboot.asm in ..\lib\bios. 
	; Why can't we set up DS here instead of setting it up in 
	; 2 different places below. Is this because DS can be destroyed
	; by the int 21 ax=3515h or the int 15h ax=4f53h? DS should not
	; be destroyed by these calls in any case.
	;
	mov	AX,3515h
	int	21h			; Get int 15h vector in ES:BX
	mov	AX,ES			; AX == Segment
	or	AX,BX			; Is this a NULL ptr
	jz	PEMWarmBoot		; If zero we can't do an int 15h

	mov	ax, seg WarmBootFlag
	mov	ds, ax
	assume	DS:ROM_DATA

	mov	KB_FLAG,ALT_SHIFT OR CTL_SHIFT
	mov	AX,(KB_INTERCEPT SHL 8) OR DEL_KEY
	int	15h			; Put Ctrl/Alt/Del into key buffer

PEMWarmBoot:

	cli
	cld

	mov	ax, seg WarmBootFlag
	mov	ds, ax
	assume	DS:ROM_DATA
	mov	WarmBootFlag, WARM_BOOT_CODE
	jmp	PowerOnReset
		; Jump to the processor power-on address FFFF:0000h
     
PrintMsgAndReboot	endp
endif

;****************************************************************************
;
;   ---- EXEC RESIZE FENCE ----
;
;   ALL CODE PAST HERE IS TOAST!
;
;****************************************************************************

resize:


;****************************************************************************
;
;   Copy program name to szProgName.
;
;   Entry: ds:dx -> program name to copy.
;
;   Exit:  ds:dx -> szCopyProgName
;
;****************************************************************************

CopyProgName PROC NEAR

    ;
    ; How long is the file name?
    ;
    or      dx, dx
    jz      nofile

    mov     ax, ds
    mov     es, ax
    mov     di, dx			;es:di -> file name
    mov     cx, 0FFFFh                  ;cx must be <> 0 for REP
    xor     ax, ax
    repnz   scasb
    not     cx				;Length in cx, including null.

    mov     si, dx			;ds:si -> file name
    mov     ax, cs
    mov     es, ax
    mov     di, codeOFFSET szCopyProgName    ;es:di -> szProgName
    push    es
    push    di
    rep     movsb                       ;mov string at ds:si to es:di

    pop     dx
    pop     ds				;ds:dx -> szProgName
nofile:
    ret

CopyProgName ENDP



;****************************************************************************
;
;   Copy CMD line to szCopyCmdLine.
;
;   es:di = pointer to cmd line to copy.
;
;****************************************************************************

CopyCmd PROC NEAR USES DS

    ;
    ; How long is the command line?
    ;
    or      di, di
    jz      nocmd
    push    di
    mov     cx, 0FFFFh                  ;cx must be <> 0 for REP
    xor     ax, ax
    repnz   scasb
    not     cx
    dec     cx                          ;Length in cx

    ;
    ; copy command line to out PSP
    ; form the length prefixed command line that DOS wants
    ;
    pop     si

    mov     ax, es
    mov     ds, ax                      ;ds:si == command line
    mov     ax, cs
    mov     es, ax
    mov     di, codeOFFSET szCopyCmdLine ;es:di == szCopyCmdLine
    mov     ax, cx
    stosb                               ;Length byte           => es:di
    rep     movsb                       ;.. followed by string => es:di
    mov     ax, 0DH                     ;.. followed by a \n   => es:di
    stosb
nocmd:
    ret

CopyCmd ENDP


;****************************************************************************
;
; void Init(void);
;
; Sets up an execblock structure in preparation for a Dos Exec Int 21h / 4bh.
;
; Passes current environment.
;
; Entry: es:di --> command line
;
; Exit:  es:bx --> execblock structure
;
;****************************************************************************

Init PROC NEAR

    mov     cs:loadparams.lpCmdLine.sel, es     ; store command line
    mov     cs:loadparams.lpCmdLine.off, di


KeepEnv:
    mov     ax, cs:MyPSP
    mov     es, ax
    mov     ax, es:[002Ch]

GotEnv:
    mov     cs:loadparams.segEnv, ax            ;loadparms.segEnv = ENV;
    mov     ax, cs
    mov     cs:loadparams.lpFCB1.off, 5ch       ;loadparms.lpFCB1 = parent's fcb0
    mov     cs:loadparams.lpFCB1.sel, ax
    mov     cs:loadparams.lpFCB2.off, 6ch       ;loadparms.lpFCB2 = parent's fcb1
    mov     cs:loadparams.lpFCB2.sel, ax

    mov     es, ax
    mov     bx, codeOFFSET loadparams           ;es:bx --> param block

    ret

Init ENDP


;****************************************************************************
;
; FreeAll() - free all DOS memory allocated by the current program.
;
;****************************************************************************

FreeMem PROC NEAR

;
;       IMPORTANT NOTE:
;
;       DOS 3.30 and later allow the user to increase the size of the
;       file handle table.  If the file handle count > 20, then a far
;       segment is allocated to store the table.  This segment must be
;       freed up before the child program is exec-ed.  This code relies
;       on the fact that DOS will free up that far segment if the handle
;       count is set back to 20.  If DOS ever changes, this code will fail.
;
        mov     ax, word ptr [_osmajor]
        xchg    ah, al          ; AH = _osmajor, AL = _osminor
        cmp     ax, (3 shl 8) + 30
        jb      pre_DOS330      ; _osmajor:_osminor < 3.30?

        mov     bx, 20          ; IF >= DOS 3.30 THEN
        mov     ah, 67h         ; Set Handle Count on principle
        int     21h             ; set number of handles to default value

pre_DOS330:
        mov     bx, _psp
        mov     es, bx
        mov     dx, es:[002Ch]  ; get the environment segment
        mov     cx, 50h

;       WARNING - any errors past this point - must go to execpanic
;       now free all blocks of memory belonging to this process
;       except the PSP and new environment block

;       cx = Paranoia count.
;       bx = PSP
;       dx = environment segment

freemore:

;        WriteAux 'We're in the freemore loop now.'

        dec     cx
        jcxz    free_done       ; If paranoia count goes to zero panic !!
        push    bx              ; save PSP
        mov     ah, 52h         ; magic DOS call
        int     21h
        mov     ax, es:[bx-2]   ; ax = first arena segment!!!
        pop     bx              ; restore PSP

;       ax = current segment to check

findused:

;        WriteAux 'We're in the findused loop.'

        mov     es, ax
        inc     ax
        cmp     es:[sig], 'M'   ; Is this really an arena header ?
        jne     free_done       ; If not, lets get out !!
        cmp     ax, bx          ; is it PSP?
        je      atend           ;   yes - skip
        cmp     ax, dx          ; is it environment?
        je      atend           ;   yes - skip

        cmp     es:[own], bx    ; do we own it?
        jne     atend           ;   no -skip

        mov     es, ax          ; es = must be one past arena header
        mov     ah, 49h         ; free up the segment
        int     21h
        jmp     freemore        ; and start over - even if error

atend:
        add     ax, es:[asiz]   ; add in segment size

        jnc     @f
        jmp     freemore        ;   error - changed arena - retry

@@:
        cmp     es:[sig], 'Z'   ; last segment?
        jne     findused        ;   no - check next segment

free_done:
	ret

FreeMem ENDP


_TEXT ENDS

END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\common\index.c ===
/***************************************************************************/
/*										*/
/*	INDEX.C									*/
/*										*/
/*		Copyright (c) 1991 - Microsoft Corp.				*/
/*		All rights reserved.						*/
/*		Microsoft Confidential						*/
/*										*/
/* Program to read a message file and create a header file with the offsets	*/
/* to each entry in the file.							*/
/*										*/
/* EXAMPLE:									*/
/* INDEX  infile_name.ext  outfile_name.ext					*/
/*										*/
/* Change log:									*/
/*										*/
/*	Date	  Who	#		Description				*/
/* 	--------  ---  ----	---------------------------------------------	*/
/*	10/26/92  JDH  B001	Now defaults to create large model message.asm	*/
/*				Switch added for Small model /S 		*/
/* ie.	index  message.inc  message.h  /S					*/
/********************************************************************************/

#include    <stdio.h>
#include    <string.h>
#include    <malloc.h>

#define		EOL		0

/***************************************************************************/
int main( int argc, char *argv[] );
int ProcessMessage( char *Buffer );
/***************************************************************************/


/***************************************************************************/
/* Reads a help file and creates a header file with the offsets to each		*/
/* entry in the file as a #define value. The help file must have the			*/
/* following layout.																			*/
/*																									*/
/*   .LABEL_TEXT                                                           */
/*   Body of the text up to 25 lines                                       */
/*   .LABEL2_TEXT                                                          */
/*   Body of the text up to 25 lines                                       */
/*   ......                                                                */
/*   .END                                                                  */
/*																									*/
/* The resulting file which is created has this format, where xxxx is a    */
/* long numeric value.                                                     */
/*                                                                         */
/*	#define	LABEL_TEXT		xxxx															*/
/*	#define	LABEL_LINES		xxxx															*/
/*	#define	LABEL2_TEXT		xxxx															*/
/*	#define	LABEL2_LINES	xxxx															*/
/*	#define  ......_TEXT		xxxx															*/
/* #define	......_LINES	xxxx															*/
/*																									*/
/* A second file is created which contains the text from the message file  */
/* in a form which is assemble-able with the Microsoft MASM 5.1.				*/
/*																									*/
/* Blank lines and line which start with a simicolon are ignored and only	*/
/* the text within quote is used. Quotes are not allowed within the text	*/
/* at this time.																				*/
/*																									*/
/*																									*/
/* EXAMPLE TEXT FILE:																		*/
/*																									*/
/*																									*/
/* ; =============================================================			*/
/*	; =============================================================			*/
/*	; All of these lines are the same length to give a better					*/
/*	; appearance on the screen																*/
/*	;																								*/
/*																									*/
/*	.REMINDER_TEXT																				*/
/*																									*/
/*	"<ENTER>    = Continue the installation"											*/
/*	"<ENTER>    = Accept entry and continue"											*/
/*	"<ESC>      = Return to previous screen"											*/
/*	"<ESC>      = Exit installation program"											*/
/*	"<CTRL>+<C> = Exit installation program"											*/
/*																									*/
/*	.END_TEXT																					*/
/*																									*/
/***************************************************************************/

int main( int argc, char *argv[] )
{
   FILE		*sFile, *hFile, *aFile;		/* Source and header files */
	char		*szBuffer, *szPtr;				/* Work szBuffer and pointer */
	char		*szLastDef;						/* The last define string */
	unsigned Offset = 0;	/* Current offset */
	int		iNumBytes, iNumLines;
	int		Status = 0;
        char            MemModel[3];


   if ( argc < 3 )
      Status = 8;
   else if ( (sFile = fopen( argv[1], "rb" )) == NULL )
      Status = 1;
   else if ( (hFile = fopen( argv[2], "wb" )) == NULL )
      Status = 2;
	else if ( (aFile = fopen( "MESSAGE.ASM", "wb" )) == NULL )
		Status = 3;
   else if ( (szBuffer = malloc( 200 )) == NULL )
      Status = 4;
	else if ( (szLastDef = malloc( 200 )) == NULL )
		Status = 4;
   else
   {
                fprintf( aFile, "DOSSEG\r\n"  );
		if ( argc = 4 ) 			   /* Added check for small model b001 */
                   strcpy( MemModel, argv[3] );
		if (!strcmpi( MemModel, "/S" )) 	   /* if /S switch then */
		{
		   fprintf( aFile, ".MODEL\tSMALL,C\r\n"  );
		   fprintf( aFile, "\r\n\r\n.DATA\r\n\r\n" );
                }
		else					   /* else default LARGE model used */
                {
		   fprintf( aFile, ".MODEL\tLARGE,C\r\n"  );
		   fprintf( aFile, "\r\n\r\n.FARDATA\r\n\r\n" );
                }
		fprintf( aFile, "\tPUBLIC chMessage\r\n" );
		fprintf( aFile, "chMessage\tLABEL BYTE\r\n\r\n" );

		fprintf( hFile, "void\tGetMessage( char **Ptr, unsigned Offset_u );\r\n" );
		fprintf( hFile, "void\tGetMessStr( char *szBuf, unsigned Offset_u, int StrNum );\r\n\r\n" );

		while( !feof( sFile) && Status == 0 )
		{
			while( !feof( sFile) && Status == 0 )
   	   {
				if( *szBuffer == '.' )
				{
											/* Convert newline to EOL */
					*(strchr( szBuffer, '\r')) = '\0';
					strcpy( szLastDef, szBuffer + 1 );	/* Save definition */
					if (fprintf( hFile, "#define\t\t%-25s %#4.4x\r\n",
									 szLastDef, Offset ) == 0 )
						Status = 4;
					break;
				}
				else if ( fgets( szBuffer, 132, sFile ) != szBuffer )
					Status = 4;
			}
			if ( Status == 0 )
			{
				fgets( szBuffer, 132, sFile );
				iNumLines = 0;
			}
			while ( !feof( sFile) && *szBuffer != '.' && Status == 0 )
			{
				if ( (iNumBytes = ProcessMessage( szBuffer )) >= 0 )
				{
					iNumBytes++;
					iNumLines++;
					if ( iNumBytes > 1 )
						szPtr = "db\t\"%s\",0\r\n";
					else
						szPtr = "db\t0\r\n";

					if ( fprintf( aFile, szPtr, szBuffer ) == 0 )
						Status = 4;
					else
						Offset += iNumBytes;
				}
				if ( iNumBytes == -2 )
					Status = -2;
				else
					fgets( szBuffer, 132, sFile ) != szBuffer;
			}
			if ( Status == 0 )
			{ 
				Offset++;
				fprintf( aFile, "db\t-1\r\n" );
				strcpy( strchr( szLastDef, EOL ) - 4, "LINES" );
				fprintf( hFile, "#define\t\t%-25s %#4.4x\r\n", szLastDef,
							++iNumLines );		/* Add 1 line for NULL */
			}
		}
	}
	if ( Status == 0 )
		fprintf( aFile, "\r\nEND\r\n" );

	fcloseall();
	if ( Status != 0 )
		printf( "\nError status = %d\n", Status );
	return( Status );
}


int ProcessMessage( char *szBuffer )
{
	int	iCount;
	char	*pszPtr;

	pszPtr = szBuffer;
	while ( *pszPtr != '\"' && *pszPtr != EOL && *pszPtr != ';' )
		pszPtr++;
	
	if ( *pszPtr == '\"' )
	{
		pszPtr++;
		for( iCount = 0;
			  *pszPtr != '\"';
			  iCount++, szBuffer++, pszPtr++ )
		{
			*szBuffer = *pszPtr;
			if ( *pszPtr == EOL )
			{
				iCount = -2 ;		/* Missing end quote */
				break;
			}
		}
		*szBuffer = EOL;
	}
	else
		iCount = -1;				/* Ingore this line */

	return( iCount );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\common\memory.c ===
/***************************************************************************/
/*																									*/
/*	MEMORY.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* The following code will do error checking for malloc() calls #ifndef		*/
/*	MEM_BUG																						*/
/***************************************************************************/

#include		<stdio.h>
#include		<stdlib.h>
#include    <malloc.h>
#include		<dos.h>
#include 	<string.h>

#include		<alias.h>
#include		<message.h>
#include		<window.h>

/************************************************************************/

void  InitializeMemory( void );
unsigned GetCallerAddr( void );

/* #define		MEM_BUG	1 */

/************************************************************************/

#ifndef		MEM_BUG

/************************************************************************/
/* Used in place of the malloc() functions so the caller will not have	*/
/* to do error checking on the return value. It is assumed that the		*/
/* program cannot continue if the requested memory cannot be allocated 	*/
/* so this function will do the honors of calling the FatalError() 		*/
/* function to display the error window and do the necessary cleanup.	*/
/* If you want to do the error handling yourself don't use this			*/
/* and call malloc directly.															*/
/*																								*/
/* void *GetMemory( unsigned int Bytes )											*/
/* 																							*/
/* ARGUMENTS:	unsigned	- Number of bytes of memory to allocate.			*/
/* RETURNS:		char *	- Returns a pointer to the requested block of	*/
/*								  memory. NOTE: This function will not return	*/
/*								  if the requested block of memory is not 		*/
/*								  available, instead it will abort the program	*/
/*								  with a FatalError() call.							*/
/*																								*/
/************************************************************************/

void *GetMemory( unsigned int Bytes )
{
	void		*Memory;
	
	if ( (Memory = malloc( Bytes )) == NULL )
		FatalError( FATAL_MEMORY_ERROR );
	return( Memory );
}


#else

/************************************************************************/
/* All of the rest of the code in this module is only here for				*/
/* memory allocation problem. To turn the code on define MEM_BUG.			*/
/* These functions are replaced by macros or very simple functions		*/
/* when debugging is turned off so that there is no size of speed 		*/
/* restrictions imposed by these functions.										*/
/************************************************************************/

#include		<bios_io.h>

struct mems
{
   unsigned int   Size;
   void           *Ptr;
};

/***************************************************************************/
static struct mems   *Buffer = NULL;

/***************************************************************************/
/* Returns a pointer to a block of memory the size of the argument Byte.   */
/* if there is insuffient memory available to fill the request a fatal     */
/* error is initiated and the program is aborted. A control structure is   */
/* set up for each block of memory that is allocated. See the structure    */
/* definition "mems" for details of the control structure.                 */
/*                                                                         */
/* Bytes - the size of the request memory block in bytes                   */
/* RETURNS: pointer to a block of memory the requested size                */
/***************************************************************************/

void *GetMemory( unsigned int Bytes )
{
	struct _heapinfo  hinfo;
	int					hstat;
	register			i;									/* Loop counter					*/
	struct mems		*BufPtr;							/* Ptr to allocation struct	*/
	void				*Addr;							/* Ptr to allocated block		*/
	static char		*ErrorMess[] = {
												"Out of pointer space",
											 	"Aborting with Fatal Error"
											};

   if ( Buffer == NULL )
      InitializeMemory(); /* Initializes on the first call to this function */


	if ( _heapchk() != _HEAPOK ) 
      FatalError( FATAL_MEMORY_ERROR );

	hinfo._pentry = NULL;

	while( (hstat = _heapwalk( &hinfo)) == _HEAPOK )
		;
	if ( hstat != _HEAPEMPTY && hstat != _HEAPEND )
		FatalError( FATAL_MEMORY_ERROR );

   if ( ( Addr = malloc( Bytes )) == NULL )  /* Get memory from DOS */
      FatalError( FATAL_MEMORY_ERROR );

      /* Scan the control structure buffer for the first unused entry   */
      /* and fill in it's contents with the size of this block which    */
      /* the malloc() function has stored as a preceeding word to the   */
      /* start of the allocated memory area                             */

   BufPtr = Buffer;									/* Point to start of buf	*/
   for ( i = 0; i < 1000; i++, BufPtr++ )
   {
      if ( BufPtr->Ptr == NULL )					/* Is this an empty entry?	*/
      { 													/* Then use it					*/
         BufPtr->Ptr = Addr;
         BufPtr->Size = *( (unsigned *)(Addr) - 1 );
         break;
      }
   }

      /* If i >= 1000 there were no free pointers so abort program */
      /* This should never happen, if it does increase the buffer size */

   if ( i >= 1000 )
      FatalError( FATAL_MEMORY_ERROR );
   else
      return( Addr );      /* Return pointer to allocated memory block */
}   

/***************************************************************************/
/* Frees a block of memory allocated with GetMemory(). The argument is     */
/* is used to scan the control buffer and if a match is found the size of  */
/* the block is compared with the word which precedes the allocated block. */
/* If these match the block is valid and will be freed. If the block has   */
/* been corrupted a fatal error will be initiated and the program will     */
/* be aborted.                                                             */
/*                                                                         */
/* Addr - address of memory block being deallocated                        */
/***************************************************************************/

void  FreeMemory( void *Addr )
{
	struct _heapinfo  hinfo;
	int					hstat;
	register				i;									/* Loop counter		*/
	register				Status = OK;					/* Return status		*/
   struct mems			*BufPtr;							/* Allocation struct	*/
	static char			*apszError[] = { "Size of block is corrupt",
							  						  "Aborting with Fatal Error" };

	if ( _heapchk() != _HEAPOK ) 
      FatalError( FATAL_MEMORY_ERROR );

	hinfo._pentry = NULL;
	while( (hstat = _heapwalk( &hinfo)) == _HEAPOK )
		;

	if ( hstat != _HEAPEMPTY && hstat != _HEAPEND )
		FatalError( FATAL_MEMORY_ERROR );

      /* Scan the memory control buffer for a matching address and then */
      /* compare the size word to check for a corrupt block             */
   BufPtr = Buffer;
   for ( i = 0; i < 1000; i++, BufPtr++ )
   {
      if ( BufPtr->Ptr == Addr )
      {
         if ( BufPtr->Size != *( (unsigned *)(Addr) - 1) )
         {
            Status = -1;         /* Corrupted memory block so signal error */
            break; 
         }
         else
         {     /* Valid block so release it and clear it's control struct */
            BufPtr->Ptr = NULL;
            BufPtr->Size = 0;

            free( Addr );
            break;
         }
      }
   }
   if ( i >= 1000 || Status != 0 )
      FatalError( FATAL_MEMORY_ERROR );

	if ( _heapchk() != _HEAPOK ) 
      FatalError( FATAL_MEMORY_ERROR );
}

/***************************************************************************/
/* Scans the memory control buffer and returns the number of blocks        */
/* allocated. Call this function at the end of a program to be sure all    */
/* functions are releasing their memory blocks.                            */
/*                                                                         */
/* RETURNS: number of allocated memory blocks                              */
/***************************************************************************/

int   NumberAllocated( void )
{
	register			i;									/* Loop counter					*/
	register			count;							/* Number of items allocated	*/
	struct mems		*BufPtr;

   for ( i = 0, BufPtr = Buffer, count = 0; i < 1000; i++, BufPtr++ )
      if ( BufPtr->Ptr != NULL )
         count++;

   return( count );

}

/***************************************************************************/
/* Returns the maximum memory block size still available. Use this         */
/* before calling GetMemory() if the size of the memory block is not       */
/* critical and then call GetMemory() with the value returned. This will   */
/* guarantee that a fatal memory error won't happen.                       */
/***************************************************************************/

unsigned GetMemoryMax( void )
{
   return( (unsigned)(_memmax()) );
}

void ProgramAbort( void );

/***************************************************************************/
/* Initializes the array of memory control structures.                     */
/***************************************************************************/

void  InitializeMemory( void )
{
   register			i;							/* Loop index								*/
   struct mems    *BufPtr;					/* Ptr to allocated memory buf		*/

         /* Allocate memory for the buffer */
   if ( ( Buffer = malloc( 1000 * sizeof(struct mems) ) ) == NULL )
	{
      VideoPuts( "\nINSUFFIENT MEMORY TO RUN PROGRAM" );
		ProgramAbort();
	}

   else
   {     /* Initialize the array of memory control structures */
      BufPtr = Buffer;
      for ( i = 0; i < 1000; i++, BufPtr++ )
      {
         BufPtr->Size = 0;
         BufPtr->Ptr = NULL;
      }                        
   }
}

#endif

/************************************************************************/
/* End of module.																			*/
/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\common\dublbuf.asm ===
;****************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1991
;
;   Title:     dsufastd.asm - Detection code entry point for WDCtrl drive
;                              validation
;
;   Version:   1.00
;
;   Date:      05-FEB-1991
;
;   Author:    MC
;
;----------------------------------------------------------------------------
;
;   Change log:
;
;      DATE     REV             DESCRIPTION
;   ----------- --- ---------------------------------------------------------
;   05-FEB-1991 MC  Initial coding.
;   19-MAR-1991 DD  Changed OkForFastDisk() to GetHardDiskType().
;
;----------------------------------------------------------------------------
;
;   This module contains the source code for the GetHardDiskType() call.
;   GetHardDiskType() is designed to be called from a C module.  It returns
;   an integer representing the system's hard disk flavors.
;
;   This module calls wdrminit.asm, which includes wddetect.inc, which is
;   written and maintained by RalphL.  In fact, RalphL is the only one who
;   can touch the code in wddetect.inc.  Do not attempt to fix anything in
;   wddetect.inc unless you are RalphL!
;
;****************************************************************************

RF_Drive_80h_Ours	EQU	00000001b
RF_Drive_81h_Ours	EQU	00000010b

EXTRN WDCtrl_Real_Mode_Init:NEAR

PUBLIC _IsSafeDiskNeeded

;----------------------------------------------------------------------------

.MODEL LARGE

;------------------------------------------------------------------------------

DGROUP GROUP _DATA

FASTDISK SEGMENT WORD PUBLIC 'CODE'

	 ASSUME CS:FASTDISK
	 ASSUME DS:FASTDISK
	 ASSUME ES:FASTDISK
	 ASSUME SS:FASTDISK

;*****************************************************************************
;
;   INT FAR GetHardDiskType(void);
;
;   ENTRY: None.
;
;   EXIT:  int - Hard disk type, as enumerated in hw_asm_c.inc.
;
;*****************************************************************************

_IsSafeDiskNeeded  PROC

         push  bp
         push  ds
         push  bx
         push  si
         push  di

         ; Set up for WDCtrl_Real_Mode_Init() call.
         mov   ax, cs
         mov   ds, ax
         mov   es, ax

         call  WDCtrl_Real_Mode_Init

         ;
         ; The possible return values from WDCtrl_Real_Mode_Init() in DX are
         ; 0, 1, and 3.
         ;
         ; 0       ==> not ok to install FastDisk
         ; 1, 2, 3 ==> ok to install FastDisk
         ;

         ; Set up TRUE return value (i.e. Not fast disk compatible so
         ; need Double Buffer switch )
         mov   ax, 1

         ; Check WDCtrl_Real_Mode_Init() return value.
         cmp   dx, 0
         je    Ok_Exit

         ; If we get to here it is OK to install FastDisk

         xor   cx, cx

         test  dx, RF_Drive_80h_Ours
         jz    TestOtherBit
         inc   cx

TestOtherBit:
         test  dx, RF_Drive_81h_Ours
         jz    DetermineNumInt13Drives
         inc   cx

DetermineNumInt13Drives:

         push  cx
         mov   ah, 8
         mov   dl, 80h
         int   13h                  ; DL = # of int13 drives.
         pop   cx
         cmp   cl, dl
         ;
         ; Set up TRUE return value (i.e. Not fast disk compatible so
         ; need Double Buffer switch )
         ;
         mov   ax, 1
         jb    Ok_Exit              ; Need Double buffer switch on SD4.
         xor   ax, ax               ; Don't need Double Buffer.

Ok_Exit:
         pop   di
         pop   si
         pop   bx
         pop   ds
         pop   bp
         ret

_IsSafeDiskNeeded  ENDP

FASTDISK ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\common\select.c ===
/***************************************************************************/
/*                                                                      	*/
/* SELECT.C																						*/
/*                                                                      	*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                      	*/
/* DOS 4.01 retail upgrade highlighted data selection functions         	*/
/*                                                                      	*/
/* Created 890305 - johnhe                                              	*/
/***************************************************************************/

#include		<stdio.h>
#include		<malloc.h>

#include		<alias.h>
#include		<bios_io.h>
#include		<window.h>
#include		<strlib.h>


extern int	GetChar				( void );
extern int  GetCharExtension	( void );


extern  int PromptSelect(char * *szStrings,char * *szOpts);
extern  int GetSelection(char * *apszList,struct InputDef *NewDef);
static  void DisplayList(void );
static  void HiLite(int Current,int fOn);

int gDisplaySelectionList = TRUE;

/*************************************************************************/

static struct InputDef	*Def;
static char					**apszText;

/*************************************************************************/

/*
struct InputDef
{
	unsigned char		Top;
	unsigned char		Bottom;
	unsigned	char		Left;
	unsigned	char		Right;
	unsigned	char		Len;
	unsigned char		First;
	unsigned char		Total;
	unsigned	char		Current;
};
*/

/***************************************************************************/
/* Allows the user to select an option from a menu by using the scroll		*/
/* bar. Blank entries can be included in the menu in which case the menu	*/
/* bar will skip over the blank selection. The menu is also scrollable so	*/
/* that the total number of options don't have to fit in a fixed size		*/
/* menu.																							*/
/*                                                                         */
/*	int GetSelection( char **apszList, struct InputDef *NewDef  )				*/
/*																									*/
/*	ARGUMENTS:	apszList	- Ptr to array of strings to display in the menu	*/
/*					NewDef	- A menu definition structure which defines the		*/
/*								  size and position of the menu and the currently	*/
/*								  highlighted option.										*/
/* RETURNS: 	int	- selected option number, PREVIOUS or ABORT				*/
/*                                                                         */
/***************************************************************************/

int GetSelection( char **apszList, struct InputDef *NewDef  )
{
	#define			NO_SELECTION	-100		/* Arbitrary non-ascii char value*/
	int				PrevHiLite;					/* Last option highlighted			*/
	int				Input;						/* Value from the keyboard			*/
	int				UserSelection;				/* Menu option selected				*/


	Def = NewDef;									/* Set global values so all funcs*/
	apszText = apszList;							/* in this module can access them*/

	if (gDisplaySelectionList)
		DisplayList();								/* Display the menu					*/

   VideoCursOff();
	PrevHiLite = Def->Current;					/* Don't have a previous HiLite	*/
	HiLite( Def->Current, ON );			/* HiLite the current option		*/

					/* Keep looping until user presses the <RETURN> key to make	*/
					/* a selection or <ESC> to abort the selection.					*/

	UserSelection = NO_SELECTION;
   do
   {
		if ( PrevHiLite != Def->Current )
		{														/* HiLite proper selection */
			HiLite( PrevHiLite, OFF );
			HiLite( Def->Current, ON );
			PrevHiLite = Def->Current;
		}

      switch( Input = GetChar() )						/* Get input from user	*/
		{

			case	ESC:											/* <ESC> key pressed		*/
				UserSelection = PREVIOUS;
				break;

			case CR:												/* <RETURN> key pressed	*/
				UserSelection = Def->Current;
				break;

      	case '\0':											/* Was an extended char	*/
				Input = GetCharExtension();

				if ( Input == UP && Def->Current > 0)
				{								  					/* Move up an option		*/
					do
						Def->Current--;
					while( Def->Current > 0 &&
							apszList[ Def->Current ][0] == 0 );
				}
				else if ( Input == DOWN && Def->Current < (Def->Total - 1) )
				{													/* Move down  an option	*/
					do
						Def->Current++;
					while( Def->Current < (Def->Total - 1) &&
							apszList[ Def->Current ][0] == 0 );
				}
				break;

			default:
				break;

		}
	}
	while( UserSelection == NO_SELECTION );

	return( UserSelection );
}

/***************************************************************************/
/* Displays a menu on the screen as defined in the static global Def.		*/
/***************************************************************************/

static void DisplayList( void )
{
	int		Row;							/* Current screen row	*/
	int		Index;						/* String array index	*/
	int		BoxDif;
	int		EntryDif;
	WINDOW	Box;

	Def->Total = (unsigned char)(GetNumberStrings( apszText ));
	Def->First = Def->Current;
	Def->Len   = Def->Right - Def->Left + 1;
	
						/* Make user list fills the available window */

	BoxDif = Def->Bottom - Def->Top;
	EntryDif = Def->Total - Def->First;

	if ( BoxDif >= EntryDif )
		Def->First -= (unsigned char)(BoxDif - EntryDif + 1);

	if ( Def->First < 0 || Def->First > Def->Total )
		Def->First = 0;

						/* Display the box area */
	Box.Top = Def->Top - 1;
	Box.Bottom = Def->Bottom + 1;
	Box.Left = Def->Left - 1;
	Box.Right = Def->Right + 1;
	Box.Color = Box.BorderColor = GetBoxColor();
	Box.Type = 1;
	Box.IsShadow = 0;

	PutWindow( &Box );

						/* Display all the strings that fit in the box */
	for ( Row = Def->Top, Index = Def->First;
			Row <= Def->Bottom && Index < Def->Total;
			Index++, Row++ )
#ifdef JAPAN	/* if KEISEN */
		VideoPutsRowCol( Row, Def->Left + 2, apszText[ Index ] );
#else
		VideoPutsRowCol( Row, Def->Left + 1, apszText[ Index ] );
#endif
}		

/***************************************************************************/

static void HiLite( int Current, int fOn )

{
	int			Row; 				/* Screen row to HiLite 		*/
	int			Scroll;			/* Shows if screen gets scrolled	*/

	Row = Def->Top + Current - Def->First;
	Scroll = TRUE;					/* Assume we have to scroll		*/

	if ( Row < Def->Top )				/* Check for scroll down	*/
	{
		VideoScrollDn( Def->Top, Def->Left, Def->Bottom, Def->Right, 1,
							GetBoxColor() );
		Row++;
		Def->First--;
	}

	else if ( Row > Def->Bottom )		/* Check for scroll up		*/
	{
		VideoScrollUp( Def->Top, Def->Left, Def->Bottom, Def->Right, 1,
							GetBoxColor() );
		Row--;
		Def->First++;
	}

	else
		Scroll = FALSE;

#ifdef JAPAN	/* if KEISEN */
	if ( Scroll == TRUE )
		VideoPutsRowCol( Row , Def->Left + 2, apszText[ Current ] );

	VideoDupAttr( Row, Def->Left,
					  fOn == ON ? GetBarColor() : GetBoxColor(),
					  Def->Len-1 );
#else
	if ( Scroll == TRUE )
		VideoPutsRowCol( Row , Def->Left + 1, apszText[ Current ] );

	VideoDupAttr( Row, Def->Left,
					  fOn == ON ? GetBarColor() : GetBoxColor(),
					  Def->Len );
#endif
}

/***************************************************************************/
/* Displays a prompt window on the screen which contains text and a			*/
/* selection box with a variable number of options. The selection box is	*/
/* within the prompt window with the prompt window centered vertically and	*/
/* horizonally on the screen.																*/
/*																									*/
/*	int PromptSelect( char *szStrings[], char *szOpts[] )							*/
/*																									*/
/*	ARGUMENTS:	szStrings	- Array of ptrs to prompt strings					*/
/*					szOpts		- Array of ptrs to options for selection box		*/
/*	RETURNS:		int			- User selection based 0 or PREVIOUS is <ESC>	*/
/*																									*/
/***************************************************************************/

int PromptSelect( char *szStrings[], char *szOpts[] )
{
	char							*szText[ 25 ];
	char							*OldScrn;
	static char					*szNull = "";
	int							OptsOffset;
	int							TextOffset;
	int							i;
	int							iSelection;
	int							MaxLength;
	int							iHelpFlags;
	static unsigned long		Cursor;

	struct InputDef			Def;
	static WINDOW				Window;
	WINDOW						Box;

	for ( TextOffset = 0; szStrings[ TextOffset ] != NULL; TextOffset++ )
		szText[ TextOffset ] = szStrings[ TextOffset ];

	szText[ TextOffset++ ] = szNull;
	szText[ TextOffset++ ] = szNull;

	OptsOffset = TextOffset;
	for ( i = 0; szOpts[ i ] != NULL; i++, TextOffset++ )
		szText[ TextOffset ] = szOpts[ i ];

	szText[ TextOffset++ ] = szNull;
	szText[ TextOffset ] = NULL;

	GetWindowInfo( szText, &Window );

	OldScrn = GetMemory( (Window.Bottom - Window.Top + 2 ) *
								(Window.Right - Window.Left + 3) * 2 );

	Def.Top = Window.Top + OptsOffset;
	Def.Bottom = Def.Top + i - 1;

	MaxLength = MaxStrLen( szOpts );
	Def.Left = (UCHAR)(CenterLength( MaxLength ));
	Def.Right = Def.Left + MaxLength + 1;
	Def.Total = 2;
	Def.Current = 0;
	Def.First = 0;
	Def.Len = 0;
	Def.First = 0;

	Box.Top = Def.Top - 1;
	Box.Bottom = Def.Bottom + 1;
	Box.Left = Def.Left - 1;
	Box.Right = Def.Right + 1;
	Box.Color = Box.BorderColor = GetBoxColor();
	Box.Type = 1;
	Box.IsShadow = 0;

	Cursor = SaveCursor();
	VideoCursOff();

	iHelpFlags = GetHelpFlags();				/* Save current help line */
	HelpLine( (unsigned)iHelpFlags | CONT_HLP | ARROW_HLP );

   WindowSave( &Window, OldScrn );
	PromptWindow( szText, NULL, GetPromptColor(), OldScrn );

	PutWindow( &Box );
	iSelection = GetSelection( szOpts, &Def );

   WindowRestore( &Window, OldScrn );

	HelpLine( (unsigned)iHelpFlags );		/* Restore original help line	*/

	RestoreCursor( Cursor );
	FreeMemory( OldScrn );

	return( iSelection );
}





=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\common\fmt_io.c ===
/***************************************************************************/
/*																									*/
/* FMT_IO.C 																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* Backup utility for the MS-DOS 4.0 upgrade. These functions will       	*/
/* backup a specified disk to another specified disk. Then entry point to	*/
/* the utiltity is BackUp(). The file coping is buffered using an area of	*/
/* memory which as allocated previously by a call to InitCpyBuffer().		*/
/* Most functions comminuicate via a group of static global variables to	*/
/* keep the size of code to a mininum. 												*/
/*																									*/
/* The backup format is restorable with most versions of DOS 2.x and above.*/
/* 																								*/
/* Created 07-12-89 johnhe																	*/
/* TABS = 3																						*/
/***************************************************************************/


#include		<stdio.h>
#include		<stdlib.h>
#include		<bios.h>
#include		<dos.h>
#include		<string.h>

#include		<alias.h>

#ifdef	OEM_PROGRAM
	#include		<oem.h>
#else
	#include		<global.h>
#endif

#include		<disk_io.h>
#include		<window.h>
#include		<bios_io.h>
#include 	<data.h>
#include 	<strlib.h>
#include		"message.h" 			/* Must get from current directory */
#include 	<format.h>

/************************************************************************/

							/* Bit flags which are set as each disk is prepped */
static unsigned	DiskFlags = 0;

static char			chDestin;					/* Destination drive letter	*/
                                          /* MUST be capital letter.    */

static char 		*CurrentSource;
static char 		*CurrentDestin;

static unsigned long	StartTime = 0;			/* Time 1st disk was labeled	*/
static unsigned long	LastTime  = 0;			/* Time last disk was labeled	*/

int					iDskFmtType =  0;			/* Default format type			*/
int					DiskNum;						/* User disk number				*/

static struct BPB	Bpb;							/* Bpb from current disk		 */
int					iDrv;							/* Destination physical number */

long                                    MinSize[] = { 0, 350000L, 720000L, 1211000L, 1455000L };

int IsHardDisk(int chDrive);

/***************************************************************************/
/* Check for a distribution disk being inserted and prompts the user for 	*/
/* the disk until the label on the user inserted disk matches the one in	*/
/* the DistDisk[] array element for that disk number.								*/
/*																									*/
/*	void DispInsertDisk( int DiskNum )													*/
/*																									*/
/* ARGUMENTS:	DiskNum	- Distribution disk number									*/
/* RETURNS:		void																			*/
/*																									*/
/* GLOBALS:		vInfo		- Checks vInfo.chSource to find the drive for the	*/
/*								  to look for the disk on.									*/
/*					DistDisk[] - Gets the label to check for from this array of	*/
/*									 of pointers to strings.								*/
/*																									*/
/***************************************************************************/

void DispInsertDisk( int DiskNum )
{
	char			szLabel[15];
	char			*szDisk;
	char			*szPrompt;
	char			*pchBuffer;
	register 	iStatus;
									/* If hard drive don't need to do anything */
	if ( DiskNum == NOT_REMOVEABLE )
		return;

	pchBuffer = GetMemory( SECTOR_SIZE );

	szDisk = GetDistribLabel( DiskNum );
	szPrompt = GetDistribPrompt( DiskNum );
	iStatus = ERROR;

	do
	{
		while( !IsDiskReady( vInfo.chSource - 'A' ) )
			PromptForDisk( szPrompt, vInfo.chSource, OLD_DISK );

		if ( IsFormatted( vInfo.chSource - 'A', &Bpb, pchBuffer ) != FALSE )
			if ( GetDiskLabel( vInfo.chSource-'A', szLabel, &Bpb  ) != (UL)(-1L))
				if ( (iStatus = strcmp( szLabel, szDisk )) == OK )
					iStatus = OK;

		if ( iStatus != OK )
			PromptForDisk( szPrompt, vInfo.chSource, OLD_DISK );
	}
	while ( iStatus != OK );

#ifdef	UPGRADE_PROGRAM
	_dos_dskreset();
#endif
	FreeMemory( pchBuffer );
}

/***************************************************************************/
/* Check for a user's disk being inserted and prompts the user for the		*/
/* disk until the label on the user inserted disk matches the one in the	*/
/* DistDisk[] array element for that disk number.									*/
/*																									*/
/*	void DispInsertUserDisk( int UserDisk, char chDrive )							*/
/*																									*/
/* ARGUMENTS:	UserDisk	- User disk number											*/
/*					chDrive	- Drive letter													*/
/* RETURNS:		void																			*/
/*																									*/
/* GLOBALS:		vInfo		- Checks vInfo.chDestin to find the drive for the	*/
/*								  to look for the disk on.									*/
/*																									*/
/***************************************************************************/

void DispInsertUserDisk( int UserDisk, char chDrive )
{
	register			iStatus;
	char				*szUserLabel;
	char				*szPrompt;
	char				szLabel[15];
	char				*pchBuffer;
	unsigned			BitFlag;

										/* If hard drive don't need to do anything */
	if ( IsHardDisk( chDrive ) )
		return;
#if 0
	if ( chDrive >= (char)(GetNumberOfDrives() + 'A') )
		return;
#endif

	pchBuffer = GetMemory( SECTOR_SIZE + 80 );
	szPrompt = pchBuffer + SECTOR_SIZE;

	szPrompt = GetUserPrompt( UserDisk );
	szUserLabel = GetUserLabel( UserDisk );

	chDestin = chDrive;						/* Set the drive letter */
	DiskNum = UserDisk;
	BitFlag = 1 << UserDisk;				/* Set bit flag */

	do
	{
		if ( (DiskFlags & BitFlag) == 0 )			/* Need to prep this disk	*/
			iStatus = PrepNewDsk( szUserLabel, szPrompt );
		else
		{
			iStatus = REDO_DISK;

			if ( IsDiskReady( chDestin - 'A' ) )
			{
				if ( IsFormatted( chDestin - 'A', &Bpb, pchBuffer ) != FALSE )
				{
					if ( GetDiskLabel( chDestin-'A', szLabel, &Bpb ) != (UL)(-1L))
						if ( strcmp( szLabel, szUserLabel ) == OK )
							iStatus = OK;
				}
			}
			if ( iStatus != OK )
				PromptForDisk( szPrompt, chDrive, OLD_DISK );
		}
	}
	while ( iStatus != OK );

	DiskFlags |= BitFlag;				/* Signal disk has been preped */
	FreeMemory( pchBuffer );
	_dos_dskreset();
}

int IsHardDisk(int chDrive)
{
	return(chDrive >= vInfo.chFirstHd);
}

#ifndef	RECOVERY_PROGRAM

/***************************************************************************/
/* Prepares a diskette as user diskette. First prompts user for a disk		*/
/* and loops until a disk has been inserted. Then checks to see if disk 	*/
/* is formatted and if not formats the disk. If the disk is formatted a		*/
/* check is made to be sure the user hasn't inserted a disk which was 		*/
/* previously used during this backup session. If the disk is useable		*/
/* a call is do to CleanFatDir() which will clear the FAT and root			*/
/* directory to free all of the disk for use. If there are errors the 		*/
/* function will continue to loop until a valid disk is inserted or the		*/
/* user elects to abort the backup.														*/
/*																									*/
/*	int PrepNewDsk( char *szLabel, char *szPrompt )									*/
/*																									*/
/* ARGUMENTS:	szLabel - Ptr to label string for this disk						*/
/*	RETURNS:		int	  - OK is disk is ready to use or ABORT if user elects*/
/*																									*/
/***************************************************************************/

int PrepNewDsk( char *szLabel, char *szPrompt )
{
	char				*pchBuffer;
	register 		iStatus;
	UL					ulTime;

	iDrv = chDestin - 'A';								/* Find bios disk number	*/
	pchBuffer = GetMemory( SECTOR_SIZE );

	do
	{
		iStatus = OK;							/* No errors as of yet				*/

		do											/* Wait until disk is present 	*/
			PromptForDisk( szPrompt, chDestin, NEW_DISK );
		while( !IsDiskReady( iDrv ) );

													/* See if we need to format disk */
		if ( IsFormatted( iDrv, &Bpb, pchBuffer ) == FALSE )
		{
			if ( FormatNewDsk() != OK )
				iStatus = BAD_MEDIA;				/* Can't use this disk */
		}
													/* Make sure not a previous disk */
													/* and then srub the disk			*/

		else if ( (iStatus = IsNewDisk( iDrv )) == OK )
			iStatus = ScrubFatRoot( iDrv, &Bpb );

		if ( iStatus == OK )					/* Disk seems ok so label it	*/
		{
			if ( GetDiskFree( chDestin ) < MinSize[ vInfo.uchFloppyType	] )
				iStatus = NO_SPACE;
			else if ( (ulTime = FloppySetDiskLabel( iDrv, szLabel, &Bpb )) != (UL)(-1L) )
			{
				LastTime = ulTime;
				if ( StartTime == 0L )				/* If this is first disk	*/
					StartTime = ulTime;				/* need to set first time	*/
			}
			else
				iStatus = BAD_MEDIA;				/* Can't use this disk */
		}

		if ( iStatus != OK )
		{
			ProcessDiskError( iStatus );
			iStatus = REDO_DISK;
		}
	}
	while( iStatus == REDO_DISK );

	FreeMemory( pchBuffer );
	return( iStatus );
}

/***************************************************************************/
/* Determines if a disk has already been used during the current backup		*/
/* seqence. Each backup disk has a label and the time and date on the		*/
/* along with the label sequence number to see if the label was created		*/
/* during the current installation process.											*/
/*																									*/
/*	int IsNewDisk( int iDrive )															*/
/*																									*/
/*	ARGUMENTS:	iDrive	- Physical drive number where diskette is located	*/
/*	RETURNS:		int		- OK if disk is not distrution or already used		*/
/*																									*/
/***************************************************************************/

int IsNewDisk( int iDrive )
{
	char				szLabel[15];						/* Disk label string 		*/
	char				*szBadLabel;						/* Ptr to unusable labels	*/
	int				i;										/* Loop counter				*/
	int				iStatus;								/* Return value				*/
	UL 				ulTime;								/* Label creation time		*/


	iStatus = OK;

	if ( (ulTime = GetDiskLabel( iDrive, szLabel, &Bpb )) != 0L &&
		  ulTime != (UL)(-1L) )
	{
				/* First loop thru all distribution labels looking for a match	*/
		for ( i = 0;
				iStatus == OK &&
				(szBadLabel = GetDistribLabel( i )) != NULL;
				i++ )
			if ( strcmp( szLabel, szBadLabel ) == OK	)
				iStatus = DIST_DISK;

				/* Loop thru looking for a label from a disk program created	*/
		for ( i = 0;
				iStatus == OK &&
				(szBadLabel = GetUserLabel( i )) != NULL;
				i++ )
		{
			if ( strcmp( szLabel, szBadLabel ) == OK )
			{
				if ( ulTime >= StartTime && ulTime <= LastTime )
					iStatus = DISK_USED;
			}
		}
	}
	else if ( ulTime == (UL)(-1) )
		iStatus = BAD_MEDIA;

	return( iStatus );
}

/***************************************************************************/
/* Determines if the format type has been set and if not does a call to 	*/
/* the the format layout and then call the FormatFloopy function to do the	*/
/* format.																						*/
/*																									*/
/*	int FormatNewDsk( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/* RETURNS:		int	- OK if disk is formatted successfull else and error	*/
/*							  code from the format function or ABORT if the user	*/
/*							  chooses this at one of the prompts.						*/
/*																									*/
/***************************************************************************/

int FormatNewDsk( void )
{
	int						iStatus;
	int						iDskType;
	int						iDrv;
	extern struct BPB		DskBpb[];

	iDrv = chDestin - 'A';

	if ( iDskFmtType == 0 )
	{
		if ( (iDskType = GetDskFmtType()) == ABORT )
			iStatus = ABORT;
	}
	else
		iDskType = iDskFmtType;

   /***********************************
   *  vInfo.uchFloppyType: 1 ==> 360K
   *                       2 ==> 720K
   *                       3 ==> 1.2M
   *                       4 ==> 1.44M
   ************************************
   *  iDskType:            3 ==> 360K
   *                       4 ==> 720K
   *                       5 ==> 1.2M
   *                       6 ==> 1.44M
   ************************************/
   /* Check format type if we know we are formatting a disk in the drive
   ** from which Setup was run. */
	if ( chDestin == vInfo.chSource && iDskType < vInfo.uchFloppyType + 2 )
		iDskType = vInfo.uchFloppyType + 2;

	if ( iStatus != ABORT )
		if ( (iStatus = FormatFloppy( (UINT)iDrv, iDskType, FmtStat )) == OK )
			memcpy( &Bpb, DskBpb + iDskType, sizeof( struct BPB ) );
	
	return( iStatus );
}


/***************************************************************************/
/*	Determines the type of disk format to use. If there is a choice which	*/
/* can be made as to the type of format we let the user decide and then		*/
/* see if the user wants to always use the format selected.						*/
/*																									*/
/*	int GetDskFmtType( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- Disk format type as defined in FORMAT.H.				*/
/*																									*/
/***************************************************************************/

int GetDskFmtType( void )
{
	char			*pchBuf;							/* Work buff for GetDriveType()	*/
	int			iDrvType;						/* Type of destination drive		*/
	int			iDskIndex;						/* Index to format type arrays	*/
	int			iFmtType;						/* Disk format being returned		*/
	int			iSaveDefault; 					/* Signals make choice static		*/
	static unsigned char	DrvOpts[6][2] = {	{ 3,0 },		/* 360K	*/
														{ 3,5 },		/* 1.2M	*/
														{ 4,0 },		/* 720K	*/
														{ 4,6 } };	/* 1.44M	*/

	pchBuf = GetMemory( 100 );								/* Ioctl work buffer		*/
	iDrvType = GetDriveType( (UCHAR)iDrv, pchBuf );	/* Determine drive type	*/

							/* 360k or 720k drives only allow a single disk type	*/
	if ( iDrvType == 1 || iDrvType == 3 )
		iDskIndex = 0,	iSaveDefault = TRUE;

	else if ( (iDrvType == 2 && vInfo.uchFloppyType == 3) ||
				 vInfo.uchFloppyType > 2 ||
				 (iDrvType == 2 && vInfo.uchFloppyType == 2) )
		iDskIndex = 1,	iSaveDefault = TRUE;

						/* If we got here it means the drive will allow disks		*/
						/* bigger than distribution disk so let user decide		*/
	else
	{
		iDskIndex = PromptForDiskFmt( (UINT)(iDrvType-1) >> 1 );
		iSaveDefault = TRUE;
	}

						/* Convert the disk type into a type used by the format	*/
						/* function.															*/

	iFmtType = DrvOpts[iDrvType-1][iDskIndex];
	if ( iSaveDefault == TRUE )
			iDskFmtType	= iFmtType;				/* Save global default */

	FreeMemory( pchBuf );
	return( iFmtType );
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\common\wfwnet.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\common\newint13.asm ===
;========================================================
COMMENT #

	NEWINT13.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	New interrupt 13h handler and support functions
	which check for DMA boundary errors and if detected
	will break the read into 3 pieces to eliminate
	error.
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

; =======================================================
; DWORD address of original int 13h handler. Initialize
; by InitNew13() and then used by RestoreOld13() to
; to restore the vector before the program exits back
; to DOS.
; =======================================================

	public	OldInt13
OldInt13	dd	(?)

OldAX		dw	 (?)

SplitBuffer	dd	(?)

; =======================================================
; Sets int vector 13h to point to the NewInt13 function
; which does a check for DMA errors and corrects the
; error. Saves the original vector for later restoration.
;
; void InitNew13( char *Buffer );
;
; ARGUMENTS:	Buffer	- Ptr to min 1024 byte buffer
;			  to be used for if a disk read
;			  needs to be split to avoid a
;			  DMA boundary error
; RETURNS:	void
; =======================================================

InitNew13 PROC USES DS ES, Buffer:PTR

	mov	AX,3513h			;  Get int vector 13h
	int	21h
	mov	WORD PTR CS:OldInt13,BX	; Save the offset
	mov	WORD PTR CS:OldInt13[2],ES ; Save the segment

	mov	AX,2513h		; Set vector 13h
	mov	DX,offset NewInt13	; Load new vector offset
	push	CS			; Load new vector segment
	pop	DS
	int	21h			; DOS call

SaveBuffer:
	lds	BX,Buffer;		; DS:BX --> 1024 byte buffer

TestForSegmentBound:

	mov	AX,DS			; Put buffer segment in AX
	shl	AX,1			; Convert segment to 20 bit address
	shl	AX,1 			; while ingoring the high 4 bits
	shl	AX,1
	shl	AX,1

	add	AX,BX			; Add offset to 20 bit address

	add	AX,512			; Add sector size to 20 bit address
	jnc	GotBuffer		; If no carry then no segment overrun
	add	BX,512			; Else move to next segment

GotBuffer:
	mov	WORD PTR CS:SplitBuffer,BX
	mov	WORD PTR CS:SplitBuffer[2],DS

	ret

InitNew13 ENDP

; =======================================================
; Replaces the int 13h vector with the original pointer.
; =======================================================

RestoreOld13 PROC USES DS

	mov	AX,2513h		; Set vector 13h
	mov	DX,WORD PTR CS:OldInt13[2] ; Load old segment
	mov	DS,DX
	mov	DX,WORD PTR CS:OldInt13	; Load old offset
	int	21h
	ret

RestoreOld13 ENDP

; =======================================================
; New int 13h handler which will correct DMA errors if
; they are detected on reads or writes.
; =======================================================
	
	public	NewInt13
NewInt13:

	push	AX			; Save original request

	cmp	DL, FIRST_HARD_DISK	; Only do disk change check
	jae	FakeIntCall		; if drive in AL < 80h


;;	push	DS			; First see if we need to fake
;;	mov	AX,@DATA		; a changeline.
;;	mov	DS,AX
	xor	AX,AX
	cmp	AL,BYTE PTR CS:DiskChange
	mov	BYTE PTR CS:DiskChange,AL
;;	pop	DS

	pop	AX			; Restore AX but keep original
	push	AX

	je	FakeIntCall
	mov	AX,0600h
	stc
	jmp	SHORT TestError

FakeIntCall:
	pushf				; Simulate an int request
	call	DWORD PTR CS:[OldInt13]	; of the old int 13h handler
	jc	TestError		; Error so check for DMA error
	
IntExit:
	pop	CS:OldAX
	retf	02			; Far return and pop flags

TestError:
	cmp	AH,9			; Check for DMA bound error
	je	ServiceError
	stc				; Reset error condition	
	jmp	SHORT IntExit	

ServiceError:
	pop	AX			; Get original function call in AX
	cmp	AL,0			; Make sure of valid number sectors
	je	RestoreError
	cmp	AH,2			; Check was it a read operation
	je	SplitOperation		; If yes try splitting the read
	cmp	AH,3			; Check was it a write operation
	je	SplitOperation		; If yes try splitting the write

RestoreError:
	mov	AX,900h			; Retore original error code
	stc				; Restore the original err condition
	retf	02			; Far return and pop the flags

SplitOperation:
	call	NEAR PTR Int13Error	; Try to avoid the DMA boundary
	retf	02			; Return to caller


; =======================================================
; Breaks a disk read or write into individual sectors
; using another memory location which is not on a DMA
; boundary. Returns BIOS int 13h error code if carry set
; else AX == 0.	Preserves all registers execpt AX
; =======================================================

Int13Error PROC NEAR

	push	BX			; Save registers we need to use
	push	CX
	push	DI
	push	SI
	push	DS
	push	ES

	lds	SI,CS:SplitBuffer	; Put error buffer offset in SI

	cmp	AH,02			; See if this is a read
	jne	IsWrite			; If not read must be a write
IsRead:
	call	ReadSecs		; Call proc to read in the sectors
	jmp	SHORT CleanUp		; Finished

IsWrite:
	call	WriteSecs		; Call proc to write the sectors

CleanUp:
	pop	ES			; Restore all caller's registers
	pop	DS			; excpet AX and flags
	pop	SI
	pop	DI
	pop	CX
	pop	BX
	ret

Int13Error ENDP


; =======================================================
; Uses the BIOS int 13h call to read the number of sectors
; in AL into the buffer in DS:SI and then moves them to
; to the buffer in ES:BX. Reads and moves one sector at
; a time. AX, BX, CX, DX, ES must be setup on on entry
; for a normal BIOS read and DS:SI must point to a 
; buffer at least 512 bytes long which is not on a 
; DMA boundary.
; =======================================================

ReadSecs PROC NEAR

	mov	DI,BX			; ES:DI == start of caller's buffer
	mov	BX,SI			; Point BX to new buffer

ReadLoop:
	push	AX			; Save remaining sectors to do
	mov	AL,1			; Set number of sector to 1

	push	ES			; Save caller's buffer segment
	push	DS 			; Set ES to new buffer
	pop	ES

	pushf				; Simulate and int call
	call	DWORD PTR CS:[OldInt13]	; of the old int 13h handler
	pop	ES			; Retore caller's buffer segment

ErrorTest:
	jnc	CopyFromBuf		; No error so copy sector to user buf
	add	SP,2			; Adjust stack for pushed AX
	stc				; Signal we got an error
	jmp	SHORT ReadReturn	; Finished

CopyFromBuf:
	push	SI			; Save ptr to start of new buffer
	push	CX			; Save next sector number
	mov	CX,(512/2)		; Set count of words in buffer 
	cld				; Set direction to forward
	rep	movsw			; Move 1 sector to new buffer
	pop	CX			; Restore next sector number
	pop	SI			; Restore ptr to start of buffer

	pop	AX			; Restore remaining sectors
	inc	CL			; Increment to next sector
	dec	AL			; One less sector to do
	jnz	ReadLoop		; Loop until AL == 0
	xor	AX,AX			; No error code	also clears carry
	jmp	SHORT ReadReturn	; Finished

ReadReturn:
	ret

ReadSecs ENDP

; =======================================================
; Uses the BIOS int 13h call to write the number of sectors
; in AL	by moving them to a new buffer one sector at a
; time and then writing them one at a time.
; AX, BX, CX, DX, ES must be setup on on entry
; for a normal BIOS read and DS:SI must point to a 
; buffer at least 512 bytes long which is not on a 
; DMA boundary.
; =======================================================

WriteSecs PROC NEAR

	push	ES			; Set DS:SI to caller's buffer
	push	DS			; and ES:DI to new buffer
	pop	ES
	pop	DS
	mov	DI,SI
	mov	SI,BX
	mov	BX,DI			; Point BX to new buffer

WriteLoop:
	push	CX			; Save next sector number

CopyToBuf:
	mov	DI,BX			; Set ptr to new buffer
	mov	CX,(512/2)		; Set count of words in buffer 
	cld				; Set direction to forward
	rep	movsw			; Move 1 sector to new buffer
	pop	CX			; Restore next sector number

WriteTheSector:
	push	AX			; Save remaining sectors to do
	mov	AL,1			; Set number of sector to 1

	pushf				; Simulate and int call
	call	DWORD PTR CS:[OldInt13]	; of the old int 13h handler

ErrorTest:
	jc	WriteError		; Got an error so return

	pop	AX			; Restore remaining sectors
	inc	CL			; Increment to next sector
	dec	AL			; One less sector to do
	jnz	WriteLoop		; Loop until AL == 0
	xor	AX,AX			; No error code	also clears carry
	jmp	SHORT WriteReturn	; Finished

WriteError:
	add	SP,2			; Adjust stack for pushed AX
	stc				; Signal we got an error

WriteReturn:
	ret

WriteSecs ENDP


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\boot.inc ===
db	0EBH,03CH,090H,04DH,053H,044H,04FH,053H
	db	035H,02EH,030H,000H,002H,008H,001H,000H
	db	002H,000H,002H,003H,051H,0F8H,008H,000H
	db	011H,000H,004H,000H,001H,000H,000H,000H
	db	000H,000H,000H,000H,080H,000H,029H,000H
	db	000H,000H,000H,04EH,04FH,020H,04EH,041H
	db	04DH,045H,020H,020H,020H,020H,046H,041H
	db	054H,031H,032H,020H,020H,020H,0FAH,033H
	db	0C0H,08EH,0D0H,0BCH,000H,07CH,016H,007H
	db	0BBH,078H,000H,036H,0C5H,037H,01EH,056H
	db	016H,053H,0BFH,03EH,07CH,0B9H,00BH,000H
	db	0FCH,0F3H,0A4H,006H,01FH,0C6H,045H,0FEH
	db	00FH,08BH,00EH,018H,07CH,088H,04DH,0F9H
	db	089H,047H,002H,0C7H,007H,03EH,07CH,0FBH
	db	0CDH,013H,072H,079H,033H,0C0H,039H,006H
	db	013H,07CH,074H,008H,08BH,00EH,013H,07CH
	db	089H,00EH,020H,07CH,0A0H,010H,07CH,0F7H
	db	026H,016H,07CH,003H,006H,01CH,07CH,013H
	db	016H,01EH,07CH,003H,006H,00EH,07CH,083H
	db	0D2H,000H,0A3H,050H,07CH,089H,016H,052H
	db	07CH,0A3H,049H,07CH,089H,016H,04BH,07CH
	db	0B8H,020H,000H,0F7H,026H,011H,07CH,08BH
	db	01EH,00BH,07CH,003H,0C3H,048H,0F7H,0F3H
	db	001H,006H,049H,07CH,083H,016H,04BH,07CH
	db	000H,0BBH,000H,005H,08BH,016H,052H,07CH
	db	0A1H,050H,07CH,0E8H,092H,000H,072H,01DH
	db	0B0H,001H,0E8H,0ACH,000H,072H,016H,08BH
	db	0FBH,0B9H,00BH,000H,0BEH,0E6H,07DH,0F3H
	db	0A6H,075H,00AH,08DH,07FH,020H,0B9H,00BH
	db	000H,0F3H,0A6H,074H,018H,0BEH,09EH,07DH
	db	0E8H,05FH,000H,033H,0C0H,0CDH,016H,05EH
	db	01FH,08FH,004H,08FH,044H,002H,0CDH,019H
	db	058H,058H,058H,0EBH,0E8H,08BH,047H,01AH
	db	048H,048H,08AH,01EH,00DH,07CH,032H,0FFH
	db	0F7H,0E3H,003H,006H,049H,07CH,013H,016H
	db	04BH,07CH,0BBH,000H,007H,0B9H,003H,000H
	db	050H,052H,051H,0E8H,03AH,000H,072H,0D8H
	db	0B0H,001H,0E8H,054H,000H,059H,05AH,058H
	db	072H,0BBH,005H,001H,000H,083H,0D2H,000H
	db	003H,01EH,00BH,07CH,0E2H,0E2H,08AH,02EH
	db	015H,07CH,08AH,016H,024H,07CH,08BH,01EH
	db	049H,07CH,0A1H,04BH,07CH,0EAH,000H,000H
	db	070H,000H,0ACH,00AH,0C0H,074H,029H,0B4H
	db	00EH,0BBH,007H,000H,0CDH,010H,0EBH,0F2H
	db	03BH,016H,018H,07CH,073H,019H,0F7H,036H
	db	018H,07CH,0FEH,0C2H,088H,016H,04FH,07CH
	db	033H,0D2H,0F7H,036H,01AH,07CH,088H,016H
	db	025H,07CH,0A3H,04DH,07CH,0F8H,0C3H,0F9H
	db	0C3H,0B4H,002H,08BH,016H,04DH,07CH,0B1H
	db	006H,0D2H,0E6H,00AH,036H,04FH,07CH,08BH
	db	0CAH,086H,0E9H,08AH,016H,024H,07CH,08AH
	db	036H,025H,07CH,0CDH,013H,0C3H,00DH,00AH
	db	04EH,06FH,06EH,02DH,053H,079H,073H,074H
	db	065H,06DH,020H,064H,069H,073H,06BH,020H
	db	06FH,072H,020H,064H,069H,073H,06BH,020H
	db	065H,072H,072H,06FH,072H,00DH,00AH,052H
	db	065H,070H,06CH,061H,063H,065H,020H,061H
	db	06EH,064H,020H,070H,072H,065H,073H,073H
	db	020H,061H,06EH,079H,020H,06BH,065H,079H
	db	020H,077H,068H,065H,06EH,020H,072H,065H
	db	061H,064H,079H,00DH,00AH,000H,049H,04FH
	db	020H,020H,020H,020H,020H,020H,053H,059H
	db	053H,04DH,053H,044H,04FH,053H,020H,020H
	db	020H,053H,059H,053H,000H,000H,055H,0AAH
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\boot.asm ===
; ========================================================

COMMENT #

	BOOT.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	;================================================

	File to include partition and master
	boot records.

	;================================================

	johnhe - 02-14-90

END COMMENT #

;========================================================

INCLUDE model.inc

;========================================================

.DATA

	PUBLIC NewBootRec
NewBootRec LABEL BYTE

INCLUDE	BOOT.INC

	PUBLIC	MasterBootRec
MasterBootRec LABEL BYTE
 
INCLUDE	FDBOOT.INC

	PUBLIC	EverexMbr
EverexMbr LABEL BYTE

INCLUDE EVEREX.INC

;========================================================

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\common\switch.c ===
/***************************************************************************/
/*                                                                         */
/* SWITCH.C                                                                */
/*                                                                         */
/*    Copyright (c) 1991 - Microsoft Corp.                                 */
/*    All rights reserved.                                                 */
/*    Microsoft Confidential                                               */
/*                                                                         */
/* Command line switch processing functions for DOS/WINDOWS merge.         */
/*                                                                         */
/***************************************************************************/


#include    <stdio.h>
#include    <stdlib.h>
#include    <dos.h>
#include    <string.h>
#include    <fcntl.h>
#include    <share.h>

#include    <alias.h>
#include    <bios_io.h>
#include    <disk_io.h>
#ifdef UPGRADE_PROGRAM
   #include    <global.h>
#else
   #include    <oem.h>
#endif
#include    <message.h>
#include    <strlib.h>
#include    <window.h>

#include    <install.h>

/************************************************************************/

#define     SWITCH_CHAR    '/'

#if (UPGRADE_PROGRAM != 0) && (UJANUS != 0)
char szNuCmdLine[MAXSTRLEN] = { EOL }; /* Non-Upgrade Setup command-line */
#endif

static void near  InvalidSwitch  ( char *szArgStr );
static void near  CommandHelp    ( void );
static void near  InvalidSwitchFmt( char *szArgStr );
static int  near  ExtractSwitchPath( char *szArg, char *szBuf );


/************************************************************************/
/*                                                                      */
/* void ProcessSwitches( int argc, char **argv )                        */
/*                                                                      */
/* ARGUMENTS:  argc  -  Number of command line switches.                */
/*             argv  -   Array of ptrs to command line switch strings   */
/* RETURNS  :  void                                                     */
/*                                                                      */
/*                                                                      */
/************************************************************************/

void ProcessSwitches( int argc, char **argv )
{
   register    i;
   int         fDosSw;                    /* Dos-only switch */
   int         fWinSw;                    /* Win-only switch */
   char        *szPtr;
   char        *szCmdLine;
   char        *szWinCmdLine;
   char        szTmp[MAXSTRLEN];
#ifdef UPGRADE_PROGRAM
   int         fUpgSw;                    /* Upgrade-only switch */
#endif

   /* Init. Install structure members. */

   Install.Software = SOFTWARE_DEFAULT;
   Install.Method = METHOD_EXPRESS;
   Install.Done.fWinInf = FALSE;
   Install.Done.fNet = FALSE;
   Install.Done.fBackup = FALSE;
   Install.Flags.fAdmin = FALSE;

#ifdef UPGRADE_PROGRAM
   Install.Flags.fUninstall = TRUE;
#else
   Install.Flags.fUninstall = FALSE;
#endif

   szCmdLine = Install.szCmdLine;         /* Original Setup command-line tail */
   szCmdLine[0] = EOL;                    /* Ensure NULL terminated. */
   szWinCmdLine = Install.szWinCmdLine;   /* Win Setup command-line tail */
   szWinCmdLine[0] = EOL;                 /* Ensure NULL terminated. */

   for ( i = 1; i < argc; i++ )
   {
      szPtr = argv[i] + 1;

      if ( strchr( szPtr, SWITCH_CHAR ) || strchr( szPtr, '-' ) )
         InvalidSwitchFmt( argv[i] );

      if ( argv[i][0] != SWITCH_CHAR && argv[i][0] != '-' )
      {
         InvalidSwitch( argv[i] );
      }

      fDosSw = fWinSw = FALSE;         /* Assume neither */

#ifdef UPGRADE_PROGRAM
      fUpgSw = FALSE;                  /* Assume not Upgrade-only switch */
#endif

      switch( toupper( *szPtr ) )
      {
#ifdef JANUS
         case  'A':                    /* Admin. Setup */
            fWinSw = TRUE;             /* Win-only */
            Install.Software = SOFTWARE_WINONLY;
            Install.Flags.fAdmin = TRUE;
            break;
#endif

         case  'B':        				/* Don't use color in displays   */
            fDosSw = fWinSw = TRUE;
            vInfo.Args.fIsMono = TRUE;
#ifdef OEM_PROGRAM
				vInfo.fOemCmdLineOK = TRUE;	/* Don't need to boot setup */
#endif
            break;

#ifdef JANUS
         case  'C':
            fWinSw = TRUE;             /* Win-only */
            break;
#endif

#ifdef BACKUP_SUPPORT
         case  'D':                    /* Set by hdbkup.exe (not used)  */
            fDosSw = TRUE;             /* Dos-only */
            vInfo.Args.fDoneBackup = TRUE;
            break;
#endif

#ifndef OEMBASE
         case  'E':                    /* Extras -- Maintenance mode */
            fDosSw = TRUE;             /* Dos-Only */
            Install.Flags.fMaintenance = TRUE;  /* Turn on Maintenance mode flag */
#ifdef OEM_PROGRAM
				vInfo.fOemCmdLineOK = TRUE;	/* Don't need to boot setup */
#endif
            break;
#endif	/* ifndef OEMBASE */

#ifndef UJANUS
         case  'F':                    /* Create MS-DOS emergency boot floppy */
            fDosSw = TRUE;             /* Dos-Only */
            vInfo.Args.fFloppy = TRUE;
#ifdef OEM_PROGRAM
				vInfo.fOemCmdLineOK = TRUE;	/* Don't need to boot setup */
#endif
            break;
#endif	/* ifndef UJANUS */

#ifdef UPGRADE_PROGRAM
         case  'G':                    /* Skip Uninstall procedure */
            fUpgSw = TRUE;             /* Upgrade-only */
            fDosSw = TRUE;             /* Affects only Dos Setup */
            Install.Flags.fUninstall = FALSE;
            Install.Done.fNet = TRUE;     /* Skip Net Warning screen */
            Install.Done.fBackup = TRUE;  /* Skip Backup procedure */
            break;
#endif

#ifdef UPGRADE_PROGRAM
         case  'H':
            fDosSw = fWinSw = TRUE;

            /* Change to Batch install unless we must do Custom install */
            if ( Install.Method != METHOD_CUSTOM )
            {
               Install.Method = METHOD_BATCH;
               Install.Done.fNet = TRUE;     /* Skip Net Warning screen */
               Install.Done.fBackup = TRUE;  /* Skip Backup procedure */
            }
            break;
#endif

#ifdef UPGRADE_PROGRAM
         case  'I':                    /* Use only basic video check    */
            fWinSw = TRUE;
            Install.Method = METHOD_CUSTOM;  /* Force custom install    */
            fDosSw = TRUE;
            vInfo.Args.fNoVideoChk = TRUE;
            break;
#endif

#ifdef UPGRADE_PROGRAM
         case  'J':                    /* Disable certain features. */
            fUpgSw = TRUE;             /* Upgrade-only */
            fDosSw = TRUE;             /* Affects only Dos Setup */
            Install.Done.fNet = TRUE;     /* Skip Net Warning screen */
            Install.Done.fBackup = TRUE;  /* Skip Backup procedure */
            break;
#endif

#ifdef DEBUG
         case  'L':                    /* DEBUG switch */
            fWinSw = TRUE;             /* Win-only */
            break;
#endif

#ifdef UPGRADE_PROGRAM
         case  'M':                    /* Do minimum MS-DOS install to harddisk */
            fUpgSw = TRUE;             /* Upgrade-only */
            fDosSw = TRUE;             /* Dos-only */
            vInfo.Args.fMininum = TRUE;
            Install.Software = SOFTWARE_DOSONLY;
            break;
#endif

#if 0 /* Cannot do SETUP /N from distribution disks; must do SETUP /A first */
         case  'N':                    /* Net setup */
            fWinSw = TRUE;             /* Win-only */
            Install.Software = SOFTWARE_WINONLY;
            break;
#endif

#ifdef JANUS
         case  'O':
            fWinSw = TRUE;             /* Win-only */
            Install.Done.fWinInf = TRUE;
            break;
#endif

#ifdef UPGRADE_PROGRAM
         case  'Q':                    /* Manual installation */
            vInfo.Args.fManual = TRUE;
            Install.Flags.fUninstall = FALSE;   /* turn off uninstall */
            Install.Software = SOFTWARE_DOSONLY;    /* don't load Win opts. */
            fDosSw = TRUE;             /* DOS only */
            break;
#endif

#ifdef BACKUP_SUPPORT
         case  'R':                    /* Set by hdbkup.exe (not used)  */
            fDosSw = TRUE;             /* Dos-only */
            vInfo.Args.fRootChkDone = TRUE;
            break;
#endif

#ifdef UPGRADE_PROGRAM
         case  'S':                    /* Specifies path to setup files */
            fWinSw = TRUE;
            fDosSw = TRUE;
            Install.Done.fSrcPath = TRUE;
            if ( ExtractSwitchPath( argv[ i ], szTmp ) != OK )
               InvalidSwitchFmt( argv[ i ] );
            strcpy( vInfo.szSource, szTmp );
            vInfo.chSource = vInfo.szSource[ 0 ];
            break;
#endif

#ifdef JANUS
         case  'T':
            fWinSw = TRUE;             /* Win-only */
            break;
#endif

#ifdef UPGRADE_PROGRAM
         case  'U':
            fDosSw = TRUE;             /* Dos-only */
            vInfo.Args.fAllowBadPart = TRUE;
            break;
#endif

#ifdef DEBUG
         case  'V':                    /* DEBUG switch */
            fWinSw = TRUE;             /* Win-only */
            break;
#endif

#ifdef JANUS
         case  'W':                    /* Do Win-Only Setup; don't pass switch */
            fUpgSw = TRUE;             /* Upgrade-only */
            Install.Software = SOFTWARE_WINONLY;
            break;
#endif

#ifdef DEBUG
         case  'X':                    /* DEBUG switch */
            fWinSw = TRUE;
            break;
#endif

#ifdef JANUS
         case  'Y':
            fWinSw = TRUE;             /* Win-only */
            break;
#endif

#ifdef UPGRADE_PROGRAM
         case  'Z':
            fUpgSw = TRUE;             /* Upgrade-only */
            fDosSw = TRUE;             /* Dos-only */
            vInfo.Args.fNoBernoulli = TRUE;
            break;
#endif

         case  '?':
#ifdef OEM_PROGRAM
				vInfo.fOemCmdLineOK = TRUE;	/* Don't need to boot setup */
#endif
            CommandHelp();
            ProgramExit( 0 );
            break;

         default:
            InvalidSwitch( argv[ i ] );
      }

      /* Build copy of original Setup command-line tail. */

      strcat( szCmdLine, " ");               /* Preface with space */
      strcat( szCmdLine, argv[i] );          /* Add switch to cmd-line copy */

      /* Build Win Setup command-line tail. */

      if ( fWinSw )
      {
         strcat( szWinCmdLine, " ");         /* Preface with space */
         strcat( szWinCmdLine, argv[i] );    /* Add switch to cmd-line copy */
      }

#if (UPGRADE_PROGRAM != 0) && (UJANUS != 0)
      /* Build Non-upgrade Setup command-line tail. */

      if ( !fUpgSw )
      {
         strcat( szNuCmdLine, " ");          /* Preface with space */
         strcat( szNuCmdLine, argv[i] );     /* Add switch to cmd-line copy */
      }
#endif
   }

#ifdef UPGRADE_PROGRAM
   /* If floppy-install specified, mask out /M flag */
   if (vInfo.Args.fFloppy)
      vInfo.Args.fMininum = FALSE;
#endif

}

/************************************************************************/
/* Displays an invalid switch message along with command line switch    */
/* that caused the error.                                               */
/*                                                                      */
/* void near InvalidSwitch( char *szArgStr )                            */
/*                                                                      */
/* ARGUMENTS:  szArgStr -  Ptr to the offending command line argument   */
/* RETURNS:    void     -  Exits the program with error level set       */
/*                                                                      */
/************************************************************************/

void near InvalidSwitch( char *szArgStr )
{
   char     *apszText[ SWITCH_ERROR_LINES ];

   GetMessage( apszText, SWITCH_ERROR_TEXT );
   VideoPuts( apszText[0] );
   VideoPuts( szArgStr );
   VideoPutChar( CR );
   VideoPutChar( 0x0a );
   ProgramExit( -1 );
}

/************************************************************************/
/* Displays an invalid switch format message along with command line    */
/* switch that caused the error.                                        */
/*                                                                      */
/* void near InvalidSwitchFmt( char *szArgStr )                         */
/*                                                                      */
/* ARGUMENTS:  szArgStr -  Ptr to the offending command line argument   */
/* RETURNS:    void     -  Exits the program with error level set       */
/*                                                                      */
/************************************************************************/

void near InvalidSwitchFmt( char *szArgStr )
{
   char     *apszText[ SWFMT_ERROR_LINES ];

   GetMessage( apszText, SWFMT_ERROR_TEXT );
   VideoPuts( apszText[0] );
   VideoPuts( szArgStr );
   VideoPutChar( CR );
   VideoPutChar( 0x0a );
   ProgramExit( -1 );
}


/************************************************************************/
/* Function which given a ptr to a command line argument will copy the  */
/* path appended to it and copy it to a caller supplied buffer. If the  */
/* drive letter was not specified the drive the program was executed    */
/* from will be used.                                                   */
/*                                                                      */
/* int near ExtractSwitchPath( char *szArg, char szBuf )                */
/*                                                                      */
/* ARGUMENTS:  szArg -  Ptr to a command line argument in the format    */
/*                      /S:C:\path1\path2\...\pathx                     */
/* RETURNS:    int   -  OK if a valid path is extracted else ERROR      */
/*                                                                      */
/************************************************************************/

int near ExtractSwitchPath( char *szArg, char *szBuf )
{
   char     *szPtr;

   szPtr = szArg + 2;

                                             /* See if path is missing  */
   if ( *(szPtr++) != ':' || *szPtr == EOL )
      return( ERROR );

      /* At this point szPtr will be pointing to start of path string   */
   if ( *(szPtr + 1) != ':' ) /* See if user didn't specified the drive */
   {
      strcpy( szBuf, vInfo.szSource );       /* Use the default drive   */
      if ( *szPtr == '\\' )
         szPtr++;                            /* Skip over path char     */
      strcpy( szBuf + 3, szPtr );
   }
   else
      strcpy( szBuf, szPtr );                /* User specified drive    */

   strupr( szBuf );

   if ( *(szBuf + 2) != '\\' )         /* Make sure not a relative path */
      return( ERROR );

   RemoveTrailing( szBuf + 3, '\\' );

   if ( !IsValidPath( szBuf + 2, (UINT)((int)*szBuf - 0x40), FALSE ) )
      return( ERROR );

   return( OK );
}

/************************************************************************/
/* Display the command line help and then exits to DOS.                 */
/*                                                                      */
/* void CommandHelp( void )                                             */
/*                                                                      */
/* ARGUMENTS:  NONE                                                     */
/* RETURNS:    void                                                     */
/*                                                                      */
/************************************************************************/

void near CommandHelp( void )
{
   register    i;

#if defined (UPGRADE_PROGRAM)

   char        *apszText[ HELP_SWITCH_LINES ];
   GetMessage( apszText, HELP_SWITCH_TEXT );

#elif defined (UJANUS)

   char        *apszText[ BUSETUP_HELP_SWITCH_LINES ];
   GetMessage( apszText, BUSETUP_HELP_SWITCH_TEXT );

#elif defined (OEMFULL)

   char        *apszText[ OEMFULL_HELP_SWITCH_LINES ];
   GetMessage( apszText, OEMFULL_HELP_SWITCH_TEXT );

#elif defined (OEMBASE)

   char        *apszText[ OEMBASE_HELP_SWITCH_LINES ];
   GetMessage( apszText, OEMBASE_HELP_SWITCH_TEXT );

#endif  /* UPGRADE_PROGRAM */


   for( i = 0; apszText[ i ] != NULL; i++ )
   {
      VideoPuts( apszText[i] );
      VideoPutChar( CR );
      VideoPutChar( 0x0a );
   }
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\common\wdrminit.asm ===
PAGE 58,132
;******************************************************************************
TITLE WDRMINIT.ASM -- Real Mode Initialization for WDCTRL.386
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1990
;
;   Title:      WDRMINIT.ASM -- Real Mode Initialization for WDCTRL.386
;
;   Version:    1.00
;
;   Date:       17-Oct-1990
;
;   Author:     RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE     REV                 DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   17-Oct-1990 RAL
;   22-Oct-1991 JGT Switched to alternate status register
;                   Allowed Zenith machines to run by allowing track count
;                       to be THREE off (instead of the 'normal' TWO)
;   24-Oct-1991 JGT Allowed one drive to be non-FastDisk compatible and
;                       load.
;   27-Oct-1991 RAL For for hang if MS-NET kernel server running -- Don't
;		    call DOS to get InDOS ptr once incrmented.
;
; N.b., this file is (nearly) duplicated in apps\setup\dos\wdrminit.asm.
; Changes made to this file should also be made to that file.
;
;==============================================================================

	.386p

;******************************************************************************
;                             I N C L U D E S
;******************************************************************************

	.XLIST
	INCLUDE VMM.Inc
	INCLUDE OptTest.Inc
	INCLUDE BlockDev.Inc
	INCLUDE Int13.Inc
	INCLUDE WDLocal.Inc
	INCLUDE Int2FAPI.Inc
	.LIST

;******************************************************************************

SETUP EQU 1

IFDEF SETUP
    EXTRN _WDCtrlHangError:FAR

BeginProc MACRO ProcName
PUBLIC ProcName
ProcName PROC NEAR
	ENDM

EndProc MACRO ProcName
ProcName ENDP
	ENDM


DGROUP GROUP _DATA

ERR_WDCTRL_FATAL        equ 41
ERR_WDCTRL_BAD_SOFTWARE equ 42


FLAT SEGMENT AT 0

FLAT ENDS


;------------------------------------------------------------------------------

FASTDISK SEGMENT WORD PUBLIC USE16 'CODE'

	 ASSUME CS:FASTDISK
	 ASSUME DS:FASTDISK
	 ASSUME ES:FASTDISK
	 ASSUME SS:FASTDISK

ELSE

VxD_REAL_INIT_SEG

EXTRN Invalid_Win386_Ver_String:BYTE
EXTRN Invalid_Int13_Chain:BYTE
EXTRN Invalid_IRQ_String:BYTE
EXTRN Invalid_Controller_String:BYTE
EXTRN Validation_Failed_String:BYTE
EXTRN Invalid_DOS_Ver_String:BYTE
EXTRN WD_Fatal_Error_Code:BYTE
EXTRN WD_Fatal_Error_Msg:BYTE
EXTRN WD_Incompatible_Sw_Msg:BYTE
EXTRN No_Fixed_Disk_String:BYTE
EXTRN Pause_String:BYTE
EXTRN WD_Env_String_Bail:BYTE
EXTRN ES_Debug:BYTE
EXTRN ES_Debug_Len:BYTE
EXTRN ES_Disable:BYTE
EXTRN ES_Disable_Len:BYTE
EXTRN PS_Enable_Wdctrl:BYTE
EXTRN PS_Force_Enable_80:BYTE
EXTRN PS_Force_Enable_81:BYTE
EXTRN PS_Force_Alt_Status0:BYTE
EXTRN PS_Force_Alt_Status1:BYTE

ENDIF

;******************************************************************************


ALIGN 4
InDOS_Ptr LABEL DWORD
InDOS_Off	    dw	    ?
InDOS_Seg	    dw	    ?
DOS_BIOS_Int13_Vec  dd	    0			    ; 0 means not hooked
ROM_BIOS_Int13_Vec  dd	    0
Service_Addr        dd      0
Int13_Buffer        db      512 dup (?)
My_Read_Buffer      db      512 dup (?)

Num_Int13_Drives    db      0
Signaled_Detection  db	    False

QEMMDeviceName	    db	    'QEMM386$',0
QPIEntryPoint	    dd	    ?
QEMM_Stealth_Enabled db     False


;******************************************************************************
;
;   WD_Real_Mode_Init
;
;   DESCRIPTION:
;       This procedure attempts to detect a standard AT type hard disk
;       controller being used for Int 13h.  It will check for two hard
;       disk drives by monitoring changes to the cylinder register after
;       various reads.  Note that this code will use the DOS Int 2Fh, AH=13h
;       to bypass any caching software that may be installed.
;
;       To detect the presence of a Western Digital controller this code
;       will do the following:
;           Get original Int 13h vector from DOS
;           For disks 80h and 81h (if either exists) do
;               Read port 1F7h (Status) and make sure it looks OK
;               Read sector 1, track 0, head 0
;               Temp=Value of port(1F4h)
;               Read sector 1, track 2, head 0
;               If Temp=Value of port(1F4h) then NOT OK
;               If Temp-Value of port(1F4h) > 4 then NOT OK
;
;   ENTRY:
;       CS=DS=ES
;       AX = Win386 version number (requires 3.10)
;	SI = Environment segment
;
;   EXIT:
;       EDX = Flags
;             Bit 0 = 1 if drive 80h is on standard AT controller
;             Bit 1 = 1 if drive 81h is on standard AT controller
;             Bit 2 = 1 if alternate status register should be used
;
;   USES:
;
;==============================================================================

BeginProc WDCtrl_Real_Mode_Init

IFNDEF SETUP
	cmp     ax, 30Ah
	jb      WD_RMI_Invalid_Win386

        ;** Save the loader service address
	mov	[Service_Addr], ecx

	call	Test_Disable_Switch		; Q: User set /D:F option?
	jc	WD_RMI_Dont_Load_Silent 	;    Y: Don't load

        ;** Here we check for two environment strings:
        ;**     WDCTRLDISABLE=Y         ;Disables WDCTRL (displays message)
        ;**     WDCTRLDEBUG=Y           ;Stops debugger at INT 3 in RM Init
	mov	es, si			; Set ES to our environment
        mov     si, OFFSET ES_Disable   ;'WDCTRLDISABLE='
        xor     ch,ch
        mov     cl, ES_Disable_Len
        call    WD_RMI_Get_Env_String   ;Get the value for the string
        or      ax, ax                  ;Bail out?
        jz      SHORT WD_RMI_NoEnvBailOut ;No
        mov     dx, OFFSET WD_Env_String_Bail ;Get message
        jmp     WD_RMI_Print_Error      ;Exit with error

WD_RMI_NoEnvBailOut:
        mov     si, OFFSET ES_Debug     ;'WDCTRLDEBUG='
        xor     ch,ch
        mov     cl, ES_Debug_Len
        call    WD_RMI_Get_Env_String
        or      ax, ax
        jz      SHORT WD_RMI_NoInt3
        int     3                       ;Break to debugger
WD_RMI_NoInt3:
	;** Check for SYSTEM.INI string that must be set to true for
	;** WDCTRL to load.
        mov     ax, 3                   ;Service:  Get_Profile_Boolean
        xor     ecx, ecx                ;Default is FALSE
        xor     si, si                  ;[386Enh] is default section
	mov	di, OFFSET PS_Enable_Wdctrl ;'32BITDISKACCESS'
        call    cs:[Service_Addr]       ;Call loader service
	or	cx, cx
	jz	WD_RMI_Dont_Load_Silent

        ;** We have a SYSTEM.INI switch here to force WDCTRL enabled
        ;**     without validation.  This is useful for drives that fail
        ;**     validation, but work fine with FastDisk.
        mov     ax, 3                   ;Service:  Get_Profile_Boolean
        xor     ecx, ecx                ;Default is FALSE
        xor     si, si                  ;[386Enh] is default section
        mov     di, OFFSET PS_Force_Enable_80 ;'WDCTRLDRIVE0', 0
        call    cs:[Service_Addr]       ;Call loader service
        or      cx, cx
        mov     bl,0                    ;Clear the flag bits
        jz      SHORT WD_RMI_No_Drive_80 ;Drive not forced enabled
        or      bl, RF_Drive_80h_Ours   ;Flag that drive 80h was forced on
WD_RMI_No_Drive_80:
        mov     ax, 3                   ;Service:  Get_Profile_Boolean
        xor     ecx, ecx                ;Default is FALSE
        xor     si, si                  ;[386Enh] is default section
        mov     di, OFFSET PS_Force_Enable_81 ;'WDCTRLDRIVE1', 0
        push    bx                      ;Save flag bits
        call    cs:[Service_Addr]       ;Call loader service
        pop     bx
        or      cx, cx
        jz      SHORT WD_RMI_No_Drive_81 ;Drive not forced enabled
        or      bl, RF_Drive_81h_Ours   ;Flag that drive 80h was forced on
WD_RMI_No_Drive_81:
        test    bl,bl                   ;Any bits set?
        jz      SHORT WD_RMI_No_Force_Enable ;No.  Do normal validation

        ;** Now that we have verified that the user wanted one or two
        ;**     drives forced on, they can also specify if the drive
        ;**     should use the alternate status register.  Default is NO.
        mov     ax, 3                   ;Service:  Get_Profile_Boolean
        xor     ecx, ecx                ;Default is FALSE
        xor     si, si                  ;[386Enh] is default section
	mov	di, OFFSET PS_Force_Alt_Status0 ;'WDCTRLALTSTATUS0', 0
        push    bx                      ;Save flag bits
        call    cs:[Service_Addr]       ;Call loader service
        pop     bx
        or      cx, cx
	jz	SHORT WD_RMI_No_Alt_Status0 ;Drive not forced enabled
	or	bl, RF_Use_Alt_Stat_80	;Flag that user wanted alt status reg
WD_RMI_No_Alt_Status0:

        mov     ax, 3                   ;Service:  Get_Profile_Boolean
        xor     ecx, ecx                ;Default is FALSE
        xor     si, si                  ;[386Enh] is default section
	mov	di, OFFSET PS_Force_Alt_Status1 ;'WDCTRLALTSTATUS1', 0
        push    bx                      ;Save flag bits
        call    cs:[Service_Addr]       ;Call loader service
        pop     bx
        or      cx, cx
	jz	SHORT WD_RMI_No_Alt_Status1 ;Drive not forced enabled
	or	bl, RF_Use_Alt_Stat_81	;Flag that user wanted alt status reg
WD_RMI_No_Alt_Status1:

        jmp     WD_RMI_Have_Ref_Data    ;Force it on as if validation
                                        ;  passed successfully

WD_RMI_No_Force_Enable:

        push    ds                      ;Restore ES
        pop     es

ENDIF

;------------------------------------------------------------------------------
;
;   Now make sure that we have some Int 13h drives by calling Get Drive
;   Parameters for drive 80h.
;
;------------------------------------------------------------------------------

	mov     ah, 08h                         ; Get drive parameters
	mov     dl, 80h                         ; For first drive
	int	13h				; Q: Is there one or more?
	sti					; STI TO WORK AROUND AD-DOS!
IFNDEF SETUP
	jc	WD_RMI_No_Disk_Drives		;    N: Pretty pointless
ELSE
	jc	WD_RMI_Error_Exit		;    N: Pretty pointless
ENDIF
						;    Y: Do some funky tests
	mov     [Num_Int13_Drives], dl          ; Save this for later
;------------------------------------------------------------------------------
;
;   Now do a check for the COMPAQ dual WDCTRL configuration. COMPAQ machines
;   have the ability to support two WDCTRLs at different I/O ports but which
;   share the same IRQ (12). This would work, WDCTRL would handle one, and
;   COMPAQ driver (EXTDISK.SYS) the other, except for the fact that the IRQ
;   is shared. We don't have code to handle the IRQ sharing so we'll just
;   punt this config and not install.
;
;------------------------------------------------------------------------------
    ;
    ; First see if this is a COMPAQ machine. This is the same detection
    ;	code that is in VFD
    ;
	push	es
	mov	ax, 0F000h
	mov	es, ax
	cmp	DWORD PTR es:[0FFE8h], 'OC30'
	clc
	jnz	SHORT CompDoneP 	; Not COMPAQ
	cmp	DWORD PTR es:[0FFECh], 'QAPM'
	clc
	jnz	SHORT CompDoneP 	; Not COMPAQ
    ;
    ; Is a COMPAQ machine, check for DUAL controler config by reading CMOS
    ;
	mov	ax, 1bh			; Secondary controller drive 1
	mov	dx, 70h			; CMOS Index I/O port 
	out	dx, al
	inc	dx			; CMOS data I/O port 
	IO_Delay
	IO_Delay
	in	al, dx			; Get drive type
	or	al, al			; Q: Do we have a drive (clears carry)?
	jz	short CompDoneP 	;  N: jump with carry clear
	dec	dx
	mov	al, 0eh			; Check if CMOS is OK
	IO_Delay
	IO_Delay
	out	dx, al
	inc	dx
	IO_Delay
	IO_Delay
	in	al, dx
	test	al, 60h 		; Q: Is CMOS Valid (clears carry)?
					;    Checking CMOS Bad Checksum and
					;	      CMOS Config Invalid
	jnz	short CompDoneP 	;  N: Error, jump with carry clear
	xor	ecx,ecx
	dec	ecx			; Report validation phase 0FF,0FF
	stc				; SET CARRY, dual controler config
CompDoneP:
	pop	es
IFNDEF SETUP
	jc	WD_RMI_Validation_Failed	; Don't instl COMPAQ dual CTRL
ELSE
	jc	WD_RMI_Error_Exit		; Don't instl COMPAQ dual CTRL
ENDIF

;------------------------------------------------------------------------------
;
;   Check for QEMM stealth.  WDCTRL will load if stealth is enabled even though
;   the Int 13h hook points to a "bad" location (QEMM hooks it).
;
;------------------------------------------------------------------------------

	call	Detect_QEMM_Stealth

;------------------------------------------------------------------------------
;
;   Now do lots of party stuff to make sure cache programs flush or at least
;   don't try to lazy-write any data while we do this test.  To make sure
;   of this we will do the following:
;	Broadcast the BlockDev hardware detection API Int 2Fh
;	Do an Int 13h read of sector 0 on both drives
;	Do a DOS disk reset on drives C-Z (may flush)
;	Set the InDOS flag
;
;------------------------------------------------------------------------------
;
;   Broadcast an Int 2Fh that tells cache programs that disk hardware detection
;   is about to begin.	This broadcast can be intercepted by new cache
;   programs to prevent unnecessary flushes and to prevent conflicts.
;
;------------------------------------------------------------------------------

	mov	ax, (W386_Int_Multiplex SHL 8) + W386_Device_Broadcast
	mov	bx, BlockDev_Device_ID
	mov	cx, BlockDev_API_Hw_Detect_Start
	int	2Fh

;------------------------------------------------------------------------------
;
;   Some cache programs punt the entire cache when someone that is not DOS
;   does an Int 13h.  Hopefully this will happen when we do this read.
;
;------------------------------------------------------------------------------

	mov	ax, 0201h			; Read 1 sector
	mov	bx, OFFSET Int13_Buffer 	; Into this buffer (ES:BX)
	mov	cx, 0001h			; Track 0, sector 1
	mov	dx, 0080h			; Head 0, drive 80h
	int	13h				; Do it!
	sti					; STI TO WORK AROUND AD-DOS!

	cmp	[Num_Int13_Drives], 1		; Q: More than one drive?
	je	SHORT WD_RMI_Reset_Drives	;    N: Done

	mov	ax, 0201h			; Read 1 sector
	mov	bx, OFFSET Int13_Buffer 	; Into this buffer (ES:BX)
	mov	cx, 0001h			; Track 0, sector 1
	mov	dx, 0081h			; Head 0, drive 81h
	int	13h				; Do it!
	sti					; STI TO WORK AROUND AD-DOS!


;------------------------------------------------------------------------------
;
;   Do a disk reset on every drive C-Z so that cache programs will flush.
;   PC Super Kwik will pay attention to this DOS call and flush lazy writes.
;
;------------------------------------------------------------------------------

WD_RMI_Reset_Drives:
	mov	ah, 19h
	int	21h
	push	ax

	mov	dl, 2				; Start with drive C:

WD_RMI_Flush_Loop:
	mov	ah, 0Eh 			; Select the drive
	int	21h				; (AL contains max drive)

	mov	ah, 0Dh 			; Flush the drive
	int	21h

	inc	dl				; DL = Next drive to flush
	cmp	dl, al				; Q: Any more drives to flush?
	jb	SHORT WD_RMI_Flush_Loop 	;    Y: Keep looking

	pop	dx				; DL = Original default drive
	mov	ah, 0Eh 			; Select drive
	int	21h

;------------------------------------------------------------------------------
;
;   TSRs should not pop up and do DOS calls when the InDOS flag is set.
;   We will leave the flag non-zero throughout the entire test.
;
;------------------------------------------------------------------------------

WD_RMI_Set_InDOS:
	push	es

	mov	ah, 34h
	int	21h				; ES:[BX] -> InDOS flag
	inc	BYTE PTR es:[bx]
	mov	[InDOS_Seg], es
	mov	[InDOS_Off], bx

	pop	es

	mov	[Signaled_Detection], True	; Set flag to indicate that
						; we need to dec InDOS and
						; do end detection Int 2Fh call

;------------------------------------------------------------------------------
;
;   Now wait for 2 clock ticks to make sure all disk activity that may
;   have slipped in before we bumped InDOS will complete.
;
;------------------------------------------------------------------------------

	sti					; Paranoia in case some random
						; software int turned off ints
	push	es
	mov	ax, 40h
	mov	es, ax
	mov	ah, 2
WD_RMI_Set_Init_Time_Loop:
	mov	al, es:[6Ch]
WD_RMI_Wait_For_Tick_Loop:
	cmp	al, es:[6Ch]
	je	WD_RMI_Wait_For_Tick_Loop
	dec	ah
	jnz	WD_RMI_Set_Init_Time_Loop
	pop	es

;------------------------------------------------------------------------------
;
;   Now make sure that the Int 2Fh that we need will actually work.  We'll
;   do this by pointing DOS at somthing bogus for the time being.
;
;------------------------------------------------------------------------------

	mov     ah, 13h
	mov     bx, OFFSET WD_RMI_Int_13h_Hook
	mov     dx, OFFSET WD_RMI_Int_13h_Hook
	int     2Fh

	mov     si, ds
	mov     di, cs
	cmp     si, di
	je	WD_RMI_Cant_Hook_Int13

	mov	WORD PTR cs:[DOS_BIOS_Int13_Vec+2], ds
	mov	WORD PTR cs:[DOS_BIOS_Int13_Vec], dx

	mov	WORD PTR cs:[ROM_BIOS_Int13_Vec+2], es
	mov	WORD PTR cs:[ROM_BIOS_Int13_Vec], bx

	mov     ax, cs
	mov     es, ax
	mov     ds, ax

	call	Check_Hook_Addr_OK
IFNDEF SETUP
	jc	SHORT WD_RMI_Bad_Int_Chain
ELSE
	jc	short WD_RMI_Error_Exit
ENDIF


;------------------------------------------------------------------------------
;
;   It is possible for Int 13h to be hooked, so there may be some point
;   in loading this device.
;
;------------------------------------------------------------------------------

;
;   Make sure the interrupt we plan to use is unmasked.
;
	in      al, 0A1h
	test    al, 01000000b
IFNDEF SETUP
	jnz	SHORT WD_RMI_Wrong_IRQ
ELSE
	jnz     SHORT WD_RMI_Error_Exit
ENDIF


;
;   Check the status I/O port to make sure it looks right.
;
	mov	dx, WDIO_Def_Base_Port+WDIO_Status_Off
	IO_Delay
	IO_Delay
	in      al, dx
	and	al, NOT (WDStat_ECC_Corrected OR WDStat_Index)
	cmp     al, WDStat_Ready OR WDStat_Seek_Complete
IFNDEF SETUP
	jne	SHORT WD_RMI_Status_Bad
ELSE
	jne	SHORT WD_RMI_Error_Exit
ENDIF


;------------------------------------------------------------------------------
;
;   Now read a sector from each hard disk first through Int 13h and
;   then by sending a command directly to the controller.
;
;   We test both drives if present and set the appropriate bit for the
;   drive.  WDCTRL can use ony the drive that validates, even if there
;   are two drives and one doesn't validate
;
;------------------------------------------------------------------------------

	mov     dl, 80h
	mov     di, 41h*4
	call	WDCtrl_Validate_Drive
	pushf
	and	bx, RF_Use_Alt_Stat_80	; Save only alt status bit
	popf				; Restore carry flag
        jc      SHORT WD_RMI_First_Drive_Bogus
        or      bl, RF_Drive_80h_Ours   ; Alt status bit + good drive bit

WD_RMI_First_Drive_Bogus:
	cmp     [Num_Int13_Drives], 1
	je      SHORT WD_RMI_Do_We_Bail_Out

	mov     dl, 81h
	mov     di, 46h*4
        push    bx                      ; Save reference data
	call	WDCtrl_Validate_Drive
	mov	si, bx			; Save alt stat return from call
	pop	bx			; Get previous bits
	jc	SHORT WD_RMI_Do_We_Bail_Out
	and	si, RF_Use_Alt_Stat_81
	or	bx, si
        or      bl, RF_Drive_81h_Ours   ; Alt status bit + good drive bit

WD_RMI_Do_We_Bail_Out:
        test    bl, RF_Drive_80h_Ours OR RF_Drive_81h_Ours ; Either drive good?

IFNDEF SETUP
        jz      SHORT WD_RMI_Validation_Failed ; No, both bad so exit
ELSE
        jz      SHORT WD_RMI_Error_Exit
ENDIF

WD_RMI_Have_Ref_Data:
        movzx   edx, bl                  ; Get the reference data
	xor     bx, bx
	xor     si, si
IFNDEF SETUP
	mov     ax, Device_Load_Ok
ENDIF

;------------------------------------------------------------------------------
;
;   Common exit point for WD real mode init.  At this point, all return values
;   are in AX, BX, and SI.  If Int 13h is hooked then this code will reset
;   the hook.
;
;------------------------------------------------------------------------------

WD_RMI_Common_Exit:
	call	Clean_Up_Hooks
	ret

IFDEF SETUP

WD_RMI_Error_Exit:
	 mov   edx, 0
	 jmp   short WD_RMI_Common_Exit

ENDIF

;------------------------------------------------------------------------------
;
;   Error handlers
;
;------------------------------------------------------------------------------


IFNDEF SETUP
;
;   No disk drives were installed
;
WD_RMI_No_Disk_Drives:
	mov     dx, OFFSET No_Fixed_Disk_String
	jmp     SHORT WD_RMI_Print_Error
ENDIF

IFNDEF SETUP
;
;   Not running on Win386 verstion 3.10 or later
;
WD_RMI_Invalid_Win386:
	mov     dx, OFFSET Invalid_Win386_Ver_String
	jmp     SHORT WD_RMI_Print_Error
ENDIF

;
;   The DOS Int 2Fh did not work.  Assume wrong DOS version.
;
WD_RMI_Cant_Hook_Int13:
	mov     dx, cs
	mov     ds, dx
	mov     es, dx
IFNDEF SETUP
	mov     dx, OFFSET Invalid_DOS_Ver_String
	jmp     SHORT WD_RMI_Print_Error
ELSE
	jmp   SHORT WD_RMI_Error_Exit
ENDIF

IFNDEF SETUP
;
;   The Int 13h chain was hooked, but it appears that someone else has
;   hooked it in front of us.
;
WD_RMI_Bad_Int_Chain:
	mov     dx, OFFSET Invalid_Int13_Chain
	jmp     SHORT WD_RMI_Print_Error

;
;   The controller is not using the correct IRQ or the IRQ is masked.
;
WD_RMI_Wrong_IRQ:
	mov	dx, OFFSET Invalid_IRQ_String
	jmp     SHORT WD_RMI_Print_Error


;
;   The initial read of the controller status port did not match our
;   expectation.
;
WD_RMI_Status_Bad:
	mov	cx, ax
	call	Clean_Up_Hooks

	mov     dx, OFFSET Invalid_Controller_String
	mov     ah, 9
	int	21h

	mov	al, cl
	call	Print_Hex_Byte
	jmp	SHORT WD_RMI_Dont_Load


;
;   The controller did not pass our tests.
;
WD_RMI_Validation_Failed:
	call	Clean_Up_Hooks

	mov	dx, OFFSET Validation_Failed_String
	mov     ah, 9
	int	21h

	mov	al, cl
	call	Print_Hex_Byte

	mov	ah, 02h
	mov	dl, ','
	int	21h
	mov	dl, ' '
	int	21h

	mov	al, ch
	call	Print_Hex_Byte

	jmp	SHORT WD_RMI_Dont_Load


WD_RMI_Print_Error:
	call	Clean_Up_Hooks
	mov     ah, 9
	int	21h

WD_RMI_Dont_Load:
	mov	dx, OFFSET Pause_String
	mov	ah, 9
	int	21h

	xor	ax, ax
	int	16h

WD_RMI_Dont_Load_Silent:
	xor     bx, bx
	xor     si, si
	mov     ax, Abort_Device_Load + No_Fail_Message
	jmp     WD_RMI_Common_Exit
ENDIF

EndProc WDCtrl_Real_Mode_Init


;******************************************************************************
;
;   Detect_QEMM_Stealth
;
;   DESCRIPTION:
;	Specific check for QEMM stealth.  We'll call QEMM if it is installed
;	to find out if stealth is on.  This is done before entering the main
;	part of the detection code since we need to make DOS calls to open
;	the device driver.
;
;   ENTRY:
;	DS=ES=CS
;
;   EXIT:
;	None
;
;   USES:
;	Flags
;
;==============================================================================

BeginProc Detect_QEMM_Stealth

	pusha
;
;   Open QEMM device driver
;
	mov	dx, OFFSET QEMMDeviceName
	mov	ax, 3D00h
	int	21h				; Try to open QEMM386$
	jc	SHORT DQS_No_QEMM		; If CY, QEMM-386 not present
	mov	bx, ax				; Save file handle in BX
	mov	dx, OFFSET QPIEntryPoint	; Store the entry point here
	mov	cx, 4				; We're reading 4 bytes
	mov	ax, 4402h			; IOCTL read control string
	int	21h
	pushf					; Save error code
	mov	ah, 3Eh 			; Close the file handle
	int	21h
	popf
	jc	SHORT DQS_No_QEMM

;
;   At this point QPIEntryPoint contains the address of the QEMM entry
;   point.  We KNOW that we're on version 6.0 or later (since the IOCTL worked)
;   so we'll make the stealth install call.
;
	xor	cx, cx				; Set CL to zero just in case...
	mov	ax, 30*100h+0			; QEMM get info call
	push	ds				; More paranoia...
	push	es
	call	[QPIEntryPoint] 		; Call Mr. QEMM
	pop	es
	pop	ds
	test	cl, cl				; Q: Is stealth enabled?
	jz	SHORT DQS_No_Stealth		;    N: Don't set falg
						;    Y: Set flag for use later
	mov	[QEMM_Stealth_Enabled], True

DQS_No_Stealth:
DQS_No_QEMM:
	popa
	ret

EndProc Detect_QEMM_Stealth


;******************************************************************************
;
;   Check_Hook_Addr_OK
;
;   DESCRIPTION:
;	This procedure checks the BIOS Int 13h interrupt vector value to
;	see if it is "acceptable".  The address is considered acceptable
;	iff the segment is >= A000h or QEMM 6.0 or greater is installed
;	and stealth is enabled or the hook code responds to our Int 2Fh.
;
;   ENTRY:
;	DS=ES=CS
;
;   EXIT:
;	If carry set then
;	    Hook is NOT acceptable
;	else (carry clear)
;	    Hook address looks good
;
;   USES:
;	Flags
;
;==============================================================================

BeginProc Check_Hook_Addr_OK

	cmp	WORD PTR [ROM_BIOS_Int13_Vec+2], 0A000h
	jae	SHORT CHAO_Quick_OK_Exit

	pusha


;------------------------------------------------------------------------------
;
;   Broadcast an Int 2Fh that asks DOS Int 13h hookers if they are "blockdev
;   aware".  If they are aware of BlockDev and want fastdisk drivers to load
;   then they will return 0 in CX.
;
;------------------------------------------------------------------------------

	mov	ax, (W386_Int_Multiplex SHL 8) + W386_Device_Broadcast
	mov	bx, BlockDev_Device_ID
	.ERRE	BlockDev_API_Int13_Chain_Check	 ; Should not be 0!
	mov	cx, BlockDev_API_Int13_Chain_Check
	int	2Fh
	jcxz	SHORT CHAO_Chain_Is_OK

;------------------------------------------------------------------------------
;
;   Specific check for QEMM stealth.  We'll call QEMM if it is installed
;   to find out if stealth is on.  If it is then we'll load anyway.
;
;------------------------------------------------------------------------------

;
;   Now make sure that both hooks point to the same code segment as a sanity
;   check.
;
	mov	ax, WORD PTR [ROM_BIOS_Int13_Vec+2]
	cmp	ax, WORD PTR [DOS_BIOS_Int13_Vec+2]
	jne	SHORT CHAO_QEMM_Seg_Check_Failed

	cmp	[QEMM_Stealth_Enabled], True	; Q: Stealth on?
	jne	SHORT CHAO_QEMM_Seg_Check_Failed;    N: Not gonna do it!

;
;   All success cases exit here
;
CHAO_Chain_Is_OK:
	popa
CHAO_Quick_OK_Exit:
	clc
	ret

;
;   All failure cases exit here
;
CHAO_QEMM_Seg_Check_Failed:
CHAO_No_Stealth:
CHAO_No_QEMM:
	popa
	stc
	ret

EndProc Check_Hook_Addr_OK


IFNDEF SETUP


;******************************************************************************
;
;   Test_Disable_Switch
;
;   DESCRIPTION:
;	This procedure scans the parameters passed to Win386 for /d:F which
;	is a debug switch to disable "FastDisk".  It if is found then
;	WDCTRL will not load.
;
;   ENTRY:
;	None
;
;   EXIT:
;	If carry flag set then /D:F selected.  WDCTRL should not load.
;
;   USES:
;	Flags
;
;==============================================================================

BeginProc Test_Disable_Switch

	push	ds
	pusha

	mov	ah, 62h 			; Get current PSP
	int	21h
	mov	ds, bx				; ES -> Current PSP

    ;
    ; Get command-line debug option
    ;
    ; There are several forms for this:
    ;
    ;	  /d:s foo /d:p
    ;
    ; In this case, the first /d: is ours, the second isn't, the second
    ; is an argument to the app "foo". We detect the boundary (in this case
    ; the "foo") by detecting a character which is not a tab, space or '/'
    ; which is not part of a '/' arg. Thus:
    ;
    ;	  foo	 is a boundary
    ;	  /goooo is not a boundary
    ;	  /d:&	 is not a boundary and will be skipped, valid debug options
    ;		   are either 'A'-'Z' or 'a'-'z'
    ;
    ;
    ;	  /d:svf
    ;	  /d:s /d:v /d:f
    ;
    ; These two are the same, both s and v debug options are specified.
    ; we allow both forms so that users don't get confused and can do multiple
    ; debug options either way.
    ;
    ; This loop exits immeidatly if /d:f is found.  Wdctrl will be disabled.
    ;

	movzx	cx, BYTE PTR ds:[80h]
	jcxz	WD_RMI_TSD_No_Debug_Opt

	mov	si, 81h
	cld
WD_RMI_TSD_Cont_Search:
	lodsb
WD_RMI_TSD_Cont_Search2:
	cmp	al,'/'
	jne	short WD_RMI_TSD_ChkBnd
WD_RMI_TSD_NextSw:
	dec	cx
	jz	SHORT WD_RMI_TSD_No_Debug_Opt
	lodsb
	or	al,20h			; force to lower case
	cmp	al,'d'			; /d ?
	jne	SHORT WD_RMI_TSD_UnkSwitch	; No, unknown switch
	dec	cx
	jz	SHORT WD_RMI_TSD_No_Debug_Opt
	lodsb
	cmp	al,':'			; /d: ?
	jne	SHORT WD_RMI_TSD_UnkSwitch	; No, unknown switch
	dec	cx
	jz	SHORT WD_RMI_TSD_No_Debug_Opt
	lodsb
WD_RMI_TSD_ContDebOpt:
	cmp	al,'A'			; /d: something that is a letter?
	jb	short WD_RMI_TSD_UnkSwitch	; No, unknown switch
	cmp	al,'Z'
	jbe	short WD_RMI_TSD_IsUpDebOpt	; Yes
	cmp	al,'a'
	jb	short WD_RMI_TSD_UnkSwitch	; No, unknown switch
	cmp	al,'z'
	ja	short WD_RMI_TSD_UnkSwitch	; No, unknown switch
WD_RMI_TSD_IsUpDebOpt:
	or	al,20h			; force to lower case
	cmp	al, "f"
	je	SHORT WD_RMI_TSD_Dont_Load
	dec	cx
	jz	SHORT WD_RMI_TSD_No_Debug_Opt
	lodsb
	cmp	al,20h			; End of this debug opt?
	je	short WD_RMI_TSD_LoopIt 	; Yes
	cmp	al,09h			; End of this debug opt?
	je	short WD_RMI_TSD_LoopIt 	; Yes
	cmp	al,'/'			; End of this debug opt?
	je	short WD_RMI_TSD_NextSw 	; Yes
	jmp	short WD_RMI_TSD_ContDebOpt

WD_RMI_TSD_UnkSwitch:
	dec	cx
	jz	SHORT WD_RMI_TSD_No_Debug_Opt
WD_RMI_TSD_UnkSwitchCnt:
	lodsb
	cmp	al,20h
	je	short WD_RMI_TSD_LoopIt
	cmp	al,09h
	je	short WD_RMI_TSD_LoopIt
	cmp	al,'/'
	je	short WD_RMI_TSD_NextSw
	loop	WD_RMI_TSD_UnkSwitchCnt
	jmp	SHORT WD_RMI_TSD_No_Debug_Opt

WD_RMI_TSD_ChkBnd:
	cmp	al,' '
	je	short WD_RMI_TSD_LoopIt
	cmp	al,09h
	jne	short WD_RMI_TSD_No_Debug_Opt
WD_RMI_TSD_LoopIt:
	loop	WD_RMI_TSD_Cont_Search

WD_RMI_TSD_No_Debug_Opt:
	clc
WD_RMI_TSD_Pop_Exit:
	popa
	pop	ds
	ret

WD_RMI_TSD_Dont_Load:
	stc
	jmp	WD_RMI_TSD_Pop_Exit

EndProc Test_Disable_Switch


;******************************************************************************
;
;   Print_Hex_Byte
;
;   DESCRIPTION:
;
;   ENTRY:
;	AL = Byte to print
;
;   EXIT:
;
;   USES:
;	Flags
;
;==============================================================================

Hex_Convert_Table db "0123456789ABCDEF"

BeginProc Print_Hex_Byte

	pusha

	mov	bx, ax
	mov	si, ax

	shr	bx, 4
	and	bx, 1111b
	and	si, 1111b

	mov	dl, Hex_Convert_Table[bx]
	mov	ah, 2
	int	21h

	mov	dl, Hex_Convert_Table[si]
	int	21h

	popa
	ret

EndProc Print_Hex_Byte

ENDIF

;******************************************************************************
;
;   Clean_Up_Hooks
;
;   DESCRIPTION:
;
;   ENTRY:
;
;   EXIT:
;
;   USES:
;
;==============================================================================

BeginProc Clean_Up_Hooks

	pusha

	xor     ecx, ecx
	xchg	ecx, [DOS_BIOS_Int13_Vec]
	jecxz	WD_UIC_Int13_Unhooked

	mov	eax, [ROM_BIOS_Int13_Vec]

	mov     dx, cx
	shr     ecx, 16
	mov     ds, cx

	mov     bx, ax
	shr     eax, 16
	mov     es, ax

	mov     ah, 13h
	int     2Fh

	mov     ax, cs
	mov     ds, ax
	mov     es, ax

;
;   Check to see if we have incremented the InDOS flag and broadcasted the
;   hardware detection Int 2Fh API.  If so, dec the InDOS flag and signal
;   then end of hardware detection.
;
WD_UIC_Int13_Unhooked:
	xor	cx, cx
	xchg	cl, [Signaled_Detection]
	jcxz	SHORT WD_UIC_Exit

;
;   WARNING:  Strange hanging bug with MS-NET server kernel loaded if you
;	      try to get the InDOS ptr while InDOS is non-zero.  Therefore,
;	      we don't want to call DOS here to get the InDOS flag.  That's
;	      why we saved it away earlier.
;
	push	es
	les	bx, [InDOS_Ptr] 		; ES:[BX] -> InDOS flag
	dec	BYTE PTR es:[bx]		; Dec the InDOS flag
	pop	es

	mov	ax, (W386_Int_Multiplex SHL 8) + W386_Device_Broadcast
	mov	bx, BlockDev_Device_ID
	mov	cx, BlockDev_API_Hw_Detect_End
	int	2Fh

WD_UIC_Exit:
	popa
	ret

EndProc Clean_Up_Hooks


;******************************************************************************
;
;   Fatal_Disk_Error
;
;   DESCRIPTION:
;       This procedure is jumped to by WDCtrl_Validate_Drive if a fatal
;       error is detected.  It displays a nasty warning message and hangs
;       the machine.
;
;   ENTRY:
;       DS = Our data segment
;       BL = Error code
;
;   EXIT:
;       Never!
;
;   USES:
;       Who cares!
;
;==============================================================================

BeginProc Fatal_Disk_Error

	call	Clean_Up_Hooks

IFNDEF SETUP
        add     bl,'0'                  ;Convert error code to ASCII 0-9
        mov     si, OFFSET WD_Fatal_Error_Code
        mov     ds:[si], bl             ;Poke the error number in

	mov     ah, 9
	mov     dx, OFFSET WD_Fatal_Error_Msg
	int     21h
ELSE
	mov   ax, DGROUP              ;Set up DS, ES to our data segment
	mov   ds, ax                  ;before calling error display routine.
	mov   es, ax

	mov   ax, ERR_WDCTRL_FATAL
	push  ax
	call  _WDCtrlHangError
	pop   ax
ENDIF

	jmp     $

EndProc Fatal_Disk_Error


;******************************************************************************
;
;   WDCtrl_Validate_Drive
;
;   DESCRIPTION:
;   The procedure must be called with the following parameters:
;	DL = Int 13h drive number to test (80h or 81h)
;	[0:DI] -> Fixed disk parameter table for this drive
;	DS=ES pointing to a data segment with the following data variables:
;
;	    Orig_Int13_Vector	dd	?
;	    Int13_Buffer	db	512 dup (?)
;	    My_Read_Buffer	db	512 dup (?)
;
;	The Orig_Int13_Vector must be filled in by the caller before invoking
;	this code.  This variable should contain the CS:IP value returned
;	by DOS from the Int 2Fh/AH=13h call to obtain the address of the
;	original Int 13h handler.  The other variables do not need to be
;	filled in.
;
;   The procedure will do one of three things:
;	Return with carry clear to indicate that the drive is WDCtrl compatible
;	Return with carry set to indicate that it can't use the drive
;	Jump to a label named "FATAL_DISK_ERROR".  The main program should
;	    display an error message and HANG THE MACHINE if this happens.
;
;	If the procedure returns with carry set then CX will contain a value
;	    that defines the phase of initialization that failed.
;
;       A flag is returned in BX indicating whether or not the ALTERNATE
;	Status register should be used.  BX is set to 0FFFFh iff the
;	alt status register should be used by WDCtrl for this drive.  BX
;	will be 0 if the normal status register should be used for this drive.
;
;   All segment registers will be preserved by the procedure.  All other
;   registers and flags will be modified.
;
;==============================================================================


Check_Invalid MACRO JmpIns
        LOCAL WD_CI_Invalid, WD_CI_Valid

IFNDEF DEBUG
	JmpIns	WD_VD_Invalid
	inc	[bp.Test_Phase]
ELSE
        JmpIns  SHORT WD_CI_Invalid
        inc     [bp.Test_Phase]
        jmp     SHORT WD_CI_Valid

WD_CI_Invalid:
        int     3
        jmp     WD_VD_Invalid

WD_CI_Valid:
ENDIF
	ENDM

Check_Fatal_Error MACRO JmpIns,ErrorCode        ;;Trashes bl
	mov	bl, ErrorCode
	JmpIns	Fatal_Disk_Error
	ENDM


BeginProc WDCtrl_Validate_Drive

Test_Stack_Frame STRUC
Test_Sector_Num      dw         ?
Test_Cyl_Num	     dw	        ?
Test_Head_Num	     dw	        ?
Test_Phase	     dw	        ?
Test_Loop_Phase      dw	        ?
Test_Drive_Number    db	        ?
		     db	        ?       ; Dword align
Test_Param_Off	     dw	        ?
Test_Param_Seg	     dw	        ?
Test_Alt_Status_Flag dw         ?
Test_Stack_Frame ENDS


	push	es
	push	bp
	sub	sp, SIZE Test_Stack_Frame
	mov	bp, sp

	mov	[bp.Test_Drive_Number], dl

	xor	ax, ax
	mov	[bp.Test_Phase], ax
	mov	[bp.Test_Loop_Phase], ax

	mov	es, ax
	les	di, es:[di]			; ES:DI -> Drive param table

	mov	[bp.Test_Param_Seg], es
	mov	[bp.Test_Param_Off], di

        ;** Default to the ALT status register.  We clear the bit
        ;**     anytime we fail with this register and use the normal one.
	mov	[bp.Test_Alt_Status_Flag], 0FFFFh

;------------------------------------------------------------------------------
;
;   First make sure that the fixed disk parameter table contains the same
;   information as Int 13h Get Drive Parameters returns.
;
;------------------------------------------------------------------------------

        ;** Phase 0
	mov	ah, 08h
	pushf
	cli
	call	[ROM_BIOS_Int13_Vec]		; Q: Did get drive params work?
	Check_Invalid jc			;    N: Error
						;    Y: Compare to FDPT

        ;** Phase 1
	inc	dh				; One greater returned
	cmp	dh, es:[di.FDPT_Max_Heads]	; Q: Heads equal?
	Check_Invalid jne			;    N: No good

        ;** Phase 2
	mov	ax, cx
	and	al, 00111111b
	cmp	al, es:[di.FDPT_Sec_Per_Track]	; Q: Sector count the same?
	Check_Invalid jne			;    N: That's strange!

        ;** Phase 3
	shr	cl, 6
	xchg	ch, cl
	add	cx, 2				; TWO GREATER RETURNED!
	cmp	cx, es:[di.FDPT_Max_Cyl]	; Q: Cylinder numbers match?
        jne     SHORT @F                        ;    N: Try Zenith check
        inc     [bp.Test_Phase]                 ;    Y: Yes.  Bump phase
        jmp     SHORT WD_VD_CylOK
@@:     inc     cx                              ; Check THREE for Zenith
	cmp	cx, es:[di.FDPT_Max_Cyl]
	Check_Invalid jne			;    N: Very, very weird
WD_VD_CylOK:


;------------------------------------------------------------------------------
;
;   The Test_Loop_Phase variable determines which test to perform.  We will
;   attempt to read 3 different sectors:
;	The 1st sector on the 1st head on the 1st Cyl
;	The 503rd sector
;	The next-to-last sector on the next-to-last head on the next-to-last cyl
;
;------------------------------------------------------------------------------

WD_VD_Do_Next_Test:
	mov	ax, [bp.Test_Loop_Phase]
	cmp	ax, 1
	je	SHORT WD_VD_Test_503
	ja	SHORT WD_VD_Test_Last

	inc	ax
	mov	[bp.Test_Sector_Num], ax
	mov	[bp.Test_Head_Num], ax
	mov	[bp.Test_Cyl_Num], ax
	jmp	SHORT WD_VD_Do_Read_Now

;------------------------------------------------------------------------------
;
;   Now read the next-to-the-last sector on the next-to-the-last head,
;   and on the cylinder 7/8 of the way to the end.  We don't test the
;   last sector because the BIOS might be lying to us about where the
;   last sector resides.
;
;------------------------------------------------------------------------------

WD_VD_Test_Last:
	movzx	ax, es:[di.FDPT_Sec_Per_Track]
	dec	ax
	mov	[bp.Test_Sector_Num], ax
	movzx	ax, es:[di.FDPT_Max_Heads]
	dec	ax
	mov	[bp.Test_Head_Num], ax
	mov	ax, es:[di.FDPT_Max_Cyl]
        mov     cx, ax                          ; Get cyl 7/8 of way to end
        shr     cx, 3
        sub     ax, cx
	mov	[bp.Test_Cyl_Num], ax
	jmp	SHORT WD_VD_Do_Read_Now

;------------------------------------------------------------------------------
;
;   Now figure out the head/cyl/sector number for sector 503 on the disk.
;   This number was chosen since 503 (decimal) is a prime number.  This will
;   verify that the BIOS is using standard translation of the BIOS parameter
;   table.
;
;------------------------------------------------------------------------------

WD_VD_Test_503:
	mov	eax, 503			; EAX = Sector to begin xfer at

	xor	edx, edx			; Zero high dword for idiv
	movzx	ecx, es:[di.FDPT_Sec_Per_Track]
	idiv	ecx				; Remainder+1 = Starting sector
	inc	dx				; Inc to make 1 based
	mov	[bp.Test_Sector_Num], dx	; Save it on the stack
	xor	edx, edx			; Zero high dword for idiv
	movzx	ecx, es:[di.FDPT_Max_Heads]
	idiv	ecx				; EAX = Cylinder number
						; EDX = Starting head
	mov	[bp.Test_Cyl_Num], ax		; Save 'em for later
	mov	[bp.Test_Head_Num], dx

;------------------------------------------------------------------------------
;
;   The drive parameters look OK.  Now verify read a sector from the drive to
;   attempt to force that drive to be selected.  To prevent problems with a
;   cache we will call the original BIOS handler directly.
;
;------------------------------------------------------------------------------

        ;** Phase 4/B/12  (Three passes through here)
WD_VD_Do_Read_Now:
	push	es
	mov	ax, ds
	mov	es, ax
	mov	bx, OFFSET Int13_Buffer
	mov	ax, 0201h			; Read one sector
	mov	cx, [bp.Test_Cyl_Num]
	xchg	ch, cl
	shl	cl, 6
	or	cl, BYTE PTR [bp.Test_Sector_Num]
	mov	dl, [bp.Test_Drive_Number]	; DL = Drive number
	mov	dh, BYTE PTR [bp.Test_Head_Num]
	pushf
	cli
	call	[ROM_BIOS_Int13_Vec]
	pop	es				; ES:DI points to drive params!
        mov     al, ah                          ; Put value in AL for macro
	Check_Invalid jc

;------------------------------------------------------------------------------
;
;   The thing worked!  Now check all the I/O ports to make sure they look
;   the way we want them to.
;
;------------------------------------------------------------------------------

        ;** Phase 5/C/13
	mov	dx, WDIO_Def_Base_Port+WDIO_Error_Off
	in	al, dx				; Read the error status
	test	al, al				; Non-zero is no good
	Check_Invalid jnz

        ;** Phase 6/D/14
	inc	dx
	IO_Delay
	IO_Delay
	in	al, dx				; Read the sector count
	test	al, al				; Non-zero is no good
	Check_Invalid jnz

        ;** Phase 7/E/15
	inc	dx
	IO_Delay
	IO_Delay
	in	al, dx				; Read the sector number
	cmp	al, BYTE PTR [bp.Test_Sector_Num];Q: Is sector number right?
	Check_Invalid jne			;    N: Die! Die! Die!

        ;** Phase 8/F/16
	inc	dx
	IO_Delay
	IO_Delay
	in	al, dx				; Read low cyl number
	mov	ah, al
	inc	dx
	IO_Delay
	IO_Delay
	in	al, dx				; Read high cyl number
	xchg	al, ah
	cmp	ax, [bp.Test_Cyl_Num]		; Q: Cyl number correct?
	Check_Invalid jnz			;    N: Wrong track

        ;** Phase 9/10/17
	inc	dx
	mov	al, [bp.Test_Drive_Number]	; Get drive #
	and	ax, 1
	shl	ax, 12				; Move bit to proper position
	IO_Delay
	IO_Delay
	in	al, dx
	xor	al, ah				; Drive bit should be 0.
	xor	al, BYTE PTR [bp.Test_Head_Num] ; Should make head # 0
	cmp	al, 10100000b			; Q: Head 0, 512 byte sectors?
	Check_Invalid jne			;    N: Error

        ;** Phase A/11/18
	inc	dx
	IO_Delay
	IO_Delay
	in	al, dx				; Read status
	mov	ah, al				; Preserve real status in case
	and	ah, NOT (WDStat_ECC_Corrected OR WDStat_Index) ; of error we
	cmp	ah, WDStat_Ready OR WDStat_Seek_Complete ; will get good info
	Check_Invalid jne

;------------------------------------------------------------------------------
;
;   Wowsa!  All of the port status looks correct.  Now for the big, grand-
;   pooba test -- Actually try to read some data by directly programming
;   the controller.  This is pretty silly polling code, but it dosen't really
;   matter.
;
;------------------------------------------------------------------------------

	IO_Delay
	IO_Delay
	in	al, 0A1h
	or	al, 01000000b
	IO_Delay
	IO_Delay
	out	0A1h, al

	mov	dx, WDIO_Def_Base_Port+WDIO_Drive_Control_Off
	mov	al, es:[di.FDPT_Drive_Control]
	IO_Delay
	IO_Delay
	out	dx, al

	mov	ax, es:[di.FDPT_Write_Precom_Cyl]
	cmp	ax, -1
	jne	SHORT WD_VD_Set_Precom
	xor	ax, ax
WD_VD_Set_Precom:
	shr	ax, 2

	mov	dx, WDIO_Def_Base_Port+WDIO_Precomp_Off
	IO_Delay
	IO_Delay
	out	dx, al

	inc	dx
	mov	al, 1
	IO_Delay
	IO_Delay
	out	dx, al				; Sector count = 1

	inc	dx
	mov	ax, [bp.Test_Sector_Num]
	IO_Delay
	IO_Delay
	out	dx, al				; Sector number

	inc	dx
	mov	ax, [bp.Test_Cyl_Num]
	IO_Delay
	IO_Delay
	out	dx, al				; Low byte of cylinder
	inc	dx
	mov	al, ah
	IO_Delay
	IO_Delay
	out	dx, al				; High byte

	mov	al, 10100000b			; Head 0, drive 0
	test	[bp.Test_Drive_Number], 1	; Q: Drive 1?
	jz	SHORT WD_VD_Prog_Head
	mov	al, 10110000b			; Head 0, drive 1
WD_VD_Prog_Head:
	or	al, BYTE PTR [bp.Test_Head_Num]
	inc	dx
	IO_Delay
	IO_Delay
	out	dx, al

	inc	dx
	mov	al, 20h
	IO_Delay
	IO_Delay
	out	dx, al				; Send a read to Mr. Ctrl

;------------------------------------------------------------------------------
;
;   The command has been sent.	Now wait for the command to complete.
;   Check to see whether or not we have already detected that we CANNOT
;   use the ALT status register.  If we detect this, we don't try again.
;
;------------------------------------------------------------------------------

	cmp	[bp.Test_Alt_Status_Flag], 0
	je	SHORT WD_VD_Try_Normal_Status	; Nope, must use NORMAL status
	mov	ax, 40h
	mov	es, ax
	mov	cx, 18*3/4			; 3/4 second time-out
        mov     dx, WDIO_Def_Base_Port + WDIO_Alt_Stat_Off

WD_VD_One_More_Tick:
	mov	bl, BYTE PTR es:[6Ch]		; BL = Low byte of tick count
WD_VD_Loop_Til_Done:

	IO_Delay
	IO_Delay
	in	al, dx				; AL = Status
	test	al, WDStat_Busy 		; Q: Controller busy?
	jz	SHORT WD_VD_No_Longer_Busy	;    N: Read the data!
						;    Y: Keep polling

WD_VD_Not_Really_Done:
	cmp	bl, BYTE PTR es:[6Ch]		; Q: Has time changed?
	je	SHORT WD_VD_Loop_Til_Done	;    N: Don't time-out
	loop	WD_VD_One_More_Tick		;	else dec CX count
        jmp     SHORT WD_VD_Try_Normal_Status   ; We timed out!!

;------------------------------------------------------------------------------
;
;   The controller is no longer busy.  Now make sure the status looks right.
;   (No error, data request set)
;   This test is kind of strange, but it is important.	Apparently on some
;   controllers the controller will go to the not busy state BEFORE setting
;   the DRQ bit.  We'll just keep looping until we see not busy AND DRQ set.
;
;   If the ALT status register doesn't look good, we'll try it again with
;   the normal status register.
;
;------------------------------------------------------------------------------

WD_VD_No_Longer_Busy:
	test	al, WDStat_Error		; Q: Error?
        jnz     SHORT WD_VD_Try_Normal_Status   ;  Y: Try the normal status reg
	test	al, WDStat_DRQ			; Q: Data request set?
	jz	SHORT WD_VD_Not_Really_Done  	;  N: Keep looking for it

        ;** Once we get here, we're OK using the ALT status register
        mov     dx, WDIO_Def_Base_Port + WDIO_Status_Off
	IO_Delay
	IO_Delay
	in	al, dx				; Clear IRQ by reading status
        jmp     SHORT WD_VD_Status_OK           ;  Y: Things look happy

;------------------------------------------------------------------------------
;
;   If we timed out or if we encountered a strange register configuration,
;   we need to check the normal status register because we've only been
;   looking at the alternate up to this point.  We will flag what the final
;   decision between normal and alternate register is.  If neither one is
;   right, we bail out.
;
;------------------------------------------------------------------------------

WD_VD_Try_Normal_Status:
	mov	[bp.Test_Alt_Status_Flag], 0
	mov	cx, 18*3/4			; Reset 3/4 second time-out
        mov     dx, WDIO_Def_Base_Port + WDIO_Status_Off

WD_VD_N_One_More_Tick:
	mov	bl, BYTE PTR es:[6Ch]		; BL = Low byte of tick count
WD_VD_N_Loop_Til_Done:

	IO_Delay
	IO_Delay
	in	al, dx				; AL = Status
	test	al, WDStat_Busy 		; Q: Controller busy?
	jz	SHORT WD_VD_N_No_Longer_Busy	;    N: Read the data!
						;    Y: Keep polling
WD_VD_N_Not_Really_Done:
	cmp	bl, BYTE PTR es:[6Ch]		; Q: Has time changed?
	je	SHORT WD_VD_N_Loop_Til_Done	;    N: Don't time-out
	loop	WD_VD_N_One_More_Tick		;	else dec CX count
        Check_Fatal_Error jmp, FATAL_TIME_OUT   ; Timeout!!!

;------------------------------------------------------------------------------
;
;   As with the ALT status register, we get here when the NORMAL status
;   register is no longer busy.  We have to check to see that there was
;   no reported error, and that the DREQ bit is set.  If we pass these
;   tests, we're still OK (even though the ALT reg failed) and we just
;   flag to always use the normal status register.
;
;------------------------------------------------------------------------------

WD_VD_N_No_Longer_Busy:
	test	al, WDStat_Error		; Q: Error?
    Check_Fatal_Error jnz, FATAL_BAD_STATUS ;    Y: Die!
	test	al, WDStat_DRQ			; Q: Data request set?
    jz	WD_VD_N_Not_Really_Done         ;    N: Keep looping!
                                            ;    Y: We look happy now

;------------------------------------------------------------------------------
;
;   Looks good.  Now read the data and compare it to what the BIOS gave us back
;
;------------------------------------------------------------------------------

WD_VD_Status_OK:
	mov	ax, ds
	mov	es, ax
	mov	di, OFFSET My_Read_Buffer
	mov	cx, 100h
	cld
	mov	dx, WDIO_Def_Base_Port+WDIO_Data_Off
	IO_Delay
	IO_Delay
	rep insw

	mov	si, OFFSET Int13_Buffer
	mov	di, OFFSET My_Read_Buffer
	mov	cx, 80h
	cld
	rep cmpsd
	Check_Fatal_Error jne, FATAL_DATA_BAD_COMPARE

;------------------------------------------------------------------------------
;
;   It worked!	Everything is OK.  No re-enable interrupts for the drive.
;
;------------------------------------------------------------------------------

	in	al, 0A1h
	and	al, NOT 01000000b
	IO_Delay
	IO_Delay
	out	0A1h, al

;------------------------------------------------------------------------------
;
;   Step to the next phase of the test.  First we will re-load ES:DI to point
;   to the drive parameter table.
;
;------------------------------------------------------------------------------

	les	di, DWORD PTR [bp.Test_Param_Off]

	inc	[bp.Test_Loop_Phase]
	cmp	[bp.Test_Loop_Phase], 3
	jb	WD_VD_Do_Next_Test

;------------------------------------------------------------------------------
;
;   This is a valid drive.  Return with carry clear.
;
;------------------------------------------------------------------------------

	mov     bx, [bp.Test_Alt_Status_Flag]
	add	sp, SIZE Test_Stack_Frame
	pop	bp
	pop	es
	clc
	ret

;------------------------------------------------------------------------------
;
;   This is NOT a valid drive.
;
;------------------------------------------------------------------------------

WD_VD_Invalid:
        xor     bx, bx                          ;Clear use bits
	mov	cx, [bp.Test_Phase]
	mov	ch, al
	add	sp, SIZE Test_Stack_Frame
	pop	bp
	pop	es
	stc
	ret

EndProc WDCtrl_Validate_Drive


;******************************************************************************
;
;   WD_RMI_Int_13h_Hook
;
;   DESCRIPTION:
;       This stub procedure is only hooked into the Int 13h chain for a
;       very short period of time.  However, if it is called, it will cause
;       a fatal error.  Disk cache programs that do "lazy writes" may wake
;       up on a timer interrupt and attempt to write out a sector.  In this
;       case, we will display an error message and hang the machine.
;
;   ENTRY:
;       Who cares!
;
;   EXIT:
;       Never
;
;   USES:
;       Anything it wants
;
;==============================================================================

BeginProc WD_RMI_Int_13h_Hook

IFDEF SETUP
	mov   ax, DGROUP	; Set up DS, ES to our data segment before
	mov   ds, ax		; calling the display error routine.
	mov   es, ax
	mov   ss, ax
	mov   sp, 0FFFEh

	mov   ax, ERR_WDCTRL_BAD_SOFTWARE
	push  ax
	call  _WDCtrlHangError
	pop   ax
ELSE
	mov     ah, 9
	mov     dx, OFFSET WD_Incompatible_Sw_Msg
	int     21h
ENDIF

	jmp     $

EndProc WD_RMI_Int_13h_Hook

IFNDEF SETUP
;******************************************************************************
;
;   WD_RMI_Get_Env_String
;
;   DESCRIPTION:
;       Tries to find a given string in the environment.  If the resulting
;       string starts with 'Y', 'y', 'T', 't', or '1', returns nonzero in
;       AX
;
;   ENTRY:
;       ES points to environment
;       SI is string to match
;       CX is length of string to match
;
;   EXIT:
;       AX is nonzero iff string is found and starts with chars above.
;
;   USES:
;       Does not trash ES or other seg regs.  Don't assume anything else!
;
;==============================================================================
BeginProc WD_RMI_Get_Env_String

	xor	di, di                  ;Environment always at zero offset
        mov     dx, si                  ;Save string start in DX
        mov     bx, cx                  ;Save string len in BX

WD_GES_Try_Another_String:
	mov	si, dx                  ;Point to start of compare string
        mov     cx, bx                  ;Restore string len match
	cld
        push    di                      ;Save current position in env seg
	repe cmpsb
	mov	al, es:[di]             ;Get the first char after '='
        pop     di
	jne	SHORT WD_GES_Try_Next_Env_Str

        cmp     al, '1'
        je	SHORT WD_GES_Exit       ;Return nonzero
	and     al, NOT ('a'-'A')       ;Convert to uppercase
	cmp     al, 'Y'
        je	SHORT WD_GES_Exit       ;Return nonzero
        cmp     al, 'T'
        je	SHORT WD_GES_Exit       ;Return nonzero
        xor     ax, ax                  ;Return zero, string found but bad char
	jmp	SHORT WD_GES_Exit

WD_GES_Try_Next_Env_Str:
	xor	cx, cx
	mov	ax, cx
	dec	cx
	repne scasb
	cmp	es:[di], al             ;End of environment?
	jne	WD_GES_Try_Another_String ;No, try next string
                                        ;Return zero, string not found

WD_GES_Exit:
        ret

EndProc WD_RMI_Get_Env_String

ENDIF

IFDEF SETUP
        FASTDISK ENDS
ELSE
        VxD_REAL_INIT_ENDS
ENDIF

IFDEF SETUP
        EndFile MACRO EntryPoint
                END
        ENDM
ELSE
        EndFile MACRO EntryPoint
                END EntryPoint
        ENDM
ENDIF

        EndFile WDCtrl_Real_Mode_Init
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\common\wingrp.c ===
/* wingroup.c - Adds a new Program Manager group to PROGMAN.INI.
 * Roy Harper
 * Copyright (C) Microsoft, 1992
 * June 8, 1992
 *
 * Portions came from DSUSRCH.C by Mike Colee
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <io.h>
#include <dos.h>
#include <errno.h>
#include <disk_io.h>
#include <file_io.h>
#include <fcntl.h>
#include <share.h>

#include <window.h>
#include <alias.h>
#include <install.h>
#include <message.h>

#ifdef	OEM_PROGRAM
	#include <oem.h>
#else
	#include <global.h>
#endif

static struct BPB	Bpb;							/* Bpb from current disk		 */

char *gszGroup                         = "Group";
#define GSZ_GROUP_LEN                    5
char *gszGroupsSection                 = "[Groups]";
char *gszGroupTemplate                 = "Group%d=%s";
char *gszProgmanIni                    = "PROGMAN.INI";
char *gszProgmanTmp                    = "__PGI__.$$$";
char *gszProgmanBak                    = "PROGMAN.BAK";
char *gszWNToolsGrp                    = "WNTOOLS.GRP";
char *gszWinCom                        = "WIN.COM";
char *gszSystemIni                     = "SYSTEM.INI";
char *gszSystemTmp                     = "__SYS__.$$$";
char *gszSystemBak                     = "SYSTEM.BAK";
char *gszVFINTD386                     = "VFINTD.386";
char *gszWinfileIni                    = "WINFILE.INI";
char *gszWinfileTmp                    = "__WFI__.$$$";
char *gszWinfileBak                    = "WINFILE.BAK";
char *gszMstoolsDll                    = "MSTOOLS.DLL";
char *gsz386EnhSection                 = "[386Enh]";
char *gszCommentBegin                  =
    ";======== MS-DOS 6 Setup Modification - Begin ========";
char *gszCommentEnd                    =
    ";======== MS-DOS 6 Setup Modification - End ========";

char *gszRemovalComment                = ";Removed by MS-DOS 6.0 Setup: ";


/* DBCS */
#ifndef DBCS
   #define AnsiPrev(h,p)     ((p)-1)      // AnsiPrev for SBCS
   #define AnsiNext(p)       ((p)+1)      // AnsiNext for SBCS
   #define IsDBCSLeadByte(p) FALSE        // IsDBCSLeadByte for SBCS
   #define OFFSET(x)  (x)
#else
   #define OFFSET(fp) ((PSTR)(LOWORD((DWORD)fp)))
   #ifdef DOSONLY
      #include <dbcs.h>
   #else
      #ifndef WM_USER  // Is Windows.H included ?
         extern int   far pascal IsDBCSLeadByte(unsigned char);
         extern FPUCH far pascal AnsiNext(FPUCH);
         extern FPUCH far pascal AnsiPrev(FPUCH, FPUCH);
      #endif
   #endif
#endif  //DBCS

#ifdef JANUS
int fnIsOs2Win(char *szPath);
#endif

void InstallWNToolsGrp (void);
void InstallVFINTD386 (void);
void InstallMstoolsDll (void);
unsigned AddSectionAndLine (int      fReplace,
                            char     *pszSection,
                            char     *pszLine,
                            char     *szBuffer,
                            unsigned uCharCount);
unsigned MyDeleteLine (char *szBuffer, unsigned uCharCount, char *sz);
unsigned MyInsertLine (char     *szNewString,
                       char     *szBuffer,
                       unsigned uCharCount,
                       char     *sz);
int MyGetFixedDisks (int *piDriveLetters);
int GetFileAttributes (char *pszPathname);
int SetFileAttributes (char *pszPathname, int iAttribute);
int ValidDrive (char bDrive);
int myfnSearchDisk (char *szPath, char *szFile1, char *szFile2,
                    char *szFile3);
char DosGetCurrentDrive (void);
char DosSetCurrentDrive (char bDrive);

int  UniqueRename (char *szFile, char *szNew);


/*********************************************************************
 * InstallWNToolsGrp - Installs WNTOOLS.GRP file in PROGMAN.INI.
 *********************************************************************/

void InstallWNToolsGrp (void)
{
  char     *szIniPath;                /* Path to PROGMAN.INI           */
  char     *szTmpPath;                /* Path to __PGI__.$$$           */
  char     *szGrpPath;                /* Path to WNTOOLS.GRP           */
  char     *szBuffer;                 /* Input/output buffer           */
  char     *sz;                       /* Character pointer             */
  int      fileInput;                 /* Old PROGMAN.INI file handle   */
  int      fileOutput;                /* .TMP output file handle       */
  int      ShareAccess;               /* Share access                  */
  int      fProgmanBakAttr;           /* MS-DOS File attributes        */
  int      fProgmanIniAttr;           /* MS-DOS File attributes        */
  int      iReadValue    = OK;        /* Return value from DosReadLine */
  int      iWriteValue   = OK;        /* Return value from DosWriteLine*/
  int      iMaxGroupNmbr = 0;         /* Highest numbered group        */
  int      iGroupNmbr    = 0;         /* Highest numbered group        */
  int      iGroupCount   = 0;         /* Count of the number of groups */
  int      iBlankLines   = 0;         /* Counts the number of blank    */
                                      /*   lines at the end of the     */
                                      /*   [Groups] section.           */


  /* Create the path to PROGMAN.INI */
  szIniPath = GetMemory (MAX_PATH_LEN);
  strcpy (szIniPath, vInfo.szWinPath);
  mycatpath (szIniPath, gszProgmanIni);


  /* Create the path to __PGI__.$$$ */
  szTmpPath = GetMemory (MAX_PATH_LEN);

  /* Determine if the Windows directory is on the destination drive */
  if (vInfo.szWinPath[0] == vInfo.szTmpDir[0])
    strcpy (szTmpPath, vInfo.szTmpDir);
  else
    strcpy (szTmpPath, vInfo.szWinPath);

  mycatpath (szTmpPath, gszProgmanTmp);


  /* Create the path to WNTOOLS.GRP */
  szGrpPath = GetMemory (MAX_PATH_LEN);
  strcpy (szGrpPath, vInfo.szPath);
  mycatpath (szGrpPath, gszWNToolsGrp);


  /* Add the group to the PROGMAN.INI file */
  if (_osmajor < 3  || (_osmajor == 3 && _osminor < 10))
    ShareAccess = O_RDONLY;
  else
    ShareAccess = SH_DENYWR;


  {
    int iRetVal;    /* Return codes from _dos_open */

    /* Open PROGMAN.INI for input and __PGI__.$$$ for output */
    if ((iRetVal = _dos_open (szIniPath, ShareAccess, &fileInput)) != OK ||
        (_dos_creat (szTmpPath, 0, &fileOutput)) != OK)
      {
        char  *apszError[PROGMAN_INI_ERROR_LINES]; /* error message string array */

        GetMessage (apszError, PROGMAN_INI_ERROR_TEXT);
        Error (apszError);

        /* Close the files that were opened */
        if (iRetVal == OK)
          _dos_close (fileInput);

        FreeMemory (szIniPath);
        FreeMemory (szTmpPath);
        FreeMemory (szGrpPath);

        return;
      }
  }

  /* Allocate space for the buffer */
  szBuffer = GetMemory (MAX_PROGMAN_INI_LINE_LEN + 1);

  /* Find the section */
  if (MyFindSection (gszGroupsSection, fileInput, fileOutput) != TRUE)
    {
      while (iWriteValue == OK &&
             (iReadValue = DosReadLine (szBuffer, MAX_PROGMAN_INI_LINE_LEN,
                               fileInput)) == OK && szBuffer[0] != '[')
        {
          /* Check to see if the WNTOOLS.GRP file is already mentioned */
          if ((sz = strchr (szBuffer, '=')) != NULL &&
               stricmp (++sz, szGrpPath) == 0)
            {
              /* If the existing PROGMAN.INI mentions our .GRP file */
              /*   we don't have to change PROGMAN.INI.             */

              /* Close the files */
              _dos_close (fileInput);
              _dos_close (fileOutput);

              /* Delete __PGI__.$$$ */
              AbsUnlink (szTmpPath);

              /* Free up szBuffer */
              FreeMemory (szBuffer);
              FreeMemory (szIniPath);
              FreeMemory (szTmpPath);
              FreeMemory (szGrpPath);

              return;
            }

          /* Count up the blank lines */
          if (szBuffer[0])
            {
              /* Write out the pending blank lines */
              while (iBlankLines > 0 && iWriteValue == OK)
                {
                  --iBlankLines;
                  iWriteValue = DosWriteLine (NULL, fileOutput);
                }

              /* Write out the line right away */
              if (iWriteValue == OK)
                iWriteValue = DosWriteLine (szBuffer, fileOutput);

              iBlankLines = 0;

              /* Check for error */
              if (iWriteValue)
                break;
            }
          else
            ++iBlankLines;

          /* Ignore blank lines or lines beginning with a semi-colon */
          if (szBuffer[0] == '\0' || szBuffer[0] == ';')
            continue;

          /* Is this a "Group%d" line? */
          if (strnicmp (gszGroup, szBuffer, GSZ_GROUP_LEN) == 0)
            {
              ++iGroupCount;

              /* Find the highest numbered group */
              iGroupNmbr = max (atoi (&szBuffer[GSZ_GROUP_LEN]), iGroupNmbr);
            }
        }

      /* If we just read a new section, unread the line */
      if (iReadValue == OK && szBuffer[0] == '[')
        DosUnreadLine (szBuffer);

      /* We have reached the end of the section -- Write our group line, */
      /*   but only if Program Manager isn't at it's limit already       */
      if (iGroupCount < MAX_PROGRAM_MANAGER_GROUPS)
        {
          if (iWriteValue == OK)
            iWriteValue = DosWriteLine (gszCommentBegin, fileOutput);

          /* Write the group line */
          sprintf (szBuffer, gszGroupTemplate, iGroupNmbr + 1, szGrpPath);
          if (iWriteValue == OK)
            iWriteValue = DosWriteLine (szBuffer, fileOutput);

          if (iWriteValue == OK)
            iWriteValue = DosWriteLine (gszCommentEnd, fileOutput);
        }

      /* Write out the pending blank lines */
      while (iBlankLines > 0 && iWriteValue == OK)
        {
          --iBlankLines;
          iWriteValue = DosWriteLine (NULL, fileOutput);
        }

      /* Copy the rest of the PROGMAN.INI file through */
      while ((DosReadLine (szBuffer, MAX_PROGMAN_INI_LINE_LEN, fileInput)) == OK &&
             iWriteValue == OK)
        iWriteValue = DosWriteLine (szBuffer, fileOutput);
    }
  else
    {
      /* A [Groups] section was not found.  Add one. */
      if (iWriteValue == OK)
        iWriteValue = DosWriteLine (NULL, fileOutput);

      if (iWriteValue == OK)
        iWriteValue = DosWriteLine (gszCommentBegin, fileOutput);

      if (iWriteValue == OK)
        iWriteValue = DosWriteLine (gszGroupsSection, fileOutput);

      /* Add the group */
      sprintf (szBuffer, gszGroupTemplate, 1, szGrpPath);
      if (iWriteValue == OK)
        iWriteValue = DosWriteLine (szBuffer, fileOutput);

      if (iWriteValue == OK)
        iWriteValue = DosWriteLine (gszCommentEnd, fileOutput);
    }

  /* Close the files */
  _dos_close (fileInput);
  _dos_close (fileOutput);


  /* If a write error occured, give an error message */
  if (iWriteValue)
    {
      char  *apszError[PROGMAN_INI_ERROR_LINES]; /* error message string array */

      /* Delete __PGI__.$$$ */
      AbsUnlink (szTmpPath);

      GetMessage (apszError, PROGMAN_INI_ERROR_TEXT);
      Error (apszError);
    }
  else
    {
      if (vInfo.szWinPath[0] == vInfo.szTmpDir[0])
        {
          /* .INI file IS on the destination drive */
          if ((UniqueRename (szIniPath, NULL)    != OK) ||
              ReplaceFile (szTmpPath, szIniPath) != OK)
            ProcessCopyError (szIniPath, ERR_RENAMING);
        }
      else /* .INI file IS NOT on the destination drive */
        {
          /* Create the path to PROGMAN.BAK */
          strcpy (szBuffer, szIniPath);
          myfnTruncFN (szBuffer);
          mycatpath (szBuffer, gszProgmanBak);

          /* Get System, Hidden, and Read-only bits */
          fProgmanBakAttr = GetFileAttributes (szBuffer);

          /* Delete PROGMAN.BAK */
          AbsUnlink (szBuffer);

          /* Rename PROGMAN.INI to PROGMAN.BAK */
          fProgmanIniAttr = GetFileAttributes (szIniPath);
          if (fProgmanIniAttr != -1)
            SetFileAttributes (szIniPath, fProgmanIniAttr & 0xF8);
          rename (szIniPath, szBuffer);
          if (fProgmanBakAttr != -1)
            SetFileAttributes (szIniPath, fProgmanBakAttr);

          /* Rename __PGI__.$$$ to PROGMAN.INI */
          rename (szTmpPath, szIniPath);

          /* Make the new PROGMAN.INI's file attributes match the original's */
          if (fProgmanIniAttr != -1)
            SetFileAttributes (szBuffer, fProgmanIniAttr);
        }
    }

  /* Free up szBuffer */
  FreeMemory (szBuffer);
  FreeMemory (szIniPath);
  FreeMemory (szTmpPath);
  FreeMemory (szGrpPath);
}


/*********************************************************************
 * InstallVFINTD386 - Installs VFINTD.386 in SYSTEM.INI.
 *********************************************************************/

void InstallVFINTD386 (void)
{
  char     *apszVxd[VXD_REMOVAL_LIST_LINES]; /* VxDs to remove         */
  char     *szIniPath;                /* Path to SYSTEM.INI            */
  char     *szTmpPath;                /* Path to __SYS__.$$$           */
  char     *szDevPath;                /* Path to VFINTD.386            */
  char     *szBuffer;                 /* Input/output buffer           */
  char     *sz;                       /* Character pointer             */
  int      u;                         /* Index variable                */
  int      fileInput;                 /* Old SYSTEM.INI file handle    */
  int      fileOutput;                /* .TMP output file handle       */
  int      ShareAccess;               /* Share access                  */
  int      fSystemBakAttr;            /* MS-DOS File attributes        */
  int      fSystemIniAttr;            /* MS-DOS File attributes        */
  int      iCommentBeginLen;          /* Length of gszCommentBegin     */
  int      iCommentEndLen;            /* Length of gszCommentEnd       */
  int      iReadValue  = OK;          /* Return value from DosReadLine */
  int      iWriteValue = OK;          /* Return value from DosWriteLine*/
  int      iBlankLines = 0;           /* Counts the number of blank    */
                                      /*   lines at the end of the     */
                                      /*   [Groups] section.           */


  /* Set the lengths */
  iCommentBeginLen = strlen (gszCommentBegin);
  iCommentEndLen   = strlen (gszCommentEnd);


  /* Create the path to SYSTEM.INI */
  szIniPath = GetMemory (MAX_PATH_LEN);
  strcpy (szIniPath, vInfo.szWinPath);
  mycatpath (szIniPath, gszSystemIni);


  /* Create the path to __SYS__.$$$ */
  szTmpPath = GetMemory (MAX_PATH_LEN);

  /* Determine if the Windows directory is on the destination drive */
  if (vInfo.szWinPath[0] == vInfo.szTmpDir[0])
    strcpy (szTmpPath, vInfo.szTmpDir);
  else
    strcpy (szTmpPath, vInfo.szWinPath);

  mycatpath (szTmpPath, gszSystemTmp);


  /* Create the path to VFINTD.386 */
  szDevPath = GetMemory (MAX_PATH_LEN);
  strcpy (szDevPath, vInfo.szPath);
  mycatpath (szDevPath, gszVFINTD386);


  /* Add the device driver to the SYSTEM.INI file */
  if (_osmajor < 3  || (_osmajor == 3 && _osminor < 10))
    ShareAccess = O_RDONLY;
  else
    ShareAccess = SH_DENYWR;


  {
    int iRetVal;    /* Return codes from _dos_open */

    /* Open SYSTEM.INI for input and __SYS__.$$$ for output */
    if ((iRetVal = _dos_open (szIniPath, ShareAccess, &fileInput)) != OK ||
        (_dos_creat (szTmpPath, 0, &fileOutput)) != OK)
      {
        char  *apszError[SYSTEM_INI_ERROR_LINES];

        GetMessage (apszError, SYSTEM_INI_ERROR_TEXT);
        Error (apszError);

        /* Close the files that were opened */
        if (iRetVal == OK)
          _dos_close (fileInput);

        FreeMemory (szIniPath);
        FreeMemory (szTmpPath);
        FreeMemory (szDevPath);

        return;
      }
  }

  /* Allocate space for the buffer */
  szBuffer = GetMemory (MAX_SYSTEM_INI_LINE_LEN + 1);

  /* Find the section */
  if (MyFindSection (gsz386EnhSection, fileInput, fileOutput) != TRUE)
    {
      /* Add the lines for the Windows Backup .VxD */
      if (iWriteValue == OK)
        iWriteValue = DosWriteLine (gszCommentBegin, fileOutput);
      strcpy (szBuffer, "device=");
      strcat (szBuffer, szDevPath);
      if (iWriteValue == OK)
        iWriteValue = DosWriteLine (szBuffer, fileOutput);
      if (iWriteValue == OK)
        iWriteValue = DosWriteLine (gszCommentEnd, fileOutput);

      /* Get the list of .VxDs to remove */
      GetMessage (apszVxd, VXD_REMOVAL_LIST_TEXT);


      /* Now, go through the rest of the [386Enh] section */
      /*   removing lines that must be removed.           */
      while (iWriteValue == OK &&
             (iReadValue =
                  DosReadLine (szBuffer, MAX_SYSTEM_INI_LINE_LEN,
                               fileInput)) == FALSE && szBuffer[0] != '[')
        {
          /* Check for MS-DOS 6.0's "do not modify" comment lines */
          if (strnicmp (szBuffer, gszCommentBegin, iCommentBeginLen) == 0)
            {
              /* Remove all lines between these comment lines */
              while (iReadValue == OK &&
                     (iReadValue =
                          DosReadLine (szBuffer, MAX_SYSTEM_INI_LINE_LEN,
                                       fileInput)) == FALSE &&
                      strnicmp (szBuffer, gszCommentEnd, iCommentEndLen) != 0)
                ;

              /* Display an error message if we didn't find */
              /*   a matching line before the end of file   */
              if (iReadValue != OK)
                {
                  char  *apszError[SYSTEM_INI_MODIFIED_ERROR_LINES];

                  /* Close the files */
                  _dos_close (fileInput);
                  _dos_close (fileOutput);

                  /* Delete __SYS__.$$$ */
                  AbsUnlink (szTmpPath);

                  /* Free up szBuffer */
                  FreeMemory (szBuffer);
                  FreeMemory (szIniPath);
                  FreeMemory (szTmpPath);
                  FreeMemory (szDevPath);

                  GetMessage (apszError, SYSTEM_INI_MODIFIED_ERROR_TEXT);
                  Error (apszError);

                  return;
                }
              else
                /* Continue reading lines */
                continue;
            }


          /* Check for .VxDs that have to be removed */

          /* Skip whitespace */
          u = strspn (szBuffer, " \t");
          sz = &szBuffer[u];

          if (strnicmp (sz, "device", 6) == 0)
            {
              /* Skip whitespace after "device" */
              sz += 6;
              sz += strspn (sz, " \t");

              /* Check for an '=' sign */
              if ((sz = strchr (sz, '=')) != NULL)
                {
                  int  i;                   /* Looping variable */
                  int  fRemoveLine = FALSE; /* TRUE when line must be removed */
                  char szBuffer1[MAX_SYSTEM_INI_LINE_LEN];
                  char szVxdPath[MAX_SYSTEM_INI_LINE_LEN]; /* Identifies .VxD */
                  char *pszVxdPath;         /* Used as character pointer */


                  /* Skip whitespace after the '=' sign */
                  ++sz;
                  sz += strspn (sz, " \t");

                  /* Copy the .VxD pathname */
                  strcpy (szVxdPath, sz);
                  pszVxdPath = &szVxdPath[0];

                  /* Remove extraneous characters */
                  u = strcspn (pszVxdPath, "/,; \t");
                  if (u)
                    pszVxdPath[u] = '\0';

                  /* Look for the last colon or backslash */
                  if (strrchr (pszVxdPath, ':'))
                    pszVxdPath = strrchr (pszVxdPath, ':') + 1;
                  if (strrchr (pszVxdPath, '\\'))
                    pszVxdPath = strrchr (pszVxdPath, '\\') + 1;

                  /* pszVxdPath now points to the filename. */
                  /*   Check the removal list               */
                  for (i = 0; apszVxd[i] != NULL && fRemoveLine == FALSE; ++i)
                    {
                      if (stricmp (pszVxdPath, apszVxd[i]) == 0)
                        fRemoveLine = TRUE;
                    }

                  /* If this line is to be removed, comment the line out */
                  if (fRemoveLine == TRUE)
                    {
                      strcpy (szBuffer1, gszRemovalComment);
                      strcat (szBuffer1, szBuffer);
                      strcpy (szBuffer, szBuffer1);
                      fRemoveLine = FALSE;
                    }
                }
            }

          /* Write out the line */
          if (iWriteValue == OK)
            iWriteValue = DosWriteLine (szBuffer, fileOutput);
        }

      /* If we just read a new section, unread the line */
      if (iReadValue == OK && szBuffer[0] == '[')
        DosUnreadLine (szBuffer);

      /* Write out the pending blank lines */
      while (iBlankLines > 0 && iWriteValue == OK)
        {
          --iBlankLines;
          iWriteValue = DosWriteLine (NULL, fileOutput);
        }

      /* Copy the rest of the SYSTEM.INI file through */
      while ((DosReadLine (szBuffer, MAX_SYSTEM_INI_LINE_LEN, fileInput)) == OK &&
             iWriteValue == OK)
        iWriteValue = DosWriteLine (szBuffer, fileOutput);
    }

  /* Close the files */
  _dos_close (fileInput);
  _dos_close (fileOutput);

  /* If an error occured, give an error message */
  if (iWriteValue)
    {
      char  *apszError[SYSTEM_INI_ERROR_LINES];


      /* Delete __SYS__.$$$ */
      AbsUnlink (szTmpPath);

      GetMessage (apszError, SYSTEM_INI_ERROR_TEXT);
      Error (apszError);
    }
  else
    {
      if (vInfo.szWinPath[0] == vInfo.szTmpDir[0])
        {
          /* .INI file IS on the destination drive */
          if ((UniqueRename (szIniPath, NULL)    != OK) ||
              ReplaceFile (szTmpPath, szIniPath) != OK)
            ProcessCopyError (szIniPath, ERR_RENAMING);
        }
      else /* .INI file IS NOT on the destination drive */
        {
          /* Create the path to SYSTEM.BAK */
          strcpy (szBuffer, szIniPath);
          myfnTruncFN (szBuffer);
          mycatpath (szBuffer, gszSystemBak);

          /* Get System, Hidden, and Read-only bits */
          fSystemBakAttr = GetFileAttributes (szBuffer);

          /* Delete SYSTEM.BAK */
          AbsUnlink (szBuffer);

          /* Rename SYSTEM.INI to SYSTEM.BAK */
          fSystemIniAttr = GetFileAttributes (szIniPath);
          if (fSystemIniAttr != -1)
            SetFileAttributes (szIniPath, fSystemIniAttr & 0xF8);
          rename (szIniPath, szBuffer);
          if (fSystemBakAttr != -1)
            SetFileAttributes (szIniPath, fSystemBakAttr);

          /* Rename __SYS__.$$$ to SYSTEM.INI */
          rename (szTmpPath, szIniPath);

          /* Make the new SYSTEM.INI's file attributes match the original's */
          if (fSystemIniAttr != -1)
            SetFileAttributes (szBuffer, fSystemIniAttr);
        }
    }

  /* Free up szBuffer */
  FreeMemory (szBuffer);
  FreeMemory (szIniPath);
  FreeMemory (szTmpPath);
  FreeMemory (szDevPath);
}


#define MAX_INI_FILE_LEN  (65536 - 48)
#define ADD_TO            1
#define REPLACE_LINE_TYPE 2

/*********************************************************************
 * InstallMstoolsDll - Installs MSTOOLS.DLL into WINFILE.INI file.
 *********************************************************************/

void InstallMstoolsDll (void)
{
  char     *szIniPath;                /* Path to WINFILE.INI            */
  char     *szTmpPath;                /* Path to __WFI__.$$$            */
  char     *szDllPath;                /* Path to MSTOOLS.DLL            */
  char     *szBuffer;                 /* Buffer for holding WINFILE.INI */
  char     *sz;                       /* Character pointer              */
  int      fileInput;                 /* Old WINFILE.INI file handle    */
  int      fileOutput;                /* .TMP output file handle        */
  int      ShareAccess;               /* Share access                   */
  int      fWinfileBakAttr;           /* MS-DOS File attributes         */
  int      fWinfileIniAttr;           /* MS-DOS File attributes         */
  unsigned uLen;                      /* String length (+ 1)            */
  int      iReturnValue = OK;         /* Return value from DosReadLine  */
  unsigned uCharCount   = 0;          /* Count of characters in file    */
  int      iRetVal;    /* Return codes from _dos_open */


  /* Create the path to WINFILE.INI */
  szIniPath = GetMemory (MAX_PATH_LEN);
  strcpy (szIniPath, vInfo.szWinPath);
  mycatpath (szIniPath, gszWinfileIni);


  /* Create the path to __WFI__.$$$ */
  szTmpPath = GetMemory (MAX_PATH_LEN);

  /* Determine if the Windows directory is on the destination drive */
  if (vInfo.szWinPath[0] == vInfo.szTmpDir[0])
    strcpy (szTmpPath, vInfo.szTmpDir);
  else
    strcpy (szTmpPath, vInfo.szWinPath);

  mycatpath (szTmpPath, gszWinfileTmp);


  /* Create the path to MSTOOLS.DLL */
  szDllPath = GetMemory (MAX_PATH_LEN);
  strcpy (szDllPath, vInfo.szPath);
  mycatpath (szDllPath, gszMstoolsDll);


  /* Add the lines to the WINFILE.INI file */
  if (_osmajor < 3  || (_osmajor == 3 && _osminor < 10))
    ShareAccess = O_RDONLY;
  else
    ShareAccess = SH_DENYWR;


  /* Read the file */
  {

    /* Open WINFILE.INI for input.  File may not exist. */
    iRetVal = _dos_open (szIniPath, ShareAccess, &fileInput);
    if ( (iRetVal != OK) && (iRetVal != ENOENT) )
      {
        char  *apszError[WINFILE_INI_ERROR_LINES];

        GetMessage (apszError, WINFILE_INI_ERROR_TEXT);
        Error (apszError);

        /* Close the files that were opened */
        if (iRetVal == OK)
          _dos_close (fileInput);

        FreeMemory (szIniPath);
        FreeMemory (szTmpPath);
        FreeMemory (szDllPath);

        return;
      }
  }


  /* Read the file */

  /* Allocate space for WINFILE.INI's text */
  szBuffer = GetMemory (MAX_INI_FILE_LEN);
  sz = szBuffer;

  if (iRetVal != ENOENT)
  {
      while ((iReturnValue = DosReadLine (sz, MAX_SYSTEM_INI_LINE_LEN,
                                          fileInput)) == FALSE)
        {
          uLen = strlen (sz) + 1;
          sz += uLen;
          uCharCount += uLen;

          /* Break out if there isn't enough memory */
          if ((long) uCharCount + (long) MAX_SYSTEM_INI_LINE_LEN >
              (long) MAX_INI_FILE_LEN)
            {
              char  *apszError[WINFILE_INI_ERROR_LINES];

              GetMessage (apszError, WINFILE_INI_ERROR_TEXT);
              Error (apszError);

              /* Close the file */
              _dos_close (fileInput);

              FreeMemory (szIniPath);
              FreeMemory (szTmpPath);
              FreeMemory (szDllPath);
              FreeMemory (szBuffer);

              return;
            }
        }


      /* Close the input file */
      _dos_close (fileInput);
  }

  /* Make the edits */

  {
    char szNewLine[MAX_SYSTEM_INI_LINE_LEN];    /* sprintf buffer     */
    char szNewPath[MAX_PATH_LEN];               /* DOS path workspace */
    char *apszAddOns[WINFILE_ADDONS_LINES];     /* [AddOns] strings   */
    char *apszSettings[WINFILE_SETTINGS_LINES]; /* [Settings] strings */


    /* Get the strings */
    GetMessage (apszAddOns, WINFILE_ADDONS_TEXT);
    GetMessage (apszSettings, WINFILE_SETTINGS_TEXT);


    /* [AddOns] section */

    /* Create the path to the .DLL */
    strcpy (szNewPath, vInfo.szPath);
    mycatpath (szNewPath, apszAddOns[2]);

    /* Create the line to be added */
    sprintf (szNewLine, apszAddOns[1], szNewPath);

    /* Add the line */
    uCharCount = AddSectionAndLine (REPLACE_LINE_TYPE, apszAddOns[0],
                                    szNewLine, szBuffer, uCharCount);


    /* [Settings] section */

    /* Create the path to the .DLL */
    strcpy (szNewPath, vInfo.szPath);
    mycatpath (szNewPath, apszSettings[2]);

    /* Create the line to be added */
    sprintf (szNewLine, apszSettings[1], szNewPath);

    /* Add the line */
    uCharCount = AddSectionAndLine (REPLACE_LINE_TYPE, apszSettings[0],
                                    szNewLine, szBuffer, uCharCount);
  }


  /* Write the file */

  {
    /* Open WINFILE.INI for input */
    if ((_dos_creat (szTmpPath, 0, &fileOutput)) != OK)
      {
        char  *apszError[WINFILE_INI_ERROR_LINES];

        GetMessage (apszError, WINFILE_INI_ERROR_TEXT);
        Error (apszError);

        /* Close the file */
        _dos_close (fileOutput);

        FreeMemory (szIniPath);
        FreeMemory (szTmpPath);
        FreeMemory (szDllPath);
        FreeMemory (szBuffer);

        return;
      }

    /* Write the lines */
    sz = szBuffer;
    iReturnValue = OK;
    while (sz < &szBuffer[uCharCount] && iReturnValue == OK)
      {
        iReturnValue = DosWriteLine (sz, fileOutput);
        sz += strlen (sz) + 1;
      }
  }

  /* Close the file */
  _dos_close (fileOutput);

  /* If an error occured, give an error message */
  if (iReturnValue)
    {
      char  *apszError[WINFILE_INI_ERROR_LINES];


      /* Delete __WFI__.$$$ */
      AbsUnlink (szTmpPath);

      GetMessage (apszError, WINFILE_INI_ERROR_TEXT);
      Error (apszError);
    }
  else
    {
      if (vInfo.szWinPath[0] == vInfo.szTmpDir[0])
        {
          /* .INI file IS on the destination drive */
          if ((UniqueRename (szIniPath, NULL)    != OK) ||
              ReplaceFile (szTmpPath, szIniPath) != OK)
            ProcessCopyError (szIniPath, ERR_RENAMING);
        }
      else /* .INI file IS NOT on the destination drive */
        {
          /* Create the path to WINFILE.BAK */
          strcpy (szBuffer, szIniPath);
          myfnTruncFN (szBuffer);
          mycatpath (szBuffer, gszWinfileBak);

          /* Get System, Hidden, and Read-only bits */
          fWinfileBakAttr = GetFileAttributes (szBuffer);

          /* Delete WINFILE.BAK */
          AbsUnlink (szBuffer);

          /* Rename WINFILE.INI to WINFILE.BAK */
          fWinfileIniAttr = GetFileAttributes (szIniPath);
          if (fWinfileIniAttr != -1)
            SetFileAttributes (szIniPath, fWinfileIniAttr & 0xF8);
          rename (szIniPath, szBuffer);
          if (fWinfileBakAttr != -1)
            SetFileAttributes (szIniPath, fWinfileBakAttr);

          /* Rename __WFI__.$$$ to WINFILE.INI */
          rename (szTmpPath, szIniPath);

          /* Make the new WINFILE.INI's file attributes match the original's */
          if (fWinfileIniAttr != -1)
            SetFileAttributes (szBuffer, fWinfileIniAttr);
        }
    }

  FreeMemory (szIniPath);
  FreeMemory (szTmpPath);
  FreeMemory (szDllPath);
  FreeMemory (szBuffer);
}


/***********************************************************************
 * AddSectionAndLine - Adds a section line, if the section does not
 *                     already exist, and a line to that section.
 *
 * Arguments: fReplace    - ADD_TO adds the line to the section,
 *                          REPLACE_LINE replaces the first matching item.
 *            pszSection  - Section name.  Ie, "[Settings]"
 *            pszLine     - Line to add.  Ie, "UNDELETE.DLL=MSTOOLS.DLL"
 *            szBuffer    - Buffer holding ASCIIZ strings.
 *            uCharCount  - Number of characters in the buffer.
 * Returns:   Void.
 **********************************************************************/

unsigned AddSectionAndLine (int      fReplace,
                            char     *pszSection,
                            char     *pszLine,
                            char     *szBuffer,
                            unsigned uCharCount)
{
  int      fSectionFound;       /* TRUE when section found                */
  int      fEndOfSectionFound;  /* TRUE when end of section found         */
  int      fLineAlreadyThere;   /* TRUE if our line was already added     */
  char     *sz;                 /* Points to current location             */
  char     *szSectionStart;     /* Locates the start of the section       */
  char     szLineType[MAX_SYSTEM_INI_LINE_LEN]; /* Stores "device=", etc. */


  /* Get the line type */
  if (fReplace == REPLACE_LINE_TYPE)
    {
      int u;   /* Index to szLineType */

      /* Skip whitespace */
      sz = pszLine;
      sz += strspn (sz, " \t");
      strcpy (szLineType, sz);

      /* Check for ' ', '\t', '=', and ';' */
      if ((u = strcspn (szLineType, " \t=;")) != 0)
        szLineType[u] = '\0';
    }


  fSectionFound = FALSE;
  sz = szBuffer;

  while (fSectionFound == FALSE && sz < &szBuffer[uCharCount])
    {
      /* Skip whitespace */
      sz += strspn (sz, " \t");

      /* Check for our section */
      if (strnicmp (sz, pszSection, strlen (pszSection)) == 0)
        fSectionFound = TRUE;

      sz += strlen (sz) + 1;
    }


  /* If the section was found, see if our line already exists */
  if (fSectionFound == TRUE)
    {
      szSectionStart = sz;

      fLineAlreadyThere  = FALSE;
      fEndOfSectionFound = FALSE;

      while (fEndOfSectionFound == FALSE && sz < &szBuffer[uCharCount])
        {
          /* Skip whitespace */
          sz += strspn (sz, " \t");

          /* Check for a new section */
          if (*sz == '[')
            fEndOfSectionFound == TRUE;
          else
            {
              /* Check for an exact duplicate */
              if (stricmp (sz, pszLine) == 0)
                {
                  fLineAlreadyThere = TRUE;
                  break;
                }
              else if (fReplace == REPLACE_LINE_TYPE &&
                       strnicmp (sz, szLineType, strlen (szLineType)) == 0)
                {
                  char szString[MAX_SYSTEM_INI_LINE_LEN];


                  /* Create the commented out the line */
                  strcpy (szString, gszRemovalComment);
                  strcat (szString, sz);

                  /* Remove the original line */
                  uCharCount = MyDeleteLine (szBuffer, uCharCount, sz);

                  /* Insert the commented out line */
                  uCharCount = MyInsertLine (szString, szBuffer,
                                             uCharCount, sz);

                  /* Break out */
                  break;
                }
            }

          /* Point to the next line */
          sz += strlen (sz) + 1;
        }

      /* Add the line if it wasn't there already */
      if (fLineAlreadyThere == FALSE)
        {
          sz = szSectionStart;

          uCharCount = MyInsertLine (gszCommentBegin, szBuffer, uCharCount, sz);
          sz += strlen (sz) + 1;

          uCharCount = MyInsertLine (pszLine, szBuffer, uCharCount, sz);
          sz += strlen (sz) + 1;

          uCharCount = MyInsertLine (gszCommentEnd, szBuffer, uCharCount, sz);
          sz += strlen (sz) + 1;
        }
    }
  else  /* The section was not found */
    {
      /* Add the section and our line */

      sz = &szBuffer[uCharCount];

      /* Blank line */
      uCharCount = MyInsertLine ("", szBuffer, uCharCount, sz);
      sz += strlen (sz) + 1;

      uCharCount = MyInsertLine (gszCommentBegin, szBuffer, uCharCount, sz);
      sz += strlen (sz) + 1;

      /* Section string */
      uCharCount = MyInsertLine (pszSection, szBuffer, uCharCount, sz);
      sz += strlen (sz) + 1;

      /* Actual line */
      uCharCount = MyInsertLine (pszLine, szBuffer, uCharCount, sz);
      sz += strlen (sz) + 1;

      uCharCount = MyInsertLine (gszCommentEnd, szBuffer, uCharCount, sz);
      sz += strlen (sz) + 1;
    }

  /* Return the new character count */
  return (uCharCount);
}


/***********************************************************************
 * MyDeleteLine - Removes a line from the buffer, and moves the rest of
 *                the buffer down to fill in the empty space.
 *
 * Arguments: szBuffer   - Points to the start of the buffer.
 *            uCharCount - Total number of characters in the buffer.
 *            sz         - Points to line to be deleted.
 * Returns:   Void.
 **********************************************************************/

unsigned MyDeleteLine (char *szBuffer, unsigned uCharCount, char *sz)
{
  unsigned uLen;        /* sz string length plus 1 */
  unsigned uMoveCount;  /* Number of bytes to move */
  char *szAfter;        /* Point to the line after this line */


  uLen = strlen (sz) + 1;

  /* Point to the character beyond the line to be deleted */
  szAfter = sz + uLen;

  /* Calculate the number of bytes to move */
  uMoveCount = uCharCount - (szAfter - szBuffer);

  /* Pull everything over the line to be deleted */
  if (uMoveCount)
    memmove (sz, szAfter, uMoveCount);

  /* Return the new character count */
  return (uCharCount - uLen);
}


/***********************************************************************
 * MyInsertLine - Removes a line from the buffer, and moves the rest of
 *                the buffer down to fill in the empty space.
 *
 * Arguments: szNewLine  - Line to be added to the buffer.
 *            szBuffer   - Points to the start of the buffer.
 *            uCharCount - Total number of characters in the buffer.
 *            sz         - Points to line to be deleted.
 * Returns:   Void.
 **********************************************************************/

unsigned MyInsertLine (char     *szNewLine,
                       char     *szBuffer,
                       unsigned uCharCount,
                       char     *sz)
{
  unsigned uLen;        /* szNewLine string length plus 1 */
  unsigned uMoveCount;  /* Number of bytes to move */
  char *szNew;          /* Point to the new location of the lines */
                        /*   that will be after the new line */


  uLen = strlen (szNewLine) + 1;

  /* Point to the character beyond where the new line will be inserted */
  szNew = sz + uLen;

  /* Calculate the number of bytes to move */
  uMoveCount = uCharCount - (sz - szBuffer);

  /* Move everything out of the way */
  if (uMoveCount)
    memmove (szNew, sz, uMoveCount);

  /* Put the line into place */
  strcpy (sz, szNewLine);

  /* Return the new character count */
  return (uCharCount + uLen);
}


/* int myfnSearchForOldWin3 (char *szWinPath, char *szFile1, char *szFile2,
 *                         char *szFile3);
 *
 * Function will search the given path for the file(s) defined by szFile1,
 *     szFile2, and szFile3.
 *
 * ENTRY: szWinPath   - Pointer to buffer in which path will be returned.
 *        szFile1/2/3 - Files to search for -- files that are in a Windows
 *                      3.0+ directory.
 *
 * EXIT: int --> TRUE == File(s) found. FALSE == File(s) not found.
 */
int myfnSearchForOldWin3 (char *szWinPath, char *szFile1, char *szFile2,
                        char *szFile3)
{
   unsigned          Disks[26];
   unsigned          uNumDisks;
   register unsigned i;
   int               nRetVal = FALSE;  // Init to oldwin not found.
   int               nFoundType;

   /* Search rules:
    *
    *    1) Search path first.
    *    2) Search each local fixed disk entirely (depth-wise search).
    */

   /* Tell int 24h handler were searching in case our customer puts a
    * floppy on the path or joins a floppy.
    */
   gbPathSearch = TRUE;

   /* Search path. */
   _searchenv(szFile1, "PATH", szWinPath);

   if (szWinPath[0])
   {
      myfnTruncFN(szWinPath);

#ifdef JANUS
      if ( fnIsOs2Win(szWinPath) == TRUE )
          ;
      else
#endif

      /* Check to see if szFile2 exists */
      if (szFile2[0])
      {
          mycatpath (szWinPath, szFile2);

          if (access (szWinPath, 00))
              nRetVal = FALSE;
          else
              nRetVal = TRUE;

          myfnTruncFN(szWinPath);
      }

      /* Check to see if szFile3 exists */
      if (nRetVal && szFile3[0])
      {
          mycatpath (szWinPath, szFile3);

          if (access (szWinPath, 00))
              nRetVal = FALSE;
          else
              nRetVal = TRUE;

          myfnTruncFN(szWinPath);
      }
   }

   if (nRetVal)
   {
      /* Tell Int24h handler we're done searching. */
      gbPathSearch = FALSE;
      return nRetVal;
   }

   /* Search each local fixed disk entirely (depth-wise search). */

   uNumDisks = MyGetFixedDisks(Disks);

   for (i = 0; i < uNumDisks; i++)
   {
      szWinPath[0] = (char)(Disks[i] + 'A');
      szWinPath[1] = ':';
      szWinPath[2] = '\\';
      szWinPath[3] = '\0';
      if (nFoundType = myfnSearchDisk (szWinPath, szFile1, szFile2, szFile3))
      {
         myfnTruncFN (szWinPath);
         nRetVal = nFoundType;
         break;
      }
   }

   /* Tell Int24h handler we're done searching. */
   gbPathSearch = FALSE;
   return nRetVal;
}

/* int myfnSearchDisk (char *szPath, char *szFile1, char *szFile2,
 *                   char *szFile3);
 *
 * Function will search the given path for the file defined by szFile1 and
 * szFile2. The function will return the first location where a valid
 * szFile1 and szFile2 is found to exist.
 *
 * ENTRY: szPath      - path to be searched.
 *        szFile1/2/3 - Files to search for -- files that are in a Windows
 *                      3.0+ directory.
 *
 * EXIT: int --> TRUE  == Valid szFile1/2/3 found.
 *               FALSE == Valid szFile1/2/3 not found.
 */
int myfnSearchDisk (char *szPath, char *szFile1, char *szFile2,
                  char *szFile3)
{
   struct find_t MyFCB;     /* Need an FCB for findfirst / findnext. */

   /* Try to locate the file. */

   if (strlen(szPath) >= MAX_PATH_LEN)
   {
      myfnTruncFN(szPath);
      return FALSE;
   }
   mycatpath(szPath, szFile1);

   if (!access (szPath, 00))
   {
#ifdef JANUS
		if ( fnIsOs2Win(szPath) == TRUE )
			;
		else
#endif

      /* Check to see if szFile2 exists */
      if (szFile2[0])
      {
          myfnTruncFN(szPath);
          mycatpath (szPath, szFile2);

          if (!access (szPath, 00))
              return (TRUE);
      }

      /* Check to see if szFile3 exists */
      if (szFile3[0])
      {
          myfnTruncFN(szPath);
          mycatpath (szPath, szFile3);

          if (!access (szPath, 00))
              return (TRUE);
      }
   }

   myfnTruncFN(szPath);
   mycatpath(szPath, "*.*");
   if (_dos_findfirst (szPath, _A_SUBDIR, &MyFCB))
      return FALSE;
   else
   {
      myfnTruncFN(szPath);
      while (TRUE)
      {
         while ((MyFCB.name[0] == '.') || (! (MyFCB.attrib & _A_SUBDIR)))
         {
            if (_dos_findnext (&MyFCB))
            {
               myfnTruncFN(szPath);
               return FALSE;
            }
         }
         mycatpath(szPath, MyFCB.name);

         /* Recurse */
         if (myfnSearchDisk (szPath, szFile1, szFile2, szFile3))
            return TRUE;
         MyFCB.name[0] = '.';
      }
   }
}

/* void myfnTruncFN(PSTR);
 *
 * ENTRY: Pointer to string containing fully qualified file name.
 * EXIT:  Truncates the file name portion of the fully qualified filename.
 *
 * WARNING: Danger ! assumes NULL terminated string. Also assumes it can
 *          Write a NULL char into the buffer pointed to by the func arg.
 *
 */
void myfnTruncFN (char *szPathStr)
{
   register char   *szFile    = szPathStr;
   register char   *BeginChar = szPathStr;

   while ( *szFile != '\0' )   /* Seek end of string. */
      szFile = OFFSET (AnsiNext(szFile));

   /* Ok, seek back till we hit a path char or the begining of the string */

   while ((*szFile != '\\') && (*szFile != '/') && (szFile != BeginChar) && (*szFile != ':'))
      szFile = OFFSET (AnsiPrev(BeginChar,szFile));

   /*  DBCS Note, This is a path were parsing and according to the DBCS ferry, the only
    *  place the character ':' may appear in a path is as a drive seperator. Therefore,
    *  this code will work correctly when DBCS is turned on.
    */
   if (*szFile == ':' || (*(szFile-1) == ':') )
      *(szFile+1) = '\0';
   else
      *szFile = '\0';

}

/* BUGBUG: fnIsOs2Win does not appear necessary for DOSONLY */
#if 0
/* int fnIsOs2Win(char *szWinPath);
 *
 * Function will determine whether the path given by the function argument
 * points to an OS/2 version of windows. We make this determination
 * by looking for unique OS/2 windows files whose names are listed in
 * SETUP.INF.  We only require 1 of the files in the list to be present.
 *
 * ENTRY: szWinPath - Pointer to possible windows path.
 *
 * EXIT: Boolean - TRUE == OS/2 windows, FALSE == Not OS/2 windows.
 *
 *
 */
int fnIsOs2Win(char *szWinPath)
 {
    int   bRet = FALSE;
    int  	iPathLen;
	int	i;
	int	iLines;
	PINF  pinfSect;
	PINF  pinfLine;
	char	szPath[MAX_INF_LINE_LEN];

	if ( (pinfSect = infFindSection( NULL, "winos2" )) == NULL ||
		  (iLines = infLineCount( pinfSect )) == 0 )
		return( bRet );

	pinfLine = pinfSect;

	_fstrcpy( szPath, szWinPath );
	strcat( szPath, "\\" );
   iPathLen = strlen(szPath);

	for ( i=0; i < iLines; i++ )
	{
		infParseField( pinfLine, 1, (LPSTR) &szPath[iPathLen],
							(MAX_INF_LINE_LEN - iPathLen) );

        if (access (szPath, 00))
		{
			bRet = TRUE;
			break;			/* return when first match is found */
		}

		pinfLine = infNextLine(pinfLine);
		szPath[iPathLen] = '\0';
	}

	return( bRet );
}
#else
int fnIsOs2Win(char *szWinPath)
{
    return (FALSE);
}
#endif


/*********************************************************************
 * MyGetFixedDisks - Stores the list of local fixed disks in the array
 *                 pointed to by piDriveLetters.
 *********************************************************************/

int MyGetFixedDisks (int *piDriveLetters)
{
  int i;                /* Looping variable */
  int iIndex = 0;       /* Index to aiDriveLetters array */
  char bLastDrive;      /* Last valid drive */
  char bCurrentDrive;   /* Last valid drive */

  /* Store the current drive number */
  bCurrentDrive = DosGetCurrentDrive();

  /* Determine the last valid drive to check */
  bLastDrive = DosSetCurrentDrive (bCurrentDrive);

  /* Begin counting up the valid drives */
  for (i = 0; i < bLastDrive; ++i)
    {
      if (ValidDrive    ((char) i)     &&
          IsLocalDrive  ((char) i + 1) &&
          !IsRemoveable ((char) i + 1))
        {
          piDriveLetters[iIndex] = i;
          ++iIndex;
        }
    }

  return (iIndex);
}


/*********************************************************************
 * ValidDrive - Determines if this drive number is a valid drive.
 *
 * bDrive - Drive letter to test.
 *
 * Returns:  TRUE if this is a valid drive number.  FALSE if not.
 *********************************************************************/

int ValidDrive (char bDrive)
{
  /* Attempt to make this drive number the current drive */
  DosSetCurrentDrive (bDrive);


  /* Return success or failure */
  if (DosGetCurrentDrive() == bDrive)
    return (TRUE);
  else
    return (FALSE);
}


/*********************************************************************
 * DosGetCurrentDrive - Obtain drive number of the current drive.
 *
 * Returns:  Current drive number.
 *********************************************************************/

char DosGetCurrentDrive (void)
{
  union REGS inregs, outregs;   /* Register structures for int86() */


  /* DOS call to return the current drive number */
  inregs.h.ah = 0x19;
  int86 (0x21, &inregs, &outregs);


  /* Return the current drive letter */
  return (outregs.h.al);
}


/*********************************************************************
 * DosSetCurrentDrive - Sets the current drive to the given drive
 *                      number.
 *
 * bDrive      - Drive number to set as the current drive.
 * wDosVersion - DOS Version (ie 3.20 == 320).
 *
 * Returns:  The highest potentially valid drive letter.  The highest
 *           of 5, LASTDRIVE in CONFIG.SYS, or the highest drive
 *           number in the system.
 *********************************************************************/

char DosSetCurrentDrive (char bDrive)
{
  union REGS inregs, outregs;   /* Register structures for int86() */


  /* DOS call to return the current drive number */
  inregs.h.ah = 0x0e;
  inregs.h.dl = bDrive;
  int86 (0x21, &inregs, &outregs);

  return (outregs.h.al);
}


void mycatpath (char *path, char *sz)
{
    //
    // Remove any drive letters from the directory to append
    //
    if ( sz[1] == ':' )
       sz+=2;

    //
    // Remove any current directories ".\" from directory to append
    //
    while (sz[0] == '.' && SLASH(sz[1]))
		  sz+=2;

	//
	// Remove leading slashes.
	//
	while (SLASH(*sz))
		sz++;

    //
    // Dont append a NULL string or a single "."
    //
    if (*sz && !(sz[0] == '.' && sz[1] == 0))
    {
       if ( (!SLASH(path[strlen(path)-1])) && ((path[strlen(path)-1]) != ':') )
          strcat(path,CHSEPSTR);
       strcat(path,sz);
    }
}


/**********************************************************************
 * GetFileAttributes - Gets a file's MS-DOS attributes
 *
 * pszFilename - Filename
 *
 * Returns: -1 on error.
 **********************************************************************/

int GetFileAttributes (char *pszPathname)
{
  union REGS inregs, outregs;   /* Register values for int86x */
  struct SREGS sregs;           /* Segment register values */
  char far * fszPathname = (char far *) pszPathname;

  inregs.x.ax = 0x4300;
  sregs.ds    = (unsigned) FP_SEG (fszPathname);
  inregs.x.dx = (unsigned) FP_OFF (fszPathname);

  int86x (0x21, &inregs, &outregs, &sregs);

  if (outregs.x.cflag)
    return (-1);
  else
    return (outregs.x.cx);
}


/**********************************************************************
 * SetFileAttributes - Gets a file's MS-DOS attributes
 *
 * pszFilename - Filename
 * iAttribute - New attribute for the file
 *
 * Returns: DOS Error number:
 **********************************************************************/

int SetFileAttributes (char *pszPathname, int iAttribute)
{
  union REGS inregs, outregs;   /* Register values for int86x */
  struct SREGS sregs;           /* Segment register values */
  char far * fszPathname = (char far *) pszPathname;

  inregs.x.ax = 0x4301;
  inregs.x.cx = iAttribute;
  sregs.ds    = (unsigned) FP_SEG (fszPathname);
  inregs.x.dx = (unsigned) FP_OFF (fszPathname);

  int86x (0x21, &inregs, &outregs, &sregs);

  if (outregs.x.cflag)
    return (outregs.x.ax);
  else
    return (0);
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\common\window.c ===
/***************************************************************************/
/*                                                                         */
/*	WINDOW.C																						*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* General windowing functions for the DOS  install                        */
/* program.																						*/
/*                                                                         */
/* Created 03-06-89 - johnhe																*/
/***************************************************************************/

#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>
#include    <dos.h>

#include		<alias.h>
#include 	<bios_io.h>
#include 	<strlib.h>
#include		<window.h>
#include		<disk_io.h>
#include    <data.h>

#include		"message.h" 						/* Must be in current directory */


#ifdef	OEM_PROGRAM
	#include <oem.h>
#else
	#include <global.h>
#endif

#if (UPGRADE_PROGRAM != 0) || (OEM_PROGRAM != 0)
	#include <install.h>
#endif

#ifdef DEBUG	/* ErrorEndPrompt() */
char *DebugContinueMessage="<NORMAL EXIT> DEBUG may continue with 'ENTER'";
#endif

extern unsigned gfCompressedDiskCritSection;

extern int GetChar( void );

#if defined(UPGRADE_PROGRAM) || defined(OEM_PROGRAM)
char * ultoacr (unsigned long, char *, int);
char * ultoac (unsigned long, char *);
#endif

void ReplaceParam (char **apszScreen, char *pszOld, char *pszNew,
                   char *pszBuf, int fKeepLength);

/***************************************************************************/

int	CR_Response[]		= { CR, 0 };		/* M200 */
int	YesNoResponse[]	= { UCASE_YES, LCASE_YES, CR, 0 }; // IPG- ?casey to ?caseyes

static int	IsUpgrade;				/* TRUE for upgrade & FALSE for recovery */

#ifndef	OEM_PROGRAM
	int			CreatingRecovery;			/* Set while creating recovery disk */
#endif

#ifdef DEBUG
char	szDebug[260];	/* Temp. buffer for Debug messages */
#endif

#if (OEM_PROGRAM != 0 || UPGRADE_PROGRAM != 0)
#define EXIT_MSG_TEXT	SETUP_EXIT_TEXT
#define EXIT_MSG_LINES	SETUP_EXIT_LINES
#else
#define EXIT_MSG_TEXT	ERROR_EXIT_TEXT
#define EXIT_MSG_LINES	ERROR_EXIT_LINES
#endif

/***************************************************************************/
/* Fatal error function will display an error message detailing the error  */
/* and warning that program is being aborted and then wait for any key to  */
/* be pressed. After a key a general cleanup is done by closing open       */
/* file, restoring all of the original interrupt handlers, cleaning up the */
/* video and then return to DOS with the error number set                  */
/*                                                                         */
/* ErrorNumber - An error number corresponding to the fatal error type     */
/* RETURNS: Does not return to caller, exits to DOS                        */
/***************************************************************************/

void FatalError( int ErrorNumber)
{
	char			*apszMessage[ FATAL_MESSAGE_LINES ];
	char			*apszExit[ EXIT_MSG_LINES ];
   char			*apszText[ FATAL_LINES ];

	GetMessage( apszMessage, FATAL_MESSAGE_TEXT );
	GetMessage( apszExit, EXIT_MSG_TEXT );
	GetMessage( apszText, FATAL_TEXT );

	if ( ErrorNumber > MAX_FATAL_ERROR || ErrorNumber < 0 )
		ErrorNumber = MAX_FATAL_ERROR;

	apszMessage[2] = apszText[ErrorNumber];
	apszMessage[3] = apszExit[vCurrentFile.chValidErrors];

	HelpLine( CONT_HLP );

   PromptWindow( apszMessage, CR_Response, GetErrorColor(), GetErrorBuffer());
	ProgramCleanUp( RESTORE_SCREEN );			/* Restore video & interrupts */

	if ( vCurrentFile.chValidErrors == REBOOT )
		RebootSystem();
	else
	{
		VideoCleanup();
		ProgramExit( ErrorNumber );       /* Exit to DOS with error code set */
	}
}


/***************************************************************************/
/* Similar to FatalError() above, but lets the caller display a custom     */
/* dialog layout.                                                          */
/*                                                                         */
/* void FatalErrCustom( unsigned msg)                                      */
/*                                                                         */
/* msg - Text group to display                                             */
/* RETURNS: Does not return to caller, exits to DOS                        */
/***************************************************************************/
void FatalErrCustom( unsigned msg )
{
   char			*apszText[ MAX_STRINGS ];

	GetMessage( apszText, msg );

	PushHelp ( 0xffff );	               // No help for this
	HelpLine( CONT_HLP );

   PromptWindow( apszText, CR_Response, GetErrorColor(), NULL);
	ProgramCleanUp( RESTORE_SCREEN );			/* Restore video & interrupts */

	if ( vCurrentFile.chValidErrors == REBOOT )
		RebootSystem();
	else
	{
		VideoCleanup();
		ProgramExit( 1 );       /* Exit to DOS with error code set */
	}
}


/***************************************************************************/
/* Prompts user to place a diskette in a drive and press return.				*/
/*																									*/
/* Need to do a disk reset after each disk change because of a bug in		*/
/* DOS 3.2																						*/
/*																									*/
/*	void PromptForDisk( char *szName, char chDrive, int IsNewDisk )			*/
/*																									*/
/*	ARGUMENTS:	szName	- String describing disk									*/
/*					chDrive	- Drive letter for to to be inserted into				*/
/*					IsNewDisk- 0 if we need to include warning that files wil	*/
/*								  be erased from the disk when it's preped.			*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void PromptForDisk( char *szName, char chDrive, int IsNewDisk )
{
	char			*apszText[ MAX_STRINGS ];
	int 			OldHelp;
	char			szTmp[ MAX_SCRN_LINE_LEN ];
	unsigned		uDiskMsg;

#ifdef	HD_BACKUP
	uDiskMsg = DISK_WARNING_TEXT;
#else
	uDiskMsg = IsNewDisk ? DISK_WARNING_TEXT : DISK_PROMPT_TEXT;
#endif

	GetMessage( apszText, uDiskMsg );

	if( uDiskMsg == DISK_WARNING_TEXT )
	{
		apszText[4] = szName;
		sprintf( szTmp, apszText[6], chDrive );
		apszText[6] = szTmp;
	}
	else	/* Must be DISK_PROMPT_TEXT */
	{
		apszText[4] = szName;
		sprintf( szTmp, apszText[2], chDrive );
		apszText[2] = szTmp;
	}

	OldHelp = GetHelpFlags();
	HelpLine( CONT_HLP |
				 (vCurrentFile.chValidErrors != REBOOT ? EXIT_HLP : 0) );

	VideoPutChar( BEL );

	PromptWindow( apszText, CR_Response, GetPromptColor(), NULL );
	HelpLine ( OldHelp );
	_dos_dskreset();
}

/***************************************************************************/
/* Displays a window with the status of files being copied. It uses the		*/
/* global structure "vinfo" to get the name of the file and whether it is	*/
/* is being read or written.																*/
/* 																								*/
/* void FileStatusUpdate( void ) 														*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void FileStatusUpdate( void )
{
	char		*apszStatus[ STATUS_LINES ];
	char		szStr[ 50 ];


	GetMessage( apszStatus, STATUS_TEXT );

	strcpy( szStr, apszStatus[vCurrentFile.chReadWrite] );
	strcpy( szStr + FNAME_OFFSET, vCurrentFile.szFileName );
	PadStr( szStr, SPC, STATUS_LINE_MAX );
	
	VideoPutsRowCol( LAST_VIDEO_ROW, STATUS_START_COL, szStr );
}

/***************************************************************************/
/* Sets up the current file structure and then calls FileStatusUpdate to	*/
/* display the	read-write message and file name on the screen's current    */
/* status line.																				*/
/* 																								*/
/* void DisplayFileStatus( char *szFileName, int Type )							*/
/* 																								*/
/* ARGUMENTS:	szFileName	- Name of current file in the form "NAME.EXT"	*/
/* 				Type			- Flag access type of READ or WRITE 				*/
/* RETURNS: 	void																			*/
/***************************************************************************/

void DisplayFileStatus( char *szFileName, int Type )
{
	vCurrentFile.chReadWrite = (unsigned char)Type;
	strcpy( vCurrentFile.szFileName, szFileName );
	FileStatusUpdate();
}

/************************************************************************
 * This function should be called if the user presses a key which 		
 * causes the program to end. It will prompt the user to confirm that
 * they wish to end the program and if the user confirms it will call	
 * ProgramAbort().
 *
 * Note: For Janus, if abort is confirmed, we will never return from
 * 		AbortPrompt().
 *																								
 * void AllowAbort( void )																
 *																								
 * ARGUMENTS:	NONE																		
 *	RETURNS:		void																		
 *																								
 ************************************************************************/
void AllowAbort( void )
{
	AbortPrompt();
}

/************************************************************************/
/* Allows the program to abort gracefully by checking to see if a			*/
/* return to DOS can be done or if a re-boot is necessary. If a there	*/
/* has to be a re-boot it can be done without any cleanup but if there	*/
/* there is going to be a return to DOS all interrupt handlers must be	*/
/* removed and if debugging all allocated memory must be freed.			*/
/*																								*/
/* void ProgramAbort( void )															*/
/*																								*/
/* ARGUMENTS:	NONE																		*/
/* RETURNS:		void																		*/
/*																								*/
/************************************************************************/

void ProgramAbort( void )
{
	ProgramCleanUp( RESTORE_SCREEN );

	if ( vCurrentFile.chValidErrors == REBOOT )
		RebootSystem();
	else
		ProgramExit( 0 );
}	

/***************************************************************************/
/* Prompts the user to confirm abort what ever they are doing. User can    */
/* confirm or not.                                         						*/
/*                                                                         */
/* RETURNS: TRUE to abort, otherwise FALSE                                        */
/***************************************************************************/

int AbortPrompt( void )
{
	int		  	YesNo, AnyChar = 0;
	int 			OldHelp;
   extern int  YesNoResponse[];
   char		  	*apszText[ MAX_STRINGS ];

#if (UPGRADE_PROGRAM != 0) || (RECOVERY_PROGRAM != 0)
	GetMessage( apszText, vCurrentFile.chValidErrors == REBOOT ?
								 REBOOT_EXIT_TEXT : EXIT_TEXT );
#elif (OEM_PROGRAM != 0) && (UJANUS != 0)
	if ( vInfo.Flag.fFloppyBoot && vInfo.Flag.fOsFound )
		GetMessage( apszText, FLOPPY_EXIT_TEXT );
	else
		GetMessage( apszText, EXIT_TEXT );
#else
	if ( vInfo.Flag.fFloppyBoot )
		GetMessage( apszText, FLOPPY_EXIT_TEXT );
	else
		GetMessage( apszText, EXIT_TEXT );
#endif

  			/*Disable help during this prompt.*/
	PushHelp ( 0xffff );	

	OldHelp = GetHelpFlags();
	HelpLine( 0 );
	YesNo = PromptWindow( apszText, &AnyChar, GetErrorColor(), NULL );
	HelpLine( OldHelp );

	PopHelp();

	/* M200: F3 is intercepted in GetChar(), and is never passed back to
	 * this function through PromptWindow(), so we always return FALSE.
	 */
	return( FALSE );
}

/************************************************************************/

void WriteProtectPrompt( char Disk )
{
	char			*apszText[ WRITE_PROTECT_LINES ];
	int			OldHelp;
	extern char *apszReadWriteError[];
	char			szTmp[ MAX_SCRN_LINE_LEN ];

	GetMessage( apszText, WRITE_PROTECT_TEXT );
	apszText[0] = apszReadWriteError[ WRITE ];
	sprintf( szTmp, apszText[2], Disk );
	apszText[2] = szTmp;

	OldHelp = GetHelpFlags();
	HelpLine( CONT_HLP |
				 (vCurrentFile.chValidErrors != REBOOT ? EXIT_HLP : 0) );

	PromptWindow( apszText, CR_Response, GetErrorColor(), GetErrorBuffer() );
	HelpLine( OldHelp );
}


/************************************************************************/

void NotReadyPrompt( char Disk )
{
	int			OldHelp;
	char			*apszText[ NOT_READY_LINES ];
	extern char *apszReadWriteError[];
	char			szTmp[ MAX_SCRN_LINE_LEN ];

	if ( vCurrentFile.chReadWrite > 1 )
		vCurrentFile.chReadWrite = WRITE;

	GetMessage( apszText, NOT_READY_TEXT );
	apszText[0] = apszReadWriteError[vCurrentFile.chReadWrite];
	sprintf( szTmp, apszText[2], Disk );
	apszText[2] = szTmp;

	OldHelp = GetHelpFlags();
	HelpLine( CONT_HLP |
				 (vCurrentFile.chValidErrors != REBOOT ? EXIT_HLP : 0) );

	PromptWindow( apszText, CR_Response, GetErrorColor(), GetErrorBuffer() );
	HelpLine( OldHelp );
}


/***************************************************************************/

void CompressedDiskFullPrompt (void)
{
  unsigned long cbMinFree;
  char *apszText[MAX_STRINGS];         /* Error message text */
  char  szParam[16];
  char szBuf1[MAX_SCRN_LINE_LEN];
  char szBuf2[MAX_SCRN_LINE_LEN];

  /*Disable help */
  PushHelp ( 0xffff );

  /* Choose the correct error message */
  if (gfCompressedDiskCritSection == TRUE)
    GetMessage (apszText, CMP_DISK_FULL_UNBOOTABLE_TEXT);
  else
    {
      GetMessage (apszText, CMP_DISK_FULL_BOOTABLE_TEXT);
      // Insert the drive letter
      szParam[0] = vInfo.chDestin;
      szParam[1] = 0;
      ReplaceParam (apszText, "%2", szParam, szBuf1, TRUE);

#if defined(UPGRADE_PROGRAM) || defined(OEM_PROGRAM)
      // Insert the free-space-required figure
      cbMinFree = atol(GetDataString (COMPONENTS_BYTES, DOS_INSTALL_BYTES));
      ReplaceParam (apszText, "%1", ultoac(cbMinFree,szParam), szBuf2, TRUE);
#endif
    }

  HelpLine (CONT_HLP);

  PromptWindow (apszText, CR_Response, GetErrorColor(), GetErrorBuffer());

  PopHelp();
}


/***************************************************************************/

#if	(UPGRADE_PROGRAM != 0) || (RECOVERY_PROGRAM != 0)

/***************************************************************************/
/* A lot of code is used in both the upgrade and recovery programs so		*/
/* this function must be called by the main function of the program to		*/
/* allow the actual program to be detected.											*/
/*																									*/
/* void SetIsUpgrade( int fTrueFalse )													*/
/*																									*/
/* ARGUMENTS: int fTrueFalse		- Boolean TRUE if upgrade program 			*/
/*											- else FALSE if recovery program				*/
/* RETURNS	: void																			*/
/*																									*/
/***************************************************************************/

void SetIsUpgrade( int TrueFalse )
{
	extern int	IsUpgrade;

	IsUpgrade = TrueFalse;
}

#endif

/***************************************************************************/
/* Functions specific to the retail upgrade program.								*/
/***************************************************************************/

#ifdef	UPGRADE_PROGRAM

/***************************************************************************/
/* Prompts the user to do a final committal to do a hard disk upgrade. 		*/
/* User can press 'Y' to start upgrade or F3 to exit Setup.					*/
/*																			*/
/*	int CommittPrompt( void )												*/
/*																			*/
/* ARGUMENTS:	NONE														*/
/* RETURNS:		OK															*/
/*																			*/
/***************************************************************************/

int CommittPrompt( void )
{
	int		YesNo = 0xFF;
	static int	ValidChars[] = { UCASE_YES, LCASE_YES, 0 };// IPG- ucase_yes,
	int		OldHelp;                                   //      lcase_yes
	char	*apszText[ CONFIRM_LINES ];

	WorkAreaCls();
	HelpLine( START_HLP );

	GetMessage( apszText, CONFIRM_TEXT );

	OldHelp = GetHelpFlags();
	HelpLine(  START_HLP | EXIT_HLP );

	do
	{
		YesNo = PromptWindow( apszText, ValidChars, GetErrorColor(), NULL );
	}
	while (toupper (YesNo) != UCASE_YES); // IPG- ucase_y to ucase_yes

	return (OK);
	HelpLine( OldHelp );
}


#endif


#if (UPGRADE_PROGRAM != 0) || (OEM_PROGRAM != 0) || (HD_BACKUP != 0)

/***************************************************************************/
/* Displays a "PLEASE WAIT" "......" message and then								*/
/* returns leaving the message on the screen.										*/
/*																									*/
/*	void WaitPrompt( int message )														*/
/*																									*/
/* ARGUMENTS:																					*/
/*		message -- define for message that is displayed underneath 				*/
/*					"PLEASE WAIT"																*/
/*					   																			*/
/* RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void WaitPrompt( int	Message )
{
	char		*apszText[ WAIT_LINES + 5];

	GetMessage( apszText, WAIT_TEXT );
	GetMessage( &apszText[WAIT_LINES-1], Message );

	HelpLine( 0 );
	PromptWindow( apszText, NULL, GetPromptColor(), NULL );
}

#endif


#ifndef	HD_BACKUP

/***************************************************************************/
/* Displays an error message on the screen along with the file name being	*/
/* read or written. If the BuildRecovery flag is set the user will not be	*/
/* allowed to continue and the program will be aborted. If this flag is 	*/
/* not set the user will just be told that what file was not copied and 	*/
/* to press any key to continue. 														*/
/* 																								*/
/* int ProcessCopyError( char *FileName, int ReadWrite )							*/
/* 																								*/
/* ARGUMENTS:	FileName 	- The name of the file being read or written		*/
/* 				ReadWrite	- Flags if the file is being read or written 	*/
/* RETURN:		int			- OK always (may abort program and not return)	*/
/*																									*/
/***************************************************************************/

void ProcessCopyError( char *szFileName, int Type )
{
	char		*apszMessage[ COPY_ERROR_LINES ];
	char		*apszError[ ERROR_STRINGS_LINES ];
	char		*apszType[ VALID_RESPONSE_LINES ];
	int		OldHelp;

	GetMessage( apszMessage, COPY_ERROR_TEXT );
	GetMessage( apszError, ERROR_STRINGS_TEXT );
	GetMessage( apszType, VALID_RESPONSE_TEXT );

	apszMessage[5] = GetMemory( 80 );
	strcpy( apszMessage[5], apszError[ Type ] );
	strcat( apszMessage[5], "--> " );
	strcat( apszMessage[5], szFileName );

	#ifdef	OEM_PROGRAM
		apszMessage[7] = apszType[ 0 ];
	#else
		apszMessage[7] = apszType[ CreatingRecovery != FALSE ];
	#endif

	OldHelp = GetHelpFlags();
	HelpLine( CONT_HLP | EXIT_HLP );

	PromptWindow(apszMessage, CR_Response, GetErrorColor(), GetErrorBuffer());
	HelpLine( OldHelp );

	FreeMemory( apszMessage[5] );

	#ifdef	UPGRADE_PROGRAM
	{
		extern int		CreatingRecovery;

		if ( CreatingRecovery )	/* Need to abort if in middle of recovery disk */
			ProgramAbort();
	}
	#endif
}

#if 0 /* BUGBUG: unused? */
/************************************************************************/

void FatalDiskError( char Disk )
{
	char			*apszText[ FATAL_DISK_LINES ];
	char			*apszMessage[ MAX_STRINGS ];
	extern char *apszReadWriteError[];
	char			szTmp[ MAX_SCRN_LINE_LEN ];

	GetMessage( apszText, FATAL_DISK_TEXT );

	#ifdef OEM_PROGRAM
		GetMessage( apszMessage, RESTART_TEXT );
	#else
		GetMessage( apszMessage, (vCurrentFile.chValidErrors == REBOOT) ?
										  RECOVER_TEXT : RESTART_TEXT );
	#endif

	apszText[4] = apszMessage[0];
	apszText[5] = apszMessage[1];
	apszText[0] = apszReadWriteError[ 2 ];
	sprintf( szTmp, apszText[2], Disk );
	apszText[2] = szTmp;

	HelpLine( 0 );
	PromptWindow( apszText, CR_Response, GetErrorColor(), GetErrorBuffer() );

	ProgramAbort();
}
#endif

/***************************************************************************/
/* Prompts user to remove all diskettes and press any key to reboot.			*/
/*																									*/
/* void RebootPrompt( void )																*/
/*																									*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void RebootPrompt( void )
{
   char		*apszText[ MAX_STRINGS ];
	
	DisplayFileStatus( "", CLEAR );

#if (UPGRADE_PROGRAM != 0)
    if ( vInfo.Args.fManual)
        GetMessage( apszText, MANUAL_DONE_TEXT);

	else if ( vInfo.Flag.fHardInstall )
	{
   	    VideoPutChar( BEL );
	    WorkAreaCls();
		GetMessage( apszText, HD_REMOVE_FLOPPY_TEXT );
	    PromptWindow( apszText, CR_Response, GetPromptColor(), NULL );

		if ( Install.Software == SOFTWARE_DOSWIN )
			GetMessage( apszText, REBOOT_WINSETUP_TEXT );
		else
		{
			if ( Install.Flags.fUninstall )
				GetMessage( apszText, REBOOT_CONTINUE_TEXT );
			else
				GetMessage( apszText, HD_REBOOT_TEXT );
		}
	}
	else
		GetMessage( apszText, FD_DONE_TEXT );
#elif (RECOVERY_PROGRAM != 0)
	GetMessage( apszText, REBOOT_CONTINUE_TEXT );

#else
	if ( vInfo.Flag.fHardInstall )
   {
   	VideoPutChar( BEL );
	   WorkAreaCls();
		GetMessage( apszText, HD_REMOVE_FLOPPY_TEXT );
	   PromptWindow( apszText, CR_Response, GetPromptColor(), NULL );
   }

	GetMessage( apszText, vInfo.Flag.fHardInstall ?
								 HD_REBOOT_TEXT : FD_DONE_TEXT);
#endif

	WorkAreaCls();
	HelpLine( vInfo.Flag.fHardInstall ? CONT_HLP : (CONT_HLP | EXIT_HLP) );

	PromptWindow( apszText, CR_Response, GetPromptColor(), NULL );
}

/***************************************************************************/
/* Removes the color the current screen display.									*/
/*																									*/
/*	void StripScreenColor( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void StripScreenColor( void )
{
	register			i;
	char				*Buf;
	char				*Ptr;
	static WINDOW	Win = { 0, 24, 0, 79, 0, 0, 0, 0 };

	Ptr = Buf = GetMemory( 25 * 80 * 2 );
	WindowMove( &Win, Buf, SAVE );
	
	for ( i = 0, Ptr++ ; i < (25 * 80 * 2); i += 2, Ptr += 2 )
		*Ptr = *Ptr >= (char)0x30 ? (char)0x70 : (char)0x07;						

 	WindowMove( &Win, Buf, RESTORE );
	FreeMemory( Buf );
	vInfo.Args.fIsMono = TRUE;

#ifndef RECOVERY_PROGRAM
	strcat( Install.szCmdLine, " /B" );
	strcat( Install.szWinCmdLine, " /B" );
#endif
}

#endif

/************************************************************************/


int Int24DiskError( char Disk )
{
	char			*apszText[ INT_24_LINES ];
	char			*apszOptions[ INT_24_EXIT_LINES ];
	char			szTmp[ MAX_SCRN_LINE_LEN ];

	GetMessage( apszText, INT_24_TEXT );
	GetMessage( apszOptions, INT_24_EXIT_TEXT );
	sprintf( szTmp, apszText[4], Disk );
	apszText[4] = szTmp;

	return( PromptSelect( apszText, apszOptions ) );
}


/***************************************************************************/
/* Displays the help screen associated with the value on the help stack		*/
/* pointed to by HelpStackPtr. Waits for the user to press a key and then	*/
/* restores the original screen. Functions which want to use help should	*/
/* push a help indentifier on the help stack with the macro PushHelp( x )	*/
/* and then call GetChar() to get input from the user. If F1 is pressed 	*/
/* GetChar will this function. If the value of *HelpStackPtr == -1 the 		*/
/* function will return without displaying any text.								*/
/*                                                                         */
/*	void Help( void )																			*/
/*                                                                         */
/* ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*                                                                         */
/*	EXTERNS:		HelpMemErrText	- Declared in EXTERN.C								*/
/*                                                                         */
/* johnhe - 12/29/89																			*/
/***************************************************************************/

void Help( void )
{
	char					*apszError[ ERROR_LINES ];
	char					*ScrnBuf;
	extern unsigned	HelpMemErrText;

	GetMessage( apszError, HelpMemErrText	);		/* Get mem error message	*/

	if ( *(HelpStackPtr-1) != 0xffff	)				/* Is valid help on stack?	*/
	{
		if ( (ScrnBuf = malloc( 5000 )) != NULL )	/* Is enough memory? 		*/
		{
			free( ScrnBuf );								/* Free this block			*/
			DisplayHelp();									/* Show the help				*/
		}
		else
			Error( apszError );							/* Too little memory 		*/
	}
}

/***************************************************************************/
/* Saves the contents of the original screen and then diplays a help			*/
/* screen. Must save the contents of the screen as well as the cursor size	*/
/* and location.																				*/
/*                                                                         */
/*	void DisplayHelp( void )																*/
/*                                                                         */
/* ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*                                                                         */
/***************************************************************************/

void DisplayHelp( void )
{
	char				*apszText[ MAX_STRINGS ];	/* Help strings	*/
	char				*ScrnBuf;					/* Storage for orignal screen	*/
	int 				OldHelp;
	long				Cursor;
	static WINDOW	Wind = { 0, 24, 0, 79, 0, 0, 0 }; /* Screen description	*/

	ScrnBuf = GetMemory( 4000 );				/* Allocate size of screen	*/
	Cursor = SaveCursor();
	VideoCursOff();								/* Turn cursor off			*/

	WindowMove( &Wind, ScrnBuf, SAVE );		/* Save current screen		*/

	SetHelpColors( VideoIsColor() && !vInfo.Args.fIsMono ? TRUE : FALSE );

	GetMessage( apszText, *(HelpStackPtr - 1));/* Display help screen	*/
	VideoCls( GetBackGroundColor() );
	DisplayScreenHeader( 1 );
	DisplayText( apszText, TITLE_ROW );

	OldHelp = GetHelpFlags(); 					/* Save original help flags*/
	HelpLine( PREV_HLP | EXIT_HLP );

	PushHelp( 0xffff );							/* Can't have help on help	*/
	while( GetChar() != ESC )					/* Wait for <RETURN>			*/
		;

	SetDefaultColors( VideoIsColor() && !vInfo.Args.fIsMono ? TRUE : FALSE );

	PopHelp();										/* Turn help back on			*/

	WindowMove( &Wind, ScrnBuf, RESTORE );	/* Restore original screen */
	HelpLine ( OldHelp );						/* Restore orig. help flags*/
	RestoreCursor( Cursor );

	FreeMemory( ScrnBuf );
}


/***************************************************************************
 * Program exit.
 *																									
 * void ProgramExit( int iStatus )
 * 																							
 * ARGUMENTS:	iStatus - Exit status.
 * 				
 * RETURNS	:	NEVER (Does not return to caller.)
 *
 ***************************************************************************/
void ProgramExit( int iStatus )
{
   unsigned i;

   //
   // Set user back to the drive they started from
   //
   if (vInfo.drStart != 0)                   // Make sure its been initialized
      _dos_setdrive(vInfo.drStart, &i);

#if (OEM_PROGRAM != 0) && (UJANUS != 0)
	/* If existing operating system found, OK to exit to command-line. */

	if ( vInfo.Flag.fOsFound  || vInfo.fOemCmdLineOK )
		exit( iStatus );
	else
 		ErrorEndPrompt( DRIVE_ERROR_TEXT );
#else
	exit( iStatus );
#endif
}


#if (UPGRADE_PROGRAM != 0) || (OEM_PROGRAM != 0)

/***************************************************************************
 * void _Assert(char*,int);
 *
 * Called as a result of an assertion failure. Will print out an error
 * dialog containing the file and line number of where the assertion failure
 * occured and warning that program is being aborted and then wait for any
 * key to be pressed. After a key a general cleanup is done by closing open
 * file, restoring all of the original interrupt handlers, cleaning up the
 * video and then return to DOS.
 *	
 * ENTRY: Only from an assertion failure.
 * EXIT : Fatal Error (exit to dos).
 *
 ***************************************************************************/

void _Assert(char *szFile, int line)
{
#ifdef DEBUG
	char			*apszMessage[ ASSERT_FAIL_LINES ];
	char			*apszExit[ EXIT_MSG_LINES ];
	char			szTmp[MAX_SCRN_LINE_LEN];

	GetMessage( apszMessage, ASSERT_FAIL_TEXT );
	GetMessage( apszExit, EXIT_MSG_TEXT );

   sprintf(szTmp,apszMessage[2],szFile,line);
   apszMessage[2] = szTmp;
	apszMessage[3] = apszExit[vCurrentFile.chValidErrors];

	HelpLine( CONT_HLP );

   PromptWindow( apszMessage, CR_Response, GetErrorColor(), GetErrorBuffer());
	ProgramAbort();
#else
	szFile = szFile;
	line = line;
#endif
}


/***************************************************************************
 * DebugMsg(char*,int,char*);
 *
 * Will print out an message dialog containing the file and line number of
 * where the call occurred and a user specified string.  It will then wait for
 * any key to be pressed. When a key is pressed, the function returns.
 *
 * ENTRY:
 * EXIT : none
 *
 *
 ***************************************************************************/

void DebugMsg(char *szFile, int line, char *szText)
{
#ifdef DEBUG
	char			*apszMessage[ DEBUG_MESSAGE_LINES ];
	char			szTmp[MAX_SCRN_LINE_LEN];

	GetMessage( apszMessage, DEBUG_MESSAGE_TEXT );
   sprintf(szTmp,apszMessage[2],szFile,line);
   apszMessage[2] = szTmp;
   apszMessage[3] = szText;

	HelpLine( CONT_HLP | EXIT_HLP );

	PromptWindow( apszMessage, CR_Response, GetErrorColor(), GetErrorBuffer());
#else
	szFile = szFile;
	line = line;
	szText = szText;
#endif
}


/***************************************************************************
 * void FatalMsg(unsigned);
 *
 * Called as a result of an unrecoverable error. Will print out an message
 * dialog describing the error, and warning that program is being aborted
 * and then wait for any key to be pressed. After a key a general cleanup
 * is done by closing open file, restoring all of the original interrupt
 * handlers, cleaning up the video and then return to DOS.
 *
 * ENTRY: unsigned uOffset:	Offset of message text.
 * EXIT : Fatal Error (exit to dos).
 *
 * NOTE: This function differs from FatalError() in that these error messages
 * 		typically consist of more than one line; therefore, the offset and
 *			number of message lines are passed, rather than just a message index.
 *			Also, unlike FatalError(), this function will not reboot your
 *			system.
 *
 ***************************************************************************/

void FatalMsg(unsigned uOffset)
{
	char	*apszMessage[ MAX_STRINGS ];

	GetMessage( apszMessage, uOffset );
	HelpLine( CONT_HLP );
   PromptWindow( apszMessage, CR_Response, GetErrorColor(), GetErrorBuffer());
	ProgramAbort();
}


/***************************************************************************
 * Displays a TTY error message on the screen and enters an infinite loop.
 * This effectively terminates SETUP and does not return the User to the
 * command prompt.
 *																									
 * void ErrorEndTty( unsigned uOffset )
 * 																							
 * ARGUMENTS:	uOffset - Offset of error message text to display.
 * 				
 * RETURNS	:	NEVER (Does not return to caller.)
 *
 ***************************************************************************/
void ErrorEndTty( unsigned uOffset )
{
	int	i;
	char	*apszText[ MAX_STRINGS ];

	GetMessage( apszText, uOffset );

	for( i = 0; apszText[ i ] != NULL; i++ )
	{
		VideoPuts( apszText[i] );
		VideoPutChar( CR );
		VideoPutChar( 0x0a );
	}

	while( TRUE )
		;		/* Wait forever */
}


#ifdef	OEM_PROGRAM		/* NOT NEEDED BY UPGRADE_PROGRAM */
/***************************************************************************
 * Prompts with an error message on the screen and enters a loop.
 * This effectively terminates SETUP Asking for CtrlAltDel OR it
 * will allow user to return to the command prompt by pressing ENTER.
 *																									
 * void ErrorEndPrompt( unsigned uOffset )
 * 																							
 * ARGUMENTS:	uOffset - Offset of error message text to display.
 * 				
 * RETURNS	:	NEVER (Does not return to caller.)
 *
 *					[ DEBUG WILL RETURN - NOT EXIT ]
 *
 ***************************************************************************/
void ErrorEndPrompt( unsigned uOffset )
{
	int	i;
	char	*apszText[ MAX_STRINGS ];
	int		ExitChoice = 0xFF;

	GetMessage( apszText, uOffset );

	VideoPutChar( CR );
	VideoPutChar( 0x0a );
	for( i = 0; apszText[ i ] != NULL; i++ )
	{
		VideoPuts( apszText[i] );
		VideoPutChar( CR );
		VideoPutChar( 0x0a );
	}

#ifdef DEBUG

	/* DEBUG can avoid exit with ENTER at prompt */
	{
		VideoPutChar( CR );
		VideoPutChar( 0x0a );
		VideoPuts( DebugContinueMessage );
		VideoPutChar( CR );
		VideoPutChar( 0x0a );
	}

	ExitChoice = 0xff & KbdGetKey();

	if ( CR == ExitChoice)
		return;
	else
		exit(3);
#else
	do
	{	/* Wait for Enter or CtrlAltDel */
		ExitChoice = 0xff & KbdGetKey();
	}
	while ( CR != ExitChoice);

	exit( 3 );
#endif
}
#endif	/* OEM_PROGRAM	- NOT NEEDED BY UPGRADE_PROGRAM */


/***************************************************************************
 * Displays an error message on the screen and enters an infinite loop.
 * This effectively terminates SETUP and does not return the User to the
 * command prompt.
 *																									
 * void ErrorEndMsg( unsigned uOffset )
 * 																							
 * ARGUMENTS:	uOffset - Offset of error message text to display.
 * 				
 * RETURNS	:	NEVER (Does not return to caller.)
 *
 ***************************************************************************/
void ErrorEndMsg( unsigned uOffset )
{
	char	*apszText[ MAX_STRINGS ];

	AbortEnabled = FALSE;	/* Don't allow user to exit to command prompt */
	GetMessage( apszText, uOffset );
	WorkAreaCls();
	HelpLine(0);
	PromptWindow( apszText, NULL, GetErrorColor(), NULL );

	while( TRUE )
		;		/* Wait forever */
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\autoconf.c ===
/***************************************************************************/
/*																									*/
/*	AUTOCONF.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* Functions for creating new config.sys and autoexec.bat files for the		*/
/* DOS 5.0 retail nstallation program.													*/
/*																									*/
/* Created 02-28-90	- johnhe																*/
/***************************************************************************/

#include 	<stdio.h>
#include 	<stdlib.h>
#include 	<memory.h>
#include 	<string.h>
#include		<dos.h>
#include		<io.h>
#include 	<malloc.h>

#include 	<alias.h>
#include 	<global.h>
#include 	<disk_io.h>
#include		<file_io.h>
#include 	<strlib.h>
#include		<upgrade.h>
#include		<prompts.h>

/***************************************************************************/

#define		FILE_BUF_SIZE		2000		/* Size of file buffer in bytes		*/

/***************************************************************************/

static char	*apszFile[] = { "X:\\AUTOEXEC.BAT", "X:\\CONFIG.SYS" };
static char	*apszOld[]	= { "X:\\AUTOEXEC.OLD", "X:\\CONFIG.OLD" };

static char	*szBuf;									/* Buffer to build file in		*/
static char *szEndLine = "\r\n"; 				/* End of line characters		*/
static char	chBootDrv;

/***************************************************************************/

extern void AutoConfig		( void );
extern int	NetUpgradeStr	( char *szBuf );

static unsigned CreatAutoexec( void );
static unsigned CreatConfig( void );

/***************************************************************************/
/* Main function for creating autoexec.bat and config.sys files. First 		*/
/* renames an existing file of the same name to *.OLD and then call a		*/
/* function for each of the files.														*/
/*																									*/
/*	void NewAutoConfig( int iType, char *szFile )									*/
/*																									*/
/*	ARGUMENTS:	iType	- Type of file to create 0 == AUTOEXEC, 1 = CONFIG		*/
/*					szFile - Full path name for the new file							*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void NewAutoConfig( int iType, char *szFile )
{
//	char					*apszError[ ERROR_LINES ];
	register				iStatus;
	int					iFile;
	unsigned				uToWrite;
	unsigned				uWritten;


#ifdef	NEED_FIX
	static unsigned	Errors[] = { AUTOEXEC_BAT_ERROR, CONFIG_SYS_ERROR };
#endif

	static unsigned	(*Func[])(void) =	{ CreatAutoexec, CreatConfig };
							
	chBootDrv = (vInfo.Flag.fHardInstall ? (char)'C' : (char)'A');

	szBuf = GetMemory( FILE_BUF_SIZE );

	apszOld[iType][0] = chBootDrv;

											/* There may be an old files so delete it	*/
	AbsUnlink( szFile );
	uToWrite = (*Func[iType])();				/* Create the text for the file	*/

														/* Next create the file				*/
	if ( uToWrite > 0 )
	{
		DisplayFileStatus( apszFile[iType]+ 3, WRITE );
		iStatus = ERROR;
		if ( _dos_creat( szFile, 0, &iFile ) == OK )
		{
			if ( _dos_write( iFile, szBuf, uToWrite, &uWritten )	== OK &&
				  uWritten == uToWrite )
				iStatus = OK;

				iStatus |= (int)_dos_close( iFile );
		}
		if ( iStatus != OK )
		{
#ifdef	NEED_FIX
apszError is not being used anwhere so why was this done?

			GetMessage( apszError, Errors[iType] );
			Error( apszError );
#endif
		}
	}

	FreeMemory( szBuf );
}

/***************************************************************************/
/* Creates a new CONFIG.SYS file in the file buffer. First checks for		*/
/* extended memory and if available forces DOS to load into the high 		*/
/* memory area and then checks to see if SMARTDRV.SYS should be installed	*/
/* and adds the line if installing. If SMARTDRV is installed the number of */
/* buffers are	reduced from the normal default that DOS would set. Next a	*/
/* check is done to see if a COUNTRY line should be added.						*/
/* 																								*/
/* unsigned CreatConfig( void )															*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	unsigned - Number of bytes in the new file.						*/
/* 							  NOTE: this number may be zero which will signal	*/
/* 									  that no CONFIG.SYS file will be created.	*/
/* 																								*/
/***************************************************************************/

unsigned CreatConfig( void )
{
	char				*szPtr;
	extern char		*szShell;


	szPtr = szBuf;
	*szBuf = EOL;

	strcat( szPtr, DEVICE_STR );                    /* "DEVICE=SETVER.EXE"	*/
   szPtr = strchr( szPtr, EOL );
   BuildPath( szPtr, chBootDrv, vInfo.szPath + 2, SETVER_STR );
   strcat( szPtr, szEndLine );

							/* If extended memory is available put DOS in himem.  */
	if ( vInfo.NoCopy[ NO_HIMEM ] == FALSE &&
		  vInfo.Hw.ExtMem >= HIMEM_K_SIZE )
	{
		strcat( szBuf, DEVICE_STR );							/* "DEVICE=HIMEM		*/
		szPtr = strchr( szBuf, EOL );
		BuildPath( szPtr, chBootDrv, vInfo.szPath + 2, HIMEM_STR );
		strcat( szPtr, XMA_STR );								/* "DOS=HIGH\r\n"		*/
	}

	strcat( szBuf, FILES_STR );								/* FILES= line 		*/

	if ( vInfo.Hw.VideoType == VIDEO_EGA )
	{
		strcat( szBuf, DEVICE_STR );							/* "DEVICE=EGA.SYS	*/
		szPtr = strchr( szBuf, EOL );
		BuildPath( szPtr, chBootDrv, vInfo.szPath + 2, EGA_STR );
	}

	if ( vInfo.Flag.fHardInstall )
	{
		szPtr = DefaultShellLine( strchr( szBuf, EOL ) );
		strcat( szPtr, "\r\n" );
	}

	#ifdef	STACKS_STR
		strcat( szBuf, STACKS_STR );							/* STACKS= line		*/
	#endif

	szPtr = strchr( szBuf, EOL );
	return( (UINT)(szPtr - szBuf) );
}

/***************************************************************************/
/* Creates an new AUTOEXEC.BAT file in the file buffer. First adds all of	*/
/* the standard items which are used on all systems and then based on the	*/
/* user options may add the keyboard driver, mouse or dos shell.				*/
/* 																								*/
/* unsigned CreatAutoexec( void )														*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	unsigned - Then number of bytes in the new file.				*/
/* 																								*/
/***************************************************************************/

unsigned CreatAutoexec( void )
{
	char			*szPtr;

	*szBuf = EOL;									/* Needed for strcat to work		*/

#ifdef NET_SUPPORT														
	if ( NetUpgradeStr( szBuf ) )				/* Add the net setup string		*/
		strcat( szBuf, szEndLine );			/* Add the CR LF characters		*/
#endif

	strcat( szBuf, AUTO_STR ); 				/* Add standard autoexec items	*/
														/* Append the dos path string 	*/
	if ( vInfo.Flag.fHardInstall )
	{
		strcat( szBuf, PATH_STR );
		szPtr = strchr( szBuf, EOL );
		BuildPath( szPtr, chBootDrv, vInfo.szPath + 2, "" );
		RemoveTrailing( szPtr + 3, '\\' );	/* Remove trailing seperater		*/
		strcat( szPtr, szEndLine );			/* Add the CR LF characters		*/

		strcat( szBuf, TEMP_STR );
		szPtr = strchr( szBuf, EOL );
		BuildPath( szPtr, chBootDrv, vInfo.szPath + 2, "" );
		RemoveTrailing( szPtr + 3, '\\' );	/* Remove trailing seperater		*/
		strcat( szPtr, szEndLine );			/* Add the CR LF characters		*/
	}

#ifdef	ADD_MOUSE
	if ( vInfo.Flag.fMouse )
	{
		if ( !vInfo.ToFloppy )
		{
			szPtr = strchr( szBuf, EOL );
			BuildPath( szPtr, chBootDrv, vInfo.szPath + 2, MOUSE_STR );
		}
		else
			strcat( szBuf, MOUSE_STR );
	}
#endif
																/* See if adding dos shell */
	if ( vInfo.Flag.fShell && vInfo.Flag.fHardInstall )
	{
		szPtr = strchr( szBuf, EOL );
		strcpy( szPtr, SHELL_STR );
	}

	szPtr = strchr( szBuf, EOL );
	return( (UINT)(szPtr - szBuf) );
}

#ifdef NET_SUPPORT
/***************************************************************************/
/* Creates a string to launch the net upgrade program from the autoexec		*/
/* file. 																						*/
/*																									*/
/*	int NetUpgradeStr( char *szStr )														*/
/*																									*/
/*	ARGUMENTS:	szStr	- Ptr to buffer to hold the string.							*/
/* RETURNS:		int	- TRUE if a string was created, FALSE if the net		*/
/*							  upgrade program doesn't need to be run.					*/
/***************************************************************************/

int NetUpgradeStr( char *szStr )
{
	if ( vInfo.Flag.fHardInstall )
	{
		BuildPath( szStr, vInfo.szPath[0], vInfo.szPath + 2, NET_UPGRADE );
		strcat( szStr, " " );

		if ( vInfo.chSource > vInfo.chFirstHd )	/* Upgrading from net?	 	*/
		{
			strcat( szStr, vInfo.szNetDir );
			RemoveTrailing( szStr, '\\' );
		}
		else
			strcat( szStr, vInfo.szSource );

		strcat( szStr, " /UPGRADE" );
		if ( vInfo.Args.fIsMono )
			strcat( szStr, " /B" );
		return( TRUE );
	}		
	else
		return( FALSE );
}

#endif

/***************************************************************************/
/* Creates a default SHELL= line for a config.sys file using the path to	*/
/* the DOS directory. The function assumes the drive is the boot hard disk	*/
/* C: since there is no need to call this function for a floppy upgrade.	*/
/*																									*/
/*	void DefaultShellLine( char *szPtr )												*/
/*																									*/
/*	ARGUMENTS:	szPtr		- Ptr to buffer where shell= line to be created		*/
/*	RETURNS:		char *	- Ptr to end of line which was created					*/
/*																									*/
/***************************************************************************/

char *DefaultShellLine( char *szPtr )
{
	extern char		*szCommandShell;
	extern char		*szShell;

	strcpy( szPtr, szShell );
	BuildPath( strchr( szPtr, EOL ), 'C', vInfo.szPath + 2, szCommandShell );
	BuildPath( strchr( szPtr, EOL ), 'C', vInfo.szPath + 2, " " );

	strcat( szPtr, " /p" );
	return( strchr( szPtr, EOL ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\auto.c ===
/***************************************************************************/
/* 																								*/
/* AUTO.C																						*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* Processes the autoexec.bat file in the root directory or creates one 	*/
/* if it doesn't already exist.                                            */
/* 																								*/
/* NOTE: 																						*/
/* 		In order to correctly process the mouse driver the config.sys		*/
/* 		file processing must be done before calling ProcessAutoexec(). 	*/
/* 		This will insure that any existing mouse.sys driver in the			*/
/* 		config.sys file has been identified and the vInfo.fMouse flag		*/
/* 		has been set to signal adding mouse to autoexec.bat.					*/
/* 																								*/
/* 12-10-89 johnhe																			*/
/***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include	<alias.h>
#include	<data.h>
#include <disk_io.h>
#include	<file_io.h>
#include <global.h>
#include <strlib.h>
#include	<errors.h>
#include	<prompts.h>

/***************************************************************************/

#define		MAX_FNAME_LEN	12			/* m104	*/
#define		FILE_EXT_LEN	3			/* m104	*/

#define		MAX_LEN		256			/* Max length of line in autoexec.bat	*/
#define		STR_BUF_LEN	128
#define		MAX_DEFAULT 10 			/* Max # of default autoexe.bat lines	*/
#define		MAX_TO_ADD	4				/* Max lines added to existing file 	*/
#define		MOUSE 		1				/* Offset of "MOUSE" in apszFiles[] 	*/

enum			CmdStrs		{ CMD_PATH, CMD_SET, CMD_DOSSHELL, CMD_MOUSE };
enum			SetStrs		{ SET_PATH, SET_COMSPEC };

struct AUTO_LINE_FLAGS
{
	unsigned 	fHasPath :1;			/* Cmd has a path prefixed to it 		*/
	unsigned 	fRemOut	:1;			/* Prefix line with a REM cmd 			*/
	unsigned 	fCopyOld :1;			/* strcat the old line to szNewLine 	*/
	unsigned 	fHasExt	:1;			/* Cmd had an extension on it 			*/
	unsigned		fDelLine	:1;			/* Delete the line from the file			*/
}ThisLine;

/***************************************************************************/

extern struct BITS
{
	unsigned 	fXma			:1;
	unsigned 	fHimem		:1;
	unsigned 	fSmartDrv	:1;
	unsigned 	fRamDrv		:1;
	unsigned 	fEmm386		:1;
	unsigned 	fPath 		:1;
	unsigned 	fMouse		:1;
	unsigned 	fDosKey		:1;
	unsigned 	fDosShell	:1;
	unsigned 	fNeedHiMem	:1;
	unsigned		fHaveDosEqu	:1;
} DevFlags;


extern FILE		*OldFile;			/* File handle for existing autoexec	*/
extern FILE		*NewFile;			/* File handle for new autoexec			*/

extern char 	*szOldString;		/* Original line from file 				*/
extern char 	*szNewString;		/* Processed line to add to file 		*/
extern char 	*szAutoBat; 		/* Full path & name for old autoexe.bat*/
extern char 	*szConfSys;			/* Full path & name for old config.sys */

static char 	*apszAlways[] = { "@ECHO OFF", "PROMPT $p$g" };
static char 	*apszFiles[]  = { NULL, "MOUSE ", "DOSKEY", "DOSSHELL" };
static char 	*apszDefault[ MAX_DEFAULT ];	/* Ptrs to default strs 	*/

static char 	szPath[STR_BUF_LEN] = "PATH ";	/* Default path cmd string */
static int		iFlags[ MAX_TO_ADD ];			/* Flag for user options	*/


static char		*apszCmdStrs[] = { "PATH", "SET", "DOSSHELL", "MOUSE", NULL };
static char 	*szPathCmd		=	"PATH=";
static char 	*szComspec		=	"COMSPEC=";


#define			PATH_STRING 	2	/* Indice to "PATH"	in apszDefault[]	*/
#define			PATH_CMD_LEN	5					/* strlen( "PATH=" ) 		*/
#define			COMSPEC_LEN 	8					/* strlen( "COMSPEC=" ) 	*/


#define			REM_LINE			1
#define			DEL_LINE			2

/***************************************************************************/

extern void	ProcessFile		( int iType, char *szOldFile, char *szNewFile,
									  int (*Funcs[])( int iStatus ) );

extern int	NewFilePuts		( char *szString, FILE *File );

extern void MoveAutoConfig( void );
extern void	ProcessAuto		( void );
extern void ProcessConfig	( void );
extern int	NetUpgradeStr	( char *szBuf );

static int	NewAutoFirst		( int iStatus );
static int	NewAutoLast		( int iStatus );
static int	ProcessAutoStr	( int iStatus );

static void	near BuildDefaultAuto( void );
static void near CreateEnvPath	( char *szPtr );
static int	near IsDosFile			( char *szName );
static int	near UniqueRename		( char *szFile, char *szNew );


/***************************************************************************/
/* Renames the tmp autoexec.bat and config.sys files into the root dir. 	*/
/* A check is done first to see if the tmp file exists before deleting the */
/* original just in case we need to continue if there is a system crash 	*/
/* and this is the second try and one of the files was already successfully*/
/* moved.																						*/
/* 																								*/
/* void MoveAutoConfig( void )															*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void MoveAutoConfig( void )
{
	char		*szNewAutoStr = "X:\\AUTOEXEC.NEW";			/* M002 */
	char		*szNewConfStr = "X:\\CONFIG.NEW";			/* M002 */
	char		*szAutoNew;											/* M002 */
	char		*szConfNew;											/* M002 */

	if ( vInfo.Args.fMininum )
	{
		szAutoNew = szNewAutoStr;
		szConfNew = szNewConfStr;		
		*szAutoNew = *szConfNew = vInfo.chDestin;
	}
	else
		szAutoNew = szAutoBat,	szConfNew = szConfSys;

	if ( (vInfo.Flag.fConfigSys && vInfo.Flag.fNewSysFiles &&
			UniqueRename( szConfSys, vInfo.szRenConfig ) != OK) ||
		  ReplaceFile( vInfo.szTmpConfig, szConfNew ) != OK )
		ProcessCopyError( vInfo.szTmpConfig, ERR_RENAMING );

 	if ( (vInfo.Flag.fAutoexecBat && vInfo.Flag.fNewSysFiles &&
		   UniqueRename( szAutoBat, vInfo.szRenAuto ) != OK) ||
		  ReplaceFile( vInfo.szTmpAuto, szAutoNew ) != OK )
		ProcessCopyError( vInfo.szTmpAuto, ERR_RENAMING );

	if ( vInfo.Args.fMininum )									/* M002 */
	{
		AbsUnlink( szAutoBat );
		AbsUnlink( szConfSys );
	}
}

/***************************************************************************/
/* Builds a list of default strings for a new autoexec.bat file and the 	*/
/* calls ProcessFile() to create a new autoexec.bat in the tmp directory	*/
/* using processed lines from the original if it exists or else the			*/
/* list of default strings if it doesn't exist.                            */
/* 																								*/
/* void ProcessAuto( void )																*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void ProcessAuto( void )
{
	char			*Buffer;
	register 	i;
	static int	(*Funcs[])(int) = { NewAutoFirst, ProcessAutoStr, NewAutoLast };

										/* Allocate memory for and assign ptrs to 	*/
										/* buffers for default autoexec file strings */

	Buffer = GetMemory( STR_BUF_LEN * MAX_DEFAULT );
	for ( i = 0; i < MAX_DEFAULT; i++ )
		apszDefault[ i ] = Buffer + (i * STR_BUF_LEN);

	BuildDefaultAuto();						  /* Create default strings array	*/

	ProcessFile( AUTOEXEC_BAT, szAutoBat, vInfo.szTmpAuto, Funcs );

	FreeMemory( Buffer );
}

/***************************************************************************/
/* Builds a list of strings for the default autoexec.bat file. 				*/
/* 																								*/
/* void BuildDefaultAuto( void ) 														*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void near BuildDefaultAuto( void )
{
	register 		i;
	register 		iStr;
											/* Set ptrs to default strings which will */
											/*	always be added to a new autoexec file	*/

	for ( iStr = 0; iStr < PATH_STRING; iStr++ )
		strcpy( apszDefault[ iStr ], apszAlways[ iStr ] );

	strcat( szPath, vInfo.szPath );					/* Create the path string	*/
	apszDefault[ iStr ] = apszFiles[0] = szPath;	/* Copy ptr to 2 arrays		*/
	iStr++;

	iFlags[0] = TRUE; 									/* Always set path			*/
	iFlags[1] = vInfo.Flag.fMouse;					/* Check user option flags */
	iFlags[2] = vInfo.Flag.fDosKey;
	iFlags[3] = vInfo.Flag.fShell;

									/* Skip over the path command and then create a	*/
									/* a complete command string with path for each */
									/* user option to be added to the autoexec file */

	for ( i = 1; i < MAX_TO_ADD; i++ )
	{
		if ( iFlags[ i ] )
		{
			if ( i == (MAX_TO_ADD - 1) )				/* No path for DOSSHELL		*/
				strcpy( apszDefault[ iStr ], apszFiles[ i ] );
			else
				BuildPath( apszDefault[ iStr ], vInfo.szPath[ 0 ],
							  vInfo.szPath + 2, apszFiles[ i ] );
			iStr++;								/* Incr default strings array ptr	*/
		}
	}
	apszDefault[ iStr ] = NULL;			/* Mark the end of the list			*/
}

/***************************************************************************/
/* Adds any lines to the new autoexec.bat file which need to go before any */
/* of the original lines are processed.												*/
/* 																								*/
/* NOTE: For now there is nothing to add. 											*/
/* 																								*/
/* int NewAutoFirst( int iStatus )														*/
/* 																								*/
/* ARGUMENTS:	iStatus	- Current processing status								*/
/* RETURNS: 	int		- Original arg status if successfull else ERROR 	*/
/* 																								*/
/***************************************************************************/

int NewAutoFirst( int iStatus )
{
#ifdef NET_SUPPORT
	char			*szBuf;

	szBuf = GetMemory( 100 );					/* Add net upgrade line if			*/
	if ( NetUpgradeStr( szBuf ) )				/* it's needed							*/
		iStatus = NewFilePuts( szBuf, NewFile );
	FreeMemory( szBuf );
#endif
	return( iStatus );
}

/***************************************************************************/
/* Adds new lines to the end of the new autoexec.bat file based on the		*/
/* user's selected options and whether or not the lines were already       */
/* detected and updated during the processing of the lines in the original */
/* autoexec.bat file.																		*/
/* 																								*/
/* int NewAutoLast( int iStatus )														*/
/* 																								*/
/* ARGUMENTS:	iStatus	- Current error status of the file processing		*/
/* RETURNS: 	int		- OK if successfull else ERROR							*/
/* 																								*/
/***************************************************************************/

int NewAutoLast( int iStatus )
{
	register 	i; 								/* Loop indice							*/
	register		iDefault;						/* Default file strings	indice	*/
	int			iAddFlags[ MAX_TO_ADD ];	/* Flags line not added yet		*/

	iAddFlags[ 0 ] = !DevFlags.fPath;				/* Path may be done			*/
	iAddFlags[ 1 ] = !DevFlags.fMouse;				/* Mouse may be done 		*/

											/* We know doskey and shell not done yet	*/
	iAddFlags[ 2 ] = iAddFlags[ 3 ] = TRUE;

									/* If string was created in the default list 	*/
									/* and has not already been processed we	need	*/
									/* to add it to the end of the file					*/

	for ( i = 0, iDefault = PATH_STRING;
			iStatus == OK && i < MAX_TO_ADD;
			i++ )
	{
		if ( iFlags[ i ] )							/* If exists in default list	*/
		{
			if ( iAddFlags[ i ] )					/* If still needs to be added */
				iStatus = NewFilePuts( apszDefault[ iDefault ], NewFile );

			iDefault++; 							/* Index next str in default list */
		}
	}
	return( iStatus );
}

/***************************************************************************/
/* Processes each line in the original autoexec.bat file and copies the 	*/
/* lines to the new file in the root directory. The lines to be changed 	*/
/* are:																							*/
/* 																								*/
/* d:\xxx\DOSSHELL				 ; REM out the line									*/
/* SET COMSPEC 					 ; REM out the line									*/
/* d:\xxx\DOSHELL 				 ; REM out line if vInfo.fShell == TRUE		*/
/* d:\xxx\DOSKEY					 ; REM out line if vInfo.fDosKey == TRUE		*/
/* 																								*/
/* PATH								 ; Prefix new dos directory path and set		*/
/* SET PATH=						 ; flag to show it's been processed          */
/* d:\xxx\MOUSE					 ; Change path if vInfo.fMouse == TRUE	and	*/
/* 										set flag to show it's been processed		*/
/* 																								*/
/* NOTE: Need to REM out the existing lines rather than delete them. 		*/
/* 																								*/
/* int ProcessAutoStr( int iStatus	)													*/
/* 																								*/
/* ARGUMENTS:	iStatus	- Current error status. (not used by function)		*/
/* RETURNS: 	int		- OK if sucessfull else ERROR 							*/
/* 																								*/
/***************************************************************************/

int ProcessAutoStr( int iStatus )
{

	char				*szPtr;
	char				*szTmp;
	char				szName[ MAX_FNAME_LEN + 1 ];							/* m104 */
	register 		iFound;

	ThisLine.fCopyOld = TRUE;
	ThisLine.fHasPath = ThisLine.fRemOut = ThisLine.fHasExt = FALSE;

	szNewString[0] = EOL;							/* Setup for later strcat()	*/
	szTmp = SkipLeadingWhite( szOldString );	/* Point to 1st char in str	*/

	if ( *szTmp == COLON )							/* If it's a label just keep	*/
	{														/* the orginal string			*/
		strcat( szNewString, szOldString );
		return( iStatus );
	}

	szPtr = ParseFileName( szTmp );
	if ( szTmp != szPtr )
		ThisLine.fHasPath = TRUE;									/* Path check		*/

	ExtractNextWord( szPtr, szName, MAX_FNAME_LEN + 1 );	/* m104 Get cmd name*/
	if ( (szTmp = strchr( szName, '.' )) != NULL )
		*szTmp = EOL, ThisLine.fHasExt = TRUE;					/* Remove ext		*/

	if ( (iFound = StrSearch( szName, apszCmdStrs )) != -1 )
	{
		if ( !(ThisLine.fHasPath || ThisLine.fHasExt ) )
		{
			if ( iFound == CMD_SET )
			{
				szPtr = SkipWord( szPtr ); 				/* Skip to variable name */
				if ( strnicmp( szPtr, szPathCmd, PATH_CMD_LEN ) == OK )
					iFound = CMD_PATH;						/* Process farther down */

				else if ( strnicmp( szPtr, szComspec, COMSPEC_LEN ) == OK )
					ThisLine.fRemOut = TRUE;				/* Change line remark	*/
			}

			if ( iFound == CMD_PATH )
			{
				CreateEnvPath( szPtr ); 					/* Add new	path str 	*/
				ThisLine.fCopyOld = FALSE;
				DevFlags.fPath = TRUE;
			}
		}

	   if ( iFound == CMD_DOSSHELL )
		{
			if ( !vInfo.Flag.fShell )
				ThisLine.fRemOut = TRUE;
			else
				ThisLine.fDelLine = TRUE;
		}

		#ifdef ADD_MOUSE
			else if ( iFound == CMD_MOUSE && vInfo.Flag.fMouse )
			{
				ThisLine.fCopyOld = FALSE;
				DevFlags.fMouse = TRUE;
				BuildPath( szNewString, vInfo.szPath[0], vInfo.szPath+2, szPtr );
			}
		#endif
	}
	else if ( IsDosFile( szName ) )			/* See if need a path change		*/
	{
		ThisLine.fCopyOld = FALSE;
		BuildPath( szNewString, vInfo.szPath[0], vInfo.szPath+2, szPtr );
	}		
	else if ( FindDataMatch( szName, DELETE_FILE ) )
		ThisLine.fDelLine = TRUE;

	if ( ThisLine.fCopyOld )
		strcat( szNewString, szOldString );	/* Just copy old string				*/

	iStatus = OK;
	if ( ThisLine.fDelLine )
		iStatus = DEL_LINE;
	else if ( ThisLine.fRemOut )
		iStatus = REM_LINE;

	return( iStatus );
}

/***************************************************************************/
/* Creates a new path string from the existing path string. First seperates*/
/* the existing path string into individual paths and then creates a new	*/
/* string using the DOS path for the first entry and then appending each	*/
/* of the original strings. A check is done to be sure that if the DOS		*/
/* path is in the old string it is not duplicated in the new.					*/
/*																									*/
/*	NOTE:																							*/
/*			The value 64 for length of array of ptrs is derived from max of	*/
/*		   128 byte string / min 2 char path entry ";\".							*/
/*																									*/
/*	void CreateEnvPath( char *szString )												*/
/*																									*/
/*	ARGUMENTS:	szString	- Ptr to "PATH= xxxx" string from autoexec file		*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void near CreateEnvPath( char *szString )
{
	char		*TmpBuf;
	char		*chBuffer;							/* Work buffer							*/
	char		**apszPaths;						/* Ptrs to individ path strs		*/
	char		*chPtr;								/* Ptr to start of individ path	*/
	char		*pchEnd;								/* Ptr to end of old PATH string	*/
	int		i;										/* Indice for array apszPaths		*/


	chBuffer = GetMemory( MAX_LEN * 4 );
	TmpBuf = chBuffer + (MAX_LEN * 2);
	apszPaths = GetMemory( MAX_LEN * sizeof( char * ) );

	szString = SkipWord( szString );				/*	Jump over "PATH "				*/

	strcpy( chBuffer, szString );					/* Copy string to work buffer	*/

	chPtr = chBuffer;
	RemoveSpaces( chBuffer );						/* Clean up the string			*/
	pchEnd = strchr( chBuffer, EOL ); 			/* Find end of string			*/
	ReplaceChar( chBuffer, ';', EOL );			/* Convert to individ string	*/

	for ( i = 0; chPtr < pchEnd; i++ )
	{
		apszPaths[i] = chPtr;						/* Save pointer to this path	*/
		chPtr = strchr( chPtr, EOL ) + 1;		/* Find end of this path		*/
	}
	apszPaths[i] = NULL;								/* Mark end of array				*/

	strcpy( szNewString, "PATH " );
	if ( apszPaths[0][0] != '>' )
		strcat( szNewString, vInfo.szPath );	/* Add new DOS path 				*/

	for ( i = 0; apszPaths[i] != NULL; i++ ) 	/* Append original path strs	*/
	{
		strcpy( TmpBuf, apszPaths[i] );
		RemoveTrailing( TmpBuf, '\\' );
															/* Chk for duplicate path		*/
		if ( strcmpi( TmpBuf, vInfo.szPath ) != OK )
		{
			strcat( szNewString, ";" ); 			/* Not duplicate so append		*/
			strcat( szNewString, apszPaths[i] );
		}
	}

	FreeMemory( chBuffer );
	FreeMemory( apszPaths );
}

/***************************************************************************/
/* Checks to see if the specified command is really a DOS command which		*/
/* was copied from the distribution disks. The specified command may			*/
/* or may not contain an extension.														*/
/*																									*/
/*	int IsDosFile( char *szName )															*/
/*																									*/
/*	ARGUMENTS:	szName	- Ptr to command name or file name string				*/
/*	RETURNS:		int		- TRUE if command or filename is a DOS file on the	*/
/*								  distribution disk. Else FALSE.							*/
/***************************************************************************/

int near IsDosFile( char *szName )
{
	register			i;
	char				*szExt;
	char				szFile[ MAX_FNAME_LEN + 1 ];							/* m104	*/
	extern char		*szExeExt[];

	strncpy( szFile, szName, MAX_FNAME_LEN );								/* m104 */
	*(szFile + MAX_FNAME_LEN) = EOL;							/* m104 Error check */

	if ( (szExt = strchr( szFile, '.' )) == NULL )
		szExt = strchr( szFile, EOL );
	*(szExt++) = '.';

				/* Check for a base name which has more than 8 characters	*/
				/* the last line of code may have destroyed the EOL marker	*/
				/* so exit function on bad name										*/
	if ( (szExt - szFile) > (MAX_FNAME_LEN - FILE_EXT_LEN) )		/* m104	*/
		return( FALSE );										/* m104 Bad file name*/

	for ( i = 0; szExeExt[i] != NULL; i++ )
	{
		
		strcpy( szExt, szExeExt[i] );
		if ( IsDistrFile( szFile ) && !FindDataMatch( szFile, RE_NAME ) &&
			  !FindDataMatch( szFile, NET_FILES ) ) 
			return( TRUE );
	}
	return( FALSE );
}

/***************************************************************************/
/* Renames a file to a unique file with the same primary name but with an	*/
/* extension in the form of an ascii integer value between 0 & 999.			*/
/*																									*/
/*	int UniqueRename( char *szFile )														*/
/*																									*/
/*	ARGUMENTS:	szFile	- Full path and file name to be renamed				*/
/*					szName	- Buffer to copy new file name to or NULL				*/
/*	RETURNS:		int		- OK if successfull else ERROR							*/
/*																									*/
/***************************************************************************/

int near UniqueRename( char *szFile, char *szName )
{
	register	i;
	char		*szExt;
	char		*szTmp;
	char		szNew[ MAX_PATH_LEN ];


	if ( !FileExists( szFile ) )
		return( OK );

	strcpy( szNew, szFile );
	szExt = ParseFileName( szNew );

	if ( (szTmp = strchr( szExt, '.' )) != NULL )
		szExt = szTmp + 1;
	else
		szExt = strchr( szExt, EOL );

	for ( i = 1; i < 999; i++ )
	{
		itoa( i, szExt, 10 );
		if ( rename( szFile, szNew ) == OK )
		{
			if ( szName != NULL )
				strcpy( szName, szNew );
			return( OK );
		}
	}
	return( ERROR );
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\b_disk.asm ===
page	,132
	title	b_disk
;***
;b_disk.asm - contains the _bios_disk() function
;
;	Copyright (c) 1987-1990, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	This module contains the _bios_disk() function.
;
;*******************************************************************************

include model.inc
include dpmi.inc

   .286
	.xlist
	.list

extrn lpInt13Buf:DWORD
extrn lpfnInt13Func:DWORD

diskinfo_t struc
_drive	dw	?		; 0-3 or 0x80-0x81
_head	dw	?		; 0-?
_track	dw	?		; 0-1023
_sector dw	?		; 0-16
_numsec dw	?		; 0-128
_buffer dd	?
diskinfo_t ends

.data

RealModeCallFrame	RealModeCallStruc	<>

.CODE

page
;***
;unsigned _bios_disk(service, p_diskinfo) - BIOS disk services
;
;Purpose:
;	The function "_bios_disk" allows direct access to the BIOS
;	services to access floppy diskettes and hard disks.
;	These BIOS services are called via INT 13h.
;
;
;Entry:
;	unsigned service - the diskette/disk service requested
;	struct diskinfo_t {
;		unsigned drive;
;		unsigned head;
;		unsigned track;
;		unsigned sector;
;		unsigned nsectors;
;		void far *buffer;
;	} *p_diskinfo	-	contains diskette/disk parameters
;
;Exit:
;	AL = disk status byte (0 means success, otherwise error)
;
;Uses:
;	BX, CX, DX
;
;Exceptions:
;
;*******************************************************************************


_bios_disk	proc  uses ds si di, service:word, p_diskinfo:word

	mov	ah, byte ptr service
	mov 	bx, p_diskinfo

   cmp        ah, 5
   je         special_format_code

	mov	dl,byte ptr [bx._drive]
	cmp	ah,2
	jb	do_int13	; do not load other regs for services 0 and 1

	mov	dh,byte ptr [bx._head]
	mov	cx,[bx._track]
	xchg	ch,cl
	ror	cl,1		   ; bits 8 and 9 of track are stored
	ror	cl,1		   ; in the high two bits of CL
	and	cl,0C0H 	              ; clear off unused lower bits
	or	cl,byte ptr [bx._sector]
	mov	al,byte ptr [bx._numsec]
	les	bx,[bx._buffer]

do_int13:
	int	13H		   ; request diskette/disk service

	ret

special_format_code:
;
; We have some special code here that will handle int 13h func 5 (format track.)
; This code is necessary to work around a bug in some older Compaq BIOS's. The bug
; will crop up if you have emm386 loaded and you use int 13 to format a floppy disk
; track from standard mode. (pmode).
;
; The fix for this is to execute the int 13 in real mode via the DPMI provided
; "Call Real Mode Procedure with Far return". DOS 1 CUI has left us a bit of code in
; his resident stub that will to the int 13h followed by a far ret. We get the seg:off
; of the int 13h stub in DOS 1 CUI via the vinfo structure.

;
; Convert real mode segment into protected mode selector
;

   push  bx
   mov   ax,SEG_TO_DESC           ; Function to convert segment to descriptor.
   mov   bx,word ptr lpInt13Buf+2 ; bx = real mode segment.
   int   DPMI                	  ; ax = protect mode selector.
   pop   bx
   jc    err_no_mem

   ;
   ; Now, copy _buffer into the real mode addressable memory
   ;
   mov	es,ax
   mov	di,word ptr lpInt13Buf	; es:di -> destination buffer
   push  ds
   lds   si,[bx._buffer]        ; Source pointer loaded into ds:si
   mov   cx,256d                ; Move 256 words (512 bytes.)
   cld                          ; Assure that we increment si,di
   rep   movsw
   pop   ds
   ;
   ; Now, we need to prepare the real mode call data structure so that we can
   ; ask DPMI to call our real mode int 13h stub.
   ;
	lea   di, [RealModeCallFrame]
	mov   byte ptr [di].RegEAX+1, 05        ; ah = 5  Int 13h / func 5
   mov   al, byte ptr [bx._numsec]
	mov   byte ptr [di].RegEAX,al           ; al = Num sectors.
   mov   al, byte ptr [bx._head]
   mov   byte ptr [di].RegEDX+1, al        ; dh = Head number.
   mov   al, byte ptr [bx._drive]
   mov   byte ptr [di].RegEDX, al          ; dl = Drive number.

   mov   ax, word ptr lpInt13Buf
   mov   word ptr [di].RegEBX, ax
   mov   ax, word ptr lpInt13Buf+2
   mov   [di].RegES, AX                    ; es:bx = ptr to real mode buffer

	mov   cx,[bx._track]
	xchg  ch,cl
	ror   cl,1		                  ; bits 8 and 9 of track are stored
	ror   cl,1	           	       ; in the high two bits of CL
	and   cl,0C0H 	                  ; clear off unused lower bits
   mov   word ptr [di].RegECX, cx          ; cx = Track.
   mov   [di].RegSS,0                      ; ss:sp 0:0 to force DPMI to
   mov   [di].RegSP,0                      ; give us a 30 word stack.
	pushf
	pop   ax                                ; flags.
	mov   [di].RegFlg,ax
   mov   ax, word ptr lpfnInt13Func
   mov   [di].RegIP, ax                    ; cs:ip = pointer to real mode
   mov   ax, word ptr lpfnInt13Func+2
   mov   [di].RegCS, AX                    ; call address, seg:off
	;
	; Call real mode procedure with far return.
	;
	mov   ax, ds
	mov   es, ax	      ; es:di = RealModeCallStruc
   mov   bh, 0                 ; should be zero to avoid A20 state change.
   xor   cx,cx                 ; Number or words to copy from pmode to real mode stack.
   mov   ax,CALL_REALMODE_PROC ; DPMI Func 301h
	int   DPMI

   ;
   ; Lastly, we get the real mode int 13h AX and flag returns from the
   ; RealModeCallFrame so we can determine the outcome of our int 13h call.
   ;
	lea   di, [RealModeCallFrame]
   mov   ax, word ptr [di].RegEAX ; Get AX into ax.
   ret

err_no_mem:
   mov   ax,-1
   ret

_bios_disk	endp
	end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\dos2.c ===
//=========================================================================
// 																								
// DOS2.C																					   
// 																								
//		Copyright (c) 1992 - Microsoft Corp.											
//		All rights reserved.																	
//		Microsoft Confidential																
// 								  																
// This is the main module for the GUI portion of the combined DOS/WINDOWS
//	setup program. It intializes the main window for the program, registers
// the progress dialog window class and the sbuttin window class, initializes
// the Dos upgrade and calls off to wsUpgradeHard.
// 
// Created 01-25-92
//
//=========================================================================

#include <winenv.h>
#include	<install.h>
#include "pro.h"
#include "wsrc.h"
#include "ws.h"
#include "doscode.h"
#include "sbutton.h"
#include "lib\common\sulib.h"

extern HWND  ghWnd;               // declared in pro.c
extern DWORD DptPtr;

/* Local function prorotypes. */

long FAR PASCAL WndProc     (HWND, WORD, WORD, LONG) ;
void PRIVATE wsInstallDos(void);

HWND hwndParent;
HANDLE hinstWS;

BOOL bIsUpgrade = TRUE;
char szHimemSwitch[80] = "";  //BUGBUG


/* int PASCAL WinMain (HANDLE hInstance, HANDLE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow);
 * 
 * Entry point for DOS2GUI. Handles init, calls secondary dispatcher
 * wsInstallDos.
 *
 * ENTRY: hInstance     - This instance handle.
 *        hPrevInstance - Handle to previous instance, NULL if were the first.
 *        lpszCmdLine   - Command line.
 *        nCmdShow      - How do we init ? (full screen, iconized, ?).
 *
 * EXIT: None.
 *        
 */
int PASCAL WinMain (HANDLE hInstance, HANDLE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
	WNDCLASS    wndclass ;

	if (hPrevInstance)
	     return FALSE ;

   dsStartWait();   // Put up hourglass while we do all this init stuff.
   wsYield(NULL);   // Yield to allow repaint before we get started.

	hinstWS = hInstance;

   /*  Register setup's own personal dialog class. We do this so that we
    *  can have generic help and exit buttons on all the setup dialogs
    *  that need them.
    */

   wndclass.hCursor       = LoadCursor(NULL,IDC_ARROW);
   wndclass.hIcon         = NULL;
   wndclass.lpszMenuName  = NULL;
   wndclass.lpszClassName = CLS_MYDLGS;
   wndclass.hbrBackground = NULL;
   wndclass.hInstance     = hInstance;
   wndclass.style         = CS_DBLCLKS | CS_SAVEBITS | CS_BYTEALIGNWINDOW;
   wndclass.lpfnWndProc   = wsDefSetupDlgProc;
   wndclass.cbClsExtra    = 0;
   wndclass.cbWndExtra    = DLGWINDOWEXTRA;

   if (!RegisterClass(&wndclass))
      return FALSE;

	/* Register the "Status Text" and "Special button" classes. */

	if (!ControlInit(hPrevInstance,hInstance))
		return FALSE;

	if (!ProInit(hPrevInstance, hInstance)) // progress dialogs!
		return FALSE;

	wsExitInit();

	wsInstallDos();
}

/* void PRIVATE wsInstallDos(void);
 *
 * Secondary level dispatcher. Handle some init work, call off to main
 * dispatcher wsUpgradeHard. Could this be modularity for modularitys sake ?
 *
 * ENTRY: None.
 *
 * EXIT: None.
 *
 */
void PRIVATE wsInstallDos(void)
{
	int nFiles;

   if ( InitDosUpgrade() ) {
      /*
       *  Some welcoming UI telling user to prepare an uninstall disk(s),
       *  Let'em quit if they get scared, provide help, ect. Allow repaint
       *  after we take the dialog down, turn on arrow cursor.
       */

      dsEndWait();

#if 0
		if ( lpInstall->Flags.fUninstall )
		   fDialog(DLG_UNINSTALLINFO,GetActiveWindow(),dsWelcomeDlg);
#endif

      wsYield(NULL);

      /*
       *  Ok, now get on with it, first display the gas gauge.
       */
		ProOpen(NULL,DLG_PROGRESS,NULL);  // Prepare progress dialog.
		ProClear(NULL);
		ProSetBarPos(0);

		nFiles = CopyDosFiles();	// get count of DOS files	

      ProSetBarRange(nFiles+21);

		DptPtr = GlobalDosAlloc(16);

		WinAssert ( DptPtr != NULL );

		GetDPTVec();
      wsUpgradeHard();

		ProClose();

		GlobalDosFree( (UINT) DptPtr );
   }
   else
      AppQuit();

	wsExitTerm(NULL);
   CleanUpDroppings();

	fDialog( DLG_DOSREBOOT, GetActiveWindow(), (FARPROC) wsExitDlg );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\doscode.h ===
/***************************************************************************/
/* DOSCODE.H																					*/
/*
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/*	This module serves as the calling interface between the Windows and		*/
/* DOS portition of the DOS/WINDOWS combined Setup program.						*/
/*																									*/
/* 																								*/
/*	05-23-91 johnhe																			*/
/***************************************************************************/


/*
	FUNCTION PROTOTYPES
*/

int  far	IsDosUpgrade				( char *szWinPath );
BOOL far InitDosUpgrade				( void );
void far wsCreateRecoveryFloppy	( void );
int  far	CopyDosFiles				( void );
void far wsBuildConfigPath       ( char *szPath, char *szDeviceName );
void far wsUpgradeHard				( void );
char far * far AutoFixup			( char far *InBuf, int StartWin );

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\d_setvec.asm ===
page	,132
;============================================================================
	title	d_setvec - Set Interrupt Vector
;============================================================================
;
;   (C) Copyright MICROSOFT Corp. 1991-1992
;
;   Title:    DOS2.EXE - GUI Portion of DOS Install
;
;   Module:   D_SETVEC - Direct interface to DOS "set interrupt vector" 
;			 system call.
;
;   Version:  0.001
;
;   Date:     Jan 26,1992
;
;   Author:   HKN
;
;============================================================================
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   01/26/92  Original
;
;============================================================================

include model.inc
include dpmi.inc

.data

public ProtDskParmsPtr	
public RealDskParmsPtr
public DptPtr	
public PMPtr		
public RMPtr		


ProtDskParmsPtr	dd	?
RealDskParmsPtr	dd	?
DptPtr	label	dword
PMPtr		dw	?
RMPtr		dw	?

.code

page

;===========================================================================
;
;	Procedure 	: _dos_setvect
;
;	Input		: interrupt = interrupt number
;			  handler = address of new handler
;			  ProtDskParmsPtr = Sel:Off of the int 1eh vec at 
;			  program startup
;			  RealDskParmsPtr = Seg:Off of the int 1eh vec at 
;			  program startup
;			
;
;	Output		: Sets the int vector.
;
;	Description:
;		This is provided to serve the needs of the _dos_setvec calls
;	made by the common libraries used by the DOS setup program. The 
;	_dos_setvec calls are made to set and reset the int 1eh vector 
;	when doing general disk io. It is required that the real mode int 
;	1eh vector be changed to reflect the data that is pointed to by 
;	the input parm 'handler'. Since this input parm is in the form of
;	a sel:off we copy 13bytes (length of the DPT) into our DOS buffer
;	that was allocated at program startup (PMPtr=Sel:off of real mode
;	buffer  and RMPtr=Seg:off of real mode buffer) and set the real mode 
;	int 1eh vector to RMPtr. 
;
;===========================================================================

_dos_setvect	proc	uses ds si es di cx, interrupt:word, handler:dword


	mov	ax, ds
	mov	es, ax			; es = data segment
	mov	ax, interrupt
	lds	dx, handler

	cmp	al, 01eh		; Q: are we seeting the DPT vector
	je	DS1			; Y: continue 
					; N: just do int 21
	mov	ah, 25h
	int	21h
	jmp	short DSdone

DS1:
	;
	; If we are just resetting the 1eh vector back to the original 
	; value we just do an int 21h and set the real mode int 1eh vec
	; back to RealDskParmsPtr. else we must copy the contents pointed
	; to by 'handler' to our local real mode buffer and set the int
	; 1eh vec to our local real mode buffer.
	;
	cmp	dx, word ptr es:[ProtDskParmsPtr]
	jne 	DS2			
	mov	si, ds
	cmp	si, word ptr es:[ProtDskParmsPtr + 2]
	jne	DS2			

	mov	ah, 25h
	int	21h

	mov	bl, 01eh
	mov	dx, word ptr es:[RealDskParmsPtr]
	mov	cx, word ptr es:[RealDskParmsPtr + 2]
	mov	ax, SET_REALMODE_INTVEC
	int 	DPMI

DSdone:
	xor	ax,ax			;routine is supposed to return void...
	ret

DS2:
	;
	; We must now copy the contents of the buffer which is of length 
	; equal to DSK_PARAM_LEN defined in disk_io.h = 13. Then we do
	; a DPMI Set Real Mode Interrupt Vector call.
	;
	push	es
	mov	cx, 13
	mov	si, dx		; ds:si -> user buffer
	xor	di, di
	mov	es, es:PMPtr	; es:di -> our DPT buffer
rep	movsb
	pop	ds	    	; ds = data segment
	
	mov	cx, RMPtr
	xor	dx, dx		; cx:dx = real mode address of our DPT buffer
	mov	bl, al
	mov	ax, SET_REALMODE_INTVEC
	int 	DPMI

	mov	dx, es
	mov	ds, dx
	xor	dx, dx
	mov	ax, 251eh
	int	21h
	jmp	short DSdone
	
_dos_setvect	endp

;===========================================================================
;
;	Procedure	: GetDPTVec
;
;	Input		: None
;	Output		: Initializes the foll:
;			  ProtDskParmsPtr to Sel:off of current int 1eh vec
;			  RealDskParmsPtr to Seg:off of current int 1eh	vec
;			  PMPtr to Sel:off of real mode buffer.
;			  RMPtr to Seg:off of real mode buffer
;
;===========================================================================

GetDPTVec	proc 	uses dx bx es

	mov	ax, 0351eh
	int	21h
	mov	word ptr ProtDskParmsPtr, bx
	mov	word ptr ProtDskParmsPtr + 2, es

	mov	bl, 01eh
	mov	ax, GET_REALMODE_INTVEC
	int	DPMI
	mov	word ptr RealDskParmsPtr, dx
	mov	word ptr RealDskParmsPtr + 2, cx
	ret

GetDPTVec 	endp

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\dpmi.inc ===
;
; Real Mode call structure for Simulating Real Mode Interrupts using DPMI
;
RealModeCallStruc	Struc

RegEDI	dd	?
RegESI	dd	?
RegEBP	dd	?
Regres	dd	?
RegEBX	dd	?
RegEDX	dd	?
RegECX	dd	?
RegEAX	dd	?
RegFlg	dw	?
RegES	dw	?
RegDS	dw	?
RegFS	dw	?
RegGS	dw	?
RegIP	dw	?
RegCS	dw	?
RegSP	dw	?
RegSS	dw	?

RealModeCallStruc	Ends

DPMI			EQU	031h

ALLOC_LDT_DESC		EQU	0000h
SEG_TO_DESC		EQU	0002h
SET_SEG_BASE_ADDR	EQU	0007h
SET_SEG_LIMIT		EQU	0008h
ALLOC_DOS_MEM_BLOCK	EQU	0100h
FREE_DOS_MEM_BLOCK	EQU	0101h
SET_REALMODE_INTVEC	EQU	0201h
GET_REALMODE_INTVEC	EQU	0200h
SIMULATE_RELMODE_INT	EQU	0300h
CALL_REALMODE_PROC      EQU     0301h


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\dsk_rset.asm ===
;========================================================
COMMENT #

	DSK_RSET.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Instructs DOS to do a reset of all it's disk buffers.
	Also sets the DiskChange variable to 1. The address
	of this is in DiskChangePtr initialized in upginit.c.
	This variable is checked by the retail upgrades int13
	handler in ..\common\newint13.asm .

	int	_dos_dskreset( void )

	RETURNS: void

	================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

;INCLUDE	disk_io.inc
INCLUDE	model.inc
 	
; =======================================================


EXTRN	DiskChangePtr:DWORD

.CODE


; =======================================================

_dos_dskreset PROC USES ES BX

	les	bx, [DiskChangePtr]
	mov	byte ptr es:[bx], 1
	mov	AH,0dh
	int	21h
	ret

_dos_dskreset ENDP

; =======================================================

	END

; =======================================================

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\config.c ===
/***************************************************************************/
/*																									*/
/* CONFIG.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* Processes the CONFIG.SYS file in the root directory or creates one		*/
/* if it doesn't already exist.															*/
/*																									*/
/* NOTE:																							*/
/* 		In order to correctly process the mouse driver the config.sys		*/
/* 		file processing must be done before calling ProcessAutoexec().		*/
/* 		This will insure that any existing mouse.sys driver in the			*/
/* 		config.sys file has been identified and removed and the				*/
/* 		vInfo.fMouse flag	has been set to signal adding mouse to				*/
/* 		autoexec.bat.																		*/
/*																									*/
/*																									*/
/* Change log:																					*/
/*																									*/
/*   	Date      Who   #		Description													*/
/* 	--------  ---  ----	---------------------------------------------	*/
/*      12/07/89  JAH          Created													*/
/*      02/19/91  DLB  M006    Rename HIMEM.DOS and EMM386.DOS to				*/
/*										 HIMEM.SYS and EMM386.EXE. Also move EMM386	*/
/*										 after rename is done, not before.				*/
/*																									*/
/***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <io.h>
#include <dos.h>
#include <string.h>
#include <ctype.h>

#include	<alias.h>
#include <global.h>
#include <strlib.h>
#include <data.h>
#include	<upgrade.h>
#include	<errors.h>
#include	<prompts.h>

/***************************************************************************/

extern void	NewAutoConfig	( int iType, char *szFile );
void		ProcessFile			( int iType, char *szOldFile, char *szNewFile,
									  int (*Funcs[])( int iStatus ) );
int		BuildNewFile( int (*Funcs[])( int Status	) );
void		CreateDeviceLine	( char *szLine, char *szDevice, int iType );
/* void		ProcessConfig		( void ); */
int		NewConfigFirst		( int iStatus );
int		NewConfigLast		( int iStatus );
int		ProcessConfigLine	( int iStatus );

char		*NewFileGets		( char *szBuffer, int Count, FILE *File );
int		NewFilePuts			( char *szString, FILE *File );

static int near	ProcessShellLine	( char *szStr );
static int near	ProcessDeviceLine	( char *szPtr, int iType	);
static int near	InstallNewDrivers	( void );
static int near	AddNewDevice		( char *szDevName, int iType	);
static void	near	MoveToEndFile		( char *szStr, int iDevice );

static int	near AddDrvParm		( void );
static int	near add_driv_line	( char *szDrivparm, UCHAR uchDrv );
static void near find_drive		( UCHAR *puchDrv1, UCHAR *puchDrv2 );

/***************************************************************************/

/* M006 */
enum			DEV_TAGS 		{ HIMEMSYS, HIMEMDOS, SMARTDRV, EMM386SYS, EMM386DOS, EMM386EXE,
									  MOUSE, RAMDRIVE, EGASYS, SHARE, SETVER,
									  LAST_DEVICE };

#define		MAX_LEN			256		/* Max length of line in autoexec.bat	*/
#define		STR_BUF_LEN		128
#define		MAX_RAM_DRIVE	23 		/* Max number of RAM drives installed	*/
#define		MAX_DEV_LINE	RAMDRIVE + MAX_RAM_DRIVE + 1

#define		HIMEM_SYS		Devices[ HIMEMSYS ]     /* M006 */
#define		HIMEM_DOS		Devices[ HIMEMDOS ]     /* M006 */
#define		SMARTDRV_SYS	Devices[ SMARTDRV ]
#define		EMM386_SYS		Devices[ EMM386SYS ]
#define		EMM386_DOS		Devices[ EMM386DOS ]    /* M006*/
#define		EMM386_EXE		Devices[ EMM386EXE ]
#define		MOUSE_SYS		Devices[ MOUSE ]
#define		RAMDRIVE_SYS	Devices[ RAMDRIVE ]

#define		DEVICE			0			/* Specifies a device driver				*/
#define		INSTALL			1			/* Specifies an installable program 	*/
#define		LOAD_HIGH		2

#define		REM_LINE			1
#define		DEL_LINE			2

/***************************************************************************/

/* declared in upgrade.c */
extern char		*szAutoBat; 			/* Autoexec drive, path and name str	*/
extern char		*szConfSys;				/* Config.sys drive, path and name str */

FILE		*OldFile;						/* File handle for existing autoexec	*/
FILE		*NewFile;						/* File handle for new autoexec			*/

char		*szNewString;					/* Config.sys line for new file			*/
char		*szOldString;					/* Config.sys line from old file			*/

char 				*szShell   	= "SHELL=";
char				*szCommandShell = "COMMAND.COM ";

static char 	*szDevice  	= "DEVICE=";
static char 	*szInstall 	= "INSTALL=";
static char		*szLoadHi	= "DEVICEHIGH=";
static char		*szDosEqu  	= "DOS";
static char		*szShellEqu	= "SHELL";
static char		*szInstallEqu = "INSTALL";
static char		*szDeviceEqu = "DEVICE";
static char		*szLoadHiEqu = "DEVICEHIGH";

struct BITS
{
	unsigned 	fXma			:1;
	unsigned 	fHimem		:1;
	unsigned 	fSmartDrv	:1;
	unsigned 	fRamDrv		:1;
	unsigned 	fEmm386		:1;
	unsigned 	fPath 		:1;
	unsigned 	fMouse		:1;
	unsigned 	fDosKey		:1;
	unsigned 	fDosShell	:1;
	unsigned 	fNeedHiMem	:1;
	unsigned		fHaveDosEqu	:1;
	unsigned		fHaveEga		:1;
	unsigned		fHaveComspec:1;
} DevFlags;

/* M006 */
static char	*Devices[] = { "HIMEM.SYS", "HIMEM.DOS", "SMARTDRV.SYS",
									"EMM386.SYS", "EMM386.DOS", "EMM386.EXE", "MOUSE.SYS",
									"RAMDRIVE.SYS", "EGA.SYS", "SHARE.EXE",
									"SETVER.EXE", NULL };

static UCHAR DeviceNameLen[] = { (UCHAR) 9, (UCHAR) 9, (UCHAR) 12,
											(UCHAR) 10, (UCHAR) 10, (UCHAR) 10, (UCHAR) 9,
											(UCHAR) 12,	(UCHAR) 7, (UCHAR) 9,
											(UCHAR) 10, (UCHAR) 0 };
/* M006 */

static char *DeviceLines[ MAX_DEV_LINE ];
static int	RamDriveCount;				/* # of times RAMDRIVE installed 	*/

/***************************************************************************/
/* Process an autoexec or config.sys file by opening the old file and and	*/
/* and creating a new file and then passing a series of parsing functions	*/
/* from the caller to BuildNewFile(). If the original file doesn't exist	*/
/* or there is an error creating the new file a new file will be created	*/
/* using the information in the vInfo structure.									*/
/*																									*/
/*	void ProcessFile( int iType, char *szOldFile, char *szNewFile,				*/
/*						int (*Funcs[])( int iStatus ) )									*/
/*																									*/
/*	ARGUMENTS:	iType			- 0 == AUTOEXEC.BAT, 1 == CONFIG.SYS				*/
/*					szOldFile	- Name of existing file to process					*/
/*					szNewFile	- Name for new file to be created					*/
/*					Funcs			- Array of ptrs to file processing functions		*/
/*	RETURNS:		void																			*/
/*																									*/
/* 																								*/
/***************************************************************************/

void ProcessFile( int iType, char *szOldFile, char *szNewFile,int (*Funcs[])( int iStatus ) )
{
	register	iStatus;

	iStatus = ERROR;

	if ( !vInfo.Flag.fNewSysFiles &&
		  (OldFile = fopen( szOldFile, "rt" )) != NULL )
	{
		if ( (NewFile = fopen( szNewFile, "wt" )) != NULL )
		{
			iStatus = BuildNewFile( Funcs );
			iStatus |= fclose( NewFile );
		}
		iStatus |= fclose( OldFile );

		if ( iStatus != OK )
			ProcessCopyError( szOldFile, ERR_PROCESSING );
	}
											
	if ( iStatus != OK )
		NewAutoConfig( iType, szNewFile );
}

/***************************************************************************/
/* Generic file processing function. Accepts an array of 3 pointers to 3	*/
/* functions which will do the actual processing of the file. The 3			*/
/* 3 functions must be provided which do the following with the int arg 	*/
/* passed to the function the current error status up to that point. 		*/
/* 																								*/
/* int Function1( int ) - Add new lines to the file which are needed 		*/
/* 							  before lines from the original file are processed*/
/* int Function2( int ) - Called once for each line found in original file */
/* 							  returns 0 if line is to be added else !0			*/
/* 							  The line read from the file is in szOldString &	*/
/* 							  the function fills in szNewString to be written	*/
/* int Function3( int ) - Cleanup function to do anything needed before 	*/
/* 							  the new file is closed.									*/
/* 																								*/
/* 																								*/
/* int BuildNewFile( *Func[])( int Status ) )										*/
/* 																								*/
/* ARGUMENTS:	Funct 	- Array of pointers to 3 functions.						*/
/* RETURNS: 	int		- OK if sucessfull else ERROR 							*/
/* 																								*/
/* NOTE: When a line is specified for not being copied it is prefixed		*/
/* 		with a REM and written anyway.												*/
/***************************************************************************/

int BuildNewFile( int (*Func[])( int Status	) )
{
	register 	iStatus;
	register		iToDo;

	szOldString = GetMemory( MAX_LEN * 3 );
	szNewString = szOldString + (MAX_LEN + 10);

	iStatus = OK;


	iStatus = (*Func[0])( OK );						/* Call startup function	*/

																/* Loop once for each line */
																/* line in the old file 	*/
	while ( iStatus == OK && !feof( OldFile ) )
	{
		if ( NewFileGets( szOldString, MAX_LEN, OldFile ) != NULL )
		{
			if ( (iToDo = (*Func[1])( OK )) != OK )
			{
				if ( iToDo == REM_LINE )
				{
					strcpy( szNewString, "REM " );
					strncpy( szNewString + 4, szOldString, MAX_LEN );
					iStatus = NewFilePuts( szNewString, NewFile );
				}
					/* Else just don't copy the line */
			}
			else
				iStatus = NewFilePuts( szNewString, NewFile );
		}
		if ( ferror( OldFile ) || ferror( NewFile ) )
			iStatus = ERROR;
	}
	iStatus = (*Func[2])( iStatus );

	FreeMemory( szOldString );
	return( iStatus );
}

/***************************************************************************/
/* Creates a new config.sys file in the tmp directory. If an old config.sys*/
/* exists in the root directory it will be used as a model and will be		*/
/* fixed up to reflect then new paths to the DOS directory and the new		*/
/* requirement that EMM386.EXE, RAMDRIVE.SYS and SMARTDRV.SYS require that */
/* HIMEM.SYS be installed to suppy XMA memory access. If there was not an	*/
/* old file a new default file will created. 										*/
/* 																								*/
/* void ProcessConfig( void ) 															*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void ProcessConfig( void )
{
	static int (*Funcs[])(int) = { NewConfigFirst, ProcessConfigLine,
											 NewConfigLast };

	ProcessFile( CONFIG_SYS, szConfSys, vInfo.szTmpConfig, Funcs );
}

/***************************************************************************/
/* Initializes the DeviceLines[] array to all NULL ptrs and then install	*/
/* any new devices which are specified in the DOSDATA.DAT file.				*/
/* 																								*/
/* int NewConfigFirst( int iStatus )													*/
/* 																								*/
/* ARGUMENTS:	iStatus	- Current error status of the file processing		*/
/* RETURNS: 	int		- OK if successfull else ERROR							*/
/* 																								*/
/***************************************************************************/
																		/*lint -e715 */
int NewConfigFirst( int iStatus )
{
	register 	i;

	for ( i = 0; i < MAX_DEV_LINE; i++ )
		DeviceLines[ i ] = NULL;					/* Set line ptrs to NULL	*/

	RamDriveCount = 0;

		/* Add the line "DEVICE=X:\dos\SETVER.EXE"  and any new drivers	*/
	if ( (iStatus = AddNewDevice( "SETVER.EXE", DEVICE )) == OK )
		iStatus = InstallNewDrivers();

	return( iStatus );
}																		/*lint +e715 */

/***************************************************************************/
/* Adds any lines to the end of the config.sys file which need to be added */
/* or which needed to moved to the end of the file and frees any memory 	*/
/* allocated for device line strings in DevicesLines[]. If status value arg*/
/* reflects an error the lines will not be written and only the allocated	*/
/* memory will be freed.																	*/
/* 																								*/
/* int NewConfigLast( int iStatus ) 													*/
/* 																								*/
/* ARGUMENTS:	iStatus	- Current processing status								*/
/* RETURNS: 	int		- Original arg status if successfull else ERROR 	*/
/* 																								*/
/***************************************************************************/

int NewConfigLast( int iStatus )
{
	register 	i;
											
	if ( !DevFlags.fHaveComspec )	/* See if shell= needs to be added		*/
	{
		DefaultShellLine( szNewString );
		NewFilePuts( szNewString, NewFile );
	}
											/* See if Himem.sys needs to be added	*/
	if ( vInfo.Hw.ExtMem >= HIMEM_K_SIZE )
		DevFlags.fNeedHiMem = TRUE;

	if ( vInfo.NoCopy[ NO_HIMEM ] == FALSE &&
		  (DevFlags.fNeedHiMem && !DevFlags.fHimem) )
		MoveToEndFile( Devices[ HIMEMSYS ], HIMEMSYS	);

	if ( vInfo.Hw.VideoType == VIDEO_EGA && !DevFlags.fHaveEga )
		MoveToEndFile( Devices[ EGASYS ], EGASYS );

	for ( i = 0; i < MAX_DEV_LINE; i++ )
	{
		if ( DeviceLines[ i ] != NULL )
		{
			if ( iStatus == OK )
				iStatus = AddNewDevice( DeviceLines[ i ],	DEVICE );
			FreeMemory( DeviceLines[ i ] );
		}
	}

	if ( vInfo.Hw.ExtMem >= HIMEM_K_SIZE && !DevFlags.fHaveDosEqu )
		iStatus = fputs( DOS_HIGH, NewFile );
	return( iStatus );
}

/***************************************************************************/
/* Process a line in the config.sys file. Search for DEVICE= or SHELL=		*/
/* line and then calls function to process that line. If neither of these	*/
/* commands are detected the original string is copied to the new string	*/
/* buffer for adding to the new file.													*/
/* 																								*/
/* int ProcessConfigStr( void )															*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	int		- OK if sucessfull else ERROR to signal don't      */
/* 							  write this string to the new config.sys 			*/
/* 																								*/
/***************************************************************************/

int ProcessConfigLine( int iStatus )
{
	char				*szPtr;
	static char		*ConfEntry[] = { "BUFFERS", "BREAK", "DEVICE", "DEVICEHIGH",
											  "FILES", "FCBS", "LASTDRIVE", "MULTITRACK",
											  "DRIVPARM", "STACKS", "COUNTRY", "SHELL",
											  "INSTALL", "COMMENT", "REM", "SWITCHES",
											  "DOS", NULL };

	iStatus = OK;
	szPtr = szOldString;
	while ( *szPtr == ' ' || *szPtr == '\t' )
		szPtr++;
	/*	szPtr = SkipLeadingWhite( szOldString ); */

	ExtractNextWord( szPtr, szNewString, 25 );	/* Get the entry type	*/
	strupr( szNewString );

	szPtr = SkipWord( szPtr ); 						/* Skip to device name */

	if ( *szPtr != EOL )									/* Check for null str		*/
	{
																/* Check for "DOS="			*/
		if ( strcmpi( szDosEqu, szNewString ) == OK )
		{
			DevFlags.fHaveDosEqu = TRUE;
			strcpy( szNewString, szOldString );
			iStatus = OK;
		}

		else if ( strcmpi( szDeviceEqu, szNewString ) == OK )
			iStatus = ProcessDeviceLine( szPtr, DEVICE );

																/* Check for "INSTALL="		*/
		else if ( strcmpi( szInstallEqu, szNewString ) == OK  )
			iStatus = ProcessDeviceLine( szPtr, INSTALL );

		else if ( strcmpi( szLoadHiEqu, szNewString ) == OK )
			iStatus = ProcessDeviceLine( szPtr, LOAD_HIGH );

																/* Check for "SHELL="		*/
		else if ( strcmpi( szShellEqu, szNewString ) == OK )
			iStatus = ProcessShellLine( szPtr );
																/* Check for invalid entry	*/
		else if ( StrSearch( szNewString, ConfEntry ) == -1 &&
					 *szNewString != EOL )
			iStatus = REM_LINE;

		else													/* Using existing string	*/
			strcpy( szNewString, szOldString );
	}

	return( iStatus );
}

/***************************************************************************/
/* Processes the SHELL= line from the config.sys. If the command file		*/
/* name is COMMAND the path to it will be removed and any reload path will */
/* be removed. This will force it to always be loaded from the root dir.	*/
/* Any existing parameters for /e or /p will be used in the new string. 	*/
/* 																								*/
/* int ProcessShellLine( char *szStr ) 												*/
/* 																								*/
/* ARGUMENTS:	szStr 	- Ptr to device pathname									*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

static int near ProcessShellLine( char *szString )
{
	char			*szPtr;
	char			*szOpts;

	strcpy( szNewString, szShell );			/* Copy "SHELL=" */

	szPtr = strchr( szNewString, EOL );
	BuildPath( szPtr, HD_BOOT_DRV, vInfo.szPath + 2, szCommandShell );
	szPtr = strchr( szNewString, EOL );
	BuildPath( szPtr, HD_BOOT_DRV, vInfo.szPath + 2, " " );

					/* If the existing shell is COMMAND.COM we have to check		*/
					/* the /E: switch and if found copy it to the new string		*/

	szPtr = ParseFileName( szString );			/* Get original comspec file	*/
	if ( strnicmp( szPtr, szCommandShell, 11 ) == OK )
	{
		if ( (szPtr = strchr( szPtr, '/' )) != NULL )
		{
			do		/* Loop looking at all switches but only save the /E switch	*/
			{
				szOpts = strchr( szNewString, EOL );
				szPtr++;												/* Ptr to option	*/
				if ( UCASE_E == toupper( *szPtr ) )
				{
					*(szOpts++) = '/';
					ExtractNextWord( szPtr, szOpts, 25 );
				}
			}
			while ( (szPtr = strchr( szPtr, '/' )) != NULL );
		}
	}
	strcat( szNewString, " /p" );

	DevFlags.fHaveComspec = TRUE;
	return( OK );
}

/***************************************************************************/
/* Processes the DEVICE= line from the config.sys. Changes the paths for	*/
/* devices or deletes the entry based on entries in the dosdata file. The	*/
/* new SMARTDRV, EMM386 and RAMDRIVE need HIMEM installed to work so 		*/
/* SMARTDRV and RAMDRIVE entries as copied to a buffer to be added at the	*/
/* end of the config file and if EMM386 is detected a line to load HIMEM	*/
/* will be added at the current location and the xma already installed		*/
/* flag will be set so it won't be added at the end if it is needed by     */
/* smartdrive or ramdrive. 																*/
/* 																								*/
/* NOTE: See the file SYS.DOC for an explaination of work done to support	*/
/* 		changes to RAMDRIVE, SMARTDRV and EMM386 which now require XMA.	*/
/* 																								*/
/* Changed to also process the INSTALL= lines										*/
/* Changed to cause any DEVICE=SETVER.EXE lines to be deleted					*/
/* 																								*/
/* int ProcessDeviceLine( char *szStr )												*/
/* 																								*/
/* ARGUMENTS:	szStr 	- Ptr to device pathname									*/
/* 				iType 	- Determine if device is DEVICE= or INSTALL= 		*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

int near ProcessDeviceLine( char *szStr, int iType )
{
	char			szDevName[25]; 			/* Storage for device file name	*/
	char			*szPtr;						/* String ptr							*/
	register		i; 							/* Array index 						*/

	struct	TmpFlags
	{
		unsigned 	fDelete		:1;		/* Delete current line				*/
		unsigned		fChangePath :1;		/* Change path on this line		*/
		unsigned 	fNoCopy		:1;		/* Already copied to szNewString */
	}f;


	*((unsigned *)(&f)) = 0;
	szPtr = ParseFileName( szStr );
	ExtractNextWord( szPtr, szDevName, 25 );

	for ( i = 0; i < LAST_DEVICE; i++ )
		if ( strnicmp( szDevName, Devices[i], (size_t)DeviceNameLen[i] ) == OK )
			break;

	switch( i )
	{
		case	HIMEMSYS:						/* Process "DEVICE=HIMEM.SYS" line		*/
		case	HIMEMDOS:						/* M006: Process "DEVICE=HIMEM.DOS" line	*/
			if ( DevFlags.fHimem != TRUE )
			{
				DevFlags.fHimem = TRUE;
				if ( !vInfo.NoCopy[ NO_HIMEM ] )
				{
						/* Need to create a new name in case was HIMEM.DOS. */
					memcpy( szPtr, HIMEM_SYS, strlen(szDevName) );

					f.fChangePath = TRUE;
				}
			}
			else
				f.fDelete = TRUE;

			break;

		case	SMARTDRV:					/* Process "DEVICE=SMARTDRV.SYS" line	*/
			if ( !vInfo.NoCopy[ NO_SMARTDRV ] )
			{
				if ( DevFlags.fSmartDrv )			/* Check for duplicate entry	*/
					f.fDelete = TRUE;
				else if ( !DevFlags.fHimem && 	/* If XMA not installed			*/
							 FindParam( szPtr, 'A' ) == FALSE )	/* Using EMM mem?	*/
				{
					DevFlags.fNeedHiMem = TRUE;				/* If not need himem */
					MoveToEndFile( szPtr, SMARTDRV );
					f.fDelete = TRUE;
				}
				else
					f.fChangePath = TRUE;
				DevFlags.fSmartDrv = TRUE;
			}
			break;

		case	RAMDRIVE:					/* Process "DEVICE=RAMDRIVE.SYS" line	*/
			if ( !vInfo.NoCopy[ NO_RAMDRV ] )
			{
				if ( !DevFlags.fHimem && FindParam( szPtr, 'E' ) == TRUE )
				{
					MoveToEndFile( szPtr, RAMDRIVE + RamDriveCount );
					f.fDelete = TRUE;
					DevFlags.fNeedHiMem = TRUE;
					RamDriveCount++;
				}
				else
					f.fChangePath = TRUE;
			}
			break;

		case	EMM386SYS:						/* Process "DEVICE=EMM386.SYS" line       */
		case	EMM386DOS:						/* M006: Process "DEVICE=EMM386.DOS" line */
		case	EMM386EXE:						/* Process "DEVICE=EMM386.EXE" line       */
			if ( vInfo.NoCopy[ NO_EMM386 ] )
				break;
			else if ( DevFlags.fEmm386 )			/* Check for duplicate entries	*/
				f.fDelete = TRUE;
			else
			{										/* See if need to install himem driver */
				if ( !DevFlags.fHimem )
				{
					MoveToEndFile( szPtr, EMM386EXE );
					f.fDelete = TRUE;
					DevFlags.fNeedHiMem = TRUE;

                                	/* M006: Create new name in case
                                           was EMM386.SYS or EMM386.DOS. */
					memcpy( DeviceLines[EMM386EXE],
                                		EMM386_EXE,
                                		strlen(szDevName) );
				}
                                else
                                {
					/* M006: Create new name in case
                                    	   was EMM386.SYS or EMM386.DOS. */
					memcpy( szPtr,
                                        	EMM386_EXE,
                                                strlen(szDevName) );
                                }

				f.fChangePath = TRUE;
				DevFlags.fEmm386 = TRUE;
			}
			break;

#ifdef ADD_MOUSE
												/* Process "DEVICE=MOUSE.SYS" line		*/
		case	MOUSE:
			if ( vInfo.Flag.fMouse ) 	/* If adding new mouse driver need to	*/
				f.fDelete = TRUE;			/* REM out this line							*/
			break;
#endif

		case	EGASYS:
			f.fChangePath = TRUE;
			DevFlags.fHaveEga = TRUE;
 			break;

		case	SHARE:
			f.fChangePath = TRUE;
			break;

		case	SETVER:
			return( DEL_LINE );						/* Just don't copy the line	*/
			
		default: 													/* No match found 	*/
			if ( iType == DEVICE )
			{
				if ( FindDataMatch( szDevName, REM_DEVICE ) ||
					  FindDataMatch( szDevName, DELETE_DRIVER )	)
					f.fDelete = TRUE;

				else if ( IsDistrFile( szDevName ) )
					f.fChangePath = TRUE;
			}
			else if ( iType == INSTALL || iType == LOAD_HIGH )
				if ( IsDistrFile( szDevName ) )
					f.fChangePath = TRUE;
			break;
	}																  /* End switch			*/

	if ( f.fChangePath == TRUE && !f.fNoCopy )
		CreateDeviceLine( szNewString, szPtr, iType );

	else if ( !f.fDelete )
		strcpy( szNewString, szOldString );

	return( f.fDelete ? REM_LINE : OK );
}

/***************************************************************************/
/* Function to add a device line to the new config.sys file.					*/
/* 																								*/
/* int AddNewDevice( char *szDevName, int iType	)									*/
/* 																								*/
/* Arguments:	szDevName	- Ptr to the device name and any parameters		*/
/* 				iType 	- Specifies if should be DEVICE= or INSTALL= 		*/
/* RETURNS: 	int			- Status of fputs() function							*/
/* 																								*/
/***************************************************************************/

static int near AddNewDevice( char *szDevName, int iType	)
{
	char			*szOldString;
	register 	iStatus;

	szOldString = GetMemory( MAX_LEN * 2 );

	CreateDeviceLine( szOldString, szDevName, iType );
	iStatus = NewFilePuts( szOldString, NewFile );

	FreeMemory( szOldString );

	return( iStatus );
}

/***************************************************************************/
/* Creates a device string for the config.sys file in the form of:			*/
/* "DEVICE=X:\DOS_PATH\DEVICE /x/x/x"													*/
/* The drive letter is derived from vInfo.chDestin and the path from 		*/
/* vInfo.szPath.																				*/
/* 																								*/
/* void CreateDeviceLine( char *szLine, char *szDevice, int iType	)			*/
/* 																								*/
/* ARGUMENTS:	szLine	- Ptr to buffer to hold the new string 				*/
/* 				szDevice - The name of the device with any needed params 	*/
/* 				iType 	- Specifies if should be DEVICE= or INSTALL= 		*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void CreateDeviceLine( char *szLine, char *szDevString, int iType	)
{
	char			*szDevicePath;

	if ( iType == LOAD_HIGH )
		strcpy( szLine, szLoadHi );
	else
		strcpy( szLine, iType == DEVICE ? szDevice : szInstall );

	szDevicePath = strchr( szLine, EOL );
	BuildPath( szDevicePath, HD_BOOT_DRV, vInfo.szPath + 2, szDevString );
}

/***************************************************************************/
/* Allocates a buffer for and copies a device name and parameters to the	*/
/* specifed place in the DeviceLines array which holds ptrs to devices to	*/
/* add to the end of the new config.sys file.										*/
/* 																								*/
/* void MoveToEndFile( char szStr, int iDevice )									*/
/* 																								*/
/* ARGUMENTS:	szStr 	-	Ptr to a device name and any needed	parameters	*/
/* 				iDevice	-	An enumerated device descriptor for specifing	*/
/* 								an element in the DeviceLines[] array				*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

static void near MoveToEndFile( char *szStr, int iDevice )
{
	DeviceLines[ iDevice ] = GetMemory( MAX_LEN + 10 );
	strcpy( DeviceLines[ iDevice ], szStr );
}

/***************************************************************************/
/* Reads a line from the specified open 'C' file handle and then parses 	*/
/* off any trailing carriage return or newline characters. The function 	*/
/* has the same calling arguments and returns the same thing as a fgets().	*/
/* 																								*/
/* char *NewFileGets( char *szBuffer, int Count, FILE *File )					*/
/* 																								*/
/* ARGUMENTS:	szBuffer - Buffer to read the line into							*/
/* 				iCount	- Max character to read in 								*/
/* 				File		- Ptr to open 'C' file structure							*/
/* RETURNS: 	char *	- Ptr to szBuffer or NULL if error or end of file	*/
/* 																								*/
/***************************************************************************/

char *NewFileGets( char *szBuffer, int Count, FILE *File )
{
	char	*szPtr;

	if ( (szBuffer = fgets( szBuffer, Count, File )) != NULL )
	{
		if ( (szPtr = strchr( szBuffer, '\n' )) != NULL )
			*szPtr = EOL;
		if ( (szPtr = strchr( szBuffer, '\r' )) != NULL )
			*szPtr = EOL;
	}

	return( szBuffer );
}

/***************************************************************************/
/* Appends a newline character to a string and then writes the string to	*/
/* an open file.																				*/
/* 																								*/
/* int NewFilePuts( char *szString, FILE *File )									*/
/* 																								*/
/* ARGUMENTS:	szString - Ptr to string to write to file 						*/
/* 				File		- Ptr to open 'C' file structure							*/
/* RETURNS: 	int		- OK if sucessfull else non-zero value 				*/
/* 																								*/
/***************************************************************************/

int NewFilePuts( char *szString, FILE *File )
{
	strcat( szString, "\n" );
	return( fputs( szString, File ) );
}

/***************************************************************************/
/* Checks the dos data and adds all lines from the [add-dev] class to the	*/
/* current location in the open new	config.sys file.								*/
/* 																								*/
/* static int AddDevice( void )															*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	int			- File write status from fputs() 					*/
/* 																								*/
/***************************************************************************/

static int near InstallNewDrivers( void )
{
	char			*szNewStr;
	register 	i;
	register 	iStatus;

	for ( i = 0, iStatus = OK;
			iStatus == OK &&
			(szNewStr = GetDataString( ADD_DEVICE, i )) != NULL;
			i++ )
		iStatus = AddNewDevice( szNewStr, DEVICE );

	if ( iStatus == OK )
		iStatus = AddDrvParm();

	return( iStatus );
}

/***************************************************************************/

static int near AddDrvParm()
{
	char			*szDrivparm;
	char			*szDataStr;
	int			iStatus;
	UCHAR 		uchDrivparmDrv1;
	UCHAR 		uchDrivparmDrv2;

	iStatus = OK;
	szDrivparm = GetMemory( MAX_LEN + 10 );
	szDataStr = GetDataString( DRIV_PARM, 0 );
	if ( szDataStr	!= NULL )
	{
		find_drive( &uchDrivparmDrv1, &uchDrivparmDrv2 );
		strncpy( szDrivparm, szDataStr, MAX_LEN + 9 );

		if ( uchDrivparmDrv1 != 0xff )
			iStatus = add_driv_line( szDrivparm, uchDrivparmDrv1 );

		if ( iStatus == OK && uchDrivparmDrv2 != 0xff )
			iStatus = add_driv_line( szDrivparm, uchDrivparmDrv2 );
	}

	FreeMemory( szDrivparm );
	return( iStatus );
}

/***************************************************************************/

static int near add_driv_line( char *szDrivparm, UCHAR uchDrv )
{
	char		szNum[4];

	itoa( uchDrv, szNum,10 );						/* Create drive number string */

	strcat( szDrivparm, " /d:" );
	strcat( szDrivparm, szNum	);

	return( NewFilePuts( szDrivparm, NewFile ) );
}

/***************************************************************************/

void near find_drive( UCHAR *puchDrv1, UCHAR *puchDrv2 )
{
	UCHAR 		chByte;

	*puchDrv1 = *puchDrv2 = 0xff;
											/*Get TANDY id byte at 0xf000:0xc000*/

	chByte = (UCHAR) *( (UCHAR far *) ((0xf000L << 16L) | 0xc000L) );

	if (chByte == 0x21)
	{
			/* At 40:B5 - bit 0 = 1 => drive A is 720K
							  - bit 1 = 1 => drive B is 720K */

		chByte = (UCHAR) *( (UCHAR far *) ((0x0040L << 16) | 0x00b5L) );

		if ( (chByte >>= 1) != 0 )
			*puchDrv1 = 0;

		if ( (chByte >> 1) != 0 )
			*puchDrv2 = 1;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\errors.h ===
enum	Errors	  { ERR_OPENING, ERR_READING, ERR_WRITING, ERR_RENAMING,
						 ERR_DELETING, ERR_CREATING, ERR_PROCESSING	};


void ProcessCopyError( char *szFile, int ErrorType );
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\fdboot.inc ===
db	0FAH,033H,0C0H,08EH,0D0H,0BCH,000H,07CH
	db	08BH,0F4H,050H,007H,050H,01FH,0FBH,0FCH
	db	0BFH,000H,006H,0B9H,000H,001H,0F2H,0A5H
	db	0EAH,01DH,006H,000H,000H,0BEH,0BEH,007H
	db	0B3H,004H,080H,03CH,080H,074H,00EH,080H
	db	03CH,000H,075H,01CH,083H,0C6H,010H,0FEH
	db	0CBH,075H,0EFH,0CDH,018H,08BH,014H,08BH
	db	04CH,002H,08BH,0EEH,083H,0C6H,010H,0FEH
	db	0CBH,074H,01AH,080H,03CH,000H,074H,0F4H
	db	0BEH,08BH,006H,0ACH,03CH,000H,074H,00BH
	db	056H,0BBH,007H,000H,0B4H,00EH,0CDH,010H
	db	05EH,0EBH,0F0H,0EBH,0FEH,0BFH,005H,000H
	db	0BBH,000H,07CH,0B8H,001H,002H,057H,0CDH
	db	013H,05FH,073H,00CH,033H,0C0H,0CDH,013H
	db	04FH,075H,0EDH,0BEH,0A3H,006H,0EBH,0D3H
	db	0BEH,0C2H,006H,0BFH,0FEH,07DH,081H,03DH
	db	055H,0AAH,075H,0C7H,08BH,0F5H,0EAH,000H
	db	07CH,000H,000H,049H,06EH,076H,061H,06CH
	db	069H,064H,020H,070H,061H,072H,074H,069H
	db	074H,069H,06FH,06EH,020H,074H,061H,062H
	db	06CH,065H,000H,045H,072H,072H,06FH,072H
	db	020H,06CH,06FH,061H,064H,069H,06EH,067H
	db	020H,06FH,070H,065H,072H,061H,074H,069H
	db	06EH,067H,020H,073H,079H,073H,074H,065H
	db	06DH,000H,04DH,069H,073H,073H,069H,06EH
	db	067H,020H,06FH,070H,065H,072H,061H,074H
	db	069H,06EH,067H,020H,073H,079H,073H,074H
	db	065H,06DH,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,055H,0AAH
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\everex.inc ===
; ========================================================
COMMENT #

	EVEREX.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	Binary contents of Everex master boot record which
	changes the disk geometries at boot time. Provided
	by Everex so Setup can detect this system and
	refuse to install.

	To:	John Hensley, Microsoft
	From:	Henry Tang, Everex
	Date:	February 1, 1991
	Re:	Evdisk master boot sector "signature"

END COMMENT #
;========================================================


	db	0FAH,033H,0C0H,0BEH,000H,07CH,08EH,0D8H
	db	0BFH,000H,006H,08EH,0C0H,08BH,0E6H,08EH
	db	0D0H,0FBH,0B9H,000H,001H,0FCH,0F3H,0A5H
	db	0EAH,0E0H,006H,000H,000H,049H,06EH,076H
	db	061H,06CH,069H,064H,020H,070H,061H,072H
	db	074H,069H,074H,069H,06FH,06EH,020H,074H
	db	061H,062H,06CH,065H,024H,045H,072H,072H
	db	06FH,072H,020H,06CH,06FH,061H,064H,069H
	db	06EH,067H,020H,06FH,070H,065H,072H,061H
	db	074H,069H,06EH,067H,020H,073H,079H,073H
	db	074H,065H,06DH,024H,04DH,069H,073H,073H
	db	069H,06EH,067H,020H,06FH,070H,065H,072H
	db	061H,074H,069H,06EH,067H,020H,073H,079H
	db	073H,074H,065H,06DH,024H,0FCH,0BBH,007H
	db	000H,0ACH,03CH,024H,074H,008H,0B4H,00EH
	db	056H,0CDH,010H,05EH,0EBH,0F3H,0EBH,0FEH
	db	057H,056H,08BH,0F5H,0C5H,034H,051H,0B9H
	db	008H,000H,0FCH,0F3H,0A5H,059H,05EH,05FH
	db	026H,089H,01DH,026H,088H,055H,002H,08BH
	db	0DEH,00AH,0DBH,074H,00CH,026H,089H,045H
	db	005H,026H,089H,04DH,00CH,026H,088H,05DH
	db	00EH,026H,088H,075H,008H,033H,0C9H,08EH
	db	0D9H,0FAH,03EH,089H,07EH,000H,03EH,08CH
	db	046H,002H,0FBH,08EH,0C1H,0C3H,081H,0FBH
	db	000H,010H,077H,06DH,08AH,055H,002H,00AH
	db	0D2H,074H,066H,080H,0FAH,040H,077H,061H
	db	08AH,075H,0FBH,08BH,045H,0F9H,08BH,04DH
	db	0F7H,08BH,075H,0F6H,0C4H,07DH,0FCH,0C3H
	db	081H,03EH,0FEH,007H,055H,0AAH,075H,049H
	db	0BFH,0BBH,007H,08BH,01DH,00BH,0DBH,074H
	db	040H,0E8H,0CAH,0FFH,0BDH,004H,001H,0E8H
	db	086H,0FFH,0B4H,009H,0B2H,080H,0CDH,013H
	db	072H,06DH,0B2H,080H,0B4H,008H,0CDH,013H
	db	080H,0FAH,002H,075H,04CH,0BFH,005H,000H
	db	0B8H,001H,002H,0BAH,081H,000H,0B9H,001H
	db	000H,0BBH,000H,07CH,0CDH,013H,073H,017H
	db	04FH,075H,0EDH,0EBH,034H,0BEH,035H,006H
	db	0E9H,042H,0FFH,0BEH,054H,006H,0E9H,03CH
	db	0FFH,0BEH,01DH,006H,0E9H,036H,0FFH,081H
	db	03EH,0FEH,07DH,055H,0AAH,075H,01AH,0BFH
	db	0BBH,07DH,08BH,01DH,00BH,0DBH,074H,011H
	db	0E8H,073H,0FFH,0BDH,018H,001H,0E8H,02FH
	db	0FFH,0B4H,009H,0B2H,081H,0CDH,013H,072H
	db	016H,0BEH,0BEH,007H,08AH,004H,03CH,080H
	db	074H,00FH,00AH,0C0H,075H,0CBH,083H,0C6H
	db	010H,081H,0FEH,0EEH,007H,076H,0EDH,0CDH
	db	018H,08BH,0FEH,083H,0C7H,010H,081H,0FFH
	db	0EEH,007H,077H,008H,032H,0C0H,00AH,005H
	db	075H,0AFH,0EBH,0EFH,0BFH,005H,000H,08BH
	db	014H,08BH,04CH,002H,0B8H,001H,002H,0BBH
	db	000H,07CH,0CDH,013H,073H,005H,04FH,075H
	db	0EEH,0EBH,08AH,081H,0BFH,0FEH,001H,055H
	db	0AAH,075H,088H,0EAH,000H,07CH
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\getinfo.asm ===
;============================================================================
	title	GETINFO
;============================================================================
;
;   (C) Copyright MICROSOFT Corp. 1991-1992
;
;   Title:    DOS2.EXE - GUI Portion of DOS Install
;
;   Module:   GETINFO - Routine that returns a pointer to the vInfo data 
;			data created by the CUI portion of DOS Install
;
;   Version:  0.001
;
;   Date:     Jan 26,1992
;
;   Author:   HKN
;
;============================================================================
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   01/26/92  Original
;
;============================================================================

include model.inc
include dpmi.inc

.data

RealModeCallFrame	RealModeCallStruc	<>

.code

;===========================================================================
;
;	Procedure	: GetInfo
;
;	Input		: None
;	Output		: Returns a Selector:Offset to the Vinfo Data
;
;	Description:
;		
;		1. Simulate Real Mode Int 2fh ax=4910h
;		2. Build a selector for the segment indiacted by ES in the
;		   Real Mode Call Structure.
;		3. Return the Selector:Offset
;
;===========================================================================

GetInfo	proc	uses es di bx cx

	;
	; Initialize the RealModeCallFrame with the inout registers we want 
	; to pass to the int 2f call. Note we are going to initialize RegSS
	; and RegSP to 0. This will make the DPMI server provide a 30 word 
	; stack which is sufficient for our purposes.
	;
	lea	di, [RealModeCallFrame]
	mov	word ptr [di].RegEAX, 4910h
	xor	ax, ax
	mov	[di].RegSS, ax
	mov	[di].RegSP, ax
	pushf
	pop	ax
	mov	[di].RegFlg,ax
	
	;
	; Simulate the Real Mode Int.
	;
	mov	ax, ds
	mov	es, ax			; es:di = RealModeCallStruc
	mov	bx, 02fh		; bl = int number
	xor	cx, cx
	mov	ax, SIMULATE_RELMODE_INT
	int	DPMI
	jc	GIerror

	;
	; The Int 2f was successful. At this point the registers returned by 
	; the real mode int call are in the RealModeCallStruc. The expected
	; output from the int 2f should be: AX = -1 and ES:BX points to the 
	; vInfo data.
	;
	mov	ax, word ptr [di].RegEAX
	cmp	ax, -1
	jne	GIerror

	;
	; We now need to map the segment in RegES to a selector.
	;
	mov	cx, 1			; one descriptor
	mov	ax, ALLOC_LDT_DESC
	int	DPMI
	jc	GIerror
	
	mov	bx, ax			; bx = selector
	mov	ax, [di].RegES
	mov	dx, ax
	mov	cl, 12
	shr	ax, cl
	mov	cl, 4
	shl	dx, cl
	mov	cx, ax			; cx:dx = 32 bit linear base address
	mov	ax, SET_SEG_BASE_ADDR
	int	DPMI			; set the base address of the desc
	jc	GIerror

	mov	dx, 0ffffh
	xor	cx, cx			; cx:dx = 64K limit
	mov	ax, SET_SEG_LIMIT
	int	DPMI
	jc	GIerror

	mov	dx, bx
	mov	ax, word ptr [di].RegEBX	
	ret

GIerror:
	;
	; If error return NULL
	;
	xor	dx, dx
	xor	ax, ax
	ret

GetInfo	endp

	end
	
	





=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\extern.c ===
/***************************************************************************/
/*                                                                         */
/*	EXTERN.C																						*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/*                                                                         */
/* johnhe - 12/29/89																			*/
/***************************************************************************/


/* 
unsigned	ErrorMessageText	= ERROR_MESSAGE_TEXT;

unsigned	AcceptText			= ACCEPT_TEXT;
unsigned SetDefaultText 	= SET_DEFAULT_TEXT;

unsigned DiskErrorText		= DISK_ERROR_TEXT;

unsigned Type525Text 		= TYPE_525_TEXT;
unsigned Type35Text			= TYPE_35_TEXT;
unsigned DskFmtText			= DSK_FMT_TEXT;

unsigned FmtStatText 		= FMT_STAT_TEXT;

*/


#include		<stdio.h>
#include		<stdlib.h>
#include		<malloc.h>
#include		<dos.h>
#include		<direct.h>
#include    <io.h>
#include    <sys\types.h>
#include    <sys\stat.h>
#include    <fcntl.h>


#include		<alias.h>
#include		<global.h>
#include		<upgrade.h>


void FatalError( int );

/* Globals to resolve */

char	*szRootPath = "\\";

int	CreatingRecovery;

/***************************************************************************/

fmemcmp( char far *Str1, char far *Str2, UINT Len )
{
	while( Len && *Str1 == *Str2 )
		Str1++, Str2++, Len--;


	return( Len );
}

/***************************************************************************/
/*																									*/
/* Functions replaced with windows versions											*/
/*																									*/
/***************************************************************************/

#if 0
void Error( int x )
{;}

void PromptForDisk( int x )
{;}

int PromptForDiskFmt( int x )
{;}

int PromptForDefault( void )
{;}

void ProcessCopyError( char *szFile, int ErrorType )
{;}

void WriteProtectPrompt( void )
{;}

void NotReadyPrompt( void )
{;}

#endif

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\harddisk.c ===
/***************************************************************************/
/* 																								*/
/* HARDDISK.C																					*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* Functions which check the hard disk partition table to be sure they are	*/
/* compatible with DOS 5.0 and determine which drive is going to be the		*/
/* boot drive when the system reboots with DOS 5.0.								*/
/* 																								*/
/* johnhe - 09/03/90																			*/
/***************************************************************************/

#include		<stdio.h>
#include		<stdlib.h>
#include 	<bios.h>
#include		<memory.h>
#include		<dos.h>
#include		<string.h>

#include 	<alias.h>
#include 	<disk_io.h>
#include 	<global.h>
#include		<hdisk.h>
#include		<strlib.h>
#include		<upgrade.h>
#include		"wsrc.h"

void ChkBootRecs( void );

/***************************************************************************/

extern int far	IOMFIXBPB			( char far * );
		 int	SetBootDrive			( void );

static int	near GetBootPart		( void );
static int	near NumDosParts		( void );
static int	near ParseHardInfo	( int Error );
static int	near IsNonCompatiblePart( void );
static int	near SpecialPartCheck( struct Part *PartEntry );

int	IsSystemFile			( struct DIR *Dir );
int	VfeatureCheck			( void );
int	SyquestCheck			( void );

static int	near IsDiskSizeOK	( void );
static void	near AppendToRoot	( struct DIR *Entry, int iDrv, struct BPB *Bpb );
static int	near IsValidConfig	( char DrvLetter );
static void	near FilesInRootChk	( void );
static void near BadWyseDosCheck	( char *pchBootRec );	  /* m010 */
extern void CopyFiles( int id, struct MULT_FILES *Files ); /* m110 */

void			PowerOf2Error	( void );

/***************************************************************************/

#define		OFFSET  			(BOOT_SIG_OFFSET - ((UINT)Entries * sizeof(struct Part)))
#define		EXT_BPB_LEN		51

struct BPB				HdBpb;
static struct Part	*Part;
static int				Entries;
static char				DosName[2][12] = {{ "IO      SYS" }, { "MSDOS   SYS" }};

/***************************************************************************/

#define		DM_PART		1														/* m110	*/
#define		SPEED_PART	-1														/* m110	*/
#define		MakeDate(m,d,y)	( d + (m<<5) + ((y-1980) << 9) )		/* m110	*/

// m110	The date format is as follows:
// m110
// m110	Bits      Contents
// m110	0-4       Day of month (1-31)
// m110	5-8       Month (1-12)
// m110	9-15      Year (1980-2099)

static unsigned DvrDate = MakeDate( 4U, 9U, 1991U );					/* m110	*/
static char		szDmDriver[] = "DMDRVR.BIN";								/* m110	*/
static char		szSsDriver[] = "SSTOR.SYS";								/* m110	*/
static char		szOverLay[] = "XBIOS.OVL";									/* m110	*/
static char		szOverLaySrc[] = "X:\\XBIOS.OVL";						/* m110	*/
static char		szOverLayDst[] = "X:\\XBIOS.BAK";						/* m110	*/


/***************************************************************************/
/* Determines the number of entries in a partition table by examining the	*/
/* master partition record for specific OEMs which use more than 4 entries.*/
/*																									*/
/* First check is for an AST 8 partition entry table. If will have a 		*/
/* signature of 0x0A55A at offset 0x17c and may have partitions of type		*/
/* 0x14.																							*/
/*																									*/
/*	int GetPartEntries( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- Number of entries in the partition table.				*/
/*																									*/
/***************************************************************************/

int GetPartEntries( void )
{
	register			i;
	UCHAR				Type;
	struct Part		*PartEntry;

	if ( *((UINT *)(pchMbrBuf + AST_SIG_OFFSET)) == (UINT)AST_8_ENT_SIG )
	{
		PartEntry = (struct Part *) (pchMbrBuf + AST_TABLE_OFFSET);

		for ( i = 0; i < 4; i++, PartEntry++ )
		{
			Type = PartEntry->SystemIndicator;
			if ( IsCompatPart( Type ) )
				return( 8 );
		}
	}
	return( 4 );
}

/***************************************************************************/
/* Writes either the tmp master boot record or both the new master boot		*/
/* record and boot partition record.													*/
/* 																								*/
/* NOTE:																							*/
/*			There is a problem with Zenith DOS version 3.21 which causes the	*/
/*			drive letter assignments to change after changing the boot record	*/
/*			and the next time a DOS disk reset is done the drive letter			*/
/*			assigments change. The fix is to zero out all partition entries	*/
/*			except the boot one when the tmp master boot record is written.	*/
/*																									*/
/* void WriteNewBoot( int IsFinal )														*/
/* 																								*/
/* ARGUMENTS:	IsFinal	- If TRUE will write the real boot record.			*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void WriteNewBoot( int IsFinal )
{
	#define			PartRec		(Part + vInfo.chBootPart)
	register			i;
	char				*PartBootRec;
	extern char		TmpBoot;
	extern char		NewBootRec;
	extern char		MasterBootRec;

				/* M008 if doing an IADF upgrade we need to use the 3rd sector	*/
				/* for the boot record and the 1st sector for partition table	*/

	PartBootRec = IsFinal ? &MasterBootRec : &TmpBoot;

	if ( RdWrSector( 0x80, 0, 0, 1, READ ) == OK )
	{
		Part = (struct Part *)(pchMbrBuf + TABLE_OFFSET);
		Entries = GetPartEntries();
			
		if ( !vInfo.Flag.fHasIadf )											/* m008 */
			memcpy( pchMbrBuf, PartBootRec, BOOT_CODE_LEN );
		for( i = 0; i < Entries; i++ )
		{		/* If tmp boot record need to zero out all but active  part	*/
			if ( !vInfo.Flag.fHasIadf && !IsFinal && i != (int)vInfo.chBootPart )
				memset( Part + i, 0, sizeof( struct Part ) );
			else
				(Part + i)->BootIndicator = 0;	/* Clear part active field	*/
		}
		PartRec->BootIndicator = ACTIVE;

		if ( !vInfo.Flag.fHasIadf )											/* m008 */
			*( (UL *)(pchMbrBuf+(BOOT_CODE_LEN - 4)) ) = vInfo.ulTmpSerial;

		if ( IsFinal )
		{						/* Add new partition boot record on boot drive	*/
			if ( ReadPartBootRec( PartRec, pchBootBuf, 0x80 ) == OK )
			{
				memcpy( &NewBootRec + 11, pchBootBuf + 11,
						  sizeof( struct BOOT_HEADER ) - 11 );
				if ( WritePartBootRec( PartRec, &NewBootRec, 0x80 ) != OK )
					FatalError( FATAL_HD_WRITE_ERROR );
			}
														/* Also set final serial #			*/
			if ( !vInfo.Flag.fHasIadf )										/* m008 */
				*( (UL *)(pchMbrBuf+(BOOT_CODE_LEN - 4)) ) = vInfo.ulFinalSerial;
		}
		else
		{		/* Tmp partition record must be readable by DOS 5 for recovery	*/
			if ( !IsDosPart( PartRec->SystemIndicator ) )
				PartRec->SystemIndicator = (UCHAR)DOSNEW;
		}
			/* Write new partition boot rec and if system has IADF also need	*/
			/* to put the MBR code on the 3rd sector.									*/
		if ( RdWrSector( 0x80, 0, 0, 1, WRITE ) == OK )
		{
			if ( vInfo.Flag.fHasIadf )
			{			/* Need to write MBR to 3rd sector with proper serial #	*/
				memcpy( pchMbrBuf, PartBootRec, SECTOR_SIZE );

				*( (UL *)(pchMbrBuf+(BOOT_CODE_LEN - 4)) ) = IsFinal ?
				vInfo.ulFinalSerial : vInfo.ulTmpSerial;

				*((UINT *)(pchMbrBuf + BOOT_SIG_OFFSET)) = (UINT)BOOT_SIG; 
				if ( RdWrSector( 0x80, 0, 0, 3, WRITE ) == OK )
					return;
			}
			else
				return;
		}
	}
	FatalError( FATAL_HD_WRITE_ERROR );
}

/***************************************************************************/
/* Gets the name of the 2 system files in the root directory if they exist.*/
/*																									*/
/*	void GetSysFiles( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void GetSysFiles( void )
{
	struct DIR		Dir[2];

	if ( ReadWriteRoot( vInfo.chFirstHd-'A', &HdBpb, pchBootBuf,
							  0, READ ) == OK )
	{
		memcpy( Dir, pchBootBuf, sizeof( Dir ) );

		if ( IsSystemFile( &Dir[0] ) )
		{													/* Save bios file	name	*/
			vInfo.Flag.fIoSys = TRUE;
			DirToFileName( vInfo.szIoSys, Dir[0].Name );
		}
		if ( IsSystemFile( &Dir[1] ) )
		{													/* Save dos file name	*/
			vInfo.Flag.fMsDos = TRUE;
			DirToFileName( vInfo.szMsDos, Dir[1].Name );
		}				
	}
	else
		FatalError( FATAL_HD_READ_ERROR );
}

/***************************************************************************/
/* Moves the first 2 entries in the root directory to the end of the 		*/
/* directory if they are not DOS system files and then creates 2 new first	*/
/* entries for MSDOS.SYS and IO.SYS.													*/
/*																									*/
/*	int FixupRoot( int iDosDrv )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void FixupRoot( void )
{
	register			i; 								/* Loop indice 					*/
	register			iDosDrv;
	struct DIR		OldEntry[ 2 ];					/* Old 1st 2 root entries		*/

	iDosDrv = vInfo.chFirstHd - 'A';
	if ( ReadWriteRoot( iDosDrv, &HdBpb, pchBootBuf, 0, READ ) == OK )
	{
		memcpy( OldEntry, pchBootBuf, sizeof( OldEntry ) );
		for ( i = 0; i < 2; i++ )
		{
			if ( !IsSystemFile( &(OldEntry[i]) ) &&
				  OldEntry[i].Name[0] != 0 &&
				  OldEntry[i].Name[0] != (char)0xe5 )
			{
				AppendToRoot( OldEntry + i, iDosDrv, &HdBpb );
				OldEntry[i].Name[0] = (char)(0xe5);
			}
		}
								/* Have to read the root sector again in case we	*/
								/* changed it by appending entries						*/
		if ( ReadWriteRoot( iDosDrv, &HdBpb, pchBootBuf, 0, READ ) == OK )
		{
			if ( OldEntry[0].Name[0] == 0 || OldEntry[0].Name[0] == (char)0xe5 )
				memset( pchBootBuf, 0, sizeof( struct DIR ) );

			if ( OldEntry[1].Name[0] == 0 || OldEntry[1].Name[0] == (char)0xe5 )
				memset( pchBootBuf + sizeof(struct DIR), 0, sizeof(struct DIR) );

									/* strcpy will also set the attrib to _A_NORMAL	*/
			strcpy( pchBootBuf, DosName[ 0 ] );
			strcpy( pchBootBuf+sizeof( struct DIR ), DosName[ 1 ] );

			if ( ReadWriteRoot( iDosDrv, &HdBpb, pchBootBuf, 0, WRITE ) == OK )
			{
				_dos_dskreset();
				return;
			}
			FatalError( FATAL_HD_WRITE_ERROR );
		}
	}
	FatalError( FATAL_HD_READ_ERROR );
}

/***************************************************************************/
/* Appends a directory entry to the end of the root directory on the			*/
/* the specified drive. The first 2 root directory entries are always		*/
/* skipped over in the search for the first free entry.							*/
/*																									*/
/*	int AppendToRoot( struct DIR *Entry, int iDrv, struct BPB *Bpb )			*/
/*																									*/
/*	ARGUMENTS:	Entry	- Ptr to directory entry structure to append				*/
/*					iDrv	- Drive number (A=1, B=2, ...)								*/
/*					Bpb	- Ptr to BPB struct for disk being fixed up				*/
/*	RETURNS:		int	- OK if successful else ERROR if no room or disk err	*/
/*																									*/
/***************************************************************************/

void near AppendToRoot( struct DIR *Entry, int iDosDrv, struct BPB *Bpb )
{
	register			i;
	register			iSector;
	int				iTotalSectors;
	int				iEntriesPerSector;
	struct DIR		*Dir;

	iEntriesPerSector =	(int)Bpb->uBytesPerSec / (int)(sizeof( struct DIR ));
	iTotalSectors = (int)Bpb->uRootEntries / iEntriesPerSector;

	for ( iSector = 0; iSector < iTotalSectors; iSector++ )
	{
		if ( !ReadWriteRoot( iDosDrv, Bpb, pchBootBuf, iSector, READ ) )
		{
			Dir = (struct DIR *)pchBootBuf;

			for ( i = 0; i < iEntriesPerSector; i++, Dir++	)
			{											/* Skip over 2 reserved entries */
				if ( iSector == 0 && i == 0 )	
					Dir += 2, i += 2;
				if ( Dir->Name[0] == (char)0xe5 || Dir->Name[0] == 0 )
				{
					memcpy( Dir, Entry, sizeof( struct DIR ) );
					if ( !ReadWriteRoot( iDosDrv, Bpb, pchBootBuf, iSector, WRITE ) )
						return;
				}
			}
		}
	}
	FatalError( FATAL_HD_WRITE_ERROR );
}

/***************************************************************************/
/* Read a single disk sector into a global buffer using int 13h.				*/
/* 																								*/
/* int RdWrSector( int iDrv, int Head, int Track, int Sector, int RdWr	)	*/
/* 																								*/
/* ARGUMENTS:	iDrv		- Physical drive number (starts from 0)				*/
/* 				iHead 	- Head number				(starts from 0)				*/
/* 				iTrack	- Track number 			(starts from 0)				*/
/* 				iSector	- Sector number			(starts from 1)				*/
/* 				RdWr		- Signals READ or WRITE 									*/
/* RETURNS: 	int		- OK if successful else !OK								*/
/* 																								*/
/***************************************************************************/

unsigned RdWrSector( int iDrv, int iHead, int iTrack, int iSector, int RdWr )
{
	struct diskinfo_t 	Info;

	Info.drive = (unsigned)iDrv;
	Info.head = (unsigned)iHead;
	Info.track = (unsigned)iTrack;
	Info.sector = (unsigned)iSector;
	Info.nsectors = 1;
	Info.buffer = pchMbrBuf;

	return( _bios_disk( RdWr == READ ? _DISK_READ : _DISK_WRITE, &Info ) >> 8 );
}

/***************************************************************************/
/* Returns TRUE if a directory entry is a system file as noted by it having*/
/* and IBM or MS system file name.														*/
/*																									*/
/*	int IsSystemFile( struct DIR *Dir )													*/
/*																									*/
/*	ARGUMENTS:	Dir	- Ptr to directory structure to check.						*/
/*	RETURNS:		int	- TRUE if entry is a system file else false				*/
/*																									*/
/***************************************************************************/

int IsSystemFile( struct DIR *Dir )
{
	register			i;

	for ( i = 0; i < 2; i++ )
	{
		if ( memcmp( Dir->Name, DosName[i], 11 ) == OK )
			return( TRUE );
	}

	return( FALSE );
}

/***************************************************************************/
/* Determines if a partition system indicator is either a valid DOS or		*/
/* compatible system indicator.															*/
/*																									*/
/*	int IsCompatPart( UCHAR SystemIndicator )											*/
/*																									*/
/*	ARGUMENTS:	SystemIndicator - Partition type value								*/
/*	RETURNS:		int				 - TRUE is DOS compatible else FALSE			*/
/*																									*/
/***************************************************************************/

int IsCompatPart( UCHAR SystemIndicator )
{
	register			i;
	static int OkType[] = { DOS12, DOS16, DOSNEW, ASTid, ATNTid, TANDYid,
								 		 UNISYSid, L_EDGEid, NECid, COMMODOREid };

	for ( i = 0; i < (int)(sizeof( OkType ) / sizeof( int )); i++ )
		if ( (int)SystemIndicator == OkType[i] )
			return( TRUE );

	return( FALSE );
}

/***************************************************************************/
/*	Renames an existing Disk Manager or SpeedStor device driver to .BAK and	*/
/*	then copy over a newer driver from the distribution disk. If the driver	*/
/*	being replaced is Disk Manager a new XBIOS.OVL file will be copied to	*/
/* the root directory of the boot hard disk after the existing file is		*/
/* renamed to .BAK.																			*/
/*																									*/
/*	void near UpdatePartDrivers( void )													*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

#include		<data.h>
#include		<copy.h>
#include		<file_io.h>

void UpdatePartDrivers( void )
{
	char						*szFileName;
	struct MULT_FILES 	File[ 3 ];
	extern int				CreatingRecovery; /* Signal can't continue on error */
	char						szSrcPath[ MAX_PATH_LEN ];
	char						szDstPath[ MAX_PATH_LEN ];

   if ( !vInfo.Flag.fSpeedstor && !vInfo.Flag.fDMdriver ) // MC 4/13/92 #1
      return;                                             // MC 4/13/92 #1

   if ( vInfo.Flag.fSpeedstor )                   // MC 4/13/92 #1
      szFileName = szSsDriver;                    // MC 4/13/92 #1
   else                                           // MC 4/13/92 #1
      szFileName = szDmDriver;                    // MC 4/13/92 #1
   
   memset( File, 0, sizeof( struct MULT_FILES ) * 3 );

	File[ 0 ].Name.Destin = File[ 0 ].Name.Source = szFileName;

	File[ 0 ].Path.Destin = vInfo.szPartDrvPath+2;
	if ( File[ 0 ].Path.Destin[0] == EOL )
		File[ 0 ].Path.Destin = "\\";
	File[ 0 ].Path.Source = vInfo.szSource + 2;


	File[ 0 ].Drive.Destin = vInfo.szPartDrvPath[0];
	File[ 0 ].Drive.Source = vInfo.chSource;

	File[ 0 ].UserDisk = NOT_REMOVEABLE;
	File[ 0 ].DiskNumber = GetRealSrcDisk( szFileName, 0 );

	if ( vInfo.chSource >= vInfo.chFirstHd )
		File[ 0 ].DiskNumber = NOT_REMOVEABLE;

									/* Rename existing driver(s) to "xxx.bak"	*/
	BuildPath(szSrcPath,vInfo.szPartDrvPath[0],vInfo.szPartDrvPath+2,szFileName);
	strcpy( szDstPath, szSrcPath );	

			/* The strchr won't return NULL so long as we supply the driver	*/
			/* name with the .ext added.													*/
	strcpy( strchr( ParseFileName( szDstPath ), '.' ), ".BAK" );
	AbsUnlink( szDstPath );
	rename( szSrcPath, szDstPath );

		/* If Disk Manager we have to copy XBIOS.OVL to root of boot drive	*/
   if ( vInfo.Flag.fDMdriver )                   // MC 4/13/92 #1
	{
		File[ 1 ].Name.Destin = File[ 1 ].Name.Source = szOverLay;

		File[ 1 ].Path.Destin = "\\";						/* Always to the root	*/
		File[ 1 ].Path.Source = vInfo.szSource + 2;

		File[ 1 ].Drive.Destin = vInfo.chDestin;
		File[ 1 ].Drive.Source = vInfo.chSource;

		File[ 1 ].UserDisk = NOT_REMOVEABLE;
		File[ 1 ].DiskNumber = GetRealSrcDisk( szOverLay, 0 );

		if ( vInfo.chSource >= vInfo.chFirstHd )
			File[ 1 ].DiskNumber = NOT_REMOVEABLE;

			/* Rename X:\XBIOS.OVL to X:\XBIOS.BAK	*/
		*szOverLaySrc = *szOverLayDst = vInfo.chDestin;
		AbsUnlink( szOverLayDst );
		rename( szOverLaySrc, szOverLayDst );
	}
	CopyFiles( IDS_WAITCOPY, File );
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\fmt_io.c ===
/***************************************************************************/
/*																									*/
/* FMT_IO.C 																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* Backup utility for the MS-DOS 4.0 upgrade. These functions will       	*/
/* backup a specified disk to another specified disk. Then entry point to	*/
/* the utiltity is BackUp(). The file coping is buffered using an area of	*/
/* memory which as allocated previously by a call to InitCpyBuffer().		*/
/* Most functions comminuicate via a group of static global variables to	*/
/* keep the size of code to a mininum. 												*/
/*																									*/
/* The backup format is restorable with most versions of DOS 2.x and above.*/
/* 																								*/
/* Created 07-12-89 johnhe																	*/
/* TABS = 3																						*/
/***************************************************************************/


#include		<stdio.h>
#include		<stdlib.h>
#include		<bios.h>
#include		<dos.h>
#include		<string.h>

#include		<alias.h>

#ifdef	OEM_PROGRAM
	#include		<oem.h>
#else
	#include		<global.h>
#endif

#include		<disk_io.h>
#include 	<data.h>
#include 	<strlib.h>
#include 	<format.h>
#include		<prompts.h>
#undef NULL
#include 	"lib\common\sulib.h"
#include    "wsrc.h"

/************************************************************************/

#define		BOOT_DRVLET			'A'
#define		BOOT_DRVNUM			0
/************************************************************************/
static unsigned long	StartTime = 0;			/* Time 1st disk was labeled	*/
static unsigned long	LastTime  = 0;			/* Time last disk was labeled	*/

int					iDskFmtType =  0;			/* Default format type			*/

static struct BPB	Bpb;							/* Bpb from current disk		 */

long					MinSize[] = { 0, 350000L, 720000L, 1211000L, 1455000L };

/***************************************************************************/

static int		PrepUninstallDsk( char *szLabel );
void 				PromptForUninstall( char *szUserLabel );

/*
 *  Declared in towin.c, always contains the currect uninstall disk
 *  number (zero based)
 */
extern int iUninstallDiskNum;

/***************************************************************************/
/* Check for a distribution disk being inserted and prompts the user for 	*/
/* the disk until the label on the user inserted disk matches the one in	*/
/* the DistDisk[] array element for that disk number.								*/
/*																									*/
/*	void InsertDisk( int DskNum )    													*/
/*																									*/
/* ARGUMENTS:	DskNum	- Distribution disk number									*/
/* RETURNS:		void																			*/
/*																									*/
/* GLOBALS:		vInfo		- Checks vInfo.chSource to find the drive for the	*/
/*								  to look for the disk on.									*/
/*					DistDisk[] - Gets the label to check for from this array of	*/
/*									 of pointers to strings.								*/
/*																									*/
/***************************************************************************/

void InsertDisk( int DskNum )
{
	char			szLabel[15];
	char			*szDisk;
	char			*pchBuffer;
	register 	iStatus;

	/* If hard drive don't need to do anything */

	if ( DskNum == NOT_REMOVEABLE )
      return;

	pchBuffer = GetMemory( SECTOR_SIZE );

	szDisk = GetDistribLabel( DskNum );
	iStatus = ERROR;

	do
	{
		while( !IsDiskReady( vInfo.chSource - 'A' ) )
			PromptForDisk( vInfo.chSource );

		if ( IsFormatted( vInfo.chSource - 'A', &Bpb, pchBuffer ) != FALSE )
			if ( GetDiskLabel( vInfo.chSource-'A', szLabel, &Bpb  ) != (UL)(-1L))
				if ( (iStatus = strcmp( szLabel, szDisk )) == OK )
					iStatus = OK;

		if ( iStatus != OK )
			PromptForDisk( vInfo.chSource );
	}
	while ( iStatus != OK );

	_dos_dskreset();
	FreeMemory( pchBuffer );
}

/***************************************************************************/
/* Check for a user's disk being inserted and prompts the user for the		*/
/* disk until the label on the user inserted disk matches the one in the	*/
/* DistDisk[] array element for that disk number.									*/
/*																									*/
/* void InitUninstallDisk( int iUserDisk )                                 */
/*																									*/
/* ARGUMENTS:	UserDisk	- User disk number											*/
/*					                                                      		*/
/* RETURNS:		void																			*/
/*																									*/
/* GLOBALS:		vInfo		- Checks vInfo.chDestin to find the drive for the	*/
/*								  to look for the disk on.									*/
/*																									*/
/***************************************************************************/

void InitUninstallDisk( int iUserDisk )
{
	register			iStatus;
	char				*szUserLabel;
	char				szLabel[15];
	char				*pchBuffer;
	static int		iFirstTime = 999;

	pchBuffer = GetMemory( SECTOR_SIZE + 80 );
	szUserLabel = GetUserLabel( iUserDisk );

	do
   {
      /*
       *  If this is the first time through for an un-install disk we'll
       *  need to prepare it.
       */
		if ( iFirstTime != iUserDisk )
      {
         do
         {
			   PromptForUninstall(szUserLabel);      /* Wait until disk present */
		   }
         while( !IsDiskReady( BOOT_DRVNUM ) );

			iStatus = PrepUninstallDsk( szUserLabel ); /* Do this only once per */
         iFirstTime = iUserDisk;                    /* each uninstall disk.  */
      }
		else
		{
			iStatus = REDO_DISK;

			if ( IsDiskReady( BOOT_DRVNUM ) )
			{
				if ( IsFormatted( BOOT_DRVNUM, &Bpb, pchBuffer ) != FALSE )
				{
					if ( GetDiskLabel( BOOT_DRVNUM, szLabel, &Bpb ) != (UL)(-1L))
						if ( strcmp( szLabel, szUserLabel ) == OK )
							iStatus = OK;
				}
			}
			if ( iStatus != OK )
				PromptForUninstall(szUserLabel);
		}
	}
	while ( iStatus != OK );

	FreeMemory( pchBuffer );
	_dos_dskreset();
}

/***************************************************************************/
/* Prepares a diskette as user diskette. First prompts user for a disk		*/
/* and loops until a disk has been inserted. Then checks to see if disk 	*/
/* is formatted and if not formats the disk. If the disk is formatted a		*/
/* check is made to be sure the user hasn't inserted a disk which was 		*/
/* previously used during this backup session. If the disk is useable		*/
/* a call is do to CleanFatDir() which will clear the FAT and root			*/
/* directory to free all of the disk for use. If there are errors the 		*/
/* function will continue to loop until a valid disk is inserted or the		*/
/* user elects to abort the backup.														*/
/*																									*/
/*																									*/
/***************************************************************************/

int PrepUninstallDsk( char *szLabel )
{
	char				*pchBuffer;
	register 		iStatus;
	UL					ulTime;

	pchBuffer = GetMemory( SECTOR_SIZE );

	do
	{
		iStatus = OK;							/* No errors as of yet				*/

      /*
       *  Assure disk was re-inserted after the error dialog was dismissed. 
       *  Bug fix #172 MC.
       */
      while( !IsDiskReady( BOOT_DRVNUM ) )
         NotReadyPrompt(BOOT_DRVNUM);

													/* See if we need to format disk */
		if ( IsFormatted( BOOT_DRVNUM, &Bpb, pchBuffer ) == FALSE )
		{
			if ( FormatNewDsk() != OK )
				iStatus = BAD_MEDIA;				/* Can't use this disk */
		}
													/* Make sure not a previous disk */
													/* and then srub the disk			*/

		else if ( (iStatus = IsNewDisk( BOOT_DRVNUM )) == OK )
			iStatus = ScrubFatRoot( BOOT_DRVNUM, &Bpb );

		if ( iStatus == OK )					/* Disk seems ok so label it	*/
		{
			if ( GetDiskFree( BOOT_DRVLET ) < MinSize[ vInfo.uchFloppyType	] )
				iStatus = NO_SPACE;
			else if ( (ulTime = SetDiskLabel( BOOT_DRVNUM, szLabel, &Bpb )) != (UL)(-1L) )
			{
				LastTime = ulTime;
				if ( StartTime == 0L )				/* If this is first disk	*/
					StartTime = ulTime;				/* need to set first time	*/
			}
			else
				iStatus = BAD_MEDIA;					/* Can't use this disk */
		}

		if ( iStatus != OK )
		{
			ProcessDiskError( iStatus + IDS_DSKPREPERR );
			iStatus = REDO_DISK;
		}
	}
	while( iStatus == REDO_DISK );

	FreeMemory( pchBuffer );
	return( iStatus );
}

/***************************************************************************/
/* Determines if a disk has already been used during the current backup		*/
/* seqence. Each backup disk has a label and the time and date on the		*/
/* along with the label sequence number to see if the label was created		*/
/* during the current installation process.											*/
/*																									*/
/*	int IsNewDisk( int iDrive )															*/
/*																									*/
/*	ARGUMENTS:	iDrive	- Physical drive number where diskette is located	*/
/*	RETURNS:		int		- OK if disk is not distrution or already used		*/
/*																									*/
/***************************************************************************/

int IsNewDisk( int iDrive )
{
	char				szLabel[15];						/* Disk label string 		*/
	char				*szBadLabel;						/* Ptr to unusable labels	*/
	int				i;										/* Loop counter				*/
	int				iStatus;								/* Return value				*/
	UL 				ulTime;								/* Label creation time		*/


	iStatus = OK;

	if ( (ulTime = GetDiskLabel( iDrive, szLabel, &Bpb )) != 0L &&
		  ulTime != (UL)(-1L) )
	{
				/* First loop thru all distribution labels looking for a match	*/
		for ( i = 0;
				iStatus == OK &&
				(szBadLabel = GetDistribLabel( i )) != NULL;
				i++ )
			if ( strcmp( szLabel, szBadLabel ) == OK	)
				iStatus = DIST_DISK;

				/* Loop thru looking for a label from a disk program created	*/
		for ( i = 0;
				iStatus == OK &&
				(szBadLabel = GetUserLabel( i )) != NULL;
				i++ )
		{
			if ( strcmp( szLabel, szBadLabel ) == OK )
			{
				if ( ulTime >= StartTime && ulTime <= LastTime )
					iStatus = DISK_USED;
			}
		}
	}
	else if ( ulTime == (UL)(-1) )
		iStatus = BAD_MEDIA;

	return( iStatus );
}

/***************************************************************************/
/* Determines if the format type has been set and if not does a call to 	*/
/* the the format layout and then call the FormatFloopy function to do the	*/
/* format.																						*/
/*																									*/
/*	int FormatNewDsk( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/* RETURNS:		int	- OK if disk is formatted successfull else and error	*/
/*							  code from the format function or ABORT if the user	*/
/*							  chooses this at one of the prompts.						*/
/*																									*/
/***************************************************************************/

int FormatNewDsk( void )
{
	int						iStatus;
	int						iDskType;
	extern struct BPB		DskBpb[];

	if ( iDskFmtType == 0 )
		iDskType = GetDskFmtType();
	else
		iDskType = iDskFmtType;

   /***********************************
   *  vInfo.uchFloppyType: 1 ==> 360K
   *                       2 ==> 720K
   *                       3 ==> 1.2M
   *                       4 ==> 1.44M
   ************************************
   *  iDskType:            3 ==> 360K
   *                       4 ==> 720K
   *                       5 ==> 1.2M
   *                       6 ==> 1.44M
   ************************************/
   /* Check format type if we know we are formatting a disk in the drive
   ** from which Setup was run. */

	if ( (iStatus = FormatFloppy( BOOT_DRVNUM, iDskType, FmtStat )) == OK )
		memcpy( &Bpb, DskBpb + iDskType, sizeof( struct BPB ) );
	
	return( iStatus );
}

/***************************************************************************/
/*	Determines the type of disk format to use. If there is a choice which	*/
/* can be made as to the type of format we let the user decide and then		*/
/* see if the user wants to always use the format selected.						*/
/*																									*/
/*	int GetDskFmtType( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- Disk format type as defined in FORMAT.H.				*/
/*																									*/
/***************************************************************************/

int GetDskFmtType( void )
{
	char			*pchBuf;							/* Work buff for GetDriveType()	*/
	int			iDrvType;						/* Type of destination drive		*/
	int			iDskIndex;						/* Index to format type arrays	*/
	int			iFmtType;						/* Disk format being returned		*/

	static unsigned char	DrvOpts[6][2] = {	{ 3,0 },		/* 360K	*/
														{ 3,5 },		/* 1.2M	*/
														{ 4,0 },		/* 720K	*/
														{ 4,6 } };	/* 1.44M	*/

	pchBuf = GetMemory( 100 );                		/* Ioctl work buffer		*/
																	/* Determine drive type	*/
	iDrvType = GetDriveType( (UCHAR)BOOT_DRVNUM, pchBuf );

   /* iDrvType (phyisical hardware) will be one of:
    *
	 *	 1	   360K   5.25"
	 *	 2	   1.2M   5.25"
	 *	 3	   720K   3.5"
	 *	 4	   1.44M  3.5"
    *
    *  vInfo.uchFloppyType (type of floppy user is installing from):
    *
    *  1 ==> 360K
    *  2 ==> 720K
    *  3 ==> 1.2M
    *  4 ==> 1.44M
    */
	if ( iDrvType == 1 || iDrvType == 3 ) /* 360k or 720k ? no choice then ! */
		iDskIndex = 0;

   else
      /*  User has a 1.2mb or 1.44mb drive, for these cases we allow them
       *  to choose their uninstall disk type.
       *  For 1.2mb drives, the choices are 1.2mb or 360kb.
       *  For 1.44mb drives, the choices are 1.44mb or 720kb.
       *
       *  iDskIndex return value will be 0 for 360kb/720kb, 1 for 1.2mb/1.44mb
       */

		iDskIndex = PromptForDiskFmt(iDrvType);

	/* Convert the disk type into a type used by the format function.	*/

	iFmtType = DrvOpts[iDrvType-1][iDskIndex];

	/* If there is a bad Uninstal disk we need to ask again		*/
	/*	iDskFmtType	= iFmtType;	*/			/* Save global default */

	FreeMemory( pchBuf );
	return( iFmtType );
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\fixboot.c ===
/***************************************************************************/
/* 																								*/
/* FIXBOOT.C																					*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/*	Module which does the fixup on all of the boot records and partition		*/
/* tables on the harddisks.																*/
/* 																								*/
/* CHANGE LOG:																					*/
/*		m102	- Fixed boundary condition bug when converting partitions to	*/
/*				  to BIGFOOT and now only convert small primary partitions to	*/
/*				  BIGFOOT if part of it lies physically past 32 meg boundary	*/
/*				  																					*/
/* johnhe - 09/15/90																			*/
/***************************************************************************/

#include		<stdio.h>
#include		<stdlib.h>
#include 	<bios.h>
#include		<dos.h>
#include		<string.h>

#include 	<alias.h>
#include 	<disk_io.h>
#include 	<global.h>
#include		<hdisk.h>
#include		<upgrade.h>
#include		<install.h>

/***************************************************************************/

#define	PART_LEN			sizeof( struct Part )
#define	HEADER_LEN		sizeof( struct BOOT_HEADER )

#define	HEADER_OFFSET	0
#define	TABLE_LEN		(SECTOR_SIZE - TABLE_OFFSET)
/* #define 	BOOT_CODE_LEN	0xe0 */

/***************************************************************************/

static int				iHdNum;
static struct Part	*NewTable;

/***************************************************************************/

extern int	ConvertBoot			( struct Part *Part, int IsPrimary ); /* m102*/
static void	near FixupPartitions( struct Part *PartLocation, int IsPrimary ); /*m102*/
static void	near PackPartitionTable( int Entries );
static struct Part * near GetNextFreePartEntry( void );

/***************************************************************************/
/* Function to do fixup of all boot records and partition tables in the		*/
/* system for up to 2 hard disks. Copies the master partition table for		*/
/* each drive into the pchMbrBuf, creates a dummy partition entry with the	*/
/* sectors phyical location and then calls FixupPartitions() to do the		*/
/* actual processing. Fixup requires converting DOS compatible parititions	*/
/* to types 1, 4 or 6 and then converting logical sectors into 512 byte		*/
/* sectors in the partition boot record.												*/
/*																									*/
/* NOTE:																							*/
/*			Rather than reading the partition record from the first hard disk	*/
/*			we have to get it from the pchOldPartRec buffer because we put		*/
/*			a tmp one on the hard disk which may be missing some entries.		*/
/*																									*/
/*	void FixupBootRecs( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void FixupBootRecs( void )
{
	register					i;
	register					Entries;
	static struct Part	MasterPart = { 0, 0, 1, 0,  0, 0, 0, 0,  0, 0 };
	extern char				TmpBoot;

	NewTable = GetPartTable( 4 );			/* Start of DOS 5.x partition table	*/

	memcpy( pchMbrBuf, pchOldPartRec, SECTOR_SIZE );

	/* Write temp. boot code if we have created Uninstall disk */

	if ( lpInstall->Flags.fUninstall )
	{
#ifdef	IADF_SUPPORT						/* M008 Added for IADF support		*/
		if ( !vInfo.Flag.fHasIadf )
		{				/* If real MBR is on first sector we need tmp boot code	*/
						/* and the TMP serial number restored							*/
			memcpy( pchMbrBuf, &TmpBoot, BOOT_CODE_LEN );
			*( (UL *)(pchMbrBuf+(BOOT_CODE_LEN - 4)) ) = vInfo.ulTmpSerial;
		}
#else
		memcpy( pchMbrBuf, &TmpBoot, BOOT_CODE_LEN );
		*( (UL *)(pchMbrBuf+(BOOT_CODE_LEN - 4)) ) = vInfo.ulTmpSerial;
#endif
	}

	*(pchMbrBuf + TABLE_OFFSET + (vInfo.chBootPart * 0x10)) = (CHAR)ACTIVE;

	for ( i = 0, iHdNum = 0x80; i < (int)vInfo.Hw.NumHard; i++, iHdNum++ )
	{
		if ( iHdNum == 0x80 || 
			  ReadPartBootRec( &MasterPart, pchMbrBuf, iHdNum ) == OK )
		{
			if ( !IsValidPartTable() )
				continue;

			Entries = GetPartEntries();		/* Determine size of part table	*/
			if ( Entries > 4 )
				PackPartitionTable( Entries );
														/* Write the master boot record	*/
			FixupPartitions( &MasterPart, TRUE );	/*m102 Added argument	*/
		}	
		else
			FatalError( FATAL_HD_READ_ERROR );
	}
}

/***************************************************************************/
/* Scans a partition table in the pchMbrBuf looking for compatible DOS 		*/
/* partitions. The BPB in the boot record on each DOS compatible partition	*/
/* is converted to DOS 5.x compatible format and the correct partition		*/
/* type inicator is placed in the partition table entry for than partition	*/
/* and then the boot record is written back. After all of the compatible	*/
/* entries are fixed up the updated partition table in pchMbrBuf is			*/
/* written back. Next a check is done for an extended partition entry and	*/
/* if one is found the entry for it is copied to a local buffer, the 		*/
/* sector for the extended paritition table is read in and the function		*/
/* recursively calls itself to process the extended partition.					*/
/*																									*/
/* NOTE: 																						*/
/* 		Because the function is recursive it may need at least 500 bytes	*/
/* 		of stack to allow for a possible 22 extended partitions.				*/
/*																									*/
/*	void FixupPartitions( struct Part *Part, int IsPrimary )						*/
/*																									*/
/*	ARGUMENTS:	struct Part * - Partition entry which specifies where the	*/
/*										 partition table in pchMbrBuf needs to be		*/
/*										 written back to the disk.							*/
/*					IsPrimary	- Flags if converting a primary partition			*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void near FixupPartitions( struct Part *PartLocation, int IsPrimary ) /* m102 */
{
	register			i;
	struct Part		ExtPartition;
	struct Part		*PartEntry;

	PartEntry = NewTable;								/* Addr first table entry	*/
																/* in pchMbrBuf				*/
	for ( i = 0; i < 4; i++, PartEntry++ )
	{
		if ( IsCompatPart( PartEntry->SystemIndicator ) )
		{
			if ( ReadPartBootRec( PartEntry, pchBootBuf, iHdNum ) == OK )
			{
				if ( ConvertBoot( PartEntry, IsPrimary ) == OK )		/* m102	*/
					if ( WritePartBootRec( PartEntry, pchBootBuf, iHdNum ) != OK )
						FatalError( FATAL_HD_WRITE_ERROR );
			}
			else
				FatalError( FATAL_HD_READ_ERROR );
		}
	}
											/* Write out the updated partition table	*/
	if ( WritePartBootRec( PartLocation, pchMbrBuf, iHdNum ) != OK )
		FatalError( FATAL_HD_WRITE_ERROR );
		
											/* Now handle possible extended partition	*/
	if ( (PartEntry = FindExtPartEntry( 4 )) != NULL )
	{
		memcpy( &ExtPartition, PartEntry, sizeof( struct Part ) );
		if ( ReadPartBootRec( PartEntry, pchMbrBuf, iHdNum ) == OK )
		{
			if ( IsValidPartTable() )
				FixupPartitions( &ExtPartition, FALSE );					/* m102	*/
		}
		else
			FatalError( FATAL_HD_READ_ERROR );
	}
}	

/***************************************************************************/
/* Function to transform partition boot records with logical sectoring 		*/
/* into DOS 5.0 compatible format and determines what the system indicator	*/
/* in the partition should be changed to. The boot sector must have			*/
/* already been read into the pchBootBuf before this function is called.	*/
/*																									*/
/*	int ConvertBoot( struct Part *Part )												*/
/*																									*/
/*	ARGUMENTS:	Part	- Ptr to a partition table entry for this boot sector	*/
/*					IsPrimary - Flags if converting a primary partition			*/
/*	RETURNS:		int	- OK if successful conversion else ERROR if the boot	*/
/*							  record is not a valid DOS record.							*/
/*																									*/
/***************************************************************************/

int ConvertBoot( struct Part *Part, int IsPrimary )					/* m102	*/
{
	unsigned					Factor;
	unsigned long			TotalSectors;
	struct DIR				Dir;
	struct BOOT_HEADER	Header;
	extern char				NewBootRec;
	unsigned					Clusters;

	memcpy( &Header, &NewBootRec, sizeof( struct BOOT_HEADER ) );
	memcpy( &Header.Bpb, pchBootBuf + 11, sizeof( struct BPB ) );

						/* First a sanity check to be sure it can be converted	*/
	if ( !IsFmtedBoot( (char *)(&Header) ) )
		return( ERROR );								/* Not a real DOS partition	*/

	Factor = Header.Bpb.uBytesPerSec / SECTOR_SIZE;
	TotalSectors = ((UL)(Header.Bpb.uTotalSectors)) * ((UL)Factor);

	Header.Bpb.uBytesPerSec		=  SECTOR_SIZE;
	Header.Bpb.uTotalSectors	=  0;					/* Already save the value	*/
	Header.Bpb.ulTotalBigSecs	*= (UL)Factor;
	Header.Bpb.uchSecPerClus = (UCHAR)(Factor*(UCHAR)Header.Bpb.uchSecPerClus);
	Header.Bpb.uReservSec		*= Factor;
	Header.Bpb.uSecPerFat		*= Factor;
	Header.Bpb.ulHiddenSec		=  Part->RelativeSector;
	Header.Bpb.uchMediaDescr	=  (UCHAR)0xf8;
													/* Check for missing total sectors	*/
	if ( TotalSectors == 0L )
	{
		if ( Header.Bpb.ulTotalBigSecs == 0L )
			  TotalSectors = Header.Bpb.ulTotalBigSecs = Part->TotalSectors;
		else
			TotalSectors = Header.Bpb.ulTotalBigSecs;
	}
	else
		Header.Bpb.ulTotalBigSecs = TotalSectors;

	strncpy( (char *)Header.uchSystemId,"FAT16   ",sizeof( Header.uchSystemId ));

		/* m102 We need to work around a bug in old versions of DOS by making*/
		/*      sure any primary partition lies completely in first 32 megs	*/
		/*      of the physcial disk or else we make it a bigfoot partition	*/

	if ( (TotalSectors + (IsPrimary ? Header.Bpb.ulHiddenSec : 0L)) > 0x10000L )
		Part->SystemIndicator = DOSNEW;
	else
	{
		Header.Bpb.ulTotalBigSecs = 0L;
		Header.Bpb.uTotalSectors = (UINT)TotalSectors;

													/* Determine if 16 or 12 bit FAT	*/
		Clusters = Header.Bpb.uTotalSectors -
					  (Header.Bpb.uSecPerFat * (UINT)Header.Bpb.uchNumberFats) -
					  (Header.Bpb.uRootEntries * sizeof( struct DIR ) / 512) -
					  Header.Bpb.uReservSec;
		Clusters = Clusters / (unsigned)Header.Bpb.uchSecPerClus;

		if ( Clusters >= (4096-10) )	/* DOS uses less than (4096-10)=12 bit */
			Part->SystemIndicator = DOS16;
		else
		{
			Header.uchSystemId[ 4 ] = '2';
			Part->SystemIndicator = DOS12;
		}
	}

	SetFileTimeDate( &Dir );
																/*lint -e740 */
	Header.ulSerial = *( (UL *)(&(Dir.Time)) );	/*lint +e740 */
	Header.uchExtSig = 0x29;

	memset( Header.uchVolLabel, ' ', sizeof( Header.uchVolLabel ) );
	Header.uchPhysDrv = (UCHAR)(iHdNum);
 	Header.uchCurHd = 0;

	memcpy( pchBootBuf, &Header, sizeof( struct BOOT_HEADER ) );
	return( OK );
}

/***************************************************************************/
/* Moves all entries in a partition table into the normal DOS 5.x entry		*/
/* positions. Any entries already in the correct location will not be		*/
/* moved. The partition sector must have already been read into the 			*/
/* pchMbrBuf before this function is called.											*/
/*																									*/
/*	void PackPartitionTable( int Entries )												*/
/* 																								*/
/*	ARGUMENTS:	Entries	- Total partition entry fields to process.			*/
/*	RETURNS:		void																			*/
/* 																								*/
/***************************************************************************/

void near PackPartitionTable( int Entries )
{
	struct Part		*OldTable;
	struct Part 	*NextFreeEntry;

	for ( OldTable = GetPartTable( Entries ); OldTable < NewTable; OldTable++ )
	{
		if ( IsCompatPart( OldTable->SystemIndicator ) )
		{
			if ( (NextFreeEntry = GetNextFreePartEntry()) != NULL )
			{
				memcpy( NextFreeEntry, OldTable, sizeof( struct Part ) );
				memset( OldTable, 0, sizeof( struct Part ) );
			}
		}
	}
}

/***************************************************************************/
/* Returns a ptr to then next free partition table entry in the pchMbrBuf.	*/
/* based on a DOS 5.x limit of 4 entries in the table.							*/
/*																									*/
/*	struct Part *GetNextFreePartEntry( void )											*/
/*																									*/
/*	ARGUMENTS:	void																			*/
/*	RETURNS:		struct Part *	- Ptr to first free partition entry				*/
/*																									*/
/***************************************************************************/

struct Part * near GetNextFreePartEntry( void )
{
	register			i;
	struct Part 	*NextFreeEntry;

	NextFreeEntry = NewTable;

	for ( i = 0; i < 4; i++, NextFreeEntry++ )
		if ( NextFreeEntry->SystemIndicator == 0 )
			return( NextFreeEntry );

	return( NULL );
}

/***************************************************************************/
/* Returns TRUE if a sector in pchMbrBuf contains a valid boot signature	*/
/* in the last 2 bytes of the sector (offset 0x1fe - 0x1ff).					*/
/*																									*/
/* int IsValidPartTable( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- TRUE if signature exists else FALSE						*/
/*																									*/
/***************************************************************************/

int IsValidPartTable( void )
{
	return( *((UINT *)(pchMbrBuf + BOOT_SIG_OFFSET)) == (UINT)BOOT_SIG );
}

/***************************************************************************/
/* Returns a ptr to the first extended partition entry in partition table	*/
/* in the pchMbrBuf. If no extended partition entry is found in the number	*/
/* of entries specified a NULL ptr is returned.										*/
/*																									*/
/*	struct Part *FindExtPartEntry( int Entries )										*/
/*																									*/
/*	ARGUMENTS:	int	- TotalEntries in the partition table						*/
/*	RETURNS:		struct Part * - Ptr to first ext. partition entry or NULL	*/
/*																									*/
/***************************************************************************/

struct Part *FindExtPartEntry( int Entries )
{
	register		i;
	struct Part	*Part;

	Part = GetPartTable( Entries );
	for ( i = 0; i < Entries; i++, Part++ )
		if ( Part->SystemIndicator == EXTENDED )
			return( Part );
	return( NULL );
}

/***************************************************************************/
/* Returns a ptr to the start of a partition table in the pchMbrBuf based	*/
/* on the number of entries in the table.												*/
/*																									*/
/*	struct Part *GetPartTable( int Entries )											*/
/*																									*/
/*	ARGUMENTS:	Entries	- Total entries which will be in the table			*/
/* RETURNS:		struct Part * - Ptr to start of the partition table			*/
/*																									*/
/***************************************************************************/

struct Part *GetPartTable( int Entries )
{
	return( (struct Part *)(pchMbrBuf + BOOT_SIG_OFFSET -
								   ((UINT)Entries * PART_LEN)) );
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\fake-ver.c ===
/***************************************************************************/
/* 																								*/
/* FAKE-VER.C																					*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* This module contains the functions which read in the version table		*/
/* from SETVER.EXE and then updates the table with new entries and 			*/
/* writes it back to the file.															*/
/*																									*/
/* The fake version table is located in the SETVER.EXE file and it's			*/
/* location and length are specified right after the device header in		*/
/* the executable part of the file.														*/
/* 																								*/
/* Created 			12-06-89 -  johnhe													*/
/* Major change 	04-18-90	-  johnhe													*/
/*										Ported from SERVER.C to support the new		*/
/*										lie table format in DOS 5.00 which moved		*/
/*										the table from the end of MSDOS.SYS to a		*/
/*										a random location within the file and			*/
/*										deleted the FAKE COUNT field.						*/
/* Major change	01-04-91	- johnhe														*/
/*									  Move the table from MSDOS.SYS to					*/
/*									  SETVER.EXE.												*/
/*																									*/
/*	Major change	08-10-91	- New code to copy the version table from the	*/
/*									  OLD_DOS.xxx directory if it's compatible m113	*/
/***************************************************************************/

#include 	<stdio.h>
#include 	<string.h>
#include 	<dos.h>
#include 	<io.h>
#include 	<fcntl.h>
#include		<malloc.h>															/* m113	*/

#include		<alias.h>
#include		<global.h>
#include 	<disk_io.h>
#include		<strlib.h>
#include 	<data.h>

/***************************************************************************/

#define	MAX_NAME_LEN		13
#define	MAX_ENTRY_SIZE		(MAX_NAME_LEN + 1 + 2 + 1)

struct ExeHeader
{
	UINT		Signature;
	UINT		LastPageLen;
	UINT		TotalFilePages;
	UINT		NumRelocEntries;
	UINT		HeaderParas;
	UINT		MinEndParas;
	UINT		MaxEndParas;
	UINT		StackSeg;
	UINT		StackPtr;
	UINT		NegChkSum;
	UINT		IndexPtr;
	UINT		CodeSeg;
	UINT		RelocTblOffset;
	UINT		OverlayNum;
};

struct DevHeader
{
	char far		*NextDevice;
	unsigned		DeviceAttrib;
	char near	*Strategy;
	char near	*Entry;
	char			Name[ 8 ];
	char			VersMinor;
	char			VersMajor;
	long			TblOffset;
	unsigned		TblLen;
};

/***************************************************************************/

static char		szPath[ MAX_PATH ];
static char		*LieBuffer;		/* Buffer to read lietable into	*/
static char		*NextEntry; 	/* Ptr to next free entry in lietable buffer */
static int 		iFile;

struct ExeHeader		ExeHdr;
struct DevHeader		DevHdr;
static char				*szSetVer = "SETVERXX";
long						FileOffset;

static unsigned		OldTblLen;												/* m113	*/
static char				*OldLieBuffer;											/* m113	*/

/***************************************************************************/

extern void	UpdateLie		( void );
int			SeekRead			( void *Buf, long lOffset, unsigned uBytes );

static int near	ReadLieTable	( void );
static int near	WriteLieTable	( void );
static int near	FindLastEntry	( void );
static void near	AddToTable		( char *szFile );

static int near	ReadVersionTable( void );
static int near	WriteVersionTable( void );
static int near	LoadOldTable	( void );								/* m113	*/

/***************************************************************************/
/* Gets all strings in the LIE_TO list for this OEM and adds them to the	*/
/* lie table in the SETVER.EXE file on the boot drive in the DOS directory	*/
/* m113 - If there is a version table in the OLD_DOS.xxx directory it will	*/
/*			 be used instead.																	*/
/*																									*/
/* void UpdateLie( void )																	*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void UpdateLie( void )
{
	register			i; 								/* Loop indice 					*/
	int				iStatus; 						/* Keep track of any errors	*/
	char				*szString;						/* File name to lie to			*/
	char				*MaxEntry;

	if ( LoadOldTable() == OK )												/* m113	*/
	{																					/* m113	*/
		iStatus = ERROR;															/* m113	*/
	   BuildPath( szPath, vInfo.szPath[0], vInfo.szPath + 2,			/* m113	*/
					  SETVER_STR );												/* m113	*/
		if ( ReadVersionTable() == OK )										/* m113	*/
		{																				/* m113	*/
			memset( LieBuffer, 0, DevHdr.TblLen );							/* m113	*/
			memcpy( LieBuffer, OldLieBuffer,									/* m113	*/
					  (DevHdr.TblLen < OldTblLen ?							/* m113	*/
						DevHdr.TblLen : OldTblLen) );							/* m113	*/
			FreeMemory( OldLieBuffer );										/* m113	*/
			iStatus = WriteVersionTable ();									/* m113	*/
			_dos_close( iFile );													/* m113	*/
			FreeMemory( LieBuffer );											/* m113	*/
		}																				/* m113	*/
		if ( iStatus != OK )														/* m113	*/
			FatalError( LIE_TABLE_UPDATE_ERROR );							/* m113	*/
		return;																		/* m113	*/
	}																					/* m113	*/
									/* Make sure some lie-to files were specified	*/
									/* for this OEM in the dosdata file 				*/

	if ( (szString = GetDataString( LIE_TO, 0 )) == NULL )
		return;
   BuildPath( szPath, vInfo.szPath[0], vInfo.szPath + 2, SETVER_STR );

	LieBuffer = NULL;
	iStatus = ERROR;
	if ( ReadVersionTable() == OK )				/* Read in the old lie table	*/
	{
		NextEntry = LieBuffer;
		MaxEntry = LieBuffer + (DevHdr.TblLen - MAX_ENTRY_SIZE);

															/* Find where new entries go	*/
		while( *NextEntry != 0 && NextEntry < MaxEntry )
			NextEntry += (*NextEntry + 3);

									/* Set up loop to get all the	lie-to strings		*/
		for ( i = 0;
				(szString = GetDataString( LIE_TO, i )) != NULL &&
				NextEntry <= MaxEntry;
				i++ )
			AddToTable( szString );

		iStatus = WriteVersionTable ();				/* Write file back to disk	*/
	}

	if ( iFile )
		_dos_close( iFile );
	if ( LieBuffer != NULL )
		FreeMemory( LieBuffer );

	if ( iStatus != OK )
		FatalError( LIE_TABLE_UPDATE_ERROR );	/* Error was detected			*/
}

/***************************************************************************/
/* Add a file name to the lie table buffer. Copies up to 12 character in	*/
/* in the file name and then set the length of the string, major and minor */
/* version numbers and fake count.														*/
/* 																								*/
/* void AddToTable( char *szFile )														*/
/* 																								*/
/* ARGUMENTS:	szFile	- Ptr to file name to add to the list					*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void near AddToTable( char *szFile )
{
	char			*Ptr;
	register 	iLen;

	Ptr = NextEntry + 1;
	strupr( szFile );
	strncpy( Ptr, szFile, MAX_NAME_LEN );		/* Copy the entry filename */

	iLen = (int)strlen( Ptr );						/* Get number bytes copied */
	*NextEntry = (char)iLen;						/* Set length of field		*/

	NextEntry++;										/* Add size of len field	*/
	NextEntry += iLen;								/* Add len of file name		*/
	*(NextEntry++) = (char)vInfo.uchVersMajor;/* Copy major version # 	*/
	*(NextEntry++) = (char)vInfo.uchVersMinor;/* Copy minor versoin # 	*/
}

/***************************************************************************/
/* Opens the SETVER.EXE file and reads in the .EXE header to find the		*/
/* start of the code and then reads in the device header there which has	*/
/* the offset and length of the lie table.											*/
/*																									*/
/*	int ReadVersionTable( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- OK if successful else error code							*/
/*																									*/
/***************************************************************************/

int near ReadVersionTable( void )
{
	register		iStatus;						/* Function's return value				*/
	unsigned		uRead;						/* Number of bytes read from file	*/

			/* Open the file and read in the max buffer len from stack seg		*/
	if ( _dos_open( szPath, O_RDWR, &iFile ) != OK )
		return( ERROR );

	iStatus = ERROR;

	if ( _dos_read( iFile, &ExeHdr, sizeof( ExeHdr ), &uRead ) == OK &&
		  uRead == sizeof( ExeHdr ) )
	{
		/* m113 Can't assume FileOffset was 0 if function is called twice		*/
		/* m113	FileOffset += (long)(ExeHdr.HeaderParas * 16);					*/

		FileOffset = (long)(ExeHdr.HeaderParas * 16);					/* m113	*/

		if ( SeekRead( &DevHdr, FileOffset, sizeof( DevHdr ) ) == OK )
		{
			if ( strncmp( DevHdr.Name, szSetVer, 8 ) == OK &&
				  DevHdr.VersMajor >= 1 )
			{
				FileOffset += DevHdr.TblOffset;
				LieBuffer = GetMemory( DevHdr.TblLen );
				if ( SeekRead( LieBuffer, FileOffset, DevHdr.TblLen ) == OK )
					iStatus = OK;
			}
		}
	 }
	return( iStatus );
}

/***************************************************************************/
/* Writes the version table to the already open SETVER.EXE file.				*/
/*																									*/
/*	int WriteVersionTable( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- OK if successful else ERROR									*/
/*																									*/
/***************************************************************************/

int near WriteVersionTable( void )
{
	unsigned			uWritten;				/* Number of bytes written to file	*/

	if ( _dos_seek( iFile, FileOffset, SEEK_SET ) == FileOffset &&
		  _dos_write(iFile, LieBuffer, DevHdr.TblLen, &uWritten ) == OK &&
		  uWritten == DevHdr.TblLen )
		return( OK );
	else
		return( ERROR );
}

/***************************************************************************/
/* Seeks to the specified offset in a file and reads in the specified		*/
/* number of bytes into the caller's buffer.											*/
/*																									*/
/*	unsigned SeekRead( char *Buf, long lOffset, unsigned uBytes )				*/
/*																									*/
/*	ARGUMENTS:	Buf		- Ptr to read buffer											*/
/*					lOffset	- Offset in file to start reading at					*/
/*					uBytes	- Number of bytes to read									*/
/*	RETURNS:		unsigned	- OK if successfull else ERROR							*/
/*																									*/
/***************************************************************************/

int SeekRead( void *Buf, long lOffset, unsigned uBytes )
{
	unsigned		uRead;

	if ( _dos_seek( iFile, lOffset, SEEK_SET ) == lOffset &&
		  _dos_read( iFile, Buf, uBytes, &uRead ) == OK &&
		  uRead == uBytes )
		return( OK );
	else
		return( ERROR );
}

/***************************************************************************/
/*	Searches for a SETVER.EXE file in the OLD_DOS.xxx directory and if one	*/
/* is found and it's compatible with DOS 5.0 the table will be copied to	*/
/* to OldLieBuffer.																			*/
/*																									*/
/*	int LoadOldTable( void )																*/
/*																									*/
/*	ARGUEMENT:	NONE																			*/
/*	RETURNS:		int	-	OK if a table was loaded into OldLieBuffer			*/
/*								else ERROR														*/
/***************************************************************************/

int near LoadOldTable( void )													/* m113	*/	
{																						/* m113	*/	
	int		iStatus = ERROR;													/* m113	*/

   BuildPath( szPath, vInfo.szTmpDir[0], vInfo.szTmpDir + 2,		/* m113	*/
				  SETVER_STR );													/* m113	*/	
	LieBuffer = NULL;																/* m113	*/	
	if ( ReadVersionTable() == OK )											/* m113	*/
	{																					/* m113	*/
		OldTblLen = DevHdr.TblLen;												/* m113	*/
		OldLieBuffer = LieBuffer;												/* m113	*/
		iStatus = OK;																/* m113	*/
	}																					/* m113	*/
	else if ( LieBuffer != NULL )												/* m113	*/
	{																					/* m113	*/
		FreeMemory( LieBuffer );												/* m113	*/
		LieBuffer = NULL;															/* m113	*/
	}																					/* m113	*/

	if ( iFile )																	/* m113	*/
	{																					/* m113	*/
		_dos_close( iFile );														/* m113	*/
		iFile = 0;																	/* m113	*/	
	}																					/* m113	*/	

	return( iStatus );															/* m113	*/	
}																						/* m113	*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\log.h ===
void FAR LogProgress(char *pszInfo);

#ifdef LOGGING
#define LOG(c)    LogProgress(c);
#else
#define LOG(c)    0
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\helpcon.h ===
/*
 *  This file contains help context numbers. Each of the values refers to
 *  a dialog. The HELPCONTEXT dialog control defined below is used to place
 *  help context information into dialog templates.
 *
 */

#define HELPCONTEXT(n)            LTEXT "", n, 0, 0, 0, 0

/*
 *  These are the help context values for each of the dialogs that contain
 *  help context information.
 */

/* Help screen context numbers. */

#define  DOS2GUI_INDEX             0x1000

#define  HLP_BADDOSEXIT            0x1001
#define  HLP_UNINSTALL             0x1002
#define  HLP_FMTTYPE               0x1003
#define  HLP_EXPRESSINSERTDISK     0x1004
#define  HLP_UNINSTALLINFO         0x1005

/*  Min and max Context ID values, we use these in the code to validate
 *  the help context numbers.
 */

#define  HELP_CONTEXT_MIN          0x1001  // Set me to the smallest help ID.
#define  HELP_CONTEXT_MAX          0x1005  // Set me to the largest help ID.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\pro.h ===
/***************************************************************************

INCLUDE FILE: Progress.h


   Copyright (C) Microsoft, 1991

HISTORY:

   Modified by:      Date:       Comment:

   TL                11/01/87    Created



***************************************************************************/

BOOL EXPORT ProDlgProc(HWND, WORD, WORD, DWORD);
BOOL PUBLIC ProInit(HANDLE,HANDLE);
void PUBLIC ProClear(HWND hDlg);
HWND PUBLIC ProOpen(HWND,int,char *);
BOOL PUBLIC ProClose(void);
BOOL PUBLIC ProSetBarRange(int);
BOOL PUBLIC ProSetBarPos(int);
BOOL PUBLIC ProDeltaPos(int);
BOOL PUBLIC ProSetText (int,LPSTR);
void PUBLIC ProToTop (void);
BOOL FAR cdecl ProPrintf (int,LPSTR,...);

#define ID_BAR	      100
#define CLS_STEXT    "stext"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\prompts.h ===
/* Defines information for file copy errors */

struct CurrentFile
{

	unsigned char		chReadWrite;
	unsigned char		chValidErrors;
	char					szFileName[13];

} vCurrentFile;


extern int		PromptForDisk( char chSourceDrv );

extern void 	RebootPrompt		( void );
extern void 	DisplayFileStatus	( char *szFileName, int Type );
extern int		PromptSelect		( char * *szStrings, char * *szOpts );
extern void 	ProcessCopyError	( char *szFileName, int Type );
extern int		AbortPrompt			( void );
extern void 	WriteProtectPrompt( char Disk );
extern void 	NotReadyPrompt		( char Disk );
extern void 	FatalDiskError		( char Disk );
extern void 	FatalError			( int ErrorNumber );
extern void 	FileStatusUpdate	( void );

/* PROMPTS lib */
extern int		PromptForDefault( void );
extern int		PromptForDiskFmt( int iDrvType );
extern void 	FmtStat( unsigned uTrack, unsigned uHead );
extern void		ProcessDiskError(int ErrorType);
extern void 	Error(char * *ErrorString);


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\model.inc ===
; ========================================================================
call_M	MACRO	Function

IF 	@codesize			; Call adjusted for memory model

	call	FAR PTR Function	; FAR call if LARGE, MED, or HUGE
ELSE
	call	NEAR PTR Function	; Else NEAR call
ENDIF
ENDM

; ========================================================================

DOSSEG

IFDEF  MODEL_SMALL
.MODEL	SMALL,C
ENDIF

IFDEF	MODEL_COMPACT
.MODEL  COMPACT,C
ENDIF

IFDEF  MODEL_MEDIUM
.MODEL	MEDIUM,C
ENDIF

IFDEF  MODEL_LARGE
.MODEL	LARGE,C
ENDIF


LoadPtr MACRO vSegReg, vReg, vPtr

  SEG_OK = 0
  REG_OK = 0
  PTR_OK = 0

				;; Error checking on segment register
  IFNB <vSegReg>
    IRP x, <ES,DS>
      IFIDN <x>,<vSegReg>
        SEG_OK = 1
      ENDIF
    ENDM 
  ENDIF

				;; Error checking on index register
  IFNB <vReg>
    IRP y, <AX,BX,CX,DX,SI,DI>
      IFIDN <y>,<vReg>
        REG_OK = 1
      ENDIF
    ENDM 
  ENDIF

				;; Error checking on memory pointer
  IFNB <vPtr>
    PTR_OK = 1
  ENDIF

  IF (SEG_OK + REG_OK + PTR_OK) NE 3

    IF SEG_OK EQ 0
      %out <LoadPtr Macro --> Invalid segment register vSegReg was specified.>
    ENDIF

    IF REG_OK EQ 0
      %out <LoadPtr Macro --> Invalid register vReg was specified.>
    ENDIF

    IF PTR_OK EQ 0
      %out <LoadPtr Macro --> No memory pointer was specified.>
    ENDIF

    .ERR

  ELSE

    IF @DataSize

      IFIDN <vSegReg>,<DS>
        lds	vReg, vPtr
      ELSEIFIDN <vSegReg>,<ES>
        les vReg, vPtr
      ENDIF
    ELSE
      mov  vReg, vPtr	

    ENDIF

  ENDIF

ENDM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\pro.c ===
#include "winenv.h"
#include "lib\\common\\sulib.h"
#include "wsrc.h"
#include "pro.h"
#include "ws.h"


//======================================================================
//
//		e x t e r n s 
//
//======================================================================

extern HWND hwndParent;
extern HANDLE hInstWS;

//======================================================================
//                                                                      
//   g l o b a l   v a r i a b l e s                                    
//                                                                      
//======================================================================

HWND    ghWnd = NULL;
static int     iCnt;
static FARPROC fpxProDlg;
static DWORD   rgbFG;
static DWORD   rgbBG;
static FARPROC fpfnWait;
static HWND    hwndStatus;

#define BAR_RANGE 0
#define BAR_POS   2

#define BAR_SETRANGE  WM_USER+BAR_RANGE
#define BAR_SETPOS    WM_USER+BAR_POS
#define BAR_DELTAPOS  WM_USER+4

#ifndef COLOR_HIGHLIGHT
    #define COLOR_HIGHLIGHT     (COLOR_APPWORKSPACE + 1)
    #define COLOR_HIGHLIGHTTEXT   (COLOR_APPWORKSPACE + 2)
#endif

#define COLORBG  rgbBG
#define COLORFG  rgbFG

extern BOOL fMono;
char szNull[] = "";

//========================================================================
//
//		f u n c t i o n   d e f i n i t i o n s
//
//========================================================================


BOOL FAR PASCAL ProDlgProc(HWND, WORD, WORD, DWORD);
LONG FAR PASCAL ProBarProc(HWND, unsigned, WORD, LONG);

/*----------------------------------------------------------------------------*\
|   ProInit( hPrev,hInst )                         |
|                                                                              |
|   Description:                                                               |
|       This is called when the application is first loaded into               |
|   memory.  It performs all initialization.                |
|                                                                              |
|   Arguments:                                                                 |
|   hPrev      instance handle of previous instance              |
|   hInst      instance handle of current instance                |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if successful, FALSE if not                                       |
|                                                                              |
\*----------------------------------------------------------------------------*/

BOOL PUBLIC ProInit (HANDLE hPrev, HANDLE hInst)
{
   WNDCLASS   rClass;

   if (!hPrev)
   {
      rClass.hCursor       = LoadCursor(NULL,IDC_ARROW);
      rClass.hIcon         = NULL;
      rClass.lpszMenuName  = NULL;
      rClass.lpszClassName = PRO_CLASS;
      rClass.hbrBackground = (HBRUSH)COLOR_WINDOW+1;
      rClass.hInstance     = hInst;
      rClass.style         = CS_HREDRAW | CS_VREDRAW;
      rClass.lpfnWndProc   = ProBarProc;
      rClass.cbClsExtra    = 0;
      rClass.cbWndExtra    = 2*sizeof(WORD);

      if (!RegisterClass(&rClass))
         return FALSE;
   }

#if 0
   rgbFG = GetSysColor(COLOR_HIGHLIGHTTEXT);
   rgbBG = GetSysColor(COLOR_HIGHLIGHT);
#endif

   if (fMono)
   {
      rgbBG = RGB(0,0,0);
      rgbFG = RGB(255,255,255);
   }
   else
   {
      rgbBG = RGB(0,0,255);
      rgbFG = RGB(255,255,255);
   }
   return TRUE;
}

void PUBLIC ProClear(HWND hDlg)
{
   if (!hDlg)
      hDlg = ghWnd;

   SetDlgItemText (hDlg, ID_STATUS1, szNull);
   SetDlgItemText (hDlg, ID_STATUS2, szNull);
//   SetDlgItemText (hDlg, ID_STATUS3, szNull);
//   SetDlgItemText (hDlg, ID_STATUS4, szNull);
}


/***************************************************************************

ProDlgProc
----------

DESCRIPTION:

   This is the dialog procedure for the Progress Dialog 



HISTORY:

   Modified by:      Date:       Comment:

   PAK               8/21/91     Created

***************************************************************************/
BOOL EXPORT ProDlgProc(HWND hDlg, WORD wMsg, WORD wParam, DWORD dwParam)
{
   switch (wMsg)
   {
      case WM_COMMAND:
         switch (wParam)
         {
//            case ID_CANCEL:
//               gbProgressCancel = TRUE;
//               break;

//            case ID_EXIT:
//               PostMessage(hwndWS, WM_COMMAND, ID_EXITSETUP, (LONG)hDlg);
//               break;

            default:
               return FALSE;
         }
         break;

      case WM_INITDIALOG:
         ProClear(hDlg);
         if (dwParam)
            SetDlgItemText(hDlg, ID_CANCEL, (PSTR)dwParam);
         wsDlgInit(hDlg, DLGINIT_REMOVE_CLOSE_MENU);
         break;

      default:
         return FALSE;
   }
   return TRUE;
}

/*----------------------------------------------------------------------------*\
|   ProBarProc( hWnd, uiMessage, wParam, lParam )
|
|   Description:
|   The window proc for the Progress Bar chart
|
|   Arguments:
|   hWnd      window handle for the dialog
|       uiMessage       message number
|       wParam          message-dependent
|       lParam          message-dependent
|
|   Returns:
|       0 if processed, nonzero if ignored
|
\*----------------------------------------------------------------------------*/

LONG EXPORT ProBarProc( HWND hWnd, unsigned uiMessage,
                        WORD wParam, long lParam )
{
   PAINTSTRUCT rPS;
   RECT        rc1,rc2;
   WORD        dx,dy,x;
   WORD        iRange,iPos;
   char        ach[30];
   DWORD       dwExtent;

   switch (uiMessage)
   {
      case WM_CREATE:
         SetWindowWord (hWnd,BAR_RANGE,100);
         SetWindowWord (hWnd,BAR_POS,0);
         return 0L;

      case BAR_SETRANGE:
      case BAR_SETPOS:
         SetWindowWord (hWnd,uiMessage-WM_USER,wParam);
         InvalidateRect (hWnd,NULL,FALSE);
         UpdateWindow(hWnd);
         return 0L;

      case BAR_DELTAPOS:
         iPos = GetWindowWord (hWnd,BAR_POS);
         SetWindowWord (hWnd,BAR_POS,iPos+wParam);
         InvalidateRect (hWnd,NULL,FALSE);
         UpdateWindow(hWnd);
         return 0L;

      case WM_PAINT:
         BeginPaint(hWnd,&rPS);
         GetClientRect (hWnd,&rc1);
         FrameRect(rPS.hdc,&rc1,GetStockObject(BLACK_BRUSH));
         InflateRect(&rc1,-1,-1);

         rc2 = rc1;
         iRange = GetWindowWord (hWnd,BAR_RANGE);
         iPos   = GetWindowWord (hWnd,BAR_POS);

         if (iRange <= 0)
            iRange = 1;

         if (iPos > iRange)   // make sure we don't go past 100%
            iPos = iRange;

#ifdef fixbar
THIS_CODE_NOT_DEBUGGED
         /* following code should fix overwrite of left edge of
         status bar.  If we have time to verify this, enable it */
         dx = rc1.right - rc1.left;
         dy = rc1.bottom - rc1.top;
         x  = (WORD)((DWORD)iPos * dx / iRange);
#else
         dx = rc1.right;
         dy = rc1.bottom;
         x  = (WORD)((DWORD)iPos * dx / iRange) + 1;
#endif

         wsprintf (ach,"%3d%%",(WORD)((DWORD)iPos * 100 / iRange));
         dwExtent = GetTextExtent (rPS.hdc,ach,4);

#ifdef fixbar
THIS_CODE_NOT_DEBUGGED
         /* following code should fix overwrite of left edge of
         status bar.  If we have time to verify this, enable it */
         rc1.right = rc2.left  = (rc1.left + x);
#else
         rc1.right = x;
         rc2.left  = x;
#endif

         SetBkColor(rPS.hdc,COLORBG);
         SetTextColor(rPS.hdc,COLORFG);
         ExtTextOut (rPS.hdc,
                     (dx-LOWORD(dwExtent))/2,(dy-HIWORD(dwExtent))/2,
                     ETO_OPAQUE | ETO_CLIPPED,
                     &rc1,
                     ach,4,NULL);

         SetBkColor(rPS.hdc,COLORFG);
         SetTextColor(rPS.hdc,COLORBG);
         ExtTextOut (rPS.hdc,
                     (dx-LOWORD(dwExtent))/2,(dy-HIWORD(dwExtent))/2,
                     ETO_OPAQUE | ETO_CLIPPED,
                     &rc2,
                     ach,4,NULL);

         EndPaint(hWnd,(LPPAINTSTRUCT)&rPS);
         return 0L;

    }
    return DefWindowProc(hWnd,uiMessage,wParam,lParam);
}


/*----------------------------------------------------------------------------*\
|   ProOpen ()                               |
|                                                                              |
|   Description:                                                               |
|                                                                              |
|   Arguments:                                                                 |
|                                                                              |
|   Returns:                                                                   |
|       0 if processed, nonzero if ignored                                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
HWND PUBLIC ProOpen(HWND hWnd, int id, char *pszCancelButtonText)
{
   DWORD dwParam = 0L;

//   if (id == DLG_PROGRESS_GENERIC)
//      dwParam = MAKELONG(pszCancelButtonText,0);
      
   iCnt++;
   if (!ghWnd)
   {
      fpxProDlg = MakeProcInstance((FARPROC)ProDlgProc,NULL);
      ghWnd = hwndParent = CreateDialogParam(hInstWS, MAKEINTRESOURCE(id),
                                             hWnd, fpxProDlg, dwParam);
      WinAssert(ghWnd);
      ShowWindow (ghWnd,SHOW_OPENWINDOW);
      UpdateWindow(ghWnd);
   }
   ProSetBarRange(100);
   ProSetBarPos(0);
   return ghWnd;
}

/*----------------------------------------------------------------------------*\
|   ProClose ()                             |
|                                                                              |
|   Description:                                                               |
|                                                                              |
|   Arguments:                                                                 |
|                                                                              |
|   Returns:                                                                   |
|       0 if processed, nonzero if ignored                                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
BOOL PUBLIC ProClose()
{
   iCnt--;
   if (ghWnd && iCnt == 0) {
      DestroyWindow (ghWnd);
      FreeProcInstance (fpxProDlg);
      ghWnd = NULL;
   }
   return TRUE;
}


BOOL PUBLIC ProSetText (int i,LPSTR lpch)
{
   if (ghWnd)
   {
      SetDlgItemText (ghWnd,i,lpch);
      return TRUE;
   }
   return FALSE;
}

BOOL FAR cdecl ProPrintf (int i, LPSTR lpch, ...)
{
   char ach[200];

   if (ghWnd)
   {
      wvsprintf(ach, lpch, (LPSTR)(&lpch+1));
      SetDlgItemText(ghWnd, i, ach);
      return TRUE;
   }
   return FALSE;
}

BOOL PUBLIC ProSetBarRange (int i)
{
   if (ghWnd)
   {
      SendDlgItemMessage(ghWnd,ID_BAR,BAR_SETRANGE,i,0L);
      return TRUE;
   }
   return FALSE;
}

BOOL PUBLIC ProSetBarPos (int i)
{
   if (ghWnd)
   {
      SendDlgItemMessage(ghWnd,ID_BAR,BAR_SETPOS,i,0L);
      return TRUE;
   }
   return FALSE;
}

BOOL PUBLIC ProDeltaPos (int i)
{
   if (ghWnd)
   {
      SendDlgItemMessage(ghWnd,ID_BAR,BAR_DELTAPOS,i,0L);
      return TRUE;
   }
   return FALSE;
}

void PUBLIC ProToTop(void)
{
   if (ghWnd)
      BringWindowToTop(ghWnd);
}



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\resolve.c ===
#include <string.h>

#include "winenv.h"
#include "pro.h"
#include "ws.h"
#include "wsrc.h"

typedef		unsigned char		UCHAR;
#include	<install.h>
#include <data.h>
#include <copy.h>
#include <global.h>
#include	<file_io.h>

#include "lib\\common\\sulib.h"

extern char 		*GetDistribPrompt	( int iDiskNum );
void RebootSystem(void);

char     gpszLoadBuf[MAX_RES];    // Used only in wsLoadsz() function for NULL case.
WORD	fExit;

typedef struct {
   LPSTR lpszPath;
   BYTE  cDisk;
} DISK, *PDISK;

extern 	struct MULT_FILES *gFiles;
extern 	void 	 InsertDisk( int DskNum );
extern   int    iWillReboot;

/*
 *  Declared in towin.c, always contains the currect uninstall disk
 *  number (zero based)
 */
extern int iUninstallDiskNum;
extern void	InitUninstallDisk	( int iUninstallDiskNum );

/*----------------------------------------------------------------------------*\
|   fDialog(id,hwnd,fpfn)                                                       |
|                                                                               |
|   Description:                                                               |
|   This function displays a dialog box and returns the exit code.                |
|   the function passed will have a proc instance made for it.                   |
|                                                                               |
|   this also handles special keyboard input by calling CheckSpecialKeys()      |
|                                                                              |
|                                                                              |
|   Arguments:                                                                 |
|   id      resource id of dialog to display                                        |
|   hwnd      parent window of dialog                                            |
|   fpfn      dialog message function                                            |
|                                                                              |
|   Returns:                                                                   |
|   exit code of dialog (what was passed to EndDialog)                            |
|                                                                              |
\*----------------------------------------------------------------------------*/
int FAR fDialog(int id, HWND hwnd, FARPROC fpfn)
{
    int      result = 0;
    MSG     msg;

    while (PeekMessage((LPMSG)&msg, NULL, WM_KEYFIRST, WM_MOUSELAST,
                        PM_NOYIELD|PM_REMOVE));

    fpfn  = MakeProcInstance(fpfn,hInstWS);

    if (!fpfn)
       goto ERR_EXIT;

    result = DialogBox(hInstWS, MAKEINTRESOURCE(id), hwnd, fpfn);

    FreeProcInstance(fpfn);

ERR_EXIT:

//    wsHelp(HLP_NULL);
    return result;
}

/*----------------------------------------------------------------------------*\
|   fDialogWithlParam(int id, HWND hwnd, PARPROC fpfn, DWORD lParam)          |
|                                  |
|   Description:                                                               |
|   This function displays a dialog box and returns the exit code.          |
|   the function passed will have a proc instance made for it.          |
|       This function is equivelent to fDialog except it calls                 |
|       DialogBoxParam(); to create the dialog so that init info               |
|       can be passed to the dislog proc at WM_INITDIALOG time.                |
|                                  |
|   this also handles special keyboard input by calling CheckSpecialKeys() |
|                                  |
|   Arguments:                                                                 |
|   id      resource id of dialog to display             |
|   hwnd      parent window of dialog                 |
|   fpfn      dialog message function                 |
|       lParam          DWORD info that will become the lParam on the          |
|                       WM_INITDIALOG message to the dialog proc.              |
|                                                                              |
|   Returns:                                                                   |
|   exit code of dialog (what was passed to EndDialog)             |
|                                                                              |
\*----------------------------------------------------------------------------*/
int FAR fDialogWithlParam(int id, HWND hwnd, FARPROC fpfn, DWORD lParam)
{
    int      result = 0;
    MSG     msg;

//    wsHelp(id);

    while (PeekMessage((LPMSG)&msg, NULL, WM_KEYFIRST, WM_MOUSELAST,
                        PM_NOYIELD|PM_REMOVE));

    fpfn  = MakeProcInstance(fpfn,hInstWS);

    if (!fpfn)
       goto ERR_EXIT;

    result = DialogBoxParam(hInstWS,MAKEINTRESOURCE(id),hwnd,fpfn,lParam);

    FreeProcInstance(fpfn);

ERR_EXIT:

//    wsHelp(HLP_NULL);
    return result;
}

/***************************************************************************
 *
 *
 * note:
 *   this uses a TASKMODAL dialog so no parent is needed.
 *
 * returns:
 *   TRUE   user wants to exit
 *   FALSE   doesn't want to exit
 *
 ***************************************************************************/

BOOL PUBLIC QueryExit(HWND hwnd)
{
   char buf[MAXSTR];
   BOOL res;
   HWND lHwnd;

   // user press exit (implies aborted setup)
   //
   // first time setup, user is told that windows is not
   // setup and given choice to continue

   EnableExit(FALSE);

   if ( hwnd )
      lHwnd = hwnd;
   else
      lHwnd = GetActiveWindow();

	if ( fExit & EF_NOEXIT )
		return ( fDialog( DLG_BADDOSEXIT, lHwnd, wsBadDosExitDlg ) );
	else
	{
	   res = MessageBox(lHwnd, 
            wsLoadSz(IDS_EXITNOTSETUP, NULL, 0),
            wsLoadSz(IDS_EXITCAP, buf, sizeof(buf)), 
            (MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2 | MB_SYSTEMMODAL))
            == IDYES;
	}

   EnableExit(TRUE);

   return res;
}


/*----------------------------------------------------------------------------*\
|   wsLoadSz()                                                                 |
|                                                                              |
|   Description:                                                               |
|       Load a string from our resource file                                   |
|                                  |
|       ids     Id of string to load                                           |
|       pch     buffer to place string, if NULL string will be placed in a     |
|               global buf                                                     |
|                                  |
|   Returns:                                                                   |
|       near pointer to loaded string                                          |
|                                                                              |
\*----------------------------------------------------------------------------*/
PSTR PUBLIC wsLoadSz(int ids, PSTR pch, int iBufLen)
{
   if (pch == NULL)
      {
      pch = gpszLoadBuf;
      LoadString(hInstWS,ids,pch,MAX_RES);
      }
   else
      LoadString(hInstWS,ids,pch,iBufLen);

   return pch;
}

void PUBLIC EnableExit(BOOL bEnable)
{
   static int iCount = 1;      // start out enabled

   if (bEnable)
      {
      if (iCount < 1)
         iCount++;
      }
   else
      iCount--;
}


/* void PUBLIC wsDlgInit(HWND hDlg, WORD wWorkFlags);
 *
 * Function preforms various common dialog init duties, these include:
 *
 * Centering the dialog.
 * Removing the Close menu.
 * Flushing the keyboard queue.
 *
 * EMTRY: HWND hDlg - Handle to dialog window were initing.
 *
 *        WORD wWorkFlags - 16 bits used to identify optional work needed
 *                          for a particular dialog init.
 *
 * EXIT: None.
 *
 */
void PUBLIC wsDlgInit(HWND hDlg, WORD wWorkFlags)
{
    RECT   rc;
    MSG    msg;
    HANDLE hMenu;
    /*
     *   Center the dialog.
     */
    GetWindowRect(hDlg,&rc);
    SetWindowPos(hDlg,NULL,
        (GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2,
        (GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 3,
        0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
    /*
     *   Remove Close menu if were asked to.
     */
    if ( wWorkFlags & DLGINIT_REMOVE_CLOSE_MENU ) {
       hMenu = GetSystemMenu(hDlg,FALSE);
       if ( hMenu ) {
          DeleteMenu(hMenu,SC_CLOSE,MF_BYCOMMAND);
          DrawMenuBar(hDlg);
      }
   }
   // Perform "flush" keyboard operation
   // We retrieve and delete all keyboard messages placed in
   // our application queue after calling CreateDialog. Doing so
   // removes "strange" actions for impatient user, who pressed keys
   // during creation of dialog.

   while (PeekMessage((LPMSG)&msg, NULL, WM_KEYFIRST, WM_MOUSELAST,
                      PM_NOYIELD|PM_REMOVE));

}

/*----------------------------------------------------------------------------*\
|   wsYield()                                                                  |
|                                                                              |
|   Description:                                                               |
|       Handle any messages in our queue, return when the queue is empty.      |
|                                                                              |
|   Returns:                                                                   |
|       FALSE if a WM_QUIT message was encountered, TRUE otherwise             |
|
|
|  PAK               6/20/91     Added hwnd parameter to allow call to
|                                IsDialogMessage in order to process
|                                key messages such as 'Enter', 'Esc', et al.,
|                                when such processing is required.  E.g.,
|                                when the Progress Dialog has a Cancel
|                                Button.
|
\*----------------------------------------------------------------------------*/
BOOL PUBLIC wsYield(HWND hwnd)
{
   MSG     msg;

	while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
	{
//		if ( msg.message == WM_KEYDOWN && msg.wParam == VK_F3 )
//			PostMessage(hwndWS,WM_COMMAND,ID_EXITSETUP,(LONG)hwnd);

      if ( !hwnd || !IsDialogMessage(hwnd, &msg) ) 
		{
         TranslateMessage(&msg);
         DispatchMessage(&msg);
      }
   }
   return TRUE;
}

void PUBLIC AppQuit()
{
    /*
     * end the windows session, if are the boot shell
     */
#ifdef DEBUG
   char         szTmp[100];

   wsprintf(szTmp,"DOSIIGUI Goodbye, iWillReboot = %i",iWillReboot);
   FatalAppExit(0,szTmp);
#endif

   if ( iWillReboot)
      PostMessage(lpInstall->wHwndWinSetup,UM_CHILD_TERMINATED,EW_REBOOTSYSTEM,0L);
	else
      PostMessage(lpInstall->wHwndWinSetup,UM_CHILD_TERMINATED,0,0L);

   DosExit(0);   // dossetup goes bye bye via Int 21h/4Ch
}

char	cDisk;
LPSTR	szEdit;

/*----------------------------------------------------------------------------*\
|                                                                              |
| wsCopyError()                                                                |
|                                                                              |
|   Handles errors, as the result of copying files.                            |
|                                                                              |
|   this may include net contention errors, in witch case the user must	       |
|   retry the operation.						       |
|                                                                              |
\*----------------------------------------------------------------------------*/
WORD PUBLIC wsCopyError(int n, LPSTR sz)
{
	char buf[200];
   char file[MAXSTR];
   int  res;
	LPSTR lpMessageText;


   lstrcpy(file, sz);		// in case our DS moves durring wsLoadSz()

	if (!wsLoadSz(IDS_ERROR + n, buf, 200)) 
	{
   	// error string doesn't exist.  if it is a net error use
		// net string, if not that use generic error string

    	if (n > ERROR_SHARE)
			wsLoadSz(IDS_ERROR + ERROR_SHARE, buf, 200);
		else
	   	wsprintf(buf, wsLoadSz(IDS_ERROR,NULL, NULL), n);
   }

   lstrcat(buf,"\n");

   // check for the out of disk space case

   lstrcat(buf, file);		// add the file name

   lpMessageText = (LPSTR) buf;
   res = fDialogWithlParam(DLG_COPYERROR, GetActiveWindow(),
                           wsErrorDlg, (DWORD)lpMessageText);
   return res;
}
/*----------------------------------------------------------------------------*\
|                                                                              |
| wsInsertDisk()                                                               |
|                                                                              |
|   Handles errors, as the result of copying files.                            |
|                                                                              |
\*----------------------------------------------------------------------------*/
WORD PUBLIC wsInsertDisk(LPSTR szSrcPath)
{

   DISK disk;

   disk.lpszPath = szSrcPath;
   disk.cDisk = (BYTE)gFiles->DiskNumber;

   szEdit = szSrcPath;

   return (WORD)fDialogWithlParam(DLG_EXPRESSINSERTDISK, GetActiveWindow(),
                                  wsDiskDlg, MAKELONG(&disk,0));
}

/*----------------------------------------------------------------------------*\
|   wsDiskDlg( hDlg, uiMessage, wParam, lParam )                               |
|                                                                              |
|   Arguments:                                                                 |
|       hDlg            window handle of about dialog window                   |
|       uiMessage       message number                                         |
|       wParam          message-dependent                                      |
|       lParam          message-dependent                                      |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if message has been processed, else FALSE                         |
|                                                                              |
\*----------------------------------------------------------------------------*/

BOOL FAR PASCAL wsDiskDlg(HWND hDlg, unsigned uiMessage, WORD wParam, long lParam)
{

    switch (uiMessage)
    {
		case WM_COMMAND:
	   	switch (wParam)
	    	{
				case ID_OK:
            	EndDialog(hDlg, FC_RETRY);
		    		break;

				case ID_CANCEL:

					//BUGBUG EndDialog(hDlg, fFirstTime ? FC_IGNORE : FC_ABORT);
		    		EndDialog(hDlg, FC_IGNORE);
		    		break;
	    	}
	    	return TRUE;

		case WM_INITDIALOG:
	   {
			PDISK pdisk;
         char szTmp[MAX_INF_LINE_LEN];
			char szTmp2[MAX_INF_LINE_LEN];
			char ach[2];

         EnableMenuItem(GetSystemMenu(hDlg, FALSE), SC_CLOSE,
                        MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);

         pdisk = (PDISK)LOWORD(lParam);

			if ( pdisk->cDisk == NOT_REMOVEABLE )
				strcpy (szTmp2, GetDistribPrompt(GetRealSrcDisk( gFiles->Name.Source, NOT_REMOVEABLE )));
			else
				strcpy(szTmp2,GetDistribPrompt(pdisk->cDisk));

         SetDlgItemText(hDlg, ID_STATUS0, szTmp2);

//            ach[0] = (char)UPCASE(*szDiskPath);
	  		ach[0] = vInfo.chSource;
			ach[1] = 0;
         wsLoadSz(IDS_INTO_DRIVE, szTmp, sizeof(szTmp));
         wsprintf(szTmp2, szTmp, (LPSTR)ach);
         SetDlgItemText(hDlg, ID_STATUS1, szTmp2);

         wsDlgInit(hDlg, DLGINIT_REMOVE_CLOSE_MENU);
         MessageBeep(0);
         return TRUE;

	    }
    }
    return FALSE;
}

/*----------------------------------------------------------------------------*\
|   wsErrorDlg( hDlg, uiMessage, wParam, lParam )                |
|                                                                              |
|   Arguments:                                                                 |
|       hDlg            window handle of about dialog window                   |
|       uiMessage       message number                                         |
|       wParam          message-dependent                                      |
|       lParam          message-dependent                                      |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if message has been processed, else FALSE                         |
|                                                                              |
\*----------------------------------------------------------------------------*/
BOOL FAR PASCAL wsErrorDlg(HWND hDlg, unsigned uiMessage, WORD wParam, long lParam)
{
	extern int CreatingRecovery;

   switch (uiMessage)
   {
      case WM_SYSCOMMAND:    // suppress taskman
         if(wParam == SC_TASKLIST)
            return TRUE;
         break;

      case WM_COMMAND:
         switch (wParam)
         {
            case ID_RETRY:
               EndDialog(hDlg, FC_RETRY);
               break;

            case ID_IGNORE:
               EndDialog(hDlg, FC_IGNORE);
               break;

            default:
               return(FALSE);
         }
         return TRUE;
         break;

      case WM_INITDIALOG:
         SetDlgItemText(hDlg, ID_STATUS1, (LPSTR) lParam);

         EnableMenuItem(GetSystemMenu(hDlg, FALSE), SC_CLOSE,
                        MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);
			if ( CreatingRecovery )
				EnableWindow( GetDlgItem(hDlg, ID_IGNORE), FALSE );
         wsDlgInit(hDlg, DLGINIT_REMOVE_CLOSE_MENU);
         MessageBeep(0);
         return TRUE;
         break;

      }

   return(FALSE);
}

/*----------------------------------------------------------------------------*\
|   define the call back function used by the FileCopy() function.	       |
|                                                                              |
\*----------------------------------------------------------------------------*/

WORD FAR PASCAL wsCopyStatus(int msg, int n, LPSTR szFile)
{
	extern int CreatingRecovery;
	WORD res;
//	char buf[80];

   switch (msg)
   {
	case COPY_INSERTDISK:
		if ( CreatingRecovery )
		{
			InitUninstallDisk(iUninstallDiskNum);
			return FC_RETRY;
		}
		else
		{
			if ( gFiles->DiskNumber == NOT_REMOVEABLE )
				return wsInsertDisk(szFile);

			InsertDisk(gFiles->DiskNumber);
			return FC_RETRY;
		}
	case COPY_ERROR:

      if ( n == ERROR_WRITE && CreatingRecovery && iUninstallDiskNum == 0 ) {
         /*
          *  For this case, we must prepare another uninstall disk. This
          *  may happen when folks are using 360kb or 720kb uninstall disks.
          */

          /* Need to add disk space check here to assure the disk is indeed full */

			InitUninstallDisk(++iUninstallDiskNum);
         return FC_RETRY;
      }
      res = wsCopyError(n,szFile);
		if ( res == FC_RETRY )
			if ( CreatingRecovery )
				InitUninstallDisk(iUninstallDiskNum);
			else
				InsertDisk(gFiles->DiskNumber);
		
		return res;

	case COPY_QUERYCOPY:

	    // special case hack for .386 files built into win386.exe

//	    infParseField(szFile, 1, buf);

//	    if (*FileName(buf) == '*')
//	    	return FALSE;		// don't copy

	    return TRUE;

	case COPY_END:
	case COPY_START:
	    SetErrorMode(msg == COPY_START);	// don't crit error on us
	    break;

   case COPY_STATUS:
//		if (n == 0)
//		{
		  	// if their is a title update it.  this allows shared titles
//			if ( infParseField( szFile, 2, buf ) )
//				ProPrintf( ID_STATUS2, wsLoadSz( IDS_COPYING,NULL,NULL ), (LPSTR)buf );
//		}
		if (n == 100)
			ProDeltaPos(1);
		wsYield(hwndParent);
		break;

	}	/* End of switch */
	return FC_IGNORE;
}

/*----------------------------------------------------------------------------*\
|   wsExitDlg( hDlg, uiMessage, wParam, lParam )                               |
|                                                                              |
|   Arguments:                                                                 |
|       hDlg            window handle of about dialog window                   |
|       uiMessage       message number                                         |
|       wParam          message-dependent                                      |
|       lParam          message-dependent                                      |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if message has been processed, else FALSE                         |
|                                                                              |
\*----------------------------------------------------------------------------*/
BOOL EXPORT wsExitDlg(HWND hDlg, unsigned uiMessage, WORD wParam, LONG lParam )
{
   #define WEC_RESTART 0x42

	switch (uiMessage)
	{
		case WM_COMMAND:
			switch (wParam)
			{
				case ID_REBOOT:
					ProClose();
               iWillReboot = TRUE;  // Assure reboot.
               AppQuit();

					break;

				case ID_CANCEL:
					#ifdef DEBUG
													// allow abort in debug release
//						if ( !fFirstTime )
							EndDialog(hDlg,FALSE);
					#endif
					break;
		
				default:
				    return FALSE;
			}
			return TRUE;

		case WM_INITDIALOG:
			wsDlgInit( hDlg, DLGINIT_REMOVE_CLOSE_MENU );
			return TRUE;
	}
	return FALSE;
}




#define ISDIGIT(c)  ((c) >= '0' && (c) <= '9')

int PUBLIC atoi(PSTR sz)
{
	int n = 0;

	while (ISDIGIT(*sz))
   {
		n *= 10;
		n += *sz - '0';
		sz++;
   }
   return n;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\sbutton.c ===
/*****************************************************************************
*                                                                            *
*  SBUTTON.C                                                                 *
*                                                                            *
*  Program Description: Implements "3-D" buttons                             *
*                                                                            *
******************************************************************************
*                                                                            *
*  Revision History:  Created by Todd Laney, Munged 3/27/89 by Robert Bunney *
*		      7/25/89  - revised by Chris Guzak for transparent	     *
*				 color bitmaps.				     *
*                     7/26/89  - revised by Todd Laney to handle multi-res   *
*                                bitmaps. 				     *
*                                windows 3 support                           *
*                                                                            *
*****************************************************************************/

#define NOCOMM
#include <windows.h>
#include "sbutton.h"

//
//  if WIN2 is defined the code will work in windows 2.x and windows 3.0
//  otherwise windows 3.0 is required
//

/*****************************************************************************
*                                                                            *
*                               Defines                                      *
*                                                                            *
*****************************************************************************/

#define PRIV static

#define rgbWhite   RGB(255,255,255)
#define rgbBlack   RGB(0,0,0)
#define ISDIGIT(c)  ((c) >= '0' && (c) <= '9')
#define BEVEL   2
#define FRAME   1

#define GWW_STATE   0
#define GWW_HBM     2
#define GWW_FLAGS   4
#define GWW_CHECK   6
#define GETSTYLE(hwnd) LOWORD(GetWindowLong(hwnd,GWL_STYLE))
#define GETSTATE(hwnd) GetWindowWord(hwnd,GWW_STATE)
#define GETFLAGS(hwnd) GetWindowWord(hwnd,GWW_FLAGS)
#define GETCHECK(hwnd) GetWindowWord(hwnd,GWW_CHECK)
#define GETHBM(hwnd)   GetWindowWord(hwnd,GWW_HBM)
#define lpCreate ((LPCREATESTRUCT)lParam)

#define DPSoa    0x00A803A9L
#define DSPDxax  0x00E20746L

#define EraseButton(hwnd,hdc,prc) ExtTextOut(hdc,0,0,ETO_OPAQUE,prc,NULL,0,NULL)
#define NearestColor(hdc,rgb) (GetNearestColor(hdc,rgb) & 0x00FFFFFFL)

#ifdef WIN2
    extern int far cdecl fsprintf(LPSTR, LPSTR, ...);
    #define SPRINTF fsprintf
#else
    #define SPRINTF wsprintf
#endif

#ifndef COLOR_BTNFACE
    #define COLOR_BTNFACE           15
    #define COLOR_BTNSHADOW         16
    #define COLOR_BTNTEXT           18
#endif

/*****************************************************************************
*                                                                            *
*                               Prototypes                                   *
*                                                                            *
*****************************************************************************/

PRIV int     NEAR PASCAL atoi(PSTR);
PRIV DWORD   NEAR PASCAL ReadRGB(PSTR szApp,PSTR szItem,DWORD rgb);
PRIV VOID    NEAR PASCAL DrawGrayButton (HWND, HDC, LPRECT, WORD, BOOL);
PRIV VOID    NEAR PASCAL DrawButtonFace (HWND, HDC, PRECT, WORD);
PRIV BOOL    NEAR PASCAL PaintButton    (HWND, HDC);
PRIV VOID    NEAR PASCAL NotifyParent   (HWND);
PRIV VOID    NEAR PASCAL PatB           (HDC, int, int, int, int, DWORD);
PRIV HBITMAP NEAR PASCAL LoadBitmapResource(HANDLE hInst, LPSTR lpName);
PRIV VOID    NEAR PASCAL BitmapColorTranslate(HDC hdcBits, BITMAP* pbm, DWORD rgb);

/*****************************************************************************
*                                                                            *
*                               Variabls                                     *
*                                                                            *
*****************************************************************************/

HBRUSH hbrFocus = NULL;                // focus for text

DWORD  rgbButtonFocus;
DWORD  rgbButtonFace;
DWORD  rgbButtonText;
DWORD  rgbButtonShadow;

PRIV char szColor[]  = "Colors";          // Name of color section
PRIV char szButton[] = "sbutton";
PRIV char szText[]   = "stext";

/*---------------------------------------------------------------------------*\
|   ControlInit( hPrev,hInst )                                                 |
|                                                                              |
|   Description:                                                               |
|       This is called when the application is first loaded into               |
|       memory.  It performs all initialization.                               |
|                                                                              |
|   Arguments:                                                                 |
|       hPrev      instance handle of previous instance                        |
|       hInst      instance handle of current instance                         |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if successful, FALSE if not                                       |
|                                                                              |
\*----------------------------------------------------------------------------*/

BOOL FAR PASCAL ControlInit (hPrev,hInst)
    HANDLE hPrev;
    HANDLE hInst;
{
    WNDCLASS    cls;
    HDC         hdc;


    hdc = GetDC(NULL);

#ifdef WIN2
    if (LOBYTE(GetVersion()) >= 3)
    {
        rgbButtonFace   = GetSysColor(COLOR_BTNFACE);
        rgbButtonShadow = GetSysColor(COLOR_BTNSHADOW);
        rgbButtonText   = GetSysColor(COLOR_BTNTEXT);
        rgbButtonFocus  = rgbWhite;
    }
    else
    {
        rgbButtonFace   = ReadRGB(szColor,"ButtonFace",  RGB(192,192,192));
        rgbButtonShadow = ReadRGB(szColor,"ButtonShadow",RGB(64,64,64));
        rgbButtonText   = ReadRGB(szColor,"ButtonText",  rgbBlack);
        rgbButtonFocus  = ReadRGB(szColor,"ButtonFocus", rgbWhite);
    }
#else
    rgbButtonFace   = GetSysColor(COLOR_BTNFACE);
    rgbButtonShadow = GetSysColor(COLOR_BTNSHADOW);
    rgbButtonText   = GetSysColor(COLOR_BTNTEXT);
    rgbButtonFocus  = rgbWhite;  // ??
#endif

    rgbButtonFace   = NearestColor(hdc,rgbButtonFace);
    rgbButtonShadow = NearestColor(hdc,rgbButtonShadow);
    rgbButtonText   = NearestColor(hdc,rgbButtonText);
    rgbButtonFocus  = NearestColor(hdc,rgbButtonFocus);

    if (rgbButtonFocus == rgbButtonFace)
        rgbButtonFocus = rgbButtonText;

    ReleaseDC(NULL,hdc);

    hbrFocus = CreateSolidBrush(rgbButtonFocus);

    if (!hPrev) {
        cls.hCursor        = LoadCursor(NULL,IDC_ARROW);
        cls.hIcon          = NULL;
        cls.lpszMenuName   = NULL;
        cls.lpszClassName  = (LPSTR)szButton;
        cls.hbrBackground  = (HBRUSH)COLOR_WINDOW+1;
        cls.hInstance      = hInst;
        cls.style          = CS_HREDRAW | CS_VREDRAW;
        cls.lpfnWndProc    = fnButton;
        cls.cbClsExtra     = 0;
        cls.cbWndExtra     = 4 * sizeof(WORD);
        RegisterClass(&cls);

        cls.hCursor        = LoadCursor(NULL,IDC_ARROW);
        cls.hIcon          = NULL;
        cls.lpszMenuName   = NULL;
        cls.lpszClassName  = (LPSTR)szText;
        cls.hbrBackground  = (HBRUSH)COLOR_WINDOW+1;
        cls.hInstance      = hInst;
        cls.style          = CS_HREDRAW | CS_VREDRAW;
        cls.lpfnWndProc    = fnText;
        cls.cbClsExtra     = 0;
        cls.cbWndExtra     = 0;
        RegisterClass(&cls);
    }

    return TRUE;
}


void FAR PASCAL ControlTerm()
{

	if (hbrFocus)
		DeleteObject(hbrFocus);

}


/*----------------------------------------------------------------------------*\
|                                                                              |
| Custom push-button                                                           |
|                                                                              |
\*----------------------------------------------------------------------------*/

PRIV BOOL NEAR PASCAL PaintButton(HWND hwnd, HDC hdc)
{
    WORD   style;
    RECT   rc;
    BOOL   f;

    HDC     hdcMem;
    HBITMAP hbmMem,hbmT;

    GetClientRect(hwnd,&rc);

    if (!RectVisible(hdc,&rc))
        return TRUE;

    style  = GETSTYLE(hwnd) | (GETFLAGS(hwnd) & 0xFF00);
    f      = GETSTATE(hwnd);

    hdcMem = CreateCompatibleDC(hdc);
    hbmMem = CreateCompatibleBitmap(hdc,rc.right,rc.bottom);

    switch (LOBYTE(style))
    {
        case BS_PUSHBUTTON:
        case BS_DEFPUSHBUTTON:
            if (hdcMem && hbmMem)
            {
                hbmT = SelectObject(hdcMem,hbmMem);
                DrawGrayButton(hwnd, hdcMem, &rc, style, f);

                BitBlt(hdc,0,0,rc.right,rc.bottom,hdcMem,0,0,SRCCOPY);
                SelectObject(hdcMem,hbmT);
            }
            else
            {
                DrawGrayButton(hwnd, hdc, &rc, style, f);
            }
            break;
    }

    if (hbmMem)
        DeleteObject(hbmMem);
    if (hdcMem)
        DeleteDC(hdcMem);
    return TRUE;
}


/*******************
**
** Name:      ButtonState
**
** Purpose:   Compares the passed state (f) with the current state.  If
**            they differ, the button is invalidated and TRUE is
**            is returned.
**
** Arguments: hwnd - window handle of the button
**            f    - state to set
**
** Returns:   TRUE iff the current state is different than f
**
*******************/

BOOL ButtonState(HWND hwnd, BOOL f)
{
    WORD state;

    state = GetWindowWord(hwnd,GWW_STATE);

    if (state != (unsigned)f)
    {
        SetWindowWord(hwnd,GWW_STATE,f);
        InvalidateRect(hwnd,NULL,TRUE);
        UpdateWindow(hwnd);
        return TRUE;
    }
    return FALSE;
}


/*******************
**
** Name:      fnButton
**
** Purpose:   Window proc for buttons
**
** Arguments: Standard window proc
**
*******************/

LONG FAR PASCAL fnButton(hwnd, message, wParam, lParam)
    HWND hwnd;
    unsigned message;
    WORD wParam;
    LONG lParam;
{
    HANDLE      hbm;
    PAINTSTRUCT ps;
    RECT        rc;
    LONG        l;

    switch (message)
    {
        case WM_CREATE:
            SetWindowWord(hwnd,GWW_HBM,NULL);
            SetWindowWord(hwnd,GWW_STATE,0);
            SetWindowWord(hwnd,GWW_FLAGS,(WORD)lpCreate->style & 0xFF00);
            SetWindowText(hwnd,lpCreate->lpszName);
            SetWindowLong(hwnd,GWL_STYLE,lpCreate->style & 0xFFFF00FF);
            break;

        case WM_LBUTTONDOWN:
            if (!IsWindowEnabled(hwnd))
                return 0L;

            if (GetCapture() != hwnd)  /* ignore multiple DOWN's */
            {
                ButtonState(hwnd,TRUE);
                SetCapture(hwnd);
                if (!(GETFLAGS(hwnd) & BS_NOFOCUS))
                    SetFocus(hwnd);
            }
            return 0L;

        case WM_MOUSEMOVE:
            if (GetCapture() == hwnd)
            {
                GetClientRect(hwnd,&rc);
                ButtonState(hwnd,PtInRect(&rc,MAKEPOINT(lParam)));
            }
            return 0L;

        case WM_LBUTTONUP:
            if (GetCapture() == hwnd)
            {
                ReleaseCapture();
                if (ButtonState(hwnd,FALSE))
                    NotifyParent(hwnd);
            }
            return 0L;

        case WM_DESTROY:
            if (hbm = GETHBM(hwnd))
                DeleteObject(hbm);
            break;

        case WM_SETTEXT:
            if (hbm = GETHBM(hwnd))
                DeleteObject(hbm);

            if (*(LPSTR)lParam == '#')
            {
                hbm = LoadBitmapResource(GetWindowWord(hwnd,GWW_HINSTANCE),(LPSTR)lParam+1);
            }
            else
            {
                hbm = NULL;
            }
            SetWindowWord(hwnd,GWW_HBM,hbm);
            InvalidateRect(hwnd,NULL,TRUE);
            break;

        case WM_ENABLE:
        case WM_KILLFOCUS:
        case WM_SETFOCUS:
            InvalidateRect(hwnd,NULL,TRUE);
            break;

        case WM_KEYDOWN:
            if (wParam == VK_SPACE && IsWindowEnabled(hwnd))
                ButtonState(hwnd,TRUE);
            break;

        case WM_KEYUP:
        case WM_SYSKEYUP:
            if (wParam == VK_SPACE && IsWindowEnabled(hwnd))
            {
                if (ButtonState(hwnd,FALSE))
                    NotifyParent(hwnd);
            }
            break;

        case BM_GETSTATE:
            return((LONG)GETSTATE(hwnd));

        case BM_SETSTATE:
            if (ButtonState(hwnd,wParam) && !wParam)
                NotifyParent(hwnd);
            break;

        case BM_GETCHECK:
            return((LONG)GETCHECK(hwnd));

        case BM_SETCHECK:
            SetWindowWord(hwnd,GWW_CHECK,wParam);
            break;

        case BM_SETSTYLE:
            l = GetWindowLong(hwnd,GWL_STYLE);
            SetWindowLong(hwnd,GWL_STYLE,MAKELONG(wParam,HIWORD(l)));
            if (lParam)
                InvalidateRect(hwnd, NULL, TRUE);
            break;

        case WM_GETDLGCODE:
            switch (LOBYTE(GETSTYLE(hwnd)))
            {
                case BS_DEFPUSHBUTTON:
                    wParam = DLGC_DEFPUSHBUTTON;
                    break;

                case BS_PUSHBUTTON:
                    wParam = DLGC_UNDEFPUSHBUTTON;
                    break;

                default:
                    wParam = 0;
            }

            return((LONG)(wParam | DLGC_BUTTON));

        case WM_ERASEBKGND:
            return 0L;

        case WM_PAINT:
            BeginPaint(hwnd, &ps);
            PaintButton(hwnd,ps.hdc);
            EndPaint(hwnd, &ps);
            return 0L;
    }
    return DefWindowProc(hwnd, message, wParam, lParam);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  DrawGrayButton() -                                                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/

PRIV VOID NEAR PASCAL DrawGrayButton(hwnd, hdc, lprc, style, fInvert)
    HWND        hwnd;
    HDC         hdc;
    RECT FAR    *lprc;
    WORD        style;
    BOOL        fInvert;
{
    RECT        rc;
    int         dx,dy;
    HBRUSH      hbr;
    int         i;
    int         iFrame;

    SetBkColor(hdc,GetSysColor(COLOR_WINDOW));

    hbr = (HBRUSH)SendMessage(GetParent(hwnd), WM_CTLCOLOR, hdc, MAKELONG(hwnd, CTLCOLOR_BTN));
    FillRect(hdc, lprc, hbr);

    rc = *lprc;
    dx = rc.right  - rc.left;
    dy = rc.bottom - rc.top;

    iFrame = FRAME;

    if (LOBYTE(style) == BS_DEFPUSHBUTTON)
        iFrame *= 2;

    PatB(hdc, rc.left+1, rc.top, dx-2,iFrame,            rgbBlack);
    PatB(hdc, rc.left+1, rc.bottom-iFrame,dx-2,iFrame,   rgbBlack);
    PatB(hdc, rc.left, rc.top+1, iFrame,dy-2,            rgbBlack);
    PatB(hdc, rc.right-iFrame,  rc.top+1, iFrame,dy-2,   rgbBlack);

    InflateRect(&rc,-iFrame,-iFrame);
    dx = rc.right  - rc.left;
    dy = rc.bottom - rc.top;

    SetBkColor(hdc,rgbButtonFace);
    EraseButton(hwnd,hdc,&rc);

    if (fInvert)
    {
        PatB(hdc, rc.left,   rc.top,   1,dy,     rgbButtonShadow);
        PatB(hdc, rc.left,   rc.top,   dx,1,     rgbButtonShadow);
        rc.left += BEVEL*2;
        rc.top  += BEVEL*2;
    }
    else
    {
        for (i=0; i<BEVEL; i++)
        {
            PatB(hdc, rc.left,   rc.top,   1,dy,     rgbWhite);
            PatB(hdc, rc.left,   rc.top,   dx,1,     rgbWhite);
            PatB(hdc, rc.right-1,rc.top+1, 1,dy-1,   rgbButtonShadow);
            PatB(hdc, rc.left+1, rc.bottom-1, dx-1,1,rgbButtonShadow);

            InflateRect(&rc,-1,-1);
            dx -= 2;
            dy -= 2;
        }
    }

    SetBkColor(hdc,rgbButtonFace);

    if (GetFocus() == hwnd)
        SetTextColor(hdc,rgbButtonFocus);
    else
        SetTextColor(hdc,rgbButtonText);

    DrawButtonFace(hwnd,hdc,&rc,style);
}

/*******************
**
** Name:      DrawButtonFace
**
** Purpose:   Responsible for the rendering of the text or bitmap on
**            on a button.
**
** Arguments: hwnd  - window handle of button
**            hdc   - hdc for window
**            prc   - clipping rect
**            sytle - button style (push button or default pushbutton)
**
*******************/


PRIV VOID NEAR PASCAL DrawButtonFace(HWND hwnd, HDC hdc, PRECT prc, WORD style)
{
    RECT        rc;
    HBITMAP     hbm;
    HDC         hdcBits;
    BITMAP      bm;
    BOOL        fMono;

    rc = *prc;

    SaveDC(hdc);
    IntersectClipRect(hdc, prc->left, prc->top, prc->right, prc->bottom);

    if (hbm = GETHBM(hwnd))
    {
        hdcBits = CreateCompatibleDC(hdc);
        SelectObject(hdcBits,hbm);
        GetObject(hbm,sizeof(bm),(LPSTR)&bm);
        fMono = (bm.bmPlanes == 1) && (bm.bmBitsPixel == 1);

        BitmapColorTranslate(hdcBits, &bm, rgbButtonFace);

        if (!(style & BS_STRETCH))
        {
            // now center this thing on the button face
            rc.left += (rc.right - rc.left - bm.bmWidth) / 2;
            rc.top += (rc.bottom - rc.top - bm.bmHeight) / 2;
            rc.right  = rc.left + bm.bmWidth;
            rc.bottom = rc.top + bm.bmHeight;
        }

        SetStretchBltMode (hdc,fMono ? BLACKONWHITE : COLORONCOLOR);

        StretchBlt(hdc,rc.left,rc.top,rc.right  - rc.left,rc.bottom - rc.top,
                   hdcBits,0,0,bm.bmWidth,bm.bmHeight, SRCCOPY);

        DeleteDC(hdcBits);
    }

#if 0
	// don't support text only sbuttons

    else
    {
        GetWindowText(hwnd,sz,80);
        len = lstrlen(sz);

        dw = GetTextExtent(hdc,sz,len);
        x =  (rc.right  + rc.left - LOWORD(dw)) / 2;
        y =  (rc.bottom + rc.top  - HIWORD(dw)) / 2;

        rc.left   = x;
        rc.top    = y;
        rc.right  = x + LOWORD(dw);
        rc.bottom = y + HIWORD(dw);

        if (IsWindowEnabled(hwnd))
        {
            DrawText(hdc,sz,len,&rc,DT_LEFT);

            if (rgbButtonFocus == rgbButtonText && GetFocus() == hwnd)
                FrameRect(hdc,&rc,hbrGray);

            if (LOBYTE(style) == BS_DEFPUSHBUTTON)
            {
                rc.left++;
                SetBkMode(hdc,TRANSPARENT);
                DrawText(hdc,sz,len,&rc,DT_LEFT);
            }
        }
        else
        {
            GrayString(hdc,NULL,NULL,(LONG)(LPSTR)sz,len,
                rc.left,rc.top,0,0);
        }
    }
#endif

    RestoreDC(hdc, -1);
}

/*
 *  using the first pixel as the "transparent" color, make all pixels
 *  in the hdc that are equal to the "transparent" color the passed
 *  color.
 */
PRIV VOID NEAR PASCAL BitmapColorTranslate(HDC hdcBits, BITMAP* pbm, DWORD rgb)
{
    HDC     hdcMask;
    HBITMAP hbmMask, hbmT;
    HBRUSH  hbrT;
    BOOL    fMono;

    /*
     * is the bitmap mono, or the first pixel is already equal to the
     * passed color?  if so we have nothing to do.
     */

    fMono = pbm->bmPlanes == 1 && pbm->bmBitsPixel == 1;
    if (fMono || GetPixel(hdcBits, 0, 0) == rgb)
        return;

    // create a mask bitmap and associated DC

    if (hbmMask = CreateBitmap(pbm->bmWidth, pbm->bmHeight, 1, 1, NULL))
    {
        hdcMask = CreateCompatibleDC(hdcBits);

        // select the mask bitmap into the mono DC

        hbmT = SelectObject(hdcMask, hbmMask);

        // create the brush and select it into the bits DC

        hbrT = SelectObject(hdcBits, CreateSolidBrush(rgb));

        // do a color to mono bitblt to build the mask
        // generate 1's where the source is equal to the background is

        SetBkColor(hdcBits, GetPixel(hdcBits, 0, 0));
        BitBlt(hdcMask, 0, 0, pbm->bmWidth, pbm->bmHeight, hdcBits, 0, 0, SRCCOPY);

        // where the mask is 1 lay down the brush, where it is 0 leave the desitnation

        SetBkColor(hdcBits, rgbWhite);
        SetTextColor(hdcBits, rgbBlack);
        BitBlt(hdcBits, 0, 0, pbm->bmWidth, pbm->bmHeight, hdcMask, 0, 0, DSPDxax);

        DeleteObject(SelectObject(hdcBits, hbrT));
        DeleteObject(SelectObject(hdcMask, hbmT));

        DeleteDC(hdcMask);
    }
}

#ifdef WIN2

/*******************
**
** Name:      atoi()
**
** Purpose:   Ascii to integer translation
**
** Arguments: sz - string to translate
**
** Returns:   Integer value represented by string, or 0 if an error occurred.
**
*******************/

PRIV int NEAR PASCAL atoi(PSTR sz)
{
    int n = 0;

    while (ISDIGIT(*sz))
    {
        n *= 10;
        n += *sz - '0';
        sz++;
    }
    return n;
}

/*******************
**
** Name:      ReadRgb()
**
** Purpose:   Read a RGB color from WIN.INI
**
** Arguments: szApp     - Section name in WIN.INI
**            szItem    - Key name in WIN.INI
**            rgb       - default value
**
** Returns:   DWORD rgb
**
*******************/

PRIV DWORD NEAR PASCAL ReadRGB(PSTR szApp,PSTR szItem,DWORD rgb)
{
    char buf[80];
    char *pch;
    WORD r,g,b;

    GetProfileString(szApp, szItem, "", buf,sizeof(buf));

    if (*buf)
    {
        pch = buf;
        r = atoi(pch);
        while (*pch && *pch != ' ') pch++;
        while (*pch && *pch == ' ') pch++;
        g = atoi(pch);
        while (*pch && *pch != ' ') pch++;
        while (*pch && *pch == ' ') pch++;
        b = atoi(pch);

        return RGB(r,g,b);
    }
    else
    {
        return rgb;
    }
}

#endif

/*******************
**
** Name:      NotifyParent
**
*******************/

PRIV VOID NEAR PASCAL NotifyParent(HWND hwnd)
{
    PostMessage(GetParent(hwnd),WM_COMMAND,GetWindowWord(hwnd,GWW_ID),MAKELONG(hwnd,BN_CLICKED));
}

/*******************
**
** Name:      PatB
**
** Fast Solid color PatBlt() using ExtTextOut()
**
*******************/

PRIV VOID NEAR PASCAL PatB(HDC hdc,int x,int y,int dx,int dy, DWORD rgb)
{
    RECT    rc;

    SetBkColor(hdc,rgb);
    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  PRIV text control that uses ExtTextOut() IE no flicker!                */
/*                                                                           */
/*---------------------------------------------------------------------------*/

LONG FAR PASCAL fnText( hwnd, msg, wParam, lParam )
    HWND hwnd;
    unsigned msg;
    WORD wParam;
    LONG lParam;
{
    PAINTSTRUCT ps;
    RECT rc;
    char        ach[128];
    int  len;

    switch (msg)
    {
    case WM_SETTEXT:
        DefWindowProc(hwnd, msg, wParam, lParam);
        InvalidateRect(hwnd,NULL,FALSE);
        UpdateWindow(hwnd);
        return 0L;

    case WM_ERASEBKGND:
        return 0L;

    case WM_PAINT:
        BeginPaint(hwnd, &ps);
        GetClientRect(hwnd,&rc);

        len = GetWindowText(hwnd,ach,sizeof(ach));
        SetBkColor(ps.hdc,GetSysColor(COLOR_WINDOW));
        SetTextColor(ps.hdc,GetSysColor(COLOR_WINDOWTEXT));
        ExtTextOut(ps.hdc,0,0,ETO_OPAQUE,&rc,ach,len,NULL);

        EndPaint(hwnd, &ps);
        return 0L;
    }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

/*
 *  LoadBitmapResource()
 *
 *  load a bitmap from a resource file that is specific to a device.
 *
 */
PRIV HBITMAP NEAR PASCAL LoadBitmapResource(HANDLE hInst, LPSTR lpName)
{
    char    szName[80];
    HBITMAP hbm;
    WORD    nColors;
    WORD    dxScreen;
    WORD    dyScreen;
    HDC     hdc;

    hdc = GetDC(NULL);

    nColors  = GetDeviceCaps(hdc,NUMCOLORS);
    dxScreen = GetSystemMetrics(SM_CXSCREEN);
    dyScreen = GetSystemMetrics(SM_CYSCREEN);

    ReleaseDC(NULL,hdc);

    /* look for a resource of the form WxHxC */

    SPRINTF(szName, "%ls%dx%dx%d", lpName, dxScreen, dyScreen, nColors);

    hbm = LoadBitmap(hInst,szName);

    /* look for a resource of the form WxH */

    if (!hbm)
    {
        SPRINTF(szName,"%ls%dx%d", lpName, dxScreen, dyScreen);
        hbm = LoadBitmap(hInst,szName);
    }

    /* look for the default resource name */

    if (!hbm)
    {
        hbm = LoadBitmap(hInst,lpName);
    }

    return hbm;
}


#if 0

/*******************
**
** Name:      FindGray
**
** Purpose:   Responsible for finding (if possible) a dark gray
**            on the curent device.
**
** Arguments: rgb   - value for gray
**
** Returns:   RGB value for dark gray
**
*******************/

DWORD NEAR PASCAL FindGray(DWORD rgb)
{
    int r,g,b;
    HDC hdc;

    hdc = GetDC(NULL);

    rgb == NearestColor(hdc,rgb);

    r = GetRValue(rgb);
    g = GetGValue(rgb);
    b = GetBValue(rgb);

    while ((r>0 || g>0 || b>0) && rgb == NearestColor(hdc,RGB(r,g,b)))
    {
        if (r > 0) r -= 63;
        if (g > 0) g -= 63;
        if (b > 0) b -= 63;
    }

    rgb = NearestColor(hdc,RGB(r,g,b));

    ReleaseDC(NULL,hdc);
    return rgb;
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\upginit.c ===
//=========================================================================
// 																								
// UPGINIT.C																					   
// 																								
//		Copyright (c) 1992 - Microsoft Corp.											
//		All rights reserved.																	
//		Microsoft Confidential																
//
//	Contains routines that initiliazes all the info for the upgrade process.
//
//  	Created 01-28-92
//
//=========================================================================

#include <stdio.h>
#include <stdlib.h>
#include <dos.h>
#include <string.h>
#include <memory.h>
#include	<io.h>
#include	<fcntl.h>
#include	<direct.h>


#include <alias.h>
#include <install.h>
#include	<data.h>
#include <disk_io.h>
#include <global.h>
#include	<strlib.h>
#include	<file_io.h>
#include <copy.h>
#include <upgrade.h>
#include <errors.h>
#include "prompts.h"

typedef int BOOL;
#define		_A_FINDALL				(_A_HIDDEN | _A_SYSTEM | _A_RDONLY)
#define		DEVICE					0


INFO 		vInfo;
BOOL 		fMono;
char		szDataPath[ MAX_PATH_LEN ];
char		szTmpDos[ MAX_PATH_LEN ];

char		szWinAuto[ 25 ];				/* "X:\autoexec.xxx"	*/
char		szWinConf[ 25 ];				/* "X:\config.xxx"	*/
char		*szTmpConfigPath;
char		*szTmpAutoPath;
void far *lpInt13Buf;         	/* declared/inited here. Used in b_disk.asm */
void far *lpfnInt13Func;         /* declared/inited here. Used in b_disk.asm */

INSTALL far	*lpInstall = NULL;	/* Address of CUI Dos Setup resident data. */

extern char		*szAutoBat;   /* declared in upgrade.c */
extern char		*szConfSys;   /* declared in upgrade.c */

char far	*DiskChangePtr;
unsigned char	gInstallMode;

extern void fmemcpy( char far *Str1, char far *Str2, UINT Len );
extern void	InitFileStruc	( struct MULT_FILES *FileStruc, int iDisk,
			  					  	  int IsHdUpgrade );
extern void	CreateDeviceLine( char *szLine, char *szDevString, int iType );
extern void	FatalError( int ErrorType );

extern char far *GetInfo(void);


/***************************************************************************/
/*	Function to initialize the DOS part of the DOS/WINDOWS combined setup.	*/
/*																									*/
/*	void InitDosUpgrade( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		FALSE if DosSetup already done (NON-UPGRADE case)  			*/
/*				   TRUE  otherwise.
/*																									*/
/***************************************************************************/

BOOL InitDosUpgrade()
{

	struct DIR			DirEntry;
	struct find_t		FileInfo;

	char far * InfoPtr;

	if ( !(InfoPtr = GetInfo()) )
				FatalError( FATAL_MEMORY_ERROR );

	if ( _fstrcmp(((INSTALL far *)InfoPtr)->szSignature, SIGNATURE) != 0 )
		return FALSE;
	else
		lpInstall = (INSTALL far *) InfoPtr;

	if ( lpInstall->Done.fDosSetup == TRUE )
		return FALSE;

	DiskChangePtr = (char far *)(InfoPtr + sizeof(INSTALL) + sizeof(vInfo));

	gInstallMode = lpInstall->Method;

	fmemcpy( (char far *)&vInfo, 
				(char far *)(InfoPtr + sizeof(INSTALL)),
				sizeof(vInfo) );

	fMono = vInfo.Args.fIsMono ? TRUE : FALSE;

	BuildPath( szDataPath, vInfo.szSource[0], vInfo.szSource + 2,
				  DOS_DATA_FILE );

	InitDosData( szDataPath );		/* Read in and initialize data file */

	LoadOemData( (struct DDR *)&vInfo.ddrRestore );

	SetFileTimeDate( &DirEntry );
																	/*lint  -e740 */
	vInfo.ulTmpSerial = *( (UL *)&DirEntry.Time );	/*lint  +e740 */
	vInfo.ulFinalSerial = vInfo.ulTmpSerial + 1;

//	pchBootBuf = GetMemory( (unsigned)((int)vInfo.uchBootRecs[0][0]) * 512);
	pchBootBuf = GetMemory( (unsigned)((int)vInfo.uchBootRecs[0]) * 512);

	pchMbrBuf = GetMemory( SECTOR_SIZE * 4 );

	pchOldPartRec = GetMemory( SECTOR_SIZE );

	*szAutoBat = *szConfSys = vInfo.chDestin;

   /* Init real-mode Int 13h pointers from vInfo structure:
	 *	
	 *	lpInt13Buf    -> 512 byte buffer.
	 *	lpfnInt13Func -> Function which performs Int 13h. (follows Int 13h buffer)
	 */
	lpInt13Buf    = vInfo.lpfnInt13;
   lpfnInt13Func = (void far *) (((char far *) vInfo.lpfnInt13) + 512);

	if ( _dos_findfirst( szAutoBat, _A_FINDALL, &FileInfo ) == OK )
		vInfo.Flag.fAutoexecBat = TRUE;
	if ( _dos_findfirst( szConfSys, _A_FINDALL, &FileInfo ) == OK )
		vInfo.Flag.fConfigSys = TRUE;


	szTmpConfigPath = vInfo.szTmpConfig;	/* Give windows code access	*/
	szTmpAutoPath = vInfo.szTmpAuto;			/* to these files.				*/

	return TRUE;

}

/***************************************************************************/
/* Function that determines number of DOS files to copy							*/
/*																									*/
/*	int far CopyDosFiles( void )															*/
/*						  																		   */
/* ARGUMENTS: NONE																			*/
/*	RETURNS:		int		-	Number of files to copy									*/
/*																									*/
/***************************************************************************/

int CopyDosFiles( void )
{
	#define			BUF_LEN (sizeof( struct MULT_FILES ) * MAX_PER_DISK)

	char					**apszNames;
	register				iCount;
	register				iDisk;
	struct MULT_FILES *Files;
	struct MULT_FILES *TmpPtr;

	extern int	   XDosCopy;				/* Defined in Windows setup copy.c	*/
	extern char		szDosDesName[];		/* Defined in Windows setup copy.c	*/

	Files = GetMemory( BUF_LEN );
	apszNames = GetMemory( MAX_DOS_FILES * sizeof( char * ) );
	memset( apszNames, 0, MAX_DOS_FILES * sizeof( char * ) );

	XDosCopy = TRUE;

	if ( lpInstall->Flags.fUninstall )
		iDisk = 0;
	else
		iDisk = FIRST_USER_DISK;			/* Skip Uninstall files */

	for ( iCount = 0;							/* Outer loop	*/
			iDisk < (int)vInfo.uchNumDisks;
			iDisk++ )
	{
		memset( Files, 0, BUF_LEN );
		InitFileStruc( Files, iDisk, TRUE );

		for ( TmpPtr = Files;									/* Inner loop	*/
				TmpPtr->Name.Source != NULL;
				TmpPtr++ )
		{	
											/* First see if file is a duplicate	*/
			if ( StrSearch( TmpPtr->Name.Source, apszNames ) != -1 )
				continue;
			apszNames[ iCount++ ] = TmpPtr->Name.Source;	/* Add new name	*/
		}
	}
   /*  Increment the file count appropiatly if we have to upgrade DMDriver
    *  or speedstor drivers. The code below assumes that these drivers are
    *  mutualy exclusive.
    */
   if ( vInfo.Flag.fDMdriver )   // MC 4/13/92 #1
      iCount += 2;               // MC 4/13/92 #1
   if ( vInfo.Flag.fSpeedstor )  // MC 4/13/92 #1
      iCount++;                  // MC 4/13/92 #1

	FreeMemory( apszNames );
	FreeMemory( Files );

	XDosCopy = FALSE;
	return( iCount );
}

/***************************************************************************/
/* Creates a unique file name based on the full pathname passed as an		*/
/* argument to the function by appending an ascii number as an extension.	*/
/* 																								*/
/*																									*/
/*	int CreateUniqueName( szBuf, szFile )												*/
/*																									*/
/*	ARGUMENTS:	szBuf		- Buffer to copy new file name to or NULL				*/
/*					szFile	- Full path and file name to be renamed				*/
/*	RETURNS:		int		- OK if successfull else ERROR							*/
/*																									*/
/***************************************************************************/

int far CreateUniqueName( char *szBuf, char *szFile )
{
	register			i;
	char				*szExt;
	char				*szTmp;
	char				szNew[ MAX_PATH_LEN ];
	struct find_t	Info;

	strcpy( szNew, szFile );
	szExt = ParseFileName( szNew );

	if ( (szTmp = strchr( szExt, '.' )) != NULL )
		szExt = szTmp + 1;
	else
		szExt = strchr( szExt, EOL );

	for ( i = 1; i < 999; i++ )
	{
		itoa( i, szExt, 10 );
		if ( _dos_findfirst( szNew, _A_FINDALL, &Info  ) != OK )
		{
			if ( szBuf != NULL )
				strcpy( szBuf, szNew );
			return( OK );
		}
	}
	return( ERROR );
}

/***************************************************************************/
/* Far memory copy function copies memory from one location to another.		*/
/*																									*/
/*	void fmemcpy( char far *Str1, char far *Str2, UINT Len )						*/
/*																									*/
/*	ARGUMENTS:	Str1	- Far ptr to destination  memory location 				*/
/*					Str2	- Far ptr to source memory location							*/
/*					Len	- Number of bytes to move										*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void fmemcpy( char far *Str1, char far *Str2, UINT Len )
{
	while( Len-- )
		*(Str1++) = *(Str2++);
}

/***************************************************************************/
/* Entry point for Windows to do the main portition of the DOS upgrade.		*/
/*																									*/
/*	void far wsUpgradeHard( void )														*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void far wsUpgradeHard( void )
{
//BUGBUG	ToggleTsrs( OFF );								/* Turn ASSIGN & APPEND off	*/
	UpgradeHard( 0 );
}

/***************************************************************************/
/* Interface function which creates a DEVICE= line in the callers buffer	*/
/* using the DOS directory path.															*/
/*																									*/
/*	void far wsBuildConfigLine( char *szBuf, char *szDeviceName )				*/
/*																									*/
/*	ARGUMENTS:	szBuf		- Buffer big enought to hold the new line				*/
/*					szDev		- Device drive file name									*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void far wsBuildConfigLine( char *szBuf, char *szDeviceName )
{
	CreateDeviceLine( szBuf, szDeviceName, DEVICE );
}



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\sbutton.h ===
/*****************************************************************************
*                                                                            *
*  SBUTTON.C                                                                 *
*                                                                            *
*  Program Description: Implements "3-D" buttons                             *
*                                                                            *
******************************************************************************
*                                                                            *
*  Revision History:  Created by Todd Laney, Munged 3/27/89 by Robert Bunney *
*                     7/26/89  - revised by Todd Laney to handle multi-res   *
*                                bitmaps.  transparent color bitmaps         *
*                                windows 3 support                           *
*                                                                            *
*****************************************************************************/

/*
 *  WINDOW CLASS "sbutton"
 *
 *  ControlInit() registers a button class called "sbutton".
 *  a "sbutton" behaves exactly like a normal windows push button, with the
 *  following enhancments:
 *
 *  3D-PUSH effect.
 *
 *  COLORS:
 *
 *      The folowing colors will be read from WIN.INI to be used as the
 *      button colors. (under Win3 the approp. SYS colors will be used.)
 *
 *      [colors]
 *          ButtonText
 *          ButtonFace
 *          ButtonShadow
 *          ButtonFocus
 *
 *
 *  BITMAPS:
 *      if the window text of the button begins with a '#' and the string
 *      following names a bitmap resource, the bitmap will be displayed as
 *      the button.
 *
 *      bitmap can have color res specific versions in the resource file.
 *
 *      if the button name is "#%foo" bitmap resources will be searched
 *      for in the following order:
 *
 *          fooWxHxC
 *          fooWxH
 *          foo
 *
 *          W is the width in pixels of the current display
 *          H is the height in pixels of the current display
 *          C is the number of colors of the current display
 *
 *      for example a EGA specific resource would be named "foo640x350x8"
 *
 *      The first pixel of color bitmap's will be used as the "transparent"
 *      color.  All pixels that match the transparent color will be set
 *      equal to the button face color
 *
 *  BUTTON STYLES:
 *      BS_STRETCH    - stretch bitmaps to fit button
 *      BS_NOFOCUS    - dont steal focus on mouse messages
 *
 */

#define BS_STRETCH  0x8000L
#define BS_NOFOCUS  0x4000L


//
//  Init routine, will register class "sbutton" and "stext"
//
BOOL FAR PASCAL ControlInit (HANDLE hPrev, HANDLE hInst);
void FAR PASCAL ControlTerm(void);

//
// Window proc for buttons, THIS FUNCTION MUST BE EXPORTED
//
LONG FAR PASCAL fnButton (HWND, unsigned, WORD, LONG);
LONG FAR PASCAL fnText   (HWND, unsigned, WORD, LONG);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\setup.c ===
/***************************************************************************/
/* 																								*/
/* SETUP.C																						*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* Creates the recovery disk when doing a hard disk upgrade.					*/
/* New functions to allow creating a recovery floppy when memory size is	*/
/* less than size of the FAT by breaking up the reads and writes into		*/
/* small enough pieces. 																	*/
/* 																								*/
/* 10-25-80 johnhe																			*/
/* 																								*/
/* New functions to replace existing CreateRecoveryFloppy() code. This new */
/* implementation will use the new multiple file copy function xcopy() to	*/
/* actually copy the files to the recovery disk rather that relying on a	*/
/* seperate function and buffer. 														*/
/* 																								*/
/*	11-05-89 johnhe																			*/
/***************************************************************************/

#include 	<stdio.h>
#include 	<stdlib.h>
#include 	<dos.h>
#include 	<string.h>
#include		<malloc.h>

#include		<alias.h>
#include 	<copy.h>
#include		<global.h>
#include 	<data.h>
#include 	<disk_io.h>
#include		<hdisk.h>
#include 	<strlib.h>
#include 	<upgrade.h>
#include		<errors.h>
#include		<prompts.h>
#include		"wsrc.h"

/***************************************************************************/

#define		MAX_SECTOR_SIZE		4096		/* Max allowable sector size */
#define		EXT_BPB_LEN				51

#define		SYS_FILES				(_A_RDONLY | _A_HIDDEN | _A_SYSTEM )
#define		RECOVERY 				0
#define		BUF_LEN					(sizeof( struct MULT_FILES ) * MAX_PER_DISK)

#define		_A_FINDALL				(_A_HIDDEN | _A_SYSTEM | _A_RDONLY)

/***************************************************************************/
/* Global variables needed by functions in this module							*/
/* 11-05-89 johnhe																			*/
/***************************************************************************/

extern struct BPB				HdBpb;
extern char		szTmpDos[ MAX_PATH_LEN ];
/*
 *  Declared in towin.c, always contains the currect uninstall disk
 *  number (zero based)
 */
extern int iUninstallDiskNum;

extern char		*szCommand;
extern char 	*szAutoBat;
extern char 	*szConfSys;
extern char		*szWinA20;

char				*szSysFile = "X:\\*.*";

char				*szUninstall = "uninstal";	/* Contents of AUTOEXEC.BAT */


struct FILES_REC
{
	int		Valid;						/* TRUE if file exists		*/
	char		SourceName[13];			/* Source file name			*/
	char		DestinName[13];			/* Destination file name	*/

};

enum	{ IO_OLD, DOS_OLD };
enum  { CMD_OLD, AUTO_OLD, CFG_OLD, WINA20 };
#define END_LIST  999

struct FILES_REC FileRecAnyDisk[] =  { { FALSE,    "COMMAND.COM",  "COMMAND.DAT",	},
					                        { FALSE,    "AUTOEXEC.BAT", "AUTOEXEC.DAT",  },
					                        { FALSE,    "CONFIG.SYS",   "CONFIG.DAT",	   },
					                        { FALSE,    "WINA20.386",   "WINA20.386"     },
                                       { END_LIST, "",             "",              }};

struct FILES_REC FileRecDisk0[] =    { { FALSE,    "",				 "BIOS.OLD",		},
					                        { FALSE,    "",				 "DOS.OLD",		   },
                                       { END_LIST, "",             "",              }};

					                        /******************************************/
					                        /* 		     				  				*/
					                        /*	Valid,     SourceName,	  DestinName	*/
					                        /******************************************/

/***************************************************************************/

/* This guy lives in resolve.c */
extern void	InitUninstallDisk	( int iUninstallDiskNum );

extern void fmemcpy				( char far *Str1, char far *Str2, UINT Len );
extern void	UpdateFileBar		( int iFiles );

extern void	SaveBootRecs		( void );
extern void DispInsertUserDisk(int UserDisk,char chDrive);
extern void	InitFileStruc		( struct MULT_FILES *FileStruc, int iDisk,
			  						  	  int IsHdUpgrade );
extern void CopyFiles( int id, struct MULT_FILES *Files );
extern void XHcopy( struct MULT_FILES *Files ,char * szTmpDos);

void GetOldSysNames( void );

static void near 	CopyRecFiles( void );
static int near	NeedToSaveFile		( char *szPath );
static void near	InitRecoveryFiles	( struct MULT_FILES *Files );
static void near  CopyRecStruct( struct MULT_FILES *File, struct FILES_REC *FileRec );
static void near	CopyFATRoot			(void );
static void near	SaveRootEntries	( void );
static int near	SectorsToFile		( int iFile, int iDrive, long lStartSec,
												  UINT uNumSectors, UINT uBytesPerSector);

/***************************************************************************/
/* Sets up the structure needed by xcopy() and then calls it copy all of	*/
/* system files from the install disk and all of the old system files from */
/* the hard disk onto the recovery floppy. Next it calls functions to copy */
/* the FAT and root directory, master and partition boot records and then	*/
/* the global data structure "vInfo" to the recovery disk.						*/
/* 																								*/
/* void CreateRecoveryFloppy( void )													*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	void																			*/
/* 																								*/
/* 11-05-89 johnhe																			*/
/***************************************************************************/

void CreateRecoveryFloppy( void )
{
	struct MULT_FILES 	*Files;
   struct MULT_FILES    *FilesHeadPtr;
	extern int				CreatingRecovery; /* Signal can't continue on error */

	Files = GetMemory( BUF_LEN ); /* Allocate memory for file list. */
   FilesHeadPtr = Files;         /* Keep a pointer to the head of the list. */

	vInfo.uchFloppyType = 1;      /* Default floppy type = 360kb */
   /*
    *  Init the uninstall disk number. This is a global that is used to track
    *  the uninstall disk number. It's declared in towin.c, it's incremented in
    *  resolve.c when an uninstall disk becomes full and it becomes necessary
    *  to prompt for a second uninstall disk. MC Janus work 4/9/92 
    */
   iUninstallDiskNum = 0;   /* Init uninstall disk number (zero based). */

	GetHdBpb( &HdBpb );						/* Get hd's bpb from boot sect		*/

	CreatingRecovery = 1;			/* Signal need to abort if error detected */

	CopyRecFiles();

	/* This call inits both the FileRecDisk0 and FileRecAnyDisk data structures. */
   GetOldSysNames();

	InitRecoveryFiles( Files );	/* Create MULTI_FILES structure for xcopy	*/

	CopyFiles(IDS_WAITCOPYRECFL, Files );	/* Copy files to RECOVERY DISK 0 */

	MakeHidden( 'A' ); 				/* Set system file attributes					*/

	SaveBootRecs();
	UpdateFileBar( 1 );

	SaveRootEntries();				/* Copy 1st 2 root entries to vInfo			*/
	UpdateFileBar( 1 );
											/* Copy user's option choices             */
	CopyBuf( "GLOBAL.DAT", &vInfo, sizeof( vInfo ) );
	UpdateFileBar( 1 );
											/*  Create AUTOEXEC.BAT */
	CopyBuf( "AUTOEXEC.BAT", (void *)szUninstall, strlen( szUninstall ) );
	UpdateFileBar( 1 );

   /* The remaining uninstall files can be copied to either disk 0 or 1. */

   Files = FilesHeadPtr;                   /* Reset files pointer. */
	CopyRecStruct(Files, FileRecAnyDisk);
	CopyFiles(IDS_WAITCOPYRECFL, Files );	 /* Copy files to ANY recovery disk */

	CopyFATRoot();						/* Copy FAT and Root dir to recovery disk */
	UpdateFileBar( 1 );

	CreatingRecovery = 0;			/* Signal recovery disk is complete 		*/
	FreeMemory( Files );
}

/***************************************************************************/
/* Initializes the MULT_FILES struct to contain all information necessary	*/
/* to create the recovery diskette. First gets info about files from the	*/
/* installation disk and then add info about the user's existing files     */
/* which need to be saved. 																*/
/* 																								*/
/* void InitRecoveryFiles( struct MULT_FILES *Files )								*/
/* 																								*/
/* ARGUMENTS:	Files - Ptr to array of MAX_PER_DISK # of MULT_FILES strucs */
/* RETURNS: 	void																			*/
/* 																								*/
/* 11-19-89 johnhe																			*/
/***************************************************************************/

void near InitRecoveryFiles( struct MULT_FILES *Files )
{
	struct MULT_FILES 	*OldFiles;

	memset( Files, 0, BUF_LEN );
											/* Init info about files on distrib disk	*/
	InitFileStruc( Files, RECOVERY, FALSE );

		/* Find where user file info should start and set distr. file's path	*/
		/* destination drive																	*/

	for ( OldFiles = Files; OldFiles->Path.Source != NULL; OldFiles++	)
	{
		OldFiles->Drive.Source = szTmpDos[ 0 ];
		OldFiles->Path.Source = szTmpDos + 2;
		OldFiles->Drive.Destin = 'A';

		//	We hard code the DiskNumber to NOT_REMOVEBALE as we know that the 
		// source is directory is on the hard disk.

		OldFiles->DiskNumber = NOT_REMOVEABLE;

	}
	/* Create struct needed by file copy func */
	CopyRecStruct( OldFiles, FileRecDisk0);
}

/***************************************************************************/
/* Finds the name of the original bios and dos files by doing a findfirst	*/
/* and assuming that the first 2 files in the root directory are the 		*/
/* system files. Saves these 2 names in the file name structure. Next it	*/
/* checks to see if an autoexec.bat or config.sys exists and updates the	*/
/* structure to reflect that the file exist. The existing system files		*/
/* must be marked as hidden, system and readonly.									*/
/* 																								*/
/* void GetOldSysNames( void ) 															*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	void																			*/
/* 																								*/
/* 11-05-89 johnhe																			*/
/***************************************************************************/

void GetOldSysNames( void )
{

   *szCommand = *szAutoBat = *szConfSys = *szSysFile =
	*szWinA20 = vInfo.chDestin;

	GetSysFiles();

	if ( vInfo.Flag.fIoSys )
	{
		strcpy( FileRecDisk0[ IO_OLD	].SourceName, vInfo.szIoSys );
		FileRecDisk0[ IO_OLD ].Valid = TRUE;
	}
	if ( vInfo.Flag.fMsDos )
	{
		strcpy( FileRecDisk0[ DOS_OLD ].SourceName,	vInfo.szMsDos );
		FileRecDisk0[ DOS_OLD ].Valid = TRUE;
	}
	if ( NeedToSaveFile( szCommand ) )
		vInfo.Flag.fCommandCom = 1, FileRecAnyDisk[ CMD_OLD ].Valid = TRUE;

	if ( NeedToSaveFile( szAutoBat ) )
		vInfo.Flag.fAutoexecBat = 1, FileRecAnyDisk[ AUTO_OLD ].Valid = TRUE;

	if (  NeedToSaveFile( szConfSys ) )
		vInfo.Flag.fConfigSys = 1, FileRecAnyDisk[ CFG_OLD ].Valid = TRUE;

	if (  NeedToSaveFile( szWinA20 ) )
		vInfo.Flag.fWinA20 = 1, FileRecAnyDisk[ WINA20 ].Valid = TRUE;
}

/***************************************************************************/
/* Determines if a file needs to be saved by checking to see if it exists	*/
/* and ensuring that it's not zero length.											*/
/* 																								*/
/* int NeedToSaveFile( char *szPath )													*/
/* 																								*/
/* ARGUMENTS:	szPath	- Ptr to file's full path name							*/
/* RETURNS: 	int		- TRUE if file exists and is not zero length			*/
/*								  else FALSE													*/
/* 																								*/
/***************************************************************************/

int near NeedToSaveFile( char *szPath )
{
	struct find_t		Find;

	return( _dos_findfirst( szPath, _A_FINDALL, &Find ) == OK &&
           Find.size != 0L );
}

/***************************************************************************/
/* Creates information in a MULT_FILES structure to allow coping the files */
/* from the user's hard disk which will be neccessary for doing a recovery.*/
/* 																								*/
/* void CreateRecStruct( struct MULT_FILES *File ) 								*/
/* 																								*/
/* ARGUMENTS:	File		- Ptr to 1st element in array of MULT_FILES strucs */
/* 																								*/
/* 				FileRec  - Ptr to recovery file struct to be added to       */
/* 							  the mult_files (File) data struct.               */
/* 																								*/
/* RETURNS: 	void																			*/
/* 																								*/
/* 11-05-89 johnhe																			*/
/***************************************************************************/

void near CopyRecStruct( struct MULT_FILES *File, struct FILES_REC *FileRec )
{
	int					i = 0;
	extern char			*szRootPath;

	while( FileRec[ i ].Valid != END_LIST )
	{
		if ( FileRec[ i ].Valid != FALSE )
		{
			File->Name.Destin = FileRec[ i ].DestinName;

			File->Path.Source = szRootPath;
			File->Path.Destin = szRootPath;

			File->Drive.Destin = 'A';
			File->UserDisk = RECOVERY;					/* Recovery disk number	*/

			File->Name.Source = FileRec[ i ].SourceName;
			File->Drive.Source = vInfo.chDestin;
			File->DiskNumber = NOT_REMOVEABLE;

			File++;
		}
      i++;
	}
   File->Name.Source = NULL; /* Tie off the list !! */
}

/***************************************************************************/
/* Copies the FAT and root directory to the recovery disk. Allocates a		*/
/* variable	size buffer and then reads in up to 3f sectors at a time and	*/
/* then writes them to the recovery disk.	The root is copied first and		*/
/* then a check has to be made to see if the hard disk has a big FAT and	*/
/* if it does the recovery disk must have > 360K free space or else the 	*/
/* user is prompted for recovery disk #2.												*/
/*																									*/
/*	void CopyFATRoot( void )																*/
/*																									*/
/*	ARGUMENTS:	void																			*/
/*	RETURNS:		void																			*/
/*																									*/
/* 10-25-89 johnhe																			*/
/***************************************************************************/

static void near CopyFATRoot( void )
{
	static char		*szPath[] = { "A:\\ROOT.DAT", "A:\\FAT.DAT" };
	char				chDrive;							/* Physical drive number	*/
	int				i;									/* Loop counter & indice	*/
	int				iFile;							/* DOS file handle			*/
	int				iStatus;
	unsigned			uStartSector;					/* Starting sector to read	*/
	unsigned			uNumSectors;					/* Total sectors to read	*/
	long				lNumBytes;
	struct BPB		Bpb;								/* Hard disk's bpb			*/

	GetHdBpb( &Bpb );									/* Get hd's bpb from boot sect*/
							/* Boot sector was left in the pchBootBuf so copy	*/
							/* to the recovery disk before doing anything else	*/
	chDrive = vInfo.chDestin - (char) 0x41;	/* Calculate the drive number */

	uStartSector = (Bpb.uSecPerFat * Bpb.uchNumberFats) + Bpb.uReservSec;
	uNumSectors = (Bpb.uRootEntries * 32) / Bpb.uBytesPerSec;

						/* Loop once for once for root directory and FAT			*/
	for ( i = 0, iStatus = OK;
			iStatus == OK && i < 2;
			i++ )
	{
		lNumBytes = (long)uNumSectors * (long)Bpb.uBytesPerSec;
		if ( GetDiskFree( 'A' ) < lNumBytes )
			InitUninstallDisk(1);

		DisplayFileStatus( szPath[i] + 3, WRITE );

		if ( _dos_creat( szPath[i], _A_NORMAL, &iFile) == OK )
		{
			if ( (iStatus = SectorsToFile( iFile, chDrive, (long)(uStartSector),
					uNumSectors, Bpb.uBytesPerSec )) == OK )
			{
				if ( _dos_close( iFile ) == OK )
				{
					if ( 0 == i )
					{	
						uStartSector = Bpb.uReservSec;/* Set start sec to 1st fat*/
						uNumSectors = Bpb.uSecPerFat;	/* Set total sec in FAT	*/
						lNumBytes = (long)uNumSectors * (long)Bpb.uBytesPerSec;
						lNumBytes += 1024L;
					}
				}
				else
					iStatus = BAD_RECOVERY_DISK;	/* Couldn't close the file */
			}
		}
		else
			iStatus = BAD_RECOVERY_DISK;			/* Couldn't open the file	*/
	}
	if ( iStatus != OK )								/* Check for error			*/
		FatalError( iStatus );						/* Abort program if error	*/
}

/***************************************************************************/
/* Read the specified sectors from a disk and write them to a an opened		*/
/* file handle. Will first allocate a buffer as large as possible (up to	*/
/* 64K using halloc()). Next it sets up a loop to read in as many sectors	*/
/* as possible in iteration and then write them to the file. The loop will	*/
/* continue until all sectors are done or an error is detected.				*/
/*																									*/
/*	int SectorsToFile( int iFile, int iDrive, long lStartSec,					*/
/*							 unsigned uNumSecs, int uBytesPerSec )						*/
/*																									*/
/*	ARGUMENTS:	iFile			- File handled which was opened for writing to	*/
/*					iDrive		- Drive number to read the sectors from			*/
/*					lStartSec	- Sector to starting reading from					*/
/*					uNumSecs		- Number of of sectors to transfer					*/
/*					uBytesPerSec- Number of bytes out for each sector read in	*/
/*																									*/
/*	RETURNS:		int			- OK if no errors else a FATAL error code			*/
/*																									*/
/*	GLOBALS:		NONE																			*/
/*																									*/
/* 10-25-89 johnhe																			*/
/***************************************************************************/

int near SectorsToFile( int iFile, int iDrive, long lStartSec,
								unsigned uNumSectors, unsigned uBytesPerSector )
{
	int							iStatus;
	unsigned						uBufSize;
	unsigned						uBytesToWrite;
	unsigned						uBytesWritten;
	struct	ABSIO_PACKET	Packet;

							/* Allocate the buffer as large as possible */
	for ( uBufSize = 0xf800; 
			(Packet.pchBuffer = _fmalloc( uBufSize )) == NULL;
			uBufSize -= 0x400 )
	{
		if ( uBufSize <= 0x800 )
			return( FATAL_MEMORY_ERROR );
	}
						/* Determine number of sector which fit in the buffer	*/
	Packet.uNumSectors = uBufSize / uBytesPerSector;

	if ( Packet.uNumSectors > uNumSectors )
		Packet.uNumSectors = uNumSectors;
	uBufSize = Packet.uNumSectors * uBytesPerSector;

													/* Load rest of access packet	*/
	Packet.lStartSector = lStartSec;
	uBytesToWrite = uBufSize;				/* Set maximum write size */
					 
	iStatus = OK;							/* Loop until all sector are done	*/
	while ( iStatus == OK && uNumSectors != 0 )
	{
		if ( AbsReadWrite( iDrive, &Packet, READ ) == OK )
		{
			if ( _dos_write( iFile, Packet.pchBuffer, uBytesToWrite,
										 (unsigned *)&uBytesWritten ) == OK &&
				  uBytesWritten == uBytesToWrite )
			{
						/* Find new starting sector and number left to do	*/
				Packet.lStartSector += (long)(Packet.uNumSectors);
				uNumSectors -= Packet.uNumSectors;
				if ( uNumSectors < Packet.uNumSectors )
				{
					Packet.uNumSectors = uNumSectors;
					uBytesToWrite = uNumSectors * uBytesPerSector;
				}
			}					
			else
				iStatus = BAD_RECOVERY_DISK;
		}
		else
			iStatus = FATAL_HD_READ_ERROR;
	}

	_ffree( Packet.pchBuffer );
	return( iStatus );
}

/***************************************************************************/
/* Gets the boot sector from the hard drive being upgraded.						*/
/*																									*/
/*	void GetHdBpb( struct BPB *Bpb )														*/
/*																									*/
/*	ARGUMENTS:	Bpb		- Ptr to a bpb structure to be filled in.				*/
/*	RETURNS:		void																			*/
/*																									*/
/* 10-25-89 johnhe																			*/
/***************************************************************************/

void GetHdBpb( struct BPB *Bpb )
{
	struct	ABSIO_PACKET	Packet;

	Packet.lStartSector = 0L;
	Packet.uNumSectors = 1L;
	Packet.pchBuffer = pchBootBuf;

	if ( AbsReadWrite( vInfo.chDestin - 'A', &Packet, READ ) == OK )
		fmemcpy( (char far *)Bpb, Packet.pchBuffer + 11, sizeof( struct BPB ) );
	else
		FatalError( FATAL_HD_READ_ERROR );
}

/***************************************************************************/
/* Create a specified file on the recovery disk and copies the contents of */
/* of the specified buffer to the file.												*/
/*																									*/
/* void CopyBuf( char *szFile, void *pchBuf, unsigned uBytes )					*/
/*																									*/
/*	ARGUMENTS:	szFile	- Name of file to be created. 							*/
/* 				pchBuf	- Ptr to buffer to be copied to the file				*/
/* 				uBytes	- Size of the buffer in bytes 							*/
/*	RETURNS:		void		- Will not return if an error is detected.			*/
/*																									*/
/* 11-06-89 johnhe																			*/
/***************************************************************************/

void CopyBuf( char *szFile, void *pBuf, unsigned uBytes )
{
	char			szPath[ 25 ];
	int			iFile;
	unsigned 	uWritten;

	szPath[0] = 'A';
	szPath[1] = ':';
	szPath[2] = '\\';
	strcpy( szPath + 3, szFile );

	DisplayFileStatus( szFile, WRITE );

	if ( _dos_creat( szPath, 0, &iFile ) != OK ||
		  _dos_write( iFile, pBuf, uBytes, &uWritten) != OK ||
		  uBytes != uWritten ||
		  _dos_close( iFile ) != OK )
		ProcessCopyError( szFile, ERR_WRITING );
}

/***************************************************************************/
/* Reads in the first sector of the root directory and then copies the		*/
/* first 2 entries into the vInfo structure.											*/
/*																									*/
/*	void SaveRootEntries( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void near SaveRootEntries( void )
{
	int				iDosDrv;							/* Physical drive number	*/
	struct BPB		Bpb;								/* Hard disk's bpb			*/


	GetHdBpb( &Bpb );									/* Get hd's bpb from boot sect*/

	iDosDrv = vInfo.chFirstHd - 'A';
	if ( ReadWriteRoot( iDosDrv, &Bpb, pchBootBuf, 0, READ ) == OK )
		memcpy( vInfo.RootEntry, pchBootBuf, sizeof( struct DIR ) * 2 );
	else
		FatalError( FATAL_HD_READ_ERROR );
}

/***************************************************************************/
/*	Function to copy the DOS files from the distribution disk (or net) to	*/
/* the tmp DOS directory and returns the total number of files copied. The	*/
/* function argument allows the caller to specify if it really want the		*/
/* files to be copied or if just the count is needed.								*/
/*																									*/
/* NOTE:																							*/
/*		Since this function is copying files for the recovery disk it must	*/
/*		make sure that it starts at user disk 0.										*/
/*																									*/
/*	void CopyRecFiles( void )																*/
/*																									*/
/***************************************************************************/

void near CopyRecFiles( void )
{
	#define			BUF_LEN (sizeof( struct MULT_FILES ) * MAX_PER_DISK)

	struct MULT_FILES *TmpFiles;

	extern char		szDosDesName[];		/* Defined in Windows setup copy.c	*/

	TmpFiles = GetMemory( BUF_LEN );

	memset( TmpFiles, 0, BUF_LEN );
	InitFileStruc( TmpFiles, RECOVERY, TRUE );
   XHcopy(TmpFiles, szTmpDos);

	FreeMemory( TmpFiles );

}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\upgrade.c ===
/***************************************************************************/
/* 																								*/
/* UPGRADE.C																					*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* This module contains the functions which upgrade a floppy disk or 		*/
/* hard disk system. UpgradeHard() will upgrade a hard disk system and		*/
/* return to the caller when complete. UpgradeFloppy() will upgrade a		*/
/* floppy disk system and return to the caller when complete.					*/
/*																									*/
/* Created 11-13-89 - johnhe																*/
/***************************************************************************/

#include 	<stdio.h>
#include 	<fcntl.h>
#include 	<io.h>
#include 	<stdlib.h>
#include 	<string.h>
#include 	<ctype.h>
#include 	<dos.h>
#include 	<process.h>
#include 	<sys\types.h>
#include 	<sys\stat.h>
#include 	<direct.h>

#include		<alias.h>
#include		<copy.h>
#include 	<data.h>
#include 	<disk_io.h>
#include		<file_io.h>
#include 	<strlib.h>
#include		<global.h>
#include 	<upgrade.h>
#include		<prompts.h>
#include		<errors.h>
#include		<install.h>
#include		"wsrc.h"
#undef NULL
#include		"lib\common\sulib.h"
#include    "log.h"


#define		EXT_BPB_LEN		51

/***************************************************************************/


char				*szBios		= "X:\\io.sys";
char				*szDos		= "X:\\msdos.sys";
char 				*szCommand	= "X:\\command.com";
char				*szVxd		= VXD_NAME;

char				*szAutoBat	= "X:\\AUTOEXEC.BAT";
char				*szConfSys	= "X:\\CONFIG.SYS";
char				*szWinA20	= "X:\\WINA20.386";

#if 0
	static char 	*szOldBios	= "X:\\12345678.123";
	static char 	*szOldDos	= "X:\\12345678.123";
#endif
																	/* Executable extensions */
char 	*szExeExt[] = { "EXE", "COM", "BAT", NULL };

int				iWillReboot = FALSE;


/***************************************************************************/

extern void		FixupRoot			( void );
extern void		RenameOemFiles		( int IsRecovery );

/***************************************************************************/

extern void		NewAutoConfig	( int iType, char *szFilePath );
extern void		InitFileStruc	( struct MULT_FILES *FileStruc, int iDisk,
			  						 	  int IsHdUpgrade );
extern void		UpdatePartDrivers	( void );				// MC 4/13/92 #1

static void near	InstallFiles	( int iDisk, int IsHdUpgrade );
static void near	CreateTmpDir	( void );
static int near	MoveDeleteFile ( char *szSource, char *szDestin, int Type );
static void near	CreateNulFile	( int SeqNum );
static void near	DeleteNulFiles	( void );
static void near	CreateReadMe		( void );

static void near	CopyCommandCom	( void );
static void near	SetTotalBytes	( int iStartDisk, int iTotalDsks );
static int near	InitFileInfo	( char *szName, struct MULT_FILES *File,
											  int iDisk, int IsHdDisk );
static void near	DelTmpFiles		( void );


extern void		UpdateFileBar		( int iFiles );
extern void		ForceExitReboot	( void );
extern void    GetReadMeText		( char *Buf );

extern void CopyFiles( int id, struct MULT_FILES *Files );
extern void ProPrintfStat1( int id );

extern void 	GetOldSysNames		( void );
extern void 	GetHdBpb				( struct BPB *Bpb );
extern struct BPB	HdBpb;

extern char	szTmpDos[];

/***************************************************************************/
/* HARD DISK INSTALLATION																	*/
/* 																								*/
/* Main procedure for upgrading a hard disk. First creates the recovery 	*/
/* disk and then does a fixup on the master partition record, creates a 	*/
/* new tmp boot which prompts for the recovery disk, copies all of the		*/
/* files, updates the lie table in msdos.sys, creates new autoexec.bat and */
/* config.sys files, installs a new master boot record, changes all bpbs	*/
/* on all partitions on all hard disks to remove logical sectoring and		*/
/* then writes the new boot records to all partitions on all hard disks 	*/
/* making sure to do the boot partition last.										*/
/* 																								*/
/* This code is also used by the recovery program to continue the upgrade	*/
/* if there is a failure part of the way through so it is designed to be	*/
/* able to continue from an place based on existence of the number of NULL */
/* files which have already been created in the TMP directory. This is the */
/* reason for the #ifdef RECOVERY_PROGRAM condition compilation statements.*/
/* 																								*/
/* void UpgradeHard( int iNextFile )													*/
/* 																								*/
/* ARGUMENTS:	iNextFile	- Defines the starting point for the upgrade 	*/
/* 								  based on null files created in tmp dir, the	*/
/* 								  caller should use the last null file number	*/
/* 								  + 1 														*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void UpgradeHard( int iNextFile )
{

	register 	iDiskNum;

   LOG("Updating Partition drivers");
   UpdatePartDrivers();				// MC 4/13/92 #1
   LOG("Updating Partition drivers done");

				/*Create the target path, if it doesn't already exist.*/
	CreatTmpTwo();
	IsValidPath( vInfo.szPath + 2, (UINT)((int)vInfo.chDestin) - 0x40, TRUE );
	CreateTmpDir();								/* Create the rup directory	*/
	DeleteTmpTwo();

				/* Create tmp directory in OLD_DOS to copy Recovery files into*/
	BuildPath( szTmpDos, vInfo.szTmpDir[0], vInfo.szTmpDir + 2, TMP_DOS_DIR );

	if ( lpInstall->Flags.fUninstall )
   {
      LOG("Creating recovery");

		if ( mkdir( szTmpDos ) != OK )
			FatalError( BAD_TMPDIR );

		CreateRecoveryFloppy(); 		  /* Create the recovery floppy */

	   DelTmpFiles();                  /* Delete temporary scratch files and dir. */

      LOG("Creating recovery Done");
   }
	else
	{
		GetHdBpb( &HdBpb );						/* Get hd's bpb from boot sect */

		GetOldSysNames();							/* Init. global values */

		/* Read MBR into pchMbrBuf, and copy to pchOldPartRec if valid.
		 * FixupBootRec() needs pchOldPartRec.
		 */
		if ( RdWrSector(0x80, 0, 0, 1, READ) == OK )
		{
			if ( IsValidPartTable() )
				memcpy( pchOldPartRec, pchMbrBuf, SECTOR_SIZE );
		}
		else
			FatalError( FATAL_HD_READ_ERROR );
	}
	CreateNulFile( iNextFile++ ); 			/* Create null file 0			*/

	if ( lpInstall->Flags.fUninstall )
	{
		iWillReboot = TRUE;
		vCurrentFile.chValidErrors = REBOOT;	/* Signal can't quit now    */
		ForceExitReboot();
      LOG("Writing out temporary master boot record");
		WriteNewBoot( FALSE );						/* Write temp boot record		*/
      LOG("Writing out temporary master boot record done");
	}
   LOG("Creting readme");
	CreateReadMe();
   LOG("Cretaing readme done");

	CreateNulFile( iNextFile++ );

   LOG("Moving Files");
	MoveFiles( DO_MOVE );						/* Move DOS files to tmp dir	*/
   LOG("Loving Files done");

	CreateNulFile( iNextFile++ );

	LOG("Fixing up Root");
   FixupRoot();
	LOG("Fixing up Root done");

	CreateNulFile( iNextFile++ );

   LOG("renaming OEM Files");
	RenameOemFiles( FALSE );					/* Rename old utilities kept	*/
   LOG("Renaming OEM Files done");

	CreateNulFile( iNextFile++ );

	iDiskNum = FIRST_USER_DISK;

   LOG("Entering Main file install loop");

						/* NOTE: Recovery disks were 0 & 1 so min here must be 2 */
	while( iDiskNum < (int)vInfo.uchNumDisks )
	{
		InstallFiles( iDiskNum, TRUE );		/* Install files to hard disk	*/
		CreateNulFile( iNextFile++ );
		iDiskNum++;
	}
   LOG("Exiting Main file install loop");

	if ( !vInfo.Args.fMininum ) {		/* M002 Don't update for minimum	*/
      LOG("Updating lie table");
		UpdateLie();						/* Update lie table					*/
   }
	MakeHidden( vInfo.chDestin ); 	/* Set system file attributes		*/

	if ( !vInfo.Args.fMininum ) {		/* M002 Don't copy for minimum	*/
      LOG("Copying command.com");
		CopyCommandCom();					/* Copy command.com to DOS dir	*/
   }

	CreateNulFile( iNextFile++ );

   LOG("Processing Config");
	ProcessConfig();
   LOG("Processing Auto");
	ProcessAuto();
	CreateNulFile( iNextFile++ );

   LOG("Move Auto/Config");
	MoveAutoConfig();
	CreateNulFile( iNextFile++ );

   LOG("Fixup Boot record");
	FixupBootRecs();							/* Fixup all boot records		*/
	CreateNulFile( iNextFile++ );

   LOG("Write new Master boot record");
	WriteNewBoot( TRUE );		/* Replace tmp boot record with real one */
	UpdateFileBar( 1 );

   LOG("delete all the NULL files.");
	DeleteNulFiles();
   LOG("Returning from function UpgradeHard()");
}

/***************************************************************************/
/* Create the RUP tmp directory and then expands it to make sure it has 	*/
/* all clusters allocated to it when the FAT is saved on the recovery		*/
/*	disk. The RUP directory will be "\RUPXX" where the XX is a number from	*/
/* 1 to 99. 																					*/
/* Because the install program in DOS 4.x left old msdos system files		*/
/* laying around we have to delete any io.sys or msdos.sys files that are	*/
/* not the first 2 directory entries on the disk.									*/
/*																									*/
/* void CreateTmpdir( void )																*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void near CreateTmpDir( void )
{
	#define			_A_FINDALL (_A_HIDDEN | _A_SYSTEM | _A_RDONLY)
	static char 	*szPath = "X:\\OLD_DOS.000";
	int				i;

	static char		*szAnyFile = "X:\\*.*";
	char				szName1[ 15 ];
	char				szName2[ 15 ];
	struct find_t	Info;
	#ifdef NET_SETUP
		static char		*szNetDir = NET_DIR;
	#endif


												 			/* Set drive letter in paths	*/
	szPath[ 0 ] = szAnyFile[0] = szBios[0] = szDos[0] = vInfo.chDestin;

									/* Following code deletes bogus system files		*/
	szName1[0] = szName2[0] = EOL;
	if ( _dos_findfirst( szAnyFile, _A_FINDALL, &Info ) == OK )
	{
		strcpy( szName1, Info.name );
		if ( _dos_findnext( &Info ) == OK )
			strcpy( szName2, Info.name );
	}

	if ( strcmpi( szName1, szBios + 3 ) != OK &&
		  strcmpi( szName2, szBios + 3 ) != OK )
		AbsUnlink( szBios );
	if ( strcmpi( szName1, szDos + 3 ) != OK &&
		  strcmpi( szName2, szDos + 3 ) != OK )
		AbsUnlink( szDos );
									/* End of code for deleting bogus system files	*/
	for (i = 1; i < 100; i++)
	{
		itoa( i, szPath + 11, 10 );
		DisplayFileStatus( szPath + 3, CREATE );
		if ( mkdir( szPath ) == OK )
			break;
	}

	if ( i < 1000 )
	{
		strcpy( vInfo.szTmpDir, szPath );
		ExpandRupDir( MoveFiles( DO_COUNT ) + MAX_DISK + 10 );

								/* Create tmp autoexec.bat and config.sys names */
		strcpy( vInfo.szTmpConfig, szPath );
		strcat( vInfo.szTmpConfig, "\\CONFIG.XXX" );					/* M003	*/
		strcpy( vInfo.szTmpAuto, szPath );
		strcat( vInfo.szTmpAuto, "\\AUTOEXEC.XXX" );					/* M003	*/

		#ifdef NET_SETUP
												/* Create the directory for net stuff	*/
			strcpy( vInfo.szNetDir, szPath );
			strcat( vInfo.szNetDir, szNetDir );
			DisplayFileStatus( szNetDir + 1, CREATE );
			if ( mkdir( vInfo.szNetDir ) != OK )
				FatalError( FATAL_HD_WRITE_ERROR );
		#endif
	}
	else
		FatalError( ROOT_DIR_FULL );
}

/***************************************************************************/
/* Create a null file in the rup directory.											*/
/*																									*/
/*	void CreateNulFile( iType )															*/
/*																									*/
/*	ARGUMENTS:	iType			- The sequence number for the null file			*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void near CreateNulFile( int SeqNum )
{
	register 		iStatus;
	static char 	*szNullFile = "diskXXXX.XXX   ";
	char				*szPath;
	int				hFile;

   LOG("Creating Null File");

	iStatus = ERROR;

	itoa( SeqNum, szNullFile + 4, 10 );
	strcat( szNullFile, ".NUL" );

	szPath = GetMemory( MAX_PATH_LEN );
	BuildPath( szPath, vInfo.szTmpDir[0], vInfo.szTmpDir + 2, szNullFile );

	if ( _dos_creat( szPath, _A_NORMAL, &hFile ) == OK &&
		  _dos_close( hFile ) == OK )
		iStatus = OK;

	FreeMemory( szPath );

	if ( iStatus != OK )
		FatalError( FATAL_HD_WRITE_ERROR );

   LOG("Creating Null File done");

}

/***************************************************************************/
/* Renames the existing OEM files which we want to keep but need to rename	*/
/* so they can be replaced by the new DOS utility. Function will also 		*/
/* rename the files back to the orginal names during recovery. To reduce	*/
/* the code size we need to cheat by changing the name of the TmpDir to		*/
/* the same name as the new DOS directory so that we can call the function	*/
/* MoveDeleteFile() and have it rename all files with an executable			*/
/* extension for us. We restore the name of the Tmp directory before			*/
/* returning.																					*/
/* 																								*/
/* void RenameOemFiles( int IsRecovery )												*/
/* 																								*/
/* ARGUMENTS:	IsRecovery - FALSE if upgrade or TRUE if recovery				*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void RenameOemFiles( int IsRecovery )
{
	register 	i; 						/* Loop and array indice					*/
	char			*szSource; 				/* Current file name 						*/
	char			*szDestin;
	char			*szTmpDir;

	if ( vInfo.Args.fMininum )			/* M002 Don't rename for minimum	setup	*/
		return;

	szTmpDir = GetMemory( MAX_PATH );
	strcpy( szTmpDir, vInfo.szTmpDir );
	strcpy( vInfo.szTmpDir, vInfo.szPath );

	for ( i = 0; (szSource = GetDataString( RE_NAME, i)) != NULL; i += 2 )
	{
		szDestin = GetDataString( RE_NAME, i + 1 );
		if ( IsRecovery )
			MoveDeleteFile( szDestin, szSource, DO_MOVE );
		else
			MoveDeleteFile( szSource, szDestin, DO_MOVE );
	}

	strcpy( vInfo.szTmpDir, szTmpDir );
	FreeMemory( szTmpDir );
}

/***************************************************************************/
/* Moves all files which need to be moved from the DOS directory. First 	*/
/* moves all the files marked for deletion in the dosdata file and then 	*/
/* moves all of the files which are being replaced by new files. The files */
/* are renamed into the upgrade tmp directory.										*/
/* 																								*/
/* If the argument Type == DO_DELETE the new files are deleted from the 	*/
/* DOS directory. If Type == DO_COUNT files are not moved or deleted and	*/
/* only counted.																				*/
/* 																								*/
/* int MoveOldFiles( int Type )															*/
/* 																								*/
/* ARGUMENTS:	Type		- 0 == move, 1 == delete file, other == count		*/
/* RETURNS: 	int		- Count of file found needing to be moved 			*/
/* 																								*/
/***************************************************************************/

int MoveFiles( int Type )
{
	register 	i; 						/* Loop and array indice					*/
	register 	iDisk;					/* Current distribution disk				*/
	char			*szFile; 				/* Current file name 						*/
	int			iCount;					/* Total number of files found			*/

	if ( vInfo.Args.fMininum )			/* M002 Don't move for minimum setup	*/
		return( 0 );

	iCount = 0;
							/* First make sure there are some files in the dir 	*/
	if ( !IsDirEmpty( vInfo.szPath ) )
	{
												/* Now get all files which are marked	*/
												/* for deletion in the dosdata file 	*/
		for ( i = 0; (szFile = GetDataString( DELETE_FILE, i )) != NULL; i++ )
			iCount += MoveDeleteFile( szFile, szFile, Type );

												/* Now chk for duplicate renamed files	*/
		if ( Type != DO_DELETE )		/* but recovery can't delete them		*/
		{
			for ( i = 0; GetDataString( RE_NAME, i) != NULL; i += 2 )
			{
				szFile = GetDataString( RE_NAME, i + 1 );
				iCount += MoveDeleteFile( szFile, szFile, Type );
			}
		}
							/* Now move all files being replaced with new version */
							/* If recovery we need to delete the files which 		*/
							/* replace the renamed files.									*/
		for ( iDisk = FIRST_USER_DISK; iDisk < (int)vInfo.uchNumDisks; iDisk++ )
			for ( i = 0; (szFile = GetFileName( iDisk, i )) != NULL; i++ )
				if ( (szFile = GetRealDestName( szFile )) != NULL &&
						!FindDataMatch( szFile, NET_FILES ) &&
						(Type == DO_DELETE || !FindDataMatch( szFile, RE_NAME )) )
					iCount += MoveDeleteFile( szFile, szFile, Type );
	}
	return( iCount );
}

/***************************************************************************/
/* Moves the specified file from the DOS directory to the tmp directory.	*/
/* The argument Type signals if the file is to be moved, deleted or just	*/
/* counted. If the file has an executable extension the move or delete is	*/
/* repeated for all 3 possible executable file extensions.						*/
/* 																								*/
/* If the argument Type == DO_DELETE the new files are deleted from the 	*/
/* DOS directory. If Type == DO_COUNT files are not moved or deleted and	*/
/* only counted.																				*/
/* 																								*/
/* int MoveDeleteFile( char *szFile, int Type	)									*/
/* 																								*/
/* ARGUMENTS:	szFile	- Ptr to name of file to be moved 						*/
/* 				Type		- 0 == move, 1 == delete file, other == count		*/
/* RETURNS: 	int		- Returns TRUE if file exists 							*/
/* 																								*/
/***************************************************************************/

int near MoveDeleteFile( char *szFileSource, char *szFileDestin, int Type )
{

	char			*szDestin;
	char			*szSource;
	register 	iFileCount;
	register 	i;
	int			IsExeFile;

	if (Type == DO_DELETE)
		ProPrintfStat1(IDS_WAITDEL);
	else if ( Type == DO_MOVE)
		ProPrintfStat1(IDS_WAITREN);

	IsExeFile = (FindExtMatch( szFileSource, szExeExt ) != -1 ? TRUE: FALSE);

	szSource = GetMemory( MAX_PATH_LEN * 2 ); /* Get memory for file paths	*/
	szDestin = szSource + MAX_PATH_LEN;

	BuildPath( szSource, vInfo.szPath[0], vInfo.szPath + 2, szFileSource );
	BuildPath( szDestin, vInfo.szTmpDir[0], vInfo.szTmpDir + 2, szFileDestin );

	for ( i = iFileCount = 0; i < 3; i++ )
	{
		if ( IsExeFile )
		{
			strcpy( strchr( ParseFileName( szSource ), '.' ) + 1, szExeExt[i] );
			strcpy( strchr( ParseFileName( szDestin ), '.' ) + 1, szExeExt[i] );
		}

		if ( FileExists( szSource ) ) 			/* Make sure file exists		*/
		{
			iFileCount++;								/* Increment file found count */
			if ( Type != DO_COUNT )					/* Display the file status 	*/
				DisplayFileStatus( szFileSource,
										 Type == DO_DELETE ? DELETE : RENAME );

			if ( Type == DO_DELETE )				/* See if deleting the file	*/
				remove( szSource );
			else if ( Type == DO_MOVE )			/* See if moving the file		*/
				if ( rename( szSource, szDestin ) != OK )
					FatalError( ERROR_MOVING_FILE );
		}
		if ( IsExeFile == FALSE )					/* If file is not executable	*/
			break;										/* break out of for loop		*/
	}

	FreeMemory( szSource );
	return( iFileCount );
}

/***************************************************************************/
/* Set the 2 system file attribute to hidden system on the specified 		*/
/* drive.																						*/
/* 																								*/
/* void Makehidden( char Drive ) 														*/
/* 																								*/
/* ARGUMENTS:	Drive 	- DOS drive letter to set the file attribs on		*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void MakeHidden( char Drive )
{
	*szBios = *szDos = *szVxd = Drive;

	_dos_setfileattr( szBios, _A_HIDDEN | _A_SYSTEM | _A_RDONLY );	/* m103	*/
	_dos_setfileattr( szDos,  _A_HIDDEN | _A_SYSTEM | _A_RDONLY );	/* m103	*/
	_dos_setfileattr( szVxd,  _A_RDONLY );
}

/***************************************************************************/
/* Builds a MULT_FILES structure for the specified disk and then calls		*/
/* Xcopy() to install the new files.													*/
/* 																								*/
/* void InstallFiles( int iDisk )														*/
/* 																								*/
/* ARGUMENTS:	iDisk - Distribution disk number to install						*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void near InstallFiles( int iDisk, int IsHdUpgrade )
{
	#define					BUF_LEN (sizeof( struct MULT_FILES ) * MAX_PER_DISK)
	struct MULT_FILES 	*Files;

	Files = GetMemory( BUF_LEN );
	memset( Files, 0, BUF_LEN );

	InitFileStruc( Files, iDisk, IsHdUpgrade );

			/* M002  If minimum install only copy 1st 3 DOS files	*/
	if ( vInfo.Args.fMininum && FIRST_USER_DISK == iDisk )
		Files[ 3 ].Name.Source = NULL;
//	Xcopy( Files );
	CopyFiles( IDS_WAITCOPY, Files );


	FreeMemory( Files );
	#undef					BUF_LEN											/* m111	*/
}

/***************************************************************************/
/* Initializes a MULT_FILES structure for the specified disk.					*/
/* 																								*/
/* void InitFileStruc( struct MULT_FILES *FileStruc, int iDisk,				*/
/*							  int IsHdUpgrade )												*/
/* void InstallFiles( int iDisk )														*/
/* 																								*/
/* ARGUMENTS:	FileStruc	- Array of MULT_FILES strucs to be filled in 	*/
/* 				iDisk 		- Distribution disk number to be copied			*/
/* 				IsHdUpgrade - Signals doing a hard disk upgrade if TRUE		*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void InitFileStruc( struct MULT_FILES *FileStruc, int iDisk, int IsHdDisk )
{
	register 				i;
	char						*szTmp;
	struct MULT_FILES 	*File;

	for ( i = 0, File = FileStruc;
			(szTmp = GetFileName( iDisk, i )) != NULL;
			i++ )
	{
		if ( InitFileInfo( szTmp, File, iDisk, IsHdDisk ) == OK )
			File++;
	}
}

/***************************************************************************/
/* Initializes a file info structure for the specified file name. The data	*/
/*	base is checked for the file and all translations for this specific 		*/
/*	file are done. 																			*/
/* 																								*/
/* Possible translations and the order in which they are done					*/
/* 																								*/
/* 	Destin file - Don't copy the file            - [no-copy]             */
/* 					  Rename file							- [rename]					*/
/* 					  Use different directory path	- [diff-path]				*/
/* 																								*/
/* 	Source file - Use alternate file					- [diff-file]				*/
/* 					  Get file from alternate disk	- [diff-disk]				*/
/* 																								*/
/* 																								*/
/*	int InitFileInfo( char *szFileName, struct MULT_FILES *FileStruc,			*/
/*							int iIsHdDisk )													*/
/* 																								*/
/* ARGUMENTS:	szFileName	- The name of the file to initialize				*/
/*					FileStruc	- Array of MULT_FILES strucs to be filled in 	*/
/* 				iDisk 		- Distribution disk number to be copied			*/
/* 				iIsHdDisk	- Signals destination is a hard drive				*/
/* RETURNS: 	int			_ OK if file gets copy else ERROR for no copy	*/
/* 																								*/
/***************************************************************************/

int near InitFileInfo( char *szName, struct MULT_FILES *File, int iDisk,
							  int IsHdDisk )
{
											/* Determine destination information		*/

	if ( (File->Name.Destin = GetRealDestName( szName )) == NULL )
		return( ERROR );				/* Don't copy was specifed for this file  */

	File->Path.Destin = GetRealDestPath( File->Name.Destin,
													 vInfo.szPath + 2 );
	File->UserDisk = IsHdDisk ? NOT_REMOVEABLE : iDisk;/* User's disk			*/
	File->Drive.Destin = vInfo.chDestin;					/* Set drive letter	*/

														/* Determine source information	*/
	if ( (File->Name.Source = GetRealSrcName( szName )) == NULL )
		return( ERROR );

															/* Set path to distrib files 	*/
	File->Path.Source =  vInfo.szSource + 2;
													/* Distrib disk checking for a path	*/

	File->DiskNumber =  GetRealSrcDisk( File->Name.Source, iDisk );
	if ( vInfo.chSource >= vInfo.chFirstHd )
		File->DiskNumber = NOT_REMOVEABLE;

	File->Drive.Source = vInfo.chSource;					/* Set drive letter	*/

	return( OK );
}

/***************************************************************************/
/* Copies the command.com file from the root dir into the DOS dir.			*/
/* 																								*/
/* void CopyCommandCom( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/*	m108	-	Changed so DOSSHELL.INI is copied from OLD_DOS.xxx if exists	*/
/***************************************************************************/

void near CopyCommandCom( void )
{
// m108	struct MULT_FILES 	File[2];
	struct MULT_FILES 	File[ 3 ];											/* m108	*/
	static char				*szFileName = "COMMAND.COM";
	extern char				*szRootPath;
	char						szPath[ MAX_PATH_LEN ];							/* m108	*/
	static char				*szDosShell = "DOSSHELL.INI";					/* m108	*/

// m108	memset( File, 0, sizeof( struct MULT_FILES ) * 2 );
	memset( File, 0, sizeof( struct MULT_FILES ) * 3 );				/* m108	*/

	File[ 0 ].Name.Destin = File[ 0 ].Name.Source = szFileName;
	File[ 0 ].Path.Destin = vInfo.szPath + 2;
	File[ 0 ].Path.Source = szRootPath;
	File[ 0 ].UserDisk = File[ 0 ].DiskNumber = NOT_REMOVEABLE;
	File[ 0 ].Drive.Destin = File[ 0 ].Drive.Source = vInfo.chDestin;

					/* m108 If DOSSHELL.INI exists in OLD_DOS, copy to DOS dir	*/
	BuildPath( szPath, vInfo.szTmpDir[0], vInfo.szTmpDir + 2,szDosShell );/* m108	*/
	if ( FileExists( szPath ) )												/* m108	*/
	{																					/* m108	*/
		File[ 1 ].Name.Destin = File[ 1 ].Name.Source = szDosShell;	/* m108	*/
		File[ 1 ].Path.Destin = vInfo.szPath + 2;
		File[ 1 ].Path.Source = vInfo.szTmpDir + 2;							/* m108	*/
		File[ 1 ].UserDisk = File[ 1 ].DiskNumber = NOT_REMOVEABLE;	/* m108	*/
		File[ 1 ].Drive.Destin = File[ 1 ].Drive.Source = vInfo.chDestin;/* m108*/
	}																					/* m108	*/

//	Xcopy( File );

	CopyFiles( (int)NULL, File );

}	

/***************************************************************************/
/* Creates a unique file name on the specified drive in the specified		*/
/* directory and then deletes the file and returns the name, including		*/
/* the path in a buffer supplied by the caller. The name will be a			*/
/* an acii number between "0" and "999". If the file can't be created		*/
/* the program will be aborted with a FatalError() call.							*/
/*																									*/
/* void CreatUniqueName( char chDrive, char *szPath, char *szName )			*/
/*																									*/
/* ARGUMENTS:	chDrive		- Drive letter	for the unique file.					*/
/*					szPath		- Directory path for the unique file.				*/
/*					szname		- Buffer to store the complete file pathname		*/
/* RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void CreatUniqueName( char chDrive, char *szPath, char *szName )
{
	int		i, iHandle;

			/* Create the path string */
	*szName = chDrive;
	*(szName + 1) = ':';
	*(szName + 2) = '\\';
	strcat( szName + 2, szPath );

				/* Keep trying to create a file with an ascii number name */
	for( i = 0; i < 1000; i++ )
	{
		itoa( i, szName + 3, 10 );
		if ( (iHandle=creat( szName, S_IREAD | S_IWRITE )) != -1 )
		{
			if ( close( iHandle ) != OK )
				FatalError( ROOT_DIR_FULL );
			break;
		}
	}
				/* If i < 1000 we created a file so now delete it */
	if ( i < 1000 && unlink( szName ) == OK )
		;
	else
		FatalError( ERROR_DELETING_TMP_FILE );
}

/***************************************************************************/

static char		szTmp1[25];
static char		szTmp2[25];

/***************************************************************************/

/***************************************************************************/
/* Creates 2 tmp files in the root directory. This is to act as place		*/
/* holders in case the first 2 directory entries are free so that creating	*/
/* the OLDDOS the DOS directory and the OLD_DOS directory do not take		*/
/* get allocated these 2 entries.														*/
/*																									*/
/*	void CreatTmpTwo( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void CreatTmpTwo( void )
{
	extern char		*szRootPath;

	CreatUniqueName( vInfo.chDestin, szRootPath, szTmp1 );
	CreatUniqueName( vInfo.chDestin, szRootPath, szTmp2 );
}

/***************************************************************************/

void DeleteTmpTwo( void )
{
	remove( szTmp1 );
	remove( szTmp2 );
}

/***************************************************************************/
/* Deletes all of the DISK.NUL files in the OLD_DOS.xxx directory. The		*/
/* function should be called after writing the final master boot record		*/
/* onto the destination hard disk.														*/
/*																									*/
/*	void DeleteNulFiles( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void near DeleteNulFiles( void )
{
	char				szPath[ MAX_PATH ];
	char				*szName;
	register			i;

	BuildPath( szPath, vInfo.szTmpDir[0], vInfo.szTmpDir + 2, "" );
	szName = ParseFileName( szPath );
	strcpy( szName, "DISK" );

	for ( i = 0; i <= MAX_DISK; i++ )
	{													/* Delete all DISKxx.NUL files */
			itoa( i, szName + 4, 10 );
			strcat( szName, ".NUL" );
			DisplayFileStatus( szName, DELETE );
			AbsUnlink( szPath );
	}
}

/***************************************************************************/
/* Creates the readme.now file in the OLD_DOS.xxx directory. 					*/
/*																									*/
/*	void CreateReadMe( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void near CreateReadMe( void )
{
	char			szPath[ MAX_PATH ];
	char			*Buf;
	int			iFile;
	unsigned		uToWrite;
	unsigned		uWritten;
	
	Buf = GetMemory( 2000 );
	GetReadMeText( Buf );

	BuildPath( szPath, vInfo.szTmpDir[0], vInfo.szTmpDir + 2, README_FILE );
	DisplayFileStatus( README_FILE, WRITE );

	uToWrite = strlen( Buf );
	if ( _dos_creat( szPath, 0, &iFile ) != OK ||
		  _dos_write( iFile, Buf, uToWrite, &uWritten) != OK ||
		  uToWrite != uWritten ||
		 _dos_close( iFile ) != OK )
		FatalError( FATAL_HD_WRITE_ERROR );

	UpdateFileBar( 1 );

	FreeMemory( Buf );
}


/***************************************************************************/
/* Expands the backup directory created to store the user's old DOS files	*/
/* in. The directory needs to be expanded before we save the FAT so that	*/
/* it will be reflected in the saved FAT. The directory is expanded by		*/
/* creating MAX_DOS_FILES number of zero lenght files in it. If the			*/
/* directory can't be expanded as would be reflected by an error in			*/
/* in creating one of the files, the program will be aborted with a call	*/
/* to FatalError(). All files which are created are also deleted.				*/
/*																									*/
/* void ExpandRupDir( void )																*/
/*																									*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void ExpandRupDir( int iTotalFiles )
{
	char		*szName;
	char		*szFile;

	int		i;
	int		iHandle;
	int		Status;

	Status = OK;

	szName = vInfo.szTmpDir;				/* Use existing path buf for the 	*/
	szFile = strchr( szName, EOL );		/* file path								*/
	strcpy( szFile, "\\RUP" ); 			/* Append RUP to path					*/

					/* Create each new file and then close it */

	for( i = 0; Status == OK && i < iTotalFiles; i++ )
	{
		itoa( i, szFile + 4, 10 );
		if ( (iHandle = creat( szName, S_IREAD | S_IWRITE )) != -1 )
			close( iHandle );
		else
			Status = ERROR;
	}

	while( Status == OK && --i >= 0 )	/* Close any files we created 		*/
	{
		itoa( i, szFile + 4, 10 );
		if ( unlink( szName ) != OK )
			Status = ERROR;
	}	

	if ( Status != OK )
		FatalError( BAD_TMPDIR );

	*(szFile) = EOL;				/* Restore EOL at end of original path name	*/
}

/***************************************************************************/
/* Deletes all files remaining in the TmpDos directory and then deletes		*/
/* the directory entry.																		*/
/*																									*/
/*	void DelTmpFiles( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		VOID																			*/
/*																									*/
/***************************************************************************/

void near DelTmpFiles( void )
{
	register				iStatus;
	char					szFile[ MAX_PATH ];
	struct find_t		Info;

	BuildPath( szFile, szTmpDos[ 0 ], szTmpDos + 2, "*.*" );

	for ( iStatus = (int)_dos_findfirst( szFile, _A_FINDALL|_A_NORMAL, &Info );
			iStatus == OK;
			iStatus = (int)_dos_findnext( &Info ) )
	{
		BuildPath( szFile, szTmpDos[ 0 ], szTmpDos + 2, Info.name );
		AbsUnlink( szFile );
	}

	/* Make current directory something other than the one we're deleting */
	chdir( vInfo.szTmpDir );

	rmdir( szTmpDos );

	UpdateFileBar( 2 );
}

#ifdef LOGGING

/* void FAR LogProgress(char *pszInfo);
 *
 * Function is used to log progress information. Used in debug and
 * special "LOGGING = ON" mode.
 *
 */
void FAR LogProgress(char *pszInfo)
{
   static BOOL bLogCreated = 0;
	static char	CrLf[ 3 ] = { CR, LF, EOL };
   char        szTmp[256];
	int			iFile;
	unsigned		uToWrite;
   unsigned    uWritten;
	
   strcpy( szTmp, pszInfo );
   strcat( szTmp, CrLf );
	uToWrite = strlen( szTmp );

   if (! bLogCreated ) {
      _dos_creat("c:\\dos2gui.log", 0, &iFile );
      bLogCreated = TRUE;
   }
   else
      _dos_open("c:\\dos2gui.log", O_WRONLY, &iFile);

   lseek(iFile, 0L, SEEK_END);  // Seek to the end of the file.

   _dos_write( iFile, szTmp, uToWrite, &uWritten);
   _dos_close( iFile );
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\towin.c ===
#include		"winenv.h"
#include		"ws.h"
#include		"wsrc.h"
#include		"pro.h"
#include		"lib\\common\\sulib.h"

typedef		unsigned char		UCHAR;
#include		<ctype.h>
#include		<string.h>
#include 	<copy.h>
#include		<strlib.h>
#include		<errors.h>

/***************************************************************************/

#define		OK								0
#define		FATAL_MEMORY_ERROR		0
#define		MAX_PATH_LEN				128
#define		READ							0

#define		FATAL_DLL_LOAD_ERROR		28

extern char					szTmpDos[ MAX_PATH_LEN ];
extern unsigned char 	gInstallMode;	
extern int              CreatingRecovery; /* Signals creating Uninstal disk	*/


/***************************************************************************/
/*
**	Windows area functions
*/

WORD PUBLIC wsCopyStatus(int msg, int n, LPSTR szFile);
//BOOL PUBLIC AppQuit( void );

VOID FAR PASCAL fdos_dskreset( void );

/***************************************************************************/
/*
**	DOS area functions
*/

void		InitUninstallDisk	   ( int iUninstallDiskNum );
void		FatalError				( int ErrorType );
int		WinDiskNum				( int DosDiskNum );
void		ProcessCopyError		( char *szFile, int ErrNo );
void		DisplayFileStatus		( char *szFile, int Type );

void 		InsertDisk( int DskNum );

/***************************************************************************/
/*			 	
**	GLobals
*/

static int	gDiskNum;
struct MULT_FILES *gFiles;

int iUninstallDiskNum;   /* Always contains the uninstall disk number. (Zero Based) */

/***************************************************************************/
/*
**	Windows publics
*/

extern int	   XDosCopy;			/* Defined in Windows setup copy.c	*/
extern char		szDosDesName[];	/* Defined in Windows setup copy.c	*/

/***************************************************************************/

void *GetMemory( unsigned uMemSize )
{
	HANDLE	Ptr;

	if ( (Ptr = LocalAlloc( LMEM_FIXED, (WORD)uMemSize )) != NULL )
		return( (void *)Ptr );
	else
		FatalError( FATAL_MEMORY_ERROR );
}

/***************************************************************************/

void FreeMemory( void *Ptr )
{
	if ( LocalFree( (HANDLE)Ptr ) != NULL )
		FatalError( FATAL_MEMORY_ERROR );
}

/***************************************************************************/

void FatalError( int ErrorType )
{
	extern	iWillReboot;

	wsFatalError( ErrorType, iWillReboot );
	AppQuit();
}

/***************************************************************************/

void Xcopy( struct MULT_FILES *Files )
{
	#define			COPY_FLAGS			(FC_QUALIFIED | FC_DEST_QUALIFIED)
	char				szSource[ MAX_PATH_LEN ];
	char				szDestin[ MAX_PATH_LEN ];
	char				*szPtr;
	int				iDiskNum;

	XDosCopy = TRUE;

   gFiles = Files;
	if ((iDiskNum = Files->DiskNumber) != gDiskNum)  
		InsertDisk(gDiskNum = iDiskNum);

	while ( Files->Name.Source != NULL )
	{
		gFiles = Files;
		gDiskNum = Files->DiskNumber;
		if (iDiskNum != gDiskNum)
			// This file is on a different distribution disk. Prompt for it.
			InsertDisk(iDiskNum = gDiskNum);

		BuildPath( szSource, Files->Drive.Source, Files->Path.Source,
					  Files->Name.Source );
			
		BuildPath( szDestin, Files->Drive.Destin, Files->Path.Destin, "" );

		szPtr = strchr( szDestin, EOL );
		if ( szPtr > (szDestin + 3) )
			*(--szPtr) = EOL;				/* Strip trailing backslash	*/

							/* Set destination file name Windows copy will use	*/
		strcpy( szDosDesName, Files->Name.Destin );

		if ( CreatingRecovery )
			InitUninstallDisk(iUninstallDiskNum);

		DisplayFileStatus( szDosDesName, READ );

      if ( FileCopy(szSource,szDestin,(FPFNCOPY)wsCopyStatus,COPY_FLAGS) && CreatingRecovery )
			ProcessCopyError( ParseFileName( szSource ), ERR_PROCESSING );

		Files++;
	}
	XDosCopy = FALSE;

	#undef		COPY_FLAGS
}		

/***************************************************************************/
/*																									*/
/*		Routine Name		: PromptForDisk												*/
/*																									*/
/*																									*/
/***************************************************************************/

void PromptForDisk( char chSourceDrv )
{
	static char		szPath[] = "X:\\";

	szPath[ 0 ] = chSourceDrv;
	wsInsertDisk( (LPSTR) szPath );

   wsYield(NULL); // Allow repaint to erase disk prompt dialog.
}

/***************************************************************************/

void PromptForUninstall(char *szUserLabel )
{
	wsInsertUninstall(szUserLabel);

   wsYield(NULL); // Allow repaint to erase uninstall disk prompt.
}

/***************************************************************************/

void FmtStat( unsigned uTrack, unsigned uHead )
{
	register				Percent;
	static unsigned	uTotalTrks;

	if ( uHead == (unsigned)-1 )
	{												/* Display dialog box at 0%		*/
		uTotalTrks = uTrack;					/* Save total number of tracks	*/
		wsFmtDlgOpen();
	}
	else if ( uTrack == (unsigned)-1	) {
		wsFmtDlgClose();						/* Remove status dialog	*/
      wsYield(NULL);                   // Yield a bit to fix unsightly re-paint delay.
   }
	else
	{												/* Update status dialog percentage	*/
		Percent = (int)( (long)(uTrack + 1) * 100L / (long)(uTotalTrks) );
		wsFmtDlgUpdate( Percent );
	}
}

/***************************************************************************/

void ProcessCopyError( char *szFile, int ErrorType )
{
	extern int		CreatingRecovery;

	wsDosCopyError( szFile, ErrorType, CreatingRecovery );

	if ( CreatingRecovery )
		AppQuit();
}

/***************************************************************************/
/* The drive letter argument is not needed in the DOS/Windows Setup			*/
/* because the only removeabale drive that is ever accessed will be A:.		*/
/***************************************************************************/

void WriteProtectPrompt( char Disk )
{
   wsNonFatalError( IDS_WRITEPROTECT );
}

/***************************************************************************/

void NotReadyPrompt( char Disk )
{
   wsNonFatalError( IDS_NOTREADY );
}

/***************************************************************************/

int PromptForDiskFmt( int iDriveType )
{
	return( (int)wsSelectDskFmt(iDriveType) );
}

/***************************************************************************/
/***************************************************************************/

void ProcessDiskError( int iErrorType )
{
	iErrorType--;						/* Convert to Zero based message offset	*/
	wsNonFatalError( iErrorType );
}

#if 0

/***************************************************************************/
/* Interface function which calls the Windows Setup copy function.			*/
/*																									*/
/*	int WinFileCopy( char *szSource, char *szDestPath, char *szName );		*/
/*																									*/
/*	ARGUMENTS:	szSource		- Source file and disk number "1:msdos.sys"		*/
/*					szDestPath	- Fully qualified destination path only			*/
/*					szName		- Destination file name									*/
/*	RETURNS:		int			- OK if no errors else !OK								*/
/*																									*/
/***************************************************************************/

int WinFileCopy( char *szSource, char *szPath, char *szName )
{
	#define		COPY_FLAGS			(FC_FILE | FC_DEST_QUALIFIED)
	int			iStatus;


	XDosCopy = TRUE;
	strcpy( szDosDesName, szName );
	szSource[ 0 ] = (char)WinDiskNum( (int)szSource[ 0 ] ); 


	DisplayFileStatus( szDosDesName, READ );

	iStatus = FileCopy( szSource, szPath, (FPFNCOPY)wsCopyStatus,
							  COPY_FLAGS );
	XDosCopy = FALSE;
	return( iStatus );

	#undef		COPY_FLAGS
}

/***************************************************************************/
/***************************************************************************/

int WinDiskNum( int iDosDiskNum )
{
	char		szNum[ MAX_INF_LINE_LEN ];	
	int		iFirstDosDisk;	

	infGetProfileString( NULL, "data", "firstdosdisk", szNum );
	iFirstDosDisk = atoi( szNum );
	return( iDosDiskNum + iFirstDosDisk );
}

#endif

/***************************************************************************/
/* Displays the status of the current file in a the Windows dialog.			*/
/*																									*/
/*	void DisplayFileStatus( char *szFile, int Type )								*/
/*																									*/
/*	ARGUMENTS:	szFile	- Ptr to current file's name.								*/
/*					Type		- Type of file processing.									*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void DisplayFileStatus( char *szFile, int Type )
{
	char			szName[ 25 ];

	strcpy( szName, szFile );

	#if 0
		char			*szPtr;
		char			ch;	

		if ( (szPtr = strchr( szName, '.' )) != NULL )	/* Delete file extension*/
			*szPtr = EOL;
		strlwr( szName );
	#endif

	strupr( szName );

	ProPrintf( ID_STATUS2, wsLoadSz( IDS_FSTATUS + Type, NULL, NULL ),
				  (LPSTR)szName );
}

/***************************************************************************/
/* Windows code interface function to update the file copy gage by a			*/
/* specified number of files.																*/
/*																									*/
/*	void UpdateFileBar( int iFiles )														*/
/*																									*/
/*	ARGUMENTS:	iFiles	- Number of files to add to bar position				*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void UpdateFileBar( int iFiles )
{
	ProDeltaPos( iFiles );
}

/***************************************************************************/
/* Copies the README.NOW text from the resource file into the callers		*/
/* buffer, adding the proper carriage return - line feed extension to each	*/
/* line in the buffer.																		*/
/*																									*/
/*	void GetReadMeText( char *Buf )														*/
/*																									*/
/*	ARGUMENTS:	Buf		- Ptr to a buffer large enough to hold the entire	*/
/*								  README.NOW file.											*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void GetReadMeText( char *Buf )
{
	register			RcId;
	static char		CrLf[ 3 ] = { CR, LF, EOL };

	for ( *Buf = EOL, RcId = IDS_DOSREADME; RcId <= IDS_END_README; RcId++ )
	{
		lstrcat( Buf, wsLoadSz( RcId, NULL, NULL ) );
		lstrcat( Buf, CrLf );

	}
}

/***************************************************************************/
/***************************************************************************/

/*
int _dos_dskreset( void )
{
   char     		szDllName[MAX_SYS_INF_LEN];
	HANDLE			hLibrary;
	static int		iFirstTime = TRUE;
	static void		(FAR PASCAL *lpFunc)( void );

	if (GetWinFlags() & WF_PMODE )
		return( OK );

	if ( iFirstTime )
	{
		if ( !infGetProfileString( NULL, "data", "int13dll", szDllName ) ||
			  (hLibrary = LoadLibrary( szDllName )) < 32 ||
			  (lpFunc = GetProcAddress( hLibrary, "fdos_dskreset" )) == NULL )
			wsFatalError( FATAL_DLL_LOAD_ERROR,  FALSE );
		else
			iFirstTime = FALSE;
	}

	(*lpFunc)();
	return( OK );
}
*/

/***************************************************************************/
/***************************************************************************/

void wffree( void far *n )
{
	GlobalFree((HANDLE)HIWORD((LONG)n));
}

/***************************************************************************/
/***************************************************************************/
void far *wfmalloc( WORD n )
{
	return( (VOID FAR *)MAKELONG(0, GlobalAlloc(GPTR, (DWORD)n)) );
}

/***************************************************************************/
/***************************************************************************/

void ForceExitReboot( void )
{
	fExit |= EF_NOEXIT;
}


void XHcopy( struct MULT_FILES *Files ,char * szTmpDos)
{
	#define			COPY_FLAGS			(FC_QUALIFIED | FC_DEST_QUALIFIED)
	char				szSource[ MAX_PATH_LEN ];
	char				szDestin[ MAX_PATH_LEN ];
	char				*szPtr;

	gFiles = Files;
	ProPrintf(ID_STATUS1, wsLoadSz(IDS_WAITCOPYRECHD,NULL,NULL));	
	XDosCopy = TRUE;
	InsertDisk(gDiskNum = Files->DiskNumber);

	while ( Files->Name.Source != NULL )
	{
		gFiles = Files;
		BuildPath( szSource, Files->Drive.Source, Files->Path.Source,
					  Files->Name.Source );

		BuildPath( szDestin, szTmpDos[0], szTmpDos + 2, "" );

		szPtr = strchr( szDestin, EOL );
		if ( szPtr > (szDestin + 3) )
			*(--szPtr) = EOL;				/* Strip trailing backslash	*/

	  	/* Set destination file name Windows copy will use	*/
		strcpy( szDosDesName, Files->Name.Destin );

		DisplayFileStatus( szDosDesName, READ );

      if ( FileCopy(szSource,szDestin,(FPFNCOPY)wsCopyStatus,COPY_FLAGS) && CreatingRecovery )
			ProcessCopyError( ParseFileName( szSource ), ERR_PROCESSING );

		Files++;
	}
	XDosCopy = FALSE;
	#undef		COPY_FLAGS
}

void CopyFiles( int id, struct MULT_FILES *Files )
{
	if ( id != NULL )
		ProPrintf(ID_STATUS1, wsLoadSz(id,NULL,NULL));	

	Xcopy(Files);
}


void ProPrintfStat1( int id )
{
		ProPrintf(ID_STATUS1, wsLoadSz(id,NULL,NULL));	
}
	


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\winenv.h ===
#include <windows.h>
#include <stdio.h>


/*
 *  macros used to define functions:
 *
 *	EXPORT	    - This function can be called from external to this DLL
 *		      but be sure to list it in you DEF file!
 *
 *	PUBLIC	    - This function can be called from another file
 *
 *	PRIVATE     - This function can only be called from inside this file
 *
 *  eg	  int EXPORT foo();
 */

#define EXPORT	    FAR  PASCAL
#define PUBLIC	    FAR  PASCAL
#define PRIVATE     NEAR PASCAL

#ifdef DEBUG
	#define WinAssert(exp)\
				{\
					if (!(exp))\
						{\
							char szBuffer[40];\
							sprintf(szBuffer, "File %s, Line, %d",\
								__FILE__, __LINE__);\
							if (IDABORT == MessageBox(NULL, szBuffer,\
															  "Assertion Error",\
																MB_ABORTRETRYIGNORE | \
																MB_ICONSTOP))\
								FatalExit(-1);\
						}\
				}
#else
   #define WinAssert(exp)  
#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\upgrade.h ===
/***************************************************************************/
/*                                                                         */
/* UPGRADE.H																					*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* Function prototypes and #defines for retail DOS 5.0 install program		*/
/*																									*/
/* Created 11-13-89 - johnhe																*/
/***************************************************************************/

#define	IADF_SUPPORT			1

#define	HD_BOOT_DRV				'C'
#define	REBOOT					1

#define	DO_MOVE					0
#define	DO_DELETE				1
#define	DO_COUNT 				2

#define	ASTid						0x14
#define	ATNTid					0x56
#define	TANDYid					0xe5
#define	UNISYSid					0xf2
#define	L_EDGEid					0x11
#define	NECid						0x24
#define	COMMODOREid				0x08

#define	DM_DRIVERid1			0x50
#define	DM_DRIVERid2			0x51

#define	AST_8_ENT_SIG			0x0A55A			/* Sig for AST 8 partitions*/
#define	AST_SIG_OFFSET			0x17c				/* Offset of AST signature	*/
#define	AST_TABLE_OFFSET		0x17e				/* Offset of AST part table*/

#define	IADF_SIG					0x5a5a
#define	IADF_SIG_OFFSET		0x1bc

#define	MULTI_DOS_PARTS		1
#define	MULTI_FLOPPY			2
#define	BAD_CONFIG_FILE		3

#define	HD_READ_ERROR			10
#define	TOO_MANY_PARTS			11
#define	NO_BOOT_LETTER			12
#define	FUNNY_PARTITION		13
#define	ROOT_FULL				14
#define	DISK_FULL				15
#define	NOT_COMPAT_PART		16

#define	PRIAM_DETECTED			17
#define	VFEATURE_DETECTED		18
#define	SYQUEST_DETECTED		19
#define	IADF_DETECTED			20
#define	EVEREX_DETECTED		21
#define	SPEEDSTOR_DETECTED	22
#define	DISKMAN_DETECTED		23

#define	NOT_HDISK				FALSE

#define	BAD_PART_LIST { 0x50, 0x51,\
								 0x61, 0x63, 0x64, 0x66,\
								 0x71, 0x73, 0x74, 0x76,\
								 0xe1, 0xe3, 0xe4, 0xe6,\
							    0xf1, 0xf3, 0xf4, 0xf6,\
								 0x21, 0x23, 0x24, 0x26,\
								 0x31, 0x33, 0x34, 0x36,\
								 0xa1, 0xa3, 0xa4, 0xa6,\
								 0xb1, 0xb3, 0xb4, 0xb6 }
								 
															
/***************************************************************************/

extern char chArgSwitch[];

/***************************************************************************/

/* UPGRADE.C */

extern void 	UpgradeFloppy	( void );
extern void 	UpgradeHard 	( int iNullFile );
extern void 	SpecialIds		( void );
extern int		FileExists		( char *szFile );
extern int		MoveFiles		( int Type );
extern void 	MakeHidden		( char Drive );
/* FDUPGRAD.C */

extern  void FloppyDiskUpgrade(void );
extern  void FloppyEndPrompt(void );
extern  void GetVideoType( void );

/* FINDOEM.C */

extern void	SaveVenderInfo		( int iVender );
extern void	BestPathGuess		( void );
extern int	BestVenderGuess	( void );
extern void	BuildComspec		( void );
extern int	FindDosFiles		( char *szPath );

/* HDUPGRAD.C */
extern  void HardDiskUpGrade	( void );
extern  void far TooManyPartitions( int Number,int Drive );

/* INITIAL.C */
extern void	ProgramInitialize	(void );
extern int	RoomForSystem		( char chDrv );
extern void	ExpandRupDir		( int iTotalFiles );
extern void CreatUniqueName	( char chDrive, char *szPath, char *szName );
extern void	CreatTmpTwo			( void );
extern void DeleteTmpTwo		( void );


/* SETUP.C */
extern void CreateRecoveryFloppy( void );
extern void GetHdBpb			( struct BPB *Bpb );
extern void	CopyBuf			( char *szFile, void *pBuf, UINT uBytes );

/* SETVER.C */

extern void	UpdateLie		( void );

/* AUTO.C */
extern void	ProcessAuto		( void );
extern void MoveAutoConfig( void );

/* CONFIG.C */
extern void ProcessConfig	( void );

/* AUTOCONF.C */
extern char	*DefaultShellLine( char *szPtr );

/* HARDDISK.C */
extern int	HardDiskCheck	( void );
extern void GetSysFiles		( void );
extern int	GetPartEntries	( void );
extern void	WriteNewBoot	( int IsFinal );
extern unsigned RdWrSector	( int iDrv, int iHead, int iTrack, int iSector,
									  int RdWr );

/* FIXBOOT.C */
extern void	FixupBootRecs	( void );
extern int	GetPartEntries	( void );
extern int	IsValidPartTable( void );
extern int	IsCompatPart	( UCHAR SystemIndicator );

extern struct Part *FindExtPartEntry	( int Entries );
extern struct Part *GetPartTable		( int Entries );

/* Burnoulli */
extern int far IOMINIT			( void );
extern int far	IOMREM			( void );

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\ws.h ===
#define F_AUTOSTART 0x10

/*
 *  Exit flags.
 */
#define EF_RESTART  0x01        // User allowed option to start windows.
#define EF_REBOOT   0x02        // User needs to reboot
#define EF_DOS      0x04        // User should be returned to DOS
#define EF_NOEXIT   0x08		  // Can't allow an exit without rebooting

/*
 *   Work specification flags, used in DlgInit() calls.
 */

#define    DLGINIT_REMOVE_CLOSE_MENU    0x01

/* Misc stuff. */

#define MAXSTR             128
#define MAX_RES            256

extern WORD	fExit;
extern HWND hwndParent;
extern HANDLE hInstWS;

/*
 *  **** Publics living in WSEXIT.C ***
 */

void PUBLIC CleanUpDroppings(void);


// need to get these functions

WORD PUBLIC wsInsertDisk(LPSTR sz);
int  PUBLIC atoi(PSTR sz);


// Functions and global variables added for DOS/Windows merge defined in 
// wsdosdlg.c

extern BOOL	bIsQuick;
extern BOOL bIsUpgrade;

BOOL PUBLIC wsUninstallDlg( HWND, unsigned, WORD, LONG );
WORD PUBLIC wsInsertUninstall( char *szDiskLabel );
BOOL PUBLIC dsWelcomeDlg(HWND hDlg, unsigned uiMessage, WORD wParam, long lParam);

WORD PUBLIC wsSelectDskFmt( int iDriveType );

BOOL FAR PASCAL wsDskTypeDlg( HWND, unsigned, WORD, LONG );

void PUBLIC wsFatalError( WORD wType, WORD WillReboot ); 
BOOL FAR PASCAL wsFatalErrorDlg( HWND, unsigned, WORD, LONG );

void PUBLIC wsFmtDlgOpen( void );
void PUBLIC wsFmtDlgClose( void );
void PUBLIC wsFmtDlgUpdate( WORD wPercent );
BOOL FAR PASCAL wsFmtProDlg( HWND, unsigned, WORD, LONG );

void PUBLIC wsDosCopyError( char *szFile, WORD wErrorType, WORD Reboot );
BOOL FAR PASCAL wsDosCpyErrDlg( HWND, unsigned, WORD, LONG );

void PUBLIC wsDskError( WORD wErrorDlg );
BOOL FAR PASCAL wsDskErrorDlg( HWND, unsigned, WORD, LONG );

void PUBLIC wsDskPrepError( WORD wErrorType );
BOOL FAR PASCAL wsDskPrepErrorDlg( HWND, unsigned, WORD, LONG );

BOOL FAR PASCAL wsQueryStartDlg( HWND, unsigned, WORD, LONG );

BOOL FAR PASCAL wsBadDosExitDlg( HWND, unsigned, WORD, LONG );

void PUBLIC wsNonFatalError( WORD wMsgID );
void PUBLIC wsFatalError( WORD wType, WORD WillReboot );

void PUBLIC dsEndWait(void);
void PUBLIC dsStartWait(void);

/* RESOLVE.C */

int	FAR    fDialog(int, HWND, FARPROC);
int   FAR    fDialogWithlParam(int, HWND, FARPROC, DWORD);
void  PUBLIC wsDlgInit(HWND hDlg, WORD wWorkFlags);
BOOL 	PUBLIC QueryExit(HWND);
BOOL 	PUBLIC wsYield(HWND);
PSTR 	PUBLIC wsLoadSz(int ids, PSTR pch, int iBufLen);
void 	PUBLIC EnableExit(BOOL); /*BUGBUG is this required*/
void	PUBLIC AppQuit(void);
BOOL 	PUBLIC wsDiskDlg(HWND,unsigned,WORD,LONG);
BOOL 	PUBLIC wsErrorDlg(HWND,unsigned,WORD,LONG);
int  	PUBLIC atoi(PSTR sz);
BOOL 	PUBLIC wsExitDlg(HWND,unsigned,WORD,LONG);

void GetDPTVec(void);
LONG EXPORT wsDefSetupDlgProc(HWND, WORD, WORD, LONG);
BOOL PUBLIC wsExitInit(void);
VOID PUBLIC wsExitTerm(HWND);



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\wsdosdlg.c ===
#include <winenv.h>
#include "ws.h"
#include "wsrc.h"
#include "pro.h"
#include "lib\\common\\sulib.h"

/*-------------------------------------------------------------------------*/
/* The following code was added to support the DOS/Windows merge				*/
/*-------------------------------------------------------------------------*/

#define	FMT_UPDATE			500

WORD		wFatalErrorType;		/* Used by wsFatalError()	*/
WORD  	wWillReboot;			/* Used by wsFatalError()	*/

HANDLE	hFmtWnd;					/* Handle to format status dialog		*/

FARPROC	fpxFmtProDlg;			/* Ptr to fmt status handler instance	*/
PSTR		szFmtStatus[ MAXSTR / 2 ];
PSTR		szPercent[ MAXSTR / 2 ];

WORD		wCpyErrorType;
WORD		wWillExit;
PSTR		szErrorStr[ MAXSTR / 2 ];
PSTR		szFileName[ MAXSTR / 2 ];

WORD     wPrepErrType;
HCURSOR  hSavedCur = NULL;

/*-------------------------------------------------------------------------*/
/*	Function which prompts the user to insert the disk they labeled			*/
/* Uninstall into drive A:.																*/
/* 																								*/
/* WORD PUBLIC wsInsertUninstalDisk( void )											*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:																						*/
/*     OK (0) if user pressed OK key else												*/
/*-------------------------------------------------------------------------*/

WORD PUBLIC wsInsertUninstall(char *szUserLabel )
{
	return ( (WORD)fDialogWithlParam( DLG_UNINSTALL,GetActiveWindow(),
									          wsUninstallDlg, (LONG)((LPSTR)szUserLabel) ) );
}

/*-------------------------------------------------------------------------*/
/*	wsUninstallDlg( hDlg, uiMessage, wParam, lParam )                       */
/*	                                                                        */
/*	Arguments:                                                              */
/*	    hDlg            window handle of about dialog window                */
/*	    uiMessage       message number                                      */
/*	    wParam          message-dependent                                   */
/*	    lParam          message-dependent                                   */
/*	                                                                        */
/*	Returns:                                                                */
/*	    TRUE if message has been processed, else FALSE                      */
/*	                                                                        */
/*-------------------------------------------------------------------------*/

BOOL FAR PASCAL wsUninstallDlg(HWND hDlg,unsigned uiMessage,WORD wParam,long lParam)
{
   char    szTmp1[200];
   char    szTmp2[200];

	switch (uiMessage)
	{
		case WM_COMMAND:
			switch (wParam )
			{
				case ID_OK:
					EndDialog( hDlg, 0 );
					break;

				default:
					break;
			}
			return TRUE;

		case WM_INITDIALOG:
			wsDlgInit( hDlg, DLGINIT_REMOVE_CLOSE_MENU );
         GetDlgItemText(hDlg,ID_STATUS0,szTmp1,sizeof(szTmp1));
         wsprintf(szTmp2,szTmp1,(LPSTR)lParam);
         SetDlgItemText(hDlg,ID_STATUS0,szTmp2);
			MessageBeep( 0 );
			return TRUE;

		default:
			return( FALSE );
	}
}

/*-------------------------------------------------------------------------*/
/*	Function to display a dialog box to let the user select the proper		*/
/*	format for a 3.5" disk.                                                 */
/* 																								*/
/* WORD PUBLIC wsSelectDskFmt( void )                                      */
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:                                                                */
/*    0 if 720K, 1 if 1.44 MB, 2 if CANCEL                                 */
/*-------------------------------------------------------------------------*/

WORD PUBLIC wsSelectDskFmt( int iDriveType )
{

   return( fDialogWithlParam(DLG_FMTTYPE,GetActiveWindow(),wsDskTypeDlg,
                             (DWORD)iDriveType) );

}

/*-------------------------------------------------------------------------*/
/* Process messages sent to the dialog box DLG_DISKFMT_TYPE which allows	*/
/*	the user to select the proper format for a 3.5" disk.							*/
/*	                                                                        */
/*	wsUninstallDlg( hDlg, uiMessage, wParam, lParam )                       */
/*																									*/
/*	Arguments:                                                              */
/*	    hDlg            window handle of about dialog window                */
/*	    uiMessage       message number                                      */
/*	    wParam          message-dependent                                   */
/*	    lParam          message-dependent                                   */
/*                     at WM_INIT time, lParam will be iDriveType where    */
/*                                                                         */
/*                     iDriveType = 2 = 1.2mb floppy drive.                */
/*                     iDriveType = 4 = 1.44mb floppy drive.               */
/*	                                                                        */
/*	Returns: Return value will indicate choice of disk capacity chosen:     */
/*                                                                         */
/*          Return of 0 indicates lower density choice was made.           */
/*          Return of 1 indicates high density choice was made.            */
/*	                                                                        */
/*-------------------------------------------------------------------------*/

BOOL FAR PASCAL wsDskTypeDlg( HWND hDlg, unsigned uiMessage, WORD wParam,
										  long lParam )
{
	WORD		  wSelection;
   static int iSavDrvType;
	
	switch (uiMessage)
	{
		case WM_COMMAND:
			switch (wParam )
			{
				case ID_OK:
					if ( ! SendDlgItemMessage( hDlg, ID_LOW_DENSITY, BM_GETCHECK, 0, 0L ) )
						wSelection = 1;
               else
						wSelection = 0;
					EndDialog( hDlg, wSelection );
					break;

			}
			return TRUE;

		case WM_INITDIALOG:

         iSavDrvType = (int)LOWORD(lParam);

         if ( iSavDrvType == 2 ) {
            SetDlgItemText(hDlg, ID_HIGH_DENSITY, wsLoadSz(IDS_KB1200,NULL,0));
            SetDlgItemText(hDlg, ID_LOW_DENSITY, wsLoadSz(IDS_KB360,NULL,0));
         }
			wsDlgInit( hDlg, DLGINIT_REMOVE_CLOSE_MENU );

			/* Send messge to hi-lite top radio button (high capacity choice)	*/

			SendDlgItemMessage( hDlg, ID_HIGH_DENSITY, BM_SETCHECK, 1, 0L );
			MessageBeep( 0 );
			return TRUE;

		default:
			return( FALSE );
	}
}

/*-------------------------------------------------------------------------*/
/*	Opens the disk formatting status box on the screen and then calls the	*/
/*	format status update function to set the initial state to 0%.				*/
/*																									*/
/*	void PUBLIC wsFmtDlgOpen( void )														*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/*-------------------------------------------------------------------------*/

void PUBLIC wsFmtDlgOpen( void )
{
	
	fpxFmtProDlg = MakeProcInstance( (FARPROC)wsFmtProDlg, hInstWS );
	hFmtWnd = CreateDialog( hInstWS, MAKEINTRESOURCE( DLG_FMTSTATUS ),
									GetActiveWindow(), fpxFmtProDlg );

	ShowWindow( hFmtWnd, SHOW_OPENWINDOW );
	UpdateWindow( hFmtWnd );
	wsFmtDlgUpdate( 0 );
}   

/*-------------------------------------------------------------------------*/
/* Removes the format status box from the screen.									*/
/*																									*/
/*	void PUBLIC wsFmtDlgClose( void )													*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/*-------------------------------------------------------------------------*/

void PUBLIC wsFmtDlgClose( void )
{
	DestroyWindow( hFmtWnd );
	FreeProcInstance( fpxFmtProDlg );
}

/*-------------------------------------------------------------------------*/
/* Updates the percentage complete line in the format status dialog by		*/
/* sending a message to the window with the new percentage value.				*/
/*																									*/
/*	void PUBLIC wsFmtDlgUpdate( WORD wPercent )										*/
/*																									*/
/*	ARGUMENTS:	wPercent	-	Percentage of format that is complete.				*/
/*	RETURNS:		void																			*/
/*																									*/
/*-------------------------------------------------------------------------*/

void PUBLIC wsFmtDlgUpdate( WORD wPercent )
{
	SendMessage( hFmtWnd, FMT_UPDATE, wPercent, 0L );
}

/*-------------------------------------------------------------------------*/
/* Updates the percentage complete line in the format status dialog by		*/
/* sending a message to the window with the new percentage value.				*/
/*																									*/
/*	void PUBLIC wsFmtDlgUpdate( WORD wPercent )										*/
/*																									*/
/*	Arguments:                                                              */
/*		hDlg			Handle for the format status window								*/
/*		uiMessage	message number FMT_UPDATE or WN_INITDIALOG					*/
/*		wParam		If uiMessage == FMT_UPDATE the percentage complete value	*/
/*		lParam		Not used.																*/
/*	                                                                        */
/*	Returns:			TRUE if message was handled else FALSE							*/
/*																									*/
/*-------------------------------------------------------------------------*/

BOOL FAR PASCAL wsFmtProDlg( HWND hDlg, unsigned uiMessage, WORD wParam,
									  long lParam )
{
	switch ( uiMessage )
	{
		case WM_INITDIALOG:
			wsDlgInit( hDlg, 0 );
			wsLoadSz( IDS_PERCENT, (PSTR)szPercent , MAXSTR*2);
			/* 	MessageBeep( 0 ); */
			return( TRUE );

		case FMT_UPDATE:
			wsprintf( (LPSTR)szFmtStatus, "%d%s", wParam, (LPSTR)szPercent );
			SetDlgItemText( hFmtWnd, ID_STATUS0, (LPSTR)szFmtStatus );
			return( TRUE );

		default:
			return( FALSE );
	}
}

/*-------------------------------------------------------------------------*/
/* Displays a file copy error message in a dialog box and tells the user	*/
/*	the program will either continue to exit to DOS depending of the value	*/
/* of the argument WillReboot.															*/
/* 																								*/
/*	WORD PUBLIC wsDosCopyError( char *szFile, WORD wType, WORD WillReboot ) */
/*																									*/
/*	ARGUMENTS:																					*/
/*		szFile			Ptr to a file name												*/
/*		wErrorType		Enumerated error type											*/
/*		WillExit			Signals which exit message should be displayed			*/
/*							!0 will show reboot ELSE exit to DOS message				*/
/*	RETURNS:																						*/
/*																									*/
/*-------------------------------------------------------------------------*/

void PUBLIC wsDosCopyError( char *szFile, WORD wErrorType, WORD WillExit )
{
   char   szText1[512];
   char   szText2[512];
   char   szCaption[50];

	if ( wErrorType > MAX_DOSCPYERR )
		wErrorType = MAX_DOSCPYERR;

   wsLoadSz(IDS_CPYERRPREFIX, szText1 , sizeof(szText1));
   wsLoadSz(IDS_DOSCPYERROR + wErrorType, szText2 , sizeof(szText2));

   lstrcat(szText1,szText2);
   wsprintf(szText2, szText1, (LPSTR)szFile);

   if ( wWillExit ) {
      wsLoadSz(IDS_DOSERROPT + 1, szText1 , sizeof(szText1));
      wsLoadSz(IDS_FATAL_CAPTION, szCaption , sizeof(szCaption));
   }
   else {
      wsLoadSz(IDS_DOSERROPT, szText1 , sizeof(szText1));
      wsLoadSz(IDS_NONFATAL_CAPTION, szCaption , sizeof(szCaption));
   }
   lstrcat(szText2,szText1);
   
   MessageBox(GetActiveWindow(),szText2,szCaption,MB_OK|MB_SYSTEMMODAL|
              MB_ICONEXCLAMATION);
}

/*-------------------------------------------------------------------------*/
/*	Displays a generic error dialog on the screen. The caller passes the		*/
/* resourse ID number of the dialog to be displayed.								*/
/*                 																			*/
/*	void PUBLIC wsNonFatalError( WORD wMsgID )         							*/
/*																									*/
/*	ARGUMENTS:																					*/
/*		wMsgID 	   Resource ID of the dialog box to be displayed.				*/
/*	RETURNS:																						*/
/*     void																						*/
/*-------------------------------------------------------------------------*/

void PUBLIC wsNonFatalError( WORD wMsgID )
{
   char   szText1[512];
   char   szCaption[50];

   wsLoadSz(wMsgID,szText1,sizeof(szText1));
   wsLoadSz(IDS_NONFATAL_CAPTION,szCaption,sizeof(szCaption));

   MessageBox(GetActiveWindow(),szText1,szCaption,MB_OK|MB_SYSTEMMODAL|
              MB_ICONEXCLAMATION);

}

/*-------------------------------------------------------------------------*/
/* Displays a fatal error message in a dialog box and tells the user the	*/
/* program will exit either by a return to DOS or a reboot.						*/
/* 																								*/
/*	WORD PUBLIC wsFatalError( WORD wType, WORD WillReboot )						*/
/*																									*/
/*	ARGUMENTS:	wType			- Enumerated error type.								*/
/*					WillReboot	- Signals which exit message should be displayed*/
/*									  !0 will show reboot ELSE exit to DOS message	*/
/*	RETURNS:		VOID                                                        */
/*-------------------------------------------------------------------------*/

void PUBLIC wsFatalError( WORD wType, WORD WillReboot )
{
   char   szText1[512];
   char   szText2[256];
   char   szCaption[50];
   WORD   wMBflags;

   wsLoadSz(IDS_FERROR+wType,szText1,sizeof(szText1));
   wsLoadSz(IDS_FATAL_CAPTION,szCaption,sizeof(szCaption));
   wMBflags = MB_OK | MB_SYSTEMMODAL;

   if ( WillReboot ) {
	   wsLoadSz(IDS_FERRORABORT,szText2,sizeof(szText2));
      wMBflags |= MB_ICONSTOP;
   }
   else {
	   wsLoadSz(IDS_FERROREXIT,szText2,sizeof(szText2));
      wMBflags |= MB_ICONEXCLAMATION;
   }

   lstrcat(szText1,"\n\n");
   lstrcat(szText1,szText2);

   MessageBox(GetActiveWindow(),szText1,szCaption,wMBflags);
}

/*----------------------------------------------------------------------------*\
|   wsQueryStartDlg( hDlg, uiMessage, wParam, lParam )                         |
|                                                                              |
|   Queries the user if they want Windows started at boot time.
|
|   Returns:                                                                   |
|       TRUE if message has been processed, else FALSE                         |
|                                                                              |
\*----------------------------------------------------------------------------*/

BOOL FAR PASCAL  wsQueryStartDlg( HWND hDlg, unsigned uiMessage, WORD wParam,
											 long lParam )
{
    WORD    fOptions;

	switch (uiMessage)
	{
		case WM_COMMAND:
			switch (wParam)
			{
				case ID_AUTOSTART:
					CheckDlgButton( hDlg, wParam, !IsDlgButtonChecked( hDlg, wParam ) );
					break;

				case ID_OK:
					fOptions = 0;
					if ( IsDlgButtonChecked( hDlg, ID_AUTOSTART ) )
						fOptions = F_AUTOSTART;
					EndDialog( hDlg, fOptions );
					return( TRUE );

				case ID_CANCEL:
					    // make this the same as pressing F3
					if ( QueryExit(NULL) )
					{
						EndDialog(hDlg, 0);
						AppQuit();
					}
					break;
			}
			return TRUE;

		case WM_INITDIALOG:
			wsDlgInit(hDlg, DLGINIT_REMOVE_CLOSE_MENU);
			CheckDlgButton( hDlg, ID_AUTOSTART, TRUE );
#ifdef NEED_FIX
			wsHelp( DLG_WINSETUP );
#endif
		return( TRUE );
	}
	return( FALSE );
}


/*-------------------------------------------------------------------------*/
/*	wsBadDosExitDlg( hDlg, uiMessage, wParam, lParam )                       */
/*	                                                                        */
/*	Arguments:                                                              */
/*	    hDlg            window handle of about dialog window                */
/*	    uiMessage       message number                                      */
/*	    wParam          message-dependent                                   */
/*	    lParam          message-dependent                                   */
/*	                                                                        */
/*	Returns:                                                                */
/*	    
/*	                                                                        */
/*-------------------------------------------------------------------------*/

BOOL FAR PASCAL wsBadDosExitDlg( HWND hDlg, unsigned uiMessage, WORD wParam, long lParam )
{

	switch (uiMessage)
	{
		case WM_COMMAND:
			switch (wParam )
			{
				case ID_EXITSETUP:
					EndDialog( hDlg, TRUE );
					AppQuit();
					break;

				case ID_OK:
					EndDialog( hDlg, FALSE );
					break;

				default:
					break;
			}
			return FALSE;

		case WM_INITDIALOG:
			wsDlgInit( hDlg, 0 );
			MessageBeep( 0 );
			return TRUE;

		default:
			return( FALSE );
	}
}

#if 0

/* BOOL PUBLIC dsWelcomeDlg(HWND hDlg, unsigned uiMessage, WORD wParam, long lParam);
 *
 * Dialog proc for welcome UI. Explane about the process, need for an
 * uninstall disk. Allow user access to help or quit. Pretty generic DlgProc
 * since help and exit are handled for this class.
 *
 * Used with template DLG_UNINSTALLINFO. Dialog is of CLS_MYDLGS.
 *
 * ENTRY:  hDlg            window handle for this dialog window.
 *         uiMessage       message for us.
 *         wParam          message-dependent                   
 *         lParam          message-dependent                   
 *
 * EXIT: BOOL as per message processing. TRUE to user if we processed.
 *                                       FALSE to user if we did not process.
 *
 *       EndDialog() return is not important.
 */
BOOL PUBLIC dsWelcomeDlg(HWND hDlg, unsigned uiMessage, WORD wParam, long lParam)
{
	switch (uiMessage) {
		case WM_COMMAND:
			switch (wParam){
				case ID_OK:
					EndDialog(hDlg,0);
					break;

				default:
					break;
			}
			return TRUE;

		case WM_INITDIALOG:
			wsDlgInit( hDlg, DLGINIT_REMOVE_CLOSE_MENU );
			return TRUE;

		default:
			return( FALSE );
	}
}

#endif

/* void PUBLIC dsStartWait(void);
 *
 * Turn the DosSetup cursor to a hour glass
 *
 * ENTRY: None.
 * EXIT: None.
 *
 */
void PUBLIC dsStartWait()
{
   HCURSOR  hCur;
        
   if ( hCur = LoadCursor(NULL,IDC_WAIT) )
      hSavedCur = SetCursor(hCur);
}

/* void PUBLIC dsEndWait(void);
 *
 * Turn the DosSetup cursor to an arrow.
 *
 * ENTRY: None.
 * EXIT: None.
 *
 */
void PUBLIC dsEndWait()
{
   if ( hSavedCur )
      SetCursor(hSavedCur);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\lib\common\decomp.h ===
/*******************************************************************
*****  Header for Decompression Library (condensed from API.H and RETCODES.H)
********************************************************************/

/*** API.H:  Extern procs for the decompression library. ***/

#ifndef WIN32
typedef int  SHORT;    // defined elsewhere for WIN32 version
typedef char CHAR;     // defined elsewhere for WIN32 version
#endif

typedef int (far * PFNWFROMW)(int);


extern BOOL FTerminateDecomp(void);


  /* procedures in SUDECOMP.LIB */
extern  SHORT   far  WReadHeaderInfo(int fhSrc);
extern  BOOL    far  FFreeHeaderInfo(void);
extern  LONG    far  LcbDecompFile(int fhSrc, int fhDest, LONG lcbDestMax,
                           LONG libStart, BOOL fHeaderAlreadyRead,
						   BYTE far * fpbBuf, LONG lcbBuf, PFNWFROMW pfn,
						   int cProgTicks, PFNWFROMW pfnYield);
extern  LONG    far  LcbDecompressToFile(int fhSrc, int fhDest, LONG lcbDestMax,
                           LONG libStart, BOOL fHeaderAlreadyRead);
extern  LONG    far  LcbDecompressToBuffer(int fhSrc, BYTE far * fpbBuf,
                           LONG lcbBuf, LONG libStart, BOOL fHeaderAlreadyRead);
extern  LONG    far  LcbCalculateDecompressedLength(int fhSrc,
                           BOOL fHeaderAlreadyRead);

  /* global variables for file header info before writing or after reading */
extern  SHORT   vwAlgType;
extern  LONG    vlcbSrcLength;
extern  BOOL    vfChecksum;
extern  USHORT  vusChecksum;
extern  USHORT  vcbArgs;
extern  BYTE *  vrgbArgs;
extern  CHAR    vszBaseName[9];
extern  CHAR    vszExtension[4];
extern  SZ      vszText;
extern  USHORT  vcbText;



/*** RETCODES.H:  Return Codes for compression module for Setup Toolkit. ***/

 
  /* error codes - quick check is anything less than rcNoError */
#define  rcNoError                 0     /* no errors */
#define  rcNoHeader              (-1)    /* no header (eg no magic value) */
#define  rcUnknownAlgType        (-2)    /* wAlgType doesn't match knowns */
#define  rcBadHeader             (-3)    /* header too short or bad value */
#define  rcFilenamesTooLong      (-4)    /* filenames bigger than 8.3 */

#define  rcReadError             (-5)    /* reading error with fhSrc */
#define  rcReadSeekError         (-6)    /* seeking error with fhSrc */

#define  rcWriteError            (-7)    /* writing error with fhDest */
#define  rcWriteSeekError        (-8)    /* seeking error with fhDest */
#define  rcDestPatchError        (-9)    /* patching error with fhDest */

#define  rcCompChecksumBad      (-10)    /* compressed checksums mismatch */
#define  rcDecompChecksumBad    (-11)    /* decompressed checksums mismatch */
#define  rcCompLengthBad        (-12)    /* compressed length mismatch */
#define  rcDecompLengthBad      (-13)    /* decompressed length mismatch */

#define  rcGenericCompError     (-14)    /* internal compression error */
#define  rcGenericDecompError   (-15)    /* internal decompression error */

#define  rcSplitSizeTooSmall    (-16)    /* split size too small for header */

#define  rcOutOfMemory          (-17)    /* unable to alloc a buffer */


  /* each code below here has a standard header */
#define  wAlgTypeNil             (-1)    /* no algorithm type (never found) */
#define  wAlgTypeZK1               2     /* Steve Zeck compression algorithm */
#define  wAlgTypeJJJ1              3     /* Jeff J. Johnson algorithm */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\wsrc.h ===
/*  defines for Janus resources live here. */

/*  These two window classes are used for the progress dialog and for
 *  dialogs needing sub-classed (code-free!) help and/or exit processing.
 */
#define PRO_CLASS      "PRO"
#define CLS_MYDLGS     "mydlg"

/*                                  
 *  Dialog control ID's             
 */
#define ID_NULL        -1  
#define ID_EDIT        11
#define ID_TEXT        12
#define WM_MYSETFOCUS  3999

/* STATIC TEXT FIELD ID's */

#define ID_STATUS0     4000
#define ID_STATUS1     (ID_STATUS0 + 1)
#define ID_STATUS2     (ID_STATUS0 + 2)
#define ID_STATUS3     (ID_STATUS0 + 3)
#define ID_STATUS4     (ID_STATUS0 + 4)
#define ID_STATUS5     (ID_STATUS0 + 5)           

/* BUTTON ID's */

#define ID_OK          1 /* These are equal to the defines in windows.h */
#define ID_CANCEL      2 /* These are equal to the defines in windows.h */
#define ID_ABORT       4
#define ID_RETRY       5
#define ID_IGNORE      6
#define ID_HELP        4100
#define ID_EXIT		  4101
#define ID_REBOOT      4112

/* RADIO BUTTON ID's */

#define ID_SEARCH       4300
#define ID_SPECIFY      4301
#define ID_MODIFY       4302
#define ID_REVIEW       4303
#define ID_NOMODIFY     4304
#define ID_HIGH_DENSITY 4305
#define ID_LOW_DENSITY  4306

/* Miscelaneous defines */

#define ID_EXITSETUP          8233  // Exit Setup Message, exit now! Really!

/* dialog resource IDs */

#define DLG_EXPRESSINSERTDISK 17
#define DLG_PROGRESS          18
#define DLG_COPYERROR         19
#define DLG_UNINSTALL         35
#define DLG_FMTTYPE           36
#define DLG_FMTSTATUS         39
#define DLG_AUTOSTART         43
#define DLG_DOSREBOOT         44
#define DLG_DOSCONFIGSYS      45
#define DLG_BADDOSEXIT        46
#define DLG_UNINSTALLINFO     47

/* strings IDs */

#define IDS_PLEASE_INSERT      306

#define 	IDS_COPYING     		 317
#define 	IDS_WAITCOPY    		 319
#define  IDS_WAITCOPYRECHD		 320
#define  IDS_WAITCOPYRECFL		 321
#define	IDS_WAITOLDDOS	 		 322
#define  IDS_WAITDEL				 323
#define	IDS_WAITREN				 324
#define  IDS_DISKS             325
#define  IDS_OEMDISKS          326
#define 	IDS_OUTOFDISK	 		 359
#define  IDS_INTO_DRIVE        487
#define  IDS_DOSCPYERROR       500  // Leave 500 - 507 unused. See dos2.rc line 172 for reason.
#define  IDS_FATAL_CAPTION     600
#define  IDS_NONFATAL_CAPTION  601
#define  IDS_NOTREADY          602
#define  IDS_WRITEPROTECT      603
#define	IDS_FERROR      		 700
#define  IDS_FERROREXIT  		 750
#define  IDS_FERRORABORT 		 751
#define	IDS_PERCENT		 		 760
#define	IDS_CPYERRPREFIX 		 770
#define  IDS_HELPFILE          775
#define  IDS_HELP_ERROR        777
#define  IDS_DOSERROPT   		 780
#define	IDS_DSKPREPERR  		 790
#define  IDS_DOS         		 799
#define  IDS_FSTATUS     		 800
#define  IDS_DOSREADME   		 810
#define  IDS_END_README        (IDS_DOSREADME  + 9)

#define  IDS_KB1200            900
#define  IDS_KB360             901

/* Misc #defines for DOS/Windows merge */

#define  ID_AUTOSTART    ID_STATUS0
#define	MAX_DOSCPYERR   6
#define  MAX_DSKPREPERR  3

/*
 *  String ID's (These are in groups of 16, as they will be stored by USER)
 */

#define IDS_EXITNOTSETUP         355
#define IDS_EXITCAP              357
#define IDS_HELP                1000
#define IDS_ERROR              20000


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\lib\common\copy.c ===
/*
 *  copy.c - Copy routine for WinDosSetup
 *  Todd Laney
 *
 *  Modification History:
 *  3/24/89  Toddla      Wrote it
 *
 *
 *  notes:
 *	we now use the LZCopy stuff so COMPRESS is NOT defined
 *	we now set the crit error handler ourselves so CHECKFLOPPY is
 *	NOT defined
 */

#include <dos.h>
#include <malloc.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <io.h>
#include <string.h>

#define COMPRESS

#ifdef COMPRESS
#include "lzcopy.h"
#else
#include "sulib.h"
#endif



int    XDosCopy;                    /* Added to allow renaming DOS files	*/
char   szDosDesName[ 25 ];          /* Added to allow renaming DOS files	*/
#define  _A_FINDALL   (_A_HIDDEN | _A_SYSTEM | _A_RDONLY)	/* DOS Upgrade	*/


char szDisks[] = "disks";

BOOL NEAR GetDiskPath(char cDisk, PSTR szPath);
#ifdef CHECK_FLOPPY
BOOL NEAR IsDiskInDrive(int iDisk);
#endif

/*
 *  global vars used by DosCopy
 */
static LPSTR    lpBuf = NULL;   // copy buffer
static int      iBuf = 0;       // usage count
static WORD     nBufSize;

#define MAXBUF  (60 * 1024)     // size of default copy buffer

void NEAR PASCAL AllocCopyBuf();
void NEAR PASCAL FreeCopyBuf();

void FAR PASCAL fartonear(LPSTR dst, LPSTR src)
{
	while (*src)
		*dst++ = *src++;

	*dst = 0;
}

/*  WORD FileCopy (szSource, szDir, fpfnCopy, WORD f)
 *
 *  This function will copy a group of files to a single destination
 *
 *  ENTRY:
 *
 *  szSourc      : pointer to a SETUP.INF section
 *  szDest       : pointer to a string containing the target DIR
 *  fpfnCopy     : callback function used to notify called of copy status
 *  fCopy        : flags
 *
 *      FC_SECTION      - szSource is a section name
 *      FC_LIST         - szSource is a pointer to a list, each item \0
 *                        terminated and the whole list \0\0 terminated
 *      FC_FILE         - szSource is a file name.
 *      FC_QUALIFIED    - szSource is a fully qualified file name.
 *      FC_DEST_QUALIFIED - szDir is fully qualified. Don't expand this.
 *      FC_DEST_QFILE   - szDir is a fully quilified path and filename.
 *
 *  NOTES:
 *      if szSource points to a string of the form '#name' the section
 *      named by 'name' will be used as the source files
 *
 *      the first field of each line in the secion is used as the name of the
 *      source file.  A file name has the following form:
 *
 *          #:name
 *
 *          #       - Disk number containing file 1-9,A-Z
 *          name    - name of the file, may be a wild card expression
 *
 *  Format for copy status function
 *
 *  BOOL FAR PASCAL CopyStatus(int msg, int n, PSTR szFile)
 *
 *      msg:
 *          COPY_ERROR          error occured while copying file(s)
 *                              n      is the DOS error number
 *                              szFile is the file that got the error
 *                              return: TRUE ok, FALSE abort copy
 *
 *          COPY_STATUS         Called each time a new file is copied
 *                              n      is the percent done
 *                              szFile is the file being copied
 *                              return: TRUE ok, FALSE abort copy
 *
 *          COPY_INSERTDISK     Please tell the user to insert a disk
 *                              n      is the disk needed ('1' - '9')
 *                              return: TRUE try again, FALSE abort copy
 *
 *          COPY_QUERYCOPY      Should this file be copied?
 *                              n      line index in SETUP.INF section (0 based)
 *                              szFile is the line from section
 *                              return: TRUE copy it, FALSE dont copy
 *
 *          COPY_START          Sent before any files are copied
 *
 *          COPY_END            Sent after all files have been copied
 *                              n   is dos error if copy failed
 *
 *
 *  EXIT: returns TRUE if successful, FALSE if failure.
 *
 */

WORD FAR PASCAL FileCopy (LPSTR szSource, PSTR szDir, FPFNCOPY fpfnCopy, WORD fCopy)
{
    int       err = ERROR_OK;
    char      szFile[MAXPATHLEN];
    char      szPath[MAXPATHLEN+20];
    char      szLogSrc[MAXPATHLEN+20];
    char      szSrcBase[15];
    char      szSrc[MAXPATHLEN+20];
    char      szErrFile[MAXPATHLEN+20];
    LPSTR far *pFileList;
    LPSTR far *pFileListBegin;
    LPSTR     pFile;
    LPSTR     pFileBegin;
    BOOL      f;
    BOOL      fDoCopy;
    int       n = 0;
    int       nDisk;
    char      cDisk;
    int       cntFiles = 0;
    PINF      pinf;

    #define CALLBACK(msg,n,pFile) \
        (fpfnCopy ? ((*fpfnCopy)((WORD)(msg),(int)(n),(LPSTR)(pFile))) : FC_IGNORE)

    if (!szSource || !*szSource || !szDir || !*szDir)
        return FALSE;

#ifndef COMPRESS
    AllocCopyBuf();
#endif

    /*
    if ( fCopy & (FC_DEST_QUALIFIED | FC_DEST_QFILE) )
     *  fix up the drive in the destination
     */


    if ( fCopy & FC_DEST_QUALIFIED )
       strcpy(szPath,szDir);
//    else
//       ExpandFileName(szDir,szPath);

    fCopy &= ~FC_DEST_QUALIFIED;

    if (szSource[0] == '#' && fCopy == FC_FILE)
    {
        fCopy = FC_SECTION;
        ++szSource;
    }

    switch (fCopy)
    {
        case FC_LSTPTR:
            pFileList = pFileListBegin = (LPSTR far *)szSource;
            pFileBegin = *pFileList;

            while ( pFileList[n] ) {
               if ( *pFileList[n] )
                  ++cntFiles;
               ++n;
            }

            break;

        case FC_SECTION:
	    {
	    char buf[40];

	    fartonear(buf, szSource);
//            szSource = infFindSection(NULL,buf);
            if (szSource == NULL)
                goto exit;

	    fCopy = FC_LIST;
	    }
            // fall through to FC_LIST

        case FC_LIST:
            pFileBegin = szSource;
//            cntFiles = infLineCount(szSource);
            break;

        case FC_FILE:
        case FC_QUALIFIED:
        default:
            pFileBegin = szSource;
            cntFiles = 1;
    }

    /*
     * Does the destination directory exist? if not create it.
     */
    if (!DosValidDir(szPath)) {

        err = DosMkDir(szPath);

	// oh no! this is bad

        if (err != ERROR_OK) {
            CALLBACK(COPY_ERROR,err,szPath);
            goto exit;
        }
    }

    /*
     *  walk all files in the list and call DosCopy ....
     *
     *  NOTES:
     *      we must walk file list sorted by disk number.
     *      we should use the disk that is currently inserted.
     *      we should do a find first/find next on the files????
     *      we need to check for errors.
     *      we need to ask the user to insert disk in drive.
     *
     */
    CALLBACK(COPY_START,0,NULL);

    for (nDisk = 1; cntFiles > 0; nDisk++) {

        cDisk      = CHDISK(nDisk);
        pFileList  = pFileListBegin;
        pFile      = pFileBegin;
        n          = 0;

        while (pFile) {

            /*
             *  should we copy this file?
             *  copy the files in disk order.
             */
            fDoCopy = pFile[1] == ':' && cDisk == UP_CASE(pFile[0]) ||
                      pFile[1] != ':' && nDisk == 1 && *pFile ||
                      fCopy == FC_QUALIFIED;

            if (fDoCopy)
                cntFiles--;         // done with a file. decrement count.

            if (fDoCopy && CALLBACK(COPY_QUERYCOPY,n,pFile)) {

                if (CALLBACK(COPY_STATUS, 0, pFile) == FC_ABORT) {
		    err = ERROR_NOFILES;
                    goto exit;
		}

		// now we convert logical dest into a physical (unless FC_QUALIFIED)

//                infParseField(pFile, 1, szLogSrc);	 // logical source
	              fartonear(szLogSrc,pFile);

                if ( fCopy != FC_QUALIFIED )
                   strcpy(szSrc,szLogSrc);
//                   ExpandFileName(szLogSrc, szSrc); // full physical source
                else
                   strcpy(szSrc,szLogSrc);

tryagain:   
                // Call low level copy command

                err = DosCopy(szSrc, szPath);
      
                if (err != ERROR_OK) {

		    strcpy(szSrcBase, FileName(szSrc));	// save base name

                    if (err == ERROR_FILENOTFOUND || err == ERROR_PATHNOTFOUND) {

                        // isolate the path

                        StripPathName(szSrc);

		   	// now try to get a new path in szSrc

                   	switch (CALLBACK(COPY_INSERTDISK, szLogSrc[0], szSrc)) {
	           	case FC_RETRY:
		   		catpath(szSrc, szSrcBase);	// add the file back on
		   		goto tryagain;			// and try again...

                   	case FC_ABORT:
                   		goto exit;

	           	case FC_IGNORE:
        	        	break;
                   	}

                    }

		    // ERROR situation
		    //
		    // this may be a real error or something like
		    // a share violation on a network.

          strcpy(szSrc,szLogSrc);

//		    ExpandFileName(szLogSrc, szSrc);	// full physical source

		    // if it is a write error report the destination file
		    // otherwise report with the source file

		    switch (err) {
		       case ERROR_WRITE:
		    	   strcpy(szErrFile, szPath);
			      catpath(szErrFile, szSrcBase);
		    	   break;

		    default:
		    	strcpy(szErrFile, szSrc);
		    }

                    switch (CALLBACK(COPY_ERROR, err, szErrFile)) {

                    case FC_RETRY:
                            goto tryagain;
    
                    case FC_ABORT:
                            goto exit;

                    case FC_IGNORE:
                            break;
                    }
                }

                if (CALLBACK(COPY_STATUS,100,pFile) == FC_ABORT)
                    goto exit;
            }

            /*
             * Move on to next file in the list
             */
            n++;
            if (fCopy == FC_LSTPTR)
                pFile = *(++pFileList);
//	         else if (fCopy == FC_LIST)
//                pFile = infNextLine(pFile);
            else
                pFile = NULL;
        }
    }

    err = ERROR_OK;

exit:
    CALLBACK(COPY_END,err,NULL);
#ifndef COMPRESS
    FreeCopyBuf();
#endif
    return err;

    #undef CALLBACK
}

#ifndef COMPRESS

/*  AllocCopyBuf()
 *
 *  allocate a buffer for DosCopy to use
 *
 */
void NEAR PASCAL AllocCopyBuf()
{
    if (iBuf++ == 0)
    {
        nBufSize = MAXBUF;
        for(;;)
        {
            lpBuf = FALLOC(nBufSize);
            if (lpBuf || nBufSize == 1)
                break;
            nBufSize /= 2;
        }
        if (lpBuf == NULL)
            iBuf--;
    }
}

/*  FreeCopyBuf()
 *
 *  free copy buffer, if its use count is zero
 *
 */
void NEAR PASCAL FreeCopyBuf()
{
    if (iBuf > 0 && --iBuf == 0 && lpBuf)
    {
        FFREE(lpBuf);
    }
}
#endif

PSTR GetExtension(PSTR szFile)
{
	PSTR ptr;

	for (ptr = szFile; *ptr && *ptr != '.'; ptr++);

	if (*ptr != '.')
		return NULL;
	else
		return ptr+1;

}

BOOL GetCompressedName(PSTR szComp, PSTR szSrc)
{
	PSTR ptr;

	strcpy(szComp, szSrc);

	ptr = GetExtension(szComp);

	if (ptr )
	{
		szComp[strlen(szComp)-1] = '_';
		return TRUE;
	}
#if	0	/* Changed for dos/windows merge */
	if (ptr && !strcmpi(ptr, "sys"))
	{
		szComp[strlen(szComp)-1] = '$';
		return TRUE;
	}
#endif

	return FALSE;
}

/*  DosCopy(PSTR szSrc, PSTR szPath)
 *
 *  Copy the file specifed by szSrc to the drive and directory
 *  specifed by szPath
 *
 *  ENTRY:
 *      szSrc   - File name to copy from
 *      szPath  - directory to copy to
 *
 *  RETURNS:
 *      0 - no error, else dos error code
 *
 */
int NEAR DosCopy(PSTR szSrc, PSTR szPath)
{
    FCB         fcb;
    WORD        size;
    int         fhSrc,fhDst;
    char        szFile[MAXPATHLEN+20];
    char        szComp[MAXPATHLEN+20];
    int         f = ERROR_OK;
    unsigned    date;
    unsigned    time;
    long	l;
    BOOL	bCompressedName;
    

#ifdef DEBUG
    if (fDontCopy)
        return ERROR_OK;

//    if (infGetProfileString(NULL,"setup","copy",szFile) && szFile[0] == 'f')
//        return ERROR_OK;
#endif

#ifndef COMPRESS
    AllocCopyBuf();

    if (!lpBuf)
        return ERROR_NOMEMORY;
#endif

#ifdef CHECK_FLOPPY
    if (!IsDiskInDrive(szSrc[0]))
    {
        f = ERROR_FILENOTFOUND;
        goto errfree;
    }
#endif


    // allows both sy$ and sys on the disks

    if (GetCompressedName(szComp, szSrc) &&
    	DosFindFirst(&fcb, szComp, XDosCopy ? _A_FINDALL : ATTR_FILES)) {

    	bCompressedName = TRUE;

    } else {

        bCompressedName = FALSE;

    	if (!DosFindFirst(&fcb, szSrc, XDosCopy ? _A_FINDALL : ATTR_FILES)) {
		f = ERROR_FILENOTFOUND;
		goto errfree;
	}
    }

    /*
     * copy every file that matches the file pattern passed in.
     */
    do
    {
        /*
         * create the source file name from the source path and the file
         * name that DosFindFirst/Next found
         */
        strcpy(szFile,szSrc);
        StripPathName(szFile);
        catpath(szFile,fcb.szName);

        fhSrc = FOPEN(szFile);

        if (fhSrc == -1)
        {
            f = FERROR();
            goto errfree;
        }

//#ifndef COMPRESS
        /* Save date of opened file */

        if (_dos_getftime(fhSrc,&date,&time))
           goto errclose1;
//#endif
        /*
         * create the destination file name from the dest path and the file
         * name that DosFindFirst/Next found
        */

        strcpy( szFile, szPath );

          /* bIsUpgrade - johnhe 05-25-91
           * If XDosCopy != FALSE then we are doing a DOS copy and
           * we have to get the destination name from the global
           * array szDosDesName.
          */
             
        if ( XDosCopy )
        {
           struct find_t    Info;

           catpath( szFile, szDosDesName );

           _dos_setfileattr( szFile, 0 );

                /* First see if the file exists and if it does we need to */
                /* open it without truncating. This is necessary so that  */
                /* IO.SYS/MSDOS.SYS will truly be written over top of the */
                /* original files so that UNINSTALL can restore the files */

           if ( _dos_findfirst( szFile, _A_FINDALL, &Info ) == 0 )
           {
              if ( (FERROR() = _dos_open( szFile, O_RDWR, &fhDst )) != 0 )
	              fhDst = -1;
           }
           else if ( (FERROR() = _dos_creat( szFile, 0, &fhDst )) != 0 )
              fhDst = -1;
        }
        else
        {
              // don't support wildcards for compressed files
           if (bCompressedName)
              catpath( szFile, FileName(szSrc) );
           else
              catpath( szFile, fcb.szName );	// used name from fcb
           fhDst = FCREATE( szFile );
        }

        if (fhDst == -1)
        {
           f = FERROR();
           goto errclose1;
        }

#ifdef COMPRESS

	// translate LZERROR_ returns (all < 0) to DOS errors

        if ((l = DOSLZCopy(fhSrc, fhDst)) < 0) {

		// was this a dos error?

		if (FERROR() != 0) {
			f = FERROR();
		} else {

			// translate LZ error codes to DOS errors

			switch ((int)l) {
			case LZERROR_BADINHANDLE:
			case LZERROR_READ:
				f = ERROR_READ;
				break;

			case LZERROR_BADOUTHANDLE:
			case LZERROR_WRITE:
				f = ERROR_WRITE;
				break;

			case LZERROR_GLOBALLOC:
			case LZERROR_GLOBLOCK:
				f = ERROR_NOMEMORY;
				break;
			}
		}
	}
#else
        while (size = FREAD(fhSrc,lpBuf,nBufSize))
        {
            if (FWRITE(fhDst,lpBuf,size) != size)
            {
                /* write error? */
                f = FERROR();
                if (f == ERROR_OK)
                    f = ERROR_WRITE;
                goto errclose;
            }
        }

        /* Restore date of written file */
        _dos_setftime(fhDst,date,time);
#endif
		if ( f == 0 )
      {
         chsize( fhDst, lseek( fhDst, 0L, SEEK_CUR ) );
         _dos_setftime(fhDst,date,time);
      }
      else
         /*
          *  We've had some kind of copy error here and we need to delete
          *  the zero length file we have created at the destination.
          *  MC Bugfix #178 for UPG/JANUG 5/21/92
          */
         remove(szFile);

errclose:
        FCLOSE(fhDst);
errclose1:
        FCLOSE(fhSrc);

    }   while ( f == ERROR_OK && DosFindNext(&fcb) );

errfree:

#ifndef COMPRESS
    FreeCopyBuf();
#endif

    return f;
}

#if 0

/*  BOOL FAR PASCAL ExpandFileName(PSTR szFile, PSTR szPath)
 *
 *  This function will retrive the full path name for a file
 *  it will expand, logical disk letters to pyshical ones
 *  will use current disk and directory if non specifed.
 *
 *  if the drive specifed is 0-9, it will expand the drive into a
 *  full pathname using GetDiskPath()
 *
 *  IE  0:system ==>  c:windows\system
 *      1:foo.txt     a:\foo.txt
 *
 *  ENTRY:
 *
 *  szFile       : File name to expandwhat disk to find
 *  szPath       : buffer to hold full file name
 *
 */
BOOL FAR PASCAL ExpandFileName(PSTR szFile, PSTR szPath)
{
    char    szBuf[MAXPATHLEN*2];

    if (szFile[1] == ':' && GetDiskPath(szFile[0],szBuf))
    {
        strcpy(szPath,szBuf);
        if (szFile[2])
            catpath(szPath,szFile + 2);
    }
    else
    {
        strcpy(szPath,szFile);
    }
    return TRUE;
}

/*  BOOL GetDiskPath(char cDisk, szPath)
 *
 *  This function will retrive the full path name for a logical disk
 *  the code reads the [disks] section of SETUP.INF and looks for
 *  n = path where n is the disk char.  NOTE the disk '0' defaults to
 *  the root windows directory.
 *
 *  ENTRY:
 *
 *  cDisk        : what disk to find 0-9,A-Z
 *  szPath       : buffer to hold disk path
 *
 */
BOOL NEAR GetDiskPath(char cDisk, PSTR szPath)
{
    char    ach[2];
    char    szBuf[MAXPATHLEN];

    if (cDisk == '0')
    {
        /*
         * return the windows setup directory
         */
        strcpy(szPath,szSetupPath);
        return TRUE;
    }

    /*
     * now look in the [disks] section for a full path name
     */
    ach[0] = cDisk;
    ach[1] = 0;
//    if ( !infGetProfileString(NULL,szDisks,ach,szPath) )
//       return FALSE;
//    infParseField(szPath,1,szPath);
    /*
     *  is the path relative? is so prepend the szDiskPath
     */
    if (szPath[0] == '.' || szPath[0] == 0)
    {
        strcpy(szBuf,szDiskPath);
        catpath(szBuf,szPath);
        strcpy(szPath,szBuf);
    }
    return TRUE;
}

#endif

#ifdef CHECK_FLOPPY

/*  BOOL IsDiskInDrive(char cDisk)
 *
 *  Is the specifed disk in the drive
 *
 *  ENTRY:
 *
 *  cDisk        : what disk required to be in the drive (logical)
 *
 *  return TRUE if the specifed disk is in the drive
 *         FALSE if the wrong disk is in the drive or disk error
 *
 */
BOOL NEAR IsDiskInDrive(int iDisk)
{

    if ((iDisk  >= 'A' && iDisk <= 'Z') || 
    	(iDisk  >= 'a' && iDisk <= 'z')) {

	    if (DosRemoveable(iDisk)) {

	        if (!IsValidDiskette(iDisk))
        		return FALSE;
	    }


	    return TRUE;
    }

    return TRUE;	// for non drive letters assume a path
    			// and thus always in.
}

#define CBSECTORSIZE	512
#define INT13_READ	2

/*--------------------------------------------------------------------------
									    
  IsValidDiskette() - 						    
									    
--------------------------------------------------------------------------*/

BOOL NEAR IsValidDiskette(int iDrive)
{
  char	    buf[CBSECTORSIZE];

  iDrive |= 0x0020;	// make lower case

  iDrive -= 'a';	// A = 0, B = 1, etc. for BIOS stuff

  return MyReadWriteSector(buf, INT13_READ, iDrive, 0, 0, 1);
}

#endif 

void FAR PASCAL catpath(PSTR path, PSTR sz)
{
    //
    // Remove any drive letters from the directory to append
    //
    if ( sz[1] == ':' )
       sz+=2;

    //
    // Remove any current directories ".\" from directory to append
    //
    while (sz[0] == '.' && SLASH(sz[1]))
		  sz+=2;

	//
	// Remove leading slashes.
	//
	while (SLASH(*sz))
		sz++;

    //
    // Dont append a NULL string or a single "."
    //
    if (*sz && !(sz[0] == '.' && sz[1] == 0))
    {
       if ( (!SLASH(path[strlen(path)-1])) && ((path[strlen(path)-1]) != ':') )
          strcat(path,CHSEPSTR);
       strcat(path,sz);
    }
}


PSTR FAR PASCAL FileName(PSTR szPath)
{
    PSTR   sz;

    for (sz=szPath; *sz; sz++)
        ;
    for (; sz>=szPath && !SLASH(*sz) && *sz!=':'; sz--)
        ;
    return ++sz;
}

PSTR FAR PASCAL StripPathName(PSTR szPath)
{
    PSTR   sz;

    sz = FileName(szPath);

    if (sz > szPath+1 && SLASH(sz[-1]) && sz[-2] != ':')
        sz--;

    *sz = 0;
    return szPath;
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\wsexit.c ===
/***************************************************************************

MODULE: wshelp.c  - Pretty much new for 3.1

   Copyright (C) Microsoft, 1991

HISTORY:

   Modified by:      Date:       Comment:
     Mikecole       7/23/91      Do away with RTF help window. Work for new
                                 context sensitive help design.

***************************************************************************/
#include "winenv.h"
#include	<file_io.h>
#include "lib\\common\\sulib.h"
#include "ws.h"
#include "wsrc.h"
#include "helpcon.h"

// Local function prototypes.

DWORD EXPORT wsSetupExit(int nCode, WORD wParam, DWORD lParam);

// Globals to this module.

char            szHelpFile[MAXSTR];
static  BOOL	 bHelpCalled = FALSE;

FARPROC lpfnOldHook = NULL;
FARPROC lpfnMyHook  = NULL;

/* BOOL PUBLIC wsExitInit(void)
 *
 * Function will grab the name of the help file from setup.inf and put
 * in the help hook.
 *
 * ENTRY: None.
 *
 * EXIT: BOOL - Success = TRUE. Failure == FALSE.
 *
 */
BOOL PUBLIC wsExitInit(void)
{
   wsLoadSz(IDS_HELPFILE,szHelpFile,MAXSTR);

   if (!(lpfnMyHook = MakeProcInstance((FARPROC)wsSetupExit, hInstWS)))
      return FALSE;

   lpfnOldHook = SetWindowsHook(WH_MSGFILTER,lpfnMyHook);

   return TRUE;
}

/* DWORD EXPORT wsSetupHelp(int nCode, WORD wParam, DWORD lParam);
 *
 * This is the WH_MSGFILTER hook function for Windows setup. This functions
 * purpose is to intercept help and exit requests and  convert them to
 * the appropriate WM_COMMAND messages.
 *
 * ENTRY: nCode - Code value that tells this function where messages are
 *                coming from; ie. dialog or message-box, keyb or mouse.
 *
 *        wParam - Always NULL.
 *
 *        lParam - Pointer to a MSG data structure.
 *
 * EXIT: Non-zero (TRUE) if this function processes the message. Otherwise FALSE.
 *
 */
DWORD EXPORT wsSetupExit(nCode, wParam, lParam)
int   nCode;
WORD  wParam;
DWORD lParam;
{
   LPMSG   lpMsg = (LPMSG)lParam;
   WORD    wHelpContext = 0;
   HWND    hDlgWnd = NULL, hWnd = NULL;
   char    szClassName[25];

   bHelpCalled = TRUE;

   if ( nCode < 0 )
      return DefHookProc(nCode, wParam, lParam, &lpfnOldHook);

   /* First check that we received a message for dialog box   */

   if ( nCode == MSGF_DIALOGBOX )
   {
       /* We want to process only keyboard messsages          */
       if ( lpMsg->message == WM_KEYDOWN )
       {

         if ( lpMsg->wParam != VK_F3 )
            return FALSE;

         /* Now we have to detetrmine handle of current dialog window.
          * We know that class name of all our dialogs is MYDLG so
          * I am going through the chain of parent windows for current
          * focus windows until I will find parent dialog or NULL.
          */

         hWnd = lpMsg->hwnd;
         while ( hWnd )
         {
             *szClassName = '\0';
             GetClassName(hWnd,szClassName,sizeof(szClassName));
             AnsiUpper(szClassName);
             if ( lstrcmpi((LPSTR)szClassName,(LPSTR)CLS_MYDLGS) == 0 )
               break;

             hWnd = GetParent(hWnd);
         }

         /* Did we find anything ???                          */
         if ( ! hWnd )
            return FALSE;

         /* Convert keyboard messages came into WM_COMMANDs to
          * the found dialog. Return TRUE because we procecessed
          */
         switch (lpMsg->wParam)
         {
            case VK_F3:                        
               PostMessage(hWnd,WM_COMMAND,ID_EXIT,(LONG)lpMsg->lParam);
               return TRUE;
               break;
         }
       }
   }
   return FALSE;
}


/* LONG EXPORT wsDefSetupDlgProc(HWND hwnd, unsigned msg, WORD wParam,
 *                               LONG lParam);
 *
 * Function acts as setup's DefDialogProc(). We use this to process Help and
 * Exit button usage so that we don't have to put code into each of our dialog
 * procs to do this. The way it works is we filter all the dialog message for
 * WM_COMMAND - ID_HELP/ID_EXIT messages, these we process right here. The rest
 * of the messages are passed on to DefDialogProc().
 *
 * ENTRY: hwnd   - Handle to dialog box who received the focus.
 *        msg    - Message.
 *        wParam - Message dependent.
 *        lParam - Message dependent.
 *
 * EXIT:  BOOL   - TRUE if message processed, FALSE if not.
 *
 */
LONG EXPORT wsDefSetupDlgProc(HWND hwnd, WORD msg, WORD wParam, LONG lParam)
{
   switch(msg)
   {
      case WM_KEYDOWN:
         switch(wParam)
         {
            case VK_F1:
               SendMessage(hwnd,WM_COMMAND,ID_HELP,lParam);
               break;
            case VK_F3:
               SendMessage(hwnd,WM_COMMAND,ID_EXIT,lParam);
               break;
         }
         break;

      case WM_SYSCOMMAND:           // suppress taskman
         if(wParam == SC_TASKLIST)
            return TRUE;
         break;

      case WM_COMMAND:
         switch(wParam)
         {
            case ID_EXIT:
               if ( QueryExit(NULL) ) {
                  if ( hwndParent )
                     DestroyWindow(hwndParent);
                  CleanUpDroppings();
                  AppQuit();
               }
               break;
           
            case ID_HELP:
            {
               HWND hContextWnd;
               WORD wHelpContext = 0;

               hContextWnd = GetWindow(hwnd, GW_CHILD);
               wHelpContext = GetWindowWord(hContextWnd, GWW_ID);

               if ( (wHelpContext >= HELP_CONTEXT_MIN) && (wHelpContext <= HELP_CONTEXT_MAX) )
               {
                  bHelpCalled = WinHelp(hwnd,szHelpFile,HELP_CONTEXT,(LONG)wHelpContext);

                  WinHelp(hwnd,szHelpFile,HELP_SETINDEX,DOS2GUI_INDEX);

                  if (! bHelpCalled)
                  {
                     MessageBox(hwnd, wsLoadSz(IDS_HELP_ERROR, NULL, 0), NULL,
                                MB_APPLMODAL | MB_OK);
                     WinHelp(hwnd, szHelpFile, HELP_QUIT, 0L);
                  }
               }
               return(TRUE);
            }
         }
   }
   return(DefDlgProc(hwnd, msg, wParam, lParam));
}

/* VOID PUBLIC wsExitTerm(HWND hwnd);
 *
 * Function properly cleans up after setup's help usage by telling
 * the engine we no longer need it and un-hooking the message filter
 * we put in when we started.
 *
 * ENTRY: hWnd - Handle to parent window.
 *
 * EXIT: none.
 *
 */
VOID PUBLIC wsExitTerm(hwnd)
HWND hwnd;
{
	if ( bHelpCalled )
		WinHelp(hwnd, szHelpFile, HELP_QUIT, 0L);

   if ( lpfnMyHook )
      UnhookWindowsHook(WH_MSGFILTER, lpfnMyHook);
}

/* void PUBLIC CleanUpDroppings(void);
 *
 * Function cleans up any temporarialy copied files along with any other
 * house keeping that needs to be done when the user either completes or
 * terminates DOS install.
 *
 * ENTRY: None.
 *
 * EXIT: None.
 *
 */
void PUBLIC CleanUpDroppings(void)
{
   char  szTmp[MAXFILESPECLEN];

   GetWindowsDirectory(szTmp,sizeof(szTmp));  // Where are we ?
   catpath(szTmp,szHelpFile);                 // Build FQP to the victim.
   AbsUnlink(szTmp);                          // The kill.
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\lib\common\dos.asm ===
;****************************************************************************
;*                                                                          *
;*  WFDOSDIR.ASM -                                                          *
;*                                                                          *
;*      Directory searching primitives                                      *
;*                                                                          *
;****************************************************************************

?PLM=1      ; PASCAL Calling convention is DEFAULT
?WIN=1      ; Windows calling convention
?386=0      ; Use 386 code?

include cmacros.inc

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends

ifndef SEGNAME
    SEGNAME equ <TEXT>
endif

if ?386
    createSeg _%SEGNAME, CodeSeg, word, use16, CODE
else
    createSeg _%SEGNAME, CodeSeg, word, public, CODE
endif

NOT_SUPPORTED     =  2h      ; Return code from IsDeviceRemote function.
REMOTE            =  3h      ; Return code for remote drive found.
TRUE              =  1h      ; TRUE Definition
FALSE             =  0h      ; False Definition.

;=============================================================================

sBegin DATA

include ioctl.inc

VolExtendedFCB  db  0FFh
                db  0, 0, 0, 0, 0
                db  1000b
                db  0
                db  11 dup('?')
                db  5 dup(0)
                db  11 dup('?')
                db  9 dup(0)

DTA             db  64 dup(0)

sEnd   DATA

;=============================================================================

sBegin CodeSeg

assumes CS,CodeSeg
assumes DS,DATA

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  DosFindFirst() -                                                        *
;*                                                                          *
;*--------------------------------------------------------------------------*

; Get the first directory entry.

cProc DosFindFirst, <FAR, PUBLIC>

ParmD lpDest
ParmD szFileSpec
ParmW attrib

cBegin
            push    ds
            lds     dx,lpDest
            mov     ah,1Ah          ; Set DTA
            int     21h

            mov     cx,attrib       ; Find First File
            lds     dx,szFileSpec   ; Path = szFileSpec
            mov     ah,4Eh
            int     21h
            jc      fferr
            mov     ax,1
            jmp     short ffdone

fferr:
            xor     ax,ax           ; Return zero on error
ffdone:
            pop     ds
cEnd


;*--------------------------------------------------------------------------*
;*                                                                          *
;*  DosFindNext() -                                                         *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc DosFindNext, <FAR, PUBLIC>

ParmD lpDest

cBegin
            push    ds
            lds     dx,lpDest
            mov     ah,1Ah          ; Set DTA
            int     21h
            pop     ds

            les     bx,lpDest       ; ES:BX = lpDest
            mov     ah,4Fh          ; Find Next File
            int     21h
            mov     ax,1
            jnc     FNExit          ; Exit if no error
FNErr:
            xor     ax,ax           ; Return FALSE
FNExit:
cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  DosMkDir()                                                              *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc DosMkDir, <FAR, PUBLIC>
ParmD   szDir
cBegin
        lds     dx,szDir
        mov     ah,39h
        int     21h
        jc      mderror
        xor     ax,ax
        jmp     short mdexit

mderror:
        mov     ah,59h
        xor     bx,bx
        int     21h

mdexit:

cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  GetCurrentDrive() -                                                     *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc GetCurrentDrive, <FAR, PUBLIC>

cBegin
        mov     ah,19h              ; Get Current Drive
        int     21h
        sub     ah,ah               ; Zero out AH
cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  SetCurrentDrive() -                                                     *
;*                                                                          *
;*--------------------------------------------------------------------------*

; Returns the number of drives in AX.

cProc SetCurrentDrive, <FAR, PUBLIC>

ParmW Drive

cBegin
            mov     dx,Drive
            mov     ah,0Eh              ; Set Current Drive
            int     21h
            sub     ah,ah               ; Zero out AH
cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  GetCurrentDirectory() -                                                 *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc DosCwd, <FAR, PUBLIC>, <SI, DI>

ParmD lpDest

cBegin
            push    ds                  ; Preserve DS

            call    GetCurrentDrive
            mov     si,ax               ; SI = Current drive

            les     di,lpDest           ; ES:DI = lpDest
            push    es
            pop     ds                  ; DS:DI = lpDest
            cld
            mov     ax,si               ; AX = Current drive
            inc     al                  ; Convert to logical drive number
            mov     dl,al               ; DL = Logical Drive Number
            add     al,'@'              ; Convert to ASCII drive letter
            stosb
            mov     al,':'
            stosb
            mov     al,'\'              ; Start string with a backslash
            stosb
            mov     byte ptr es:[di],0  ; Null terminate in case of error
            mov     si,di               ; DS:SI = lpDest[1]
            mov     ah,47h              ; Get Current Directory
            int     21h
            jc      CDExit              ; Skip if error
            xor     ax,ax               ; Return FALSE if no error
CDExit:
            pop     ds                  ; Restore DS
cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  SetCurrentDirectory() -                                                 *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc DosChDir, <FAR, PUBLIC>

ParmD lpDirName

cBegin
            push    ds                  ; Preserve DS
            lds     dx,lpDirName        ; DS:DX = lpDirName

            mov     bx,dx
            mov     ax,ds:[bx]
            cmp     ah,':'
            jnz     cdnodrive

            ;
            ;       Convert drive letter to drive index
            ;
            or      al,20h
            sub     al,'a'
            xor     ah,ah

            push    dx
            cCall   SetCurrentDrive,<ax>
            pop     dx
cdnodrive:
            mov     ah,3Bh              ; Change Current Directory
            int     21h
            jc      SCDExit             ; Skip on error
            xor     ax,ax               ; Return FALSE if successful
SCDExit:
            pop     ds                  ; Restore DS
cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  DosValidDir()                                                           *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc DosValidDir, <FAR, PUBLIC>, <SI, DI>
ParmD       szDir
LocalV      szCwd, 128
cBegin
    lea     si,szCwd
    cCall   DosCwd,<ss,si>
    push    szDir.sel
    push    szDir.off
    call    DosChDir
    or      ax,ax
    pushf
    cCall   DosChDir,<ss,si>
    ;
    ;   return TRUE if DosChdir returns 0, FALSE otherwise
    ;
    xor     ax,ax                ; don't care about this return val.
    popf
    jnz     vdexit
    inc     ax
vdexit:

cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  DosExit(ec);                                                            *
;*                                                                          *
;*  Terminate program                                                       *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc DosExit, <FAR, PUBLIC>
ParmW   ec
cBegin
        mov     al,byte ptr ec
        mov     ah,4Ch
        int     21h
cEnd

;*******************************************************************
;
; None of the code below this comment is presently used in DOS2 GUI.
;
;*******************************************************************

if 0

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  DosRename(lpszFrom, lpszTo);                                            *
;*                                                                          *
;*  Rename file From (far pointer to old filename)                          *
;*                To (far pointer to new filename)                          *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc DosRename, <FAR, PUBLIC>, <DI,DS>
ParmD   lpszFrom
ParmD   lpszTo
cBegin
        lds     dx,lpszFrom
        les     di,lpszTo
        mov     ah,56h
        int     21h
        jc      rnexit
        xor     ax,ax
rnexit:
cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  DosDelete(szFile);                                                      *
;*                                                                          *
;*  Delete file                                                             *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc DosDelete, <FAR, PUBLIC>, <DS>
ParmD   szFile
cBegin
        lds     dx,szFile
        mov     ah,41h
        int     21h
        jc      dexit
        xor     ax,ax
dexit:
cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  int GetCodePage(void)                                                   *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc GetCodePage, <FAR, PUBLIC>

cBegin
        mov     ax,6601h          ; Get Code page call (Dos Ver >= 3.30)
        int     21h               ; Call DOS.
        mov     ax,bx             ; Stick axtive code page in AX.
        jnc     short GCPdone     ; default CP is already in DX so were done.
        mov     ax,-1             ; return error condition if carry set.
                                  ; other wise, return ax,dx pair.
GCPdone:                          

cEnd

;*--------------------------------------------------------------------------
;*
;*  LONG DosDiskFreeSpace(Drive)
;*
;*  note:
;*      Drive == 0      default
;*      Drive == 1      A
;*      Drive == 2      B
;*--------------------------------------------------------------------------

; Returns the number of bytes free in DX:AX

cProc DosDiskFreeSpace, <FAR, PUBLIC>
ParmW Drive
cBegin
            mov     dx,Drive
            mov     ah,36h              ; Set Current Drive
            int     21h
            cmp     ax, 0ffffh          ; bogus drive?
            je      error
            mul     cx                  ;
            mul     bx
            jmp     done                ; DX:AX contains free space
error:
            mov     dx, ax              ; return dx:ax = -1L
done:
cEnd


;*--------------------------------------------------------------------------*
;*                                                                          *
;* BOOL DosIsRemote(int);                                                   *
;*                                                                          *
;* ENTRY:  Word, iPDrive: must be of the form ( logical volume A = 0 )      *
;*               Physical Drive Spec.                          B = 1        *
;*                                                             C = 2        *
;*                                                             ect.         *
;* EXIT: BOOL  returned in AX Remote = Remote                               *
;*                            False  = Local                                *
;*                            not_supported                                 *
;*                                                                          *
;* DESTROYS: AX. (preserves all registers except AX for return value)       *
;*                                                                          *
;* AUTHOR: MC                                                               *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc   DosIsRemote, <FAR, PUBLIC>, <BX,CX,DX,SI,DI,ES,DS>

ParmW   iPDrive                   ; Int Physical drive spec 0 - 25
localV  local_name,     16d       ; Buffer to hold redirected local name.
localV  net_name,      128d       ; Buffer to hold remote device name.
localV  remote_list,    42d       ; Buffer, will be filled with list of
                                  ; redirected local device names.
cBegin

        ; First, we need to make a list of remote devices (logical Volumes)
        ; I have to use DOS call int 21h/5f02h because DOS call int 21h/4409h
        ; is not reliable under DOS versions 4.00 and 4.01. (IBM fuck-up).

        xor     cx,cx
        xor     dx,dx

next_entry:
        mov     bx,cx                 ; CX = redirection list index.
        mov     ax,ss                 ; Load segs for stack vars.
        mov     es,ax
        mov     ds,ax
        mov     ax,5f02h              ; func 5f/02 Get redirection list.
        lea     si,local_name         ; ds:si = local_name
        lea     di,net_name           ; es:di = net_name
        push    cx                    ; save CX
        push    dx                    ; save DX
        int     21h
        pop     dx                    ; restore DX
        pop     cx                    ; restore CX
        jc      check_support         ; error, not supported or end of list.
        cmp     bl,04h                ; Is redirected device a drive ?
        jne     not_a_drive           ; If not, we don't care !

        mov     al,byte ptr ds:[si]   ; Grab volume name.
        sub     al,41h                ; Convert to volume number A=0 ect.
        lea     di,remote_list        ; get a pointer to our remote list.
        add     di,dx                 ; DX is index into list of devices.
        mov     byte ptr es:[di],al   ; save remote device into out list.
        inc     dx                    ; Increment list index pointer.

not_a_drive:
        inc     cx                    ; CX = redirection list index.
        jmp     short next_entry

check_support:
        cmp     ax,12h                ; AX = 12h means end of redir list !
        jne     Game_Over_Man         ; If not then soooo long.
        lea     di,remote_list
        add     di,dx                 ; DX is index into list of devices.
        mov     byte ptr es:[di],0ffh ; Terminate list.

        ;
        ; Is the drive remote ?
        ; See if it matches any entries in list of redirected devices.
        ;

        lea     di,remote_list        ; pointer to list of redirected drives.
        mov     bx,iPDrive            ; Grab the parameter.

next_in_list:
        cmp     byte ptr es:[di],0ffh ; Are we at the end of the redir list ?
        jne     keep_checking
        mov     ax,FALSE              ; Indicate Volume not remote !
        jmp     IsRemoteDone

keep_checking:
        xor     cx,cx
        mov     cl,byte ptr es:[di]
        cmp     bx,cx
        je      Found_Remote
        inc     di
        jmp     short next_in_list

Game_Over_Man:
        mov     ax,NOT_SUPPORTED      ; Indicate no support in return value.
        jmp     short IsRemoteDone

Found_Remote:
        mov     ax,REMOTE             ; Indicate Volume is remote !

IsRemoteDone:

cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;* int GetFixedDisks(int foo[26]);                                          *
;*                                                                          *
;* Returns the number of active LOCAL FIXED disk drives in the system AND   *
;* puts their indexes into rgiDrive[].                                      *
;*                                                                          *
;* ENTRY: Pointer to array of 26 integers.                                  *
;*                                                                          *
;* EXIT:  Returns the number of active LOCAL FIXED disk drives in the       *
;*        system puts their indexes into rgiDrive[].                        * 
;*                                                                          *
;* DESTROYS: AX. (preserves all registers except AX for return value)       *
;*                                                                          *
;* AUTHOR: MC                                                               *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc GetFixedDisks, <FAR, PUBLIC>, <BX,SI,DI>

ParmW   rgiDrive
localW  cRealDrives

cBegin
        ; Preserve the current drive setting.
        call    GetCurrentDrive
        mov     di,ax                ; Save original drive.

        xor     si,si                ; SI = iLogDrives = zero
        mov     cRealDrives,si       ; cRealDrives = zero

GDCLoop:
        ; Attempt to set the current drive to SI.
        
        push    si
        call    SetCurrentDrive

        ; Did it actually work?
        ;
        call    GetCurrentDrive
        cmp     ax,si
        jnz     GDC300                ; Nope, skip

        ;
        ; Is the drive remote ?
        ;

        push    si
        call    DosIsRemote
        cmp     ax,REMOTE             ; Is the drive remote ?
        je      GDC300

        ; Here we have found the drive is not Remote or we cannot tell if
        ; the drive is remote so lets find out if
        ; its removable before we add it to the cRealDrives list.
        
        mov     ax,4408h             ; IOCTL is removeable            
        mov     bx,si            
        inc     bx                   ; map from 0=A to 1=A            
        int     21h            
        jc      check_call           ; error, skip            
        or      al,al            
        jz      GDC300               ; removeable, skip            
        
        ; Store the drive number in rgiDrive[]
        mov     ax,rgiDrive
        mov     bx,cRealDrives
        inc     cRealDrives
        shl     bx,1
        add     bx,ax
        mov     word ptr [bx],si
        jmp     short GDC300

; We have a problem if IOCTL int 21h/4408h is not supported because then
; we have know way of knowing weather or not the machine in question really
; does have a fixed disk connected. Therefore, in this case, we'll give the
; user the benifit of the doubt and let them continue to install windows.
            
check_call:
        cmp     ax,1                 ; Is this call supported ?
        jnz     GDC300               ; If yes, continue on normally.
        mov     cRealDrives,1        ; If not, we better indicate we have
        jmp     short no_chance      ; a fixed disk and return.

GDC300:
        inc     si
        cmp     si,26                ; Loop through all 26 drives
        jne     GDCLoop

no_chance:
        ; Restore the original current drive.

        push    di                   ; Put pram on stack for call.
        call    SetCurrentDrive      ; Restore original drive.
        mov     ax,cRealDrives       ; Return num local drives in AX.
cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;* BOOL DosRemoveable(char);                                                *
;*                                                                          *
;* ENTRY: Word iLDrive - Logical drive spec. A - Z. (case does not matter)  *
;*                                                                          *
;* EXIT:  BOOL Returns TRUE if media is removable. False if Remote or fixed *
;*                                                                          *
;* DESTROYS: AX. (preserves all registers except AX for return value)       *
;*                                                                          *
;* AUTHOR: MC                                                               *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc DosRemoveable, <FAR, PUBLIC>, <BX>

ParmW   iLDrive                     ; Logical Drive spec A - Z.

cBegin

        mov     bx,iLDrive          ; Grab the parameter.
        or      bx,20h              ; case insensitive.
        sub     bx,'a'              ; map to A=0
        push    bx                  ; Put param on stack for call.
        call    DosIsRemote         ; Find out if logical volume is remote
        or      ax,ax               ; check IsRemote return ?
        jnz     Remote_Or_Removable ; False ( 0 ) means local.

        ; Now we have found the volume is local, we can check to
        ; see if it's removable or not.
        
        mov     ax,4408h            ; IOCTL is removeable
        inc     bx                  ; Map from A=0 to A=1 ...
        int     21h
        jc      Remote_Or_Removable ; error, skip
        or      al,al
        jnz     Remote_Or_Removable ; NOT removeable
        inc     ax
        jnz     ir_exit

Remote_Or_Removable:
        xor     ax,ax               ; Return FALSE for remote or removable.

ir_exit:                            ; Finished.

cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  MyReadWriteSector() -                                                   *
;*                                                                          *
;*--------------------------------------------------------------------------*

; Uses INT 13h to read/write an absolute sector.

cProc MyReadWriteSector, <PUBLIC, FAR>, <SI,DI>

ParmD   lpBuffer
ParmW   Function                       ; 02 for Read and 03 for Write
ParmW   Drive
ParmW   Cylinder
ParmW   Head
ParmW   Count

LocalW  wRetryCount 

cBegin
        ; Retry this operation three times.
        mov     wRetryCount,4

MRWS_TryAgain:
        mov     ax,Count                ; AL = Number of sectors
        mov     ah,byte ptr Function    ; AH = Function #
        mov     ch,byte ptr Cylinder    ; CH = Starting Cylinder
        mov     cl,1                    ; CL = Starting Sector

        mov     dx,Drive        ; DL = INT 13h drive designation

        mov     dh,byte ptr Head        ; DH = Head #
        les     bx,lpBuffer             ; ES:BX = Buffer
        int     13h
        
        mov     ax, 1                   ; success

        jnc     MRWS_End_success        ; Problems?
        dec     wRetryCount             ; Yup, retry
        jz      MRWS_End_fail           ; Are we out of retries?

        xor     ah,ah                   ; Nope, reset the disk
        mov     dx,Drive
        int     13h
        jmp     short MRWS_TryAgain
MRWS_End_fail:
        xor     al,al           ; AH contains the error code, if any.
MRWS_End_success:

cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  GetCurrentVolume() -                                                    *
;*                                                                          *
;*--------------------------------------------------------------------------*

; Returns ZERO if successful.

cProc GetCurrentVolume, <FAR, PUBLIC>, <SI, DI>

ParmD lpszVol

cBegin
            push    ds

            ; Set the DTA
            mov     dx,offset DGROUP:DTA
            mov     ah,1Ah              ; Set DTA
            int     21h

            ; Get the current volume name.
            mov     dx,offset DGROUP:VolExtendedFCB
            mov     ah,11h              ; Search for First Entry
            int     21h
            test    al,al
            jnz     GVNoVol

            ; Copy volume name into buffer.
            les     di,lpszVol
            mov     al,'['
            stosb
            cld
            mov     si,offset DGROUP:DTA + 8
            mov     cl,11
GVLoop:
            lodsb
            cmp     al,' '
            jz      GVCont
            stosb
            loop    GVLoop
GVCont:
            mov     al,']'
            stosb

            ; NULL terminate.
            xor     ax,ax
            stosb
GVNoVol:
            pop     ds
cEnd

if 0
;*--------------------------------------------------------------------------*
;*                                                                          *
;*  GetFileAttributes() -                                                   *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc GetFileAttributes, <FAR, PUBLIC>

ParmD lpszPath

cBegin
            push    ds                  ; Preserve DS
            lds     dx,lpszPath         ; DS:DI = lpszPath
            mov     ax,4300h            ; Get File Attributes
            int     21h
            jc      GFAErr
            mov     ax,cx               ; AX = attribute
            jmps    GFAExit             ; Return attribute
GFAErr:     mov     ah,80h              ; Return negative error code
GFAExit:
            pop     ds                  ; Restore DS
cEnd
endif

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  DosMemory()                                                             *
;*                                                                          *
;*  RETURNS     ax = Max DOS memory dx = Max XMS                            *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc DosMemory, <FAR, PUBLIC>, <si>
cBegin
        mov     dx,-1       ; just incase it fails
        mov     ah,08h      ; Get XMS Memory Free
        call    XmsCall     ; call XMS driver, Total memory in DX
        int     12h         ; Total base memory in AX
cEnd


;*--------------------------------------------------------------------------*
;*                                                                          *
;*  ExtendedMemory()                                                        *
;*                                                                          *
;*  find out how much mem is free above 1M                                  *
;*                                                                          *
;*  RETURNS     ax = Extended memory free                                   *
;*                                                                          *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc ExtendedMemory, <FAR, PUBLIC>, <si>
cBegin
        mov     ah, 88h         ; now ask int 15 how much he knows about
        int     15h
cEnd



;*--------------------------------------------------------------------------*
;*                                                                          *
;*  DosVersion()                                                            *
;*                                                                          *
;*  RETURNS     ax = DOS version                                            *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc DosVersion, <FAR, PUBLIC, NODATA>, <si>
cBegin
        mov     ax,3000h
        int     21h
cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  Reboot()                                                                *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc Reboot, <FAR, PUBLIC, NODATA>, <>
cBegin
        ;
        ;   disable memory test
        ;
        mov     ax,40h
        mov     ds,ax
        mov     word ptr ds:[72h],1234h
        ;
        ;   jmp FFFF:0000
        ;
        mov     ax,0FFFFh
        push    ax
        xor     ax,ax
        push    ax
        retf
cEnd nogen

;
;   DosGetEnv
;
;   returns a FAR pointer to the current environment block
;
cProc DosGetEnv,<FAR,PUBLIC>,<si,di>
cBegin
        mov ah,62H
        int 21h                 ; get PSP seg in BX
        mov es,bx
        mov dx,es:[002CH]       ; get environment seg
        mov ax,0                ; DS:AX --> env block
cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  XmsVersion()                                                            *
;*                                                                          *
;*  RETURNS     AX = (LOWORD) XMS spec version				    *
;*              DX = (HIWORD) driver internal version			    *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc XmsVersion, <FAR, PUBLIC>
        LocalD  xms
cBegin
        mov     ah,0
        call    XmsCall
        mov     dx,bx
cEnd


; BOOL XmsInstalled(void);

cProc XmsInstalled, <FAR, PUBLIC>
cBegin
        mov     ax,4300h
	int	2Fh
	cmp	al,80h
	jne	no_xms
	mov	ax,1
	jmp	xms_done
no_xms:
        xor	ax,ax
xms_done:
cEnd


;*--------------------------------------------------------------------------*
;*                                                                          *
;*  XmsCall()                                                               *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc XmsCall, <NEAR>
        LocalD  xms
cBegin
        mov     cx,ax
        mov     ax,4300h    ; Hello XMS?
        int     2fh
        cmp     al,80h
        mov	ax,0	    ; don't set the flags
        jnz     xc_exit
        mov     ax,4310h    ; Get XMS function pointer
        int     2fh
        mov     ax,cx       ; Get XMS function number back
        mov     xms.sel,es
        mov     xms.off,bx
        call    [xms]
xc_exit:
cEnd

; constants used by _get_ext

CMOS_PORT       equ     70H
CMOS_DATA       equ     71H
CMOS_REG_D2     equ     1AH
CMOS_EXT_STF    equ     1718H



;***************************************************************************
; Get extended memory amount.
;---------------------------------------------------------------------------

cProc  get_ext, <FAR, PUBLIC>
cBegin

       MOV        AX, CMOS_EXT_STF
       CALL       CMOS_READ
       XCHG       AL, AH
       CALL       CMOS_READ
  
cEnd   get_ext



;***************************************************************************
; very similar to IBM AT Technical Reference BIOS listing
; determine total extended memory by looking at the CMOS RAM.
;---------------------------------------------------------------------------

CMOS_POPF       PROC NEAR
       IRET
CMOS_POPF       ENDP

CMOS_READ       PROC NEAR
       PUSHF
       ROL      AL, 1
       STC
       RCR      AL, 1
       CLI
       OUT      CMOS_PORT, AL
       NOP

       IN       AL, CMOS_DATA
       PUSH     AX
       MOV      AL, CMOS_REG_D2
       RCR      AL, 1
       OUT      CMOS_PORT, AL
       POP      AX
       PUSH     CS
       CALL     CMOS_POPF
       RET

CMOS_READ       ENDP

;* BOOL PASCAL fnGetRamDriveVersion(char *szVerString);
;*
;* Function will look for and return the presence of ramdrive. If a ramdrive
;* is found it's version string will be returned in the char buffer provided
;* as a formal argument.
;*
;* ENTRY: szVerString - pointer to buffer of sufficent size to hold the
;*                      ramdrive version string. (8 chars).
;*
;* EXIT: Bool as to the presence of a ramdrive.
;*
;*
cProc fnGetRamDriveVersion, <FAR, PUBLIC>, <SI, DI, BX, DX>
   ParmD       szVerString
   LocalV      FixedDisks,   52d
   LocalV      ReadBuf,      512d
   LocalW      Cnt
cBegin

        lea   ax,FixedDisks
        cCall GetFixedDisks,<ax>
        or    ax,ax
        jz    No_Ramdrive
        mov   Cnt,ax                ; Number of disks to check.
        mov   ax,ss                 ; DS = SS for this code.
        mov   ds,ax
        lea   si,FixedDisks

Check_Next_Drv:
        mov   ax,[si]
        mov   cx,1
        lea   bx,ReadBuf
        xor   dx,dx
        push  si
        push  bp
        int   25h                   ; This call will trash SI and BP @!#
        inc   sp                    ; Fix up stack, this call leaves flags.
        inc   sp
        pop   bp
        pop   si
        jc    Next_Drive
        cmp   [bx+2],5290h
        jne   Next_Drive
        cmp   [bx+4],5644h
        je    RamDrive_Found

Next_Drive:
        dec   Cnt
        inc   si
        inc   si
        or    Cnt,0
        jnz   Check_Next_Drv

No_Ramdrive:
        xor   ax,ax
        lds   di,szVerString
        mov   byte ptr ds:[si],0
        jmp   short RD_Done

RamDrive_Found:
        lea   si,ReadBuf
        add   si,3                  ; Increment pointer past near jump.
        les   di,szVerString
        mov   cx,8
        cld
        rep   movsb
        mov   byte ptr es:[di],0    ; Null terminate string.
        mov   ax,1

RD_Done:

cEnd

;****************************************************************************
;
; unsigned fnGetSmartDrvVersion(void);
;
; This function will check to see if smartdrv is installed. If it is found
; that SD is installed we will return it's version number as an unsigned
; int.
;
; ENTRY: None.
;
; EXIT : Returns carry set if SD is not present. If carry clear, AX will
;        contain the Smartdrv version number.
;
; Thanks AAR.
;
;****************************************************************************

cProc fnGetSmartDrvVersion, <FAR, PUBLIC>, <SI, DI, BX, DX>
cBegin

        mov  dx,offset DGROUP:SMRTDRVName ; DS:DX pointer to smartdrv name
        mov  ax,3D02h                     ; Q:func is smartdrv installed ?
        int  21h                          ;   Y: continue.
        jc   short NoSmartShrink          ;   N: No memory steal possible.
        mov  bx,ax                        ; move SD handle to BX for next call

        mov  ax,4400h                     ; IOCTL get device information.
        int  21h                      
        jc   short NoSmartShrinkCls       ; Carry indicates call unsuccesful
        test dx,0080h                     ; Test if clock device.
        jz   short NoSmartShrinkCls       ; if not, we can't steal memory.
        test dx,4000h                     ; Are IOCTL's 02h and 03h supported
        jz   short NoSmartShrinkCls       ; if not we cannot steal memory.
        mov  dx,offset DGROUP:SMRTDRVInfo ; Now, make call to get SD info.
        mov  cx,SIZE SD_IOCTL_Read
        mov  ax,4402h                     ; Read control data from SD.
        int  21h
        jc   short NoSmartShrinkCls       ; Carry indicates call unsuccesful
        cmp  ax,cx                        ; If ax != cx we did not get the
        jne  short NoSmartShrinkCls       ; number of bytes we requested !
        mov  dx,offset DGROUP:SMRTDRVInfo ; DX may be trashed after last call.
        mov  si,dx                        ; si = index into SD_IR struc.
        mov  al,[si.SD_IR_Minor_Ver]      ; Save SD version in ax.
        mov  ah,[si.SD_IR_Major_Ver]
        push ax                           ; Save AX.
        mov  ax,3E00h                     ; Close device, handle in BX.
        int  21h                          ; Call DOS
        pop  ax                           ; restore AX.
        clc
        jmp  short ok_to_steal            ; Ax contains Amt avail to steal.

NoSmartShrinkCls:
        mov  ax,3E00h                     ; Close device, handle in BX.
        int  21h                          ; Call DOS

NoSmartShrink:
        xor  ax,ax                        ; return AX = 0.
        stc                               ; Set carry to indicate no success.

ok_to_steal:

cEnd

endif

sEnd CodeSeg

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\lib\common\exe.c ===
/*
 *  exe.c   Get info from a EXEHDR
 *
 *  Modification History:
 *
 *  4/03/89  ToddLa Wrote it
 *
 */

#include <dos.h>
#include <fcntl.h>
#include <io.h>
//#include <sys/types.h>
//#include <sys/stat.h>

#include "sulib.h"
#include <newexe.h>

char	szDOSCALLS[] = "DOSCALLS";
#define lenDOSCALLS 8

BOOL NEAR PASCAL IsFAPI(int fh, struct new_exe *pne, long off);

/* BOOL FAR PASCAL GetExeInfo(szFile, pBuf, nBuf, fInfo)
 *
 *  Function will return a specific piece of information from a new EXEHDR
 *
 *      szFile      - Path Name a new exe
 *      pBuf        - Buffer to place returned info
 *      nBuf        - Size of buffer
 *      fInfo       - What info to get?
 *
 *          GEI_MODNAME         - Get module name
 *          GEI_DESCRIPTION     - Get description
 *          GEI_FLAGS           - Get EXEHDR flags
 *
 *  returns:  TRUE if successful, FALSE otherwise.
 */

BOOL FAR PASCAL GetExeInfo(PSTR szFile, VOID *pBuf, int nBuf, WORD fInfo)
{
    int         fh;
    DWORD       off;
    BYTE        len;
    struct exe_hdr exehdr;
    struct new_exe newexe;

    fh = FOPEN(szFile);

    if (fh == -1)
        return FALSE;

    if (FREAD(fh, (LPSTR)&exehdr, sizeof(struct exe_hdr)) !=
        sizeof(struct exe_hdr) ||
        exehdr.e_magic != EMAGIC ||
        exehdr.e_lfanew == 0L)
            goto error;        /* Abort("Not an exe",h); */

    FSEEK(fh, exehdr.e_lfanew, SEEK_SET);

    if (FREAD(fh, (LPSTR)&newexe, sizeof(struct new_exe)) !=
        sizeof(struct new_exe))
            goto error;      // Read error

    if (newexe.ne_magic != NEMAGIC)
            goto error;      // Invalid NEWEXE

    switch (fInfo)
    {
        case GEI_FAPI:
            *(BOOL *)pBuf = IsFAPI(fh,&newexe,exehdr.e_lfanew);
            break;

        case GEI_EXEHDR:
            *(struct new_exe*)pBuf = newexe;
            break;

        case GEI_FLAGS:
            *(WORD *)pBuf = newexe.ne_flags;
            break;

        /* module name is the first entry in the resident name table */
        case GEI_MODNAME:
            off = exehdr.e_lfanew + newexe.ne_restab;
            goto readstr;
            break;

        /* module name is the first entry in the non-resident name table */
        case GEI_DESCRIPTION:
            off = newexe.ne_nrestab;
readstr:
            FSEEK(fh, off, SEEK_SET);
            FREAD(fh, &len, sizeof(BYTE));

            nBuf--;         // leave room for a \0

            if (len > (BYTE)nBuf)
                len = (BYTE)nBuf;

            FREAD(fh, (LPSTR)pBuf, len);
            ((PSTR)pBuf)[len] = 0;
            break;

        default:
            goto error;
    }

    FCLOSE(fh);
    return TRUE;

error:
    FCLOSE(fh);
    return FALSE;
}

static int near pascal
strncmpi(char *pch1, char *pch2, int n)
{
    while (*pch1 && --n > 0 && UP_CASE(*pch1) == UP_CASE(*pch2))
	     *pch1++,*pch2++;
    return UP_CASE(*pch1) != UP_CASE(*pch2);
}


/* BOOL NEAR PASCAL IsFAPI(fh,off)
 *
 *  Function will return whether a exe is a FAPI exe
 *
 *      fh      - Open file handle to NEW EXE
 *      off     - Base of module table
 *
 *  returns:  TRUE if FAPI, FALSE otherwise.
 */
BOOL NEAR PASCAL IsFAPI(int fh, struct new_exe *pne, long off)
{
    char    buf[256];
    char   *pch;
    WORD   *pw;
    WORD    len;
    int     n;
    int     i;
    BOOL    f = FALSE;

    /*
     *	look through the imported module table for the name "DOSCALLS" if
     *	found the EXE is a FAPI app.
     *
     *  NOTE! assumes module table will fit in a 256 byte buffer
     */

    // make sure this doesn't point off the end of the buffer we will use

    if (pne->ne_modtab > sizeof(buf))
	return FALSE;

    FSEEK(fh,off,SEEK_SET);
    FREAD(fh,buf,sizeof(buf));

    pw = (WORD*)(buf + pne->ne_modtab);

    for (i = 0; i < pne->ne_cmod; i++)
    {
        pch = buf + pne->ne_imptab + *pw++;

	if (pch > (buf + sizeof(buf)))	// be sure we don't go off the end
	    break;

        n = (int)*pch++;

	if (n == 0)
	    break;

	if (n == lenDOSCALLS && !strncmpi(szDOSCALLS,pch,lenDOSCALLS))
	{
	    f = TRUE;
	    break;
	}
    }

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\lib\common\file.c ===
/*
 *  file.c     Read a file into memory. For DosWin Setup. Also contains
 *             config.sys and autoexec.bat munging. Lots of stuff is far
 *             pascal because we need to call from windows code.
 *  MC
 *
 *  Modification History:
 *
 *  3/24/89  Mike Colee	 Wrote it
 *
 */

#include <dos.h>
#include <malloc.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <io.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "sulib.h"

#define PHILSMAXPATH         256

/* Globaly used pointers to non-translatable text strings. */

char   *pszDEVICE   =               "device";
char   *pszMOUSE    =               "mouse";
char   *pszMSSYS    =               "mouse.sys";
char   *pszHPSYS    =               "mousehp.sys";
char   *pszADD_Y    =               "add_y";
char   *pszSYSEXT   =               ".sys";
char   *pszCOMEXT   =               ".com";
char   *pszPATH     =               "PATH";
char   *pszTEMP     =               "TEMP";
char   *pszSET      =               "set";

/*
 *  Global flag indicating type of setup.
 */

BOOL bIsNetSetup = FALSE;

/* Global far pointers to buffers that will contain autoexec.bat and
   config.sys contents. These can be modified by the DOS or windows
   portion of setup in case the buffer needs to be expanded. */

LPSTR    lpConfigBuff;
LPSTR    lpAutoBuff;

BOOL  gbAutoMod;      /* becomes true if autoexec buffer is modified */
BOOL  gbSysMod;       /* becomes true if config buffer is modified */

PSTR    pConfigWin = CONFIG_WIN;
PSTR    pAutoWin   = AUTOEXEC_WIN;

/* Another stupid global needed bucause of another hack to the config
   munger. Some wierd machines will need a himem switch. This global
   will either contain the switch string or will be NULL if no switch
   is needed. */

extern  char  szHimemSwitch[];

BOOL   gbBufValid = FALSE;  /* Global flag used to detect first call to
                               fnProcessConfig from subsiquent call.    */

/* Functions resolved here that are only used here !! (Local Prototypes ) */

BOOL     fnEditPath(char*);
void     fnModifyDeviceEntry(int, int, PSTR, PSTR);
unsigned fnWriteFiles(LPSTR, char*, char*);
BOOL     fnPathline(LPSTR);
void     fnTerminate(char*);
LPSTR    fnCreateFileBuffer(unsigned);
char     *fnMyStrPath(char*, char*);
BOOL     fnCheckDevice(char*,char*,BOOL);
BOOL     fnFileExists(char*);
BOOL     fnMouseline(LPSTR, PSTR);
BOOL     fnTempLine(LPSTR);

/* unsigned FAR PASCAL fnProcessFile(&iEga,&iHimem,&iSmartdrvMin,&iSmartdrvMAX,&iLim,&iRamdrive,Opt_Flag)
 *
 *  iHimem, iSmartsrv, and iRamdrive are the values of their respective
 *  devices. iHimem will be (1) true if himem is present or is to be
 *  installed. iRamdrive and iSmartdrv are the sizes of the drivers to
 *  be installed or are the sizes of the currently installed devices.
 *
 *  Function will operate on config.sys file according to function chosen
 *  with Opt_Flag. Opt_Flag options are:
 *
 *       RETURN_PRAMS : Function returns size of smartdrive, ramdrive, and
 *                      weather himem.sys is installed. These values are
 *                      returned in pointer provided as func args. Return
 *                      value indicates success or failure.
 *
 *       SET_PRAMS :    Function sets parameters for smartdrive, ramdrive
 *                      and will add himem to config.sys. Parameters are
 *                      set according to values given in func args. A null
 *                      argument leaves that value un affected. Return value
 *                      indicates success or failure. Success indicates that
 *                      the newly modified buffer will need to be written.
 *
 *                      The SET_PRAMS option is also affected by the value
 *                      of the given device parameter. If the value is
 *                      zero the device entry will be un-affected. If a
 *                      positive value is given, that will become the size
 *                      of the installed devive. If a -1 value is given, the
 *                      device will be removed from config.sys
 *
 *       CHECK_COMPAT:  Function will check config.sys for any of the device
 *                      drivers listed in setup.inf as "incompatable". Any
 *                      drivers found will be removed. This option will also
 *                      make sure the files = spec is greater than or = to
 *                      30. Return value indicates true or false as to 
 *                      weather a config buffer will need to be written.
 *
 *       WRITE_SYS   :  Function will rename the current config.sys to
 *                      config.win then write out the newly modified buffer
 *                      as config.sys. Return indicates success or failure.
 *
 *       WRITE_BAK   :  Function will write out the newly modified buffer
 *                      as config.win. Return indicates sucess or failure.
 *
 *       WRITE_NONE  :  Throws out the modified buffer (read free).
 *
 *       MUNGE_AUTO  :  Will add szSetupPath to the path statement in the
 *                      users autoexec.bat file. also will set temp
 *                      environment variable if necessary.
 *
 *       ASSURE_OPEN :  This is a NOP call used only to assure buffers
 *                      for autoexec.bat and config.sys have been opened.
 *
 *  ASSURE_MOUSE_POSITION: This call should be made to assure EGA.SYS will
 *                         be installed before mouse.sys. sigh ...
 *
 */
unsigned FAR PASCAL fnProcessFile(piEGA,piHimem,piSmartdrvMIN,piSmartdrvMAX,piLim,piRamdrive,Opt_Flag)
int       *piEGA;
int       *piHimem;
int       *piSmartdrvMIN;
int       *piSmartdrvMAX;
int       *piLim;
int       *piRamdrive;
unsigned  Opt_Flag;
{
   char szConfigPath[MAXPATHLEN];    /* String buffer to hold fully qualified
                                        path to config.sys file.   */

   char szAutoexecPath[MAXPATHLEN];      /* String buffer to hold fully qualified
                                            path to autoexec.bat file. */
   unsigned    AutoExecWork = 0; /* bit field to determine work needed */
   unsigned    fRetVal = 0;
   unsigned    fRetVal2 = 0;
   int         fhDst;
   char        szTmpPath[15];
   char        szConfigLine[MAXCMDLINELEN];
   char        szLookPath[256];
   int         n = NO_ACTION;            /* do nothing to these entries */
   BOOL        bTmpRetVal = TRUE;


   if (!piHimem)       piHimem       = &n;  /* do nothing to these entries */
   if (!piSmartdrvMIN) piSmartdrvMIN = &n;  /* do nothing to these entries */
   if (!piSmartdrvMAX) piSmartdrvMAX = &n;  /* do nothing to these entries */
   if (!piLim)         piLim         = &n;  /* do nothing to these entries */
   if (!piRamdrive)    piRamdrive    = &n;  /* do nothing to these entries */
   if (!piEGA)         piEGA         = &n;  /* do nothing to these entries */

   if (!gbBufValid)          // If first call or buffer previously written
   {

      #ifndef	DOSONLY
         extern BOOL	   bIsUpgrade;
         extern char    *szTmpConfigPath, *szTmpAutoPath;

         if ( !bIsUpgrade )
         {
            fnGetFilePath(szConfigPath,CONFIG_SYS);
            fnGetFilePath(szAutoexecPath,AUTOEXEC_BAT);
         }
         else
         {

            strcpy( szConfigPath, szTmpConfigPath );
            strcpy( szAutoexecPath, szTmpAutoPath );
         }
      #else
         fnGetFilePath(szConfigPath,CONFIG_SYS);
         fnGetFilePath(szAutoexecPath,AUTOEXEC_BAT);

      #endif

      if (! (lpConfigBuff = fnLoadFile(szConfigPath)) ) {
         lpConfigBuff = fnCreateFileBuffer(CONFIG); // Open failure so create
         if ( lpConfigBuff )
            gbSysMod = TRUE;
         else
            return FALSE;
      }
      else
         gbSysMod = FALSE;               // Config.sys buffer not modified.
      
      if (! (lpAutoBuff = fnLoadFile(szAutoexecPath)) ) {
         lpAutoBuff = fnCreateFileBuffer(AUTOEXEC); // Open failure so create
         if ( lpAutoBuff )
            gbAutoMod = TRUE;
         else
            return FALSE;
      }
      else
         gbAutoMod = FALSE;              // Autoexec.bat buffer not modified.
         
      gbBufValid = TRUE;                 // Ok, files loaded !
   }

   #ifndef DOSONLY

   /* Ok, we have to check for any incompatable devices in config.sys and
      also make sure number of file handles is >= 30. */

   if ( Opt_Flag & CHECK_COMPAT ) {
      int            i = 0;
      PINF           pinfSectP;
      BOOL           bNR;           // No Replace flag for files = line.

      if (bNR = fnUpdateDevice(FILES,RETURN_PRESENCE,szConfigLine)) {
         while ( !ISDIGIT(szConfigLine[i]) && !ISEOF(szConfigLine[i]) )
            ++i;
         if ( atoi(szConfigLine + i) < 30 )    // File less than 30 ?
            bNR = FALSE;
      }
      if ( !bNR ) {
         fnUpdateDevice(FILES,REMOVE_DEVICE,szConfigLine);
         strcpy(szTmpPath,FILES);          // Yes, build files = 30 line.
         strcat(szTmpPath,NUM_FILES);
         if (bTmpRetVal &= fnUpdateDevice(szTmpPath,ADD_DEVICE,szConfigLine))
            gbSysMod = TRUE;
      }
      pinfSectP = infFindSection(NULL,COMPATIBILITY);
      while ( pinfSectP != NULL ) {
         char buf[40];
	      fartonear(buf, pinfSectP);
         if (fnUpdateDevice(buf,RETURN_PRESENCE,szConfigLine)) {
            if (bTmpRetVal &= fnUpdateDevice(buf,REMOUT_DEVICE,szConfigLine))
               gbSysMod = TRUE;
         }
         pinfSectP = infNextLine(pinfSectP);
      }
      if ( bTmpRetVal )
         fRetVal |= CHECK_COMPAT_SUCCESS;
   }

   #endif // DOSONLY

   if ( Opt_Flag & RETURN_PRAMS ) {
      if (fnUpdateDevice(HIMEM,RETURN_PRESENCE,szConfigLine))
         *piHimem = TRUE;
      else
         *piHimem = FALSE;

      if (fnUpdateDevice(EGASYS,RETURN_PRESENCE,szConfigLine))
         *piEGA = TRUE;
      else
         *piEGA = FALSE;

      if (fnCheckDevice(CACHE_SECT,szConfigLine,NO_REMOVE)) {
         *piSmartdrvMAX = fnGetInstalledSize(szConfigLine,1);
         *piSmartdrvMIN = fnGetInstalledSize(szConfigLine,2);
      }
      else {
         *piSmartdrvMAX = NO_ACTION; // no Smartdrive installed.
         *piSmartdrvMIN = NO_ACTION; // no Smartdrive installed.
      }

      if (fnCheckDevice(VDISK_SECT,szConfigLine,NO_REMOVE))
         *piRamdrive = fnGetInstalledSize(szConfigLine,1);
      else
         *piRamdrive = NO_ACTION; // no Ramdrive installed.

      if (fnCheckDevice(LIM_SECT,szConfigLine,NO_REMOVE)) 
         *piLim = fnGetInstalledSize(szConfigLine,1);
      else
         *piLim = NO_ACTION; // no Limulator installed.

      fRetVal |= RET_PRAMS_SUCCESS;
   }

   if ( Opt_Flag & SET_PRAMS ) {
      fnModifyDeviceEntry(*piSmartdrvMAX,*piSmartdrvMIN,SMARTDRV,CACHE_SECT);
      fnModifyDeviceEntry(*piRamdrive,0,RAMDRIVE,VDISK_SECT);
      fnModifyDeviceEntry(*piLim,0,LIMDRIVER,LIM_SECT);
      fnModifyDeviceEntry(*piEGA,0,EGASYS,NULL);
      fnModifyDeviceEntry(*piHimem,0,HIMEM,NULL);
      fRetVal |= SET_PRAMS_SUCCESS;
   }

   /* Make sure at all costs that ega.sys is installed before mouse.sys */

   if ( Opt_Flag & ASSURE_MOUSE_POSITION ) {
      if ( fnUpdateDevice(MOUSE_SYS,RETURN_PRESENCE,szConfigLine) ) {
         fnUpdateDevice(MOUSE_SYS,REMOVE_DEVICE,NULL);
         fnUpdateDevice(szConfigLine,ADD_DEVICE,NULL);
         gbSysMod = TRUE;
      }
   }

   /* What we want to do here is rename original config.sys to config.bak
      and write out modified buffer as config.sys */

   if ( Opt_Flag & WRITE_SYS )
	{
	#ifndef	DOSONLY
	{
		extern	int	bIsUpgrade;

		if ( bIsUpgrade )		/* If Upgrade need to write 		*/
		{							/* to root as a unique name		*/
			extern char		*szAutoBat;
			extern char		*szConfSys;
			extern char		szWinAuto[];
			extern char		szWinConf[];
			extern int far	CreateUniqueName( char *szBuf, char *szFile );
			static int		SaveFile( PSTR szFile, LPSTR lpBuf );

			CreateUniqueName( szWinAuto, szAutoBat );
			fRetVal |= SaveFile( szWinAuto, lpAutoBuff );

			CreateUniqueName( szWinConf, szConfSys );
			fRetVal2 |= SaveFile( szWinConf, lpConfigBuff );
		}
		else
		{
	      if ( gbSysMod )
	         fRetVal2 |= fnWriteFiles(lpConfigBuff,CONFIG_BAK,CONFIG_SYS);
	      if ( gbAutoMod )
	         fRetVal |= fnWriteFiles(lpAutoBuff,AUTOEXEC_BAK,AUTOEXEC_BAT);
		}
	}
	#else
	{
      if ( gbSysMod )
         fRetVal2 |= fnWriteFiles(lpConfigBuff,CONFIG_BAK,CONFIG_SYS);
      if ( gbAutoMod )
         fRetVal |= fnWriteFiles(lpAutoBuff,AUTOEXEC_BAK,AUTOEXEC_BAT);
	}
	#endif

      if (( fRetVal & WRITE_SUCCESS) && (fRetVal2 & WRITE_SUCCESS) )
         Opt_Flag |= WRITE_NONE;
      else 
		{
         if (!(fRetVal2 & WRITE_SUCCESS))
            fRetVal = fRetVal2;
      }
   }

   /* What we do here is write out the modified buffer as config.win */

   if ( Opt_Flag & WRITE_BAK ) {
      if ( gbSysMod )
         fRetVal2 |= fnWriteFiles(lpConfigBuff,NULL,pConfigWin);
      if ( gbAutoMod )
         fRetVal |= fnWriteFiles(lpAutoBuff,NULL,pAutoWin);
      if (( fRetVal & WRITE_SUCCESS) && (fRetVal2 & WRITE_SUCCESS) )
         Opt_Flag |= WRITE_NONE;
      else {
         if (!(fRetVal2 & WRITE_SUCCESS))
            fRetVal = fRetVal2;
      }
   }

   /* All we need to do here is throw out the buffer. */

   if ( Opt_Flag & WRITE_NONE ) {
      FFREE(lpConfigBuff);                        // Free the config buffer
      FFREE(lpAutoBuff);                          // Free the autoexec buffer
      gbSysMod = gbAutoMod = gbBufValid = FALSE;  // Invalidate buffer
      fRetVal |= WRITE_SUCCESS;
   }

   /* The autoexec munging code is only used in the windows part of setup. */

   #ifndef DOSONLY

   /* Ok, let's add the installation path to autoexec.bat */

   if ( Opt_Flag & MUNGE_AUTO ) {

      if (! getenv(pszTEMP) )        // If no temp environment var, argg !...
         AutoExecWork |= DO_TEMP;

      if (! fnMyStrPath(getenv(pszPATH),szSetupPath) )
         AutoExecWork |= DO_PATH;

      if ( bIsNetSetup ) {
         if (! fnMyStrPath(getenv(pszPATH),szDiskPath) )
            AutoExecWork |= DO_PATH;
      }
      
      if ( fnModifyPath(AutoExecWork,NULL))    // Now munge away !!
         gbAutoMod = TRUE;
   }

   #endif // DOSONLY

   if (gbSysMod)
      fRetVal |= CONFIG_DIRTY;
   
   if (gbAutoMod)
      fRetVal |= AUTOEXEC_DIRTY;

   return fRetVal;
}

/* BOOL fnCheckDevice(char *Device_Sect,char *szConfigLine,BOOL bRemoveFlag);
 *
 * Function will check users config.sys file for all [type] device
 * drivers listed in setup.inf under the [type] section. If one of
 * these drivers is found the line from config.sys will be returned in
 * the buffer provided. The device line in question may also be romoved
 * from the config.sys file.
 * 
 * ENTRY: Device_Sect  - This argument specifies the device type to be
 *                       searched for. One of: CACHE, LIM, RAMDRIVE.
 *
 *        szConfigLine - Buffer of sufficent size to hold the line from
 *                       the config.sys file.
 * 
 *        bRemoveFlag  - Booleen flag set to TRUE if device in question
 *                       should be removed from config.sys file.
 * 
 * EXIT: Boolean as to success or failure of function. TRUE if device found.
 *       FALSE if device not found.
 *
 */
BOOL fnCheckDevice(Device_Sect,szConfigLine,bRemoveFlag)
char       *Device_Sect;
char       *szConfigLine;
BOOL       bRemoveFlag;
{
   char   szNearBuf[MAX_INF_LINE_LEN];
   PINF   pinfSectP;
   BOOL   RetVal = FALSE;

   pinfSectP = infFindSection(NULL,Device_Sect);

   while ( pinfSectP ) {
      fartonear(szNearBuf,pinfSectP);
      if ( fnUpdateDevice(szNearBuf,RETURN_PRESENCE,szConfigLine) ) {
         if ( bRemoveFlag )
            fnUpdateDevice(szNearBuf,REMOUT_DEVICE,szConfigLine);
         RetVal = TRUE;
         break;
      }
      pinfSectP = infNextLine(pinfSectP);
   }

   return RetVal;
}

/* void fnGetFilePath(char* sDestBuff, char* sFileName);
 *
 * Function returns fully qualified path for either autoexec.bat or
 * config.sys. Pretty simple assumption here. Get list of fixed diskes,
 * assume first in list is boot drive ???
 *
 * ENTRY: sDestBuff  String pointer to buffer large enough to contain fully
 *                   qualified path to file.
 *
 *        sFileName  Pointer to file name to be path qualified.
 *
 * EXIT:  None
 *
 */
void FAR PASCAL fnGetFilePath(sDestBuff,sFileName)
char    *sDestBuff;
char    *sFileName;
{
   unsigned        Disks[26];

   /* If the installation destination is a remote drive, create new
      autoexec.bat and config.sys files in the destination directory. */

   if ( DosIsRemote((UPCASE(szSetupPath[0]) - 'A')) == REMOTE )
      strcpy(sDestBuff,szSetupPath); 
   else {                            
      GetFixedDisks(Disks);
      sDestBuff[0] = (char)(Disks[0] + 'A');
      sDestBuff[1] = ':';
      sDestBuff[2] = '\\';
      sDestBuff[3] = '\0';
   }
   if ( sFileName )
      catpath(sDestBuff,sFileName);
}

/* unsigned fnWriteFiles(szBuff,NewNameofOrig,BuffName);
 *
 * Function will write the contents of the buffer pointed to by BuffName.
 *
 * ENTRY: 
 *
 *
 */
unsigned fnWriteFiles(szBuff,NewNameofOrig,BuffName)
LPSTR    szBuff;
char     *NewNameofOrig;
char     *BuffName;
{
   char     szTmpBuffNew[MAXPATHLEN];
   char     szTmpBuffName[MAXPATHLEN];
   int      fhDst;

   fnGetFilePath(szTmpBuffNew,BuffName); // Qualify filename for buffer dest.
   if ( NewNameofOrig ) {
      fnGetFilePath(szTmpBuffName,NewNameofOrig); // Qualify filename for buff
      DosDelete(szTmpBuffName);
      DosRename(szTmpBuffNew,szTmpBuffName);      // Ren config.sys config.bak
   }
   _dos_setfileattr(szTmpBuffNew,_A_NORMAL);      // Make sure not read only.
   if (_dos_creat(szTmpBuffNew,_A_NORMAL,&fhDst) != 0) // Create file
      return CREATE_FAIL;
   if (fnWriteFile(szBuff,fhDst))           // Write new config.sys
      return WRITE_FAIL;
   return WRITE_SUCCESS;
}

/* unsigned fnGetInstalledSize(PSTR szConfigLine, int FieldNum);
 *
 * Function will return installed size of either ramdrive or smartdrive
 * given an entire device = line from config.sys.
 *
 * NOTES   : It seems that one of the few things you can depend on in a
 *           config.sys device = entry is that there will be a fully 
 *           qualified device driver name. This means that there will be
 *           a period (.) followed by three chars. (Thank God for this).
 *
 * ENTRY   : Near pointer to line from config.sys ( ramdrive or smartdrv ).
 *         : FieldNum = numeric field following device driver name to be
 *           returned.
 *         
 * RETURNS : Size of installed device as an unsigned value. A return value
 *           of zero indicates default size in use.
 *
 */
unsigned fnGetInstalledSize(szConfigLine,FieldNum)
PSTR     szConfigLine;
int      FieldNum;
{
   unsigned     i = 0;
   unsigned     uFieldCnt = 1;

   while ( szConfigLine[i] != '.' && szConfigLine[i] )
      ++i;

   ++i;    /* point to first char after file type period. */

   /* Now look for a numeric value in the field given as the second function
      argument. */

   while (!ISDIGIT(szConfigLine[i]) && szConfigLine[i] ) // find a digit.
      ++i;

   while ( uFieldCnt != FieldNum ) {
      while (ISDIGIT(szConfigLine[i]) && szConfigLine[i])  // Find next Field
         ++i;
      while (!ISDIGIT(szConfigLine[i]) && szConfigLine[i]) // find a digit.
         ++i;
      ++uFieldCnt;
   }

   return (atoi(szConfigLine + i));   // Convert to int and return value !

}

/* void fnConstructDeviceEntry(PSTR, PSTR, int, int);
 *
 * Function will create a device = entry line that is ready to be placed
 * into the config.sys file. The device will be ramdrive, smartdrv, or
 * himem depending on the device name given. The size of the device is
 * given in iActionValue, and the newly constructed line will be returned
 * in szConfigLine.
 *
 * ENTRY   : szConfigLine, buffer large enough to hold the config line. This
 *           buffer will contain the config line if it is presently in the
 *           config.sys file. (ie, were changing an entry).
 *
 *         : szDeviceName, the name of the device for which were
 *           constructing the new config line for.
 *
 *         : iActionValue, The size of the the ramdrive or smartdrive. If
 *           zero, default size will be used ( no size entry ). Ignored
 *           if himem is the device being operated on.
 *
 * RETURNS : None.
 *
 */

void fnConstructDeviceEntry(szConfigLine,szDeviceName,iActionValue,iMin)
PSTR     szConfigLine;
PSTR     szDeviceName;
int      iActionValue;
int      iMin;
{
   char         szPath[MAXPATHLEN];
   char         szInt_to_String[8];
   char         *p;
   int          i;

#ifndef  DOSONLY
   extern BOOL  bIsUpgrade;
   void far     wsBuildConfigLine( char *szPath, char *szDeviceName );

   if ( bIsUpgrade )
      wsBuildConfigLine(szConfigLine, szDeviceName );
   else
   {
      if ( !strcmpi( szDeviceName, HIMEM ) )
         fnGetFilePath( szPath, szDeviceName );
      else
      {
         ExpandFileName("0:",szPath);      // Get path to device driver.
         catpath( szPath, szDeviceName );  // Cat with device driver name.
      }
      strcpy(szConfigLine,pszDEVICE);     // Copy in device =
      i = strlen(szConfigLine);
      szConfigLine[i++] = EQUAL;
      szConfigLine[i] = NULL;
      strcat( szConfigLine,szPath );     // Copy in the fully qualified driver
     }
#else
      if ( !strcmpi( szDeviceName, HIMEM ) )
         fnGetFilePath( szPath, szDeviceName );
      else
      {
         ExpandFileName("0:",szPath);      // Get path to device driver.
         catpath( szPath, szDeviceName );  // Cat with device driver name.
      }
      strcpy(szConfigLine,pszDEVICE);     // Copy in device =
      i = strlen(szConfigLine);
      szConfigLine[i++] = EQUAL;
      szConfigLine[i] = NULL;
      strcat( szConfigLine,szPath );     // Copy in the fully qualified driver
#endif

   if (iActionValue && (strcmpi(szDeviceName,HIMEM)) &&
      (strcmpi(szDeviceName,EGASYS))) {
      i = strlen(szConfigLine);
      szConfigLine[i++] = SPACE;
      szConfigLine[i] = NULL;
      p = itoa(iActionValue,szInt_to_String,10);
      strcat(szConfigLine,szInt_to_String);
      if ( iMin ) {
         i = strlen(szConfigLine);
         szConfigLine[i++] = SPACE;
         szConfigLine[i] = NULL;
         p = itoa(iMin,szInt_to_String,10);
         strcat(szConfigLine,szInt_to_String);
      }
   }
   if (! (strcmpi(szDeviceName,RAMDRIVE)) )
      strcat(szConfigLine,EMM_SWITCH);

   if (! (strcmpi(szDeviceName,HIMEM)) && szHimemSwitch[0] ) {
      strcat(szConfigLine," /M:");
      strcat(szConfigLine,szHimemSwitch);
   }
}

/* LPSTR fnCreateFileBuffer(unsigned fType);
 *
 * This function is called in the cases where the user does not have either
 * an autoexec.bat or config.sys file. In these cases we create a buffer on
 * the far heap and build the appropiate file and return a long pointer to
 * the buffer.
 *
 * ENTRY: fType - This is a flag value specifing which file buffer to create
 *                must be either AUTOEXEC or CONFIG.
 *
 * EXIT:  LPSTR - Returns long pointer to newly created buffer.
 *
 */
LPSTR fnCreateFileBuffer(fType)
unsigned    fType;
{

   LPSTR          lpBuf;  /* far pointer to buffer. */
   LPSTR            pTo;  /* Used to keep pointer into new buffer. */
   unsigned         len;  /* used to calculate length of buff for autoexec */
   char   TmpWork1[128];  /* temp work buffers for string construction. */
   char   TmpWork2[128];

   if ( fType == CONFIG ) {
      /* First, create files = line */
      strcpy(TmpWork1,FILES" "NUM_FILES);
      /* Now, create buffers = line */
      strcpy(TmpWork2,BUFFERS" "NUM_FILES);
   }
   else {
      TmpWork1[0] = '\0';
      strcpy(TmpWork2,pszPATH);
      strcat(TmpWork2," ");
      strcat(TmpWork2,szSetupPath);
   }

   /* Now calculate length of buffer required for new file and place newly
      created strings into new buffer. Finaly return pointer to buffer     */

   len = (strlen(TmpWork1) + strlen(TmpWork2) + 8 );
   lpBuf = FALLOC(len);                              /* Allocate buffer */
   if (!lpBuf) 
      return NULL;  /* if allocation failes, return null pointer. */
   /* Now, write newly constructed strings into buffer ! */
   pTo = lpBuf;
   pTo = fnCopyBuf(TmpWork1,pTo,REMAINDER);
   *pTo = CR, ++pTo, *pTo = LF, ++pTo;       /* attach a cr,lf pair. */
   pTo = fnCopyBuf(TmpWork2,pTo,REMAINDER);
   *pTo = CR, ++pTo, *pTo = LF, ++pTo;       /* attach a cr,lf pair. */
   *pTo = '\0';                              /* terminate new buffer.    */
   return lpBuf;                             /* return pointer to buffer */
}

/* void fnModifyDeviceEntry(int, int, PSTR, PSTR);
 *
 *  Function will operate on a single line from config.sys This function
 *  is only called by fnProcessConfig. This function is given an option
 *  value, a pointer to the config.sys buffer, and the device name to be
 *  operated on. Depending on action value the following operations are
 *  possible.
 *
 *   NO_ACTION      : No action taken.
 *
 *   REMOVE_DEVICE  : Device = line will be removed from config.sys buffer.
 *
 *   default        : Device = line will be added to config.sys buffer. If
 *                    the action value is zero, the default size for that
 *                    device will be used. Otherwise the size given will
 *                    be used.
 *
 *   RETURN: None
 *	
 */ 
void fnModifyDeviceEntry(iActionValue, iMin, szDeviceName, szDeviceSect)
int          iActionValue;
int          iMin;
PSTR         szDeviceName;
PSTR         szDeviceSect;
{

   static char        szConfigLine[MAXPATHLEN];

   szConfigLine[0] = '\0';

   switch (iActionValue) {
      case NO_ACTION:
         break;
      case REMOVE_DEVICE:
         if ( szDeviceSect )
            fnCheckDevice(szDeviceSect,szConfigLine,YES_REMOVE);
         fnUpdateDevice(szDeviceName,REMOVE_DEVICE,NULL);
         gbSysMod = TRUE;
         break;
      default:   // Install device with given numerical size or default.
         if ( szDeviceSect )
            fnCheckDevice(szDeviceSect,szConfigLine,YES_REMOVE);
         fnUpdateDevice(szDeviceName,REMOVE_DEVICE,NULL);
         fnConstructDeviceEntry(szConfigLine,szDeviceName,iActionValue,iMin);
         if ( strcmpi(HIMEM,szDeviceName) )
            fnUpdateDevice(szConfigLine,ADD_DEVICE,szConfigLine);
         else
            fnUpdateDevice(szConfigLine,ADD_DEVICE_FIRST,szConfigLine);
         gbSysMod = TRUE;
   }
}

/* LPSTR fnLoadFile(szFile);
 *
 *  Reads the entire file into a far malloc'd buffer and returns a pointer
 *  to the buffer. End of lines are indicated by cr,lf pairs. EOF, or in
 *  this case, the end of the buffer is indacated by a single NULL byte.
 *
 *  ENTRY: szFile	- File name to load, null terminated string required.
 *	
 *
 *  RETURNS: Far pointer to loaded buffer or NULL on Failure.
 *
 */
LPSTR NEAR PASCAL fnLoadFile(szFile)
PSTR  szFile;
{
   LPSTR        lpBuf = NULL;
   WORD         fh = -1;
   char         szDst[MAXPATHLEN];
   unsigned     len;

   /* First off, Open the file */
   /* first try to open passed parameter as is */

   fh = FOPEN(szFile);

   if (fh == -1)
      goto error_close;

   /* Find size of file and allocate buffer in far heap */

   len = (WORD)FSEEK(fh,0L,SEEK_END); /* find File size in Bytes */
   FSEEK(fh,0L,SEEK_SET);

   if ( len >= 65000 )     /* limit on size of files we can load. */
      goto error_close;

   lpBuf = FALLOC(len+1);  /* Allocate buffer plus one 1 for 0 terminator */
   if (!lpBuf)
      goto error_close;

   /*	Read ALL of the file into memory, Including comments, ect. */
   
   if ( FREAD(fh,lpBuf,len) != len ) {
      FFREE(lpBuf);
      lpBuf = NULL;
   }
   else
      lpBuf[len] = 0;

error_close:

   FCLOSE(fh);
   return lpBuf;

}

/* BOOL NEAR PASCAL fnUpdateDevice(szDeviceName,Opt_Flag,szConfigLine);
 *
 *  Function will add, delete or determine presence of a device = driver
 *  or files = in the users config.sys file.
 *
 *  ENTRY: szDeviceName: Name of device you intend to operate on. ie 
 *                       SMARTDRV.SYS ect. In the case of ADD_DEVICE
 *                       must point to a complete Config.sys device = entry
 *                       or files = entry.
 *
 *                       Example:  device = c:\dev\vt52.sys /c /l
 *                       Example:  files  = 30
 *
 *                       In the case of REMOVE_DEVICE of RETURN_PRESENCE
 *                       should point to either a device driver name or
 *                       If operating on the files = line, must point to
 *                       string "files"
 *
 *         Opt_Flag    : One of four mutually exclusive options.
 *
 *         1.) ADD_DEVICE:      Adds a new device = line or files = line.
 *         3.) ADD_DEVICE_FIRST Adds new device = line as the FIRST device.
 *         3.) REMOVE_DEVICE:   Removes entire device = line or files = line.
 *         4.) RETURN_PRESENCE: Return BOOL as to presence of device = line
 *                              or files = line.
 *         5.) REMOUT_DEVICE:   Comment out the device line in question.
 *
 *        szConfigLine : In the case of RETURN_PRESENCE This must be a near
 *                       pointer to a buffer of sufficient size to hold the
 *                       requested line from config.sys (MAXCMDLINELEN).
 *                       
 *
 *  NOTES: When adding a device = line to config.sys, it will be placed into
 *         the files as the second device = line. When adding a files = line
 *         it will be made the first line in the file.
 *
 *  RETURNS: On add or remove return value indicates success or failure.
 *           On return_presence, return value indicates presence
 *           or lack of presence of config.sys line.
 *	
 *               
 */
BOOL NEAR PASCAL fnUpdateDevice(szDeviceName,Opt_Flag,szConfigLine)
PSTR      szDeviceName;
unsigned  Opt_Flag;
PSTR      szConfigLine;
{

   BOOL           bFiles = FALSE;
   LPSTR          lpFileOffset = lpConfigBuff;
   LPSTR          lpFileBuf = lpConfigBuff;
   LPSTR          pTo;
   LPSTR          lpTmpHold;
   unsigned       iCharCnt;
   char           szDevice[7];

   /* Initial seek to beginning of first line in config.sys buffer. */

   while ( ISWHITE(*lpFileOffset) ) 
      ++lpFileOffset;
   if ( ISEOF(*lpFileOffset) )
      return FALSE;

   if ( (Opt_Flag == ADD_DEVICE) || (Opt_Flag == ADD_DEVICE_FIRST) ) {

      /* Allocate new buff large enough for old + new device + CR,LF,NULL
         + another possible CR,LF,NULL */

      pTo = FALLOC(fnLstrlen(lpFileBuf) + strlen(szDeviceName) + 6);
      if (!pTo)
         return FALSE;

      lpConfigBuff = pTo;               // Save pointer to head of new buff.
      if (strnicmp(szDeviceName,FILES,strlen(FILES))) {
         // While not to device section yet, copy lines to new buffer.
         while (strncmpinf(pszDEVICE,lpFileOffset,6) && !ISEOF(*lpFileOffset)) {
            pTo = fnCopyBuf(lpFileOffset,pTo,fnLinelenl(lpFileOffset));
            lpFileOffset = fnNextConfigLine(lpFileOffset);
         }
         if ( Opt_Flag != ADD_DEVICE_FIRST ) {
            while ( !ISEOF(*lpFileOffset) ) {
               pTo = fnCopyBuf(lpFileOffset,pTo,fnLinelenl(lpFileOffset));
               lpFileOffset = fnNextConfigLine(lpFileOffset);
            }
         }
      }
      // Put new device line in.
      if ( ISEOF(*lpFileOffset) && !ISCRLF(*(lpFileOffset-1)) ) {
         *pTo = CR,++pTo;
         *pTo = LF,++pTo;
      }
      pTo = fnCopyBuf((LPSTR)szDeviceName,pTo,strlen(szDeviceName)); 
      *pTo = CR,++pTo;
      *pTo = LF,++pTo;
      fnCopyBuf(lpFileOffset,pTo,REMAINDER); // attach remainder of buff.
      FFREE(lpFileBuf);                      // Free the old buffer.
      return TRUE;                           // Return success !
   }
   else { 
      // We need to either remove or verify presence of a device.
      pTo = lpFileOffset;
      if (!strcmpi(szDeviceName,FILES)) {
         strcpy(szDevice,FILES);
         bFiles = TRUE;
      }
      else 
         strcpy(szDevice,pszDEVICE);

      /* Now, while we have not hit the end of the buffer ... */
      while (!(ISEOF(*lpFileOffset))) {
         pTo = lpFileOffset;
         if ( !strncmpinf(szDevice,lpFileOffset,strlen(szDevice)) ) {
            while ( *lpFileOffset != EQUAL && !ISEOL(*(lpFileOffset+1)) )
               ++lpFileOffset;
            ++lpFileOffset;
            while ( ISFILL(*lpFileOffset) && *lpFileOffset )
               ++lpFileOffset;
            while ( !ISWHITE(*lpFileOffset) && *lpFileOffset )
               ++lpFileOffset;
            --lpFileOffset;
            iCharCnt = 0;
            while ( !DEVICESEP(*lpFileOffset) && (lpFileOffset > pTo) )
               --lpFileOffset, ++iCharCnt;
            ++lpFileOffset;
            if ( bFiles || !strncmpinf(szDeviceName,lpFileOffset,iCharCnt) &&
               iCharCnt == strlen(szDeviceName) ) {
               switch(Opt_Flag) {        // !!! we found the device !!!.
                  case RETURN_PRESENCE:
                     fnCopyBuf(pTo,(LPSTR)szConfigLine,(fnLinelenl(pTo)));
                     fnTerminate(szConfigLine);
                     return TRUE;
                  case REMOVE_DEVICE:
                     lpFileOffset = fnNextConfigLine(lpFileOffset);
                     fnCopyBuf(lpFileOffset,pTo,REMAINDER);
                     return TRUE;
                  case REMOUT_DEVICE:
                     *pTo = CR,++pTo;
                     *pTo = LF,++pTo;
                     lpFileOffset = fnNextConfigLine(lpFileOffset);
                     fnCopyBuf(lpFileOffset,pTo,REMAINDER);
                     return TRUE;
               }
            }
         }
         lpFileOffset = fnNextConfigLine(lpFileOffset);
      }
      return FALSE;
   }
}

/* INT NEAR PASCAL strncmpinf(PSTR pch1, LPSTR pch2, int n);
 *
 * Function compares N chars of strings without regaurd to case. I needed
 * this so that I could compare a string in near mem with a string in far
 * mem.
 *
 * ENTRY: Near string pointer, far string pointer, number of chars to comp.
 *
 * RETURNS: 0 if compare == ok. non zero if strings do not compare.
 *
 */
int NEAR PASCAL strncmpinf(pch1, pch2, n)
PSTR      pch1;
LPSTR     pch2;
int       n;
{
   while (*pch1 && --n > 0 && toupper(*pch1) == toupper(*pch2))
      *pch1++,*pch2++;
   return toupper(*pch1) != toupper(*pch2);
}

/* LPSTR NEAR PASCAL fnCopyBuff(LPSTR pFrom, LPSTR pTo, unsigned iCnt);
 *
 * Function moves the remaining contents of a text buffer from one location
 * within the buffer to a new location within the buffer. This is used to
 * either remove or make room for an entry in the file buffer.
 *
 * ENTRY: pointers To and From designate where the remaining protion of the
 *        buffer will be moved to. The new buffer will be NULL terminated.
 *
 * EXIT:  Returns pointer to next available char position in the buffer.
 *
 */
LPSTR fnCopyBuf(pFrom,pTo,iCnt)
LPSTR     pFrom;
LPSTR     pTo;
unsigned  iCnt;
{
   // While not End of buffer or end of count.

   while ( *pFrom != 0 && iCnt != 0 ) {
      *pTo = *pFrom;                          // Do the move.
      ++pTo;
      ++pFrom;          // Increment buffer poointers.
      --iCnt;           // Decrement count.
   }
   if ( *pFrom == '\0' )
      *pTo = *pFrom;      // Terminate newly expanded or contracted buffer.
   return pTo;
}

/* unsigned fnLstrlen(LPSTR)
 *
 * Returns length of string not including null terminating
 * char (far pointer version).
 *
 * ENTRY:    LPSTR to buffer
 * EXIT:     length of string.
 * WARNING:
 * EFFECTS:  No global data effected.
 *
 */
unsigned fnLstrlen(lpBuf)
LPSTR  lpBuf;
{

   unsigned i = 0;

   while ( *lpBuf++ != '\0' )
      ++i;
   return i;

}

/* int fnLinelenl(LPSTR)
 *
 * Returns length of buffer line up to and including any LF and CR chars.
 *
 * (far pointer version).
 *
 * ENTRY:    LPSTR to buffer
 * EXIT:     length of line.
 * WARNING:
 * EFFECTS:  No global data effected.
 *
 */
int fnLinelenl(lpBuf)
LPSTR  lpBuf;
{

   unsigned i = 0;

   while (!ISEOL(*lpBuf))
      ++i,++lpBuf;

   while ( ISCRLF(*lpBuf) )
      ++i,++lpBuf;

   return i;

}

/* LPSTR fnNextConfigLine(LPSTR lpFileOffset);
 *
 * Advances Far pointer into config.sys files to the first non-white char
 * of the next line in the buffer containing the file. Will return null
 * in the EOF case.
 *
 * ENTRY: Far pointer into buffer holding file.
 *
 * EXIT:  Far pointer into buffer holding file. NULL on EOF.
 *
 */
LPSTR fnNextConfigLine(lpFileOffset)
LPSTR    lpFileOffset;
{

   while ( !ISEOL(*lpFileOffset) )   //seek end of line.
      ++lpFileOffset;
 
   /* seek to beginning of next line, or end of buffer. */
 
   while ( ISWHITE(*lpFileOffset) )
      ++lpFileOffset;

   return lpFileOffset;
}

/* int fnWriteFile(LPSTR szBuffer, int fh);
 *
 *  Function will determine length of buffer, write buffer out to file
 *  handle provided. Close the files, return condition of opertion.
 *
 *
 *
 */
int NEAR PASCAL fnWriteFile(szBuffer,fh)
LPSTR    szBuffer;
int      fh;
{

   unsigned   len;
   int        condition;

   len = fnLstrlen(szBuffer);
   if ( FWRITE(fh,szBuffer,len) != len )   /* Write Error ! */
      condition = FERROR();
   else
      condition = ERROR_OK;

   FCLOSE(fh);
   return condition;
}

/* void fnTerminate(char* Buffer);
 *
 * Function seeks to the end of the buffer
 * appended and NULL teriminates the buffer.
 *
 * ENTRY: buffer - Pointer to buffer containing path.
 *
 * EXIT:  None
 *
 */
void fnTerminate(Buffer)
char      *Buffer;
{
   unsigned     Index;

   Index = fnLinelenl(Buffer);
   --Index;

   while(ISWHITE(Buffer[Index]))  //Back up to some meat.
      --Index; 

   Buffer[Index+1] = '\0';
}

/* BOOL fnMystrstr(char *szSrcStr, char *szSearchStr);
 *
 * Function will return BOOL value as to weather the Search string exists
 * any where within the source string. The difference between this func
 * the C run time func is that this one is simpler and is also not case
 * sensitive.
 *
 * ENTRY: szSrcStr    - Char buffer to be searched.
 *
 *        szSearchStr - String that will be searched for.
 *
 * EXIT:  BOOL value as to weather or not string was found.
 *
 *
 * WARNING: Source and search strings MUST be null terminated.
 *          
 *
 */
BOOL fnMystrstr(szSrcStr, szSearchStr)
char       *szSrcStr;
char       *szSearchStr;
{
   unsigned      len;             // Get length of search string.

   len = strlen(szSearchStr);

   while ( !ISEOL(*szSrcStr) ) {
      if ( ! strnicmp(szSrcStr,szSearchStr,len))
         return TRUE;
      ++szSrcStr;
   }
   return FALSE;

}

#ifndef DOSONLY

/* BOOL fnModifyPath(unsigned WorkNeeded, PSTR szMouseName);
 *
 * This function can add the windows installation path to the users path
 * statement in autoexec.bat This function will also add a temp environment
 * variable to the users autoexec.bat file if specified.
 *
 * ENTRY: WorkNeeded - bit field that will specify any combination of the
 *        following options:
 *
 *        DO_PATH  : This option tells the func to munge the users path.
 *
 *        DO_MOUSE : This option will search for a mouse driver installation
 *                   and replace it with a new installation line which will
 *                   install the new mouse driver from the windows
 *                   installation directory.
 *
 * EXIT : Function returns a boolean as to the success, or failure.
 *
 */
BOOL NEAR PASCAL fnModifyPath(WorkNeeded,szMouseName)
unsigned     WorkNeeded;
PSTR         szMouseName;
{
   LPSTR          lpFileOffset = lpAutoBuff;
   LPSTR          pHead = lpAutoBuff;
   LPSTR          pTo;
   char           TmpWorkSpace[PHILSMAXPATH]; // large enough for path construction.
   char           *szSearch;         // used to search through a string.
   unsigned       len;               // used to calc size of new buffer.
   BOOL           bNew      = FALSE;
   BOOL           bMouseFnd = TRUE;
   BOOL           bPathFnd  = TRUE;
   BOOL           bTempFnd  = TRUE;
   BOOL           bBufMod   = FALSE;
   
   if (! WorkNeeded )
      return bBufMod;

   if ( WorkNeeded & DO_PATH )
      bPathFnd = FALSE;

   if ( WorkNeeded & DO_MOUSE )
      bMouseFnd = FALSE;

   if ( WorkNeeded & DO_TEMP )
      bTempFnd = FALSE;

   /* Initial seek to beginning of first line in autoexec.bat buffer. */

   while ( ISWHITE(*lpFileOffset) && *lpFileOffset != '\0' ) 
      ++lpFileOffset;
   if (*lpFileOffset == NULL)
      return FALSE;

   /* Allocate new buff big enough for the following new items: */

   len = (fnLstrlen(lpFileOffset) + /* Length of current autoexec.bat    */
   (strlen(szSetupPath))          + /* path, 1 for path.                 */
   7 );                             /* 2 CR, 2 LF, 2 NULL chars, 1 ';'   */

   if ( bIsNetSetup )               // If were adding a net source dir to the
      len += strlen(szDiskPath);    // path allocate space for it too !

   if ( WorkNeeded & DO_MOUSE )     // If we have to add a mouse install ?
      len += MAXPATHLEN;

   if ( WorkNeeded & DO_TEMP )         // strlen of installation dir + length
      len += (strlen(szSetupPath)+16); // of "set temp=tempCR,LF,NULL"

   pTo = FALLOC(len);
   if (!pTo)
      return FALSE;
   lpAutoBuff = pTo;               // Save pointer to head of new buff.

   /* Now, start looking through the autoexec.bat file for relevent info */
   
   while ( !ISEOF(*lpFileOffset) )  {     // While not at end of autoexec.bat
      bTempFnd |= fnTempLine(lpFileOffset);        // check if line is temp ?
      if ( (WorkNeeded & DO_PATH) && !bPathFnd ) {
         if ( fnPathline(lpFileOffset) ) {  // check if path ?
            bPathFnd = TRUE;

            /* A somewhat dangerous but usually safe assumption: The path
               will be less than PHILSMAXPATH chars. */

            fnCopyBuf(lpFileOffset,(LPSTR)TmpWorkSpace,fnLinelenl(lpFileOffset));
            fnTerminate(TmpWorkSpace);           // Find end, NULL terminate.
            if ( fnEditPath(TmpWorkSpace) ) {    // Edit the path.
               pTo = fnCopyBuf(TmpWorkSpace,pTo,strlen(TmpWorkSpace));
               *pTo = CR,++pTo;
               *pTo = LF,++pTo;
               bNew = TRUE;
               bBufMod = TRUE;
            }
         }
      }
      if ( (WorkNeeded & DO_MOUSE) && !bMouseFnd ) {
         if ( fnMouseline(lpFileOffset,pszMOUSE) ) {  // Mouse Line ?
            bMouseFnd = TRUE;
            if (! stricmp(szMouseName,pszADD_Y) ) {
               fnCopyBuf(lpFileOffset,(LPSTR)TmpWorkSpace,fnLinelenl(lpFileOffset));
               fnTerminate(TmpWorkSpace);
               if (! fnMystrstr(TmpWorkSpace,"\Y") )
                  strcat(TmpWorkSpace," /Y");
            }
            else {
               strcpy(TmpWorkSpace,szSetupPath);
               catpath(TmpWorkSpace,szMouseName);
               strcat(TmpWorkSpace,pszCOMEXT);
               strcat(TmpWorkSpace," /Y");
            }
            pTo = fnCopyBuf(TmpWorkSpace,pTo,strlen(TmpWorkSpace));
            *pTo = CR,++pTo;
            *pTo = LF,++pTo;
            bNew = TRUE;
            bBufMod = TRUE;
         }
      }
      if (! bNew )
        pTo = fnCopyBuf(lpFileOffset,pTo,fnLinelenl(lpFileOffset));
      bNew = FALSE;
      lpFileOffset = fnNextConfigLine(lpFileOffset);
      if ( bPathFnd && bMouseFnd && bTempFnd) {      // If all work is done !
         fnCopyBuf(lpFileOffset,pTo,REMAINDER);
         break;                                     // Then were done !!!
      }
   }
   if (! bPathFnd ) {      // Now if a path was not found, add one.
      if ( ISEOF(*lpFileOffset) && !ISCRLF(*(lpFileOffset-1)) ) {
         *pTo = CR,++pTo;
         *pTo = LF,++pTo;
      }
      strcpy(TmpWorkSpace,pszPATH);
      strcat(TmpWorkSpace,"=");
      strcat(TmpWorkSpace,szSetupPath);
      pTo = fnCopyBuf((LPSTR)(TmpWorkSpace),pTo,strlen(TmpWorkSpace));
      *pTo = CR,++pTo;
      *pTo = LF,++pTo;
      bBufMod = TRUE;
      pTo = fnCopyBuf(lpFileOffset,pTo,REMAINDER);
   }
   if (! bTempFnd ) {           // And if a temp was not found add one.
      if ( ISEOF(*lpFileOffset) && !ISCRLF(*(lpFileOffset-1)) && bPathFnd ) {
         *pTo = CR,++pTo;
         *pTo = LF,++pTo;
      }
      strcpy(TmpWorkSpace,pszSET);     // construct set statement.
      strcat(TmpWorkSpace," ");
      strcat(TmpWorkSpace,pszTEMP);
      strcat(TmpWorkSpace,"=");
      strcat(TmpWorkSpace,szSetupPath);
      catpath(TmpWorkSpace,pszTEMP);
      pTo = fnCopyBuf((LPSTR)(TmpWorkSpace),pTo,strlen(TmpWorkSpace));
      *pTo = CR,++pTo;
      *pTo = LF,++pTo;
      *pTo = '\0';
      szSearch = TmpWorkSpace;
      while ( *szSearch != '=' )
         ++szSearch;
      ++szSearch;
      DosMkDir(szSearch);             // Make the directory.
      bBufMod = TRUE;
   }
   if ( ISEOF(*lpFileOffset) )
      *pTo = '\0';                   // Assure buffer terminated !!!
   FFREE(pHead);                     // Free the old buffer.
   return bBufMod;                   // Return state of buffer
}

/* BOOL fnEditPath(char *ExistingPath);
 *
 * Function will add the szSetupPath to the users path statement in the
 * autoexec.bat file. The szSetupPath will be the first location in the
 * path statement. The path can be in about a million fucked up forms
 * depending on the level of stupidity in the user. Here are a few to
 * think about. DOS will accept any of these.
 *
 *   PATH=C:\foo;C:\foobar;...
 *   SET PATH=C:\foo;C:\foobar;...
 *   PATH C:\foo;C:\foobar;...
 *   PATH =C:\foo;C:\foobar;...
 *   PATH= C:\foo;C:\foobar;...
 *   PATH = C:\foo;C:\foobar;...
 *   
 * ENTRY: ExistingPath - near buffer containing the path statement to be
 *                       edited.
 *
 * EXIT:  BOOL, TRUE  = Path succesfully modified.
 *              FALSE = Path was too long after modification (path >= 128).
 *
 */
BOOL fnEditPath(ExistingPath)
char       *ExistingPath;
{
   char      TmpWorkSpace[PHILSMAXPATH];
   char      NewPathBuff[PHILSMAXPATH];
   char      *Path;
   char      *InsertPoint;
   unsigned  i = 0;

   Path = ExistingPath;
   while ( *Path != 'h' && *Path != 'H' ) {  /* look for end of PATH */
      TmpWorkSpace[i] = *Path;
      ++Path, ++i;
   }
   TmpWorkSpace[i] = *Path++;             /* Cat on the 'h' or 'H'       */
   TmpWorkSpace[i+1] = *Path++;           /* Cat on a ' ' or an '='      */
   TmpWorkSpace[i+2] = '\0';              /* Terminate.                  */

   /* There may be extranious crapola here so lets rid ourselvs of it. */
   
   while ( *Path == ' ' || *Path == '=' || *Path == '\t' )
      ++Path;

   strcpy(NewPathBuff,Path);

   /* now we have a "path =" or "path " null terminated string. Now we need
      to assure that in all cases of path editing, the users local windows
      installation directory comes before a shared windows directory. This
      of course is only relevent if we are doing a net setup. */

   strcat(TmpWorkSpace,szSetupPath);     /* Now cat the new path seg */
   strcat(TmpWorkSpace,";");             /* Cat on the seperator     */

   if ( (InsertPoint = fnMyStrPath(NewPathBuff,szSetupPath)) ) {
      *InsertPoint++ = '\0';
      while ( !ISEOL(*InsertPoint) && *InsertPoint != ';' )
         ++InsertPoint;
      if ( *InsertPoint == ';' )
         ++InsertPoint;
      strcat(NewPathBuff,InsertPoint);
   }
   if ( bIsNetSetup ) {
      strcat(TmpWorkSpace,szDiskPath);     /* Now cat the new path seg */
      strcat(TmpWorkSpace,";");            /* Cat on the seperator     */
      if ( (InsertPoint = fnMyStrPath(NewPathBuff,szDiskPath)) ) {
         *InsertPoint++ = '\0';
         while ( !ISEOL(*InsertPoint) && *InsertPoint != ';' )
            ++InsertPoint;
         if ( *InsertPoint == ';' )
            ++InsertPoint;
         strcat(NewPathBuff,InsertPoint);
      }
   }
   strcat(TmpWorkSpace,NewPathBuff);       /* Now the rest of the path */

   /* Last but not least, check to make sure we don't insert a path that
      is too long into the dudes autoexec.bat, also check to make sure
      we don't edit the path when there was no reason to */
   
   if ( strlen(TmpWorkSpace) >= PHILSMAXPATH )
      return FALSE;
   else {
      if (! stricmp(TmpWorkSpace,ExistingPath) )
         return FALSE;
      strcpy(ExistingPath,TmpWorkSpace);   /* Put path back into orig buf */
      return TRUE;
   }
}

/* BOOL fnPathline(LPSTR);
 *
 * Function determines if the string pointed to by sStrPtr is a path statement
 * of any one of three possible forms:
 *
 *   PATH=C:\foo;C:\foobar;...
 *   SET PATH=C:\foo;C:\foobar;...
 *   PATH C:\foo;C:\foobar;...
 *
 * Function returns true or false as to weather or not the string is a path
 * or not.
 *
 */
BOOL fnPathline(sStrPtr)
LPSTR    sStrPtr;
{
   if ( !strncmpinf(pszPATH,sStrPtr,strlen(pszPATH)) ) // First, check the easy case
      return TRUE;
   else {
      if ( !strncmpinf(pszSET,sStrPtr,strlen(pszSET)) ) {
         sStrPtr += strlen(pszSET);            // Advance past set statement
         while ( ISFILL(*sStrPtr) )            // Seek for beginning of path
            ++sStrPtr;
         if ( !strncmpinf(pszPATH,sStrPtr,strlen(pszPATH)) )
            return TRUE;
      }
   }
   return FALSE;
}

/* char *fnMyStrPath(char *szPath, char *szSearchStr);
 *
 * Function will return BOOL value as to weather the Search string exists
 * any where within the source string. The difference between this func
 * the C run time func is that this one is simpler and is also not case
 * sensitive.
 *
 * ENTRY: szPath      - Char buffer to be searched.
 *
 *        szSearchStr - String that will be searched for.
 *
 * EXIT:  char* - Returns pointer to first char of string that matches.
 *
 *
 * WARNING: Source and search strings MUST be null terminated.
 *          
 *
 */
char *fnMyStrPath(szPath, szSearchStr)
char       *szPath;
char       *szSearchStr;
{
   unsigned      len;             // Get length of search string.

   len = strlen(szSearchStr);

   while (! ISEOL(*szPath) ) {
      if ( ! strnicmp(szPath,szSearchStr,len)) {
         if ( ISEOL(*(szPath + len)) || *(szPath + len) == ';' )
            return szPath;
      }
      ++szPath;
   }
   return NULL;
}

/* BOOL fnMouseline(LPSTR szLine, PSTR szMouseName);
 *
 * Function will make the determination as to weather or not a given line
 * (usually from an autoexec.bat file) is a mouse installation line or
 * not.
 *
 * ENTRY: szLine - The line from the autoexec.bat file for which the
 *                 determination will be made.
 *
 * EXIY: Boolean as to weather the line is a mouse installation line or
 *       not.
 * 
 */
BOOL fnMouseline(szLine,szMouseName)
LPSTR  szLine;
PSTR   szMouseName;
{
   char      TmpWorkBuf[MAXCMDLINELEN*2];
   unsigned  index;

   fnCopyBuf(szLine,TmpWorkBuf,fnLinelenl(szLine));

   fnTerminate(TmpWorkBuf);

   if (! fnMystrstr(TmpWorkBuf,szMouseName) )
      return FALSE;
   else {
      if ( strlen(TmpWorkBuf) < 128 && fnFileExists(TmpWorkBuf) )
         return TRUE;
      else
         return FALSE;
   }
}

/* BOOL fnTempLine(LPSTR);
 *
 * Function determines if the string pointed to by sStrPtr is a temp
 * environment variable definition of the following form.
 *
 *   SET TEMP=C:\foo
 *
 * Function returns true or false as to weather or not the string is a temp
 * environment variable or not.
 *
 */
BOOL fnTempline(sStrPtr)
LPSTR    sStrPtr;
{

   while ( ISWHITE(*sStrPtr) )    // May be whitespace before set statement.
      ++sStrPtr;

   if (! strncmpinf("set temp",sStrPtr,8)) {
      sStrPtr += 8;
      if ( *sStrPtr == '=' || *sStrPtr == ' ' || *sStrPtr == '\t' )
         return TRUE;
   }
   return FALSE;

}

/* BOOL fnFileExists(char *szFile);
 *
 * Function will determine if the given filename (weather qualified or not)
 * exists.
 *
 * ENTRY: szFile - File name, qualifed or not.
 *
 * EXIT: Boolean as to existance of file.
 *
 * WARNING: Function assumes you will be looking for a .com file.
 *
 */
BOOL fnFileExists(szFile)
char    *szFile;
{
   int             fh;
   char            szTmpBuf[PHILSMAXPATH];
   char            *tmp;
   unsigned        Disks[26];

   if ( szFile[strlen(szFile) - 4] != '.' ) {
      tmp = szFile;
      tmp += (strlen(szFile) - 1);
      while ( *tmp && UPCASE(*tmp) != 'E' )
         --tmp;
      *(tmp+1) = '\0';
      strcat(szFile,".com");
   }

   /* First see if the file exists by trying to open it. */

   fh = FOPEN(szFile);  // Try to open the file.

   if ( fh == -1 ) {               /* May need to prepend a drive spec. */
      if ( szFile[1] != ':' ) {
         GetFixedDisks(Disks);
         szTmpBuf[0] = (char)(Disks[0] + 'A');
         szTmpBuf[1] = ':';
         szTmpBuf[2] = '\0';
         strcat(szTmpBuf,szFile);
         fh = FOPEN(szTmpBuf);        // Try to open the file.
      }
   }

   if ( fh != -1 ) {
      FCLOSE(fh);
      return TRUE;
   }

   /* Next, see if the file exists anywhere on the path. */

   _searchenv(szFile,pszPATH,szTmpBuf);
   if ( *szTmpBuf )
      return TRUE;
   else
      return FALSE;

}

/* void FAR PASCAL fnTweekMouse(PSTR szMouseDrv,PSTR szMouseName);
 *
 * Function will look into the autoexec.bat and config.sys files and 
 * replace an existing mouse.com/mouse.sys file installation entry with
 * a new entry line which will install a new mouse driver from the windows
 * installation directory.
 *  
 *  ENTRY: szMouseDrv  - Buffer of sufficent size to hold the name of the
 *                       mouse driver + the logocal drive volume.
 *
 *         szMouseName - Name of mouse driver to be upgraded. One of:
 *                       hpmouse,mouse.
 *	
 *  RETURNS: No formal return, fills buffer provided with name of DOS
 *                             mouse driver.
 *
 */
void FAR PASCAL fnTweekMouse(szMouseDrv,szMouseName)
PSTR  szMouseDrv;
PSTR  szMouseName;
{
   char     szConfigLine[MAXCMDLINELEN*2];
   char     szMouseLnConst[MAX_INF_LINE_LEN];
   char     szProfileBuf[MAX_INF_LINE_LEN];
   char     *pMouseFnd;
   BOOL     IsAddY = FALSE;
   PINF     pinfSectP;

   if (! stricmp(szMouseName,pszADD_Y) )
      IsAddY = TRUE;

   strcpy(szMouseLnConst,szMouseName);
   strcpy(szProfileBuf,szMouseName);
   fnProcessFile(NULL,NULL,NULL,NULL,NULL,NULL,ASSURE_OPEN);

   if ( fnModifyPath(DO_MOUSE,szMouseName) ) {
      gbAutoMod = TRUE;
      if ( IsAddY )
         szProfileBuf[0] = '\0';
      else
         strcat(szProfileBuf,pszCOMEXT);
   }
   else {
      strcat(szMouseLnConst,pszSYSEXT);
      strcat(szProfileBuf,pszSYSEXT);

      /* First, find out what mouse driver if any is in config.sys. */

      if ( fnUpdateDevice(pszMSSYS,RETURN_PRESENCE,szConfigLine) )
         pMouseFnd = pszMSSYS;
      else if ( fnUpdateDevice(pszHPSYS,RETURN_PRESENCE,szConfigLine) )
         pMouseFnd = pszHPSYS;
      else
         pMouseFnd = NULL;

      /* Second, are we doing an add_y switch operation ? */

      if ( IsAddY && pMouseFnd && !fnMystrstr(szConfigLine,"/Y") ) {
         fnUpdateDevice(pMouseFnd,REMOUT_DEVICE,szConfigLine);
         strcat(szConfigLine," /Y");
         fnUpdateDevice(szConfigLine,ADD_DEVICE,szConfigLine);
         szProfileBuf[0] = '\0';
         gbSysMod = TRUE;
      }
      else if ( IsAddY && !pMouseFnd ) {
         strcpy(szMouseLnConst,pszMOUSE);
         strcat(szMouseLnConst,pszSYSEXT);
         strcpy(szProfileBuf,szMouseLnConst);
         strcat(szMouseLnConst," /Y");
         fnConstructDeviceEntry(szConfigLine,szMouseLnConst,0,0);
         fnUpdateDevice(szConfigLine,ADD_DEVICE,szConfigLine);
         gbSysMod = TRUE;
      }
      else if ( !IsAddY ) {
         if ( pMouseFnd )
            fnUpdateDevice(pMouseFnd,REMOUT_DEVICE,szConfigLine);
         strcat(szMouseLnConst," /Y");
         fnConstructDeviceEntry(szConfigLine,szMouseLnConst,0,0);
         fnUpdateDevice(szConfigLine,ADD_DEVICE,szConfigLine);
         gbSysMod = TRUE;
      }
      /* the case of (IsAddY && pMouseFnd && fnMystrstr(szConfigLine,"/Y")
         will work ok even though szProfileBuf contains add_y.sys. This
         will remain true as long as one never adds a profile string of
         add_y.sys to the [dos.mouse] section of setup.inf. */
   }
      /* Last thing to do, get name of DOS mouse driver to copy. */
   
   infGetProfileString(NULL,DOS_MOUSE_SECT,szProfileBuf,szMouseLnConst);
   infParseField(szMouseLnConst,1,szMouseDrv);
}

// write out a file.  
//
// in:
//	szFile	file to write.
//	lpBuf	null terminated string
// returns
// 	TRUE	success
//	FALSE	faile


static int SaveFile( PSTR szFile, LPSTR lpBuf )
{
	int			fh;
	unsigned		utowrite;
	unsigned    BufLen;
	char			buf[ MAXPATHLEN ];


	for ( BufLen = 0; lpBuf[ BufLen ] != '\0'; BufLen++ )
		;

	if (szFile[1] != ':')
	{
		ExpandFileName( szSetupPath, buf );
		catpath( buf, szFile );
	}
	else
		strcpy(buf, szFile);

	if ( _dos_creat( buf, 0, &fh) == 0 )
	{
		if ( _dos_write( fh, lpBuf, BufLen, &utowrite ) == 0 &&
			  utowrite == BufLen )
		{
			_dos_close( fh );
			return WRITE_SUCCESS;
		}
		close( fh );		
		return WRITE_FAIL;
	}
	else
		return CREATE_FAIL;
}

#endif  // DOSONLY
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\lib\common\infparse.c ===
/*
 * Infparse.c - Setup.inf parsing code.
 * Clark Cyr, Mike Colee, Todd Laney
 * Copyright (C) Microsoft, 1989
 * March 15, 1989
 *
 *  Modification History:
 *
 *  3/15/89  CC  Clark wrote this code for control Panel. This is windows
 *		 code.
 *
 *  3/20/89  MC  Decided this code would work for Dos and windows portion
 *		 of setup. take out windows specifc stuff like local alloc's
 *		 and dialog stuff. Replace it with standard C run time calls.
 *
 *  3/24/89  Toddla TOTAL rewrite! nothing is the same any more.
 *
 *  6/29/89  MC fixed getprofilestring func to not strip quotes if more
 *              than one field exists.
 */

#ifdef DOSONLY
unsigned char XlateAnsi850(unsigned char c);
#endif

#include <dos.h>
#include <fcntl.h>
#include <io.h>
#include <malloc.h>
#include <string.h>
#include <stdlib.h>
#include "sulib.h"

#ifdef FAR_HEAP
/*** hack.  to avoid realloc problems we make READ_BUFSIZE
            as big as the inf file, thus avoiding any reallocs */

#define READ_BUFSIZE	27000	/* size of inf buffer */
#endif
#define TMP_BUFSIZE	1024	/* size of temp reads */

#define ISSEP(c)   ((c) == '='  || (c) == ',')
#define ISWHITE(c) ((c) == ' '  || (c) == '\t' || (c) == '\n' || (c) == '\r')
#define ISNOISE(c) ((c) == '"')
#define EOF     26

#define QUOTE   '"'
#define COMMA   ','
#define SPACE   ' '
#define EQUAL   '='

PINF   pinfDefault = NULL;

static PSTR    pBuf;
static PINF    pInf;
static WORD    iBuf;
static WORD    iInf;

/* Globaly used pointers to non-translatable text strings. */

char        *pszINFFILE    =   "setup.inf";
extern char *pszPATH;

/* Local prototypes */

BOOL multifields(PINF);


static char GETC(int fh)
{
    register WORD n;

    if (!pBuf)
        return EOF;

    n = iBuf % TMP_BUFSIZE;

    if (n == 0)
    {
       FREAD(fh,pBuf,TMP_BUFSIZE);
    }
    iBuf++;
    return pBuf[n];
}

#ifdef FAR_HEAP

static void PUTC(char c)
{
    if (!pInf)
        return;

#ifdef DOSONLY
    c = XlateAnsi850(c);
#endif

    pInf[iInf++] = c;
}

#else

static void PUTC(char c)
{
    register WORD    n;
    register PINF    pInfT;

    if (!pInf)
        return;

    n = iInf % READ_BUFSIZE;
    if (n == 0)
    {
        n = (iInf / READ_BUFSIZE) + 1;
        pInfT = REALLOC(pInf,n * READ_BUFSIZE);

        if (pInfT)
        {
            pInf = pInfT;
        }
        else
        {
            AssertF(FALSE);
            FREE(pInf);
            pInf = NULL;
        }
    }
    if (pInf)
        pInf[iInf++] = c;
}
#endif

/* int infLoadFile()	  Load a entire INF file into memory
 *			  comments are removed, each line is terminated
 *			  by a \0 each section is terminated by a \0\0
 *			  ONLY spaces inside of " " are preserved
 *			  the end of file is marked with a ^Z
 *
 *   RETURNS:  A pointer to a block of memory containg file, NULL if failure
 *
 */
PINF infLoadFile(int fh)
{
    WORD    len;
    PINF    pInfT;
    register char    c;
    register BOOL    fQuote = FALSE;

    if (fh == -1)
      return NULL;

    len = (WORD)FSEEK(fh,0L,SEEK_END);

    FSEEK(fh,0L,SEEK_SET);

    pBuf = ALLOC(TMP_BUFSIZE);		// temp buffer
#ifdef FAR_HEAP
    pInf = FALLOC(len);			// destination, at least as big as file
#else
    pInf = ALLOC(READ_BUFSIZE);
#endif
    iBuf = 0;
    iInf = 0;

    AssertF(pBuf && pInf);
    if (!pBuf || !pInf)
	return NULL;


    while (iBuf < len)
    {
	c = GETC(fh);
loop:
        if (iBuf >= len)
            break;

	switch (c)
	{
	    case '\r':	    /* ignore '\r' */
		break;

	    case '\n':
		for (; ISWHITE(c); c = GETC(fh))
		    ;
		if (c != ';')
		    PUTC(0);	/* all lines end in a \0 */

		if (c == '[')
		    PUTC(0);	/* all sections end with \0\0 */

		fQuote = FALSE;
		goto loop;
		break;

	    case '\t':
	    case ' ':
		if (fQuote)
		    PUTC(c);
		break;

	    case '"':
		fQuote = !fQuote;
		PUTC(c);
		break;

	    case ';':
		for (; !ISEOL(c); c = GETC(fh))
		    ;
		goto loop;
		break;

	    default:
		PUTC(c);
		break;
	}
    }

    PUTC(0);
    PUTC(0);
    PUTC(EOF);
    FREE(pBuf);

    // try to shrink this block

#ifdef FAR_HEAP

    // just leave pInf it's original size.  don't bother shrinking it

#else
    pInfT = REALLOC(pInf,iInf);

    if (pInfT)		// if REALLOC fails just leave pInf as is
    	pInf = pInfT;
#endif

    AssertF(pInf);
    return pInf;
}

static int near pascal
strncmpi(LPSTR pch1, LPSTR pch2, int n)
{
    while (*pch1 && --n > 0 && UP_CASE(*pch1) == UP_CASE(*pch2))
	     *pch1++,*pch2++;
    return UP_CASE(*pch1) != UP_CASE(*pch2);
}

/* PINF infOpen()    takes the string held in szBasePath as the path
 *                   to find SETUP.INF and attempts to open it. Returns
 *                   a valid file handle is successful.
 *   
 *   RETURNS:  A file pointer if successful, Null pointer in the case of
 *	       a failure.
 *
 *   ENTER:
 *   EXIT:   To caller
 */
PINF FAR PASCAL infOpen(PSTR szInf)
{
    char    szBuf[MAXPATHLEN];
    short   fh;
    PINF    pinf;

    fh = -1;

    if (szInf == NULL)
        szInf = pszINFFILE;

    /*
     * Next try to open passed parameter as is. For Dos half.
     */
    if (fh == -1)
    {
        fh = FOPEN(szInf);
    }
    /*
     * Next try destination path\system. for win half.
     */
    if (fh == -1) {
    	strcpy(szBuf, szSetupPath);
      catpath(szBuf, "system");
      catpath(szBuf, szInf);
      fh = FOPEN(szBuf);
    }
    /*
     * Next try destination path. for initial setup.
     */
    if (fh == -1) {
    	strcpy(szBuf, szSetupPath);
      catpath(szBuf, szInf);
      fh = FOPEN(szBuf);
    }
    /*
     * May need to look on the path to find the .inf file.
     */
    if ( fh == -1 ) {
      _searchenv(szInf,pszPATH,szBuf);
      if ( *szBuf )
         fh = FOPEN(szBuf);
    }

    if (fh != -1)
    {
        pinf = infLoadFile(fh);
        FCLOSE(fh);

        if (pinf && !pinfDefault)
            pinfDefault = pinf;

        return pinf;
    }
    return NULL;
}

/* void CloseSetupInf()
 *
 *   ENTER:
 *   EXIT:   To caller
 */
void FAR PASCAL infClose(PINF pinf)
{
    if (pinf == NULL)
        pinf = pinfDefault;

    if (pinf != NULL)
    {
	FFREE(pinf);

	if (pinf == pinfDefault)
	    pinfDefault = NULL;
    }
}


/* FindSection	locates a section in Setup.Inf.  Sections are
 *               assumed to be delimited by a '[' as the first
 *               character on a line.
 *
 * Arguments:	pInf	 Pointer to SETUP.INF buffer
 *		pszSect  PSTR to section name
 *
 * Return:	WORD file position of the first line in the section
 *               0 if section not found
 */

WORD FindSection(PINF pInf, PSTR pszSect)
{
    BOOL	fFound = FALSE;
    short	nLen = strlen(pszSect);
    PINF	pch;
    char        ch;

    if (!pInf)
        return 0;

    pch = pInf;
    while (!fFound && *pch != EOF)
    {
	if (*pch++ == '[')
	{
	    fFound = !strncmpi(pszSect, pch, nLen) && pch[nLen] == ']';
	}

	/*
	 * go to the next line, dont forget to skip over \0 and \0\0
	 */
	while (*pch != EOF && *pch != '\0')
	    pch++;

	while (*pch == 0)
	    pch++;
    }
    return((fFound && *pch != '[' && *pch != EOF) ? pch - pInf : 0);
}

/* char* fnGetDataString(npszData,szDataStr)
 *
 * Called by functions that read sections of information from setup.inf
 * to obtain strings that are set equal to keywords. Example:
 *
 * welcome=("Hello There")
 * 
 * This function will return a pointer to the null terminated string
 * "Hello There".
 *
 * ENTRY:
 *
 * npszData    : pointer to entire section taken from setup.inf
 * npszDataStr : pointer to key word to look for (welcome in example above.)
 *
 * EXIT: retutns pointer to string if successful, NULL if failure.
 *
 */
BOOL fnGetDataString(PINF npszData, PSTR szDataStr, LPSTR szBuf)
{
    unsigned char  *clocation;
    unsigned char  *pStringHead;
    int len = strlen(szDataStr);

    while (npszData)
    {
	    if (!strncmpi(npszData,szDataStr,len))  // looking for correct prof.
	    {
	       npszData += len;            // found !, look past prof str.
	       while (ISWHITE(*npszData))  // suck out the crap.
		       npszData++;
          if (*npszData == EQUAL)     // Now we have what were looking for !
	       {
		       npszData++;
		       
             if (!multifields(npszData) )
             {
                while (ISWHITE(*npszData) || ISNOISE(*npszData))
		             npszData++;

		          while (*npszData)
		             *szBuf++ = *npszData++;

   		       /*
	   	        * remove trailing spaces, and those pesky ()'s
		           */

                while (ISWHITE(szBuf[-1]) || ISNOISE(szBuf[-1]))
		             szBuf--;

		          *szBuf = 0;
		          return TRUE;
             }
             else
             {
                while (*npszData)
                   *szBuf++ = *npszData++;
                *szBuf = '\0';
                return TRUE;
             }
	       }
       }
       npszData = infNextLine(npszData);
    }
    *szBuf = 0;
    return FALSE;
}

/*  PINF infSetDefault(pinf)
 *
 *  Sets the default INF file
 *
 * ENTRY:
 *      pinf            : inf file to be new default
 *
 * EXIT: retutns old default
 *
 */
PINF FAR PASCAL infSetDefault(PINF pinf)
{
    PINF pinfT;

    pinfT = pinfDefault;
    pinfDefault = pinf;
    return pinfT;
}

/*  PINF infFindSection(pinf,szSection)
 *
 *  Reads a entire section into memory and returns a pointer to it
 *
 * ENTRY:
 *      pinf            : inf file to search for section
 *	szSection	: section name to read
 *
 * EXIT: retutns pointer to section, NULL if error
 *
 */
PINF FAR PASCAL infFindSection(PINF pinf, PSTR szSection)
{
    WORD   pos;

    if (pinf == NULL)
        pinf = pinfDefault;

    pos = FindSection(pinf, szSection);
    return pos ? pinf + pos : NULL;
}

/*  BOOL infGetProfileString(szSection,szItem,szBuf)
 *
 *  Reads a single string from a section in SETUP.INF
 *
 *  [section]
 *	item = string
 *
 * ENTRY:
 *	szSection	: pointer to section name to read.
 *	szItem		: pointer to item name to read
 *	szBuf		: pointer to a buffer to hold result
 *
 * EXIT: retutns TRUE if successful, FALSE if failure.
 *
 */
BOOL FAR PASCAL infGetProfileString(PINF pinf, PSTR szSection,PSTR szItem,LPSTR szBuf)
{
    PINF    pSection;

    if (pSection = infFindSection(pinf,szSection))
        return fnGetDataString(pSection,szItem,szBuf);
    else
        *szBuf = 0;
    return FALSE;
}

/* BOOL infParseField(szData,n,szBuf)
 *
 * Given a line from SETUP.INF, will extract the nth field from the string
 * fields are assumed separated by comma's.  Leading and trailing spaces
 * are removed.
 *
 * ENTRY:
 *
 * szData    : pointer to line from SETUP.INF
 * n         : field to extract. ( 1 based )
 *             0 is field before a '=' sign
 * szDataStr : pointer to buffer to hold extracted field
 *
 * EXIT: retutns TRUE if successful, FALSE if failure.
 *
 */
BOOL FAR PASCAL infParseField(PINF szData, int n, LPSTR szBuf)
{
    BOOL    fQuote = FALSE;
    PINF    pch;
    LPSTR   ptr;

    if (!szData || !szBuf)
        return FALSE;

    /*
     * find the first separator
     */
    for (pch=szData; *pch && !ISSEP(*pch); pch++) {
      if ( *pch == QUOTE )
         fQuote = !fQuote;
    }

    if (n == 0 && *pch != '=')
        return FALSE;

    if (n > 0 && *pch == '=' && !fQuote)
        szData = ++pch;

    /*
     *	locate the nth comma, that is not inside of quotes
     */
    fQuote = FALSE;
    while (n > 1)
    {
	    while (*szData)
	    {
          if (!fQuote && ISSEP(*szData))
	    	   break;

          if (*szData == QUOTE)
	    	   fQuote = !fQuote;

	       szData++;
	    }

	    if (!*szData) {
	       szBuf[0] = 0;		// make szBuf empty
	       return FALSE;
	    }

	    szData++;
	    n--;
    }
    /*
     * now copy the field to szBuf
     */
    while (ISWHITE(*szData))
	    szData++;

    fQuote = FALSE;
    ptr = szBuf;		// fill output buffer with this
    while (*szData)
    {
       if (*szData == QUOTE)
	       fQuote = !fQuote;
       else if (!fQuote && ISSEP(*szData))
	       break;
	    else
	       *ptr++ = *szData;
	    szData++;
    }
    /*
     * remove trailing spaces, and those pesky ()'s
     */
    while ((ptr > szBuf) && (ISWHITE(ptr[-1]) || ISNOISE(ptr[-1])))
	    ptr--;

    *ptr = 0;
    return TRUE;
}

/* BOOL multifields(PSTR npszData);
 *
 * Given a line line from setup.inf that was phycisacaly after a profile
 * string this function will determine if that line has more than one
 * field. ie. Fields are seperated by commas that are NOT contained between
 * quotes.
 *
 * ENYRY:
 *
 * npszData : a line from setup.inf Example "xyz adapter",1:foobar.drv
 *
 * EXIT: This function will return TRUE if the line containes more than
 *       one field, ie the function would return TRUE for the example line
 *       shown above.
 *
 */
BOOL multifields(PINF npszData)
{
   BOOL    fQuote = FALSE;

	while (*npszData)
	{
      if (!fQuote && ISSEP(*npszData))
		   return TRUE;

      if (*npszData == QUOTE)
		   fQuote = !fQuote;

	   npszData++;
	}
   return FALSE;
}

/* PSTR infNextLine(sz)
 *
 * Given a line from SETUP.INF, advance to the next line.  will skip past the
 * ending NULL character checking for end of buffer \0\0
 *
 * ENTRY:
 *
 * sz	     : pointer to line from a SETUP.INF section
 *
 * EXIT: retutns pointer to next line if successful, NULL if failure.
 *
 */
PINF FAR PASCAL infNextLine(PINF pinf)
{
    if (!pinf)
        return NULL;

    while (*pinf != 0 || *(pinf + 1) == ' ')
        pinf++;

    return *++pinf ? pinf : NULL;
}

/* int infLineCount(pinf)
 *
 * Given a section from SETUP.INF, returns the number of lines in the section
 *
 * ENTRY:
 *
 * pinf	     : pointer to a section from SETUP.INF
 *
 * EXIT: retutns line count
 *
 */
int FAR PASCAL infLineCount(PINF pinf)
{
    int n = 0;

    for (n=0; pinf; pinf = infNextLine(pinf))
	n++;

    return n;
}

/* int infLookup(szInf,szBuf)
 *
 * lookup a section/key in SETUP.INF
 *
 * ENTRY:
 *
 * szInf        : pointer to a string of the form section.key
 * szBuf        : pointer to buffer to recive string
 *
 * EXIT: retutns TRUE/FALSE
 *
 */
BOOL FAR PASCAL infLookup(PSTR szInf, LPSTR szBuf)
{
    PSTR pch;
    BOOL f;

    /*
     * find the LAST .
     */
    for (pch = szInf; *pch; pch++)
	;

    for (; pch > szInf && *pch != '.'; pch--)
	;

    if (*pch == '.')
    {
	*pch++ = 0;
        f = infGetProfileString(NULL,szInf,pch,szBuf);
        if (szInf != szBuf)
            *pch = '.';
        return f;
    }
    else
    {
        *szBuf = 0;
        return FALSE;
    }
}

#ifdef DOSONLY

unsigned char AnsiToOemTable[] = {

        0x20,     /* non breaking space (NBSP)                 */
        0xAD,     /* A1h  inverted point                       */
        0xbd,     /* A2h  cent ---                             */
        0x9C,     /* A3h  british pound                        */
        0xcf,     /* A4h  sun ---                              */
        0xbe,     /* A5h  yen ---                              */
        0xdd,     /* A6h  vertical bar (cut) ---               */
        0xf5,     /* A7h  section mark ---                     */
        0xf9,     /* A8h  umlaut ---                           */
        0xb8,     /* A9h  copyright sign ---                   */
        0xa6,     /* AAh  a underlined (superscript) ---       */
        0xae,     /* ABh  << ---                               */
        0xAA,     /* ACh  logical NOT                          */
        0xf0,     /* ADh  syllabic hyphenation (SHY) ---       */
        0xa9,     /* AEh  registered mark                      */
        0xee,     /* AFh  top bar ---                          */

        0xF8,     /* B0h  degree                               */
        0xF1,     /* B1h  + underlined (plus or minus)         */
        0xFD,     /* B2h  2 (superscript)                      */
        0xfc,     /* B3h  3 (superscript) ---                  */
        0xef,     /* B4h  acute ---                            */
        0xE6,     /* B5h  greek mu                             */
        0xf4,     /* B6h  paragraph sign ---                   */
        0xFA,     /* B7h  middle dot                           */
        0xf7,     /* B8h  cedilla for deadkey ---              */
        0xfb,     /* B9h  1 (superscript) ---                  */
        0xa7,     /* BAh  o underlined (superscript) ---       */
        0xaf,     /* BBh  >> ---                               */
        0xac,     /* BCh  1/4 ---                              */
        0xab,     /* BDh  1/2 ---                              */
        0xf3,     /* BEh  3/4 ---                              */
        0xA8,     /* BFh  inverted question mark               */

        0xb7,     /* C0h  A grave uppercase --                 */
        0xb5,     /* C1h  A acute uc --                        */
        0xb6,     /* C2h  A circumflex uc --                   */
        0xc7,     /* C3h  A tilde uc ---                       */
        0x8E,     /* C4h  A umlaut uc                          */
        0x8F,     /* C5h  A ring uc                            */
        0x92,     /* C6h  AE uc                                */
        0x80,     /* C7h  C cedilla uc                         */
        0xd4,     /* C8h  E grave uc ---                       */
        0x90,     /* C9h  E acute uc                           */
        0xd2,     /* CAh  E circumflex uc ---                  */
        0xd3,     /* CBh  E umlaut uc ---                      */
        0xde,     /* CCh  I grave uc ---                       */
        0xd6,     /* CDh  I acute uc ---                       */
        0xd7,     /* CEh  I circumflex uc ---                  */
        0xd8,     /* CFh  I umlaut uc ---                      */

        0xd1,     /* D0h  Icelandic eth (D striked) uc ---     */
        0xA5,     /* D1h  N tilde uc                           */
        0xe3,     /* D2h  O grave uc ---                       */
        0xe0,     /* D3h  O acute uc ---                       */
        0xe2,     /* D4h  O circumflex uc ---                  */
        0xe5,     /* D5h  O tilde uc ---                       */
        0x99,     /* D6h  O umlaut uc                          */
        0x9e,     /* D7h  Multiply sign ---                    */
        0x9D,     /* D8h  O slashed uc ---                     */
        0xeb,     /* D9h  U grave uc ---                       */
        0xe9,     /* DAh  U acute uc ---                       */
        0xea,     /* DBh  U circumflex uc ---                  */
        0x9A,     /* DCh  U umlaut uc                          */
        0xed,     /* DDh  Y acute uc ---                       */
        0xe8,     /* DEH  Icelandic thorn uc ---               */
        0xE1,     /* DFh  german sharp S                       */


        0x85,     /* E0h  a grave lowercase                    */
        0xA0,     /* E1h  a acute lc                           */
        0x83,     /* E2h  a circumflex lc                      */
        0xc6,     /* E3h  a tilde lc ---                       */
        0x84,     /* E4h  a umlaut lc                          */
        0x86,     /* E5h  a ring lc                            */
        0x91,     /* E6h  ae lc                                */
        0x87,     /* E7h  c cedilla lc                         */
        0x8A,     /* E8h  e grave lc                           */
        0x82,     /* E9h  e acute lc                           */
        0x88,     /* EAh  e circumflex lc                      */
        0x89,     /* EBh  e umlaut lc                          */
        0x8D,     /* ECh  i grave lc                           */
        0xA1,     /* EDh  i acute lc                           */
        0x8C,     /* EEh  i circumflex lc                      */
        0x8B,     /* EFh  i umlaut lc                          */

        0xd0,     /* F0h  Icelandic eth (d striked) lc ---     */
        0xA4,     /* F1h  n tilde lc                           */
        0x95,     /* F2h  o grave lc                           */
        0xA2,     /* F3h  o acute lc                           */
        0x93,     /* F4h  o circumflex lc                      */
        0xe4,     /* F5h  o tilde lc ---                       */
        0x94,     /* F6h  o umlaut lc                          */
        0xf6,     /* F7h  divide sign ---                      */
        0x9B,     /* F8h  o slashed lc ---                     */
        0x97,     /* F9h  u grave lc                           */
        0xA3,     /* FAh  u acute lc                           */
        0x96,     /* FBh  u circumflex lc                      */
        0x81,     /* FCh  u umlaut lc                          */
        0xec,     /* FDh  y acute lc                           */
        0xe7,     /* FEH  icelandic thorn lc                   */
        0x98      /* FFh  y umlaut lc                          */
             };   /* end of AnsiToOemTable                     */



unsigned char XlateAnsi850(unsigned char c)
{


    if (c >= 160)
        c = AnsiToOemTable[c - 160];
    return c;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\lib\common\ioctl.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988
;
;   Title:	smartdrv.inc - smartdrv equates & structures
;
;   Version:	1.00
;
;   Date:	15-Sep-1989
;
;   Author:	ARR
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   15-Sep-1989 ARR Original
;   30-Oct-1989 MC  Borrowed from AAR for use in win.com. Pared down to only
;                   SD_IOCTL_Read because thats all I need. I need only look
;                   at the size of SD. I do not have to shrink it.
;   11-Dec-1989 MC  Add needed struc's and support for talking to LIM drivers
;
;==============================================================================
;
;
; Device name of SMARTDRV
;
SD_DEV_NAME	equ	"SMARTAAR",0    ; Name for SD driver IOCTL opens.
EMM_DEV_NAME    equ     "EMMXXXX0",0    ; Name for EMM driver IOCTL opens.
;
;
; Structure of the data returned on the SMARTDRV IOCTL read call
;

SD_IOCTL_Read	struc

    SD_IR_Write_Through   db	?   ; Write-through flag, currently always 1
    SD_IR_Write_Buff	  db	?   ; Buffer write flag, currently always 0
    SD_IR_Enable_Int13	  db	?   ; Cache enable flag, 1 = enabled
    SD_IR_Driver_Type     db	?   ; Type 1 (XMS cache) or 2 (EMS cache)
    SD_IR_Tick_Setting	  dw	?   ; Ticks between flushes, currently unused
    SD_IR_Lock_Cache	  db	?   ; Non-zero if cache is locked
    SD_IR_Reboot_Flush	  db	?   ; Non-zero if cache should be flushed on reboot
    SD_IR_Cache_All	  db	?   ; Zero if full track writes are not cached
    SD_IR_Double_Buffer   db	?   ; Dbl buff state 0=Off, 1=On, 2=Dynamic
    SD_IR_Original_INT13  dd	?   ; INT 13 address SMARTDRV hooked
    SD_IR_Minor_Ver	  db	?   ; Minor version number
    SD_IR_Major_Ver	  db	?   ; Major version number
			  dw	?   ; Unused
                    ; Next three values are used for computing
                    ; cache statistics.  They may be scaled rather
                    ; than absolute values
    SD_IR_Total_Sec_Read  dw	?   ; Count of sectors read
    SD_IR_Cache_Sec_Read  dw	?   ; Count of sectors read from cache
    SD_IR_Track_Sec_Read  dw	?   ; Count of sectors read from track buffer
                    ; Cache statistics
    SD_IR_Cache_Hit_Ratio db	?   ; = Cache_Sec_Read * 100 / Total_Sec_Read
    SD_IR_Track_Hit_Ratio db	?   ; = Track_Sec_Read * 100 / Total_Sec_Read

    SD_IR_Total_Tracks	  dw	?   ; Number of tracks in the cache
    SD_IR_Total_Used	  dw	?   ; Tracks currently in use
    SD_IR_Total_Locked	  dw	?   ; Tracks currently locked
    SD_IR_Total_Dirty	  dw	?   ; Tracks currently dirty
                    ; Information for resizing cache
                    ; All values are in terms of 16Kb pages.
    SD_IR_Current_Size	  dw	?   ; Current size of the cache, in 16Kb pages
    SD_IR_Dev_Size	  dw	?   ; Original size requested by user
    SD_IR_Min_Cache_Size  dw	?   ; Minimum allowable size

SD_IOCTL_Read	ends

SMRTDRVInfo	SD_IOCTL_Read  <>

;
; Structure of the data returned on the IOCTL call to the EMM driver
;
EMM_Import_IOCTL_Data	struc

    EMM_Import_Data_Phys_Ptr	dd	?   ; PHYSICAL 32 bit address of the
					    ;	EMM_Import_Data structure
    EMM_Import_API_Version_Maj	db	?   ; API version #
    EMM_Import_API_Version_Min	db	?

EMM_Import_IOCTL_Data	ends

;
; For the IOCTL to get the data and version number of importable EMM info
;   the IOCTL read subfunction is encoded in the first byte of the IOCTL
;   read buffer.
;
EMM_IMPRT_IOCTL_FUNC	equ	1

EMM_OK	                equ	0
;
; Current version number restriction of WIN386 on EMM_Import_API_Version
;
EMM_IMPORT_MIN_VER	equ	0100h
EMM_IMPORT_MAX_VER	equ	0100h

EMMIoctlBuf	db	EMM_IMPRT_IOCTL_FUNC
		db	(SIZE EMM_Import_IOCTL_Data) dup (0)

SMRTDRVName	db SD_DEV_NAME     ; Name for smartdrv IOCTL opens.
EMM_Name        db EMM_DEV_NAME    ; Name for EMM IOCTL opens.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\lib\common\findwin.c ===
#include <stdio.h>
#include "sulib.h"
#include "newexe.h"

#define NE_TYPE(ne) (((BYTE *)&(ne))[0x36])

main (int argc, char ** argv)
{
    printf("%-13s %-8s %-4s %-4s %-4s %s\n\n",
        "File",
        "Name",
        "Flag",
        "Type",
        "Ver",
        "Description" );

    if (argc>1)
        FindWin(argv[1]);
    else
        FindWin("/");
}

char    info[128];
char    modname[128];

FindWin(char *sz)
{
    char    path[128];
    WORD    fExe;
    struct  new_exe  newexe;
    FCB     fcb;
    BOOL    f;
    BOOL    fFAPI;

    if (!DosValidDir(sz))
        *FileName(sz) = 0;

    strcpy(path,sz);
    catpath(path,"*.exe");
    f = DosFindFirst(&fcb,path,ATTR_FILES);

    while (f)
    {
        strcpy(path,sz);
        catpath(path,fcb.szName);

        if (GetExeInfo(path,&newexe,sizeof(newexe),GEI_EXEHDR))
        {
            GetExeInfo(path,&fExe,sizeof(fExe),GEI_FLAGS);
            GetExeInfo(path,info,sizeof(info),GEI_DESCRIPTION);
            GetExeInfo(path,modname,sizeof(modname),GEI_MODNAME);

            if ( (NE_TYPE(newexe) == 0 || NE_TYPE(newexe) == 2) &&
                !(newexe.ne_flags & NENOTP) )
            {
                /*
                 * test for FAPI's that are unknown EXE types.
                 */
                if (NE_TYPE(newexe) == 0 && newexe.ne_expver == 0)
                    GetExeInfo(path,&fFAPI,sizeof(fFAPI),GEI_FAPI);
                else
                    fFAPI = FALSE;

                if (fFAPI)
                    printf("%-13s %-8s %04X %04X FAPI %s\n",
                        fcb.szName,
                        modname,
                        fExe,
                        NE_TYPE(newexe),
                        info );
                else
                    printf("%-13s %-8s %04X %04X %04X %s\n",
                        fcb.szName,
                        modname,
                        fExe,
                        NE_TYPE(newexe),
                        newexe.ne_expver,
                        info );
            }
        }

        f = DosFindNext(&fcb);
    }

    strcpy(path,sz);
    catpath(path,"*.*");

    f = DosFindFirst(&fcb,path,ATTR_DIR);
    while (f)
    {
        if ((fcb.Attr & ATTR_DIR) && fcb.szName[0] != '.')
        {
            strcpy(path,sz);
            catpath(path,fcb.szName);

            FindWin(path);
        }
        f = DosFindNext(&fcb);
    }
}

#ifdef DEBUG

/* FAR _Assert(char*,int);
 *
 * Called as a result of an assertion failure. Will print out an error
 * dialog containing the file and line number of where the assertion failure
 * occured.
 *
 * ENTRY: Only from an assertion failure.
 * EXIT : Fatal Error (exit to dos).
 *
 */
FAR _Assert(char *szFile, int line)
{
   fprintf(stderr,"ASSERT, FILE %s LINE: %d",szFile,line);
   exit(-1);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\lib\common\test.c ===
/*
 * MC & CG                               Test stuff.
 * Copyright (C) Microsoft, 1989
 * March 15, 1989
 *
 */

#include <sys\types.h>
#include <io.h>           /* For file I/O  */
#include <sys\stat.h>     /* For file I/O  */
#include <fcntl.h>        /* For file I/O  */
#include <dos.h>          /* For file I/O  */
#include <stdlib.h>
#include <conio.h>
#include <string.h>
#include <stdio.h>   /* for null def ect. */
#include "..\dos\setup.h"

char szHimemSwitch[2];

/* Main()
*
*
*/
void main(argc,argv)
int  argc;
char **argv;
{

   int       back;
   int       iEGA;
   int       iHimem;
   int       iSmartdrvMAX;
   int       iSmartdrvMIN;
   int       iLim;
   int       iRamdrive;
   char      szMouseDrv[20];
   char      szMouseName[20];
   char      szVerString[20];

   fnGetSmartDrvVersion();

   fnGetRamDriveVersion((LPSTR)szVerString);

   bIsNetSetup = TRUE;

   if (XmsInstalled())
	   printf("XMS Version %lx\n", XmsVersion());
   else
   	printf("No XMS installed\n");

   printf("CMOS Ram reports extended memory = %d\n", get_ext());
   
   // Open the .inf file because we need to read the compatibility sections.

   if ( infOpen("setup.inf") == NULL )
      printf("Error opening setup.inf file\n");

   strcpy(szDiskPath,"C:\\netpath");
   strcpy(szSetupPath,"C:\\goober");

   // First, get all the current prams and print them !

   back = fnProcessFile(&iEGA,&iHimem,&iSmartdrvMIN,&iSmartdrvMAX,&iLim,
                        &iRamdrive,RETURN_PRAMS);
 
   printf("\nParameters from Config.Sys RETURN_PRAMS Call:\n");
   printf("SmartDrive MAX: %i \n", iSmartdrvMAX);
   printf("SmartDrive MIN: %i \n", iSmartdrvMIN);
   printf("RamDrive      : %i \n", iRamdrive);
   printf("LimDriver     : %i \n", iLim);

   if ( iHimem )
      printf("Himem Present\n");
   else
      printf("Himem Not Present\n");

   if ( iEGA )
      printf("EGA.SYS Present\n");
   else
      printf("EGA.SYS Not Present\n");

   /* Lets see if we need to rem out any incompatable drivers. */
   
//   back = fnProcessFile(&iEGA,&iHimem,&iSmartdrvMIN,&iSmartdrvMAX,&iLim,
//                        &iRamdrive,CHECK_COMPAT);

   // Now let's excersize the munger by making it add the world to your
   // config.sys and then write the file as config.win.

   iEGA          = TRUE;   // Add ega.sys
   iHimem        = TRUE;   // Add himem
   iSmartdrvMAX  = 2222;   // Put in a smartdrv with a min and max
   iSmartdrvMIN  = 1111;
   iLim          = REMOVE_DEVICE;   // Stick in a limulator while were at it !
   iRamdrive     = 4444;   // What the hell, why not add a ramdrive to !

   back = fnProcessFile(&iEGA,&iHimem,&iSmartdrvMIN,&iSmartdrvMAX,&iLim,
                        &iRamdrive,SET_PRAMS);

   back = fnProcessFile(&iEGA,&iHimem,&iSmartdrvMIN,&iSmartdrvMAX,&iLim,
                        &iRamdrive,MUNGE_AUTO);

   printf("Mouse Driver Version %x\n",fnMouseDriverVer());

   printf("*****************************\n");

   printf("\nEnter a mouse operation: ( add_y, mouse, or mousehp )\n");
   gets(szMouseName);
   printf("%s Operation Chosen\n",szMouseName);

//   fnTweekMouse(szMouseDrv,szMouseName);

   printf("\nDos Mouse Driver Needed: %s\n",szMouseDrv);

   back = fnProcessFile(&iEGA,&iHimem,&iSmartdrvMIN,&iSmartdrvMAX,&iLim,
                        &iRamdrive,ASSURE_MOUSE_POSITION);

   back = fnProcessFile(&iEGA,&iHimem,&iSmartdrvMIN,&iSmartdrvMAX,&iLim,
                        &iRamdrive,WRITE_BAK);
} 

void _Assert(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\lib\common\sulib.h ===
/*
 * SULIB.H - Windows/DOS Setup common code
 *
 *  Modification History:
 *
 *
 *  3/23/89  Toddla  combined common.h and prototypes into this file
 *               
 */

#define FAR_HEAP

/* has windows.h been included */
#ifndef WM_USER

#ifndef	MLARGE
	#define NULL		0
#else
	#define NULL		0L
#endif

    #define FALSE		0
    #define TRUE		1

	 #define FAR		far
	 #define NEAR
    #define LONG		long
    #define VOID		void
    #define PASCAL		pascal

    #define MAKELONG(a, b)	((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
    #define LOWORD(l)		((WORD)(l))
    #define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
    #define LOBYTE(w)		((BYTE)(w))
    #define HIBYTE(w)		(((WORD)(w) >> 8) & 0xFF)

    typedef unsigned char	BYTE;
    typedef unsigned short	WORD;
    typedef unsigned long	DWORD;
    typedef int 		 BOOL;
    typedef char		*PSTR;
    typedef char FAR		*LPSTR;
    typedef int FAR		*LPINT;

    int         _ret;
    unsigned    _error;

/* These macros are for near heap only */

    #define FOPEN(sz)                ((_ret=-1),(_error=_dos_open(sz,O_RDONLY,&_ret)),_ret)
    #define FCREATE(sz)              ((_ret=-1),(_error=_dos_creat(sz,_A_NORMAL,&_ret)),_ret)
    #define FCLOSE(fh)               ((_error=_dos_close(fh)))
    #define FREAD(fh,buf,len)        ((_error=_dos_read(fh,buf,len,&_ret)),_ret)
    #define FWRITE(fh,buf,len)       ((_error=_dos_write(fh,buf,len,&_ret)),_ret)
    #define FERROR()                 _error
    #define FSEEK(fh,off,i)          lseek(fh,(long)(off),i)

    #define ALLOC(n)                 malloc(n)
    #define FREE(p)                  free(p)
    #define SIZE(p)                  _msize(p)
    #define REALLOC(p,n)             realloc(p,n)

/* here are some macros for allocating and freeing far heap space */

    #define FALLOC(n)                _fmalloc(n)
    #define FFREE(n)                 _ffree(n)

#else

    #define FALLOC(n)                (VOID FAR *)MAKELONG(0, GlobalAlloc(GPTR, (DWORD)n))
    #define FFREE(n)                 GlobalFree((HANDLE)HIWORD((LONG)n))

    #define FOPEN(sz)                _lopen(sz,READ)
    #define FCREATE(sz)              _lcreat(sz,0)
    #define FCLOSE(fh)               _lclose(fh)
    #define FREAD(fh,buf,len)        _lread(fh,buf,len)
    #define FWRITE(fh,buf,len)       _lwrite(fh,buf,len)
    #define FSEEK(fh,off,i)          _llseek(fh,(DWORD)off,i)

    #define FERROR()		     0

    #define ALLOC(n)                 (VOID *)LocalAlloc(LPTR,n)
    #define FREE(p)                  LocalFree(p)
    #define SIZE(p)                  LocalSize(p)
    #define REALLOC(p,n)             LocalRealloc(p,n,LMEM_MOVEABLE)
#endif

/* flags for _lseek */
#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

/* These path length constants have been made large enough to account for
 * drive letter, directory name, file name, terminating null, plus some pad
 * on both FAT and Installable File Systems (IFS), which may implement
 * long file names.
 */
#define MAXPATHLEN			  260
#define MAXFILESPECLEN		  260

#define MAXCMDLINELEN	     128      /* Maximum length of DOS command line */
#define MAX_INF_LINE_LEN     150      /* Maximum length of any .inf line */
#define MAX_SYS_INF_LEN      16       /* ##: + 8.3 + NULL */
#define MAX_ASPECT_STR_LEN   11       /* Max length of aspect ratio string */
#define MAX_VDD_LEN          75       /* multiple vdd names, vdd,vdd,vdd ect. */
#define MAX_SECT_NAME_LEN    20       /* Max length of a section Name. */

/* For SLICK, MAX_PROF_LINE_LEN must be >= FILEMAX */
#define MAX_PROF_LINE_LEN    15       /* Mamimum length of any profile string */
#define FILEMAX 	     14       /* 8.3 + NULL byte */

#define WIN386VER              "win386"         
#define MACHINE_SECT           "machine"
#define SYSTEM_SECT            "system"
#define DISPLAY_SECT           "display"
#define KEYBOARD_DRV_SECT      "keyboard.drivers"
#define KEYTYPE_SECT           "keyboard.types"
#define KEYBOARD_TABLES_SECT   "keyboard.tables"
#define MOUSE_SECT             "pointing.device"
#define DOS_MOUSE_SECT         "dos.mouse.drivers"
#define SYSFONT_SECT           "sysfonts"
#define OEMFONT_SECT           "oemfonts"
#define FIXEDFON_SECT          "fixedfonts"
#define DISK_SECT              "disks"
#define USER_FONTS_SECT        "fonts"
#define LANGUAGE_SECT          "language"
#define NETWORK_SECT           "network"
#define EXCLUSIONS_SECT        "exclusions"
#define EBIOS_SECT             "ebios"

#define INTL_SECT              "intl"
#define S_LANG                 "sLanguage"

#define COMPATIBILITY          "compatibility"
#define CSCALE                 "continuousscaling"

#define LIM_SECT               "lim"
#define CACHE_SECT             "diskcache"
#define VDISK_SECT             "ramdrive"

#define USADLL                 "usadll"       /* dll profile string for usa */
#define DEFKEYDLL              "defkeydll"    /* data sectio profile string */
#define CHDISK(n)              (char)((n) < 10 ? '0' + (char)(n) : 'A' + (char)((n) - 10))

#define FILES                  "files"
#define BUFFERS                "buffers"
#define NUM_FILES              "= 30"
#define EMM_SWITCH             " /e"
#define REM                    "rem  "
#define HIMEM                  "himem.sys"
#define SMARTDRV               "smartdrv.sys"
#define RAMDRIVE               "ramdrive.sys"
#define MOUSE_SYS              "mouse.sys"
#define EGASYS                 "ega.sys"
#define LIMDRIVER 				 "emm386.sys"

#define AUTOEXEC_BAK           "autoexec.old"
#define AUTOEXEC_WIN 			 "autoexec.win"

#define CONFIG_BAK             "config.old"  /* Name of config.bak file */
#define CONFIG_WIN             "config.win"
#define OEMINFFILE             "oemsetup.inf"
#define SETUPEXE               "setup.exe"
#define BOOT_SECT_INI          "boot"
#define KEYB_SECT_INI          "keyboard"
#define SYSTEM_SECT_INI        "386enh"
#define BOOT_DESC_INI          "boot.description"
#define SYSTEMSRC              "system.src"
#define PROCESSOR              "data.product"   /* used to retrieve processor =    */
#define WIN386VER              "win386"         /* means were setting up win386    */
#define CODEPAGES              "codepages"
#define RAMDRIVEMIN	128
#define SMARTDRVMIN	256

/* These are the module names that can be found in the LIBRARY entry of
   all mouse and display drivrs. */

#define MOUSE_LIB                  "mouse"
#define DISPLAY_LIB                "display"

 /* These are the possible return values from fnProcessConfig or 
    fnAutoexecProcess*/

#define CONFIG_ERR                0x8000
#define OPEN_CONFIG_ERR           (CONFIG_ERR + 2)
#define OPEN_AUTOEXEC_ERR         (CONFIG_ERR + 3)
#define RENAME_FAIL               (CONFIG_ERR + 4)
#define CREATE_FAIL               (CONFIG_ERR + 5)
#define WRITE_FAIL                (CONFIG_ERR + 6)
#define WRITE_SUCCESS             0x0001
#define CHECK_COMPAT_SUCCESS      0x0004
#define RET_PRAMS_SUCCESS         0x0008
#define SET_PRAMS_SUCCESS         0x0010
#define CONFIG_DIRTY              0x0020      // file needs to be writen
#define AUTOEXEC_DIRTY            0x0040      // file needs to be writen

#define DO_PATH                   0x0001      // bit def's to specify work
#define DO_TEMP                   0x0002      // needed to autoexec.bat file.
#define DO_MOUSE                  0x0004      // mouse driver install

#define RETURN_PRAMS           0x0001
#define SET_PRAMS              0x0002
#define CHECK_COMPAT           0x0004
#define WRITE_SYS              0x0008
#define WRITE_BAK              0x0010   // Option flags for fnProcessFile
#define WRITE_NONE             0x0020
#define MUNGE_AUTO             0x0080
#define ASSURE_OPEN            0x0100
#define ASSURE_MOUSE_POSITION  0x0200

#define NO_ACTION		-1  // Option flag defines for fnUpdateDevice
#define REMOVE_DEVICE      	-2
#define RETURN_PRESENCE		-3
#define REMOUT_DEVICE  		-4
#define ADD_DEVICE     		-5
#define ADD_DEVICE_FIRST   -6

/* These defines are used as arguments to the fnCheckDevice call. */

#define CACHE               0
#define LIM                 1
#define VDISK               2

/* These are used as the only argument to the fnCreateFileBuffer function
   call. They denote which buffer and file is to be created. */

#define CONFIG              0x1
#define AUTOEXEC            0x2

#define REMOTE              0x3      /* Return value from DosIsRemote */

/* Used in the fnCopyBuf call to specify the copying of the remainder on
   the from buffer. */

#define CNT_Z        0x1A

/* Used as an argument in function call fnCheckDevice(); */

#define NO_REMOVE        FALSE
#define YES_REMOVE       TRUE

#define REMAINDER           0xffff  // Used to copy remainder of buffer.

#define ISEOF(c)     ((c) == '\0' || (c) == CNT_Z)
#define ISSEP(c)     ((c) == '='  || (c) == ',')
#define ISWHITE(c)   ((c) == ' '  || (c) == '\t' || (c) == '\n' || (c) == '\r')
#define ISFILL(c)    ((c) == ' '  || (c) == '\t')
#define ISEOL(c)     ((c) == '\n' || (c) == '\r' || (c) == '\0' || (c) == CNT_Z)
#define ISCRLF(c)    ((c) == '\n' || (c) == '\r')
#define ISNOISE(c)   ((c) == '"')
#define ISDIGIT(c)   ((c) >= '0' && (c) <= '9')
#define ISHEX(c)     (ISDIGIT(c) || ISCHAR(c))
#define ISCHAR(c)    (((c) >= 'A' && (c) <= 'Z') || ((c) >= 'a' && (c) <= 'z'))
#define SLASH(c)     ((c) == '/' || (c) == '\\')
#define DEVICESEP(c) ((c) == '/' || (c) == '\\' || (c) == '=' || (c) == ' ' || (c) == '\t')
#define UP_CASE(c)   ((c) | 0x20)  // this is lower case !
#define UPCASE(c)    ((c) & 0xdf)  // real upcase.
#define HEXVAL(c)    (ISDIGIT(c) ? (c) - '0' : UP_CASE(c) - 'a' + 10)

#define CHSEPSTR                "\\"
#define EQUAL                   '='
#define SPACE						  ' '


/* TYPEDEFS - infparse.c */

/*
 *  directory or file name where SETUP.INF can be found.
 */
char szSetupInf[MAXPATHLEN];

/*
 *  directory where windows will be setup to
 */
char szSetupPath[MAXPATHLEN];

/*
 *  directory where the root of the setup disks are!
 */
char szDiskPath[MAXPATHLEN];

typedef LPSTR    PINF;

extern PINF FAR PASCAL infOpen(PSTR szInf);
extern void FAR PASCAL infClose(PINF pinf);
extern PINF FAR PASCAL infSetDefault(PINF pinf);
extern PINF FAR PASCAL infFindSection(PINF pinf, PSTR szSection);
extern BOOL FAR PASCAL infGetProfileString(PINF pinf, PSTR szSection, PSTR szItem,LPSTR szBuf);
extern BOOL FAR PASCAL infParseField(PINF szData, int n, LPSTR szBuf);
extern PINF FAR PASCAL infNextLine(PINF pinf);
extern int  FAR PASCAL infLineCount(PINF pinf);
extern BOOL FAR PASCAL infLookup(PSTR szInf, LPSTR szBuf);

/* TYPEDEFS - copy.c */
typedef BOOL (FAR PASCAL    *FPFNCOPY) (int,int,LPSTR);
#define COPY_ERROR          0x0001
#define COPY_STATUS         0x0002
#define COPY_INSERTDISK     0x0003
#define COPY_QUERYCOPY      0x0004
#define COPY_START          0x0005
#define COPY_END            0x0006

extern WORD FAR PASCAL FileCopy (LPSTR szSource, PSTR szDir, FPFNCOPY fpfnCopy, WORD fCopy);

#define FC_FILE      0x0000
#define FC_LIST      0x0001
#define FC_SECTION   0x0002
#define FC_LSTPTR    0x0004
#define FC_QUALIFIED 0x0008
#define FC_DEST_QUALIFIED 0x0010

#define FC_ABORT    0
#define FC_IGNORE   1
#define FC_RETRY    2

/* External functions from copy.c */

extern void FAR PASCAL fartonear(LPSTR dst, LPSTR src);
extern BOOL FAR PASCAL ExpandFileName(PSTR szFile, PSTR szPath);
extern int  NEAR       DosCopy(PSTR szFile, PSTR szPath);
extern void FAR PASCAL catpath(PSTR path, PSTR sz);
extern PSTR FAR PASCAL FileName(PSTR szPath);
extern PSTR FAR PASCAL StripPathName(PSTR szPath);

/* TYPEDEFS - dos.asm */

#define ATTR_READONLY   0x0001
#define ATTR_HIDDEN     0x0002
#define ATTR_SYSTEM     0x0004
#define ATTR_VOLUME     0x0008
#define ATTR_DIR        0x0010
#define ATTR_ARCHIVE    0x0020
#define ATTR_FILES      (ATTR_READONLY+ATTR_SYSTEM)
#define ATTR_ALL_FILES  (ATTR_READONLY+ATTR_SYSTEM+ATTR_HIDDEN)
#define ATTR_ALL        (ATTR_READONLY+ATTR_DIR+ATTR_HIDDEN+ATTR_SYSTEM)

typedef struct {
    char        Reserved[21];
    BYTE        Attr;
    WORD        Time;
    WORD        Date;
    DWORD       Length;
    char        szName[13];
}   FCB;

typedef FCB     * PFCB;
typedef FCB FAR * LPFCB;

/* functions from dos.asm */

extern int   FAR PASCAL DosFindFirst (LPFCB lpfcb, LPSTR szFileSpec, WORD attr);
extern int   FAR PASCAL DosFindNext  (LPFCB lpfcb);
extern int   FAR PASCAL GetCurrentDrive (void);
extern int   FAR PASCAL SetCurrentDrive (int iDrive);
extern LONG  FAR PASCAL DosDiskFreeSpace(int iDrive);
extern int   FAR PASCAL DosCwd   (LPSTR szDir);
extern int   FAR PASCAL DosChDir (LPSTR szDir);
extern int   FAR PASCAL DosMkDir (LPSTR szDir);
extern int   FAR PASCAL DosValidDir (LPSTR szDir);
extern int   FAR PASCAL GetFixedDisks(int * rgiDrive);
extern int   FAR PASCAL GetCurrentVolume (LPSTR szBuf);
extern int   FAR PASCAL DosRemoveable(int iDisk);
extern int   FAR PASCAL DosIsRemote(int);
extern int   FAR PASCAL MyReadWriteSector(void far *, int, int, int, int, int);
extern DWORD FAR PASCAL DosMemory(void);
extern int   FAR PASCAL DosRename(LPSTR, LPSTR);
extern int   FAR PASCAL DosDelete(LPSTR);
extern WORD  FAR PASCAL DosVersion(void);
extern void  FAR PASCAL DosExit(WORD);
extern LPSTR FAR PASCAL DosGetEnv(void);
extern DWORD FAR PASCAL XmsVersion(void);
extern BOOL  FAR PASCAL XmsInstalled(void);
extern void  FAR PASCAL Reboot(void);
extern int   FAR PASCAL GetCodePage(void);
extern WORD  FAR PASCAL get_ext(void);
extern WORD  FAR PASCAL ExtendedMemory(void);
extern void  FAR PASCAL fnGetFilePath(char*, char*);

extern unsigned FAR PASCAL fnGetSmartDrvVersion(void);
extern BOOL     FAR PASCAL fnGetRamDriveVersion(LPSTR szVerString);

/* External functions from file.c */

extern unsigned FAR PASCAL fnProcessFile(int*,int*,int*,int*,int*,int*,unsigned);
extern void                fnConstructDeviceEntry(PSTR, PSTR, int, int);
extern unsigned            fnGetInstalledSize(PSTR,int);
extern unsigned            fnLstrlen(LPSTR);
extern LPSTR NEAR PASCAL   fnLoadFile(PSTR);
extern int NEAR PASCAL     strncmpinf(PSTR, LPSTR, int);
extern LPSTR               fnCopyBuf(LPSTR, LPSTR, unsigned);
extern int                 fnLinelenl(LPSTR);
extern LPSTR               fnNextConfigLine(LPSTR);
extern int NEAR PASCAL     fnWriteFile(LPSTR szBuffer, int fh);
extern BOOL   NEAR PASCAL  fnModifyPath(unsigned,PSTR);
extern BOOL   NEAR PASCAL  fnUpdateDevice(PSTR, unsigned, PSTR);
extern void   FAR  PASCAL  fnTweekMouse(PSTR,PSTR);
extern BOOL                fnMystrstr(char*, char*);

/* External functions from exe.c */

extern BOOL FAR PASCAL GetExeInfo(PSTR szFile, VOID *pBuf, int nBuf, WORD fInfo);
#define GEI_MODNAME         0x01
#define GEI_DESCRIPTION     0x02
#define GEI_FLAGS           0x03
#define GEI_EXEHDR          0x04
#define GEI_FAPI            0x05

/* DOS ERROR CODES */

#define ERROR_OK            0x00
#define ERROR_FILENOTFOUND  0x02    /* File not found */
#define ERROR_PATHNOTFOUND  0x03    /* Path not found */
#define ERROR_NOFILEHANDLES 0x04    /* Too many open files */
#define ERROR_ACCESSDENIED  0x05    /* Access denied */
#define ERROR_INVALIDHANDLE 0x06    /* Handle invalid */
#define ERROR_FCBNUKED      0x07    /* Memory control blocks destroyed */
#define ERROR_NOMEMORY      0x08    /* Insufficient memory */
#define ERROR_FCBINVALID    0x09    /* Memory block address invalid */
#define ERROR_ENVINVALID    0x0A    /* Environment invalid */
#define ERROR_FORMATBAD     0x0B    /* Format invalid */
#define ERROR_ACCESSCODEBAD 0x0C    /* Access code invalid */
#define ERROR_DATAINVALID   0x0D    /* Data invalid */
#define ERROR_UNKNOWNUNIT   0x0E    /* Unknown unit */
#define ERROR_DISKINVALID   0x0F    /* Disk drive invalid */
#define ERROR_RMCHDIR       0x10    /* Attempted to remove current directory */
#define ERROR_NOSAMEDEV     0x11    /* Not same device */
#define ERROR_NOFILES       0x12    /* No more files */
#define ERROR_13            0x13    /* Write-protected disk */
#define ERROR_14            0x14    /* Unknown unit */
#define ERROR_15            0x15    /* Drive not ready */
#define ERROR_16            0x16    /* Unknown command */
#define ERROR_17            0x17    /* Data error (CRC) */
#define ERROR_18            0x18    /* Bad request-structure length */
#define ERROR_19            0x19    /* Seek error */
#define ERROR_1A            0x1A    /* Unknown media type */
#define ERROR_1B            0x1B    /* Sector not found */
#define ERROR_WRITE         0x1D    /* Write fault */
#define ERROR_1C            0x1C    /* Printer out of paper */
#define ERROR_READ          0x1E    /* Read fault */
#define ERROR_1F            0x1F    /* General failure */
#define ERROR_SHARE         0x20    /* Sharing violation */
#define ERROR_21            0x21    /* File-lock violation */
#define ERROR_22            0x22    /* Disk change invalid */
#define ERROR_23            0x23    /* FCB unavailable */
#define ERROR_24            0x24    /* Sharing buffer exceeded */
#define ERROR_32            0x32    /* Unsupported network request */
#define ERROR_33            0x33    /* Remote machine not listening */
#define ERROR_34            0x34    /* Duplicate name on network */
#define ERROR_35            0x35    /* Network name not found */
#define ERROR_36            0x36    /* Network busy */
#define ERROR_37            0x37    /* Device no longer exists on network */
#define ERROR_38            0x38    /* NetBIOS command limit exceeded */
#define ERROR_39            0x39    /* Error in network adapter hardware */
#define ERROR_3A            0x3A    /* Incorrect response from network */
#define ERROR_3B            0x3B    /* Unexpected network error */
#define ERROR_3C            0x3C    /* Remote adapter incompatible */
#define ERROR_3D            0x3D    /* Print queue full */
#define ERROR_3E            0x3E    /* Not enough room for print file */
#define ERROR_3F            0x3F    /* Print file was deleted */
#define ERROR_40            0x40    /* Network name deleted */
#define ERROR_41            0x41    /* Network access denied */
#define ERROR_42            0x42    /* Incorrect network device type */
#define ERROR_43            0x43    /* Network name not found */
#define ERROR_44            0x44    /* Network name limit exceeded */
#define ERROR_45            0x45    /* NetBIOS session limit exceeded */
#define ERROR_46            0x46    /* Temporary pause */
#define ERROR_47            0x47    /* Network request not accepted */
#define ERROR_48            0x48    /* Print or disk redirection paused */
#define ERROR_50            0x50    /* File already exists */
#define ERROR_51            0x51    /* Reserved */
#define ERROR_52            0x52    /* Cannot make directory */
#define ERROR_53            0x53    /* Fail on Int 24H (critical error) */
#define ERROR_54            0x54    /* Too many redirections */
#define ERROR_55            0x55    /* Duplicate redirection */
#define ERROR_56            0x56    /* Invalid password */
#define ERROR_57            0x57    /* Invalid parameter */
#define ERROR_58            0x58    /* Net write fault */


/* LZCopy() return error codes. These must be neagtive */

#define LZERROR_BADINHANDLE   -1  /* Invalid input handle */
#define LZERROR_BADOUTHANDLE  -2  /* Invalid output handle */
#define LZERROR_READ          -3  /* Bad compressed file format */
#define LZERROR_WRITE         -4  /* Out of space for output file */
#define LZERROR_GLOBALLOC     -5  /* Insufficient memory for buffers */
#define LZERROR_GLOBLOCK      -6  /* Bad global handle */


#ifdef DEBUG
        BOOL    fDebug;
        BOOL    fDontCopy;
        BOOL    __f;

#ifndef WM_USER
		  extern void FAR _Assert(char *,int);
#else
        extern FAR _Assert();
#endif

        #define AssertF(exp) ( (exp) ? 0 : _Assert(__FILE__,__LINE__) )
        #define AssertE(exp) ((__f=(exp)),AssertF(__f),__f)
#else
        #define AssertF(exp) 0
        #define AssertE(exp) (exp)
#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\lib\common\newexe.h ===
/*static char *SCCSID = "@(#)newexe.h:2.9";*/
/*
 *  Title
 *
 *      newexe.h
 *      Pete Stewart
 *      (C) Copyright Microsoft Corp 1984
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 *  Modification History
 *
 *      84/08/17        Pete Stewart    Initial version
 *      84/10/17        Pete Stewart    Changed some constants to match OMF
 *      84/10/23        Pete Stewart    Updates to match .EXE format revision
 *      84/11/20        Pete Stewart    Substantial .EXE format revision
 *      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
 *      85/01/10        Steve Wood      Added resource definitions
 *      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
 *      85/03/07        Pete Stewart    Added movable entry count
 *      85/04/01        Pete Stewart    Segment alignment field, error bit
 */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words in header */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned short      e_res[ERESWDS]; /* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0

struct new_exe                          /* New .EXE header */
  {
    unsigned short int  ne_magic;       /* Magic number NE_MAGIC */
    char                ne_ver;         /* Version number */
    char                ne_rev;         /* Revision number */
    unsigned short int  ne_enttab;      /* Offset of Entry Table */
    unsigned short int  ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short int  ne_flags;       /* Flag word */
    unsigned short int  ne_autodata;    /* Automatic data segment number */
    unsigned short int  ne_heap;        /* Initial heap allocation */
    unsigned short int  ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short int  ne_cseg;        /* Count of file segments */
    unsigned short int  ne_cmod;        /* Entries in Module Reference Table */
    unsigned short int  ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short int  ne_segtab;      /* Offset of Segment Table */
    unsigned short int  ne_rsrctab;     /* Offset of Resource Table */
    unsigned short int  ne_restab;      /* Offset of resident name table */
    unsigned short int  ne_modtab;      /* Offset of Module Reference Table */
    unsigned short int  ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short int  ne_cmovent;     /* Count of movable entries */
    unsigned short int  ne_align;       /* Segment alignment shift count */
    unsigned short int  ne_cres;        /* Count of resource segments */

    unsigned short int  ne_psegcsum;    /* offset to segment chksums */
    unsigned short int  ne_pretthunks;  /* offset to return thunks */
    unsigned short int  ne_psegrefbytes;/* offset to segment ref. bytes */
    unsigned short int  ne_swaparea;    /* Minimum code swap area size */
    unsigned short int  ne_expver;      /* Expected Windows version number */
  };

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_RES(x)       (x).ne_res

#define NE_USAGE(x)     (WORD)*((WORD FAR *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_PAUTODATA(x) (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif


/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   c                                  Non-conforming
 *    e                                 Errors in image
 *     xxxxxxxxx                        Unused
 *              P                       Runs in protected mode
 *               r                      Runs in real mode
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NENONC          0x4000          /* Non-conforming program */
#define NEIERR          0x2000          /* Errors in image */
#define NEPROT          0x0008          /* Runs in protected mode */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */

struct new_seg                          /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
  };

struct new_seg1                         /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
    unsigned short      ns_handle;      /* Handle of segment */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc

/*
 *  Format of NS_FLAGS(x):
 *
 *  xxxx                                Unused
 *      DD                              286 DPL bits
 *        d                             Segment has debug info
 *         r                            Segment has relocations
 *          e                           Execute/read only
 *           p                          Preload segment
 *            P                         Pure segment
 *             m                        Movable segment
 *              i                       Iterated segment
 *               ttt                    Segment type
 */
#define NSTYPE          0x0007          /* Segment type mask */
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL           0x0C00          /* 286 DPL bits */
#define NSDISCARD       0x1000          /* Discard bit for segment */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            unsigned short      ns_niter;       /* number of iterations */
            unsigned short      ns_nbytes;      /* number of bytes */
            char                ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            char                ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    unsigned short      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

struct new_rlc                          /* Relocation item */
  {
    char                nr_stype;       /* Source type */
    char                nr_flags;       /* Flag byte */
    unsigned short      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            char        nr_segno;       /* Target segment number */
            char        nr_res;         /* Reserved */
            unsigned short nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            unsigned short nr_mod;      /* Index into Module Reference Table */
            unsigned short nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
      }                 nr_union;       /* Union */
  };

#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc

/*
 *  Format of NR_STYPE(x):
 *
 *  xxxxx                               Unused
 *       sss                            Source type
 */
#define NRSTYP          0x07            /* Source type mask */
#define NRSSEG          0x02            /* 16-bit segment */
#define NRSPTR          0x03            /* 32-bit pointer */
#define NRSOFF          0x05            /* 16-bit offset */

/*
 *  Format of NR_FLAGS(x):
 *
 *  xxxxx                               Unused
 *       a                              Additive fixup
 *        rr                            Reference type
 */
#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */
#define OSFIXUP 	0x03		/* Floating point fixup */


/* Resource type or name string */
struct rsrc_string
    {
    char rs_len;            /* number of bytes in string */
    char rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    unsigned short rt_id;
    unsigned short rt_nres;
    long rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    unsigned short rn_offset;   /* file offset to resource data */
    unsigned short rn_length;   /* length of resource data */
    unsigned short rn_flags;    /* resource flags */
    unsigned short rn_id;       /* resource name id */
    unsigned short rn_handle;   /* If loaded, then global handle */
    unsigned short rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0x1000      /* Discard bit for resource */

#define RNLOADED    0x0004      /* True if handler proc return handle */

/* Resource table */
struct new_rsrc
    {
    unsigned short rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\lib\compress\doslzexp.h ===
// doslzexp.h
// housekeeping for DOS Lempel-Ziv decompression command-line and library
// module

#if defined(LZDLL)
#define LZPTR FAR
#else
#define LZPTR NEAR
#endif

#include "..\common\sulib.h"


// Constants
/////////////
#define FALSE           0              // booleans
#define TRUE            1

#define END_OF_INPUT       500         // readInBuf() EOF flag for input file

#define LZDECODE_OK        501         // LZDecode() successful return value
#define COPYCREATEDATE_OK  502         // copyCreateDate() successful return
                                       // value

#define cbRingBufMax    4096           // size of ring buffer
#define cbIndex         2              // encode string into position and
                                       // length
#define cbStrMax        16             // upper limit for match length

#define ucbIOBufMax     32768U         // max size of rguchInBuf[] used for
                                       // reads and rguchOutBuf[] used for
                                       // writes
#define ucbIOBufStep    512U           // step down value used in attempting
                                       // to allocate rguchInBuf[] and
                                       // rguchOutBuf[]

#define uchBUF_CLEAR ((UCHAR) ' ')  // rguchRingBuf[] initializer

#define szCompSig       "SZDD\x88\xf0\x27\x33"  // compressed file signature:
                                                // "SZDD'3"
#define cbCompSigLength 8              // length of signature (bytes)
                                       // (no '\0' terminator)

#define uchFLUSH     ((UCHAR) 'F')  // dummy character used to flush
                                       // outBuf[] to output file

#define uchALG_LEMPEL_ZIV  ((UCHAR) 'A')  // Lempel-Ziv algorithm label
#define uchVER_1           ((UCHAR) '\0') // start with version 1

// length of entire compressed file header (used as offset to start of
// compressed data)
#define cbHdrSize       14

// (14 == cbCompSigLength * sizeof(char) + 2 * sizeof(UCHAR) + sizeof(long))
//     == cbCompSigLength + algorithm + version + uncompressed length



// Macros
//////////
#define FOREVER         for(;;)

// read a character (buffered) from input file - returns character read cast
// as int if successful, or one of readInBuf()'s error codes if unsuccessful
#define ReadUchar(uch)        ((puchInBuf < puchInBufEnd) ?\
                               (int)(uch = *puchInBuf++) :\
                               ReadInBuf((UCHAR LZPTR *)&uch, doshSource))

// put at most one character back into the buffered input,
// n.b., can be used at most (puchInBuf - &rguchInBuf[1]) times (i.e., at
// beginning of buffer, can only be used once)
#define UnreadUchar()         ((puchInBuf == &rguchInBuf[1]) ?\
                               (bLastUsed = TRUE) :\
                               (int)(UCHAR LZPTR *)(--puchInBuf))

// write a character (buffered) to output file - returns given character
// argument cast as int if successful, or one of WriteOutBuf()'s error codes
// if unsuccessful
#define writeUChar(uch)       ((puchOutBuf < puchOutBufEnd) ?\
                               (int)(*puchOutBuf++ = uch) :\
                               WriteOutBuf(uch, doshDest))

#define InitBufferPtrs()      {  puchInBufEnd = &rguchInBuf[1] + ucbIOBufLen;\
                                 puchInBuf = &rguchInBuf[1] + ucbIOBufLen;\
                                 puchOutBufEnd = rguchOutBuf + ucbIOBufLen;\
                                 puchOutBuf = rguchOutBuf;\
                              }
                           

// free the far/global heap space used by the buffers
#define FreeBuffers()         {  FFREE(rguchInBuf);\
                                 FFREE(rguchOutBuf);\
                                 FFREE(rguchRingBuf);\
                              }


// Types
/////////
typedef unsigned char UCHAR;
typedef unsigned long ULONG;

// n.b., the compressed file header does not contain the file size of the
// compressed file since this is readily obtainable through filelength() or
// lseek().  The file info structure, however, does contain the compressed
// file size.
typedef struct tagFH          // file info structure (compressed file header
                              // + some additional information)
{
    UCHAR rguchMagic[cbCompSigLength]; // magic array of compressed file
                                       // signature bytes

    UCHAR uchAlgorithm;       // algorithm label
    UCHAR uchVersion;         // version id

    ULONG cbulUncompSize;     // uncompressed file size
    ULONG cbulCompSize;       // compressed file size (not stored in header)
} FH;



// Globals available to outside modules
////////////////////////////////////////
extern UCHAR FAR *rguchInBuf;       // input buffer for reads
extern UCHAR FAR *puchInBufEnd;     // pointer past end of rguchInBuf[]
extern UCHAR FAR *puchInBuf;        // pointer to next byte to read from
                                    // rguchInBuf[]

extern UCHAR FAR *rguchOutBuf;      // output buffer for writes
extern UCHAR FAR *puchOutBufEnd;    // pointer past end of rguchOutBuf[]
extern UCHAR FAR *puchOutBuf;       // pointer to last byte to write from
                                    // rguchOutBuf[]

extern UCHAR FAR *rguchRingBuf;     // ring buffer

// flag indicating whether or not rguchInBuf[0], which holds the last byte
// from the previous input buffer, should be read as the next input byte
// (only used so that at least one unReadUChar() can be called at all input
// buffer positions)
extern BOOL bLastUsed;

extern unsigned ucbIOBufLen;        // length of input and output buffers
// (actually, rguchInBuf[] has length ucbIOBufLen + 1 since rguchInBuf[0] is
// used when bLastUsed is TRUE)



#include "doslzexp.pro"

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\lib\compress\doslzexp.c ===
/*          DOS Lempel-Ziv Data Decompression Module
            (C) Copyright 1989 by Microsoft
            written by Steve Zeck and David Dickman

   This module contains functions and variables common to the LZ command-line
   module (compress.c), the DOS library module (lzcopy.c), and the Windows
   DLL (lzexpand.dll).
*/


// Headers
///////////

#if defined(LZDLL)

#include <windows.h>
#include <winexp.h>

#else

#include <string.h>
#include <io.h>
#include <dos.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>

#endif

#include "doslzexp.h"


// Globals
//////////
UCHAR FAR *rguchInBuf;     // input buffer for reads
UCHAR FAR *puchInBufEnd;   // pointer past end of rguchInBuf[]
UCHAR FAR *puchInBuf;      // pointer to next byte to read from rguchInBuf[]

UCHAR FAR *rguchOutBuf;    // output buffer for writes
UCHAR FAR *puchOutBufEnd;  // pointer past end of rguchOutBuf[]
UCHAR FAR *puchOutBuf;     // pointer to last byte to write from rguchOutBuf[]

UCHAR FAR *rguchRingBuf;   // ring buffer

// flag indicating whether or not rguchInBuf[0], which holds the last byte
// from the previous input buffer, should be read as the next input byte
// (only used so that at least one unReadUChar() can be done at all input
// buffer positions)
BOOL bLastUsed;

unsigned ucbIOBufLen;      // length of input and output buffers
// (actually, rguchInBuf[] has length ucbIOBufLen + 1 since rguchInBuf[0] is
// used when bLastUsed is TRUE)




// copyCreateDate()
//
// Copies create date of file with DOS handle doshfrom to file with DOS
// handle doshTo.  Returns LZERROR_BADINHANDLE or LZERROR_BADOUTHANDLE as
// error codes.
//
// n.b., stream-style I/O routines like fopen() and fclose() may counter the
// intended effect of this function.  fclose() writes the current date to any
// file it's called with which was opened in write "w" or append "a" mode.
// One klugey way to get around this in order to modify the date of a file
// opened for writing or appending by fopen() is to fclose() the file and
// fopen() it again in read "r" mode.  Then pass it to copyCreateDate().
//
int CopyCreateDate(int doshFrom,       // date and time stamp origin handle
                   int doshTo)         // target handle
{
   // _dos function prototypes
   extern unsigned _dos_getftime(int, unsigned *, unsigned *);
   extern unsigned _dos_setftime(int, unsigned, unsigned);

#if defined(LZDLL)
   static
#endif
   unsigned uFrom_date, uFrom_time;

   if (_dos_getftime(doshFrom, &uFrom_date, &uFrom_time) != 0u)
      return((int)LZERROR_BADINHANDLE);

   if (_dos_setftime(doshTo, uFrom_date, uFrom_time) != 0u)
      return((int)LZERROR_BADOUTHANDLE);

   return(COPYCREATEDATE_OK);
}  // copyCreateDate()



// ReadInBuf()
//
// Reads input buffer from input file.  Returns c cast as an int if the read
// is successful.  If the read is unsuccessful, returns LZERROR_BADINHANDLE or
// END_OF_INPUT.
//
int ReadInBuf(UCHAR LZPTR *puch, // first character to be read from the new
                                 // input buffer after reading from disk
              int doshSource)    // DOS input file handle
{
   unsigned ucbRead;             // number of bytes actually read

   rguchInBuf[0] = *(puchInBufEnd - 1);

   if ((ucbRead = FREAD(doshSource, &rguchInBuf[1], ucbIOBufLen))
       != ucbIOBufLen)
#if defined(LZDLL)
      if (ucbRead == (unsigned)(-1))
#else
      if (_error != 0U)
#endif
         // given incorrect input file handle
         return((int)LZERROR_BADINHANDLE);
      else if (ucbRead > 0U)
         // read last ucbRead bytes of input file, change input buffer end to
         // account for shorter read
         puchInBufEnd = &rguchInBuf[1] + ucbRead;
      else  // (ucbRead == 0U)
         // couldn't read any bytes from input file (EOF)
         return(END_OF_INPUT);

   // reset read pointer to beginning of input buffer
   puchInBuf = &rguchInBuf[1];

   if (bLastUsed)
   {
      // return the last character from the previous input buffer
      bLastUsed = FALSE;
      return((int)(*puch = rguchInBuf[0]));
   }
   else
      // return the first character from the new input buffer
      return((int)(*puch = *puchInBuf++));
}  // ReadInBuf()



// GetHdr()
//
// Puts compressed file header information from file with DOS handle
// doshSource into the file info structure pointed to by pFH.  Returns TRUE
// if input file size was long enough to have contained valid header
// information.  Returns FALSE if file was too short to have contained header
// information, or if a read error occurred when trying to get the header.
//
BOOL GetHdr(FH LZPTR *pFH,       // pointer to destination info structure
            int doshSource)      // DOS input file handle
{
   UCHAR rguchBuf[cbHdrSize];    // storage for compressed file header
   long cblInSize;               // length of input file
   int i, j;

   // get file length to compare to size of compressed file header
   if ((cblInSize = FSEEK(doshSource, 0L, SEEK_END)) == -1L)
      return(FALSE);

   // make sure file length >= size of compressed file header
   if (cblInSize < (long)cbHdrSize)
      return(FALSE);

   // move to beginning of input file
   if (FSEEK(doshSource, 0L, SEEK_SET) != 0L)
      return(FALSE);

   // put entire compressed file header into rguchBuf[]
   if (FREAD(doshSource, (UCHAR FAR *)rguchBuf, cbHdrSize) != cbHdrSize)
      return(FALSE);

   // put compressed file signature into rguchMagic[] of struct
   for (i = 0; i < cbCompSigLength; i++)
      pFH->rguchMagic[i] = rguchBuf[i];

   // get algorithm label and version id
   pFH->uchAlgorithm = rguchBuf[i++];
   pFH->uchVersion = rguchBuf[i++];

   // extract uncompressed file size, LSB --> MSB (4 bytes in long)
   pFH->cbulUncompSize = 0UL;
   for (j = 0; j < 4; j++)
      pFH->cbulUncompSize |= ((ULONG)(rguchBuf[i + j])) << (8 * j);

   // add compressed file size
   pFH->cbulCompSize = (ULONG)cblInSize;

   return(TRUE);              // file header read ok
}  // GetHdr()



// ChkHdr()
//
// Examines the compressed file signature in the given header info structure
// to see if it matches the real signature.  Returns non-0 if the bytes
// match (compressed file with signature).  Returns 0 if the bytes don't
// match (uncompressed file).
//
int ChkHdr(FH FHIn)           // header info structure to check
{
   int i;
   // storage for FHIn's compressed file signature (used to make it an sz)
   char rgchBuf[cbCompSigLength + 1];

   // copy file info structure's compressed file signature into rgchBuf[] to
   // make it an sz
   for (i = 0; i < cbCompSigLength; i++)
      rgchBuf[i] = FHIn.rguchMagic[i];

   rgchBuf[i] = '\0';

#if defined(LZDLL)
   return(lstrcmp((LPSTR)rgchBuf, (LPSTR)szCompSig) == 0);
#else
   return(strcmp(rgchBuf, szCompSig) == 0);
#endif
}  // ChkHdr()



// InitBuffers()
//
// Allocates far heap space (DOS) or fixed global heap space (Windows) for
// the input, output, and ring buffers.  Initializes working far pointers
// used to manipulate these buffers.  Returns TRUE if there was sufficient
// heap space to allocate the buffers, FALSE if not.  The ring buffer must be
// allocated at the fixed size used during encoding for decoding to proceed
// properly.  However, the input and output buffers hog as much heap space as
// they can get, up to ucbIOBufMax.  ucbIOBufLen is set when the input and
// output buffers are successfully allocated.  n.b., InitBuffers() will try
// to allocate buffer space down to (ucbIOBufMax % ucbIOBufStep).
//
BOOL InitBuffers(void)
{
      // set up ring buffer, n.b., extra cbStrMax - 1 bytes used to
      // facilitate string comparisons near end of ring buffer
      if ((rguchRingBuf = (UCHAR FAR *)FALLOC(cbRingBufMax + cbStrMax - 1))
          == NULL)
         return(FALSE);

      for (ucbIOBufLen = ucbIOBufMax; ucbIOBufLen > 0U;
                                      ucbIOBufLen -= ucbIOBufStep)
      {
         // try to set up input buffer, n.b., extra byte because
         // rguchInBuf[0] holds last byte from previous input buffer
         if ((rguchInBuf = (UCHAR FAR *)FALLOC(ucbIOBufLen + 1U)) == NULL)
            continue;

         // try to set up output buffer
         if ((rguchOutBuf = (UCHAR FAR *)FALLOC(ucbIOBufLen)) == NULL)
         {
            FFREE(rguchInBuf);
            continue;
         }

         // buffers allocated OK, so set up working pointers
         InitBufferPtrs();

         return(TRUE);
      }

      return(FALSE);
}  // InitBuffers()





// LZDecode()
//
// Decompresses input file into output file using LZ algorithm.  Returns
// LZDECODE_OK if everything went alright.  If any errors occurred, returns
// LZERROR_BADINHANDLE, LZERROR_BADOUTHANDLE, LZERROR_READ, or LZERROR_WRITE.
// n.b., LZDecode() starts decoding from the current position of the input
// file pointer.
//
int LZDecode(int doshSource,  // compressed input file to decode
             int doshDest)    // decompressed output file
{
   int i,
       cb,                    // number of bytes to unpack
       f;                     // holds ReadUchar() return values
   int oStart,                // buffer offset for unpacking
       iCurBuf;               // ring buffer offset
   UCHAR uch1, uch2;          // input byte holders
   unsigned ufFlags = 0U;     // holds high order description byte

   bLastUsed = FALSE;

   for (i = 0; i < cbRingBufMax - cbStrMax; i++)
      rguchRingBuf[i] = uchBUF_CLEAR;

   iCurBuf = cbRingBufMax - cbStrMax;

   f = ReadUchar(uch1);
   if (f != (int)uch1)
      return((int)LZERROR_BADINHANDLE);

   FOREVER
   {
      if (f == END_OF_INPUT)        // EOF reached
         break;

      // high order byte counts the number of bits used in the low order byte
      if (((ufFlags >>= 1) & 0x100) == 0)
      {
         // set bit mask describing the next 8 bytes
         ufFlags = ((unsigned)uch1) | 0xff00;
         f = ReadUchar(uch1);
         if (f != (int)uch1)
            return((int)LZERROR_READ);
      }

      if (ufFlags & 1)
      {
         // just store the literal character in the buffer
         if ((f = writeUChar(uch1)) != (int)uch1)
            return((int)LZERROR_WRITE);

         rguchRingBuf[iCurBuf++] = uch1;
         iCurBuf &= cbRingBufMax - 1;
      }
      else
      {
         // extract the buffer offset and count to unpack
         f = ReadUchar(uch2);
         if (f != (int)uch2)
            return((int)LZERROR_READ);

         cb = (int)uch2;
         oStart = (cb & 0xf0) << 4 | (int)uch1;
         cb = (cb & 0x0f) + cbIndex;

         for (i = 0; i <= cb; i++)
         {
            uch1 = rguchRingBuf[(oStart + i) & (cbRingBufMax - 1)];

            if ((f = writeUChar(uch1)) != (int)uch1)
	       return((int)LZERROR_WRITE);

            rguchRingBuf[iCurBuf++] = uch1;
            iCurBuf &= cbRingBufMax - 1;
         }
      }

      f = ReadUchar(uch1);
   }

   // flush buffer to output file
   // (uchFLUSH isn't actually written to the output file)
   if ((f = WriteOutBuf(uchFLUSH, doshDest)) != (int)uchFLUSH)
      return((int)LZERROR_WRITE);

   return(LZDECODE_OK);
}  // LZDecode()
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dosdata\compiler\messages.h ===
/***************************************************************************/
/* Messages for DOSDATA.C 																	*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/***************************************************************************/
char *szMsgMemFailed 	= "Memory allocation failed\n";
char *szMsgErrDelOld 	= "Error deleting old DOSDATA.BAK\n";
char *szMsgInfParam		= "Insufficient parameters\n";
char *szMsgIllegalParam = "Illegal file name\n";
char *szMsgErrOpening	= "Error opening %s\n";
char *szMsgErrReading	= "Error reading %s\n";
char *szMsgBadFormat 	= "Bad format in file %s\n";
char *szMsgErrWriting	= "Error writing %s\n";
char *szMsgTooMuch		= "Too much data in %s\n";
char *szMsgTooManyNames = "Too many different names\n";
char *szMsgErrRenaming	= "Error renaming %s to .bak\n";
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\lib\compress\lzcopy.c ===
/*          DOS Lempel-Ziv Data Decompression Module
            (C) Copyright 1989 by Microsoft
            written by David Dickman
            LZ code by Steve Zeck

  note:
 	this module is compiled twice.  with LZDLL defined to be linked
 	with the LZEXPAND.DLL windows code.  without this, to build the
 	LZCOPY.LIB dos library.  be sure things work in both cases.

*/

#ifdef LZDLL

#include <windows.h>
#include <winexp.h>

#else

#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <io.h>
#include <dos.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>
#include <errno.h>

#endif

#include "lzcopy.h"


// Globals

static long cblOutSize;        // size in bytes of output file



// WriteOutBuf()
//
// NOTE! not to be confused with WriteOutBuf() in compress.c
//
// Dumps output buffer to output file.  Returns c cast as an int if the write
// is successful.  If the write is unsuccessful, returns LZERROR_BADOUTHANDLE or
// LZERROR_WRITE.
//
// returns:
//	< 0	error code (all errors are < 0)
//	> 0	success, char as described above
//
int WriteOutBuf(UCHAR uch,    // first character to be added to the empty
                              // buffer after the full buffer is written
                int doshDest) // DOS output file handle
{
   unsigned ucbToWrite,        // number of bytes to write from rguchOutBuf[]
            ucbWritten;        // number of bytes actually written

   // how many bytes should be written from rguchOutBuf[]?
   ucbToWrite = (unsigned)(puchOutBuf - rguchOutBuf);

   ucbWritten = FWRITE(doshDest, rguchOutBuf, ucbToWrite);
   
   if (ucbWritten != ucbToWrite)
      return LZERROR_WRITE;

#ifndef LZDLL
   if (FERROR())
         return LZERROR_WRITE;
#endif

   // keep track of bytes written
   cblOutSize += (long)ucbWritten;

   // reset write pointer to beginning of output buffer
   puchOutBuf = rguchOutBuf;

   // add the next character to the new buffer
   return ((int)(*puchOutBuf++ = uch));
}  // WriteOutBuf()



/***************************************************************************
 *
 * long DOSLZCopy()
 *
 * Copies input file with DOS handle doshSource to output file with DOS
 * handle doshDest.  If the input file has a LZ compressed file header, 
 * it is decompressed into the output file using LZ decoding.  If the 
 * input file does not have a LZ compressed file header, it is directly 
 * copied to the output file.
 *
 * in:
 *	doshSource	source file handle
 *	doshDest	dest file handle
 *
 * returns:
 *	# bytes copied	success
 *	< 0	failure for various LZERROR_ reasons
 *
 ***************************************************************************/

long DOSLZCopy(int doshSource, int doshDest)
{
   FH FHIn;          // structure holding header information from
                     // compressed input file (used for decoding)
   unsigned ucbRead;  // number of bytes actually read into rguchOutBuf[]
                     // during direct copy
   int f;            // holds LZDecode() return value

   cblOutSize = 0L;

   if (! InitBuffers())
      return LZERROR_GLOBALLOC;

   // check for LZ compressed file header
   if (! GetHdr((FH LZPTR *)&FHIn, doshSource) || ! ChkHdr(FHIn)
       || FHIn.uchAlgorithm != uchALG_LEMPEL_ZIV)
   {

      /************************ not compressed ****************************/

      // uncompressed file (straight DOS copy)
      // move to beginning of input file
      if (FSEEK(doshSource, 0L, SEEK_SET) != 0L)
      {
         FreeBuffers();
         return LZERROR_BADINHANDLE;
      }


      while ((ucbRead = FREAD(doshSource, (LPSTR)rguchOutBuf, ucbIOBufLen)) > 0U
#ifdef LZDLL
             && ucbRead != (unsigned)(-1))
#else
             && (FERROR() == 0))
#endif
      {
         if (FWRITE(doshDest, rguchOutBuf, ucbRead) != ucbRead) {

            FreeBuffers();

            return LZERROR_WRITE;
         }

         cblOutSize += (long)ucbRead;
      }

#ifdef LZDLL
      // here, ucbRead ==  0,		EOF (proper loop termination)
      //               == -1,		bad DOS handle
      if (ucbRead == (unsigned)(-1))
#else
      // here, FERROR() == 0U,		EOF (proper loop termination)
      //                != 0U,		bad DOS handle
      if (FERROR() != 0U)
#endif
      {
         FreeBuffers();
         return LZERROR_READ;
      }

   } else {

      /************************ compressed ****************************/

      // compressed file (LZ decompression)

      // move to beginning of compressed data and decompress file

      if (FSEEK(doshSource, (long)cbHdrSize, SEEK_SET) != (long)cbHdrSize)
      {
         FreeBuffers();
         return LZERROR_BADINHANDLE;
      }

      if ((f = LZDecode(doshSource, doshDest)) != LZDECODE_OK)
      {
         FreeBuffers();
         return f;
      }
   }

   // copy date and time stamp
   // doshSource and doshDest known to be valid DOS file handles

   CopyCreateDate(doshSource, doshDest);

   FreeBuffers();

   return cblOutSize;		// # bytes generated

}  // DOSLZCopy()
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dos2\lib\compress\lzcopy.h ===
// lzcopy.h
// housekeeping for DOS Lempel-Ziv decompression library module


#include "doslzexp.h"
#include "lzcopy.pro"

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dosdata\compiler\dosdata.c ===
/* DOSDATA.C -

		Copyright (c) 1991 - Microsoft Corp.
		All rights reserved.
		Microsoft Confidential


		Program to maintain the data file for the retail upgrade install
		utility.  Usage is as follows:

		DOSDATA filename
			Incorporates the information from the specified text information
			file into the master data file.

		DOSDATA /D oemname version
			Deletes all information for the specified version of DOS
			from the master data file.


		An typical text information file might contain:

			Compaq 3.31
			lie:
			mode.com
			fdisk.exe
			rename:
			mode.com mode40.com
			fdisk.exe fdisk40.exe
			delete:
			print.exe

		The master data file has the format:

			Dos_record_1
			Dos_record_2
			...
			Dos_record_n
			Null_dos_record
			Name_record_1
			Name_record_2
			...
			Name_record_n
			Null_name_record
			Name_entry_1
			Name_entry_2
			...

		A Dos_record is:

			[oem-name][dos-version][data-addr]
			    18          2           4       = 24 bytes

			(The data-addr field is a pointer to the beginning of the
			various data tables for that DOS.)

		A Name_record is a variable length record containing a
			zero-terminated string with a file name or action name.

		A Name_entry is a 1 byte record containing an integer index into
			the name record table.

*/

#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <stdlib.h>
#include <string.h>
#include <dos.h>
#include <errno.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <memory.h>
#include "messages.h"


#define	FALSE					0
#define	TRUE					1
#define	OK 					0
#define	EOL					'\0'
#define	USIZE					sizeof( unsigned )


#define OEM_SIZE				20
#define COMMENT_CHAR 		';'
#define OPEN_MODE 			( O_CREAT | O_RDWR | O_BINARY )


typedef char			FLAG;

char			*szEOD			= "###";
char			*szDosDataFile	= "dosdata.dat";
char			*szOldDataFile = "dosdata.bak";


/***************************************************************************/

#define	MAX_OEMS 			256
#define	MAX_STRINGS			1000
#define	MAX_DATA 			4000
#define	MAX_TEXT 			20000U


struct NEW_DDR
{
	char			szOemName[ OEM_SIZE ];		/* OEM name 						*/
	char			MajorVer;						/* Major DOS version number	*/
	char			MinorVer;						/* Minor DOS verison number	*/
	unsigned 	uDataOffset;					/* Offset of start of data 	*/
}nDDR;


struct NEW_DDR	*ddrOemList;		/* Array of DDR structures 				*/
struct NEW_DDR	*pNextOem;

char			*pchStringBuf;			/* Flat buffer to hold the data text	*/
char			*pchNextStr;			/* Ptr to next free data text addr		*/

unsigned		*uDataBuf;				/* Array to hold offset of data text	*/
unsigned		uDataNext;				/* Next free entry in the data array	*/

char			**apszPtr;				/* Araray of ptrs to the data text		*/
unsigned		uNextPtr;				/* Index to next free text list entry	*/

void			*Buf[3];					/* Ptrs to 3 allocated buffers			*/

/***************************************************************************/

void		main					( int cszArg,char * *rgszArg );
void		TrimSz				( char *sz );
void		ExitMsg				( char *szMsg );
void		ExitMsg1				( char *szMsg,void *pParam );
void		GetFileName			( char *szFileName,int cszArg,char * *rgszArg );
char		DoesItExist			( void );


void		InitializeBuffers ( void );
void		ReadOldFile 		( void );
void		GetDosId 			( FILE *pFile, char *szSourceFile );
void		WriteNewFile		( void );
void		ReadSourceData 	( char *szSourceFile );
unsigned GetTextOffset		( char *szText );
void		*GetMemory			( unsigned int	Bytes );

/***************************************************************************/

void main( int cszArg, char **rgszArg )
{	
        char                                    szSourceFile[ 200 ];
	struct find_t		File;

	InitializeBuffers();

	GetFileName( szSourceFile, cszArg, rgszArg );

	if ( !(_dos_findfirst( szDosDataFile, _A_NORMAL, &File )) )
		ReadOldFile();

	ReadSourceData( szSourceFile );

	WriteNewFile();
}
/***************************************************************************/
/* Allocate all needed buffers.															*/
/* 																								*/
/* void InitializeBuffers( void )														*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* 																								*/
/* RETURNS: 	void																			*/
/* 																								*/
/* johnhe 11-10-89																			*/
/***************************************************************************/

void InitializeBuffers( void )
{

	ddrOemList = GetMemory( sizeof( struct NEW_DDR	) * MAX_OEMS );
	pchStringBuf = GetMemory( sizeof( unsigned ) * MAX_TEXT );
	uDataBuf = GetMemory( sizeof( unsigned ) * MAX_DATA );
	apszPtr = GetMemory( sizeof( char *	) * MAX_STRINGS );

	memset( ddrOemList, 0, sizeof( struct NEW_DDR ) * MAX_OEMS );

										/* Initialize all ptrs and indexes in	*/
										/* case starting new file					*/
	pNextOem = ddrOemList;
	pchNextStr = pchStringBuf;
	uDataNext = 0;
	uNextPtr = 0;

	Buf[0] = ddrOemList; 		/* Initialize array of ptrs to buffers */
	Buf[1] = pchStringBuf;
	Buf[2] = uDataBuf;

}

/***************************************************************************/
/* Read in all the data from the existing data file and initialize the		*/
/* array of indexes to the strings in the text buffer. On return the all	*/
/* of the indices and ptrs to the next free positions will be set to the	*/
/* correct value and ready for adding new data to each of the data areas.	*/
/* 																								*/
/* void ReadOldFile( void )																*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* 																								*/
/* RETURNS: 	void																			*/
/* 																								*/
/* johnhe 11-10-89																			*/
/***************************************************************************/

void ReadOldFile( void )
{
	char			*EndStrBuf;
	int			iFile;
	int			i;
	unsigned 	uSize[3];

									/* Read in the 3 parts of the file	*/

	if ( (iFile = open( szDosDataFile, O_RDONLY | O_BINARY )) != -1 )
	{
		for ( i = 0; i < 3; i++ )
			if ( read( iFile, (char *) &uSize[i], USIZE ) != USIZE ||
				  read( iFile, (char *)Buf[i], uSize[i] ) != (int)uSize[i] )
						ExitMsg1( szMsgErrReading, szOldDataFile );

		close ( iFile );
	}
									/* Initialize the array of ptrs to text */
	EndStrBuf = pchStringBuf + uSize[1];
	pchNextStr = pchStringBuf;

	for ( uNextPtr = 0;
			pchNextStr < EndStrBuf;
			uNextPtr++ )
	{
		apszPtr[ uNextPtr ] = pchNextStr;
		pchNextStr = strchr( pchNextStr, EOL ) + 1;
	}
	pNextOem = ddrOemList + (uSize[0] / sizeof( struct NEW_DDR ));
	uDataNext = uSize[2] / sizeof( unsigned );

}

/***************************************************************************/
/* Opens the file specified on the command line and processes the text in	*/
/* in the file and then updates the 4 data areas in memory with the new 	*/
/* information.																				*/
/* 																								*/
/* void ReadSourceData( char *szSourceFile ) 										*/
/* 																								*/
/* ARGUMENTS:	szSource 	- Path and name string for the file to process	*/
/* 																								*/
/* RETURNS: 	void																			*/
/* 																								*/
/* johnhe 11-10-89																			*/
/***************************************************************************/

void ReadSourceData( char *szSourceFile )
{
	FILE				*pFile;
	char				szBuf[ 80 ];
	char				*szString;

	if ( (pFile = fopen( szSourceFile, "rt" )) == NULL )
		ExitMsg1( szMsgErrOpening, szSourceFile );

	while ( ! feof( pFile ) )
	{
											/* Create an OEM struct for this vender */
		GetDosId( pFile, szSourceFile );

		while ( !feof( pFile ) )
		{
			if ( !fgets( szBuf, 80, pFile ) )	/* Get next line from file */
			{
				if ( ferror( pFile ) )
					ExitMsg1( szMsgErrReading, szSourceFile );
			}
			else
			{													/* Check for buffer overflow */
				if ( uDataNext >= MAX_DATA - 1 ||
					  uNextPtr >= (MAX_STRINGS - 1) ||
					  (pchNextStr - pchStringBuf) > (int)(MAX_TEXT - 100) )
					ExitMsg1( szMsgTooMuch, szSourceFile );

				szString = strchr( szBuf, COMMENT_CHAR );
				if ( szString )
					*szString = 0	;						/* truncate comments */

				TrimSz( szBuf );
				if ( strcmp( szBuf, szEOD ) == 0 )
					break;									/* End of this OEM's data */

				if ( *szBuf )
					uDataBuf[ uDataNext++ ] = GetTextOffset( szBuf );
			}
		}
		uDataBuf[ uDataNext++ ] = 0xffffU;		/* Mark end of OEM data 	*/
	}

	fclose( pFile );
}
/***************************************************************************/
/* Reads in an OEM string and initializes the next free OEM ddr structure	*/
/* with the OEM name, version number and then increments the next free OEM */
/* structure pointer.																		*/
/* 																								*/
/* void GetDosId( FILE *pFile, char *szSourceFile )								*/
/* 																								*/
/* ARGUMENTS:	pFile 		- Open file structure									*/
/* 				szSourceFile - The name of the source file (for error msgs) */
/* 																								*/
/* RETURNS: 	void																			*/
/* 																								*/
/* johnhe 11-10-89																			*/
/***************************************************************************/

void GetDosId( FILE *pFile, char *szSourceFile )
{
	char			*szString;
	char			szBuf[ 80 ];
	char			szOemName[ OEM_SIZE ];
	register 	i;
	int			MajorVer;
	int			MinorVer;

	do
	{
		if ( feof( pFile ) )
			return;

		if ( ! fgets( szBuf, 80, pFile ) )
			ExitMsg1( szMsgErrReading, szSourceFile );

		szString = strchr( szBuf, COMMENT_CHAR );

		if ( szString )
			*szString = 0;		/* truncate comments */

		TrimSz( szBuf );
	} 
	while ( *szBuf == 0 );

	for ( i = 0;
			szBuf[i] != '*' &&
			szBuf[i] != EOL &&
			i < (OEM_SIZE - 1);
			i++ )
		szOemName[i] = szBuf[i];

	szOemName[i++] = EOL;
	if ( sscanf( szBuf+i, "%d.%d", &MajorVer, &MinorVer ) != 2 )
		ExitMsg1( szMsgBadFormat, szSourceFile );

	strncpy( pNextOem->szOemName, szOemName, sizeof( pNextOem->szOemName ) - 1 );
	pNextOem->MajorVer = (char)MajorVer;
	pNextOem->MinorVer = (char)MinorVer;
	pNextOem->uDataOffset = uDataNext * USIZE;
	pNextOem++; 								/* Increment ptr to next OEM			*/

	printf( "OEM: %-24s Version: %2d.%2.2d\n", szOemName, MajorVer, MinorVer );
}



/* johnhe 11-10-89																			*/
/***************************************************************************/

void WriteNewFile( void )
{
	int			iFile;
	int			i;
	unsigned 	uSize[3];

	uSize[0] = (unsigned)((pNextOem - ddrOemList) * sizeof( struct NEW_DDR ));
	uSize[1] = (unsigned)(pchNextStr - pchStringBuf);
	uSize[2] = uDataNext * USIZE;

	unlink( szOldDataFile );						/* Delete existing .bak file */
	rename( szOldDataFile, szOldDataFile	);

	if ( (iFile = open( szDosDataFile, OPEN_MODE, S_IWRITE )) != -1 )
	{
		for ( i = 0; i < 3; i++ )
			if ( write( iFile, (char *) &uSize[i], USIZE ) != USIZE ||
				  write( iFile, (char *)Buf[i], uSize[i] ) != (int)uSize[i] )
						ExitMsg1( szMsgErrWriting, szOldDataFile );

		close ( iFile );
	}
	else
		ExitMsg1( szMsgErrWriting, szOldDataFile );
}

/***************************************************************************/

/* Remove trailing spaces, tabs, and new-lines from string */

void TrimSz( char *szString )
{
	char *szPtr;

												/* szPtr -> end of string marker */
	szPtr = strchr( szString, EOL );

												/* go back to first non-space, non-tab */
	while ( (--szPtr >= szString ) &&
			  (*szPtr == ' ' || *szPtr == '\t' || *szPtr == '\n') )
		;

	*(++szPtr) = EOL; 						/* terminate the string after that */
}	

/***************************************************************************/

void ExitMsg( char *szMsg )
{
	printf( szMsg );
	exit( 1 );
}

/***************************************************************************/

void ExitMsg1( char *szMsg, void *pParam )
{
	char		szBuf[ 80 ];

	sprintf( szBuf, szMsg, pParam );
	ExitMsg( szBuf );
}

/***************************************************************************/
/* Returns an index to the array of pointers which has a pointer to the 	*/
/* specified string. If the string does not exist a buffer is allocated 	*/
/* for it and a pointer to this buffer is added in the next available		*/
/* element in the array of pointers an the index to this element is			*/
/* returned.																					*/
/* 																								*/
/* unsigned GetTextOffset( char *szText ) 											*/
/* 																								*/
/* ARGUMENTS:	szText		- Point to a string to find in or add to buffer */
/* 																								*/
/* RETURNS: 	unsigned 	- Offset in text buffer where string is located */
/* 																								*/
/* johnhe 11-10-89																			*/
/***************************************************************************/

unsigned GetTextOffset( char *szText )
{
	int				i;
	unsigned 		uOffset;
												/* See if the string is a duplicate */
	for ( i = 0; i < (int)uNextPtr; i++ )
	{
		if ( strcmp( apszPtr[ i ], szText ) == OK )
		{
			uOffset = (unsigned)(apszPtr[i] - pchStringBuf);
			break;
		}
	}
												/* If didn't find a match need to add  */
												/* this string to the text buffer		*/
	if ( i >= (int) uNextPtr )
	{
		uOffset = (unsigned)(pchNextStr - pchStringBuf);

		strcpy( pchNextStr, szText );
		apszPtr[ uNextPtr++ ] = pchNextStr;

		pchNextStr = strchr( pchNextStr, EOL ) + 1;
	}

	return( uOffset );
}

/***************************************************************************/

void GetFileName( char *szFileName, int cszArg, char *rgszArg[] )
{
	if ( cszArg < 2 )
		ExitMsg( szMsgInfParam );

        if ( strlen( rgszArg [1] ) > 128 )
		ExitMsg( szMsgIllegalParam );

	strcpy( szFileName, rgszArg[ 1 ] );
}

/***************************************************************************/
/* Allocates the specified size buffer and returns a pointer to it. Checks */
/* for error and aborts program if memory is not available. 					*/
/* 																								*/
/* void *GetMemory( unsigned int Bytes )												*/
/* 																								*/
/* ARGUMENTS:	Bytes 	- Size of buffer to allocate in bytes					*/
/* 																								*/
/* RETURNS: 	void *	- Ptr to allocated buffer									*/
/* 																								*/
/* johnhe 11-10-89																			*/
/***************************************************************************/

void *GetMemory( unsigned int Bytes )
{
	void		*Ptr;

	if ( (Ptr = malloc( Bytes )) == NULL )
		ExitMsg( szMsgMemFailed );

	return( Ptr );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\alias.h ===
/***************************************************************************/
/* 																								*/
/* ALIAS.H																						*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* Global defines for the DOS 5.0 OEM and Retail install programs.			*/
/* 																								*/
/* Created 01/28/90	- johnhe																*/
/***************************************************************************/

/* #define	MEM_BUG	1 */

/***************************************************************************/
/* Normal variable typedefs. These type defs are compatible with OS2			*/
/* typedefs.																					*/
/***************************************************************************/

typedef		char					CHAR;
typedef		unsigned char		UCHAR;
typedef		int					INT;
typedef		unsigned int		UINT;
typedef		long					LONG;
typedef		unsigned long		UL;
typedef		float 				FLOAT;
typedef		double				DOUBLE;

/***************************************************************************/
/* Standard global constants.															  	*/
/* Don't change the TRUE define because some functions depend on it being	*/
/* 1 instead of !FALSE.																		*/
/***************************************************************************/

#ifndef		FALSE
   #define     FALSE          0
#endif

#ifndef		TRUE
   #define     TRUE           1
#endif

#ifndef		OFF
   #define     OFF            0
#endif

#ifndef		ON
   #define     ON             1
#endif

#ifndef		EOL
   #define     EOL            '\0'
#endif

#ifndef	  OK
   #define		OK			      0
#endif

#ifndef	  ABORT
   #define		ABORT			   -1
#endif

#ifndef	  ERROR
   #define		ERROR			   -1
#endif

#ifndef    ESC
	#define	  ESC					0x1b					/* ESC key ascii code		*/
#endif

#ifndef    PREVIOUS
	#define	  PREVIOUS			-2						/* Previous menu signal		*/
#endif

#ifndef	MAX_PATH
	#define		MAX_PATH					64 			/* Max DOS path length		*/
#endif

#ifndef	MAX_BLOCK
	#define		MAX_BLOCK				0xff00		/* Max file read/write		*/
#endif 														/* at one time size			*/


#define		MAX_PATH_LEN		128					/* Size of filepath buffers*/


/***************************************************************************/
/* Defines used by copy functions to determine the type of operation being	*/
/* performed.																					*/
/***************************************************************************/

#define		READ					0
#define		WRITE					1
#define 		DELETE				2
#define		RENAME				3
#define		CREATE				4
#define		CLEAR					5

/***************************************************************************/
/* Fatal error defines. This is an enumerated series which matches the 		*/
/* error messages in GLOBAL.TXT.															*/
/***************************************************************************/

#define		FATAL_MEMORY_ERROR		0
#define		FATAL_UNKOWN_ERROR		1
#define		FATAL_DOS_VERSION 		2
#define		FATAL_DISK_ERROR			3
#define		FATAL_DATA_READ_ERROR	4
#define		FATAL_HD_READ_ERROR		5
#define		FATAL_BPB_ERROR			6
#define		FATAL_HD_WRITE_ERROR 	7
#define		NO_ACT_PART					8
#define		BAD_MBR						9
#define		BAD_BPB						10
#define		BAD_SYS						11
#define		BAD_EBR						12
#define		BAD_RECOVERY_DISK 		13
#define		BAD_DOSDIR					14
#define		BAD_TMPDIR					15
#define		BAD_COMMAND_COM			16
#define		CORRUPT_DATA_FILE			17
#define		NO_COMSPEC_ERROR			18
#define		FATAL_SYSTEM_MISSING		19
#define		CORRUPT_DATA_ERROR		20
#define		ERROR_MOVING_FILE 		21
#define		ROOT_DIR_FULL				22
#define		ERROR_DELETING_TMP_FILE 23
#define		LIE_TABLE_UPDATE_ERROR	24
#define		NO_SUPPORTED_DISK_TYPES	25
#define		MAX_FATAL_ERROR			25

/* Compressed Disk defines */
#define		DOUBLE_SPACE_COMPRESSION_RATIO	0
#define		STACKER_COMPRESSION_RATIO			1
#define		SUPERSTOR_COMPRESSION_RATIO		2


/***************************************************************************/
/* Memory allocation function prototypes. If debugging is enabled the		*/
/* normal free() function is replaced by a function which does a heap walk	*/
/* before calling free(). A fatal error will be generated if the heap is	*/
/* corrupt.																						*/
/***************************************************************************/

void			*GetMemory( unsigned int Bytes );

#ifdef		MEM_BUG

	void  	FreeMemory( void *Addr );
	unsigned GetMemoryMax( void );
	int   	NumberAllocated( void );
	void  	InitializeMemory( void );

#else
		#define	FreeMemory( x )		free( x )

#endif

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\bios_io.h ===
/***************************************************************************/
/*                                                                         */
/*	BIOS_IO.H																					*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Include file for video definitions and function prototypes              */
/* Include file for keyboard function definitions and prototypes.          */
/*                                                                         */
/* Created 880305 - johnhe                                                 */
/***************************************************************************/

/***************************************************************************/
/* Misc. definitions that should always be defined                         */
/***************************************************************************/
#ifndef     FALSE
   #define     FALSE          0
#endif
#ifndef     TRUE
   #define     TRUE           1
#endif
#ifndef     OFF
   #define     OFF            0
#endif
#ifndef     ON
   #define     ON             1
#endif
#ifndef     EOL
   #define     EOL            '\0'
#endif

/***************************************************************************/
/* Definitons for video and keyboard functions                             */
/***************************************************************************/


#define     MONO_NORMAL    07
#define     MONO_REVERSE   112
#define     FORWARD     1
#define     REVERSE     0
#define     COLOR_80    3
#define     COLOR_40    1
#define     MONO        7
#define     HRES_BW     6


#ifndef	CTRL_C
	   /* Key codes */

	#define  CTRL_C   03
	#define	BEL      7
	#define	BS       8
	#define	CR       '\r'
	#define	CTRL_X   24
	#define  CTRL_R   18
	#define	TAB		9
	#define	SPC		32
	#define	QST		'?'
	#define	PERCENT	'%'
	#define	BLK		''
	#define	LF			'\n'

	#define	CHAR_0	'0'
	#define	COLON		':'


	#define  ESC      0x1b
	#define  LEFT     0x4b
	#define  RIGHT    0x4d
	#define  UP       0x48
	#define  DOWN     0x50
	#define  PAGE_UP  0x49
	#define  PAGE_DN  0x51
	#define  END      0x4f
	#define  HOME     0x47
	#define  INS      0x52
	#define  DEL      0x53
	#define  CENTER   0x4c

	#define	LCASE_A	'a'
	#define	LCASE_B	'b'
	#define	LCASE_C	'c'
	#define	LCASE_D	'd'
	#define	LCASE_E	'e'
	#define	LCASE_F	'f'
	#define	LCASE_G	'g'
	#define	LCASE_H	'h'
	#define	LCASE_I	'i'
	#define	LCASE_J	'j'
	#define	LCASE_K	'k'
	#define	LCASE_L	'l'
	#define	LCASE_M	'm'
	#define	LCASE_N	'n'
	#define	LCASE_O	'o'
	#define	LCASE_P	'p'
	#define	LCASE_Q	'q'
	#define	LCASE_R	'r'
	#define	LCASE_S	's'
	#define	LCASE_T	't'
	#define	LCASE_U	'u'
	#define	LCASE_V	'v'
	#define	LCASE_W	'w'
	#define	LCASE_X	'x'
	#define	LCASE_Y	'y'
	#define	LCASE_Z	'z'

	#define	UCASE_A	'A'
	#define	UCASE_B	'B'
	#define	UCASE_C	'C'
	#define	UCASE_D	'D'
	#define	UCASE_E	'E'
	#define	UCASE_F	'F'
	#define	UCASE_G	'G'
	#define	UCASE_H	'H'
	#define	UCASE_I	'I'
	#define	UCASE_J	'J'
	#define	UCASE_K	'K'
	#define	UCASE_L	'L'
	#define	UCASE_M	'M'
	#define	UCASE_N	'N'
	#define	UCASE_O	'O'
	#define	UCASE_P	'P'
	#define	UCASE_Q	'Q'
	#define	UCASE_R	'R'
	#define	UCASE_S	'S'
	#define	UCASE_T	'T'
	#define	UCASE_U	'U'
	#define	UCASE_V	'V'
	#define	UCASE_W	'W'
	#define	UCASE_X	'X'
	#define	UCASE_Y	'Y'
	#define	UCASE_Z	'Z'

	#define  F1       0x3b
	#define  F2       0x3c
	#define  F3       0x3d
	#define  F4       0x3e
	#define  F5       0x3f
	#define  F6       0x40
	#define  F7       0x41
	#define  F8       0x42
	#define  F9       0x43
	#define  F10      0x44

#endif

/************************************************************************/

struct COUNTRY_INFO
{
	unsigned			DateFmt;
	char				CurrencySym[5];
	char				ThousandSep[2];
	char				DecimalSep[2];
	char				DateSep[2];
	char				TimeSep[2];
	char				Bits;
	char				CurrencyPlaces;
	char				TimeFmt;
	char far 		*CaseMapAddr;
	char				DataSep[2];
	char				Reserved[10];
};

/************************************************************************/

unsigned char     ScreenWidth;
unsigned char     ScreenLength;
unsigned char     DisplayType;

/************************************************************************/

#define		COLOR_AREAS  	9

unsigned char		*uchAreaColors;		/* uchAreaColors[ COLOR_AREAS ] */

enum  AREA_COLORS { vuchHeaderColor, vuchBackGroundColor, vuchTitleColor,
						  vuchStatusColor, vuchRevBackColor, vuchPromptColor,
						  vuchErrorColor, vuchBoxColor, vuchBarColor,
						  vuchGageColor };

#define	GetHeaderColor()  			uchAreaColors[ vuchHeaderColor ]
#define	GetBackGroundColor()			uchAreaColors[ vuchBackGroundColor ]
#define	GetTitleColor()				uchAreaColors[ vuchTitleColor	]
#define	GetStatusColor()				uchAreaColors[ vuchStatusColor ]
#define	GetRevBackColor()				uchAreaColors[ vuchRevBackColor ]
#define	GetPromptColor()				uchAreaColors[ vuchPromptColor ]
#define	GetErrorColor()				uchAreaColors[ vuchErrorColor	]
#define	GetBoxColor()					uchAreaColors[ vuchBoxColor ]
#define	GetBarColor()					uchAreaColors[ vuchBarColor ]
#define	GetGageColor()					uchAreaColors[ vuchGageColor ]

#define	SetHeaderColor( x )			uchAreaColors[ vuchHeaderColor ] = x
#define	SetBackGroundColor( x )		uchAreaColors[ vuchBackGroundColor ] = x
#define	SetTitleColor( x )			uchAreaColors[ vuchTitleColor ] = x
#define	SetStatusColor( x )			uchAreaColors[ vuchStatusColor ] = x
#define	SetRevBackColor( x )			uchAreaColors[ vuchRevBackColor ] = x
#define	SetPromptColor( x )			uchAreaColors[ vuchPromptColor ] = x
#define	SetErrorColor( x )			uchAreaColors[ vuchErrorColor ] = x
#define	SetBoxColor( x )				uchAreaColors[ vuchBoxColor ] = x
#define	SetBarColor( x )				uchAreaColors[ vuchBarColor ] = x
#define	SetGageColor( x )				uchAreaColors[ vuchGageColor ] = x

#define	VideoGetWidth()				ScreenWidth

/************************************************************************/
   /* Video function prototypes */

void	MinVideoInitial	( void );			/* M100 - New function	*/
void  VideoInitial		( void );
int   GetOemDisplayID	( void );
int   VideoIsColor		( void );
void  VideoCls 			( int Color );

int   VideoGetMode		( void );
void  VideoSetMode		( int NewMode );

void  VideoSaveMode		( void );
void  VideoRestoreMode	( void );

void  VideoCursOff		( void );
void  VideoNormalCurs	( void );
void  VideoBlockCurs 	( void );
void  VideoSetRowCol 	( int Row, int Col );
int   VideoGetRowCol 	( void );

int   VideoGetCursSize	( void );
void  VideoSetCursSize	( unsigned	Size );

void  VideoPutChar		( int Character );
void  VideoPutCharRowCol( int Row, int Col, int Character );
void  VideoPutCharAttr	( int Row, int Col, int Character, int Color);

void  VideoPuts			( char *String );
void  VideoPutsRowCol	( int Row, int Col, char *String );
void  VideoPutsAttrRowCol( int Row, int Col, char *String,
	  							int Attribute );

void  VideoDupCharAttr	( int Row, int Col, int Character,
	  						  int Attribute, int Count );
void  VideoVertDupCharAttr( int Row, int Col, int DupChar,
	  							  int Attrib, int DupFactor );
void  VideoDupAttr		( int Row, int Col, int Attribute, int Count );
void 	VideoVertDupAttr	( int Row, int Col, int Attribute, int Count );

void  VideoScrollDn		( int StartRow, int StartCol, int EndRow,
	  						  int EndCol, int Lines, int BlankAttribute );
void  VideoScrollUp		( int StartRow, int StartCol, int EndRow,
	  						  int EndCol, int Lines, int BlankAttribute );

void  VideoGetBlock		( int Row, int Col, char *awSource,
	  						  int WordCount );
void  VideoPutBlock		( int Row, int Col, char *awSource,
											  int WordCount );
#ifdef JAPAN

void  VideoPutDBCharAttr	( int Row, int Col, int Character, int Color);
void  VideoDupDBCharAttr	( int Row, int Col, int Character,
	  						  int Attribute, int Count );
void  VideoVertDupDBCharAttr( int Row, int Col, int DupChar,
										  int Attrib, int DupFactor );
#endif

	/* Keyboard input functions */

int	KbdGetKey				( void );
int	KbdIsWaiting			( void );
int	KbdGetStatus			( void );


	/* DOS Ctrl break check functions */

int	GetBreakSetting		( void );
void	UpdateBreakSetting	( int );

/* */

void	RebootSystem		( void );
unsigned GetMemoryFree		( void );
unsigned GetModelBytes     ( void );
void	DisableAppend			( void );
void	EnableAppend			( void );
void	ToggleAssign			( void );

int	GetDosDataVersion 	( void );
int	IsIBM 					( void );

int	IsNotWindows			( void );

int   GetCountryInfo			( void *Buf34Bytes );

extern void interrupt cdecl far NewInt1b ( void );
extern void interrupt cdecl far NewInt23 ( void );


/************************************************************************/
/* Defines for hardtest.asm 															*/
/* define IDs for machines, displays, and mice			 						*/
/************************************************************************/

#if 0

#define UNKNOWN_MACHINE        0
#define IBMPC_XT_AT            1
#define IBMPS2_25_30           2
#define IBMPS2_50_60_80        3
#define ATT_PC                 4
#define HP_VECTRA              5
#define ZENITH_PC              6

/* Display ID's. These are returned from the GetDisplayID() func */

#define UNKNOWN_DISPLAY        0
#define COMPAQ_PLASMA          1
#define ATT_VDC400_MONO        2
#define IBMCGA                 3
#define HPMULTIMODE            4
#define VGA                    5
#define EGAHIRES_BW            6
#define EGA_COLOR              7
#define EGAHIRES_MONO          8
#define MCGA                   9
#define GAD_8514               10
#define CTVGA                  11
#define HERC_HIRES_MONO        12
#define EGA_64K                13
#define EGA_128K               14
#define EGA_192K               15
#define EGA_256K               16
#define VIDEO7VGA              17
#define VGA_MONO               18

/* Display ID's These are returned from the low level VideoAdapter() func */

#define CGA                    1
#define FAILED                 -1

/* Memory amounts returned from the EGAmemory() func. */

#define MEM_64K                0
#define MEM_128K               1
#define MEM_192K               2
#define MEM_256K               3

/* Mouse ID's returned by GetMouseType().

   n.b., values 1 through 5 should not be changed or reassigned.  They match
   the return values from the mouse driver INT 33h's function 36.
*/

#define UNKNOWN_MOUSE          0    /* Can't tell whether or not a mouse is
                                       installed... */

#define BUS_MOUSE              1    /* Type of mouse installed. */
#define SERIAL_MOUSE           2
#define INPORT_MOUSE           3
#define IBMPS2_MOUSE           4
#define HP_MOUSE               5

#define NO_MOUSE               6    /* No mouse installed. */

#endif


/*
** Display types returned by GetOEMDisplayID().  Equated similarly in
** video.asm.  These display values MUST match the manifest constants in
** lib\bios\video.asm!
*/

#define MONO_DISPLAY          0
#define CGA_DISPLAY           1
#define EGA_DISPLAY           2
#define EGA_MONO_DISPLAY      3
#define VGA_DISPLAY           4
#define VGA_MONO_DISPLAY      5
#define HERC_DISPLAY          6
#define MCGA_DISPLAY          7
#define GAD_8514              8


/* Hardware support functions */

extern unsigned	GetConvMem		( void );

extern unsigned 	IsConvertible	( void );
extern int      	GetCpuType		( void );
extern unsigned 	GetExtMemSize	( void );
extern unsigned 	GetRamDrive		( void ); /* Returns RAM-Drive version	*/
extern unsigned 	GetEmmVersion	( void ); /* Returns EMM386 version		*/
extern unsigned 	GetHimemVer		( void ); /* Returns HIMEM versison		*/
extern unsigned 	GetSmartDrvVer	( void ); /* Returns SMARTDrv version	*/

/************************************************************************/

#ifdef DBCS
/* DBCS function prototypes */

int	CheckLead 	( int Row, int Col );
int	CheckTail 	( int Row, int Col );
#endif

/************************************************************************/

#ifdef JAPAN
/* Kanji graphic characters */

#define		K_THICK_TOP_LEFT		0x84AC
#define		K_THICK_TOP_RIGHT		0x84AD
#define		K_THICK_BOTOM_LEFT		0x84AF
#define		K_THICK_BOTOM_RIGHT		0x84AE
#define		K_THICK_HORIZ_LINE		0x84AA
#define		K_THICK_VERT_LINE		0x84AB
#define		K_THICK_LEFT_TEE		0x84B0
#define		K_THICK_RIGHT_TEE		0x84B2

#define		K_THIN_TOP_LEFT			0x84A1
#define		K_THIN_TOP_RIGHT		0x84A2
#define		K_THIN_BOTOM_LEFT		0x84A4
#define		K_THIN_BOTOM_RIGHT		0x84A3
#define		K_THIN_HORIZ_LINE		0x849F
#define		K_THIN_VERT_LINE		0x84A0
#define		K_THIN_LEFT_TEE			0x84A5
#define		K_THIN_RIGHT_TEE		0x84A7
#endif







=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\dosonly.h ===
/***************************************************************************/
/*                                                                         */
/* DOSONLY.H																						*/
/*                                                                         */
/*		Copyright (c) 1992 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Global variables and macros for DOS only setup (ASTRO)					*/
/*                                                                         */
/* Created 03/05/89	- johnhe																*/
/***************************************************************************/

#define     DOS_BANNER_FILE     "SETUP.MSG"
#define 	MAX_BANNER_SCREENS	10
#define 	MAX_BANNER_LINES	10
#define 	BANNER_SECTION		"[CopyWait]"

extern char ***ppszBanners;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\disk_io.h ===
/***************************************************************************/
/*																									*/
/* DISK_IO.H																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* Prototypes and struct definitions for low level disk access via			*/
/* int 13h. 																					*/
/*																									*/
/* 																								*/
/* Created 06-06-89 johnhe																	*/
/***************************************************************************/


/***************************************************************************/

#pragma 		pack(1)							/* Pack all structures */

/***************************************************************************/

#define		DOS_O_RDWR				2

#define		LAST_DISK				256
#define		REDO_DISK				257
#define		NOT_FOUND				258

#define		BAD_MEDIA				1
#define		BAD_HARDWARE			2
#define		BAD_SOURCE				3
#define		NO_SPACE					4

#define		DMA_ERROR				0x09
#define		BAD_DISK_ERROR			-100
#define		MEMORY_ERROR			-200
#define		IVALID_DRIVE_TYPE		-300

#define		MAX_RETRIES				5
#define		DSK_PARAM_LEN			13
#define		DISK_INTERRUPT 		0x13

#define		DISK_TIME_OUT			0x80
#define		DISK_WRITE_PROTECT	0x03

#define		DSK_PARAMS_VECT		0x1e

#define		READ						0
#define		WRITE						1

#define		MAX_FORMAT_TYPE		6

#define     MAX_HIDDEN_SECTORS   1UL


/***************************************************************************/
/* Structure for passing to DOS 4.x int 25h & 26h disk io operations.		*/
/***************************************************************************/

struct ABSIO_PACKET
{
	long			lStartSector;			/* Starting sector	*/
	unsigned 	uNumSectors;			/* Number of sectors */
	char far 	*pchBuffer;				/* Ptr to buffer		*/
};


/***************************************************************************/
/*                                                                    		*/
/* Media bios parameter block structure. Gives information about FAT based	*/
/* block devices.																				*/
/*                                                                    		*/
/***************************************************************************/

struct BPB
{
	unsigned int		uBytesPerSec;		/* Bytes per sector			  		*/
	unsigned char		uchSecPerClus;		/* Sectors per cluster		  		*/
	unsigned int		uReservSec;			/* Number of reserved sectors		*/
	unsigned char		uchNumberFats;		/* Number of copies of the FAT	*/
	unsigned	int		uRootEntries;		/* Number of root dir entries		*/
	unsigned	int		uTotalSectors;		/* Total sectors on the disk		*/
	unsigned char		uchMediaDescr;		/* Media descriptor					*/
	unsigned int		uSecPerFat;			/* Number sectors per FAT copy	*/
	unsigned int		uSecPerTrack; 		/* Number of sectors per track	*/
	unsigned	int		uNumberHeads; 		/* Total number of heads			*/
	unsigned long		ulHiddenSec;		/* Total hidden sectors (boot)	*/
	unsigned long		ulTotalBigSecs;	/* Total sectors on > 32M disks	*/
};

/***************************************************************************/

													/* MS-DOS 4.0 boot record layout	*/
struct BOOT_HEADER
{
	unsigned char		BootJmp[3];			/* 3 byte jmp 							*/
	unsigned char		OemString[8];		/* 8 byte OEM name string 			*/
	struct BPB			Bpb;					/* Disk BPB structure				*/
	unsigned	char		uchPhysDrv;			/* Physical drive number			*/
	unsigned char		uchCurHd;			/* Current hard disk					*/
	unsigned char		uchExtSig;			/* Extended BPB signature 0x29	*/
	unsigned long		ulSerial;			/* Serial number						*/
	unsigned char		uchVolLabel[11];	/* Volume label string				*/
	unsigned char		uchSystemId[8];	/* System ID ie: "FAT12" etc.		*/
};


/***************************************************************************/
/* Format of file's creation time in a DIR structure								*/
/***************************************************************************/

struct	TIME
{
	unsigned		tSec:5;
	unsigned		Min:6;
	unsigned    Hour:5;
};

/***************************************************************************/

#ifndef	DATE_DEFINED

	struct	DATE
	{
		unsigned		Day:5;
		unsigned		Month:4;
		unsigned 	Year:7;
	};
	#define	DATE_DEFINED

#endif

/***************************************************************************/

struct DIR										/* MS-DOS directory entry layout	*/
{
	char				Name[8];					/* File name padded with spaces	*/
	char				Ext[3];					/* Padded file extension			*/
	char				Attrib;					/* File attributes					*/
	char     		Reserv[10];				/* Reserved for MS-DOS				*/
	struct TIME		Time;						/* Packed file creation time		*/
	struct DATE    Date;						/* Packed file creation date		*/
	unsigned			Cluster;					/* File's starting cluster			*/
	unsigned long	Size;						/* File size in bytes				*/
};

/***************************************************************************/
													/* Track layout information		*/
													/* needed by the ROM BIOS format	*/
													/* track function.					*/
struct FIELD_LIST
{
	unsigned	char		uchTrack;			/* Zero based track					*/
	unsigned	char		uchHead;				/* Zero based head					*/
	unsigned	char		uchSector;			/* One based sector					*/
	unsigned char		uchSize;				/* Sector size ( 2 == 512 bytes)	*/
};

/***************************************************************************/
												/* ROM BIOS DASD structure for	*/
												/* disk parameters.					*/
struct DSK_PARMS
{
	unsigned char	Specify1;
	unsigned char	Specify2;
	unsigned char	MotorWait;			/* Wait till motor off 				*/
	unsigned char	SecSize;				/* Bytes/Sector (2 = 512)			*/
	unsigned char	EOT;					/* Sectors per track (MAX)			*/
	unsigned char	RWGap;				/* Read Write Gap						*/
	unsigned char	DTL;					/*  										*/
	unsigned char	FmtGap;				/* Format Gap Length					*/
	unsigned char	Fill;					/* Format Fill Byte					*/
	unsigned char	HdSettle;			/* Head Settle Time (MSec)			*/
	unsigned char	MotorStrt;			/* Motor start delay					*/
	unsigned char	Res1;					/* Reserve field for new ROMs		*/
	unsigned char	Res2;					/* Reserve field for new ROMs		*/
};

/***************************************************************************/

struct DOS_FCB
{
	char				Drive;
	char				Name[8];
	char				Ext[3];
	unsigned			CurBlock;

	unsigned			RecSize;
	unsigned long	FileSize;
	unsigned			Date;
	unsigned			Time;

	char				Reserved[8];
	unsigned char	CurRecord;
	unsigned long	RelRecord;
};

/***************************************************************************/
/* Function prototype for all functions in disk_lib								*/
/***************************************************************************/

extern int	IsInterlnk		( int Drive );
extern int	IsRemoveable	( int Drive );
extern int	IsLocalDrive	( int Drive );
extern int	IsValidDrive	( char DriveLetter );
extern int	IsRamDrive		( char DriveLetter );
extern int	IsReallyValidHardDrive( char chDrive );
extern int	IsValidHardDrive( char chDrive );

extern void	EnableDiskAccess( unsigned char Drive );

extern void	far *SetMediaType	( unsigned uDrv,unsigned uTotalTracks,
									  unsigned uSecPerTrack );
extern int	ResetDrv 		( int Drive );
extern int	SetDiskType 	( unsigned uDrv, unsigned char DiskType );

extern int	IsDiskReady		( int Drive );
extern int	GetBootSector	( int Drive, char far *Buffer );

extern int	CheckDmaBound	( void *Buffer, unsigned Bytes );

extern int	PhyDiskRead		( char *pchBuf,int iSecCyl,int iHead,char chDrive,
									  int cSecs);
extern int	PhyDiskWrite	( char *pchBuf,int iSecCyl,int iHead,char chDrive,
									  int cSecs);

extern int	FcbOpen			( struct DOS_FCB *Fcb );
extern int	FcbRename		( char *Fcb );
extern int	FcbParse			( char *Name, char *Fcb );

extern void far Int24Fail		( void );	/* Must be FAR */
extern int	GetNumberOfDrives( void );
extern int	AbsReadWrite	( int Drive, struct ABSIO_PACKET *absPack,
									  int ReadWrite );

extern int IsValidPath		(char *szPath,unsigned int uDrvNumber, int SavePath);
extern int MoveToDir 		(char *szPath, int SavePath);
extern int IsValidDirName	(char *szPath);
extern int ValidDirChars	(char *szPath);
extern void SetFileTimeDate( struct DIR *Dir );
extern unsigned long ToLongTd( struct DIR *Dir );

extern int	ValidatePath	( char *szPath );
extern int	ValidateDir		( char *szPath );

extern int IsFormatted		( int iDrv, struct BPB *Bpb, char *pchBuffer	);
extern int GetDiskHead		( unsigned uSec, struct BPB *Bpb );
extern int GetDiskTrack 	( unsigned uSec, struct BPB *Bpb );

extern long	_dos_seek		( int Handle, long lOffset, int Mode );
extern int	_dos_dskreset	( void );
extern int	_dos_getdir 	( char *Buffer, int Drive	);

extern unsigned long	GetDiskLabel( int iDrv, char *szLabel, struct BPB *Bpb );
extern unsigned long	SetDiskLabel( int iDrv, char *szLabel, struct BPB *Bpb );

extern int	ReadWriteBoot	( int iDosDrv, void *Buffer, int ReadWrite );
extern int	ReadWriteRoot	( int iDosDrv, struct BPB *Bpb, void *Buf,
									  int Sector, int ReadWrite );
extern int	ReadWriteFat	( int iDosDrv, struct BPB *Bpb, void *Buf,
									  int Sector, int ReadWrite );


extern void interrupt cdecl far NewInt24 (unsigned es, unsigned ds,
														unsigned di, unsigned si,
														unsigned bp, unsigned sp,
														unsigned bx, unsigned dx,
														unsigned cx, unsigned ax );

extern unsigned GetMaxSectorSize	( void );
extern unsigned GetSectorSize		( unsigned char );


/* FILE_LIB */

extern int FileExists		( char *szFile );
extern int IsDirEmpty		( char *szPath );
extern int BigReadWrite		( int iFile,char far *Buf,long lBytes,int RdWr );
extern int RenameFCB			( char *szFrom,char *szTo );
extern int ReplaceFile		( char *szSource,char *szDestin );
extern int RdWrSectors		( int iDrv, unsigned uSec, unsigned uNumSec,
									  char *puchBuf, struct BPB *Bpb, int RdWr );
extern int	CreatRootDir	( int iDrv, struct BPB *Bpb );
extern int	ScrubFatRoot	( int iDrv, struct BPB *Bpb );
extern void ScrubFat 		( unsigned char *pchFat, unsigned Clusters );
extern int	WriteBoot		( int iDrv, struct BPB *Bpb, char *szLabel );
extern long GetDiskFree 	( int DrvLetter );
extern int	GetDskFmtType	( void );
extern int	GetDisketteType( int Drv );


extern int	FindFirstHd		( void *Buffer );
extern int	GetDriveType	( unsigned char Drive, void *Buffer );
extern void	InitNew13		( void *SectorBuffer );
extern void	RestoreOld13	( void );

extern unsigned long	FloppySetDiskLabel( int iDrv, char *szLabel, struct BPB *Bpb );
int FloppyWriteBoot( int iDrv, struct BPB *Bpb, char *szLabel );
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\blockdev.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1990
;
;   Title:	BLOCKDEV.INC -- Services and equates for BlockDev VxD
;
;   Version:	3.10
;
;   Date:	23-Aug-1990
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   23-Aug-1990 RAL Original
;
;==============================================================================

;
;   Service Declarations
;
Begin_Service_Table BlockDev

BlockDev_Service    BlockDev_Get_Version, LOCAL
BlockDev_Service    BlockDev_Register_Device, LOCAL
BlockDev_Service    BlockDev_Find_Int13_Drive, LOCAL
BlockDev_Service    BlockDev_Get_Device_List, LOCAL
BlockDev_Service    BlockDev_Send_Command, LOCAL
BlockDev_Service    BlockDev_Command_Complete, LOCAL
BlockDev_Service    BlockDev_Synchronous_Command, LOCAL

End_Service_Table   BlockDev


;
;   Block Device Desctiptor data structrue
;

BD_Priv_Data_Size	EQU	30h

BD_Major_Version	EQU	3
BD_Minor_Version	EQU	0Ah

BlockDev_Device_Descriptor STRUC
BDD_Next		dd	?
BDD_BD_Major_Ver	db	BD_Major_Version
BDD_BD_Minor_Ver	db	BD_Minor_Version
BDD_Device_Type 	db	?
BDD_Int_13h_Number	db	?
BDD_Flags		dd	?
BDD_Name_Ptr		dd	?
BDD_Max_Sector		dq	?
BDD_Sector_Size 	dd	?
BDD_Num_Heads		dd	?
BDD_Num_Cylinders	dd	?
BDD_Num_Sec_Per_Track	dd	?
BDD_Sync_Cmd_Proc	dd	?
BDD_Command_Proc	dd	?
BDD_Hw_Int_Proc 	dd	0
BDD_Reserved_BlockDev	db	BD_Priv_Data_Size dup (?)
BlockDev_Device_Descriptor ENDS


;
;   Flags for BDD_Flags field
;
BDF_Int13_Drive 	EQU	00000001b
BDF_Int13_Drive_Bit	EQU	0
BDF_Writeable		EQU	00000010b
BDF_Writeable_Bit	EQU	1
BDF_Removable		EQU	00000100b
BDF_Removable_Bit	EQU	2
BDF_Remote		EQU	00001000b
BDF_Remote_Bit		EQU	3
BDF_Serial_Cmd		EQU	00010000b
BDF_Serial_Cmd_Bit	EQU	4
BDF_Cache		EQU	00100000b
BDF_Cache_Bit		EQU	5


;
;   Device types for BDD_Device_Type field
;
BDT_360K_5_Inch_Floppy	EQU	00h
BDT_1200K_5_Inch_Floppy EQU	01h
BDT_720K_3_Inch_Floppy	EQU	02h
BDT_Single_Dens_8_Inch	EQU	03h
BDT_Double_Dens_8_Inch	EQU	04h
BDT_Fixed_Disk		EQU	05h
BDT_Tape_Drive		EQU	06h
BDT_Other		EQU	07h


;
;   Command Block for Block Devices
;
BlockDev_Command_Block	STRUC
BD_CB_Next		dd	?
BD_CB_Command		dw	?
BD_CB_Cmd_Status	dw	?
BD_CB_Flags		dd	?
BD_CB_Cmd_Cplt_Proc	dd	?
BD_CB_Sector		dq	?
BD_CB_Count		dd	?
BD_CB_Buffer_Ptr	dd	?
BD_CB_Reserved_Client	dd	?
BD_CB_Reserved_BlockDev dd	?
BD_CB_Reserved_FastDisk dd	?
BlockDev_Command_Block	ENDS


;
;   Commands
;   NOTE:  Commands 8000h-FFFFh are reserved for device specific commands
;
BDC_Read		EQU	0
BDC_Write		EQU	1
BDC_Verify		EQU	2
BDC_Cancel		EQU	3


;
;   Equates for command status. All codes below 10h imply successful completion
;   Error code value are > 10h
;
BDS_Success		  EQU	0		; Completed successfully
BDS_Success_With_Retries  EQU	1		; Completed successfully after retries
BDS_Success_With_ECC	  EQU	2		; Successful after error correction

BDS_First_Error_Code	  EQU	10h		; first error code value
BDS_Invalid_Sector_Number EQU	10h		; Invalid sector number
BDS_Canceled		  EQU	11h		; Command was canceled
BDS_Cmd_In_Progress	  EQU	12h		; Can't cancel cmd in progress
BDS_Invalid_Cmd_Ptr	  EQU	13h		; Cancel of invalid cmd pointer
BDS_Media_Error		  EQU	14h		; Read/Write failed
BDS_Device_Error	  EQU 	15h		; Device/Adapter failed
BDS_Invalid_Command	  EQU	16h


;
;   Flags for commands
;
BDCF_High_Priority	EQU	00000001b
BDCF_High_Priority_Bit	EQU	0
BDCF_Scatter_Gather	EQU	00000010b
BDCF_Scatter_Gather_Bit EQU	1
BDCF_Dont_Cache 	EQU	00000100b
BDCF_Dont_Cache_Bit	EQU	2


;
;   Equates for synchronous commands
;
BD_SC_Get_Version	EQU	0000h


;
;   Equates for error returns from synchronous command
;
BD_SC_Err_Invalid_Cmd	EQU	0001h


;
;   Value specified in CX register when API call-out Int 2Fh executed
;   The Hw_Detect_Start and End APIs are used by block devices to notify
;   TSR and DOS device driver software that they are performing hardware
;   detection.	This may, for example, disable a write-behind cache.
;
BlockDev_API_Hw_Detect_Start	EQU	0001h
BlockDev_API_Hw_Detect_End	EQU	0002h
;
;   The Int13_Chain_Check API is executed by Int 13h block devices to check
;   to see if the software that has hooked DOS's ROM BIOS int 13h address
;   is aware of BlockDev and it is OK to load block device drivers.  If it
;   is OK for block devices such as WDCTRL to load even though the DOS Int 13h
;   chain has been modified, the hook code should zero the CX register and
;   iret from this call.
;
BlockDev_API_Int13_Chain_Check	EQU	0003h
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\copy.h ===
/***************************************************************************/
/* 																								*/
/* COPY.H																						*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* Function prototypes and structure definitions for used by callers of 	*/
/* functions in COPY.C. 																	*/
/* 																								*/
/* 																								*/
/* Created 11-01-89 johnhe																	*/
/* TABS = 3																						*/
/***************************************************************************/


#define	INDEX_LEN		2			/* encode string into position and length */
#define	RING_BUF_LEN	4096					/* size of ring buffer				*/
#define	MAX_STR_LEN 	(16 + INDEX_LEN)	/* upper limit for match_length	*/
#define	UNPACK_BUF_LEN (512 * 17)			/* Size of unpacked buffer 		*/

#define	LANGUAGE_COMPRESS	1
#define	WINDOWS_COMPRESS	2

/***************************************************************************/

struct FILE_NAME
{
	char			*Source; 						/* Ptr to source file name 		*/
	char			*Destin; 						/* Ptr to destination file name	*/
};

/***************************************************************************/

struct FILE_PATH
{
	char			*Source; 						/* Ptr to source file's path     */
	char			*Destin; 						/* Ptr to destin file's path     */
};

/***************************************************************************/

struct DRIVE_LETTER
{
	char			Source;
	char			Destin;
};


/***************************************************************************/
/* struct MULT_FILES 																		*/
/* 																								*/
/* Structure used by the multifile copy functions to identify a file to		*/
/* be copied and information about how much of the file has been copied 	*/
/* and where in the copy buffer the file's data is located.                */
/***************************************************************************/

struct MULT_FILES
{
	struct FILE_NAME			Name; 			/* Source & destin file names 	*/
	struct FILE_PATH			Path; 			/* Source & destin file paths 	*/
	struct DRIVE_LETTER		Drive;			/* Source & destin drv letter 	*/
	long							lSourceSize;	/* Size of source	file				*/
	long							lDestinSize;	/* Size of destination file		*/
	long							lRead;			/* Bytes read from source. 		*/
	long							lWritten;		/* Bytes written to destination	*/
	long							lUnpacked;		/* Num of packed bytes unpacked	*/
	int							DiskNumber; 	/* Distrib disk# for source file */
	int							UserDisk;		/* User disk # for destination	*/
	unsigned						Time;				/* File creation time				*/
	unsigned						Date;				/* File creation date				*/
	unsigned char				IsPacked;		/* Flags file is compressed		*/
	char far						*pchStart;		/* Ptr to file's data in cpy buf */
};

/***************************************************************************/

struct  PACKED_HEADER
{												/* File info structure		*/
	 UCHAR	MagicStr[8];				/* array of magic words 	*/
	 long 	lDestinSize;				/* uncompressed file size	*/
};

/***************************************************************************/
#define		WIN_STR	"SZDD\x88\xf0\x27\x33"	/* "SZDD'3" */

struct	WIN_HEADER
{
	char				MagicStr[8];
	unsigned char	Algorithm;
	unsigned char	Version;
	long				lDestinSize;				/* uncompressed file size	*/
};

/***************************************************************************/

#define	PACKED_HEADER_SIZE	sizeof( struct PACKED_HEADER )

/***************************************************************************/


extern void		Xcopy					( struct MULT_FILES File[] );
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\data.h ===
/***************************************************************************/
/* 																								*/
/* DATA.H																						*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* Defines, prototypes and extern declarations for functions in DATA.C. 	*/
/*																									*/
/* Created 11-11-89 - johnhe																*/
/***************************************************************************/


#define	MAX_SRC_LIST		110
#define	MAX_PER_DISK		110

#define	EOC_MARKER			0xffff
#define	MAX_NUM_DISKS		15

#define	MAINTENANCE_MODE_INSTALL	-1

enum		UpgradeData			{ LIE_TO, RE_NAME, DELETE_FILE, ADD_DEVICE,
									  DRIV_PARM, REM_DEVICE, NO_INSTALL, DIF_FILE,
									  DIF_DISK, BIOS,

											/* Distribution disk label strings */
									  DIST_LABEL,

											/* Distribution disk prompts */
									  USER_LABEL,

									  COMPRESSION_RATIO,

									  USER_PROMPT, PROMPT,

									  DIF_PATH, GLOBAL_RENAME, UPDATE_DEV,
									  VIDEO_LIST, VIDEO_DRIVER, DISK_BYTES,
									  DISK_TYPE, GRABBER_DRIVER, NET_FILES,
									  DRIVER_VERSION, DELETE_DRIVER,
									  COMPONENTS_BYTES, TOTAL_BYTES,

									  BACKUP_WINDOS_FILES,
									  BACKUP_WIN_FILES,
									  BACKUP_DOS_FILES,
									  UNDELETE_WINDOS_FILES,
									  UNDELETE_WIN_FILES,
									  UNDELETE_DOS_FILES,
                             OPTCOMP_UNDELETE,
									  ANTIVIRUS_WINDOS_FILES,
									  ANTIVIRUS_WIN_FILES,
									  ANTIVIRUS_DOS_FILES,
                             OPTCOMP_ANTIVIRUS,

                                 /* Emergency-floppy layouts */
                             DOS360, DOS720, DOS120,

                                 /* 3rd part disk caching */
                             CACHES,

                                 /* Utilities smartdrv won't run with */
                             CONFLICTS_SMARTDRV,

                                 /* Drivers we can't add files before */
                             LOAD_AFTER_DRVS,

											/* Distribution disk file layouts */
									  DISTR_0, DISTR_1, DISTR_2, DISTR_3, DISTR_4,
                             DISTR_5, DISTR_6, DISTR_7, DISTR_8, DISTR_9,
                             DISTR_10,DISTR_11,DISTR_12,DISTR_13,DISTR_14,

											/* User disk file layouts */
									  DISK_0,DISK_1, DISK_2, DISK_3, DISK_4,
									  DISK_5, DISK_6, DISK_7, DISK_8, DISK_9,

									  OEM_TABLE, END_CLASS };

#define   MIN_INSTALL_BYTES               0
#define   DOS_INSTALL_BYTES               1

#define   BACKUP_COMPONENTS               2

#define   BACKUP_WIN_DOS_COMPONENTS       2
#define   BACKUP_WIN_COMPONENTS           3
#define   BACKUP_DOS_COMPONENTS           4

#define   UNDELETE_COMPONENTS             5

#define   UNDELETE_WIN_DOS_COMPONENTS     5
#define   UNDELETE_WIN_COMPONENTS         6
#define   UNDELETE_DOS_COMPONENTS         7

#define   ANTI_VIRUS_COMPONENTS           8

#define   ANTI_VIRUS_WIN_DOS_COMPONENTS   8
#define   ANTI_VIRUS_WIN_COMPONENTS       9
#define   ANTI_VIRUS_DOS_COMPONENTS       10

#define   FLOPPY_360_INSTALL_BYTES        11
#define   FLOPPY_720_INSTALL_BYTES        12
#define   FLOPPY_120_INSTALL_BYTES        13

#define   UNINSTALL_BYTES                 14

/***************************************************************************/
/* Structure to define the layout of the dos data OEM records. 				*/
/***************************************************************************/

#ifndef	OEM_SIZE
	#define OEM_SIZE	20

struct DDR
{
	char			szOemName[ OEM_SIZE ];		/* OEM name 						*/
	UCHAR			MajorVer;						/* Major DOS version number	*/
	UCHAR 		MinorVer;						/* Minor DOS verison number	*/
	unsigned 	uDataOffset;					/* Offset of start of data 	*/
};

#endif

/***************************************************************************/
/* Prototypes for all functions in DATA.C.											*/
/***************************************************************************/

extern void 		InitDosData 		( char *szFilePath );
extern void 		FreeDataMemory 	( void );
extern void 		LoadOemData			( struct DDR *Oem );
extern char 		**InitSearchData	( int MajorVer, int	MinorVer );
extern void 		FreeSearchData 	( void );

extern void 		InitBannerData 		( char *szFilePath );

static unsigned	GetNextDataBlock	( int iFile, void **DataBuf );
static void			ReadOemData			( unsigned uDataOffset );
static char			**GetClassData		( char *InfoClass );

extern struct DDR *GetOemRecord		( char *szOemName, int MajorVer,
												  int MinorVer );

extern char			*GetDataString		( int Type, int Index );
extern char 		**GetClassList 	( int Type );
extern char 		*TranslateString	( int Type, char *szString );
extern int			BuildOemList		( char **szList, int MajorVer,
												  int	MinorVer );

extern int			GetDistrDiskType	( void );
extern int			GetNumberDisks 	( void );
extern char 		*GetFileName		( int iDisk, int iFile );

extern char 		*GetDistribLabel	( int iDiskNum );
extern char 		*GetDistribPrompt	( int iDiskNum );
extern char 		*GetUserLabel		( int iDiskNum );
extern char 		*GetUserPrompt		( int iDiskNum );
extern long			GetDiskBytes		( int	iDiskNum );
extern unsigned	GetDriverVersion	( int iDriverNum );
extern int			IsDistrFile			( char *szFile );

extern char 		*GetRealDestName	( char *szFileName );
extern int			GetRealSrcDisk 	( char *szFile, int iOldDisk );
extern char 		*GetRealDestPath	( char *szFile, char *szOldPath );
extern char 		*GetRealSrcName	( char *szFile );
extern int			FindDataMatch		( char *szString, int Type );
extern char 		*GetSearchStr		( int FileNum, int StrNum );

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\file_io.h ===
/***************************************************************************/
/*																									*/
/*	FILE_IO.H																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* Created 10-28-89 johnhe																	*/
/* Updated 06-09-92 royha	- Added file attributes 									*/
/***************************************************************************/


/* File attributes */

#ifndef SLASH
  #define SLASH(c)     ((c) == '/' || (c) == '\\')
#endif

#ifndef CHSEPSTR
  #define CHSEPSTR                "\\"
#endif

extern unsigned gbPathSearch;

extern int	FileExists		( char *szFile);
extern int	IsDirEmpty		( char *szPath);
extern int	BigReadWrite	( int iFile, char far *Buf, long lBytes, int RdWr);
extern int	RenameFCB		( char *szFrom, char *szTo);
extern int	ReplaceFile 	( char *szSource, char *szDestin);
extern int	AbsUnlink		( char *szFile );
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\format.h ===
/***************************************************************************/
/* 																								*/
/* FORMAT.H																						*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* Include file with definitions for FORMAT.C. and FMT_IO.C						*/
/*																									*/
/* Created 07-23-89 johnhe																	*/
/*																									*/
/***************************************************************************/


#define		OK					0
#define		FALSE				0
#define		TRUE				1

#define		ERR				-1


/***************************************************************************/
/*																									*/
/* Prototypes for functions in FORMAT.C												*/
/*																									*/
/***************************************************************************/

int  			FormatFloppy	( unsigned uDrive, int iFormat,
									  void (*vStatus)( unsigned int, unsigned ) );

static int	WriteSectors	( unsigned uStartSec, unsigned uNumSecs,
									  char *pchBuf );

static int	WriteFat			( void );
static int 	FmtTrack			( void );
static void	InitialFmtFlds	( void );
static void AllocFat			( void );

static int	MarkBadTrack	( void );


static int	GetSysSec		( void );
static int	SetDskParms		( void );


 /***************************************************************************/
/* Function prototypes for all functions in  FMT_IO.C								*/
/***************************************************************************/


extern  void DispInsertDisk(int DiskNum);
extern  void DispInsertUserDisk(int UserDisk,char chDrive);
extern  int PrepNewDsk(char *szLabel, char *szPrompt );
extern  int IsNewDisk(int iDrive);
extern  unsigned long ToLongTd(struct DIR *Dir);
extern  int FormatNewDsk(void );
extern  int GetDskFmtType( void );
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\opttest.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1990
;
;   Title:	OPTTEST.INC - Macros to optimize test instructions
;
;   Version:	1.00
;
;   Date:	28-Jun-1990
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   28-Jun-1990 RAL
;
;==============================================================================


TestMem MACRO MemPtr, M
IFE (M) AND 0FFFFFF00h
	test	BYTE PTR [MemPtr], M
ELSE
IFE (M) AND 0FFFF00FFh
	test	BYTE PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 0FF00FFFFh
	test	BYTE PTR [MemPtr+2], ((M) SHR 16)
ELSE
IFE (M) AND 000FFFFFFh
	test	BYTE PTR [MemPtr+3], ((M) SHR 24)
ELSE
IFE (M) AND 0FFFF0000h
	test	WORD PTR [MemPtr], M
ELSE
IFE (M) AND 0FF0000FFh
	test	WORD PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 00000FFFFh
	test	WORD PTR [MemPtr+2], ((M) SHR 16)
ELSE
	test	DWORD PTR [MemPtr], M
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM





TestReg MACRO R, Mask

_@TR MACRO Ltr
IFE (Mask) AND 0FFFFFF00h
	test	Ltr&&l, Mask
ELSE
IFE (Mask) AND 0FFFF00FFh
	test	Ltr&&h, ((Mask) SHR 8)
ELSE
IFE (Mask) AND 0FFFF0000h
	test	Ltr&&x, Mask
ELSE
	test	e&&Ltr&&x, Mask
ENDIF
ENDIF
ENDIF
	ENDM


IFIDNI <R>, <EAX>
	_@TR a, Mask
ELSE
IFIDNI <R>, <EBX>
	_@TR b, Mask
ELSE
IFIDNI <R>, <ECX>
	_@TR c, Mask
ELSE
IFIDNI <R>, <EDX>
	_@TR d, Mask
ELSE
IFIDNI <R>, <ESI>
IFE (Mask) AND 0FFFF0000h
	test	si, Mask
ELSE
	test	esi, Mask
ENDIF
ELSE
IFIDNI <R>, <EDI>
IFE (Mask) AND 0FFFF0000h
	test	di, Mask
ELSE
	test	edi, Mask
ENDIF
ELSE
%OUT ERROR:  Bad param to TestReg macro
.ERR
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM




SetFlag MACRO MemPtr, M
IFE (M) AND 0FFFFFF00h
	or	BYTE PTR [MemPtr], M
ELSE
IFE (M) AND 0FFFF00FFh
	or	BYTE PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 0FF00FFFFh
	or	BYTE PTR [MemPtr+2], ((M) SHR 16)
ELSE
IFE (M) AND 000FFFFFFh
	or	BYTE PTR [MemPtr+3], ((M) SHR 24)
ELSE
IFE (M) AND 0FFFF0000h
	or	WORD PTR [MemPtr], M
ELSE
IFE (M) AND 0FF0000FFh
	or	WORD PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 00000FFFFh
	or	WORD PTR [MemPtr+2], ((M) SHR 16)
ELSE
	or	DWORD PTR [MemPtr], M
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM



ClrFlag MACRO MemPtr, M
IFE (M) AND 0FFFFFF00h
	and	BYTE PTR [MemPtr], NOT (M)
ELSE
IFE (M) AND 0FFFF00FFh
	and	BYTE PTR [MemPtr+1], NOT ((M) SHR 8)
ELSE
IFE (M) AND 0FF00FFFFh
	and	BYTE PTR [MemPtr+2], NOT ((M) SHR 16)
ELSE
IFE (M) AND 000FFFFFFh
	and	BYTE PTR [MemPtr+3], NOT ((M) SHR 24)
ELSE
IFE (M) AND 0FFFF0000h
	and	WORD PTR [MemPtr], NOT (M)
ELSE
IFE (M) AND 0FF0000FFh
	and	WORD PTR [MemPtr+1], NOT ((M) SHR 8)
ELSE
IFE (M) AND 00000FFFFh
	and	WORD PTR [MemPtr+2], NOT ((M) SHR 16)
ELSE
	and	DWORD PTR [MemPtr], NOT (M)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\int13.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1990
;
;   Title:	INT13.INC - Services for Int13.386 virtual device
;
;   Version:	1.00
;
;   Date:	30-Sep-1990
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   30-Sep-1990 RAL
;
;==============================================================================


Begin_Service_Table Int13

Int13_Service	    Int13_Get_Version, LOCAL
Int13_Service	    Int13_Device_Registered, LOCAL
Int13_Service	    Int13_Translate_VM_Int, LOCAL
Int13_Service	    Int13_Hooking_BIOS_Int, LOCAL
Int13_Service	    Int13_Unhooking_BIOS_Int, LOCAL

End_Service_Table   Int13



;
;   Structure defines the fixed disk parameter tables used by the BIOS Int 13h.
;
Fixed_Disk_Parameter_Table STRUC
FDPT_Max_Cyl		dw	?
FDPT_Max_Heads		db	?
			dw	?
FDPT_Write_Precom_Cyl	dw	?
FDPT_Max_ECC_Burst	db	?
FDPT_Drive_Control	db	?
			db	3 dup (?)
FDPT_Landing_Zone_Cyl	dw	?
FDPT_Sec_Per_Track	db	?
			db	?
Fixed_Disk_Parameter_Table ENDS


;
;   Fixed Disk Drive Status Code Equates
;
I13Stat_Success 	EQU	00h
I13Stat_Bad_Command	EQU	01h
I13Stat_Mark_Not_Found	EQU	02h
I13Stat_Sec_Not_Found	EQU	04h
I13Stat_Reset_Failed	EQU	05h
I13Stat_Params_Failed	EQU	07h
I13Stat_64K_DMA_Error	EQU	09h
I13Stat_Bad_Block	EQU	0Ah
I13Stat_Fatal_ECC_Error EQU	10h
I13Stat_ECC_Corrected	EQU	11h
I13Stat_Ctrl_Failed	EQU	20h
I13Stat_Seek_Failed	EQU	40h
I13Stat_Drive_Failed	EQU	80h
I13Stat_Not_Ready	EQU	0AAh
I13Stat_Undefined_Error EQU	0BBh
I13Stat_Write_Fault	EQU	0CCh
I13Stat_Sense_Failed	EQU	0FFh
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\hdisk.h ===
/***************************************************************************/
/*																									*/
/*	HDISK.H																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* Definition for hard disk partition information. 								*/
/*																									*/
/***************************************************************************/

#define INVALID		0xFF
#define PRIMARY		0x00
#define EXTENDED		0x05
#define XENIX1 		0x02
#define XENIX2 		0x03
#define PCIX			0x75
#define DOS12			0x01
#define DOS16			0x04
#define DOSNEW 		0x06


/* OS/2 Boot Manager (BM) partition types */

#define BM_PART			0x0a
#define BM_FAT12_PART	0x11
#define BM_FAT16_PART	0x14
#define BM_BIGFAT_PART	0x16
#define BM_HPFS_PART		0x17
#define HPFS_PART			0x07

/* DR-DOS Password Protected (PP) partition types */

#define PP_FAT12_PART	0xC1
#define PP_FAT16_PART	0xC4
#define PP_BIGFAT_PART	0xC6
#define PP_EXT_PART		0xC5

#define FAT16_SIZE	32680
#define VOLUME 		0x00
#define LOGICAL		0x05

#define TABLE_OFFSET 		0x1be
#define BOOT_SIG_OFFSET		510
#define BOOT_SIG				0xaa55
#define ACTIVE					0x80
#define INACTIVE           0x00
#define NO_DOS_PART        (-1)
#define DOS_MAX				65535 	/* Allow exactly 32mb of partitions */

#define BYTES_PER_SECTOR	512
#define MAX_PART_ENTRIES	4
#define MAX_DIR_ENTRIES		0x200
#define HD_MEDIA_BYTE		0xf8
#define BPB_OFFSET			11

#define NO_DRIVE					-1
#define MAXIMUM_DRIVE_NUMBER	7
#define MAX_HARD_DRIVES 		8
#define FIRST_HARD_NUM			0x80

#define NO_VOLUME		""
#define NO_FORMAT		"UNKNOWN "
#define FAT_12			"FAT12   "
#define FAT_16			"FAT16   "
#define EXT_DISK_INFO 0x0F

#define VOL_LABEL 	0x08
#define DECIMAL		0x2E
#define PERIOD 		0x2E
#define ONE_MEG		1048576

#define	MAX_MAP_ENTRIES	9
#define	MAP_SIZE			(sizeof( struct PartMap ) * MAX_MAP_ENTRIES)
#define	BIG_MAP_SIZE	(MAP_SIZE *  MAX_HARD_DRIVES)
#define	HD_INFO_SIZE	(sizeof( struct HdInfo ) *  MAX_HARD_DRIVES)
#define	MIN_DOS_PART	(4000L)

/* Used to set unformatted media flag with SetHDAccess(). */
#define  ALLOW_HD_ACCESS   1
#define  DENY_HD_ACCESS    0

/***************************************************************************/
/* Hard disk partition record																*/
/***************************************************************************/

struct	Part
{
	unsigned char	BootIndicator; 	/* If 80h means this is boot partition */
	unsigned char	StartHead;			/* Partition starting head based 0		*/
	unsigned char	StartSector;		/* Partition starting sector based 1	*/
	unsigned char	StartCylinder; 	/* Partion starting track based 0		*/
	
	unsigned char	SystemIndicator;	/* Partition type signature field		*/
	unsigned char	EndHead; 			/* Partition ending head based 0 		*/
	unsigned char	EndSector;			/* Partition ending sector based 1		*/
	unsigned char	EndCylinder;		/* Partition ending track based 0		*/

	unsigned long	RelativeSector;	/* Physcial starting sector based 0 	*/
	unsigned long	TotalSectors;		/* Total physical sectors in partition	*/
};

/***************************************************************************/
/* Hard disk partition table																*/
/***************************************************************************/

struct   PartTable
{
	struct Part    PartEntry[MAX_PART_ENTRIES];
};

/***************************************************************************/
/* Hard disk physical layout structure. Information to fill in the struct	*/
/* can be found using int 13h function 8h.											*/
/***************************************************************************/

struct	HdParms
{
	unsigned 		MaxHead; 			/* Maximum head number based from 0 	*/
	unsigned 		MaxSec;				/* Maximum sector number based from 1	*/
	unsigned			MaxCyl;				/* Maximum track number based from 0	*/
};

/***************************************************************************/
/* Hard disk information structure. 													*/
/***************************************************************************/

struct	HdInfo
{
	int					DrvNum;									/* Phys drv #			*/
	struct HdParms 	Parms;									/* Dsk parameters 	*/
	struct Part 		PartEntry[ MAX_PART_ENTRIES ];	/* Partition table	*/
	unsigned 			DiskError	:1;
	unsigned				HasMbr		:1;						/* Flags valid mbr	*/
	unsigned 			HasDosPart	:1;						/* Flags if dos part */
	unsigned 			IsFmted		:1;						/* Flags if fmted 	*/
	unsigned				IsDos4		:1;						/* Dos 4 compatible	*/
	unsigned 			HasFree		:1;						/* Has free space 	*/
	unsigned 			HasBmPart	:1;						/* OS/2 Boot Manager Part. */
	unsigned 			HasBmDosPart:1;						/* Dos parts reserved by BM */
	unsigned 			HasHpfsPart	:1;						/* HPFS partition		*/
	unsigned 			HasPpDosPart:1;						/* Password Protected Part. */
};

/***************************************************************************/
/* Partition map entry structure for keeping information about a paritions */
/* physical position on the hard disk. 												*/
/***************************************************************************/

struct	PartMap

{
	unsigned 	PartType;				/* Partition type signature				*/
	UL				StartSec;				/* Partition physical starting sector	*/
	UL 			EndSec;					/* Partition physical last sector		*/
	UL 			TotalSecs;				/* Total physical sectors in partition */
};

/***************************************************************************/

struct diskaccess
{
	char			dac_special_func;
	char			dac_access_flag;
};

/***************************************************************************/


extern UINT IsDosPart		( unsigned char PartitionType );
extern UINT IsFmtedBoot		( char *SectorBuf );
extern UINT	IsDos4Compat	( char *SectorBuf );
extern UL 	GetTotalHdSectors( struct HdParms *Parms );

extern void CreateMapEntry	( struct PartMap *Map, struct Part *Part );
extern UL	BuildPartMap	( struct Part *Part, struct PartMap *Map,
									  struct HdParms *Parms );

extern int 	GetNumHardDisks( void );
extern int	GetDrvParms 	( struct HdParms *Parms, int DrvNum );
extern int	ReadPartBootRec( struct Part *Entry, void *SectorBuf,
									  int HardDrvNum );

extern int	WritePartBootRec( struct Part *Entry, void *SectorBuf,
									   int HardDrvNum );

extern int	FindMaxFreePart( struct PartMap *Map );
extern void BuildPartEntry	( struct PartMap *Map, struct HdParms *Parms,
									  struct Part *PartEntry );

extern int	HdIsFormatted	( char DriveLetter, struct diskaccess *Dac );



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\get.h ===
/***************************************************************************/
/*                                                                         */
/*	GET.H																							*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Definitions and function prototypes for field entry functions.          */
/*                                                                         */
/* Created 880305 - johnhe                                                 */
/***************************************************************************/

#define     MAX_INT_VALUE     32000
#define     MAX_DECIMALS      6
#define     INT_LENGTH        6
#define     DATE_LENGTH       8
#define     TIME_LENGTH       5

/***************************************************************************/
/* Enumerated definitions for data types												*/
/***************************************************************************/

enum TYPE_TAG { NO_TYPE, TYPE_CHAR, TYPE_STRING, TYPE_INT, TYPE_TIME,
                TYPE_DATE, TYPE_FLOAT, TYPE_FIELD };

#define			MAX_TYPE			TYPE_FLOAT

/***************************************************************************/
/* Bit aligned structure to hold the date. May be read as an unsigned int. */
/* UnsignedValue = (unsigned *)(*(&Date));                                 */
/***************************************************************************/

struct	Date
{
	unsigned int		Day	:	5;
	unsigned int		Month :	4;
	unsigned int		Year	:	7;
};

/***************************************************************************/
/* Structure to hold the value being passed to and returned from the field */
/* editing functions.                                                      */
/***************************************************************************/

union	TYPES
{
	char						Char;                /* Single character */
	char						*String;             /* Pointer to a string */
	int						Int;                 /* Single integer value */
	struct Date          Date;                /* Date structure */
	unsigned					Time; 					/* Hours * 100 + Minutes */
   double               Float;               /* Single double value */
};	

/***************************************************************************/
/* Entry field definition function which must be passed to the field       */
/* editing functions.                                                      */
/***************************************************************************/

struct	field
{
	int				Type;             /* Data type from enumerated TYPE_TAG */
	int				Row;              /* Row on the display */
	int				Col;              /* Col for first character in the field */
   int            Length;           /* Length of field on screen */
	union TYPES		Data;             /* Data to initialize the field with */
   union TYPES    Min;              /* Minimum returnable value */
   union TYPES    Max;              /* Maximum returnable value */
};


/***************************************************************************/

   /*  GETFIELD.C */
int   GetField(struct field *field_info);
int	ProcessCtr(void );
int	ProcessExtended(void );
void  ScrUpdate(void );
void  SaveChar(void );
void  BackSpace(void );
void  ClrField(void );
void  InsChar(char *s,int c);
void  DeleteChar(void );
void  CursToEol(void );
void  InitString(void );
int	StringToString( char *szString, char *szReturnStr, int Min, int Max );
int	InitializeString(char *Str, union TYPES Data, int Length);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\install.h ===
/***************************************************************************
 *
 * INSTALL.H																						
 *
 *		Copyright (c) 1991 - Microsoft Corp.											
 *		All rights reserved.																	
 *		Microsoft Confidential																
 *
 * Installation status structure
 *
 * History:	M200: Created.
 *
 ***************************************************************************/

/* XLATOFF */					/* M200: Disable translation by H2INC */

/***************************************************************************/

#pragma pack(1)				/* Pack all structures */

/***************************************************************************/

/* XLATON */					/* M200: Enable translation by H2INC */

/***************************************************************************/

/* Global structure for storing installation information. A copy of this
 * structure is stored in resident data, so that it can be passed from DOS
 * Setup to Win Setup.
 */

#define SIG_LEN 12


/* This string length constant has been made large enough to account for
 * drive letter, directory name, file name, terminating null, plus some pad
 * on both FAT and Installable File Systems (IFS), which may implement
 * long file names.
 */
#define MAXSTRLEN  260
#define MAXLINELEN  80

typedef struct _BDONE { /* done */		/* Progress Bit Flags */
	unsigned		fResData	:1;				/* TRUE if Install data is resident */
	unsigned		fSrcPath	:1;				/* TRUE if Source path set */
	unsigned		fNet		:1;				/* TRUE if Network detection done */
	unsigned		fBackup	:1;				/* TRUE if HDBKUP done */
	unsigned		fDosPath	:1;				/* TRUE if Dos path set */
	unsigned		fWinInf	:1;				/* TRUE if Win SETUP.INF filespec set */
	unsigned		fDisplay	:1;				/* TRUE if Display set */
	unsigned		fDosSetup:1;				/* TRUE if MS-DOS install complete */
	unsigned		fWinSetup:1;				/* TRUE if Win Setup done (may have failed). */
} BDONE;

typedef struct _BFLAGS { /* flag */		/* General purpose Bit Flags */
	unsigned		fAdmin   		:1;		/* TRUE if is Administrative Setup */
	unsigned		fDosFirst		:1;		/* TRUE if must do Dos Setup before Win Setup. */
	unsigned		fUninstall		:1;		/* TRUE if must do Uninstall procedure */
	unsigned		fINT2FChained	:1;		/* TRUE if must leave INT 2F hook around. */
	unsigned		fINT2FOrphan	:1;		/* TRUE if we are INT 2F orphan (chain only) */
	unsigned		fMaintenance	:1;		/* TRUE if in Maintenance Mode */
} BFLAGS;


typedef struct _INSTALL { /* inst */
	unsigned char	Software;				 	 	/* Software to install:
											 		 	  	 * DOS-WIN, DOS-ONLY, WIN-ONLY
											 		  	  	 */
#ifndef RECOVERY_PROGRAM
	char				szSignature[SIG_LEN]; 	 	/* Identifying signature */
	unsigned char	Method;					 	 	/* Method of install: Express,Custom */
   unsigned int   wHwndWinSetup;             /* WinSetup windows handle to which dossetup */
                                             /* posts it's "finished" message */
	char				szCmdLine[MAXSTRLEN]; 		/* Original Setup command line */
	char				szWinCmdLine[MAXSTRLEN]; 	/* Win Setup command line */
	char				szWinInf[MAXSTRLEN]; 	 	/* Location of Win SETUP.INF */
	char				szCountryCode[MAXLINELEN];	/* Windows country code */
	char				szCountryLang[MAXLINELEN];	/* Windows country language */
	char				szKeyLayout[MAXLINELEN]; 	/* User specified Keyboard Layout */
	char				szLanguage[MAXLINELEN];	 	/* User specified language */
	BDONE				Done;							 	/* Progress flags */
	BFLAGS			Flags;						 	/* Status flags */
#endif
} INSTALL;


/* Multiplex Interrupt */

#define INT2F					0x2F			/* DOS multiplex interrupt */

#define INT2F_INSTALL_FMT	0x4900		/* Int 2Fh, function 4900h dedicated
													 * for Setup format operation.
													 * (See OEM\AUTOFMT.C)
													 */

#define INT2F_INSTALL_DATA	0x4910		/* Int 2Fh, function 4910h dedicated
													 * for Setup data transfer.
													 * (See COMMON\RESIDENT.ASM)
													 */

/*  WM_USER = 0x400 from windows.h This is the private message that is posted
 *  from Dossetup to Winsetup so that dossetup can communicate the fact that
 *  he's completed.
 */

#define UM_CHILD_TERMINATED 0x0400 + 1

/***************************************************************************/

/* XLATOFF */					/* M200: Disable translation by H2INC */

/***************************************************************************/

extern INSTALL Install;

/* Install.Signature */

#define SIGNATURE "$DOSWIN$"

/* Install.Software values */

enum software { SOFTWARE_DOSWIN, SOFTWARE_WINONLY, SOFTWARE_DOSONLY };

/* Install.Method values */

enum method { METHOD_EXPRESS, METHOD_CUSTOM, METHOD_BATCH };


/* WINGROUP.C */

#define MAX_PROGMAN_INI_LINE_LEN       MAX_PATH_LEN + 10
#define MAX_SYSTEM_INI_LINE_LEN        MAX_PATH_LEN + 30
#define MAX_PROGRAM_MANAGER_GROUPS     40
#define MAX_INF_LINE_LEN               150  /* Max length of any .inf line */


extern char *gszGroup;
extern char *gszGroupsSection;
extern char *gszGroupTemplate;
extern char *gszSystemIni;
extern char *gszSystemTmp;
extern char *gszSystemBak;
extern char *gszProgmanIni;
extern char *gszProgmanTmp;
extern char *gszProgmanBak;
extern char *gszWinfileIni;
extern char *gszWinfileTmp;
extern char *gszWinfileBak;
extern char *gszWinCom;

int DeleteFile (char *szPathname);
void mycatpath (char *path, char *sz);
void myfnTruncFN (char *szPathStr);
int myfnSearchForOldWin3 (char *szWinPath, char *szFile1, char *szFile2,
                          char *szFile3);
int SetWinPath (void);
int MyFindSection (char *szSection, int iFileIn, int iFileOut);
void DosUnreadLine (char *szBuffer);
int DosReadLine (char *szBuffer, int iLength, int iFile);
int DosWriteLine (char *szBuffer, int iFile);


/* resident.asm */

extern void far ResExec 			(char *szFile, char *szCmdLine);
extern void far InitNewInt2Fh		(void);
extern void far RestoreOldInt2Fh	(void);

/* Declarations for obtaining pointer to resident data */

extern char far * DosInstallData( void );
extern INSTALL far *lpInstall;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\int2fapi.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	INT2FAPI.INC - Windows/386 V86 Application Program Interface
;
;   Version:	3.00
;
;   Date:	10-Mar-1989
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   10-Mar-1989 RAL Original for 3.0
;   07-Apr-1989 RAL Added device broadcast equate
;
;==============================================================================
;
;   For inforamtion on these APIs please refer to the Windows/386 DDK
;   appendix on the Int 2Fh Application Program Interface.
;
;------------------------------------------------------------------------------

;
;   Interrupt 2Fh is used for Windows/386 API calls.
;
W386_API_Int		EQU	2Fh

;
;   All Windows/386 API Int 2Fh calls must be issued with AH = 16h
;
W386_Int_Multiplex	EQU	16h

;
;   Values for AL for all Windows/386 API calls
;
W386_Get_Version	EQU	00h		; Install check/Get version
W386_Old_Get_VMID_API	EQU	02h		; Version 2.xx get VMID API call
W386_Startup		EQU	05h		; Broadcast when Win386 starting
W386_Exit		EQU	06h		; Broadcast when Win386 exited
W386_Device_Broadcast	EQU	07h		; Broadcast by virtual device
W386_Startup_Complete	EQU	08h		; Broadcast when Win386 start is complete
W386_Begin_Exit 	EQU	09h		; Broadcast when Win386 is starting
						;   a NORMAL exit sequence
W386_Windows_ID 	EQU	0Ah		; Identify windows ver/type
W386_TSR_Identify	EQU	0Bh		; Identify TSRs
W386_ROM_Detect 	EQU	0Ch		; Used by ROM win to detect ROMs

W386_Release_Time	EQU	80h		; Release cur VM's time-slice
W386_Begin_Critical	EQU	81h		; Begin critical section
W386_End_Critical	EQU	82h		; End critical section
W386_Get_Cur_VMID	EQU	83h		; Returns BX = ID of current VM
W386_Get_Device_API	EQU	84h		; Returns ES:DI -> Device API
W386_Switch_And_Call	EQU	85h		; Change VMs and call-back
W386_Test_Int31_Avail	EQU	86h		; Returns AX=0 if Int 31 avail
W386_Get_PM_Switch_Addr EQU	87h		; Get call-back addr for PM
W386_Get_LDT_Base_Sel	EQU	88h		; Get selector to LDT
W386_Win_Kernel_Idle	EQU	89h		; Windows kernel idle call
W386_DPMI_Extension	EQU	8Ah		; DPMI extension Int 2Fh
W386_Set_Focus		EQU	8Bh		; Set focus to specified VM
W386_Restart_Cmd	EQU	8Ch		; Win.Com execs specified app

;
;   Structure for real mode device initialization API.
;
Win386_Startup_Info_Struc STRUC
SIS_Version		db	3, 0		; Structure version
SIS_Next_Ptr		dd	?		; Seg:Off of next dev in list
SIS_Virt_Dev_File_Ptr	dd	0		; Ptr to ASCIZ file name to load
SIS_Reference_Data	dd	?		; Data to be passed to device
SIS_Instance_Data_Ptr	dd	0		; Ptr to instance data list
Win386_Startup_Info_Struc ENDS

;
;   Structure for instance data list.  (List terminated with 0 dword).
;
Instance_Item_Struc STRUC
IIS_Ptr 		dd	?		; Seg:Off of instance item
IIS_Size		dw	?		; Size of instance item in bytes
Instance_Item_Struc ENDS

;
;   Flags passed to the Win_Kernel_Idle call to indicate state of Windows
;   in the BX register.
;
Win_Idle_Mouse_Busy	EQU	00000001b
Win_Idle_Mouse_Busy_Bit EQU	0

;
; Structure for TSR <-> Windows communication
; (W386_TSR_Identify call, AL=0Bh)
;
TSR_Info_Struc	STRUC
    TSR_Next		    dd	?
    TSR_PSP_Segment	    dw	?
    TSR_API_Ver_ID	    dw	100h
    TSR_Exec_Flags	    dw	0
    TSR_Exec_Cmd_Show	    dw	0
    TSR_Exec_Cmd	    dd	0
    TSR_Reserved	    db	4 dup (0)
    TSR_ID_Block	    dd	0
    TSR_Data_Block	    dd	0
TSR_Info_Struc ENDS

;
; TSR_Exec_Flags equates
;
TSR_WINEXEC	EQU	1
TSR_LOADLIBRARY EQU	2
TSR_OPENDRIVER	EQU	4
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\strlib.h ===
/***************************************************************************/
/* 																								*/
/* STRLIB.H																						*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* Function prototypes and structure definitions for used by callers of 	*/
/* functions in STRLIB.C.																	*/
/* 																								*/
/* Created 03-23-89 - johnhe																*/
/* TABS = 3																						*/
/***************************************************************************/


#ifndef	EOL
	#define		EOL	'\0'
#endif

#ifndef	CTRL_C
	   /* Key codes */

	#define  CTRL_C   03
	#define	BEL      7
	#define	BS       8
	#define	CR       '\r'
	#define	CTRL_X   24
	#define  CTRL_R   18
	#define	TAB		9
	#define	SPC		32
	#define	QST		'?'
	#define	PERCENT	'%'
	#define	BLK		''
	#define	LF			'\n'

	#define	CHAR_0	'0'
	#define	COLON		':'

	#define  ESC      0x1b
	#define  LEFT     0x4b
	#define  RIGHT    0x4d
	#define  UP       0x48
	#define  DOWN     0x50
	#define  PAGE_UP  0x49
	#define  PAGE_DN  0x51
	#define  END      0x4f
	#define  HOME     0x47
	#define  INS      0x52
	#define  DEL      0x53
	#define  CENTER   0x4c

	#define	LCASE_A	'a'
	#define	LCASE_B	'b'
	#define	LCASE_C	'c'
	#define	LCASE_D	'd'
	#define	LCASE_E	'e'
	#define	LCASE_F	'f'
	#define	LCASE_G	'g'
	#define	LCASE_H	'h'
	#define	LCASE_I	'i'
	#define	LCASE_J	'j'
	#define	LCASE_K	'k'
	#define	LCASE_L	'l'
	#define	LCASE_M	'm'
	#define	LCASE_N	'n'
	#define	LCASE_O	'o'
	#define	LCASE_P	'p'
	#define	LCASE_Q	'q'
	#define	LCASE_R	'r'
	#define	LCASE_S	's'
	#define	LCASE_T	't'
	#define	LCASE_U	'u'
	#define	LCASE_V	'v'
	#define	LCASE_W	'w'
	#define	LCASE_X	'x'
	#define	LCASE_Y	'y'
	#define	LCASE_Z	'z'

	#define	UCASE_A	'A'
	#define	UCASE_B	'B'
	#define	UCASE_C	'C'
	#define	UCASE_D	'D'
	#define	UCASE_E	'E'
	#define	UCASE_F	'F'
	#define	UCASE_G	'G'
	#define	UCASE_H	'H'
	#define	UCASE_I	'I'
	#define	UCASE_J	'J'
	#define	UCASE_K	'K'
	#define	UCASE_L	'L'
	#define	UCASE_M	'M'
	#define	UCASE_N	'N'
	#define	UCASE_O	'O'
	#define	UCASE_P	'P'
	#define	UCASE_Q	'Q'
	#define	UCASE_R	'R'
	#define	UCASE_S	'S'
	#define	UCASE_T	'T'
	#define	UCASE_U	'U'
	#define	UCASE_V	'V'
	#define	UCASE_W	'W'
	#define	UCASE_X	'X'
	#define	UCASE_Y	'Y'
	#define	UCASE_Z	'Z'

	#define  F1       0x3b
	#define  F2       0x3c
	#define  F3       0x3d
	#define  F4       0x3e
	#define  F5       0x3f
	#define  F6       0x40
	#define  F7       0x41
	#define  F8       0x42
	#define  F9       0x43
	#define  F10      0x44

#endif

/***************************************************************************/

extern void		BuildPath			( char *szPath, char chDrive, char *szDir,
											  char *szName );
extern long 	GetMaxHugeSize 	( void );
extern int		GetNumberStrings	( char **Strings );
extern unsigned InsertChar			( char *String, int Char );
extern unsigned MaxStrLen			( char **Strings );
extern void		PadStr				( char *szStr, char chChar, int Len );
extern char		*ParseFileName		( char *szPath );
extern unsigned RemoveSpaces		( char *szString );
extern unsigned RemoveTrailing	( char *String, char Char );
extern void		ReplaceChar			( char *szStr, char chChar, char chNewChar );
extern unsigned ShiftStringLeft	( char *String );
extern int		StrSearch			( char *szSearchStr, char **szStrs );
extern void		UnGetChar			( int Char );
extern int		IndexMaxInt 		( int aiMatch[], int iLen );
extern int		IsValidPathChar	( char Char	);
extern int		FindExtMatch		( char *szFile, char **szExt );
extern unsigned ExtractNextWord	( char *szStr, char *szBuffer, int iMax );
extern char 	*SkipLeadingWhite ( char *szPtr );
extern char 	*SkipNonWhite		( char *szPtr );
extern char 	*SkipWord			( char *szPtr );
extern int		IsWhite				( char ch );
extern int		FindParam			( char *szStr, char ch );

extern void		GetPathStrings		( char **apszPaths, char *chBuffer,
											  int BufSize );

extern void		DirToFileName		( char *Str, char *Dir );
extern int		FindString			( char far *Buffer, char far *String,
											  unsigned BufferSize );

extern char far *NormalizePtr		( char far *Ptr );
extern char	far *HugeAdd			( char far *Ptr, long lBytes );


#ifdef DBCS
extern int	IsDBCSLeadByte(unsigned char);
extern int	CheckDBCSTailByte(unsigned char *,unsigned char *);
extern unsigned char	*DBCSstrupr(unsigned char *str);
extern unsigned char	*DBCSstrchr(unsigned char *str,unsigned char c);
#endif



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\wdlocal.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1990
;
;   Title:	WDLOCAL.INC -- Equates and structures for WDCTRL.386
;
;   Version:	1.00
;
;   Date:	27-Sep-1990
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   27-Sep-1990 RAL
;
;==============================================================================


;
;   Private data structure for Block Device Descriptor
;

WDCtrl_Private_BDD	STRUC
			db	SIZE BlockDev_Device_Descriptor dup (?)
BDP_Base_IO_Port	dw	?
BDP_Status_Port 	dw	?
BDP_Write_Precom	db	?
BDP_Drive_Control	db	?
WDCtrl_Private_BDD	ENDS



;******************************************************************************
;			       E Q U A T E S
;******************************************************************************

WDIO_Def_Base_Port	EQU	1F0h


WDIO_Data_Off		EQU	0
WDIO_Error_Off		EQU	1
WDIO_Precomp_Off	EQU	1
WDIO_Sector_Cnt_Off	EQU	2
WDIO_Sector_Num_Off	EQU	3
WDIO_Cly_Low_Off	EQU	4
WDIO_Cly_High_Off	EQU	5
WDIO_Drive_Sel_Off	EQU	6
WDIO_Status_Off 	EQU	7
WDIO_Command_Off	EQU	7
WDIO_Alt_Stat_Off	EQU	3F6h-WDIO_Def_Base_Port
WDIO_Drive_Control_Off	EQU	3F6h-WDIO_Def_Base_Port
WDIO_Drive_Address_Off	EQU	3F7h-WDIO_Def_Base_Port


WDStat_Error		EQU	00000001b
WDStat_Index		EQU	00000010b
WDStat_ECC_Corrected	EQU	00000100b
WDStat_DRQ		EQU	00001000b
WDStat_Seek_Complete	EQU	00010000b
WDStat_Write_Fault	EQU	00100000b
WDStat_Ready		EQU	01000000b
WDStat_Busy		EQU	10000000b



;
;   Largest legal sector count for one transfer
;
WD_Max_Sector_Xfer	EQU	7Fh



;
;   Version numbers
;
WD_Major_Ver		EQU	03h
WD_Minor_Ver		EQU	0Ah



;
;   Reference data flags
;
RF_Drive_80h_Ours	EQU	00000001b
RF_Drive_80h_Ours_Bit	EQU	0
RF_Drive_81h_Ours	EQU	00000010b
RF_Drive_81h_Ours_Bit	EQU	1
RF_Use_Alt_Stat_80	EQU	00000100b
RF_Use_Alt_Stat_80_Bit	EQU	2
RF_Use_Alt_Stat_81	EQU	00001000b
RF_Use_Alt_Stat_81_Bit	EQU	3


;
;   Time-out values (in Ms)
;
WD_Write_Ready_Timeout	EQU	500
WD_Busy_Timeout 	EQU	500


;
;   Fatal controller error numbers
;
FATAL_TIME_OUT          EQU     1
FATAL_BAD_STATUS        EQU     2
FATAL_DATA_BAD_COMPARE  EQU     3


;
;   Maximum number of retries for an operation before it is failed
;
WD_Max_Retries		EQU	3
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\include\vmm.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	VMM.INC - Include file for Virtual Machine Manager
;
;   Version:	1.00
;
;   Date:	05-May-1988
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   05-May-1988 RAL Original
;
;==============================================================================


; NON Windows/386 Virtual Device sources can include this file to get some
; useful equates by declaring the symbol "Not_VxD"  If this symbol is defined,
; then everything that has to do with the specifics of the 32 bit environment
; for virtual devices is removed.  Useful equates include:  device ID's, pushad
; structure, BeginDoc/EndDoc/BeginMsg/EndMsg equates, page table equates, etc.



False	EQU	0
True	EQU	NOT False

;
;   These null macros are recognized by a utility program that produces
;   documentation files.
;
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>


BeginDoc
;******************************************************************************
;
;			EQUATES FOR REQUIRED DEVICES
;
;   Device ID formulation note:
;
;	Device ID's are a combination of OEM # and device # in the form:
;
;		xOOOOOOOOOODDDDD
;
;	The high bit of the device ID is reserved for future use.  The next
;	10 bits are the OEM # which is assigned by Microsoft.  The last 5 bits
;	are the device #.  This allows each OEM to create 32 unique devices.
;	If an OEM is creating a replacement for a standard device, then it
;	should re-use the standard ID listed below.  Microsoft reserves the
;	first 16 OEM #'s (0 thru 0Fh)
;
;==============================================================================

Undefined_Device_ID		EQU	00000h
VMM_Device_ID			EQU	00001h	; Used for dynalink table
Debug_Device_ID 		EQU	00002h
VPICD_Device_ID 		EQU	00003h
VDMAD_Device_ID 		EQU	00004h
VTD_Device_ID			EQU	00005h
V86MMGR_Device_ID		EQU	00006h
PageSwap_Device_ID		EQU	00007h
Parity_Device_ID		EQU	00008h
Reboot_Device_ID		EQU	00009h
VDD_Device_ID			EQU	0000Ah
VSD_Device_ID			EQU	0000Bh
VMD_Device_ID			EQU	0000Ch
VKD_Device_ID			EQU	0000Dh
VCD_Device_ID			EQU	0000Eh
VPD_Device_ID			EQU	0000Fh
BlockDev_Device_ID		EQU	00010h
VMCPD_Device_ID 		EQU	00011h
EBIOS_Device_ID 		EQU	00012h
BIOSXlat_Device_ID		EQU	00013h
VNETBIOS_Device_ID		EQU	00014h
DOSMGR_Device_ID		EQU	00015h
WINLOAD_Device_ID		EQU	00016h
SHELL_Device_ID 		EQU	00017h
VMPoll_Device_ID		EQU	00018h
VPROD_Device_ID 		EQU	00019h
DOSNET_Device_ID		EQU	0001Ah
VFD_Device_ID			EQU	0001Bh
VDD2_Device_ID			EQU	0001Ch	; Secondary display adapter
WINDEBUG_Device_ID		EQU	0001Dh
TSRLoad_Device_ID		EQU	0001Eh	; TSR instance utility ID
BiosHook_Device_ID		EQU	0001Fh	; Bios interrupt hooker VxD
Int13_Device_ID 		EQU	00020h
PageFile_Device_ID		EQU	00021h	; Paging File device
SCSI_Device_ID			EQU     00022h  ; SCSI device
MCA_POS_Device_ID		EQU     00023h  ; MCA_POS device
SCSIFD_Device_ID		EQU	00024h	; SCSI FastDisk device
VPEND_Device_ID 		EQU	00025h	; Pen device
APM_Device_ID			EQU	00026h	; Power Management device

;
;   Initialization order equates.  Devices are initialized in order from
;   LOWEST to HIGHEST.	If 2 or more devices have the same initialization
;   order value, then they are initialized in order of occurance, so a
;   specific order is not guaranteed.  Holes have been left to allow maximum
;   flexibility in ordering devices.
;

VMM_Init_Order			EQU	000000000h
APM_Init_Order			EQU	001000000h
Debug_Init_Order		EQU	004000000h
BiosHook_Init_Order		EQU	006000000h
VPROD_Init_Order		EQU	008000000h
VPICD_Init_Order		EQU	00C000000h
VTD_Init_Order			EQU	014000000h
PageFile_Init_Order		EQU	018000000h
PageSwap_Init_Order		EQU	01C000000h
Parity_Init_Order		EQU	020000000h
Reboot_Init_Order		EQU	024000000h
EBIOS_Init_Order		EQU	026000000h
VDD_Init_Order			EQU	028000000h
VSD_Init_Order			EQU	02C000000h
VCD_Init_Order			EQU	030000000h
VMD_Init_Order			EQU	034000000h
VKD_Init_Order			EQU	038000000h
VPD_Init_Order			EQU	03C000000h
BlockDev_Init_Order		EQU	040000000h
MCA_POS_Init_Order		EQU	041000000h
SCSIFD_Init_Order		EQU	041400000h
SCSIMaster_Init_Order	        EQU     041800000h
Int13_Init_Order		EQU	042000000h
VFD_Init_Order			EQU	044000000h
VMCPD_Init_Order		EQU	048000000h
BIOSXlat_Init_Order		EQU	050000000h
VNETBIOS_Init_Order		EQU	054000000h
DOSMGR_Init_Order		EQU	058000000h
DOSNET_Init_Order		EQU	05C000000h
WINLOAD_Init_Order		EQU	060000000h
VMPoll_Init_Order		EQU	064000000h

Undefined_Init_Order		EQU	080000000h

WINDEBUG_Init_Order		EQU	081000000h
VDMAD_Init_Order		EQU	090000000h
V86MMGR_Init_Order		EQU	0A0000000h

Undef_Touch_Mem_Init_Order	EQU	0A8000000h  ; Device that must touch
						    ; memory in 1st Mb at
						    ; crit init (after V86mmgr)
SHELL_Init_Order		EQU	0B0000000h
EndDoc

;******************************************************************************
;
;   Macro to cause a delay in between I/O accesses to the same device.
;
;------------------------------------------------------------------------------

IO_Delay    macro
jmp $+2
ENDM

Pushad_Struc	STRUC
Pushad_EDI	dd	?		; Client's EDI
Pushad_ESI	dd	?		; Client's ESI
Pushad_EBP	dd	?		; Client's EBP
Pushad_ESP	dd	?		; ESP at pushall
Pushad_EBX	dd	?		; Client's EBX
Pushad_EDX	dd	?		; Client's EDX
Pushad_ECX	dd	?		; Client's ECX
Pushad_EAX	dd	?		; Client's EAX
Pushad_Struc	ENDS



IFNDEF Not_VxD

??_CUR_CODE_SEG = 0


??_CODE  = 1
??_ICODE = 2
??_LCODE = 3
??_RCODE = 4

?_CODE	equ <(??_CUR_CODE_SEG MOD 8) - ??_CODE>
?_ICODE equ <(??_CUR_CODE_SEG MOD 8) - ??_ICODE>
?_LCODE equ <(??_CUR_CODE_SEG MOD 8) - ??_LCODE>
?_RCODE equ <(??_CUR_CODE_SEG MOD 8) - ??_RCODE>

;
;  SEGMENT definitions and order
;

;*	32 Bit locked code
_LTEXT		SEGMENT DWORD USE32 PUBLIC 'CODE'
_LTEXT		ENDS

;*	32 Bit code
_TEXT		SEGMENT DWORD USE32 PUBLIC 'PCODE'
_TEXT		ENDS

;*	32 Bit initialization code
_ITEXT		SEGMENT DWORD USE32 PUBLIC 'ICODE'
_ITEXT		ENDS

;*	Contains 32 Bit locked data
_LDATA		SEGMENT DWORD PUBLIC 'CODE'
_LDATA		ENDS

;*	Contains 32 Bit data
_DATA		SEGMENT DWORD PUBLIC 'PCODE'
_DATA		ENDS

;*	Contains 32 Bit initialization data
_IDATA		SEGMENT DWORD PUBLIC 'ICODE'
_IDATA		ENDS

;*	Real Mode initialization code/data for devices
_RCODE		SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE		ENDS


_LGROUP GROUP _LTEXT, _LDATA
_PGROUP GROUP _TEXT, _DATA
_IGROUP GROUP _ITEXT, _IDATA

	ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT


OFFSET32 EQU <OFFSET FLAT:>


BeginDoc
;==============================================================================
; The following macros are used in defining the routines
;   in a VxD which are going to be registered with VMM as callable entry
;   points. Once registered, the entry points can be called by any other
;   devices via the "VxDCall" macro, defined below. In the comments below,
;   replace "VxD" with the appropriate device name.
;
;*******
;   In the VxD.INC file, put the following lines, replacing <function_name>
;	with an appropriate name describing the function of the routine.
;
;	Begin_Service_Table VxD[,<segname>]
;	VxD_Service <function_name>[,<local segname>]
;	VxD_Service <function_name>[,<local segname>]
;		. . .
;	VxD_Service <function_name>[,<local segname>]
;	End_Service_Table   VxD[,<segname>]
;
;   Note that <segname> is an optional argument and, if specified, the
;	table is put in the segment defined by the macro "yyy_Data_Seg",
;	where yyy=segname. Otherwise the segment is defined by the
;	"VxD_Data_Seg" macro, defined below.
;   Note that <local segname> is an optional argument and, if specified,
;	the procedure's segment is defined by the macro "zzz_Code_Seg",
;	where zzz=segname. Otherwise the segment is defined by the
;	"VxD_Code_Seg" macro, defined below.
;
;*******
; One VxD module should have the following in order to define the entry points:
;Create_VxD_Service_Table = 1			; Only in module where table is
;	INCLUDE     VxD.INC			; Include the table definition
;
;*******
; All modules that want to call the services defined in the table should include
;   VxD.INC, but not define the label "Create_VxD_Service_Table". This
;   will define the service names to be used with the VxDCall macro.
;
EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment
IFB <Def_Segment>
	BST2 Device_Name, VxD
ELSE
	BST2 Device_Name, Def_Segment
ENDIF
	ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table
Def_Segment&_LOCKED_DATA_SEG
Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition
LOCAL $$&&Procedure
  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
	EXTRN	@&&Procedure:NEAR
      ELSE
	dd	OFFSET32 @&&Procedure
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    PUBLIC $&&Procedure
    IF1
    $&&Procedure LABEL DWORD
    ENDIF
    IFDIFI <Local_Seg>, <LOCAL>
	IFNB <Local_Seg>
Local_Seg&&_SEG
	ELSE
Def_Segment&_CODE_SEG
	ENDIF
	IFNB <Condition>
	$$&&Procedure extern
	ELSE
	EXTRN	@&&Procedure:NEAR
	ENDIF
	IFNB <Local_Seg>
Local_Seg&&_ENDS
	ELSE
Def_Segment&_CODE_ENDS
	ENDIF
    ENDIF
	IFNB <Condition>
	$$&&Procedure
	ELSE
	dd	OFFSET32 @&&Procedure
	ENDIF
	Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ELSE
	dd  0
  ENDIF
	Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
	ENDM

ELSE

Device_Name&_Service MACRO Procedure
  IFDIFI <Procedure>, <RESERVED>
	Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
	Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
	ENDM

ENDIF
	ENDM

;------------------------------------------------------------------------------

End_Service_Table MACRO Device_Name, Def_Segment

	PURGE	Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table
IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF
ENDIF

	ENDM


;******************************************************************************
;
;   Dword_Align -- Aligns code to dword boundry by inserting nops
;
;------------------------------------------------------------------------------

Dword_Align MACRO Seg_Name
	LOCAL segn
IFNB <Seg_Name>
	segn equ Seg_Name
ELSE
IFE ?_CODE
	segn equ <_TEXT>
ELSE
IFE ?_ICODE
	segn equ <_ITEXT>
ELSE
IFE ?_LCODE
	segn equ <_LTEXT>
ELSE
.err Dword_Align not supported
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
	    ENDM


BeginDoc
;******************************************************************************
;
;   Fatal_Error
;
;   DESCRIPTION:
;	This macro is used to crash Windows/386 when an unrecoverable error
;	is detected.  If Msg_Ptr is ommitted then no error message will be
;	displayed, otherwise Msg_Ptr is the address
;	when the
;
;   PARAMETERS:
;	Msg_Ptr (OPTIONAL) - Points to an ASCIIZ string to display.
;
;   EXIT:
;	To DOS (hopefully).  This macro never returns.
;
;==============================================================================
EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
	pushad
IFB <Msg_Ptr>
	xor	esi, esi
ELSE
	mov	esi, Msg_Ptr
IFB <Exit_Flags>
	xor	eax, eax
ELSE
	mov	eax, Exit_Flags
ENDIF
ENDIF
	VMMcall Fatal_Error_Handler
	ENDM

EF_Hang_On_Exit     EQU     1h


;******************************************************************************
;==============================================================================
;------------------------------------------------------------------------------

BeginDoc
;******************************************************************************
;   The following are control block offsets of items that can be of interest
;	to VxDs.
;*******
; VM status indicates globally interesting VM states
CB_VM_Status		EQU	DWORD PTR 00h

VMStat_Exclusive	EQU	000000000000000000001b	; VM is exclusive mode
VMStat_Exclusive_Bit	EQU	0
VMStat_Background	EQU	000000000000000000010b	; VM runs in background
VMStat_Background_Bit	EQU	1
VMStat_Creating 	EQU	000000000000000000100b	; In process of creating
VMStat_Creating_Bit	EQU	2
VMStat_Suspended	EQU	000000000000000001000b	; VM not scheduled
VMStat_Suspended_Bit	EQU	3
VMStat_Not_Executeable	EQU	000000000000000010000b	; VM partially destroyed
VMStat_Not_Executeable_Bit  EQU 4
VMStat_PM_Exec		EQU	000000000000000100000b	; Currently in PM app
VMStat_PM_Exec_Bit	EQU	5
VMStat_PM_App		EQU	000000000000001000000b	; PM app present in VM
VMStat_PM_App_Bit	EQU	6
VMStat_PM_Use32 	EQU	000000000000010000000b	; PM app is 32-bit
VMStat_PM_Use32_Bit	EQU	7
VMStat_VxD_Exec 	EQU	000000000000100000000b	; Call from VxD
VMStat_VxD_Exec_Bit	EQU	8
VMStat_High_Pri_Back	EQU	000000000001000000000b	; High pri background
VMStat_High_Pri_Back_Bit    EQU 9
VMStat_Blocked		EQU	000000000010000000000b	; Blocked on semaphore
VMStat_Blocked_Bit	EQU	0Ah
VMStat_Awakening	EQU	000000000100000000000b	; Woke up after blocked
VMStat_Awakening_Bit	EQU	0Bh
VMStat_PageableV86	EQU	000000001000000000000b	; part of V86 is pageable (PM app)
VMStat_PageableV86Bit	EQU	0Ch
VMStat_V86IntsLocked	EQU	000000010000000000000b	; Rest of V86 is locked
VMStat_V86IntsLockedBit EQU	0Dh			;  regardless of pager type
VMStat_TS_Sched 	EQU	000000100000000000000b	; Scheduled by time-slicer
VMStat_TS_Sched_Bit	EQU	0Eh
VMStat_Idle		EQU	000001000000000000000b	; VM has released time
VMStat_Idle_Bit 	EQU	0Fh			; slice
VMStat_Closing		EQU	000010000000000000000b	; Close_VM called for VM
VMStat_Closing_Bit	EQU	10h

VMStat_Use32_Mask	EQU	VMStat_PM_Use32 OR VMStat_VxD_Exec


;*******
; Add this value to a V86 linear address to get address of VM's memory in
;	the VMM linear address space
CB_High_Linear		EQU	DWORD PTR 04h

;*******
CB_Client_Pointer	EQU	DWORD PTR 08h

CB_VMID 		EQU	DWORD PTR 0Ch

;
;   Equates for protected mode application control blocks
;
PMCB_Flags		EQU	DWORD PTR 00h
PMCB_Parent		EQU	DWORD PTR 04h
EndDoc

;******************************************************************************
;			    V M M   S E R V I C E S
;******************************************************************************

Begin_Service_Table VMM, VMM

VMM_Service	Get_VMM_Version, LOCAL		; MUST REMAIN SERVICE 0!

VMM_Service	Get_Cur_VM_Handle
VMM_Service	Test_Cur_VM_Handle
VMM_Service	Get_Sys_VM_Handle
VMM_Service	Test_Sys_VM_Handle
VMM_Service	Validate_VM_Handle

VMM_Service	Get_VMM_Reenter_Count
VMM_Service	Begin_Reentrant_Execution
VMM_Service	End_Reentrant_Execution

VMM_Service	Install_V86_Break_Point
VMM_Service	Remove_V86_Break_Point
VMM_Service	Allocate_V86_Call_Back
VMM_Service	Allocate_PM_Call_Back

VMM_Service	Call_When_VM_Returns


VMM_Service	Schedule_Global_Event
VMM_Service	Schedule_VM_Event
VMM_Service	Call_Global_Event
VMM_Service	Call_VM_Event
VMM_Service	Cancel_Global_Event
VMM_Service	Cancel_VM_Event
VMM_Service	Call_Priority_VM_Event
VMM_Service	Cancel_Priority_VM_Event

VMM_Service	Get_NMI_Handler_Addr
VMM_Service	Set_NMI_Handler_Addr
VMM_Service	Hook_NMI_Event

VMM_Service	Call_When_VM_Ints_Enabled
VMM_Service	Enable_VM_Ints
VMM_Service	Disable_VM_Ints

VMM_Service	Map_Flat
VMM_Service	Map_Lin_To_VM_Addr

;
;   Scheduler services
;
VMM_Service	Adjust_Exec_Priority
VMM_Service	Begin_Critical_Section
VMM_Service	End_Critical_Section
VMM_Service	End_Crit_And_Suspend
VMM_Service	Claim_Critical_Section
VMM_Service	Release_Critical_Section
VMM_Service	Call_When_Not_Critical
VMM_Service	Create_Semaphore
VMM_Service	Destroy_Semaphore
VMM_Service	Wait_Semaphore
VMM_Service	Signal_Semaphore
VMM_Service	Get_Crit_Section_Status
VMM_Service	Call_When_Task_Switched
VMM_Service	Suspend_VM
VMM_Service	Resume_VM
VMM_Service	No_Fail_Resume_VM
VMM_Service	Nuke_VM
VMM_Service	Crash_Cur_VM

VMM_Service	Get_Execution_Focus
VMM_Service	Set_Execution_Focus
VMM_Service	Get_Time_Slice_Priority
VMM_Service	Set_Time_Slice_Priority
VMM_Service	Get_Time_Slice_Granularity
VMM_Service	Set_Time_Slice_Granularity
VMM_Service	Get_Time_Slice_Info
VMM_Service	Adjust_Execution_Time
VMM_Service	Release_Time_Slice
VMM_Service	Wake_Up_VM
VMM_Service	Call_When_Idle

VMM_Service	Get_Next_VM_Handle

;
;   Time-out and system timer services
;
VMM_Service	Set_Global_Time_Out
VMM_Service	Set_VM_Time_Out
VMM_Service	Cancel_Time_Out
VMM_Service	Get_System_Time
VMM_Service	Get_VM_Exec_Time

VMM_Service	Hook_V86_Int_Chain
VMM_Service	Get_V86_Int_Vector
VMM_Service	Set_V86_Int_Vector
VMM_Service	Get_PM_Int_Vector
VMM_Service	Set_PM_Int_Vector

VMM_Service	Simulate_Int
VMM_Service	Simulate_Iret
VMM_Service	Simulate_Far_Call
VMM_Service	Simulate_Far_Jmp
VMM_Service	Simulate_Far_Ret
VMM_Service	Simulate_Far_Ret_N
VMM_Service	Build_Int_Stack_Frame

VMM_Service	Simulate_Push
VMM_Service	Simulate_Pop

;
; Heap Manager
;
VMM_Service	_HeapAllocate
VMM_Service	_HeapReAllocate
VMM_Service	_HeapFree
VMM_Service	_HeapGetSize

; ---------------------------------------------------
;
;	 Flags for heap allocator calls
;
; ---------------------------------------------------


HeapZeroInit	equ	00000000000000000000000000000001B
HeapZeroReInit	equ	00000000000000000000000000000010B
HeapNoCopy	equ	00000000000000000000000000000100B

; NOTE: HIGH 8 BITS (bits 24-31) are reserved


;
; Page Manager
;
VMM_Service	_PageAllocate
VMM_Service	_PageReAllocate
VMM_Service	_PageFree
VMM_Service	_PageLock
VMM_Service	_PageUnLock
VMM_Service	_PageGetSizeAddr
VMM_Service	_PageGetAllocInfo
VMM_Service	_GetFreePageCount
VMM_Service	_GetSysPageCount
VMM_Service	_GetVMPgCount
VMM_Service	_MapIntoV86
VMM_Service	_PhysIntoV86
VMM_Service	_TestGlobalV86Mem
VMM_Service	_ModifyPageBits
VMM_Service	_CopyPageTable
VMM_Service	_LinMapIntoV86
VMM_Service	_LinPageLock
VMM_Service	_LinPageUnLock
VMM_Service	_SetResetV86Pageable
VMM_Service	_GetV86PageableArray
VMM_Service	_PageCheckLinRange
VMM_Service	_PageOutDirtyPages
VMM_Service	_PageDiscardPages

; ---------------------------------------------------
;
;	 Flags for other page allocator calls
;
; ---------------------------------------------------
PageZeroInit		equ	00000000000000000000000000000001B
PageUseAlign		equ	00000000000000000000000000000010B
PageContig		equ	00000000000000000000000000000100B
PageFixed		equ	00000000000000000000000000001000B
PageDEBUGNulFault	equ	00000000000000000000000000010000B
PageZeroReInit		equ	00000000000000000000000000100000B
PageNoCopy		equ	00000000000000000000000001000000B
PageLocked		equ	00000000000000000000000010000000B
PageLockedIfDP		equ	00000000000000000000000100000000B
PageSetV86Pageable	equ	00000000000000000000001000000000B
PageClearV86Pageable	equ	00000000000000000000010000000000B
PageSetV86IntsLocked	equ	00000000000000000000100000000000B
PageClearV86IntsLocked	equ	00000000000000000001000000000000B
PageMarkPageOut 	equ	00000000000000000010000000000000B
PagePDPSetBase		equ	00000000000000000100000000000000B
PagePDPClearBase	equ	00000000000000001000000000000000B
PageDiscard		equ	00000000000000010000000000000000B
PagePDPQueryDirty	equ	00000000000000100000000000000000B
;
; New for 3.10
;
PageMapFreePhysReg	equ	00000000000001000000000000000000B



; NOTE: HIGH 8 BITS (bits 24-31) are reserved

;
; Informational services
;
VMM_Service	_GetNulPageHandle
VMM_Service	_GetFirstV86Page
VMM_Service	_MapPhysToLinear
VMM_Service	_GetAppFlatDSAlias
VMM_Service	_SelectorMapFlat
VMM_Service	_GetDemandPageInfo
;
; Data structure for _GetDemandPageInfo
;
DemandInfoStruc struc
DILin_Total_Count     dd	      ?       ; # pages in linear address space
DIPhys_Count	      dd	      ?       ; Count of phys pages
DIFree_Count	      dd	      ?       ; Count of free phys pages
DIUnlock_Count	      dd	      ?       ; Count of unlocked Phys Pages
DILinear_Base_Addr    dd	      ?       ; Base of pageable address space
DILin_Total_Free      dd	      ?       ; Total Count of free linear pages
DIReserved	      dd      10 dup (?)      ; Resvd for expansion
DemandInfoStruc ends

VMM_Service	_GetSetPageOutCount
;
; Flags bits for _GetSetPageOutCount
;
GSPOC_F_Get	equ	00000000000000000000000000000001B

;
; Device VM page manager
;
VMM_Service	Hook_V86_Page
VMM_Service	_Assign_Device_V86_Pages
VMM_Service	_DeAssign_Device_V86_Pages
VMM_Service	_Get_Device_V86_Pages_Array
VMM_Service	MMGR_SetNULPageAddr

;
; GDT/LDT management
;
VMM_Service	_Allocate_GDT_Selector
VMM_Service	_Free_GDT_Selector
VMM_Service	_Allocate_LDT_Selector
VMM_Service	_Free_LDT_Selector
VMM_Service	_BuildDescriptorDWORDs
;
; Flag equates for _BuildDescriptorDWORDs
;
BDDExplicitDPL	EQU	00000000000000000000000000000001B
;
; Flag equates for _Allocate_LDT_Selector
;
ALDTSpecSel	EQU	00000000000000000000000000000001B

VMM_Service	_GetDescriptor
VMM_Service	_SetDescriptor


VMM_Service	_MMGR_Toggle_HMA
;
; Flag equates for _MMGR_Toggle_HMA
;
MMGRHMAPhysical EQU	00000000000000000000000000000001B
MMGRHMAEnable	EQU	00000000000000000000000000000010B
MMGRHMADisable	EQU	00000000000000000000000000000100B
MMGRHMAQuery	EQU	00000000000000000000000000001000B


VMM_Service	Get_Fault_Hook_Addrs
VMM_Service	Hook_V86_Fault
VMM_Service	Hook_PM_Fault
VMM_Service	Hook_VMM_Fault
VMM_Service	Begin_Nest_V86_Exec
VMM_Service	Begin_Nest_Exec
VMM_Service	Exec_Int
VMM_Service	Resume_Exec
VMM_Service	End_Nest_Exec

VMM_Service	Allocate_PM_App_CB_Area, VMM_ICODE
VMM_Service	Get_Cur_PM_App_CB

VMM_Service	Set_V86_Exec_Mode
VMM_Service	Set_PM_Exec_Mode

VMM_Service	Begin_Use_Locked_PM_Stack
VMM_Service	End_Use_Locked_PM_Stack

VMM_Service	Save_Client_State
VMM_Service	Restore_Client_State

VMM_Service	Exec_VxD_Int

VMM_Service	Hook_Device_Service

VMM_Service	Hook_Device_V86_API
VMM_Service	Hook_Device_PM_API

VMM_Service	System_Control

;
;   I/O and software interrupt hooks
;
VMM_Service	Simulate_IO
VMM_Service	Install_Mult_IO_Handlers
VMM_Service	Install_IO_Handler
VMM_Service	Enable_Global_Trapping
VMM_Service	Enable_Local_Trapping
VMM_Service	Disable_Global_Trapping
VMM_Service	Disable_Local_Trapping


;
;   Linked List Abstract Data Type Services
;
VMM_Service	List_Create
VMM_Service	List_Destroy
VMM_Service	List_Allocate
VMM_Service	List_Attach
VMM_Service	List_Attach_Tail
VMM_Service	List_Insert
VMM_Service	List_Remove
VMM_Service	List_Deallocate
VMM_Service	List_Get_First
VMM_Service	List_Get_Next
VMM_Service	List_Remove_First

;
;   Flags used by List_Create
;
LF_Async		EQU	00000001b
LF_Async_Bit		EQU	0
LF_Use_Heap		EQU	00000010b
LF_Use_Heap_Bit 	EQU	1
LF_Alloc_Error		EQU	00000100b
LF_Alloc_Error_Bit	EQU	2


;==============================================================================
;	I N I T I A L I Z A T I O N   P R O C E D U R E S
;------------------------------------------------------------------------------


;
; Instance data manager
;
VMM_Service	_AddInstanceItem
;
; Data structure for _AddInstanceItem
;
InstDataStruc struc
InstLinkF	      dd	      0       ; RESERVED SET TO 0
InstLinkB	      dd	      0       ; RESERVED SET TO 0
InstLinAddr	      dd	      ?       ; Linear address of start of block
InstSize	      dd	      ?       ; Size of block in bytes
InstType	      dd	      ?       ; Type of block
InstDataStruc ends
;
; Values for InstType
;
INDOS_Field	equ	100h	; Bit indicating INDOS switch requirements
ALWAYS_Field	equ	200h	; Bit indicating ALWAYS switch requirements

;
; System structure data manager
;
VMM_Service	_Allocate_Device_CB_Area, VMM_ICODE
VMM_Service	_Allocate_Global_V86_Data_Area, VMM_ICODE
VMM_Service	_Allocate_Temp_V86_Data_Area, VMM_ICODE
VMM_Service	_Free_Temp_V86_Data_Area, VMM_ICODE

;
; Flag bits for _Allocate_Global_V86_Data_Area
;
GVDAWordAlign		EQU		00000000000000000000000000000001B
GVDADWordAlign		EQU		00000000000000000000000000000010B
GVDAParaAlign		EQU		00000000000000000000000000000100B
GVDAPageAlign		EQU		00000000000000000000000000001000B
GVDAInstance		EQU		00000000000000000000000100000000B
GVDAZeroInit		EQU		00000000000000000000001000000000B
GVDAReclaim		EQU		00000000000000000000010000000000B
;
; New for 3.10
;
GVDAInquire		EQU		00000000000000000000100000000000B
GVDAHighSysCritOK	EQU		00000000000000000001000000000000B

;
; Initialization information calls (win.ini and environment parameters)
;
VMM_Service	Get_Profile_Decimal_Int, VMM_ICODE
VMM_Service	Convert_Decimal_String, VMM_ICODE
VMM_Service	Get_Profile_Fixed_Point, VMM_ICODE
VMM_Service	Convert_Fixed_Point_String, VMM_ICODE
VMM_Service	Get_Profile_Hex_Int, VMM_ICODE
VMM_Service	Convert_Hex_String, VMM_ICODE
VMM_Service	Get_Profile_Boolean, VMM_ICODE
VMM_Service	Convert_Boolean_String, VMM_ICODE
VMM_Service	Get_Profile_String, VMM_ICODE
VMM_Service	Get_Next_Profile_String, VMM_ICODE
VMM_Service	Get_Environment_String, VMM_ICODE
VMM_Service	Get_Exec_Path, VMM_ICODE
VMM_Service	Get_Config_Directory, VMM_ICODE
VMM_Service	OpenFile, VMM_ICODE
VMM_Service	Get_PSP_Segment, VMM_ICODE
VMM_Service	GetDOSVectors, VMM_ICODE
VMM_Service	Get_Machine_Info

GMIF_80486	EQU	00010000h
GMIF_80486_Bit	EQU	10h
GMIF_PCXT	EQU	00020000h
GMIF_PCXT_Bit	EQU	11h
GMIF_MCA	EQU	00040000h
GMIF_MCA_Bit	EQU	12h
GMIF_EISA	EQU	00080000h
GMIF_EISA_Bit	EQU	13h


;
; Following service is not restricted to initialization
;
VMM_Service	GetSet_HMA_Info
VMM_Service	Set_System_Exit_Code

VMM_Service	Fatal_Error_Handler
VMM_Service	Fatal_Memory_Error

;
;   Called by VTD only
;
VMM_Service	Update_System_Clock

;==============================================================================
;		    D E B U G G I N G	E X T E R N S
;==============================================================================

VMM_Service	Test_Debug_Installed		; Valid call in retail also

VMM_Service	Out_Debug_String		; Valid in DEBLEVEL=1
VMM_Service	Out_Debug_Chr
VMM_Service	In_Debug_Chr
VMM_Service	Debug_Convert_Hex_Binary
VMM_Service	Debug_Convert_Hex_Decimal

VMM_Service	Debug_Test_Valid_Handle
VMM_Service	Validate_Client_Ptr
VMM_Service	Test_Reenter
VMM_Service	Queue_Debug_String
VMM_Service	Log_Proc_Call
VMM_Service	Debug_Test_Cur_VM

VMM_Service	Get_PM_Int_Type
VMM_Service	Set_PM_Int_Type

VMM_Service	Get_Last_Updated_System_Time
VMM_Service	Get_Last_Updated_VM_Exec_Time

; for DBCS Enabling
VMM_Service	Test_DBCS_Lead_Byte

.errnz	Test_DBCS_Lead_Byte - 100D1h   ; VMM service table changed above this service

;*************************************************************************
;*************************************************************************
;*************************************************************************
;
; END OF 3.00 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
;	FOR COMPATIBILITY.
;

VMM_Service	_AddFreePhysPage, VMM_ICODE
VMM_Service	_PageResetHandlePAddr
VMM_Service	_SetLastV86Page, VMM_ICODE
VMM_Service	_GetLastV86Page
VMM_Service	_MapFreePhysReg
VMM_Service	_UnmapFreePhysReg
VMM_Service	_XchgFreePhysReg
VMM_Service	_SetFreePhysRegCalBk, VMM_ICODE
VMM_Service	Get_Next_Arena, VMM_ICODE
VMM_Service	Get_Name_Of_Ugly_TSR, VMM_ICODE
VMM_Service	Get_Debug_Options, VMM_ICODE

;
; Bits for the ECX return of Get_Next_Arena
;
GNA_HiDOSLinked  equ	 0000000000000010B	; High DOS arenas were linked in
						;   when WIN386 was started
GNA_IsHighDOS	 equ	 0000000000000100B	; High DOS arenas do exist

VMM_Service	Set_Physical_HMA_Alias, VMM_ICODE
VMM_Service	_GetGlblRng0V86IntBase, VMM_ICODE
VMM_Service	_Add_Global_V86_Data_Area, VMM_ICODE

VMM_Service	GetSetDetailedVMError
;
; Error code values for the GetSetDetailedVMError service. PLEASE NOTE
;   that all of these error code values need to have bits set in the high
;   word. This is to prevent collisions with other VMDOSAPP standard errors.
;   Also, the low word must be non-zero.
;
; First set of errors (high word = 0001) are intended to be used
;   when a VM is CRASHED (VNE_Crashed or VNE_Nuked bit set on
;   VM_Not_Executeable).
;
; PLEASE NOTE that each of these errors (high word == 0001) actually
;   has two forms:
;
;	0001xxxxh
;	8001xxxxh
;
;   The device which sets the error initially always sets the error with
;   the high bit CLEAR. The system will then optionally set the high bit
;   depending on the result of the attempt to "nicely" crash the VM. This
;   bit allows the system to tell the user whether the crash is likely or
;   unlikely to destabalize the system.
;
GSDVME_PrivInst 	equ	00010001h	; Privledged instruction
GSDVME_InvalInst	equ	00010002h	; Invalid instruction
GSDVME_InvalPgFlt	equ	00010003h	; Invalid page fault
GSDVME_InvalGpFlt	equ	00010004h	; Invalid GP fault
GSDVME_InvalFlt 	equ	00010005h	; Invalid fault, not any of abv
GSDVME_UserNuke 	equ	00010006h	; User requested NUKE of running
						;    VM
GSDVME_DevNuke		equ	00010007h	; Device specific problem
GSDVME_DevNukeHdwr	equ	00010008h	; Device specific problem,
						;   invalid hardware fiddling
						;   by VM (invalid I/O)
GSDVME_NukeNoMsg	equ	00010009h	; Supress standard messgs,
						;   SHELL_Message used for
						;   custom msg.

GSDVME_OkNukeMask	equ	80000000h	; "Nice nuke" bit

;
; Second set of errors (high word = 0002) are intended to be used
;   when a VM start up is failed (VNE_CreateFail, VNE_CrInitFail, or
;   VNE_InitFail bit set on VM_Not_Executeable).
;
GSDVME_InsMemV86	equ	00020001h	; base V86 mem	   - V86MMGR
GSDVME_InsV86Space	equ	00020002h	; Kb Req too large - V86MMGR
GSDVME_InsMemXMS	equ	00020003h	; XMS Kb Req	   - V86MMGR
GSDVME_InsMemEMS	equ	00020004h	; EMS Kb Req	   - V86MMGR
GSDVME_InsMemV86Hi	equ	00020005h	; Hi DOS V86 mem   - DOSMGR
						;		     V86MMGR
GSDVME_InsMemVid	equ	00020006h	; Base Video mem   - VDD
GSDVME_InsMemVM 	equ	00020007h	; Base VM mem	   - VMM
						;   CB, Inst Buffer
GSDVME_InsMemDev	equ	00020008h	; Couldn't alloc base VM
						;   memory for device.
GSDVME_CrtNoMsg 	equ	00020009h	; Supress standard messgs,
						;   SHELL_Message used for
						;   custom msg.
VMM_Service	Is_Debug_Chr
;
; Mono_Out services
;
VMM_Service	Clear_Mono_Screen
VMM_Service	Out_Mono_Chr
VMM_Service	Out_Mono_String
VMM_Service	Set_Mono_Cur_Pos
VMM_Service	Get_Mono_Cur_Pos
VMM_Service	Get_Mono_Chr

;
;   Service locates a byte in ROM
;
VMM_Service	Locate_Byte_In_ROM, VMM_ICODE

VMM_Service	Hook_Invalid_Page_Fault
VMM_Service	Unhook_Invalid_Page_Fault
;
; This is the structure of the "invalid page fault information"
; which is pointed to by EDI when Invalid page fault hookers
; are called.
;
; page faults can occur on a VM which is not current by touching the VM at
;   its high linear address. In this case, IPF_FaultingVM may not = the
;   current VM, it will be set to the VM whos high linear address was touched.
;
IPF_Data	struc

  IPF_LinAddr	    dd	    ?	; CR2 address of fault
  IPF_MapPageNum    dd	    ?	; Possible converted page # of fault
  IPF_PTEEntry	    dd	    ?	; Contents of PTE that faulted
  IPF_FaultingVM    dd	    ?	; May not = Current VM (IPF_V86PgH set)
  IPF_Flags	    dd	    ?	; Flags

IPF_Data	ends
;
; Flag bits of IPF_Flags
;
			; Page directory entry not-present (not pres page table)
IPF_PgDir	equ	000000000000000000000000000000001b
			; Unexpected not present Page in V86
IPF_V86Pg	equ	000000000000000000000000000000010b
			; Unexpected not present Page in V86 at high linear
IPF_V86PgH	equ	000000000000000000000000000000100b
			; page has invalid not present type
IPF_InvTyp	equ	000000000000000000000000000001000b
			; pageswap device couldn't page for some reason
IPF_PgErr	equ	000000000000000000000000000010000b
			; re-entrant page fault
IPF_ReFlt	equ	000000000000000000000000000100000b
			; Page fault caused by a VxD
IPF_VMM 	equ	000000000000000000000000001000000b
			; Page fault caused by VM running in Prot Mode
IPF_PM		equ	000000000000000000000000010000000b
			; Page fault caused by VM running in V86 Mode
IPF_V86 	equ	000000000000000000000000100000000b

VMM_Service	Set_Delete_On_Exit_File

VMM_Service	Close_VM
;
;   Flags for Close_VM service
;
CVF_Continue_Exec   equ 00000001b
CVF_Continue_Exec_Bit equ 0

VMM_Service	Enable_Touch_1st_Meg		; Debugging only
VMM_Service	Disable_Touch_1st_Meg		; Debugging only

VMM_Service	Install_Exception_Handler
VMM_Service	Remove_Exception_Handler

Exception_Handler_Struc STRUC
EH_Reserved	dd	?
EH_Start_EIP	dd	?
EH_End_EIP	dd	?
EH_Handler	dd	?
Exception_Handler_Struc ENDS

VMM_Service	Get_Crit_Status_No_Block

.errnz	 Get_Crit_Status_No_Block - 100F1h   ; VMM service table changed above this service

;*************************************************************************
;*************************************************************************
;*************************************************************************
;
; END OF 3.10 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
;	FOR COMPATIBILITY.
;


End_Service_Table VMM, VMM


;******************************************************************************

IFDEF DEBUG
DebFar	EQU	NEAR PTR
ELSE
DebFar	EQU	SHORT
ENDIF

BeginDoc

;******************************************************************************
;
;		     EQUATES FOR SYSTEM_CONTROL CALLS
;
;==============================================================================

;
; Sys_Critical_Init is a device init call. Devices that have a critical
;   function that needs initializing before interrupts are enabled should
;   do it at Sys_Critical_Init. Devices which REQUIRE a certain range of
;   V86 pages to operate (such as the VDD video memory) should claim them
;   at Sys_Critical_Init. SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT
;   ALLOWED. Returning carry aborts device load only.
;
Sys_Critical_Init	EQU	0000h		; Devices required for virt mode
;
; Device init is where most devices do the bulk of their initialization.
;   SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
;   aborts device load only.
;
Device_Init		EQU	0001h		; All other devices init
;
; Init_Complete is the final phase of device init called just before the
;   WIN386 INIT pages are released and the Instance snapshot is taken.
;   Devices which wish to search for a region of V86 pages >= A0h to use
;   should do it at Init_Complete.
;   SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
;   aborts device load only.
;
Init_Complete		EQU	0002h		; All devices have initialized

;----------------- INITIALIZATION CODE AND DATA DISCARDED ---------------------

;
; Same as VM_Init, except for SYS VM.
;
Sys_VM_Init		EQU	0003h		; Execute the system VM (Win86)
;
; Same as VM_Terminate, except for SYS VM (Normal WIN386 exit ONLY, on a crash
;   exit this call is not made). SYS VM Simulate_Int, Exec_Int activity is
;   allowed.
;
Sys_VM_Terminate	EQU	0004h		; System VM terminted (exiting)

;------------------------------------------------------------------------------

;
; System_Exit call is made when WIN386 is exiting either normally or via
;   a crash. INTERRUPS ARE ENABLED. Instance snapshot has been restored.
;   SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT ALLOWED.
;
System_Exit		EQU	0005h		; Devices prepare to exit
;
; System_Exit call is made when WIN386 is exiting either normally or via
;   a crash. INTERRUPS ARE DISABLED. SYS VM Simulate_Int, Exec_Int ACTIVITY
;   IS NOT ALLOWED.
;
Sys_Critical_Exit	EQU	0006h		; System critical devices reset

;
; Create_VM creates a new VM. EBX = VM handle of new VM. Returning Carry will
;   fail the Create_VM.
;
Create_VM		EQU	0007h
;
; Second phase of Create_VM. EBX = VM handle of new VM. Returning Carry will
;   cause the VM to go Not_Executeable, then be destroyed. VM Simulate_Int,
;   Exec_Int activity is NOT allowed.
;
VM_Critical_Init	EQU	0008h
;
; Third phase of Create_VM. EBX = VM handle of new VM. Returning Carry will
;   cause the VM to go Not_Executeable, then be destroyed. VM Simulate_Int,
;   Exec_Int activity is allowed.
;
VM_Init 		EQU	0009h

;
; NORMAL (First phase) of Destroy_VM. EBX = VM Hanlde. This occurs on normal
;   termination of the VM. Call cannot be failed. VM Simulate_Int, Exec_Int
;   activity is allowed.
;
VM_Terminate		EQU	000Ah		; Still in VM -- About to die
;
; Second phase of Destroy_VM. EBX = VM Handle, EDX = Flags (see below). Note
;   that in the case of destroying a running VM, this is the first call made
;   (VM_Terminate call does not occur). Call cannot be failed. VM Simulate_Int,
;   Exec_Int activity is NOT allowed.
;
VM_Not_Executeable	EQU	000Bh		; Most devices die (except VDD)
;
; Final phase of Destroy_VM. EBX = VM Handle. Note that considerable time
;   can elaps between the VM_Not_Executeable call and this call. Call cannot
;   be failed. VM Simulate_Int, Exec_Int activity is NOT allowed.
;
Destroy_VM		EQU	000Ch		; VM's control block about to go

;
;   Flags for VM_Not_Executeable control call (passed in EDX)
;
VNE_Crashed		EQU	0000000000000000000000001b
VNE_Crashed_Bit 	EQU	0		; VM was crashed
VNE_Nuked		EQU	0000000000000000000000010b
VNE_Nuked_Bit		EQU	1		; VM was destroyed while active
VNE_CreateFail		EQU	0000000000000000000000100b
VNE_CreateFail_Bit	EQU	2		; Some device failed Create_VM
VNE_CrInitFail		EQU	0000000000000000000001000b
VNE_CrInitFail_Bit	EQU	3		; Some device failed VM_Critical_Init
VNE_InitFail		EQU	0000000000000000000010000b
VNE_InitFail_Bit	EQU	4		; Some device failed VM_Init
VNE_Closed		EQU	0000000000000000000100000b
VNE_Closed_Bit		EQU	5

;------------------------------------------------------------------------------

;
; EBX = VM Handle. Call cannot be failed.
;
VM_Suspend		EQU	000Dh		; VM not runnable until resume
;
; EBX = VM Handle. Returning carry fails and backs out the resume.
;
VM_Resume		EQU	000Eh		; VM is leaving suspended state

;------------------------------------------------------------------------------

;
; EBX = VM Handle to set device focus to. EDX = Device ID if device specific
;   setfocus. == 0 if device critical setfocus (all devices). THIS CALL CANNOT
;   BE FAILED.
;
;   NOTE: In case where EDX == 0, ESI is a FLAG word that indicates special
;	  functions. Currently Bit 0 being set indicates that this Device
;	  critical set focus is also "VM critical". It means that we do not
;	  want some other VM to take the focus from this app now. This is
;	  primarily used when doing a device critical set focus to Windows
;	  (the SYS VM) it is interpreted by the SHELL to mean "if an old app
;	  currently has the Windows activation, set the activation to the
;	  Windows Shell, not back to the old app". ALSO in the case where
;	  Bit 0 is set, EDI = The VM handle of the VM that is "having trouble".
;	  Set this to 0 if there is no specific VM associated with the problem.
;
Set_Device_Focus	EQU	000Fh

;------------------------------------------------------------------------------

;
; EBX = VM Handle going into message mode. THIS CALL CANNOT BE FAILED.
;
Begin_Message_Mode	EQU	0010h
;
; EBX = VM Handle leaving message mode. THIS CALL CANNOT BE FAILED.
;
End_Message_Mode	EQU	0011h

;------------------------- SPECIAL CONTROL CALLS ------------------------------

;
; Request for reboot. Call cannot be failed.
;
Reboot_Processor	EQU	0012h		; Request a machine reboot
;
; Query_Destroy is an information call made by the SHELL device before an
;   attempt is made to initiate a destroy VM sequence on a running VM which
;   has not exited normally. EBX = VM Handle. Returning carry indicates that
;   a device "has a problem" with allowing this. THE DESTROY SEQUENCE CANNOT
;   BE ABORTED HOWEVER, this decision is up to the user. All this does is
;   indicate that there is a "problem" with allowing the destroy. The device
;   which returns carry should call the SHELL_Message service to post an
;   informational dialog about the reason for the problem.
;
Query_Destroy		EQU	0013h		; OK to destroy running VM?

;------------------------- DEBUGGING CONTROL CALL -----------------------------

;
; Special call for device specific DEBUG information display and activity.
;
Debug_Query		EQU	0014h

;---------- CALLS FOR BEGIN/END OF PROTECTED MODE VM EXECUTION ----------------

;
;   About to run a protected mode application.
;   EBX = Current VM handle.
;   EDX = Flags
;   EDI -> Application Control Block
;   Returning with carry set fails the call.
;
Begin_PM_App		EQU	0015h

;
;   Flags for Begin_PM_App (passed in EDX)
;
BPA_32_Bit		EQU	00000001b
BPA_32_Bit_Flag 	EQU	1

;
;   Protected mode application is terminating.
;   EBX = Current VM handle.  THIS CALL CAN NOT FAIL.
;   EDI -> Application Control Block
;
End_PM_App		EQU	0016h

;
;   Called whenever system is about to be rebooted.  Allows VxDs to clean
;   up in preperation for reboot.
;
Device_Reboot_Notify	EQU	0017h
Crit_Reboot_Notify	EQU	0018h

;
;   Called when VM is about to be termintate using the Close_VM service
;	EBX = Current VM handle (Handle of VM to close)
;	EDX = Flags
;	      CVNF_Crit_Close = 1 if VM is in critical section while closing
;
Close_VM_Notify 	EQU	0019h

CVNF_Crit_Close 	EQU	00000001b
CVNF_Crit_Close_Bit	EQU	0

;
;   Power management event notification.
;   EBX = 0
;   ESI = event notification message
;   EDI -> DWORD return value; VxD's modify the DWORD to return info, not EDI
;   EDX is reserved
;
Power_Event		EQU	001Ah


EndDoc

BeginDoc
;******************************************************************************
; BeginProc is a macro for defining entry points to routines in VMM and in the
;   VxDs. It correctly defines the procedure name for VxD services(it prepends
;   a "@" to the procedure name), DWORD aligns the procedure, takes care of
;   public declaration and does some calling verification for debug versions
;   of the software. EndProc is a macro which defines the end of the procedure.
;
; Valid parameters to the BeginProc macro are:
;	PUBLIC				; Routine used outside this module
;	HIGH_FREQ			; DWORD align procedure
;	SERVICE 			; Routine is called via VxDCall
;	ASYNC_SERVICE			; Same as "SERVICE" plus routine can
;					;	be called under interrupt.
; After the routine header in which the routine entry conditions, exit
;   conditions, side affects and functionality are specified, the BeginProc
;   macro should be used to define the routine's entry point. It has up to
;   four parameters as specified below. For example:
;
;BeginProc  <Function_Name>,PUBLIC, HIGH_FREQ, ASYNC_SERVICE
;
;	<code>
;
;EndProc    <Function_Name>
;==============================================================================
EndDoc

BeginProc MACRO Name, P1, P2, P3, P4
	LOCAL	Profile_Data, Skip_Data

IF ?_RCODE

Process_Param MACRO P
IFNB <P>
IFIDNI <P>, <HIGH_FREQ>
Dword_Align
ELSE
IFIDNI <P>, <SERVICE>
??_SERVICE = 1
ELSE
IFIDNI <P>, <ASYNC_SERVICE>
??_ASYNC_SERVICE = 1
IF ?_LCODE
%OUT ERROR:  ASYNC_SERVICE's must be in LOCKED code
;;.err
ENDIF
ELSE
IFIDNI <P>, <NO_LOG>
??_NO_LOG = 1
ELSE
IFDIFI <P>, <PUBLIC>
%OUT ERROR:  Bad para "&P" to BeginProc
.ERR
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM


??_SERVICE = 0
??_ASYNC_SERVICE = 0
??_NO_LOG = 0

Process_Param P1
Process_Param P2
Process_Param P3
Process_Param P4


IFE ??_SERVICE + ??_ASYNC_SERVICE

PUBLIC Name
Name PROC NEAR
IFDEF DEBUG
IFE ??_NO_LOG
IFNDEF VMMSYS
	VMMcall Log_Proc_Call
ENDIF
ENDIF
ENDIF

ELSE

IFDEF DEBUG
	jmp	SHORT Skip_Data
Profile_Data LABEL DWORD
	dd	0
Skip_Data:
ENDIF

PUBLIC @&Name
@&Name PROC NEAR

IFDEF DEBUG
IFE ??_NO_LOG
;;;;IFNDEF VMMSYS
	VMMcall Log_Proc_Call
;;;;ENDIF
ENDIF
	pushfd
	inc	[Profile_Data]
IFE ??_ASYNC_SERVICE
	VMMcall Test_Reenter
ENDIF
	popfd
ENDIF
ENDIF

ELSE
IFIDNI <P1>, <PUBLIC>
PUBLIC Name
ENDIF
Name PROC NEAR
ENDIF


	ENDM



EndProc MACRO Name
IFDEF @&Name
@&Name ENDP
ELSE
IFDEF Name
Name ENDP
ELSE
.ERR
%OUT EndProc for &Name does not match BeginProc
ENDIF
ENDIF
	ENDM


;******************************************************************************
;	       S C H E D U L E R   B O O S T   V A L U E S
;==============================================================================

Reserved_Low_Boost	EQU	00000000000000000000000000000001b
Cur_Run_VM_Boost	EQU	00000000000000000000000000000100b
Low_Pri_Device_Boost	EQU	00000000000000000000000000010000b
High_Pri_Device_Boost	EQU	00000000000000000001000000000000b
Critical_Section_Boost	EQU	00000000000100000000000000000000b
Time_Critical_Boost	EQU	00000000010000000000000000000000b
Reserved_High_Boost	EQU	01000000000000000000000000000000b


;******************************************************************************
;	 F L A G S   F O R   C A L L _ P R I O R I T Y _ V M _ E V E N T
;==============================================================================

PEF_Wait_For_STI	EQU	0000001b
PEF_Wait_For_STI_Bit	EQU	0
PEF_Wait_Not_Crit	EQU	0000010b
PEF_Wait_Not_Crit_Bit	EQU	1
PEF_Dont_Unboost	EQU	0000100b
PEF_Dont_Unboost_Bit	EQU	2
PEF_Always_Sched	EQU	0001000b
PEF_Always_Sched_Bit	EQU	3
PEF_Time_Out		EQU	0010000b
PEF_Time_Out_Bit	EQU	4

;******************************************************************************
;	 F L A G S   F O R   B E G I N _ C R I T I C A L _ S E C T I O N
;		       A N D   W A I T _ S E M A P H O R E
;==============================================================================

Block_Svc_Ints			EQU	0000001b
Block_Svc_Ints_Bit		EQU	0
Block_Svc_If_Ints_Locked	EQU	0000010b
Block_Svc_If_Ints_Locked_Bit	EQU	1
Block_Enable_Ints		EQU	0000100b
Block_Enable_Ints_Bit		EQU	2
Block_Poll			EQU	0001000b
Block_Poll_Bit			EQU	3



BeginDoc
;******************************************************************************
; The following structures are pointed to by EBP when VxD routines are entered,
;   both for VxD control calls and traps(I/O traps, software INT traps, etc.).
;   The first structure as DWORD values, the second WORD values and the last
;   has BYTE values.
;
Client_Reg_Struc   struc
Client_EDI	dd	?		; Client's EDI
Client_ESI	dd	?		; Client's ESI
Client_EBP	dd	?		; Client's EBP
		dd	?		; ESP at pushall
Client_EBX	dd	?		; Client's EBX
Client_EDX	dd	?		; Client's EDX
Client_ECX	dd	?		; Client's ECX
Client_EAX	dd	?		; Client's EAX
Client_Error	dd	?		; Dword error code
Client_EIP	dd	?		; EIP
Client_CS	dw	?		; CS
		dw	?		;   (padding)
Client_EFlags	dd	?		; EFLAGS
Client_ESP	dd	?		; ESP
Client_SS	dw	?		; SS
		dw	?		;   (padding)
Client_ES	dw	?		; ES
		dw	?		;   (padding)
Client_DS	dw	?		; DS
		dw	?		;   (padding)
Client_FS	dw	?		; FS
		dw	?		;   (padding)
Client_GS	dw	?		; GS
		dw	?		;   (padding)
Client_Alt_EIP	dd	?
Client_Alt_CS	dw	?
		dw	?
Client_Alt_EFlags  dd	?
Client_Alt_ESP	dd	?
Client_Alt_SS	dw	?
		dw	?
Client_Alt_ES	dw	?
		dw	?
Client_Alt_DS	dw	?
		dw	?
Client_Alt_FS	dw	?
		dw	?
Client_Alt_GS	dw	?
		dw	?
Client_Reg_Struc   ends


Client_Word_Reg_Struc	struc
Client_DI	dw	?		; Client's DI
		dw	?		;   (padding)
Client_SI	dw	?		; Client's SI
		dw	?		;   (padding)
Client_BP	dw	?		; Client's BP
		dw	?		;   (padding)
		dd	?		; ESP at pushall
Client_BX	dw	?		; Client's BX
		dw	?		;   (padding)
Client_DX	dw	?		; Client's DX
		dw	?		;   (padding)
Client_CX	dw	?		; Client's CX
		dw	?		;   (padding)
Client_AX	dw	?		; Client's AX
		dw	?		;   (padding)
		dd	?		; Dword error code
Client_IP	dw	?		; Client's IP
		dw	?		;   (padding)
		dd	?		; CS
Client_Flags	dw	?		; Client's flags (low)
		dw	?		;   (padding)
Client_SP	dw	?		; SP
		dw	?
		dd	5 dup (?)
Client_Alt_IP	dw	?
		dw	?
		dd	?
Client_Alt_Flags    dw	?
		dw	?
Client_Alt_SP	dw	?
Client_Word_Reg_Struc	ends



Client_Byte_Reg_Struc	struc
		dd	4 dup (?)	; EDI, ESI, EBP, ESP at pushall
Client_BL	db	?		; Client's BL
Client_BH	db	?		; Client's BH
		dw	?		;   (padding)
Client_DL	db	?		; Client's DL
Client_DH	db	?		; Client's DH
		dw	?		;   (padding)
Client_CL	db	?		; Client's CL
Client_CH	db	?		; Client's CH
		dw	?		;   (padding)
Client_AL	db	?		; Client's AL
Client_AH	db	?		; Client's AH
Client_Byte_Reg_Struc	ends

;==============================================================================
EndDoc

.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX



PushCParams MACRO P1, P2, P3, P4, P5, P6, P7, P8, P9, P10
	IRP Param, <P10, P9, P8, P7, P6, P5, P4, P3, P2, P1>
	IFNB <Param>
	push	Param
	ENDIF
	ENDM
	ENDM

ClearCParams MACRO Count, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10
IFNB <P1>
	ClearCParams %(Count+1), <P2>, <P3>, <P4>, <P5>, <P6>, <P7>, <P8>, <P9>, <P10>
ELSE
IF Count
	add	esp, Count*4
ENDIF
ENDIF
	ENDM



Dyna_Link_Int	EQU 20h

;
;
BeginDoc
;******************************************************************************
; The VMMCall and VxDCall macros provide a dynamic link to the VMM and VxD
;   service routines. For example:
;
;   VMMCall Enable_VM_Ints		; Equivalent to STI in VM code
;
;   mov     eax,[My_IRQ_Handle]
;   VxDCall VPICD_Set_Int_Request	; Set IRQ for my device's interrupt
;
; Note that Enable_VM_Ints is defined in VMM.INC and VPICD_Set_Int_Request is
;	defined in VPICD.INC
;
;==============================================================================
EndDoc


BeginDoc
;******************************************************************************
; VxDCall
;==============================================================================
EndDoc
VxDcall MACRO P, Param
	PushCParams Param
	int	Dyna_Link_Int
	dd	P
	ClearCParams 0, Param
	ENDM

VxDjmp	MACRO P, Param
IFNB <Param>
%OUT ERROR:  Parameters may not be passed to VxDjmp or VMMjmp macros
.ERR
ENDIF
	int	Dyna_Link_Int
IFDEF DEBUG
	dd	P
	ret
ELSE
	dd	P OR DL_Jmp_Mask
ENDIF
	ENDM

DL_Jmp_Mask	EQU	8000h
DL_Jmp_Bit	EQU	0Fh


VMMcall MACRO P, Param
	.ERRNZ (P SHR 16) - VMM_Device_ID
	VxDcall <P>, <Param>
	ENDM

VMMjmp MACRO P, Param
	.ERRNZ (P SHR 16) - VMM_Device_ID
	VxDjmp <P>, <Param>
	ENDM

cCall MACRO P, Param
	PushCParams Param
	call	P
	ClearCParams 0, Param
	ENDM


BeginDoc
;******************************************************************************
; Segment definition macros
;
; The segment definition macros are a convenience used in defining the
;	segments used by the device driver. They are:
;VxD_ICODE_SEG	 defines start of initialization code segment
;VxD_ICODE_ENDS  defines end of initialization code segment
;VxD_IDATA_SEG	 defines start of initialization data segment
;VxD_IDATA_ENDS  defines end of initialization data segment
;VxD_CODE_SEG	 defines start of always present code segment
;VxD_CODE_ENDS	 defines end of always present code segment
;VxD_DATA_SEG	 defines start of always present data segment
;VxD_DATA_ENDS	 defines end of always present data segment
;==============================================================================
EndDoc


;   Protected mode code
VxD_CODE_SEG	EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS	EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 3 + ??_LCODE
	ASSUME	cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
		ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 3
_LTEXT	 ENDS
		ENDM



;   Protected mode initialization code
VxD_ICODE_SEG	MACRO
_ITEXT	SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 3 + ??_ICODE
	ASSUME	cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
		ENDM

VxD_ICODE_ENDS	MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 3
_ITEXT	ENDS
		ENDM


;   Protected mode data
VxD_DATA_SEG	EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS	EQU <VxD_LOCKED_DATA_ENDS>



VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA	 SEGMENT
IFB <NO_ALIGN>
	ALIGN 4
ENDIF
		ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA	 ENDS
		ENDM




;   Protected mode initialization data
VxD_IDATA_SEG	MACRO
_IDATA	SEGMENT
		ENDM
VxD_IDATA_ENDS	MACRO
_IDATA	ENDS
		ENDM

VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 3 + ??_RCODE
		  ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 3
_RCODE ENDS
		   ENDM

ENDIF

DDK_Version equ 30Ah		; 3.10

VxD_Desc_Block STRUC
DDB_Next		dd  ?			; VMM RESERVED FIELD
DDB_SDK_Version 	dw  DDK_Version 	; VMM RESERVED FIELD
DDB_Req_Device_Number	dw  Undefined_Device_ID ; Required device number
DDB_Dev_Major_Version	db  0			; Major device number
DDB_Dev_Minor_Version	db  0			; Minor device number
DDB_Flags		dw  0			; Flags for init calls complete
DDB_Name		db  "        "		; Device name
DDB_Init_Order		dd  Undefined_Init_Order; Initialization Order
DDB_Control_Proc	dd  ?			; Offset of control procedure
DDB_V86_API_Proc	dd  0			; Offset of API procedure (or 0)
DDB_PM_API_Proc 	dd  0			; Offset of API procedure (or 0)
DDB_V86_API_CSIP	dd  0			; CS:IP of API entry point
DDB_PM_API_CSIP 	dd  0			; CS:IP of API entry point
DDB_Reference_Data	dd  ?			; Reference data from real mode
DDB_Service_Table_Ptr	dd  0			; Pointer to service table
DDB_Service_Table_Size	dd  0			; Number of services
VxD_Desc_Block ENDS


IFNDEF Not_VxD

; flag values for DDB_Flags

DDB_Sys_Crit_Init_Done	    EQU 00000001b
DDB_Sys_Crit_Init_Done_Bit  EQU        0
DDB_Device_Init_Done	    EQU 00000010b
DDB_Device_Init_Done_Bit    EQU       1

BeginDoc
;******************************************************************************
;
;   Declare_Virtual_Device macro
;
; ???? Write something here ????
;
;==============================================================================
EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc
	LOCAL	V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len

dev_id_err MACRO
%OUT Device ID required when providing services
.ERR
	ENDM

IFB <V86_Proc>
	V86_API_Offset EQU 0
ELSE
IFB <Device_Num>
	dev_id_err
ENDIF
	V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF
IFB <PM_Proc>
	PM_API_Offset EQU 0
ELSE
IFB <Device_Num>
	dev_id_err
ENDIF
	PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF
IFDEF Name&_Service_Table
IFB <Device_Num>
	dev_id_err
ELSE
IFE Device_Num - Undefined_Device_ID
	dev_id_err
ENDIF
ENDIF
	Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
	Serv_Tab_Len	EQU Num_&Name&_Services
ELSE
	Serv_Tab_Offset EQU 0
	Serv_Tab_Len	EQU 0
ENDIF


VxD_LOCKED_DATA_SEG
PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
			 OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
			 ,,,Serv_Tab_Offset, Serv_Tab_Len>
VxD_LOCKED_DATA_ENDS
	ENDM


BeginDoc
;******************************************************************************
; The Begin_Control_Dispatch macro is used for building a table for dispatching
; messages passed to the VxD_Control procedure.  It is used with
; Control_Dispatch and End_Control_Dispatch.  The only parameter is used to
; contruct the procedure label by adding "_Control" to the end (normally the
; device name is used i.e. VKD results in creating the procedure VKD_Control,
; this created procedure label must be included in Declare_Virtual_Device)
;
; An example of building a complete dispatch table:
;
; Begin_Control_Dispatch MyDevice
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
; Control_Dispatch  Sys_VM_Init, MyDeviceSysInitProcedure
; Control_Dispatch  Create_VM,	 MyDeviceCreateVMProcedure
; End_Control_Dispatch MyDevice
;
; (NOTE: Control_Dispatch can be used without Begin_Control_Dispatch, but
;	 then it is the programmer's responsibility for declaring a procedure
;	 in locked code (VxD_LOCKED_CODE_SEG) and returning Carry clear for
;	 any messages not processed.  The advantage in using
;	 Begin_Control_Dispatch is when a large # of messages are processed by
;	 a device, because a jump table is built which will usually require
;	 less code space then the compares and jumps that are done when
;	 Control_Dispatch is used alone.
;
;==============================================================================
EndDoc
Begin_Control_Dispatch MACRO VxD_Name
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control
ENDM

End_Control_Dispatch   MACRO VxD_Name
	LOCAL ignore, table

jmpproc MACRO num
	jmp	??_cd_&&num
ENDM

procoff MACRO num
IFDEF ??_cd_&&num
	dd	OFFSET32 ??_cd_&&num
ELSE
	dd	OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
	cmp	eax, ??_cd_low
	jne	short ignore
	jmpproc %(??_cd_low)
ignore:
	clc
	ret
ELSE
	cmp	eax, ??_cd_high
	ja	short ignore
	sub	eax, ??_cd_low
	jb	short ignore
	jmp	cs:[eax*4+table]
ignore:
	clc
	ret

table label dword
	REPT   ??_cd_high - ??_cd_low + 1
	procoff %(??_cd_low)
	??_cd_low = ??_cd_low + 1
	ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE jmpproc
PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc
;******************************************************************************
; The Control_Dispatch macro is used for dispatching based on message
;	passed to the VxD_Control procedure. E.G.:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
;
; (NOTE: Control_Dispatch can be used with Begin_Control_Dispatch and
;	 End_Control_Dispatch to create a jump table for dispatching messages,
;	 when a large # of messages are processed.)
;
;==============================================================================
EndDoc
Control_Dispatch MACRO Service, Procedure
	LOCAL Skip_Interseg_Jump

IFE ?_lcode
IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
	cmp	eax, Service
	jne	SHORT Skip_Interseg_Jump
	jmp	Procedure
Skip_Interseg_Jump:
ENDIF
ELSE
%OUT ERROR:  The Control proc should be in LOCKED code.
%OUT	     Control_Dispatch can only be used inside of VxD_LOCKED_CODE_SEG.
.err
ENDIF
	ENDM


BeginDoc
;******************************************************************************
; The following are the definitions for the "type of I/O" parameter passed
;   to a I/O trap routine
Byte_Input	EQU	000h
Byte_Output	EQU	004h
Word_Input	EQU	008h
Word_Output	EQU	00Ch
Dword_Input	EQU	010h
Dword_Output	EQU	014h

Output		EQU	0000000000000100b
Output_Bit	EQU	2
Word_IO 	EQU	0000000000001000b
Word_IO_Bit	EQU	3
Dword_IO	EQU	0000000000010000b
Dword_IO_Bit	EQU	4

String_IO	EQU	00000020h
String_IO_Bit	EQU	5
Rep_IO		EQU	00000040h
Rep_IO_Bit	EQU	6
Addr_32_IO	EQU	00000080h
Addr_32_IO_Bit	EQU	7
Reverse_IO	EQU	00000100h
Reverse_IO_Bit	EQU	8

IO_Seg_Mask	EQU	0FFFF0000h		; Use these bits to get segment
IO_Seg_Shift	EQU	10h			; Must shift right this many

;==============================================================================
EndDoc

BeginDoc
;******************************************************************************
;
;   Dispatch_Byte_IO macro
;
; Dispatch_Byte_IO Byte_In_Proc, Byte_Out_Proc
;==============================================================================
EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
	LOCAL	Byte_IO
	cmp	ecx, Byte_Output
	jbe	SHORT Byte_IO
	VMMjmp	Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
	je	Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
	jb	In_Proc
ELSE
	je	Out_Proc
	jmp	In_Proc
ENDIF
ENDIF
	ENDM

BeginDoc
;******************************************************************************
;
;   Emulate_Non_Byte_IO
;
; Emulate_Non_Byte_IO
;
;==============================================================================
EndDoc
Emulate_Non_Byte_IO MACRO
	LOCAL	Byte_IO
	cmp	ecx, Byte_Output
	jbe	SHORT Byte_IO
	VMMjmp	Simulate_IO
Byte_IO:
	ENDM


VxD_IOT_Hdr STRUC
VxD_IO_Ports	dw  ?
VxD_IOT_Hdr ENDS

VxD_IO_Struc STRUC
VxD_IO_Port	dw  ?
VxD_IO_Proc	dd  ?
VxD_IO_Struc ENDS


BeginDoc
;******************************************************************************
;
; Begin_VxD_IO_Table
;
;   Example:
; Begin_VxD_IO_Table MyTableName
;
;==============================================================================
EndDoc
.ERRNZ SIZE VxD_IOT_Hdr - 2	; Begin_VxD_IO_Table creates a 1 word count hdr
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD
IF2
IFNDEF Table_Name&_Entries
%OUT ERROR:  No End_VxD_IO_Table for &Table_Name
.ERR
ENDIF
	dw	Table_Name&_Entries
ELSE
	dw	?
ENDIF

	ENDM

.ERRNZ SIZE VxD_IO_Struc - 6	; VxD_IO creates 6 byte I/O port entries
VxD_IO MACRO Port, Proc_Name
	dw	Port
	dd	OFFSET32 Proc_Name
	ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
%OUT ERROR:  No Begin_VxD_IO_Table for &Table_Name
.ERR
ELSE
	Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
%OUT ERROR:  Invalid number of port traps in &Table_Name
.ERR
ENDIF
ENDIF
	    ENDM


;******************************************************************************
;******************************************************************************

Push_Client_State MACRO
	sub	esp, SIZE Client_Reg_Struc
	push	edi
	lea	edi, [esp+4]
	VMMcall Save_Client_State
	pop	edi
	ENDM

Pop_Client_State MACRO
	push	esi
	lea	esi, [esp+4]
	VMMcall Restore_Client_State
	pop	esi
	add	esp, SIZE Client_Reg_Struc
	ENDM

BeginDoc
;******************************************************************************
;
;   CallRet -- Call procedure and return.  For debugging purposes only.
;	       If compiled with debugging then this will generate a call
;	       followed by a return.  If non-debugging version then the
;	       specified label will be jumped to.
;
;   PARAMETERS:
;	Label_Name = Procedure to be called
;
;   EXIT:
;	Return from current procedure
;
;------------------------------------------------------------------------------
EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
	call	P2
ELSE
	call	P1
ENDIF
	ret
ELSE
	jmp	P1 P2
ENDIF
	ENDM


; ebp offsets to segments pushed by PMode_Fault in Fault_Dispatch
PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16


Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off

IFDIFI <Reg_32>, <EAX>
	push	eax
ENDIF
IFB <Cli_Off>
	mov	ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
	mov	ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
	VMMcall Map_Flat

IFDIFI <Reg_32>, <EAX>
	mov	Reg_32, eax
	pop	eax
ENDIF

	ENDM

;------------------------------------------------------------------------------

VxDint	MACRO	Int_Number
	push	DWORD PTR Int_Number
	VMMcall Exec_VxD_Int
	ENDM


ENDIF	; Not_VxD


BeginDoc
;******************************************************************************
;
;   The following equates are for flags sent to the real mode
;   initialization portion of a device driver:
;
Duplicate_Device_ID	    equ 0000000000000001b   ; duplicate device ID already
Duplicate_Device_ID_Bit     equ 	       0    ; loaded
Duplicate_From_INT2F	    equ 0000000000000010b   ; duplicate device ID already
Duplicate_From_INT2F_Bit    equ 	      1     ; loaded as part of INT 2F
						    ; device list
Loading_From_INT2F	    equ 0000000000000100b   ; this device was specified
Loading_From_INT2F_Bit	    equ 	     2	    ; in the INT 2F device list

EndDoc

BeginDoc
;******************************************************************************
;
;   The following equates are used to indicate the result of the real mode
;   initialization portion of a device driver:
;

Device_Load_Ok	    equ 0		; protected mode portion of device
					; should be loaded
Abort_Device_Load   equ 1		; don't load any protected mode portion
					; of this device, but continue loading
					; the rest of the devices
Abort_Win386_Load   equ 2		; fatal-error: abort the load of Win386

No_Fail_Message     equ 8000h		; The high bit is set in the return
No_Fail_Message_Bit equ 15		; code, if the loader should not print
					; any message for results
					; Abort_Device_Load or Abort_Win386_Load
;==============================================================================
EndDoc


;==============================================================================

; CR0 bit assignments
PE_Mask 	EQU	0001h	; 1 = Protected Mode
PE_Bit		EQU	0
MP_Mask 	EQU	0002h	; 1 = Monitor Coprocessor
MP_Bit		EQU	1
EM_Mask 	EQU	0004h	; 1 = Emulate Math Coprocessor
EM_Bit		EQU	2
TS_Mask 	EQU	0008h	; 1 = Task Switch occured
TS_Bit		EQU	3
ET_Mask 	EQU	0010h	; 1 = 387 present, 0 = 287 present
ET_Bit		EQU	4
PG_Mask 	EQU 80000000h	; 1 = paging enabled, 0 = paging disabled
PG_Bit		EQU	31


; EFLAGs bit assignments
CF_Mask 	EQU	000000000000000001b	; Carry flag
CF_Bit		EQU	0
PF_Mask 	EQU	000000000000000100b	; Parity flag
PF_Bit		EQU	2
AF_Mask 	EQU	000000000000010000b	; Aux flag
AF_Bit		EQU	4
ZF_Mask 	EQU	000000000001000000b	; Zero flag
ZF_Bit		EQU	6
SF_Mask 	EQU	000000000010000000b	; Sign flag
SF_Bit		EQU	7
TF_Mask 	EQU	000000000100000000b	; Trace flag
TF_Bit		EQU	8
IF_Mask 	EQU	000000001000000000b	; Int flag
IF_Bit		EQU	9
DF_Mask 	EQU	000000010000000000b	; Direction flag
DB_Bit		EQU	10
OF_Mask 	EQU	000000100000000000b	; Overflow flag
OF_Bit		EQU	11
IOPL_Mask	EQU	000011000000000000b	; IOPL flags
IOPL_Bit0	EQU	12
IOPL_Bit1	EQU	13
NT_Mask 	EQU	000100000000000000b	; Nested task flag
NT_Bit		EQU	14
RF_Mask 	EQU	010000000000000000b	; Resume flag
RF_Bit		EQU	16
VM_Mask 	EQU	100000000000000000b	; Virtual Mode flag
VM_Bit		EQU	17


;------------------------------------------------------------------------------
;
;	  Temporary MASM macros (to be removed when supported by MASM)
;
;------------------------------------------------------------------------------

loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>


;******************************************************************************
; PAGE TABLE EQUATES
;******************************************************************************


P_SIZE		equ	1000h		; page size

; ---------------------------------------------------
;
;	Page table entry bits
;
; ---------------------------------------------------

P_PRES		equ	01h		; page present bit
P_PRESBit	equ	0
P_WRITE 	equ	02h		; write access bit
P_WRITEBit	equ	1
P_USER		equ	04h		; access bit for User mode
P_USERBit	equ	2
P_ACC		equ	20h		; page accessed bit
P_ACCBit	equ	5
P_DIRTY 	equ	40h		; page dirty bit
P_DIRTYBit	equ	6

P_AVAIL 	equ	(P_PRES+P_WRITE+P_USER) ; avail to everyone & present

; ---------------------------------------------------
;
;  Page types - definition of the OS reserved bits in the page table
;		entry.
; ---------------------------------------------------

PG_TYPE 	equ	0E00h		; TYPE bits in PTE

; ---------------------------------------------------
;
;	 Page types for page allocator calls
;
; ---------------------------------------------------
PG_VM		equ	0
PG_SYS		equ	1
PG_RESERVED1	equ	2
PG_PRIVATE	equ	3
PG_RESERVED2	equ	4
PG_RELOCK	equ	5		; PRIVATE to MMGR
PG_INSTANCE	equ	6
PG_HOOKED	equ	7
PG_IGNORE	equ	0FFFFFFFFh


; ---------------------------------------------------
;
;	 Types for page table entries
;
; ---------------------------------------------------
PgT_VM		equ	PG_VM SHL 9
PgT_SYS 	equ	PG_SYS SHL 9
PgT_RESERVED1	equ	PG_RESERVED1 SHL 9
PgT_PRIVATE	equ	PG_PRIVATE SHL 9
PgT_RESERVED2	equ	PG_RESERVED2 SHL 9
PgT_RELOCK	equ	PG_RELOCK SHL 9
PgT_INSTANCE	equ	PG_INSTANCE SHL 9
PgT_HOOKED	equ	PG_HOOKED SHL 9



;******************************************************************************

; ---------------------------------------------------
;
; Definitions for the access byte in a descriptor
;
; ---------------------------------------------------


; Following fields are common to segment and control descriptors

D_PRES		equ	080h		; present in memory
D_NOTPRES	equ	0		; not present in memory

D_DPL0		equ	0		; Ring 0
D_DPL1		equ	020h		; Ring 1
D_DPL2		equ	040h		; Ring 2
D_DPL3		equ	060h		; Ring 3

D_SEG		equ	010h		; Segment descriptor
D_CTRL		equ	0		; Control descriptor

D_GRAN_BYTE	equ	000h		; Segment length is byte granular
D_GRAN_PAGE	equ	080h		; Segment length is page granular
D_DEF16 	equ	000h		; Default operation size is 16 bits
D_DEF32 	equ	040h		; Default operation size is 32 bits


; Following fields are specific to segment descriptors

D_CODE		equ	08h		; code
D_DATA		equ	0		; data

D_RX		equ	02h		; if code, readable
D_X		equ	0		; if code, exec only
D_W		equ	02h		; if data, writable
D_R		equ	0		; if data, read only

D_ACCESSED	equ	1		; segment accessed bit


; Useful combination access rights bytes

RW_Data_Type equ (D_PRES+D_SEG+D_DATA+D_W)
R_Data_Type  equ (D_PRES+D_SEG+D_DATA+D_R)
Code_Type    equ (D_PRES+D_SEG+D_CODE+D_RX)

D_PAGE32	equ	(D_GRAN_PAGE+D_DEF32)		  ; 32 bit Page granular

; Masks for selector fields

SELECTOR_MASK	equ	0fff8h		; selector index
SEL_LOW_MASK	equ	0f8h		; mask for low byte of sel indx
TABLE_MASK	equ	04h		; table bit
RPL_MASK	equ	03h		; privilige bits
RPL_CLR 	equ	not 03h 	; clear ring bits
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\auxputs.asm ===
; ========================================================

COMMENT #

	AUXPUTS.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	Outputs a string to the STDAUX device. (com1)

	void AuxPuts( char *Str )

	ARGUMENTS: Str	- Ptr to string to display
	RETURNS:   void

	johnhe - 02/24/90

END COMMENT #

;========================================================

include BIOS_IO.INC

include	MODEL.INC

; ========================================================

.CODE

; ========================================================

IF @DataSize
	AuxPuts PROC  USES DS, Str:PTR
ELSE
	AuxPuts PROC Str:PTR
ENDIF
	mov	AX,40h			; DOS write file

	LoadPtr	DS DX Str
	mov	BX,3			; AUX handle
	int	21h
	ret

AuxPuts ENDP

; ========================================================

	PUBLIC GetCallerAddr
GetCallerAddr:

	mov	AX,[BP+2]
	ret

; ========================================================

END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\bios_io.asm ===
; ========================================================

COMMENT #

	BIOS_IO.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	johnhe - 03/03/89

END COMMENT #

;========================================================

include BIOS_IO.INC
include	MODEL.INC

;========================================================

.CODE

; ========================================================
; New int 1bh and 23h which just do an iret
; ========================================================

	public NewInt1b
NewInt1b LABEL FAR

	public NewInt23
NewInt23 LABEL FAR

	iret
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\model.inc ===
; ========================================================================
call_M	MACRO	Function

IF 	@codesize			; Call adjusted for memory model

	call	FAR PTR Function	; FAR call if LARGE, MED, or HUGE
ELSE
	call	NEAR PTR Function	; Else NEAR call
ENDIF
ENDM

; ========================================================================

DOSSEG

IFDEF  MODEL_SMALL
.MODEL	LARGE,C
ENDIF

IFDEF	MODEL_COMPACT
.MODEL  COMPACT,C
ENDIF

IFDEF  MODEL_MEDIUM
.MODEL	MEDIUM,C
ENDIF

IFDEF  MODEL_LARGE
.MODEL	LARGE,C
ENDIF

; ========================================================================
; LoadPtr
;
;	Macro to load a pointer based on the memory model that is in use.
;	Argument checking is included in the macro and the appropriate
;	error message will be displayed.
;	
; LoadPtr MACRO vSegReg, vReg, vPtr
;
;	vSegReg		- Segment register ( ES or DS )
;	vReg		- Any general purpose register (AX,BX,CX,DX,SI,DI)
;	vPtr		- Pointer to a memory location.
;			  The value will be treated as a dword ptr in
;			  LARGE/COMPACT model and word ptr in MEDIUM/SMALL.
;
; ========================================================================


LoadPtr MACRO vSegReg, vReg, vPtr

  SEG_OK = 0			;; Variables to specify different errors
  REG_OK = 0
  PTR_OK = 0

				;; Error checking on segment register
  IFNB <vSegReg>
    IRP x, <ES,DS>
      IFIDN <x>,<vSegReg>
        SEG_OK = 1
      ENDIF
    ENDM 
  ENDIF

				;; Error checking on index register
  IFNB <vReg>
    IRP y, <AX,BX,CX,DX,SI,DI>
      IFIDN <y>,<vReg>
        REG_OK = 1
      ENDIF
    ENDM 
  ENDIF

				;; Error checking on memory pointer
  IFNB <vPtr>
    PTR_OK = 1
  ENDIF

				;; If errs found display appropriate message
  IF (SEG_OK + REG_OK + PTR_OK) NE 3

    IF SEG_OK EQ 0
      %out <LoadPtr Macro --> Invalid segment register vSegReg was specified.>
    ENDIF

    IF REG_OK EQ 0
      %out <LoadPtr Macro --> Invalid register vReg was specified.>
    ENDIF

    IF PTR_OK EQ 0
      %out <LoadPtr Macro --> No memory pointer was specified.>
    ENDIF

    .ERR

  ELSE			;; Start of code in the macro since no errs found

    IF @DataSize	;; For LARGE & COMPACT models use LDS or LES  opcodes
			
      IFIDN <vSegReg>,<DS>
        lds	vReg, vPtr
      ELSEIFIDN <vSegReg>,<ES>
        les vReg, vPtr
      ENDIF

    ELSE
			;; If vSegReg == ES we have to set ES to DATA SEG
      IFIDN <vSegReg>,<ES>
        push	DS
        pop	ES
      ENDIF
			;; Load pointer into specified register
      mov  vReg, vPtr	

    ENDIF

  ENDIF

ENDM


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\catalog.c ===
/****************************************************************************/
	int AbsReadWrite( int Drive, struct ABSIO_PACKET far *absPack,
	  		int ReadWrite );

	INCLUDE: DISK_IO.H

	LOCATION: \DISK\ABS_RDWR.ASM


	ARGUMENTS: 
			absPack - Ptr to DOS 4.x int 25,26 access packet
			Drive	- Drive number (A=0,B=1,C=2,...)
			ReadWrite-	Flags whether to do a read or write
		   		  		operation: 0  = READ, !0 = WRITE
	RETURNS:	
			int - 0 if successful else error code

	Does an absolute sector read or write using int
	25h or 26h. Special care is taken to be sure the
	function will work under any version of DOS
	2.0 - 4.x.
/****************************************************************************/




/****************************************************************************/
	void AuxPuts( char *Str )

	INLCUDE: BIOS_IO.H

	LOCATION: \BIOS\AUXPUTS.ASM
	

	ARGUMENTS: Str	- Ptr to string to display
	RETURNS:   void

	Outputs a string to the STDAUX device. (com1)

/****************************************************************************/





/***************************************************************************/
	int BigReadWrite( int iFile, char far *Buf, long lBytes, int RdWr )

	INCLUDE: FILE_IO.H

	LOCATION: \FILE\F_RDWR.C	
																						
	ARGUMENTS:	iFile - Open DOS file handle, file pointer must be set	
							 	to position for start of read or write				
					*Buf - buffer to read to or write from
					lBytes - Number of bytes to read or write						
					fRdWr - Flags 0 for read and 1 for write						
	RETURN:		int 	- OK if no error - ERROR if read or write error		
																								

	Reads or writes a requested number of bytes into a specified buffer. 	
	The number of bytes requested may be > 64K without causing a problem.	

/***************************************************************************/




/***************************************************************************/
	BuildDosPartEntry( struct PartMap *Map, struct HdParms *Parms,				
					 	struct Part *PartEntry )											
																								

	INCLUDE: HDISK.H

	LOCATION: \HDISK\MAKEPART.C

						
	ARGUMENTS:	Map		- Ptr partition map entry									
					Parms		- Ptr to an initialize hard disk parameters struct	
					PartEntry- Ptr to partitin entry to be filled in				
	RETURNS:		void																			
				  

	Builds a DOS paritition entry from a partition map entry. Determines 	
	the type of DOS partition needed based on the number of sectors in the	
	partition area. To be compatible with all previous versions of DOS the	
	partition will start the first sector of a cylinder and end on the last 
	sector of a cylinder.																	
																				
	NOTE: Must remember that heads and cylinders are 0 based while sectors	
			are 1 based.																		
																								
	Head = ((AbsSector % SectorPerTrack) * NumberOfHeads) / SectorsPerTrack	
	Track =	AbsSector / ( NumberOfHeads * SectorsPerTrack )						
	Sector = (absSector % SectoPerTrack) + 1											
																								
/***************************************************************************/




/***************************************************************************/
	void BuildPath( char *szPath, char *szDirPath, char *szFileName ) 		
																								
	INCLUDE: STRLIB.H
	
	LOCATION: \STRLIB\BLDPATH.C

	
	ARGUMENTS:	szPath	-  Buffer to hold the created pathname					
					chDrive	-	Drive designator											
					szDirPath -	Pointer to drive and directory path					
					szFileName - Pointer to a file name									
	RETURNS: 	void																			


	Builds a valid path name when given the 3 elements of drive, path and	
	file name along with a buffer for the created path.
																								
/***************************************************************************/






/***************************************************************************/
	BuildPartMap( struct Part *Part, struct PartMap *Map,							
						 	struct HdParms *Parms )										

	INCLUDE: HDISK.H

	LOCATION: \HDISK\PARTMAP.C

						 
	ARGUMENTS:	Part	- Ptr to partition entry table to build the map from	
					Map	- Ptr to array of at least 9 partition map structures	
					Parms - Ptr to hard disk parameter structure 					
	RETURNS:		void																			
																								

	Builds a map of the entire partition layout of a hard disk. The map is	
	sorted by physical starting disk sectors and contains all free and		
	allocated areas of the disk.															
	
/***************************************************************************/




/***************************************************************************/
	int CenterLength( int iStrLen )														

	INCLUDE: WINDOW.H

	LOCATION: \WINDOW\W_CENTER.C
																								
	ARGUMENTS:	int iStrLen - The lenght of a string to be centered on 		
									  the current display.									
	RETURNS:		int - Starting column to make the string centered	
																								

	Function to return the starting column of a string consisting of StrLen 
	number of characters for the string to be centered on a line of the     
	current screen. The function will adjust current width of the screen.   
	
/***************************************************************************/




/***************************************************************************/
	int CenterStr( char *szString )														
				 
	INCLUDE: WINDOW.H
																			
	LOCATION: \WINDOW\W_STRCEN.C

	ARGUMENTS:	szString - pointer to a string                              

	RETURNS:	int column number which causes the string to be centered		

	Returns the display column which cause the string passed as an argument 
	to be displayed centered on the screen. 										   
/***************************************************************************/





/***************************************************************************/
	int CheckDBCSTailByte (unsigned char *str,unsigned char *point)

	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\DBCS.C


	input:	*str = strart pointer of the string
				*point = character pointer to check
	output:	TRUE if at the tail byte


	Check if the character point is at tail byte
/***************************************************************************/




/****************************************************************************/
	int CheckDmaBound( void far *Buffer, unsigned Bytes )

	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\DMA_CHK.ASM
	
	ARGUMENTS:	Buffer	- Ptr to memory area
					Bytes	- Lenght of memory area in byts
	RETURN:	int - OK if not on boudary else !OK

	Checks to see if an area of memory will cross a DMA
	boundary. Returns OK if not on a boundary else return
	!OK.
/****************************************************************************/




/***************************************************************************/
	int CheckForMouseDriver ( void )

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\MOUSEDRV.ASM

	EXIT: int: 1 if mouse driver is installed, 0 otherwise

	Checks if a mouse driver has been installed.
/***************************************************************************/





/***************************************************************************/
	char	ChipTechVGA(void);

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\VIDTEST.ASM


	EXIT:
     	- TRUE if C & T VGA is present, FALSE otherwise

	Returns true if we have a Chips and Technologies 441 VGA.
	Before calling this routine confirm we have a VGA from VideoAdapter()
	This routine should be used only to distinguish IBM VGA from C&T VGA.

/***************************************************************************/





/***************************************************************************/
	void CreateMapEntry( struct PartMap *Map, struct Part *Part )				
																								
	INCLUDE: HDISK.H

	LOCATION: \HDISK\MAP_ENT.C


	ARGUMENTS:	Map	-	Ptr to partition map structure							
					Part	-	Ptr to partition table entry								
	RETURNS: 	void																			
																								

	Creates a partition map entry from a partition entry structure.			

/***************************************************************************/





/***************************************************************************/
	int CreatRoot( int iDrv, struct BPB *Bpb )										
													  
	
	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\DSK_ROOT.ASM
										
	ARGUMENTS:	iDrv	-	Physical drive number										
					Bpb	-	Bpb structure for disk in the drive						
	RETURNS:		int	-	OK if successful												

	Creates an empty root directory on the specified drive using the			
	specified BPB for the size and location.
/***************************************************************************/




/***************************************************************************/
	unsigned char *DBCSstrchr(unsigned char *str,unsigned char c)

	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\DBCS.C


	ENTRY: str - string to search for character
			 c -- character to search for

	EXIT:  pointer to first occurence of character if succesful, NULL otherwise


	Does a DBCS enabled strchr to find the first occurence of a character
	in a string.

/***************************************************************************/





/***************************************************************************/
	unsigned char	*DBCSstrupr(unsigned char *str)

	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\DBCS.C


	ENTRY: String to convert to upper case.

	EXIT: Pointer to string that was passed in.

	Does a DBCS enabled strupr.

/***************************************************************************/





/***************************************************************************/
	int  detect8514(void);

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\VIDTEST.ASM


	EXIT: True if 8514 display card is present and contains proper memory 
      	configuration, False otherwise.


	This function detects the presence of an 8514 display card.
	The way we do this is to first write to the Error Term Register and then
	make sure we can read back the value we wrote. Next I read in the value of
	the subsystem status register and check bit 7 to determine if the 8 plane
	memory configuration is present. Only if both these conditions are
	satisfied will we install the 8524 display driver.

/***************************************************************************/




/***************************************************************************/
	void DisplayScreenHeader( void )														
																								
	INCLUDE: BIOS_IO.H

	LOCATION: \PROMPTS\HEADER.C


	ARGUMENTS:	NONE																			

	RETURNS:		void 																			
																								
	EXTERNS:		HelpHeaderText - Both declared in EXTERN.C						
					HeaderText;																	
																								

	Displays the header and title at the top of the screen in the proper		
	color as defined by the macro GetHeaderColor().									
					
/***************************************************************************/




/***************************************************************************/
	void DisplayText( char *szText[], int StartRow  )						
		  
	INCLUDE: BIOS_IO.H
	
	LOCATION: \PROMPTS\DISPLAY.C
																				
	
	ARGUMENTS:	szText		- array of pointers to strings. Last element		
									  	should be a NULL pointer. (max 9 strings)		
					StartRow		- Screen row where text starts						
	RETURNS:		void																			
																								

	Displays multiple lines of text on the screen starting at the specified	
	row. 
	
/***************************************************************************/




/***************************************************************************/
	void DisplayTitle( char *szTitle )													
		
	INCLUDE: HDISK.H

	LOCATION: \HDISK\DISPLAY.C

																				
	ARGUMENTS:	szTitle	- Ptr to string to be displayed.							
	RETURNS:		void																			
	
	
	Displays a string centered horizonally on the screen starting at			
	the position specified by the #define TITLE_ROW.								
																				
/***************************************************************************/






/****************************************************************************/
	void DoInt2f( unsigned Percent );


	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\DOINT2F.ASM

	
	ARGUMENTS: Percent - Percentage of format complete
	
	RETURNS:   void

	Does an int 2f with AX = 4400h to update the format
	complete gage. This function is mainly for getting
	the gage setup before the format program is spawned.

/****************************************************************************/




/****************************************************************************/
	int	_dos_dskreset( void )

	LOCATION: \DISK\DSK_RSET.ASM

	RETURNS: nothing

	Instructs DOS to do a reset of all it's disk buffers.

/****************************************************************************/


/****************************************************************************/
	int _dos_getdir( char far *Buffer, int Drive );

	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\GET_DIR.ASM

	ARGUMENTS:	Buffer - Ptr to 64 byte memory	area
					Drive	- DOS drive number (0=default, 1=A, 2=B, ...)
	RETURN: 	int	- 0 if successfull else, !0 if error

	Gets the current directory path from DOS.
				  
/****************************************************************************/	


/****************************************************************************/
	long	_dos_seek( int Handle, long lOffset, int Mode )

	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\DOS_SEEK.ASM
	
	ARGUMENTS:	Handle	- Open DOS file handle
					lOffset - Offset to seek to in bytes
					Mode - Seek mode as described below
			  			0 = Beginning of file + offset
			  			1 = Current file position + offset
			  			2 = End of file + offset
	RETURNS:	long	- New offset in file is success
   		  	or -1L if error
/****************************************************************************/




/****************************************************************************/
	void EnableDiskAccess( unsigned char Drive )

	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\DRV_ACC.ASM

	ARGUMENTS: Drive - DOS drive letter (A=0, B=1, C=2, ...)
	RETURNS:   VOID

	Sets the drive access bit using undocumented
	function SET_ACCESS_FLAG (47h) of IOCtrl function
	44h.
/****************************************************************************/



/***************************************************************************/
	void Error( char **ErrorString )													
																								
	INCLUDE: BIOS_IO.H

	LOCATION: \PROMPTS\ERROR.C
	
	
	ARGUMENTS:	ErrorString 	- 		pointer to string identifing the error.
					CorrectionString - pointer to string detailing the error    
	RETURNS: 	void                                                        
																								
	EXTERNS:		ErrorMessageText	- Declared in EXTERN.C							
																								

	Non-fatal error function. An array of pointers to a string defining the 
	error and a pointer to a string suggesting a possible correction. Will  
	display an error message in a window on the screen and wait for a any   
	key to be pressed. A buffer to store the orginal contents under the     
	error window must be allocated at the start of the program since there  
	is no guarentee that there will be sufficient memory available when the 
	the error function is called.                                           

/***************************************************************************/





/***************************************************************************/
	void ExtractNextWord( char *szStr, char *szBuffer, int iBufLen )			
	
	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\NEXTWORD.C
	
																					
	ARGUMENTS:	szStr - Ptr to string to parse word from						
					szBuffer - Buffer to copy the word into							
					iBufLen	- Total length of the buffer in bytes					
	RETURNS: 	void																			
																								

	Copies the first word from a string into a buffer with a specified max	
	length.																						
/***************************************************************************/






/****************************************************************************/
	int FcbParse( char far *OldName, struct FCB far *Fcb );

	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\FCB_PARSE.ASM
	
	ARGUMENTS:	OldName - Ptr to string to parse
			Fcb	- Ptr to FCB struct to store
				  parsed name and drive.
	RETURNS:	int	- 00 - No wild card characters
				  01 - Wild card characters used
				  -1 - Invalid drive or filename

	Uses DOS FCB call 29h to parse a file name

	The following rules are observed based on the filename
	string argument. These are specifed by the bits in AL.
	when the int 21h is done.

	0. Ingores leading filename seperator
	1. Sets the drive number to 0 if not found in string
	2. Sets the filename to blanks if filename == ""
	3. Sets the file extension to blanks if not found
/****************************************************************************/



/****************************************************************************/
	int FcbRename( struct FCB far *Fcb );
	
	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\FBC_REN.ASM

	ARGUMENTS:	Fcb	- Ptr to Special FCB structure of
				  the following form.

			BYTE(s) - CONTENTS
			0h	  - Drive number
			01h-08h - Old file name, padded with blanks
			09h-0bh - Old file ext., padded with blanks
			0ch-10h - All zeros
			11h-18h - New file name, padded with blanks
			19h-1bh - New file ext., padded with blanks
			1ch,24h - All zeros

	RETURNS:	int	- 0 if successfull else -1

	Uses DOS FCB call 17h to rename a file.
/****************************************************************************/






/***************************************************************************/
	int FindExtMatch( char *szFile, char **szExt )									
 
	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\MATCHEXT.C

																								
	ARGUMENTS: szFile - Ptr to filename to chech for a matching extension	
	RETURNS: int	 - Index to matching extension in the list or -1		
																								

	Checks a file name to see if it's extension exists in a list of         
	different extensions. Returns the index to the first matching extension 

	NOTE: the filename may consist of the full path to the file.				
/***************************************************************************/






/***************************************************************************/
	int FileExists( char *szFile )														
				 
	INCLUDE: FILE_IO.H
																			
	LOCATION: \FILE\F_EXISTS.C
	
	ARGUMENTS:	szFile		- Ptr to full path name for file to be found 	
	RETURNS: 	int			- TRUE if file was found else FALSE 				

	Determines if the specified file exists.											

/***************************************************************************/





/***************************************************************************/
	int FindMaxFreePart( struct PartMap *Map )										
	
	INCLUDE: HDISK.H

	LOCATION: \HDISK\FINDPART.C

																							
	ARGUMENTS:	Map	- Ptr to partition map											

	RETURNS:		int	- Index to largest free area in the map or -1 if no	
						  	free area is found												
																								
	Scans a partition map and returns the index to the largest free area.	
	If no free partition area is found it returns -1. 
								
/***************************************************************************/





/***************************************************************************/
	int FindParam( char *szStr, char ch )												
  
	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\FINDPARM.C

																								
	ARGUMENTS:	szStr 	- Ptr to string to be searched							
					ch 		- Parameter	character to search for 					
	RETURNS: 	int		- TRUE if search parameter	is found else false		
	
																							
	Searches a string for the specified character prefixed with a forward	
	slash character. The search for the parameter is not case sensitive. 	

/***************************************************************************/





/****************************************************************************/
	int FindString( char *Buffer, char *String, unsigned BufferSize );
 

	
	ARGUMENTS:
		Buffer  - The buffer to search
		String  - The zero terminated string to search for
		Count   - The length of the buffer in bytes
	RETURNS:
		 0 if succesful or -1 otherwise

	Quickly searches for a string in a buffer of any type of
	data. The search is case sensitive.

/****************************************************************************/





/***************************************************************************/
	void FmtStat( unsigned uTrack, unsigned uHead )									

	INCLUDE: BIOS_IO.H

	LOCATION: \PROMPTS\FMTSTAT.C

																								
	ARGUMENTS:	uTrack	- Specifies the current track being formatted or	
							  	if -1 signals a popup window should be removed	
					uHead		- Specified the cureent head being formatted or		
							  	if -1 signals a popup window should be displayed	
	RETURNS:		void																			
																								
	EXTERNS:		FmtStatText	- Declared in EXTERN.C as FMT_STAT_TEXT.			
																								

	This function is passed as an argument to the floppy disk format			
	which will call it indirectly to allow displaying the status of the 		
	formatting operation. The uTrack and uHead arguments specify the status	
	and are also used to indicate if the temporary window should be			
	displayed or removed.																	

/***************************************************************************/





/****************************************************************************/
	int	fnGetVideoInfo(void);

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\VIDTEST.ASM
	
	
	EXIT:
      	1 - CGA
      	9 - MCGA
      	8 - EGAHIRES_MONO
      	7 - EGA_COLOR
      	5 - VGA
     		-1 - FAILED
     		-2 - unknown value in BL after the first test.


	Determine the display adapter type using Int 10h function 1Bh.

/****************************************************************************/





/***************************************************************************/
	int FormatFloppy( unsigned uDrv, int iFmt, void (*vStatus)( int, int ))
																								
	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\NEWFMT.C

	ARGUMENTS:	uDrv		Physical drive letter to format the disk on			
								which must be a floppy drive.								
					iFmt		Layout of the disk from the table above.				
					vStatus  Pointer to a function which will be called for		
								each time a track is formatted with the arguments	
								specifing the current track and head.					
																								
	RETURNS:		A valid error code or OK (0) if format was successfull.		
					The error code are the same as those returned by an iotcl	
					format.																		

	Formats a floppy diskette using int 13h function calls. Caller must		
	specify the drive number of 0 - 7fh and disk layout via a disk type of	
	0 - 6 as reflected in the table below.												
																								
	-------------------------------------------------------						
	0 | 160K  - 40 tracks - 08 sectors per track - 1 head							
	1 | 180K  - 40 tracks - 09 sectors per track - 1 head							
	2 | 320K  - 40 tracks - 08 sectors per track - 2 heads						
	3 | 360K  - 40 tracks - 09 sectors per track - 2 heads						
	4 | 720K  - 80 tracks - 09 sectors per track - 2 heads						
	5 | 1.2M  - 80 tracks - 15 sectors per track - 2 heads						
	6 | 1.44M - 80 tracks - 18 sectors per track - 2 heads						
																								
																								
/***************************************************************************/





/****************************************************************************/
	int GetBootSector( int Drive, char far *Buffer )
	
	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\GET_BOOT.ASM
	

	ARGUMENTS:	Drive	- Physical drive number
			Buffer	- Ptr to sector size buffer

	RETURNS:	int	- OK (0) if successfull
				  else error code

	Reads the boot record on the first sector of the
	specified drive into the specified buffer
/****************************************************************************/






/****************************************************************************/
	int GetBreakSetting( void );

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\CTRLBRK.ASM

	ARGUMENTS:	NONE
  
	RETURNS:	int	- 0 if check is off else 1

	Returns the setting of DOS's internal Ctrl C check.

/****************************************************************************/





/****************************************************************************/
	unsigned GetConvMem( void );

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\GETMEM.ASM

	ARGUMENTS:	NONE

	RETURNS:	unsigned - Kbytes of convential memory

	Returns number of Kbytes of convential memory which is returned by int 12h.
/****************************************************************************/





/****************************************************************************/
	unsigned GetModelBytes( void );

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\GETMODEL.ASM

	ARGUMENTS:	NONE

	RETURNS:	unsigned - model byte in MSB
                       sub-model byte in LSB

	Returns model bytes as returned by int 15h, function c0h.
/****************************************************************************/





/****************************************************************************/
   unsigned IsConvertible( void );

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\GETMODEL.ASM

	ARGUMENTS:	NONE

	RETURNS:	unsigned - 1 if system is an IBM PC Convertible,
                       0 if not

   Checks model byte.
/****************************************************************************/





/****************************************************************************/
	void GetCountryInfo( struct COUNTRY_INFO *Cntry );

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\COUNTRY.ASM
	
	ARGUMENTS: Cntry - Ptr to 34 byte buffer
	
	RETURNS:   void

	Fills in a country information structure

/****************************************************************************/




/****************************************************************************;   _A386machine - return type of processor (386 vs. 8088/86/286).
	int GetCpuType( void );

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\GETCPU.ASM


	ENTRY:  (none)
	EXIT:   0 == 8086, 1 == 80286, 2 == 80386

	This routine relies on Intel-approved code that takes advantage
	of the documented behavior of the high nibble of the flag word
	in the REAL MODE of the various processors.  The MSB (bit 15)
	is always a one on the 8086 and 8088 and a zero on the 286 and
	386.  Bit 14 (NT flag) and bits 13/12 (IOPL bit field) are
	always zero on the 286, but can be set on the 386.

	CALLABLE FROM REAL MODE ONLY - near ROUTINE
/****************************************************************************/



/***************************************************************************/
	int GetDisketteType( int Drv )														
	
	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\DSK_TYPE.C

																	
	ARGUMENTS:	Drv		- Drive letter to check										
	RETURNS:		int		- Type of diskette											
							  	1 == 360K														
							  	2 == 720K														
							  	3 == 1.2M														
							  	4 == 1.44M										
			
	Returns the type of diskette in the specied floppy drive.		
							  
/***************************************************************************/





/***************************************************************************/
	long GetDiskFree( int DrvLetter )													
	
	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\DSK_FREE.ASM
																			
	
	ARGUMENTS:	DrvLetter - DOS drive letter										
	RETURNS:		long - Number of free bytes for the specified disk	
					    	or -1L if there is an error reading the disk	

	Returns the number of free bytes on the specified disk. Uses DOS get		
	disk free call for information about the disk and then calculates the	
	number of free bytes.								  
/***************************************************************************/




/***************************************************************************/
	int GetDiskHead( unsigned uSec, struct BPB *Bpb )								
																								
	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\DSK_HEAD.C

	
	ARGUMENTS:	uSec		- Absolute disk sector										
					Bpb		- Ptr to BPB structure for disk being accessed.		
	RETURNS:		int		- The drive head which corresponds to uSec			

	Calculates the drive head which will access an absolute sector on			
	a disk.																						
/***************************************************************************/




/***************************************************************************/
	int GetDiskTrack( unsigned uSec, struct BPB *Bpb )								
									  
	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\DSK_TRK.C


	ARGUMENTS:	uSec		- Absolute disk sector										
					Bpb		- Ptr to BPB structure for disk being accessed.		
	RETURNS:		int		- The drive track which corresponds to uSec			

	Caculates the track that an absolute sector is on.
																								
/***************************************************************************/


/***************************************************************************/
	int GetDisplayID(int MachineId)														
				 
	INCLUDE: BIOS_IO.H
																			
	LOCATION: \HARDWARE\VIDEO_ID.C

	Will return display type. Requires machineid.									
																								
	ENTRY: None 																				
	EXIT:	Returns Video adapter type 													
																								
/***************************************************************************/


/****************************************************************************/
	int GetDosDataVersion( void );


	INCLUDE: BIOS_IO.H


	LOCATION: \BIOS\DATAVERS.ASM
	
	
	Returns the DOS Data version from DOSDATA:04h

/****************************************************************************/


/****************************************************************************/
	int GetDrvParms( struct HdParms *Parms, int DrvNum )

	INCLUDE: HDISK.H

	LOCATION: \HDISK\HD_PARMS


	ARGUMENTS:	Parms	- Ptr to hdParms structure
					DrvNum	- Physical hard disk number
	RETURNS:	int	- 0 if successful
				- !0 if error (invalid drive)


	Gets the drive parameters for the specified hard
	and uses them to fill in the HdParms structure
	passed as an argument.

/****************************************************************************/





/****************************************************************************/
	int GetDriveType( unsigned char Drive, void far *Buffer )

	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\DRV_TYPE.ASM

	ARGUMENTS: Drive	- Physical drive number
		Buffer	- Ptr to work buffer at least 100 bytes

	RETURNS:	Drive type as defined by int 13h function 8.
		1	   360K   5.25"
		2	   1.2M   5.25"
		3	   720K   3.5"
		4	   1.44M  3.5"

	Determines the type of drive installed.
/****************************************************************************/




/***************************************************************************/
	unsigned GetExtMemSize ( void )

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\CMOS.ASM

	EXIT: extended memory amount

	Gets extended memory amount.
/***************************************************************************/



/***************************************************************************/
	int GetHelpFlags( void )																
							
	INCLUDE: HDISK.H

	LOCATION: \HDISK\DISPLAY.C

																	
	ARGUMENTS:	void																			

	RETURNS:		int - Bit flags specifing the current messages.			
																								

	Returns a bit flag of the current help line that is displayed on the 	
	bottom of the screen.

/***************************************************************************/





/***************************************************************************/
	long GetMaxHugeSize( void )															
	
	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\MAXHUGE.C

																							
	ARGUMENTS:	NONE
																			
	RETURNS:		long - Number of bytes of huge memory avaiable			
																								

	Returns the size of the max block of huge memory that is available. The	
	amount available is determined doing a DOS call to allocate the largest	
	block avaliable and then freeing the allocated block and returning the	
	the size of the block that was allocated.											

/***************************************************************************/






/****************************************************************************/
	unsigned GetMemoryFree( void )

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\MEMFREE.ASM


	EXIT: Number of free memory paragraphs available as a contiguos block
			from DOS


/****************************************************************************/




/***************************************************************************/
	void GetMessage( char **apszArray, unsigned uOffset )							
	
	INCLUDE: BIOS_IO.H

	LOCATION: \PROMPTS\MESSAGE.C

																							
	ARGUMENTS:	apszArray	- Array to hold the string pointers.				
					uOffset		- The offset of the first string in the			
								  	MESSAGE.TXT file as defined in the MESSAGE.H	
								  	file.														
	RETURNS:		void																			
																								
	EXTERNS:		chMessage	- First character in message area declared in 	
								  	MESSAGE.ASM by the message compiler.				

	Builds an array of pointers to the strings starting at a specified		
	offset. The caller should get the offset from the #defines in the			
	MESSAGE.H file which is created by the INDEX.EXE program. The the			
	array passed as argument should be long enought to hold the number		
	of lines store at the specified offset, this value is also generated		
	by the INDEX.EXE program and is included in the MESSAGE.H file. A NULL	
	pointer will be added to the array after the pointer to the last string	
	in the specified group.		 
															
/***************************************************************************/




/***************************************************************************/
	void GetMessStr( char *szBuf, unsigned TextOffset, int StrNum )			
		  
	INCLUDE: BIOS_IO.H

	LOCATION: \PROMPTS\MSTRING.C

																						
	ARGUMENTS:	szBuf 		- Ptr to buffer to copy the specified string to 
					TextOffset	- String group offset in the message file 		
					StrNum		- The group string number to get 					
	RETURNS: 	void																			
																								

	Copies a single string from the message area to the user's buffer.      

/***************************************************************************/






/****************************************************************************/
	int GetModelBytes	( void )

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\GETMODEL.ASM

	EXIT: int- hight byte contains model byte, low byte contain sub model

	Does INT 15h fuction C0h to determine the system model.
/****************************************************************************/




/****************************************************************************/
	int GetMouseID( void );

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\MOUSEID.ASM

	EXIT: mouse type -- UNKNOWN_MOUSE = 0, BUS_MOUSE = 1, SERIAL_MOUSE = 2,
	   	INPORT_MOUSE = 3, IBMPS2_MOUSE = 4, HP_MOUSE = 5, NO_MOUSE = 6

	Uses Int 33 to determine the mouse type.
/****************************************************************************/



/***************************************************************************/
	int GetNumHardDisks( void )

	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\GETNUMHD.ASM
	
	ARGUMENTS:	NONE
	RETURN: 	int	- Number of hard disks installed

	Returns the total number of hard disks installed
	in the system as reported by the ROM BIOS at
	boot time.
/***************************************************************************/



/****************************************************************************/
	int	GetNumberOfDrives( void );

	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\NUMDRVS.ASM
	
	ARGUMENTS:	NONE
	RETURN: 	int	- Number of drives installed

	Uses int 11h to return the total number of floppy
	drives in the system as reported by the ROM BIOS
	at boot time.
/****************************************************************************/




/***************************************************************************/
	int GetNumberStrings( char **Strings ) 											
 
	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\NUMSTRS.C

	ARGUMENTS:	Strings	- Array of pointers to strings							
	
	RETURNS: 	int		- Total number of strings									


	Returns the number of strings in a array of strings. The last element   
	of the array must be a NULL pointer.                                    
/***************************************************************************/





/***************************************************************************/
	int GetOemDisplayID( void )															
																									
	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\VIDEO.ASM
	
	ENTRY: None 																				
	
	EXIT:	Returns Video adapter type 													
			0 = MONO																				
			1 = CGA																				
			2 = EGA																				
			3 = VGA																				
			4 = HERCULES																		
	
	Will return display type. Requires machineid.									
/***************************************************************************/






/***************************************************************************/
	void GetPathStrings( char **apszPaths, char *chBuffer )						
	
	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\PATHS.C

																							
	ARGUMENTS:	apszPaths	- Array of pointers to be filled in					
					chBuffer		- Buffer to copy the string into						
	RETURNS:		void																			

	Gets the PATH variable from the enviroment and then copies it to a		
	specified buffer and seperates the string into individual paths and		
	fills in an array of pointers to the beginning of each string.				
/***************************************************************************/





/***************************************************************************/
	int GetResponse( int ValidResponse[] )												

	INCLUDE: WINDOW.H

	LOCATION: \WINDOW\W_RESPON.C

	ARGUMENTS:	ValidResponse - Array of valid keystrokes                  

	RETURNS: 	int - User's validated input                     


	Waits for a character to input by the user. The inputted character must 
	match a character in the argument array or an error beep will be        
	sounded. If the first element of the argument array is 0 the function   
	will accept any keystroke as a valid character and return. Case of the  
	characters in not consider as everything is converted to uppercase.     
																								
/***************************************************************************/







/***************************************************************************/
	unsigned long GetTotalHdSectors( struct HdParms *Parms )									
																								
	INCLUDE: HDISK.H

	LOCATION: \HDISK\GETSEC.C


	ARGUMENTS:	Parms 			- Ptr to hard disk parameters structure		
	RETURNS: 	unsigned long	- Total physical sectors on the hard disk		
																								

	Calculates the total sectors on a hard disk based on the values in a 	
	hard disk parameters structure.														


	NOTE: 																						
			Need to remember that heads and cylinders begin with 0 and			
			sectors begin with 1.															
																								
/***************************************************************************/




/***************************************************************************/
	int GetWinInfo( char **String, WINDOW *Window ) 								

	INCLUDE: WINDOW.H

	LOCATION: \WINDOW\W_SIZE.C
																						
	ARGUMENTS:	Strings	-	Array of pointers to strings (NULL terminated)	
					Window	- Pointer to a WINDOW structure to be initialized	
	RETURNS:		int		- Number of strings which will fit in the window	


	Initializes a specified window structure based on the number and			
	length of an array of strings.														
																								
/***************************************************************************/





/****************************************************************************/
	int HardMouseDetect(void);

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\MOUSE.ASM
	
	
	EXIT: int -- mouse type or -1 if the hardware will not support mouse detection.     

	ALTERS  AX, BX, CX, DX, SI, DI


	This procedure what type of mouse is being used. It will determine
	that that type of mouse is present in the system and is working
	properly.  It calls: TestForInport, IRQAvailable, TestForBus, TestForSerial
	and TestForPS2

/****************************************************************************/




/***************************************************************************/
	void Help( void )																			
                                                                        
	INCLUDE: BIOS_IO.H

	LOCATION: \PROMPTS\HELP.C
	
	ARGUMENTS:	NONE																			

	RETURNS:		void																			
                                                                        
	EXTERNS:		HelpMemErrText	- Declared in EXTERN.C								
                                                                        
	Displays the help screen associated with the value on the help stack		
	pointed to by HelpStackPtr. Waits for the user to press a key and then	
	restores the original screen. Functions which want to use help should	
	push a help indentifier on the help stack with the macro PushHelp( x )	
	and then call GetChar() to get input from the user. If F1 is pressed 	
	GetChar will this function. If the value of *HelpStackPtr == -1 the 		
	function will return without displaying any text.								
 
/***************************************************************************/






/***************************************************************************/
	void HelpLine( int iFlags )															
	
	INCLUDE: HDISK.H

	LOCATION: \HDISK\DISPLAY.C

																							
	ARGUMENTS:	iFlags	- Bit flags specifing the messages to display.		
	RETURNS:		void																			
																								
	EXTERNS:		HelpLineText - Declared in EXTERN.C									
																								


	Displays a help line in reverse video on bottom line of the screen. The	
	text displayed on the line is specified by the flags passed as an arg	
	and defined by the string in the message file with the label				
	HELP_LINE_TEXT each bit in the argument represents a line from the text	
	group and are concatenated together and displayed as a single string.	
	

/***************************************************************************/





/****************************************************************************/
	int  Herc(void)

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\VIDTEST.ASM


	EXIT
      	0 - if it is not a Hercules.
      	1 - Herc 112
      	2 - Herc 222
      	3 - Herc 102



	Check for a Hercules. We are checking for a Herc102, 112, 222.
	This is the best possible test since the Hercules does not have any
	standard detection mechanism built into it.
	Taken from WORD code.

/****************************************************************************/



/***************************************************************************/
	char far *HugeAdd( char far *Ptr, long lBytes ) 								
	
	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\HUGEADD.C

																							
	ARGUMENTS:	Ptr		- Far pointer which will be added to					
					lBytes	- Number of bytes to add to Ptr							
	RETURN:		char far * - New normalized pointer 								


	Adds a long integer to a far pointer without causing a segment wrap. 	
	The pointer that is returned will also be normalized so that the offset 
	is always < 16.																			
																								
/***************************************************************************/



/***************************************************************************/
	int IsWhite( char ch )																	
				 
	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\ISWHITE.C

																				
	ARGUMENTS:ch - Character to be tested										
	RETURNS:	int - TRUE is arg is a DOS cmd line delimiter else FALSE	
																								

	Returns TRUE is the argument character is a valid DOS command line		
	delimiter.																					
	

/***************************************************************************/





/***************************************************************************/
	char far *NormalizePtr( char far *Ptr )											

	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\HUGENORM.C
	
																							
	ARGUMENTS: 	Ptr - Far pointer to be normalized						
	RETURNS:	char far *	- Normalized far pointer								


	Accepts a far pointer and returns a new pointer to the same location 	
	which has been normalize so that the offset is always < 16.					
/***************************************************************************/






/****************************************************************************/
	void InitNew13( char far *Buffer );

	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\NEWINT13.ASM
	
	ARGUMENTS:	Buffer	- Far ptr to min 1024 byte buffer
			  	to be used for if a disk read
			  	needs to be split to avoid a
			  	DMA boundary error
	RETURNS:	void


	Sets int vector 13h to point to the NewInt13 function
	which does a check for DMA errors and corrects the
	error. Saves the original vector for later restoration.
/****************************************************************************/





/***************************************************************************/
	unsigned InsertChar( char *String, int Char )									
				
	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\CHRINS.C

																				
	ARGUMENTS:	String		- Pointer to a string									
		   		Char			- character to be inserted at begining of string
																								
	RETURNS: 	unsigned 	- length of orignal string - 1						


	Inserts a character at the begining of a string and returns the new		
	length of the string.                                                   
																								
/***************************************************************************/






/****************************************************************************/
	void Int13WithRetry ( void )

	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\INT13RTR.ASM

	Does an int 13h and resets the disk and does a retry
	if the first operation fails with an error other than
	a timeout error returns all register in the condition
	returned by the int 13h call.

/****************************************************************************/



/****************************************************************************/
	void Int24Fail( void );

	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\FAIL24.ASM

	ARGUMENTS:	NONE
	RETURN: 	void	- Does not return to caller

	This function is can be called by an int 24h handler to
	simulate DOS failing the previous int 21h call. This
	function returns CPU control to the instruction following
	the last int 21h call. The registers are set exactly as
	they were when the int 21h was issued except the carry
	is set to signal an error and AL contains an error
	code to signal disk failure.
/****************************************************************************/




/****************************************************************************/
	int IsCEMMIn ( void )

	INCLUDE: FILE_IO.H

	LOCATION: \FILE\FGETCEMM.ASM

	EXIT: 1 if CEMM version 3.2 is installed, 0 otherwise

	Determines if CEMM version 3.2 is installed.
/****************************************************************************/



	

/***************************************************************************/
	int IsDBCSLeadByte(unsigned char c)

	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\DBCS.C


	ENTRY: char to compare with first byte of DBCS

	EXIT: TRUE if char is leadbyte, FALSE otherwise


	Test a character to see if it is a DBCS lead byte.

/***************************************************************************/



	

/***************************************************************************/
	int IsDirEmpty( char *szPath )														
				 
	INCLUDE: FILE_IO.H
																			
	LOCATION: \FILE\F_ISDIR.C

	ARGUMENTS:	szPath	- Ptr to full path name for directory to search 	
	RETURNS: 	int		- FALSE if file is found else TRUE						
																								
	Determines if any files exist in the specified directory path. 			
/***************************************************************************/



	
/***************************************************************************/
	int IsDiskReady( int Drive )
	
	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\DSK_RDY.ASM

	ARGUMENTS:	Drive  - Physical drive number
	
	RETURNS:	int    - TRUE is disk is ready else FALSE

	Returns TRUE if a disk is in the specified drive
	else returns FALSE. Uses BIOS int 13h to try to
	verify the first sector on the disk and then checks
	the return code if an error is detected and returns
	TRUE if error != 0x80 else returns FALSE if time out
	error is returned. If changeline is returned the
	verify is retried to avoid conflicts.
/***************************************************************************/



/***************************************************************************/
	int IsDos4Compat( void )																
																								
	INCLUDE: HDISK.H

	LOCATION: \HDISK\IS_DOS4.C

	ARGUMENTS:	NONE																			

	RETURN:		int	- TRUE is BPB is DOS 4.x compatible else FALSE			
																								
                                                                        
	Determines if a BPB in a boot record is compatible with DOS 4.x. The 	
	boot sector must have already been read in the global sector buffer. 	
	First checks 512 bytes per sector, then maximum root directory entries	
	and then makes sure there is not a conflict in the total number of		
	sectors. 																					

/***************************************************************************/




/***************************************************************************/
	int IsDosPart( unsigned char PartitionType ) 									
																								
	INCLUDE: HDISK.H

	LOCATION: \HDISK\ISDOSPRT.C

	ARGUMENTS:	PartitionType	- Partition type as found in partition table 
	
	RETURNS: 	int				- TRUE if DOS primary partition else false	
																								

	Checks a partition entry type to see if it is a valid DOS primary 		
	partition.																					
																								
	VALID PARTITION TYPES:																	
																								
	DOS12  == 1 == FAT file system - 12 bit FAT										
	DOS16  == 4 == FAT file system - 16 bit FAT										
	DOSNEW == 6 == FAT file sytem	 - huge partition > 32 meg						
																								

/***************************************************************************/






/***************************************************************************/
	int IsFmtedBoot( char *SectorBuf )													
																								
	INCLUDE: HDISK.H

	LOCATION: \HDISK\FMTBOOT.ASM

	ARGUMENTS:	SectorBuf	- Ptr to buf holding the boot sector to check	
	
	RETURNS: 	int			- TRUE if a formatted boot record else FALSE 	
	
																							
	Determines if a boot record if from a partition that was formatted		
	under any version of DOS. Checks for proper opcode in the first 3 bytes 
	(e9,XX,XX or eb,XX,90).																	

/***************************************************************************/






/***************************************************************************/
	int IsFormatted( int iDrv )															

	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\DSK_ISFM.C
																								
	ARGUMENTS:	iDrv	- Physical drive number											
					Bpb	- Ptr to BPB struct to be filled in							
					pchBuffer - Ptr to work buffer at least SECTOR_SIZE 			
	RETURNS:		int	- TRUE if disk is formatted else false						
																								
	GLOBALS:		DskBpb - Array of valid BPB structures in DSK_BPB.C				

	Determines if the disk in the specified drive has been formatted by		
	reading in the boot record and checking the BPB with all normal floppy	
	disk BPB layouts. If there is an error reading the boot record or if		
	the BPB is not valid returns FALSE else TRUE. If the disk is formmatted	
	the Bpb struct specified by the argument Bpb will be filled in. Before	
	this function is called to IsDiskReady should be done to be sure that	
	there is a disk in the drive.		
/***************************************************************************/





/***************************************************************************/
	int IsHimemDrvPresent ( void )

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\GETHIMEM.ASM

	EXIT: 1 if HIMEM.SYS is already installed, 0 otherwise

	Determines if HIMEM.SYS is installed.
/****************************************************************************/




/****************************************************************************/
	int IsNotIBM ( void )

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\IBM_ID.ASM
	
	EXIT: 0 if ROM contains IBM basic, !0 otherwise
	
	Check for a ROM containing IBM basic.

/****************************************************************************/




/****************************************************************************/
	int IsTsengLabsVGA( void )

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\VIDEOTEST.ASM

	EXIT:  TRUE  = Tseng Labls VGA is present, FALSE otherwise

	Function will detect Tseng Labs VGA card. This is necessary because if
	the Chips & Technologies detection code is executed on the Tseng Labs VGA
	card it's game over man !! Hang city !	Detection works on the principal that 
	the Attribute Controller Reg 16h is	known to exist only on Tseng Labs VGA

/****************************************************************************/





/***************************************************************************/
   int IsValidPath( char *szPath, unsigned DrvNumber, int SavePath )
	
	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\DSK_DIR.C

   ARGUMENTS:	szPath	- A directory path string
   				DrvNumber - DOS drive number: 1 = A, 2 = B, 3 = C, ...
   				SavePath - TRUE if part of path that is created is to be
   								kept, FALSE if it	is to be deleted.
   RETURNS:		int		- TRUE if a valid path else FALSE

   Validates a directory path string by cleaning up the string and then
   creating the directory path. If the path can be successfully created it
   is assumed to be a valid path. If there is an error creating the path
   it is assumed the path name is invalid and any part of the path that
   did not exist originally is deleted. The path may contain a trailing
   '\' character but it is not necessary as one will be added by this
   function if it was omitted. If SavePath is FALSE, the part of the path
   that has been created is deleted. The current path is is saved on entry
   and restored before the function returns to the caller.
/***************************************************************************/



/***************************************************************************/
	IsValidPathChar( char Char )															

	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\PATHCHR.C

																								
	ARGUMENTS:	Char	- Character to be tested										
	RETURNS: 	int	- TRUE if a valid character else FALSE 					


	Validates a character as a valid path and file name character. 			

/***************************************************************************/




/****************************************************************************/
	int  KbdGetKey( void );

	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\KEYBOARD.ASM

	EXIT: high byte contains scan code, low byte contains ASC character of key
			pressed.
	
	Waits for a character from the keyboard returns it's value and the keyboard
	scan code.

/****************************************************************************/




/****************************************************************************/
	int  KbdGetStatus( void );
	
	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\KEYBOARD.ASM
	
	EXIT: Status of various keyboard toggles and shift keys.

	Does INT 16h function 2 to get the keyboard status.

/****************************************************************************/




/****************************************************************************/
	int  KbdIsWaiting( void );
	
	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\KEYBOARD.ASM

	Checks for a character waiting in the keyboard buffer
	Returns 0 in AX if no character is waiting.
	The character is not removed from the buffer and will
	be returned by the next call to KbdGetKey

/****************************************************************************/




/****************************************************************************/
	void interrupt cdecl far NewInt24 (unsigned es, unsigned ds,
				unsigned di, unsigned si, unsigned bp, unsigned sp,
				unsigned bx, unsigned dx, unsigned cx, unsigned ax )

	INCLUDE: DISK_IO.H			
				
	LOCATION: \DISK\DSK_I24.C

	ARGUMENTS:	es, ds, di, si, bp, sp, bx, dx, cx, ax registers

	Interrupt 24h handler. Checks to see if the error is drive door open 	
	or write protect error on a floppy disk and will prompt the user to		
	remedy the problem and then return to DOS for a retry of the operation
	else will issue a fatal disk error and abort the program.					
/****************************************************************************/




/***************************************************************************/
	int IndexMaxInt( int aiMatch[], int iLen )

	INCLUDE: STRLIB.H

   LOCATION: \STRLIB\MAXINT.C

                                                     
	Scans an array of integers and returns the index to the max int in the	
	array. If 2 or more integers equal MAX the index to the first one in		
	the array is used. If all elements in the array are 0 a -1 is returned.	
																								
	ARGUMENTS:	aiMatch - Array of integers to search.							
					iLen - Number of elements in the array.						
	RETURNS:		int - First maximium value in the array or -1 if all	
					   	elements == 0.												
                                                                        
/***************************************************************************/



/***************************************************************************/
	unsigned MaxStrLen( char *Strings[] )												

	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\STRMAX.C

																								
	ARGUMENTS:	Strings - array of pointers to strings								

	RETURNS: 	unsigned - length of the longest string in the array			
																								

	Returns the length of the longest string in an array of strings.			

/***************************************************************************/




/***************************************************************************/
	void NewScreen( unsigned Text, unsigned Help )									
	
	INCLUDE: BIOS_IO.H

	LOCATION: \PROMPTS\MESSAGE.C

																							
	ARGUMENTS:	Text		- Offset of message in the text file					
					HelpFlags- Bit flags for desired help line messages			
	RETURNS:		int		- Number of strings displayed.							
																								

	Clears the screen and displays the messages from the text file as			
	specified by the Text argument and then displays the help line as 		
	specified by the HelpFlags argument.												

/***************************************************************************/




/***************************************************************************/
	void PadStr( char *szStr, char chChar, int Len )								

	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\STRPAD.C
																								
	ARGUMENTS:	szStr 	- Ptr to string												
					chChar	- Character to pad the string with						
					Len		- Total length of the padded string in bytes			

	RETURNS: 	void																			
																								
	Pads the end of a string with a specified character.							

/***************************************************************************/





/***************************************************************************/
	char *ParseFileName( char *szPath ) 												
	
	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\PARSEFN.C

	ARGUMENTS:	szPath - Ptr to a file path in the form d:\xxxx\xxx.xxx	

	RETURNS: 	char * - Ptr to file name or character after last			
						   	backslash or ':' in the string if the path did	
						   	not contain a file name									

	Returns a pointer to the first character in the filename which may or	
	may not be appended to a path.														
	
							  
/***************************************************************************/




/****************************************************************************/
	int PhyDiskRead( char far *pchBuf, int iSecCyl,
			  int iHead, char chDrive,
			  int cSecs);

	INCLUDE: DISK_IO.H		  
			  
	LOCATION: \DISK\DSKREAD.ASM

	ARGUMENTS:
		pchBuf -- buffer to read the disk into
		iSecCyl -- low byte contains starting sector, high byte contains
					  starting cylinder
		iHead -- head to use
		chDrive -- drive to use	 (00h - 7Fh = floppy, 80h - FFh = fixed disk)
		cSecs -- number of sectors to read
	EXIT:
		0 if succesful, 1 otherwise

	Uses the ROM BIOS int 13h read sectors function
	to read the specified number of sectors.
/****************************************************************************/


	

/****************************************************************************/
	int PhyDiskWrite( char far *pchBuf, int iSecCyl,
			  int iHead, char chDrive,
			  int cSecs);

	INCLUDE: DISK_IO.H
			  
	LOCATION: \DISK\DSKWRITE.ASM

	ARGUMENTS:
		pchBuf -- buffer to write to disk 
		iSecCyl -- low byte contains starting sector, high byte contains
					  starting cylinder
		iHead -- head to use
		chDrive -- drive to use	 (00h - 7Fh = floppy, 80h - FFh = fixed disk)
		cSecs -- number of sectors to write
	EXIT:
		0 if succesful, 1 otherwise

	Uses the ROM BIOS int 13h write sectors function
	to write the specified number of sectors.
/****************************************************************************/




/***************************************************************************/
	void ProcessDiskError( int ErrorType ) 											
																								
	INCLUDE: HDISK.H

	LOCATION: \HDISK\DSKERROR.C

	ARGUMENTS:	NONE												
							
	RETURN:		void																			
																								
	EXTERNS:		DiskErrorText	- Declared in EXTERN.C								
																								

	Displays an error message based on a disk error passed as an argument.	

/***************************************************************************/




/***************************************************************************/
	int PromptForDefault( void )															
	
	INLCUDE: WINDOW.H

	LOCATION: \PROMPTS\DFLTPRMT.C

	ARGUMENTS:	NONE																			
	
	RETURNS: 	int		TRUE is user selects YES else FALSE 					
																								
	EXTERNS:		AcceptText 		- Defined in extern.c								
					SetDefaultText	- Defined in extern.c								
																								

	Displays a prompt asking the user if they want to use the disk format	
	they have previously selected as the default for the rest of the			
	program. 																					

				
/***************************************************************************/





/**************************************************************************/
	int PromptWindow( char **String, int *ValidResponse, int wColor, 			
                 	char *Buffer )														
 
	INCLUDE: WINDOW.H

	LOCATION: \WINDOW\W_PROMPT.C                 
                 
                    
	ARGUMENTS:	String 			- Array of ptrs to strings to be displayed	
									  	in the window,the last element of the		
									  	array must be a NULL pointer           		
					ValidResponse 	- Array of ints which specify valid input		
									  	from the user. If the first element of the	
									  	array is 0 the function will not validate	
									  	the input and will return after any key is	
									  	pressed. If ValidResponse == NULL no input	
									  	is waited for and the window is left			
									  	displayed												
					wColor 			- color of the window to be displayed        
					Buffer 			- a ptr to buffer large enough to hold the	
									  	contents of the orginal display under the	
									  	window, if Buffer == NULL the function		
									  	will allocate a buffer to hold the data.   
	RETURNS: 	int				- Character input by the user                
																								

	Displays an untitled window on the screen and prompts waits for input   
	from the user that matches an entry in a validation array specified by  
	the caller. The length and width of the window are calculated based on  
	number and length of the strings passed to the function.                


/***************************************************************************/





/***************************************************************************/
	void  PutTitledWindow( struct WindowStruct *Window, char *Title )			
                                                                        
	INCLUDE: WINDOW.H

	LOCATION: \WINDOW\W_TWIN.C
	
	
	ARGUMENTS:	Window	- Ptr to initialized window definition structure.  
					Title 	- Ptr to a title string                            
	RETURNS:		void																			
																								

	Displays a titled window in the screen as define in the window          
	definition structure and displays the window's title.                   

/***************************************************************************/





/***************************************************************************/
	void PutWindow ( struct  WindowStruct *Win )										
                                                                        
	INCLUDE: WINDOW.H

	LOCATION: \WINDOW\W_PUTWIN.C
	
	ARGUMENTS:	Win	- Ptr to initialized window definition structure.     

	RETURNS:		void																			


	Displays an un-titled window in the screen as define in the window      
	definition structure.                                                   
																								
/***************************************************************************/






/***************************************************************************/
	int RdWrSectors( int iDrv, unsigned uSec, unsigned uNumSec,					
					  	char *puchBuf, struct BPB *Bpb, int RdWr )					

  	INCLUDE: DISK_IO.H
						
	LOCATION: \DISK\DSK_SECT.C
																									
	ARGUMENTS:	unsigned iDrv		Physical drive to write to						
					unsigned uSec		Absolute starting sector to begin at		
					unsigned uNumSec	Number of sectors to write						
					int		iFmt		Disk type listed in first header				
					char 		*puchBuf	Ptr to buffer holding data to write			
					struct BPB *Bpb	BPB struct for disk in drive					
					int		RdWr		Specifies read (0) or write (1)				
																									
	RETURNS:		int					Error code or OK if successfull				

	Reads or writes the specified number of sectors to a floppy disk			
	using interrupt 13h calls. 															

/***************************************************************************/





/***************************************************************************/
	int ReadPartBootRec( struct Part *PartEntry, void *Buffer,
			     int DrvNum );

	INCLUDE: HDISK.H

	LOCATION: \HDISK\PARTBOOT.ASM
			  
				  
	ARGUMENTS:	PartEntry - Partition table entry structure
			Buffer	- Ptr to read buffer of 512 bytes
			DrvNum	- Physical hard disk number
	RETURNS:	int	- 0 if successful
				- !0 if error


	Reads in the first sector (boot	record) of a hard
	disk partition.


/***************************************************************************/





/***************************************************************************/
	int ReadWriteBoot( int iDosDrv, void *Buffer, int ReadWrite )			  
																								  
	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\RW_BOOT.C
	
	ARGUMENTS:	iDosDrv	- DOS drive number to get boot record from		  
					Buffer	- Ptr to buffer to hold the boot record			  
	RETURNS:		int		- OK if successful else a DOS error code for		  
	
	Uses int 25h&26h to read or write the boot record for the specified	  
	drive.																					  
/***************************************************************************/




/***************************************************************************/
	ReadWriteFat( int iDosDrv, struct BPB *Bpb, void *Buf, int Sector,		
				  	int ReadWrite )															
																		
	INCLUDE: DISK_IO.H
					
	LOCATION: \DISK\RW_FAT.C					
	
	ARGUMENTS:	iDosDrv	- The DOS drive number to get the sector from		
					Bpb		- Ptr to bpb structure for the specified drive		
					Buf		- Ptr to sector buffer										
					Sector	- The FAT sector number based 0							
					ReadWrite- Flags reading or writing sector - READ or WRITE 	
	RETURNS:		int		- OK if successfull else int 25h error code			

	Reads or writes a specified FAT sector on the specified drive.	Will		
	update the same sector in all copies of the FAT.	
	
/***************************************************************************/





/***************************************************************************/
	ReadWriteRoot( int iDosDrv, struct BPB *Bpb, void *Buf, int Sector		
				  				int ReadWrite )												
																								
	INCLUDE: DISK_IO.H
								
	LOCATION: \DISK\RW_ROOT.ASM
								
	ARGUMENTS:	iDosDrv	- The DOS drive number to get the sector from		
					Bpb		- Ptr to bpb structure for the specified drive		
					Buf		- Ptr to sector buffer										
					Sector	- The root directory sector number based 0			
					ReadWrite- Flags reading or writing sector - READ or WRITE 	
	RETURNS:		int		- OK if successfull else int 25h error code			

	Reads or writes a specified root directory sector on the specified drive.	
	
/***************************************************************************/




/****************************************************************************/
	void RebootSystem( void );

	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\REBOOT.ASM

	Forces a system power on reboot.

/****************************************************************************/




/***************************************************************************/
	unsigned RemoveSpaces( char *szString )											

	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\STRRMSP.C
																								
	ARGUMENTS:	String - pointer to string											

	RETURNS: 	unsigned - length of the new string									
																								

	Removes all spaces in a string.														

/***************************************************************************/





/***************************************************************************/
	unsigned RemoveTrailing( char *String, char Char ) 							
																								
	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\RMTRAIL.C

	ARGUMENTS:	String - pointer to a string										
					Char - the ascii char to remove from the end of string	
																								
	RETURNS: 	unsigned - length of the new string									
																								

	Removes all trailing characters of the type specified from a string		
	and returns the length of the new string.                               
/***************************************************************************/




/***************************************************************************/
	int RenameFCB( char *szFrom, char *szTo )											

	INCLUDE: FILE_IO.H

	LOCATION: \FILE\F_REN.C
																							
	ARGUMENTS:	szFrom	- Original name of file in the form X:\NAME.EXT 	
					szTo		- New name for	file in the form X:\FILENAME.EXT		
	RETURNS: 	int		- OK if successfull else error							


	Renames within the same directory of the specified full drive and path	
	anem. This is necessary when renameing the system files because DOS		
	versions < 3 move the physical directory entry when renaming which will 
	move the system file entries out of the first 2 positions.					
/***************************************************************************/





/***************************************************************************/
	void ReplaceChar( char *szString, char chOldChar, char chNewChar )		
	
	LOCATION: STRLIB\CHRREPL.C
																							
	ARGUMENTS:	szString 	- Ptr to string											
					chOldChar	- Char to be replaced									
					chNewChar	- Replacement character 								
	RETURNS: 	void																			
																								

	Replaces all occurances of a specified character in a string with 		
	another character.																		
	
/***************************************************************************/






/***************************************************************************/
	int ReplaceFile( char *szSource, char *szDestin )								
				 
	INCLUDE: FILE_IO.H

	LOCATION: \FILE\F_REPLACE.C

	ARGUMENTS:	szSource - Ptr to full path and name for source file			
					szDestin - Ptr to full path and name for destination file	
	RETURNS: 	int		- OK if successful else ERROR 							

		
	Replaces the destination file with the source file by first seeing if	
	the source exists and then deleting the destination and renameing the	
	destination and renaming the source to take it's place. The check for   
	the destination is done to be sure the replace has not already taken 	
	place.																																														

/***************************************************************************/




/****************************************************************************/
	void ResetDrv( int Drive );

	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\BIOSRSET.ASM
	
	ARGUMENTS:	Drive	- Physical disk drive number.

	RETURNS:	void

	Does a ROM BIOS drive reset on the specified drive.
/****************************************************************************/





/***************************************************************************/
	void RestoreCursor( unsigned long Cursor )										
	
	INCLUDE: WINDOW.H

	LOCATION: \WINDOW\W_RSTCUR.C

	ARGUMENTS:	Cursor	- Cursor size & position returned by SaveCursor()	
	
	RETURNS:		void																			


	Displays the cursor at the screen position and size specified in the		
	argument as an unsigned long with the  position in the high byte and		
	size in the low byte.																	
																								
/***************************************************************************/




/***************************************************************************/
	unsigned long SaveCursor ( void )													
	
	INCLUDE: WINDOW.H

	LOCATION: \WINDOW\W_SAVCUR.C

																							
	ARGUMENTS:	NONE																			
	
	RETURNS:		unsigned long	- Cursor screen position and size				

	Returns the size and position of the cursor as an unsigned long value 	
	with the position in the high byte and size in the low byte.				
																								
/***************************************************************************/





/***************************************************************************/
	int ScrubFatRoot( int iDrv, struct BPB *Bpb )									
																								
	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\DSK_SCRB.C
	
	ARGUMENTS:	iDrv	-	Physical floppy drive number								
					Bpb	-	Ptr to Bpb struct for the disk being scrubbed		
	RETURNS:		int	-	OK if successfull else !OK									

	Empties the FAT and root directory to make the disk look freshly			
	formatted by zeroing all good clusters in all copies of the FAT and		
	then zeroing out all entries in all root directory sectors.					
/***************************************************************************/





/***************************************************************************/
	void SetDefaultColors( int IsColor )												
																								
	INCLUDE: WINDOW.H

	LOCATION: \WINDOW\W_COLOR.C

	ARGUMENTS:	NONE																			

	RETURNS:		void																			

	Sets the default colors based on whether IsColor is TRUE or FALSE.	
/***************************************************************************/






/***************************************************************************/
	int SetDiskType( unsigned uDrv, unsigned char DiskType );

	INCLUDE: DISK_IO.H

	LOCATION: \DISK\SETDSKTY.ASM

	ARGUMENTS:	uDrv	- Physical floppy drive number
			DiskType - Extended BIOS disk type
			0	- Not used
			1	- 320/360K in 360K drive
			2	- 320/360K in 1.2M drive
			3	- 1.2M in 1.2M drive
			4	- 720K in 720K drive
	RETURN:		int	- 0 if ok else INVALID_DRIVE_TYPE

	Extended ROM BIOS call which sets a disk type for
	formatting using function 17h of int 13h. The function
	must do 1 retry in case disk changed status is returned.

/***************************************************************************/





/***************************************************************************/
	void SetFileTimeDate( struct DIR *Dir )											
															
	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\DSK_TIME.C
									
	ARGUMENTS:	Dir	- Ptr to directory entry structure							
	RETURNS: 	void										 
	
	Sets date and time of file to current date and time.							
																									
/***************************************************************************/



/***************************************************************************/
	void far *SetMediaType( int Drive, int Tracks, int Sectors )

	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\SETMEDIA.ASM
	
	ARGUMENTS: Drive	- Physical drive number
		   Tracks	- Total tracks on the floppy disk
		   Sectors	- Number of sectors per track

	RETURNS:		  Ptr to DASD for this type of drive
				  is successfull else NULL ptr

	Extended ROM BIOS call to set the disk layout for a
	format operation. The function must do 1 retry in case
	a disk change status is returned.
/***************************************************************************/




/***************************************************************************/
	int SetNewBpb( struct BPB far *Bpb, char far *WorkBuffer, int Drive );

	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\SETBPB.ASM
	
	ARGUMENTS:	Bpb	- The new BPB structure
			Buffer	- A work buffer for use by the function
			Drive	- The disk drive to set the new bpb for
	RETURNS:	int	- 0 if successfull else -1

	Uses the generic IOCTL call to set the default bpb for a	specified 
	disk drive

/***************************************************************************/




/***************************************************************************/
	unsigned ShiftStringLeft( char *String )											
	
	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\STRSHL.C
																							
	ARGUMENTS:	String	- pointer to string to be shifted						
	
	RETURNS: 	unsigned - length of original string - 1							
																								

	ShiftStringLeft() moves a string left one character, including EOL.		
	Returns the length of the new string.                                   
	
/***************************************************************************/




/***************************************************************************/
	char *SkipLeadingWhite( char *szPtr )												
			 
	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\SKIPSPC.C

	ARGUMENTS: Str - Ptr to a string												

	RETURNS: char*	- Ptr to first non-white space character or EOL 	

	Returns a ptr to first character after any white spaces or '=' chars.	
	Checks for EOL and if encountered stops processing and returns a ptr 	
	to the EOL character.																	
/***************************************************************************/





/***************************************************************************/
	char *SkipNonWhite( char *szPtr )													
																								
	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\NONWHITE.C
	
	ARGUMENTS:	Str		- Ptr to a string												

	RETURNS: 	char *	- Ptr to first white space character or EOL	
																								

	Returns a ptr to first white space or '=' character encountered.			

/***************************************************************************/





/***************************************************************************/
	char *SkipWord( char *szPtr ) 														
						
	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\SKIPWORD.C
																		
	ARGUMENTS:	szPtr - Ptr to string												

	RETURNS: 	char * - Ptr to first character of next word or EOL 		
			  																							

	Returns a ptr to the first character of the word following the first 	
	encountered in the specified string.												
/***************************************************************************/






/***************************************************************************/
	int StrSearch( char *szSearchStr, char **szStrings ) 							
																								
	INCLUDE: STRLIB.H

	LOCATION: \STRLIB\STRSRCH.C

	ARGUMENTS:	szSearchStr	- String to match											
					szStrings	- Array of pointers to strings with last the		
								  	end of the array marked with a NULL pointer	
	RETURNS:		int			- Index to the first matching string or -1 if	
								  	there was no matching string found.				
                                                                        
	
	Looks for a matching string in an array of pointers to strings.			
/***************************************************************************/







/****************************************************************************/
	void SwapDiskTable ( void )

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\TRS_TOG.ASM

	Swaps the 26 bytes in Assign's disk table with those
	in our disk table.

/****************************************************************************/




/****************************************************************************/
	void ToggleAppend( void )
	
	INCLUDE: BIOS_IO.H

	
	LOCATION: \BIOS\TRS_TOG.ASM
	
	Checks to see if APPEND has been installed and if it has
	toggles it active or inactive depending on it's current
	state.
/****************************************************************************/


/****************************************************************************/
	void ToggleAssign( void )

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\TRS_TOG.ASM
	
	Checks to see if ASSIGN has been installed and if it 
	has toggles it active or inactive depending on it's
	current state.
/****************************************************************************/



/***************************************************************************/
	unsigned long ToLongTd( struct find_t *File )									
																								
	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\DSK_TCNV.C
	
	ARGUMENTS:	File		- Ptr to a filled in find_t structure					
	RETURNS:		long		- Date in most sig. byte and Time in least sig.		

	Converts the time and date returned by the a call to _dos_findfirst		
	int a long value with the date in the most signifiant byte and the time	
	in the least sig. bytes. This allows for simple and accurate file			
	creation comparisions.																	
/***************************************************************************/



/****************************************************************************/
	void UpdateBreakSetting( int OnOffFlag );

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\SETBRK.ASM
	
	ARGUMENTS:	OnOffFlag - TRUE if turning on else FALSE
	
	RETURNS:	void

	Sets the DOS internal break check setting to on or off.
/****************************************************************************/




/***************************************************************************/
	int	ValidateDir( char *szPath )													
																									
	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\V_DIR.C
	
	ARGUMENTS: szPath	- The path string to use to find the next directory
	
	RETURNS: int - OK if successful else ERROR								

	Parses out the first directory from a path string and validates that 	
	directory name and if valid recursively calls itself until each name	in	
	in the path has been validated or an error is detected.						

/***************************************************************************/




/***************************************************************************/
	int ValidatePath( char *szPath )														
	
	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\V_DIR.C
																							
	ARGUMENTS:	szPath	- A directory path string									
	
	RETURNS:		int		- TRUE if a valid path else FALSE						

	Validates a directory path string by cleaning up the string and then		
	checking that each directory in the path has a valid directory name.		
	
/***************************************************************************/




/****************************************************************************/
	int	VideoAdapter(void);

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\VIDEO_ID.C
	
	Returns in AX:
		1 - CGA
		9 - MCGA
		8 - EGAHIRES_MONO
		7 - EGA_COLOR
		5 - VGA
		-1 - FAILED
		-2 - unknown value in BL after the first test.

	Determine the display adapter type using int 10h function 1Bh
/****************************************************************************/




/****************************************************************************/
	void VideoBlockCurs ( void )

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\VIDEO.ASM
	
	Makes the cursor a block cursor.
/****************************************************************************/






/***************************************************************************/
	void VideoCleanup( void )																

	INCLUDE: WINDOW.H

	LOCATION: \WINDOW\W_CLEAN.C

	ARGUMENTS:	NONE																			
	
	RETURNS:		void																			
																							
	Function to clear the screen and restore the cursor to normal size and	
	top left corner position.																
/***************************************************************************/






/****************************************************************************/
	void VideoCls( int Attrib )

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\VIDEO.ASM

	ARGUMENTS
		attrib -- attribute of blanked characters

	Blanks the entire screen using a specified attribute.
/****************************************************************************/



/****************************************************************************/
	void VideoCursOff ( void )

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\VIDEO.ASM

	Turns the text mode cursor off.
/****************************************************************************/



/****************************************************************************/
	void  VideoDupAttr( int Row, int Col, int Attr, int DupFactor )

	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\VIDEO.ASM
	
	ENTRY
		row -- row to start changing attribute
		col -- column to start changing attributes
		attr -- attribute to set characters to
		dupfactor -- number of characters in the line

	Changes the attributes of a horizontal line of characters on the display 
	and rewrites it with the new attribute set.

/****************************************************************************/




/****************************************************************************/
	VideoDupCharAttr (int Row, int Col, int DupChar, int Attrib, int DupFactor)

	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\VIDEO.ASM
	
	ENTRY
		row -- row to start writing character
		col -- column to start writing character
		dupchar -- character to be written
		attrib -- attribute of character to be written
		dupfactor -- number of characters in the line

	Writes a horizontal line of characters on the display.
/****************************************************************************/




/****************************************************************************/
	void VideoGetBlock( int Row, int Col, char *awSource, int Count )

	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\VIDEO.ASM


	ARGUMENTS
		row -- starting row of block to copy from
		col -- starting column of block to copy from
		awSource -- ptr to buffer to copy block to
		count -- number of characters to copy

	Copies a horizontal block of characters and their attributes to a buffer.
 	Each character is represented as a word with the high byte containing the
	attribute and the low byte the ASCII code for the character.
/****************************************************************************/





/****************************************************************************/
	int VideoGetCursSize (void)

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\VIDEO.ASM
	
	RETURNS
		cursor size --	bits 0-4 of high byte contain	starting line for cursor 
							and bits 0-4 of low byte contain	ending line for cursor. 
	
	Gets the current cursor size.
/****************************************************************************/




/****************************************************************************/
	void VideoGetMode( void );
	
	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\VIDEO.ASM
	
	Returns current video mode and does setup of the
	static variables containing screen setup
/****************************************************************************/




/****************************************************************************/
	int VideoGetRowCol ( void)

	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\VIDEO.ASM
	
	RETURNS
		location of cursor position: row is in top byte and column in bottom

	Gets current cursor position. 
/****************************************************************************/



/****************************************************************************/
	void	VideoInitial( void );
	
	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\VIDEO.ASM
	
	Initializes the video data, must be called before any
	other video function

/****************************************************************************/





/****************************************************************************/
	int VideoIsColor ( void )

	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\VIDEO.ASM
	
	Returns true if a color card is active.
/****************************************************************************/


/****************************************************************************/
	void VideoNormalCurs ( void )

	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\VIDEO.ASM
	
	Makes the cursor an underlin cursor.
/****************************************************************************/



/****************************************************************************/
	void VideoPutBlock( int Row, int Col, char *awSource, int Count )

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\VIDEO.ASM
	
	ARGUMENTS
		row -- starting row of block to copy to
		col -- starting column of block to copy to
		awSource -- ptr to buffer to copy block from
		count -- number of characters to copy	

	Copies the characters and their attributes from a buffer to a horizonal 
	block on the screen.  The characters are stored in the block as words with
	the high byte containing the attribute and the low byte the ASCII code for
	the character.
/****************************************************************************/




/****************************************************************************/
	void VideoPutChar( char Character);

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\VIDEO.ASM

	Displays a character at the current cursor position on the screen and
	advances the cursor to the next character position.
/****************************************************************************/




/****************************************************************************/
	VideoPutCharAttr( Row, Col, Character, Color )
	
	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\VIDEO.ASM
	
	Displays a character at the specified row and column on the screen  with
	the specifed screen attribute. Cursor will end up at the specified row
	and column position.
/****************************************************************************/


/****************************************************************************/
	void VideoPutCharRowCol( int Row, int Col, int Character )

	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\VIDEO.ASM

	Displays a character at the specified row and column on the screen.
	Cursor will end up at the specified row and column position.
/****************************************************************************/



/****************************************************************************/
	void	VideoPuts( char far *String )

	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\VIDEO.ASM
	
	ENTRY
		string -- pointer to a string

	Writes string to current position on the screen.
/****************************************************************************/



/****************************************************************************/
	void  VideoPutsAttrRowCol( int Row, int Col, char far *String, int Attr )

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\VIDEO.ASM

	ENTRY
		row -- row at which to output string
		col -- column at which to output string
		string -- pointer to string to be written
		attr -- attribute of chars of string

	Writes a string to the current position on the display.  All characters
	are written with the specified attribute.
/****************************************************************************/




/****************************************************************************/
	void  VideoPutsRowCol( int Row, int Col, char far *String )

	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\VIDEO.ASM

	ENTRY
		row -- row at which to output string
		col -- column at which to output string
		string -- pointer to string to be written

	Writes string to a specified location
/****************************************************************************/



/****************************************************************************/
	void VideoScrollDn( int StartRow, int StartCol, int EndRow, int EndCol,
	                    int Lines, int Attrib )

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\VIDEO.ASM

	ENTRY
		startrow -- starting row of window to be scrolled
		startcol -- starting column of window to be scrolled
		endrow -- ending row of window to be scrolled
		endcol -- ending column of window to be scrolled
		lines -- number of lines to scroll
		attrib -- attribute to be used for blanked area

	Does int 10 function 07h to scroll down the contents of a window by
	a specified number of lines.  If the number of lines to scroll is zero,
	the entire window is blanked.
/****************************************************************************/



/****************************************************************************/
	void VideoScrollUp( int StartRow, int StartCol, int EndRow, int EndCol,
                       int Lines, int Attrib )

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\VIDEO.ASM

	ENTRY
		startrow -- starting row of window to be scrolled
		startcol -- starting column of window to be scrolled
		endrow -- ending row of window to be scrolled
		endcol -- ending column of window to be scrolled
		lines -- number of lines to scroll
		attrib -- attribute to be used for blanked area

	Does int 10 function 06h to scroll up the contents of a window by
	a specified number of lines.  If the number of lines to scroll is zero,
	the entire window is blanked.
/****************************************************************************/




/****************************************************************************/
	void VideoSetCursSize ( unsigned Size )

	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\VIDEO.ASM

	ARGUMENTS
		Size -- 	specifies size of cursor: bits 0-4 of high byte contain
					starting line for cursor and bits 0-4 of low byte contain
					ending line for cursor.

	Does INT 10 function 01h to set the size of the cursor.
/****************************************************************************/



/****************************************************************************/
	void VideoSetMode (int NewMode);
	
	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\VIDEO.ASM

	VideoSetMode() attempts to set the video mode
	passed as the argument. Returns new current mode
/****************************************************************************/



/****************************************************************************/
	void VideoSetPage ( int ScrPage )

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\VIDEO.ASM
	
	ARGUMENTS
		ScrPage -- screen page to set
	
	Sets active display page.
/****************************************************************************/





/****************************************************************************/
	void VideoSetRowCol ( int Row, int Column)

	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\VIDEO.ASM

	ARGUMENTS
		Row -- row to move cursor to
 		Column -- column to move cursor to

	Modify current cursor position.
/****************************************************************************/



/****************************************************************************/
	VideoVertDupAttr( int Row, int Col, int Attrib, int DupFactor )

	INCLUDE: BIOS_IO.H
	
	LOCATION: \BIOS\VIDEO.ASM

	ENTRY
		row -- row to start changing attribute
		col -- column to start changing attributes
		attr -- attribute to set characters to
		dupfactor -- number of characters in the line

	Changes the attributes of a vertical line of characters on the display 
	and rewrites it with the new attribute set.
/****************************************************************************/



/****************************************************************************/
	VideoVertDupCharAttr (int Row, int Col, int DupChar, int Attrib, 
								 int DupFactor)

	INCLUDE: BIOS_IO.H

	LOCATION: \BIOS\VIDEO.ASM
								 
	ENTRY
		row -- row to start writing character
		col -- column to start writing character
		dupchar -- character to be written
		attrib -- attribute of character to be written
		dupfactor -- number of characters in the line

	Writes a vertical line of characters on the display.
/****************************************************************************/


/****************************************************************************/
	int  V7VGA(void)

	INCLUDE: BIOS_IO.H

	LOCATION: \HARDWARE\VIDTEST.ASM

	EXIT: TRUE is Video 7 VGA card is detected, FALSE otherwise

	This function detects the presence of the Video 7 VGA card.
/****************************************************************************/





/***************************************************************************/
	void  WindowMove( struct WindowStruct *Wind, char *Buffer,					
							int iSaveRestore )												

	INCLUDE: WINDOW.H

	LOCATION: \WINDOW\W_MOVE.C            

	ARGUMENTS:	Wind 			- Ptr to a completed window definition struc		
					Buffer 		- Ptr to data area large enough to hold the		
								  	screen contents  										
					SaveRestore - signals copy from screen to buffer or buffer	
								  	to screen													
								  	SAVE = copy from screen								
								  	RESTORE = copy to screen         					
	RETURNS:		void																			
																								


	Moves a window from the screen to a buffer if SaveRestore == SAVE       
	else it moves from the buffer to the screen.										
/***************************************************************************/




/***************************************************************************/
	void WorkAreaCls( void )																
	
	INCLUDE: WINDOW.H

	LOCATION: \WINDOW\W_CLS.C

	ARGUMENTS:	NONE																			
	
	RETURNS:		void																			

	Function to clear the work area of the screen. The work are is defined  
	as the area below the screen header and above the help prompt at the    
	bottom of the screen.                                                   
/***************************************************************************/





/************************************************************************/
	int WriteBoot( int iDrv, struct BPB *Bpb, char *szLabel )				

	INCLUDE: DISK_IO.H
	
	LOCATION: \DISK\DSK_BOOT.C
																						
	ARGUMENTS:	Bpb		- BPB to use for this disk								
					szLabel	- Disk label string or NULL for no label			
	RETURNS:		int		- OK or BIOS int 13h disk error						

	Copies the BPB structure for the current disk to a boot record and	
	then writes the boot record to the disk.										
/************************************************************************/


/***************************************************************************/
	int Xcopy( struct MULT_FILES *FileList )									
																							
	INLCUDE: COPY.H
	
	LOCATION: COPY\FILECOPY.C
	
	ARGUMENTS:	FileList 	- Array of structures which describe everything 
								  	necessary about the files.							
	RETURNS: 	void																			
	
	Functions to copy multiple files between different drives. Will prompt	
	for the disks before each file is read or written if the disk is not 	
	already inserted. Will allow the user to decide whether to continue or	
	or not if there is an error reading any of the files.
/***************************************************************************/



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\bios_io.inc ===
;================= BIOS_IO.INC =========================
COMMENT #

	BIOS_IO.INC

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential


	johnhe - 03/05/89

END COMMENT #
;========================================================


ASCII_CR	EQU	13
ASCII_LF	EQU	10

; =======================================================
; Equates
; =======================================================
KBD_INT           EQU   16h     ; Bios keyboard interrupt
KBD_GET_CHAR      EQU   00      ; Get char from keyboard buffer
KBD_IS_WAITING    EQU   01      ; See if character is waiting
KBD_GET_STATUS    EQU   02      ; Return shift status

COLOR_BIT         EQU     000001b
EGA_BIT           EQU     000010b
FAST_BIT          EQU     000100b


; =========================================================================
; Macro which does an explicit NEAR or FAR call based on the memory
; model.
; =========================================================================

call_M	MACRO	Function

IF 	@codesize			; Call adjusted for memory model

	call	FAR PTR Function	; FAR call if LARGE, MED, or HUGE
ELSE
	call	NEAR PTR Function	; Else NEAR call
ENDIF

ENDM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\ctrlbrk.asm ===
; ========================================================

COMMENT #

	CTRLBRK.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential


	johnhe - 03/03/89

END COMMENT #

;========================================================

include BIOS_IO.INC
include	MODEL.INC

;========================================================

.CODE

; ========================================================
; New int 1bh and 23h which just do an iret
; ========================================================

	public NewInt1b
NewInt1b LABEL FAR

	public NewInt23
NewInt23 LABEL FAR

	iret


;========================================================

	END

;========================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\datavers.asm ===
; ========================================================

COMMENT #

	DATAVERS.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	johnhe - 03/03/89

END COMMENT #

;========================================================

include BIOS_IO.INC
include	MODEL.INC


.CODE

; ========================================================
;
; Returns the DOS Data version from DOSDATA:04h
;
; int	GetDosDataVersion( void );
;
; ========================================================

GetDosDataVersion PROC USES ES

	mov	AH,34h			; DOS get critical flag address
	int	21h
	mov	BX,4			; Put address of DATA version in BX
	mov	AL,ES:[BX]		; Get DATA version byte
	cbw				; Convert AL to an integer
	ret

GetDosDataVersion ENDP	

; ========================================================

	END

; ========================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\country.asm ===
; ========================================================

COMMENT #

	COUNTRY.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential


	Fills in a country information structure

	GetCountryInfo( struct COUNTRY_INFO *Cntry );

	ARGUMENTS: Cntry - Ptr to 34 byte buffer
	RETURNS:   TRUE if successful, FALSE if not

	johnhe - 02/24/90

END COMMENT #

;========================================================

include BIOS_IO.INC
include	MODEL.INC


; ========================================================

.CODE

; ========================================================

IF @DataSize
 GetCountryInfo PROC USES DS, Buffer:PTR
ELSE	
 GetCountryInfo PROC Buffer:PTR
ENDIF
	mov	AX,3800h		; Get country info function
	LoadPtr	DS,DX,Buffer		; Address of buffer
	int	21h
        mov     ax, 01h
        jnc     gci1
        xor     ax, ax                  ; Error, so return FALSE
    gci1:
	ret

GetCountryInfo ENDP

; ========================================================

	END

; ========================================================

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\doint2f.asm ===
; ========================================================

COMMENT #

	DOINT2F.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	Does an int 2f with AX = 4400h to update the format
        complete gage. This function is mainly for getting
        the gage setup before the format program is spawned.

	DoInt2f( unsigned Percent );

	ARGUMENTS: Percent - Percentage of format complete
	RETURNS:   void

	johnhe - 02/24/90

END COMMENT #

;========================================================

include BIOS_IO.INC
include	MODEL.INC

; ========================================================

.CODE

; ========================================================

DoInt2f PROC  Value:WORD

	mov	AX,4900h
	mov	BX,Value
	int	2fh
	ret

DoInt2f ENDP

; ========================================================

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\findstr.asm ===
; ========================================================

COMMENT #

	FINDSTR.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	johnhe - 08/01/89	Initial coding
		 01/12/89	Converted to LIB form

END COMMENT #

;========================================================

include BIOS_IO.INC
include	MODEL.INC


;========================================================

.CODE

; ========================================================
; FindString( char *Buffer, char *String, unsigned BufferSize );
;
; Quickly searches for a string in a buffer of any type of
; data. The search is case sensitive.
; 
; Buffer  - The buffer to search
; String  - The zero terminated string to search for
; Count   - The length of the buffer in bytes
; ========================================================

FindString PROC USES DS ES DI SI, Buffer:DWORD, String:DWORD, Count:WORD

	cld  
	mov	CX,Count	; Put length of buffer in CX
	or	CX,CX		; Make sure length > 0
	jnz	LoadStrings
	jmp	SHORT NoMatch

LoadStrings:
	lds	SI,String	; Pointer to string in DS:SI
	les	DI,Buffer	; Pointer to buffer in ES:DI
	lodsb			; Put first character of string in AL  
	or	AL,AL		; Check for zero length string
	jnz	FindChar
	jmp	SHORT NoMatch
FindChar:
	repne	scasb		; Try to match the first char in the string
	jcxz	NoMatch		; If CX==0 no matches were found
	push	AX		; Save setup of the scan so it can be
	push	DI		; continued if this is not a matching string
	push	SI
	push	CX
CmpString:
	lodsb			; Get next char in the string
	or	AL,AL		; See if EOL marker
	jnz	CheckForMatch	; If not EOL compare the character
	pop	CX		; If EOL we found a matching string
	pop	SI		; So restore the register and break the loop
	pop	DI
	pop	AX
	jmp	SHORT FoundMatch
CheckForMatch:
	cmp	AL,ES:[DI]	; Cmp next char from str. with next in buffer
	jne	RestoreRegs	; If not equal go back to checking first char
	inc	DI		; Else point to next char in the buffer
	dec	CX		; and dec count
	jz	RestoreRegs	; If CX==0 were at the end of the buffer
	jmp	SHORT CmpString	; Else cmp the next chars
RestoreRegs:
	pop	CX		; Restore register setup used by char scan
	pop	SI
	pop	DI
	pop	AX
	jmp	SHORT FindChar	; Go back to checking for first char match
FoundMatch:
	xor	AX,AX			; Signal OK  (ie: match found)
	jmp	SHORT FindStringReturn	; Jmp to procedure return
NoMatch:
	mov	AX,-1		; Signal no match was found
FindStringReturn:
	ret			; Finished

FindString  ENDP

; ========================================================

	END

; ========================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\getbrk.asm ===
; ========================================================

COMMENT #

	GETBREAK.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	johnhe - 03/03/89

END COMMENT #

;========================================================

include BIOS_IO.INC
include	MODEL.INC

;========================================================

.CODE

; ========================================================
; Returns the setting of DOS's internal Ctrl C check.
;
; int GetBreakSetting( void );
;
; ARGUMENTS:	NONE
; RETURNS:	int	- 0 if check is off else 1
;
; ========================================================

GetBreakSetting PROC 

	mov	AX,3300h		; Request Ctrl C check state
	int	21h
	mov	AL,DL			; Put state in AL
	cbw				; Convert AL to a word
	ret

GetBreakSetting ENDP


END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\ibm_id.asm ===
; ========================================================

COMMENT #

	IBM_ID.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	johnhe - 03/03/89

END COMMENT #

; ========================================================

include BIOS_IO.INC
include	MODEL.INC

; ========================================================

.DATA

; ========================================================

COPYR_LEN	EQU	15

CopyrightIBM	db	'The IBM Personal Computer Basic'

; ========================================================

.CODE

; ========================================================
; Check for a ROM containing IBM basic and returns false
; 0 if the ROM is found else NOT 0.
;
; int IsNotIBM( void );
;
; ========================================================

IsIBM PROC	USES ES DI SI

	mov	AX,0fac0h		; Load segment ES
	mov	ES,AX
	mov	DI,09bh			; Put offset in DI
	mov	SI,OFFSET CopyrightIBM	; Set up for cmpstring
	mov	CX,COPYR_LEN		; Put length of string in CX
	repz	cmpsw
	jz	IsTrueIBM

	mov	AH,22h
	int	15h
	jc	NotIBM

	or	AH,AH
	jnz	NotIBM

IsTrueIBM:
	mov	AX,1
	ret	

NotIBM:
	xor	AX,AX
	ret	

IsIBM ENDP

; ========================================================

	END

; ========================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\keyboard.asm ===
; ========================================================

COMMENT #

	KEYBOARD.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	Functions to use the ROM BIOS for getting
	input from keyboard via interrupt 16h


	Video initialization function. This function
	must be called before any of the other vio
	library functions.


	johnhe - 03/03/89

END COMMENT #

;========================================================

include	BIOS_IO.INC
include	MODEL.INC

;========================================================


.CODE

; =======================================================
; int  KbdGetKey( void );
;
; Waits for a character from the keyboard and returns the
; character in AL and scan code in AH
; =======================================================

KbdGetKey PROC

        mov     AH,KBD_GET_CHAR
	int	16h
        ret

KbdGetKey ENDP

; =======================================================
; int  KbdIsWaiting( void );
;
; Checks for a character waiting in the keyboard buffer
; Returns 0 in AX if no character is waiting.
; The character is not removed from the buffer and will
; be returned by the next call to KbdGetKey
; =======================================================

KbdIsWaiting PROC 

        mov     AH,KBD_IS_WAITING
	int	16h
        mov     AX,1                    ; Assume char is waiting
        jnz     IsWaitingReturn         ; Char waiting so return character
        xor     AX,AX                   ; No char waiting so return zero
IsWaitingReturn:
        ret

KbdIsWaiting ENDP

; =======================================================
; int  KbdGetStatus( void );
;
; Returns the status of the shift and ctrl keys in AX
; =======================================================

KbdGetStatus PROC

        mov     AH,KBD_GET_STATUS
	int	16h
        cbw                             ; Clear AH
        ret

KbdGetStatus ENDP

; =======================================================
	END
; =======================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\setbrk.asm ===
; ========================================================

COMMENT #

	SETBREAK.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	johnhe - 03/03/89

END COMMENT #

;========================================================


include	MODEL.INC

.CODE

; ========================================================
; Sets the DOS internal break check setting to on or off.
;
; void UpdateBreakSetting( int OnOffFlag );
;
; ARGUMENTS:	OnOffFlag - TRUE if turning on else FALSE
; RETURNS:	void
; ========================================================

UpdateBreakSetting PROC  OnOff:WORD

	mov	AX,3301h
	xor	DX,DX
	or	OnOff,0			; Test for zero
	jz	SetState
	mov	DL,1			; Request was for turn it on
SetState:
	int	21h
	ret

UpdateBreakSetting ENDP

; ========================================================

	END

; ========================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\reboot.asm ===
; ========================================================

COMMENT #

	REBOOT.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	johnhe - 12/01/89

END COMMENT #

;-----------------------------------------------------------------------------;
;	K E Y B O A R D   S C A N   C O D E S				      ;
;-----------------------------------------------------------------------------;

KB_INTERCEPT	EQU	4fh

DEL_KEY		EQU	53h
ALT_SHIFT	EQU	08h
CTL_SHIFT	EQU	04h

WARM_BOOT_CODE	EQU	1234h	

;-----------------------------------------------------------------------------;
;	BIOS DATA AREA LOCATED AT 40:00
;-----------------------------------------------------------------------------;

ROM_DATA SEGMENT AT 040h

	org	17h
KB_FLAG		LABEL BYTE


	org	072h
WarmBootFlag	LABEL WORD

ROM_DATA ENDS

;-----------------------------------------------------------------------------;
;	CPU POWER-ON STARTUP LOCATION AT ffff:00
;-----------------------------------------------------------------------------;

ROM_BIOS SEGMENT AT 0ffffh
	org	0

PowerOnReset	LABEL FAR

ROM_BIOS ENDS

;-----------------------------------------------------------------------------;

include	MODEL.INC

;-----------------------------------------------------------------------------;

.CODE

RebootSystem PROC
	mov	ah,0Dh			;disk reset
	int	21h

	mov	AX,3515h
	int	21h			; Get int 15h vector in ES:BX
	mov	AX,ES			; AX == Segment
	or	AX,BX			; Is this a NULL ptr
	jz	WarmBoot		; If zero we can't do an int 15h

DoInt15:
	mov	ax, seg WarmBootFlag
	mov	ds, ax
	assume	DS:ROM_DATA

	mov	KB_FLAG,ALT_SHIFT OR CTL_SHIFT
	mov	AX,(KB_INTERCEPT SHL 8) OR DEL_KEY
	int	15h			; Put Ctrl/Alt/Del into key buffer

WarmBoot:
	cli
	cld

	mov	ax, seg WarmBootFlag
	mov	ds, ax
	assume	DS:ROM_DATA
	mov	WarmBootFlag, WARM_BOOT_CODE
	jmp	PowerOnReset
		; Jump to the processor power-on address FFFF:0000h

RebootSystem	ENDP

; ========================================================

	END

; ========================================================

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\memfree.asm ===
; ========================================================

COMMENT #

	MEMFREE.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	johnhe - 07/01/89

END COMMENT #

;========================================================

DOSSEG

include	MODEL.INC

.CODE

; ========================================================
; Returns number of free memory paragraphs available
; as a contigous block from DOS.
;
; unsigned GetMemoryFree( void )
;
; ========================================================

GetMemoryFree PROC

	mov	BX,0ffffh		; Set for max 1 meg memory
	mov	AH,48h			; Dos allocate memory function
	int	21h
	push	BX			; Put free para count on the stack
	jc	GetMemoryFreeRet	; If no carry need to free memory
	push	ES			; Save ES
	mov	ES,AX			; Put segment address in ES
	mov	AH,49h			; Dos free memory function
	int	21h
	pop	ES			; Restore ES
GetMemoryFreeRet:
	pop	AX			; Put max memory paragraphs in AX
	ret

GetMemoryFree ENDP

; ========================================================

	END

; ========================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\tsr_tog.asm ===
; ========================================================

COMMENT #

	TSR_TOG.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	johnhe - 03/03/89

END COMMENT #

;========================================================

MPLX			EQU	2fh

APPEND_ID		EQU	0b7h
APPEND_GET_STATE	EQU	6
APPEND_SET_STATE	EQU	7

ASSIGN_ID		EQU	6

APPEND_GET_DIRLIST	EQU	4
ASSIGN_GET_SEGMENT	EQU	1

MPLX_GET_STATE		EQU	0

APPEND_FLAG		EQU	1b
ASSIGN_FLAG		EQU	10b

DISK_TABLE_LEN		EQU	13	; 26 bytes converted to words

;========================================================

include BIOS_IO.INC
include	MODEL.INC


;========================================================

.DATA

MultiplexFlags		db	0

DisableBytes		db	';', 0	; Replacment 1st 2 bytes of dir list
AppendPtr		dd	(?)	; Address of APPEND dirlist
AssignPtr		dd	0103h
DiskTable		db	1,2,3,4,5,6,7,8,9,10,11,12,13, \
				14,15,16,17,19,20,21,22,23,24,25,26
AppendState		dw	0

; ========================================================

.CODE

; ========================================================
; void DisableAppend( void )
;
; Checks to see if APPEND has been installed and if it has
; disables it.
; ========================================================

DisableAppend PROC USES ES DI

	call	NEAR PTR TestForInt2f
	jz	ProcExit

InstallCheck:
	mov	AX,(APPEND_ID SHL 8) OR MPLX_GET_STATE  ; 0B700h
	int	2fh			; int 2fh
	cmp	AL,0ffh			; See if installed.
	jne	ProcExit		; Not installed so just return

	mov	AX,(APPEND_ID SHL 8) + APPEND_GET_STATE ; 0b706h
	mov	BX,0ffffh
	mov	CX,BX
	int	2fh
	cmp	BX,CX			; Did value in BX change
	je	UseOldMethod
	mov	AppendState,BX

NewMethod:
	xor	BX,BX
	mov	AX,(APPEND_ID SHL 8) + APPEND_SET_STATE ; 0b707h
	int	2fh
	jmp	SHORT ProcExit

UseOldMethod:
	mov	ES,CX			; Set ES to 0xffff
	mov	AX,(APPEND_ID SHL 8) OR APPEND_GET_DIRLIST ; 0B704h
	int	2fh

	mov	BX,ES			; See if ES got changed
	cmp	BX,CX
	jne	GotPtr			; If yes then save ES:DI

	mov	AX,0b701h		; This gets DIR list in 
	int	2fh			; append for DOS 3.2
	mov	BX,ES
	cmp	BX,CX
	je	ProcExit

GotPtr:
	mov	WORD PTR AppendPtr,DI	; Save offset of directory list
	mov	WORD PTR AppendPtr[2],ES ; Save segment of directory list
	mov	AX,WORD PTR DisableBytes ; Put disable bytes in AX
	xchg	AX,WORD PTR ES:[DI]	 ; Do a swap to disable APPEND
	mov	WORD PTR DisableBytes,AX ; Save original first 2 bytes.

ProcExit:
	ret	

DisableAppend ENDP

; ========================================================
; void EnableAppend( void )
;
; Checks to see if APPEND has been installed and if it has
; toggles it active or inactive depending on it's current
; state.
; ========================================================

EnableAppend PROC USES ES DI

	call	NEAR PTR TestForInt2f
	jz	ProcExit

InstallCheck:
	mov	AX,(APPEND_ID SHL 8) OR MPLX_GET_STATE  ; 0B700h
	int	MPLX			; int 2fh
	cmp	AL,0ffh			; See if installed.
	jne	ProcExit		; Not installed so just return

	mov	AX,(APPEND_ID SHL 8) + APPEND_GET_STATE ; 0b706h
	mov	BX,0ffffh
	mov	CX,BX
	int	2fh
	cmp	BX,CX			; Did value in BX change
	je	UseOldMethod

NewMethod:
	mov	BX,AppendState
	mov	AX,(APPEND_ID SHL 8) + APPEND_SET_STATE ; 0b707h
	int	2fh
	jmp	SHORT ProcExit

UseOldMethod:
	mov	ES,CX			; Set ES to 0xffff
	mov	AX,(APPEND_ID SHL 8) OR APPEND_GET_DIRLIST ; 0B704h
	int	2fh

	mov	BX,ES			; See if ES got changed
	cmp	BX,CX
	jne	GotPtr			; If yes then save ES:DI

	mov	AX,0b701h		; This gets DIR list in 
	int	2fh			; append for DOS 3.2
	mov	BX,ES
	cmp	BX,CX
	je	ProcExit

GotPtr:
	mov	WORD PTR AppendPtr,DI	; Save offset of directory list
	mov	WORD PTR AppendPtr[2],ES ; Save segment of directory list
	mov	AX,WORD PTR DisableBytes ; Put disable bytes in AX
	xchg	AX,WORD PTR ES:[DI]	 ; Do a swap to disable APPEND
	mov	WORD PTR DisableBytes,AX ; Save original first 2 bytes.

ProcExit:
	ret	

EnableAppend ENDP
; ========================================================
; void ToggleAssign( void )
;
; Checks to see if ASSIGN has been installed and if it 
; has toggles it active or inactive depending on it's
; current state.
; ========================================================

ToggleAssign PROC USES ES

	call	NEAR PTR TestForInt2f
	jz	ProcExit

	test	MultiplexFlags,ASSIGN_FLAG
	jnz	DoSwap

InstallCheck:
	mov	AX,(ASSIGN_ID SHL 8) OR MPLX_GET_STATE  ; 0600h
	int	MPLX			; int 2fh
	cmp	AL,0ffh			; See if installed.
	jne	ProcExit		; Not installed so just return
	or	MultiplexFlags,ASSIGN_FLAG ; Show Assign is installed
	mov	AX,(ASSIGN_ID SHL 8) OR ASSIGN_GET_SEGMENT ; 0601h
	int	MPLX			; int 2fh
	mov	WORD PTR AssignPtr[2],ES; Save ASSIGN segment

DoSwap:
	call	NEAR PTR SwapDiskTable	; Switch disk table

ProcExit:
	ret	

ToggleAssign ENDP

; ========================================================
; Swaps the 26 bytes in Assign's disk table with those
; in our disk table.
; ========================================================

SwapDiskTable PROC NEAR  USES DS SI ES DI

	les	DI,AssignPtr		; Set up ES:DI

	mov	SI,offset DiskTable	; Set up DS:SI
	mov	CX,DISK_TABLE_LEN	; Number of words in disktable
	cld				; Set direction to forward
StartLoop:
	mov	AX,ES:[DI]		; Put 2 entries into AX
	xchg	AX,[SI]			; Swap with our Disk Table
	stosw				; Put our entries in Assign's table
					; also increments DI twice
	inc	SI			; Increment SI twice
	inc	SI
	loop	StartLoop		; Loop until entire table is swapped
ProcExit:
	ret

SwapDiskTable ENDP


; ========================================================
; Tests to see if the int 2fh vector has been initialized
; by making sure it's not pointing to 00:00
;
; RETURNS:	NZ - If vector is initialize
;		ZR - If vector is not initialized
; ========================================================

TestForInt2f	PROC NEAR

	push	DS
	xor	AX,AX		; Make sure vector 0x2f is initialized
	mov	BX,2fh*4
	mov	DS,AX	
	mov	AX,[BX]
	or	AX,[BX+2]	; Is vector 2fh initialized ?
	pop	DS
	ret

TestForInt2f	ENDP

; ========================================================

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\video.inc ===
;========================================================

COMMENT #

	VIDEO.INC

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	Definitions for assembly language video fuctions.
	Must be include in BIOS_IO.ASM

	johnhe - 03/03/89
		 01/12/90	Converted to lib form

END COMMENT #

;========================================================

VIDEO_INT         EQU     10h         ; Video interrupt
KB_INT            EQU     16h         ; Keyboard interrupt
SET_VIDEO_MODE    EQU     00h         ; Set video mode function
SET_CURS_SIZE     EQU     01h         ; Set cursor size
SET_CURS_POS      EQU     02h         ; Modify cursor posn
GET_CURS_POS      EQU     03h         ; Read current cursor posn
READ_LIGHT_PEN    EQU     04h         ; Read light pen position
SET_VIDEO_PAGE    EQU     05h         ; Set screen page
SCROLL_UP         EQU     06h         ; Scroll screen up
SCROLL_DOWN       EQU     07h         ; Scroll screen down
READ_CHAR_ATTR    EQU     08h         ; Get char & attrib from scr
WRITE_CHAR_ATTR   EQU     09h         ; Write character & attrib
WRITE_CHAR_ONLY   EQU     0ah         ; Write character to scr
SET_GRAPHIC_PAL   EQU     0bh         ; Set graphics palete
WRITE_GRAPHIC     EQU     0ch         ; Write a graphic pixel
READ_GRAPHIC      EQU     0dh         ; Read a graphic pixel
WRITE_TTY         EQU     0eh         ; Write char & move cursor
GET_VIDEO_MODE    EQU     0fh         ; Get video mode & disp pg
MAX_SCR_ROW       EQU     24          ; Max row # on screen
ZERO_FLAG         EQU     40h         ; Bit 6 of the flags
BEL			          EQU     07h         ; ASCII BEL character

ASCII_CR	EQU	13
ASCII_LF	EQU	10

; =======================================================
; Equates
; =======================================================
KBD_INT           EQU   16h     ; Bios keyboard interrupt
KBD_GET_CHAR      EQU   00      ; Get char from keyboard buffer
KBD_IS_WAITING    EQU   01      ; See if character is waiting
KBD_GET_STATUS    EQU   02      ; Return shift status

COLOR_BIT         EQU     000001b
EGA_BIT           EQU     000010b
FAST_BIT          EQU     000100b


; =========================================================================
; Macro which does an explicit NEAR or FAR call based on the memory
; model.
; =========================================================================

call_M	MACRO	Function

IF 	@codesize			; Call adjusted for memory model

	call	FAR PTR Function	; FAR call if LARGE, MED, or HUGE
ELSE
	call	NEAR PTR Function	; Else NEAR call
ENDIF

ENDM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\win_chk.asm ===
; ========================================================

COMMENT #

	WIN_CHK.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	Change Log:

    	Date      Who   NUMBER		Description
  	--------  ---  ----	---------------------------------------------
        11/06/90  JAH           Created
        09/14/92  ECH           Now detects Standard-mode Windows, and DosShell

END COMMENT #

;========================================================

include BIOS_IO.INC
include	MODEL.INC

;========================================================

.CODE


; ========================================================
; Determines if currently in a Windows 3.0 VM.
; (Stolen from MSD 2.0)
;
; int IsNotWindows( void );
;
; ARGUMENTS:	NONE
; RETURNS:	int	- TRUE if not a windows VM else FALSE
;
; ========================================================

IsNotWindows PROC USES ES

      ; Check for Windows 3.1
        mov     ax,160Ah                ; WIN31CHECK
        int     2Fh                     ; check if running under win 3.1
        or      ax,ax
        jnz     Win30EnhModeCheck
        jmp     short InDosBox

      ; Check for 3.0 Enhanced mode
      Win30EnhModeCheck:
        mov     ax,1600h                ; WIN386CHECK
        int     2Fh
        test    al,7Fh
        jz      Win286Check
        jmp     short InDosBox

      ; Check for Windows/286
      ; Doubt it's needed, but i left it in anyway...
      Win286Check:
        mov     ax,1700h                ; WIN286CHECK
        int     2Fh
        cmp     al,2h                   ; If /286 installed, ver = AL.AH
        jnz     WinOldApCheck           ; /286 is always 2.x
        jmp     short InDosBox

      ; Check for WINOLDAP (also checks for DOS5 task swapper)
      WinOldApCheck:
        mov     ax,4680h                ; IS_WINOLDAP_ACTIVE
        int     2Fh
        or      ax,ax                   ; running under 3.0 derivative ?
        jz      InDosBox

      ;
      ; So now we know we're not in a Windows or DosShell dos box.
      ;
      ; NOTES:
      ;    Doesn't detect DosShell box if task swapper not active.
      ;    Don't yet know if it detects OS/2 1.x or 2.x.
      ;

        mov     ax, 1
        jmp     short ExitIt
InDosBox:
        xor     ax, ax
ExitIt:
        ret

IsNotWindows ENDP






IF 0

; ========================================================
; Determines if currently in a Windows 3.0 VM.
;
; int IsNotWindows( void );
;
; ARGUMENTS:	NONE
; RETURNS:	int	- TRUE if not a windows VM else FALSE
;
; ========================================================

IsNotWindows PROC USES ES

	mov	AX,352fh		; Get int 2fh vector
	int	21h
	mov	AX,ES			; Move segment value to AX
	or	AX,BX			; Is this a NULL ptr
	mov	AX,1			; AX == TRUE if int 2f not valid
	jz	ExitCheck		; Not windows on NULL ptr

	mov	AX,1600h		; Windows int 2fh interface
	int	2fh
	mov	BX,AX			; Move version into BX
	mov	AX,1			; AX == TRUE == windows not runnning

	or	BL,BL			; If BL == 0 then not windows
	je	ExitCheck

	cmp	BL,80h			; Else if BL == 0x80 then not windows
	je	ExitCheck
	xor	AX,AX			; Must be windows so set to FALSE
	

ExitCheck:
	ret

IsNotWindows ENDP

ENDIF


END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\bios\video.asm ===
; ========================================================

COMMENT #

	VIDEO.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	Video initialization function. This function
	must be called before any of the other vio
	library functions.


	johnhe - 03/03/89

END COMMENT #

;========================================================

include	VIDEO.INC
include	MODEL.INC

;========================================================

;
; These display values MUST match the manifest constants in include\bios_io.h!
;
MONO        EQU     0
CGA         EQU     1
EGA         EQU     2
EGA_MONO    EQU     3
VGA         EQU     4
VGA_MONO    EQU     5
HERC        EQU     6
MCGA        EQU     7
GAD_8514    EQU     8
ifdef JAPAN
JEGA        EQU     9
endif

HercStatusPort       equ   03BAH       ; Hercules status port
idmask_112           equ   00110000B   ; ID mask for GB112
idcode_112           equ   00010000B   ; ID code for GB112

idmask_222           equ   01110000B   ; ID mask for GB222
idcode_222           equ   01010000B   ; ID code for GB222

IO_Delay macro
         jmp       $+2
         jmp       $+2
endm

;========================================================

SCREEN   SEGMENT AT 0B800H
SCREEN   ENDS

;========================================================

BIOS_DATA SEGMENT AT 40h
	ORG	87h

CursorEmulation	db	?

BIOS_DATA ENDS

;========================================================

.DATA

;========================================================

PUBLIC  ScreenBuffer, ScreenWidth, ScreenLength
PUBLIC  DisplayType, VideoAddress, ScreenPage

VideoAddress	dd	0b800000h	; Default to mono

BackGrColor	db	00	; Default background color
TextColor	db	07	; Default text color
ReverseText	db	00	; Default reverse text color
ReverseBkGr	db	07	; Default reverse background color
ScreenColor	db	07	; Current attribute

ScreenBuffer	dw	?	; Address of display buffer
ScreenWidth	db	80	; Current screen width, columns
ScreenLength	db	25	; Current number of rows on screen
ScreenMode	db	3	; Current video mode
ScreenPage	db	0	; Current video page

CursorSize	dw	?	; Current cursor size

;; Next three lines are for VideoSaveMode and VideoRestoreMode
SaveScreenMode	db	3	; Saved video mode
SaveScreenRows	db	25	; Saved number of rows on screen
SaveCursorSize	dw	?	; Save cursor size
EmulationSave	db	?	; Cursor emulation value for EGA

DisplayType	db	0	; 0 = MONO
				; 1 = CGA
				; 2 = EGA
				; 3 = EGA MONO
				; 4 = VGA
				; 5 = VGA MONO
				; 6 = HERC
				; 7 = MCGA
                            ; 8 = 8514

MonitorType	db	0	; 0 == mono and 1 == color

IsBadATI	db	0	; m112

;========================================================

.CODE

;========================================================
; Simple video detection which only looks at the
; current video mode to detect either CGA or MDA.
;========================================================

MinVideoInitial PROC			; M100 minimum video detection

	mov	AH,0fh
	int	10h
	cmp	AL,07			; See if monochrome video mode
	je	IsMDA			; If it is return not CGA

IsCGA:
	mov	DisplayType,CGA
	mov	MonitorType,1
	mov	AX,03
	jmp	SHORT SetDefaultVideoMode

IsMDA:
	mov	DisplayType,MONO
	mov	MonitorType,0
	mov	AX,07

SetDefaultVideoMode:
	mov	AH,SET_VIDEO_MODE
	int	10h
	mov	AX,SET_VIDEO_PAGE SHL 8	; Mov AH value and AL 0
	int	10h			; Set video page to 0

	call_M	<VideoNormalCurs>	; Make a normal cursor
	call_M	<VideoGetMode>		; Save all video info

	ret

MinVideoInitial	ENDP			; M100 - end of this change

;========================================================
; void	VideoInitial( void );
; Initializes the video data, must be called before any
; other video function. Will also set screen to 25 lines
; if EGA or VGA and set page to 1 for color systems.
;========================================================

VideoInitial	PROC USES ES SI

	mov	MonitorType,0

Step1:
	mov	AX,1a00h		; read display combination code
	int	10h
	cmp	AL,1ah			; function supported ?
	jne	Step2			; No, Try other tests.

		; BL contains active display code. I have however, seen that
		; on some vga cards this call will return the active display
		; in BH. For this reason need to chk BL for zero, if BL is
		; zero we place BH into BL and assume that the only display
		; attached to the system is the active display.

	or	BL,BL			; Do we have an active display ?
	jnz	ChkEga			; Yes, then continue on normally.
	mov	BL,BH			; No.

ChkEga:
	mov	SI,EGA			; Assume it's EGA
	cmp	BL,4			; Chk for EGA color
	je	GotColorVideoType

	inc	SI			; Now assume EGA mono
	cmp	BL,5			; Chk for EGA mono
	je	GotVideoType

ChkVga:
	inc	SI			; Not EGA mono so assume VGA color
	cmp	BL,8			; Chk for VGA color
	je	TestFor8514

	inc	SI			; Not VGA color so assume VGA MONO
	cmp	BL,7			; Chk for VGA mono
	je	TestFor8514
	jmp	SHORT McgaCheck

TestFor8514:
    ;
    ; Before testing for 8514 lets make sure there is no Arcnet
    ; Card at I/O address 2e8h which would be reset by the 8514
    ; detection.
    ;
    call    ArcnetCardPresent
    or      ax, ax
    jnz     Test_ATI

    call	NEAR PTR Detect8514	; Adjust for 8514

    cmp     si, GAD_8514
	je	GotColorVideoType

		; m112  At this point we've detected VGA so now
		; m112  check for ATI Wonder Card or ATI VIP Card
Test_ATI:
	call	ATI_Check		; m112 Return AX == 1 if bad card
	mov	IsBadATI,AL		; m112 else AX == 0

	cmp	SI,VGA			; Decide if Mono or Color display
	je	GotColorVideoType
	jmp	SHORT GotVideoType

McgaCheck:
	mov	SI,MCGA
	mov	AL,BL
	cmp	AL,0ah			; Test for digital color
	je	GotColorVideoType
	cmp	AL,0bh			; Test for analog mono
	je	GotVideoType
	cmp	AL,0ch			; Test for analog color
	je	GotColorVideoType

ChkCga:
	mov	SI,CGA			; Assume it may be CGA
	cmp	BL,1			; Make sure it's not mono
	jne	SHORT GotColorVideoType

	mov	SI,MONO			; Must now assume it's mono
	jmp	SHORT GotVideoType

Step2:
	mov	SI,EGA			; First assume EGA
	mov	AH, 12h
	mov	BL, 10h			; Get EGA info
	int	10h
	cmp	BL, 10h
	je	Step3			; Not an EGA
	or	BH,BH			; If BH==0 then EGA color system
	jz	GotColorVideoType
	inc	SI
	jmp	SHORT GotVideoType	; Else BH==1 and EGA_MONO system

Step3:
	mov	SI,HERC			; Must check for HERC before CGA
	call	NEAR PTR HercCheck	; because a herc will pass the
	or	AX,AX			; the CGA test and not be detected
	jnz	GotVideoType

	call	NEAR PTR CgaCheck	; Returns true if SI is correct
	or	AX,AX
	jnz	GotColorVideoType

	xor	SI,SI			; Must be MONO or HERC
	jmp	SHORT GotVideoType
	

GotColorVideoType:
	inc	MonitorType		; Signal to use colors

GotVideoType:
	mov	AX,SI
	mov	DisplayType,AL		; Save the working display type

SetMode:
	mov	AL,07			; Assume Mono
	or	SI,SI			; Is this a mono system
	jz	DoInt
	cmp	SI,HERC			; Herc also uses mode 7
	je	DoInt

	cmp	SI,CGA
	je	SetCO80
					; Will only get here is EGA or VGA
	cmp	SI,VGA
	je	SetVgaScan
    cmp     SI,GAD_8514
	je	SetVgaScan
	cmp	SI,VGA_MONO
	je	SetVgaScan

SetEgaScan:
	mov	AH,12h			; Get video EGA configuration
	mov	BL,10h
	int	10h
	test	BL,11b			; See if only 64K of video memory
	jz	FakeCga

TestSwitches:
	cmp	CL,8
	je	FakeCga			; I002
	cmp	CL,7			; I002 CGA Display on EGA w/256k memory?
	jne	DisableCursorEmulation	; I002

FakeCga:
	mov	SI,CGA			; Since only 64K assume CGA system
	jmp	SHORT SetCO80

DisableCursorEmulation:
	mov	AX,BIOS_DATA		; Need to update bit 1 of 40h:87h
	mov	ES,AX
	ASSUME	ES:BIOS_DATA

	mov	AL,ES:CursorEmulation
	mov	EmulationSave,AL
	and	EmulationSave,1		; Mask off emulation bit
	
	and	AL,0feh			; Disable ROM BIOS cursor emulation
	mov	ES:CursorEmulation,AL	; Replace the updated value
	mov	AX,1201h		; Set scan lines to 350
	jmp	SHORT SetScanLines

SetVgaScan:
	cmp	IsBadATI,0		; m112 See if bad ATI card
	jnz	SetCO80			; m112 If ATI don't set scan lines

	mov	AX,1200h		; AL == disable cursor emulation
	mov	BL,34h			; BL == Cursor emulation function
	int	10h
	mov	AX,1202h		; Set scan lines to 400

SetScanLines:
	mov	BL,30h			; This sets the scan lines but we
	int	10h			; have to fall thru and do a video
					; set mode for it to take effect
SetCO80:
	mov	AL,03			; Set for color 80 columns text

DoInt:
	mov	AH,SET_VIDEO_MODE
	int	10h

	mov	AX,1111h		; If EGA load 8x14 character set
	cmp	SI,EGA
	je	SetFont
	cmp	SI,EGA_MONO
	je	SetFont

	cmp	IsBadATI,0		; m112 See if bad ATI card
	jnz	SetPage			; m112 If ATI don't set scan lines

	mov	AX,1114h		; If VGA load 8x16 character set
	cmp	SI,VGA
	je	SetFont
	cmp	SI,GAD_8514
	je	SetFont
	cmp	SI,VGA_MONO
	jne	SetPage

SetFont:
	xor	BL,BL
	int	10h

SetPage:
	mov	AX,SET_VIDEO_PAGE SHL 8	; Mov AH value and AL 0
	int	10h			; Set video page to 0


SetCursorType:
	cmp	SI,EGA_MONO		; Final check to see if we have
	je	@f			; EGA or VGA mono and need to
	cmp	SI,VGA_MONO		; use mono text attributes
	jne	CursorSet
@@:
	mov	MonitorType,0		; 

CursorSet:
	call_M	<VideoNormalCurs>	; Make a normal cursor
	call_M	<VideoGetMode>		; Save all video info
	ret

VideoInitial ENDP

;***************************************************************************
;*
;* ArcnetCardPresent - Detects the presence of an Arcnet Card
;*
;* ENTRY: None.
;*
;* EXIT: Boolean
;*       AX = 1 , Arcnet Card Probably present
;*       AX = 0 , Arcnet Card Probably NOT Present
;*
;***************************************************************************
ArcnetCardPresent PROC NEAR USES SI
LOCAL InputBytes[4]:BYTE
LOCAL ACP_First:BYTE

      ; Read a BYTE from four different 16-bit I/O addresses that have
      ; the same lower 10 bits (2E0h).  2E0h is the address of the Status
      ; register for the Arcnet Cards that tend to be reset easily
      ; (a Read or write to I/O addresses 2E8, 2E9, 2EA, OR 2EB).
      ; Store the BYTE in InputBytes
      ;
      mov   dx, 56E0h
      IO_Delay
      in    al, dx
      mov   InputBytes, al

      mov   dx, 0AAE0h
      IO_Delay
      in    al, dx
      mov   InputBytes+1, al

      mov   dx, 0E2E0h
      IO_Delay
      in    al, dx
      mov   InputBytes+2, al

      mov   dx, 1EE0h
      IO_Delay
      in    al, dx
      mov   InputBytes+3, al

      xor   si, si                  ; Clear the loop counter

ACP_Loop:
      mov   al, [InputBytes+si]     ; Read a byte from table

      cmp   al, 0FFh                ; If it is FF or E0 (low Byte of I/O
      je    NoArcNet                ;  address we will assume that we read
                                    ;  air.
      cmp   al, 0E0h
      je    NoArcNet

      and   al, 78h                 ; bits 6 through 3 (0XXX X000) should
                                    ;  be constant

      cmp   si, 0h                  ; Is it first byte read ?
      je    ACP_First_Pass

      cmp   ACP_First, al           ; is it equal to the first Byte read
      jne   NoArcNet

      inc   si                      ; point to next byte in table
      cmp   si, 4d                  ; have we done all four bytes
      je    ArcNetFound             ; Yes, we have found an Arcnet Card

      jmp   ACP_Loop

ACP_First_Pass:
      mov   ACP_First, al           
      inc   si                      ; point to next byte in table
      jmp   ACP_Loop
      

ArcNetFound:
      mov   ax, 1                   ; return TRUE
      jmp   short ACP_End

NoArcNet:
      xor   ax, ax                  ; return FALSE

ACP_End:
    ret
ArcnetCardPresent ENDP

;========================================================
; void pascal VideoGetMode( void );
; Returns current video mode and does setup of the
; static variables containing screen setup
;========================================================

VideoGetMode  PROC

	mov	AH,GET_VIDEO_MODE
	int	10h
	mov	ScreenPage,BH
	mov	ScreenMode,AL
	mov	ScreenWidth,AH
	mov	ScreenBuffer,0B000h ; Assume mono
	mov	WORD PTR VideoAddress[2],0B000h
	cmp	AL,07
	je	ReturnMode
	mov	ScreenBuffer,0B800h ; Set to address of color memory
	mov	WORD PTR VideoAddress[2],0B800h
ReturnMode:
	mov	WORD PTR VideoAddress,0B000h	; Alway on page 1
	cbw			    ; Convert AL to integer
	ret

VideoGetMode ENDP

;========================================================
; VideoSetMode() attempts to set the video mode
; passed as the argument. Returns new current mode
;========================================================

VideoSetMode	PROC	NewMode:BYTE

	mov	AL,NewMode	    ; Get new mode in AX
	mov	AH,SET_VIDEO_MODE
	int	10h
	call_M	<VideoGetMode>	    ; Update static video variables
	ret			    ; Returns new video mode in AX

VideoSetMode ENDP

;========================================================
; VideoSaveMode() saves the number of lines currently
; displayed.  The information is saved in global storage
; so that it can later be restored. The video mode along
; with the cursor size is also saved so it can later be
; restored.
;
;========================================================

VideoSaveMode	PROC

	mov	ah,0Fh			; (AH) = 0Fh
	int	10h			; transfer to bios
	mov	SaveScreenMode,al	; save video mode
        push	es			; save ES since next call trashes it
        push	bp			; save BP since next call trashes it
	mov	ax,1130h	        ; (AX) = 1130h
	xor	bx,bx			; (BX) = 0 
	int 	10h                     ; get current char generator info
	mov	SaveScreenRows,dl	; save the number of rows (DL)
        pop	bp			; restore BP
        pop	es			; restore ES

	mov  	ah,03h			; (AH) = 03h
	xor  	bx,bx                   ; (BX) = 0
	int  	10h                     ; get cursor size
	mov  	SaveCursorSize,cx	; save the cursor size (CX)
	ret

VideoSaveMode ENDP

;========================================================
; VideoRestoreMode() restores the video mode to the state
; it was in when VideoSaveMode was called.
;========================================================

VideoRestoreMode PROC

	mov	ah,0			; (AH) = 0
	mov	al,SaveScreenMode	; (AL) = attribute byte
	int	10h			; transfer to bios

	mov	ah,SaveScreenRows	; (AH) = number of rows
	cmp	ah,25                   ; if previously 43 line mode then
	jbe	short VRestoreDone	;   restore that mode

	mov	ax,1112h		; (AX) = 1112h, 8 X 8 char defs
	mov	bl,0                    ; (BL) = 0
	mov	dl,SaveScreenRows	; (DL) = number rows, 2bh = 43 decimal
	int	10h			; load graphics char def
	mov	ax,1200h		; (AX) = 1200h
	mov	bl,20h			; (BL) = 20h
	int	10h			; print screen code must find correct
					;   number of rows to print
VRestoreDone:
	cmp	DisplayType,EGA		; May need to restore cursor
	jne	SetCursSize		; emulation on EGA systems

	push	ES
	mov	AX,BIOS_DATA		; Need to update bit 1 of 40h:87h
	mov	ES,AX
	ASSUME	ES:BIOS_DATA
	and	ES:CursorEmulation,0feh	; Disable ROM BIOS cursor emulation
	mov	AL,EmulationSave	; EmulationSave has only has lsb
	or	ES:CursorEmulation,AL	; so it only affects lsb of 
	pop	ES			; CursorEmulation

SetCursSize:
	mov  ah,01h			; (AH) = 1
	mov  cx,SaveCursorSize		; (CX) = cursor size
	int  10h                        ; restore the cursor
	ret

VideoRestoreMode ENDP

;========================================================
; Returns true if a color card is active
;========================================================

VideoIsColor  PROC

	mov	AL,MonitorType		; Monitor type == 0 if mono or 1
	cbw				; for color
	ret

VideoIsColor ENDP

;========================================================
; Sets active display page
;========================================================

VideoSetPage PROC  ScrPage:BYTE

	mov	AL,ScrPage
	mov	AH,SET_VIDEO_PAGE
	int	10h
	call_M	<VideoGetMode>	    ; Update static video variables
	ret

VideoSetPage ENDP

;========================================================
; Get current cursor position. The top byte of the
; return value holds the row, the bottom by the
; column.
;========================================================

VideoGetRowCol PROC

	mov	AH,GET_CURS_POS
	mov	BH,ScreenPage
	int	10h
	mov	CursorSize,CX		; Save current cursor size
	mov	AX,DX			; Put cursor pos in AX for return value
	ret

VideoGetRowCol ENDP

;========================================================
; Modify current cursor position.
;========================================================

VideoSetRowCol  PROC Row:BYTE, Column:BYTE

	mov	AH,SET_CURS_POS
	mov	BH,ScreenPage
	mov	DH,BYTE PTR Row		; Put Row in CL
	mov	DL,BYTE PTR Column	; Put Column in DL
	int	10h
	ret

VideoSetRowCol ENDP

;========================================================
; Functions to set cursor size
;========================================================

VideoSetCursSize PROC CurSize:WORD

	mov	BH,ScreenPage
	mov	CX,CurSize
	mov	AH,SET_CURS_SIZE
	int	10h
	mov	CursorSize,CX	     ; Save the new cursor size
	ret

VideoSetCursSize ENDP

;========================================================
;========================================================

VideoGetCursSize  PROC
	mov	AX,CursorSize
	ret
VideoGetCursSize ENDP

;========================================================
;========================================================

VideoCursOff  PROC

	cmp	ScreenMode,4		; Make sure not in graphics mode
	jl	CutOff
	cmp	ScreenMode,7
	je	CutOff
	jmp	SHORT CutOffReturn

CutOff:
	mov	AL,DisplayType
	cmp	AL,EGA
	je	IsHighRes
	cmp	AL,VGA
	je	IsHighRes
	cmp	AL,GAD_8514
	je	IsHighRes
	cmp	AL,EGA_MONO
	je	IsHighRes
	cmp	AL,VGA_MONO
	je	IsHighRes

	mov	CX,0f00h		; Put cutoff size in CX
	jmp	SHORT TurnItOff

IsHighRes:

	mov	CX,1000h
TurnItOff:
	mov	AH,SET_CURS_SIZE
	mov	BH,ScreenPage
	int	10h
	mov	CursorSize,CX		; Save the new cursor size
CutOffReturn:
	ret

VideoCursOff ENDP

;========================================================
; Make the cursor a block curser
;========================================================

VideoBlockCurs  PROC

	mov	CX,0007h		; Assume color screen
	cmp	ScreenMode,7
	jne	SetBlock
	mov	CX,000bh		; Was mono screen
SetBlock:
	mov	AH,SET_CURS_SIZE
	mov	BH,ScreenPage
	int	10h
	mov	CursorSize,CX		; Save the new cursor size
	ret

VideoBlockCurs ENDP

;========================================================
; Make it an underline cursor
;========================================================

VideoNormalCurs  PROC

	mov	CX,0607h		; Assume color screen
	cmp	ScreenMode,7
	jne	SetNormal
	mov	CX,0a0bh		; Was mono screen
SetNormal:
	mov	AH,SET_CURS_SIZE
	mov	BH,ScreenPage
	int	10h
	mov	CursorSize,CX		; Save the new cursor size
	ret

VideoNormalCurs ENDP

; =======================================================
; void VideoPutChar( char Character);
;
; Displays a character at the current cursor position on the screen and
; advances the cursor to the next character position.
; =======================================================

VideoPutChar PROC Character:BYTE

	mov	AH,WRITE_TTY		; BIOS tty video output
	mov	AL,BYTE PTR Character	; Put the character in AL
	mov	BH,ScreenPage		; Put page number in BH
	int	10h			; BIOS video call
	ret				; Return to caller

VideoPutChar ENDP

; =======================================================
; void VideoPutCharRowCol( int Row, int Col, int Character )
;
; Displays a character at the specified row and column on the screen.
; Cursor will end up at the specified row and column position.
; =======================================================

VideoPutCharRowCol  PROC Row:BYTE, Col:BYTE, Character:BYTE
					; Set the cursor position
	mov	AH,SET_CURS_POS		; Put function number in AH
	mov	AL,BYTE PTR Character	; Put the character in AL
	mov	DH,BYTE PTR Row	     	; Put screen row in DH
	mov	DL,BYTE PTR Col	     	; Put screen column in DL
	mov	BH,ScreenPage		; Put page number in BH
	push	BP
	int	10h			; Let BIOS set the cursor position
	pop	BP
	mov	AL,BYTE PTR Character	; Put the character to display in AL
	mov	AH,WRITE_CHAR_ONLY	; Display the character in AL
	mov	CX,1			; Set to display 1 character
	int	10h			; Let BIOS set the cursor position
	ret				; Return to caller

VideoPutCharRowCol  ENDP

; =======================================================
;   VideoPutCharAttr( Row, Col, Character, Color )
;
; Displays a character at the specified row and column on the screen  with
; the specifed screen attribute. Cursor will end up at the specified row
; and column position.
; =======================================================

VideoPutCharAttr  PROC Row:BYTE, Col:BYTE, Character:BYTE, Color:BYTE

					; Set the cursor position
	mov	AH,SET_CURS_POS		; Put function number in AH
	mov	DH,BYTE PTR Row	     	; Put screen row in DH
	mov	DL,BYTE PTR Col	     	; Put screen column in DL
	mov	BH,ScreenPage		; Put page number in BH
	push	BP
	int	10h			; Let BIOS set the cursor position
	pop	BP
	mov	AH,WRITE_CHAR_ATTR	; Display the character in AL
	mov	AL,BYTE PTR Character	; Put the character to display in AL
	mov	BH,ScreenPage		; Put display in BH
	mov	BL,BYTE PTR Color	; Put display attribute in BL
	mov	CX,1			; Set to display 1 character
	int	10h			; Let BIOS set the cursor position
	ret				; Return to caller

VideoPutCharAttr  ENDP

ifdef JAPAN
;
;	for Double Byte Character
;
VideoPutDBCharAttr  PROC Row:BYTE, Col:BYTE, Character:WORD, Color:BYTE

	mov	AX,Character		; Display the character in AX
	mov	DH,BYTE PTR Row	     	; Put screen row in DH
	mov	DL,BYTE PTR Col	     	; Put screen column in DL
	mov	BL,BYTE PTR Color	; Put display attribute in BL
	call	NEAR PTR write_dbchar	; display it
	ret				; Return to caller

VideoPutDBCharAttr  ENDP

;
;	Write Double Byte Character
;
;	input:	AX = character
;		BL = color
;		DH = cursor row
;		DL = cursor column
;	output:	DL = next column
;
write_dbchar PROC NEAR
	push	ax
	mov	ah,SET_CURS_POS
	mov	bh,ScreenPage
	int	10h			; set cursor in DX
	pop	ax
	push	ax
	xchg	al,ah
	mov	ah,WRITE_CHAR_ATTR
	mov	bh,ScreenPage
	mov	cx,1
	int	10h			; display lead byte
	mov	ah,SET_CURS_POS
	mov	bh,ScreenPage
	inc	dl			; next column
	int	10h
	pop	ax
	push	ax
	mov	ah,WRITE_CHAR_ATTR
	mov	bh,ScreenPage
	mov	cx,1
	int	10h			; display tail byte
	inc	dl
	pop	ax
	ret
write_dbchar	endp

endif


; =======================================================
; void	VideoPuts( char *String )
; =======================================================

IF @DataSize
  VideoPuts PROC USES DS SI, String:PTR
ELSE
  VideoPuts PROC USES    SI, String:PTR
ENDIF

	mov	BH,ScreenPage		; Put current display page in BH
;	lds	SI,String		; DS:SI --> String to display
	LoadPtr	DS, SI, String		; DS:SI --> String to display

NextChar:
	mov	AH,WRITE_TTY		; Put tty write function in AH
	cld				; KEEP IN THE LOOP
	lodsb				; Put character into AL
	and 	AL,AL			; See if EOL character
	jz	EndPuts 		; If AL == 0 we're finished
	int	10h			; Display the character
	jmp	SHORT NextChar

EndPuts:
	ret

VideoPuts ENDP

; =======================================================
; void  VideoPutsRowCol( int Row, int Col, char *String )
; =======================================================

IF @DataSize
  VideoPutsRowCol PROC USES DS SI, Row:BYTE, Col:BYTE, String:PTR
ELSE
  VideoPutsRowCol PROC USES    SI, Row:BYTE, Col:BYTE, String:PTR
ENDIF
					; Set cursor to Row,Col
					; Access all variables in .DATA
					; before changing DS
	mov	AH,SET_CURS_POS		; BIOS set cursor function
	mov	BH,ScreenPage		; Put current display page in BH
	mov	DH,Row			; Put screen row in DH
	mov	DL,Col			; Put screen column in DL
	int	10h			; BIOS video call

        mov     BH,ScreenPage           ; Load screen page again.  Paranoia
                                        ; in case some video BIOS changes BH.
                                        ; Probably not necessary.
GetPtrToString:
;	lds	SI,String		; DS:SI --> String to display
	LoadPtr	DS, SI, String		; DS:SI --> String to display

LoadNextChar:
	mov	AH,WRITE_TTY		; Put tty write function in AH
	cld				; KEEP IN THE LOOP
	lodsb				; Put character into AL
	and 	AL,AL			; See if EOL character
	jz	EndPutsRowCol		; If AL == 0 we're finished
	int	10h			; Display the character
	jmp	SHORT LoadNextChar

EndPutsRowCol:
	ret

VideoPutsRowCol ENDP

; =======================================================
; void  VideoPutsAttrRowCol( int Row, int Col, char *String, int Attr )
; =======================================================

VideoPutsAttrRowCol PROC USES ES SI, Row:BYTE, Col:BYTE, \
				     String:PTR, Attr:BYTE

					; Set cursor to Row,Col
	mov	AH,SET_CURS_POS		; BIOS set cursor function
	mov	BH,ScreenPage		; Put current display page in BH
	mov	DH,BYTE PTR Row	     	; Put screen row in DH
	mov	DL,BYTE PTR Col	     	; Put screen column in DL
	push	BP
	int	10h	; BIOS video call
	pop	BP
SetUpForStringDisplay:
;	les	SI,String		; Put pointer to string in DS:SI
	LoadPtr	ES, SI, String		; ES:SI --> String to display

PutNextCharAttr:
	cld				; Set direction to forward
	mov	AL,ES:[SI]		; Put next character into AL
	inc	SI			; Increment string pointer
	or	AL,AL			; Check for EOL marker ('\0')
	jz	EndPutsAttrRowCol	; If EOL then we're finished

	cmp	AL,ASCII_LF		; Check for line feed char ('\n')
	jnz	NormalPutsAttrRowCol	; Ok to display the character

DisplayLfCr:
;	inc	SI			; Skip over this character
	mov	AL,ASCII_CR		; Use tty output to scroll screen
	mov	AH,WRITE_TTY		; BIOS tty video output
	mov	BH,ScreenPage		; Put page number in BH
	push	BP
	int	10h			; BIOS video call
	pop	BP
	mov	AL,ASCII_LF		; Use tty output to scroll screen
	mov	AH,WRITE_TTY		; BIOS tty video output
	int	10h			; BIOS video call

UpdateScreenPosition:
	mov	BH,ScreenPage		; Put page number in BH
	mov	AH,GET_CURS_POS		; Get curs position function
	push	BP
	int	10h			; BIOS video call
	pop	BP
	jmp	SHORT PutNextCharAttr	; Go back and do next character

NormalPutsAttrRowCol:
	mov	AH,WRITE_CHAR_ATTR	; Display char & attr function
	mov	BH,ScreenPage		; Put page number in BH
	mov	BL,BYTE PTR Attr	; Put char attribute in BL
	mov	CX,1			; Put # of chars to display in CX
	push	BP
	int	10h			; BIOS video call
	pop	BP
	inc	DL			; Increment DL to next col position
	cmp	DL,ScreenWidth		; Check for last screen column
	jc	SetScreenLocation	; If not past last column move curs
	mov	DL,0			; Else do a cariage return
	inc	DH			; and increment the row
	cmp	DH,ScreenLength 	; See if past bottom of screen
	jc	SetScreenLocation	; If not move the cursor
	jmp	SHORT DisplayLfCr	; Else do a CR-LF
SetScreenLocation:
	mov	AH,SET_CURS_POS		; BIOS set cursor function
	mov	BH,ScreenPage		; Put current display page in BH
	push	BP
	int	10h			; BIOS video call
	pop	BP
	jmp	SHORT PutNextCharAttr
EndPutsAttrRowCol:
	ret				; Finished displaying the string

VideoPutsAttrRowCol ENDP

; =======================================================
; void  VideoDupAttr( int Row, int Col, int Attr, int DupFactor )
; =======================================================

VideoDupAttr PROC USES ES DI, Row:BYTE, Col:BYTE, Attr:BYTE, Count:WORD

	mov	AH,GET_CURS_POS		; Save the initial cursor position
	mov	BH,ScreenPage		; Put the display page in BH
	int	10h			; BIOS video call
	push	DX			; Save the row and column
LoopSetUp:
	mov	CX,Count		; Put duplication factor in CX
StartOfLoop:
	push	CX

	mov	AH,SET_CURS_POS		; Put set curs. function in AH
	mov	DH,BYTE PTR Row		; Put screen row in DH
	mov	DL,BYTE PTR Col		; Put screen column in DL
	mov	BH,ScreenPage		; Put page number in BH
	push	BP
	int	10h			; BIOS video call
	pop	BP
ReadFromScreen:
	mov	AH,READ_CHAR_ATTR	; Put read from screen function in AH
	mov	BH,ScreenPage		; Put page number in BH
	push	BP
	int	10h			; BIOS video call
	pop	BP
WriteToScreen:
	mov	BL,BYTE PTR Attr	; Put new attribute in BL
	mov	CX,1			; Put character count in CX
	mov	AH,WRITE_CHAR_ATTR	; Display the char & new attribute
	push	BP
	int	10h			; BIOS video call
	pop	BP
UpdateCursor:
	inc	Col			; Increment the display column
	pop	CX
	loop	StartOfLoop
EndOfLoop:
	pop	DX			; Get original curs pos. from stack
	mov	AH,GET_CURS_POS		; Save the initial cursor position
	mov	BH,ScreenPage		; Put the display page in BH
	int	10h			; Restore original curs. position

	ret

VideoDupAttr ENDP

; =======================================================
; VideoDupCharAttr( int Row, int Col, int DupChar, int Attrib, int DupFactor )
; =======================================================

VideoDupCharAttr PROC USES ES DI, Row:BYTE, Col:BYTE, DupChar:BYTE, \
                                     Attrib:BYTE, DupFactor:WORD

	mov	AH,SET_CURS_POS		; Put function number in AH
	mov	DH,BYTE PTR Row	     	; Put screen row in DH
	mov	DL,BYTE PTR Col	     	; Put screen column in DL
	mov	BH,ScreenPage		; Put page number in BH
	int	10h			; Let BIOS set the cursor position
	mov	AH,WRITE_CHAR_ATTR	; Display the character in AL
	mov	AL,BYTE PTR DupChar	; Put the character to display in AL
	mov	BH,ScreenPage		; Put display in BH
	mov	BL,BYTE PTR Attrib	; Put display attribute in BL
	mov	CX,DupFactor		; Put # times to dup in CX
	int	10h			; Let BIOS set the cursor position
	ret

VideoDupCharAttr ENDP

ifdef JAPAN
;
;	for Double Byte Character
;
VideoDupDBCharAttr PROC USES ES DI, Row:BYTE, Col:BYTE, DupChar:WORD, \
                                     Attrib:BYTE, DupFactor:WORD

	mov	DH,BYTE PTR Row	     	; Put screen row in DH
	mov	DL,BYTE PTR Col	     	; Put screen column in DL
	mov	AX,DupChar		; Put the character to display in AX
	mov	BL,BYTE PTR Attrib	; Put display attribute in BL
	mov	CX,DupFactor		; Put # times to dup in CX
@@:
	push	cx
	call	NEAR PTR write_dbchar
	pop	cx
	loop	@b
	ret

VideoDupDBCharAttr ENDP

endif

; =======================================================
; VideoVertDupCharAttr( int Row, int Col, int DupChar,
;                       int Attrib, int DupFactor )
; =======================================================

VideoVertDupCharAttr PROC USES ES DI, Row:BYTE, Col:BYTE, DupChar:BYTE, \
                                     Attrib:BYTE, DupFactor:WORD

	mov	CX,DupFactor		; Put duplication count in CX
        jcxz    EndVerticalLine         ; Fall out and do nothing
                                        ; if CX is zero

VerticalLineLoop:
	push	CX			; Save loop count
	mov	AH,SET_CURS_POS		; Put set cursor function in AH
	mov	DH,BYTE PTR Row	     	; Put screen row in DH
	mov	DL,BYTE PTR Col	     	; Put screen column in DL
	mov	BH,ScreenPage		; Put page number in BH
	push	BP
	int	10h			; Let BIOS set the cursor position
	pop	BP
	mov	AH,WRITE_CHAR_ATTR	; Put display function in AH
	mov	BH,ScreenPage		; Put page number in BH
	mov	BL,BYTE PTR Attrib	; Put attribute in BL
	mov	AL,BYTE PTR DupChar	; Put character in AL
	mov	CX,1			; Put # of chars in CX
	push	BP
	int	10h		; Video BIOS call
	pop	BP
	inc	Row			; Increment the screen row
	pop	CX			; Restore loop count
	loop	VerticalLineLoop
EndVerticalLine:
	ret

VideoVertDupCharAttr ENDP

ifdef JAPAN
;
;	for Double Byte Character
;
VideoVertDupDBCharAttr PROC USES ES DI, Row:BYTE, Col:BYTE, DupChar:WORD, \
                                     Attrib:BYTE, DupFactor:WORD

	mov	DH,BYTE PTR Row	     	; Put screen row in DH
	mov	DL,BYTE PTR Col	     	; Put screen column in DL
	mov	BL,BYTE PTR Attrib	; Put attribute in BL
	mov	AX,DupChar		; Put character in AX
	mov	CX,DupFactor		; Put duplication count in CX
        jcxz    vd_end		        ; Fall out and do nothing
                                        ; if CX is zero

vd_loop:
	push	cx
	push	dx
	call	NEAR PTR write_dbchar
	pop	dx
	pop	cx
	inc	dh			; next row
	loop	vd_loop
vd_end:
	ret

VideoVertDupDBCharAttr ENDP

endif

; =======================================================
; VideoVertDupAttr( int Row, int Col, int Attrib, int DupFactor )
; =======================================================

VideoVertDupAttr PROC USES ES DI, Row:BYTE, Col:BYTE, Attrib:BYTE, \
				  DupFactor:WORD

	mov	CX,DupFactor		; Put duplication count in CX

VertAttrLoop:
	push	CX			; Save loop count
	mov	AH,SET_CURS_POS		; Put set cursor function in AH
	mov	DH,BYTE PTR Row	     	; Put screen row in DH
	mov	DL,BYTE PTR Col	     	; Put screen column in DL
	mov	BH,ScreenPage		; Put page number in BH
	push	BP
	int	10h			; Let BIOS set the cursor position
	pop	BP

ReadFromScreen2:
	mov	AH,READ_CHAR_ATTR	; Put read from screen function in AH
	mov	BH,ScreenPage		; Put page number in BH
	push	BP
	int	10h			; BIOS video call
	pop	BP
WriteToScreen2:
	mov	BL,BYTE PTR Attrib	; Put new attribute in BL
	mov	CX,1			; Put character count in CX
	mov	AH,WRITE_CHAR_ATTR	; Display the char & new attribute
	push	BP
	int	10h			; BIOS video call
	pop	BP
UpdateCursor:
	inc	Row			; Increment the display column
	pop	CX
	loop	VertAttrLoop
	ret

VideoVertDupAttr ENDP

; =======================================================
; void VideoScrollDn( int StartRow, int StartCol, int EndRow, int EndCol,
;                     int Lines, int Attrib )
; =======================================================

VideoScrollDn PROC StartRow:BYTE, StartCol:BYTE, EndRow:BYTE, EndCol:BYTE, \
		   Lines:BYTE, Attrib:BYTE

	mov	AH,SCROLL_DOWN		; BIOS scroll down function
	mov	AL,BYTE PTR Lines	; # of lines to scroll
	mov	BH,BYTE PTR Attrib	; Attribute for erased lines
	mov	CH,BYTE PTR StartRow	; Put starting row in CH
	mov	CL,BYTE PTR StartCol	; Put starting column in CL
	mov	DH,BYTE PTR EndRow	; Put ending row in DH
	mov	DL,BYTE PTR EndCol	; Put ending column in DL
	int	10h			; BIOS video call
	ret

VideoScrollDn ENDP

; =======================================================
; void VideoScrollUp( int StartRow, int StartCol, int EndRow, int EndCol,
;                     int Lines, int Attrib )
; =======================================================

VideoScrollUp PROC StartRow:BYTE, StartCol:BYTE, EndRow:BYTE, EndCol:BYTE, \
		   Lines:BYTE, Attrib:BYTE

	mov	AH,SCROLL_UP		; BIOS scroll down function
	mov	AL,BYTE PTR Lines	; # of lines to scroll
	mov	BH,BYTE PTR Attrib	; Attribute for erased lines
	mov	CH,BYTE PTR StartRow	; Put starting row in CH
	mov	CL,BYTE PTR StartCol	; Put starting column in CL
	mov	DH,BYTE PTR EndRow	; Put ending row in DH
	mov	DL,BYTE PTR EndCol	; Put ending column in DL
	int	10h			; BIOS video call
	ret				; Finished with this call

VideoScrollUp ENDP

; =======================================================
; void VideoCls( int Attrib )
; =======================================================

VideoCls PROC Attrib:BYTE

	mov	AH,SCROLL_DOWN		; Put function request in AH
	xor	AL,AL			; Set AL for clear screen
	mov	BH,BYTE PTR Attrib	; Put screen attribute in BH
	mov	CX,0			; Put starting row-col & 0,0
	mov	DH,ScreenLength		; Put starting row in DH
	dec	DH			; Decrement to start at 0
	mov	DL,ScreenWidth		; Put ending column in DL
	dec	DL			; Decrement to start at 0
	int	10h			; BIOS video call
	ret				; Finished with clear screen

VideoCls ENDP
;===============================================================
; void VideoGetBlock( int Row, int Col, char *awDest, int Count );
;===============================================================

VideoGetBlock PROC USES ES DI SI, Row:BYTE, Col:BYTE, awDest:PTR, Count:WORD

SetUpForBlockMove:
	mov	DH,BYTE PTR Row	     	; Put screen row in DH
	mov	DL,BYTE PTR Col	     	; Put screen column in DL
	mov	BH,ScreenPage		; Put the screen page in the
	xor	BL,BL			; high byte of SI
	mov	SI,BX

;	les	DI,awDest		; Put pointer to destin. in ES:DI
	LoadPtr	ES, DI, awDest		; ES:DI --> Destination buffer

	mov	CX,Count		; Put number words to move in CX
MoveToNextGetPosition:
	mov	BX,SI
	mov	AH,SET_CURS_POS		; BIOS set cursor function
	push	BP
	int	10h			; BIOS video call
	pop	BP
GetNextCharAttr:
	mov	BX,SI
	mov	AH,READ_CHAR_ATTR	; Bios get char & attribute function
	push	BP
	int	10h			; BIOS video call
	pop	BP
	cld				; Set direction to forward
	stosw
	inc	DL			; Increment the column
	loop	MoveToNextGetPosition
	ret

VideoGetBlock ENDP

;===============================================================
; void VideoPutBlock( int Row, int Col, char *awSource, int Count );
;===============================================================

IF @DataSize
VideoPutBlock PROC USES DS DI SI, Row:BYTE, Col:BYTE, awSource:PTR, \
			          Count:WORD
ELSE
VideoPutBlock PROC USES    DI SI, Row:BYTE, Col:BYTE, awSource:PTR, \
			          Count:WORD
ENDIF

SetUpForBlockDisplay:
	mov	DH,BYTE PTR Row	     	; Put screen row in DH
	mov	DL,BYTE PTR Col	     	; Put screen column in DL
	mov	BH,ScreenPage		; Put the screen page in the
	xor	BL,BL			; high byte of DI
	mov	DI,BX

;	lds	SI,awSource		; Put pointer to source in DS:DI
	LoadPtr	DS, SI, awSource	; DS:SI --> Source buffer

	mov	CX,Count		; Put number words to move in CX
MoveToNextColPosition:
	push	CX			; Save the count
	mov	BX,DI
	mov	AH,SET_CURS_POS		; BIOS set cursor function
	push	BP
	int	10h			; BIOS video call
	pop	BP
PutNextCharAttr:
	mov	BX,DI			; Put page number in BH
	cld				; Set direction to forward
	lodsw				; Get char in AL & attrib in AH
	mov	BL,AH			; Move attribute in BL
	mov	AH,WRITE_CHAR_ATTR	; Bios get char & attribute function
        mov	CX,1			; Set number char & attrib to write
	push	BP
	int	10h			; BIOS video call
	pop	BP
	inc	DL			; Increment the column
	pop	CX			; Restore the loop count in CX
	loop	MoveToNextColPosition
	ret

VideoPutBlock ENDP

; =======================================================
; Check for a Hercules. We are checking for a Herc102, 112, 222.
; This is the best possible test since the Hercules does not have any
; standard detection mechanism built into it.
; Taken from WORD code.
; Returns in AX
;       0 - if it is not a Hercules.
;       1 - Herc 112
;       2 - Herc 222
;       3 - Herc 102
; =======================================================

HercCheck PROC NEAR USES ES
	 LOCAL locvar1:WORD

         MOV       locvar1,0		; initiliase local var

	mov	AX,0b000h
	mov	ES,AX			; ES --> MDA video memory segment
	mov	AX,ES:[00]		; Get first byte of MDA memory
	mov	BX,AX

	not	AX			; M100 - Use xchg to fix floating bus
	xchg	WORD PTR ES:[00],AX	; Flip the bits in memory
	not	AX

	cmp	AX,ES:[00]		; See memory bits really flipped
	mov	ES:[00],BX		; Retore memory location
	jne	HercDone		; If memory & AX are not equal it means
					; the memory wasn't real

         MOV       DX, HercStatusPort   ; Herc status port is 03BAh
         XOR       BX, BX               ; Start with no 112 or 222 successes.
         MOV       CX, 100                ; Get a majority of 100 tries

Check:

         IN       AL, DX
         AND       AL, idmask_222         ; strip to just the 222 bits
         CMP       AL, idcode_222         ; check for GB222 code
         JNE       Check_112              ; No, Skip to test for 112
         INC        BH                    ; Count another 222 success

Check_112:

         AND       AL, idmask_112         ; strip further to just the 112 bits
         CMP       AL, idcode_112         ; check for the GB112 id code
         JNE       CheckAgain             ; No skip
         INC        BL                    ; Count another 112 success

CheckAgain:

         LOOP       Check                 ; Loop back and check again

; 100 tries are over.
         CMP       BL, 50                 ; Did we get a majority of 112 hits ?
         JBE       CheckGB102             ; If not check for a Herc GB102

; every time we get a 222 hit we get a 112 hit too.
; Hence it can be either a 112 or a 222 at this stage.
         MOV       locvar1, 1             ; indicate it is a 112, this may be
                                          ; over written later
         CMP       BH, 50                 ; Did we get a majority for the 222 ?
         JBE       HercDone               ; it is a Herc 112 only.
         MOV       locvar1, 2             ; It is a Herc 222, overwrite locvar1.
	 JMP	   SHORT HercDone

CheckGB102:

; Bit 7 at port HercStatusPort changes pretty often on a Hercules. Check to see
; if it flips.

			MOV		 DX, HercStatusPort
			MOV		 CX, 6FFFh					; m119: # of times we read from port 03BA
         IN        AL, DX
         MOV       BL, AL

ReadAgain:

         IN        AL, DX                 ; Get current value of port 03BA
         XOR       AL, BL                 ; XOR to see if it changes
         OR        AL, AL                 ; Did it ?
         JS        Yes102                 ; Yes it is a Hercules
         LOOP      ReadAgain              ; No, try again

	 JMP	   SHORT HercDone
Yes102:
         MOV       locvar1, 3             ; indicate it is a Herc GB102

HercDone:

         MOV       AX, locvar1
	 ret

HercCheck ENDP

; =======================================================
;
; int GetOemDisplayID( void )															*/
; 																								*/
;	Will return display type.
; 																								*/
; ENTRY: None 																				*/
; EXIT:	Returns Video adapter type 													*/
;			0 = MONO																				*/
;			1 = CGA																				*/
;			2 = EGA																				*/
;			3 = VGA																				*/
;			4 = HERCULES																		*/
;
; =======================================================

GetOemDisplayID PROC

	mov	AL,DisplayType

ifdef JAPAN
	cmp	al,EGA
	jnz	@f			; if not EGA
	xor	bx,bx
	mov	ah,50h
	mov	al,1			; get display mode
	int	10h
	mov	al,EGA
	cmp	bx,81
	jnz	@f			; if not JAPAN
	mov	al,JEGA
@@:
endif

	cbw
	ret

GetOemDisplayID ENDP


; =======================================================
; Returns AX != 0 if CGA adapter and SI is set to CGA 
; =======================================================

CgaCheck PROC NEAR USES ES

	mov	AX,0b800h
	mov	ES,AX			; ES --> CGA memory segment

	mov	AX, ES:0000h		; Get first byte of CGA memory
	mov	BX, AX			; and save it for replacement

	not	AX			; M100 - Use xchg to fix floating bus
	xchg	AX,ES:0000h
	not	AX			; If memory is real AX should
					; equal ES:0000h
	cmp	AX, ES:0000h		; See if it really changed
	mov	ES:0000,BX		; Restore original value

	jne	MonoRet			; If zero memory was real

		; We found CGA memory so now see if monochrome memory
		; also exists

	mov	AX,0b000h
	mov	ES,AX			; ES --> Monochrome memory segment

	mov	AX, ES:0000h		; Get first byte of Monochrome memory
	mov	BX, AX			; and save it for replacement

	not	AX			; M100 - Use xchg to fix floating bus
	xchg	AX,ES:0000h
	not	AX			; If memory is real AX should
					; equal ES:0000h

	cmp	AX, ES:0000h		; See if it really changed
	mov	ES:0000,BX		; Restore original value
	jne	CgaRet			; If zero memory was real

		; M100 - We found both CGA and Monochrome memory so no get the
		; video mode to determine the active video type

	mov	AH,0fh
	int	10h
	cmp	AL,07			; See if monochrome video mode
	je	MonoRet			; If it is return not CGA


CgaRet:
	mov	SI,CGA			; Assume memory was real
	mov	AX,1			; Signal CGA adapter was detected.
	jmp	SHORT @f

MonoRet:
	mov	AX,0			; Signal not a CGA adapter.
	mov	SI,MONO			; Not CGA so must be MONO

@@:
	ret

CgaCheck ENDP

; =======================================================
;
; This function detects the presence of an 8514 display card.
;
;The way we do this is to first write to the Error Term Register and then
;make sure we can read back the value we wrote. Next I read in the value of
;the subsystem status register and check bit 7 to determine if the 8 plane
;memory configuration is present. Only if both these conditions are
;satisfied will we install the 8524 display driver.
;
;Entry:
;       SI has current video mode
;Exit:
;	SI has been updated to VGA or VGA_MONO if 8514 is detected
;       if display card is present and contains the proper memory
;	configuration.
;
; =======================================================

; Equates for 8514 register ports.

ERR_TERM             equ   92e8h       ; 8514 error term register.
SUBSYS_STAT          equ   42e8h       ; 8514 Subsystem status register.

Detect8514 PROC NEAR

	mov	dx, ERR_TERM	; load DX with port address (error term port).
	mov	ax, 5555h	; load AX with value to write to port.
	out	dx, ax		; Write the data.
	IO_Delay
	IO_Delay
	in	ax, dx		; Now read the data back in.
	cmp	ax, 5555h	; Q: is 8514 present ?
	jne	fn8514Done	;   N: indicate 8514 not present.
				;   Y: 8514 is present, now check monitor.
    ;
    ; Now we need to determine what type of monitor is attached to the
    ; 8514 card. To do this we check ID bits 6,5,4 of the subsystem
    ; status register. Depending on the Monitor attached we return:
    ;
    ; There are 4 valid monitor types:
    ; 
    ; bits 6-4       Type
    ;
    ;   001          Ascot (mono)
    ;   010          Henley (color)
    ;   011          Invalid (color) This is supposedly valid in spite
    ;                of what the spec says.
    ;   101          Surrey (mono)
    ;   110          Conestoga/Crown (color)
    ;
    mov  dx,SUBSYS_STAT      ; Now, we have the adapter. Check monitor.
    in   ax,dx               ; Get word from SUBSYS_STAT
    and  ax,0070h            ; Mask out bits 6-4
    cmp  ax,0020h            ; Is it Henley type? 
    je   Disp_8514           ; Yes, then it is an 8514 type
    cmp  ax,0060h            ; Is it Conestoga/Crowwn type?
    je   Disp_8514           ; Yes, then it is an 8514 type
    cmp  ax,0030h            ; Is it Korys' machine
    je   Disp_8514           ; Yes, then it is an 8514 type
    cmp  ax,0010h            ; Is it Ascot type?
    je   Disp_8503           ; Yes, then it is a VGA Mono type
    cmp  ax,0050h            ; Is it Surrey type?
    je   Disp_8503           ; Yes, then it is a VGA Mono type

	mov	SI,VGA
	jmp	short fn8514Done

Disp_8503:
	mov	SI,VGA_MONO
	jmp	short fn8514Done
         
Disp_8514:
	mov	SI,GAD_8514
         
fn8514Done:
	ret

Detect8514	ENDP

; =======================================================

ifdef DBCS
;
;	Check if the specified cursor is at lead byte
;
CheckLead PROC USES ES SI, Row:BYTE, Col:BYTE
	mov	al, byte ptr Row
	mul	ScreenWidth
	mov	si,ax
	shl	si,1			; set start address of the row
	add	al,Col
	adc	ah,0
	mov	bx,ax
	shl	bx,1			; get cursor address
	mov	es,ScreenBuffer
	call	NEAR PTR aCheckDBCSTailByte
	jz	cl_no			; if this is tail byte
	mov	al,es:[bx]
	call	NEAR PTR aIsDBCSLeadByte
	jnz	cl_no			; if this is not lead byte
	mov	ax,1
	jmp	short cl_ret
cl_no:
	mov	ax,0
cl_ret:
	ret
CheckLead	ENDP

;
;	Check if the specified cursor is at tail byte
;
CheckTail PROC USES ES SI, Row:BYTE, Col:BYTE
	mov	al, byte ptr Row
	mul	ScreenWidth
	mov	si,ax
	shl	si,1			; get start address of the row
	add	al,Col
	adc	ah,0
	mov	bx,ax
	shl	bx,1			; get cursor address
	mov	es,ScreenBuffer
	mov	ax,0
	call	NEAR PTR aCheckDBCSTailByte
	jnz	ct_ret			; if not at tail byte
	inc	ax
ct_ret:
	ret
CheckTail	ENDP

;
;	Test if the character is DBCS Lead Byte
;
;	input:	AL = character to check
;	outpit:	ZF = 1 if DBCS Lead Byte
;

DBCSLeadByteTable	dd	0

aIsDBCSLeadByte	PROC NEAR
	push	ax
	push	si
	push	ds
	lds	si,cs:DBCSLeadByteTable
	cmp	word ptr cs:DBCSLeadByteTable+2,0
	jnz	idlb_check		; if table is already set
	push	ax
	mov	ax,6300h
	int	21h			; get DBCS lead byte table
	pop	ax
	mov	word ptr cs:DBCSLeadByteTable,si
	mov	word ptr cs:DBCSLeadByteTable+2,ds
idlb_check:
	cmp	word ptr [si],0
	jz	idlb_not		; if end of table
	cmp	al,[si]
	jb	idlb_next		; if below low value
	cmp	al,[si+1]
	jbe	idlb_yes		; if below high value
idlb_next:
	add	si,2			; do next
	jmp	short idlb_check
idlb_not:
	or	al,1			; reset ZF
	jmp	short idlb_end
idlb_yes:
	and	al,0			; set ZF
idlb_end:
	pop	ds
	pop	si
	pop	ax
	ret
aIsDBCSLeadByte		endp

;
;	Check if the character position is at Tail Byte of DBCS
;
;	input:	es:si = start address of the string
;		es:bx = character position to check
;	output:	ZF = 1 if at Tail Byte
;
aCheckDBCSTailByte PROC NEAR
	push	ax
	push	bx
	push	cx
	mov	cx,bx			; save character position
cdtb_check:
	cmp	bx,si
	jz	cdtb_next		; if at the top
	sub	bx,2			; go back
	mov	al,es:[bx]		; get character
	call	NEAR PTR aIsDBCSLeadByte
	jz	cdtb_check		; if DBCS lead byte do next
	add	bx,2			; adjust
cdtb_next:
	shr	cx,1
	shr	bx,1
	sub	cx,bx			; if the length is odd then
	xor	cl,1			; the character position is
	test	cl,1			; at the tail byte
	pop	cx
	pop	bx
	pop	ax
	ret

aCheckDBCSTailByte	endp
endif

; ========================================================

.DATA

; ========================================================

ATI_SigBuf	db	'         '
ATI_SigStr	db	'761295520'	; m112 ATI Generic Signature

ATI_Table	db	'21CQ'		; m112 Wonder Rev 1
		db	'21NS'		; m112 Wonder Rev 2
		db	'22NS'		; m112 Wonder Rev 3
		db	'23NS'		; m112 Wonder Rev 4 
		db	'21SC'		; m112 Wonder 800 Rev 0-6 & VIP
		db	'22SC'		; m112 Wonder 801
		db	'23SC'		; m112 VIP PGA
		db	'24SC'		; m112 Wonder 480
		db	'25SC'		; m112 Wonder 880 Rev 7
		db	0,0		; m112 End of table marker

ATI_SIG_LEN	EQU	9
NUM_ATI_CODES	EQU	9

; ========================================================

.CODE

; ========================================================
; Checks for problematic ATI video cards and returns
; Zero flag set if found else NZ
; ========================================================

ATI_Check PROC NEAR USES ES SI DI


	push	DS
	pop	ES			; DS & ES --> .DATA seg
	mov	AX, ATI_ROM
	mov	DS, AX			; DS --> ATI ROM seg

	assume	DS: ATI_ROM
	assume	ES: @DATA

	mov	SI, OFFSET DS:ATI_RomSig ; DS:SI --> Signature string in ROM
	mov	DI, OFFSET ES:ATI_SigBuf ; ES:DI --> Local buffer
	mov	CX, ATI_SIG_LEN		; CX == length of signature in bytes

	cld
	rep	movsb			; Copy signature to local buffer

	push	ES
	pop	DS			; DS --> .DATA seg
	assume	DS: @DATA

	mov	SI, OFFSET ATI_SigStr	; DS:SI --> ATI_SigStr
	mov	DI, OFFSET ATI_SigBuf	; ES:DI --> ATI_SIGBuf
	mov	CX, ATI_SIG_LEN		; CS == length of signature in bytes

	cld
	repe	cmpsb			; DOS ROM have an ATI signature?
	jne	NotBadATI

		; At this point we've determined this is an ATI
		; producte and now we look at the card type

	mov	AX, ATI_ROM
	mov	ES, AX			; ES --> ATI ROM seg
	ASSUME	ES: ATI_ROM
	
	mov	DX,WORD PTR ES:CardType	  ; Get first word of card type
	mov	CX,WORD PTR ES:CardType[2]; Get 2nd word of card type

	mov	SI, OFFSET ATI_Table	; DS:SI --> Table of card types

CheckTableEntry:
	lodsw				; Get first word of this entry
	or	AX,AX			; See if at end of the table
	jz	NotBadATI		; If zero no more entries
	mov	BX,AX			; BX == First word of entry

	lodsw				; Grab 2nd word for this entry
	cmp	BX,DX			; See if entries match
	jne	CheckTableEntry		; If no match go get next entry
	cmp	AX,CX			; See if entries match
	jne	CheckTableEntry		; No match on 2nd words

FoundBadATI:				; Fall thru if card type found in table
	mov	AX,1			; Signal a bad card
	jmp	SHORT ATI_CheckReturn

NotBadATI:
	xor	AX,AX			; Signal didn't find a bad card

ATI_CheckReturn:
	ret	

ATI_Check ENDP

; ========================================================

ATI_ROM SEGMENT	AT 0c000h

; m114	ORG	30h
	ORG	31h			; m114
ATI_RomSig	db	?

	ORG	40h
CardType	db	?


ATI_ROM ENDS

; ========================================================

	END

; ========================================================


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\copy\filecopy.c ===
/***************************************************************************/
/* FILECOPY.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* 																								*/
/* File copy functions for copying multiple files across disks.				*/
/* 																								*/
/* 																								*/
/* Created 11-01-89 johnhe																	*/
/* TABS = 3																						*/
/***************************************************************************/


#include 	<stdio.h>
#include		<stdlib.h>
#include 	<malloc.h>
#include 	<dos.h>
#include 	<fcntl.h>
#include 	<io.h>
#include		<share.h>
#include 	<sys\\types.h>
#include 	<sys\\stat.h>
#include 	<string.h>
#include 	<ctype.h>

#include		<alias.h>
#include 	<disk_io.h>
#include 	<window.h>
#include 	<strlib.h>
#include 	<copy.h>
#include 	<decomp.h>

extern unsigned gfCompressedDiskIsFull;
extern unsigned gfCompressedDiskCritSection;
extern unsigned gfCompressedDiskInstall;

/***************************************************************************/

#define		_A_FINDALL	(_A_HIDDEN | _A_SYSTEM)

/* m116 #define		MIN_BUF_SIZE			10000L	*/
/* m116 #define		MALLOC_RESERVE 		40000L	*/

#define		MIN_BUF_SIZE			10000L	/* m116	*/
#define		MALLOC_RESERVE 		40000L	/* m116	*/

#define		MAX_BLOCK				0xff00

extern  void DispInsertDisk(int DiskNum);
extern  void DispInsertUserDisk(int UserDisk,char chDrive);

#ifndef	SYSTEMS_COMPRESSION
extern  int IsHardDisk(int chDrive);
#endif

/***************************************************************************/
/*                                                                    		*/
/*	WR_BUF_INFO																					*/
/*																									*/
/* Status structure which contains the currents status of the disk			*/
/* write buffer.																				*/
/*                                                                    		*/
/***************************************************************************/

struct BUF_INFO
{
	char	far	*Start;			/* Far ptr to start of buffer */
	char	far	*Next;
	long			BufLen;			/* Total length of the buffer */
	long			BytesFree;		/* Number free  bytes left in the buffer */
};

/***************************************************************************/
/* Static globals for this module.														*/
/***************************************************************************/

static struct MULT_FILES	*File;	/* Ptr to current file information		*/
static struct BUF_INFO		Buf;		/* Copy buffer information struct		*/

#ifdef SYSTEMS_COMPRESSION
static char	far *UnpackArea;			/* Ptr to unpack area						*/
extern char	far *UnpackSeg;			/* Ptr segment	allocated for unpack()	*/
#endif

/***************************************************************************/
/* Prototypes for local functions within this module. 							*/
/***************************************************************************/

static UINT		ShareAccess;			/* File access mode */
static void		BufCopyFile		( struct MULT_FILES *File );

static int		BufFlush			( void );
static int		InitCpyBuffer	( void );
static int		InitFile			( struct MULT_FILES *File, char *szFile );
static long 	WriteFile		( int iFile, struct MULT_FILES *ThisFile,
										  long lToWrite );
long far			Unpack			( int iFile, char far *InBuffer,
										  long lPackedBytes );
void far			ClearRingBuffer( int CompressType );
void far 		CompressedDiskIsFull (void);

#ifndef SYSTEMS_COMPRESSION

static long 	ExpandFile		( int iFile, struct MULT_FILES *File );

#endif

/***************************************************************************/
/* Functions to copy multiple files between different drives. Will prompt	*/
/* for the disks before each file is read or written if the disk is not 	*/
/* already inserted. Will allow the user to decide whether to continue or	*/
/* or not if there is an error reading any of the files. 						*/
/*																									*/
/* int Xcopy( struct MULT_FILES *FileList )									*/
/*																									*/
/* ARGUMENTS:	FileList 	- Array of structures which describe everything */
/* 								  necessary about the files.							*/
/* RETURNS: 	void																			*/
/*																									*/
/***************************************************************************/

void Xcopy( struct MULT_FILES *FileList )
{
	register 	i;

	if ( _osmajor < 3  || (_osmajor == 3 && _osminor < 10) )
		ShareAccess = O_RDONLY;
	else
		ShareAccess = SH_DENYWR;


	File = FileList;								/* Set ptr to file structures */

	if ( InitCpyBuffer() == OK )				/* Initialize the copy buffer */
	{
														/* Loop for each file			*/
		for ( i = 0; gfCompressedDiskIsFull == FALSE &&
                   File[i].Name.Source    != NULL; i++ )
			BufCopyFile( File+i );

		if (gfCompressedDiskIsFull == FALSE)
			BufFlush();								/* Flush any files in memory	*/

		hfree( Buf.Start );						/* Free the copy buffer 		*/
#ifdef SYSTEMS_COMPRESSION
		hfree( UnpackArea );						/* Free the unpacked segment	*/
/*		FreeMemory( UnpackArea );*/			/* Free the unpacked segment	*/
#endif
		if (gfCompressedDiskIsFull == TRUE)
		{
			/* The compressed disk filled up */
			CompressedDiskIsFull();		/* This routine reboots */
		}
	}
	else
		FatalError( FATAL_MEMORY_ERROR );
}

/***************************************************************************/
/* Reads a specified file and appends it to the copy buffer. The copy		*/
/* buffer is flushed to disk as often as necessary. If an error occurs		*/
/* while reading a file the file is marked with a zero length and the   	*/
/* user is given a chance to continue if no making recovery disk. 			*/
/*																									*/
/* void BufCopyFile( int Index )															*/
/*																									*/
/* ARGUMENTS:	File		- File structure for file to be copied.				*/
/* 							  Source and Destination path and file members		*/
/* 							  must be complete											*/
/* RETURNS: 	void																			*/
/*																									*/
/***************************************************************************/

static void BufCopyFile( struct MULT_FILES *File )
{
	int			iStatus; 							/* Return status				*/
	int			iFile;								/* Open file handle			*/
	char			*szFile; 							/* Full path name for file */
	long			lToRead;
#ifndef SYSTEMS_COMPRESSION
	int			fFlush;
	long			lDecompRead;

	File->pchStart = NULL;
#endif

	szFile = GetMemory( MAX_PATH_LEN );
	BuildPath( szFile, File->Drive.Source, File->Path.Source,
				  File->Name.Source );
	do
	{
#ifndef SYSTEMS_COMPRESSION
	  fFlush = FALSE;
#endif
		iStatus = ERROR;

		DispInsertDisk( File->DiskNumber );
		DisplayFileStatus( File->Name.Source, READ );

																/* Set up file's structure */
		if ( File->lSourceSize == 0L && InitFile( File, szFile ) != OK )
		{
			File->lSourceSize = 0L;
			break;
		}
									/* Determine how much of the file will fit in	*/
									/* the buffer and where it will be written to	*/

#ifdef SYSTEMS_COMPRESSION
		File->pchStart = Buf.Next;
#else
		if ( File->pchStart == NULL )
			File->pchStart = Buf.Next;
#endif
		lToRead = File->lSourceSize - File->lRead;
		if ( lToRead > Buf.BytesFree )
			lToRead = Buf.BytesFree;

									/* Open the file and seek to the location for	*/
									/* the start of the next read. Then read in the	*/
									/* portition of the file and update structures	*/

		if ( _dos_open( szFile, ShareAccess, &iFile ) == OK )
		{

#ifdef SYSTEMS_COMPRESSION

			if ( _dos_seek( iFile, File->lRead, SEEK_SET ) == File->lRead )
			{
				if ( BigReadWrite( iFile, Buf.Next, lToRead, READ ) == OK )
				{
									/* Update buffer information */
					Buf.Next = HugeAdd( Buf.Next, lToRead );
					Buf.BytesFree -= lToRead;

									/* Update the file's structure */
					File->lRead	+= lToRead;
					iStatus = OK;				/* Can only get here if no error */
				}
			}
#else
			if ( File->IsPacked )
			{
				/* The file is compressed, it gets uncompressed as it's read
					into the buffer.	There is a big time hit for every pass
					through the same file because the decompression code has to
					(re)decompress and through away everything it's already done
					for a file on subsequent passes.  So, if a packed file will
					not fit into the remaining buffer space, but it will fit
					into an empty buffer, force a BufFlush() call and loop back
					here again. */

				if ( lToRead == Buf.BytesFree )		/* reading to fill buffer? */
				{
					/* reading less when remaining, but remaining would fit in
						empty buffer? */

					lDecompRead = File->lSourceSize - File->lRead;	/* remaining*/

					if ( lToRead < lDecompRead )

						if ( lDecompRead <= Buf.BufLen ) 	/* remaining fit? 	*/
						{
							lToRead = 0;				/* don't read anything this   */
							iStatus = OK;				/*   pass, just force a flush */
							fFlush = TRUE; 			/*   and read on next pass 	*/

						} else

							/* The packed file is too big for even an empty buffer,
								but if installing to a hard disk (non swappable)
								it can be expanded directly from file to file.
								Otherwise just go ahead and buffer it. */

							if ( IsHardDisk(File->Drive.Destin) )
							{
								lToRead = 0;			/* don't try to buffer below  */

								lDecompRead = ExpandFile( iFile, File );

								UpdateByteCount (lDecompRead * 2);	/* Update gauge   */

								if ( lDecompRead == File->lDestinSize )/* got all? */
									iStatus = OK;
							}
				}

				if ( lToRead > 0 )					/* may have been zeroed above */
				{

					/* read and decompress a chunk (maybe all) of the file		*/

					lDecompRead = LcbDecompressToBuffer( iFile, Buf.Next, lToRead,
																	 File->lRead, FALSE );

					UpdateByteCount (lDecompRead);				/* Update gauge   */

					if ( lDecompRead == lToRead ) /* got all that was requested? */
						iStatus = OK;
				}

			} else {

				/* The file is not packed, so just seek to the read offset
					and read the next chunk */

				if ( _dos_seek( iFile, File->lRead, SEEK_SET ) == File->lRead )
					iStatus = BigReadWrite( iFile, Buf.Next, lToRead, READ );
			}

			if ( iStatus == OK )
			{
							/* Update buffer information */
				Buf.Next = HugeAdd( Buf.Next, lToRead );
				Buf.BytesFree -= lToRead;

							/* Update the file's structure */
				File->lRead += lToRead;
			}
#endif

			if ( _dos_close( iFile ) != OK ) /* Close the file checking 	*/
				iStatus = ERROR;					/* for errors						*/
		}
									/* Check for an error reading the file and	*/
									/* if error mark this file as 0 length if 	*/
									/* user decides to continue						*/

		if ( iStatus != OK )
			File->lSourceSize = 0L;

#ifdef SYSTEMS_COMPRESSION
		else if ( Buf.BytesFree == 0 )	/* See if the buffer needs flushing */
#else
		else if ( fFlush || Buf.BytesFree == 0 )	/* Buffer need flushing?	*/
#endif
		{
#ifdef SYSTEMS_COMPRESSION
			if ( BufFlush() != OK )
				File->lSourceSize = 0L; 	/* Signal this file not written	*/
#else
			if ( BufFlush() == OK )
				File->pchStart = NULL;
			else
				File->lSourceSize = 0L; 	/* Signal this file not written	*/
#endif
		}
	}
	while ( iStatus == OK && File->lRead < File->lSourceSize &&
				gfCompressedDiskIsFull == FALSE);

	if ( iStatus != OK )
		ProcessCopyError( File->Name.Destin, ERR_READING );

	FreeMemory( szFile );
}

/***************************************************************************/
/* Initializes a file structure for use by the BufCopyFile() function.		*/
/* Also reads first 12 bytes of the files to see if it is a packed file.	*/
/* 																								*/
/* int InitFile( struct MULT_FILES *File, char *szFile ) 						*/
/* 																								*/
/* ARGUMENTS:	File		- Ptr to file structure to be initialized 			*/
/* 				szFile	- Complete file and path for a source file			*/
/* RETURNS: 	int		- OK if no file errors else ERROR						*/
/* 																								*/
/***************************************************************************/

static int InitFile( struct MULT_FILES *File, char *szFile )
{
	char						*szEndChar;
	register 				i; 					/* Loop Indice 						*/
	int						iFile;				/* DOS file handle					*/
	unsigned 				uStatus; 			/* Error status						*/
	struct find_t			Info;
	uStatus = (UINT) ERROR; 					/* Assume may not be successful	*/

#ifdef SYSTEMS_COMPRESSION
	unsigned 				uRead;				/* Count of byte read from file	*/
	struct PACKED_HEADER	Fh;					/* Struct to hold file header 	*/
	struct WIN_HEADER		Wh;					/* Alternate windows file header	*/
	static char 			MagicValue[8] =	{ 'S',	'Z',	  ' ',	  '\x88',
														 '\xf0', '\x27', '\x33', '\xd1' };
#endif

								/* Try to open the file normally and if it fails	*/
								/* try opening the file as a compressed file by 	*/
								/* switching last char of name extension to a '$'	*/

	for ( i = 0; i < 2; i++ )
	{
		if ( (_dos_findfirst( szFile, _A_FINDALL, &Info ) == OK &&
				_dos_open( szFile, ShareAccess, &iFile ) == OK) )
			break;
		szEndChar = strchr( szFile, EOL );				/* Find end of string	*/
		if ( szEndChar != NULL )
			*(szEndChar - 1) = '_';
	}

	if ( i < 2 )												/* See if open was OK	*/
	{
		File->lDestinSize = File->lSourceSize = filelength( iFile );

#ifdef SYSTEMS_COMPRESSION
																/* Read in the file header */
		if ( _dos_read( iFile, &Wh, sizeof( Wh ), &uRead ) == OK &&
			  uRead > 0 )
		{
												/* Need the header in both structures	*/
			memcpy( &Fh, &Wh, sizeof( Wh ) );

											/* Check for a languages group's header	*/
			if ( memcmp( MagicValue, Fh.MagicStr, sizeof(MagicValue)) == OK )
			{
				File->lDestinSize = Fh.lDestinSize;
				File->lRead = File->lUnpacked = (long)sizeof( Fh );
				File->IsPacked = LANGUAGE_COMPRESS;
			}
									/* Now check for a Windows group's header */
			else if ( memcmp( WIN_STR, Fh.MagicStr, sizeof(MagicValue)) == OK )
			{
				File->lDestinSize = Wh.lDestinSize;
				File->lRead = File->lUnpacked = (long)sizeof( Wh );
				File->IsPacked = WINDOWS_COMPRESS;
			}
			uStatus = OK;
		}
#else
        if ((int) (uStatus = WReadHeaderInfo (iFile)) > 0)
          {
            /* This is a compressed file, using APPS compression.  */
            /*   Unfortunately, the file must be decompressed into */
            /*   RAM, as the APPS compression APIs do not have a   */
            /*   method to decompress from a buffer to a file (but */
            /*   it can decompress from a file to a buffer).       */

            File->lDestinSize = LcbCalculateDecompressedLength (iFile, TRUE);
            File->lSourceSize = File->lDestinSize;
            File->IsPacked = TRUE;
            uStatus = OK;
          }
        else
            uStatus = (uStatus == rcNoHeader) ? OK : ERROR;
#endif

		uStatus |= _dos_getftime( iFile, &File->Date, &File->Time );
		uStatus |= _dos_close( iFile );
	}
	return( (uStatus == OK && File->lSourceSize > 0L) ? OK : ERROR );
}

/***************************************************************************/
/* Initializes the copy buffer to max available memory less 20K bytes. If	*/
/* there is less than 5K of memory available for use the program is			*/
/* with a call to FatalError(). The static global pchCpyBuffer is set to	*/
/* point to the successfully allocated buffer a buffer must also be			*/
/* allocate for the unpack functions. This buffer will have to be				*/
/* normalized so the functions can use it with an offset of 0 so 16 must	*/
/* be added to the offset before normalization to allow for this.				*/
/*																									*/
/*	void InitCpyBuffer( void )																*/
/*																									*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS:		void																			*/
/*																									*/
/* GLOBALS:		lBufSize	- Set to size of allocated buffer						*/
/*					pchCpyBuffer - Pointed to allocated buffer						*/
/*					UnPackSeg	- Normalized ptr to an unpack segment area		*/
/*																									*/
/***************************************************************************/

static int InitCpyBuffer( void )
{
	register	iStatus;

	iStatus = ERROR;									/* Error if fails any test 	*/

															/* Allocate an unpack segment	*/

#ifdef SYSTEMS_COMPRESSION
	/*	UnpackArea = GetMemory(UNPACK_BUF_LEN+RING_BUF_LEN+MAX_STR_LEN+100); */
	UnpackArea = halloc( (long)(UNPACK_BUF_LEN + RING_BUF_LEN +MAX_STR_LEN + 100), 1 );
		if ( UnpackArea == (char far *)(NULL) )
			return( iStatus );

	UnpackSeg = NormalizePtr( (char far *)UnpackArea + 16 );
#endif

						/* Find out how much memory we can get */
	Buf.BufLen = GetMaxHugeSize() - MALLOC_RESERVE;

	if ( Buf.BufLen >= MIN_BUF_SIZE )			/* Is there enough memory ?	*/
	{
		Buf.Start = halloc( Buf.BufLen, 1); 	/* Do we allocate it OK 		*/
		if ( Buf.Start != NULL )
		{
			Buf.Next = Buf.Start;					/* Set next free byte			*/
			Buf.BytesFree = Buf.BufLen;			/* Set number of bytes free	*/
			iStatus = OK;								/* Passed all tests				*/
		}
	}
	return( iStatus );
}

/***************************************************************************/
/* Walks throught the array of file structures and writes out each file 	*/
/* or a portition of each file that resides in the copy buffer.				*/
/* 																								*/
/* int BufFlush( void )																		*/
/* 																								*/
/* ARGUMENTS:	void																			*/
/* RETURN:		int		- OK if no error												*/
/* 																								*/
/* Return status will reflect the status of the last file written. This 	*/
/*	will be a signal to the BufCopyFile() to abort the current file being	*/
/* copied and go to the next file.														*/
/***************************************************************************/

static int BufFlush( void )
{
	char						*szFile;
	int						iFile;
	int						iStatus;

	long						lToWrite;
	long						lWritten;
	struct MULT_FILES 	*ThisFile;
	struct find_t			Info;


	DisplayFileStatus( "", CLEAR );
	szFile = GetMemory( MAX_PATH_LEN );		/* Allocate a path buffer			*/
	Buf.Next = Buf.Start;						/* Reset ptr to begining of buf	*/

											/* Loop until all files are checked */
	for ( iStatus = OK, ThisFile = File;
			ThisFile->Name.Source != NULL;
			ThisFile++ )
	{
		BuildPath( szFile, ThisFile->Drive.Destin, ThisFile->Path.Destin,
					  ThisFile->Name.Destin );

		if ( ThisFile->lUnpacked < ThisFile->lSourceSize )
		{
			iStatus = ERROR;
			lToWrite = ThisFile->lRead - ThisFile->lUnpacked;

			DispInsertUserDisk( ThisFile->UserDisk, ThisFile->Drive.Destin );
			DisplayFileStatus( ThisFile->Name.Destin, WRITE );

			_dos_setfileattr( szFile, _A_NORMAL );

			if ( (_dos_findfirst( szFile, _A_FINDALL, &Info ) == OK &&
				   _dos_open( szFile, O_RDWR, &iFile ) == OK)||
				  _dos_creat( szFile, 0, &iFile ) == OK )
			{
				if ( (lWritten = WriteFile( iFile, ThisFile, lToWrite )) != -1L )
				{
					iStatus = OK;
					ThisFile->lUnpacked += lToWrite;
					ThisFile->lWritten += lWritten;

					if ( ThisFile->lWritten == ThisFile->lDestinSize )
					{			
						chsize( iFile, ThisFile->lDestinSize );
						_dos_setftime( iFile, ThisFile->Date, ThisFile->Time );
					}
				}

				iStatus |= (int)_dos_close( iFile );
			}
		}

		if ( iStatus != OK ||
			  (ThisFile->lRead == ThisFile->lSourceSize &&
				ThisFile->lWritten != ThisFile->lDestinSize) )
		{
			if (gfCompressedDiskInstall)
			{
				gfCompressedDiskIsFull = TRUE;
				FreeMemory (szFile);				/* Free the path buffer 			*/
				return (ERROR);
			}
			else
			{
				ProcessCopyError( ParseFileName( szFile ), ERR_WRITING );
				ThisFile->lSourceSize = 0L;	/* If error set file size to 0	*/
				ThisFile->lDestinSize = 0L;
			}
		}

		if ( ThisFile->lSourceSize == 0L )	/* If source size == 0 we had	an	*/
			remove( szFile );						/* error so delete destin file	*/
	}

	Buf.BytesFree = Buf.BufLen;				/* Reset number of bytes free 	*/
	Buf.Next = Buf.Start;						/* Reset ptr to begining of buf	*/
	FreeMemory( szFile );						/* Free the path buffer 			*/

	DisplayFileStatus( "", CLEAR );
	return( iStatus );
}

/***************************************************************************/
/* Writes out the part of a file in the copy buffer with checking for		*/
/* using UnPack() or BigReadWrite() depending on whether the file is a		*/
/* packed file or not.																		*/
/* 																								*/
/* static long WriteFile( int iFile, struct MULT_FILES *ThisFile, 			*/
/* 							  long lToWrite ) 											*/
/* 																								*/
/* ARGUMENTS:	iFile 	- Open DOS file handle, file pointer must be set	*/
/* 							  to position for start of read or write				*/
/* 				ThisFile - Structure describing the file being written		*/
/* 				lToWrite	- Number of bytes in the copy buffer to write out	*/
/* RETURN:		long		- Number of bytes written to output file or -1L if */
/* 							  and error was detected.									*/
/*																									*/
/***************************************************************************/

static long WriteFile( int iFile, struct MULT_FILES *ThisFile, long lToWrite )
{
	long		lWritten;
#ifdef SYSTEMS_COMPRESSION
	int		HeaderLen;
#endif

	lWritten = -1L;								/* Assume there may be an error */

							/* Be sure file is the length it is supposed to be 	*/
							/* and then seek to the offset for the next write		*/

	if ( filelength( iFile ) >= ThisFile->lWritten &&
		  _dos_seek( iFile, ThisFile->lWritten, SEEK_SET ) == ThisFile->lWritten )
	{
#ifdef SYSTEMS_COMPRESSION
		if ( ThisFile->IsPacked )						/* Check for compress file */
		{
								/* If first time for file, initialize ring buffer	*/
			HeaderLen = ThisFile->IsPacked == WINDOWS_COMPRESS ?
							sizeof( struct WIN_HEADER ) :
							sizeof( struct PACKED_HEADER );

			if ( ThisFile->lUnpacked <= HeaderLen )
				ClearRingBuffer( ThisFile->IsPacked );

			lWritten = Unpack( iFile, ThisFile->pchStart, lToWrite );
		}
		else
#endif
            if ( BigReadWrite( iFile, ThisFile->pchStart, lToWrite,
					 WRITE ) == OK )
				lWritten = lToWrite; 						/* written == lToWrite		*/
	}
	return( lWritten );
}

#ifndef SYSTEMS_COMPRESSION


/***************************************************************************/
/* Expands a file directly from file to file without buffering in memory.	*/
/* Used as a performance enhancement when copying large packed files and	*/
/* installing to a hard disk (no disk swaps necessary).							*/
/* 																								*/
/* static long ExpandFile( int iFile, struct MULT_FILES *ThisFile )			*/
/* 																								*/
/* ARGUMENTS:	fhSrc 	- Open DOS file handle, file pointer must be set	*/
/* 							  to start of file (input packed file) 				*/
/* 				ThisFile - Structure describing the file being written		*/
/* RETURN:		long		- Number of bytes written to output file or -1L if */
/* 							  and error was detected.									*/
/*																									*/
/***************************************************************************/

static long ExpandFile( int fhSrc, struct MULT_FILES *ThisFile )
{
	char				*szFile;
	int				iFile;
	int				iStatus;
	long				lWritten;
	struct find_t	Info;

	DisplayFileStatus( "", CLEAR );
	szFile = GetMemory( MAX_PATH_LEN );		/* Allocate a path buffer			*/

	BuildPath( szFile, ThisFile->Drive.Destin, ThisFile->Path.Destin,
				  ThisFile->Name.Destin );

	iStatus = ERROR;

	DisplayFileStatus( ThisFile->Name.Destin, WRITE );

	_dos_setfileattr( szFile, _A_NORMAL );

	if ( (_dos_findfirst( szFile, _A_FINDALL, &Info ) == OK &&
			_dos_open( szFile, O_RDWR, &iFile ) == OK)||
		  _dos_creat( szFile, 0, &iFile ) == OK )
	{
		lWritten = LcbDecompressToFile( fhSrc, iFile, LCBNIL, 0L, FALSE );
		if ( lWritten == ThisFile->lDestinSize )
		{
			iStatus = OK;
			ThisFile->lWritten  = lWritten;
			ThisFile->lUnpacked = ThisFile->lRead = ThisFile->lSourceSize;

			chsize( iFile, ThisFile->lDestinSize );
			_dos_setftime( iFile, ThisFile->Date, ThisFile->Time );

		} else

			lWritten = 0;					/* error, return 0 size 				*/

		iStatus |= (int)_dos_close( iFile );
	}

	if ( iStatus != OK )
	{
		if (gfCompressedDiskInstall)
		{
			gfCompressedDiskIsFull = TRUE;
			FreeMemory (szFile); 			/* Free the path buffer 			*/
			return (ERROR);
		}
		else
		{
			ProcessCopyError( ParseFileName( szFile ), ERR_WRITING );
			ThisFile->lSourceSize = 0L;	/* If error set file size to 0	*/
			ThisFile->lDestinSize = 0L;
		}
	}

	if ( ThisFile->lSourceSize == 0L )	/* If source size == 0 we had an */
		remove( szFile ); 					/* error so delete destin file	*/

	FreeMemory( szFile );						/* Free the path buffer 			*/

	DisplayFileStatus( "", CLEAR );

	return ( lWritten );

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\biosrset.asm ===
;========================================================
COMMENT #

	BIOSRSET.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Does a ROM BIOS drive reset on the specified drive.

	void ResetDrv( int Drive );

	ARGUMENTS:	Drive	- Physical disk drive number.

	RETURNS:	void
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

ResetDrv PROC Drive:BYTE

	mov	AL,00
	mov	DL,Drive
	int	13
	ret

ResetDrv ENDP

; =======================================================

	END

; =======================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\abs_rdwr.asm ===
;========================================================
COMMENT #

	ABS_RDWR.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential


	=================================================
	Does an absolute sector read or write using int
	25h or 26h. Special care is taken to be sure the
	function will work under any version of DOS
	2.0 - 4.x.

	int AbsReadWrite( int Drive, struct ABSIO_PACKET far *absPack,
			  int ReadWrite );

	ARGUMENTS:	absPack - Ptr to DOS 4.x int 25,26 access packet
			Drive	- Drive number (A=0,B=1,C=2,...)
			ReadWrite- Flags whether to do a read or write
				   operation, ie:
				   0  = READ
				   !0 = WRITE
	RETURNS:	int	- 0 if successful else error code
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

ABSIO_PACKET	STRUC

	StartSec	dd	?
	NumSecs		dw	?
	SecBuffer	dd	?

ABSIO_PACKET	ENDS

INCLUDE	model.inc


; =======================================================

.CODE

; =======================================================


AbsReadWrite PROC uses ES DS SI DI, Drive:BYTE, absPack:PTR, ReadWrite:WORD
	
LoadRegs:
	mov	AL,Drive		; Put DOS drive # in AL

;	lds	BX,absPack		; DS:BX ptr to packet structure
	LoadPtr	DS, BX, absPack

	mov	CX,-1			; Test DOS it's a packet call

SetupForNewMethod:
	push	AX			; Save registers in case first
	push	BX			; try fails and we need to try
	push	CX			; the new type of packet call
	push	DS

UseOldMethod:
	mov	CX,[BX].NumSecs		; Number of sectors to read or write
	mov	DX,WORD PTR [BX].StartSec ; Starting sector #
	lds	BX,[BX].SecBuffer	; Ptr to buffer in DS:BX

TestReadWrite:
	push	CX
	or	ReadWrite,0 		; 0 == READ else WRITE
	jz	DoRead

DoWrite:
	int	26h			; DOS absolute sector write
	jmp	SHORT CheckCarry

DoRead:
	int	25h			; DOS absolute sector read

CheckCarry:
	pop	BX			; Adjust the stack (see MS Prog Ref)
	pop	CX
	pushf				; Save return status
	cmp	CX,-1			; See if first try
	jne	DoSecondTry 		; Was first try do second method
	popf				; Restore error status
	jc	ConvertToInteger	; If carry return error code
	jmp	SHORT NoError

DoSecondTry:
	popf				; Restore error status
	pop	DS 			; Restore packet segment
	pop	CX			; Restore packet signal word
	pop	BX			; Restore packet offset
	pop	AX			; Restore drive number
	jnc	NoError			; First try was success 
	jmp	SHORT TestReadWrite	; Retry the operation

NoError:
	xor	AX,AX			; No error so return OK

ConvertToInteger:
	cbw				; Extend the sign bit into AH

	or	ReadWrite,0 		; If this was a write we
	jz	Done			; need to do a disk reset
					; to be sure buffers are flushed
	push	AX			
	mov	AH,0dh			; DOS disk reset function
	int	21h
	pop	AX

Done:
	ret

AbsReadWrite ENDP

; =======================================================

	END

; =======================================================

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\copy\unpack.asm ===
COMMENT	#

	UNPACK.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	Functions for uncompressing an LZ compressed buffer.

	Created 11-28-89 johnhe
	TABS = 7

END_COMMENT #

RING_BUF_LEN	EQU	4096
UNPB_BUF_LEN	EQU	(512 * 17)
INDEX_LEN	EQU	2

WIN_MAX_STR_LEN	EQU	16
LANG_MAX_STR_LEN	EQU	(16 + INDEX_LEN)
MAX_STR_LEN		EQU	(LANG_MAX_STR_LEN + 2)

LANGUAGE_COMPRESS	EQU	1
WINDOWS_COMPRESS	EQU	2

; =========================================================================

DOSSEG

.MODEL	LARGE,C

.DATA

; =========================================================================
; UnpackSet has to allocated before a call to either ClearRingBuffer for
; Unpack. It will contain a ptr to a segment allocated for use by the
; unpack functions. When it is allocated it must be normalize to the
; allocated buffer + 16 so that it can be used with a zero offset by
; the unpack functions.
; =========================================================================

	PUBLIC	UnpackSeg
UnpackSeg	dd	(?)

; =========================================================================
; BUFFER_SEG is not a real segment in the program but is used to get the
; offsets into a buffer pointed to by UnpackSeg. By using this dummy segment
; it allows setting DS to WORD PTR UnpackSeg[2] and then accessing all of
; the area without using segment over-rides.
; =========================================================================

BUFFER_SEG 	SEGMENT at 00

	ORG	0
RingBuf		db	RING_BUF_LEN DUP (?)	; Must org @ 0
RingBufEnd	LABEL	BYTE

UnpackBuffer	db	UNPB_BUF_LEN DUP (?)
UnpackBufEnd	LABEL	BYTE

lToDo		dd	(?)		; Total bytes remaining in unpack buf
lWritten	dd	(?)		; Keeps track of total unpacked bytes

iOutFile	dw	(?)		; Open file handle passed by caller
CtrlFlags	dw	(?)		; Currunt control byte from upack buf
RingIndex	dw	(?)		; Start offset in RingBuffer
Char		db	(?)		; Current char from packed buffer

SplitPoint	db	(?)		; Determines where to start
OldSplitPoint	db	(?)		; Saves last spit point

BUFFER_SEG	ENDS

; =========================================================================

.CODE

EXTRN		fUpdateByteCount:FAR		; Must be explicitly FAR

; =========================================================================
; Sets up the ring buffer for a new file by filling the buffer with
; spaces and setting the ctrl flags and buffer index to known starting
; values.
;
; void ClearRingBuffer( int CompressType )
;
; ARGUMENTS:	int	- Compression type (0 == Language group, 1 == Windows)
; RETURNS: 	void
;
;	RingIndex =  MAX_STR_LEN (depending on compression type)
;	CtrlFlags = 0;
;	SplitPoint = 0;
;	memset( RingBuffer, ' ', RING_BUF_LEN - MAX_STR_LEN );
;
; =========================================================================

ClearRingBuffer PROC USES DS ES DI, CompressType:BYTE

	mov	AX,WORD PTR UnpackSeg[2]	; Get the allocated segment
	mov	DS,AX
	mov	ES,AX

	ASSUME	DS:BUFFER_SEG, ES:BUFFER_SEG

	xor	AX,AX				; DS:AX -> Start of ring buff
	mov	CtrlFlags,AX
	mov	SplitPoint,AL
	mov	DI,AX				; DS:DI -> Start of ring buff

	mov	RingIndex, RING_BUF_LEN - LANG_MAX_STR_LEN
	cmp	CompressType,WINDOWS_COMPRESS
	jne	@F
	mov	RingIndex, RING_BUF_LEN - WIN_MAX_STR_LEN 
@@:
	mov	AX,2020h			; AX == '  '
	mov	CX,(RING_BUF_LEN / 2)		; Storing words so use half
	cld
	rep	stosw				; Fill buffer with ' ' chars

	ret

ClearRingBuffer ENDP

; =========================================================================
; Uncompresses a portion of a compressed file which was compressed using
; LZ compression algorithm. Before the function is called the ring buffer
; and unpacked buffer must be allocated. Before each new file is unpacked
; a call must be done to ClearRingBuffer() to initialize the buffers and
; indices. As the buffer is unpacked it is written to the destination
; file when ever the index in the unpacked buffer reaches a point
; MAX_STR_LEN from the end of the buffer. Each time the buffer is flushed
; the ptr to the packed buffer must be normalized to prevent a possible
; segment wrap of the ptr.
; 																							
; long Unpack( int iFile, char far *InBuf, long lPackedBytes )			
; 																							
; ARGUMENTS:	iFile 	- Open DOS file handle to write the unpacked bytes
; 		InBuf 	- Ptr to buffer to be unpacked
; 			  lPackedBytes  - Length of the buffer in bytes
; RETURNS: 	long	- Number of bytes written to the file.
;
;
; Register will be setup and used as follows within the function
;
;	ES:BX	-> Next byte in packed buffer
;	DS:SI	-> Ring buffer
;	DS:DI	-> Next byte in unpack buffer
;	BP     ==  CtrlFlags
;	DX	   General use
;	CX	   General use
; =========================================================================

Unpack PROC USES DS ES DI SI,iFile:WORD, PackedBuf:PTR, lPackedBytes:DWORD

	mov	AX,WORD PTR UnpackSeg[2]; Get the allocated unpack segment
	mov	DS,AX

	ASSUME	DS:BUFFER_SEG

	les	AX,lPackedBytes		; ES:AX == number of bytes to unpack
	mov	WORD PTR lToDo,AX	; Move number for faster access
	mov	WORD PTR lToDo[2],ES	; lToDo = Total byte to unpacked

	mov	AL,SplitPoint		; Save split point in case this is
	mov	OldSplitPoint,AL	; a continuation of a previous unpack
	mov	SI,RingIndex		; DS:SI -> current pos. in ring buffer

	mov	AX,iFile		; Put iFile into new segment
	mov	iOutFile,AX

	les	BX,PackedBuf		; Get input buffer and normalize
	call	NEAR PTR NormalizePackPtr ; ES:BX -> normalize packed buffer

	mov	DI,OFFSET UnpackBuffer	; DS:DI -> Unpack buffer

	xor	AX,AX			; Reset everything else to 0
	mov	SplitPoint,AL
	mov	WORD PTR lWritten,AX
	mov	WORD PTR lWritten[2],AX


	push	BP			; Save BP for cleanup later
	mov	BP,CtrlFlags		; BP will always hold the ctrl flags

	cmp	OldSplitPoint,1		; See if this is a continuation
	je	SplitPoint1		; of a previous file and if so
	mov	AL,Char			; may need last char from unpack buf
	cmp	OldSplitPoint,2		; to start at the place where it
	je	SplitPoint2		; was left off last time

MainLoop:	; Start of loop which will continue until lToDo == 0

	mov	AX,WORD PTR lToDo	; See if all bytes are unpacked
	or	AX,WORD PTR lToDo[2]
	jnz	CheckUnpackBuf		; Continue if both bytes != 0
	jmp	UnpackExit		; Jump to successfull exit point

CheckUnpackBuf:				; See if time to flush buffer
	and	SI,0fffh		; Make ptr to wrap back to 0 if > 4095
	cmp	DI,OFFSET UnpackBufEnd - MAX_STR_LEN
	jl	GetNextChar 		; Buffer not full yet

	call	NEAR PTR FlushUnpackBuffer ; Else flush the buffer

	or	AX,AX			; AX will be -1 if error else 0
	jz	GetNextChar
	jmp	ErrorExit

GetNextChar:
	mov	AL,ES:[BX]		; Get next char from in buf
	inc	BX			; Increment packed buffer ptr
	sub	WORD PTR lToDo,1	; Decrement remaining packed bytes
	sbb	WORD PTR lToDo[2],0

AnyFlagsLeft:
	shr	BP,1			; High byte has bit mask of flags
	test	BP,0ff00h 		; Any flags left in this byte?
	jnz	TestFlag		; If yes go forward and check the flag

		; Set bit mask to for next 8 characters

	or	AX,0ff00h		; Set all bits in high byte for count
	mov	BP,AX

	mov	AX,WORD PTR lToDo	; See if all bytes are unpacked
	or	AX,WORD PTR lToDo[2]
	jnz	SplitPoint1		; Continue if both bytes != 0

		; If we get here it means we ran out of characters in the
		; unpacked buffer but there's still more to do on the next
		; call so set up to continue where we left off and then
		; flush the buffer and return. We we return on the next
		; call we already have the new control word can continue
		; where we left off

	mov	SplitPoint,1		; Set starting point for next call
	jmp	SHORT UnpackExit

SplitPoint1:				; At this point we just used the char
	mov	AL,ES:[BX]		; as ctrlbyte and need another char
	inc	BX			; Increment packed buffer ptr
	sub	WORD PTR lToDo,1	; Decrement remaining packed count
	sbb	WORD PTR lToDo[2],0

TestFlag:
	test	BP,1			; If flag == 1 character is not
	jz	UnpackIt		; special so just copy it

	mov	[DI],AL			; Store char in unpacked buffer
	mov	[SI],AL			; Also store it in the ring buffer
	inc	DI			; Point to next char in unpacked
	inc	SI			; and ring buffer
	jmp	MainLoop

		; Flag bit was 0 so get a string from ring buf
UnpackIt:
	mov	DX,WORD PTR lToDo	; See if all bytes are unpacked
	or	DX,WORD PTR lToDo[2]
	jnz	SplitPoint2		; Continue if both bytes != 0

		; If we get here it means we ran out of characters in the
		; unpacked buffer but there's still more to do on the next
		; call so set up to continue where we left off and then
		; flush the buffer and return. We we return on the next
		; call we already have the first byte of the control
		; word which determines the ringbuf offset and string count

	mov	Char,AL			; Save the byte, we need it next call
	mov	SplitPoint,2		; Set starting point for next call
	jmp	SHORT UnpackExit

SplitPoint2:	; offset in ringbuf = ((next char & 0xf0) << 4) + AL
		; length to copy    = (nextchar & 0x0f) + 2)

					; AL has last char from packed buffer
	mov	AH,ES:[BX]		; Get the ctrl byte from packed buf
	inc	BX			; Increment packed buffer ptr
	sub	WORD PTR lToDo,1	; Decrement remaining packed bytes
	sbb	WORD PTR lToDo[2],0

	xor	CX,CX			; Determine the str length in CX
	mov	CL,AH			; CX = ctrl byte from the packed buf
	and	CL,0fh			; Mask off the high nibble of low byte
	add	CL,3
;	inc	CL			; Add 2
;	inc	CL			; CX == count of bytes to copy


	shr	AH,1			; Put hi nibble into low nibble	of AH
	shr	AH,1			; and now AX will be a 12 bit value
	shr	AH,1			; which represents the offset in the
	shr	AH,1			; ring buffer

CopyString:
		; The string length may force a wrap of the ringbuffer so
		; we have to anticipate this by	having 2 methods of
		; copying. If the ring buffer wraps we do a slow copy that
		; normalizes SI after each movs instruction.

		; Don't need a CX check because the value will always
		; always be >= 3 because of the above ADD CX,3

	push	ES			; Save the unpacked segment

	mov	DX,SI			; DS:DX --> Dest ringbuf location

	mov	SI,AX			; DS:SI --> Source ringbuf location
	mov	AX,DS			
	mov	ES,AX			; ES:DI --> Dest unpackbuf location
					
	cld

DoCopy:
	lodsb				; Get source byte from ring buffer
	stosb				; Copy byte to unpacked buffer
	xchg	DI,DX			; DS:DI --> Dest ringbuf location
	stosb				; Copy byte to new ringbuf location
	xchg	DI,DX			; DS:DI --> Next unpackbuf location
	and	DX,0fffh		; Prevent wraps in the ring buffer
	and	SI,0fffh		; Have to do both source ptrs
	loop	DoCopy

	mov	SI,DX			; DS:SI --> Next ringbuf offset
	pop	ES			; ES:BX --> unpacked segment again
	jmp	MainLoop

		; ==========================================================
		; Function exit points. If the unpacked buffer has anything
		; copied to it which needs to be written it will be flushed
		; if there were no errors.
		; ==========================================================
UnpackExit:
	cmp	DI,OFFSET UnpackBuffer 	; See if anything in unpack buffer
	je	SetReturnCount

	call	NEAR PTR FlushUnpackBuffer ; Need to flush one last time
	or	AX,AX			; Check for error
	jnz	ErrorExit

SetReturnCount:
	les	AX,lWritten
	mov	DX,ES			; DX:AX == Unpacked bytes written
	jmp	SHORT UnpackExit2

ErrorExit:
	mov	AX,-1			; Signal error
	cwd				; DX:AX == -1

UnpackExit2:
	mov	RingIndex,SI		; Save current ring buffer index
	mov	CtrlFlags,BP
	pop	BP
	ret

Unpack	ENDP

; =========================================================================
; Flushes the unpack buffer to file and then resets the output buffer
; indices to be ready to starting filling the buffer again. After writing
; to the file a call is done to update the gage on the screen and
; then the unpacked ptr is normalized.
;
; int FlushUnpackBuffer( void )
;
; ARGUMENTS:	NONE																			*/
; RETURN:	int	- OK if disk write successfully else ERROR
;																						*/
; =========================================================================

FlushUnpackBuffer:

	push	SI
	mov	SI,BX			; Save unpacked offset for normalizing

	mov	DX,OFFSET UnpackBuffer	; DS:DX --> Start of unpacked buffer
	sub	DI,DX			; DI == count of bytes to write
	mov	CX,DI			; CX == Count of byte to write

	mov	AH,40h			; DOS write handle function
	mov	BX,iOutFile		; BX = Open file handle

	int	21h
	jc	FlushError		; Error check
	cmp	AX,DI			; See if all bytes were written
	jne	FlushError

	add	WORD PTR lWritten,CX	; Update total bytes
	adc	WORD PTR lWritten[2],0	; written to disk

		; Bytes were successfully written so setup and call
		; the function to update the gage on the screen

	push	DS
	push	ES

	mov	AX,@DATA		; Setup ES & DS to C data segment
	mov	DS,AX
	mov	ES,AX

	xor	AX,AX			
	push	AX			; Put byte count on the stack
	push	CX			; as a long value (dword)
					
	call	fUpdateByteCount	; Update the status gage C function
	add	SP,4			; Adjust SP for 2 pushes

	pop	ES
	pop	DS

	mov	BX,SI			; ES:BX --> packed buffer
	call	NEAR PTR NormalizePackPtr ; ES:BX -> normalize packed buffer

FlushExit:
	mov	DI,OFFSET UnpackBuffer	; Reset DS:DI to start of unpack buf
	pop	SI
	xor	AX,AX			; Return OK
	ret

FlushError:
	pop	SI
	mov	AX,-1			; Signal error
	ret

; =========================================================================
; Normalizes ptr to packed buffer in ES:BX
; =========================================================================

NormalizePackPtr:

	push	AX
	push	BX

	mov   	AX,ES			; AX:BX -> current packed buf location
	xchg	AX,BX			; Now BX == Segment, AX = Offset

	shr	AX,1			; Divid offset in AX by 16
	shr	AX,1
	shr	AX,1
	shr	AX,1
	add	AX,BX			; Add segment to normalized offset
	mov	ES,AX			; ES == Normalized segment

	pop	BX
	pop	AX

	and	BX,0fh			; Mask all but 4 low bits of offset

	ret				; ES:BX --> normalized packed location
					; Offset will be less than 16

; =========================================================================

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\disk_io.asm ===
;========================================================
COMMENT #

	DISK_IO.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

.CODE

; =======================================================

END




;========================================================




;========================================================

;========================================================

.CODE


; =======================================================
; Does an int 13h and resets the disk and does a retry
; if the first operation fails with an error other than
; a timeout error returns all register in the condition
; returned by the int 13h call.
; =======================================================

Int13WithRetry PROC NEAR

	push	CX			; Save needed registers
	push	DI
	push	SI

	mov	DI,AX			; Put function call in DI
	mov	SI,CX			; Put head and track in SI
	mov	CX,DISK_RETRIES		; Put number of retries in CX
	
DoInt13:
	push	CX			; Save loop counter
	mov	CX,SI			; Put head and track back in CX
	int	13h			; BIOS disk call
	pop	CX			; Restore the loop counter
	jc	IsItTimeOut		; If error then retry the operation
	jmp	SHORT FunctReturn	; Else we're finished

IsItTimeOut:
	cmp	AH,DISK_TIMEOUT		; See if this is a timeout error
	je	SetCarry		; If timeout don't retry
	cmp	CX,1			; See if retries are exhausted
	je	SetCarry		; If exhaust don't do reset

DiskReset:
	xor	AX,AX			; Set AX == 0 for retry call
	int	13h			; We can assume no timeout error
	mov	AX,DI			; Restore function call AX
	loop	DoInt13			; Exhuast all retries

SetCarry:
	stc				; Set the carry flag to show error

FunctReturn:
	pop	SI			; Restore the used registers
	pop	DI
	pop	CX
	ret

Int13WithRetry ENDP


END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\disk_io.inc ===
;========================================================
COMMENT #

	DISK_IO.INC

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	johnhe - 06/06/89

END COMMENT #
;========================================================


INVALID_DRIVE_TYPE	EQU -300
DISK_TIMEOUT		EQU 80h
DISK_RETRIES		EQU 5
BPB_SIZE		EQU 25


ABSIO_PACKET	STRUC

	StartSec	dd	?
	NumSecs		dw	?
	SecBuffer	dd	?

ABSIO_PACKET	ENDS


DOS_FCB		STRUC

	FcbDrive	db	(?)
	FcbName		db	"NUL     "
	FcbExt		db	"   "
	FcbCurBlock	dw	(?)

	FcbRecSize	dw	(?)
	FcbFileSize	dd	(?)
	FcbDate		dw	(?)
	FcbTime		dw	(?)
	
	FcbReserved	db	8 DUP (?)
	FbcCurRecord	db	(?)
	FcbRelRecord	dd	(?)

DOS_FCB		ENDS

;========================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dos_seek.asm ===
;========================================================
COMMENT #

	DOS_SEEK.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Seeks to the specified offset in an open disk
	disk file.

	long	_dos_seek( int Handle, long lOffset, int Mode )

	ARGUMENTS:	Handle	- Open DOS file handle
			lOffset - Offset to seek to in bytes
			Mode	- Seek mode as described below
				  0 = Beginning of file + offset
				  1 = Current file position + offset
				  2 = End of file + offset
	RETURNS:	long	- New offset in file is success
				  or -1L if error
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

_dos_seek PROC USES ES, Handle:WORD, lOffset:DWORD, Mode:BYTE

	mov	AH,42h
	mov	AL,Mode
	mov	BX,Handle

LoadOffset:
	les	DX,lOffset
	mov	CX,ES

Int21Call:
	int	21h
	jc	SeekError
	jmp	SHORT SeekReturn

SeekError:
	mov	AX,-1		; Error code
	cwd			; Extend sign to make a LONG (dword)

SeekReturn:
	ret

_dos_seek ENDP

; =======================================================

	END

; =======================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dma_chk.asm ===
;========================================================
COMMENT #

	DMA_CHK.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Checks to see if an area of memory will cross a DMA
	boundary. Returns OK if not on a boundary else return
	!OK.

	int CheckDmaBound( void *Buffer, unsigned Bytes )

	ARGUMENTS:	Buffer	- Ptr to memory area
			Bytes	- Lenght of memory area in byts
	RETURN:	int		- OK if not on boudary else !OK
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

CheckDmaBound PROC USES ES, Buffer:Ptr, Bytes:WORD

;	les	BX,Buffer		; ES:BX = Buffer address
	LoadPtr	ES, BX, Buffer		; ES:BX = Buffer address

TestSegmentBound:

	mov	AX,ES			; Put buffer offset in AX
	shl	AX,1			; Convert segment to 20 bit address
	shl	AX,1 			; while ingoring the high 4 bits
	shl	AX,1
	shl	AX,1

	add	AX,BX			; Add offset to 20 bit address

	add	AX,Bytes		; Add number of bytes to 20 bit addr
	jnc	NotOnBound		; If no carry then no DMA overrun
	mov	AX,1			; Signal DMA error
	jmp	SHORT DmaBoundExit	; Return to caller

NotOnBound:
	xor	AX,AX			; Signal OK

DmaBoundExit:
	ret

CheckDmaBound ENDP

; =======================================================

	END

; =======================================================

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\drv_acc.asm ===
;========================================================
COMMENT #

	DRV_ACC.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================

	void EnableDiskAccess( unsigned char Drive )

	Sets the drive access bit using undocumented
	function SET_ACCESS_FLAG (47h) of IOCtrl function
	44h.

	ARGUMENTS: Drive - DOS drive letter (A=0, B=1, C=2, ...)
	RETURNS:   VOID

	=================================================

	johnhe - 06/04/90

END COMMENT #

;========================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

;========================================================

.CODE

; =======================================================

IF @DataSize
  EnableDiskAccess PROC USES DS, Drive:BYTE
ELSE
  EnableDiskAccess PROC          Drive:BYTE
ENDIF

	LOCAL	AccessPacket:WORD

	mov	Accesspacket,0100h		; Setup the packet
	lea	DX,AccessPacket

IF @DataSize
	push	SS
	pop	DS
ENDIF

	mov	AX,4411h			; Generic ioctl	support chk
	xor	BX,BX				; Clear BX
	mov	BL,Drive			; Get Drive letter
	inc	BL				; Make it 1 based
	mov	CX,847h				; Allow access to disk
	int	21h
	jc	SetAccessExit			; If function not supported
						; we know access is allowed
	mov	AX,440dh
	int	21h

SetAccessExit:
	ret

EnableDiskAccess ENDP

;========================================================

	END

;========================================================

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dskread.asm ===
;========================================================
COMMENT #

	DSKREAD.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Uses the ROM BIOS int 13h write sectors function
	to read the specified number of sectors.

	int PhyDiskRead( char *pchBuf, int iSecCyl,
			  int iHead, char chDrive,
			  int cSecs);
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

PhyDiskRead PROC USES ES BX, pchBuf:PTR, iSecCyl:WORD, iHead:BYTE, \
			      chDrive:BYTE, cSecs:BYTE
	mov	AH,02
	mov	AL,cSecs
	mov	CX,iSecCyl
	mov	DH,iHead;
	mov	DL,chDrive

;	les	BX,pchBuf
	LoadPtr	ES, BX, pchBuf		; ES:BX --> caller's buffer

	int	13h
	mov	AX,1
	jc	ReadExit
	xor	AX,AX
ReadExit:
	ret

PhyDiskRead ENDP


END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dskwrite.asm ===
;========================================================
COMMENT #

	DSKWRITE.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Uses the ROM BIOS int 13h write sectors function
	to write the specified number of sectors.

	int PhyDiskWrite( char *pchBuf, int iSecCyl,
			  int iHead, char chDrive,
			  int cSecs);
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

.CODE

; =======================================================

PhyDiskWrite PROC USES ES BX, pchBuf:PTR, iSecCyl:WORD, iHead:BYTE, \
			      chDrive:BYTE, cSecs:BYTE
	mov	AH,03
	mov	AL,cSecs
	mov	CX,iSecCyl
	mov	DH,iHead;
	mov	DL,chDrive

;	les	BX,pchBuf
	LoadPtr	ES, BX, pchBuf

	int	13h
	mov	AX,1
	jc	WriteExit
	xor	AX,AX
WriteExit:
	ret

PhyDiskWrite ENDP

END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\drv_type.asm ===
;========================================================
COMMENT #

	DRV_TYPE.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================

	int GetDriveType( unsigned char Drive, void *Buffer )

	Determines the type of drive installed.

	ARGUMENTS: Drive	- Physical drive number
		Buffer	- Ptr to work buffer at least 100 bytes

	RETURNS:	Drive type as defined by int 13h function 8.
		1	   360K   5.25"
		2	   1.2M   5.25"
		3	   720K   3.5"
		4	   1.44M  3.5"

	=================================================

	STRATEGY:

	if ( DOS IOCTL Supported )
		got drive	type
	else if ( bios int 13 function 8 != CARRY )
		got drive	type
	else if ( bios int 13 function 15h != CARRY )
	{
		if ( changeline supported )
		drive type = 1.2 meg
		else
		drive tyupe = 360K
	}
	else
		drive type = 360K

	=================================================

	johnhe - 06/06/89

END COMMENT #

;========================================================

INCLUDE	model.inc

;========================================================

.CODE

; =======================================================

IF @DataSize
  GetDriveType PROC USES DS ES DI, Drive:BYTE, Buffer:PTR
ELSE
  GetDriveType PROC USES    ES DI, Drive:BYTE, Buffer:PTR
ENDIF

TryIoctl:

;	les	DI,Buffer	; ES:DI is ptr to buffer
	LoadPtr	ES, DI, Buffer	; ES:DI is ptr to buffer

	push	DI		; Save ptr in DI for later use
	mov	CX,50		; Get length of buffer in words
	xor	AX,AX		; Buffer fill bytes
	cld 			; Set direction to forward
	rep	stosw 		; Set the buffer to all zeros

	mov	AX,440dh	; DOS generic IOCTL
	mov	BL,Drive	; Set drive number
	inc	BL		; Convert to DOS drive number
	mov	CX,0860h	; CH = block dev, CL = Get parameters

;	lds	DX,Buffer	; Ptr to buffer in DS:DX
	LoadPtr	DS, DX, Buffer	; Ptr to buffer in DS:DX

	int	21h		; DOS call
	pop	DI		; Get ptr to buffer off stack

	jc	TryBios08	; This IOCTL call not supported

ConvertToBiosType:
	inc	DI		; Point to device type byte
	mov	AL,[DI]		; Get the device type byte
 	inc	AL		; Convert to BIOS type device
	cmp	AL,08h		; Check for special 1.44 meg case
	jne	GotDrive	; Finished so jump to exit
	shr	AL,01		; Convert from DOS 1.44 drive # to BIOS #
	jmp	SHORT GotDrive	; Finished so jump to exit

TryBios08:
	mov	AH,08h		; Get disk parameters function
	mov	DL,Drive	; DL = physical drive number

	push	DX 		; This function may fail so keep DX
	int	13h 		; Bios disk interupt
	pop	DX		; Restore drive number in DX

	jc	TryBios15	; Function not support so try function 15h
	mov	AL,BL		; Move drive type into AL
	jmp	SHORT GotDrive 	; Finished so jump to exit


TryBios15:
	mov	AH,15h		; Get change line support, remember
	int	13h		; that DX already has drive number
	jc	Is360K		; Function not supported so must be 360K
	test	AH,1		; Test no changeline bit
	jnz	Is360K		; No change line so default to 360K
	mov	AL,02		; Has change lines so assume 1.2 meg drive
	jmp	SHORT GotDrive	; Finished so jump to exit

Is360K:
	mov	AL,01		; Default drive size

GotDrive:
;	cbw			; Clear high byte of AX
	xor	AH,AH		; M00 Clear high byte of AX

	cmp	AL,4		; M125 Error check for unsupported drive type
	jbe	@f		; M125 such as 2.88 meg drives, in such cases
	mov	AL,4		; M125 revert to 1.44 drive type
@@:				; M125
	ret

GetDriveType ENDP

;========================================================

	END

;========================================================

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_fbot.c ===
/***************************************************************************/
/*																									*/
/*	DSK_BOOT.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/*	Misc. floppy disk access function via the ROM BIOS int 13h interface.	*/
/* Original created for the RUP format and backup programs.						*/
/*																									*/
/* 																								*/
/* Created 07-23-89 johnhe																	*/
/***************************************************************************/

#include		<stdio.h>
#include 	<string.h>
#include		<memory.h>

#include		<alias.h>
#include 	<disk_io.h>

/************************************************************************/
/* Copies the BPB structure for the current disk to a boot record and	*/
/* then writes the boot record to the disk.										*/
/*																								*/
/* int WriteBoot( int iDrv, struct BPB *Bpb, char *szLabel )				*/
/*																								*/
/*	ARGUMENTS:	Bpb		- BPB to use for this disk								*/
/*					szLabel	- Disk label string or NULL for no label			*/
/*	RETURNS:		int		- OK or BIOS int 13h disk error						*/
/*																								*/
/************************************************************************/

int FloppyWriteBoot( int iDrv, struct BPB *Bpb, char *szLabel )
{
	extern char				NewBootRec;		/* 512 byte boot sector	*/
	struct BOOT_HEADER	*Header;
	struct DIR				Dir;
	int						i;

	Header = (struct BOOT_HEADER *)(&NewBootRec);

	memcpy( &(Header->Bpb), Bpb, sizeof( struct BPB ) );

	Header->uchPhysDrv = 0;
	Header->uchCurHd = 0;

		/* If boot header doesn't have extended BPB signature we need	*/
		/* to zero any extended fields not explicitly set by us.			*/

	Header->Bpb.ulHiddenSec &= 0x0000ffffL;
	Header->Bpb.ulTotalBigSecs = 0L;
	Header->uchExtSig = 0x29;

	SetFileTimeDate( &Dir );
	Header->ulSerial = *( (long *)(&(Dir.Time)) );
	
	if ( szLabel != NULL )
	{
		for ( i = 0; i < 11; i++ )
		{
			if ( *szLabel != 0 )
				Header->uchVolLabel[i] = *(szLabel++);
			else
				Header->uchVolLabel[i] = ' ';	
		}
	}
	else
		memset( Header->uchVolLabel, ' ', 11 );


	memcpy( Header->uchSystemId, "FAT12   ", 8 );

	return( RdWrSectors( iDrv, 0, 1, &NewBootRec, Bpb, WRITE ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_boot.c ===
/***************************************************************************/
/*																									*/
/*	DSK_BOOT.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/*	Misc. floppy disk access function via the ROM BIOS int 13h interface.	*/
/* Original created for the RUP format and backup programs.						*/
/*																									*/
/* 																								*/
/* Created 07-23-89 johnhe																	*/
/***************************************************************************/

#include		<stdio.h>
#include 	<string.h>
#include		<memory.h>

#include		<alias.h>
#include 	<disk_io.h>

/************************************************************************/
/* Copies the BPB structure for the current disk to a boot record and	*/
/* then writes the boot record to the disk.										*/
/*																								*/
/* int WriteBoot( int iDrv, struct BPB *Bpb, char *szLabel )				*/
/*																								*/
/*	ARGUMENTS:	Bpb		- BPB to use for this disk								*/
/*					szLabel	- Disk label string or NULL for no label			*/
/*	RETURNS:		int		- OK or BIOS int 13h disk error						*/
/*																								*/
/************************************************************************/

int WriteBoot( int iDrv, struct BPB *Bpb, char *szLabel )
{
	extern char				NewBootRec;		/* 512 byte boot sector	*/
	struct BOOT_HEADER	*Header;
	struct DIR				Dir;
	int						i;

	Header = (struct BOOT_HEADER *)(&NewBootRec);

	memcpy( &(Header->Bpb), Bpb, sizeof( struct BPB ) );

	Header->uchPhysDrv = 0;
	Header->uchCurHd = 0;

		/* If boot header doesn't have extended BPB signature we need	*/
		/* to zero any extended fields not explicitly set by us.			*/

	if ( Header->uchExtSig != 0x29 )
	{												/* Zero hi-word of hidden sectors	*/
		Header->Bpb.ulHiddenSec &= 0x0000ffffL;
		Header->Bpb.ulTotalBigSecs = 0L;
		Header->uchExtSig = 0x29;
	}

	SetFileTimeDate( &Dir );
	Header->ulSerial = *( (long *)(&(Dir.Time)) );
	
	if ( szLabel != NULL )
	{
		for ( i = 0; i < 11; i++ )
		{
			if ( *szLabel != 0 )
				Header->uchVolLabel[i] = *(szLabel++);
			else
				Header->uchVolLabel[i] = ' ';	
		}
	}
	else
		memset( Header->uchVolLabel, ' ', 11 );


	memcpy( Header->uchSystemId, "FAT12   ", 8 );

	return( RdWrSectors( iDrv, 0, 1, &NewBootRec, Bpb, WRITE ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_dir.c ===
/***************************************************************************/
/*																									*/
/* DSK_DIR.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* Functions to verify a multi-level directory path and create the path.	*/
/* If an error is detected any newly created levels in the path are			*/
/* removed to insure the disk is not left with random directories.			*/
/*																									*/
/* Created 07-23-89 johnhe																	*/
/*																									*/
/*	modified 07/26/90 t-gerrit -- IsValidPath now gives caller the option	*/
/*	to delete the portion of the path that is created regardless of whether */
/*	or not an error occurs.																	*/
/***************************************************************************/
 
#include 	<stdio.h>
#include 	<dos.h>
#include 	<direct.h>

#include 	<alias.h>
#include 	<disk_io.h>
#include 	<string.h>
#include		<strlib.h>

#define		ERROR 			-1

int IsReservedName( char *szPath );

/***************************************************************************/
/* Validates a directory path string by cleaning up the string and then		*/
/* creating the directory path. If the path can be successfully created it	*/
/* is assumed to be a valid path. If there is an error creating the path	*/
/* it is assumed the path name is invalid and any part of the path that		*/
/* did not exist originally is deleted. The path may contain a trailing		*/
/* '\' character but it is not necessary as one will be added by this		*/
/* function if it was omitted. If SavePath is FALSE, the part of the path  */
/* that has been created is deleted. The current path is is saved on entry */
/* and restored before the function returns to the caller. 						*/
/*																									*/
/*	int IsValidPath( char *szPath, unsigned DrvNumber, int SavePath )			*/
/*																									*/
/* ARGUMENTS:	szPath	- A directory path string									*/
/* 				DrvNumber - DOS drive number: 1 = A, 2 = B, 3 = C, ...		*/
/*					SavePath - TRUE if part of path that is created is to be 	*/
/*									kept, FALSE if it	is to be deleted.					*/
/* RETURNS:		int		- TRUE if a valid path else FALSE						*/
/***************************************************************************/

int IsValidPath( char *szPath, unsigned uDrvNumber, int SavePath )
{
	char				szCurPath[ MAX_PATH_LEN	];
	char				*szPtr;
	register 		Status;
	unsigned			uDrvTotal;
	unsigned 		uDrvCurrent;

	_dos_getdrive( &uDrvCurrent );					/* Save current drive		*/
	_dos_setdrive( uDrvNumber, &uDrvTotal );		/* Change to desired drive	*/
	if ( uDrvNumber > uDrvTotal )						/* Check for valid drive	*/
		return( FALSE );

#ifdef DBCS
	DBCSstrupr( szPath );
#else
	strupr( szPath );
#endif

	getcwd( szCurPath, (MAX_PATH_LEN - 1) );
	szPtr  = szPath;

	RemoveSpaces( szPath );
	RemoveTrailing( szPath, '\\' );
	if ( *szPtr != '\\' )
		InsertChar( szPath, '\\' );

	if ( strlen( szPath ) == 1 ) 						/* Check for root dir */
		return( FALSE );

	chdir( "\\" );											/* Change to root dir		*/

	if ( (Status = MoveToDir( szPath, SavePath )) == OK )
	  ;						/* New path was success 	*/
	else
		Status = ERROR;

	chdir( szCurPath );								/* Return to original dir	*/
	_dos_setdrive( uDrvCurrent, &uDrvTotal ); 	/* Restore current drive	*/

	return( Status == OK ? TRUE : FALSE );
}

/***************************************************************************/
/* Changes the current directory to the first directory and then				*/
/* recursively calls itself to go to the next directory so that eventually	*/
/* the current directory will be the same as the entire path string. If 	*/
/* any directories in the path string do not exist, they will be created	*/
/* but if the next recursive call to MoveToDir fails or SavePath is FALSE  */
/* any directory which was created will be deleted.								*/
/*																									*/
/* int	MoveToDir( char *szPath, int SavePath)										*/
/*																									*/
/*	ARGUMENTS:	szPath	- The path string to use to find the next directory*/
/*					SavePath - TRUE if directories created are to be deleted,	*/
/*								  FALSE ifthey are to be kept.							*/
/* RETURNS:		int		- OK if successful else ERROR								*/
/*																									*/
/***************************************************************************/
int	MoveToDir( char *szPath, int SavePath )
{
	int		Status = OK, NewDir = FALSE;
	char		*pchEnd = NULL;

	if ( *szPath == EOL )		/* See if there is a path to change to */
		;								/* If not just return success */
	else
	{
		szPath++; 					/* Step over the backslach character */
#ifdef DBCS
		pchEnd = DBCSstrchr( szPath, '\\' );
#else
		pchEnd = strchr( szPath, '\\' );
#endif
		if ( pchEnd != NULL )	/* If a back slash change it to an EOL */
			*pchEnd = EOL;
										/* Check for max directory name length */
		if ( !IsValidDirName( szPath ) )
			Status = ERROR;
		else if ( chdir( szPath ) == OK )
			;
		else
		{
			if ( mkdir( szPath ) == OK )
			{
				NewDir = TRUE;
				if ( chdir( szPath ) == OK )
				{
					Status = OK;

						/*If we aren't saving path's and aren't going to*/
						/*recurse any further then remove the directory.*/
					if ((SavePath == FALSE) && (pchEnd == NULL))
					{
						chdir ("..");
						rmdir ( szPath );
					}

				}
				else
					rmdir( szPath ), Status = ERROR, NewDir = FALSE;
			}
			else
				Status = ERROR;
		}
		if ( Status == OK  && pchEnd != NULL )
		{									/* Recursively move to the next directory */
			*pchEnd = '\\';			/* Replace directory seperator */
			if ( (Status = MoveToDir( pchEnd, SavePath )) == OK )
				{
					if ( ( NewDir == TRUE ) && ( SavePath == FALSE) )
					{
						chdir ("..");
						*pchEnd = EOL;
						rmdir ( szPath );
						*pchEnd = '\\';
					}
				}
			else
			{
				chdir( ".." );
				if ( NewDir == TRUE )
				{
					*pchEnd = EOL;
					rmdir( szPath );
					*pchEnd = '\\';				/* Replace directory seperator */
				}
			}
		}

	}
	return( Status );
}

/***************************************************************************/
/* Scans a string to see if the string can be used a valid directory name. */
/* The scan checks to be sure each character in the name is a valid			*/
/* character for a path name. There is also a check to be sure that only	*/
/* there is not more than 1 decimal in the name and that if there is a		*/
/* decimal that the primary name and extension do not exceed the maximum	*/
/* length of 8 chars for primary and 3 for extension. If the name does 		*/
/* not include a decimal the max length is 8 characters.							*/
/*																									*/
/* int IsValidDirName( char *szPath )													*/
/*																									*/
/* ARGUMENTS: szPath		- String containing a directory name.					*/
/* RETURNS	: int			- TRUE if valid name else FALSE.							*/
/*																									*/
/***************************************************************************/

int IsValidDirName( char *szPath )
{
	int		Status;
	char		*szDecimal;

	Status = FALSE;
	if ( strlen( szPath ) > 0 &&
		  ValidDirChars( szPath ) &&
		  !IsReservedName( szPath ) )
	{
		if ( (szDecimal = strchr( szPath, '.' )) != NULL )
		{
			if ( strchr( szDecimal + 1, '.' ) == NULL &&	/* Chk for more '.'s */
				  (szDecimal - szPath) <= 8 &&				/* Chk lengths */
				  (strchr( szDecimal, EOL ) - szDecimal - 1) <= 3  )
				Status = TRUE;
		}
		else if ( strlen( szPath ) <= 8 )
			Status = TRUE;
	}
	return( Status );
}

/***************************************************************************/
/* Checks all of the characters in a string to see if they are vaild path	*/
/* name characaters.																			*/
/*																									*/
/* int ValidDirChars( char *szPath )													*/
/*																									*/
/* ARGUMENTS:	szPath	-  Directory name string									*/
/* RETURN:		int		-	TRUE if chars in string are valid else FALSE		*/
/*																									*/
/***************************************************************************/

int ValidDirChars( char *szPath )
{
	int		IsOk = TRUE;

	while ( IsOk && *szPath != EOL )
#ifdef DBCS
	    if (IsDBCSLeadByte(*szPath))
		szPath += 2;
	    else
#endif
		IsOk = IsValidPathChar( *(szPath++) );

	return( IsOk );
}

/***************************************************************************/
/* Checks a file or path name against a list of reserved DOS filenames and	*/
/* returns TRUE if the name is a reserved name. The function must first		*/
/* off any extension from the name.														*/
/*																									*/
/*	int NotReservedName( char *szPath )													*/
/*																									*/
/* ARGUMENTS:	szPath	-  Directory name string									*/
/* RETURN:		int		-	TRUE if name is reserved DOS name					*/
/*																									*/
/***************************************************************************/

int IsReservedName( char *szPath )
{
	register			Status;
	register			i;
	char				*szTmp;
	static char		*apszRes[] = { "AUX", "CLOCK$", "COM1", "COM2",
											"COM3", "COM4", "CON", "LPT", "LPT1",
											"LPT2", "LPT3", "LST", "NUL", "PRN", NULL };

	if ( (szTmp = strchr( szPath, '.' )) != NULL )
		*szTmp = EOL;

	for ( i = 0, Status = FALSE; Status == FALSE && apszRes[i] != NULL; i++ )
		Status = !strcmpi( szPath, apszRes[i] );

	if ( szTmp != NULL )
		*szTmp = '.';

	return( Status );
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_bpb.c ===
/***************************************************************************/
/*																									*/
/* DSK_BPB.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* Array of default BPB structures for MS-DOS 4.x compatible floppy disk	*/
/*	drives.																						*/
/* 																								*/
/* Created 07-23-89 johnhe																	*/
/***************************************************************************/

#include		<disk_io.h>

														/* Array of valid BPB structures */
struct BPB DskBpb[] =
{
							/* 160K	- 40 tracks - 8 sectors per track - 1 head	*/
	{ 512, 1, 1, 2,  64, 1*8*40, 0xfe, 1,  8, 1, 0, 0L },

							/* 180K	- 40 tracks - 9 sectors per track - 1 head	*/
	{ 512, 1, 1, 2,  64, 1*9*40, 0xfc, 2,  9, 1, 0, 0L },

							/* 320K	- 40 tracks - 8 sectors per track - 2 heads	*/
	{ 512, 2, 1, 2, 112, 2*8*40, 0xff, 1,  8, 2, 0, 0L },

							/* 360K	- 40 tracks - 9 sectors per track - 2 heads	*/
	{ 512, 2, 1, 2, 112, 2*9*40, 0xfd, 2,  9, 2, 0, 0L },

							/* 720K	- 80 tracks - 09 sectors per track - 2 heads */
	{ 512, 2, 1, 2, 112, 2*9*80, 0xF9, 3,  9, 2, 0, 0L },

							/* 1.2M	- 80 tracks - 15 sectors per track - 2 heads	*/
	{ 512, 1, 1, 2, 224, 2*15*80, 0xF9, 7, 15, 2, 0, 0L },

							/* 1.44M - 80 tracks - 18 sectors per track - 2 heads	*/
	{ 512, 1, 1, 2, 224, 2*18*80, 0xF0, 9, 18, 2, 0, 0L }
};
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_free.c ===
/***************************************************************************/
/*																									*/
/*	DSK_FREE.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Returns the number of free bytes on the specified disk. Uses DOS get		*/
/* disk free call for information about the disk and then calculates the	*/
/* number of free bytes.																	*/
/*																									*/
/*	long GetDiskFree( int DrvLetter )													*/
/*																									*/
/* ARGUMENTS:	DrvLetter	- DOS drive letter										*/
/* RETURNS:		long			- Number of free bytes for the specified disk	*/
/*									  or -1L if there is an error reading the disk	*/
/*																									*/
/* Created 07-23-89 johnhe																	*/
/***************************************************************************/

#include 	<dos.h>

#include 	<alias.h>
#include 	<disk_io.h>

long GetDiskFree( int DrvLetter )
{
	struct diskfree_t 	sDrive;
	unsigned					iBytesPerClus;

	DrvLetter -= 0x40;
	if ( _dos_getdiskfree( (unsigned)DrvLetter, &sDrive ) != OK )
		return( -1L );

	iBytesPerClus = sDrive.bytes_per_sector * sDrive.sectors_per_cluster;

	return( (long)(sDrive.avail_clusters) * (long)(iBytesPerClus) );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_flab.c ===
/***************************************************************************/
/*																									*/
/*	DSK_SETL.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/*																									*/
/* Creates a volume label on the specified drive.									*/
/*																									*/
/*	UL SetDiskLabel( int iDrv, char *szLabel, struct *Bpb ) 						*/
/*						 																			*/
/*	ARGUMENTS:	iDrv		- Drive to read 												*/
/*					Bpb		- Ptr to Bpb struct for this disk						*/
/*					szLabel	- String to use for disk label							*/
/*	RETURNS:		UL			- Label creation time or -1L if disk write error	*/
/*																									*/
/*																									*/
/*	johnhe - 02-14-90																			*/
/***************************************************************************/

#include		<stdio.h>
#include		<stdlib.h>
#include		<bios.h>
#include		<dos.h>
#include		<string.h>

#include		<alias.h>
#include		<strlib.h>
#include		<disk_io.h>


#define		SECTOR_SIZE			512

/***************************************************************************/

UL FloppySetDiskLabel( int iDrv, char *szLabel, struct BPB *Bpb )
{
	char					*pchBuf;
	unsigned				uSec;
	UL						ulTime;
	struct DIR			*Dir;						/* Disk label DIR entry		*/

	ulTime =  (UL)(-1L);
	pchBuf = GetMemory( SECTOR_SIZE );		/* Allocate a sector and	*/
	memset( pchBuf, 0, SECTOR_SIZE );		/* then fill it with 0's	*/

	Dir = (struct DIR *)(pchBuf);
	Dir += 2;
	strcpy( Dir->Name, szLabel );		/* Set volume label name 			*/
	PadStr( Dir->Name, ' ', 11 );		/* Add ' ' chars to end of name	*/
	Dir->Attrib = 8;						/* Set attrib to volumne label	*/
	SetFileTimeDate( Dir );				/* Set the dir entry time & date */

 	*(pchBuf) = (char)0xe5;
	*(pchBuf + sizeof( struct DIR )) = (char)0xe5;

														/* Find sector offset of root	*/
	uSec = Bpb->uSecPerFat * Bpb->uchNumberFats;
	uSec += Bpb->uReservSec;

	if ( RdWrSectors( iDrv, uSec, 1, pchBuf, Bpb, WRITE ) == OK &&
		  FloppyWriteBoot( iDrv, Bpb, szLabel ) == OK )
	{
		_dos_dskreset();
												/* Convert time to long timedate */
		ulTime = (unsigned long) (*((unsigned*)(&Dir->Date)));
		ulTime <<= 16;
		ulTime += (unsigned long)(*((unsigned *)(&Dir->Time)));
	}

	FreeMemory( pchBuf );
	return( ulTime );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_head.c ===
/***************************************************************************/
/*																									*/
/*	DSK_HEAD.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Calculates the drive head which will access an absolute sector on			*/
/* a disk.																						*/
/* 																								*/
/* STRATAGEY: Head =																			*/
/* ((AbsSector % SectorPerTrack) * NumberOfHeads) / SectorsPerTrack			*/
/*																									*/
/*	int GetDiskHead( unsigned uSec, struct BPB *Bpb )								*/
/*																									*/
/* ARGUMENTS:	uSec		- Absolute disk sector										*/
/*					Bpb		- Ptr to BPB structure for disk being accessed.		*/
/* RETURNS:		int		- The drive head which corresponds to uSec			*/
/*																									*/
/* Created 07-23-89 johnhe																	*/
/***************************************************************************/

#include		<disk_io.h>

int GetDiskHead( unsigned uSec, struct BPB *Bpb )
{
	return( (int)((uSec % (Bpb->uSecPerTrack * Bpb->uNumberHeads)) /
			  Bpb->uSecPerTrack) );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_i24.c ===
/***************************************************************************/
/*																									*/
/*	DSK_I24.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* Interrupt 24h handler. Checks to see if the error is drive door open 	*/
/* or write protect error on a floppy disk and will prompt the user to		*/
/* remedy the problem and then return to DOS for a retry of the operation	*/
/* else will issue a fatal disk error and abort the program.					*/
/* 																								*/
/* Created 07-23-89 johnhe																	*/
/***************************************************************************/

#include		<stdlib.h>
#include 	<alias.h>
#include 	<disk_io.h>
#include 	<window.h>

/***************************************************************************/

void ProgramAbort( void );

/***************************************************************************/

#define		WRITE_PROTECT			0
#define		DRIVE_NOT_READY		2
#define		WRITE_FAULT				10

#define		IGNORE					0
#define		RETRY						1

/***************************************************************************/
																				/*lint -715 */

unsigned gbPathSearch                = FALSE;
unsigned gfCompressedDiskIsFull      = FALSE;
unsigned gfCompressedDiskCritSection = FALSE;
unsigned gfCompressedDiskInstall     = FALSE;

void interrupt cdecl far NewInt24 (unsigned es, unsigned ds,
			unsigned di, unsigned si, unsigned bp, unsigned sp,
			unsigned bx, unsigned dx, unsigned cx, unsigned ax )
{
	char		Disk;

	((void)es), ((void)ds),	((void)si),	((void)bp), ((void)sp);
	((void)bx), ((void)dx), ((void)bx), ((void)dx), ((void)cx);

	Disk = (char)('A' + (ax & 0xff));				/* Get the value of AL		*/

	ax &= 0xff00;											/* Clear al */
	ax |= RETRY;											/* Assume user will retry	*/
	di &= 0xff;												/* Mask off error code		*/

	if (di == WRITE_FAULT && gfCompressedDiskInstall)
	{
		/* The Stacker or SuperStor disk is full */
		gfCompressedDiskIsFull = TRUE;
		Int24Fail();
	}
	else if ( di == WRITE_PROTECT )
		WriteProtectPrompt( Disk );
#if 0
	else if ( di == DRIVE_NOT_READY )
		NotReadyPrompt( Disk );
#endif
	else
	{
		if ( gbPathSearch || Int24DiskError( Disk ) )
			Int24Fail();
	}
}																				/*lint +715 */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_ilnk.asm ===
;========================================================
COMMENT #

	DSK_ILNK.ASM

	Copyright (c) 1992 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Checks a DOS drive to see if it is an Interlnk drive

	int IsInterlnk( int Drive );

	ARGUMENTS: Drive - DOS drive number (0=A, 1=B, 2=C, ...)
	RETURNS:   int	- TRUE if drive is Interlnk; else FALSE

	================================================

	05/31/92 - created

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

FALSE	EQU 0
TRUE	EQU 1

; =======================================================

.CODE

; =======================================================

IsInterlnk PROC Drive:BYTE

	mov	AX,5600h
	xor	BX,BX
	mov	CX,BX
	mov	DX,0FFFFh
	int	2Fh
	cmp	AL,0FFh		; Interlnk Installed?
	jne	II10		;  No - jump.	

	mov	AX,5601h
	xor	BX,BX
	mov	CX,BX
	mov	BH,Drive
	mov	DX,0FFFFh
	int	2Fh
	cmp	AL,0FFh		; Interlnk drive?
	mov	AX,TRUE		;  Assume yes.
	je	IIX		;  Yes - jump.

II10:	mov	AX,FALSE	; Not Interlnk.

IIX:	ret

IsInterlnk ENDP


; ========================================================

END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_ishd.c ===
/***************************************************************************/
/*																									*/
/*	DSK_ISHD.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Determines if a disk is a valid hard disk. The requirements are that		*/
/* the drive letter is C: or greater, the drive exists, is a local drive,	*/
/* is not removeable and is not the MS-DOS RamDrive.								*/
/*																									*/
/*	int IsValidHardDrive( char chDrive )												*/
/*																									*/
/*	ARGUMENTS:	chDrive	- The drive letter of the drive to check				*/
/*	RETURNS:		int		- TRUE if a hard disk else FALSE							*/
/*																									*/
/* Created 09-01-90 johnhe																	*/
/***************************************************************************/

#include		<alias.h>
#include		<disk_io.h>

/***************************************************************************/

int IsValidHardDrive( char chDrive )
{
	int	iDrvNum;

	iDrvNum = (int)chDrive - ('A' - 1);

	if ( chDrive >= 'C' )
		if ( IsValidDrive( chDrive ) )
			if ( IsLocalDrive( iDrvNum ) )
				if ( !IsRemoveable( iDrvNum ) )
					if ( !IsRamDrive( chDrive ) )
						return( TRUE );
	return( FALSE );
}

// This is just like IsValidHardDrive, except that it makes sure the 
// drive is formatted also.
int IsReallyValidHardDrive( char chDrive )
{
#define SECTOR_SIZE    512

    char  *pchBuffer;
    
    if (!IsValidHardDrive(chDrive))
        return( FALSE );

    pchBuffer = GetMemory(SECTOR_SIZE);

    if (GetBootSector(chDrive, pchBuffer) == OK)
    {
       FreeMemory(pchBuffer);
       return( TRUE );
    }   

    FreeMemory(pchBuffer);
    return ( FALSE );   
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_isfm.c ===
/***************************************************************************/
/*																									*/
/*	DSK_ISFM.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Determines if the disk in the specified drive has been formatted by		*/
/* reading in the boot record and checking the BPB with all normal floppy	*/
/* disk BPB layouts. If there is an error reading the boot record or if		*/
/* the BPB is not valid returns FALSE else TRUE. If the disk is formmatted	*/
/* the Bpb struct specified by the argument Bpb will be filled in. Before	*/
/* this function is called to IsDiskReady should be done to be sure that	*/
/* there is a disk in the drive.															*/
/*																									*/
/*	int IsFormatted( int iDrv )															*/
/*																									*/
/* ARGUMENTS:	iDrv	- Physical drive number											*/
/*					Bpb	- Ptr to BPB struct to be filled in							*/
/*					pchBuffer - Ptr to work buffer at least SECTOR_SIZE 			*/
/* RETURNS:		int	- TRUE if disk is formatted else false						*/
/*																									*/
/* GLOBALS:		DskBpb - Array of valid BPB structures in NEWFMT.C				*/
/*																									*/
/* Created 07-23-89 johnhe																	*/
/***************************************************************************/

#include		<stdio.h>
#include 	<string.h>

#include 	<alias.h>
#include 	<disk_io.h>

int IsFormatted( int iDrv, struct BPB *Bpb, char *pchBuffer	)
{
	register				iStatus;			/* Return status 							*/
	register				i;					/* Loop counter							*/
	extern struct BPB DskBpb[];		/* Array of valid BPB structures		*/

	iStatus = FALSE;						/* Assume not formatted 				*/
												/* Try to read the boot record		*/
	if ( GetBootSector( iDrv, pchBuffer ) == OK )
	{
		memcpy( Bpb, pchBuffer + 11, sizeof(struct BPB) );	/* Get BPB */

										/* Loop for all valid disk types to see	*/
										/* if the BPB is valid							*/

		for ( i = 3; i < 7; i++ )
		{
			if ( memcmp( &(DskBpb[i]), Bpb, sizeof(struct BPB) - 6 ) == OK )
			{
				iStatus = TRUE;			/* Disk's BPB was valid				*/
				break;
			}
		}
	}
	return( iStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_ram.c ===
/***************************************************************************/
/*																									*/
/*	DSK_BOOT.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Checks to see if a disk is the MS-DOS Ramdrive by looking at the			*/
/* volume label to see has the ram drive signature.								*/
/*																									*/
/*	NOTE: This is not a very accurate test and will not be acurate if			*/
/*			someone uses the same label on a regular drive.							*/
/*																									*/
/*	ARGUMENTS:	chDrive	- The drive letter of the drive to check.				*/
/*	RETURNS:		int		- TRUE if a ramdisk vol label is found else FALSE	*/
/*																									*/
/* Created 09-01-90 johnhe																	*/
/***************************************************************************/

#include		<dos.h>
#include		<string.h>

#include		<alias.h>

/***************************************************************************/

int IsRamDrive( char chDrive )
{
	register				i;
	static char			*szPath = "X:\\*.*";
	static char			*RamDrv[] = { "MS-RAMDR.IVE",
											  "VDISK",
											  "RDV" };
	struct find_t		Info;

	*szPath = chDrive;

	if ( _dos_findfirst( szPath, _A_VOLID, &Info ) == OK )
	{
		for ( i = 0; i < (sizeof( RamDrv ) / sizeof( char * )); i++ )
		{
			if ( strnicmp( Info.name, RamDrv[i], strlen( RamDrv[i] ) ) == OK )
				return( TRUE );
		}
	}

	return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_labl.c ===
/***************************************************************************/
/*																									*/
/*	DSK_LABL.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/*	Reads a disk label directly from the root directory of a floppy disk and*/
/* returns the labels creation time and date in the form of a long and 		*/
/* copies the label to a caller supplied buffer.									*/
/*																									*/
/*	 UL GetDiskLabel( int iDrive, char *szLabel )									*/
/*																									*/
/*	ARGUMENTS:	iDrive	- Physical drive number where disk is located.		*/
/*					szLabe	- Ptr to a buffer to copy the label to.				*/
/*	RETURNS:		UL			- Label creation time or -1L if no label was found	*/
/*																									*/
/*	johnhe - 02-14-90																			*/
/***************************************************************************/

#include		<stdio.h>
#include		<stdlib.h>
#include		<bios.h>
#include		<dos.h>
#include		<string.h>

#include		<alias.h>
#include		<strlib.h>
#include		<disk_io.h>


#define		SECTOR_SIZE			512

/***************************************************************************/

UL GetDiskLabel( int iDrive, char *szLabel, struct BPB *Bpb )
{
	#define		FOUND_IT		1000					/* Signals found a label		*/
	#define		END_DIR		2000					/* Signals end of root dir		*/

	char			*Buf;									/* Sector buffer					*/
	unsigned		uLastSec;							/* Last sector of root dir		*/
	register		iStatus;								/* Current search status		*/
	register		i;										/* Loop indice	for entry scan	*/
	unsigned		uSec;									/* Current disk sector			*/
	struct DIR	*Dir;									/* Ptr to current dir entry	*/
	UL 			ulTime;								/* Label creation time/date	*/

	ulTime = 0L;										/* Assume no label found		*/
	*szLabel = EOL;									/* Create default label str	*/

	Buf = GetMemory( SECTOR_SIZE );

	uSec = Bpb->uSecPerFat * Bpb->uchNumberFats;/* Determine first and last	*/
	uSec += Bpb->uReservSec;							/* sector of the root dir		*/
	uLastSec = uSec + (Bpb->uRootEntries * sizeof( struct DIR )) /
							 Bpb->uBytesPerSec;

								 					/* Once for each sector in root dir	*/
	for ( iStatus = OK;
			uSec < uLastSec && iStatus == OK;
			uSec++ )
	{
		Dir = (struct DIR *)(Buf);
		if ( (iStatus = RdWrSectors( iDrive, uSec, 1, Buf, Bpb, READ )) == OK )
		{
										/* Scan through current dir sector for label	*/
			for ( i = 0;
					i < (SECTOR_SIZE / sizeof( struct DIR )) && iStatus == OK;
					i++, Dir++ )
			{
				if ( Dir->Name[0] == 0 )			/* Check for last entry	mark	*/
				{
					iStatus = END_DIR;				/* No more entries				*/
					break;
				}
				else if ( (Dir->Attrib & _A_VOLID) != 0 )	/* Chk for VOL id		*/
				{
					Dir->Name[11] = EOL;					/* Cnvrt VOL id to string	*/
					strcpy( szLabel, Dir->Name );		/* Copy to caller's buf		*/
					RemoveTrailing( szLabel, ' ' );	/* Clean up the string		*/

																/* Cnvrt time/date to long	*/
					ulTime = (UL) (*((unsigned*)(&Dir->Date)));
					ulTime <<= 16;
					ulTime += (UL)(*((unsigned *)(&Dir->Time)));

					iStatus = FOUND_IT;					/* Signal found it			*/
				}
			}
		}
		else
		{
			ulTime = (UL)(-1L);				/* Disk error while reading label	*/
			break;
		}
	}

	FreeMemory( Buf );
	return( ulTime );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_rdy.asm ===
;========================================================
COMMENT #

	DSK_RDY.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Returns TRUE if a disk is in the specified drive
	else returns FALSE. Uses BIOS int 13h to try to
	verify the first sector on the disk and then checks
	the return code if an error is detected and returns
	TRUE if error != 0x80 else returns FALSE if time out
	error is returned. If changeline is returned the
	verify is retried to avoid conflicts.

	int IsDiskReady( int Drive )

	ARGUMENTS:	Drive  - Physical drive number

	RETURNS:	int    - TRUE is disk is ready
				 else FALSE
	=================================================


	johnhe - 06/06/89

END COMMENT #
;========================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

;========================================================

.CODE

;========================================================

IsDiskReady PROC Drive:BYTE

	mov	AX,0401h	; Verify 1 disk sector function
	mov	CX,01		; Sector 1 track 0
	mov	DH,00		; Head 0
	mov	DL,Drive	; Caller specified drive number

	push	AX		; Do a disk reset before the
	xor	AX,AX		; sector verify to fix a bug in
	int	13h		; the EPSON ROM BIOS.
	pop	AX		; Restore AX

VerifySector:
	int	13h		; BIOS disk interrupt call
	jnc	IsReady		; No error so disk is ready

	cmp	AH,06		; See if changeline returned
	jne	CheckTimeOut	; Not changeline so check for timeout

	mov	AX,0401h	; Retry the call if changeline error
	int	13h		; BIOS disk interrupt call
	jnc	IsReady		; No error so disk is ready

CheckTimeOut:
	cmp	AH,80h		; See if timeout error
	jne	IsReady		; Not timeout so disk is inserted

NotReady:
	xor	AX,AX		; Single disk not ready
	jmp	SHORT ReadyExit	; Finished so jump to exit

IsReady:
	mov	AX,1		; Return TRUE

ReadyExit:
	ret
	
IsDiskReady ENDP

;========================================================

	END

;========================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_locl.asm ===
;========================================================
COMMENT #

	DSK_LOCL.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Checks a DOS drive to see if it is removeable

	int IsRemoveable( int Drive );

	ARGUMENTS: Drive - DOS drive number (0=default, 1=A, 2=B, ...)
	RETURNS:   int	- TRUE if disk is removeable else false

	================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

NET_MAP		EQU    1000000000000b ; Mask for net drive bits



DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
TEMPLEN 	EQU	DIRSTRLEN*2

CURDIR_LIST	STRUC
CURDIR_TEXT	DB	DIRSTRLEN DUP (?)   ; text of assignment and curdir
CURDIR_FLAGS	DW	?		; various flags
CURDIR_DEVPTR	DD	?		; local pointer to DPB or net device
CURDIR_ID	DW	2 dup (?)	; cluster of current dir (net ID)
CURDIR_USER_WORD DW	?
CURDIR_END	DW	?		; index to ".." backup limit - see above
CURDIR_TYPE	DB	?		; IFS drive (2=ifs, 4=netuse)
CURDIR_IFS_HDR	DD	?		; Ptr to File System Header
CURDIR_FSDA	DB	2 DUP (?)	; File System Dependent Data Area
CURDIR_LIST	ENDS

curdirLen	EQU	Size CURDIR_list	; Needed for screwed up
						; ASM87 which doesn't allow
						; Size directive as a macro
						; argument
CURDIR_netID	EQU	DWORD PTR CURDIR_ID


;**	Flag values for CURDIR_FLAGS

CURDIR_isnet	EQU	1000000000000000B
CURDIR_isifs	EQU	1000000000000000B
CURDIR_inuse	EQU	0100000000000000B
CURDIR_splice	EQU	0010000000000000B
CURDIR_local	EQU	0001000000000000B



SysInitVars STRUC
SYSI_DPB	    DD	    ?		; DPB chain
SYSI_SFT	    DD	    ?		; SFT chain
SYSI_CLOCK	    DD	    ?		; CLOCK device
SYSI_CON	    DD	    ?		; CON device
SYSI_MAXSEC	    DW	    ?		; maximum sector size
SYSI_BUF	    DD	    ?		; points to Hashinitvar
SYSI_CDS	    DD	    ?		; CDS list
SYSI_FCB	    DD	    ?		; FCB chain
SYSI_Keep	    DW	    ?		; keep count
SYSI_NUMIO	    DB	    ?		; Number of block devices
SYSI_NCDS	    DB	    ?		; number of CDS's
SYSI_DEV	    DD	    ?		; device list
SYSI_ATTR	    DW	    ?		; null device attribute word
SYSI_STRAT	    DW	    ?		; null device strategy entry point
SYSI_INTER	    DW	    ?		; null device interrupt entry point
SYSI_NAME	    DB	 8 DUP(?)	; null device name
SYSI_SPLICE	    DB	    0		; TRUE -> splicees being done
SYSI_IBMDOS_SIZE    DW	    ?		; DOS size in paragraphs
SYSI_IFS_DOSCALL@   DD	    ?		; IFS DOS service rountine entry
SYSI_IFS	    DD	    ?		; IFS header chain
SYSI_BUFFERS	    DW	    ?,0 	; BUFFERS= values (m,n)
SYSI_BOOT_DRIVE     DB	    ?		; boot drive A=1 B=2,..
SYSI_DWMOVE	    DB	    0		; 1 if 386 machine
SYSI_EXT_MEM	    DW	    0		; Extended memory size in KB.
SysInitVars ENDS

; =======================================================

.CODE

; =======================================================

IsRemoveable PROC Drive:BYTE

	xor	AX,AX			; First check to be sure the
	mov	AL,Drive		; drive is really local because
	push	AX			; net drives don't support the


	call_M	IsLocalDrive		; isremoveable ioctl so always


	add	SP,2			; return  non-removeable for
	or	AX,AX			; for net drives.
	jz	NotSupported		; NOTE: DOS 4.x hangs if 4408 is
					; called for a bogus drive

	mov	AX,4408h		; IOCTL is changeable? function
	mov	BL,Drive		; BL = drive number
	int	21h

	jc	NotSupported		; Error check
	and	AX,1			; Mask off low bit
	xor	AX,1			; Flip the bit
	jmp	SHORT IsRemoveableExit

NotSupported:
	mov	AX,0			; Can't tell so assume not removable

IsRemoveableExit:
	ret

IsRemoveable ENDP


;========================================================
COMMENT #

	Copyright (c) 1989 - Microsoft Corp.
	All rights reserved.


	=================================================
	Returns whether a drive is local or remote.

	int IsLocalDrive( int Drive );

	ARGUMENTS: Drive - DOS drive number (0=default, 1=A, 2=B, ...)
	RETURNS:   int	- TRUE if disk is local else FALSE


	================================================

	johnhe - 06/06/89

END COMMENT #

;========================================================

IsLocalDrive PROC USES ES, Drive:BYTE

	mov	AX,3000h
	int 	21h
	cmp	AL,04
	je	LookInCDS

	mov	AX,4409h		; IOCTL is redirected? function 
	mov	BL,Drive		; BL = drive number
	int	21h

	mov	AX,1			; Assume it is a local drive
	jc	IsLocalExit		; If not supported then can't be net

	test	DX,NET_MAP		; See if any funny bits are set
	jz	IsLocalExit		; No funny bits so must be local

	xor	AX,AX			; Signal not a local drive
	jmp	short IsLocalExit

LookInCDS:
	mov	AH,52h			; Get internal DOS DATA Segment
	int	21h			; ES:BX --> DOS interal varibles

	mov	CL,Drive		; First make sure that this drive
	dec	CL			; is not greater than last drive
					; If CL is zero it will fail the
	cmp	CL,ES:[BX].SYSI_NCDS	; compare by doing  unsigned cmp
	mov	AX,1
	ja	IsLocalExit

	les	BX,ES:[BX].SYSI_CDS	; ES:BX --> First CDS entry

	mov	AX,SIZE CURDIR_LIST	; Find offset of the entry indexed
	mul	CL			; by drive in CL
	add 	BX,AX			; ES:BX --> CDS entry for drive
	test	ES:[BX].CURDIR_FLAGS,CURDIR_isnet ; Test is net bit

	mov	AX,0			; Assume drive is not local
	jnz	IsLocalExit		; If true then jmp to exit
	inc	AX			; Else signal local drive
	
IsLocalExit:
	ret


IsLocalDrive ENDP


; ========================================================

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_rset.asm ===
;========================================================
COMMENT #

	DSK_RSET.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Instructs DOS to do a reset of all it's disk buffers.

	int	_dos_dskreset( void )

	RETURNS: void

	================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc
 	
; =======================================================

.DATA
	PUBLIC	DiskChange
DiskChange db	0

.CODE

; =======================================================

_dos_dskreset PROC

	mov	DiskChange,1
	mov	AH,0dh
	int	21h
	ret

_dos_dskreset ENDP

; =======================================================

	END

; =======================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_root.c ===
/***************************************************************************/
/*																									*/
/*	DSK_ROOT.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Creates an empty root directory on the specified drive using the			*/
/* specified BPB for the size and location.											*/
/*																									*/
/*	int CreatRoot( int iDrv, struct BPB *Bpb )										*/
/*																									*/
/*	ARGUMENTS:	iDrv	-	Physical drive number										*/
/*					Bpb	-	Bpb structure for disk in the drive						*/
/*	RETURNS:		int	-	OK if successful												*/
/* 																								*/
/* Created 07-23-89 johnhe																	*/
/***************************************************************************/

#include		<stdio.h>
#include 	<malloc.h>
#include 	<string.h>

#include		<alias.h>
#include 	<disk_io.h>

int CreatRootDir( int iDrv, struct BPB *Bpb )
{
	char			*pchBuf;					/* Buffer to hold 1 sector				*/
	int			iStatus;					/* Return value							*/
	unsigned		uThisSec;				/* Current dir sector being written	*/
	unsigned		uLastSec;				/* Last sector number in directory	*/

	pchBuf = GetMemory( Bpb->uBytesPerSec );	/* Allocate a sector			*/
	memset( pchBuf, 0, Bpb->uBytesPerSec );	/* Fill it with zeros		*/

												/* Find root dir starting sector		*/
	uThisSec = Bpb->uSecPerFat * Bpb->uchNumberFats;
	uThisSec += Bpb->uReservSec;

												/* Find last sector in the root 		*/
	uLastSec = (Bpb->uRootEntries * sizeof( struct DIR )) /
				  Bpb->uBytesPerSec;
	uLastSec += uThisSec;

							 					/* Once for each sector in root dir	*/
	for ( iStatus = OK;
			iStatus == OK && uThisSec < uLastSec;
			uThisSec++ )
		iStatus =  RdWrSectors( iDrv, uThisSec, 1, pchBuf,	 Bpb, WRITE );

	FreeMemory( pchBuf );
	return( iStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_scrb.c ===
/***************************************************************************/
/*																									*/
/*	DSK_SCRB.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Empties the FAT and root directory to make the disk look freshly			*/
/* formatted by zeroing all good clusters in all copies of the FAT and		*/
/* then zeroing out all entries in all root directory sectors.					*/
/*																									*/
/*	int ScrubFatRoot( int iDrv, struct BPB *Bpb )									*/
/*																									*/
/*	ARGUMENTS:	iDrv	-	Physical floppy drive number								*/
/*					Bpb	-	Ptr to Bpb struct for the disk being scrubbed		*/
/*	RETURNS:		int	-	OK if successfull else !OK									*/
/* 																								*/
/* Created 07-23-89 johnhe																	*/
/***************************************************************************/

#include		<stdio.h>
#include 	<bios.h>
#include 	<string.h>
#include 	<malloc.h>
#include		<dos.h>

#include		<alias.h>
#include 	<disk_io.h>


void *GetMemory( unsigned Bytes );
void free( void * );

int ScrubFatRoot( int iDrv, struct BPB *Bpb )
{
	unsigned char			*pchFat;					/* Buffer to read FAT into	*/
	register					Index;					/* Count of FATS written	*/
	register					iStatus;					/* Loop indice					*/
	unsigned					uSec;						/* Abs starting sector		*/

	pchFat = GetMemory( (Bpb->uSecPerFat * 512) + 100 );
														/* Read the first FAT		*/
	if ( (iStatus = RdWrSectors( iDrv, 1, Bpb->uSecPerFat, pchFat, Bpb,
										 READ )) == OK )
	{
														/* Zero all good clusters	*/
		ScrubFat( pchFat, Bpb->uTotalSectors / Bpb->uchSecPerClus );

														/* Write both FAT copies	*/
		for( uSec = 1, Index = 0; Index < 2 && iStatus == OK; Index++ )
		{
			iStatus = RdWrSectors( iDrv, uSec, Bpb->uSecPerFat, pchFat, Bpb,
											WRITE );
			uSec += Bpb->uSecPerFat;
		}
	}

	FreeMemory( pchFat );						/* Free the work buffer		*/

	if ( iStatus == OK )							/* Scrub the root dir 		*/
		iStatus = CreatRootDir( iDrv, Bpb );

	_dos_dskreset();								/* Force disk resets */

	return( iStatus == OK ? OK : BAD_MEDIA );
}

/***************************************************************************/
/*	Scrubs a 12 bit FAT by zeroing out all good clusters. Will not change	*/
/* the clusters marked bad.																*/
/*																									*/
/*	int ScrubFat( unsigned char *pchFat, unsigned Clusters )						*/
/*																									*/
/*	ARGUMENTS:	pchFat	-	Ptr to buffer holding the FAT							*/
/*					Clusters	-	Total number of clusters in the FAT					*/
/*	RETURNS:		void																			*/
/* 																								*/
/***************************************************************************/

void ScrubFat( unsigned char *pchFat, unsigned Clusters )
{
	register		i;								/* Loop counter				 */


	pchFat += 3;								/* Jmp over the 2 signature entries	*/

	for ( i = 2; i < Clusters; i += 2 )
	{
															/* Do even cluster			*/
		if ( *(unsigned *)(pchFat) != 0xff7 )
			*(unsigned *)(pchFat) &= 0xf000;
	
		pchFat++;										/* Incr to odd cluster		*/

		if ( *(unsigned *)(pchFat) != (0xff7 << 4) )
			*(unsigned *)(pchFat) &= 0x000f;

	 	pchFat += 2;									/* Incr to next even clust	*/
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_setl.c ===
/***************************************************************************/
/*																									*/
/*	DSK_SETL.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/*																									*/
/* Creates a volume label on the specified drive.									*/
/*																									*/
/*	UL SetDiskLabel( int iDrv, char *szLabel, struct *Bpb ) 						*/
/*						 																			*/
/*	ARGUMENTS:	iDrv		- Drive to read 												*/
/*					Bpb		- Ptr to Bpb struct for this disk						*/
/*					szLabel	- String to use for disk label							*/
/*	RETURNS:		UL			- Label creation time or -1L if disk write error	*/
/*																									*/
/*																									*/
/*	johnhe - 02-14-90																			*/
/***************************************************************************/

#include		<stdio.h>
#include		<stdlib.h>
#include		<bios.h>
#include		<dos.h>
#include		<string.h>

#include		<alias.h>
#include		<strlib.h>
#include		<disk_io.h>


#define		SECTOR_SIZE			512

/***************************************************************************/

UL SetDiskLabel( int iDrv, char *szLabel, struct BPB *Bpb )
{
	char					*pchBuf;
	unsigned				uSec;
	UL						ulTime;
	struct DIR			*Dir;						/* Disk label DIR entry		*/

	ulTime =  (UL)(-1L);
	pchBuf = GetMemory( SECTOR_SIZE );		/* Allocate a sector and	*/
	memset( pchBuf, 0, SECTOR_SIZE );		/* then fill it with 0's	*/

	Dir = (struct DIR *)(pchBuf);
	Dir += 2;
	strcpy( Dir->Name, szLabel );		/* Set volume label name 			*/
	PadStr( Dir->Name, ' ', 11 );		/* Add ' ' chars to end of name	*/
	Dir->Attrib = 8;						/* Set attrib to volumne label	*/
	SetFileTimeDate( Dir );				/* Set the dir entry time & date */

 	*(pchBuf) = (char)0xe5;
	*(pchBuf + sizeof( struct DIR )) = (char)0xe5;

														/* Find sector offset of root	*/
	uSec = Bpb->uSecPerFat * Bpb->uchNumberFats;
	uSec += Bpb->uReservSec;

	if ( RdWrSectors( iDrv, uSec, 1, pchBuf, Bpb, WRITE ) == OK &&
		  WriteBoot( iDrv, Bpb, szLabel ) == OK )
	{
		_dos_dskreset();
												/* Convert time to long timedate */
		ulTime = (unsigned long) (*((unsigned*)(&Dir->Date)));
		ulTime <<= 16;
		ulTime += (unsigned long)(*((unsigned *)(&Dir->Time)));
	}

	FreeMemory( pchBuf );
	return( ulTime );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_sect.c ===
/***************************************************************************/
/*																									*/
/*	DSK_SECT.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Reads or writes the specified number of sectors to a floppy disk			*/
/*	using interrupt 13h calls. 															*/
/*																									*/
/*	int RdWrSectors( int iDrv, unsigned uSec, unsigned uNumSec,					*/
/*						  char *puchBuf, struct BPB *Bpb, int RdWr )					*/
/*																									*/
/*	ARGUMENTS:	unsigned iDrv		Physical drive to write to						*/
/* 				unsigned uSec		Absolute starting sector to begin at		*/
/*					unsigned uNumSec	Number of sectors to write						*/
/*					int		iFmt		Disk type listed in first header				*/
/*					char 		*puchBuf	Ptr to buffer holding data to write			*/
/*					struct BPB *Bpb	BPB struct for disk in drive					*/
/*					int		RdWr		Specifies read (0) or write (1)				*/
/*																									*/
/*	RETURNS:		int					Error code or OK if successfull				*/
/* 																								*/
/* Created 07-23-89 johnhe																	*/
/***************************************************************************/

#include		<stdio.h>
#include 	<bios.h>
#include 	<malloc.h>
#include 	<string.h>
#include		<dos.h>

#include		<alias.h>
#include 	<disk_io.h>
#include 	<window.h>

#define		DSK_PARAMS_VECT		0x1e

int RdWrSectors( int iDrv, unsigned uSec, unsigned uNumSec, char *puchBuf,
					  struct BPB *Bpb, int RdWr )
{
	register					i;								/* Loop counter				*/
	register					iStatus;						/* Return status				*/
	struct diskinfo_t		DiskInfo;					/* _bios_disk struct			*/
	struct DSK_PARMS 		NewDskParms;
	struct DSK_PARMS far	*OrigDskParms;

						/* Set disk parameters in dasd to allow proper access		*/
	OrigDskParms = (void far *)_dos_getvect( DSK_PARAMS_VECT );

	/* memcpy( &NewDskParms, OrigDskParms, sizeof( struct DSK_PARMS ) ); */
	for ( i = 0; i < sizeof( struct DSK_PARMS ); i++ )
		*(((char *)(&NewDskParms)) + i) = *(((char far *)(OrigDskParms)) + i);

	NewDskParms.EOT = (UCHAR)Bpb->uSecPerTrack;
	_dos_setvect( DSK_PARAMS_VECT, (void far *)(&NewDskParms) );

	iStatus = OK;											/* This may change			*/
	DiskInfo.drive = iDrv;

													/* Read or write a track at a			*/
													/* time until all sectors are done	*/

	while( uNumSec > 0 && iStatus == OK )
	{
		DiskInfo.head = GetDiskHead( uSec, Bpb );
		DiskInfo.track = GetDiskTrack( uSec, Bpb );
		DiskInfo.sector = (uSec % Bpb->uSecPerTrack) + 1;
		DiskInfo.nsectors = Bpb->uSecPerTrack - (DiskInfo.sector - 1);

		if ( DiskInfo.nsectors > uNumSec )
			DiskInfo.nsectors = uNumSec;

		DiskInfo.buffer = (void far *)(puchBuf);	/* Point to start of buf	*/

													/* Loop until successfull or until	*/
													/* all retries are exhausted			*/

		for ( i = 0; i < MAX_RETRIES; i++ )
		{
			iStatus = _bios_disk( RdWr == READ ? 2 : 3, &DiskInfo );

			if ( (iStatus >>= 8) == OK )		/* Get status from high byte */
				break;
			else
			{
				switch( iStatus )
				{
					case	OK:
						continue;			/* Quick out if no errors */
					case	06:			 	/* Disk change */
						i = 0;
						break;
					case	DISK_TIME_OUT:
						NotReadyPrompt( (UCHAR)(iDrv + 'A') );
						i = 0;
						break;
					case 03:
						WriteProtectPrompt( (UCHAR)(iDrv + 'A') );
						break;
					default:
						break;
				}
							/* Must have been an error if it got here so do a reset */
			}

			_bios_disk( _DISK_RESET, &DiskInfo );
		}

		uNumSec -= DiskInfo.nsectors;				/* Sub sectors on last track	*/
		uSec += DiskInfo.nsectors;					/* Calc next sector to do		*/

															/* Point to next sector 		*/
		puchBuf += (UINT)DiskInfo.nsectors * Bpb->uBytesPerSec;
	}

	_dos_setvect( DSK_PARAMS_VECT, (void far *)OrigDskParms );
	return( iStatus );
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_tcnv.c ===
/***************************************************************************/
/*																									*/
/*	DSK_TCNV.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Converts the time and date returned by the a call to _dos_findfirst		*/
/* int a long value with the date in the most signifiant byte and the time	*/
/* in the least sig. bytes. This allows for simple and accurate file			*/
/* creation comparisions.																	*/
/*																									*/
/*	unsigned long ToLongTd( struct find_t *File )									*/
/*																									*/
/*	ARGUMENTS:	File		- Ptr to a filled in find_t structure					*/
/*	RETURNS:		long		- Date in most sig. byte and Time in least sig.		*/
/*																									*/
/* Created 07-23-89 johnhe																	*/
/***************************************************************************/

#include 	<disk_io.h>

unsigned long ToLongTd( struct DIR *Dir )
{
	unsigned long	Td;

	Td = (unsigned long)(*((unsigned *)(&Dir->Date)));
	Td <<= 16;
	Td += (unsigned long)(*((unsigned *)(&Dir->Time)));

	return( Td );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_time.c ===
/***************************************************************************/
/*																									*/
/*	DSK_TIME.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* void SetFileTimeDate( struct DIR *Dir )											*/
/* 																								*/
/* ARGUMENTS:	Dir	- Ptr to directory entry structure							*/
/* RETURNS: 	void																			*/
/*																									*/
/* Created 07-23-89 johnhe																	*/
/***************************************************************************/

#include 	<dos.h>
#include 	<disk_io.h>

void SetFileTimeDate( struct DIR *Dir )
{
	struct dostime_t	Time;
	struct dosdate_t	Date;

	_dos_gettime( &Time );
	_dos_getdate( &Date );

	Dir->Time.Hour = Time.hour;
	Dir->Time.Min = Time.minute;
	Dir->Time.tSec = Time.second / 2;

	Dir->Date.Day = Date.day;
	Dir->Date.Month = Date.month;
	Dir->Date.Year = Date.year - 1980;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_trk.c ===
/***************************************************************************/
/*																									*/
/*	DSK_TRK.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Caculates the track that an absolute sector is on.								*/
/* STRATAGEY:	Track =	AbsSector / ( NumberOfHeads * SectorsPerTrack )		*/
/*																									*/
/*	int GetDiskTrack( unsigned uSec, struct BPB *Bpb )								*/
/* 																								*/
/* ARGUMENTS:	uSec		- Absolute disk sector										*/
/*					Bpb		- Ptr to BPB structure for disk being accessed.		*/
/* RETURNS:		int		- The drive track which corresponds to uSec			*/
/* 																								*/
/* Created 07-23-89 johnhe																	*/
/***************************************************************************/

#include		<disk_io.h>


int GetDiskTrack( unsigned uSec, struct BPB *Bpb )
{

	return( (int)(uSec / ((unsigned)Bpb->uNumberHeads * Bpb->uSecPerTrack)) );

}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\fcb_open.asm ===
;========================================================
COMMENT #

	FCB_OPEN.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Does and FCB open using DOS int 21h function
	0xf.

	int FcbOpen( struct DOS_FCB *Fcb );

	ARGUMENTS: Fcb	- Ptr to FCB with name and drive
			  already initialized.
	RETURNS:   int	- 0 if OK else -1

	================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

FcbOpen PROC USES DS, Fcb:PTR 

;IF @datasize
;	lds	DX,Fcb
;ELSE
;	mov	DX,Fcb
;ENDIF
	LoadPtr	DS, DX, Fcb

	mov	AH,0fh
	int	21h

	mov	AH,0ffh		; If AL == 0ffh then we
	cmp	AL,AH		; have -1 in AX else clear
	je	@f		; AX to signal OK
	xor	AX,AX
@@:
	ret

FcbOpen ENDP

; =======================================================

END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\fcb_pars.asm ===
;========================================================
COMMENT #

	FCB_PARS.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Uses DOS FCB call 29h to parse a file name

	The following rules are observed based on the filename
	string argument. These are specifed by the bits in AL.
	when the int 21h is done.

	0. Ingores leading filename seperator
	1. Sets the drive number to 0 if not found in string
	2. Sets the filename to blanks if filename == ""
	3. Sets the file extension to blanks if not found

	int FcbParse( char *OldName, struct FCB *Fcb );

	ARGUMENTS:	OldName - Ptr to string to parse
			Fcb	- Ptr to FCB struct to store
				  parsed name and drive.
	RETURNS:	int	- 00 - No wild card characters
				  01 - Wild card characters used
				  -1 - Invalid drive or filename
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

IF @DataSize
  FcbParse PROC USES DS ES DI SI, FileName:PTR, Fcb:PTR
ELSE
  FcbParse PROC USES    ES DI SI, FileName:PTR, Fcb:PTR
ENDIF
	mov	AX,2901h
;	lds	SI,FileName		; Load ptr to string to parse
	LoadPtr	DS, SI, FileName	; DS:SI --> String to parse

;	les	DI,Fcb			; Load ptr to FCB
	LoadPtr	ES, DI, Fcb		; ES:DI --> FCB

	int	21h
	cbw				; Convert byte in AL to word in AX
	ret

FcbParse ENDP

; =======================================================

	END

; =======================================================

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_vald.asm ===
;========================================================
COMMENT #

	DSK_VALD.asm

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential


	=================================================
	Returns TRUE if specified drive is valid. Determines
	if a drive letter exists by making that drive the
	current drive and then getting the current drive
	to see if it really was changed. Restores the
	current drive to what it was on entry.

	int IsValidDrive( char Drive );

	ARGUMENTS: Drive - DOS drive letter (A,B,C,...,Z)
	RETURNS:   int	- TRUE if disk exists else FALSE


	================================================

	johnhe - 09/01/90

END COMMENT #
;========================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

;========================================================

COMMENT #
.DATA

Fcb	DOS_FCB	< 0, "NUL     " , "   ",,,,,,,, >

END COMMENT #

;========================================================

.CODE

COMMENT #
;========================================================

IsValidDrive PROC Drive:BYTE

	mov	AL,Drive	; AL == Drive letter
	sub	AL,('A'-1)	; Convert to drive number (1=A,2=B,3=C,...)
	mov	Fcb.FcbDrive,AL	; Put the drive number in the FCB

	mov	AH,0fh		; FCB open function
	mov	DX,OFFSET Fcb
	int	21h

	not	AL		; If error AL == 0ffh we now have 0
	xor	AH,AH		; 
	cmp	AL,AH		; See if AL is really 0
	je	@f		; Drive was invalid so return 0
	mov	AX,1		; else return TRUE
@@:
	ret

IsValidDrive ENDP

END COMMENT #
; ========================================================

IsValidDrive PROC Drive:BYTE

	mov	DL,Drive	; DL == Drive letter
	sub	DL,'A'		; Convert to drive number (1=A,2=B,3=C,...) 

	mov	AH,19h		; AH == Get current drive
	int	21h
	push	AX

	mov	AH,0eh		; Select drive in DL
	int	21h

	mov	AH,19h		; Get current drive
	int	21h

	cmp	AL,DL		; See if drive was changed
	mov	BX,0		; Assume it wasn't
	jne	@f
	inc	BX		; But it was, so drive is valid
@@:
	pop	DX		; Restore original current drive
	mov	AH,0eh
	int	21h

	mov	AX,BX
	ret

IsValidDrive ENDP

; ========================================================

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\fail24.asm ===
;========================================================
COMMENT #

	FAIL24.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	This function is can be called by an int 24h handler to
	simulate DOS failing the previous int 21h call. This
	function returns CPU control to the instruction following
	the last int 21h call. The registers are set exactly as
	they were when the int 21h was issued except the carry
	is set to signal an error and AL contains an error
	code to signal disk failure.

	void Int24Fail( void );

	ARGUMENTS:	NONE
	RETURN: 	void	- Does not return to caller
	=================================================

	johnhe - 10/01/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

Int24Fail PROC FAR		; Must be far to keep stack count correct

	add	SP,20h		; Adjust stack to point to int 21 regs

	pop	AX
	pop	BX
	pop	CX
	pop	DX
	pop	SI
	pop	DI
	pop	BP
	pop	DS
	pop	ES

	mov	AX,27
	stc

	retf	02

Int24Fail ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\dsk_type.c ===
/***************************************************************************/
/*																									*/
/*	DSK_TYPE.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Returns the type of diskette in the specied floppy drive.					*/
/*																									*/
/*	int GetDisketteType( int Drv )														*/
/*																									*/
/*	ARGUMENTS:	Drv		- Drive letter to check										*/
/* RETURNS:		int		- Type of diskette											*/
/*								  1 == 360K														*/
/*								  2 == 720K														*/
/*								  3 == 1.2M														*/
/*								  4 == 1.44M													*/
/***************************************************************************/

#include		<stdio.h>
#include		<dos.h>

int GetDisketteType( int Drv )
{
	static long				lSize[] = { 0, 370000L, 740000L, 1300000L };
	register 				i;
	struct diskfree_t		Drive;
	long						lBytes;

	if ( _dos_getdiskfree( (unsigned)Drv - 0x40, &Drive ) != 0 )
		return( 0 );
	lBytes = (long)Drive.total_clusters *
				(long)(Drive.bytes_per_sector * Drive.sectors_per_cluster);

	for ( i = 1; i < (sizeof( lSize  ) / sizeof( long )); i++ )
		if ( lBytes < lSize[ i ] )
			break;

	return( i );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\fcb_ren.asm ===
;========================================================
COMMENT #

	FCB_REN.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Uses DOS FCB call 17h to rename a file.

	int FcbRename( struct FCB *Fcb );

	ARGUMENTS:	Fcb	- Ptr to Special FCB structure of
				  the following form.

			BYTE(s) - CONTENTS
			0h	  - Drive number
			01h-08h - Old file name, padded with blanks
			09h-0bh - Old file ext., padded with blanks
			0ch-10h - All zeros
			11h-18h - New file name, padded with blanks
			19h-1bh - New file ext., padded with blanks
			1ch,24h - All zeros

	RETURNS:	int	- 0 if successfull else -1
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

IF @DataSize
  FcbRename PROC USES DS, FcbBuf:PTR
ELSE
  FcbRename PROC          FcbBuf:PTR
ENDIF

	mov	AH,17h
;	lds	DX,FcbBuf
	LoadPtr	DS, DX, FcbBuf		; DS:DX --> FCB 
	int	21h
	mov	AH,AL
	ret

FcbRename ENDP

; =======================================================

	END

; =======================================================

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\getnumhd.asm ===
;========================================================
COMMENT #

	GETNUMHD.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Returns the total number of hard disks installed
	in the system as reported by the ROM BIOS at
	boot time.

	int GetNumHardDisks( void )

	ARGUMENTS:	NONE
	RETURN: 	int	- Number of hard disks
				  installed
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

GetNumHardDisks PROC

	mov	AH,8			; AH = Get disk info function
	mov	dl,80h			; DL = First hard drive number

	int	13h			; Bios disk int
	mov	AX,0			; Assume no drives found

	jc	ReturnNumDisks		; Error check
	mov	AL,DL			; AL = Number of hard drives
ReturnNumDisks:
	cbw				; AX = number of hard drives
	ret

GetNumHardDisks ENDP

; =======================================================

	END

; =======================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\findboot.asm ===
;========================================================
COMMENT #

	FINDBOOT.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Returns the first harddisk drive letter. Determine
	which logical drive is the first hard disk drive
	letter by setting up a dummy int 13h handler and
	then doing an int 25h to read the first sector from
	each drive starting at C:. The first harddisk drive
	letter will be the first access which is to drive
	80h.


	int FindFirstHd( void );
	ARGUMENTS:	NONE
	RETURNS:	int	- First harddisk drive letter
				  or -1 if no harddisk drive
				  letter is found.
	=================================================

	johnhe - 10/28/90

END COMMENT #
; =======================================================


MAX_DOS_DRIVES	EQU	26

ABSIO_PACKET	STRUC

	StartSec	dd	?
	NumSecs		dw	?
	SecBuffer	dd	?

ABSIO_PACKET	ENDS

INCLUDE	model.inc

; =======================================================

.DATA

; =======================================================

DriveNum	db	(?)

; =======================================================

.CODE

; =======================================================

EXTRN		AbsReadWrite:PROC

OldInt13	DD	(?)

; =======================================================

FindFirstHd	PROC USES SI, Buffer:PTR
	LOCAL	Dsk[ SIZE ABSIO_PACKET ]:BYTE

	push	ES
	mov	AX,3513h		; Get old int 13h vector
	int	21h
	mov	WORD PTR CS:OldInt13,BX	   ; Save old offset value
	mov	WORD PTR CS:OldInt13[2],ES ; Save old segment value
	pop	ES

	push	DS
	mov	DX,OFFSET DummyInt13	; DS:DX --> Dummy int handler
	mov	AX,@CODE		; Set up new int 13h handler
	mov	DS,AX
	mov	AX,2513h
	int	21h
	pop	DS

SetupInt25_Struc:
	xor	AX,AX
	mov	WORD PTR Dsk.StartSec,AX	; Start sector == 0L
	mov	WORD PTR Dsk.StartSec[2],AX
	mov	Dsk.NumSecs,1			; Read 1 sector

	push	ES
;	les	AX,Buffer			; ES:BX --> read buffer
	LoadPtr	ES, AX, BUFFER			; ES:BX --> read buffer
	mov	WORD PTR Dsk.SecBuffer,AX	; Move the buffer address
	mov	WORD PTR Dsk.SecBuffer[2],ES	; into the structure.
	pop	ES

	mov	SI,2				; SI == drive to scan .. C:

ScanDrives:
	mov	DriveNum,0ffh		; Initialize drive value to -1
	xor	AX,AX
	push	AX			; Read/write value == READ

IF @DataSize
	push	SS			; Segment of disk structure
ENDIF
	lea	AX,Dsk			; Offset address of disk structure
	push	AX			; Push the offset
	push	SI			; Push drive to read
 	call	AbsReadWrite

IF @DataSize
	add	SP,8			; Adjust the stack for all pushes
ELSE
	add	SP,6
ENDIF

TestDriveNum:
	mov	AL,DriveNum
	cmp	AL,80h
	jne	TestForLastDrive

	mov	AX,SI			; Put drive number in AX for return
	add	AX,'A'			; Convert to asci drive letter
	jmp	SHORT RestoreInt13

TestForLastDrive:
	cbw
	cmp	AX,0ffffh
	je	RestoreInt13

SetNextDrive:
	inc	SI			; Set to next logical drive
	cmp	SI,MAX_DOS_DRIVES	; Have we scan all DOS drives?
	jb	ScanDrives		; If not keep looping
	mov	AX,0ffffh		; Didn't find drive 80h

RestoreInt13:
	push	AX
	push	DS			; Restore original int 13h handler

	lds	DX,CS:OldInt13		; DS:DX --> Original int 13h handler
	mov	AX,2513h		; Get old int 13h vector
	int	21h

	pop	DS
	pop	AX

	ret

FindFirstHd	ENDP

; =======================================================

DummyInt13:

	cmp	AH,02			; See if READ sectors function
	jne	TestForHd

	push	AX
	push	DS
	mov	AX,@DATA		; Set DS to address data segment
	mov	DS,AX
	mov	DriveNum,DL		; Save the drive number
	pop	DS
	pop	AX
	
TestForHd:
	test	DL,80h			; See if high bit set for hard drive
	jz	FloppyExit
	jmp	DWORD PTR CS:[OldInt13]

FloppyExit:
	xor	AX,AX			; Signal no errors
	clc				; Clear the carry for no error
	retf	02			; Far return and throw flags away


; =======================================================

END

; =======================================================


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\get_dir.asm ===
;========================================================
COMMENT #

	GET_DIR.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Gets the current directory path from DOS.

	int _dos_getdir( char *Buffer, int Drive );

	ARGUMENTS:	Buffer	- Ptr to 64 byte memory
				  area
			Drive	- DOS drive number (0=default, 1=A, 2=B, ...)
	RETURN: 	int	- 0 if successfull else
				  !0 if error
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

IF @DataSize
  _dos_getdir	PROC USES DS SI, Buffer:PTR, Drive:BYTE
ELSE
  _dos_getdir	PROC USES    SI, Buffer:PTR, Drive:BYTE
ENDIF

;	lds	SI,Buffer		; DS:SI -> buffer
	LoadPtr	DS, SI, Buffer		; DS:SI -> buffer

	mov	DL,Drive		; DL = disk drive (0=default,1=A)
	mov	AH,47h			; Get current dir function
	int	21h
	mov	AX,1			; Assume may may be errors
	jc	GetDirReturn		; Error check
	xor	AX,AX			; Signal no errors

GetDirReturn:
	ret

_dos_getdir ENDP

; =======================================================

	END

; =======================================================

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\get_boot.asm ===
;========================================================
COMMENT #

	GET_BOOT.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Reads the boot record on the first sector of the
	specified drive into the specified buffer

	int GetBootSector( int Drive, char *Buffer )

	ARGUMENTS:	Drive	- Physical drive number
			Buffer	- Ptr to sector size buffer

	RETURNS:	int	- OK (0) if successfull
				  else error code
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

GetBootSector PROC USES ES, Drive:BYTE, Buffer:PTR

	mov	DH,0		; Head 0
	mov	DL,Drive	; Get drive number

;	les	BX,Buffer	; Set ES:BX == ptr to buffer
	LoadPtr	ES, BX, Buffer	; ES:BX --> Caller's buffer

	mov	CX,5		; Retry count

ReadSector:
	push	CX		; Save retry count
	mov	AX,0201h	; Read 1 disk sector
	mov	CX,1		; Track 0 sector 1
	int	13h		; BIOS disk interrupt
	pop	CX		; Recover CX for possible retry

CheckStatus:
	jnc	GotSector	; No error so break loop
	xor	AX,AX		; Drive reset function
	int	13h		; Do a disk reset
	loop	ReadSector	; Now retry the operation
	mov	AX,-1		; Signal an error
	jmp	SHORT GetBootExit ; Return error in AX

GotSector:
	xor	AX,AX		; Return OK - no errors

GetBootExit:
	ret

GetBootSector ENDP

; =======================================================

	END

; =======================================================

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\int13rtr.asm ===
;========================================================
COMMENT #

	INT13RTR.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Does an int 13h and resets the disk and does a retry
	if the first operation fails with an error other than
	a timeout error returns all register in the condition
	returned by the int 13h call.

	Int13WithRetry PROC NEAR
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

.CODE


; =======================================================
; =======================================================

Int13WithRetry PROC NEAR

	push	CX			; Save needed registers
	push	DI
	push	SI

	mov	DI,AX			; Put function call in DI
	mov	SI,CX			; Put head and track in SI
	mov	CX,DISK_RETRIES		; Put number of retries in CX
	
DoInt13:
	push	CX			; Save loop counter
	mov	CX,SI			; Put head and track back in CX
	int	13h			; BIOS disk call
	pop	CX			; Restore the loop counter
	jc	IsItTimeOut		; If error then retry the operation
	jmp	SHORT FunctReturn	; Else we're finished

IsItTimeOut:
	cmp	AH,DISK_TIMEOUT		; See if this is a timeout error
	je	SetCarry		; If timeout don't retry
	cmp	CX,1			; See if retries are exhausted
	je	SetCarry		; If exhaust don't do reset

DiskReset:
	xor	AX,AX			; Set AX == 0 for retry call
	int	13h			; We can assume no timeout error
	mov	AX,DI			; Restore function call AX
	loop	DoInt13			; Exhuast all retries

SetCarry:
	stc				; Set the carry flag to show error

FunctReturn:
	pop	SI			; Restore the used registers
	pop	DI
	pop	CX
	ret

Int13WithRetry ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\newfmt.c ===
/***************************************************************************/
/*																									*/
/* NEWFMT.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* Modular Floppy disk format functions.												*/
/* 																								*/
/* This module is designed to format a floppy diskette under any version   */
/* of the MS-DOS (PC-DOS) operating system version 2.0 or greater on any	*/
/* IBM PC(AT) compatible. To accomplish this requirement will mean that		*/
/* the use of DOS function 44h to perform a format via an ioctl will not	*/
/* be allowed and all formating must be accomplished via the direct use		*/
/* of ROM BIOS interrupt 13h.																*/
/*																									*/
/* SUPPORTED FORMATS:																		*/
/* 																								*/
/* 5 1/4 INCH DRIVE - 40 TRACKS 2 HEADS - DOUBLE DENSITY							*/
/* -----------------------------------------------------  						*/
/* 360K  - 40 tracks - 09 sectors per track - 2 heads								*/
/* 320K  - 40 tracks - 08 sectors per track - 2 heads								*/
/* 180K  - 40 tracks - 09 sectors per track - 1 head								*/
/* 160K  - 40 tracks - 08 sectors per track - 1 head								*/
/*																									*/
/*																									*/
/* 5 1/4 INCH DRIVE - 80 TRACKS 2 HEADS - HIGH DENSITY							*/
/* ----------------------------------------------------- 						*/
/* 1.2M  - 80 tracks - 15 sectors per track - 2 heads								*/
/* 720K  - 80 tracks - 09 sectors per track - 2 heads								*/
/* 360K  - 40 tracks - 09 sectors per track - 2 heads								*/
/* 320K  - 40 tracks - 08 sectors per track - 2 heads								*/
/* 180K  - 40 tracks - 09 sectors per track - 1 head								*/
/* 160K  - 40 tracks - 08 sectors per track - 1 head								*/
/*																									*/
/*																									*/
/* 3 1/2 INCH DRIVE - 80 TRACKS 2 HEADS - DOUBLE DENSITY							*/
/* -----------------------------------------------------							*/
/* 720K  - 80 tracks - 09 sectors per track - 2 heads								*/
/* 360K  - 40 tracks - 09 sectors per track - 2 heads								*/
/* 320K  - 40 tracks - 08 sectors per track - 2 heads								*/
/*																									*/
/*																									*/
/* 3 1/2 INCH DRIVE - 80 TRACKS 2 HEADS - HIGH DENSITY							*/
/* -----------------------------------------------------							*/
/* 1.44M - 80 tracks - 18 sectors per track - 2 heads								*/
/* 720K  - 80 tracks - 09 sectors per track - 2 heads								*/
/* 360K  - 40 tracks - 09 sectors per track - 2 heads								*/
/* 320K  - 40 tracks - 08 sectors per track - 2 heads								*/
/*																									*/
/* Created 07-23-89 johnhe																	*/
/***************************************************************************/
#include		<stdio.h>
#include 	<dos.h>
#include 	<bios.h>
#include 	<string.h>
#include 	<malloc.h>

#include		<alias.h>
#include		<disk_io.h>
#include		<format.h>

extern void 			NotReadyPrompt( char Disk );
extern void 			WriteProtectPrompt( char Disk );


/***************************************************************************/
/* Global variables which define the various characteristics of the disks	*/
/* which will be formatted.  All of the variables execept DskBpb are			*/
/* static to this module. DskBpb is used by other modules to avoid having	*/
/* duplicate data.																			*/
/***************************************************************************/

extern struct BPB DskBpb[];

#if	0									/* Array was moved to libary file */
											/* Array of valid BPB structures */
struct BPB DskBpb[] =
{
				/* 160K  - 40 tracks - 8 sectors per track - 1 head	*/
	{ 512, 1, 1, 2,  64, 1*8*40, 0xfe, 1,  8, 1, 0, 0L },

				/* 180K  - 40 tracks - 9 sectors per track - 1 head	*/
	{ 512, 1, 1, 2,  64, 1*9*40, 0xfc, 2,  9, 1, 0, 0L },

				/* 320K  - 40 tracks - 8 sectors per track - 2 heads	*/
	{ 512, 2, 1, 2, 112, 2*8*40, 0xff, 1,  8, 2, 0, 0L },

				/* 360K  - 40 tracks - 9 sectors per track - 2 heads	*/
	{ 512, 2, 1, 2, 112, 2*9*40, 0xfd, 2,  9, 2, 0, 0L },

				/* 720K  - 80 tracks - 09 sectors per track - 2 heads */
	{ 512, 2, 1, 2, 112, 2*9*80, 0xF9, 3,  9, 2, 0, 0L },

				/* 1.2M  - 80 tracks - 15 sectors per track - 2 heads	*/
	{ 512, 1, 1, 2, 224, 2*15*80, 0xF9, 7, 15, 2, 0, 0L },

				/* 1.44M - 80 tracks - 18 sectors per track - 2 heads	*/
	{ 512, 1, 1, 2, 224, 2*18*80, 0xF0, 9, 18, 2, 0, 0L }
};

#endif

					/* Sector layout areas required by bios format functions.	*/

static char						*WorkBuffer;
static struct FIELD_LIST	*FldLst;

							/* Used by the SetDskParams function to choose the		*/
							/* format type for a BIOS int 13h function 17h			*/
							/* USE: uchDiskType[DriveType][FormatType]				*/
							/*lint -e570 */
static unsigned char uchDiskType[5][7] =
							{
								{ ERR, ERR, ERR, ERR, ERR, ERR, ERR },
								{   1,   1,   1,   1, ERR, ERR, ERR },
								{   2,   2,   2,   2,   2,   3, ERR },
								{   4,   4,   4,   4,   4,   4, ERR },
								{   4,   4,   4,   4,   4,   4,   4 }
							};
										/*lint +e570 */
										/* Format gap length for each type of drive	*/

static unsigned char	DskFmtGap[]	= { 0x00, 0x50, 0x54, 0x50, 0x6c };

static int			iFmt;			/* Format type for current diskette */
static unsigned	uDrv;			/* Physical drive number 0-7fh		*/

static unsigned	uHead;		/* Current disk head						*/
static unsigned	uTrack;		/* Current disk track					*/

static struct BPB			*Bpb;				/* Ptr to BPB for specified format */

		 		/* Total number of tracks for each disk size */
static unsigned char	auchTotalTracks[] = { 40, 40, 40, 40, 80, 80, 80 };

static struct DSK_PARMS		DskParms;	/* Disk parameters for format	*/

									/* Disk parmeters if funct 18h not supported */
static struct DSK_PARMS		LocalDskParms =
									{ 0xdf, 0x02, 0x25, 0x02, 0x09, 0x1b, 0xff,
									  0x50, 0xf6, 0x0f, 0x04, 0x00 };

static char *puchFat;						/* Pointer to a work buffer */

/***************************************************************************/
/*	Formats a floppy diskette using int 13h function calls. Caller must		*/
/*	specify the drive number of 0 - 7fh and disk layout via a disk type of	*/
/* 0 - 6 as reflected in the table below.												*/
/*																									*/
/* -------------------------------------------------------						*/
/*																									*/
/* 0 | 160K  - 40 tracks - 08 sectors per track - 1 head							*/
/* 1 | 180K  - 40 tracks - 09 sectors per track - 1 head							*/
/* 2 | 320K  - 40 tracks - 08 sectors per track - 2 heads						*/
/* 3 | 360K  - 40 tracks - 09 sectors per track - 2 heads						*/
/* 4 | 720K  - 80 tracks - 09 sectors per track - 2 heads						*/
/* 5 | 1.2M  - 80 tracks - 15 sectors per track - 2 heads						*/
/* 6 | 1.44M - 80 tracks - 18 sectors per track - 2 heads						*/
/*																									*/
/* -------------------------------------------------------						*/
/*																									*/
/*																									*/
/* int FormatFloppy( unsigned uDrv, int iFmt, void (*vStatus)( int, int ))*/
/*																									*/
/* ARGUMENTS:	uDrv		Physical drive letter to format the disk on			*/
/*								which must be a floppy drive.								*/
/*					iFmt		Layout of the disk from the table above.				*/
/*					vStatus  Pointer to a function which will be called for		*/
/*								each time a track is formatted with the arguments	*/
/*								specifing the current track and head.					*/
/*																									*/
/* RETURNS:		A valid error code or OK (0) if format was successfull.		*/
/*					The error code are the same as those returned by an iotcl	*/
/*					format.																		*/
/* 																								*/
/*	GLOBALS:		uDrv			-  Sets this value to the physical drive #		*/
/*					Bpb			-	Sets this value to the BPB for specifed fmt	*/
/* 																								*/
/*																									*/
/***************************************************************************/

int FormatFloppy( unsigned uDrive, int iFormat, void (*vStatus)( UINT, UINT ) )
{
	register			iMaxTrack;		/* Number of tracks on selected media	*/
	register			iMaxHead;		/* Number of heads on selected media	*/
	void far			*OrigDskParms;	/* Original vector at 0x1e					*/
	int				iStatus;			/* Current error status						*/

	if ( iFormat > MAX_FORMAT_TYPE )
		return( -1 );

	uDrv = uDrive;						/* Set global drive number					*/
	iFmt = iFormat;					/* Set global format indexer				*/

	Bpb = &(DskBpb[iFmt]);			/* Set pointer to bpb for formt type	*/
	OrigDskParms = _dos_getvect( DSK_PARAMS_VECT ); 	/* Save vect 1eh	*/
	AllocFat();							/* Allocate a work buffer					*/

	if ( (iStatus = SetDskParms()) == OK )
	{
						/* Initialize register variables used as loop counters */
		iMaxTrack = (int)(auchTotalTracks[iFmt]);
		iMaxHead = (int)Bpb->uNumberHeads;

		if ( vStatus != NULL )
			(*vStatus)( (UINT)iMaxTrack, 0xffff	); /* Initialize status function */

							/* Outer loop once for each track on the disk and	*/
							/* inner loop once for each head on drive 			*/

		for ( uTrack = 0; iStatus == OK && uTrack < (UINT)iMaxTrack; uTrack++ )
			for ( uHead = 0; iStatus == OK && uHead < (UINT)iMaxHead; uHead++ )
			{
				if ( vStatus != NULL )
					(*vStatus)( uTrack, uHead );	/* Status update function */
				if ( (iStatus = FmtTrack()) != OK )
					iStatus = MarkBadTrack();
			}
		if ( iStatus == OK )
			if ( (iStatus = WriteBoot( (int)uDrive, Bpb, NULL )) == OK )
				if ( (iStatus = WriteFat()) == OK )
					iStatus = CreatRootDir( (int)uDrive, Bpb );
	}
	else
		iStatus = IVALID_DRIVE_TYPE;

	FreeMemory( puchFat );
	FreeMemory( WorkBuffer );

	_dos_setvect( DSK_PARAMS_VECT, OrigDskParms ); 	/* Restore vect 1eh */

	if ( vStatus != NULL )
		(*vStatus)( 0xffff, 0 );			/* De-initalize status function */
	return( iStatus );
}

/***************************************************************************/
/* Formats a track on a floppy disk using BIOS int 13h calls. Must first	*/
/* set the fields of the tracklayout and then does a format track call.		*/
/* The formatted track is checked with a call to verify the entire track	*/
/* can be read. If the verify fails a call is done to reset the disk and	*/
/* the format is done again or until a successful verify or until all		*/
/* retries specified in MAX_RETRIES have been exhausted.							*/
/*																									*/
/*	int FmtTrack( void )																		*/
/*																									*/
/* ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/* GLOBALS:		DskParms	-	Must be pointed to by int vector 1eh on entry	*/
/*					Bpb		-	Must point to a BPB for disk being formatted		*/
/*					uTrack	-	Must contain current head being formatted			*/
/*					uHead		-	Must conatain current track being formatted		*/
/*																									*/
/***************************************************************************/

int FmtTrack( void )
{
	register					iRetry;			/* Current number of retries done	*/
	register					iStatus;			/* Return status value					*/
	struct diskinfo_t		DiskInfo;		/* Structure for int 13h calling		*/

	InitialFmtFlds();							/* Put track and heads in fields		*/

	DiskInfo.drive = uDrv;					/* Set up for bios int 13h call		*/
	DiskInfo.head = uHead;
	DiskInfo.track = uTrack;
	DiskInfo.sector = 1;
	DiskInfo.buffer = (void far *)(FldLst);

													/* Loop until the track is 			*/
													/* successfully formatted or all		*/
													/* retries have been exhausted		*/

	for ( iStatus = ERR, iRetry = 0;
			iStatus != OK && iRetry < MAX_RETRIES;
			iRetry++ )
	{
		DiskInfo.nsectors = Bpb->uSecPerTrack;

		if ( (iStatus = (_bios_disk( _DISK_FORMAT, &DiskInfo ) >> 8)) == OK )
		{
			DiskInfo.nsectors = Bpb->uSecPerTrack;
			iStatus = (_bios_disk( _DISK_VERIFY, &DiskInfo ) >> 8);
		}

		switch( iStatus )
		{
			case	OK:
				continue;			/* Quick out if no errors */
			case	06:			 	/* Disk change */
				iRetry = 0;
				break;
			case	DISK_TIME_OUT:
				NotReadyPrompt( (char)(uDrv + 'A') );
				iRetry = 0;
				break;
			case 03:
				WriteProtectPrompt( (char)(uDrv + 'A') );
				break;
			default:
				if ( iFmt == 6 && DskParms.FmtGap == 0x6c )
				{
					DskParms.FmtGap = 0x65;			/* Fix for 1.44 meg drives */
					iRetry = 0;							/* Allow max retries again */
				}
				break;
		}

					/* Must have been an error if it got here so do a reset */
		_bios_disk( _DISK_RESET, &DiskInfo );

	}
	return( iStatus );
}

/***************************************************************************/
/* Initializes the format lay fields required by the ROM BIOS format	track	*/
/* function. Each structure is the field is initialized to the current		*/
/* track and head being formatted. The uchSector and uchSize fields are		*/
/* static since we always assume 512 byte sectors and contigous sector		*/
/* numbers from 1 to n.																		*/
/*																									*/
/*	void	InitialFmtFlds( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/* RETURNS:		void																			*/
/*																									*/
/*	GLOBALS:		FldLst	- Changes the uchTrack and uchHead fields 			*/
/*					uTrack	- Must contain current head being formatted			*/
/*					uHead		- Must conatain current track being formatted		*/
/*					Bpb		- Must point to a BPB for disk being formatted		*/
/*																									*/
/***************************************************************************/

void	InitialFmtFlds( void )
{
	register		iSector;			/* Loop counter for each disk sector		*/

										/* Loop once for each sector on the track */
	for ( iSector = 0; iSector < (int)(0x24); iSector++ )
	{
		FldLst[iSector].uchTrack = (UCHAR)(uTrack);		/* Set track	*/
		FldLst[iSector].uchHead = (UCHAR)(uHead);			/* set head		*/
		FldLst[iSector].uchSector = (UCHAR)(iSector + 1);	/* Set sector	*/
		FldLst[iSector].uchSize = 2;							/* Set 512 bytes	*/
	}
}

/***************************************************************************/
/* Allocates a buffer large enough to hold one entire FAT copy as				*/
/* specified in the BPB for the current disk. Also allocates a work buffer	*/
/* to use for the track layout.															*/
/*																									*/
/*	void AllocFat( void )																	*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/* RETURN:		void																			*/
/*																									*/
/***************************************************************************/

void AllocFat( void )
{
	register		iFatSize;				/* Calculated size of FAT */

	iFatSize = (int)(Bpb->uBytesPerSec * Bpb->uSecPerFat);

	puchFat = GetMemory( (UINT)iFatSize );
	memset( puchFat, 0, (UINT)iFatSize );
	*(puchFat) = (UCHAR)Bpb->uchMediaDescr;
	*(puchFat+1) = (UCHAR)0xff;
	*(puchFat+2) = (UCHAR)0xff;

					/* Because of a bug in the PC BIOS we have to make		*/
					/* sure that the FldLst is not within 512 bytes of		*/
					/* a DMA boundary so allocate 2 * 512 bytes and use	*/
					/* the second 512 bytes of the buffer if the first 	*/
					/* is within 512 bytes of the DMA boundary.				*/

	WorkBuffer = GetMemory( 1024 );
	FldLst = (struct FIELD_LIST *) ( CheckDmaBound( WorkBuffer, 512 ) == OK ?
												WorkBuffer : WorkBuffer + 512 );
}

/***************************************************************************/
/* Marks a track as bad in the FAT in puchBuf. If any of the sectors are	*/
/* in clusters started on a previous track the joining cluster on the		*/
/* previous track is also marked bad. If the track that is bad contains		*/
/* clusters that are in the Boot, FAT or root directory area the disk is	*/
/* not use-able and BAD_DISK_ERROR will be returned.								*/
/*																									*/
/*	int MarkBadTrack( void )																*/
/*																									*/
/*	RETURNS:		int		- OK if no system clusters bad else BAD_DISK_ERROR	*/
/*																									*/
/*	GLOBALS:		uTrack	- Must contain current head being formatted			*/
/*					uHead		- Must conatain current track being formatted		*/
/*					Bpb		- Must point to a BPB for disk being formatted		*/
/*																									*/
/***************************************************************************/

int MarkBadTrack( void )
{
	register				fOddCluster;		/* Flags if even or odd offset	*/
	register				iSector;				/* Current sector	on a track		*/
	int					iCluster;			/* Current cluster number			*/
	int					iStatus;				/* Return status						*/
	unsigned char		*puchEntry;			/* Pointer to a FAT entry			*/

	puchEntry = puchFat;

								/* Find absolute starting sector of the bad track */

	iSector = Bpb->uSecPerTrack * uTrack * Bpb->uNumberHeads;
	iSector += (uHead * Bpb->uSecPerTrack);

	iSector -= GetSysSec();					 /* Subtract system sectors */

	if ( iSector >= 0  )						/* If not a system sector	*/
	{
		iCluster = iSector / Bpb->uchSecPerClus; /* Sector to cluster */
		iCluster += 2;						/* Add # of clusters for FAT signature */

		iCluster *= 3;							/* Div by 1 1/2 ( n*3 / 2 ) */
		fOddCluster = ( iCluster & 1 );	/* Save remainder of divide by 2 */
		iCluster >>= 1;						/* Divide by 2 */

		puchEntry += iCluster;				/* Add cluster number */

		for ( iSector = 0;
			   iSector < Bpb->uSecPerTrack;
		   	iSector += Bpb->uchSecPerClus )
		{
			if ( fOddCluster )					/* If this is an odd offset */
			{
				*(unsigned *)(puchEntry) |= (0xff7 << 4);
			 	puchEntry += 2;					/* Point to next FAT entry */
			}
			else										/* Else it's an even offset */
			{
				*(unsigned *)(puchEntry) |= 0xff7;
				puchEntry += 1;
			}
			fOddCluster ^= 1;						/* Toggle remainder bit */

		}
		iStatus = OK;								/* Disk is useable */
	}
	else
		iStatus = BAD_DISK_ERROR;				/* Disk is not useable	*/

	return( iStatus );
}

#if 0

/************************************************************************/
/* Copies the BPB structure for the current disk to a boot record and	*/
/* then writes the boot record to the disk.										*/
/*																								*/
/*	int WriteBoot( void )																*/
/*																								*/
/*	ARGUMENTS:	NONE																		*/
/*	RETURNS:		int		- OK or BIOS int 13h disk error						*/
/*																								*/
/*	GLOBALS:		Bpb			-	Must point to BPB struct for current disk	*/
/*					NewBootRec	-	Must point to buffer holding the boot rec	*/
/*																								*/
/************************************************************************/

int WriteBoot( void )
{
	extern char		NewBootRec;			/* 512 byte boot sector	*/

	memcpy( (&NewBootRec) + 11, Bpb, sizeof( struct BPB ) );

	return( WriteSectors( 0, 1, &NewBootRec ) );
}

#endif


/************************************************************************/
/* Writes the contents of puchFat to both FATs on a floppy disk.			*/
/*																								*/
/*	int WriteFat( void )																	*/
/*																								*/
/*	ARGUMENTS:	NONE																		*/
/*	RETURNS:		int	-	OK or BIOS int 13 write sector error code			*/
/*																								*/
/*	GLOBALS:		Bpb		-	Must point to BPB struct for current disk		*/
/*					puchFat	-	Must point to a a buffer with the new FAT		*/
/*																								*/
/************************************************************************/
int WriteFat( void )
{
	register		iCount;						/* Count of FATS written			*/
	register		iStatus;						/* Current ERROR status				*/
	unsigned		uSec;							/* Starting sector for the FAT	*/

	iStatus = OK;								/* This may change */

	for( uSec = 1, iCount = 0; iCount < 2 && iStatus == OK; iCount++ )
	{
		iStatus = WriteSectors( uSec, Bpb->uSecPerFat, puchFat );
		uSec += Bpb->uSecPerFat;
	}
	return( iStatus );
}

/************************************************************************/
/* Calculates the drive head which will access an absolute sector on		*/
/* a disk.																					*/
/* 																							*/
/* STRATAGEY: Head =																		*/
/* ((AbsSector % SectorPerTrack) * NumberOfHeads) / SectorsPerTrack		*/
/*																								*/
/*	unsigned DiskHead( unsigned uSec )												*/
/*																								*/
/* ARGUMENTS:	uSec		-  Absolute disk sector									*/
/* RETURNS:		unsigned	-	Head that will access the specified sector	*/
/*																								*/
/************************************************************************/

unsigned DiskHead( unsigned uSec )
{
	return( (uSec % Bpb->uSecPerTrack * Bpb->uNumberHeads)) /
			  Bpb->uSecPerTrack;
}


/************************************************************************/
/*	Calculates the total number of sectors on a disk used by the Boot		*/
/* record, all copies of the FAT and the root directory.	Uses the			*/
/* static global Bpb make the determination.										*/
/*																								*/
/*	int GetSysSec( void )																*/
/*																								*/
/* ARGUMENTS:	NONE																		*/
/*	RETURNS:		int	- Total number of system sectors							*/
/*																								*/
/************************************************************************/

int GetSysSec( void )
{
	register		iFatSec;						/* Total disk FAT sectors		*/
	register		iRootSec;					/* Total sectors in root dir	*/

	iFatSec = Bpb->uchNumberFats * Bpb->uSecPerFat;
	iRootSec = Bpb->uRootEntries * sizeof( struct DIR );
	iRootSec /=	Bpb->uBytesPerSec;

	return( Bpb->uReservSec + iRootSec + iFatSec );
}

/************************************************************************/
/* Sets up the disk parmeters at vector 1eh for the type of disk being	*/
/* formatted. First get the drive type and attempts to get a DSAD from	*/
/* the ROM BIOS. If this fails we have to use our own DASD and set the	*/
/* Format Gap Length and the Max Sector fields to match the specified	*/
/* format and then do an int 13h funct 17h to attempt to set if for old	*/
/* IBM AT ROMs (there is no error checking on this call because old PCs	*/
/* and XTs don't support it and it won't make any difference if it		*/
/* fails. Which ever DASD is used is then copied to a local buffer and	*/
/* vector 1eh is pointed to the local buffer.									*/
/*																								*/
/*	int SetDskParms( void )																*/
/*																								*/
/*	ARGUMENTS:	NONE																		*/
/* RETURNS:		int	- OK if a valid format for the type of drive is 	*/
/*							  specified else INVALID_DRIVE_TYPE						*/
/*																								*/
/* GLOBALS:		DskParms - Initializes the structure to current format	*/
/*																								*/
/************************************************************************/

int SetDskParms( void )
{
	register						i;						/* Loop counter				*/
	register						iStatus;				/* Return error status		*/
	int							iDrvType;			/* BIOS drive type			*/
	struct DSK_PARMS far		*TmpParms;			/* Ptr to selected DASD		*/
	char 							*IoctlBuf;			/* Tmp work buffer 			*/

	iStatus  = OK;										/* Will change if errors	*/
	IoctlBuf = GetMemory( 100 );					/* Allocate work buffer		*/
	iDrvType = GetDriveType( (UCHAR)uDrv, IoctlBuf ); /* Determine drive type */

									/* If ROM BIOS supports int 13h funct 18h */
									/* we use the ROM supplied disk parmeters */

	if ( (TmpParms = SetMediaType( uDrv, (UINT)auchTotalTracks[iFmt],
							Bpb->uSecPerTrack )) == NULL )
	{
									/* Else set format type with funct 17h	*/
									/* and setup our own dsk params table	*/

		if ( uchDiskType[iDrvType][iFmt] != ERR )
		{
			SetDiskType( uDrv, uchDiskType[iDrvType][iFmt] );

			LocalDskParms.FmtGap = DskFmtGap[iDrvType];	/* Format gap length	*/
			LocalDskParms.EOT = (UCHAR)Bpb->uSecPerTrack;/* Sectors per track */
			TmpParms = (struct DSK_PARMS far *)(&LocalDskParms);
		}
		else
			iStatus = IVALID_DRIVE_TYPE; 	/* Not valid format for drive type	*/

	}

	if ( iStatus == OK )
	{
						/* Copy the dsk params to the local buffer and then	*/
						/* set int vector 1eh to point to local buffer. Use	*/
						/* a copy loop because this may be small memory model	*/

		for ( i = 0; i < sizeof( struct DSK_PARMS ); i++ )
			*((char far *)(&DskParms) + i)  =
			*((char far *)(TmpParms) + i ); 

		_dos_setvect( DSK_PARAMS_VECT, (void far *)(&DskParms) );
	}
	
	FreeMemory( IoctlBuf );
	return( iStatus );
}

/************************************************************************/
/*	Calls RdWrSectors() to write the specified number of sectors to a		*/
/* disk.																						*/
/*																								*/
/*	ARGUMENTS:	uStartSec	-	Sector on disk where write is to start		*/
/*					uNumSecs		-	Number of sectors to write						*/
/*					pchBuf		-	Ptr to buffer to be written					*/
/*	RETURNS:		int			-	OK if success or error code if error		*/
/*																								*/
/*	GLOBALS:		uDrv			-  Uses this value for the physical drive #	*/
/*					Bpb			-	Must contain the BPB for drive uDrv			*/
/*																								*/
/************************************************************************/

int WriteSectors( unsigned uStartSec, unsigned uNumSecs, char *pchBuf )
{

	return( RdWrSectors( uDrv, uStartSec, uNumSecs, pchBuf, Bpb, WRITE ) );

}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\rw_boot.c ===
/***************************************************************************/
/*																									*/
/*	RW_BOOT.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Uses int 25h&26h to read or write the boot record for the specified		*/
/* drive.																						*/
/*																									*/
/*	int ReadWriteBoot( int iDosDrv, void *Buffer, int ReadWrite )				*/
/*																									*/
/*	ARGUMENTS:	iDosDrv	- DOS drive number to get boot record from			*/
/*					Buffer	- Ptr to buffer to hold the boot record				*/
/*	RETURNS:		int		- OK if successful else a DOS error code for			*/
/*																									*/
/*	johnhe - 02-14-90																			*/
/***************************************************************************/

#include		<alias.h>
#include		<disk_io.h>

int ReadWriteBoot( int iDosDrv, void *Buffer, int ReadWrite )
{
	struct ABSIO_PACKET	absPack;

	absPack.lStartSector = 0L;
	absPack.uNumSectors = 1;
	absPack.pchBuffer = (char far *)Buffer;

	return( AbsReadWrite( iDosDrv, &absPack, ReadWrite ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\maxsec.c ===
/***************************************************************************/
/*																									*/
/*	MAXSEC.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/*	Returns the max number of bytes for any hard disk partition in a system	*/
/*	by starting at drive C: and then checking every drive until a remote or	*/
/* remove-able disk is detected.															*/
/*																									*/
/*	unsigned GetMaxSectorSize( void )													*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		unsigned	- Max bytes per sector of all hard disk partitions	*/
/*								  0 if insuffient memory for int 25h read buffer.	*/
/*																									*/
/* Created 12-11-90 johnhe																	*/
/***************************************************************************/


#include		<stdio.h>
#include		<malloc.h>
#include		<disk_io.h>

#define		SECTOR_SIZE		512

unsigned GetMaxSectorSize( void )
{
	unsigned						MaxSize;
	unsigned						TmpSize;
	unsigned char				Drv;
	struct ABSIO_PACKET		absPack;

											/* Allocate a buffer to for int 25h reads	*/
	if ( (absPack.pchBuffer = halloc( 0xffffL, 1 )) == NULL )
		return( 0 );					/* Not enough memory so return 0 size		*/

	absPack.lStartSector = 0L;					/* Setup packet for read of 1st	*/
	absPack.uNumSectors = 1;					/* disk sector.						*/
	MaxSize = SECTOR_SIZE;						/* Set default size to 512 bytes	*/

	for ( Drv = 3;
			(Drv < 26) && (IsValidDrive( Drv + 0x40 ) && IsLocalDrive( Drv ));
			Drv++ )
	{
			if ( !IsRemoveable( Drv ) )
				if ( AbsReadWrite( (Drv - 1), &absPack, READ ) == 0 )
					if ( (TmpSize = GetSectorSize( Drv )) > MaxSize )
						MaxSize = TmpSize;
	}

	hfree( absPack.pchBuffer );
	return( MaxSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\numdrvs.asm ===
;========================================================
COMMENT #

	NUMDRVS.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Uses function 8h of int 13h or if this is not
	available, int 11h to return the total number of
	floppy drives in the system.

	int	GetNumberOfDrives( void );

	ARGUMENTS:	NONE
	RETURN: 	int	- Number of drives installed

	NOTE:	10/26/90
		Must save DS because of bug in Leading
                Edge 8088 3.10 BIOS.

	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

GetNumberOfDrives PROC

	mov	AH,8
	xor	DX,DX

	push	BP			; Bug in leading Edge requires
	push	DI			; saving all of these registers
	push	SI
	push	DS
	push	ES	

	int	13h

	pop	ES
	pop	DS
	pop	SI
	pop	DI
	pop	BP

	jc	TrySwitches
	xor	AX,AX
	mov	AL,DL
	ret

TrySwitches:
	int	11h			; Get BIOS equipment flags
	mov	CL,6			; Shift over floppy disk bits
	shr	AX,CL
	and	AX,11b			; Mask off the disk bits
	inc	AX			; Add 1
	ret

GetNumberOfDrives ENDP

; =======================================================

	END

; =======================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\newint13.asm ===
;========================================================
COMMENT #

	NEWINT13.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	New interrupt 13h handler and support functions
	which check for DMA boundary errors and if detected
	will break the read into 3 pieces to eliminate
	error.
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

FIRST_HARD_DISK		EQU	80h

INCLUDE	model.inc

.DATA
	EXTRN	DiskChange:BYTE


.CODE

; =======================================================
; DWORD address of original int 13h handler. Initialize
; by InitNew13() and then used by RestoreOld13() to
; to restore the vector before the program exits back
; to DOS.
; =======================================================

	public	OldInt13
OldInt13	dd	(?)

OldAX		dw	 (?)

SplitBuffer	dd	(?)

; =======================================================
; Sets int vector 13h to point to the NewInt13 function
; which does a check for DMA errors and corrects the
; error. Saves the original vector for later restoration.
;
; void InitNew13( char far *Buffer );
;
; ARGUMENTS:	Buffer	- Far ptr to min 1024 byte buffer
;			  to be used for if a disk read
;			  needs to be split to avoid a
;			  DMA boundary error
; RETURNS:	void
; =======================================================

InitNew13 PROC USES DS ES, Buffer:DWORD

	mov	AX,3513h			;  Get int vector 13h
	int	21h
	mov	WORD PTR CS:OldInt13,BX	; Save the offset
	mov	WORD PTR CS:OldInt13[2],ES ; Save the segment

	mov	AX,2513h		; Set vector 13h
	mov	DX,offset NewInt13	; Load new vector offset
	push	CS			; Load new vector segment
	pop	DS
	int	21h			; DOS call

SaveBuffer:
	lds	BX,Buffer;		; DS:SI --> 1024 byte buffer

TestForSegmentBound:

	mov	AX,DS			; Put buffer segment in AX
	shl	AX,1			; Convert segment to 20 bit address
	shl	AX,1 			; while ingoring the high 4 bits
	shl	AX,1
	shl	AX,1

	add	AX,BX			; Add offset to 20 bit address

	add	AX,512			; Add sector size to 20 bit address
	jnc	GotBuffer		; If no carry then no segment overrun
	add	BX,512			; Else move to next segment

GotBuffer:
	mov	WORD PTR CS:SplitBuffer,BX
	mov	WORD PTR CS:SplitBuffer[2],DS

	ret

InitNew13 ENDP

; =======================================================
; Replaces the int 13h vector with the original pointer.
; =======================================================

RestoreOld13 PROC USES DS

	mov	AX,2513h		; Set vector 13h
	mov	DX,WORD PTR CS:OldInt13[2] ; Load old segment
	mov	DS,DX
	mov	DX,WORD PTR CS:OldInt13	; Load old offset
	int	21h
	ret

RestoreOld13 ENDP

; =======================================================
; New int 13h handler which will correct DMA errors if
; they are detected on reads or writes.
; =======================================================
	
	public	NewInt13
NewInt13:

	push	AX			; Save original request

	cmp	DL, FIRST_HARD_DISK	; Only do disk change check
	jae	FakeIntCall		; if drive in AL < 80h


	push	DS			; First see if we need to fake
	mov	AX,@DATA		; a changeline.
	mov	DS,AX
	xor	AX,AX
	cmp	AL,BYTE PTR DS:DiskChange
	mov	BYTE PTR DS:DiskChange,AL
	pop	DS

	pop	AX			; Restore AX but keep original
	push	AX

	je	FakeIntCall
	mov	AX,0600h
	stc
	jmp	SHORT TestError

FakeIntCall:
	pushf				; Simulate an int request
	call	DWORD PTR CS:[OldInt13]	; of the old int 13h handler
	jc	TestError		; Error so check for DMA error
	
IntExit:
	pop	CS:OldAX
	retf	02			; Far return and pop flags

TestError:
	cmp	AH,9			; Check for DMA bound error
	je	ServiceError
	stc				; Reset error condition	
	jmp	SHORT IntExit	

ServiceError:
	pop	AX			; Get original function call in AX
	cmp	AL,0			; Make sure of valid number sectors
	je	RestoreError
	cmp	AH,2			; Check was it a read operation
	je	SplitOperation		; If yes try splitting the read
	cmp	AH,3			; Check was it a write operation
	je	SplitOperation		; If yes try splitting the write

RestoreError:
	mov	AX,900h			; Retore original error code
	stc				; Restore the original err condition
	retf	02			; Far return and pop the flags

SplitOperation:
	call	NEAR PTR Int13Error	; Try to avoid the DMA boundary
	retf	02			; Return to caller


; =======================================================
; Breaks a disk read or write into individual sectors
; using another memory location which is not on a DMA
; boundary. Returns BIOS int 13h error code if carry set
; else AX == 0.	Preserves all registers execpt AX
; =======================================================

Int13Error PROC NEAR

	push	BX			; Save registers we need to use
	push	CX
	push	DI
	push	SI
	push	DS
	push	ES

	lds	SI,CS:SplitBuffer	; Put error buffer offset in SI

	cmp	AH,02			; See if this is a read
	jne	IsWrite			; If not read must be a write
IsRead:
	call	ReadSecs		; Call proc to read in the sectors
	jmp	SHORT CleanUp		; Finished

IsWrite:
	call	WriteSecs		; Call proc to write the sectors

CleanUp:
	pop	ES			; Restore all caller's registers
	pop	DS			; excpet AX and flags
	pop	SI
	pop	DI
	pop	CX
	pop	BX
	ret

Int13Error ENDP


; =======================================================
; Uses the BIOS int 13h call to read the number of sectors
; in AL into the buffer in DS:SI and then moves them to
; to the buffer in ES:BX. Reads and moves one sector at
; a time. AX, BX, CX, DX, ES must be setup on on entry
; for a normal BIOS read and DS:SI must point to a 
; buffer at least 512 bytes long which is not on a 
; DMA boundary.
; =======================================================

ReadSecs PROC NEAR

	mov	DI,BX			; ES:DI == start of caller's buffer
	mov	BX,SI			; Point BX to new buffer

ReadLoop:
	push	AX			; Save remaining sectors to do
	mov	AL,1			; Set number of sector to 1

	push	ES			; Save caller's buffer segment
	push	DS 			; Set ES to new buffer
	pop	ES

	pushf				; Simulate and int call
	call	DWORD PTR CS:[OldInt13]	; of the old int 13h handler
	pop	ES			; Retore caller's buffer segment

ErrorTest:
	jnc	CopyFromBuf		; No error so copy sector to user buf
	add	SP,2			; Adjust stack for pushed AX
	stc				; Signal we got an error
	jmp	SHORT ReadReturn	; Finished

CopyFromBuf:
	push	SI			; Save ptr to start of new buffer
	push	CX			; Save next sector number
	mov	CX,(512/2)		; Set count of words in buffer 
	cld				; Set direction to forward
	rep	movsw			; Move 1 sector to new buffer
	pop	CX			; Restore next sector number
	pop	SI			; Restore ptr to start of buffer

	pop	AX			; Restore remaining sectors
	inc	CL			; Increment to next sector
	dec	AL			; One less sector to do
	jnz	ReadLoop		; Loop until AL == 0
	xor	AX,AX			; No error code	also clears carry
	jmp	SHORT ReadReturn	; Finished

ReadReturn:
	ret

ReadSecs ENDP

; =======================================================
; Uses the BIOS int 13h call to write the number of sectors
; in AL	by moving them to a new buffer one sector at a
; time and then writing them one at a time.
; AX, BX, CX, DX, ES must be setup on on entry
; for a normal BIOS read and DS:SI must point to a 
; buffer at least 512 bytes long which is not on a 
; DMA boundary.
; =======================================================

WriteSecs PROC NEAR

	push	ES			; Set DS:SI to caller's buffer
	push	DS			; and ES:DI to new buffer
	pop	ES
	pop	DS
	mov	DI,SI
	mov	SI,BX
	mov	BX,DI			; Point BX to new buffer

WriteLoop:
	push	CX			; Save next sector number

CopyToBuf:
	mov	DI,BX			; Set ptr to new buffer
	mov	CX,(512/2)		; Set count of words in buffer 
	cld				; Set direction to forward
	rep	movsw			; Move 1 sector to new buffer
	pop	CX			; Restore next sector number

WriteTheSector:
	push	AX			; Save remaining sectors to do
	mov	AL,1			; Set number of sector to 1

	pushf				; Simulate and int call
	call	DWORD PTR CS:[OldInt13]	; of the old int 13h handler

ErrorTest:
	jc	WriteError		; Got an error so return

	pop	AX			; Restore remaining sectors
	inc	CL			; Increment to next sector
	dec	AL			; One less sector to do
	jnz	WriteLoop		; Loop until AL == 0
	xor	AX,AX			; No error code	also clears carry
	jmp	SHORT WriteReturn	; Finished

WriteError:
	add	SP,2			; Adjust stack for pushed AX
	stc				; Signal we got an error

WriteReturn:
	ret

WriteSecs ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\setdskty.asm ===
;========================================================
COMMENT #

	SETDSKTYP.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Extended ROM BIOS call which sets a disk type for
	formatting using function 17h of int 13h. The function
	must do 1 retry in case disk changed status is returned.

	int SetDiskType( unsigned uDrv, unsigned char DiskType );

	ARGUMENTS:	uDrv	- Physical floppy drive number
			DiskType - Extended BIOS disk type
			0	- Not used
			1	- 320/360K in 360K drive
			2	- 320/360K in 1.2M drive
			3	- 1.2M in 1.2M drive
			4	- 720K in 720K drive
	RETURN:		int	- 0 if ok else INVALID_DRIVE_TYPE
	================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

SetDiskType PROC USES ES DI, Drive:BYTE, DiskType:BYTE, 

	mov	AH,17h
	mov	AL,DiskType
	mov	DL,Drive
	push	AX
	int	13h
	pop	AX
	jnc	OkExit2
	int	13h
	jnc	OkExit2
	mov	AX,INVALID_DRIVE_TYPE
	ret
OkExit2:
	xor	AX,AX		; Move OK into AX
	ret

SetDiskType ENDP

; =======================================================

	END

; =======================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\sec_size.asm ===
;========================================================
COMMENT #

	SEC_SIZE.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Uses the DPB to return the number of bytes per
	sector on the specified drive.

	unsigned GetSectorSize( Drive );

	ARGUMENTS: Drive - DOS drive number (0=default, 1=A, 2=B, ...)
	RETURNS:   int	- TRUE if disk is removeable else false

	================================================

	johnhe - 12-11-90

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

GetSectorSize PROC USES DS, Drive:BYTE

	mov	AH,32h			; Get DPB request
	mov	DL,Drive		; Drive in BL (0=default,1=A...)
	int	21h

	cmp	AL,0ffh			; Check for invalid drive error
	je	BadDrive
					; Bytes per sector is offset 2
					; in the DBP
	mov	AX,[BX+2]		; AX = Bytes per sector
	ret

BadDrive:
	mov	AX,200h			; Default to 512 bytes sectors size
	ret	

GetSectorSize ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\rw_root.c ===
/***************************************************************************/
/*																									*/
/*	RW_ROOT.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Reads or writes a specified root directory sector on the specified		*/
/*	drive.																						*/
/*																									*/
/*	ReadWriteRoot( int iDosDrv, struct BPB *Bpb, void *Buf, int Sector		*/
/*					  			int ReadWrite )												*/
/*																									*/
/*	ARGUMENTS:	iDosDrv	- The DOS drive number to get the sector from		*/
/*					Bpb		- Ptr to bpb structure for the specified drive		*/
/*					Buf		- Ptr to sector buffer										*/
/*					Sector	- The root directory sector number based 0			*/
/*					ReadWrite- Flags reading or writing sector - READ or WRITE 	*/
/*	RETURNS:		int		- OK if successfull else int 25h error code			*/
/*																									*/
/*	johnhe - 02-14-90																			*/
/***************************************************************************/

#include		<alias.h>
#include		<disk_io.h>

int ReadWriteRoot( int iDosDrv, struct BPB *Bpb, void *Buf, int Sector,
						 int ReadWrite )
{
	struct ABSIO_PACKET	absPack;

	absPack.uNumSectors = 1;
	absPack.pchBuffer = (char far *)Buf;
	absPack.lStartSector = (long)(Bpb->uReservSec +
											((UINT)Bpb->uchNumberFats * Bpb->uSecPerFat) +
											(UINT)Sector );

  return( AbsReadWrite( iDosDrv, &absPack, ReadWrite ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\setbpb.asm ===
;========================================================
COMMENT #

	SET_BPB.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Uses the generic IOCTL call to set the default bpb for
	specified a disk drive

	int SetNewBpb( struct BPB *Bpb, char *WorkBuffer, int Drive );

	ARGUMENTS:	Bpb	- The new BPB structure
			Buffer	- A work buffer for use by the function
			Drive	- The disk drive to set the new bpb for
	RETURNS:	int	- 0 if successfull else -1
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

IF @DataSize
  SetNewBpb PROC USES DS ES DI SI, Bpb:Ptr, Buffer:Ptr, Drive:WORD
ELSE
  SetNewBpb PROC USES    ES DI SI, Bpb:Ptr, Buffer:Ptr, Drive:WORD
ENDIF
	mov	AX,440dh		; IOCTL  function function 0dh
	mov	BX,Drive		; Drive number in BL
	mov	CX,860h			; CH=Device Type - CL=minor funct. #

;	lds	SI,Buffer		; Load pointer to buffer
	LoadPtr	DS, SI, Buffer		; DS:SI --> Caller supplied buffer

	mov	DX,SI			; Move offset pointer to DX
	mov	BYTE PTR [SI],0		; Set for get default params
	int	21h
	jc	Error			; Check for error

SavePtr:
	push	DS			; Save DS:DX
	push	DX

;	les	DI,Buffer		; Set ES:DI for string copy
	LoadPtr	ES, DI, Buffer		; ES:DI --> Caller supplied buffer

	add	DI,07			; Point to bpb in params

;	lds	SI,bpb			; Point DS:SI to new bpb
	LoadPtr	DS, SI, Bpb		; DS:SI --> Bpb structure

	mov	CX,BPB_SIZE		; Number of bytes in the bpb
	cld
	rep	movsb			; Copy new bpb to params
	pop	DX			; Restore DS:DX
	pop	DS

SetNewCall:	
	mov	AX,440dh		; IOCTL function 0dh
	mov	BX,Drive		; Put drive number in BL
	mov	CX,840h			; CH=Device Type - CL=minor funct. #

	mov	SI,DX			; Move offset pointer to SI
	or	BYTE PTR [SI],101b	; Set bit 0 for set default params

	int	21h
	jc	Error			; Check for errors
	xor	AX,AX			; No errors so return OK
	jmp	SHORT SetBpbReturn

Error:
	mov	AX,-1

SetBpbReturn:
	ret

SetNewBpb ENDP
	
; =======================================================

	END

; =======================================================

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\rw_fat.c ===
/***************************************************************************/
/*																									*/
/*	RW_FAT.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Reads or writes a specified FAT sector on the specified drive.	Will		*/
/* update the same sector in all copies of the FAT.								*/
/*																									*/
/*	ReadWriteFat( int iDosDrv, struct BPB *Bpb, void *Buf, int Sector,		*/
/*					  int ReadWrite )															*/
/*																									*/
/*	ARGUMENTS:	iDosDrv	- The DOS drive number to get the sector from		*/
/*					Bpb		- Ptr to bpb structure for the specified drive		*/
/*					Buf		- Ptr to sector buffer										*/
/*					Sector	- The FAT sector number based 0							*/
/*					ReadWrite- Flags reading or writing sector - READ or WRITE 	*/
/*	RETURNS:		int		- OK if successfull else int 25h error code			*/
/*																									*/
/*	johnhe - 02-14-90																			*/
/***************************************************************************/

#include		<alias.h>
#include		<disk_io.h>

int ReadWriteFat( int iDosDrv, struct BPB *Bpb, void *Buf, int Sector,
						int ReadWrite )
{
	register					i;							/* Loop indice 					*/
	register					iStatus;					/* Disk write status 			*/
	struct ABSIO_PACKET	absPack;					/* DOS 4.0 int 25h,26h packet	*/

	absPack.uNumSectors = 1;
	absPack.pchBuffer = (char far *)Buf;
	absPack.lStartSector = (long)(Bpb->uReservSec + (UINT)Sector );

	for ( iStatus = OK, i = 0;
			iStatus == OK && i < Bpb->uchNumberFats;
			absPack.lStartSector += (long)Bpb->uSecPerFat, i++ )
	{
		iStatus = AbsReadWrite( iDosDrv, &absPack, ReadWrite );
		if ( ReadWrite == READ )
			break; 											/* Only need to read once */
	}
	return( iStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\setmedia.asm ===
;========================================================
COMMENT #

	SETMEDIA.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Extended ROM BIOS call to set the disk layout for a
	format operation. The function must do 1 retry in case
	a disk change status is returned.

	void *SetMediaType( int Drive, int Tracks, int Sectors )

	ARGUMENTS: Drive	- Physical drive number
		   Tracks	- Total tracks on the floppy disk
		   Sectors	- Number of sectors per track

	RETURNS:		  Ptr to DASD for this type of drive
				  is successfull else NULL ptr
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

SetMediaType PROC USES ES DI, Drive:BYTE, Tracks:BYTE, Sectors:BYTE

	mov	AH,18h		; ROM BIOS get drive parameters function
	mov	CH,Tracks	; Load total number of disk track
	mov	CL,Sectors	; Load sectors per track
	dec	CH		; Convert track to 0 based
	mov	DL,Drive	; Load physical drive number
	push	AX 		; Save AX in case of a retry
	int	13h		; ROM BIOS disk call
	pop	AX		; Retore function number
	jnc	SetOK		; Everything OK 
	int	13h 		; Got an error so do a retry
	jc	SetError	; Now everything is OK

SetOK:
	mov	AX,DI 		; Put DASD ptr in DX:AX
	mov	DX,ES
	jmp	SHORT SetMediaExit ; Everything is ready for return

SetError:
	xor	AX,AX		; Put NULL ptr in DX:AX	to signal error
	cwd			; Extend sign into DX

SetMediaExit:
	ret

SetMediaType ENDP

; =======================================================

	END

; =======================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\tmpboot.asm ===
;========================================================
COMMENT #

	TMPBOOT.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Data area contianing a tmp boot record which
	displays a message prompting the user to insert
	a recovery disk into drive A: and press any key.
	=================================================

	johnhe - 06/06/89

END COMMENT #
; =======================================================

INCLUDE	disk_io.inc
INCLUDE	model.inc

.DATA

	PUBLIC	TmpBoot

TmpBoot	LABEL	BYTE

	include tboot.inc

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\disk\v_dir.c ===
/***************************************************************************/
/*																									*/
/* DSK_DIR.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* Functions to verify a multi-level directory path and create the path.	*/
/* If an error is detected any newly created levels in the path are			*/
/* removed to insure the disk is not left with random directories.			*/
/*																									*/
/* Created 07-23-89 johnhe																	*/
/***************************************************************************/

#include 	<stdio.h>
#include 	<dos.h>
#include 	<direct.h>

#include 	<alias.h>
#include 	<string.h>
#include		<strlib.h>
#include		<disk_io.h>

#define		ERROR 			-1


/***************************************************************************/
/* Validates a directory path string by cleaning up the string and then		*/
/* checking that each directory in the path has a valid directory name.		*/
/*																									*/
/*	int ValidatePath( char *szPath )														*/
/*																									*/
/* ARGUMENTS:	szPath	- A directory path string									*/
/* RETURNS:		int		- TRUE if a valid path else FALSE						*/
/***************************************************************************/

int ValidatePath( char *szPath )
{
	char				*szPtr;
	register 		Status;

#ifdef DBCS
	DBCSstrupr( szPath );
#else
	strupr( szPath );
#endif
	szPtr  = szPath;

	RemoveSpaces( szPath );
	RemoveTrailing( szPath, '\\' );
	if ( *szPtr != '\\' )
		InsertChar( szPath, '\\' );

	if ( strlen( szPath ) == 1 ) 						/* Check for root dir */
		return( FALSE );

	Status = ValidateDir( szPath );
	return( Status == OK ? TRUE : FALSE );
}	

/***************************************************************************/
/*	Parses out the first directory from a path string and validates that 	*/
/* directory name and if valid recursively calls itself until each name	in	*/
/* in the path has been validated or an error is detected.						*/
/*																									*/
/* int	ValidateDir( char *szPath )													*/
/*																									*/
/*	ARGUMENTS:	szPath	- The path string to use to find the next directory*/
/* RETURNS:		int		- OK if successful else ERROR								*/
/*																									*/
/***************************************************************************/
int	ValidateDir( char *szPath )
{
	int		Status;
	char		*pchEnd = NULL;

	if ( *szPath == EOL )		/* See if there is a path to change to */
		return( OK );				/* If not just return success */
	else
	{
		if ( *szPath == '\\' )	/* Step over leading backslach character */
			szPath++; 				
#ifdef DBCS
		pchEnd = DBCSstrchr( szPath, '\\' );
#else
		pchEnd = strchr( szPath, '\\' );
#endif
		if ( pchEnd != NULL )	/* If a back slash change it to an EOL */
			*pchEnd = EOL;
										/* Check for max directory name length */
		if ( IsValidDirName( szPath ) )
			Status = OK;
		else
			Status = ERROR;

		if ( pchEnd != NULL )
		{
			*pchEnd = '\\';			/* Replace directory seperator */
			if ( Status == OK )
				Status = ValidateDir( pchEnd );
		}
		return( Status );
	}
}



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\file\f_isdir.c ===
/***************************************************************************/
/*																									*/
/*	F_ISDIR.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Determines if any files exist in the specified directory path. 			*/
/* 																								*/
/* int IsDirEmpty( char *szPath )														*/
/* 																								*/
/* ARGUMENTS:	szPath	- Ptr to full path name for directory to search 	*/
/* RETURNS: 	int		- FALSE if file is found else TRUE						*/
/*																									*/
/* Created 10-28-89 johnhe																	*/
/***************************************************************************/

#include 	<stdio.h>

#include 	<alias.h>
#include 	<strlib.h>
#include 	<disk_io.h>

int IsDirEmpty( char *szPath )
{
	char				*szAnyFile = "????????.???";
	char				szFullPath[ MAX_PATH_LEN ];

	BuildPath( szFullPath, szPath[0], szPath + 2, szAnyFile );
	return( !FileExists( szFullPath ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\file\f_rdwr.c ===
/***************************************************************************/
/*																									*/
/*	F_RDWR.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Reads or writes a requested number of bytes into a specified buffer. 	*/
/*	The number of bytes requested may be > 64K without causing a problem.	*/
/* 																								*/
/* int BigReadWrite( int iFile, char far *Buf, long lToRead )					*/
/* 																								*/
/* ARGUMENTS:	iFile 	- Open DOS file handle, file pointer must be set	*/
/* 							  to position for start of read or write				*/
/*					Buf		- Far ptr to caller's buffer								*/
/* 				lBytes	- Number of bytes to read or write						*/
/* 				fRdWr 	- Flags 0 for read and 1 for write						*/
/* RETURN:		int		- OK if no error - ERROR if read or write error		*/
/*																									*/
/* Created 10-28-89 johnhe																	*/
/***************************************************************************/

#include 	<stdio.h>
#include 	<dos.h>

#include 	<alias.h>
#include 	<strlib.h>
#include		<window.h>

int BigReadWrite( int iFile, char far *Buf, long lBytes, int RdWr )
{
	unsigned		uDone;						/* Number of bytes transfered 		*/
	unsigned		uToDo;						/* Count of bytes move in the loop	*/

																					/*lint -e64 */
	static unsigned (*Func[])( int, void far *, unsigned, unsigned *) =
													{ _dos_read, _dos_write };
																					/*lint -e64 */

	if ( RdWr ) 								/* Be sure RdWr is either 0 or 1 	*/
		RdWr = 1;
													/*lint -e530 */
							 						/* Loop to do reads or writes in 	*/
													/* allowable size blocks 0xff00		*/
	while ( lBytes > 0L )
	{											  
		Buf = NormalizePtr( Buf );		  /* Precaution to prevent segment wrap*/

													/* Figure out number of bytes to do */
		uToDo = (long)MAX_BLOCK < lBytes ? MAX_BLOCK : (unsigned)lBytes;

													/* Do the read or write 				*/
		if ( (*Func[ RdWr ])( iFile, (void far *)Buf, uToDo, &uDone ) != OK ||
			  uDone != uToDo )
			return( ERROR );						/* ERROR EXIT	*/
														/* Increment the buffer pointer	*/
		Buf = HugeAdd( Buf, (long)uToDo );	/* also normalizes the ptr 		*/
		lBytes -= (LONG)(uDone);				/* Adjust remaining bytes			*/
		UpdateByteCount( (long)(uToDo) );	/* Update the status gage			*/
	}												
	return( OK );									/* NORMAL EXIT */
}																				/*lint +e530	*/

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\file\f_absdel.c ===
/***************************************************************************/
/*																									*/
/*	F_ABSDEL.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Does an absolute delete of a file reguardless of the files attributes.	*/
/* 																								*/
/* int AbsUnlink( char *szFile )															*/
/* 																								*/
/* ARGUMENTS:	szFile	- Full path name of file to be deleted					*/
/* RETURNS: 	int		- OK if successful else ERROR 							*/
/*																									*/
/* Created 12-10-89 johnhe																	*/
/***************************************************************************/

#include 	<stdio.h>
#include		<io.h>
#include		<dos.h>
#include		<alias.h>

int AbsUnlink( char *szFile )
{
	if ( _dos_setfileattr( szFile, _A_NORMAL ) == OK )
		return( unlink( szFile ) );
	return( -1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\file\f_replac.c ===
/***************************************************************************/
/*																									*/
/*	F_REPLAC.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Replaces the destination file with the source file by first seeing if	*/
/* the source exists and then deleting the destination and renameing the	*/
/* destination and renaming the source to take it's place. The check for   */
/* the destination is done to be sure the replace has not already taken 	*/
/* place.																						*/
/* 																								*/
/* int ReplaceFile( char *szSource, char *szDestin )								*/
/* 																								*/
/* ARGUMENTS:	szSource - Ptr to full path and name for source file			*/
/* 				szDestin - Ptr to full path and name for destination file	*/
/* RETURNS: 	int		- OK if successful else ERROR 							*/
/*																									*/
/* Created 12-10-89 johnhe																	*/
/***************************************************************************/

#include 	<stdio.h>
#include		<io.h>
#include		<dos.h>

#include 	<alias.h>
#include 	<disk_io.h>

int ReplaceFile( char *szSource, char *szDestin )
{

	if ( FileExists( szSource ) )
	{
		_dos_setfileattr( szDestin, _A_NORMAL );
		unlink( szDestin );

	}
	
	if ( rename( szSource, szDestin ) != OK )
		return( ERROR );													/* ERROR EXIT	*/

	return( OK );															/* NORMAL EXIT	*/
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\file\f_ren.c ===
/***************************************************************************/
/*																									*/
/*	F_REN.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Renames within the same directory of the specified full drive and path	*/
/* anem. This is necessary when renameing the system files because DOS		*/
/* versions < 3 move the physical directory entry when renaming which will */
/* move the system file entries out of the first 2 positions.					*/
/* 																								*/
/* int RenameFCB( char *szFrom, char *szTo )											*/
/* 																								*/
/* ARGUMENTS:	szFrom	- Original name of file in the form X:\NAME.EXT 	*/
/* 				szTo		- New name for	file in the form X:\FILENAME.EXT		*/
/* RETURNS: 	int		- OK if successfull else error							*/
/*																									*/
/* Created 10-28-89 johnhe																	*/
/***************************************************************************/


#include 	<stdio.h>
#include 	<stdlib.h>
#include 	<dos.h>
#include 	<string.h>
#include 	<direct.h>

#include 	<alias.h>
#include 	<strlib.h>
#include 	<disk_io.h>

int RenameFCB( char *szFrom, char *szTo )
{
	#define		SPEC_FCB_LEN	0x25
	#define		PATH_LEN 		70

	char			chDrive;
	char			Fcb[ SPEC_FCB_LEN + PATH_LEN ];
	char			*szOldPath;
	char			*szPtr;
	char			chTmp;
	int			iStatus;
													/* Check for same names */
	if ( strcmpi( szFrom + 3, szTo) == OK )
		return( OK );

	szOldPath = Fcb + SPEC_FCB_LEN;

	memset( Fcb, 0, SPEC_FCB_LEN );
	chDrive = (char)(toupper( *szFrom ) - 0x40); 	/* Get DOS drive number	*/

	strcpy( szOldPath, "X:\\" );			/* Create a path prefix 				*/
	*szOldPath = *szFrom;					/* Drive letter for path				*/

	iStatus = ERROR;							/* Assume may get some errors 		*/
	if (_dos_getdir( szOldPath + 3, (int)chDrive ) == OK )
	{
		szPtr = ParseFileName( szFrom );	/* Get ptr to end of directory path */
		chTmp = *szPtr;						/* Save first char of file name		*/
		*szPtr = EOL;							/* Form path with no file added		*/

		if ( chdir( szFrom ) == OK )		/* Change to specified directory */
		{
			*szPtr = chTmp;					/* Restore first char of file name */
													/* Use FcbParse to put the names in */
													/* the FCB and then call FcbRename	*/
			FcbParse( szPtr, Fcb );
			FcbParse( ParseFileName( szTo ), Fcb + 0x10 );
			*Fcb = chDrive;					/* Set the drive number in the FCB	*/
			if ( FcbRename( Fcb ) == OK && chdir( szOldPath ) == OK )
				iStatus = OK;
		}
		*szPtr = chTmp;						/* Necessary if there was an error */
	}

	return( iStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\file\f_exists.c ===
/***************************************************************************/
/*																									*/
/*	F_EXISTS.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Determines if the specified file exists.											*/
/* 																								*/
/* int FileExists( char *szFile )														*/
/* 																								*/
/* ARGUMENTS:	szFile		- Ptr to full path name for file to be found 	*/
/* RETURNS: 	int			- TRUE if file was found else FALSE 				*/
/*																									*/
/* Created 10-28-89 johnhe																	*/
/***************************************************************************/

#include 	<dos.h>

#include		<alias.h>

int FileExists( char *szFile )
{
	struct find_t		FileInfo;

	return( _dos_findfirst( szFile, _A_NORMAL | _A_RDONLY | _A_ARCH,
									&FileInfo ) == OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hardware\cmos.asm ===
;===========================================================================
COMMENT	#

 CMOS.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

 Functions to read information from CMOS RAM
 Converted from Windows 3.0 installation code

END COMMENT #
;===========================================================================

CMOS_PORT	EQU	70H
CMOS_DATA       EQU	71H
CMOS_REG_D2     EQU	1AH
EXT_MEM_LOW	EQU	17h
EXT_MEM_HIGH	EQU	18h

;***************************************************************************

INCLUDE model.inc

.CODE

;---------------------------------------------------------------------------
; Reads into AL into the byte location in CMOS RAM as specified in
; in AH on entry
;
; ENTRY:	AH = Byte offset in CMOS RAM
; RETURNS:	AL = Byte from CMOS memeory
;
;---------------------------------------------------------------------------

ReadCmos   PROC

	mov	AL,AH
	cli
	out	CMOS_PORT, AL
	jmp	SHORT @F
@@:
	in	AL,CMOS_DATA
	sti
	ret

ReadCmos ENDP

;---------------------------------------------------------------------------
; Writes the byte in AH into the byte location in CMOS RAM as specified
; in AL
;
; ENTRY:	AH = Byte offset in CMOS RAM
;		AL = Byte to write at CMOS RAM offset
;
;---------------------------------------------------------------------------

WriteCmos   PROC

	xchg	AH,AL

	cli

	out	CMOS_PORT,AL
	jmp	SHORT @F
@@:
	xchg	AH,AL
	out	CMOS_DATA,AL

	sti
	ret

WriteCmos ENDP

;---------------------------------------------------------------------------

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hardware\getcpu.asm ===
;===========================================================================
COMMENT #

 GETCPU.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential


   _A386machine - return type of processor (386 vs. 8088/86/286).
       This routine relies on Intel-approved code that takes advantage
       of the documented behavior of the high nibble of the flag word
       in the REAL MODE of the various processors.  The MSB (bit 15)
       is always a one on the 8086 and 8088 and a zero on the 286 and
       386.  Bit 14 (NT flag) and bits 13/12 (IOPL bit field) are
       always zero on the 286, but can be set on the 386.

       For future compatibility of this test, it is strongly recommended
       that this specific instruction sequence be used.  The exit codes
       can of course be changed to fit a particular need.

       CALLABLE FROM REAL MODE ONLY - near ROUTINE

       this routine was stolen from EMM/386 source code

   int GetCpuType( void );

   ENTRY:  (none)
   EXIT:   ax = 0 == 8086, 1 == 80286, 2 == 80386
           ax = 0 otherwise
   USED:   none
   STACK:  6 bytes

END COMMENT #
;===========================================================================

INCLUDE model.inc

.CODE

;------------------------------------------------------------------------------

GetCpuType PROC

         pushf                            ; save entry flags

         xor         ax, ax               ; 0000 into AX
         push        ax
         popf                             ; try to put that in the flags
         pushf
         pop         ax                   ; look at what really went into flags

TestFor8088:
	 test	     ax, 08000h 	  ; Q: was high bit set ?
	 jz	     short TestFor80286	  ; N: Not an 8086/8088
	 xor	     AX,AX		  ; Signal 8086 processor
	 jmp	     SHORT ExitCpuType

TestFor80286:
	 mov	     ax, 07000h 	  ;   N: try to set the NT/IOPL bits
         push        ax
         popf                             ;      ... in the flags
         sti                              ; (for VDMM/IOPL0)
         pushf
         pop         ax                   ; look at actual flags
         test        ax, 07000h           ; Q: any high bits set ?
	 jnz	     Is80386		  ; Y: must be 386 machine
	 mov	     AX,1		  ; else is 80286
	 jmp	     SHORT ExitCpuType	  ; Must be an 80386
Is80386:
	 mov	     ax,2

ExitCpuType:
         popf                             ; restore flags

	 ret

GetCpuType ENDP


END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hardware\getmem.asm ===
;========================================================
COMMENT #

	GETMEM.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================
	Returns number of Kbytes of convential memory which
	is returned by int 12h.

	unsigned GetConvMem( void );

	ARGUMENTS:	NONE
	RETURNS:	unsigned - Kbytes of convential memory
	=================================================

	johnhe - 06/06/89

END COMMENT #

; =======================================================

INCLUDE model.inc

.CODE

; =======================================================

GetConvMem PROC

	int	12h
	ret

GetConvMem ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hardware\getmodel.asm ===
;==========================================================================
COMMENT	#

 GETMODEL.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

END COMMENT #
;==========================================================================

INCLUDE model.inc

.CODE

CONVERTIBLE_MODEL_BYTE equ 0f9h

;==========================================================================
;
; GetModelBytes()
;
; Returns model byte in ah and sub-model byte in al, or 0 in ah and al if the
; BIOS can't tell us.
;
; As far as the MS high-level languages are concerned, we only need to
; save DS, SS, DI, and SI if we trash them.  But to be friendly, we won't
; corrupt anything except AX and flags.
;
;==========================================================================

GetModelBytes PROC USES ES BX

         ; Get model bytes from ROM BIOS using BIOS call.
         ; (Actually, they're stored at f000:fffe.)
         mov   ah, 0c0h
         int   15h

         ;
         ; For PC, PCjr, and really old PC XT and AT BIOSs, this int 15h call
         ; will set the carry flag, and return:
         ;
         ; (AH)    = 80h   PC and PCjr
         ;
         ; (AH)    = 86h   PC XT BIOS dated 11/08/82 and AT BIOS dated
         ;                 1/10/84, or PS/2 (except Model 30) if system model
         ;                 cannot be determined
         ;
         ; If the carry flag is not set by this int 15h call, the system is a
         ; PC XT with ROM BIOS dated 1/10/86 or after, an AT with ROM BIOS
         ; dated 6/10/85 or after, a PC XT Model 286, a PC Convertible, or a
         ; PS/2.  In these cases, the int 15h call will return:      
         ;
         ; (AH)    = 0
         ; (ES:BX) = pointer to system descriptor vector in ROM
         ;
         ; The third byte of this system descriptor vector in ROM is the
         ; model byte, and the fourth byte is the submodel byte.
         ;

         jc    No_Descriptor_Available

         ; Build model byte address.
         inc   bx
         inc   bx

         ; Get model byte.
         mov   ah, es:[bx]

         ; Get sub-model byte.
         inc   bx
         mov   al, es:[bx]

         ;
         ; The USES portion of the PROC directive directs masm to
         ; automatically push used registers on entry and pop them on exit
         ; (i.e., at all rets).  By employing a short jump here
         ; (jmp short exit) instead of two pops and a ret, we would save one
         ; byte of code.  However, the short jump is also slower than using a
         ; ret.  Let's go for speed...
         ;

         ret

No_Descriptor_Available:
         ; Return 0 in ah and al since the BIOS can't tell us the model and
         ; sub-model bytes.
         xor   ax, ax

Exit:
         ret

GetModelBytes ENDP

;==========================================================================
; IsConvertible()
;
; Returns 1 in AX if the system is an IBM PC Convertible,
;         0 in AX if not.
;
; Checks model byte.
;
;==========================================================================

IsConvertible PROC

			         
         call_M  GetModelBytes		; Get model byte to examine.
					; Are we on an IBM PC Convertible?
         cmp   ah, CONVERTIBLE_MODEL_BYTE
         je    Is_Convertible
	
         xor   ax, ax		; No, this is not an IBM PC Convertible.
         ret

Is_Convertible:
         mov   ax, 1		; Yes, this is an IBM PC Convertible.
         ret

IsConvertible ENDP

;==========================================================================

END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hardware\himem.asm ===
;========================================================
COMMENT #

	HIMEM.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================

	 Function returns the HIMEM version number if it's present else 0
	 If a driver is installed and it's not HIMEM.SYS we return
         a version number of 10 to make sure Himem will not be installed.

	 unsigned GetHimemVer( void )
 
	 ARGUMENTS:	NONE
	 RETURNS:	unsigned - Himem internal revision number or 0

	================================================

	Change Log:

    	Date      Who   No.		Description
  	--------  ---  ----    -------------------------------------
        08/20/90  JAH           Created
        01/23/90  DLB  M002     Close XMSXXXX0 device properly.

END COMMENT #

; =======================================================

INCLUDE	model.inc

; =======================================================


XMS_DEV_NAME    EQU     "XMSXXXX0",0; Name for XMS driver IOCTL open.

VER_10		EQU	1000h
; =======================================================

.DATA

XmsEntry	DD	(?)

DeviceName	db	XMS_DEV_NAME	; Name for EMM IOCTL opens.

.Code

; =======================================================

GetHimemVer PROC USES ES BX SI DI
;	LOCAL	XmsEntry:DWORD

	push	DS
	xor	AX,AX		; Make sure vector 0x2f is initialized
	mov	BX,2fh*4
	mov	DS,AX	
	mov	AX,[BX]
	or	AX,[BX+2]	; Is vector 2fh initialized ?
	pop	DS
	jz	NoXmsDriver

DoXmsCall:
	xor	DX,DX		; Init DX to zero.
	mov	AX,4300h	; Hello XMS?
	int	2fh		; multiplex call
	cmp	AL,80h		; If XMS does not answer with 80h were done.
	jnz	NoXmsDriver


IsDriverHimemSys:
	mov	DX,OFFSET DeviceName ; DS:DX pointer to device name
	mov	AX,3d02h	; Try to open the device
	int	21h
	jnc	CloseDevice
	mov	AX,VER_10	; Return bogus extreme high version number
	jmp	SHORT HimemVerReturn

CloseDevice:
        mov     BX,AX           ; M002: BX = device handle.
	mov	AX,3E00h	; Close device, handle in BX.
	int	21h

	mov	AX,4310h	; Get XMS function pointer
	int	2fh
	mov	WORD PTR XmsEntry,BX
	mov	WORD PTR XmsEntry[2],ES
	mov	AX,00		; Get XMS version request
	call	DWORD PTR [XmsEntry]

	cmp	AH,2		; Must be > version 2.x for BX to be valid
	jl	HimemVerReturn	; internal revision number

	cmp	AH,4		; BUGBUG need to change this when 
	jge	HimemVerReturn	; MS himem driver gets to 4.x

	mov	AX,BX
	jmp	SHORT HimemVerReturn

NoXmsDriver:
	xor	AX,AX

HimemVerReturn:
	ret

GetHimemVer ENDP

; =======================================================

	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hardware\getext.asm ===
;==========================================================================
COMMENT #

 GETEXT.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

 Functions to read ext memory size from CMOS RAM

END COMMENT #
;==========================================================================

; constants used by _get_ext

EXT_MEM_LOW	EQU	17h
EXT_MEM_HIGH	EQU	18h

;==========================================================================

INCLUDE model.inc


EXTRN	GetCpuType	:PROC
EXTRN	ReadCmos	:PROC
EXTRN	WriteCmos	:PROC

.CODE

;==========================================================================
; Get extended memory amount.
; First do an int 15h function 88h to be sure that extended memory is
; supported on this machine (don't worry about size returned just if
; the function is supported).
;==========================================================================

GetExtMemSize PROC

	call_M	GetCpuType		; First check to be sure not
	or	AX,AX			; an 8088 CPU type (type == 0)
	mov	AX,0
	jz	GetExtMemRet		; If CPU type 0 then 0 ext memory

	mov	AH,EXT_MEM_LOW
	call_M	ReadCmos		; Read low byte of memory size
	mov	BX,AX			; BL == Byte from CMOS
	not	AL			; Flip the bits
	call_M	WriteCmos		; Write back the flipped bits
	call_M	ReadCmos		; Read back the byte just written
	cmp	AX,BX			; See if bits in CMOS changed

	mov	AX,0			; Assume may not have CMOS
	je	GetExtMemRet

	mov	AX,BX			; Restore original CMOS contents
	call_M	WriteCmos		; Write back original low ext mem byte
	mov	AH,EXT_MEM_HIGH
	call_M	ReadCmos		; Now read the high ext memory byte
	mov	AH,AL			; Set with AH = high && AL == LOW
	mov	AL,BL

GetExtMemRet:
	ret

GetExtMemSize ENDP

;==========================================================================

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hardware\getemm.asm ===
;========================================================
COMMENT #

	GETEMM.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================

	 Function returns the EMM386 version number if it's present else 0

	 unsigned GetEmmVersion( void )

	 ARGUMENTS:	NONE
	 RETURNS:	unsigned - EMM386 internal revision number or 0

	================================================

	Change Log:

    	Date      Who   NUMBER		Description
  	--------  ---  ----	---------------------------------------------
        08/20/90  JAH           Created
        01/23/90  DLB  M000     Test for $MMXXXX0 device (when "device=
                                EMM386 NOEMS") as well as EMMXXXX0 device.
                                Also deleted "POP ES" which trashed ES.
        01/23/90  DLB  M001     If EMMXXXX0 or $MMXXXX0 device exists, verify
                                it is EMM386.EXE by checking for "MICROSOFT"
                                signature.
        09/14/92  ECH  M002     Test for $EMMQXXX0 device (VCPI, but no EMS)
                                as well.

END COMMENT #
; =======================================================

INCLUDE model.inc

; =======================================================

EMM_INT_VECT		EQU 	67h
DEVICE_OFFSET		EQU	10

EMM_READ_FUNC		EQU	1
EMM_GET_VER		EQU	2
EMM_DEV_NAME    	EQU     "EMMXXXX0",0 ; Name for EMM driver IOCTL open.
EMM_DEV_NOEMS           EQU     '$'          ; M000: Replacement for first
                                             ;   char. of EMM_DEV_NAME when
                                             ;   "device=EMM386 NOEMS".

EMM_DEV_VCPI            EQU     "EMMQXXX0",0 ; M002: Name for EMM driver when
                                             ;   VCPI but not EMS support.

EMM386_SIG           	EQU     "MICROSOFT"  ; M001: EMM386 Signature.
                                             ; M001: Offset from device base.
EMM386_SIG_OFFSET       EQU     (0ah + EMM_DEV_NAME_LEN - 1 + 2)


; Structure of the data returned on the IOCTL call to the EMM driver

EMM_STRUC	struc

    EMM_Version_Maj	db	?   ; Internal revision number
    EMM_Version_Min	db	?

EMM_STRUC	ends

Version		EQU (-((SIZE EMM_STRUC) - EMM_Version_Maj))
Function	EQU (-(SIZE EMM_STRUC))

; =======================================================
;
; For the IOCTL to get the data and version number of importable EMM info
; the IOCTL read subfunction is encoded in the first byte of the IOCTL
; read buffer.
;

; =======================================================

.DATA

; =======================================================

DeviceName	db	EMM_DEV_NAME	; Name for EMM IOCTL opens.
EMM_DEV_NAME_LEN EQU    ($-DeviceName)  ; M001: Length of DeviceName string.

EMM386Sig    	db      EMM386_SIG	; M001: Signature for EMM386 device.
EMM386_SIG_LEN  EQU     ($-EMM386Sig) 	; M001: Signature length.

;M002
VCPIDevName	db	EMM_DEV_VCPI	; Name for EMM VCPI IOCTL opens.

; =======================================================

.CODE

; =======================================================

GetEmmVersion	PROC USES ES DI SI      ; M000

        pushf                           ; M001: Save flags due to CLD below.
	push	BP
	mov	BP,SP
	sub	SP,SIZE EMM_STRUC

;M000
	mov	DX,OFFSET DeviceName	; DS:DX pointer to emm name
	mov	AX,3d02h		; Try to open the device
	int	21h
        jnc     GEV40                   ; Jump if device opens.

	mov	DeviceName,EMM_DEV_NOEMS ; DS:DX -> NOEMS emm name
	mov	AX,3d02h		; Try to open the device
	int	21h
        jnc     GEV40                   ; Jump if device opens.

;M002
	mov	DX,OFFSET VCPIDevName	; DS:DX pointer to VCPI emm name
	mov	AX,3d02h		; Try to open the device
	int	21h
        jc      GEV60                   ; Jump if device not found.

; M001: Validate "MICROSOFT" signature.

GEV40:  push    AX                      ; Save EMM device handle.
        mov     AX,(35h SHL 8) OR EMM_INT_VECT
        int     21h                     ; ES:BX -> EMM device handler.
                                        ; ES:0000 -> EMM device base.
        mov     DI,EMM386_SIG_OFFSET    ; ES:DI -> EMM Signature.
        mov     SI,OFFSET EMM386Sig	; DS:SI -> EMM386 Signature.
        mov     CX,EMM386_SIG_LEN       ; CX = Signature length.
        cld
        repz    cmpsb                   ; Signature match?
        jz      GEV80                  	;   Yes, jump.
                                        ;   No, fall thru and exit.

GEV60:	xor	AX,AX			; return code = 0.
	jmp	SHORT FunctExit         ; Go fix stack and exit.

GEV80:	pop	BX			; BX = device handle.
;M000

	mov	AX,4400h		; IOCTL get device information.
	int	21h
	jc	SHORT ErrorClose	; Carry indicates call unsuccesful

	test	DX,0080h		; Test if clock device.
	jz	SHORT ErrorClose	; if not, we can't steal memory.

	test	DX,4000h		; Are IOCTL's 02h and 03h supported
	jz	SHORT ErrorClose	; if not we cannot steal memory.

	push	DS
	mov	AX,SS
	mov	DS,AX
	mov	DX,BP			; DS:DX == SS:BP
	mov	CX,SIZE EMM_STRUC	; CX == size of the ctrl string
	sub	DX,CX			; DS:DX --> Start of data struct

	mov	BYTE PTR [BP].Function,EMM_GET_VER

	mov	AX,4402h		; Read control device string function
	int	21h
	pop	DS
	jc	SHORT ErrorClose	; Carry indicates call unsuccesful

	cmp	AX,CX			; If ax != cx we did not get the
	jne	SHORT ErrorClose	; number of bytes we requested !
	mov	AX,WORD PTR [BP].Version ; Have good version #
	xchg	AH,AL			; Put major ver. in AH & minor in AL
	jmp	SHORT CloseHandle

ErrorClose:
	xor	AX,AX			; Invalid SmartDrv version #

CloseHandle:
	push	AX
	mov	AX,3E00h		; Close device, handle in BX.
	int	21h			; Call DOS
	pop	AX

FunctExit:
	mov	SP,BP
	pop	BP
        popf                            ; M001
	ret				; return to caller.

GetEmmVersion     ENDP

; =======================================================

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hardware\ms_mice.asm ===
;**************************************************************************
; _FindMSMouse Source Code
;
; This routine determines if the version number passed to it is newer than
; the currently install Microsoft mouse driver.  If it isn't then 0 is
; returned otherwise a non-zero value is returned.
;
; This routine is intended to be used by applications and languages at
; Microsoft to determine if they should install a mouse driver during
; their setup process.
;
; To determine if a Microsoft mouse driver is installed the routine
; goes through the following logic:
;
;	Is a Mouse Driver Installed?
;	  NO - return 0
;	Is it a Microsoft mouse driver?
;	  NO - return 0
;	Return non-zero value
;
; This code can only detect Microsoft mouse drivers greater or equal to 
; version 3.00.  This should be sufficient.
;
; To call this routine from C use the following statement:
;
;	FindMSMouse(&VersionNumber, &MouseType);
;
;    where VersionNumber is a hexidecimal value containing the version
;    number of the Microsoft driver found.  The upper half of the word
;    contains the major version number and the lower half, the minor
;    version number (e.g. version 6.25 will be 0x625).  MouseType is 
;    the type of driver found.
;
;		MouseType	Type of Driver
;		---------	--------------
;		    0		Regular Mouse Driver
;		    1		Integrated Mouse Driver
;		    2		HP Mouse Driver
;
;    This function returns FALSE (0) if no Microsoft Mouse driver is
;    found and a non-zero value if a MS driver is found.
;
;**************************************************************************

;**************************************************************************
;   E Q U A T E S
;**************************************************************************

FALSE	equ	0
TRUE	equ	1

IRET_OPCODE	equ	0CFh		; op-code for IRET


;  Magic values following copyright notice in our drivers

MOUSE3_THRU_6	equ	5564h		; Mouse versions 3.00 => 6.00
MOUSE6_THRU_624	equ	557Ch		; Mouse versions 6.01Z => 6.24
MOUSE625	equ	0E806h		; Mouse version 6.25
MOUSE7		equ	0EB02h		; Mouse versions 6.26 => 7.04
INTMOUSE	equ	0800h		; Integrated mouse
;  Versions greater than 7.04 use their version number as the magic value
;  (e.g. Version 7.05 has 0507 as its magic value)


MS_STRING1_LEN	equ	23		; Length of MS_String1
MS_STRING2_LEN	equ	14		; Length of MS_String2


_TEXT	segment para public 'CODE'

;**************************************************************************
;   D A T A
;**************************************************************************

;  Copyright notice found in all drivers.  It is split in two because
;  drivers before 7.00 don't have the '-19??' following '1983' while
;  all drivers from 7.00 on, do have this extra text.
MS_String1	db	" This is Copyright 1983"
MS_String2	db	" Microsoft ***"
Version		dw	0
MouseType	dw	0


;**************************************************************************
;   C O D E
;**************************************************************************

	assume	cs:_TEXT, ds:nothing, es:nothing, ss:nothing

	public	_FindMSMouse

;--------------------------------------------------------------------------
; int FindMSMouse(&Version, &MouseType)
;
; Returns:  0 => Don't install mouse driver
;          !0 => OK to install mouse driver
;--------------------------------------------------------------------------

ifdef MODEL_MEDIUM
_FindMSMouse	proc	far
else
ifdef MODEL_COMPACT
_FindMSMouse	proc	near
else
ifdef MODEL_LARGE
_FindMSMouse	proc	far
else
	syntax error, small model not supported.
endif
endif
endif

	push	bp			; Set up for C entry
	mov	bp,sp

	push	ds			; Set DS to CS
	mov	ax,cs
	mov	ds,ax
	assume	ds:_TEXT

;  Get INT 33 vector and verify it is pointing to something
	mov	ax,3533h
	int	21h
	assume	es:nothing
	mov	ax,es			; Verify ES:BX is not 0:0
	or	ax,bx
	jz	TO_NOT_MSDRIVER
	cmp	byte ptr es:[bx],IRET_OPCODE	; Verify ES:BX doesn't point
	jne	@F				;    to an IRET

TO_NOT_MSDRIVER:
	jmp	NOT_MSDRIVER

@@:
;  Get the version number for a 'm' call (needed for pre 6.00 versions 
;  which didn't support function 36 and for version which contained errors)
	sub	di,di
	mov	ax,'m'
	int	33h
	or	di,di			; Is 'm' function call implemented?
	je	GET_ALT_VERSION_NUMBER	;  No - use function 36
	mov	bx,es:[di]		; Get version number
	xchg	bh,bl			; Put Major in BH and Minor in BL
	cmp	bh,3			; Is version < 3.00?
	jb	TO_NOT_MSDRIVER		;  Yes - done
	cmp	bh,5			; Is version > 5.00?
	jbe	CHECK_ID		;  No - skip
	cmp	bh,6			; Is version > 6.01?
	ja	GET_ALT_VERSION_NUMBER	;  Yes - get driver type
	cmp	bl,2
	jb	@F			;  No - continue

GET_ALT_VERSION_NUMBER:
;  Get MOUSE version number and driver type through a function call 36
	sub	bx,bx
	mov	ax,36
	int	33h
	or	bx,bx			; Was function 36 implemented?
	je	TO_NOT_MSDRIVER		;  No - done
	cmp	ch,5			; HP Driver?
	jne	@F			;  No - skip
	mov	word ptr [MouseType],2	; Flag HP Driver 

@@:
;  If the driver identifies itself as 6.01 it may be 6.01 or 6.00 so
;  we need to figure out the difference.
	cmp	bx,601h			; Is it 6.00 or 6.01?
	jne	CHECK_ID		;  No - skip
	cmp	di,1ABh			; Is it really 6.00?
	jne	CHECK_ID		;  No it's 6.01
	sub	bl,bl			; Make it 6.00

CHECK_ID:
	mov	[Version],bx		; Return version number

;  Check the ID string in the driver for our string
	mov	cx,bx			; Save version number
	mov	ax,3533h		; Make sure ES points to MOUSE code
	int	21h
	assume	es:nothing
	mov	bx,cx			; Recover version number
	mov	ax,"**"			; Search first 1000h bytes for
	sub	di,di			;   copyright string (begins with '***')
	mov	dx,800h

CONTINUE_SEARCH:
	mov	cx,dx			; Get length of search
	repne scasw			; Find '***'
	or	cx,cx			; Was '***' found?
	jz	NOT_MSDRIVER		;  No - done
	cmp	es:[di],al		; Skip past all three *'s
	jne	DONT_SKIP
	inc	di

DONT_SKIP:
	mov	dx,cx			; Save remaining length of search
	mov	si,offset _TEXT:MS_String1	; Compare first half of
	mov	cx,MS_STRING1_LEN		;   copyright string
	repe cmpsb
	or	cx,cx			; Was first half there?
	jne	CONTINUE_SEARCH		;  No - search for next '***'
	cmp	bh,7			; Is the version number >= 7
	jb	CHECK_END_OF_STRING	;  No - check last half of copyright
	add	di,5			;  Yes - skip '-19??' characters

CHECK_END_OF_STRING:
	mov	si,offset _TEXT:MS_String2	; Compare last half of
	mov	cx,MS_STRING2_LEN		;   copyright string
	repe cmpsb
	or	cx,cx			; Was last half there?
	jne	CONTINUE_SEARCH		;  No - search of next '***'

	mov	cx,es:[di+1]		; Get Magic number
	cmp	bh,5			; Is version > 5.03?
	ja	VERSION_6		;  Yes - try versions 6+

VERSION_3:
	cmp	cx,MOUSE3_THRU_6	; Was the Magic number there?
	jmp	short BRANCH

VERSION_6:
	cmp	bh,6			; Is version > 6.26?
	jne	VERSION_7		;  Yes - try versions 7+
	or	bl,bl			; Is it version 6.00?
	je	VERSION_3		;  Yes - check 6.00 magic number
	cmp	bl,26h			; Is it version 6.26?
	je	VERSION_626		;  Yes - check 6.26 magic number
	cmp	bl,25h			; Is it version 6.25?
	je	VERSION_625		;  Yes - check 6.25 magic number
	cmp	cx,MOUSE6_THRU_624	; Was the Magic number there?
	jmp	short BRANCH

VERSION_625:
	cmp	cx,MOUSE625		; Was the Magic number there?
	jmp	short BRANCH

VERSION_7:
	cmp	bh,7			; Is version > 7.04?
	ja	VERSION_8		;  Yes - try 7.05+
	cmp	bl,4
	ja	VERSION_8		;  Yes - try 7.05+

VERSION_626:
	cmp	cx,MOUSE7		; Was the Magic number there?

BRANCH:
	je	MSDRIVER_FOUND		; Jif Magic number found

NOT_MSDRIVER:
	sub	ax,ax			; Flag not an MS mouse driver
	jmp	short EXIT		; Done

INTDRIVER:
	mov	word ptr [MouseType],1	; Flag Integrated Driver
	sub	word ptr [Version],900h	; Convert from A.xx to 1.xx
	cmp	cx,INTMOUSE		; Was the Magic number there?
	jmp	BRANCH

VERSION_8:
	cmp	bh,0Ah			; Integrated driver?
	je	INTDRIVER		;  Yes - check its magic number
	mov	cx,es:[di]		; Get version number (Magic number
					;   for versions 7.05+)
	cmp	bh,cl			; Make sure version numbers match
	jne	NOT_MSDRIVER
	cmp	bl,ch
	jne	NOT_MSDRIVER

MSDRIVER_FOUND:
	mov	al,TRUE			; Flag MS mouse driver found

EXIT:
	mov	cx,[Version]
	mov	dx,[MouseType]
	pop	ds			; Clean-up and exit
ifdef MODEL_MEDIUM
	mov	bx,[bp+6]		; Return version number
	mov	[bx],cx
	mov	bx,[bp+8]		; Return driver type
	mov	[bx],dx
else
ifdef MODEL_COMPACT
	mov	bx,[bp+4]		; Return version number
	mov	[bx],cx
	mov	bx,[bp+6]		; Return driver type
	mov	[bx],dx
else
ifdef MODEL_LARGE
	push	es
	les	bx,[bp+6]		; Return version number
	mov	es:[bx],cx
	les	bx,[bp+10]		; Return driver type
	mov	es:[bx],dx
        pop	es
else
	syntax error, small model not supported
endif
endif
endif
	pop	bp
	ret

_FindMSMouse	endp

_TEXT	ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hardware\ramdrv.c ===
/***************************************************************************/
/* 																								*/
/* RAMDRV.C																						*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* Checks to see if RAMDRV is loaded by examining the label on each 			*/
/* non-removable disk on the sytem looking for the label "MS-RAMDR.IVE		*/
/* and then using the entry's date as the version number. The search			*/
/* will stop after the first non-local drive is detected.						*/
/*																									*/
/*	unsigned GetRamDrive( void )															*/
/*																									*/
/* ARGUMENTS:	NONE																			*/
/*	RETURN:		unsigned	- Ram drive internal revision number.					*/
/*																									*/
/* Created 08-26-90 - johnhe																*/
/***************************************************************************/

#include		<stdio.h>
#include		<stdlib.h>
#include		<string.h>
#include		<dos.h>

#include		<alias.h>
#include 	<disk_io.h>

/***************************************************************************/

unsigned GetRamDrive( void )
{
	static char			RamDrv[] = "X:\\MS-RAMDR.IVE";
	register				Drv;
	unsigned				uDate;
	struct find_t		Info;

	for ( uDate = 0, RamDrv[0] = 'C';
			uDate == 0 && IsReallyValidHardDrive( RamDrv[ 0 ] );
			RamDrv[0]++ )
	{
		Drv = (int)RamDrv[0] - 'A' + 1;
		if ( !IsRemoveable( Drv ) && IsLocalDrive( Drv) )
		{
			if ( _dos_findfirst( RamDrv, _A_VOLID, &Info ) == OK )
				uDate = Info.wr_date;

							/* This findfirst works around a bug in old versions	*/
							/* of DOS which happens when doing a findfirst for		*/
							/* a volume ID.													*/

			_dos_findfirst( RamDrv, _A_NORMAL, &Info );
		}
	}

	return( uDate );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hardware\smartdrv.asm ===
;========================================================
COMMENT #

	SMARTDRV.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================

	 Function returns the SMARTDRV version number if it's present else 0

	 unsigned GetSmartDrvVer( void )
 
	 ARGUMENTS:	NONE
	 RETURNS:	unsigned - Smartdrv internal revision number or 0

	================================================

    PAK - 04-30-92

    This only works on SD4 or greater. This is OK since we are testing
    for version greater than 4.

END COMMENT #
; =======================================================

INCLUDE	model.inc

; =======================================================

.CODE

;*--------------------------------------------------------------------------*
;*
;*  GetSmartDrvVersion - Detects presence of Bambi software (Disk Cache)
;*                       (Smartdrv.EXE ver 4.00 or greater)
;*
;*  Returns AX non-zero (version) if Bambi present (TRUE)
;*  Returns AX = zero if Bambi not present (FALSE)
;*
;*--------------------------------------------------------------------------*
GetSmartDrvVer PROC USES ES BX SI DI

      push      bp
      mov       ax,4a10h
      mov       bx,0h
      mov       bp,0h
      int       2fh
      mov       dx, bp              ; save version in case SD4 is installed
      pop       bp                  ; restore bp
      cmp       ax, 0BABEh          ; Is return value BABE
      je        BambiPresent        ; YES, SD4 is installed - Get version.
      xor       ax,ax               ; NO, return FALSE.
      jmp short IBI_Exit            ; Version is not defined.

BambiPresent:
      mov       ax, dx              ; DX contains SD4 version #

IBI_Exit:      
	  ret                           ; return to caller.

GetSmartDrvVer ENDP

; =======================================================

	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hdisk\getsec.c ===
/***************************************************************************/
/*																									*/
/*	GETSECT.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Calculates the total sectors on a hard disk based on the values in a 	*/
/* hard disk parameters structure.														*/
/* 																								*/
/* UL GetTotalHdSectors( struct HdParms *Parms )									*/
/* 																								*/
/* ARGUMENTS:	Parms 			- Ptr to hard disk parameters structure		*/
/* RETURNS: 	unsigned long	- Total physical sectors on the hard disk		*/
/* 																								*/
/* NOTE: 																						*/
/* 		Need to remember that heads and cylinders begin with 0 and			*/
/* 		sectors begin with 1.															*/
/* 																								*/
/* Created 02-07-90 johnhe																	*/
/***************************************************************************/

#include		<alias.h>
#include 	<hdisk.h>


UL GetTotalHdSectors( struct HdParms *Parms )
{
	return( (UL)(Parms->MaxHead+1) *
			  (UL)(Parms->MaxSec) *
			  (UL)( Parms->MaxCyl+1) );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hdisk\findpart.c ===
/***************************************************************************/
/*																									*/
/*	FINDPART.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Scans a partition map and returns the index to the largest free area.	*/
/* If no free partition area is found it returns -1.								*/
/*																									*/
/* int FindMaxFreePart( struct PartMap *Map )										*/
/*																									*/
/*	ARGUMENTS:	Map	- Ptr to partition map											*/
/*	RETURNS:		int	- Index to largest free area in the map or -1 if no	*/
/*							  free area is found												*/
/*																									*/
/* Created 02-09-90 johnhe																	*/
/***************************************************************************/

#include		<alias.h>
#include 	<hdisk.h>

int FindMaxFreePart( struct PartMap *Map )
{
	register		i;							/* Loop indice 								*/
	register		iBigFree;				/* Index to largest free parition		*/
	UL				ulBiggest; 				/* Sectors in biggest free partition	*/

	ulBiggest = 0L;
	iBigFree = -1; 						/* Signals no free parition				*/

	for ( i = 0; i < MAX_MAP_ENTRIES; i++, Map++ )
	{
	 	if ( Map->PartType == 0 && Map->TotalSecs > ulBiggest )
		{
			ulBiggest = Map->TotalSecs;
			iBigFree = i;
		}
	}
	return( iBigFree );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hardware\syquest.asm ===
;========================================================
COMMENT #

	SYQUEST.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================

	 Function that checks for a Syquest removeable
	 hard disk device driver.

	 int far SyquestCheck ( void )
 
	 ARGUMENTS:	NONE
	 RETURNS:	int - TRUE if Syquest device
			      driver is installed
			      else FALSE.

	================================================

	johnhe - 08-20-90

END COMMENT #
; =======================================================

INCLUDE model.inc

; =======================================================

.DATA

SyquestStr	db	'SYQ'

LEN_SYQUEST_STR	EQU	$-SyquestStr

.Code

; =======================================================

SyquestCheck PROC FAR USES SI DI DS ES
	ASSUME	ES:NOTHING

	mov	AH,52h
	int	21h			; ES:BX --> first DBP

	push	BX			; Save offset
	mov	AH,30h
	int	21h			; AL == Major version
	pop	DI			; Restore DPB offset to BX

	add	DI,17h			; DOS 2.x offset of NULL device is 17h
	cmp	AL,2			; See if version is really 2.x
	jle	@f
	add	DI,0bh			; Offset for DOS > 2.x is 22h
@@:
	mov	AX,@DATA
	mov	DS,AX

	mov	SI,OFFSET SyquestStr
	mov	CX,LEN_SYQUEST_STR
	cld

NameCmpLoop:
	cmp	DI,0ffffh		; See if ES:DX is xxxx:ffff
	je	NoSyquest

SaveSetup:
	push	CX			; Save name length
	push	DI			; Save ptr to current device
	push	SI			; Save ptr to Syquest string
	add	DI,0ah			; ES:DI --> Device name
	
	repe	cmpsb
	pop	SI
	pop	DI
	pop	CX

	je	IsSyquest
	les	DI,ES:[DI]		; Load ptr to next device.
	jmp	SHORT NameCmpLoop

NoSyquest:
	xor	AX,AX
	jmp	SHORT SyquestReturn

IsSyquest:
	mov	AX,1

SyquestReturn:
	ret

SyquestCheck ENDP

; =======================================================

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hardware\vfeat.asm ===
;========================================================
COMMENT #

	VFEAT.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================

	 Function that checks for the Vfeature hard disk
	 device driver.

	 int far VfeatureCheck ( void )
 
	 ARGUMENTS:	NONE
	 RETURNS:	int - TRUE if Vfeature device
			      driver is installed
			      else FALSE.

	================================================

	johnhe - 08-20-90

END COMMENT #
; =======================================================

INCLUDE model.inc

; =======================================================

.DATA

VfeatureStr	db	'Vfeature'

LEN_VFEATURESTR	EQU	$-VfeatureStr

.Code

; =======================================================

VfeatureCheck PROC FAR USES SI DI DS ES
	ASSUME	ES:NOTHING

	mov	AH,52h
	int	21h			; ES:BX --> first DBP

	push	BX			; Save offset
	mov	AH,30h
	int	21h			; AL == Major version
	pop	DI			; Restore DPB offset to BX

	add	DI,17h			; DOS 2.x offset of NULL device is 17h
	cmp	AL,2			; See if version is really 2.x
	jle	@f
	add	DI,0bh			; Offset for DOS > 2.x is 22h
@@:
	mov	AX,@DATA
	mov	DS,AX

	mov	SI,OFFSET VfeatureStr
	mov	CX,LEN_VFEATURESTR
	cld

NameCmpLoop:
	cmp	DI,0ffffh		; See if ES:DX is xxxx:ffff
	je	NoVfeature

SaveSetup:
	push	CX			; Save name length
	push	DI			; Save ptr to current device
	push	SI			; Save ptr to vFeature string
	add	DI,0bh			; ES:DI --> Device name + 1
	
	repe	cmpsb
	pop	SI
	pop	DI
	pop	CX

	je	IsVfeature
	les	DI,ES:[DI]		; Load ptr to next device.
	jmp	SHORT NameCmpLoop

NoVfeature:
	xor	AX,AX
	jmp	SHORT VfeatureReturn

IsVfeature:
	mov	AX,1

VfeatureReturn:
	ret

VfeatureCheck ENDP

; =======================================================

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hdisk\fmtboot.c ===
/***************************************************************************/
/*																									*/
/*	FMTBOOT.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Determines if a boot record if from a partition that was formatted		*/
/* under any version of DOS. Checks for proper opcode in the first 3 bytes */
/* (e9,XX,XX or eb,XX,90).																	*/
/* 																								*/
/* int IsFmtedBoot( char *SectorBuf )													*/
/* 																								*/
/* ARGUMENTS:	SectorBuf	- Ptr to buf holding the boot sector to check	*/
/* RETURNS: 	int			- TRUE if a formatted boot record else FALSE 	*/
/*																									*/
/* Created 02-07-90 johnhe																	*/
/***************************************************************************/

#include		<alias.h>
#include 	<hdisk.h>
#include 	<disk_io.h>

#define	SECTOR_SIZE		512

unsigned IsFmtedBoot( char *SectorBuf )
{
	struct BPB	*Bpb;

	Bpb = (struct BPB *)(SectorBuf + 11);
	
	if ( Bpb->uBytesPerSec < SECTOR_SIZE ||
		  (Bpb->uBytesPerSec % SECTOR_SIZE) ||
		  (Bpb->uchMediaDescr != (UCHAR)0xf8 &&
		   Bpb->uchMediaDescr != (UCHAR)0xfa) ) 
		return( FALSE );
	return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hdisk\hd_isfmt.asm ===
;========================================================
COMMENT #

	HD_ISFMT.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	johnhe 02-18-90


	NOTE:

	Becasue of bugs in the DOS BIOS this function doesn't work so
	use a function which reads the boots sector to find out.

END COMMENT #
; ===========================================================================

INCLUDE	model.inc

; ===========================================================================

diskaccess struc

	dac_special_func	db	?
	dac_access_flag 	db	?

diskaccess ends

GET_ACCESS EQU 0867h

; =======================================================

.CODE

; ===========================================================================
;
; This routine will invoke INT21 44h (Block Generic IOCTL Subfunction)
; call to see if the drive has been previously formatted by using an
; undocumented call.
;
; int IsFormatted( char DriveLetter, struct diskaccess *Dac )
;
; ARGUMENTS:	DriveLetter	- DOS drive letter (MUST be uppercase)
;
; RETURNS:	int         - TRUE if drive is formatted
;                            FALSE if not formatted
; ===========================================================================

; BUGBUG - (jah) - No need to preserver BX or CX in a C callable function

IF @DataSize
  HdIsFormatted PROC USES DS BX CX, DriveLetter:BYTE, Dac:PTR
ELSE
  HdIsFormatted PROC		    DriveLetter:BYTE, Dac:PTR
ENDIF
	mov	AX,440dh		; DOS generic IOCTL check media
	xor	BH,BH			; BH == 0
	mov	BL,DriveLetter		; BL == Drive letter
	sub	BL,'A'			; BL == DOS drive number
        inc     BL             	 	; 1 ==> 'A', 2==> 'B', etc.
	mov	CX,GET_ACCESS		; CX == Get format status

;	lds	DX,Dac			; DS:DX --> Dac struc
	LoadPtr	DS, DX, Dac		; DS:DX --> Dac struc

	int	21h			; DOS call

	mov	BX,DX			; DS:BX --> Dac struc
	xor	AX,AX			; Assume not formatted

	or	[BX].dac_access_flag,11111111b ; Check format status flag
	jz	HdIsFormattedReturn
	mov	AX,01			; Signal disk if formatted

HdIsFormattedReturn:
	ret

HdIsFormatted ENDP

END



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hdisk\hd_parms.asm ===
;========================================================
COMMENT #

	DSK_PARM.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================

	Gets the drive parameters for the specified hard
	and uses them to fill in the HdParms structure
	passed as an argument.

	int GetDrvParms( struct HdParms *Parms, int DrvNum )

	ARGUMENTS:	Parms	- Ptr to hdParms structure
			DrvNum	- Physical hard disk number
	RETURNS:	int	- 0 if successful
				- !0 if error (invalid drive)

	=================================================

	STRATEGY:
		Does an int 13h function 8h which returns:
			CH = Low 8 bits of max cylinder num
			CL = Bits 6&7 high order bytes of
			     max cylinder num
			     Bits 0-5 max sector num
			DH = Max head num
			DL = Number of drives (ignored)

	=================================================

	johnhe - 02/07/99

END COMMENT #
; =======================================================

INCLUDE	model.inc

; =======================================================

HdParms STRUC

	MaxHead 	dw	?
	MaxSec		dw	?
	MaxCyls 	dw	?

hdParms ENDS

; =======================================================

.CODE

; =======================================================
;  NOTE:
;	ES and DIS must be saved on entry because the int
;	13h call return a ptr to the disk parameters in
;	these registers.
; =======================================================

IF @DataSize
  GetDrvParms PROC USES DS ES DI, Parms:PTR, DrvNum:BYTE
ELSE
  GetDrvParms PROC USES    ES DI, Parms:PTR, DrvNum:BYTE
ENDIF
	mov	AH,8h			; Get drive parms function
	mov	DL,DrvNum		; Load drive number
	int	13h			; BIOS disk access

	jc	GetDrvParmsExit 	; Error check

;	lds	BX,Parms		; Load ptr to parms structure
	LoadPtr	DS, BX, Parms		: DS:BX --> Drive parameters struct

					; AH == 0 if we got here
	xor	AH,AH			; but I don't trust all BIOSs
	mov	AL,DH			; Move heads to DL
	mov	[BX].MaxHead,AX		; Store max head in struc

	mov	AL,CL			; Put max sect number in AL
	and	AL,00111111b		; Mask off low 6 bits
	mov	[BX].MaxSec,AX		; Store max sector in struc

	xchg	CH,CL			; Move CH to low byte
	rol	CH,1			; Make bits 6&7 low 2 bits
	rol	CH,1
	and	CH,00000011b		; Mask off 2 low bits
	mov	[BX].MaxCyls,CX 	; Save max cylinder in struc
	xor	AX,AX			; Signal OK

GetDrvParmsExit:
	ret

GetDrvParms ENDP

END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hdisk\isdosprt.c ===
/***************************************************************************/
/*																									*/
/*	ISDOSPRT.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Checks a partition entry type to see if it is a valid DOS primary 		*/
/* partition.																					*/
/* 																								*/
/* VALID PARTITION TYPES:																	*/
/* 																								*/
/* DOS12  == 1 == FAT file system - 12 bit FAT										*/
/* DOS16  == 4 == FAT file system - 16 bit FAT										*/
/* DOSNEW == 6 == FAT file sytem	 - huge partition > 32 meg						*/
/* 																								*/
/* 																								*/
/* int IsDosPart( unsigned char PartitionType ) 									*/
/* 																								*/
/* ARGUMENTS:	PartitionType	- Partition type as found in partition table */
/* RETURNS: 	int				- TRUE if DOS primary partition else false	*/
/* 																								*/
/* Created 02-07-90 johnhe																	*/
/***************************************************************************/

#include		<alias.h>
#include 	<hdisk.h>

unsigned IsDosPart( unsigned char PartitionType )
{
	return( PartitionType == (UCHAR)DOS12 ||
			  PartitionType == (UCHAR)DOS16 ||
			  PartitionType == (UCHAR)DOSNEW );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hdisk\map_ent.c ===
/***************************************************************************/
/*																									*/
/*	MAP_ENT.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Creates a partition map entry from a partition entry structure.			*/
/* 																								*/
/* void CreateMapEntry( struct PartMap *Map, struct Part *Part )				*/
/* 																								*/
/* ARGUMENTS:	Map	-	Ptr to partition map structure							*/
/* 				Part	-	Ptr to partition table entry								*/
/* RETURNS: 	void																			*/
/* 																								*/
/* Created 02-07-90 johnhe																	*/
/***************************************************************************/

#include		<alias.h>
#include 	<hdisk.h>

void CreateMapEntry( struct PartMap *Map, struct Part *Part )
{
	Map->PartType	= Part->SystemIndicator;
	Map->StartSec	= Part->RelativeSector;
	Map->EndSec		= Part->RelativeSector + Part->TotalSectors - 1;
	Map->TotalSecs = Part->TotalSectors;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hdisk\is_dos4.c ===
/***************************************************************************/
/*                                                                         */
/* IS_DOS4.C                                                               */
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Determines if a BPB in a boot record is compatible with DOS 4.x. The    */
/* boot sector must have already been read in the global sector buffer.    */
/* First checks 512 bytes per sector, then maximum root directory entries  */
/* and then makes sure there is not a conflict in the total number of      */
/* sectors.                                                                */
/*                                                                         */
/* int IsDos4Compat( void )                                                */
/*                                                                         */
/* ARGUMENTS:  NONE                                                        */
/* RETURN:     int   - TRUE is BPB is DOS 4.x compatible else FALSE        */
/*                                                                         */
/* Created 02-07-90 johnhe                                                 */
/***************************************************************************/

#include <alias.h>
#include <disk_io.h>
#include <hdisk.h>

unsigned IsDos4Compat(char *SectorBuf)
{
   struct BPB *Bpb;

   Bpb = (struct BPB *)(SectorBuf + BPB_OFFSET);

   if ((Bpb->uBytesPerSec == (unsigned)BYTES_PER_SECTOR)

/*
** Yank these checks since they unnecessarily restrict us from installing on
** DOS 2.x and 3.x disks.
**
**    &&
**     (Bpb->uRootEntries <= (unsigned)MAX_DIR_ENTRIES)
**    &&
**     ((Bpb->uTotalSectors == 0U && Bpb->ulTotalBigSecs == 0UL) ||
**      (Bpb->uTotalSectors != 0U && Bpb->ulTotalBigSecs == 0UL) ||
**      (Bpb->uTotalSectors == 0U && Bpb->ulTotalBigSecs != 0UL))
*/

      )
      return(TRUE);

   return(FALSE);
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hdisk\makepart.c ===
/***************************************************************************/
/*																									*/
/*	MAKEPART.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Builds a DOS paritition entry from a partition map entry. Determines 	*/
/* the type of DOS partition needed based on the number of sectors in the	*/
/* partition area. To be compatible with all previous versions of DOS the	*/
/* partition will start the first sector of a cylinder and end on the last */
/* sector of a cylinder.																	*/
/*																									*/
/* BuildDosPartEntry( struct PartMap *Map, struct HdParms *Parms,				*/
/*						 struct Part *PartEntry )											*/
/*																									*/
/*	ARGUMENTS:	Map		- Ptr partition map entry									*/
/*					Parms		- Ptr to an initialize hard disk parameters struct	*/
/*					PartEntry- Ptr to partitin entry to be filled in				*/
/*	RETURNS:		void																			*/
/*																									*/
/* NOTE: Must remember that heads and cylinders are 0 based while sectors	*/
/*			are 1 based.																		*/
/*																									*/
/*	Head = ((AbsSector % SectorPerTrack) * NumberOfHeads) / SectorsPerTrack	*/
/*	Track =	AbsSector / ( NumberOfHeads * SectorsPerTrack )						*/
/*	Sector = (absSector % SectoPerTrack) + 1											*/
/*																									*/
/* Created 02-09-90 johnhe																	*/
/***************************************************************************/

#include		<alias.h>
#include 	<hdisk.h>

#define MAX_SECTORS_PER_PARTITION   (0x7FFFFFFEL / 512L)

void BuildPartEntry( struct PartMap *Map, struct HdParms *Parms,
							struct Part *Part )
{
	UINT		uSecPerCyl;								/* Sectors per cylinder			*/
	UINT		uHeads;									/* Total number of heads		*/
	UINT		uCyl;		 								/* Tmp cylinder holder			*/
	UL			ulAbsCyl;								/* Total track count  			*/
	UL			ulTmp;									/* Hold abs starting cylinder */

	uHeads = Parms->MaxHead + 1;
	uSecPerCyl = Parms->MaxSec;

				/* Determine the starting head, sector and cylinder alway		*/
				/* rounding up to the first sector next cylinder boundary		*/

	ulAbsCyl = (Map->StartSec + (UL)(uSecPerCyl-1)) / (UL)uSecPerCyl;
	uCyl = (UINT)(ulAbsCyl / uHeads); /* + (ulAbsCyl % uHeads); */

	Part->StartHead = (UCHAR)( ulAbsCyl % uHeads );
	Part->StartCylinder = (UCHAR)( uCyl & 0x00ff );			/* Cyl low 8 bits	*/

										/* Move cyl bits 9 & 8 to sector bits 7 & 6	*/
	Part->StartSector = (UCHAR)( (uCyl >> 2) & 0xc0 );
	Part->StartSector	|= 1; 									/* Always sector 1	*/

				/* Determine the ending head, sector and cylinder always 		*/
				/* rounding down to the last sector on the last full cylinder	*/

	ulTmp = ulAbsCyl;												/* Save starting cyl	*/

	/* Is this partition going to be too large (2Gig limit) */

	if (Map->EndSec - Map->StartSec > MAX_SECTORS_PER_PARTITION)
		ulAbsCyl = ((Map->StartSec + MAX_SECTORS_PER_PARTITION) -
                 (UL)(uSecPerCyl-1)) / (UL)uSecPerCyl;
	else
		ulAbsCyl = (Map->EndSec - (UL)(uSecPerCyl-1)) / (UL)uSecPerCyl;

	uCyl = (UINT)(ulAbsCyl / uHeads);				/*  + (ulAbsCyl % uHeads); */
   if (ulAbsCyl % uHeads != Parms->MaxHead)    
      uCyl--;                                   /* eliminate partial cyl   */

	Part->EndHead = (UCHAR)( Parms->MaxHead );
	Part->EndCylinder = (UCHAR)( uCyl & 0x00ff );			/* Cyl low 8 bits	*/

										/* Move cyl bits 9 & 8 to sector bits 7 & 6	*/
	Part->EndSector = (UCHAR)( (uCyl >> 2) & 0xc0 );
	Part->EndSector |= (UCHAR)uSecPerCyl;				/* Always last sector	*/

				/* Determine relative start sector and then find total sectors	*/
				/* by finding end cylinder + 1 and subtracting start sector 	*/

	Part->RelativeSector = ulTmp * (UL)uSecPerCyl;
	Part->TotalSectors = (UL)(uCyl + 1) * (UL)uSecPerCyl * (UL)uHeads - (UL)(Part->RelativeSector);

	if ( Map->TotalSecs <= FAT16_SIZE )
		Part->SystemIndicator = (UCHAR) DOS12;
	else
		Part->SystemIndicator = (UCHAR) (Map->TotalSecs <= DOS_MAX ? DOS16 : DOSNEW);

}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hdisk\partboot.asm ===
;========================================================
COMMENT #

	PARTBOOT.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	=================================================

	Reads in the first sector (boot	record) of a hard
	disk partition.

	int ReadPartBootRec( struct Part *PartEntry, void *Buffer,
			     int DrvNum );

	ARGUMENTS:	PartEntry - Partition table entry structure
			Buffer	- Ptr to read buffer of 512 bytes
			DrvNum	- Physical hard disk number
	RETURNS:	int	- 0 if successful
				- !0 if error

	=================================================

	STRATEGY:

		Does an int 13h function 2 which reads a
		disk sector based on the following register
		settings which are taken from the passed
		parameters.

			AL = Number of sectors to read
			CH = Low 8 bits of max cylinder num
			CL = Bits 6&7 high order bytes of
			     max cylinder num
			     Bits 0-5 max sector num
			DH = Max head num
			DL = Number of drives (ignored)
			ES:BX = Ptr to buffer in memory

	=================================================

	johnhe - 02/07/99

END COMMENT #
; =======================================================

PartitionInfo	struc

	BootSig		db	?
	StartHead	db	?
	StartSector	db	?
	StartCyl 	db 	?

	PartType 	db 	?
	EndHead		db 	?
	EndSec		db 	?
	EndCyl		db 	?
	RelativeSec	dd	?
	TotalSecs	dd 	?

PartitionInfo	ends

; =======================================================

INCLUDE	model.inc

; =======================================================

.CODE

; =======================================================

IF @DataSize
  ReadPartBootRec PROC USES DS ES, PartEntry:PTR, Buffer:PTR, DrvNum:BYTE
ELSe
  ReadPartBootRec PROC             PartEntry:PTR, Buffer:PTR, DrvNum:BYTE
ENDIF

;	lds	BX,PartEntry		; DS:BX -> partition table entry
	LoadPtr	DS, BX, PartEntry	; DS:BX -> partition table entry

	mov	DH,[BX].StartHead	; DH == Disk head number
	mov	CX,WORD PTR [BX].StartSector ; CH == Cylinder, CL == Sector

	mov	DL,DrvNum		; DL == Physical disk number

;	les	BX,Buffer		; ES:BX -> Sector buffer
	LoadPtr	ES, BX, Buffer		; ES:BX -> Sector buffer

	mov	AX,0201h		; AH == Disk read, AL = 1 sector
	int	13h			; ROM BIOS disk access
	mov	AX,-1			; Setup for possible error
	jc	ReadBootRecExit		; Error check
	xor	AX,AX			; Signal no error

ReadBootRecExit:
	ret

ReadPartBootRec ENDP

; =======================================================

IF @DataSize
  WritePartBootRec PROC USES DS ES, PartEntry:PTR, Buffer:PTR, DrvNum:BYTE
ELSE
  WritePartBootRec PROC             PartEntry:PTR, Buffer:PTR, DrvNum:BYTE
ENDIF


;	lds	BX,PartEntry		; DS:BX -> partition table entry
	LoadPtr	DS, BX, PartEntry	; DS:BX -> partition table entry
	mov	DH,[BX].StartHead	; DH == Disk head number
	mov	CX,WORD PTR [BX].StartSector ; CH == Cylinder, CL == Sector

	mov	DL,DrvNum		; DL == Physical disk number

;	les	BX,Buffer		; ES:BX -> Sector buffer
	LoadPtr	ES, BX, Buffer		; ES:BX -> Sector buffer

	mov	AX,0301h		; AH == Disk read, AL = 1 sector
	int	13h			; ROM BIOS disk access
	mov	AX,-1			; Setup for possible error
	jc	WriteBootRecExit	; Error check
	xor	AX,AX			; Signal no error

WriteBootRecExit:
	ret

WritePartBootRec ENDP

; =======================================================


END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\hdisk\partmap.c ===
/***************************************************************************/
/*																									*/
/*	PARTMAP.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Builds a map of the entire partition layout of a hard disk. The map is	*/
/* sorted by physical starting disk sectors and contains all free and		*/
/* allocated areas of the disk.															*/
/* 																								*/
/* BuildPartMap( struct Part *Part, struct PartMap *Map,							*/
/*							 struct HdParms *Parms )										*/
/* 																								*/
/* ARGUMENTS:	Part	- Ptr to partition entry table to build the map from	*/
/* 				Map	- Ptr to array of at least 9 partition map structures	*/
/* 				Parms - Ptr to hard disk parameter structure 					*/
/* RETURNS:		void																			*/
/* 																								*/
/* Created 02-07-90 johnhe																	*/
/***************************************************************************/

#include		<stdio.h>

#include		<alias.h>
#include 	<hdisk.h>

UL BuildPartMap( struct Part *Part, struct PartMap *Map,	
					  struct HdParms *Parms )
{
	register 		i; 						/* Loop indice 							*/
	UL 				ulNext;					/* Start of next possible partition */
	UL 				ulMaxSec;				/* Max physical sector on the disk	*/
	UL 				ulTmpStart; 			/* Tmp holds partition start sector	*/
	UL 				ulTmpEnd;				/* Tmp hold last partition sector	*/
	UL 				ulMaxFree;				/* Largest free disk area				*/

	ulMaxSec = GetTotalHdSectors( Parms );

	ulNext = Parms->MaxSec;										/* Sector 1 track 1	*/
	ulMaxFree = 0L;

	for ( i = 0; i < MAX_PART_ENTRIES; i++ )
		if ( (Part+i)->SystemIndicator != 0 &&
			  (Part+i)->RelativeSector < ulNext )			/* Any partitions		*/
			ulNext = (Part+i)->RelativeSector;				/* start lower?		*/

	do
	{
		ulTmpEnd = ulMaxSec;
		for ( i = 0; i < MAX_PART_ENTRIES; i++ )
		{
			ulTmpStart = (Part+i)->RelativeSector;
			if ( ulTmpStart == ulNext )				/* Does a part start here? */
			{
				CreateMapEntry( Map, Part + i ); 	/* Found match so save it	*/
				break;
			}
			else if ( ulTmpStart > ulNext && ulTmpStart < ulTmpEnd )
				ulTmpEnd = ulTmpStart - 1; 		/* End of possible free area	*/
		}

		if ( i >= MAX_PART_ENTRIES )
		{									/* No partition found so mark free area	*/
			Map->PartType	= 0;
			Map->StartSec	= ulNext;
			Map->EndSec 	= ulTmpEnd;
			Map->TotalSecs = (Map->EndSec - Map->StartSec) + 1;

			if ( ulMaxFree < Map->TotalSecs )	/* See if biggest free area	*/
				ulMaxFree = Map->TotalSecs;
		}
		ulNext = Map->EndSec + 1;
		Map++;
	}
	while( ulNext < ulMaxSec );

	return( ulMaxFree );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\prompts\dfltprmt.c ===
/***************************************************************************/
/*																									*/
/* DFLTPRMT.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/* Displays a prompt asking the user if they want to use the disk format	*/
/* they have previously selected as the default for the rest of the			*/
/* program. 																					*/
/* 																								*/
/* 																								*/
/* int PromptForDefault( void )															*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	int		TRUE if user selects YES else FALSE 					*/
/* 																								*/
/*	EXTERNS:		AcceptText 		- Defined in extern.c								*/
/*					SetDefaultText	- Defined in extern.c								*/ 
/*																									*/
/* johnhe - 12/29/89																			*/
/***************************************************************************/

#include		<alias.h>
#include		<window.h>

#define		YES_NO_LINES	4

int PromptForDefault( void )
{
	char				*apszYesNo[ YES_NO_LINES ];
	char				*apszText[ MAX_STRINGS	];
	int				iSelection;
	int				iHelpFlags;

	extern UINT 	AcceptText;
	extern UINT 	SetDefaultText;

	GetMessage( apszYesNo, AcceptText );
	GetMessage( apszText, SetDefaultText );

	PushHelp( 0xffff );							/* No help is set yet				*/
	iHelpFlags = GetHelpFlags();				/* Save current help line			*/
	HelpLine( EXIT_HLP );						/* Set new help line					*/

	while ( (iSelection = PromptSelect( apszText, apszYesNo )) == PREVIOUS )
		;

	HelpLine( iHelpFlags );						/* Restore original help line		*/
	PopHelp();

	return( !iSelection );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\prompts\display.c ===
/***************************************************************************/
/*																									*/
/*	DISPLAY.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/*	Generic screen display functions.													*/
/* 																								*/
/* johnhe - 03/05/89																			*/
/***************************************************************************/

#include		<stdio.h>
#include 	<stdlib.h>
#include 	<string.h>

#include		<alias.h>
#include		<bios_io.h>
#include		<window.h>

/***************************************************************************/
/*	Displays multiple lines of text on the screen starting at the specified	*/
/* row. If the starting row is the title line the first string will be		*/
/* centered	horizonally on the screen.													*/
/*																									*/
/* void DisplayText( char *szText[], unsigned gfPrompts )						*/
/* 																								*/
/* ARGUMENTS:	szText		- array of pointers to strings. Last element		*/
/* 								  should be a NULL pointer. (max 9 strings)		*/
/* 				StartRow		- Screen row where text starts						*/
/*	RETURNS:		void																			*/
/*																									*/
/* johnhe - 03/05/89																			*/
/***************************************************************************/

void DisplayText( char **szText, int StartRow )
{
	int			i;									/* Loop counter						*/
	int			iRow;								/* Current row being displayed	*/

	for ( i = 0, iRow = StartRow; szText[i] != NULL; i++, iRow++ )
#if 0
		VideoPutsRowCol( iRow, START_COL, szText[i] );
#else
		VideoPutsAttrRowCol( iRow, START_COL, szText[i], GetBackGroundColor() );
#endif
}

/***************************************************************************/
/*	Displays a string centered horizonally on the screen starting at			*/
/* the position specified by the #define TITLE_ROW.								*/
/*																									*/
/*	void DisplayTitle( char *szTitle )													*/
/*																									*/
/*	ARGUMENTS:	szTitle	- Ptr to string to be displayed.							*/
/*	RETURNS:		void																			*/
/*																									*/
/* johnhe - 03/05/89																			*/
/***************************************************************************/

void DisplayTitle( char *szTitle )
{
	VideoPutsAttrRowCol( TITLE_ROW, CenterStr( szTitle ), szTitle,
								GetTitleColor() );
}


/***************************************************************************/
/* Displays a help line in reverse video on bottom line of the screen. The	*/
/* text displayed on the line is specified by the flags passed as an arg	*/
/* and defined by the string in the message file with the label				*/
/* HELP_LINE_TEXT each bit in the argument represents a line from the text	*/
/* group and are concatenated together and displayed as a single string.	*/
/*																									*/
/*	void HelpLine( int iFlags )															*/
/*																									*/
/*	ARGUMENTS:	iFlags	- Bit flags specifing the messages to display.		*/
/*	RETURNS:		void																			*/
/*																									*/
/*	EXTERNS:		HelpLineText - Declared in EXTERN.C									*/
/*																									*/
/* johnhe - 03/05/89																			*/
/***************************************************************************/

static int	iLastFlags;

#define		MAX_FLAGS		16
#define		MAX_HELP_ITEMS 16
#define		MAX_SCR_WIDTH	100

void HelpLine( unsigned iFlags )

{
	#define DIVIDER_COL 57

	register			i;
	char				szStr[ MAX_SCR_WIDTH ];
	static char		*apszText[ MAX_HELP_ITEMS ];
	extern UINT 	HelpLineText;

	if ( GetBackGroundColor() == 0x07 )
		iFlags &= (~KILL_COLOR);

	iLastFlags = iFlags;							/* Save flags for GetHelpFlags()	*/

			/* Load messages if this is first time called */
	if ( apszText[ 0 ] == NULL )
		GetMessage( apszText, HelpLineText );

	*szStr = 0;
	*(szStr+1) = 0;		/* For when iflags == 0 and we step over first char */
	for ( i = 0; i < MAX_FLAGS; i++, iFlags >>= 1 )
	{
		if ( iFlags & 1 )
			strcat ( szStr, apszText[i] );
	}
								/* Display line @ bottom of display */
								/* Use szStr + 1 to remove leading blank in the text*/

	VideoDupCharAttr( 24, 0, SPC, GetStatusColor(),	VideoGetWidth() ) ;
	VideoPutsRowCol( 24, 0, szStr + 1 );

	/* Display vertical divider unless messages would overlap divider. */

	if ( strlen( szStr ) <= DIVIDER_COL )
	{
#ifdef JAPAN	/* if KEISEN */
		VideoPutCharRowCol( 24, DIVIDER_COL-1, K_THIN_VERT_LINE >> 8 );
		VideoPutCharRowCol( 24, DIVIDER_COL, K_THIN_VERT_LINE & 0x00ff );
#else
		VideoPutCharRowCol( 24, DIVIDER_COL, '' );
#endif
	}

	#undef DIVIDER_COL
}


/***************************************************************************/
/* Returns a bit flag of the current help line that is displayed on the 	*/
/* bottom of the screen.																	*/
/*																									*/
/*	int GetHelpFlags( void )																*/
/*																									*/
/*	ARGUMENTS:	void																			*/
/*	RETURNS:		int		- Bit flags specifing the current messages.			*/
/*																									*/
/* johnhe - 12/06/90																			*/
/***************************************************************************/

int GetHelpFlags( void )
{
	return( iLastFlags );
}



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\prompts\dskerror.c ===
/***************************************************************************/
/*																									*/
/*	DSKERROR.C																					*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Displays an error message based on a disk error passed as an argument.	*/
/* 																								*/
/* void ProcessDiskError( int ErrorType ) 											*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURN:		void																			*/
/* 																								*/
/*	EXTERNS:		DiskErrorText	- Declared in EXTERN.C								*/
/* 																								*/
/* johnhe - 12/29/89																			*/
/***************************************************************************/

#include 	<stdio.h>

#include		<alias.h>
#include		<window.h>

void ProcessDiskError( int ErrorType )
{
	static char		*szText[] = { "", "", NULL };
	char				*szError[ MAX_STRINGS ];
	int				iHelpFlags;

	extern UINT		DiskErrorText;

	GetMessage( szError, DiskErrorText );

	szText[0] = szError[ ErrorType ];
	szText[1] = szError[ 0 ];

	PushHelp( 0xffff );							/* No help is set yet				*/
	iHelpFlags = GetHelpFlags();				/* Save current help line			*/
	HelpLine( EXIT_HLP | CONT_HLP );			/* Set new help line					*/

	Error( szText );

	HelpLine( iHelpFlags );						/* Restore original help line		*/
	PopHelp();
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\prompts\dskprmpt.c ===
/***************************************************************************/
/*																									*/
/*	DSKPRMPT.C																					*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/*	Prompts user to select the desired disk format using a scroll bar			*/
/* menu of options. 																			*/
/*																									*/
/*	int PromptForDiskFmt( int iDrvType )												*/
/*																									*/
/*	ARGUMENTS:	iDrvType		-  Type of drive: 0 = 1.2 meg : 1 = 1.44 meg		*/
/*	RETURNS:		int			- User's selection of 0 or 1							*/
/*																									*/
/*	EXTERNS:		Type525Text	- All declared in EXTERN.C								*/
/*					Type35Text																	*/
/*					DskFmtText																	*/
/*																									*/
/* johnhe - 12/29/89																			*/
/***************************************************************************/

#include		<alias.h>
#include		<window.h>

#define		TYPE_LINES	3

int PromptForDiskFmt( int iDrvType )
{
	char				*apszFmt[ TYPE_LINES ];
	char				*apszText[ MAX_STRINGS ];
	int				iSelection;
	int				iHelpFlags;

	extern UINT 	Type525Text;
	extern UINT 	Type35Text;
	extern UINT 	DskFmtText;

	GetMessage( apszFmt, iDrvType == 0 ? Type525Text : Type35Text );
	GetMessage( apszText, DskFmtText );

	PushHelp( 0xffff );							/* No help is set yet				*/
	iHelpFlags = GetHelpFlags();				/* Save current help line			*/
	HelpLine( EXIT_HLP | CONT_HLP );			/* Set new help line					*/

	while ( (iSelection = PromptSelect( apszText, apszFmt )) == PREVIOUS )
		;

	HelpLine( iHelpFlags );						/* Restore original help line		*/
	PopHelp();

	return( iSelection );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\prompts\fmtstat.c ===
/***************************************************************************/
/*																									*/
/*	FMTSTAT.C																					*/
/* 																								*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/* 																								*/
/* This function is passed as an argument to the floppy disk format			*/
/* which will call it indirectly to allow displaying the status of the 		*/
/* formatting operation. The uTrack and uHead arguments specify the status	*/
/* and are also used to indicate if the temporary window should be			*/
/* displayed or removed.																	*/
/*																									*/
/*	void FmtStat( unsigned uTrack, unsigned uHead )									*/
/*																									*/
/*	ARGUMENTS:	uTrack	- Specifies the current track being formatted or	*/
/*								  if -1 signals a popup window should be removed	*/
/*					uHead		- Specified the cureent head being formatted or		*/
/*								  if -1 signals a popup window should be displayed	*/
/*	RETURNS:		void																			*/
/*																									*/
/*	EXTERNS:		FmtStatText	- Declared in EXTERN.C as FMT_STAT_TEXT.			*/
/*																									*/
/* johnhe - 12/29/89																			*/
/***************************************************************************/

#include		<stdio.h>
#include 	<stdlib.h>
#include 	<string.h>

#include		<alias.h>
#include		<bios_io.h>
#include		<window.h>
#include		<strlib.h>

void FmtStat( unsigned uTrack, unsigned uHead )
{
	char						szStatus[25];
	int						Percent;
	int						Offset;

	static char				*OldScrn;
	static char				*Strings[ MAX_STRINGS ];
	static unsigned		uTotalTrks;
	static unsigned long	Cursor;
	static WINDOW			Window;

	extern UINT 			FmtStatText;

	*szStatus = EOL;

				/* If uHead == -1 we need to allocate some memory and then	*/
				/* save the popup area and then display the pop window.		*/

	if ( uHead == (UINT)-1 )
	{
		uTotalTrks = uTrack;
																			/*lint -e727 */
		if ( Strings[0] == NULL )
			GetMessage( Strings, FmtStatText );
																			/*lint +e727 */
		GetWindowInfo( Strings, &Window );

							/* Note: Add 2 extra rows and colums just in	*/
							/* case shadow windows are inabled				*/

		OldScrn = GetMemory( (UINT)((Window.Bottom - Window.Top + 3) *
									(Window.Right - Window.Left + 3) * 2) );
		Cursor = SaveCursor();
		VideoCursOff();
		WindowSave( &Window, OldScrn );
		PromptWindow( Strings + 1, NULL, GetPromptColor(), OldScrn );
		strcat( szStatus, Strings[0] );
		PadStr( szStatus, SPC, 21 );
	}

	else if ( uTrack == (UINT)-1	)
	{ 													/* Remove window and restore	*/
		WindowRestore( &Window, OldScrn ); 	/* the original screen			*/
		RestoreCursor( Cursor );
		FreeMemory( OldScrn );
		*szStatus = EOL;
		PadStr( szStatus, SPC, 21 );
	}

	else 												/* Update status in window		*/
	{
		strcpy( szStatus, "     " );
		Percent = (int)( (long)(uTrack + 1) * 100L / (long)(uTotalTrks) );
		Offset = Percent > 9 ? ( Percent > 99 ? 1 : 2 ) : 3;
		itoa( Percent, szStatus + Offset, 10 );
	}

	VideoPutsRowCol( 24, 58, szStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\prompts\gage.c ===
/***************************************************************************/
/*																									*/
/*	GAGE.C																						*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Functions for displaying and updating the gage on the screen.				*/
/* color as defined by the macro GetHeaderColor().									*/
/* 																								*/
/* johnhe - 07/25/90																			*/
/***************************************************************************/

#include		<stdio.h>
#include		<stdlib.h>
#include 	<string.h>

#include 	<alias.h>
#include		<window.h>
#include		<bios_io.h>

/***************************************************************************/

#ifdef JAPAN	/* if KEISEN */
static WINDOW	Gage = { 17, 20, 9, 70, 1, 0, 0, 0 }; /* Gage description	*/
#else
static WINDOW	Gage = { 17, 20, 10, 69, 1, 0, 0, 0 }; /* Gage description	*/
#endif

static char		*szCurStatus[ 2 ];
long	 			lTotalBytes;
long				lByteCount;

/***************************************************************************/
/* Displays and updates the percentage compelete gage on the screen. The	*/
/* function must first be called with a argument of 0 percent to				*/
/* initialize the display.																	*/
/*																									*/
/*	void UpdateGage( int PerCent )														*/
/*																									*/
/*	ARGUMENTS:	PerCent	- Percent to be displayed									*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

#ifndef JAPAN			/* ### if Not JAPAN ### */

void UpdateGage( int PerCent )
{
	char				szPerCent[ 10 ];
	char				*szPtr;
	char				*szRevPtr;
	register			NumCols;
	register			TotCols;
	int				i;

	if ( szCurStatus[0] == NULL)					/* See if need to initialize	*/
		DisplayGage();									  

	itoa( PerCent, szPerCent, 10 );

	szPtr = strchr( szCurStatus[0], PERCENT ) - 1;	/* Ptr to end of #		*/
	szRevPtr = strchr( szPerCent, EOL ) - 1;	/* Ptr to last char of % str	*/

	while( szRevPtr >= szPerCent )				/* Copy the # text backwards	*/
		*(szPtr--) = *(szRevPtr--);

	while( szPtr >= szCurStatus[0] )				/* Pad to begining of str		*/
		*(szPtr--) = SPC;
															/* Calc length of bar			*/	
	TotCols = (int)(Gage.Right - Gage.Left - 1);

	NumCols = (PerCent > 0 ? (TotCols * PerCent) / 100 : 0);

			/* Display the percent string, clear the box and then update it	*/

	VideoPutsRowCol( Gage.Top - 1, Gage.Left, szCurStatus[0] );

															/* Display the red bar			*/
	if ( NumCols != 0 )
		for ( i = (int)Gage.Top + 1; i < (int)Gage.Top + 3; i++ )
			VideoDupCharAttr( i, Gage.Left + 1 , BLK, GetGageColor(), NumCols );
															/* Clear the end of the bar	*/
															/* if any space is remaining	*/
	if ( TotCols != 0 && (Gage.Left + 1 + NumCols) < Gage.Right )
	   VideoScrollDn( Gage.Top + 1 , Gage.Left + 1 + NumCols,
							Gage.Bottom - 1,  Gage.Right - 1, 0, GetBoxColor() );
}

#else	/* if KEISEN */		/* ### if JAPAN ### */

void UpdateGage( int PerCent )
{
	char				szPerCent[ 10 ];
	char				*szPtr;
	char				*szRevPtr;
	register			NumCols;
	register			TotCols;
	int				i;

	if ( szCurStatus[0] == NULL)					/* See if need to initialize	*/
		DisplayGage();									  

	itoa( PerCent, szPerCent, 10 );

	szPtr = strchr( szCurStatus[0], PERCENT ) - 1;	/* Ptr to end of #		*/
	szRevPtr = strchr( szPerCent, EOL ) - 1;	/* Ptr to last char of % str	*/

	while( szRevPtr >= szPerCent )				/* Copy the # text backwards	*/
		*(szPtr--) = *(szRevPtr--);

	while( szPtr >= szCurStatus[0] )				/* Pad to begining of str		*/
		*(szPtr--) = SPC;
															/* Calc length of bar			*/	
/* #ifdef JAPAN */
	TotCols = (int)(Gage.Right - Gage.Left - 1 - 2);
/* #endif */

	NumCols = (PerCent > 0 ? (TotCols * PerCent) / 100 : 0);

			/* Display the percent string, clear the box and then update it	*/

/* #ifdef JAPAN */
	VideoPutsRowCol( Gage.Top - 1, Gage.Left + 1, szCurStatus[0] );
/* #endif */
															/* Display the red bar			*/
	if ( NumCols != 0 )
		for ( i = (int)Gage.Top + 1; i < (int)Gage.Top + 3; i++ )
/* #ifdef JAPAN */
			VideoDupCharAttr( i, Gage.Left + 2 , SPC, GetGageColor(), NumCols );
/* #endif */
															/* Clear the end of the bar	*/
															/* if any space is remaining	*/
/* #ifdef JAPAN */
	if ( TotCols != 0 && (Gage.Left + 1 + NumCols + 1) < (Gage.Right - 1) )
	   VideoScrollDn( Gage.Top + 1 , Gage.Left + 1 + NumCols + 1,
							Gage.Bottom - 1,  Gage.Right - 1 - 1, 0, GetBoxColor() );
/* #endif */
}

#endif			/* ### end if JAPAN ### */

/***************************************************************************/
/* Initializes the gage screen and sets the total byte count to zero.		*/
/*																									*/
/*	void DisplayGage( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/* RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void DisplayGage( void )
{
	extern unsigned		PercentComplete;
	extern unsigned		CopyText;

	GetMessage( szCurStatus, PercentComplete );
	Gage.Color = Gage.BorderColor = GetBackGroundColor();

	NewScreen( CopyText, 0 );
	PutWindow( &Gage );
}

/***************************************************************************/
/* Updates the global byte count and updates the gage with the percent of	*/
/* total bytes done.																			*/
/*																									*/
/*	void UpdateByteCount( long lBytes )													*/
/*																									*/
/*	ARGUMENTS:	lBytes	- Bytes to add to count										*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void UpdateByteCount( long lBytes )
{
	register		Percent;

	if ( lBytes < 0L )
		lByteCount = 0L;
	else
		lByteCount += lBytes;

	Percent = (int)(lByteCount / (lTotalBytes / 100L));

	if ( Percent > 99 )
		Percent = 99;
	else if ( Percent < 0 )
		Percent = 0;

	UpdateGage( Percent );
}

/***************************************************************************/
/* Function which gives far call access to UpdateByteCount();					*/
/*																									*/
/*	void far	fUpdateByteCount( long lBytes )											*/
/*																									*/
/*	ARGUMENTS:	lBytes	- Bytes to add to count										*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/
void far	fUpdateByteCount( long lBytes )
{
	UpdateByteCount( lBytes );
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\prompts\header.c ===
/***************************************************************************/
/*																									*/
/*	HEADER.C																						*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Displays the header and title at the top of the screen in the proper		*/
/* color as defined by the macro GetHeaderColor().									*/
/* 																								*/
/* void DisplayScreenHeader( void )														*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS:		void 																			*/
/*																									*/
/*	EXTERNS:		HelpHeaderText - Both declared in EXTERN.C						*/
/*					HeaderText;																	*/
/*																									*/
/* johnhe - 03/15/89																			*/
/***************************************************************************/

#include 	<string.h>

#include 	<alias.h>
#include		<window.h>
#include		<bios_io.h>

#define		HEADER_LINES		5

void DisplayScreenHeader( int IsHelp )
{
	char				*apszTitle[ HEADER_LINES ];
	extern UCHAR	ScreenWidth;

	extern UINT		HelpHeaderText;
	extern UINT 	HeaderText;


	GetMessage( apszTitle, IsHelp ? HelpHeaderText : HeaderText );

	/* m200: First clear any previous header */
	VideoDupCharAttr( 1, 1,	' ', GetHeaderColor(), LAST_VIDEO_COL );
	VideoDupCharAttr( 2, 1,	' ', GetHeaderColor(), LAST_VIDEO_COL );

	VideoPutsAttrRowCol( 1, 1,	apszTitle[0], GetHeaderColor() );
#ifdef JAPAN	/* if KEISEN */
	VideoDupDBCharAttr( 2, 1, K_THICK_HORIZ_LINE, GetHeaderColor(),
							((int)strlen(apszTitle[0]) + 1) / 2);
#else
	VideoDupCharAttr( 2, 1, '', GetHeaderColor(),
							(int)strlen( apszTitle[0] ) );
#endif

}	


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\prompts\message.c ===
/***************************************************************************/
/*																									*/
/*	MESSAGE.C																					*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Builds an array of pointers to the strings starting at a specified		*/
/* offset. The caller should get the offset from the #defines in the			*/
/* MESSAGE.H file which is created by the INDEX.EXE program. The the			*/
/* array passed as argument should be long enought to hold the number		*/
/* of lines store at the specified offset, this value is also generated		*/
/* by the INDEX.EXE program and is included in the MESSAGE.H file. A NULL	*/
/* pointer will be added to the array after the pointer to the last string	*/
/* in the specified group.																	*/
/*																									*/
/* void GetMessage( char **apszArray, unsigned uOffset )							*/
/* 																								*/
/* ARGUMENTS:	apszArray	- Array to hold the string pointers.				*/
/*					uOffset		- The offset of the first string in the			*/
/*									  MESSAGE.TXT file as defined in the MESSAGE.H	*/
/*									  file.														*/
/* RETURNS:		void																			*/
/*																									*/
/*	EXTERNS:		chMessage	- First character in message area declared in 	*/
/*									  MESSAGE.ASM by the message compiler.				*/
/*																									*/
/* johnhe - 03/15/89																			*/
/***************************************************************************/

#include 	<stdio.h>
#include 	<alias.h>

#define		END_MARKER			-1

void GetMessage( char **apszArray, unsigned uOffset )
{
	char			**pszPtr;
	char			*pchText;
	extern char	chMessage;

	pchText = (&chMessage) + uOffset;		/* Address the first string */
	pszPtr = apszArray;							/* Point to first element array */

	while ( *pchText != END_MARKER )			/* Loop until -1 is detected */
	{
		*(pszPtr++) = pchText;					/* Save pointer to this string */
		while( *pchText != EOL )				/* Find end of this string */
			pchText++;
		pchText++;									/* Address start of next string */
	}
	*pszPtr = NULL;								/* Mark end of the array of ptrs */

}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\prompts\error.c ===
/***************************************************************************/
/*																									*/
/*	ERROR.C																						*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Non-fatal error function. An array of pointers to a string defining the */
/* error and a pointer to a string suggesting a possible correction. Will  */
/* display an error message in a window on the screen and wait for a any   */
/* key to be pressed. A buffer to store the orginal contents under the     */
/* error window must be allocated at the start of the program since there  */
/* is no guarentee that there will be sufficient memory available when the */
/* the error function is called.                                           */
/*                                                                         */
/*	void	Error( char **ErrorString )													*/
/*																									*/
/* ARGUMENTS:	ErrorString 	- 		pointer to string identifing the error.*/
/* 				CorrectionString - pointer to string detailing the error    */
/* RETURNS: 	void                                                        */
/*																									*/
/*	EXTERNS:		ErrorMessageText	- Declared in EXTERN.C							*/
/*																									*/
/* johnhe - 03/15/89																			*/
/***************************************************************************/

#include 	<alias.h>
#include		<window.h>
#include		<bios_io.h>

void	Error( char **ErrorString )
{
	char					*apszText[ MAX_STRINGS ];
	int					iHelpFlags;
	static int			Response[] = {CR, 0};

	extern unsigned	ErrorMessageText;

	GetMessage( apszText, ErrorMessageText );
   apszText[2] = ErrorString[0];
   apszText[3] = ErrorString[1];

	PushHelp( 0xffff );							/* No help is set yet				*/
	iHelpFlags = GetHelpFlags();				/* Save current help line			*/
	HelpLine( EXIT_HLP | CONT_HLP );			/* Set new help line					*/
	
	PromptWindow( apszText, Response, GetErrorColor(), ErrorBuffer );

	HelpLine( iHelpFlags );						/* Restore original help line		*/
	PopHelp();
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\prompts\mstring.c ===
/***************************************************************************/
/*																									*/
/*	MSTRING.C																					*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Copies a single string from the message area to the user's buffer.      */
/* 																								*/
/* void GetMessStr( char *szBuf, unsigned TextOffset, int StrNum )			*/
/* 																								*/
/* ARGUMENS:	szBuf 		- Ptr to buffer to copy the specified string to */
/* 				TextOffset	- String group offset in the message file 		*/
/* 				StrNum		- The group string number to get 					*/
/* RETURNS: 	void																			*/
/* 																								*/
/* johnhe - 02-24-89																			*/
/***************************************************************************/

#include 	<stdio.h>
#include		<string.h>

#include 	<alias.h>

#define		END_MARKER			-1

void GetMessStr( char *szBuf, unsigned uOffset, int StrNum )
{
	register		i;
	char			*pchText;
	extern char	chMessage;

	pchText = (&chMessage) + uOffset;		/* Address the first string */

	for ( i = 0; i < StrNum && *pchText != END_MARKER; i++ )
	{
		while( *pchText != EOL )				/* Find end of this string */
			pchText++;
		pchText++;									/* Address start of next string */
	}

	if ( *pchText != END_MARKER )
		strcpy( szBuf, pchText );
	else
		*szBuf = EOL; 
}

/***************************************************************************/
#if 0

	char		*apszText[ MAX_STRINGS ];

	GetMessage( apszText, TextOffset );
	strcpy( szBuf, apszText[ StrNum ] );

#endif
/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\prompts\help.c ===
/***************************************************************************/
/*																									*/
/*	HELP.C																						*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Displays the help screen associated with the value on the help stack		*/
/* pointed to by HelpStackPtr. Waits for the user to press a key and then	*/
/* restores the original screen. Functions which want to use help should	*/
/* push a help indentifier on the help stack with the macro PushHelp( x )	*/
/* and then call GetChar() to get input from the user. If F1 is pressed 	*/
/* GetChar will this function. If the value of *HelpStackPtr == -1 the 		*/
/* function will return without displaying any text.								*/
/*                                                                         */
/*	void Help( void )																			*/
/*                                                                         */
/* ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*                                                                         */
/*	EXTERNS:		HelpMemErrText	- Declared in EXTERN.C								*/
/*                                                                         */
/* johnhe - 12/29/89																			*/
/***************************************************************************/

#include 	<stdio.h>
#include 	<stdlib.h>

#include 	<alias.h>
#include 	<window.h>
#include 	<bios_io.h>

/***************************************************************************/
int GetChar( void );

void Help( void )
{
	char					*apszError[ ERROR_LINES ];
	char					*ScrnBuf;
	extern unsigned	HelpMemErrText;

	GetMessage( apszError, HelpMemErrText	);		/* Get mem error message	*/

	if ( *(HelpStackPtr-1) != 0xffff	)				/* Is valid help on stack?	*/
	{
		if ( (ScrnBuf = malloc( 5000 )) != NULL )	/* Is enough memory? 		*/
		{
			free( ScrnBuf );								/* Free this block			*/
			DisplayHelp();									/* Show the help				*/
		}
		else
			Error( apszError );							/* Too little memory 		*/
	}
}

/***************************************************************************/
/* Saves the contents of the original screen and then diplays a help			*/
/* screen. Must save the contents of the screen as well as the cursor size	*/
/* and location.																				*/ 
/*                                                                         */
/*	void DisplayHelp( void )																*/
/*                                                                         */
/* ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*                                                                         */
/***************************************************************************/

void DisplayHelp( void )
{
	char				*apszText[ MAX_STRINGS ];	/* Help strings	*/
	char				*ScrnBuf;					/* Storage for orignal screen	*/
	int 				OldHelp;
	long				Cursor;
	static WINDOW	Wind = { 0, 24, 0, 79, 0, 0, 0 }; /* Screen description	*/

	ScrnBuf = GetMemory( 4000 );				/* Allocate size of screen	*/
	Cursor = SaveCursor();
	VideoCursOff();								/* Turn cursor off			*/

	WindowMove( &Wind, ScrnBuf, SAVE );		/* Save current screen		*/

	GetMessage( apszText, *(HelpStackPtr - 1));/* Display help screen	*/
	VideoCls( GetBackGroundColor() );
	DisplayScreenHeader( 1 );
	DisplayText( apszText, TITLE_ROW );

	OldHelp = GetHelpFlags(); 					/* Save original help flags*/
	HelpLine( PREV_HLP | EXIT_HLP );

	PushHelp( 0xffff );							/* Can't have help on help	*/
	while( GetChar() != ESC )					/* Wait for <RETURN>			*/
		;
	PopHelp();										/* Turn help back on			*/
														/* Restore original screen */
	WindowMove( &Wind, ScrnBuf, RESTORE );
	RestoreCursor( Cursor );
	HelpLine ( OldHelp );						/* Restore orig. help flags*/

	FreeMemory( ScrnBuf );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\bldpath.c ===
/***************************************************************************/
/*																									*/
/*	BLDPATH.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Builds a valid path name when given the 3 elements of drive, path and	*/
/* file name along with a buffer for the created path.							*/
/*																									*/
/* void BuildPath( char *szPath, char *szDirPath, char *szFileName ) 		*/
/*																									*/
/*	ARGUMENTS:	szPath	-  Buffer to hold the created pathname					*/
/* 				chDrive	-	Drive designator											*/
/*					szDirPath -	Pointer to drive and directory path					*/
/*					szFileName - Pointer to a file name									*/
/* RETURNS: 	void																			*/
/*																									*/
/* johnhe - 03/23/89																			*/
/***************************************************************************/

#include    <stdio.h>
#include 	<string.h>

#include 	<strlib.h>

void BuildPath( char *szPath, char chDrive, char *szDirPath, char *szFileName )
{
	char	*szPtr;								/* Temoporay place holder */

	*szPath = chDrive;						/* Set drive designator & seperator */
	*(szPath+1) = ':';
	*(szPath + 2 ) = '\\';					/* Add a backslash						*/
	*(szPath + 3 ) = EOL;					/* Terminate the string					*/

	if ( *szDirPath == '\\' )				/* Prevent a double backslash			*/
		szDirPath++;

		
	strncat( szPath, szDirPath, 63 );	/* Add the directory path */

	szPtr = strchr( szPath, EOL );		/* If szDir doesn't end with a   */
													/* backslash we need to add one	*/
#ifdef DBCS
	if ( *(szPtr - 1) != '\\' || CheckDBCSTailByte(szPath,szPtr -1))
#else
	if ( *(szPtr - 1) != '\\' )			
#endif
		strcat( szPath, "\\" );

	strcat( szPath, szFileName );			/* Add the file name */
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\chrins.c ===
/***************************************************************************/
/*																									*/
/*	CHRISNS.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Inserts a character at the begining of a string and returns the new		*/
/* length of the string.                                                   */
/*                                                                         */
/* unsigned InsertChar( char *String, int Char )									*/
/* 																								*/
/* ARGUMENTES: String		- Pointer to a string									*/
/* 				Char			- character to be inserted at begining of string*/
/* 																								*/
/* RETURNS: 	unsigned 	- length of orignal string - 1						*/
/* 																								*/
/* johnhe - 03-23-89																			*/
/***************************************************************************/

#include    <stdio.h>
#include    <stdlib.h>
#include		<string.h>

/***************************************************************************/

unsigned InsertChar( char *String, int Char )
{
	unsigned StringLength;

	StringLength = strlen(String) + 1;
   memmove( String+1, String, StringLength );
   *String = (char)(Char);
	return( StringLength );							/* Return length of new string */
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\prompts\newscr.c ===
/***************************************************************************/
/*																									*/
/*	NEWSCR.C																						*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Clears the screen and displays the messages from the text file as			*/
/* specified by the Text argument and then displays the help line as 		*/
/* specified by the HelpFlags argument.												*/
/*																									*/
/*	void NewScreen( unsigned Text, unsigned Help )									*/
/*																									*/
/*	ARGUMENTS:	Text		- Offset of message in the text file					*/
/* 				HelpFlags- Bit flags for desired help line messages			*/
/*	RETURNS:		int		- Number of strings displayed.							*/
/*																									*/
/* johnhe - 02-24-89																			*/
/***************************************************************************/

#include 	<alias.h>
#include		<strlib.h>
#include		<window.h>

void GetMessage( char *apszText[], unsigned Text );

int NewScreen( unsigned Text, unsigned HelpFlags )
{
	char		*apszText[ MAX_STRINGS ];

	GetMessage( apszText, Text );
	WorkAreaCls();
   DisplayText( apszText, TITLE_ROW );
	HelpLine( (int)HelpFlags );

	return( GetNumberStrings( apszText ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\chrrepl.c ===
/***************************************************************************/
/*																									*/
/* CHRREPL.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Replaces all occurances of a specified character in a string with 		*/
/* another character.																		*/
/* 																								*/
/* void ReplaceChar( char *szString, char chOldChar, char chNewChar )		*/
/* 																								*/
/* ARGUMENTS:	szString 	- Ptr to string											*/
/* 				chOldChar	- Char to be replaced									*/
/* 				chNewChar	- Replacement character 								*/
/* RETURNS: 	void																			*/
/* 																								*/
/* johnhe - 03/23/89																			*/
/***************************************************************************/

#include 	<stdio.h>
#include 	<string.h>

void ReplaceChar( char *szString, char chOldChar, char chNewChar )
{
	while ( (szString = strchr( szString, chOldChar )) != NULL )
		*(szString++) = chNewChar;

}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\dbcs.c ===
/***************************************************************************/
/*																									*/
/*	DBCS.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*																									*/
/***************************************************************************/

#ifdef DBCS

#include	<dos.h>
#include	<ctype.h>

/*
	Test if the character is DBCS lead byte

	input:	c = character to test
	output:	TRUE if leadbyte
*/

int	IsDBCSLeadByte(unsigned char c)
{
	static unsigned char far *DBCSLeadByteTable = 0;

	union REGS inregs,outregs;
	struct SREGS segregs;
	unsigned char far *p;

	if (DBCSLeadByteTable == 0)
	{
		inregs.x.ax = 0x6300;		/* get DBCS lead byte table */
		intdosx(&inregs, &outregs, &segregs);
		FP_OFF(DBCSLeadByteTable) = outregs.x.si;
		FP_SEG(DBCSLeadByteTable) = segregs.ds;
	}

	p = DBCSLeadByteTable;
	while (p[0] || p[1])
	{
		if (c >= p[0] && c <= p[1])
			return 1;
		p += 2;
	}
	return 0;
}



/*
	Check if the character point is at tail byte

	input:	*str = strart pointer of the string
		*point = character pointer to check
	output:	TRUE if at the tail byte
*/

int	CheckDBCSTailByte(unsigned char *str,unsigned char *point)
{
	unsigned char *p;

	p = point;
	while (p != str)
	{
		p--;
		if (!IsDBCSLeadByte(*p))
		{
			p++;
			break;
		}
	}
	return ((point - p) & 1);
}

/*
	DBCS enabled strupr
*/
unsigned char	*DBCSstrupr(unsigned char *str)
{
	unsigned char	*s;

	s = str;
	while (*s)
	{
		if (IsDBCSLeadByte(*s))
			s++;
		else
			*s = toupper(*s);
		s++;
	}
	return (str);
}

/*
	DBCS enabled strchr
*/
unsigned char	*DBCSstrchr(unsigned char *str,unsigned char c)
{
	while (*str)
	{
		if (IsDBCSLeadByte(*str))
			str++;
		else if (*str == c)
			return (str);
		str++;
	}
	if (c == '\0')
		return (str);
	else
		return 0;
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\findparm.c ===
/***************************************************************************/
/*																									*/
/*	FINDPARM.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Searches a string for the specified character prefixed with a forward	*/
/* slash character. The search for the parameter is not case sensitive. 	*/
/* 																								*/
/* int FindParam( char *szStr, char ch )												*/
/* 																								*/
/* ARGUMENTS:	szStr 	- Ptr to string to be searched							*/
/* 				ch 		- Parameter	character to search for 					*/
/* RETURNS: 	int		- TRUE if search parameter	is found else false		*/
/* 																								*/
/* johnhe - 12/01/89																			*/
/***************************************************************************/

#include    <stdio.h>
#include 	<string.h>
#include 	<ctype.h>

#define		FALSE 	0
#define		TRUE		1

int FindParam( char *szStr, char ch )
{
	register 	iFound;
	register		chParam;	

	iFound = FALSE;
	ch = (char)toupper( ch );

	while ( iFound == FALSE && (szStr = strchr( szStr, '/' )) != NULL )
	{
		chParam = *(++szStr);
		chParam = toupper( chParam );
		iFound = (chParam == ch );
	}
	return( iFound );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\dirtofn.c ===
/***************************************************************************/
/*																									*/
/*	DIRTOFN.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Creates a unix type file name from a directory or FCB entry.				*/
/*																									*/
/*	void DirToFileName( char *Str, struct DIR *Dir )								*/
/*																									*/
/*	ARGUMENTS:	Str	- Buffer to create the file name string in				*/
/*					Dir	- Ptr to a directory structure containing a name		*/
/*																									*/
/* johnhe - 09-03-90																			*/
/***************************************************************************/

#define		EOL		'\0'
#define		NAME_LEN	8
#define		EXT_LEN	3
#define		FN_LEN	13

#include		<string.h>
#include		<strlib.h>

void DirToFileName( char *Str, char *Dir )
{

	memset( Str, EOL, FN_LEN );
	strncpy( Str, Dir, NAME_LEN );
	Str += RemoveTrailing( Str, SPC );

	Dir += NAME_LEN;									/* Address the file extension */
	if ( *Dir != SPC )
	{
		*(Str++) = '.';
		strncpy( Str, Dir, EXT_LEN );
		RemoveTrailing( Str, SPC );
	}		
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\hugeadd.c ===
/***************************************************************************/
/*																									*/
/*	HUGEADD.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Adds a long integer to a far pointer without causing a segment wrap. 	*/
/* The pointer that is returned will also be normalized so that the offset */
/* is always < 16.																			*/
/* 																								*/
/* char far *HugeAdd( char far *Ptr, long lBytes ) 								*/
/* 																								*/
/* ARGUMENTS:	Ptr		- Far pointer which will be added to					*/
/* 				lBytes	- Number of bytes to add to Ptr							*/
/* RETURN:		char far * - New normalized pointer 								*/
/*																									*/
/* johnhe - 10/30/89																			*/
/***************************************************************************/

#define	UL 	unsigned long

char far *HugeAdd( char far *Ptr, long lBytes )
{
	UL 		lTmp;

	lTmp = (UL)(lBytes);

	lTmp += ((UL)Ptr & 0xffff0000L) >> 12;		/* Convert seg to real 20 bit */
	lTmp += (UL)Ptr & 0xffffL;						/* Add offset to 20 bit addr	*/
	
	Ptr = (char far *)((lTmp & 0xfffffff0L) << 12);	/* Creat ptr segment		*/
	Ptr += (unsigned)(lTmp & 0xfL);						/* Add ptr offset			*/

	return( Ptr );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\iswhite.c ===
/***************************************************************************/
/*																									*/
/*	ISWHITE.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Returns TRUE is the argument character is a valid DOS command line		*/
/* delimiter.																					*/
/* 																								*/
/* int IsWhite( char ch )																	*/
/* 																								*/
/* ARGUMENTS:	ch 	- Character to be tested										*/
/* RETURNS: 	int	- TRUE is arg is a DOS cmd line delimiter else FALSE	*/
/* 																								*/
/* johnhe - 12/01/89																			*/
/***************************************************************************/

#include    <ctype.h>

int IsWhite( char ch )
{
	return( isspace( ch ) || ch == ';' || ch == '=' || ch == ',' );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\maxhuge.c ===
/***************************************************************************/
/*																									*/
/*	MAXHUGE.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Returns the size of the max block of huge memory that is available. The	*/
/* amount available is determined doing a DOS call to allocate the largest	*/
/* block avaliable and then freeing the allocated block and returning the	*/
/* the size of the block that was allocated.											*/
/*																									*/
/*	long GetMaxHugeSize( void )															*/
/*																									*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS:		long		-	Number of bytes of huge memory avaiable			*/
/*																									*/
/* johnhe - 10/01/89																			*/
/***************************************************************************/

#include    <stdio.h>
#include		<dos.h>

long GetMaxHugeSize( void )
{
	unsigned		uNumParagraphs;

					/* Request more than is possible to get the max size  */
	_dos_allocmem( 0xffff, &uNumParagraphs );

					/* Return paragraphs converted to bytes */
	return( ((unsigned long) uNumParagraphs) << 4);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\hugenorm.c ===
/***************************************************************************/
/*																									*/
/*	HUGENORM.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Accepts a far pointer and returns a new pointer to the same location 	*/
/* which has been normalize so that the offset is always < 16.					*/
/*																									*/
/* char far *NormalizePtr( char far *Ptr )											*/
/* 																								*/
/* ARGUMENTS:		Ptr		- Far pointer to be normalized						*/
/* RETURNS		char far *	- Normalized far pointer								*/
/* 																								*/
/* johnhe - 03/23/89																			*/
/***************************************************************************/

#define		UL 	unsigned long

char far *NormalizePtr( char far *Ptr )
{
	UL 	lAddr;

	lAddr = ((UL)Ptr & 0xffff0000L) >> 12;		/* Convert seg to real 20 bit */
	lAddr += (UL)Ptr & 0xffffL;					/* Add offset to 20 bit addr */
	
	Ptr = (char far *)((lAddr & 0xfffffff0L) << 12);/* Creat ptr segment	*/
	Ptr += (unsigned)(lAddr & 0xf);						/* Add ptr offset		*/

	return( Ptr );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\matchext.c ===
/***************************************************************************/
/*																									*/
/*	MATCHEXT.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Checks a file name to see if it's extension exists in a list of         */
/* different extensions. Returns the index to the first matching extension */
/* NOTE: the filename may consist of the full path to the file.				*/
/*                                                                         */
/* int FindExtMatch( char *szFile, char **szExt )									*/
/* 																								*/
/* ARGUMENTS:	szFile - Ptr to filename to chech for a matching extension	*/
/* RETURNS: 	int	 - Index to matching extension in the list or -1		*/
/* 																								*/
/* johnhe - 10/30/89																			*/
/***************************************************************************/

#include    <stdio.h>
#include 	<string.h>

#include 	<strlib.h>

int FindExtMatch( char *szFile, char **szExt )
{
	register 	iMatch;

	iMatch = -1;
	szFile = ParseFileName( szFile );
	if ( (szFile = strchr( szFile, '.' )) != NULL )
		iMatch = StrSearch( szFile + 1, szExt );

	return( iMatch );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\maxint.c ===
/***************************************************************************/
/*																									*/
/*	MAXINT.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Scans an array of integers and returns the index to the max int in the	*/
/* array. If 2 or more integers equal MAX the index to the first one in		*/
/* the array is used. If all elements in the array are 0 a -1 is returned.	*/
/*																									*/
/* ARGUMENTS:	aiMatch	- Array of integers to search.							*/
/*					iLen		- Number of elements in the array.						*/
/* RETURNS:		int		- First maximium value in the array or -1 if all	*/
/*								  elements == 0.												*/
/*                                                                         */
/* johnhe - 08/01/89																			*/
/***************************************************************************/

int IndexMaxInt( int aiMatch[], int iLen )
{
	int		i, iMax, iFirstMax;

										/* One loop for each element in the array */
	for ( i = iMax = iFirstMax = 0; i < iLen; i++ )
	{
		if ( aiMatch[i] > iMax )				/* Is this element > than max */
		{
			iMax = aiMatch[i];					/* Save new max value			*/
			iFirstMax = i;							/* Save new array index			*/
		}
	}

	return( iMax == 0 ? -1 : iFirstMax );	/* Index to max element or -1	*/
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\nonwhite.c ===
/***************************************************************************/
/*																									*/
/*	NONWHITE.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Returns a ptr to first white space or '=' character encountered.			*/
/*                                                                         */
/* char *SkipNonWhite( char *szPtr )													*/
/* 																								*/
/* ARGUMENTS:	Str		- Ptr to a string												*/
/* RETURNS: 	char *	- Ptr to first white space character or EOL	*/
/* 																								*/
/* johnhe - 12/01/89																			*/
/***************************************************************************/

#include 	<strlib.h>

char *SkipNonWhite( char *szPtr )
{
	while( !IsWhite( *szPtr ) && *szPtr != EOL )
#ifdef DBCS
	{
		if (IsDBCSLeadByte(*szPtr))
			szPtr++;
		szPtr++;
	}
#else
		szPtr++;
#endif

	return( szPtr );
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\nextword.c ===
/***************************************************************************/
/*																									*/
/*	NEXTWORD.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Copies the first word from a string into a buffer with a specified max	*/
/* length.																						*/
/* 																								*/
/* void ExtractNextWord( char *szStr, char *szBuffer, int iBufLen )			*/
/* 																								*/
/* ARGUMENTS:	szStr 	- Ptr to string to parse word from						*/
/* 				szBuffer - Buffer to copy the word into							*/
/* 				iBufLen	- Total length of the buffer in bytes					*/
/* RETURNS: 	void																			*/
/* 																								*/
/* johnhe - 03/23/89																			*/
/***************************************************************************/

#include 	<strlib.h>

unsigned ExtractNextWord( char *szStr, char *szBuffer, int iBufLen )
{
	register unsigned int	i;
	register unsigned int   iLen;

	iLen = (iBufLen - 1);

	for ( i = 0; i < iLen && *szStr != EOL; i++, szStr++ )
	{
		if ( !IsWhite( *szStr ) && *szStr != '/' )
			*(szBuffer++) = *szStr;
		else
			break;
	}
	*szBuffer = EOL;

   return (i);
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\numstrs.c ===
/***************************************************************************/
/*																									*/
/*	NUMSTRS.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Returns the number of strings in a array of strings. The last element   */
/* of the array must be a NULL pointer.                                    */
/*                                                                         */
/* int GetNumberStrings( char **Strings ) 											*/
/* 																								*/
/* ARGUMENTS:	Strings	- Array of pointers to strings							*/
/* RETURNS: 	int		- Total number of strings									*/
/* 																								*/
/* johnhe - 03-23-89																			*/
/***************************************************************************/

#include 	<stdio.h>

int GetNumberStrings( char **Strings )
{
   register      i;

	for ( i = 0; Strings[i] != NULL; i++ )
		;
   return( i );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\pathchr.c ===
/***************************************************************************/
/*																									*/
/*	PATHCHR.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Validates a character as a valid path and file name character. 			*/
/* 																								*/
/* IsValidPathChar( char Char )															*/
/* 																								*/
/* ARGUMENTS:	Char	- Character to be tested										*/
/* RETURNS: 	int	- TRUE if a valid character else FALSE 					*/
/*                                                                         */
/* johnhe - 03/23/89																			*/
/***************************************************************************/

#define		FALSE 	0
#define		TRUE		1

int IsValidPathChar( char Char )
{
	int	IsOk;

	switch( Char )
	{
		case	' '  :
		case	'\t' :
		case	0x0d :
		case	'/'  :
		case	':'  :
		case	';'  :
		case	'='  :
		case	'<'  :
		case	'>'  :
		case	'|'  :
			IsOk = FALSE;
			break;
		default	  :
			IsOk = TRUE;
			break;
	}
	return( IsOk );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\parsefn.c ===
/***************************************************************************/
/*																									*/
/*	PARSEFN.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Returns a pointer to the first character in the filename which may or	*/
/* may not be appended to a path.														*/
/* 																								*/
/* char *ParseFileName( char *szPath ) 												*/
/* 																								*/
/* ARGUMENTS:	szPath	- Ptr to a file path in the form d:\xxxx\xxx.xxx	*/
/* RETURNS: 	char *	- Ptr to file name or character after last			*/
/* 							  backslash or ':' in the string if the path did	*/
/* 							  not contain a file name									*/
/* johnhe - 03/23/89																			*/
/***************************************************************************/

#include    <stdio.h>
#include 	<strlib.h>

char *ParseFileName( char *szPath )
{
	char	*szPtr;

	for ( szPtr = szPath;
			*szPtr != EOL && (IsValidPathChar( *szPtr ) ||	*szPtr == ':');
			szPtr++ )
#ifdef DBCS
		if (IsDBCSLeadByte(*szPtr))
			szPtr++;
#else
		;
#endif

#ifdef DBCS
	while(( --szPtr >= szPath && *szPtr != '\\' && *szPtr != ':') ||
		(szPtr >= szPath && CheckDBCSTailByte(szPath,szPtr)) )
#else
	while( --szPtr >= szPath && *szPtr != '\\' && *szPtr != ':' )
#endif
		;

	return( ++szPtr );
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\skipspc.c ===
/***************************************************************************/
/*																									*/
/*	SKIPSPC.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Returns a ptr to first character after any white spaces or '=' chars.	*/
/* Checks for EOL and if encountered stops processing and returns a ptr 	*/
/* to the EOL character.																	*/
/*                                                                         */
/* char *SkipLeadingWhite( char *szPtr )												*/
/* 																								*/
/* ARGUMENTS:	Str		- Ptr to a string												*/
/* RETURNS: 	char *	- Ptr to first non-white space character or EOL 	*/
/* 																								*/
/* johnhe - 12/01/89																			*/
/***************************************************************************/

#include 	<strlib.h>

char *SkipLeadingWhite( char *szPtr )
{
	while ( IsWhite( *szPtr ) && *szPtr != EOL )
		szPtr++;

	return( szPtr );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\paths.c ===
/***************************************************************************/
/*																									*/
/*	PATHS.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Gets the PATH variable from the enviroment and then copies it to a		*/
/* specified buffer and seperates the string into individual paths and		*/
/* fills in an array of pointers to the beginning of each string.				*/
/*																									*/
/*	void GetPathStrings( char **apszPaths, char *chBuffer, int BufSize )		*/
/*																									*/
/*	ARGUMENTS:	apszPaths	- Array of pointers to be filled in					*/
/*					chBuffer		- Buffer to copy the string into						*/
/*					BufSize		- Size of passed buffer in bytes						*/
/*	RETURNS:		void																			*/
/*																									*/
/* johnhe - 01/13/89																			*/
/***************************************************************************/

#include		<stdio.h>
#include		<stdlib.h>
#include 	<string.h>

#include 	<strlib.h>

void GetPathStrings( char **apszPaths, char *chBuffer, int BufSize )
{
	register		i;						/* Index for array apszPaths		*/
	char			*szEnvironment;	/* Pointer to eviro PATH string	*/
	char			*pchEnd;				/* Pointer to end of PATH string	*/

										/* Make sure there is a path enviro variable	*/
	if ( (szEnvironment = getenv( "PATH" )) != NULL )
	{
															/* Copy string to work buffer	*/
		i = strlen( szEnvironment );
		++i;

		if ( i < BufSize )
			BufSize = i;

 		strncpy( chBuffer, szEnvironment, BufSize - 1 );
		*(chBuffer + BufSize - 1 ) = EOL;

		RemoveSpaces( chBuffer );					/* Clean up the string			*/
		pchEnd = strchr( chBuffer, EOL ); 		/* Find end of string			*/
		ReplaceChar( chBuffer, ';', EOL );		/* Convert to individ string	*/

		for ( i = 0; chBuffer < pchEnd; i++ )
		{
			apszPaths[i] = chBuffer;				/* Save pointer to this path	*/
			chBuffer = strchr( chBuffer, EOL ) + 1; /* Find end of this path	*/
		}
	}

	apszPaths[i] = NULL;								/* Mark end of array				*/
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\rmtrail.c ===
/***************************************************************************/
/*																									*/
/*	RMTRAIL.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Removes all trailing characters of the type specified from a string		*/
/* and returns the length of the new string.                               */
/*                                                                         */
/* unsigned RemoveTrailing( char *String, char Char ) 							*/
/* 																								*/
/* ARGUMENTS:	String	- pointer to a string										*/
/* 				Char		- the ascii char to remove from the end of string	*/
/* 																								*/
/* RETURNS: 	unsigned - lenght of the new string									*/
/* 																								*/
/* johnhe - 03/23/89																			*/
/***************************************************************************/

#include    <stdio.h>
#include    <stdlib.h>
#include 	<string.h>

#include 	<strlib.h>

/***************************************************************************/

unsigned RemoveTrailing( char *String, char Char )
{
   char     *EndOfString;

	EndOfString = strchr(String, EOL );

#ifdef DBCS
	while( EndOfString != String && *(EndOfString-1) == Char &&
				!CheckDBCSTailByte(String,EndOfString-1))
#else
	while( EndOfString != String && *(EndOfString-1) == Char )
#endif
		EndOfString--;

	*EndOfString = EOL;
	return( (unsigned)(EndOfString - String) );
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\strmax.c ===
/***************************************************************************/
/*																									*/
/*	STRMAX.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Returns the length of the longest string in an array of strings.			*/
/*                                                                         */
/* unsigned MaxStrLen( char *Strings[] )												*/
/* 																								*/
/* ARGUMENTS:	Strings - array of pointers to strings								*/
/* RETURNS: 	unsigned - length of the longest string in the array			*/
/* 																								*/
/* johnhe - 03/23/89																			*/
/***************************************************************************/

#include    <stdio.h>
#include 	<string.h>

unsigned MaxStrLen( char **Strings )
{
	register 		i;
	unsigned 		Len;
	unsigned 		MaxLen;

	for ( i = MaxLen = 0; Strings[i] != NULL; i++ )
	{
		Len = strlen( Strings[i] );
		if ( Len > MaxLen )
			MaxLen = Len;
	}
	return( MaxLen );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\skipword.c ===
/***************************************************************************/
/*																									*/
/*	SKIPWORD.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Returns a ptr to the first character of the word following the first 	*/
/* encountered in the specified string.												*/
/* 																								*/
/* char *SkipWord( char *szPtr ) 														*/
/* 																								*/
/* ARGUMENTS:	szPtr 	- Ptr to string												*/
/* RETURNS: 	char *	- Ptr to first character of next word or EOL 		*/
/* 																								*/
/* johnhe - 12/01/89																			*/
/***************************************************************************/

#include 	<strlib.h>

char *SkipWord( char *szPtr )
{

	szPtr = SkipLeadingWhite( szPtr );
	szPtr = SkipNonWhite( szPtr );
																/* Find start of next word */
	szPtr = SkipLeadingWhite( szPtr );

	return( szPtr );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\strpad.c ===
/***************************************************************************/
/*																									*/
/*	STRPAD.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Pads the end of a string with a specified character.							*/
/* 																								*/
/* void PadStr( char *szStr, char chChar, int Len )								*/
/* 																								*/
/* ARGUMENTS:	szStr 	- Ptr to string												*/
/* 				chChar	- Character to pad the string with						*/
/* 				Len		- Total length of the padded string in bytes			*/
/* RETURNS: 	void																			*/
/* 																								*/
/* johnhe - 03/23/89																			*/
/***************************************************************************/

#include 	<string.h>

#include 	<strlib.h>

void PadStr( char *szStr, char chChar, int Len )
{
	char	*Ptr;
	char	*MaxPtr;

	MaxPtr = szStr + Len;
	Ptr = strchr( szStr, EOL );

	while ( Ptr < MaxPtr )
		*(Ptr++) = chChar;

	*Ptr = EOL;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\strsrch.c ===
/***************************************************************************/
/*																									*/
/*	STRSRCH.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/*	Looks for a matching string in an array of pointers to strings.			*/
/*																									*/
/*	int StrSearch( char *szSearchStr, char **szStrings ) 							*/
/*																									*/
/*	ARGUMENTS:	szSearchStr	- String to match											*/
/*					szStrings	- Array of pointers to strings with last the		*/
/*									  end of the array marked with a NULL pointer	*/
/*	RETURNS:		int			- Index to the first matching string or -1 if	*/
/*									  there was no matching string found.				*/
/*                                                                         */
/* johnhe - 03/23/89																			*/
/***************************************************************************/

#include    <stdio.h>
#include 	<string.h>
#define		OK 	0

int StrSearch( char *szSearchStr, char **szStrs )
{
	int		i;

	if ( szStrs == NULL )
		return( -1 );

 	for( i = 0; szStrs[i] != NULL; i++ )
	{
		if ( strcmpi( szSearchStr, szStrs[i] ) == OK )
			break;
	}

	return( szStrs[i] == NULL ? -1 : i );
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\strshl.c ===
/***************************************************************************/
/*																									*/
/*	STRSHL.C																						*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* ShiftStringLeft() moves a string left one character, including EOL.		*/
/* Returns the length of the new string.                                   */
/* 																								*/
/* unsigned ShiftStringLeft( char *String )											*/
/* 																								*/
/* ARGUMENTS:	String	- pointer to string to be shifted						*/
/* RETURNS: 	unsigned - length of original string - 1							*/
/* 																								*/
/* Created 03-23-89 - johnhe																*/
/***************************************************************************/

#include    <stdio.h>
#include 	<string.h>

unsigned ShiftStringLeft( char *String )
{
	unsigned 	Length;

   if ( (Length = strlen(String)) != 0 )
      memmove( String, String+1, Length-- );
   return( Length );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\window\w_center.c ===
/***************************************************************************/
/*																									*/
/*	W_CENTER.C																					*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Function to return the starting column of a string consisting of StrLen */
/* number of characters for the string to be centered on a line of the     */
/* current screen. The function will adjust current width of the screen.   */
/* 																								*/
/* int CenterLength( int iStrLen )														*/
/* 																								*/
/* ARGUMENTS:	int iStrLen -	The lenght of a string to be centered on 		*/
/*										the current display.									*/
/* RETURNS:		int 			-  Starting column to make the string centered	*/
/*																									*/
/* johnhe - 03/15/89																			*/
/***************************************************************************/

#include		<bios_io.h>

int CenterLength(int iStrLen)
{
	extern	unsigned char	ScreenWidth;

	return( ((VideoGetWidth() - iStrLen) / 2) + (iStrLen & 1 ? 1 : 0) );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\window\w_clean.c ===
/***************************************************************************/
/*																									*/
/*	W_CLEAN.C																					*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Function to clear the screen and restore the cursor to normal size and	*/
/* top left corner position.																*/
/*																									*/
/*	void VideoCleanup( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/* johnhe - 03/15/89																			*/
/***************************************************************************/

#include 	<alias.h>
#include		<bios_io.h>

void VideoCleanup( void )
{
	VideoCls( 7 );
	VideoSetRowCol( 0, 0 );
	VideoNormalCurs();
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\strlib\strrmspc.c ===
/***************************************************************************/
/*																									*/
/*	STRMSPC.C																					*/
/*																									*/
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Removes all spaces in a string.														*/
/*                                                                         */
/* unsigned RemoveSpaces( char *szString )											*/
/* 																								*/
/* ARGUMENTS:	String	- pointer to string											*/
/* RETURNS: 	unsigned - length of the new string									*/
/* 																								*/
/* johnhe - 03/23/89																			*/
/***************************************************************************/

#include    <stdio.h>
#include 	<strlib.h>

unsigned RemoveSpaces( char *szString )
{
	char		*szPtr, *szStart;

	szStart = szPtr = szString;
	while( *szPtr != EOL )
	{
		if ( *szPtr != SPC )
			*(szString++) = *(szPtr++);
		else
			szPtr++;
	}
	*szString = EOL;
	return( (unsigned)(szStart - szString) );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\window\w_cls.c ===
/***************************************************************************/
/*																									*/
/*	W_CLS.C																						*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Function to clear the work area of the screen. The work are is defined  */
/* as the area below the screen header and above the help prompt at the    */
/* bottom of the screen.                                                   */
/*																									*/
/*	void WorkAreaCls( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/* johnhe - 03/15/89																			*/
/***************************************************************************/

#include 	<alias.h>
#include 	<window.h>
#include		<bios_io.h>

void WorkAreaCls( void )
{
	extern unsigned char		ScreenWidth;

   VideoScrollDn( TITLE_ROW, 0, 23, VideoGetWidth() - 1,
						0, GetBackGroundColor() );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\window\w_move.c ===
/***************************************************************************/
/*																									*/
/*	W_MOVE.C																						*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Moves a window from the screen to a buffer if SaveRestore == SAVE       */
/* else it moves from the buffer to the screen.										*/
/*                                                                         */
/*	void  WindowMove( struct WindowStruct *Wind, char *Buffer,					*/
/*							int iSaveRestore )												*/
/*                                                                         */
/* ARGUMENTS:	Wind 			- Ptr to a completed window definition struc		*/
/* 				Buffer 		- Ptr to data area large enough to hold the		*/
/*									  screen contents  										*/
/* 				SaveRestore - signals copy from screen to buffer or buffer	*/
/*									  to screen													*/
/*									  SAVE = copy from screen								*/
/*									  RESTORE = copy to screen         					*/
/*	RETURNS:		void																			*/
/*																									*/
/* johnhe - 03/15/89																			*/
/* johnhe - 02/12/90 - Added shadow window support									*/
/***************************************************************************/

#include 	<alias.h>
#include		<window.h>
#include		<bios_io.h>

void  WindowMove( struct WindowStruct *Wind, char *Buffer,int iSaveRestore )
{
	register		iRow;
	register		iCol;
	int			Width;
	int			Len;
	int			BytesPerLine;

	Len = Wind->Bottom + (Wind->IsShadow ? 1 : 0);
	Width = (Wind->Right - Wind->Left) + 1;
	Width += (Wind->IsShadow ? 2 : 0);
	BytesPerLine = Width << 1;
														/* Copy a line at a time */

	for ( iRow = Wind->Top, iCol = Wind->Left; iRow <= Len; 
			iRow++, Buffer += BytesPerLine )
	{
		if ( iSaveRestore == SAVE )
			VideoGetBlock( iRow, iCol,	Buffer, Width );
		else
			VideoPutBlock( iRow, iCol,	Buffer, Width );

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\window\w_color.c ===
/***************************************************************************/
/*																									*/
/*	W_COLOR.C																					*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Sets the default colors based on whether IsColor is TRUE or FALSE.		*/
/*																									*/
/* void SetDefaultColors( int IsColor )												*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/* johnhe - 03/15/89																			*/
/***************************************************************************/

#include 	<alias.h>
#include		<bios_io.h>


extern UCHAR	*uchAreaColors;


void SetDefaultColors( int IsColor )
{
	static UCHAR MonoDefault[ ] =
#ifdef JAPAN
		{ 0x07, 0x07, 0x07, 0x70, 0x70, 0x07, 0x70, 0x07, 0x70, 0x70 };
#else
		{ 0x07, 0x07, 0x07, 0x70, 0x70, 0x07, 0x70, 0x07, 0x70, 0x07 };
#endif
									   
	static UCHAR ColorDefault[ ] =
#ifdef JAPAN
		{ 0x17, 0x17, 0x17, 0x70, 0x30, 0x30, 0x70, 0x17, 0x70, 0x60 };
#else
		{ 0x17, 0x17, 0x17, 0x70, 0x30, 0x30, 0x70, 0x17, 0x70, 0x0e };
#endif

	uchAreaColors = IsColor ? ColorDefault : MonoDefault;
}

#if 0
	if ( IsColor != FALSE )
		IsColor = 1;
	SetHeaderColor( auchDefault[IsColor][0] );
	SetBackGroundColor( auchDefault[IsColor][1] );
	SetTitleColor( auchDefault[IsColor][2] );
	SetStatusColor( auchDefault[IsColor][3] );
	SetRevBackColor( auchDefault[IsColor][4] );
	SetPromptColor( auchDefault[IsColor][5] );
	SetErrorColor( auchDefault[IsColor][6] );
	SetBoxColor( auchDefault[IsColor][7] );
	SetBarColor( auchDefault[IsColor][8] );
	SetGageColor( auchDefault[IsColor][9] );

#endif


void SetHelpColors( int IsColor )
{

	static UCHAR MonoHelp[ ] =
#ifdef JAPAN
		{ 0x70, 0x70, 0x70, 0x07, 0x07, 0x70, 0x07, 0x70, 0x07, 0x70 };
#else
		{ 0x70, 0x70, 0x70, 0x07, 0x07, 0x70, 0x07, 0x70, 0x07, 0x70 };
#endif
									   
	static UCHAR ColorHelp[ ] =
#ifdef JAPAN
		{ 0x71, 0x70, 0x71, 0x17, 0x30, 0x30, 0x07, 0x70, 0x07, 0x60 };
#else
		{ 0x71, 0x70, 0x71, 0x17, 0x30, 0x30, 0x07, 0x70, 0x07, 0x0e };
#endif

	uchAreaColors = IsColor ? ColorHelp : MonoHelp;
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\window\w_rstcur.c ===
/***************************************************************************/
/*																									*/
/*	W_RSTCUR.C																					*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Displays the cursor at the screen position and size specified in the		*/
/* argument as an unsigned long with the  position in the high byte and		*/
/*	size in the low byte.																	*/
/*																									*/
/*	void RestoreCursor( unsigned long Cursor )										*/
/*																									*/
/*	ARGUMENTS:	Cursor	- Cursor size & position returned by SaveCursor()	*/
/* RETURNS:		void																			*/
/*																									*/
/* johnhe - 03/15/89																			*/
/***************************************************************************/

#include		<bios_io.h>

void RestoreCursor( unsigned long Cursor )
{
	unsigned 		CursPos;
	unsigned			CursSize;

	CursPos  = (unsigned)(Cursor >> 16);
	CursSize = (unsigned)(Cursor & 0xffff);

	VideoSetRowCol( CursPos >> 8, CursPos & 0xff );
	VideoSetCursSize( CursSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\window\w_respon.c ===
/***************************************************************************/
/*																									*/
/*	W_RESPON.C																					*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Waits for a character to input by the user. The inputted character must */
/* match a character in the argument array or an error beep will be        */
/* sounded. If the first element of the argument array is 0 the function   */
/* will accept any keystroke as a valid character and return. Case of the  */
/* characters in not consider as everything is converted to uppercase.     */
/*                                                                         */
/*	int GetResponse( int ValidResponse[] )												*/
/*                                                                         */
/* ARGUMENTS:	ValidResponse 	- Array of valid keystrokes                  */
/* RETURNS: 	int			 	- User's validated input                     */
/*																									*/
/* johnhe - 03/15/89																			*/
/***************************************************************************/

#include 	<stdlib.h>

#include		<alias.h>
#include		<window.h>
#include		<bios_io.h>

int	GetChar( void );

int GetResponse( int ValidResponse[] )
{
	register		i;
	register		Input;
	int			Tmp;

   do
   {
      Input = GetChar();
      Input &= 0xff;    							/* Strip high byte of int */
      if ( ValidResponse[0] != 0 )
      {
         Tmp = Input;      /* Need to do this because toupper() is a macro */
         Input = toupper( Tmp );
         for( i = 0; ValidResponse[i] != 0; i++ )
            if ( Input == ValidResponse[i] )
               break;
         if ( ValidResponse[i] == 0 )     /* Check for end of array */
           Input = 0; /* No match found */
      }
   }
   while ( Input == 0 );
   return( Input );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\window\w_putwin.c ===
/***************************************************************************/
/*																									*/
/*	W_PUTWIN.C																					*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Displays an un-titled window in the screen as defined in the window     */
/* definition structure.                                                   */
/*                                                                         */
/*	void PutWindow ( struct  WindowStruct *Win )										*/
/*                                                                         */
/* ARGUMENTS:	Win	- Ptr to initialized window definition structure.     */
/*	RETURNS:		void																			*/
/*																									*/
/* johnhe - 03/15/89																			*/
/***************************************************************************/

#include		<alias.h>
#include		<window.h>
#include		<bios_io.h>

#define		SHADOW	0x08

#ifndef DBCS			/* if Not DBCS ### */

void PutWindow ( struct  WindowStruct *Win )
{
   int         DupFactor, VertDupFactor, Row, Col, i;
   enum        {tlc, trc, blc, brc, hor, ver };

   static char Border[2][6] = { { '', '', '', '', '', '' },
                                { '', '', '', '', '', '' } };

      /* Set width of box between the 2 corners */
   DupFactor = Win->Right - Win->Left - 1;
   VertDupFactor = Win->Bottom - Win->Top - 1;

      /* Draw top of box */

   VideoPutCharAttr( Win->Top, Win->Left, Border[Win->Type][tlc],
                     Win->BorderColor );
   VideoDupCharAttr( Win->Top, Win->Left + 1, Border[Win->Type][hor],
                     Win->BorderColor, DupFactor );
   VideoPutCharAttr( Win->Top, Win->Right, Border[Win->Type][trc],
                     Win->BorderColor );

      /* Draw sides of box */
   Col = Win->Left;
   Row = Win->Top + 1;
   for ( i = 0; i < 2; i++ )
   {

      VideoVertDupCharAttr( Row, Col, Border[Win->Type][ver],
                         Win->BorderColor, VertDupFactor );
      Col = Win->Right;

   }
      /* Draw bottom of box */

   VideoPutCharAttr( Win->Bottom, Win->Left, Border[Win->Type][blc],
                     Win->BorderColor );
   VideoDupCharAttr( Win->Bottom, Win->Left + 1 , Border[Win->Type][hor],
                     Win->BorderColor, DupFactor );
   VideoPutCharAttr( Win->Bottom, Win->Right, Border[Win->Type][brc],
                     Win->BorderColor );

   // Check interior size of box.
   if (Win->Top + 1 <= Win->Bottom - 1 && Win->Left + 1 <= Win->Right - 1)
      /* Clear the inside of the box */

      VideoScrollDn(Win->Top + 1, Win->Left + 1, Win->Bottom - 1,
         Win->Right - 1, 0, Win->Color);

		/* Add the show if Shadow flag is set */
	if ( Win->IsShadow && VideoIsColor() )
	{
		VideoDupAttr( Win->Bottom+1, Win->Left+2, SHADOW, DupFactor+2 );
		VideoVertDupAttr( Win->Top+1, Win->Right+1, SHADOW, VertDupFactor+1 );
		VideoVertDupAttr( Win->Top+1, Win->Right+2, SHADOW, VertDupFactor+1 );
	}
}

#else			/* ### if DBCS ### */

void PutWindow ( struct  WindowStruct *Win )
{
   int         DupFactor, VertDupFactor, Row, Col, i;
   enum        {tlc, trc, blc, brc, hor, ver };

#ifdef JAPAN	/* if KEISEN */
   static int Border[2][6] = { { K_THICK_TOP_LEFT, K_THICK_TOP_RIGHT, K_THICK_BOTOM_LEFT, K_THICK_BOTOM_RIGHT, K_THICK_HORIZ_LINE, K_THICK_VERT_LINE },
                                { K_THIN_TOP_LEFT, K_THIN_TOP_RIGHT, K_THIN_BOTOM_LEFT, K_THIN_BOTOM_RIGHT, K_THIN_HORIZ_LINE, K_THIN_VERT_LINE } };
#else
   static char Border[2][6] = { { '', '', '', '', '', '' },
                                { '', '', '', '', '', '' } };
#endif

      /* Set width of box between the 2 corners */
   DupFactor = Win->Right - Win->Left - 1;
   VertDupFactor = Win->Bottom - Win->Top - 1;

/* #ifdef DBCS */
    for ( Row = Win->Top; Row <= Win->Bottom; Row++)
    {
	if (CheckLead(Row, Win->Right))
	{
	    VideoPutCharRowCol(Row, Win->Right + 1, SPC);
	    VideoPutCharRowCol(Row, Win->Right, SPC);
	}
    }
    for ( Row = Win->Top; Row <= Win->Bottom; Row++)
    {
	if (CheckTail(Row, Win->Left))
	{
	    VideoPutCharRowCol(Row, Win->Left, SPC);
	    VideoPutCharRowCol(Row, Win->Left - 1, SPC);
	}
    }
/* #endif */

      /* Draw top of box */

#ifdef JAPAN	/* if KEISEN */

    VideoScrollDn(Win->Top, Win->Left, Win->Bottom,
         Win->Right, 0, Win->Color);

   VideoPutDBCharAttr( Win->Top, Win->Left, Border[Win->Type][tlc],
                     Win->BorderColor );
   VideoDupDBCharAttr( Win->Top, Win->Left + 2, Border[Win->Type][hor],
                     Win->BorderColor, (DupFactor-2)/2 );
   VideoPutDBCharAttr( Win->Top, Win->Right - 1, Border[Win->Type][trc],
                     Win->BorderColor );

#else			/* if Not JAPAN */

   VideoPutCharAttr( Win->Top, Win->Left, Border[Win->Type][tlc],
                     Win->BorderColor );
   VideoDupCharAttr( Win->Top, Win->Left + 1, Border[Win->Type][hor],
                     Win->BorderColor, DupFactor );
   VideoPutCharAttr( Win->Top, Win->Right, Border[Win->Type][trc],
                     Win->BorderColor );

#endif

      /* Draw sides of box */
   Col = Win->Left;
   Row = Win->Top + 1;
   for ( i = 0; i < 2; i++ )
   {

#ifdef JAPAN	/* if KEISEN */

      VideoVertDupDBCharAttr( Row, Col, Border[Win->Type][ver],
                         Win->BorderColor, VertDupFactor );
      Col = Win->Right-1;

#else			/* if Not JAPAN */

      VideoVertDupCharAttr( Row, Col, Border[Win->Type][ver],
                         Win->BorderColor, VertDupFactor );
      Col = Win->Right;

#endif

   }
      /* Draw bottom of box */

#ifdef JAPAN	/* if KEISEN */

   VideoPutDBCharAttr( Win->Bottom, Win->Left, Border[Win->Type][blc],
                     Win->BorderColor );
   VideoDupDBCharAttr( Win->Bottom, Win->Left + 2 , Border[Win->Type][hor],
                     Win->BorderColor, (DupFactor-2)/2 );
   VideoPutDBCharAttr( Win->Bottom, Win->Right -1, Border[Win->Type][brc],
                     Win->BorderColor );

#else			/* if Not JAPAN */

   VideoPutCharAttr( Win->Bottom, Win->Left, Border[Win->Type][blc],
                     Win->BorderColor );
   VideoDupCharAttr( Win->Bottom, Win->Left + 1 , Border[Win->Type][hor],
                     Win->BorderColor, DupFactor );
   VideoPutCharAttr( Win->Bottom, Win->Right, Border[Win->Type][brc],
                     Win->BorderColor );

   // Check interior size of box.
   if (Win->Top + 1 <= Win->Bottom - 1 && Win->Left + 1 <= Win->Right - 1)
      /* Clear the inside of the box */

      VideoScrollDn(Win->Top + 1, Win->Left + 1, Win->Bottom - 1,
         Win->Right - 1, 0, Win->Color);

#endif

		/* Add the show if Shadow flag is set */
	if ( Win->IsShadow && VideoIsColor() )
	{
/* #ifdef DBCS */
	    for ( Row = Win->Top + 1; Row <= Win->Bottom + 1; Row++)
	    {
		if (CheckLead(Row, Win->Right+2))
		{
		    VideoPutCharRowCol(Row, Win->Right + 3, SPC);
		    VideoPutCharRowCol(Row, Win->Right + 2, SPC);
		}
	    }
/* #endif */
		VideoDupAttr( Win->Bottom+1, Win->Left+2, SHADOW, DupFactor+2 );
		VideoVertDupAttr( Win->Top+1, Win->Right+1, SHADOW, VertDupFactor+1 );
		VideoVertDupAttr( Win->Top+1, Win->Right+2, SHADOW, VertDupFactor+1 );
	}
}
#endif			/* ### end if DBCS ### */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\window\w_prompt.c ===
/***************************************************************************/
/*																									*/
/*	W_PROMPT.C																					*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Displays an untitled window on the screen and prompts waits for input   */
/* from the user that matches an entry in a validation array specified by  */
/* the caller. The length and width of the window are calculated based on  */
/* number and length of the strings passed to the function.                */
/*                                                                         */
/*	int PromptWindow( char **String, int *ValidResponse, int wColor, 			*/
/*                  char *Buffer )														*/
/*                                                                         */
/* ARGUMENTS:	String 			- Array of ptrs to strings to be displayed	*/
/*										  in the window,the last element of the		*/
/*										  array must be a NULL pointer           		*/
/* 				ValidResponse 	- Array of ints which specify valid input		*/
/*										  from the user. If the first element of the	*/
/*										  array is 0 the function will not validate	*/
/*										  the input and will return after any key is	*/
/*										  pressed. If ValidResponse == NULL no input	*/
/*										  is waited for and the window is left			*/
/*										  displayed												*/
/*					wColor 			- color of the window to be displayed        */
/* 				Buffer 			- a ptr to buffer large enough to hold the	*/
/*										  contents of the orginal display under the	*/
/*										  window, if Buffer == NULL the function		*/
/*										  will allocate a buffer to hold the data.   */
/* RETURNS: 	int				- Character input by the user                */
/*																									*/
/* johnhe - 03/15/89																			*/
/***************************************************************************/

#include		<stdio.h>
#include 	<malloc.h>

#include		<alias.h>
#include		<window.h>
#include 	<bios_io.h>
#include		<string.h>

#ifndef DBCS			/* ### if Not DBCS ### */

int PromptWindow( char **String, int *ValidResponse, int wColor,
                  char *Buffer )
{
	extern unsigned char ScreenWidth;
	char						*OldScrn;
	register					i;
	register 				Row;
	int						Response;
	UINT						BufferSize;
	UL 						OldCursor;
	struct WindowStruct	Wind;


	GetWindowInfo( String, &Wind );		/* Init wind struct */
	Wind.Color = (char)wColor;
	Wind.BorderColor = (char)wColor;
	OldCursor = SaveCursor();					/* Save cursor position & size	*/
	VideoCursOff();								/* Blank the cursor					*/

		/* If passed a buffer or not saving window we don't need to allocate */

	if ( ValidResponse != NULL )
	{
		if ( Buffer == NULL )
		{
			BufferSize = (UINT)((Wind.Bottom - Wind.Top + 2 ) *
									  (Wind.Right - Wind.Left + 3) * 2 );
			OldScrn = GetMemory( BufferSize );
		}
		else
			OldScrn = Buffer;
		WindowSave( &Wind, OldScrn );
	}

	PutWindow( &Wind );

	for ( i = 0, Row = Wind.Top; String[i] != NULL; i++, Row++ )
		VideoPutsAttrRowCol( Row, CenterStr( String[i] ), String[i], wColor );

	if ( ValidResponse != NULL )
	{
		Response = GetResponse( ValidResponse );

		WindowRestore( &Wind, OldScrn );
		RestoreCursor( OldCursor );

		if ( Buffer == NULL )
			FreeMemory( OldScrn );

	}

	return( Response );
}

#else			/* ### if DBCS ### */

int PromptWindow( char **String, int *ValidResponse, int wColor,
                  char *Buffer )
{
	extern unsigned char ScreenWidth;
	char						*OldScrn;
	register					i;
	register 				Row;
	int						Response;
	UINT						BufferSize;
	UL 						OldCursor;
	struct WindowStruct	Wind;


	GetWindowInfo( String, &Wind );		/* Init wind struct */
	Wind.Color = (char)wColor;
	Wind.BorderColor = (char)wColor;
	OldCursor = SaveCursor();					/* Save cursor position & size	*/
	VideoCursOff();								/* Blank the cursor					*/

		/* If passed a buffer or not saving window we don't need to allocate */

	if ( ValidResponse != NULL )
	{
/* #ifdef DBCS */
		BufferSize = (UINT)((Wind.Bottom - Wind.Top + 2 ) *
							  (Wind.Right - Wind.Left + 3 + 2) * 2 );
		OldScrn = GetMemory( BufferSize );
		if ( Buffer != NULL)
			WindowSave( &Wind, Buffer );
		Wind.Left--,Wind.Right++;
		WindowSave( &Wind, OldScrn );
		Wind.Left++,Wind.Right--;
/* #endif */
	}

	PutWindow( &Wind );

#ifdef JAPAN	/* if KEISEN */
	for ( i = 0, Row = Wind.Top; String[i] != NULL; i++, Row++ )
	{
	    if (Row == Wind.Top && strlen(String[i]))
	    {
		if (CheckLead(Row, CenterStr(String[i])+strlen(String[i])-1))
		{
		    VideoPutCharRowCol(Row, CenterStr(String[i])+strlen(String[i]), SPC);
		    VideoPutCharRowCol(Row, CenterStr(String[i])+strlen(String[i])-1, SPC);
		}
	    }
	    VideoPutsAttrRowCol( Row, CenterStr( String[i] ), String[i], wColor );
	}
#else
	for ( i = 0, Row = Wind.Top; String[i] != NULL; i++, Row++ )
		VideoPutsAttrRowCol( Row, CenterStr( String[i] ), String[i], wColor );
#endif

	if ( ValidResponse != NULL )
	{
		Response = GetResponse( ValidResponse );
/* #ifdef DBCS */
		Wind.Left--,Wind.Right++;
		WindowRestore( &Wind, OldScrn );
		Wind.Left++,Wind.Right--;

		RestoreCursor( OldCursor );

			FreeMemory( OldScrn );
/* #endif */
	}

	return( Response );
}

#endif			/* ### end if DBCS ### */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\window\w_savcur.c ===
/***************************************************************************/
/*																									*/
/*	W_SAVCUR.C																					*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/*	Returns the size and position of the cursor as an unsigned long value 	*/
/* with the position in the high byte and size in the low byte.				*/
/*																									*/
/*	unsigned long SaveCursor ( void )													*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/* RETURNS:		unsigned long	- Cursor screen position and size				*/
/*																									*/
/* johnhe - 03/15/89																			*/
/***************************************************************************/

#include		<bios_io.h>

unsigned long SaveCursor ( void )

{
	unsigned long		CursorSizePos;

	CursorSizePos = (unsigned long)(VideoGetRowCol()) << 16;
	CursorSizePos += (unsigned long)(VideoGetCursSize());

	return( CursorSizePos );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\window\w_strcen.c ===
/***************************************************************************/
/*																									*/
/*	W_STRCEN.C																					*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Returns the display column which cause the string passed as an argument */
/* to be displayed centered on the screen. 										   */
/*                                                                         */
/* int CenterStr( char *szString )														*/
/* 																								*/
/* ARGUMENTS:	szString - pointer to a string                              */
/* RETURNS: 	int column number which causes the string to be centered		*/
/*																									*/
/* johnhe - 03/15/89																			*/
/***************************************************************************/

#include		<string.h>
#include		<bios_io.h>

int CenterStr( char *szString )
{
	unsigned 					cch;
	extern unsigned char 	ScreenWidth;

   cch = strlen( szString );
	return( (int)(((VideoGetWidth() - cch) / 2) + (cch & 1 ? 1 : 0)) );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\window\w_twin.c ===
/***************************************************************************/
/*																									*/
/*	W_TWIN.C																						*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Displays a titled window in the screen as define in the window          */
/* definition structure and displays the window's title.                   */
/*                                                                         */
/*	void  PutTitledWindow( struct WindowStruct *Window, char *Title )			*/
/*                                                                         */
/* ARGUMENTS:	Window	- Ptr to initialized window definition structure.  */
/* 				Title 	- Ptr to a title string                            */
/*	RETURNS:		void																			*/
/*																									*/
/* johnhe - 03/15/89																			*/
/***************************************************************************/

#include 	<string.h>

#include 	<alias.h>
#include		<window.h>
#include		<bios_io.h>

void  PutTitledWindow( struct WindowStruct *Window, char *Title )
{
   int      Width;
   
	Width = (int)((Window->Right - Window->Left)) + 1;
   PutWindow( Window );    /* Draw the window */

		/* Draw the title Seperator */
#ifdef JAPAN	/* if KEISEN */
	VideoPutDBCharAttr( (int)Window->Top+2, (int)Window->Left, K_THIN_LEFT_TEE,
							(int)Window->BorderColor );
	VideoDupDBCharAttr( (int)Window->Top+2, (int)Window->Left+2, K_THIN_HORIZ_LINE,
							(int)Window->BorderColor,
                     (Width - 4)/2 );
	VideoPutDBCharAttr( (int)Window->Top+2, (int)Window->Right-1, K_THIN_RIGHT_TEE,
							(int)Window->BorderColor );

#else
	VideoPutCharAttr( (int)Window->Top+2, (int)Window->Left, '',
							(int)Window->BorderColor );
	VideoDupCharAttr( (int)Window->Top+2, (int)Window->Left+1, '',
							(int)Window->BorderColor,
                     Width - 2 );
	VideoPutCharAttr( (int)Window->Top+2, (int)Window->Right, '',
							(int)Window->BorderColor );

#endif

		/* Display the title */
	VideoPutsRowCol( (int)Window->Top+1, (int)Window->Left +
						  ((Width - (int)strlen( Title )) / 2), Title );

}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\lib\window\w_size.c ===
/***************************************************************************/
/*																									*/
/*	W_SIZE.C																						*/
/*                                                                         */
/*		Copyright (c) 1991 - Microsoft Corp.											*/
/*		All rights reserved.																	*/
/*		Microsoft Confidential																*/
/*                                                                         */
/* Initializes a specified window structure based on the number and			*/
/* length of an array of strings.														*/
/*																									*/
/*	int GetWinInfo( char **String, WINDOW *Window ) 								*/
/*																									*/
/*	ARGUMENTS:	Strings	-	Array of pointers to strings (NULL terminated)	*/
/*					Window	- Pointer to a WINDOW structure to be initialized	*/
/* RETURNS:		int		- Number of strings which will fit in the window	*/
/*																									*/
/* johnhe - 03/15/89																			*/
/***************************************************************************/

#include 	<alias.h>
#include		<window.h>
#include		<bios_io.h>
#include		<strlib.h>


int GetWindowInfo( char **String, WINDOW *Window )
{
	UCHAR		NumStrs;
	UCHAR 	WindowWidth;
	UCHAR 	MaxLength;

	NumStrs = (UCHAR)GetNumberStrings( String );
	MaxLength = (UCHAR)MaxStrLen( String );
	WindowWidth = MaxLength + (UCHAR)(3);
																				/*lint -e734	*/
#ifdef JAPAN	/* if KEISEN */
	WindowWidth += (WindowWidth & (UCHAR)1) ? (UCHAR)2 : (UCHAR)3;
#endif

	Window->Top = ((UCHAR)25 - NumStrs) / (UCHAR)2;
	Window->Bottom = Window->Top + NumStrs;
	Window->Left =  (UCHAR)( (VideoGetWidth() - (int)WindowWidth) / 2);
	Window->Right = Window->Left + WindowWidth;					/*lint +e734	*/

   Window->Type = WINDOW_TYPE;

	/* Disable shadowing in Janus */
#if 0
	Window->IsShadow = 1;
#else
	Window->IsShadow = 0;
#endif

	return( (int)NumStrs );
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\oem\boot.asm ===
; ========================================================

COMMENT #

	BOOT.ASM

        Microsoft Confidential
        Copyright (c) Microsoft Corporation 1990-1991
        All Rights Reserved.

	File to include partition and master
	boot records.

	johnhe - 02-14-90

END COMMENT #

;========================================================

DOSSEG
.Model	  LARGE,C

;========================================================

.DATA

		PUBLIC NewBootRec
NewBootRec LABEL BYTE

INCLUDE	BOOT.INC

	PUBLIC	MasterBootRec
MasterBootRec LABEL BYTE

INCLUDE	FDBOOT.INC

;========================================================

END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\oem\addfiles.c ===
/***************************************************************************/
/* ADDFILES.C                                                              */
/*                                                                         */
/* Microsoft Confidential                                                  */
/* Copyright (c) Microsoft Corporation 1989-1991                           */
/* All Rights Reserved.                                                    */
/*                                                                         */
/* This module contains the functions which upgrade a floppy disk or       */
/* hard disk system. UpgradeHard() will upgrade a hard disk system and     */
/* return to the caller when complete. UpgradeFloppy() will upgrade a      */
/* floppy disk system and return to the caller when complete.              */
/*                                                                         */
/* Created 11-13-89 - johnhe                                               */
/***************************************************************************/

#include 	<stdio.h>
#include 	<stdlib.h>
#include 	<string.h>
#include 	<dos.h>
#include 	<io.h>
#include 	<direct.h>

#include		<alias.h>
#include		<oem.h>
#include 	<disk_io.h>
#include		<bios_io.h>
#include 	<data.h>
#include		<copy.h>
#include 	<strlib.h>
#include 	<window.h>
#include		<dosonly.h>
#include		<message.h>

static void near	DisplayAdText	(void);

/***************************************************************************/

		/* Executable extensions */
static char 	*szExeExt[] = { "EXE", "COM", "BAT", NULL };

		/* Dblspace.bin file name */
static char 	*szDblSpace	= "X:\\dblspace.bin";

		/* root */
static char		*szRootPath = "\\";

/***************************************************************************/

static void near	MySetTotalBytes( void );
static void SetTotalBytes	( int iStartDisk, int iTotalDsks );
static void MakeHidden		( char Drive );
static void InstallFiles	( int iDisk, int IsHdUpgrade );
static void InitFileStruc	( struct MULT_FILES *FileStruc, int iDisk,
									  int IsHdDisk);
static int	InitFileInfo( char *szName, struct MULT_FILES *File, int iDisk,
								  int IsHdDisk );

static void DeleteConflicts( void );
static void	DeleteDosFile	( char *szFile );
static void CopyCommandCom	( void );
static void CopyFileSet   (int iDiskSet);
static void near CopyDblspaceBin (void);

extern void DispInsertUserDisk  (int UserDisk,char chDrive);
void near   DisplayFloppyExit (void);

/* Uncomment the next line to calculate the total bytes for the gas gauge */
// #define CALC_BYTE_COUNT 1

#ifdef CALC_BYTE_COUNT
void DisplayTotalByteCount (void);
#endif




/***************************************************************************/
/* FLOPPY DISK INSTALLATION																*/
/* 																								*/
/* Main procedure for a creating an emergency boot floppy.  Formats the    */
/* floppy if needed, else zeros it out.  Copies over the boot files, plus  */
/* a few useful utilities.  If the user's floppy is 720k, 1.2m, or 1.44m,  */
/* we copy over a larger set of utilities.  We don't create CONFIG.SYS or  */
/* AUTOEXEC.BAT.                                                           */
/*																									*/
/*	void near InstallFloppy( void )			   										*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*                                                                         */
/* WARNING: Never returns!                                                 */
/*																									*/
/***************************************************************************/

void InstallFloppy( void )
{
   long        cbFree;
   long        cbMin;
   extern long lTotalBytes;
   extern long lByteCount;


	UserDiskScreen();
//
// Init the gas gauge, and set the total-bytes-to-copy, which we have to do
// before calling CopyFileSet().  We don't yet how many bytes we'll be copying,
// but we'll assume 1.2/1.44m set, since this'll be most common.
//
   DisplayGage();
   cbMin = atol(GetDataString(TOTAL_BYTES, FLOPPY_360_INSTALL_BYTES));
   lTotalBytes = (long)(cbMin +
                 atol(GetDataString(TOTAL_BYTES, FLOPPY_120_INSTALL_BYTES)));
   lByteCount = 0L;

//
// At this point, user hasn't inserted their floppy yet, so we don't know
// how large it is.  We'll start with 360k file set.
//
   // Tell Xcopy() to allow 360k disks, as well as larger sizes
	vInfo.uchFloppyType = 1;
   CopyFileSet (DOS360);

//
// Now make sure user's disk is still in drive, and see how much free space
// is left.  Then we'll copy largest set of additional files we can.
//
   DispInsertUserDisk(FIRST_USER_DISK, vInfo.chDestin);
   cbFree = GetDiskFree(vInfo.chDestin);

   if (cbFree > atol(GetDataString(COMPONENTS_BYTES, FLOPPY_120_INSTALL_BYTES)))
   {
      CopyFileSet (DOS120);
   }
   else if (cbFree > atol(GetDataString(COMPONENTS_BYTES, FLOPPY_720_INSTALL_BYTES)))
   {  // Reset gas gauge to 720k file set.
      lTotalBytes = (long)(cbMin +
                    atol(GetDataString(TOTAL_BYTES, FLOPPY_720_INSTALL_BYTES)));
      CopyFileSet (DOS720);
   }

   UpdateGage (99);
	MakeHidden( vInfo.chDestin );				/* Set system file attributes 	*/

	DisplayFloppyExit();
	ProgramCleanUp( RESTORE_SCREEN ); 	/* Restore video & interrupts */
	ProgramExit( 0 );
}


/***************************************************************************/
/* 																								*/
/* Copies a set of files from distribution disk to emergency boot floppy.  */
/*                                                                         */
/*	void CopyFileSet( int iDiskSet )                                        */
/*																									*/
/*	ARGUMENTS:  iDiskSet - section containing list of files to copy         */
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void CopyFileSet (int iDiskSet)
{
	#define					BUF_LEN (sizeof( struct MULT_FILES ) * MAX_PER_DISK)
	register 				i;
	char						*szTmp;
	struct MULT_FILES 	*Files;
	struct MULT_FILES 	*TmpFile;


	Files = GetMemory( BUF_LEN );
   memset( Files, 0, BUF_LEN );

   for (i=0, TmpFile=Files; (szTmp=GetDataString(iDiskSet, i)) != NULL; i++)
   {
      if ( InitFileInfo( szTmp, TmpFile, FIRST_USER_DISK, FALSE ) == OK )
         TmpFile++;
   }
   Xcopy( Files );

	FreeMemory( Files );
}


/***************************************************************************
 * Displays the setup-done screen for floppy-install mode.
 *																									
 * void DisplayFloppyExit (void)
 *																									
 * ARGUMENTS:	void																			
 * RETURNS:		void
 *																									
 ***************************************************************************/
void near DisplayFloppyExit (void)
{
	char			*apszText[MAX_STRINGS];

   if (vInfo.Flag.fFloppyBoot)
      GetMessage (apszText, FD_AUTO_DONE_TEXT);
   else
      GetMessage (apszText, FD_DONE_TEXT);

	WorkAreaCls();
	HelpLine (CONT_HLP);

	PromptWindow( apszText, CR_Response, GetPromptColor(), NULL );
}



/***************************************************************************/
/* HARD DISK INSTALLATION																	*/
/* 																								*/
/* First creates the 2 system files if they don't already exist and a new	*/
/* boot sector. Then creates the DOS directory specified by the user. Next	*/
/* initializes the the screen and disk count and then enters a loop to		*/
/* install all of the disks. Lastly the system files are made hidden and	*/
/* the autoexec and config.sys files are created.									*/
/* 																								*/
/* void InstallHard( void )																*/
/* 																								*/
/* ARGUMENTS:	NONE																			*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void InstallHard( void )
{
	int 	iDskNum;
	int	iTotalDsks;
						
	PrepForSysFiles( vInfo.chDestin - 'A' );
	CreateDosPath();

	DisplayGage();
	DeleteConflicts();

	iTotalDsks = GetNumberDisks();
	iDskNum = 0;	/* Use iDskNum temporarily for scratch. */

	MySetTotalBytes();

#ifndef OEMBASE

	/* #4399 - Copy DBLSPACE.BIN (and 'sys') if necessary */
	CopyDblspaceBin();

#endif	// !OEMBASE

	for ( iDskNum = FIRST_USER_DISK; iDskNum < iTotalDsks; iDskNum++ )
	  {
		DisplayAdText();
		InstallFiles( iDskNum, TRUE );	/* Install files to hard disk	*/
	  }

	CopyCommandCom();

	MakeHidden( vInfo.chDestin ); 		/* Set system file attributes	*/
	AutoConfig();
	
	UpdateGage ( 100 );						/* 100% done	*/

#ifdef CALC_BYTE_COUNT
	DisplayTotalByteCount();
#endif
}

/***************************************************************************
 * CompressedDiskIsFull - Called when the compressed disk fills up.
 ***************************************************************************/

void far CompressedDiskIsFull (void)
{
  /* The compressed disk filled up */

  /* Inform the user of their situation, and reboot */
  CompressedDiskFullPrompt();
  RebootSystem();
}

/***************************************************************************/
/* Set the global total byte count by getting the bytes for each disk from	*/
/* the dosdata library function.															*/
/*																									*/
/*	void SetTotalBytes( int iStartDisk, int iTotalDsks ) 							*/
/*																									*/
/*	ARGUMENTS:	iStartDisk	- First disk to be installed							*/
/*					iTotalDisks	- Total number of user disks in the set			*/
/*																									*/
/***************************************************************************/

void SetTotalBytes( int iStartDisk, int iTotalDsks )
{
	register			i;
	extern long		lTotalBytes;
	extern long		lByteCount;
	
	for ( i = iStartDisk; i < iTotalDsks; i++ )
		lTotalBytes += GetDiskBytes( i );

	lByteCount = 0L;
}

/***************************************************************************
 * Set the global total byte count.
 *
 * void MySetTotalBytes( int iStartDisk, int iTotalDsks )
 *
 * ARGUMENTS: None.
 ***************************************************************************/

void near MySetTotalBytes (void)
{
  extern long     lTotalBytes;
  extern long     lByteCount;


  lTotalBytes = atol (GetDataString (TOTAL_BYTES, DOS_INSTALL_BYTES));

  /* Add the amounts for each component */
  if (vInfo.OptComp.BackupChoice    != NO_COMPONENT)
    lTotalBytes += atol (GetDataString (TOTAL_BYTES, BACKUP_COMPONENTS +
                                        vInfo.OptComp.BackupChoice));

  if (vInfo.OptComp.UndeleteChoice  != NO_COMPONENT)
    lTotalBytes += atol (GetDataString (TOTAL_BYTES, UNDELETE_COMPONENTS +
                                        vInfo.OptComp.UndeleteChoice));

  if (vInfo.OptComp.AntiVirusChoice != NO_COMPONENT)
    lTotalBytes += atol (GetDataString (TOTAL_BYTES, ANTI_VIRUS_COMPONENTS +
                                        vInfo.OptComp.AntiVirusChoice));

  // astro Raid #5118 - Bad dossetup.ini file left machine unbootable
  if (lTotalBytes <= 0)
    lTotalBytes = 1;

  lByteCount = 0L;
}


#ifdef CALC_BYTE_COUNT

/***************************************************************************
 * DisplayTotalByteCount - Displays the total number of bytes that the
 *                         Setup program read and wrote.  The value is used
 *                         to make the Gas Gauge accurate.
 *
 * ARGUMENTS:  None.
 * RETURNS:    void.
 ***************************************************************************/

void DisplayTotalByteCount (void)
{
  extern long lByteCount;
  char   szTemp[MAX_SCRN_LINE_LEN];
  static char *apszText[MAX_STRINGS] =
  {
    "",
    "The total number of bytes (read and written) is:",
    NULL,
    ""
    "This is used for the Gas Gauge calculation.",
    NULL
  };

  sprintf (szTemp, "%ld", lByteCount);
  apszText[2] = szTemp;
  PromptWindow (apszText, CR_Response, GetPromptColor(), NULL);
}

#endif


/***************************************************************************/
/* Set the 2 system file attribute to hidden system on the specified 		*/
/* drive.  Also makes Command.com read only.											*/
/* If creating boot-floppy, we also copy DBLSPACE.BIN to it and set it SHR */
/* If dblspace.bin on hard drive, we set it SHR after copy                 */
/* 																								*/
/* void Makehidden( char Drive ) 														*/
/* 																								*/
/* ARGUMENTS:	Drive 	- DOS drive letter to set the file attribs on		*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void MakeHidden( char Drive )
{
	extern char		*SysFile[];
   extern char    *CommandName;
   extern char    *DblSpace;

	SysFile[0][0] = SysFile[1][0] = Drive;
	_dos_setfileattr( SysFile[0], _A_HIDDEN | _A_SYSTEM  | _A_RDONLY );
	_dos_setfileattr( SysFile[1],  _A_HIDDEN | _A_SYSTEM | _A_RDONLY );

   DblSpace[0] = Drive;
	if ( !vInfo.Flag.fHardInstall )
   {
	   _dos_setfileattr( DblSpace, _A_HIDDEN | _A_SYSTEM | _A_RDONLY );
   }
	else if ( 0 == access (DblSpace, 0) )
   {	// astro #4399 prep dblspace.bin on hard drive
	   _dos_setfileattr( DblSpace, _A_HIDDEN | _A_SYSTEM | _A_RDONLY );
   }

   CommandName[0] = Drive;
   _dos_setfileattr( CommandName, _A_RDONLY );
}

/***************************************************************************/
/* Builds a MULT_FILES structure for the specified disk and then calls		*/
/* Xcopy() to install the new files.													*/
/* 																								*/
/* void InstallFiles( int iDisk )														*/
/* 																								*/
/* ARGUMENTS:	iDisk - Distribution disk number to install						*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void InstallFiles( int iDisk, int IsHdUpgrade )
{
	#define					BUF_LEN (sizeof( struct MULT_FILES ) * MAX_PER_DISK)
	struct MULT_FILES 	*Files;

	Files = GetMemory( BUF_LEN );
	memset( Files, 0, BUF_LEN );

	InitFileStruc( Files, iDisk, IsHdUpgrade );

	Xcopy( Files );

	FreeMemory( Files );
}

/***************************************************************************/
/* Initializes a MULT_FILES structure for the specified disk.					*/
/* 																								*/
/* void InitFileStruc( struct MULT_FILES *FileStruc, int iDisk,				*/
/*							  int IsHdUpgrade )												*/
/* void InstallFiles( int iDisk )														*/
/* 																								*/
/* ARGUMENTS:	FileStruc	- Array of MULT_FILES strucs to be filled in 	*/
/* 				iDisk 		- Distribution disk number to be copied			*/
/* 				IsHdUpgrade - Signals doing a hard disk upgrade if TRUE		*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void InitFileStruc( struct MULT_FILES *FileStruc, int iDisk, int IsHdDisk )
{
	register 				i;
	char						*szTmp;
	struct MULT_FILES 	*File;

	for ( i = 0, File = FileStruc;
			(szTmp = GetFileName( iDisk, i )) != NULL;
			i++ )
	{
		if ( InitFileInfo( szTmp, File, iDisk, IsHdDisk ) == OK )
			File++;
	}
}

/***************************************************************************/
/* Initializes a file info structure for the specified file name. The data	*/
/*	base is checked for the file and all translations for this specific 		*/
/*	file are done. 																			*/
/* 																								*/
/* Possible translations and the order in which they are done					*/
/* 																								*/
/* 	Destin file - Don't copy the file            - [no-copy]             */
/* 					  Rename file							- [rename]					*/
/* 					  Use different directory path	- [diff-path]				*/
/* 																								*/
/* 	Source file - Use alternate file					- [diff-file]				*/
/* 					  Get file from alternate disk	- [diff-disk]				*/
/* 																								*/
/* 																								*/
/*	int InitFileInfo( char *szFileName, struct MULT_FILES *FileStruc,			*/
/*							int iIsHdDisk )													*/
/* 																								*/
/* ARGUMENTS:	szFileName	- The name of the file to initialize				*/
/*					FileStruc	- Array of MULT_FILES strucs to be filled in 	*/
/* 				iDisk 		- Distribution disk number to be copied			*/
/* 				iIsHdDisk	- Signals destination is a hard drive				*/
/* RETURNS: 	int			_ OK if file gets copy else ERROR for no copy	*/
/* 																								*/
/***************************************************************************/

int InitFileInfo( char *szName, struct MULT_FILES *File, int iDisk,
						int IsHdDisk )
{
											/* Determine destination information		*/

	if ( (File->Name.Destin = GetRealDestName( szName )) == NULL )
		return( ERROR );				/* Don't copy was specifed for this file  */

	File->Path.Destin = GetRealDestPath( File->Name.Destin,
													 vInfo.szPath + 2 );
	File->UserDisk = IsHdDisk ? NOT_REMOVEABLE : iDisk;/* User's disk			*/
	File->Drive.Destin = vInfo.chDestin;					/* Set drive letter	*/

														/* Determine source information	*/
	if ( (File->Name.Source = GetRealSrcName( szName )) == NULL )
		return( ERROR );

	File->Path.Source = "\\";
																		/* Distrib disk		*/
	File->DiskNumber = GetRealSrcDisk( File->Name.Source, iDisk );
	File->Drive.Source = vInfo.chSource;					/* Set drive letter	*/

	return( OK );
}

/***************************************************************************/
/* Deletes any existing files in the DOS directory which have a name			*/
/* conflict with the new DOS files.														*/
/* 																								*/
/* int DeleteConflicts( void )															*/
/* 																								*/
/* ARGUMENTS:	void																			*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void DeleteConflicts( void )
{
	register 	i; 						/* Loop and array index 					*/
	register 	iDisk;					/* Current distribution disk				*/
	int			iTotalDsks;				/* Total number of user disks				*/
	char			*szFile; 				/* Current file name 						*/

							/* First make sure there are some files in the dir 	*/
	if ( !IsDirEmpty( vInfo.szPath ) )
	{
		iTotalDsks = GetNumberDisks();
		for ( iDisk = FIRST_USER_DISK; iDisk < iTotalDsks; iDisk++ )
			for ( i = 0; (szFile = GetFileName( iDisk, i )) != NULL; i++ )
				if ( (szFile = GetRealDestName( szFile )) != NULL )
					DeleteDosFile( szFile );
	}
}

/***************************************************************************/
/* Deletes the specified file in the DOS directory. If the file has an		*/
/* executable extension the delete is repeated for all 3 possible				*/
/* executable file extensions (.exe, .com, .bat).									*/
/* 																								*/
/* int DeleteDosFile( char *szFile ) 													*/
/* 																								*/
/* ARGUMENTS:	szFile	- Ptr to  name for file to be moved 					*/
/* RETURNS: 	void																			*/
/* 																								*/
/***************************************************************************/

void DeleteDosFile( char *szFile )
{
	char			*szFullPath;
	register 	iFileCount;
	register 	i;
	int			IsExeFile;


	IsExeFile = (FindExtMatch( szFile, szExeExt ) != -1 ? TRUE: FALSE);
	szFullPath = GetMemory( MAX_PATH_LEN );	/* Get memory for file path	*/

	BuildPath( szFullPath, vInfo.szPath[0], vInfo.szPath + 2, szFile );

	for ( i = iFileCount = 0; i < 3; i++ )
	{
		if ( IsExeFile )
			strcpy( strchr( ParseFileName( szFullPath ), '.' ) + 1, szExeExt[i] );

		if ( FileExists( szFullPath ) ) 			/* Make sure file exists		*/
		{
			DisplayFileStatus( szFile, DELETE );
			remove( szFullPath );
		}
		if ( IsExeFile == FALSE )					/* If file is not executable	*/
			break;										/* break out of for loop		*/
	}

	FreeMemory( szFullPath );
}

/***************************************************************************/
/* Copies the command.com file from the root dir into the DOS dir.			*/
/* 																								*/
/* void CopyCommandCom( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void CopyCommandCom( void )
{
	struct MULT_FILES 	File[2];
	static char				*szFileName = "COMMAND.COM";

	memset( File, 0, sizeof( struct MULT_FILES ) * 2 );

	File[ 0 ].Name.Destin = File[ 0 ].Name.Source = szFileName;
	File[ 0 ].Path.Destin = vInfo.szPath + 2;
	File[ 0 ].Path.Source = szRootPath;
	File[ 0 ].UserDisk = File[ 0 ].DiskNumber = NOT_REMOVEABLE;
	File[ 0 ].Drive.Destin = File[ 0 ].Drive.Source = vInfo.chDestin;

	Xcopy( File );
}	


/***************************************************************************/
/* Displays the advertising text .                                         */
/*                                                                         */
/*  void near DisplayAdText(void)                                          */
/*                                                                         */
/*  ARGUMENTS:  Number of the disk ready to be copied.                     */
/*  RETURNS:    void                                                   		*/
/*                                                                         */
/***************************************************************************/

void near DisplayAdText (void)
{
	static iScreen = 0;  /* Index for which banner "screen" to display */

	/* Clear the banner area of the screen */
	VideoScrollDn (TITLE_ROW, 0, TITLE_ROW + MAX_BANNER_LINES,
						VideoGetWidth() - 1, 0, GetBackGroundColor());

	/* Display the banner's text */
	DisplayText (ppszBanners[iScreen++], 4);

	if (ppszBanners[iScreen][0] == NULL)
		iScreen = 0;
}


#ifndef OEMBASE
/***************************************************************************
 * CopyDblspaceBin - Copies DBLSPACE.BIN when in use, or found on root.
 * 						And if the boot drive is swapped, IO.SYS, COMMAND.COM
 *                   and MSDOS.SYS are also copied to the root of the
 * 						boot drive.
 *                   Also makes the files system-hidden-readonly.
 *
 * ARGUMENTS:  None.
 * RETURNS:    Void.
 *
 ***************************************************************************/

#define MAX_DBLSPACE_FILES_LIST   5

void near CopyDblspaceBin (void)
{
  int fDblspaceBinFound = FALSE;  /* TRUE if DBLSPACE.BIN found   */
  int i;                          /* Looping variable             */
                                  /* Xcopy() structure            */
  struct MULT_FILES File[MAX_DBLSPACE_FILES_LIST];
  char   **pszCopyNames;          /* Points to names to copy      */

#ifdef UJANUS
  static char *szSysFileNames[]    = { "IO.SYS", "MSDOS.SYS", "COMMAND.COM",
                                     "DBLSPACE.BIN", NULL };
#else
  // astro raid #5125 - OEM names should not be hardcoded
  static char *szSysFileNames[]    = { BIOS_FILE, MSDOS_FILE,
													"COMMAND.COM", "DBLSPACE.BIN", NULL };
#endif


  /* Does DBLSPACE.BIN exist on the HOST boot drive */
  *szDblSpace = vInfo.chHdHostDrv;
  fDblspaceBinFound = !access (szDblSpace, 0);

  /* Is there anything we need to do */
  if (vInfo.Flag2.fDoubleSpace == FALSE && fDblspaceBinFound == FALSE)
    return;


  /* Special case if DBLSPACE.BIN is found at root,
   *   or DoubleSpace driver active in memory,
   *   but we are in a non-swapped case, only copy dblspace.bin
   */
  if (vInfo.Flag2.fDualInstall == FALSE)
    pszCopyNames      = &szSysFileNames[3];
  else
    pszCopyNames      = szSysFileNames;


  /****************************************************/
  /* Install the new files from the distribution disk */
  /****************************************************/

  /* Clear out the Xcopy() structure */
  memset (File, 0, sizeof (struct MULT_FILES) * MAX_DBLSPACE_FILES_LIST);

  /* Name each of the files to be copied */
  for (i = 0; pszCopyNames[i] != NULL; i++)
    {
      /* Source drive, path, and filename */
      File[i].Drive.Source = vInfo.chSource;
      File[i].Path.Source  = vInfo.szSource + 2;
      File[i].Name.Source  = GetRealSrcName (pszCopyNames[i]);

      /* Return if there was no real source name */
      if (File[i].Name.Source == NULL)
        return;


      /* Destination drive, path, and filename */
      File[i].Drive.Destin = vInfo.chHdHostDrv;
      File[i].Path.Destin  = szRootPath;
      File[i].Name.Destin  = GetRealDestName (pszCopyNames[i]);

      /* Return if there was no real destination name */
      if (File[i].Name.Destin == NULL)
        return;


      /* Set up source and destination disk "names" */
      File[i].UserDisk     = NOT_REMOVEABLE;

      if (vInfo.chSource >= vInfo.chFirstHd)
        File[i].DiskNumber = NOT_REMOVEABLE;
      else
        File[i].DiskNumber = GetRealSrcDisk (File[i].Name.Source,
                                             FIRST_USER_DISK);
    }

  /* Perform the copy */
  Xcopy (File);

  /* Set the file attributes */
  MakeHidden (vInfo.chHdHostDrv);
}
#endif	// !OEMBASE


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\oem\autoconf.c ===
/***************************************************************************
 * AUTOCONF.C
 *
 * Microsoft Confidential
 * Copyright (c) Microsoft Corporation 1990-1991
 * All Rights Reserved
 *
 * Functions for creating a config.sys and autoexec.bat file for the DOS
 * 5.0 OEM installation program.
 *
 * Change log:
 *
 *   	Date       #		Description
 * 	--------  ----	----------------------------------------------------
 *      02/28/90        Created
 *      02/27/91  M001  Added codes.h.
 *      03/21/91  M003  If Country installed Code Page does not match Country
 *                      default Code Page, add Code Page to "COUNTRY="
 *			statement.
 ***************************************************************************/

#include    <stdio.h>
#include    <stdlib.h>
#include    <memory.h>
#include    <string.h>
#include    <dos.h>
#include    <io.h>
#include    <malloc.h>

#include    <oem.h>
#include    <autoconf.h>
#include    <codes.h>                   /* M001 */
#include    <alias.h>
#include    <bios_io.h>
#include    <disk_io.h>
#include    <strlib.h>
#include    <window.h>
#include    <message.h>

/***************************************************************************/

#define     FILE_BUF_SIZE     2048     /* Size of file buffer in bytes     */

/***************************************************************************/

char  *apszFile[] = { "X:\\CONFIG.SYS", "X:\\AUTOEXEC.BAT" };
char  *apszOld[]  = { "X:\\CONFIG.OLD", "X:\\AUTOEXEC.OLD" };

static char *szBuf;                          /* Buffer to build file in    */
static char *szEndLine = "\r\n";             /* End of line characters     */

/*
** Signals to CreatAutoexec() from CreatConfig() that display.sys has been
** loaded.
*/
static int  fDisplayLoaded = FALSE;
static int  fEGADisplayLoaded = FALSE;

/***************************************************************************/

extern void AutoConfig(void);
static unsigned CreatAutoexec(void);
static unsigned CreatConfig(void);

static char chBootDrv;

/***************************************************************************/
/* Main function for creating autoexec.bat and config.sys files. First     */
/* renames an existing file of the same name to *.OLD and then call a      */
/* function for each of the files.                                         */
/*                                                                         */
/* void AutoConfig( void )                                                 */
/*                                                                         */
/* ARGUMENTS:  NONE                                                        */
/* RETURNS:    void                                                        */
/*                                                                         */
/***************************************************************************/

void AutoConfig( void )
{
   char              *apszError[ ERROR_LINES ];
   register          i;
   register          iStatus;
   int               iFile;
   unsigned          uToWrite;
   unsigned          uWritten;

   static unsigned   Errors[] = { CONFIG_SYS_ERROR, AUTOEXEC_BAT_ERROR };
   /*
   ** n.b., CreatConfig() sets some flags which CreatAutoexec() requires.
   ** So CreatConfig() must be called before CreatAutoexec().
   */
   static unsigned   (*Func[])(void) = { CreatConfig, CreatAutoexec };

   chBootDrv = vInfo.chDestin;
   if ( chBootDrv != vInfo.chFirstHd )
      chBootDrv = 'A';

   szBuf = GetMemory( FILE_BUF_SIZE );
                                                /* Loop once for each file */
   for ( i = 0; i < 2; i++ )
   {
      apszOld[i][0] = apszFile[i][0] = vInfo.chDestin;

                                    /* There may be old files so save them */

      _dos_setfileattr( apszOld[i], _A_NORMAL );
      unlink( apszOld[i] );
      rename( apszFile[i], apszOld[i] );

      uToWrite = (*Func[i])();            /* Create the text for the file  */

                                          /* Next create the file          */

      if ( uToWrite > 0 )
      {
         DisplayFileStatus( apszFile[i]+ 3, WRITE );
         iStatus = ERROR;
         if ( _dos_creat( apszFile[i], 0, &iFile ) == OK )
         {
            if ( _dos_write( iFile, szBuf, uToWrite, &uWritten )  == OK &&
                 uWritten == uToWrite )
               iStatus = OK;

            iStatus |= (int)_dos_close( iFile );
         }
         if ( iStatus != OK )
         {
            GetMessage( apszError, Errors[i] );
            Error( apszError );
         }
      }
   }

   FreeMemory( szBuf );
}

/***************************************************************************/
/* Creates a new CONFIG.SYS file in the file buffer. First checks for      */
/* extended memory and if available forces DOS to load into the high       */
/* memory area.  Next a check is done to see if a COUNTRY line should be   */
/* added.                                                                  */
/*                                                                         */
/* unsigned CreatConfig( void )                                            */
/*                                                                         */
/* ARGUMENTS:  NONE                                                        */
/* RETURNS:    unsigned - Number of bytes in the new file.                 */
/*                        NOTE: this number may be zero which will signal  */
/*                              that no CONFIG.SYS file will be created.   */
/*                                                                         */
/***************************************************************************/

unsigned CreatConfig( void )
{
   char        *szPtr, *szDOSPath;
   unsigned    fIsConvertible;
	char			szTmp[20];

   szPtr = szBuf;
   *szPtr = EOL;
   szDOSPath = vInfo.szPath + 2;

	strcat( szPtr, DEVICE_STR );                    /* "DEVICE=SETVER.EXE"	*/
   szPtr = strchr( szPtr, EOL );
   BuildPath( szPtr, chBootDrv, szDOSPath, SETVER_STR );
   strcat( szPtr, szEndLine );

                     /* If extended memory is available put DOS in himem	*/
   if ( vInfo.Hw.Cpu > 0 && vInfo.Hw.ExtMem >= HIMEM_K_SIZE )
   {
      strcat( szPtr, DEVICE_STR );                    /* "DEVICE=HIMEM"    */
      szPtr = strchr( szPtr, EOL );
      BuildPath( szPtr, chBootDrv, szDOSPath, HIMEM_STR );
      strcat( szPtr, szEndLine );
      strcat( szPtr, XMA_STR );                       /* "DOS=HIGH"        */
      strcat( szPtr, szEndLine );
   }

	if ( vInfo.Hw.VideoType == EGA_DISPLAY )
	{
		strcat( szBuf, DEVICE_STR );							/* "DEVICE=EGA.SYS"  */
		szPtr = strchr( szBuf, EOL );
		BuildPath( szPtr, chBootDrv, vInfo.szPath + 2, EGA_SYS );
      strcat( szPtr, szEndLine );
	}

   /* If country is not the default add "COUNTRY=" line.  */
   /* n.b., we need to install NLSFUNC only to do a CHCP. */
   if ( vInfo.Country != COUNTRY_NONE )
   {
      strcat( szPtr, COUNTRY_STR );                   /* "COUNTRY="        */
      strcat( szPtr, CountryCode[vInfo.Country].pszName ); /* Country code */

      /* M003: If Country installed Code Page does not match Country
       *       default Code Page, add Code Page to "COUNTRY=" statement.
       */
      strcat( szPtr, SEPARATOR_STR );
      if( CountryCode[vInfo.Country].uCP1 != CountryCode[vInfo.Country].uCP2 )
         strcat( szPtr, itoa(CountryCode[vInfo.Country].uCP1, szTmp, 10) );
      strcat( szPtr, SEPARATOR_STR );

      if ( vInfo.Flag.fHardInstall )
      {
         szPtr = strchr(szPtr, EOL);
         BuildPath( szPtr, chBootDrv, szDOSPath, COUNTRYDRV_STR );
      }
      else
         strcat( szPtr, COUNTRYDRV_STR );

      strcat( szPtr, szEndLine);

      /*
      ** Add DISPLAY.SYS for EGA, VGA, and LCD displays, but not for
      ** monochrome, CGA, or Hercules displays.
      **
      ** EGA and VGA displays use EGA parameter for con.
      ** IBM PC Convertibles use LCD parameter for con.
      */

      /*
      ** n.b., the IsConvertible() call must come first in this predicate.
      ** We must make certain the value of fIsConvertible has always been set,
      ** since we use it inside the body.
      */
      if ( (fIsConvertible = IsConvertible()) ||
           (vInfo.Hw.VideoType == EGA_DISPLAY) ||
           (vInfo.Hw.VideoType == EGA_MONO_DISPLAY) ||
           (vInfo.Hw.VideoType == VGA_DISPLAY) ||
           (vInfo.Hw.VideoType == VGA_MONO_DISPLAY) )
      {
         strcat(szPtr, DEVICE_STR);
         szPtr = strchr(szPtr, EOL);
         BuildPath(szPtr, chBootDrv, szDOSPath, DISPLAY_START_STR);

         /* Tell CreatAutoexec() we're loading display.sys in config.sys. */
         fDisplayLoaded = TRUE;

         if (fIsConvertible)
            strcat(szPtr, LCD_STR);
         else
         {
            /*
            ** Tell CreatAutoexec() we're loading the EGA version of
            ** display.sys in config.sys.
            */
            fEGADisplayLoaded = TRUE;
            strcat(szPtr, EGA_STR);          /* EGA or VGA -- both use EGA */
         }

         strcat(szPtr, DISPLAY_END_STR);
         strcat(szPtr, szEndLine);
      }
   }

   strcat( szPtr, FILES_STR );                        /* FILES= line       */
   strcat( szPtr, szEndLine );

   #ifdef   STACKS_STR
      strcat( szPtr, STACKS_STR );                    /* STACKS= line      */
      strcat( szPtr, szEndLine );
   #endif


#ifdef JAPAN			/* ### if JAPAN ### */

// Add ANSI.SYS
      strcat(szPtr, DEVICE_STR);
      szPtr = strchr(szPtr, EOL);
      BuildPath(szPtr, chBootDrv, szDOSPath, ANSI_STR);

/* if KKC */
//
//	Install Kana Kanji Convert Device Driver
//

   if (vInfo.Flag.fKKC)		/* If Install KKC */
   {

// Add KKCFUNC.SYS
      strcat(szPtr, KKC_REM_STR);
      strcat(szPtr, DEVICE_STR);
      szPtr = strchr(szPtr, EOL);
      BuildPath(szPtr, chBootDrv, szDOSPath, KKCFUNC_STR);

// This is just a sample for OEM, so we store 'REM' here
      strcat(szPtr, KKC_REM_STR);

// At here 'REM DEVICE=A:\KKC.SYS" will be made
      strcat(szPtr, DEVICE_STR);
      szPtr = strchr(szPtr, EOL);
      BuildPath(szPtr, chBootDrv, szDOSPath, KKC_STR);

// Add option for input mode '/M0','/M1','/M2','/M3','/M4' or '/M5'
      strcat(szPtr, KKC_INPUT_STR);
      szPtr = strchr(szPtr, EOL);
      *(szPtr) = vInfo.KKC.input + '0';
      *(szPtr+1) = EOL;

// Add option for convert mode '/HB', '/HS' or '/HR'
      if (vInfo.KKC.convert == 0)
         strcat(szPtr, KKC_CONVERT0_STR);
      else if (vInfo.KKC.convert == 1)
         strcat(szPtr, KKC_CONVERT1_STR);
      else if (vInfo.KKC.convert == 2)
         strcat(szPtr, KKC_CONVERT2_STR);

// Add option for dictionary learning mode '/L'
      if (vInfo.KKC.learn)
         strcat(szPtr, KKC_LEARN_STR);

// Add options for dictionary drive '/A:'
      strcat(szPtr, KKC_DRIVE_STR);
      szPtr = strchr(szPtr, EOL);
      *(szPtr) = vInfo.KKC.drive + 'A';
      *(szPtr+1) = ':';
      *(szPtr+2) = EOL;

// Add option for code system '/J'
      if (vInfo.KKC.code)
         strcat(szPtr, KKC_CODE_STR);

// Add option for system directory '/SYS=A:\'
      strcat(szPtr, KKC_SYS_STR);
      szPtr = strchr(szPtr, EOL);
      BuildPath(szPtr, chBootDrv, szDOSPath, KKC_CRLF_STR);

   }


#endif				/* ### end if JAPAN ### */

   szPtr = strchr( szBuf, EOL );
   return( (UINT)(szPtr - szBuf) );
}

/***************************************************************************/
/* Creates a new AUTOEXEC.BAT file in the file buffer. First adds all of   */
/* the standard items which are used on all systems and then based on the  */
/* user options may add the keyboard driver, mouse or dos shell.           */
/*                                                                         */
/* unsigned CreatAutoexec( void )                                          */
/*                                                                         */
/* ARGUMENTS:  NONE                                                        */
/* RETURNS:    unsigned - The number of bytes in the new file.             */
/*                                                                         */
/***************************************************************************/

unsigned CreatAutoexec( void )
{
   char     *szPtr, *szDOSPath;
	char		szTmp[20];

   szPtr = szBuf;
   *szPtr = EOL;
   szDOSPath = vInfo.szPath + 2;

   /* Load for 286's and up with enough memory */
   if ( vInfo.Hw.Cpu >= 1 && vInfo.Hw.ExtMem >= SMARTDRV_MIN_K )
   {
       BuildPath( szPtr, chBootDrv, szDOSPath, SMARTDRV_STR );
       strcat( szPtr, szEndLine );            /* "DEVICE=SMARTDRV.EXE"     */
   }
   
   strcat( szPtr, AUTO_STR );             /* Add standard autoexec items   */
   
   if ( vInfo.Flag.fNoClock )             /* If no clock installed add a   */
      strcat( szPtr, TIME_DATE_STR );     /* time and date string          */

                                          /* Append the dos path string    */
                                          /* and TEMP= string              */
   if ( vInfo.Flag.fHardInstall )
   {
      strcat( szPtr, PATH_STR );
      szPtr = strchr( szPtr, EOL );
      BuildPath( szPtr, chBootDrv, szDOSPath, "" );
      RemoveTrailing( szPtr + 3, '\\' );  /* Remove trailing separator     */
      strcat( szPtr, szEndLine );         /* Add the CR LF characters      */

      strcat( szPtr, TEMP_STR );
      szPtr = strchr( szPtr, EOL );
      BuildPath( szPtr, chBootDrv, szDOSPath, "" );
      RemoveTrailing( szPtr + 3, '\\' );  /* Remove trailing seperater     */
      strcat( szPtr, szEndLine );         /* Add the CR LF characters      */
   }

   /* If keyboard is not the default, install KEYB. */
   if (( vInfo.Keyboard != KEYB_NONE ) || (vInfo.Country != COUNTRY_NONE))
   {
      /*
      ** If display.sys was loaded in config.sys, add codepage support for
      ** KEYB in autoexec.bat.
      */
      if (fDisplayLoaded)
      {
                                          /* Add MODE CON CP PREP... line. */
         strcat(szPtr, CP_START_STR);
         strcat(szPtr, CP_PREP_STR);

         /* Add appropriate country codepage for KEYB. */
         strcat(szPtr, itoa(CountryCode[vInfo.Country].uCP1, szTmp, 10));

         strcat(szPtr, CP_MID_STR);

         szPtr = strchr(szPtr, EOL);
         BuildPath(szPtr, chBootDrv, szDOSPath,
                   fEGADisplayLoaded ? EGA_STR : LCD_STR);

         strcat(szPtr, CP_END_STR);
         strcat(szPtr, szEndLine);

                                        /* Add MODE CON CP SELECT... line. */
         strcat(szPtr, CP_START_STR);
         strcat(szPtr, CP_SELECT_STR);

         /* Add appropriate country codepage for KEYB. */
         strcat(szPtr, itoa(CountryCode[vInfo.Country].uCP1, szTmp, 10));
         strcat(szPtr, szEndLine);
      }

      if (vInfo.Keyboard != KEYB_NONE)
      {
          /* Add KEYB line. */
          strcat(szPtr, KEYB_STR);
          strcat(szPtr, KeybCode[vInfo.Keyboard].pszName);    /* Keyboard code */
          strcat(szPtr, NULL_OPT_STR);
          szPtr = strchr(szPtr, EOL);
          BuildPath(szPtr, chBootDrv, szDOSPath, KEYBDRV_STR);
          strcat(szPtr, szEndLine);
      }
   }

#ifdef INSTALL_MOUSE
                                                   /* See if adding mouse  */
   if ( vInfo.Flag.fMouse )
   {
      if ( vInfo.Flag.fHardInstall )
      {
         szPtr = strchr( szPtr, EOL );
         BuildPath( szPtr, chBootDrv, szDOSPath, MOUSE_STR );
      }
      else
         strcat( szPtr, MOUSE_STR );

      strcat( szPtr, szEndLine );
   }
#endif
                                                /* See if adding dos shell */
   if ( vInfo.Flag.fShell && vInfo.Flag.fHardInstall )
   {
      szPtr = strchr( szPtr, EOL );
      BuildPath( szPtr, chBootDrv, szDOSPath, SHELL_STR );
      strcat( szPtr, szEndLine );
   }

   szPtr = strchr( szPtr, EOL );
   return( (UINT)(szPtr - szBuf) );
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\oem\extern.c ===
/***************************************************************************/
/*                                                                         */
/* Microsoft Confidential                                                  */
/* Copyright (c) Microsoft Corporation 1989-1991                           */
/* All Rights Reserved.                                                    */
/*                                                                         */
/* johnhe - 12/29/89
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\unicode.inc ===
!if 0

Copyright (C) Microsoft Corporation, 2000 - 2000

Module Name:

    unicode.inc

!endif

CharWidth = unicode

C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE

!ifdef USE_MFC
USE_MFCUNICODE = 1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\ansi.inc ===
!if 0

Copyright (C) Microsoft Corporation, 2000 - 2000

Module Name:

    ansi.inc

!endif

CharWidth = ansi

ALT_PROJECT_TARGET = win95
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\basestr.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by basestr.rc
//
#define IDS_SNAPIN_FAILED_INIT          12000
#define IDS_VIEW                        12001
#define IDS_VIEW_LARGE                  12002
#define IDS_VIEW_SMALL                  12003
#define IDS_VIEW_LIST                   12004
#define IDS_VIEW_DETAIL                 12005
#define IDS_VIEW_HTML                   12006
#define IDS_ARRANGE_ICONS               12007
#define IDS_ARRANGE_AUTO                12008
#define IDS_LINE_UP_ICONS               12009
#define IDS_NAME                        12010
#define IDS_TYPE                        12011
#define IDS_ADD_TO_FAVORITES            12012
#define IDS_ORGANIZEFAVORITES           12013
#define IDS_MESSAGE_NOT_FOUND_ERROR     12014
#define IDS_NODE_NOT_FOUND              12015
#define IDS_E_UNEXPECTED                12016

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\oem\autofmt.c ===
/***************************************************************************
 * AUTOFMT.C
 *
 * Microsoft Confidential
 * Copyright (c) Microsoft Corporation 1990-1991
 * All Rights Reserved
 *
 * Functions for automatically spawning format for all unformatted hard
 * disks.
 *
 * Change log:
 *
 *   	Date       #		Description
 * 	--------  ----	----------------------------------------------------
 *      02/18/90        Created
 *      02/27/91  M001  Fix szFormat offset in GetRealSrcDisk().
 *      02/28/91  M002  Call DisplayFormatScreen() every iteration of format
 *                      loop in HdFormatLoop().
 ***************************************************************************/

#include 	<stdio.h>
#include 	<stdlib.h>
#include 	<bios.h>
#include 	<memory.h>
#include		<dos.h>
#include		<fcntl.h>
#include 	<string.h>
#include 	<process.h>

#include 	<alias.h>
#include		<oem.h>
#include 	<message.h>
#include 	<bios_io.h>
#include 	<disk_io.h>
#include		<hdisk.h>
#include 	<window.h>
#include		<data.h>
#include		<format.h>
#include		<nudoswin.h>

/***************************************************************************/

extern char	*SectorBuf;        /* sector work buffer declared in initial.c */
extern char	*BootSecBuf;       /* sector work buffer declared in initial.c */
extern struct HdInfo *HdInfo;  /* declared in initial.c                    */

static int	StatusRow;								/* Format status screen row	*/
static int	StatusCol;								/* Format status screen col	*/
static char	*StatusStr; 							/* Ptr to status string			*/

/***************************************************************************/

static int	HdFormatLoop	( char FirstHd );

static void	(interrupt far	*OldInt2f)();		/* Original int 2fh addr.		*/

void interrupt far NewInt2f( unsigned es, unsigned ds,
			unsigned di, unsigned si, unsigned bp, unsigned sp,
			unsigned bx, unsigned dx, unsigned cx, unsigned ax );

static int	DoubleSpaceInUse	(void);

/***************************************************************************/
/* Function to automatically format all hard disks in a system which have	*/
/* unformatted parititions.																*/
/*																									*/
/*	void AutoHdFormat( void )																*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- OK if primary partition is OK else ERROR				*/
/* 																								*/
/***************************************************************************/

int AutoHdFormat( void )
{
	register						iStatus;

	OldInt2f = _dos_getvect( 0x2f );						/* Set our message hook	*/
	_dos_setvect( 0x2f, NewInt2f );

	iStatus = HdFormatLoop( vInfo.chFirstHd );

	_dos_setvect( 0x2f, OldInt2f );						/* Restore orig int 2f	*/

	if ( iStatus == OK )
	{
		if (GetHardDiskInfo() == 0 || HdInfo->DiskError == TRUE)
			iStatus = ERROR;
	}

	return( iStatus );
}

/***************************************************************************/
/* This is an interrupt function which will be used by the format program	*/
/* update the format status window on the screen. It is passed the			*/
/* percent of format completed in AX. All registers are preserved by the	*/
/* interrupt handler except AX which returns 0 for OK or !0 if aborting	   */
/* the format (not implemented).															*/
/* 																								*/
/*	ENTRY						- AX == 0x4900													*/
/*								  BX == Percent of format complete						*/
/*	REGISTERS DESTROYED	- NONE															*/
/* 																								*/
/***************************************************************************/
																				/*lint -e715	*/
void interrupt far NewInt2f( unsigned es, unsigned ds,
			unsigned di, unsigned si, unsigned bp, unsigned sp,
			unsigned bx, unsigned dx, unsigned cx, unsigned ax )
{
	char		szPercent[ 10 ];
	char		*szPtr;
	char		*szRevPtr;

	((void)es), ((void)ds),	((void)si),	((void)bp), ((void)sp);
	((void)di), ((void)dx), ((void)dx), ((void)cx);

	if ( ax != 0x4900 )
		_chain_intr( OldInt2f );

	szPtr = strchr( StatusStr, '%' ) - 1;

	itoa( (int)bx, szPercent, 10 );
	szRevPtr = strchr( szPercent, EOL ) - 1;

	while( szRevPtr >= szPercent )
		*(szPtr--) = *(szRevPtr--);

	while( szPtr >= StatusStr )
		*(szPtr--) = ' ';

	VideoPutsRowCol( StatusRow, StatusCol, StatusStr );

	ax = 0;						/* Signal everything ok to continue formatting	*/
}																				 /*lint +e715	*/

/***************************************************************************
 * Displays the auto format screen.														
 *																									
 *	void DisplayFormatScreen( unsigned uText, char chDrv )
 *																									
 *	ARGUMENTS:	uText - Offset of message text to use.
 *					chDrv - Drive letter ('A','B','C',...)
 *	RETURN:		void																			
 *																									
 ***************************************************************************/

void DisplayFormatScreen( unsigned uText, char chDrv )
{
	char						*apszPrompt[ HD_FMT_STAT_LINES ];
	char						szTmp[ MAX_SCRN_LINE_LEN ];
	struct WindowStruct	Wind;

	NewScreen( uText, 0 );
	GetMessage( apszPrompt, HD_FMT_STAT_TEXT );

	sprintf( szTmp, apszPrompt[2], chDrv );

	GetWindowInfo( apszPrompt, &Wind );					/* Display a window 		*/
	Wind.Color = (char)(GetPromptColor());
	Wind.BorderColor = (char)(GetPromptColor());
	PutWindow( &Wind );

	VideoPutsRowCol( Wind.Top+2, CenterStr(szTmp), szTmp );

	StatusStr = apszPrompt[ 3 ];
	StatusRow = Wind.Top + 3;
	StatusCol = CenterStr( StatusStr );
}


/***************************************************************************/
/* Function which loops through all drive letters starting from the first	*/
/* fixed disk and checks if the drive is partitioned and if not will 		*/
/* spawn format to format the disk. Requires that the new int 2fh handler	*/
/* has already been installed so that format can return the format status.	*/
/* Will update the prompt with the current drive letter for each disk		*/
/* that needs formatting. An immediate return of error is done if there		*/
/* are any errors on the first drive letter because this would mean a		*/
/* bad primary parition.																	*/
/*																									*/
/*	void HdFormatLoop( char FirstHd )													*/
/*																									*/
/*	ARGUMENTS:	FirstHd	- Drive letter of first hard disk in the system		*/
/*	RETURNS:		int		- OK if first paritition is alright else ERROR		*/
/*																									*/
/* NOTE: Need to remember TRUE == 1, FALSE == 0, OK == 0 & ERROR == -1		*/
/***************************************************************************/

int HdFormatLoop( char FirstHd )
{
	static char			*szFormat = FORMAT_STR;
	char					CurrentDisk;
	register				ProgDisk;
	register				iStatus;
	static char			*apszSwitches[] = { FORMAT_STR, "X:", "/U",
													  "/SELECT", "/V:DOS", NULL };

	ProgDisk = GetRealSrcDisk( szFormat + 3, 0 );	/* M001 */
	*szFormat = vInfo.chSource;

   /* We need to set the unformatted media bit for each partition here, so
   ** the IsValidHardDrive() call can be completed successfully. */
	for (CurrentDisk = FirstHd; CurrentDisk <= 'Z'; CurrentDisk++)
      EnableDiskAccess((UCHAR)CurrentDisk - 'A');

	for( CurrentDisk = FirstHd; IsValidHardDrive( CurrentDisk ); CurrentDisk++ )
	{
		if ( (iStatus = HasValidFormat( CurrentDisk )) == FALSE )
		{
         /* Warn the user that we are about to format an unformatted hard
         ** disk partition.  Give them a choice between formatting the
         ** partition and bailing out of Setup.  The fAskPartPrompt flag in
         ** vInfo is initialized to TRUE in initial.c and only changed to
         ** FALSE if the user selects "Allocate all free space for MS-DOS" in
         ** prompts.c!GetPartOpts().
         */
         if (vInfo.Flag.fAskPartFormat == TRUE)
            UnformattedPartPrompt(CurrentDisk);

			DisplayFormatScreen( HD_FMT_TEXT, CurrentDisk );
			DoInt2f( 0 ); 								/* Prompt with 0% formatted	*/
			DispInsertDisk( ProgDisk );

			apszSwitches[1][0] = CurrentDisk;
			iStatus = spawnv( P_WAIT, szFormat, apszSwitches );

         if (iStatus == OK)
            /* Make a note that this drive has been formatted, so we can
            ** leave the state of its unformatted media bit set properly.
            */
            NowFormatted(CurrentDisk);
		}
		else if ( iStatus != ERROR )
			iStatus = OK;

		if ( iStatus != OK )
		{
			if ( CurrentDisk == FirstHd )
				return( ERROR );
			else
				FormatError( CurrentDisk );
		}
	}
	return( OK );
}

/***************************************************************************/
/* Reads in the boot record of a drive using the specified drive letter		*/
/* and then does a call to see if the boot record is formatted.				*/
/*																									*/
/*	int HasValidFormat( char DrvLetter )												*/
/*																									*/
/*	ARGUMENTS:	DrvLetter	- Dos drive letter of drive to check				*/
/*	RETURNS:		int			- TRUE if valid formatted boot record				*/
/*									  FALSE if not a valid boot record					*/
/*									  ERROR if couldn't read the boot sector			*/
/*																									*/
/***************************************************************************/

int HasValidFormat( char DrvLetter )
{
	if ( ReadWriteBoot( DrvLetter - 'A', BootSecBuf, READ ) != OK )
		return( ERROR );
	else if ( IsFmtedBoot( BootSecBuf ) == TRUE )
		return( TRUE );
	else
		return( FALSE );
}

/***************************************************************************/
/*																									*/
/*	Makes a disk formatted under DOS 2 or DOS 3 (< 3.31) bootable under     */
/* DOS 5.                                                                  */
/*																									*/
/*    The extended BPB was introduced with DOS 3.31, and added 6 bytes to  */
/* end of the regular BPB.  The extended BPB changed the last BPB entry    */
/* from an unsigned word (unsigned int) into an unsigned dword (an         */
/* unsigned long -- called ulHiddenSec) and added an unsigned dword entry  */
/* following it called ulTotalBigSecs.  This change only causes a boot     */
/* problem for the DOS 4 and DOS 5 boot loaders on DOS 2 and DOS 3         */
/* formatted disks because the 6 bytes added to the old BPB to create the  */
/* extended BPB were used for other purposes in DOS 2 and DOS 3, and so    */
/* contain garbage values as far as DOS 4 and DOS 5 are concerned.  Only   */
/* the bogus ulHiddenSec value actually causes problems for the DOS 4 and  */
/* DOS 5 boot loaders, since it causes them to compute an erroneously      */
/* large offset into the disk to look for IO.SYS.                          */
/*																									*/
/*    We only need to correct the ulHiddenSec value to make the disk       */
/* bootable under DOS 4 and DOS 5, but we fix up the ulTotalBigSecs entry  */
/* for anyone else who might use it.  (Although they shouldn't use it if   */
/* uTotalSectors != 0U.)                                                   */
/*																									*/
/*    We begin by copying the RelativeSector entry from the partition's    */
/* entry in the partition table to the ulHiddenSec entry in the new        */
/* extended BPB.  Then, if the uTotalSectors entry is non-zero, we assume  */
/* it is correct and zero out the ulTotalBigSecs entry in the new extended */
/* BPB.  If the uTotalSectors entry is zero, we copy the TotalSectors      */
/* entry from the partition table into the ulTotalBigSecs entry in the new */
/* extended BPB.  The media descriptor byte is always made 0xf8.  We also  */
/* make sure the system indicator byte in the partition table is changed   */
/* to 6 for DOS 5 if necessary.                                            */
/*																									*/
/*    Of course, this disk will now no longer be bootable under DOS 2 or   */
/* DOS 3 since we will have destroyed some of the data used by those       */
/* earlier versions of the boot loader.                                    */
/*																									*/
/*																									*/
/*	int FixUpBPB(char DriveLetter)     	   											*/
/*																									*/
/*	ARGUMENTS:	DriveLetter	- DOS drive letter of boot drive to fix 			*/
/*									  (This better be correct or we'll fix up the   */
/*                            wrong BPB, and fail to fix up the boot BPB.) */
/*	RETURNS:		int         - TRUE if fix was successful,                   */
/*                           FALSE if not                                  */
/*																									*/
/***************************************************************************/

int FixUpBPB(char DriveLetter)
{
	struct ABSIO_PACKET absPack;
   int BootPart;        /* partition table offset of boot partition [0..3] */

   /* BootSecBuf is filled in with the boot sector by HasValidFormat().    */
   struct BPB  *pBPB  = (struct BPB *) (BootSecBuf + BPB_OFFSET);

   /* SectorBuf is filled in with the MBR by RdWrSector().                 */
	struct Part *pPart = (struct Part *)(SectorBuf  + TABLE_OFFSET);


   /* First make sure the drive has an ok DOS format, then look at the boot
   ** sector which has been loaded into the global BootSecBuf by
   ** HasValidFormat().
   */
   if (HasValidFormat(DriveLetter) == TRUE)
   {
      /* Read the partition table into the global SectorBuf to get the boot
      ** partition's RelativeSector and TotalSectors values.
      */
   	if (RdWrSector(0x80, 0, 0, 1, READ) != OK ||
          (BootPart = GetBootPart((struct PartTable *)pPart)) == NO_DOS_PART)
         return(FALSE);

      /* Set up pPart to point to boot partition entry in partition table. */
      pPart += BootPart;

      /* Copy RelativeSector entry from partition table to ulHiddenSec entry
      ** in BPB.
      */
      pBPB->ulHiddenSec = pPart->RelativeSector;

      /* Make sure one and only one of the uTotalSectors and ulTotalBigSecs
      ** entries is zero.
      */
      if (pBPB->uTotalSectors != 0U)
         /* Assume uTotalSectors is correct. */
         pBPB->ulTotalBigSecs = 0UL;
      else
         pBPB->ulTotalBigSecs = pPart->TotalSectors;

      /* Make sure the media descriptor byte is HD_MEDIA_BYTE (0xf8).  Some
      ** versions of DOS, e.g., Tandy, put 0xfa in this field.
      */
      pBPB->uchMediaDescr = HD_MEDIA_BYTE;

      /* Set up absPack for BPB write. */
	   absPack.lStartSector = 0L;
	   absPack.uNumSectors = 1;
	   absPack.pchBuffer = BootSecBuf;

		if ( FALSE == DoubleSpaceInUse() )
			{	/* Write out the patched BPB. */
				if (AbsReadWrite(DriveLetter - 'A', &absPack, WRITE) != OK)
					return(FALSE);
			}

      /* Make sure the system indicator entry in the partition table is
      ** changed to type 6 if appropriate for this partition.
      */

      if (pPart->SystemIndicator != DOSNEW &&
			 (pBPB->uTotalSectors + pBPB->ulTotalBigSecs + pBPB->ulHiddenSec)
          > (unsigned long)DOS_MAX)
      {
         pPart->SystemIndicator = DOSNEW;
   	   if (RdWrSector(0x80, 0, 0, 1, WRITE) != OK)
            return(FALSE);
      }

      /* The fix-ups and writes have gone ok. */
      return(TRUE);
   }
   else
      /* We don't recognize this boot sector format, so bail out without
      ** making any changes.
      */
      return(FALSE);
}


/***************************************************************************/
/* Determines wether DoubleSpace disk compression technology is being used.*/
/*                                                                         */
/* int DoubleSpaceInUse (void)                                             */
/*                                                                         */
/* ARGUMENTS:  NONE                                                        */
/* RETURNS;    int      - TRUE if DoubleSpace is in use.                   */
/***************************************************************************/

int DoubleSpaceInUse (void)
{
   union REGS regs;
   int  fDoubleSpace; /* TRUE if this drive is a DS drive      */

   fDoubleSpace = FALSE;

   /* If the INT 2Fh vector is null, return FALSE */
   if (_dos_getvect (0x2f) == NULL)
	   return ( fDoubleSpace );

   /* Ask DoubleSpace if it exists */
   regs.x.ax = 0x4A11;
   regs.x.bx = 0x0000;
   int86 (0x2F, &regs, &regs);

   /* BX == 444Dh if DoubleSpace exists */
   if (regs.x.bx == 0x444D)
   	{	/* DoubleSpace is running on this system */
      fDoubleSpace = TRUE;
	   }

   return ( fDoubleSpace );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\classreg.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      classreg.cpp
 *
 *  Contents:  Class registration code
 *
 *  History:   3-Feb-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"

#ifdef DBG
CTraceTag tagDllRegistration (_T("MMC Dll Registration"), _T("MMC Dll Registration"));
#endif //DBG

/*+-------------------------------------------------------------------------*
 * szObjScript
 *
 * Standard registration script template for all objects.  '%' characters
 * that we want to end up in the final script must be doubled (i.e. "%%")
 * because this string is used as a format string for sprintf.  sprintf
 * will convert "%%" to "%" during formatting.
 *--------------------------------------------------------------------------*/

static const WCHAR szObjScript[] =
    L"HKCR"                                                                     L"\n"
    L"{"                                                                        L"\n"
    L"    %%VProgID%% = s '%%VClassName%%'"                                     L"\n"
    L"    {"                                                                    L"\n"
    L"        CLSID = s '%%VCLSID%%'"                                           L"\n"
    L"    }"                                                                    L"\n"
    L"    %%VVersionIndependentProgID%% = s '%%VClassName%%'"                   L"\n"
    L"    {"                                                                    L"\n"
    L"        CLSID = s '%%VCLSID%%'"                                           L"\n"
    L"        CurVer = s '%%VProgID%%'"                                         L"\n"
    L"    }"                                                                    L"\n"
    L"    NoRemove CLSID"                                                       L"\n"
    L"    {"                                                                    L"\n"
    L"        ForceRemove %%VCLSID%% = s '%%VClassName%%'"                      L"\n"
    L"        {"                                                                L"\n"
    L"            ProgID = s '%%VProgID%%'"                                     L"\n"
    L"            VersionIndependentProgID = s '%%VVersionIndependentProgID%%'" L"\n"
    L"            %%ServerType%% = s '%%VFileName%%'"                           L"\n"
    L"            {"                                                            L"\n"
    L"                val ThreadingModel = s 'Apartment'"                       L"\n"
    L"            }"                                                            L"\n"
    L"            %s"    /* szCtlScript substituted here if necessary */        L"\n"
    L"        }"                                                                L"\n"
    L"    }"                                                                    L"\n"
    L"}";


/*+-------------------------------------------------------------------------*
 * szCtlScript
 *
 * Additional registration script elements for controls.  Note that '%'
 * characters we want to end up in the final script DO NOT need to be
 * doubled, because this string is used as a sprintf replacement parameter
 * (which are substituted as-is) and not the format string (where "%%"'s
 * are converted to "%").
 *--------------------------------------------------------------------------*/

static const WCHAR szCtlScript[] =
    L"            ForceRemove 'Programmable'"                                   L"\n"
    L"            ForceRemove 'Control'"                                        L"\n"
    L"            ForceRemove 'ToolboxBitmap32' = s '%VFileName%, %VBitmapID%'" L"\n"
    L"            'MiscStatus' = s '0'"                                         L"\n"
    L"            {"                                                            L"\n"
    L"                '1' = s '131473'"                                         L"\n"
    L"            }"                                                            L"\n"
    L"            'TypeLib' = s '%VLIBID%'"                                     L"\n"
    L"            'Version' = s '%VVersion%'";


/*+-------------------------------------------------------------------------*
 * MMCUpdateRegistry
 *
 * Registers a COM object or control.  This function typically isn't used
 * directly, but indirectly via DECLARE_MMC_OBJECT_REGISTRATION or
 * DECLARE_MMC_CONTROL_REGISTRATION.
 *
 * This function uses a class (ATL::CRegObject) that ATL only documents
 * indirectly.  Search MSDN for "StringRegister" to find sketchy details.
 *--------------------------------------------------------------------------*/

HRESULT WINAPI MMCUpdateRegistry (
    BOOL                        bRegister,      // I:register or unregister?
    const CObjectRegParams*     pObjParams,     // I:object registration parameters
    const CControlRegParams*    pCtlParams)     // I:control registration parameters (optional)
{
    DECLARE_SC(sc, TEXT("MMCUpdateRegistry"));

    /*
     * validate required inputs
     */
    sc = ScCheckPointers (pObjParams, E_FAIL);
    if(sc)
        return sc.ToHr();

    /*
     * string-ify the CLSID
     */
    CCoTaskMemPtr<WCHAR> spszClsid;
    sc = StringFromCLSID (pObjParams->m_clsid, &spszClsid);
    if (sc)
        return sc.ToHr();

#ifdef _ATL_NAMESPACE_BUG_FIXED
    ::ATL::CRegObject ro;  // hack around nested namespace bug in ATL30
#else
    /*
     * specify the standard object substitution parameters for CRegObject
     */
    ::ATL::ATL::CRegObject ro;  // hack around nested namespace bug in ATL30
#endif
    _ATL_REGMAP_ENTRY rgObjEntries[] =
    {
        {   L"VCLSID",                    spszClsid											},
        {   L"VFileName",                 pObjParams->m_strModuleName.data()				},
        {   L"VClassName",                pObjParams->m_strClassName.data()					},
        {   L"VProgID",                   pObjParams->m_strProgID.data()					},
        {   L"VVersionIndependentProgID", pObjParams->m_strVersionIndependentProgID.data()	},
        {   L"ServerType",				  pObjParams->m_strServerType.data()				},
    };

#ifdef DBG
	std::wstring strReplacements;
#endif

    for (int i = 0; i < countof (rgObjEntries); i++)
    {
        sc = ro.AddReplacement (rgObjEntries[i].szKey, rgObjEntries[i].szData);
        if (sc)
            return (sc.ToHr());

		AddReplacementTrace (strReplacements,
							 rgObjEntries[i].szKey,
							 rgObjEntries[i].szData);
    }


    /*
     * if we're registering a control, add its substitution parameters for CRegObject
     */
    if (pCtlParams != NULL)
    {
        /*
         * string-ify the LIBID
         */
        CCoTaskMemPtr<WCHAR> spszLibid;
        sc = StringFromCLSID (pCtlParams->m_libid, &spszLibid);
        if (sc)
            return (sc.ToHr());

        _ATL_REGMAP_ENTRY rgCtlEntries[] =
        {
            {   L"VLIBID",      spszLibid								},
            {   L"VBitmapID",   pCtlParams->m_strToolboxBitmapID.data()	},
            {   L"VVersion",    pCtlParams->m_strVersion.data()			},
        };

        for (int i = 0; i < countof (rgCtlEntries); i++)
        {
            sc = ro.AddReplacement (rgCtlEntries[i].szKey, rgCtlEntries[i].szData);
            if (sc)
                return (sc.ToHr());
	
			AddReplacementTrace (strReplacements,
								 rgCtlEntries[i].szKey,
								 rgCtlEntries[i].szData);
        }
    }

    /*
     * format the registration script
     */
    WCHAR szRegScript[countof(szObjScript) + countof(szCtlScript)];
    sc = StringCchPrintfW(szRegScript, countof(szRegScript), szObjScript, (pCtlParams != NULL) ? szCtlScript : L"");
    if (sc)
        return sc.ToHr();

    USES_CONVERSION;
    Trace (tagDllRegistration, _T("Registration script:\n%s"), W2T(szRegScript));
    Trace (tagDllRegistration, W2CT(strReplacements.data()));

    /*
     * (un)register!
     */
    sc = (bRegister) ? ro.StringRegister   (szRegScript)
                     : ro.StringUnregister (szRegScript);

	if (sc)
	    return sc.ToHr();

	// change the module path to the absolute one, if we know it
	if ( bRegister && pObjParams->m_strModulePath.length() != 0 )
	{
		// format class ID key.
		tstring strKey = tstring(_T("CLSID\\")) + W2CT( spszClsid );
		strKey += tstring(_T("\\")) + W2CT( pObjParams->m_strServerType.c_str() );

		// see what type of value we need to put
		DWORD dwValueType = CModulePath::PlatformSupports_REG_EXPAND_SZ_Values() ?
							REG_EXPAND_SZ : REG_SZ;

		CRegKey keyServer;
		LONG lRet = keyServer.Open(HKEY_CLASSES_ROOT, strKey.c_str() , KEY_WRITE);
		if (lRet == ERROR_SUCCESS)
		{
			RegSetValueEx( keyServer, NULL, 0, dwValueType,
						   (CONST BYTE *)( W2CT( pObjParams->m_strModulePath.c_str() ) ),
						   (pObjParams->m_strModulePath.length() + 1) * sizeof(TCHAR) );
		}
	}

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\conuistr.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by conuistr.rc
//
#define IDR_MAINFRAME                   128
#define IDR_AMCTYPE                     129
#define IDR_MUIFRIENDLYNAME             130
#define IDS_NEWFOLDER                   181
#define IDS_NEWFAVORITE                 182
#define IDS_FAVFOLDER                   185
#define IDS_ABOUT_ON                    186
#define IDS_FAVORITES                   187
#define ID_HELP_HELPTOPICS              12804
#define IDS_FAVORITES_ACTIVATE          12811
#define IDS_ACTION_COULD_NOTBE_COMPLETED 12813
#define ID_CONSOLE_ADDREMOVESNAPIN      13201
#define ID_CONSOLE_PROPERTIES           13220
#define ID_CUSTOMIZE_VIEW               13231
#define ID_SNAPIN_ABOUT                 13242
#define IDS_WARNING                     13244
#define IDS_TaskpadChangeButtonText     13300
#define IDS_CONSOLE_READONLY            13301
#define IDS_CONVERT_FILE_FORMAT         13302
#define IDS_CONVERT_FILE_FORMAT_CLOSE   13303
#define IDS_CantCloseLastPersistableView 13304
#define IDS_UnableToOpenDocumentMessage 13305
#define IDS_UnableToSaveDocumentMessage 13306
#define IDS_NoActiveView                13307
#define IDS_MENU_FILE                   13308
#define IDS_MENU_VIEW                   13309
#define IDS_MENU_WINDOW                 13310
#define IDS_MENU_HELP                   13311
#define AMC_IDS_WEBCTRL_FAILED_CREATE   13312
#define IDS_ModeAuthor                  13313
#define IDS_ModeUserFull                13314
#define IDS_ModeUserMDI                 13315
#define IDS_ModeUserSDI                 13316
#define IDS_ModeAuthor_Description      13317
#define IDS_ModeUserFull_Description    13318
#define IDS_ModeUserMDI_Description     13319
#define IDS_ModeUserSDI_Description     13320
#define IDS_AUTHORMODE_NOTALLOWED       13321
#define ID_FILE_SNAPINMANAGER           13322
#define IDS_NODEMGR_FAILED              13323
#define IDS_AUTHORMODE_NOTALLOWED_FORSCRIPTS 13324
#define IDS_APP_NAME                    13325
#define ID_VIEW_OPTIONS                 13326
#define IDS_TempDirNotFound             13327
#define ID_WINDOW_TILEVERTICALLY        13328
#define ID_WINDOW_CLOSEALL              13329
#define IDS_Empty                       13330
#define IDS_DiskFull                    13331
#define ID_HELP_WEBTUTORIAL             13332
#define IDS_INVALIDFILE                 13333
#define ID_WINDOW_ACTIVATEWINDOW        13333
#define IDS_InvalidVersion              13334
#define IDS_UnableToLoadSomePortionOfTheTree 13335
#define IDS_FORCE_SDI_PROMPT            13336
#define IDS_NewerVersionRequired        13337
#define ID_VIEW_DESCRIPTIONBAR          13338
#define IDS_PROGRESS                    13339
#define IDS_STATUS_STATIC               13340
#define IDR_REBAR                       13341
#define ID_MENU_ACTION                  13342
#define IDS_CONSOLE_PROPERTIES          13343
#define IDS_LISTSAVE_ER1                13344
#define IDS_LISTSAVE_ER2                13345
#define IDS_LISTSAVE_ER3                13346
#define IDS_ANSI_FILE_TYPE              13347
#define IDS_UNICODE_FILE_TYPE           13348
#define IDS_MENUOPEN                    13349
#define IDS_MENURUNAS                   13350
#define IDS_MENUAUTHOR                  13351
#define IDS_APP_VERSION                 13352
#define IDS_FILESAVE_MESSAGE            13353
#define ID_MENU_VIEW                    13354
#define IDS_HELP_ON                     13355
#define IDS_HELP_ON_SNAPIN              13356
#define IDS_ASK_TO_SAVE                 13357
#define IDS_ClosePropertyPagesBeforeClosingTheDoc 13358
#define IDS_FileNotFound                13359
#define IDS_ExploredWindowFailed        13360
#define IDS_MMC_DOCUMENT                13361
#define IDS_MMCWillCancelPropertySheets 13368
#define IDS_CLOSE                       13375
#define IDS_NEXTWINDOW                  13376
#define IDS_SNAPINMGR_CLOSEPROPSHEET    13377
#define IDS_MENU_MMC_ACTION             13378
#define IDS_MENU_MMC_VIEW               13379
#define IDS_MENU_MMC_FAVORITES          13380
#define IDS_MMC_VERB_CUT                13381
#define IDS_MMC_VERB_COPY               13382
#define IDS_MMC_VERB_PASTE              13383
#define IDS_MMC_VERB_DELETE             13384
#define IDS_MMC_VERB_PROPERTIES         13385
#define IDS_MMC_GENL_UPONELEVEL         13386
#define IDS_MMC_GENL_SCOPE              13387
#define IDS_MMC_VERB_REFRESH            13388
#define IDS_MMC_VERB_PRINT              13389
#define IDS_MMC_VERB_RENAME             13390
#define IDS_MMC_VERB_OPEN               13391
#define IDS_MMC_WEB_BACK                13392
#define IDS_MMC_WEB_FORWARD             13393
#define IDS_MMC_WEB_STOP                13394
#define IDS_MMC_WEB_REFRESH             13395
#define IDS_MMC_WEB_HOME                13396
#define IDS_MMC_GENL_CONTEXTHELP        13397
#define IDS_SAVE_LIST_BUTTON            13398
#define IDS_CloseDocNotLastView         13399
#define IDS_NORMAL                      13400
#define MMC_E_RESULT_ITEM_NOT_FOUND     13401
#define MMC_E_NO_BOOKMARK               13402
#define MMC_E_NOLIST                    13403
#define MMC_E_NO_SELECTED_ITEMS         13404
#define MMC_E_OBJECT_IS_GONE            13405
#define MMC_E_INVALID_COLUMN_INDEX      13406
#define MMC_E_ZERO_COLUMN_INVISIBLE     13408
#define IDS_EMPTY_LIST_MESSAGE          13409
#define MMC_E_NO_MULTISELECT            13410
#define MMC_E_ViewNotExtended           13411
#define MMC_E_NotOnHostedFrame          13412
#define MMC_E_NO_OCX_IN_VIEW            13413
#define MMC_E_INCORRECT_IE_VERSION      13414
#define MMC_E_UnableToLaunchMMC32       13415
#define MMC_E_UnableToLaunchMMC64       13416
#define IDS_DragDrop_CopyHere           13417
#define IDS_DragDrop_MoveHere           13418
#define IDS_DragDrop_Cancel             13419
#define IDS_TabAccessiblity_DefaultAction 13420
#define IDS_FileSize_TB                 13421
#define IDS_FileSize_GB                 13422
#define IDS_FileSize_MB                 13423
#define IDS_FileSize_KB                 13424
#define IDS_FileSize_bytes              13425
#define IDS_ConfirmDeleteTempFiles      13426
#define IDS_NODEMGR_FAILED_9x           13427
#define AFX_IDS_APP_TITLE               0xE000
#define AFX_IDS_IDLEMESSAGE             0xE001
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_MRU_FILE1               0xE110
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#define IDS_EXPORT_LIST                 57654
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151
#define ID_INDICATOR_EXT                0xE700
#define ID_INDICATOR_CAPS               0xE701
#define ID_INDICATOR_NUM                0xE702
#define ID_INDICATOR_SCRL               0xE703
#define ID_INDICATOR_OVR                0xE704
#define ID_INDICATOR_REC                0xE705
#define ID_VIEW_TOOLBAR                 0xE800
#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13
#define AFX_IDS_MDICHILD                0xEF1F
#define AFX_IDS_PREVIEW_CLOSE           0xF005

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\comobjects.cpp ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       comobjects.cpp
//
//  Contents:   Base code for com objects exported by Object Model.
//
//  Classes:    CMMCStrongReferences
//
//  History:    16-May-2000 AudriusZ     Created
//
//--------------------------------------------------------------------

#include "stdafx.h"
#include <atlcom.h>
#include "comerror.h"
#include "events.h"
#include "comobjects.h"


/***************************************************************************\
 *
 * METHOD:  CMMCStrongReferences::AddRef
 *
 * PURPOSE: (static) puts a strong reference on mmc
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    DWORD    -
 *
\***************************************************************************/
DWORD CMMCStrongReferences::AddRef()
{
    return GetSingletonObject().InternalAddRef();
}

/***************************************************************************\
 *
 * METHOD:  CMMCStrongReferences::Release
 *
 * PURPOSE: (static) releases strong reference from MMC
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    DWORD
 *
\***************************************************************************/
DWORD CMMCStrongReferences::Release()
{
    return GetSingletonObject().InternalRelease();
}

/***************************************************************************\
 *
 * METHOD:  CMMCStrongReferences::LastRefReleased
 *
 * PURPOSE: returns whether the last strong reference was released
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    bool    - true == last ref was released
 *
\***************************************************************************/
bool CMMCStrongReferences::LastRefReleased()
{
    return GetSingletonObject().InternalLastRefReleased();
}

/***************************************************************************\
 *
 * METHOD:  CMMCStrongReferences::CMMCStrongReferences
 *
 * PURPOSE: constructor
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
\***************************************************************************/
CMMCStrongReferences::CMMCStrongReferences() :
    m_dwStrongRefs(0),
    m_bLastRefReleased(false)
{
}

/***************************************************************************\
 *
 * METHOD:  CMMCStrongReferences::GetSingletonObject
 *
 * PURPOSE: (helper) returns reference to the singleton object
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CMMCStrongReferences& - singleto object
 *
\***************************************************************************/
CMMCStrongReferences& CMMCStrongReferences::GetSingletonObject()
{
    static CMMCStrongReferences singleton;
    return singleton;
}

/***************************************************************************\
 *
 * METHOD:  CMMCStrongReferences::InternalAddRef
 *
 * PURPOSE: (helper) implements strong addreff
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    DWORD    -
 *
\***************************************************************************/
DWORD CMMCStrongReferences::InternalAddRef()
{
    return ++m_dwStrongRefs;
}

/***************************************************************************\
 *
 * METHOD:  CMMCStrongReferences::InternalRelease
 *
 * PURPOSE: (helper) implements strong release
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    DWORD    -
 *
\***************************************************************************/
DWORD CMMCStrongReferences::InternalRelease()
{
    if (--m_dwStrongRefs == 0)
        m_bLastRefReleased = true;

    return m_dwStrongRefs;
}

/***************************************************************************\
 *
 * METHOD:  CMMCStrongReferences::InternalLastRefReleased
 *
 * PURPOSE: (helper) returns whether the last strong ref was released
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    bool    - true == last ref was released
 *
\***************************************************************************/
bool CMMCStrongReferences::InternalLastRefReleased()
{
    return m_bLastRefReleased;
}

/***************************************************************************\
 *
 * FUNCTION:  GetComObjectEventSource
 *
 * PURPOSE: returns singleton for emmiting Com Object Events
            [ScOnDisconnectObjects() currently is the only event]
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CEventSource<CComObjectObserver>&
 *
\***************************************************************************/
MMCBASE_API
CEventSource<CComObjectObserver>&
GetComObjectEventSource()
{
    static CEventSource<CComObjectObserver> evSource;
    return evSource;
}

/***************************************************************************/
// static members of class CConsoleEventDispatcherProvider
MMCBASE_API
CConsoleEventDispatcher *CConsoleEventDispatcherProvider::s_pDispatcher = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\mmcbase.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      mmcbase.cpp
 *
 *  Contents:  Main entry point for mmcbase.dll
 *
 *  History:   7-Jan-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "atlimpl.cpp"
#include "atlwin.cpp"


static SC ScInitAsMFCExtensionModule (HINSTANCE hInstance);

// the one and only instance.
CComModule _Module;


/*+-------------------------------------------------------------------------*
 *
 * DllMain
 *
 * PURPOSE:     The main DLL entry point
 *
 * PARAMETERS:
 *    HANDLE  hModule :
 *    DWORD   dwReason :
 *    LPVOID  lpReserved :
 *
 * RETURNS:
 *    BOOL APIENTRY
 *
 *+-------------------------------------------------------------------------*/
BOOL APIENTRY DllMain(HINSTANCE hInstance, DWORD  dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        // set the module instance for error codes.
        SC::SetHinst(hInstance);

        /*
         * attach this module to MFC's resource search path
         */
        if (ScInitAsMFCExtensionModule(hInstance).IsError())
            return (FALSE); // bail out

        _Module.Init(NULL, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }

    return TRUE;    // ok
}


/*+-------------------------------------------------------------------------*
 * ScInitAsMFCExtensionModule
 *
 * Initializes this module as an MFC extension.  This is required so MFC
 * code will automatically search this module for resources (in particular,
 * strings).
 *--------------------------------------------------------------------------*/

static SC ScInitAsMFCExtensionModule (HINSTANCE hInstance)
{
    DECLARE_SC (sc, _T("ScInitAsMFCExtensionModule"));

    /*
     * extensionDLL must be static so it lives as long as dynLinkLib below
     */
    static AFX_EXTENSION_MODULE extensionDLL = { 0 };

    if (!AfxInitExtensionModule (extensionDLL, hInstance))
        return (sc = E_FAIL);

    /*
     * Declare a static CDynLinkLibrary for MMC.  Its constructor will
     * add it to the list of modules MFC will search for resources.  It
     * must be static so it will live as long as MMC.
     */
    new CDynLinkLibrary (extensionDLL);

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\eventlock.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       eventlock.cpp
//
//  This file contains code needed to fire script event in a safer way
//  Locks made on stack will postpone firing the event on particular interface
//  as long as the last lock is released.
//--------------------------------------------------------------------------

#include "stdafx.h"
#include <comdef.h>
#include <vector>
#include <queue>
#include "eventlock.h"
#include "mmcobj.h"

// since the templates will be used from outside the library
// we need to instantiale them explicitly in order to get them exported
template class CEventLock<AppEvents>;

/***************************************************************************\
 *
 * METHOD:  CEventBuffer::CEventBuffer
 *
 * PURPOSE: Constructor
 *
\***************************************************************************/
CEventBuffer::CEventBuffer() : m_locks(0) 
{
}
 
/***************************************************************************\
 *
 * METHOD:  CEventBuffer::CEventBuffer
 *
 * PURPOSE: Destructor
 *
\***************************************************************************/
CEventBuffer::~CEventBuffer()
{
}

/***************************************************************************\
 *
 * METHOD:  CEventBuffer::ScEmitOrPostpone
 *
 * PURPOSE: The method will add methods to the queue. If interface is not locked
 *          it will emit it immediately, else it will postpone it till appropriate
 *          call to Unlock()
 *
 * PARAMETERS:
 *    IDispatch *pDispatch - sink interface to receive the event
 *    DISPID dispid        - method's disp id
 *    CComVariant *pVar    - array of arguments to method call
 *    int count            - count of arguments in the array
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CEventBuffer::ScEmitOrPostpone(IDispatch *pDispatch, DISPID dispid, CComVariant *pVar, int count)
{
    DECLARE_SC(sc, TEXT("CEventBuffer::ScEmitOrPostpone"));

    // construct the postponed data
    DispCallStr call_data;
    call_data.spDispatch = pDispatch;
    call_data.dispid = dispid;
    call_data.vars.insert(call_data.vars.begin(), pVar, pVar + count);

    // store the data for future use
    m_postponed.push(call_data);

    // emit rigt away if not locked
    if (!IsLocked())
        sc = ScFlushPostponed();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CEventBuffer::ScFlushPostponed
 *
 * PURPOSE: method will invoke all events currently in it's queue
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CEventBuffer::ScFlushPostponed()
{
    DECLARE_SC(sc, TEXT("CEventBuffer::ScFlushPostponed"));

    SC sc_last_error;

    // for each event in queue
    while (m_postponed.size())
    {
        // ectract event from the queue
        DispCallStr call_data = m_postponed.front();
        m_postponed.pop();
    
        // check the dispatch pointer
        sc = ScCheckPointers(call_data.spDispatch, E_POINTER);
        if (sc)
        {
            sc_last_error = sc; // continue even if some calls failed
            sc.TraceAndClear();
            continue;
        }

        // construct parameter structure
        CComVariant varResult;
		DISPPARAMS disp = { call_data.vars.begin(), NULL, call_data.vars.size(), 0 };

        // invoke the method on event sink
        sc = call_data.spDispatch->Invoke(call_data.dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
        if (sc)
        {
            sc_last_error = sc; // continue even if some calls failed
            sc.TraceAndClear();
            continue;
        }
        // event methods should not return any values.
        // but even if the do (thru varResult) - we do not care, just ignore that.
    }

    // will return sc_last_error (not sc - we already traced it)
    return sc_last_error;
}

/***************************************************************************\
 *
 * FUNCTION:  GetEventBuffer
 *
 * PURPOSE: This function provides access to static object created in it's body
 *          Having it as template allows us to define as many static objects as
 *          interfaces we have.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CEventBuffer&  - reference to the static object created inside
 *
\***************************************************************************/
MMCBASE_API CEventBuffer& GetEventBuffer()
{
	static CEventBuffer buffer;
	return buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\mmcdebug.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      mmctrace.cpp
//
//  Contents:  Implementation of the debug trace code
//
//  History:   15-Jul-99 VivekJ    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include <imagehlp.h>
#include "util.h"


//--------------------------------------------------------------------------
#ifdef DBG
//--------------------------------------------------------------------------

// a few global traces
CTraceTag tagError        (TEXT("Trace"),              TEXT("Error"),    TRACE_OUTPUTDEBUGSTRING);
CTraceTag tagDirtyFlag    (TEXT("Persistence"),        TEXT("MMC Dirty Flags"));
CTraceTag tagPersistError (TEXT("Persistence"),        TEXT("Snapin Dirty Flags"));
CTraceTag tagCoreLegacy   (TEXT("LEGACY mmccore.lib"), TEXT("TRACE (legacy, mmccore.lib)"));
CTraceTag tagConUILegacy  (TEXT("LEGACY mmc.exe"),     TEXT("TRACE (legacy, mmc.exe)"));
CTraceTag tagNodemgrLegacy(TEXT("LEGACY mmcndmgr.dll"),TEXT("TRACE (legacy, mmcndmgr.dll)"));
CTraceTag tagSnapinError  (TEXT("Snapin Error"),       TEXT("Snapin Error"), TRACE_OUTPUTDEBUGSTRING);

// szTraceIniFile must be a sz, so it exists before "{" of WinMain.
// if we make it a CStr, it may not be constructed when some of the
// tags are constructed, so we won't restore their value.
LPCTSTR const szTraceIniFile = TEXT("MMCTrace.INI");

//############################################################################
//############################################################################
//
//  Implementation of global Trace functions
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 *
 * Trace
 *
 * PURPOSE:     Maps the Trace statement to the proper method call.
 *              This is needed (instead of doing directly ptag->Trace())
 *              to garantee that no code is added in the ship build.
 *
 * PARAMETERS:
 *    CTraceTag & tag :        the tag controlling the debug output
 *    LPCTSTR     szFormat :   printf style formatting string
 *                ... :        printf style parameters, depends on szFormat
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
Trace( const CTraceTag & tag, LPCTSTR szFormat, ... )
{
    va_list     marker;
    va_start(marker, szFormat);
    tag.TraceFn(szFormat, marker);
    va_end(marker);
}


/*+-------------------------------------------------------------------------*
 *
 * TraceDirtyFlag
 *
 * PURPOSE: Used to trace into the objects that cause MMC to be in a dirty
 *          state, requiring a save.
 *
 * PARAMETERS:
 *    LPCTSTR  szComponent : The class name
 *    bool     bDirty      : whether or not the object is dirty.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
TraceDirtyFlag  (LPCTSTR szComponent, bool bDirty)
{
    Trace(tagDirtyFlag, TEXT("%s : %s"), szComponent, bDirty ? TEXT("true") : TEXT("false"));
}

void
TraceBaseLegacy  (LPCTSTR szFormat, ... )
{
    va_list     marker;
    va_start(marker, szFormat);
    tagCoreLegacy.TraceFn(szFormat, marker);
    va_end(marker);
}

void
TraceConuiLegacy  (LPCTSTR szFormat, ... )
{
    va_list     marker;
    va_start(marker, szFormat);
    tagConUILegacy.TraceFn(szFormat, marker);
    va_end(marker);
}

void
TraceNodeMgrLegacy(LPCTSTR szFormat, ... )
{
    va_list     marker;
    va_start(marker, szFormat);
    tagNodemgrLegacy.TraceFn(szFormat, marker);
    va_end(marker);
}


/*+-------------------------------------------------------------------------*
 *
 * TraceError
 *
 * PURPOSE:     Used to send error traces.
 *
 * PARAMETERS:
 *    LPCTSTR  szModuleName : The module in which the error occurred.
 *    SC       sc           : The error.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
TraceError(LPCTSTR szModuleName, const SC& sc)
{
    TCHAR szTemp[256];

    sc.GetErrorMessage (countof(szTemp), szTemp);
    StripTrailingWhitespace (szTemp);

    Trace(tagError, TEXT("Module %s, SC = 0x%08X = %d\r\n = \"%s\""),
          szModuleName, sc.GetCode(), LOWORD(sc.GetCode()), szTemp);
}


/*+-------------------------------------------------------------------------*
 *
 * TraceErrorMsg
 *
 * PURPOSE:     Used to send formatted error traces.  This is not SC-based, but
 *                              it does use tagError as its controlling trace tag.
 *
 * PARAMETERS:
 *    LPCTSTR  szErrorMsg : Error message to display.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
TraceErrorMsg(LPCTSTR szFormat, ...)
{
    va_list     marker;
    va_start(marker, szFormat);
    tagError.TraceFn(szFormat, marker);
    va_end(marker);
}

/*+-------------------------------------------------------------------------*
 *
 * TraceSnapinError
 *
 * PURPOSE:     Used to send snapin error traces. The method should use
 *              DECLARE_SC so that we can get the method name from sc.
 *
 *
 * PARAMETERS:
 *    LPCTSTR  szError : Additional error message.
 *    SC       sc :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
TraceSnapinError(LPCTSTR szError, const SC& sc)
{
    TCHAR szTemp[256];

    sc.GetErrorMessage (countof(szTemp), szTemp);
    StripTrailingWhitespace (szTemp);

    Trace(tagSnapinError, TEXT("Snapin %s encountered in %s  error %s, hr = 0x%08X\r\n = \"%s\""),
          sc.GetSnapinName(), sc.GetFunctionName(), szError, sc.ToHr(), szTemp);
}

/*+-------------------------------------------------------------------------*
 *
 * TraceSnapinPersistenceError
 *
 * PURPOSE:     outputs traces for persistence and snapin error tags
 *
 * PARAMETERS:
 *    LPCTSTR  szError : Error message.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
TraceSnapinPersistenceError(LPCTSTR szError)
{
    Trace(tagSnapinError,   szError);
    Trace(tagPersistError,  szError);
}

//############################################################################
//############################################################################
//
//  Implementation of class CTraceTags
//
//############################################################################
//############################################################################
CTraceTags * GetTraceTags()
{
    static CTraceTags s_traceTags;
    return &s_traceTags;
}


//############################################################################
//############################################################################
//
//  Implementation of class CTraceTag
//
//############################################################################
//############################################################################
CStr &
CTraceTag::GetFilename()
{
    /*
     * these statics are local to this function so we'll be sure they're
     * initialized, if this function is called during app/DLL initialization
     */
    static  CStr    strFile;
    static  BOOL    fInitialized    = FALSE;

    if(!fInitialized)
    {
        TCHAR   szTraceFile[OFS_MAXPATHNAME];
        ::GetPrivateProfileString(TEXT("Trace File"), TEXT("Trace File"),
                                  NULL, szTraceFile, OFS_MAXPATHNAME, szTraceIniFile);

        strFile = (_tcslen(szTraceFile)==0) ? TEXT("\\mmctrace.out") : szTraceFile;
        fInitialized = TRUE;
    }

    return strFile;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceTag::GetStackLevels
 *
 * PURPOSE: Returns a reference to the number of stack levels to display.
 *          Auto initializes from the ini file.
 *
 * RETURNS:
 *    unsigned int &
 *
 *+-------------------------------------------------------------------------*/
unsigned int &
CTraceTag::GetStackLevels()
{
    static unsigned int nLevels = 3; // the default.
    static BOOL fInitialized = FALSE;

    if(!fInitialized)
    {
        TCHAR   szStackLevels[OFS_MAXPATHNAME];
        ::GetPrivateProfileString(TEXT("Stack Levels"), TEXT("Stack Levels"),
                                  NULL, szStackLevels, OFS_MAXPATHNAME, szTraceIniFile);

        if(_tcslen(szStackLevels)!=0)
            nLevels = szStackLevels[0] - TEXT('0');
        fInitialized = TRUE;
    }

    return nLevels;
}



HANDLE  CTraceTag::s_hfileCom2 = 0;
HANDLE  CTraceTag::s_hfile     = 0;

/*+-------------------------------------------------------------------------*
 *
 * CTraceTag::CTraceTag
 *
 * PURPOSE: Constructor
 *
 * PARAMETERS:
 *    LPCTSTR  szCategory :     The category of the trace.
 *    LPCTSTR  szName :         The name of the trace.
 *    DWORD    dwDefaultFlags : The initial (and default) output setting.
 *
 *+-------------------------------------------------------------------------*/
CTraceTag::CTraceTag(LPCTSTR szCategory, LPCTSTR szName, DWORD dwDefaultFlags /*= 0*/)
: m_szCategory(szCategory),
  m_szName(szName)
{
    m_dwDefaultFlags = dwDefaultFlags;
    m_dwFlags        = dwDefaultFlags;

    //  Get the value from TRACE.INI
    m_dwFlags = ::GetPrivateProfileInt(szCategory, szName, dwDefaultFlags, szTraceIniFile);

    // add it to the end of the list.
    CTraceTags *pTraceTags = GetTraceTags();
    if(NULL != pTraceTags)
        pTraceTags->push_back(this); // add this tag to the list.

    // call the OnEnable function if any flags have been set.
    if(FAny())
    {
        OnEnable();
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceTag::~CTraceTag
 *
 * PURPOSE: Destructor
 *
 *+-------------------------------------------------------------------------*/
CTraceTag::~CTraceTag()
{
    // close the open handles.
    if (s_hfileCom2 && (s_hfileCom2 != INVALID_HANDLE_VALUE))
    {
        ::CloseHandle(s_hfileCom2);
        s_hfileCom2 = INVALID_HANDLE_VALUE;
    }
    if (s_hfile && (s_hfile != INVALID_HANDLE_VALUE))
    {
        ::CloseHandle(s_hfile);
        s_hfile = INVALID_HANDLE_VALUE;
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CTraceTag::TraceFn
 *
 * PURPOSE:     Processes a Trace statement based on the flags
 *              of the tag.
 *
 * PARAMETERS:
 *    LPCTSTR       szFormat : printf style format string
 *    va_list  marker :   argument block to pass to _vsnprintf
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/

void CTraceTag::TraceFn(LPCTSTR szFormat, va_list marker) const
{
    CStr            strT;
    CStr            str;

    // Get out quick if no outputs are enabled.
    if (!FAny())
        return;

    // first, format the string as provided.
    strT.FormatV(szFormat, marker);

    // next, prepend the name of the tag.
    str.Format(TEXT("%s: %s\r\n"), GetName(), strT);

    // send the string to all appropriate outputs
    OutputString(str);

    if(FDumpStack()) // dump the caller's info to the stack.
    {
        DumpStack();
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceTag::OutputString
 *
 * PURPOSE: Outputs the specified string to all appropriate outputs
 *          (Debug string, COM2, or file)
 *
 * PARAMETERS:
 *    CStr & str :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CTraceTag::OutputString(const CStr &str) const
{
    UINT            cbActual    = 0;

    //---------------------------------------------------------------
    // Output to OutputDebugString if needed
    //---------------------------------------------------------------
    if (FDebug())
        OutputDebugString(str);

    USES_CONVERSION;

    //---------------------------------------------------------------
    // Output to COM2 if needed
    //---------------------------------------------------------------
    if (FCom2())
    {
        // create the file if it hasn't been created yet.
        if (!s_hfileCom2)
        {
            s_hfileCom2 = CreateFile(TEXT("com2:"),
                    GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_WRITE_THROUGH,
                    NULL);

            if (s_hfileCom2 == INVALID_HANDLE_VALUE)
            {
                //::MessageBox(TEXT("COM2 is not available for debug trace"), MB_OK | MB_ICONINFORMATION);
            }
        }

        // output to file.
        if (s_hfileCom2 != INVALID_HANDLE_VALUE)
        {
            ASSERT(::WriteFile(s_hfileCom2, T2A((LPTSTR)(LPCTSTR)str), str.GetLength(), (LPDWORD) &cbActual, NULL));
            ASSERT(::FlushFileBuffers(s_hfileCom2));
        }
    }

    //---------------------------------------------------------------
    // Output to File if needed
    //---------------------------------------------------------------
    if (FFile())
    {
        // create the file if it hasn't been created yet.
        if (!s_hfile)
        {
            s_hfile = CreateFile(GetFilename(),
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_ALWAYS,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL);
            if (s_hfile != INVALID_HANDLE_VALUE)
            {
                ::SetFilePointer(s_hfile, NULL, NULL, FILE_END);

                // for Unicode files, write the Unicode prefix when the file is first created (ie it has a length of zero)
#ifdef UNICODE
                DWORD dwFileSize = 0;
                if( (::GetFileSize(s_hfile, &dwFileSize) == 0) && (dwFileSize == 0) )
                {
                    const WCHAR chPrefix  = 0xFEFF;
                    const DWORD cbToWrite = sizeof (chPrefix);
                    DWORD       cbWritten = 0;

                    ::WriteFile (s_hfile, &chPrefix, cbToWrite, &cbWritten, NULL);
                }
#endif
                // write an initial line.
                CStr strInit = TEXT("\n*********************Start of debugging session*********************\r\n");
                ::WriteFile(s_hfile, ((LPTSTR)(LPCTSTR)strInit), strInit.GetLength() * sizeof(TCHAR), (LPDWORD) &cbActual, NULL);
            }
        }
        if (s_hfile == INVALID_HANDLE_VALUE)
        {
            static BOOL fOpenFailed = FALSE;
            if (!fOpenFailed)
            {
                CStr str;

                fOpenFailed = TRUE;     // Do this first, so the MbbErrorBox and str.Format
                                        // do not cause problems with their trace statement.

                str.Format(TEXT("The DEBUG ONLY trace log file '%s' could not be opened"), GetFilename());
                //MbbErrorBox(str, ScFromWin32(::GetLastError()));
            }
        }
        else
        {
            // write to the file.
            ::WriteFile(s_hfile, ((LPTSTR)(LPCTSTR)str), str.GetLength() *sizeof(TCHAR), (LPDWORD) &cbActual, NULL);
        }
    }

    //---------------------------------------------------------------
    // DebugBreak if needed
    //---------------------------------------------------------------
    if (FBreak())
        MMCDebugBreak();
}


/*+-------------------------------------------------------------------------*
 *
 * CTraceTag::Commit
 *
 * PURPOSE: Sets the flags equal to the temporary flags setting.
 *          If any flags are enabled where previously no flags were, also
 *          calls OnEnable(). If no flags are enabled where previously flags
 *          were enabled, calls OnDisable()
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CTraceTag::Commit()
{
    if((0 != m_dwFlags) && (0 == m_dwFlagsTemp))
    {
        // disable if flags have changed from non-zero to zero
        OnDisable();
    }
    else if((0 == m_dwFlags) && (0 != m_dwFlagsTemp))
    {
        // enable if flags have changed from 0 to non-zero
        OnEnable();
    }

    m_dwFlags     = m_dwFlagsTemp;
}



//############################################################################
//############################################################################
//
//  Stack dump related code - copied from MFC with very few modifications.
//
//############################################################################
//############################################################################

static LPVOID __stdcall FunctionTableAccess(HANDLE hProcess, DWORD_PTR dwPCAddress);
static DWORD_PTR __stdcall GetModuleBase(HANDLE hProcess, DWORD_PTR dwReturnAddress);

#define MODULE_NAME_LEN 64
#define SYMBOL_NAME_LEN 128

struct MMC_SYMBOL_INFO
{
    DWORD_PTR dwAddress;
    DWORD_PTR dwOffset;
    CHAR    szModule[MODULE_NAME_LEN];
    CHAR    szSymbol[SYMBOL_NAME_LEN];
};

static LPVOID __stdcall FunctionTableAccess(HANDLE hProcess, DWORD_PTR dwPCAddress)
{
    return SymFunctionTableAccess(hProcess, dwPCAddress);
}

static DWORD_PTR __stdcall GetModuleBase(HANDLE hProcess, DWORD_PTR dwReturnAddress)
{
    IMAGEHLP_MODULE moduleInfo;

    if (SymGetModuleInfo(hProcess, dwReturnAddress, &moduleInfo))
        return moduleInfo.BaseOfImage;
    else
    {
        MEMORY_BASIC_INFORMATION memoryBasicInfo;

        if (::VirtualQueryEx(hProcess, (LPVOID) dwReturnAddress,
            &memoryBasicInfo, sizeof(memoryBasicInfo)))
        {
            DWORD cch = 0;
            char szFile[MAX_PATH] = { 0 };

         cch = GetModuleFileNameA((HINSTANCE)memoryBasicInfo.AllocationBase,
                                         szFile, MAX_PATH);

         // Ignore the return code since we can't do anything with it.
         if (!SymLoadModule(hProcess,
               NULL, ((cch) ? szFile : NULL),
               NULL, (DWORD_PTR) memoryBasicInfo.AllocationBase, 0))
            {
                DWORD dwError = GetLastError();
                //TRACE1("Error: %d\n", dwError);
            }
         return (DWORD_PTR) memoryBasicInfo.AllocationBase;
      }
        else
            /*TRACE1("Error is %d\n", GetLastError())*/;
    }

    return 0;
}




/*+-------------------------------------------------------------------------*
 *
 * ResolveSymbol
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    HANDLE        hProcess :
 *    DWORD         dwAddress :
 *    SYMBOL_INFO & siSymbol :
 *
 * RETURNS:
 *    static BOOL
 *
 *+-------------------------------------------------------------------------*/

static BOOL ResolveSymbol(HANDLE hProcess, DWORD_PTR dwAddress,
    MMC_SYMBOL_INFO &siSymbol)
{
    HRESULT hr = S_OK;
    BOOL fRetval = TRUE;

    siSymbol.dwAddress = dwAddress;

    union {
        CHAR rgchSymbol[sizeof(IMAGEHLP_SYMBOL) + 255];
        IMAGEHLP_SYMBOL  sym;
    };

    CHAR szUndec[256];
    CHAR szWithOffset[256];

    LPSTR pszSymbol = NULL;
    IMAGEHLP_MODULE mi;

    memset(&siSymbol, 0, sizeof(MMC_SYMBOL_INFO));
    mi.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    int cchLenModule = countof(siSymbol.szModule);
    if (!SymGetModuleInfo(hProcess, dwAddress, &mi))
    {
        hr = StringCchCopyA(siSymbol.szModule, cchLenModule, "<no module>");
        if (FAILED(hr))
            OutputDebugString(TEXT("StringCopy failed in ResolveSymbol pos0"));
    }
    else
    {
        LPSTR pszModule = strchr(mi.ImageName, '\\');
        if (pszModule == NULL)
            pszModule = mi.ImageName;
        else
            pszModule++;

        hr = StringCchCopyA(siSymbol.szModule, cchLenModule, pszModule);
        if (FAILED(hr))
            OutputDebugString(TEXT("StringCopy failed in ResolveSymbol pos2"));

        hr = StringCchCatA(siSymbol.szModule, cchLenModule, "! ");
        if (FAILED(hr))
            OutputDebugString(TEXT("StringCat failed in ResolveSymbol pos3"));
    }

    __try
    {
        sym.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
        sym.Address = dwAddress;
        sym.MaxNameLength = 255;

        if (SymGetSymFromAddr(hProcess, dwAddress, &(siSymbol.dwOffset), &sym))
        {
            pszSymbol = sym.Name;

            if (UnDecorateSymbolName(sym.Name, szUndec, countof(szUndec),
                UNDNAME_NO_MS_KEYWORDS | UNDNAME_NO_ACCESS_SPECIFIERS))
            {
                pszSymbol = szUndec;
            }
            else if (SymUnDName(&sym, szUndec, countof(szUndec)))
            {
                pszSymbol = szUndec;
            }

            if (siSymbol.dwOffset != 0)
            {
                hr = StringCchPrintfA(szWithOffset, countof(szWithOffset), "%s + %d bytes", pszSymbol, siSymbol.dwOffset);
                if (FAILED(hr))
                    OutputDebugString(TEXT("StringPrintf failed in ResolveSymbol pos4"));

                pszSymbol = szWithOffset;
            }
      }
      else
          pszSymbol = "<no symbol>";
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pszSymbol = "<EX: no symbol>";
        siSymbol.dwOffset = dwAddress - mi.BaseOfImage;
    }

    hr = StringCchCopyA(siSymbol.szSymbol, countof(siSymbol.szSymbol), pszSymbol);
    if (FAILED(hr))
        OutputDebugString(TEXT("StringCopy failed in ResolveSymbol pos5"));

    return fRetval;
}


/*+-------------------------------------------------------------------------*
 *
 * CTraceTag::DumpStack
 *
 * PURPOSE: Does a stack trace and sends it to the appropriate outputs.
 *          Mostly copied from AfxDumpStack.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CTraceTag::DumpStack() const
{
    HRESULT hr = S_OK;
    const int UNINTERESTING_CALLS = 3; // the lines of display which are in CTraceTag code and should not be displayed.

    CStr str;

    //OutputString("=== Begin Stack Dump ===\r\n");

    std::vector<DWORD_PTR> adwAddress;
    HANDLE hProcess = ::GetCurrentProcess();
    if (SymInitialize(hProcess, NULL, FALSE))
    {
        // force undecorated names to get params
        DWORD dw = SymGetOptions();
        dw &= ~SYMOPT_UNDNAME;
        SymSetOptions(dw);

        HANDLE hThread = ::GetCurrentThread();
        CONTEXT threadContext;

        threadContext.ContextFlags = CONTEXT_FULL;

        if (::GetThreadContext(hThread, &threadContext))
        {
            STACKFRAME stackFrame;
            memset(&stackFrame, 0, sizeof(stackFrame));

            DWORD dwMachType;

#if defined(_M_IX86)
            dwMachType                  = IMAGE_FILE_MACHINE_I386;
            stackFrame.AddrPC.Offset    = threadContext.Eip;
            stackFrame.AddrPC.Mode      = AddrModeFlat;
            stackFrame.AddrStack.Offset = threadContext.Esp;
            stackFrame.AddrStack.Mode   = AddrModeFlat;
            stackFrame.AddrFrame.Offset = threadContext.Ebp;
            stackFrame.AddrFrame.Mode   = AddrModeFlat;

#elif defined(_M_AMD64)
            dwMachType                  = IMAGE_FILE_MACHINE_AMD64;
            stackFrame.AddrPC.Offset    = threadContext.Rip;
            stackFrame.AddrPC.Mode      = AddrModeFlat;
            stackFrame.AddrStack.Offset = threadContext.Rsp;
            stackFrame.AddrStack.Mode   = AddrModeFlat;

#elif defined(_M_IA64)
            dwMachType                  = IMAGE_FILE_MACHINE_IA64;
            stackFrame.AddrPC.Offset    = threadContext.StIIP;
            stackFrame.AddrPC.Mode      = AddrModeFlat;
            stackFrame.AddrStack.Offset = threadContext.IntSp;
            stackFrame.AddrStack.Mode   = AddrModeFlat;

#else
#error("Unknown Target Machine");
#endif

            int nFrame;
            for (nFrame = 0; nFrame < GetStackLevels() + UNINTERESTING_CALLS; nFrame++)
            {
                if (!StackWalk(dwMachType, hProcess, hProcess,
                    &stackFrame, &threadContext, NULL,
                    FunctionTableAccess, GetModuleBase, NULL))
                {
                    break;
                }

                adwAddress.push_back(stackFrame.AddrPC.Offset);
            }
        }
    }
    else
    {
        DWORD dw = GetLastError();
        char szTemp[100];

        hr = StringCchPrintfA(szTemp, countof(szTemp), 
                             "AfxDumpStack Error: IMAGEHLP.DLL wasn't found. "
                             "GetLastError() returned 0x%8.8X\r\n", dw);
        if (FAILED(hr))
            OutputDebugString(TEXT("StringPrintf failed in DumpStack pos0"));

        OutputString(szTemp);
    }

    // dump it out now
    int nAddress;
    int cAddresses = adwAddress.size();
    for (nAddress = UNINTERESTING_CALLS; nAddress < cAddresses; nAddress++)
    {
        MMC_SYMBOL_INFO info;
        DWORD_PTR dwAddress = adwAddress[nAddress];

        char szTemp[20];

        HRESULT hr = StringCchPrintfA(szTemp, countof(szTemp), "        %8.8X: ", dwAddress);
        if (FAILED(hr))
            OutputDebugString(TEXT("StringPrintf failed in DumpStack pos1"));

        OutputString(szTemp);

        if (ResolveSymbol(hProcess, dwAddress, info))
        {
            OutputString(info.szModule);
            OutputString(info.szSymbol);
        }
        else
            OutputString("symbol not found");
        OutputString("\r\n");
    }

    //OutputString("=== End Stack Dump ===\r\n");
}

//--------------------------------------------------------------------------
#endif // DBG
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\nodemgrstr.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nodemgrstr.rc
//
#define IDS_NODEINIT_DESC               1
#define IDS_SCOPETREE_DESC              2
#define IDS_DOCCONFIG_DESC              4
#define IDS_ALL_CATEGORIES              213
#define IDS_ACTIVEXCONTROL              214
#define IDS_PROPERTIES                  14000
#define IDS_COLUMNS                     14001
#define IDS_CREATE_NEW                  14002
#define IDS_SNAPIN_CREATE_FAILED        14003
#define IDS_SNAPIN_FAILED               14004
#define IDS_SNAPIN_POLICYFAILURE        14005
#define IDS_VERSION                     14006
#define IDS_ABOUT                       14007
#define IDS_FOLDER                      14008
#define IDS_CUSTOMIZE                   14009
#define IDS_HTML                        14010
#define IDS_SHORTCUT                    14011
#define IDS_ENUMERATED                  14012
#define IDS_SNAPINSTR                   14013
#define IDS_CONTROL_NAME                14014
#define IDS_CATEGORY                    14015
#define IDS_NO_PERMISSION_SHUTDOWN      14016
#define IDS_VENDOR                      14017
#define IDS_ColumnsCouldNotBePersisted  14018
#define IDS_SNAPIN_NOTALLOWED           14019
#define IDS_EXTENSION_NOTALLOWED        14020
#define IDS_ViewSettingCouldNotBePersisted 14021
#define IDS_SNAPIN_SAVE_FAILED          14022
#define MMC_E_SnapinNotAdded            14023
#define IDS_WizardTitleFont             14024
#define MMC_E_SNAPINNOTFOUND            14025
#define IDS_NOT_INSTALLED2              14027
#define ID_SNP_PROPERTIES               14028
#define ID_SNP_MANAGER_TITLE            14029
#define ID_SNP_UP                       14030
#define ID_SNP_DELETE                   14031
#define IDS_VIEW_FILTERED               14032
#define ID_SNP_STANDALONE               14033
#define ID_SNP_ALLSNAPINS               14034
#define ID_SNP_EXTENSION                14035
#define IDS_WizardTitleFontSize         14036
#define IDS_NOT_INSTALLED               14037
#define IDS_SNAPINTYPE0                 14038
#define IDS_SNAPINTYPE1                 14039
#define IDS_SNAPINTYPE2                 14040
#define IDS_EXTENSION                   14041
#define SNP_DELETE_TITLE                14042
#define SNP_DELETE_TEXT                 14043
#define IDS_ROOTFOLDER_NAME             14044
#define SNPADD_ERROR1                   14045
#define IDS_SELECT_ALL                  14046
#define IDS_EXPLORE                     14047
#define IDS_OPEN                        14048
#define IDS_CUT                         14049
#define IDS_COPY                        14050
#define IDS_PASTE                       14051
#define IDS_DELETE                      14052
#define IDS_PRINT                       14053
#define IDS_REFRESH                     14054
#define IDS_RENAME                      14055
#define IDS_DOCKING                     14056
#define IDS_NEW_TASKPAD_FROM_HERE       14057
#define IDS_SNAPINMANAGER               14058
#define IDS_ARRANGE_NAME                14059
#define IDS_ARRANGE_TYPE                14060
#define IDS_ARRANGE_SIZE                14061
#define IDS_ARRANGE_DATE                14062
#define IDS_TASK                        14063
#define IDS_SCOPE_PANE                  14064
#define IDS_MMC_MENU_ACTION             14065
#define IDS_MMC_MENU_VIEW               14066
#define IDS_NEW_FOLDER_NAME             14067
#define IDS_PROP_ON_MULTIOBJ            14068
#define IDS_TASKPAD_NAME_REQUIRED_ERROR 14069
#define IDS_COMCAT_LOAD_ERR             14070
#define IDS_CLASSCAT_ENUM_ERR           14071
#define IDS_COMCAT_NONAME               14072
#define IDS_SHORTCUT_FILES              14077
#define IDS_BROWSE_SHORTCUT             14078
#define IDS_HTML_FILES                  14079
#define IDS_BROWSE_WEBLINK              14080
#define IDS_ACTIVEX_FILES               14081
#define IDS_BROWSE_ACTIVEX              14082
#define IDS_NOT_IMPLEMENTED             14083
#define IDS_CONSOLE_TOPIC               14084
#define IDS_MMC_MENU_FAVORITES          14085
#define IDS_SAVE_LIST                   14086
#define IDS_TASKPAD_ROOT_FOLDER_NAME    14087
#define IDS_INVALID_COMMAND             14088
#define IDS_RETARGET_BUTTON_TEXT        14089
#define IDS_INVALID_CONTEXT_LEVEL       14090
#define IDS_ITEM_DOES_NOT_EXIST         14091
#define IDS_NEW_TASKPAD                 14092
#define IDS_NEWTASK                     14093
#define IDS_MOVETO                      14094
#define IDS_ORDER                       14095
#define IDS_NEWGROUP                    14096
#define IDS_TASKPADS                    14097
#define IDS_TPSTYLE_VERT                14098
#define IDS_TPSTYLE_VERT_DESCR          14099
#define IDS_TPSTYLE_HORZ                14100
#define IDS_TPSTYLE_HORZ_DESCR          14101
#define IDS_TPSTYLE_NOLIST              14102
#define IDS_TPSTYLE_NOLIST_DESCR        14103
#define IDS_BROWSE_SYMBOL               14104
#define IDS_SYMBOL_FILES                14105
#define IDS_TPSTYLE_LONGDESCR           14106
#define IDS_TPSTYLE_LONGDESCR_DESCR     14107
#define IDS_TaskProps_MenuCommand       14108
#define IDS_TaskProps_CommandLine       14109
#define IDS_TaskProps_TaskpadList       14110
#define IDS_TaskProps_ConsoleTree       14111
#define IDS_TaskProps_Minimized         14112
#define IDS_TaskProps_Maximized         14113
#define IDS_TaskProps_Restored          14114
#define IDS_TaskProps_ModifyTitle       14115
#define IDS_TaskProps_ProgramFilter     14116
#define IDS_TaskProps_ErrorNoTaskName   14117
#define IDS_TaskProps_ErrorNoCommand    14118
#define IDS_TargetNodeName              14119
#define IDS_TargetNodeParentName        14120
#define IDS_TARGETNODELOCATE            14121
#define IDS_TaskProps_TargetNode        14122
#define IDS_TASK_MENU_COMMAND_REQUIRED  14123
#define IDS_COLUMN_TASK                 14124
#define IDS_COLUMN_TOOLTIP              14125
#define IDS_InvalidTarget               14126
#define IDS_EDIT_TASKPAD                14127
#define IDS_SNAPIN_FAILED_INIT_NAME     14128
#define IDS_SNAPIN_FAILED_INIT_CLSID    14129
#define IDS_NOT_AVAILABLE               14130
#define IDS_SYMBOL_REQUIRED             14131
#define IDS_NO_TASKPAD                  14132
#define IDS_DELETE_TASKPAD              14133
#define IDS_TaskpadWiz_NamePageTitle    14134
#define IDS_TaskpadWiz_NamePageSubtitle 14135
#define IDS_TaskpadWiz_NodeTypePageTitle 14136
#define IDS_TaskpadWiz_NodeTypePageSubtitle 14137
#define IDS_TaskpadWiz_StylePageTitle   14138
#define IDS_TaskpadWiz_StylePageSubtitle 14139
#define IDS_TaskpadWiz_TitlePageTitle   14140
#define IDS_TaskpadWiz_TitlePageSubtitle 14141
#define IDS_TaskWiz_CmdLinePageTitle    14142
#define IDS_TaskWiz_CmdLinePageSubtitle 14143
#define IDS_TaskWiz_MenuPageTitle       14144
#define IDS_TaskWiz_MenuPageSubtitle    14145
#define IDS_TaskWiz_NamePageTitle       14146
#define IDS_TaskWiz_NamePageSubtitle    14147
#define IDS_TaskWiz_SymbolPageTitle     14148
#define IDS_TaskWiz_SymbolPageSubtitle  14149
#define IDS_TaskWiz_TypePageTitle       14150
#define IDS_TaskWiz_TypePageSubtitle    14151
#define IDS_Small                       14152
#define IDS_Medium                      14153
#define IDS_Large                       14154
#define IDS_TASKSOURCE_RESULT           14155
#define IDS_TASKSOURCE_SCOPE            14156
#define IDS_TaskWiz_FavoritePage_Title  14157
#define IDS_TaskWiz_FavoritePage_Subtitle 14158
#define IDS_FOLDERSNAPIN_DESC           14159
#define IDS_BUILTIN_SNAPIN_PROVIDER     14160
#define IDS_OCXWiz_ControlPageTitle     14162
#define IDS_HTMLSNAPIN_DESC             14163
#define IDS_OCXWiz_ControlPageSubTitle  14166
#define IDS_OCXSNAPIN_DESC              14167
#define IDS_MMC_CONTEXTHELP             14170
#define MMC_E_CannotChangeProperty      14171
#define MMC_E_CannotRemoveProperty      14172
#define MMC_E_UnrecognizedProperty      14173
#define MMC_E_TheVerbNotEnabled         14174
#define IDS_ExplorerView                14175
#define MMC_E_CannotDisableExtension    14176
#define IDS_ViewExtSnapinName           14177
#define IDS_UnknownSnapinName           14178

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\mmcerror.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      mmcerror.cpp
//
//  Contents:  Class definitions for mmc debug support code.
//
//  History:   15-Jul-99 VivekJ    Created
//
//--------------------------------------------------------------------------
#include "stdafx.h"
#include "conuistr.h" // needed for IDR_MAINFRAME
#define  cchMaxSmallLine 256


#ifdef DBG
CTraceTag tagSCConversion(TEXT("SC"), TEXT("Conversion"));
CTraceTag tagCallDump(    TEXT("Function calls"), TEXT("ALL") );
#endif //DBG



//############################################################################
//############################################################################
//
// Definition of GetStringModule() - used by all binaries
//
//############################################################################
//############################################################################
HINSTANCE GetStringModule()
{
    return SC::GetHinst();
}

//############################################################################
//############################################################################
//
// Implementation of class SC
//
//############################################################################
//############################################################################

// static variables
HINSTANCE SC::s_hInst = 0;
HWND      SC::s_hWnd  = NULL;
DWORD     SC::s_dwMainThreadID = -1;

#ifdef DBG
UINT      SC::s_CallDepth = 0;
#endif

// accessors for the static variables.
void
SC::SetHinst(HINSTANCE hInst)
{
    s_hInst = hInst;
}

void
SC::SetHWnd(HWND hWnd)
{
    s_hWnd = hWnd;
}


void
SC::SetMainThreadID(DWORD dwThreadID)
{
    ASSERT(-1 != dwThreadID);
    s_dwMainThreadID = dwThreadID;
}

#ifdef DBG

SC&
SC::operator = (const SC& other)
{
    m_facility = other.m_facility;
    m_value = other.m_value;
    return *this;
}

SC::SC(const SC& other)
:   m_szFunctionName(NULL),
    m_szSnapinName(NULL)
{
    *this = other;
}


/*+-------------------------------------------------------------------------*
 *
 * SC::SetFunctionName
 *
 * PURPOSE: Sets the debug function name to the supplied string.
 *
 * PARAMETERS:
 *    LPCTSTR  szFunctionName : the supplied string.
 *
 * RETURNS:
 *    inline void
 *
 *+-------------------------------------------------------------------------*/
inline void SC::SetFunctionName(LPCTSTR szFunctionName)
{
    m_szFunctionName = szFunctionName;

    INCREMENT_CALL_DEPTH();

    // This computes the format string based on the call depth.
    // eg if s_CallDepth is 4, the string is "    %s"  (four spaces)
    //    if s_CallDepth is 5, the string is "     %s"  (five spaces)

    LPCTSTR szFormatString = TEXT("                                        %s");
    UINT    maxLen = _tcslen(szFormatString);

    UINT    formatLen = s_CallDepth + 2; // the -2 is for the "%s"

    formatLen = (formatLen < maxLen ? formatLen : maxLen);

    Trace(tagCallDump, szFormatString + (maxLen - formatLen), szFunctionName);
}

#endif

/*+-------------------------------------------------------------------------*
 *
 * SC::ToHr
 *
 * PURPOSE: Converts from a status code (SC) to an HRESULT. USE SPARINGLY.
 *
 * PARAMETERS: None
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
SC::ToHr() const
{
    HRESULT hr = S_OK;
    switch(GetFacility())
    {
    default:
        ASSERT(0 && "Should not come here.");
        break;

    case FACILITY_WIN:
        hr = HRESULT_FROM_WIN32 (GetCode());
        break;

    case FACILITY_MMC:
        Trace (tagSCConversion, _T("Converting from MMC error code to HRESULT, probable loss of fidelity"), *this);
        hr = (GetCode() != 0) ? E_UNEXPECTED : S_OK;
        break;

    case FACILITY_HRESULT:
        hr = (HRESULT) GetCode();
        break;
    }

    return hr;

}

/*+-------------------------------------------------------------------------*
 *
 * SC::GetErrorMessage
 *
 * PURPOSE: Writes the error message corresponding to the error code to
 *          the buffer pointed to by szMessage.
 *
 * PARAMETERS:
 *    UINT   maxLength : The maximum no of characters to output.
 *    LPTSTR szMessage : Pointer to the buffer to use. Must be non-null.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void SC::GetErrorMessage(UINT maxLength, /*[OUT]*/ LPTSTR szMessage) const
{
    ASSERT(szMessage != NULL && maxLength > 0);
    if (szMessage == NULL || maxLength == 0)
        return;

    szMessage[0] = 0;

    switch(GetFacility())
    {
    default:
        ASSERT(0 && "SC::GetErrorMessage: Unknown SC facility.");
        break;

    case FACILITY_WIN:
    case FACILITY_HRESULT:
        {
            int nChars = 0;

            if ( GetCode() == E_UNEXPECTED )
            {
                nChars = ::LoadString(SC::GetHinst(), IDS_E_UNEXPECTED, szMessage, maxLength);
            }
            else
            {
                DWORD dwFlags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS;
                void  *lpSource = NULL;

                // add XML module to be searched as well
                HMODULE hmodXML = GetModuleHandle(_T("msxml.dll"));
                if (hmodXML)
                {
                    dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
                    lpSource = hmodXML;
                }

                DWORD dwMessageID = GetCode();

                // reverse values made by HRESULT_FROM_WIN32
                // Not sure why ::FormatMessage does not work with such values,
                // but we need to convert them back, or else there won't be any messages
                if ( (dwMessageID & 0xFFFF0000) == ((FACILITY_WIN32 << 16) | 0x80000000) )
                    dwMessageID &= 0x0000FFFF;

                nChars = ::FormatMessage(   dwFlags,
                                            lpSource,
                                            dwMessageID,
                                            0,          /*dwLangID*/
                                            szMessage,  /*lpBuffer*/
                                            maxLength,  /*nSize*/
                                            0           /*Arguments*/
                                        );
            }

            if (nChars)
                break;

            // if former failed - add a default error
            nChars = ::LoadString(SC::GetHinst(), IDS_MESSAGE_NOT_FOUND_ERROR, szMessage, maxLength);

            if (nChars == 0)
            {
                // too bad. we can only use hardcoded one
                _tcsncpy(szMessage, _T("Unknown error"), maxLength);
                szMessage[maxLength - 1] = 0;
            }
        }
        break;

    case FACILITY_MMC:
        {
            int nChars = ::LoadString(GetHinst(), GetCode(), szMessage, maxLength);
            if(nChars == 0) // did not exist
            {
                nChars = ::LoadString(GetHinst(), IDS_MESSAGE_NOT_FOUND_ERROR, szMessage, maxLength);
                ASSERT(nChars > 0);
            }
        }
        break;
    }
}


/*+-------------------------------------------------------------------------*
 *
 * SC::GetHelpID
 *
 * PURPOSE: Returns the help ID associated with a status code
 *
 * RETURNS:
 *    DWORD
 *
 *+-------------------------------------------------------------------------*/
DWORD
SC::GetHelpID()
{
    return 0; // TODO
}

LPCTSTR
SC::GetHelpFile()
{
    static TCHAR szFilePath[MAX_PATH] = TEXT("\0");

    // set the path if not already set
    if(*szFilePath == TEXT('\0') )
    {
        DWORD dwCnt = ExpandEnvironmentStrings(_T("%WINDIR%\\help\\mmc.chm"), szFilePath, MAX_PATH);
        ASSERT(dwCnt != 0);
    }

    return szFilePath;
}

void SC::Throw() throw(SC)
{
    // make exact copy of itself and destroy it (forces all the output)
#ifdef DBG
    {
        SC sc(*this);
        sc.SetFunctionName(m_szFunctionName);
        // forget the debug info - it will not be usefull anyway
        // This will turn off the Trace on destructor
        SetFunctionName(NULL);
    }
#endif // DBG

    throw(*this);
}

void SC::Throw(HRESULT hr)
{
    (*this) = hr;
    Throw();
}


/*+-------------------------------------------------------------------------*
 *
 * SC::FatalError
 *
 * PURPOSE:  Terminates the application.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
SC::FatalError() const
{
    MMCErrorBox(*this);
    exit(1);
}

/*+-------------------------------------------------------------------------*
 *
 * SC::FromLastError
 *
 * PURPOSE:  Fill SC with value from GetLastError.
 *
 *           The SC is guaranteed to contain a failure code (i.e. IsError()
 *           will return true) when this function returns.
 *
 * RETURNS:  Reference to the current SC
 *
 *+-------------------------------------------------------------------------*/
SC& SC::FromLastError()
{
    FromWin32 (::GetLastError());

	/*
	 * Some APIs will fail without setting extended error information.
	 * Presumably this function was called in response to an error, so
	 * we always want this SC to indicate *some* sort of error.  If the
	 * failing API neglected to set extended error information, give
	 * this SC a generic error code
	 */
	if (!IsError())
		MakeSc (FACILITY_HRESULT, E_FAIL);

	ASSERT (IsError());
	return (*this);
}

//############################################################################
//############################################################################
//
// Error formatting
//
//############################################################################
//############################################################################
/*
 *  Purpose:    Formats an error message
 *
 *  Parameters:
 *      ids     String describing the operation in progress
 *      sc      Error code describing the problem encountered
 *      pstrMessage
 *              the resulting message.
 */
void FormatErrorIds(UINT ids, SC sc, UINT maxLength, /*[OUT]*/ LPTSTR szMessage)
{
    TCHAR   sz[cchMaxSmallLine];
    LoadString(SC::GetHinst(), IDR_MAINFRAME, sz, cchMaxSmallLine);
    FormatErrorString(sz, sc, maxLength, szMessage);
}

//
// Returns a short version of an error message associated a given SC.
//
void FormatErrorShort(SC sc, UINT maxLength, /*[OUT]*/ LPTSTR szMessage)
{
    FormatErrorString(NULL, sc, maxLength, szMessage, TRUE);
}

//
// FormatErrorString formats an error message from any SC
//
// Parameters:
//      szOperation
//              String describing the operation in progress
//              May be NULL if sc is sufficient.
//      szMessage
//              the resulting message.
//      fShort
//              TRUE if you want the error message only (no header/footer)
//
void FormatErrorString(LPCTSTR szOperation, SC sc , UINT maxLength, /*[OUT]*/ LPTSTR szMessage, BOOL fShort)
{
    sc.GetErrorMessage(maxLength, szMessage);
    // TODO: add p
}

//############################################################################
//############################################################################
//
// MMCErrorBox
//
//############################################################################
//############################################################################

/*
 *  MMCErrorBox
 *
 *  Purpose:    Displays an Error Box for the given SZ.
 *          NOTE: This is the one that actually puts-up the dialog.
 *
 *  Parameters:
 *      sz          Pointer to the message to display
 *      fuStyle     As per windows MessageBox
 *
 *  Return value:
 *      int         Button Pressed to dismiss the ErrorBox
 */
int MMCErrorBox(LPCTSTR szMessage, UINT fuStyle )
{
    INT             id;

    // If not system modal (background thread), force task modal.
     if (!(fuStyle &  MB_SYSTEMMODAL))
        fuStyle |= MB_TASKMODAL;

    TCHAR   szCaption[cchMaxSmallLine];
    LoadString(SC::GetHinst(), IDR_MAINFRAME, szCaption, cchMaxSmallLine);

    // get window to parent the message box
    HWND hWndActive = SC::GetHWnd();

    // cannot parent on hidden window!
    if ( !IsWindowVisible(hWndActive) )
        hWndActive = NULL;

    id = ::MessageBox(hWndActive, szMessage, szCaption, fuStyle);

    return id;
}


/*+-------------------------------------------------------------------------*
 *
 * MMCErrorBox
 *
 * PURPOSE: Displays an error box with the specified message and style
 *
 * PARAMETERS:
 *    UINT  idsOperation :
 *    UINT  fuStyle :
 *
 * RETURNS:
 *    int: Button pressed
 *
 *+-------------------------------------------------------------------------*/
int
MMCErrorBox(UINT idsOperation, UINT fuStyle)
{
    TCHAR sz[cchMaxSmallLine];
    LoadString(SC::GetHinst(), idsOperation, sz, cchMaxSmallLine);
    return MMCErrorBox(sz, fuStyle);
}


/*
 *  MMCErrorBox
 *
 *  Purpose:    Displays a complex Error Box, given the operation
 *              and the status code
 *
 *  Parameters:
 *      ids         description of the operation that failed.
 *      SC          Status Code to report
 *      fuStyle     As per windows MessageBox
 *
 *  Return value:
 *      int         Button Pressed to dismiss the ErrorBox
 */
int MMCErrorBox(UINT ids, SC sc, UINT fuStyle)
{
    TCHAR sz[cchMaxSmallLine];
    LoadString(SC::GetHinst(), ids, sz, cchMaxSmallLine);
    return MMCErrorBox(sz, sc, fuStyle);
}

/*
 *  MMCErrorBox
 *
 *  Purpose:    Displays a complex Error Box, given the operation
 *              and the status code
 *
 *  Parameters:
 *      szOperation Description of the operation that failed.
 *      sz          Status Code to report
 *      fuStyle     As per windows MessageBox
 *
 *  Return value:
 *      int         Button Pressed to dismiss the ErrorBox
 */
int MMCErrorBox(LPCTSTR szOperation, SC sc, UINT fuStyle)
{
    TCHAR sz[cchMaxSmallLine];
    FormatErrorString(szOperation, sc, cchMaxSmallLine, sz);
    return MMCErrorBox(sz, fuStyle);
}

/*
 *  MMCErrorBox
 *
 *  Purpose:    Displays an Error Box for the given Status Code.
 *
 *  Parameters:
 *      SC          Status Code to report
 *      fuStyle     As per windows MessageBox
 *
 *  Return value:
 *      int         Button Pressed to dismiss the ErrorBox
 */
int MMCErrorBox(SC sc, UINT fuStyle)
{
    TCHAR sz[cchMaxSmallLine];
    FormatErrorString(NULL, sc, cchMaxSmallLine, sz);
    return MMCErrorBox(sz, fuStyle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\pickicon.cpp ===
/*
 * pickicon - Icon picker
 */

#include "stdafx.h"
#include "pickicon.h"
#include "windowsx.h"
#include "commdlg.h"
#include "resource.h"
#include "util.h"

typedef TCHAR TCH;

typedef struct COFN {           /* common open file name */
    OPENFILENAME ofn;           /* The thing COMMDLG wants */
    TCH tsz[MAX_PATH];          /* Where we build the name */
    TCH tszFilter[100];         /* File open/save filter */
} COFN, *PCOFN;

/*****************************************************************************
 *
 *  InitOpenFileName
 *
 *  Initialize a COFN structure.
 *
 *****************************************************************************/

void PASCAL
InitOpenFileName(HWND hwnd, PCOFN pcofn, UINT ids, LPCTSTR pszInit)
{
    DECLARE_SC(sc, TEXT("InitOpenFileName"));

    int itchMax;
    TCH tch;

    ZeroMemory(&pcofn->ofn, sizeof(pcofn->ofn));
    pcofn->ofn.lStructSize |= sizeof(pcofn->ofn);
    pcofn->ofn.hwndOwner = hwnd;
    pcofn->ofn.lpstrFilter = pcofn->tszFilter;
    pcofn->ofn.lpstrFile = pcofn->tsz;
    pcofn->ofn.nMaxFile = MAX_PATH;
    pcofn->ofn.Flags |= (OFN_HIDEREADONLY | OFN_NOCHANGEDIR);

    /* Get the filter string */
    itchMax = LoadString(SC::GetHinst(), ids, pcofn->tszFilter, countof(pcofn->tszFilter));

    if (itchMax) {
        /* Marker character must not be DBCS */
        tch = pcofn->tszFilter[itchMax-1];
        LPTSTR ptsz = pcofn->tszFilter;
        while (ptsz < &pcofn->tszFilter[itchMax]) {
            if (*ptsz == tch) *ptsz++ = '\0';
            else ptsz = CharNext(ptsz);
        }
    }

    /* Set the initial value */
    sc = StringCchCopy(pcofn->tsz, countof(pcofn->tsz), pszInit);
    // Let the sc trace on destruction
}


/*
 *  Instance info for the dialog.
 */
typedef struct PIDI {		/* PickIcon dialog instance */
    LPTSTR ptszIconPath;	/* Which file? */
    UINT ctchIconPath;
    int iIconIndex;		/* Which icon number? */
    int *piIconIndex;
    TCH tszCurFile[MAX_PATH];	/* The path in the list box */
} PIDI, *PPIDI;

#define cxIcon GetSystemMetrics(SM_CXICON)
#define cyIcon GetSystemMetrics(SM_CYICON)

/*****************************************************************************
 *
 *  PickIcon_ppidiHdlg
 *
 *	Extract the PPIDI from an hdlg.
 *
 *****************************************************************************/

#define PickIcon_ppidiHdlg(hdlg) ((PPIDI)GetWindowLongPtr(hdlg, DWLP_USER))

/*****************************************************************************
 *
 *  PickIcon_OnMeasureItem
 *
 *	Tell USER the size of each item.
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnMeasureItem(HWND hdlg, LPMEASUREITEMSTRUCT lpmi, PPIDI ppidi)
{
    lpmi->itemWidth = cxIcon + 12;
    lpmi->itemHeight = cyIcon + 4;
}

/*****************************************************************************
 *
 *  PickIcon_OnDrawItem
 *
 *	Draw an icon.
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnDrawItem(HWND hdlg, LPDRAWITEMSTRUCT lpdi, PPIDI ppidi)
{
    SetBkColor(lpdi->hDC, GetSysColor((lpdi->itemState & ODS_SELECTED) ?
					COLOR_HIGHLIGHT : COLOR_WINDOW));

    /* repaint the selection state */
    ExtTextOut(lpdi->hDC, 0, 0, ETO_OPAQUE, &lpdi->rcItem, NULL, 0, NULL);

	/*
	 * Preserve icon shape when BitBlitting it to a
	 * mirrored DC.
	 */
	DWORD dwLayout=0L;
	if ((dwLayout=GetLayout(lpdi->hDC)) & LAYOUT_RTL)
	{
		SetLayout(lpdi->hDC, dwLayout|LAYOUT_BITMAPORIENTATIONPRESERVED);
	}

    /* draw the icon centered in the rectangle */
    if ((int)lpdi->itemID >= 0) {
	DrawIcon(lpdi->hDC,
		(lpdi->rcItem.left + lpdi->rcItem.right - cxIcon) / 2,
		(lpdi->rcItem.bottom + lpdi->rcItem.top - cyIcon) / 2,
		(HICON)lpdi->itemData);
    }

	/*
	 * Restore the DC to its previous layout state.
	 */
	if (dwLayout & LAYOUT_RTL)
	{
		SetLayout(lpdi->hDC, dwLayout);
	}

    /* if it has the focus, draw the focus */
    if (lpdi->itemState & ODS_FOCUS) {
	DrawFocusRect(lpdi->hDC, &lpdi->rcItem);
    }
}

/*****************************************************************************
 *
 *  PickIcon_OnDeleteItem
 *
 *	USER is nuking an item.  Clean it up.
 *
 *****************************************************************************/

#define PickIcon_OnDeleteItem(hdlg, lpdi, ppidi) \
    DestroyIcon((HICON)(lpdi)->itemData)

/*****************************************************************************
 *
 *  PickIcon_FillIconList
 *
 *	Fill in all the icons.  If the user picks a bad place, we leave
 *	garbage in the path (so he can edit the name) and leave the list
 *	box blank.
 *
 *****************************************************************************/

void PickIcon_FillIconList(HWND hdlg, PPIDI ppidi)
{
    DECLARE_SC(sc, TEXT("PickIcon_FillIconList"));
    sc = ScCheckPointers(ppidi);
    if (sc)
        return;

    HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    HWND hwnd = GetDlgItem(hdlg, IDC_PICKICON);
    if (!IsWindow (hwnd))
        return;

    ListBox_SetColumnWidth(hwnd, cxIcon + 12);
    ListBox_ResetContent(hwnd);

	TCHAR szFile[countof(ppidi->tszCurFile)];
    GetDlgItemText(hdlg, IDC_PICKPATH, szFile, countof(szFile));

	// support indirect paths (e.g. %SystemRoot%\...")
	TCHAR szExpandedFile[countof(ppidi->tszCurFile)];
	ExpandEnvironmentStrings (szFile, szExpandedFile, countof(szExpandedFile));

	if (SearchPath(0, szExpandedFile, 0, countof(ppidi->tszCurFile),
				   ppidi->tszCurFile, 0)) {
ExtractIcons:
		int cIcons;
		cIcons = ExtractIconEx(ppidi->tszCurFile, 0, 0, 0, 0);
		if (cIcons) {
			HICON *rgIcons = (HICON *)LocalAlloc(LPTR, cIcons * sizeof(HICON));
			if (rgIcons) {
				cIcons = (int)ExtractIconEx(ppidi->tszCurFile, 0,
											rgIcons, NULL, cIcons);
				if (cIcons) {
					int iicon;
					SendMessage(hwnd, WM_SETREDRAW, 0, 0);
					for (iicon = 0; iicon < cIcons; iicon++) {
						ListBox_AddString(hwnd, rgIcons[iicon]);
					}
					if (ListBox_SetCurSel(hwnd, ppidi->iIconIndex) == LB_ERR) {
						ListBox_SetCurSel(hwnd, 0);
					}
					SendMessage(hwnd, WM_SETREDRAW, 1, 0);
				} else {		/* Mysteriously unable to extract */
				}
				LocalFree((HLOCAL)rgIcons);
			} else {			/* Not enough memory to load icons */
			}
		} else {			/* No icons in the file */
		}

        // compare the indirect path (e.g., %SystemRoot%\...) against 
        // the expanded version (szFile - c:\windows)
        int nCmpFile = CompareString(LOCALE_USER_DEFAULT, 
                                     0, 
                                     szExpandedFile, 
                                     countof(szExpandedFile), 
                                     szFile, 
                                     countof(szFile));
        
        // If the comparision failed, then no need to do the next comparsion
        // so trace the failure and move on
        if(ERROR_INVALID_FLAGS == nCmpFile || ERROR_INVALID_PARAMETER == nCmpFile)
        {
            sc = E_UNEXPECTED ;
            sc.TraceAndClear();
        }
        else
        {
            // Compare the expanded file against the file chosen from the dialog
            int nCmpCurFile = CompareString(LOCALE_USER_DEFAULT, 
                                            0, 
                                            szExpandedFile, 
                                            countof(szExpandedFile), 
                                            ppidi->tszCurFile, 
                                            countof(ppidi->tszCurFile));

            // If the comparison failed, then no need to continue so trace the error
            // and move on
            if(ERROR_INVALID_FLAGS == nCmpCurFile || ERROR_INVALID_PARAMETER == nCmpCurFile)
            {
                sc = E_UNEXPECTED ;
                sc.TraceAndClear();
            }
            else
            {
                // if szExpandedFile != szFile and szExpandFile == ppidi->tszCurFile
                // then copy szFile into ppidi->tszCurFile to update the path for 
                // the open file dialog
                if((CSTR_EQUAL != nCmpFile) && (CSTR_EQUAL == nCmpCurFile))
		        {                    
			        sc = StringCchCopy(ppidi->tszCurFile, countof(ppidi->tszCurFile), szFile);
			        if (sc)
				        sc.TraceAndClear();
		        }
            }
        }
		SetDlgItemText(hdlg, IDC_PICKPATH, ppidi->tszCurFile);
	} else {				/* File not found */
		SC sc;
		MMCErrorBox (sc.FromWin32(ERROR_FILE_NOT_FOUND));
		goto ExtractIcons;
	}

    InvalidateRect(hwnd, 0, 1);
    SetCursor(hcurOld);
}

/*****************************************************************************
 *
 *  PickIcon_OnInitDialog
 *
 *	Dialog init.  Populate the list box with what we came in with.
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnInitDialog(HWND hdlg, PPIDI ppidi)
{
    DECLARE_SC(sc, _T("PickIcon_OnInitDialog"));

    SetWindowLongPtr(hdlg, DWLP_USER, (LPARAM)ppidi);

    sc = StringCchCopy(ppidi->tszCurFile, countof(ppidi->tszCurFile), ppidi->ptszIconPath);
    if(sc)
        sc.TraceAndClear();
    else
        SetDlgItemText(hdlg, IDC_PICKPATH, ppidi->tszCurFile);

    SendDlgItemMessage(hdlg, IDC_PICKPATH, EM_LIMITTEXT,
		       ppidi->ctchIconPath, 0);
    PickIcon_FillIconList(hdlg, ppidi);
}

/*****************************************************************************
 *
 *  PickIcon_OnBrowse
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnBrowse(HWND hdlg, PPIDI ppidi)
{
    DWORD dw;
    COFN cofn;
    InitOpenFileName(hdlg, &cofn, IDS_ICONFILES, ppidi->tszCurFile);
    dw = GetFileAttributes(ppidi->tszCurFile);
    if (dw == 0xFFFFFFFF || (dw & FILE_ATTRIBUTE_DIRECTORY)) {
	cofn.tsz[0] = '\0';
    }

    if (GetOpenFileName(&cofn.ofn)) {
        SetDlgItemText(hdlg, IDC_PICKPATH, cofn.tsz);
        SendMessage(hdlg, DM_SETDEFID, IDOK, 0);
	PickIcon_FillIconList(hdlg, ppidi);
    }
}

/*****************************************************************************
 *
 *  PickIcon_NameChange
 *
 *  Determine whether the thing in the edit control doesn't match the
 *  thing whose icons we are showing.
 *
 *****************************************************************************/

BOOL PASCAL
PickIcon_NameChange(HWND hdlg, PPIDI ppidi)
{
    TCH tszBuffer[MAX_PATH];
    GetDlgItemText(hdlg, IDC_PICKPATH, tszBuffer, countof(tszBuffer));
    int nCmpFile = CompareString(LOCALE_USER_DEFAULT, 0, 
                                tszBuffer, -1,
                                ppidi->tszCurFile, -1);

    // If the name change can't be confirmed, then assume that something
    // changed and return TRUE (which will force the selection to be cleared)
     if(ERROR_INVALID_FLAGS == nCmpFile || ERROR_INVALID_PARAMETER == nCmpFile)
         return TRUE;

    // NOTE: From the SDK: To maintain the C run-time convention of 
    // comparing strings, the value 2 can be subtracted from a nonzero 
    // return value. The meaning of < 0, ==0 and > 0 is then consistent 
    // with the C run times.
    return nCmpFile - 2; // If nCmpFile == 0, then nothing changed so return FALSE else TRUE
}

/*****************************************************************************
 *
 *  PickIcon_OnOk
 *
 *	If the name has changed, treat this as a "Okay, now reload
 *	the icons" rather than "Okay, I'm finished".
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnOk(HWND hdlg, PPIDI ppidi)
{
    DECLARE_SC(sc, _T("PickIcon_OnOk"));
    if (PickIcon_NameChange(hdlg, ppidi)) {
	PickIcon_FillIconList(hdlg, ppidi);
    } else {
	int iIconIndex = (int)SendDlgItemMessage(hdlg, IDC_PICKICON,
						LB_GETCURSEL, 0, 0L);
	if (iIconIndex >= 0) {	/* We have an icon */
	    *ppidi->piIconIndex = iIconIndex;
        sc = StringCchCopy(ppidi->ptszIconPath, ppidi->ctchIconPath, ppidi->tszCurFile);
        // if error trace on destruction, but don't clear
	    EndDialog(hdlg, 1);
	} else {		/* No icon, act like cancel */
	    EndDialog(hdlg, 0);
	}
    }
}

/*****************************************************************************
 *
 *  PickIcon_OnCommand
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnCommand(HWND hdlg, int id, UINT codeNotify, PPIDI ppidi)
{
    switch (id) {
    case IDOK: PickIcon_OnOk(hdlg, ppidi); break;
    case IDCANCEL: EndDialog(hdlg, 0); break;

    case IDC_PICKBROWSE: PickIcon_OnBrowse(hdlg, ppidi); break;

    /*
     *	When the name changes, remove the selection highlight.
     */
    case IDC_PICKPATH:
		if (PickIcon_NameChange(hdlg, ppidi)) {
			SendDlgItemMessage(hdlg, IDC_PICKICON, LB_SETCURSEL, (WPARAM)-1, 0);
		}
		break;

    case IDC_PICKICON:
		if (codeNotify == LBN_DBLCLK) {
			PickIcon_OnOk(hdlg, ppidi);
		}
		break;
    }
}

/*****************************************************************************
 *
 *  PickIcon_DlgProc
 *
 *	Dialog procedure.
 *
 *****************************************************************************/

/*
 * The HANDLE_WM_* macros weren't designed to be used from a dialog
 * proc, so we need to handle the messages manually.  (But carefully.)
 */

INT_PTR EXPORT
PickIcon_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    PPIDI ppidi = PickIcon_ppidiHdlg(hdlg);

    switch (wm) {
    case WM_INITDIALOG: PickIcon_OnInitDialog(hdlg, (PPIDI)lParam); break;

    case WM_COMMAND:
	PickIcon_OnCommand(hdlg, (int)GET_WM_COMMAND_ID(wParam, lParam),
				 (UINT)GET_WM_COMMAND_CMD(wParam, lParam),
				 ppidi);
	break;

    case WM_DRAWITEM:
	PickIcon_OnDrawItem(hdlg, (LPDRAWITEMSTRUCT)lParam, ppidi);
	break;

    case WM_MEASUREITEM:
	PickIcon_OnMeasureItem(hdlg, (LPMEASUREITEMSTRUCT)lParam, ppidi);
	break;

    case WM_DELETEITEM:
	PickIcon_OnDeleteItem(hdlg, (LPDELETEITEMSTRUCT)lParam, ppidi);
	break;

    default: return 0;	/* Unhandled */
    }
    return 1;		/* Handled */
}


/*****************************************************************************
 *
 *  MMC_PickIconDlg
 *
 *	Ask the user to pick an icon.
 *
 *	hwnd - owner window
 *	ptszIconPath - (in) default icon file
 *		      (out) chosen icon file
 *	ctchIconPath - size of ptszIconPath buffer
 *	piIconIndex - (in) default icon index
 *		      (out) index of chosen icon
 *
 *	If the dialog box is cancelled, then no values are changed.
 *
 *****************************************************************************/

MMCBASE_API INT_PTR PASCAL
MMC_PickIconDlg(HWND hwnd, LPTSTR ptszIconPath, UINT ctchIconPath, int *piIconIndex)
{
    PIDI pidi;

    pidi.ptszIconPath = ptszIconPath;
    pidi.ctchIconPath = ctchIconPath;
    pidi.piIconIndex = piIconIndex;
    pidi.iIconIndex = *piIconIndex;

    return DialogBoxParam(SC::GetHinst(), MAKEINTRESOURCE(IDD_PICKICON), hwnd,
			  PickIcon_DlgProc, (LPARAM)&pidi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mmcdebug.rc
//
#define IDC_TRACE_FILENAME              86
#define IDC_TRACE_TO_COM2               91
#define IDC_TRACE_OUTPUTDEBUGSTRING     92
#define IDC_TRACE_TO_FILE               93
#define IDC_TRACE_DEBUG_BREAK           95
#define IDC_TRACE_SELECT_ALL            96
#define IDC_TRACE_DEFAULT               97
#define IDC_TRACE_DUMP_STACK            1000
#define IDC_TRACE_STACKLEVELS           1001
#define IDD_DEBUG_TRACE_DIALOG          1003
#define IDD_PICKICON                    1004
#define IDC_PICKPATH                    1005
#define IDC_PICKICON                    1006
#define IDC_PICKBROWSE                  1007
#define IDS_ICONFILES                   1008
#define IDC_TRACE_LIST                  1032

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF

MAJORCOMP=admin
MINORCOMP=MMC

TARGETNAME=mmcbase
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLENTRY=_DllMainCRTStartup
UMTYPE=windows

WIN32_WINNT_VERSION=0x0400
WIN32_IE_VERSION=0x0500
SUBSYSTEM_VERSION=4.00

SYNCHRONIZE_BLOCK = 1
USE_NATIVE_EH     = 1
USE_RTTI          = 1
USE_VCCOM         = 1
USE_STL           = 1
USE_STATIC_ATL    = 1
ATL_VER           = 30
USE_MSVCRT        = 1
USE_WTL           = 1

!ifdef PrivateBuild_NoLocalSC
C_DEFINES = $(C_DEFINES) -DPrivateBuild_NoLocalSC
!endif

# Use LINKLIBS (gets passed first) if: (from build.hlp)
#  You are building a dynamic link.
#  You are exporting something that's defined in some other component library that you also build.
#  In your dirs file in the subdirectory above, you have ordered it so that the component libraries
#     are around before you build the dynamic link.
LINKLIBS = \
	..\..\core\$(CharWidth)\$(O)\uicore.lib

TARGETLIBS = \
   $(SDK_LIB_PATH)\kernel32.lib 	\
   $(SDK_LIB_PATH)\user32.lib   	\
   $(SDK_LIB_PATH)\gdi32.lib    	\
   $(SDK_LIB_PATH)\oleaut32.lib 	\
   $(SDK_LIB_PATH)\ole32.lib    	\
   $(SDK_LIB_PATH)\advapi32.lib 	\
   $(SDK_LIB_PATH)\uuid.lib     	\
   $(SDK_LIB_PATH)\comctl32.lib 	\
   $(SDK_LIB_PATH)\comdlg32.lib 	\
   $(SDK_LIB_PATH)\shell32.lib  	\
   $(SDK_LIB_PATH)\imagehlp.lib		\

INCLUDES = \
	..\;					\
	..\..\core;				\
	..\..\inc;				\
	..\..\types\idl\$(O);	\


DLLDEF=..\mmcbase.def


PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_CXX = 1

SOURCES = \
	..\mmcbase.rc       \
	..\comobjects.cpp   \
	..\eventlock.cpp    \
	..\mmcbase.cpp      \
	..\mmcdebug.cpp     \
	..\mmcerror.cpp     \
	..\tracedlg.cpp     \
	..\classreg.cpp     \
	..\pickicon.cpp     \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7CC9B821_F32B_4880_930E_33ADDFF3F376__INCLUDED_)
#define AFX_STDAFX_H__7CC9B821_F32B_4880_930E_33ADDFF3F376__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//############################################################################
//############################################################################
//
// Preprocessor settings.
//
//############################################################################
//############################################################################

// This #define causes  MMCBASE_API to be set to __declspec(dllexport)
#define MMCBASE_EXPORTS 1

//############################################################################
//############################################################################
//
// This is an MFC extension DLL, so we need the MFC header
//
//############################################################################
//############################################################################
#include "afxwin.h"

//############################################################################
//############################################################################
//
// ATL and  other classes
//
//############################################################################
//############################################################################

#define _WTL_NO_AUTOMATIC_NAMESPACE

#include <atlbase.h>
extern CComModule _Module;
#include <atlwin.h>
#include <atlapp.h>
#include <atlgdi.h>

/*
 * Delcarations of ImageList_Read and ImageList_Write copied from commctrl.h.
 *
 * Here's why:
 *
 * commctrl.h is included by afx.h.  At that time objidl.h (where IStream
 * is defined) hasn't been included yet, so the declaration of these
 * functions is skipped in commctrl.h.
 *
 * The definition of WTL::CImageList assumes that these functions have been
 * declared, so we have to go to this pain here, after IStream has been
 * declared.
 */
WINCOMMCTRLAPI HIMAGELIST WINAPI ImageList_Read(LPSTREAM pstm);
WINCOMMCTRLAPI BOOL       WINAPI ImageList_Write(HIMAGELIST himl, LPSTREAM pstm);

#include <atlctrls.h>

//############################################################################
//############################################################################
//
// STL and  other classes
//
//############################################################################
//############################################################################
#include <algorithm>
#include <exception>
#include <string>
#include <list>
#include <set>
#include <vector>
#include <map>
#include <iterator>

//############################################################################
//############################################################################
//
// Files #included from base and core.
//
//############################################################################
//############################################################################
#include "dbg.h"
#include "cstr.h"
#include "mmcdebug.h"
#include "mmcerror.h"
#include "countof.h"
#include "autoptr.h"
#include "classreg.h"

//############################################################################
//############################################################################
//
// The safer string handling routines
//
//############################################################################
//############################################################################
#include <strsafe.h>

//############################################################################
//############################################################################
//
// include common strings.
//
//############################################################################
//############################################################################
#include "..\base\basestr.h"

//############################################################################
//############################################################################
//
// Debug support for legacy traces.
//
//############################################################################
//############################################################################
#ifdef TRACE
#undef TRACE
#endif

#ifdef DBG

#define TRACE TraceBaseLegacy

#else // DBG

#define TRACE               ;/##/

#endif DBG



#endif // !defined(AFX_STDAFX_H__7CC9B821_F32B_4880_930E_33ADDFF3F376__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mmcdebug.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\tracedlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      tracedlg.cpp
//
//  Contents:  Implementation of the debug trace code
//
//  History:   15-Jul-99 VivekJ    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include "tracedlg.h"

#ifdef DBG


//############################################################################
//############################################################################
//
//  Implementation of class CTraceDialog
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::RecalcCheckboxes
 *
 * PURPOSE: Recomputes the settings of the check boxes. This is in response to 
 *          a trace tag selection change.
 *
 * RETURNS: 
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CTraceDialog::RecalcCheckboxes()
{
    DWORD dwMask            = TRACE_ALL; //initialize with all ones
    bool  bAtLeastOneItem   = false;
    
    int iItem = m_listCtrl.GetNextItem(-1, LVNI_SELECTED);

    while(iItem != -1)
    {
        CTraceTag *pTag = reinterpret_cast<CTraceTag *>(m_listCtrl.GetItemData(iItem));
        ASSERT(pTag != NULL);
        if(pTag == NULL)
            return;

        bAtLeastOneItem = true;
        dwMask &= pTag->GetFlag(TRACE_ALL); // AND all the selected item's bits.
        iItem =  m_listCtrl.GetNextItem(iItem, LVNI_SELECTED);
    }

    // disable the checkbox if no item selected.
    ::EnableWindow(GetDlgItem(IDC_TRACE_TO_COM2),          bAtLeastOneItem);
    ::EnableWindow(GetDlgItem(IDC_TRACE_OUTPUTDEBUGSTRING),bAtLeastOneItem);
    ::EnableWindow(GetDlgItem(IDC_TRACE_TO_FILE),          bAtLeastOneItem);
    ::EnableWindow(GetDlgItem(IDC_TRACE_DEBUG_BREAK),      bAtLeastOneItem);
    ::EnableWindow(GetDlgItem(IDC_TRACE_DUMP_STACK),       bAtLeastOneItem);

    if(!bAtLeastOneItem)
        return;

    CheckDlgButton(IDC_TRACE_TO_COM2,           dwMask & TRACE_COM2              ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(IDC_TRACE_OUTPUTDEBUGSTRING, dwMask & TRACE_OUTPUTDEBUGSTRING ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(IDC_TRACE_TO_FILE,           dwMask & TRACE_FILE              ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(IDC_TRACE_DEBUG_BREAK,       dwMask & TRACE_DEBUG_BREAK       ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(IDC_TRACE_DUMP_STACK,        dwMask & TRACE_DUMP_STACK        ? BST_CHECKED : BST_UNCHECKED);

}


/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnSelChanged
 *
 * PURPOSE: Handles a selection change notification.
 *
 * PARAMETERS: 
 *    int      idCtrl :
 *    LPNMHDR  pnmh :
 *    BOOL&    bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT 
CTraceDialog::OnSelChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled )
{    
    RecalcCheckboxes();
    return 0;
}


/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnColumnClick
 *
 * PURPOSE:    Handles the column click notification - causes a sort by the 
 *           specified column.
 *
 * PARAMETERS: 
 *    int      idCtrl :
 *    LPNMHDR  pnmh :
 *    BOOL&    bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnColumnClick(int idCtrl, LPNMHDR pnmh, BOOL& bHandled )
{
    NM_LISTVIEW *pnmlv = (NM_LISTVIEW *) pnmh;
    m_dwSortData = pnmlv->iSubItem; // iSubItem is the column clicked on. Cache this value for later
    DoSort();
    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::SetMaskFromCheckbox
 *
 * PURPOSE: Sets the trace tag flag from the state of the specified check box.
 *
 * PARAMETERS: 
 *    UINT   idControl :    The check box control
 *    DWORD  dwMask :       The bit(s) to enable/disable depending on the state
 *                          of the control.
 *
 * RETURNS: 
 *    void
 *
 *+-------------------------------------------------------------------------*/
void            
CTraceDialog::SetMaskFromCheckbox(UINT idControl, DWORD dwMask)
{
    bool bEnabled = IsDlgButtonChecked(idControl) == BST_CHECKED;
    
    int iItem = m_listCtrl.GetNextItem(-1, LVNI_SELECTED);
    ASSERT(iItem != -1);

    while(iItem != -1)
    {
        CTraceTag *pTag = reinterpret_cast<CTraceTag *>(m_listCtrl.GetItemData(iItem));
        ASSERT(pTag != NULL);
        if(pTag == NULL)
            return;

        if(bEnabled)
            pTag->SetFlag(dwMask);
        else
            pTag->ClearFlag(dwMask);

        // update the UI
        m_listCtrl.SetItemText(iItem, COLUMN_ENABLED, pTag->FAnyTemp() ? TEXT("X") : TEXT(""));

        iItem = m_listCtrl.GetNextItem(iItem, LVNI_SELECTED);
    }

    // sort the items again
    DoSort();
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::DoSort
 *
 * PURPOSE: Perform a sort of the items in the dialog
 *
 * RETURNS: 
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CTraceDialog::DoSort()
{
    m_listCtrl.SortItems(CompareItems, m_dwSortData); 
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnOutputToCOM2
 *
 * PURPOSE:     Handles checking/unchecking the "output to Com2" button.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnOutputToCOM2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetMaskFromCheckbox(IDC_TRACE_TO_COM2,           TRACE_COM2);
    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnOutputDebugString
 *
 * PURPOSE:    Handles checking/unchecking the "OutputDebugString" button.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnOutputDebugString(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetMaskFromCheckbox(IDC_TRACE_OUTPUTDEBUGSTRING, TRACE_OUTPUTDEBUGSTRING);
    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnOutputToFile
 *
 * PURPOSE:     Handles checking/unchecking the "output to File" button.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnOutputToFile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetMaskFromCheckbox(IDC_TRACE_TO_FILE,           TRACE_FILE);
    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnDebugBreak
 *
 * PURPOSE:     Handles checking/unchecking the "DebugBreak" button.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnDebugBreak(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetMaskFromCheckbox(IDC_TRACE_DEBUG_BREAK,       TRACE_DEBUG_BREAK);
    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnDumpStack
 *
 * PURPOSE: Handles checking/unchecking the "Stack Dump" button.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnDumpStack(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetMaskFromCheckbox(IDC_TRACE_DUMP_STACK,        TRACE_DUMP_STACK);
    return 0;
}



/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnRestoreDefaults
 *
 * PURPOSE:     Restores the default (canned) settings of all trace tags.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnRestoreDefaults(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    CTraceTags::iterator iter;

    CTraceTags * pTraceTags = GetTraceTags();
    if(NULL == pTraceTags)
        goto Error;

    for(iter = pTraceTags->begin(); iter != pTraceTags->end(); iter++)
    {
        (*iter)->RestoreDefaults();
    }

    RecalcCheckboxes();

Cleanup:
    return 0;

Error:
    goto Cleanup;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnSelectAll
 *
 * PURPOSE:     Selects all trace tags.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnSelectAll(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int cItems = m_listCtrl.GetItemCount();
    for(int i=0; i< cItems; i++)
    {
        m_listCtrl.SetItemState(i, LVIS_SELECTED, LVIS_SELECTED);
    }

    RecalcCheckboxes();
    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::CompareItems
 *
 * PURPOSE:     The callback routine to compare two items in the list control.
 *
 * PARAMETERS: 
 *    LPARAM  lp1 :
 *    LPARAM  lp2 :
 *    LPARAM  lpSortData :
 *
 * RETURNS: 
 *    int CALLBACK
 *
 *+-------------------------------------------------------------------------*/
int CALLBACK
CTraceDialog::CompareItems(LPARAM lp1, LPARAM lp2, LPARAM lpSortData)
{
    CTraceTag *pTag1 = reinterpret_cast<CTraceTag *>(lp1);
    CTraceTag *pTag2 = reinterpret_cast<CTraceTag *>(lp2);

    if(!pTag1 && !pTag2)
    {
        ASSERT(0 && "Should not come here.");
        return 0;
    }

    switch(lpSortData)
    {
    default:
        ASSERT(0 && "Should not come here.");
        return 0;

    case COLUMN_CATEGORY:
        return _tcscmp(pTag1->GetCategory(), pTag2->GetCategory());
        break;

    case COLUMN_NAME:
        return _tcscmp(pTag1->GetName(), pTag2->GetName());
        break;

    case COLUMN_ENABLED:
        {
            BOOL b1 = (pTag1->FAnyTemp()) ? 0 : 1;
            BOOL b2 = (pTag2->FAnyTemp()) ? 0 : 1;

            return b1 - b2;
        }
        break;
    }
    
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnInitDialog
 *
 * PURPOSE:     Initializes the dialog - adds columns, sets the file name
 *              and inserts all rows.
 *
 * PARAMETERS: 
 *    UINT    uMsg :
 *    WPARAM  wParam :
 *    LPARAM  lParam :
 *    BOOL&   bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_listCtrl.Attach(GetDlgItem(IDC_TRACE_LIST));
    m_editStackLevels.Attach(GetDlgItem(IDC_TRACE_STACKLEVELS));
    m_editStackLevels.LimitText(1); // one character only.
    
    // insert the columns - no need to localize since debug only.
    m_listCtrl.InsertColumn(COLUMN_CATEGORY, TEXT("Category") ,LVCFMT_LEFT, 150, 0);
    m_listCtrl.InsertColumn(COLUMN_NAME,     TEXT("Name"    ) ,LVCFMT_LEFT, 150, 0);
    m_listCtrl.InsertColumn(COLUMN_ENABLED,  TEXT("Enabled" ) ,LVCFMT_LEFT, 80, 0);

    // set the full row select style.
    m_listCtrl.SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);
    m_listCtrl.SortItems(CompareItems, COLUMN_CATEGORY); // the default sort.

    // Set the file name.
    SetDlgItemText(IDC_TRACE_FILENAME, CTraceTag::GetFilename());

    //Set the stack level
    SetDlgItemInt(IDC_TRACE_STACKLEVELS, CTraceTag::GetStackLevels());

    CTraceTags * pTraceTags = GetTraceTags();
    if(NULL == pTraceTags)
        return 0;


    int i = 0;
    for(CTraceTags::iterator iter = pTraceTags->begin(); iter != pTraceTags->end(); iter++, i++)
    {
        int iItem = m_listCtrl.InsertItem(LVIF_PARAM | LVIF_TEXT, 
                                          i, (*iter)->GetCategory(), 0, 0, 0, (LPARAM) (*iter));
        m_listCtrl.SetItemText(iItem, COLUMN_NAME,      (*iter)->GetName());
        m_listCtrl.SetItemText(iItem, COLUMN_ENABLED,   (*iter)->FAny() ? TEXT("X") : TEXT(""));

        // set up the tag for a temporary change.
        (*iter)->SetTempState();
    }
    RecalcCheckboxes();

    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnCancel
 *
 * PURPOSE:     Handles the Cancel button. Exits without committing changes.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_listCtrl.Detach();
    EndDialog (false);
    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnOK
 *
 * PURPOSE:     Exits and commits changes.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // Set the file name from the edit control
    TCHAR szFilename[OFS_MAXPATHNAME] = {0};
    GetDlgItemText(IDC_TRACE_FILENAME, (LPTSTR)szFilename, countof(szFilename));
    CTraceTag::GetFilename()    = szFilename;

    // Set the stack levels
    TCHAR szStackLevels[2] = {0};
    GetDlgItemText(IDC_TRACE_STACKLEVELS, (LPTSTR)szStackLevels, countof(szStackLevels));
    int nLevels = 0;
    if(_T('\0') != szStackLevels[0])
        nLevels = szStackLevels[0] - TEXT('0'); // convert to integer.

    CTraceTag::GetStackLevels() = nLevels;

    CTraceTags::iterator iter;

    CTraceTags * pTraceTags = GetTraceTags();
    if(NULL == pTraceTags)
        goto Error;

    // save all the trace tags out to the .ini file
    for(iter = pTraceTags->begin(); iter != pTraceTags->end(); iter++)
    {
        CStr str;
        CTraceTag *pTag = *iter;
        if(!pTag)
            goto Error;

        pTag->Commit();

        // write out the trace tag ONLY if the setting is not the same as the default. Avoids clutter.
        str.Format(TEXT("%d"), pTag->GetAll());
        ::WritePrivateProfileString(pTag->GetCategory(), pTag->GetName(), (LPCTSTR)str, szTraceIniFile);
    }
    m_listCtrl.Detach();

    // write out the values into the ini file.
    ::WritePrivateProfileString(TEXT("Trace File"),   TEXT("Trace File"),   (LPCTSTR)szFilename,    szTraceIniFile);
    ::WritePrivateProfileString(TEXT("Stack Levels"), TEXT("Stack Levels"), (LPCTSTR)szStackLevels, szTraceIniFile);

Cleanup:
    EndDialog (true);
    return 1;

Error:
    goto Cleanup;
}


/*+-------------------------------------------------------------------------*
 *
 * DoDebugTraceDialog
 *
 * PURPOSE:     Exported routine (DEBUG build only) to bring up the trace dialog.
 *
 * RETURNS: 
 *    MMCBASE_API void
 *
 *+-------------------------------------------------------------------------*/
MMCBASE_API void DoDebugTraceDialog()
{
    CTraceDialog dlg;
    dlg.DoModal();
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\version.h ===
#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "MMC Base DLL"
#define VER_INTERNALNAME_STR            "mmcbase.dll"
#define VER_ORIGINALFILENAME_STR        "mmcbase.dll"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\base\tracedlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      tracedlg.h
//
//  Contents:  Declaration of the debug trace code
//
//  History:   15-Jul-99 VivekJ    Created
//
//--------------------------------------------------------------------------

#ifndef TRACEDLG_H
#define TRACEDLG_H
#pragma once

#ifdef DBG

// forward class declarations
class CTraceDialog;

class CTraceDialog : public CDialogImpl<CTraceDialog>
{
    typedef CDialogImpl<CTraceDialog> BC;
// Construction
public:
    CTraceDialog() : m_dwSortData(0) {}

    enum { IDD = IDD_DEBUG_TRACE_DIALOG };

    // compare tags based on columns.
    static int CALLBACK CompareItems(LPARAM lp1, LPARAM lp2, LPARAM lpSortData);

// Implementation
protected:
    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER    (WM_INITDIALOG,              OnInitDialog)
        COMMAND_ID_HANDLER (IDOK,                       OnOK)
        COMMAND_ID_HANDLER (IDCANCEL,                   OnCancel)
        COMMAND_ID_HANDLER(IDC_TRACE_TO_COM2,           OnOutputToCOM2)
        COMMAND_ID_HANDLER(IDC_TRACE_OUTPUTDEBUGSTRING, OnOutputDebugString)
        COMMAND_ID_HANDLER(IDC_TRACE_TO_FILE,           OnOutputToFile)
        COMMAND_ID_HANDLER(IDC_TRACE_DEBUG_BREAK,       OnDebugBreak)
        COMMAND_ID_HANDLER(IDC_TRACE_DUMP_STACK,        OnDumpStack)
        COMMAND_ID_HANDLER(IDC_TRACE_DEFAULT,           OnRestoreDefaults)
        COMMAND_ID_HANDLER(IDC_TRACE_SELECT_ALL,        OnSelectAll)
        NOTIFY_HANDLER    (IDC_TRACE_LIST, LVN_ITEMCHANGED, OnSelChanged)
        NOTIFY_HANDLER    (IDC_TRACE_LIST, LVN_COL