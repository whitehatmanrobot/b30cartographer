= _tcscmp(szValue, TEXT("OnInstall")))
		{
			isVal.intVal = msidbRemoveFileInstallModeOnInstall;
		}
		else if (0 == _tcscmp(szValue, TEXT("OnRemove")))
		{
			isVal.intVal = msidbRemoveFileInstallModeOnRemove;
		}
		else if (0 == _tcscmp(szValue, TEXT("OnBoth")))
		{
			isVal.intVal = msidbRemoveFileInstallModeOnBoth;
		}
		else
		{
			// error
			_tprintf(TEXT("Compile Error: <%s> has an unrecognized value %s ")
					 TEXT("in SKU "),
					 rgXMSINodes[XMSI_INSTALLMODE].szNodeName, 
					 szValue);
			PrintSkuIDs(pSkuSet);
			hr = E_FAIL;
		}

		delete[] szValue;

		if (SUCCEEDED(hr))
			hr = pEE->SetValue(isVal, iColumn, pSkuSet);
	}

#ifdef DEBUG	
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ")
							 TEXT("ProcessInstallMode\n"));
#endif

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessIniFile
//   This function:
//         1) Process all subentities of <IniFile> include <FName>, 
//			  <DirProperty>, <Section>, <Key>, <Value>, <Action>
//         2) Insert into the IniFile table;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessIniFile(PIXMLDOMNode &pNodeIniFile, 
						IntStringValue isValComponent, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeIniFile != NULL);

	SkuSet skuSetCommon(g_cSkus); // the SkuSet that shares the common column 
								  // values

	// Values to be inserted into the DB 
	LPTSTR szIniFile	  = NULL;
	LPTSTR szFileName	  = NULL;
	LPTSTR szDirProperty  = NULL;
	LPTSTR szSection	  = NULL;
	LPTSTR szKey		  = NULL;
	LPTSTR szValue		  = NULL;
	UINT   uiAction       = MSI_NULL_INTEGER;
	LPTSTR szComponent_   = isValComponent.szVal;

	// create the File DB table
	hr = CreateTable_SKU(TEXT("IniFile"), pSkuSet);

	if (FAILED(hr))	return hr;

	// Construct an ElementEntry object. 
	ElementEntry *pEEIniFile = new ElementEntry(6, pSkuSet);
	assert(pEEIniFile);

	// Get ID attribute if there is one
	IntStringValue isValID;
	isValID.szVal = NULL;
	hr = ProcessAttribute(pNodeIniFile, TEXT("ID"), STRING, &isValID, pSkuSet);

	// if there is no ID specified, compiler generates one
	if (SUCCEEDED(hr))
	{
		if (!isValID.szVal)
		{
			isValID.szVal = GetName(TEXT("IniFile"));
#ifdef DEBUG
			_tprintf(TEXT("Processing <IniFile> with compiler generated ")
					 TEXT("primary key = %s\n"), isValID.szVal);
#endif
		}
		else
		{
#ifdef DEBUG
			_tprintf(TEXT("Processing <IniFile ID=\"%s\">\n"), isValID.szVal);
#else
		;
#endif
		}
		// at this point, a primary key should exist for this IniFile
		szIniFile = isValID.szVal;
		assert(szIniFile);

	}

	// Call ProcessChildrenArray to get back column values of all SKUs 
	// via the ElementEntry object
	if (SUCCEEDED(hr))
		hr = ProcessChildrenArray_H_XIES(pNodeIniFile, rgNodeFuncs_IniFile,
										 cNodeFuncs_IniFile, pEEIniFile, 
										 pSkuSet);
	
	// Finalize the values stored in *pEEIniFile
	if (SUCCEEDED(hr))
		hr = pEEIniFile->Finalize();

	if (SUCCEEDED(hr))
	{
		// Process Common values first
		skuSetCommon = pEEIniFile->GetCommonSkuSet();

		if (!skuSetCommon.testClear())
		{
			szFileName	   = pEEIniFile->GetCommonValue(1).szVal;
			szDirProperty  = pEEIniFile->GetCommonValue(2).szVal;
			szSection	   = pEEIniFile->GetCommonValue(3).szVal;
			szKey		   = pEEIniFile->GetCommonValue(4).szVal;
			szValue		   = pEEIniFile->GetCommonValue(5).szVal;
			uiAction	   = pEEIniFile->GetCommonValue(6).intVal;

			// insert into DB
			hr = InsertIniFile(szIniFile, szFileName, szDirProperty, 
							   szSection, szKey, szValue, uiAction, 
							   szComponent_, &skuSetCommon, -1);
		}
	}

	// process exceptional values
	if(SUCCEEDED(hr))
	{
		SkuSet skuSetUncommon = SkuSetMinus(*pSkuSet, skuSetCommon);
		if (!skuSetUncommon.testClear())
		{
			for (int i=0; i<g_cSkus; i++)
			{
				if (skuSetUncommon.test(i))
				{
					szFileName	   = pEEIniFile->GetValue(1,i).szVal;
					szDirProperty  = pEEIniFile->GetValue(2,i).szVal;
					szSection	   = pEEIniFile->GetValue(3,i).szVal;
					szKey		   = pEEIniFile->GetValue(4,i).szVal;
					szValue		   = pEEIniFile->GetValue(5,i).szVal;
					uiAction	   = pEEIniFile->GetValue(6,i).intVal;

					// insert into DB
					hr = InsertIniFile(szIniFile, szFileName, szDirProperty, 
									   szSection, szKey, szValue, uiAction, 
									   szComponent_, NULL, i);
				}
			}
		}
	}

	delete pEEIniFile;

	if (szIniFile)
		delete[] szIniFile;


#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessIniFile\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessAction
//   This function:
//         1) Process <Action> entity and set the Action Column in the
//	  IniFile Table.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessAction(PIXMLDOMNode &pNodeAction, int iColumn,
						   ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeAction != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeAction)));
#endif

	LPTSTR szValue = NULL;

	// get Value attribute 
	IntStringValue isValValue;
	isValValue.szVal = NULL;
	if (SUCCEEDED(hr = ProcessAttribute(pNodeAction, 
										rgXMSINodes[ACTION].szAttributeName,
							  		    STRING,
										&isValValue,
										pSkuSet)))
	{
		if (NULL == isValValue.szVal)
		{
			_tprintf(TEXT("Compile Error: Missing required attribute")
					 TEXT("\'%s\' of <%s>\n"), 
					 rgXMSINodes[ACTION].szNodeName,
					 rgXMSINodes[ACTION].szNodeName);
			hr = E_FAIL;
		}
		else
			szValue = isValValue.szVal;
	}

	// get the numeric value of Action column in DB
	if (SUCCEEDED(hr))
	{
		IntStringValue isVal;
		isVal.intVal = 0;

		if (0 == _tcscmp(szValue, TEXT("AddLine")))
		{
			isVal.intVal = msidbIniFileActionAddLine;
		}
		else if (0 == _tcscmp(szValue, TEXT("CreateLine")))
		{
			isVal.intVal = msidbIniFileActionCreateLine;
		}
		else if (0 == _tcscmp(szValue, TEXT("AddTag")))
		{
			isVal.intVal = msidbIniFileActionAddTag;
		}
		else
		{
			// error
			_tprintf(TEXT("Compile Error: <%s> has an unrecognized value %s ")
					 TEXT("in SKU "),
					 rgXMSINodes[ACTION].szNodeName, 
					 szValue);
			PrintSkuIDs(pSkuSet);
			hr = E_FAIL;
		}

		delete[] szValue;

		if (SUCCEEDED(hr))
			hr = pEE->SetValue(isVal, iColumn, pSkuSet);
	}

#ifdef DEBUG	
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ")
							 TEXT("ProcessAction\n"));
#endif

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessRemoveIniFile
//   This function:
//         1) Process all subentities of <RemoveIniFile> include <SourceName>, 
//			  <DestName>, <SourceFolder>, <DestFolder>, <CopyFile>;
//         2) Insert into the RemoveIniFile table;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessRemoveIniFile(PIXMLDOMNode &pNodeRemoveIniFile, 
						IntStringValue isValComponent, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeRemoveIniFile != NULL);

	SkuSet skuSetCommon(g_cSkus); // the SkuSet that shars the common column 
								  // values

	// Values to be inserted into the DB 
	LPTSTR szRemoveIniFile  = NULL;
	LPTSTR szFileName		= NULL;
	LPTSTR szDirProperty	= NULL;
	LPTSTR szSection		= NULL;
	LPTSTR szKey			= NULL;
	LPTSTR szValue			= NULL;
	UINT   uiAction			= MSI_NULL_INTEGER;
	LPTSTR szComponent_		= isValComponent.szVal;

	// create the File DB table
	hr = CreateTable_SKU(TEXT("RemoveIniFile"), pSkuSet);

	if (FAILED(hr))	return hr;

	// Construct an ElementEntry object. 
	ElementEntry *pEERemoveIniFile = new ElementEntry(6, pSkuSet);
	assert(pEERemoveIniFile);

	// Get ID attribute if there is one
	IntStringValue isValID;
	isValID.szVal = NULL;
	hr = ProcessAttribute(pNodeRemoveIniFile, TEXT("ID"), STRING, &isValID, pSkuSet);

	// if there is no ID specified, compiler generates one
	if (SUCCEEDED(hr))
	{
		if (!isValID.szVal)
		{
			isValID.szVal = GetName(TEXT("RemoveIniFile"));
#ifdef DEBUG
			_tprintf(TEXT("Processing <RemoveIniFile> with compiler generated ")
					 TEXT("primary key = %s\n"), isValID.szVal);
#endif
		}
		else
		{
#ifdef DEBUG
			_tprintf(TEXT("Processing <RemoveIniFile ID=\"%s\">\n"), isValID.szVal);
#else
		;
#endif
		}
		// at this point, a primary key should exist for this RemoveIniFile
		szRemoveIniFile = isValID.szVal;
		assert(szRemoveIniFile);

	}

	// Call ProcessChildrenArray to get back column values of all SKUs 
	// via the ElementEntry object
	if (SUCCEEDED(hr))
	{
		//because <Action> has a default value of msidbIniFileActionRemoveLine
		//set it for all SKUs in *pSkuSet 
		IntStringValue isValAction;
		isValAction.intVal = msidbIniFileActionRemoveLine;
		pEERemoveIniFile->SetNodeIndex(ACTION_REMOVEINIFILE, 5);
		pEERemoveIniFile->SetValType(INTEGER, 5);
		hr = pEERemoveIniFile->SetValueSplit(isValAction, 5, pSkuSet, NULL);

		if (SUCCEEDED(hr))
			hr = ProcessChildrenArray_H_XIES(pNodeRemoveIniFile, rgNodeFuncs_RemoveIniFile,
											 cNodeFuncs_RemoveIniFile, pEERemoveIniFile, 
											 pSkuSet);
	}
	
	// Finalize the values stored in *pEE
	if (SUCCEEDED(hr))
		hr = pEERemoveIniFile->Finalize();

	if (SUCCEEDED(hr))
	{
		// Process Common values first
		skuSetCommon = pEERemoveIniFile->GetCommonSkuSet();

		if (!skuSetCommon.testClear())
		{
			szFileName	   = pEERemoveIniFile->GetCommonValue(1).szVal;
			szDirProperty  = pEERemoveIniFile->GetCommonValue(2).szVal;
			szSection	   = pEERemoveIniFile->GetCommonValue(3).szVal;
			szKey		   = pEERemoveIniFile->GetCommonValue(4).szVal;
			szValue		   = pEERemoveIniFile->GetCommonValue(6).szVal;
			uiAction	   = pEERemoveIniFile->GetCommonValue(5).intVal;

			// insert into DB
			hr = InsertRemoveIniFile(szRemoveIniFile, szFileName, szDirProperty, 
							         szSection, szKey, szValue, uiAction, 
							         szComponent_, &skuSetCommon, -1);
		}
	}

	// process exceptional values
	if(SUCCEEDED(hr))
	{
		SkuSet skuSetUncommon = SkuSetMinus(*pSkuSet, skuSetCommon);
		if (!skuSetUncommon.testClear())
		{
			for (int i=0; i<g_cSkus; i++)
			{
				if (skuSetUncommon.test(i))
				{
					szFileName	   = pEERemoveIniFile->GetValue(1,i).szVal;
					szDirProperty  = pEERemoveIniFile->GetValue(2,i).szVal;
					szSection	   = pEERemoveIniFile->GetValue(3,i).szVal;
					szKey		   = pEERemoveIniFile->GetValue(4,i).szVal;
					szValue		   = pEERemoveIniFile->GetValue(6,i).szVal;
					uiAction	   = pEERemoveIniFile->GetValue(5,i).intVal;

					// insert into DB
					hr = InsertRemoveIniFile(szRemoveIniFile, szFileName, szDirProperty, 
										     szSection, szKey, szValue, uiAction, 
									         szComponent_, NULL, i);
				}
			}
		}
	}

	delete pEERemoveIniFile;

	if (szRemoveIniFile)
		delete[] szRemoveIniFile;


#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessRemoveIniFile\n"));
#endif

	return hr;
}


// Helper function: tells how to update an IntStringValue storing the value
// of the Action column of RemoveIniFile table. It sets the stored value to 
// be msidbIniFileActionRemoveTag
HRESULT UpdateRemoveIniFileAction(IntStringValue *pisValOut, IntStringValue isValOld, 
								  IntStringValue isValNew)
{
	pisValOut->intVal = isValNew.intVal;

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessValue
//   This function:
//         1) Process <Value> entity and set both the Value column and 
//	  the Action Column in the RemoveIniFile Table.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessValue(PIXMLDOMNode &pNodeValue, int iColumn,  
						ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeValue != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeValue)));
#endif
	
	// update Value column
	hr = ProcessSimpleElement(pNodeValue, iColumn, pEE, pSkuSet);

	// update Action column
	if (SUCCEEDED(hr))
	{
		IntStringValue isVal;
		isVal.intVal = msidbIniFileActionRemoveTag;
		hr = pEE->SetValueSplit(isVal, 5, pSkuSet, UpdateRemoveIniFileAction);
	}

#ifdef DEBUG	
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessValue\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessRegistry
//   This function process <Registry> entity:
//		(1) get Root, Key and pass to ProcessDelete, ProcessCreate
//		(2) for those SKUs that don't have <Delete> or <Create> specified,
//			insert into Registry table with Key and Root set to NULL
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessRegistry(PIXMLDOMNode &pNodeRegistry, 
						IntStringValue isValComponent, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeRegistry != NULL);
	int iRoot = MSI_NULL_INTEGER;
	LPTSTR szKey = NULL;
	LPTSTR szComponent_ = isValComponent.szVal;

	// get Root Attribute
	IntStringValue isValRoot;
	isValRoot.szVal = NULL;
	if (SUCCEEDED(hr = ProcessAttribute(pNodeRegistry, TEXT("Root"), STRING, 
										&isValRoot, pSkuSet)))
	{
		if (NULL == isValRoot.szVal)
			iRoot = -1; // default
		else if (0 == _tcscmp(isValRoot.szVal, TEXT("Default")))
			iRoot = -1;
		else if (0 == _tcscmp(isValRoot.szVal, TEXT("HKCR")))
			iRoot = msidbRegistryRootClassesRoot;
		else if (0 == _tcscmp(isValRoot.szVal, TEXT("HKCU")))
			iRoot = msidbRegistryRootCurrentUser;
		else if (0 == _tcscmp(isValRoot.szVal, TEXT("HKLM")))
			iRoot = msidbRegistryRootLocalMachine;
		else if (0 == _tcscmp(isValRoot.szVal, TEXT("HKU")))
			iRoot = msidbRegistryRootUsers;
		else 
		{
			_tprintf(TEXT("Compile Error: Unrecognized Root value %s ")
					 TEXT("attribute of <Registry> in SKU "),
					 isValRoot.szVal);
			PrintSkuIDs(pSkuSet);
			hr = E_FAIL;
		}
		
		if (isValRoot.szVal)
			delete[] isValRoot.szVal;
	}

	// get Key Attribute
	if (SUCCEEDED(hr))
	{
		IntStringValue isValKey;
		isValKey.szVal = NULL;
		if (SUCCEEDED(hr = ProcessAttribute(pNodeRegistry, TEXT("Key"),
											STRING, &isValKey, pSkuSet)))
		{
			if (NULL == isValKey.szVal)
			{
				_tprintf(TEXT("Compile Error: Missing required attribute")
						 TEXT("\'Key\' of <%s> in SKU \n"), 
						 rgXMSINodes[XMSI_REGISTRY].szNodeName);
				PrintSkuIDs(pSkuSet);
				hr = E_FAIL;
			}
			else
				szKey = isValKey.szVal;
		}
	}

	if (SUCCEEDED(hr))
	{
		// form the data structure to pass 3 values down to ProcessDelete
		// and ProcessCreate
		CompRootKey *pCompRootKey = new CompRootKey;
		assert(pCompRootKey);
		pCompRootKey->iRoot = iRoot;
		pCompRootKey->szComponent = szComponent_;
		pCompRootKey->szKey = szKey;

		IntStringValue isValCRK;
		isValCRK.pCompRootKey = pCompRootKey;

		// Process <Delete> column
		SkuSet skuSetCheckDelete(g_cSkus);
		hr = ProcessChildrenList_SKU(pNodeRegistry, XMSI_DELETE, false, isValCRK, 
									 ProcessDelete, pSkuSet,
									 &skuSetCheckDelete);
		// Process <Create> column
		SkuSet skuSetCheckCreate(g_cSkus);
		if (SUCCEEDED(hr))
			hr = ProcessChildrenList_SKU(pNodeRegistry, XMSI_CREATE, false, isValCRK,
										 ProcessCreate, pSkuSet, 
										 &skuSetCheckCreate);

		// if in some SKUs this <Registry> node has no children
		// insert into Create DB table with Name and Value column
		// set to NULL
		if (SUCCEEDED(hr))
		{
			skuSetCheckCreate &= skuSetCheckDelete;
			if (!skuSetCheckCreate.testClear())
			{
				hr = CreateTable_SKU(TEXT("Registry"), &skuSetCheckCreate);
				if (SUCCEEDED(hr))
				{
					LPTSTR szName = NULL;
					LPTSTR szValue = NULL;
					LPTSTR szRegistry = GetName(TEXT("Registry"));
					assert(szRegistry);
					
					hr = InsertRegistry(szRegistry, iRoot, szKey, szName, szValue, 
										szComponent_, &skuSetCheckCreate, -1);
				}
			}
		}
	}

	if (szKey)
		delete[] szKey;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessRegistry\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessDelete
//   This function process <Delete> entity:
//		(1) get Name column value and insert one row into RemoveRegistry table
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessDelete(PIXMLDOMNode &pNodeDelete, 
						IntStringValue isValCRK, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeDelete != NULL);

	// variables holding the values to be inserted into the DB
	LPTSTR szRemoveRegistry = NULL;
	int iRoot				= isValCRK.pCompRootKey->iRoot;
	LPTSTR szKey			= isValCRK.pCompRootKey->szKey;
	LPTSTR szName			= NULL;
	LPTSTR szComponent_		= isValCRK.pCompRootKey->szComponent;

	LPTSTR szType = NULL;

	// get ID Attribute if there is no ID specified, compiler generates one
	IntStringValue isValID;
	isValID.szVal = NULL;
	if (SUCCEEDED(hr = ProcessAttribute(pNodeDelete, TEXT("ID"), STRING, 
										&isValID, pSkuSet)))
	{
		if (!isValID.szVal)
			isValID.szVal = GetName(TEXT("RemoveRegistry"));

		// at this point, a primary key should exist for this RemoveRegistry
		szRemoveRegistry = isValID.szVal;
		assert(szRemoveRegistry);
	}
	
	// get Type and set Name accordingly
	if (SUCCEEDED(hr))
	{
		IntStringValue isValType;
		isValType.szVal = NULL;
		if (SUCCEEDED(hr = ProcessAttribute(pNodeDelete, TEXT("Type"),
											STRING, &isValType, pSkuSet)))
		{
			if (isValType.szVal && (0 == _tcscmp(isValType.szVal, TEXT("Key"))))
			{
				szName = _tcsdup(TEXT("-"));
				assert(szName);
			}
			else
			{
				// get Name attribute
				IntStringValue isValName;
				isValName.szVal = NULL;
				if (SUCCEEDED(hr = ProcessAttribute(pNodeDelete, TEXT("Name"),
													STRING, &isValName, pSkuSet)))
					szName = isValName.szVal;
			}
			if (isValType.szVal)
				delete[] isValType.szVal;
		}
	}

	if (SUCCEEDED(hr))
	{
		hr = CreateTable_SKU(TEXT("RemoveRegistry"), pSkuSet);
		if (SUCCEEDED(hr))
			hr = InsertRemoveRegistry(szRemoveRegistry, iRoot, szKey, szName,  
									  szComponent_, pSkuSet, -1);
	}

	if (szRemoveRegistry)
		delete[] szRemoveRegistry;

	if (szName)
		delete[] szName;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessDelete\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessCreate
//   This function process <Create> entity:
//		(1) get Name, Value column value and insert one row into Registry 
//			table;
//		(2) process KeyPath information;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessCreate(PIXMLDOMNode &pNodeCreate, 
						IntStringValue isValCRK, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeCreate != NULL);

	// variables holding the values to be inserted into the DB
	LPTSTR szRegistry	= NULL;
	int iRoot			= isValCRK.pCompRootKey->iRoot;
	LPTSTR szKey		= isValCRK.pCompRootKey->szKey;
	LPTSTR szName		= NULL;
	LPTSTR szValue		= NULL;
	LPTSTR szComponent_ = isValCRK.pCompRootKey->szComponent;

	LPTSTR szType = NULL;
	LPTSTR szKeyType = NULL;

	// get ID Attribute if there is no ID specified, compiler generates one
	IntStringValue isValID;
	isValID.szVal = NULL;
	if (SUCCEEDED(hr = ProcessAttribute(pNodeCreate, TEXT("ID"), STRING, 
										&isValID, pSkuSet)))
	{
		if (!isValID.szVal)
			isValID.szVal = GetName(TEXT("Registry"));

		// at this point, a primary key should exist for this Registry
		szRegistry = isValID.szVal;
		assert(szRegistry);
	}
	
	// get Type and set Name accordingly
	if (SUCCEEDED(hr))
	{
		IntStringValue isValType;
		isValType.szVal = NULL;
		if (SUCCEEDED(hr = ProcessAttribute(pNodeCreate, TEXT("Type"),
											STRING, &isValType, pSkuSet)))
		{
			if (isValType.szVal && (0 == _tcscmp(isValType.szVal, TEXT("Key"))))
			{
				// get KeyType and set Name accordingly
				IntStringValue isValKeyType;
				isValKeyType.szVal = NULL;
				if (SUCCEEDED(hr = ProcessAttribute(pNodeCreate, TEXT("KeyType"),
													STRING, &isValKeyType, pSkuSet)))
				{
					if (!isValKeyType.szVal)
					{
						szName = _tcsdup(TEXT("*"));
						assert(szName);
					}
					else
					{
						if (0 == _tcscmp(isValKeyType.szVal, TEXT("InstallUnInstall")))
						{
							szName = _tcsdup(TEXT("*"));
							assert(szName);
						}
						else if(0 == _tcscmp(isValKeyType.szVal, TEXT("InstallOnly")))
						{
							szName = _tcsdup(TEXT("+"));
							assert(szName);
						}
						else if(0 == _tcscmp(isValKeyType.szVal, TEXT("UnInstallOnly")))
						{
							szName = _tcsdup(TEXT("-"));
							assert(szName);
						}

						delete[] isValKeyType.szVal;
					}
				}
			}
			else
			{
				// get Name attribute
				IntStringValue isValName;
				isValName.szVal = NULL;
				if (SUCCEEDED(hr = ProcessAttribute(pNodeCreate, TEXT("Name"),
													STRING, &isValName, pSkuSet)))
					szName = isValName.szVal;

				// get Value attribute
				if (SUCCEEDED(hr))
				{
					IntStringValue isValValue;
					isValValue.szVal = NULL;
					if (SUCCEEDED(hr = ProcessAttribute(pNodeCreate, TEXT("Value"),
														STRING, &isValValue, pSkuSet)))
						szValue = isValValue.szVal;
				}

			}
			if (isValType.szVal)
				delete[] isValType.szVal;
		}
	}

	if (SUCCEEDED(hr))
	{
		hr = CreateTable_SKU(TEXT("Registry"), pSkuSet);
		if (SUCCEEDED(hr))
			hr = InsertRegistry(szRegistry, iRoot, szKey, szName, szValue,
								szComponent_, pSkuSet, -1);
	}

	// Process KeyPath attribute
	if (SUCCEEDED(hr))
		hr = ProcessKeyPath(pNodeCreate, szComponent_, szRegistry, pSkuSet);

	
	// Process children <LockPermission>s
	// Issue: need to ensure there is no duplicate primary key
	//		  LockOjbect + Table + Domain + User
	if (SUCCEEDED(hr))
	{
		IntStringValue isValLockPermission;
		TableLockObj *pTableLockObjTemp = new TableLockObj;
		pTableLockObjTemp->szLockObject = szRegistry;
		pTableLockObjTemp->szTable = TEXT("Registry");
		isValLockPermission.pTableLockObj = pTableLockObjTemp;
		hr = ProcessChildrenList_SKU(pNodeCreate, LOCKPERMISSION,
									false, isValLockPermission, 
									ProcessLockPermission, pSkuSet);
		delete pTableLockObjTemp;
	}

	if (szRegistry)
		delete[] szRegistry;

	if (szName)
		delete[] szName;

	if (szValue)
		delete[] szValue;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessCreate\n"));
#endif

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\mainfuncs.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       mainFuncs.cpp
//              This file contains the functions the main function and 
//				functions that process <Information> <Directories>
//				<InstallLevels> <Features> and their subentities in the 
//				input package
//--------------------------------------------------------------------------

#include "mainFuncs.h"

//////////////////////////////////////////////////////////////////////////
// Function: Main program entry point.
//       Return Value			Meaning
// ------------------------------------------------------------------------
//      ERROR_SUCCESS			Normal
//      ERROR_BAD_ARGUMENTS		Error during command line arg parsing                
//		ERROR_FILE_NOT_FOUND	Cannot find specified log file
//          -1					Other errors
//////////////////////////////////////////////////////////////////////////
int _cdecl 
_tmain(int argc, TCHAR *argv[])
{
	int errorCode = ERROR_SUCCESS;    
	HRESULT hr = S_OK;
	BSTR pBURL = NULL;       // the URL of the input WIML package 


	CommandOpt com_opt;

	// parse the command line options
	if (ERROR_SUCCESS != 
					(errorCode = com_opt.ParseCommandOptions(argc, argv)) )
		return errorCode;

	// Intialize global variables
	g_bValidationOnly = com_opt.GetValidationMode();
	g_bVerbose = com_opt.GetVerboseMode();
	g_pLogFile = com_opt.GetLogFile();
	g_szInputSkuFilter = com_opt.GetInputSkuFilter();

	if (NULL != (pBURL = LPTSTRToBSTR(com_opt.GetURL())) )
		hr = CoInitialize(NULL);
	else
	{
		_tprintf(TEXT("Internal Error. Failed to convert string")
				 TEXT("from LPSTSR to BSTR\n"));
		hr = E_FAIL;
	}

	if (SUCCEEDED(hr))
	{
	// Start processing the input package
		if (SUCCEEDED(hr = ProcessStart(pBURL)))
		{
			errorCode = CommitChanges();

#ifdef DEBUG 
	// print out the content of global data structures for debug purpose
	//PrintMap_DirRef(g_mapDirectoryRefs_SKU);
	//PrintMap_DirRef(g_mapInstallLevelRefs_SKU);
	//PrintMap_LC(g_mapComponents); 
#endif
		}

		// release the memory taken by the global data structures
		CleanUp();
		CoUninitialize();
	}

	if (pBURL)
		SysFreeString(pBURL);

	if (FAILED(hr))
		errorCode = -1;

	return errorCode;
}

////////////////////////////////////////////////////////////////////////////
// GeneratePackageCode: generate a GUID and insert into the database
////////////////////////////////////////////////////////////////////////////
HRESULT GeneratePackageCode(MSIHANDLE hSummaryInfo)
{
	HRESULT hr = S_OK;
	int errorCode = ERROR_SUCCESS;
	GUID GUID_PackageCode = GUID_NULL;

	if (SUCCEEDED(hr = CoCreateGuid(&GUID_PackageCode)))
	{
		LPTSTR szGUID = NULL;
		if (SUCCEEDED(hr = GUIDToLPTSTR(&GUID_PackageCode, szGUID)))
		{
			if (SUCCEEDED(hr = FormatGUID(szGUID)))
				if(ERROR_SUCCESS != (errorCode = 
					MsiSummaryInfoSetProperty(hSummaryInfo, PID_REVNUMBER,
												VT_LPSTR, 0, NULL, szGUID)))
				{
					PrintError(errorCode);
					hr = E_FAIL;
				}
		}
	}

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: GeneratePackageCode\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// CommitChanges: commit the changes made to the output MSI database
////////////////////////////////////////////////////////////////////////////
UINT CommitChanges()
{
	UINT errorCode = ERROR_SUCCESS;

	for (int i=0; i<g_cSkus; i++)
	{
		if (g_pskuSet->test(i))
		{
			// Commit summary infomation changes
			if (ERROR_SUCCESS == 
				(errorCode = 
						MsiSummaryInfoPersist(g_rgpSkus[i]->m_hSummaryInfo)))
			{
				// Commit database changes
				if (ERROR_SUCCESS != 
					(errorCode = MsiDatabaseCommit(g_rgpSkus[i]->m_hDatabase)))
					_tprintf(
						TEXT("Error: Failed to commit the database changes")
						TEXT(" for SKU %s\n"), g_rgpSkus[i]->GetID());
			}
			else
			{
				PrintError(errorCode);
				_tprintf(
					TEXT("Error: Failed to persist the summary info changes")
					TEXT(" for SKU %s\n"), g_rgpSkus[i]->GetID());
			}
		}
	}
	return errorCode;
}	

////////////////////////////////////////////////////////////////////////////
// ProcessStart: The compiling process starts here.
//				 This function:
//					1) call the MSXML parser to load the input WIML document;
//					2) obtaining the root node;
//					3) pass the root node to function ProcessProductFamily                  
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessStart(BSTR pBURL)
{
	HRESULT hr = S_OK;

	PIXMLDOMDocument2 pDoc = NULL;       // the document tree 
	PIXMLDOMElement pDocElement = NULL;  // the root element <ProductFamily> 
	PIXMLDOMNode pNodeProductFamily = NULL; // the root node <ProductFamily> 

	// create an empty XML document
	if (SUCCEEDED
		(hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, 
							   IID_IXMLDOMDocument, (void**)&pDoc)))
	{
		// load the XML document from specified file
		if (SUCCEEDED(hr = LoadDocumentSync(pDoc, pBURL)))
		{
			// get the root element <ProductFamily>
			if(SUCCEEDED(hr = pDoc->get_documentElement(&pDocElement)))
			{
				if (pDocElement == NULL)
				{
					_tprintf(TEXT("Compiler error: no root exists")
							 TEXT("in the input document\n"));
					hr = E_FAIL;
				}
				else  // get the root node <ProductFamily> 
					hr = pDocElement->QueryInterface(IID_IXMLDOMNode, 
											(void **)&pNodeProductFamily);
			}
		}
	}
	else	
		_tprintf(TEXT("Internal Error: Failed to create the interface")
				 TEXT("instance\n"));

	// call ProcessProductFamily to start the function tree processing
	if (SUCCEEDED(hr) && (pNodeProductFamily != NULL))
	{
		g_pNodeProductFamily = pNodeProductFamily;

		hr = ProcessProductFamily(pNodeProductFamily);
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessStart\n"));
#endif

  return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessProductFamily
//   This function is the root of the function tree. It gets the children
//   of <ProductFamily> and process them by calling their corresponding
//   tree process functions
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessProductFamily(PIXMLDOMNode &pNodeProductFamily)
{
	HRESULT hr = S_OK;

	PIXMLDOMNode pNode = NULL; 
	PIXMLDOMNode pNodeSkuManagement = NULL;
	PIXMLDOMNode pNodeModules = NULL;

	SkuSet *pskuSetInputSkuFilter = NULL;

	assert(pNodeProductFamily != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeProductFamily)));
#endif

	// Process <SkuManagement> 
	if(SUCCEEDED(hr = GetChildNode(pNodeProductFamily, 
								   rgXMSINodes[SKUMANAGEMENT].szNodeName, 
								   pNodeSkuManagement)))
	{
		if (pNodeSkuManagement == NULL) 
		{
			_tprintf(TEXT("Compile Error: Missing required entity <%s>.\n"),
								rgXMSINodes[SKUMANAGEMENT].szNodeName);
			hr = E_FAIL;
		}
		else
		{
			hr = ProcessSkuManagement(pNodeSkuManagement);
		}
	}

	// Process the Sku Filter specified from command line
	hr = ProcessSkuFilter(g_szInputSkuFilter, &pskuSetInputSkuFilter);

#ifdef DEBUG
	if (SUCCEEDED(hr))
	{
		_tprintf(TEXT("The Command Line Sku Filter:\n"));
		pskuSetInputSkuFilter->print();
		_tprintf(TEXT("\n"));
	}
#endif
	
	// Process <Information> <Directories> <InstallLevels> <Features>
	if (SUCCEEDED(hr))
	{
		assert(pskuSetInputSkuFilter != NULL);
		g_pskuSet = new SkuSet(*pskuSetInputSkuFilter);
		assert(g_pskuSet != NULL);

		hr = ProcessChildrenArray_H_XIS(pNodeProductFamily, 
									rgNodeFuncs_ProductFamily_SKU,
									cNodeFuncs_ProductFamily_SKU,
									NULL, pskuSetInputSkuFilter);
	}

	if (pskuSetInputSkuFilter)
		delete pskuSetInputSkuFilter;

	// at this point, a component list has been established
	// process them
	if (SUCCEEDED(hr))
		hr = ProcessComponents();

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessProductFamily\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessSkuManagement
//   This function processes <SkuManagement> node and its children:
//		<SKUs> and <SkuGroups>
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessSkuManagement(PIXMLDOMNode &pNodeSkuManagement)
{
	HRESULT hr = S_OK;
	PIXMLDOMNode pNodeSkus = NULL;
	PIXMLDOMNode pNodeSkuGroups = NULL;
	int cSkus = 0;  // # Skus defined in the input package. This will be the
					// length of each SkuSet

	assert(pNodeSkuManagement != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeSkuManagement)));
#endif

	// (1) Process <SKUs> tag
	if(SUCCEEDED(hr = GetChildNode(pNodeSkuManagement, 
						rgXMSINodes[SKUS].szNodeName, pNodeSkus)))
	{
		if (pNodeSkus == NULL) 
		{
			_tprintf(TEXT("Compile Error: Missing required entity <%s>.\n"),
								rgXMSINodes[SKUS].szNodeName);
			hr = E_FAIL;
		}
		else
		{
			hr = ProcessSkus(pNodeSkus, &cSkus);
		}
	}

	// (2) Process <SkuGroups> tag
	if(SUCCEEDED(hr = GetChildNode(pNodeSkuManagement, 
						rgXMSINodes[SKUGROUPS].szNodeName, pNodeSkuGroups)))
	{
		if (pNodeSkuGroups != NULL) 
			hr = ProcessSkuGroups(pNodeSkuGroups, cSkus);
	}


#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessSkuManagement\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessSkus
//   This function processes <SKUs> tag:
//		1) Process each defined <SKU> tag and create a Sku object for
///			each one of them.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessSkus(PIXMLDOMNode &pNodeSkus, int *pcSkus)
{
	HRESULT hr = S_OK;
	PIXMLDOMNodeList pNodeListSkus = NULL;

	assert(pNodeSkus != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeSkus)));
#endif

	// get the list of <SKU>s
	if (SUCCEEDED(hr = GetChildrenNodes(pNodeSkus,
								rgXMSINodes[SKU].szNodeName,
								pNodeListSkus)))
	{
		if (SUCCEEDED(hr = pNodeListSkus->get_length((long *)pcSkus)))
		{
			if (0 == *pcSkus)
			{
			   _tprintf(TEXT("Compile Error: Missing required entity <%s>.\n"),
								rgXMSINodes[SKU].szNodeName);

				hr = E_FAIL;
			}
			else // Allocate memory for the global Skus array 
			{
				g_cSkus = *pcSkus;
				g_rgpSkus = new Sku*[*pcSkus];
				for (int i=0; i<g_cSkus; i++)
					g_rgpSkus[i] = NULL;
			}

		}
	}

	// Process all Children <SKU>s
	if (SUCCEEDED(hr))
	{
		for (long i=0; i<*pcSkus; i++)
		{
			PIXMLDOMNode pNodeSku = NULL;
			// get the node
			if (SUCCEEDED(hr = pNodeListSkus->get_item(i, &pNodeSku)))
			{
				if (pNodeSku != NULL)
					hr = ProcessSku(pNodeSku, i, *pcSkus);
				if (FAILED(hr))
					break;
			}
			else
			{
				_tprintf(TEXT("Internal Error: Failed to make ")
						 TEXT("DOM API call: get_item\n"));
				break;
			}
		}
	}

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessSkus\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessSku
//   This function processes <SKU> tag:
//		1) construct a SkuSet object and insert into global map
//			(a SKU is a SkuGroup of just one element)
//		2) Update the global SKU array;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessSku(PIXMLDOMNode &pNodeSku, int iIndex, int cSkus)
{			
	HRESULT hr = S_OK;
	LPTSTR szID = NULL; // ID of a SKU

	assert(pNodeSku != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeSku)));
#endif

	// get ID attribute and assign to szID
	if(SUCCEEDED(hr = GetID(pNodeSku, szID))) 
	{
		if (NULL == szID)
		{
			_tprintf(
			TEXT("Compile Error: Missing required attribute \'ID\' on <%s>\n"),
				rgXMSINodes[SKU].szNodeName);
			hr = E_FAIL;
		}
	}

	// construct a SkuSet object and insert into global map
	if (SUCCEEDED(hr))
	{
		SkuSet *pSkuSet = new SkuSet(cSkus);
		if (pSkuSet == NULL)
		{
			_tprintf(TEXT("Internal Error: Failed to create a new")
					 TEXT("SkuSet object\n"));
			hr = E_FAIL;
		}
		else 
		{
			pSkuSet->set(iIndex);// ith bit in the bit field represent this SKU
			assert(0 == g_mapSkuSets.count(szID)); // IDs shouldn't duplicate
			g_mapSkuSets.insert(LS_ValType(szID, pSkuSet));
		}
	}

	// reserve the spot in the global SKU array
	if (SUCCEEDED(hr))
	{
		g_rgpSkus[iIndex] = new Sku(szID);
	}


#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessSku\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessSkuGroups
//   This function processes <SkuGroups> tag:
//		1) Process each defined <SkuGroup> tag and create a SkuSet object for
//			each one of them.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessSkuGroups(PIXMLDOMNode &pNodeSkuGroups, int cSkus)
{
	HRESULT hr = S_OK;
	long iListLength = 0;
	PIXMLDOMNodeList pNodeListSkuGroups = NULL;

	assert(pNodeSkuGroups != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeSkuGroups)));
#endif

	// get the list of <SkuGroup>s
	if (SUCCEEDED(hr = GetChildrenNodes(pNodeSkuGroups,
								rgXMSINodes[SKUGROUP].szNodeName,
								pNodeListSkuGroups)))
	{
		if (SUCCEEDED(hr = pNodeListSkuGroups->get_length(&iListLength)))
		{
			// Process all Children <SkuGroup>s
			for (long i=0; i<iListLength; i++)
			{
				PIXMLDOMNode pNodeSkuGroup = NULL;
				// get the node
				if (SUCCEEDED
					(hr = pNodeListSkuGroups->get_item(i, &pNodeSkuGroup)))
				{
					if (pNodeSkuGroup != NULL)
					{
						// get ID attribute
						LPTSTR szID = NULL; 
						if(FAILED(hr = GetID(pNodeSkuGroup, szID)))
							break;							
						if (NULL == szID)
						{
							_tprintf(
							TEXT("Compile Error: Missing required ")
							TEXT("attribute \'ID\' on <%s>\n"),
								rgXMSINodes[SKUGROUP].szNodeName);
							hr = E_FAIL;
							break;
						}

						// It is possible that this SkuGroup is referenced
						// from inside other SkuGroups and thus has already
						// been processed. So only process it if it hasn't
						// been processed.
						if (0 == g_mapSkuSets.count(szID))
						{
							// set is used to detect circular references
							set<LPTSTR, Cstring_less> *pSet 
								= new set<LPTSTR, Cstring_less>;

							hr = ProcessSkuGroup(pNodeSkuGroup, szID, 
															pSet, cSkus);

							delete pSet;
						}
					}
					if (FAILED(hr))
						break;
				}
				else
				{
					_tprintf(TEXT("Internal Error: Failed to make ")
							 TEXT("DOM API call: get_item\n"));
					break;
				}
			}
		}
		else
		{
			_tprintf(TEXT("Internal Error: Failed to make ")
					 TEXT("DOM API call: get_length\n"));
		}
	}

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessSkuGroups\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessSkuGroup
//   This recursive function processes <SkuGroup> tag:
//		1) construct a SkuSet object and insert into global map
//			(a SKU is a SkuGroup of just one element)
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessSkuGroup(PIXMLDOMNode &pNodeSkuGroup, LPTSTR szID,
						set<LPTSTR, Cstring_less> *pSet, int cSkus)
{			
	HRESULT hr = S_OK;
	long iListLength = 0;
	PIXMLDOMNodeList pNodeListSkuGroups = NULL;

	assert(pNodeSkuGroup != NULL);

#ifdef DEBUG
	_tprintf(TEXT("Processing <SkuGroup> ID = %s\n"), szID);
#endif

	pSet->insert(szID); // mark that this SkuGroup is being processed

	SkuSet *pSkuSet = new SkuSet(cSkus);

	// construct a SkuSet object for this SkuGroup
	if (SUCCEEDED(hr))
	{
		if (pSkuSet == NULL)
		{
			_tprintf(TEXT("Internal Error: Failed to create")
					 TEXT("a new SkuSet object\n"));
			hr = E_FAIL;
		}
	}

	// Get the list of children <SkuGroup>s
	if (SUCCEEDED(hr))
	{
		if (SUCCEEDED(hr = GetChildrenNodes(pNodeSkuGroup,
									rgXMSINodes[SKUGROUP].szNodeName,
									pNodeListSkuGroups)))
		{
			if(FAILED(hr = pNodeListSkuGroups->get_length(&iListLength)))      
				_tprintf(TEXT("Internal Error: Failed to make ")
						 TEXT("DOM API call: get_length\n"));
		}
	}

	// recursively process all the children <SkuGroup>
	if (SUCCEEDED(hr))
	{
		// Process all Children <SkuGroup>s
		for (long i=0; i<iListLength; i++)
		{
			PIXMLDOMNode pNodeChild = NULL;
			// get the node
			if (SUCCEEDED
				(hr = pNodeListSkuGroups->get_item(i, &pNodeChild)))
			{
				if (pNodeChild != NULL)
				{
					// get ID attribute
					LPTSTR szChildID = NULL; 
					if(FAILED(hr = GetID(pNodeChild, szChildID)))
						break;							
					if (NULL == szChildID)
					{
						_tprintf(
							TEXT("Compile Error: Missing required ")
							TEXT("attribute \'ID\' on <%s>\n"),
								rgXMSINodes[SKUGROUP].szNodeName);
						hr = E_FAIL;
						break;
					}
					
					// Process this child <SkuGroup> if it hasn't been
					//	processed
					if (0 == g_mapSkuSets.count(szChildID))
					{
						if (FAILED(hr = ProcessSkuGroup(pNodeChild, 
												szChildID, pSet, cSkus)))
							break;
						assert(0 != g_mapSkuSets.count(szChildID));
						*pSkuSet |= *(g_mapSkuSets[szChildID]);
					}
					else
					{
						*pSkuSet |= *(g_mapSkuSets[szChildID]);
						delete[] szChildID;
					}
				}
			}
			else
			{
				_tprintf(TEXT("Internal Error: Failed to make ")
						 TEXT("DOM API call: get_item\n"));
				break;
			}
		}
	}

	// Process the "SKUs" attribute of this <SkuGroup>
	if (SUCCEEDED(hr))
	{
		LPTSTR szSKUs = NULL;
		IntStringValue isValSKUs;
		int i=0;
		if (SUCCEEDED(hr = ProcessAttribute(pNodeSkuGroup, TEXT("SKUs"), STRING, 
											&isValSKUs, NULL)))
		{
			// "SKUs" attribute exists
			if (S_FALSE != hr)
			{
				szSKUs = isValSKUs.szVal;
				TCHAR *ptch1 = szSKUs;
				TCHAR *ptch2 = NULL;

				// Process all the SKUGroup members
				while (true)
				{
					// (1) parse the string containing all members
					// skip white spaces at the head
					while(_istspace(*ptch1)) ptch1++;					
					if (TEXT('\0') == *ptch1) break;
					ptch2 = ptch1;
					// search for the end of this SkuGroup member
					while(!_istspace(*ptch2) && *ptch2 != TEXT('\0')) 
						ptch2++;
					int iLength = ptch2-ptch1+1;
					LPTSTR szSkuGroupMember = new TCHAR[iLength];
					for (int j=0; j<iLength-1; j++)
						szSkuGroupMember[j] = *ptch1++;
					szSkuGroupMember[iLength-1] = TEXT('\0');

					// (2) check for circular reference
					if (0 != pSet->count(szSkuGroupMember))
					{
					  _tprintf(TEXT("Compile Error: Circular Reference: %s\n")
					TEXT(" in the declaration of <SkuGroup ID=\"%s\">\n"),
						  szSkuGroupMember, szID);
					  hr = E_FAIL;
					  break;
					}

					// (3) Process this member if it hasn't been
					//	    processed
					if (0 == g_mapSkuSets.count(szSkuGroupMember))
					{
						// Form the XPath query:  
						//		/SkuGroup[ @ID = "szSkuGroupMember"]
						int iLength = _tcslen(szSkuGroupMember);
						LPTSTR szXPath = new TCHAR[iLength+61];
						if (!szXPath)
						{
							_tprintf(TEXT("Error: Out of memory\n"));
							hr = E_FAIL;
							break;
						}

						_stprintf(szXPath, 
		TEXT("/ProductFamily/SkuManagement/SkuGroups//SkuGroup[ @ID = \"%s\"]"),
										szSkuGroupMember);
						
						BSTR bstrXPath = NULL;

						if (NULL == (bstrXPath = LPTSTRToBSTR(szXPath)))
						{
						   _tprintf(TEXT("Error: String conversion failed\n"));
							hr = E_FAIL;
							break;
						}
						// get the <SkuGroup> node with ID=szSkuGroupMember 
						// and pass it to ProcessSkuGroup
						PIXMLDOMNode pNodeChild = NULL;
						if(SUCCEEDED(hr = 
							pNodeSkuGroup->selectSingleNode
											(bstrXPath, &pNodeChild)))
						{
							assert(pNodeChild != NULL);
							if(FAILED
								(hr = ProcessSkuGroup(pNodeChild, 
											szSkuGroupMember, pSet, cSkus)))
								break;
						}
						else
						{
							_tprintf(TEXT("Internal Error: Failed to make ")
									 TEXT("DOM API call: get_item\n"));
							SysFreeString(bstrXPath);
							break;
						}
						SysFreeString(bstrXPath);
						// Now this member is processed and is in the 
						// global map
						assert(0 != g_mapSkuSets.count(szSkuGroupMember));
						*pSkuSet |= *(g_mapSkuSets[szSkuGroupMember]);
					}
					else
					{
						*pSkuSet |= *(g_mapSkuSets[szSkuGroupMember]);
						delete[] szSkuGroupMember;
					}

					if (TEXT('\0') == *ptch2) break;
				}

				delete[] szSKUs;
			}
		}
	}

	// insert this SkuGroup into the global map
	if (SUCCEEDED(hr))
		g_mapSkuSets.insert(LS_ValType(szID, pSkuSet));


	if (FAILED(hr)) 
	{
		if (pSkuSet)
			delete pSkuSet;
		if (szID)
			delete szID;
#ifdef DEBUG
		_tprintf(TEXT("Error in function: ProcessSku\n"));
#endif
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessInformation
//   This function processes <Information> node:
//         1) create the output database;
///		   2) create the Property Table and write several properties into it;
//         3) write several properties into the summary information stream;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessInformation_SKU(PIXMLDOMNode &pNodeInformation, 
						   const IntStringValue *isVal_In, SkuSet *pskuSet)
{
	HRESULT hr = S_OK;
	UINT iWordCount = 0;
	PIXMLDOMNode pNode = NULL; 

	assert(pNodeInformation != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeInformation)));
#endif

	// Process <InstallerVersionRequired> and <PackageFileName>
	hr = ProcessChildrenArray_H_XIS(pNodeInformation, 
								   rgNodeFuncs_Information_SKU,
								   cNodeFuncs_Information_SKU, 
								   NULL, pskuSet);


	// process nodes in rgChildren_Information: <ProductName> <ProductCode>
	//	<UpgradeCode> <ProductVersion> <Manufacturer> <Keywords> <Template>
	if (SUCCEEDED(hr))
	{
		hr = ProcessChildrenArray_H_XIS(pNodeInformation, 
									   rgNodeFuncs_Information2_SKU,
									   cNodeFuncs_Information2_SKU, 
								       NULL, pskuSet);
	}

	if (SUCCEEDED(hr))
	{
		ElementEntry *pEEWordCount = new ElementEntry(1, pskuSet);
		pEEWordCount->SetValType(INTEGER, 1);
		if (SUCCEEDED(hr = 
						ProcessOnOffAttributes_SKU(pNodeInformation, 
												   rgAttrBits_WordCount,
												   cAttrBits_WordCount, 
												   pEEWordCount, 1, pskuSet)))
		{
			pEEWordCount->Finalize();

			SkuSet skuSetCommon = pEEWordCount->GetCommonSkuSet();
			SkuSet skuSetUncommon = SkuSetMinus(*pskuSet, skuSetCommon);
			int iCommon = pEEWordCount->GetCommonValue(1).intVal;

			// process Common values
			if (!skuSetCommon.testClear())
			{
				for (int i=0; i<g_cSkus; i++)
				{
					if (skuSetCommon.test(i))
					{
					//	printf("%s: %d\n", g_rgpSkus[i]->GetID(), iCommon);
						if (FAILED(hr = 
									MsiSummaryInfoSetProperty(
												g_rgpSkus[i]->m_hSummaryInfo,
												PID_WORDCOUNT, VT_I4, iCommon,
												NULL, NULL)))
						{
							_tprintf(TEXT("Error: Failed to insert WordCount")
									 TEXT(" Property into the Summary ")
									 TEXT("information stream for SKU\n;"),
									g_rgpSkus[i]->GetID());
							break;
						}
					}
				}
			}

			// process uncommon values
			if (!skuSetUncommon.testClear())
			{
				for (int i=0; i<g_cSkus; i++)
				{
					if (skuSetUncommon.test(i))
					{
						int iWordCount = pEEWordCount->GetValue(1, i).intVal;

					//	printf("%s: %d\n", g_rgpSkus[i]->GetID(), iWordCount);
						if (FAILED(hr = 
									MsiSummaryInfoSetProperty(
												g_rgpSkus[i]->m_hSummaryInfo,
												PID_WORDCOUNT, VT_I4,
												iWordCount, NULL, NULL)))
						{
							_tprintf(TEXT("Error: Failed to insert WordCount")
									 TEXT("Property into the Summary")
									 TEXT("information stream for SKU\n;"),
									 g_rgpSkus[i]->GetID());
							break;
						}
					}
				}
			}
				
		}

		delete pEEWordCount;
	}
		
#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessInformation_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessInstallerVersionRequired
//   This function processes <InstallerVersionRequired> node:
//         1) Choose a proper template MSI file to read in database schema
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessInstallerVersionRequired_SKU
		(PIXMLDOMNode &pNodeInstallerVersionRequired, 
						   const IntStringValue *isVal_In, SkuSet *pskuSet)
{
	HRESULT hr = S_OK;
	IntStringValue isValInstallerVersion;
	isValInstallerVersion.intVal = 120; // the default value

	assert(pNodeInstallerVersionRequired != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeInstallerVersionRequired)));
#endif

	// Get the Value of the required Windows Installer Version
	if (SUCCEEDED(hr = ProcessAttribute(pNodeInstallerVersionRequired, 
						rgXMSINodes[INSTALLERVERSIONREQUIRED].szAttributeName,
							INTEGER, &isValInstallerVersion, pskuSet)))
	{
		if (isValInstallerVersion.intVal <= 120)
		{
		// open the template database which is used to read in the database 
		//	schema for each SKU
			for (int i=0; i<g_cSkus; i++)
			{
				if (pskuSet->test(i))
				{
					if (ERROR_SUCCESS != MsiOpenDatabase
			   (TEXT("Schema.msi"),
								MSIDBOPEN_READONLY, 
								&g_rgpSkus[i]->m_hTemplate))
					{
						_tprintf(
							TEXT("Error: Failed to open the template ")
							TEXT("database for SKU: %s\n"), 
								g_rgpSkus[i]->GetID());
						hr = E_FAIL;
						break;
					}
				}
			}
		}	
		else 
		{
			// Issue: need to add more templates corresponding to different
			//	MSI version
			_tprintf(TEXT("Error: Invalid value of")
					 TEXT("<InstallerVersionRequired>: %d\n"),
					 isValInstallerVersion.intVal);
			hr = E_FAIL;
		}
	}

#ifdef DEBUG
	if (FAILED(hr))	
	   _tprintf(TEXT("Error in function: ")
				TEXT("ProcessInstallerVersionRequired_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessPackageFileName
//   This function processes <PackageFileName> node:
//         1) Use the specified pathname to open the output MSI database
//            and obtain the handle;
//		   2) Use the database handle to obtain the handle to the summary info
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessPackageFilename_SKU(PIXMLDOMNode &pNodePackageFilename, 
								   const IntStringValue *isVal_In, 
								   SkuSet *pskuSet)
{
	HRESULT hr = S_OK;
	IntStringValue isValPackageName;

	UINT errorCode = ERROR_SUCCESS;

	assert(pNodePackageFilename != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodePackageFilename)));
#endif

	pskuSet->print();

	// get the specified output package name
	if (SUCCEEDED(hr = ProcessAttribute(pNodePackageFilename, 
								rgXMSINodes[PACKAGEFILENAME].szAttributeName,
								STRING, &isValPackageName, pskuSet)))
	{
		// open the output DB for each SKU
		for (int i=0; i<g_cSkus; i++)
		{
			if (pskuSet->test(i))
			{
				printf("%s\n", isValPackageName.szVal);
				// get the database handle
				if (ERROR_SUCCESS != 
						(errorCode = MsiOpenDatabase(isValPackageName.szVal, 
						  							 MSIDBOPEN_CREATE,
												&g_rgpSkus[i]->m_hDatabase)))
				{
					PrintError(errorCode);
					_tprintf(TEXT("Error: Failed to create a new database ")
							 TEXT("for SKU %s\n"), g_rgpSkus[i]->GetID());
					hr = E_FAIL;
					break;
				}

				// get the Summary Infomation handle
				if (ERROR_SUCCESS != MsiGetSummaryInformation
											(g_rgpSkus[i]->m_hDatabase, 0, 50,
											&g_rgpSkus[i]->m_hSummaryInfo))
				{
					_tprintf(TEXT("Error: Failed to get the summary ")
							TEXT("information handle for SKU %s\n"),
							g_rgpSkus[i]->GetID());
					hr = E_FAIL;
					break;
				}
				
				// Auto-generate a package code for this SKU
				if (FAILED(hr = 
					GeneratePackageCode(g_rgpSkus[i]->m_hSummaryInfo)))
				{
					_tprintf(TEXT("Error: Failed to generate PackageCode")
						 TEXT(" for SKU %s\n"), g_rgpSkus[i]->GetID());
					break;
				}				
			}
		}

		delete[] isValPackageName.szVal;
	}

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessPackageFilename_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessInformationChildren
//   This function processes the following children of <Information>:
//	  <Codepage> <ProductName> <ProductCode> <UpgradeCode> <ProductVersion> 
//	  <Keywords> <Template>.
//
// After the desired value is retrieved, the compiler will insert the value
// into Property table, SummaryInfo, or both     
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessInformationChildren_SKU(PIXMLDOMNode &pNodeInfoChild, 
									   const IntStringValue *pisVal_In, 
									   SkuSet *pskuSet)
{
	HRESULT hr = S_OK;
	int i = pisVal_In->intVal;

	// get the information needed from global array
    LPTSTR szAttributeName = 
		rgXMSINodes[rgChildren_Information[i].enumNodeIndex].szAttributeName;
    LPTSTR szPropertyName = rgChildren_Information[i].szPropertyName;
    INFODESTINATION enumDestination = 
		rgChildren_Information[i].enumDestination;
    UINT uiPropertyID = rgChildren_Information[i].uiPropertyID;
	VARTYPE vt = rgChildren_Information[i].vt;
	bool bIsGUID = rgChildren_Information[i].bIsGUID;

	IntStringValue isVal;

	assert(pNodeInfoChild != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeInfoChild)));
#endif


	// create Property table for those SKUs that haven't had one
	hr = CreateTable_SKU(TEXT("Property"), pskuSet);

	if (SUCCEEDED(hr))
	{
		if (SUCCEEDED(hr = ProcessAttribute(pNodeInfoChild, 
							szAttributeName, STRING, &isVal, pskuSet)))
		{	
			// if this is a GUID, needs format it: convert to upper case 
			// and surround it with { }
			if (bIsGUID)						
				hr = FormatGUID(isVal.szVal);
				
			if (SUCCEEDED(hr))
			{
				// insert into Property table
				if ((PROPERTY_TABLE == enumDestination) || 
									(BOTH == enumDestination))
				{
					hr = InsertProperty(szPropertyName, isVal.szVal, pskuSet, 
										/*iSkuIndex*/-1);
				}
	
				//insert into Summary Info
				if (SUCCEEDED(hr))
				{
					if ((SUMMARY_INFO == enumDestination) || 
										(BOTH == enumDestination))
					{
						int iVal = _ttoi(isVal.szVal);
						for (int i=0; i<g_cSkus; i++)
						{
							if (pskuSet->test(i))
							{
								switch (vt) {
									case VT_I2:
									case VT_I4:
									{
										if (ERROR_SUCCESS != 
												MsiSummaryInfoSetProperty(
												  g_rgpSkus[i]->m_hSummaryInfo,
												  uiPropertyID, vt, iVal, 
												  NULL, NULL))
										{
											_tprintf(
												TEXT("Error: Failed to insert")
												TEXT("%s into Summary Info ")
												TEXT("for SKU %s\n"), 
												szPropertyName,
												g_rgpSkus[i]->GetID());
											hr = E_FAIL;							
										}
										break;
									}
									case VT_FILETIME:
										//do nothing yet
										break;
									case VT_LPSTR:
									{
										if (ERROR_SUCCESS != 
												MsiSummaryInfoSetProperty(
												  g_rgpSkus[i]->m_hSummaryInfo,
												  uiPropertyID, vt, 0, NULL, 
												  isVal.szVal))
										{
											_tprintf(
												TEXT("Error: Failed to insert")
												TEXT("%s into Summary Info")
												TEXT(" for SKU %s\n"), 
												szPropertyName,
												g_rgpSkus[i]->GetID());
											hr = E_FAIL;																						
										}
										break;
									}
									default:
										assert(true);
								}
							}

							if (FAILED(hr))
								break;
						}
					}
				}
			}
			delete[] isVal.szVal;
		}
	}
	
#ifdef DEBUG
	if (FAILED(hr))	
		_tprintf(TEXT("Error in function: ProcessInformationChildren_SKU\n"));
#endif

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessDirectories
//   This function processes <Directories> node:
//         1) Create Directory Table;
///		   2) Insert "TARGETDIR", NULL, "SourceDir" into the first row of the 
//			  Directory table
//         3) Process its children <Diretory> nodes and insert into the table
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessDirectories_SKU(PIXMLDOMNode &pNodeDirectories, 
							   const IntStringValue *pIsVal, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeDirectories != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeDirectories)));
#endif

	// create Directory table for those SKUs that haven't had one
	hr = CreateTable_SKU(TEXT("Directory"), pSkuSet);

	if (SUCCEEDED(hr))
	{
		if (SUCCEEDED(hr = InsertDirectory(TEXT("TARGETDIR"), NULL, 
										TEXT("SourceDir"), pSkuSet, 
										/*iSkuIndex*/-1)))
		{
			IntStringValue isValParentDir;
			isValParentDir.szVal = TEXT("TARGETDIR");
			hr = ProcessChildrenList_SKU(pNodeDirectories, DIRECTORY,
										 /*bIsRequired*/false, isValParentDir,
										 ProcessDirectory_SKU,
										 pSkuSet); 
		}
	}

	PrintMap_DirRef(g_mapDirectoryRefs_SKU);

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessDirectories\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// a set of small help functions so that ProcessDirectory won't grow too big!

// return E_FAIL if <TargetProperty> and <TargetDir> coexists
HRESULT CheckTargetDir_TargetProperty(LPCTSTR szTargetProperty, 
									  LPCTSTR szDefaultDir,
									  SkuSet *pSkuSet,
									  int iSkuIndex)
{
	assert(szDefaultDir);

	HRESULT hr = S_OK;

	if (_tcschr(szDefaultDir, TEXT(':'))/* <TargetDir> exists */ &&
		szTargetProperty/*<TargetProptery> exists*/)
	{
		_tprintf(TEXT("Compile error: <%s> and <%s> coexists for SKU: \n"),
				 rgXMSINodes[TARGETDIR].szNodeName, 
				 rgXMSINodes[TARGETPROPERTY].szNodeName);
		if (pSkuSet)
			PrintSkuIDs(pSkuSet);
		else
		{
			assert(iSkuIndex>=0 && iSkuIndex<g_cSkus);
			_tprintf(TEXT("%s\n"), g_rgpSkus[iSkuIndex]->GetID());
		}

		hr = E_FAIL;
	}

	return hr;
}

// Return the value of primary key (Directory column)
void GetPrimaryKey(LPTSTR *pszDirectory, LPCTSTR szID)
{
	if (*pszDirectory)
	{
		// make a copy so that the value won't be destroyed after
		// deleting the ElementEntry object
		*pszDirectory = _tcsdup(*pszDirectory);
		return;
	}

	if (szID)
	{
		*pszDirectory = _tcsdup(szID);
		assert(*pszDirectory);
	}
	else
	{
		*pszDirectory = GetName(TEXT("Directory"));
		assert(*pszDirectory);
	}
}

// insert the directory reference into global data structure
void InsertDirRef(LPTSTR szID, LPTSTR szDirectory, SkuSet *pSkuSet, 
				  int iSkuIndex)
{
	if (!szID) return;

	IntStringValue isValDirectory;
	isValDirectory.szVal = szDirectory;

	// construct a SkuSetValues object if there isn't one
	// in the slot corresponding to szID
	if (!g_mapDirectoryRefs_SKU.count(szID))
	{
		SkuSetValues *pSkuSetValues = new SkuSetValues;
		assert(pSkuSetValues);
		pSkuSetValues->SetValType(STRING);
		g_mapDirectoryRefs_SKU.insert
			(map<LPTSTR, SkuSetValues *, Cstring_less>::value_type
				(szID, pSkuSetValues));							
	}

	// insert the directory reference together with its
	// associated SkuSet into the global data structure
	SkuSet *pSkuSetTemp = new SkuSet(g_cSkus);
	assert(pSkuSetTemp);
	if (pSkuSet)
		*pSkuSetTemp = *pSkuSet;
	else
	{
		assert(iSkuIndex>=0 && iSkuIndex<g_cSkus);
		pSkuSetTemp->set(iSkuIndex);
	}
	g_mapDirectoryRefs_SKU[szID]->CollapseInsert(pSkuSetTemp, 
												 isValDirectory, false);
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessDirectory
//   This is a recursive function.
//         1) Process the current <Diretory> node and insert info into the 
//			  Directory table;
//         2) Call itself to process its children <Directory> nodes;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessDirectory_SKU(PIXMLDOMNode &pNodeDirectory, 
							 IntStringValue isValParentDir, 
							 SkuSet *pSkuSet)
{
	assert(pNodeDirectory != NULL);

	HRESULT hr = S_OK;

	SkuSet skuSetCommon(g_cSkus);
	LPTSTR szDirectoryCommon = NULL;

	// Construct an ElementEntry object. 
	ElementEntry *pEEDirectory = new ElementEntry(2, pSkuSet);
	assert(pEEDirectory);

	// Get ID attribute if there is one
	IntStringValue isValID;
	isValID.szVal = NULL;
	hr = ProcessAttribute(pNodeDirectory,
						rgXMSINodes[DIRECTORY].szAttributeName, STRING, 
						&isValID, pSkuSet);

#ifdef DEBUG
	if (isValID.szVal)
		_tprintf(TEXT("Processing <Directory ID=\"%s\">\n"), isValID.szVal);
	else
		_tprintf(TEXT("Processing <Directory> without ID specified\n"));
#endif

	if (SUCCEEDED(hr))
	{
		// Call ProcessChildrenArray to get back column values of all SKUs 
		// via the ElementEntry object
		hr = ProcessChildrenArray_H_XIES(pNodeDirectory, rgNodeFuncs_Directory,
										 cNodeFuncs_Directory, pEEDirectory, 
										 pSkuSet);
	}

	// Process Common values first
	if (SUCCEEDED(hr))
	{
		pEEDirectory->Finalize();

		skuSetCommon = pEEDirectory->GetCommonSkuSet();

		printf("Common Set:");
		skuSetCommon.print();

		if (!skuSetCommon.testClear())
		{
			szDirectoryCommon = pEEDirectory->GetCommonValue(1).szVal;
			LPTSTR szDefaultDirCommon = pEEDirectory->GetCommonValue(2).szVal;

			// check that <TargetDir> and <TargetProperty> don't coexist
			hr = CheckTargetDir_TargetProperty(szDirectoryCommon, 
											   szDefaultDirCommon,
											   &skuSetCommon, -1);
			if (SUCCEEDED(hr))
			{
				GetPrimaryKey(&szDirectoryCommon, isValID.szVal);

				// insert into DB
				hr = InsertDirectory(szDirectoryCommon, isValParentDir.szVal,
									 szDefaultDirCommon, &skuSetCommon, -1);
			}
		}
		else
			szDirectoryCommon = isValID.szVal;
	}


	// process exceptional values
	if(SUCCEEDED(hr))
	{
		SkuSet skuSetUncommon = SkuSetMinus(*pSkuSet, skuSetCommon);
		if (!skuSetUncommon.testClear())
		{
			for (int i=0; i<g_cSkus; i++)
			{
				if (skuSetUncommon.test(i))
				{
					LPTSTR szDirectory = pEEDirectory->GetValue(1, i).szVal;
					LPTSTR szDefaultDir = pEEDirectory->GetValue(2, i).szVal;

					// check that <TargetDir> and <TargetProperty> don't 
					// coexist
					hr = CheckTargetDir_TargetProperty(szDirectory, 
													   szDefaultDir,
													   NULL, i);
					if (FAILED(hr)) break;
					// generate Primary Key: Directory column
					GetPrimaryKey(&szDirectory, isValID.szVal);

					// insert into DB
					hr = InsertDirectory(szDirectory, isValParentDir.szVal,
										 szDefaultDir, NULL, i);

					if (FAILED(hr)) 
					{
						delete[] szDirectory;
						break;
					}

					// if the primary key is the same as the common case,
					// put this Sku on the common SkuSet because only
					// the primary key matters for the next 2 steps:
					// store the reference and recursively process children
					if (0 == _tcscmp(szDirectory, szDirectoryCommon))
					{
						delete[] szDirectory;
						skuSetCommon.set(i);
					}
					else // otherwise perform the next 2 steps
					{
						// insert the ref into global data structure
						if (isValID.szVal)
							InsertDirRef(isValID.szVal, szDirectory, NULL, i);

						// recursively process all the children <Directory>s
						IntStringValue isValDirectory;
						isValDirectory.szVal = szDirectory;
						SkuSet skuSetTemp(g_cSkus);
						skuSetTemp.set(i);
						hr = ProcessChildrenList_SKU(pNodeDirectory, DIRECTORY,
													 /*bIsRequired*/false, 
													 isValDirectory,
													 ProcessDirectory_SKU,
													 &skuSetTemp);
						if (!isValID.szVal)
							delete[] szDirectory;
						
						if (FAILED(hr)) break;
					}
				}
			}
		}
	}

	// finally perform the last 2 steps for the common set
	// Insert the Directory ref into global data structure
	if (SUCCEEDED(hr))
	{
		if (isValID.szVal)
			InsertDirRef(isValID.szVal, szDirectoryCommon, &skuSetCommon, -1);

		// recursively process all the children <Directory>s
		IntStringValue isValDirectory;
		isValDirectory.szVal = szDirectoryCommon;
		hr = ProcessChildrenList_SKU(pNodeDirectory, DIRECTORY,
									 /*bIsRequired*/false, isValDirectory,
									 ProcessDirectory_SKU,
									 &skuSetCommon);
	}
		
	delete pEEDirectory;

	if (!isValID.szVal)
		delete[] szDirectoryCommon;

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessDirectory_SKU\n"));
#endif

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// FormDefaultDir: form TargetDir:Name for DefaultDir column 
////////////////////////////////////////////////////////////////////////////
HRESULT FormDefaultDir(IntStringValue *pIsValOut, IntStringValue isValName, 
							  IntStringValue isValTargetDir)
{
	int iLength = _tcslen(isValName.szVal) + _tcslen(isValTargetDir.szVal);
	pIsValOut->szVal = new TCHAR[iLength+2]; 
	assert(pIsValOut->szVal);

	_stprintf(pIsValOut->szVal, TEXT("%s:%s"), 
						isValTargetDir, isValName);

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessName
// This function process <Name> node under <Directory>. It writes the value
// obtained into the ElementEntry object *pEE
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessName(PIXMLDOMNode &pNodeName, int iColumn, ElementEntry *pEE,
					SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeName);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeName)));
#endif

	// Get the value of <Name>. It is either short or short|Long 
	IntStringValue isValName;
	hr = ProcessShortLong_SKU(pNodeName, &isValName, pSkuSet);

	// insert the value into the ElementEntry. Because both
	// <Name> and <TargetDir> could update the value of 
	// "DefaultDir" column, use SetValueSplit.
	if (SUCCEEDED(hr))
		hr = pEE->SetValueSplit(isValName, iColumn, pSkuSet, NULL);

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessName\n"));
#endif
	
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessTargetDir
// This function process <TargetDir> node under <Directory>. It writes the 
// value obtained into the ElementEntry object *pEE
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessTargetDir(PIXMLDOMNode &pNodeTargetDir, int iColumn, 
						 ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeTargetDir);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeTargetDir)));
#endif

	// Get the value of <TargetDir>. It is either short or short|Long 
	IntStringValue isValTargetDir;
	hr = ProcessShortLong_SKU(pNodeTargetDir, &isValTargetDir, pSkuSet);

	// insert the value into the ElementEntry. Because both
	// <Name> and <TargetDir> could update the value of 
	// "DefaultDir" column, use SetValueSplit.
	if (SUCCEEDED(hr))
		hr = pEE->SetValueSplit(isValTargetDir, iColumn, pSkuSet, 
								FormDefaultDir);

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessTargetDir\n"));
#endif

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessTargetProperty
// This function process <TargetProperty> node under <Directory>. It writes 
// the value obtained into the ElementEntry object *pEE
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessTargetProperty(PIXMLDOMNode &pNodeTargetProperty, int iColumn, 
							  ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeTargetProperty);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeTargetProperty)));
#endif

	// Get the value of <TargetProperty>. It is either short or short|Long 
	IntStringValue isValTargetProperty;
	hr = ProcessAttribute(pNodeTargetProperty, 
						  rgXMSINodes[TARGETPROPERTY].szAttributeName,
						  STRING, &isValTargetProperty, pSkuSet);

	if (SUCCEEDED(hr))
		hr = pEE->SetValue(isValTargetProperty, iColumn, pSkuSet);	
	
#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessTargetProperty\n"));
#endif

	return hr;
}
 
////////////////////////////////////////////////////////////////////////////
// Helper function used by ProcessInstallLevels to update the data structure
// storing the least possible numeric intalllevel value for each SKU.
////////////////////////////////////////////////////////////////////////////
HRESULT UpdateLevel(IntStringValue *pisValOut, IntStringValue isValOld,
					IntStringValue isValNew)
{
	HRESULT hr = S_OK;

	if (-1 == isValNew.intVal)
	{
		// This is a <InstallLevel> w/o specified value
		if (-1 == isValOld.intVal)
			// This is the second <InstallLevel> tag for this Sku
			pisValOut->intVal = 1;
		else
			pisValOut->intVal = isValOld.intVal + 1;
	}
	else // isValNew contains the Value specified by the input package
	{
		if (-1 == isValOld.intVal)
			isValOld.intVal = 0;
		// checking for if the specified value is possible or not
		if (isValNew.intVal < ++(isValOld.intVal))
		{
			hr = E_FAIL;
			_tprintf(
				TEXT("Compile Error: the value specified %d is too small ")
				TEXT("(the minimal possible value is: %d) "),
				isValNew.intVal, isValOld.intVal);
			pisValOut->intVal = -2;
		}
		else
		{
			pisValOut->intVal = isValNew.intVal;
		}
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessInstallLevels
//   This function processes <InstallLevels> node:
//         1) process its children <InstallerLevel>s, either get the
//			 specified value or assign each <InstalerLevel> a numeric value i
//			 and insert each <ID, i> into g_mapInstallLevelRefs for future
//			 look-up;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessInstallLevels_SKU(PIXMLDOMNode &pNodeInstallLevels, 
								 const IntStringValue *pisVal, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;
	
	PIXMLDOMNodeList pNodeListInstallLevels = NULL;
	long iListLength = 0;

	assert(pNodeInstallLevels != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeInstallLevels)));
#endif

	// Retrieve the list of <InstallLevel>s
	if (SUCCEEDED(hr = GetChildrenNodes(pNodeInstallLevels,
								rgXMSINodes[XMSI_INSTALLLEVEL].szNodeName,
								pNodeListInstallLevels)))
	{
		if (FAILED(hr = pNodeListInstallLevels->get_length(&iListLength)))
			_tprintf(
			  TEXT("Error: Internal error. DOM API call get_length failed\n"));
	}

	// process all the <InstallLevel>s
	if (SUCCEEDED(hr))
	{
	
		// The data structure is used to store the
		// least possible values that each Sku can take
		// as InstallLevel
		SkuSetValues *pSkuSetValues = new SkuSetValues;
		assert(pSkuSetValues);
		pSkuSetValues->SetValType(INSTALL_LEVEL);

		for (long i=0; i<iListLength; i++)
		{
			PIXMLDOMNode pNodeInstallLevel = NULL;
			IntStringValue isValID;
			SkuSet *pSkuSetChild = NULL;

			// Get the node and its SkuSet, ID.
			if (SUCCEEDED(hr = 
				pNodeListInstallLevels->get_item(i, &pNodeInstallLevel)))
			{
				assert(pNodeInstallLevel != NULL);
				// Get the SkuSet specified for this child
				if (SUCCEEDED(hr = 
								GetSkuSet(pNodeInstallLevel, &pSkuSetChild)))
				{
					assert (pSkuSetChild != NULL);

					// if the child node doesn't have a SKU filter specified,
					//  it inherits the SKU filter from its parent
					*pSkuSetChild &= *pSkuSet;

					// No need to process this node if it doesn't apply to
					// any SKU
					if (pSkuSetChild->testClear())
					{
						delete pSkuSetChild;
						continue;
					}
				}
				else
					break;

				// get ID
				if (SUCCEEDED(hr = 
					ProcessAttribute(pNodeInstallLevel, TEXT("ID"),
									 STRING, &isValID, pSkuSetChild)))
				{
					if (S_FALSE == hr)
					{
						_tprintf(TEXT("Compile Error: Missing required")
								 TEXT("\'ID\' attribute for <%s>"),
							rgXMSINodes[XMSI_INSTALLLEVEL].szNodeName);
						hr = E_FAIL;
						delete pSkuSetChild;
						break;
					}
				}
				else
				{
					delete pSkuSetChild;
					break;
				}
			}
			else 
			{
				_tprintf(
				 TEXT("Internal Error: DOM API call \'get_item\' failed"));
		
				break;
			}
			
			// Process the node

			// get Value if there is one specified
			IntStringValue isValInstallLevel_User;
			hr = ProcessAttribute(pNodeInstallLevel, TEXT("Value"), 
								  INTEGER, &isValInstallLevel_User,
								  pSkuSetChild);

			if (SUCCEEDED(hr))
			{
				// if there is no value specified, initialize to -1
				// it cannot be 0 since 0 is an acceptable value.
				// UpdateLevel needs to be able to tell that there
				// is no value specified just by looking at the value
				// passed in.
				if (S_FALSE == hr)
					isValInstallLevel_User.intVal = -1;

				// update the data structure to reflect the newest 
				// value. make a copy of pSkuSetTemp since it will
				// be destroyed inside SplitInsert
				SkuSet *pSkuSetTemp = new SkuSet(g_cSkus);
				*pSkuSetTemp = *pSkuSetChild;
				hr = pSkuSetValues->SplitInsert(pSkuSetTemp, 
												isValInstallLevel_User,
												UpdateLevel);
				if (SUCCEEDED(hr))
				{
					// query the data structure to get back a SkuSetValues 
					// object that will be stored globally
					SkuSetValues *pSkuSetValuesRetVal = NULL;
					hr = pSkuSetValues->GetValueSkuSet(pSkuSetChild, 
													   &pSkuSetValuesRetVal);

					// insert into the global data structure
					if (SUCCEEDED(hr))
					{
						// each <InstallLevel> should have a unique ID
					   assert(!g_mapInstallLevelRefs_SKU.count(isValID.szVal));
					   g_mapInstallLevelRefs_SKU.insert
						(map<LPTSTR, SkuSetValues *, Cstring_less>::value_type
										(isValID.szVal, pSkuSetValuesRetVal));	
					}
					else
						delete isValID.szVal;
				}
				else
				{
					_tprintf(TEXT("for <%s ID=\"%s\">\n"), 
						rgXMSINodes[XMSI_INSTALLLEVEL].szNodeName,
						isValID.szVal);
					delete isValID.szVal;
				}
				delete pSkuSetChild;

				if(FAILED(hr)) break;
			}
			else
			{
				delete isValID.szVal;
				delete pSkuSetChild;
				break;
			}
		}
		delete(pSkuSetValues);
	}	

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessInstallLevels_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessFeatures
//   This function processes <Features> node:
//         1) Call ProcessChildrenList to Process its children <Feature> nodes
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessFeatures_SKU(PIXMLDOMNode &pNodeFeatures, 
						const IntStringValue *pisVal, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeFeatures != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeFeatures)));
#endif

	// create Feature table for those SKUs that haven't had one
	hr = CreateTable_SKU(TEXT("Feature"), pSkuSet);

	IntStringValue isValParentFeature;
	isValParentFeature.szVal = NULL;
	hr = ProcessChildrenList_SKU(pNodeFeatures, FEATURE,
								 /*bIsRequired*/true, isValParentFeature,
								 ProcessFeature_SKU,
								 pSkuSet); 

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessFeatures_SKU\n"));
#endif
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessFeature
//   This is a recursive function:
//         1) Process <Title> <Description> <DisplayState> <Dir> <State> 
//			  <ILevel> (w/o Condition field) entities that belong to the 
//			  current <Feature> entity and insert into Feature table;
//		   2) Process <ILevel> (w/ condition field) and insert into Condition
//			  table
//         3) Process <UseModule> entity and therefore trigger the processing
//			   of all the components used by this feature
//         4) Call itself to process its children <Feature> nodes;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessFeature_SKU(PIXMLDOMNode &pNodeFeature, 
					   IntStringValue isValParentFeature, 
					   SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;
	assert(pNodeFeature != NULL);

	// Values to be inserted into the DB 
	LPTSTR szFeature = NULL;
	LPTSTR szFeatureParent = isValParentFeature.szVal;
	LPTSTR szTitle = NULL;
	LPTSTR szDescription = NULL;
	int iDisplay = MSI_NULL_INTEGER;
	int iInstallLevel = MSI_NULL_INTEGER;
	LPTSTR szDirectory = NULL;
	UINT iAttribute = MSI_NULL_INTEGER;

	SkuSet skuSetCommon(g_cSkus);

	// Construct an ElementEntry object. 
	ElementEntry *pEEFeature = new ElementEntry(6, pSkuSet);
	assert(pEEFeature);

	// Get ID attribute if there is one
	IntStringValue isValID;
	isValID.szVal = NULL;
	hr = ProcessAttribute(pNodeFeature,
						rgXMSINodes[FEATURE].szAttributeName, 
						STRING, &isValID, pSkuSet);

	if (SUCCEEDED(hr))
	{
		if (S_FALSE == hr)
		{
			_tprintf(TEXT("Compile Error: Missing required")
					 TEXT("\'%s\' attribute for <%s>"),
					rgXMSINodes[FEATURE].szAttributeName,
					rgXMSINodes[FEATURE].szNodeName);
			hr = E_FAIL;
		}
		else
			szFeature = isValID.szVal;
	}

#ifdef DEBUG
	if (SUCCEEDED(hr))
		_tprintf(TEXT("Processing <Feature ID=\"%s\">\n"), isValID.szVal);
#endif

	if (SUCCEEDED(hr))
	{
		// Call ProcessChildrenArray to get back column values of all SKUs 
		// via the ElementEntry object
		hr = ProcessChildrenArray_H_XIES(pNodeFeature, rgNodeFuncs_Feature_SKU,
										 cNodeFuncs_Feature_SKU, pEEFeature, 
										 pSkuSet);
	}

	// Process Common values first
	if (SUCCEEDED(hr))
	{
		pEEFeature->Finalize();

		skuSetCommon = pEEFeature->GetCommonSkuSet();

		if (!skuSetCommon.testClear())
		{
			szTitle = pEEFeature->GetCommonValue(1).szVal;
			szDescription = pEEFeature->GetCommonValue(2).szVal;
			iDisplay = pEEFeature->GetCommonValue(3).intVal;
			iInstallLevel = pEEFeature->GetCommonValue(4).intVal;
			szDirectory = pEEFeature->GetCommonValue(5).szVal;
			iAttribute = pEEFeature->GetCommonValue(6).intVal;

			// insert into DB
			hr = InsertFeature(szFeature, szFeatureParent, szTitle, 
							   szDescription, iDisplay, iInstallLevel, 
							   szDirectory, iAttribute, &skuSetCommon, -1);
		}
	}

	// process exceptional values
	if(SUCCEEDED(hr))
	{
		SkuSet skuSetUncommon = SkuSetMinus(*pSkuSet, skuSetCommon);
		if (!skuSetUncommon.testClear())
		{
			for (int i=0; i<g_cSkus; i++)
			{
				if (skuSetUncommon.test(i))
				{
					szTitle = pEEFeature->GetValue(1,i).szVal;
					szDescription = pEEFeature->GetValue(2,i).szVal;
					iDisplay = pEEFeature->GetValue(3,i).intVal;
					iInstallLevel = pEEFeature->GetValue(4,i).intVal;
					szDirectory = pEEFeature->GetValue(5,i).szVal;
					iAttribute = pEEFeature->GetValue(6,i).intVal;
			
					// insert into DB
					hr = InsertFeature(szFeature, szFeatureParent, szTitle, 
									   szDescription, iDisplay, iInstallLevel,
									   szDirectory, iAttribute, NULL, i);
				}
			}
		}
	}

	delete pEEFeature;

	// Process conditionalized <ILevel> nodes
	if (SUCCEEDED(hr))
	{
		hr = ProcessILevelCondition(pNodeFeature, szFeature, pSkuSet);
	}

	// Process <UseModule>s
	if (SUCCEEDED(hr))
		hr = ProcessChildrenList_SKU(pNodeFeature, USEMODULE, 
									 /*bIsRequired*/false, isValID,
									 ProcessUseModule_SKU, pSkuSet);

	/* Issue: if the feature ID will be referenced later, the compiler
			  should store the reference for checking the SKU ownership
			  of a feature. (one SkU shouldn't refer to a feature that
			  doesn't belong to it) */

	// recursively process children <Feature>s
	if (SUCCEEDED(hr))
		// recursively process all the children <Feature>s
		hr = ProcessChildrenList_SKU(pNodeFeature, FEATURE,
									 /*bIsRequired*/false, isValID,
									 ProcessFeature_SKU,
									 pSkuSet);

	if (isValID.szVal)
		delete[] isValID.szVal;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessFeature_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessDisplayState
//   This function:
//         1) Process <DisplayState> entity and store the value inside
//			  the ElementEntry object;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessDisplayState_SKU(PIXMLDOMNode &pNodeDisplayState, int iColumn,  
							 ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeDisplayState != NULL);
	assert(pEE);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeDisplayState)));
#endif

	int iDisplay = 0;
	IntStringValue isVal;
	NodeIndex ni = pEE->GetNodeIndex(iColumn);

	// Get the Value of Value Attribute of <DisplayState>
	if (SUCCEEDED(hr = ProcessAttribute(pNodeDisplayState, 
										rgXMSINodes[ni].szAttributeName,
										STRING, &isVal, pSkuSet)))
	{
		if (NULL == isVal.szVal)
		{
			_tprintf(
			TEXT("Compile Error: Missing required attribute \'%s\' of <%s>\n"), 
				rgXMSINodes[ni].szAttributeName, rgXMSINodes[ni].szNodeName);
			hr = E_FAIL;
		}
		else
		{
			if (0 != _tcscmp(isVal.szVal, TEXT("Hidden")))
			{
				iDisplay = GetUniqueNumber();

				if (0 == _tcscmp(isVal.szVal, TEXT("Collapsed")))
				{
					iDisplay *= 2;
				}
				else if (0 == _tcscmp(isVal.szVal, TEXT("Expanded")))
				{
					iDisplay = iDisplay*2 + 1;
				}
				else
				{
					_tprintf(TEXT("Compiler Error:  \'%s\' attribute ")
							 TEXT("of <%s> has an unrecognized value\n"),
							 rgXMSINodes[ni].szAttributeName,
							 rgXMSINodes[ni].szNodeName);
				}
			}

			delete[] isVal.szVal;

			isVal.intVal = iDisplay;
				// insert the value into the ElementEntry.
			hr = pEE->SetValue(isVal, iColumn, pSkuSet);
		}
	}
	
#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessDisplayState_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessState
// This function processes <State> entity under <Feature> 
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessState_SKU(PIXMLDOMNode &pNodeState, int iColumn, 
							 ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeState != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeState)));
#endif

	// Process <Favor> child
	hr = ProcessEnumAttributes(pNodeState, FAVOR, rgEnumBits_Favor_Feature,
							   cEnumBits_Favor_Feature, pEE, iColumn, pSkuSet);

	// Process <Advertise> child
	if (SUCCEEDED(hr))
		hr = ProcessEnumAttributes(pNodeState, ADVERTISE, 
								  rgEnumBits_Advertise_Feature,
								  cEnumBits_Advertise_Feature, pEE, 
								  iColumn, pSkuSet);

	// Process all on/off children elements
	if (SUCCEEDED(hr))
		hr = ProcessOnOffAttributes_SKU(pNodeState, rgAttrBits_Feature,
						cAttrBits_Feature, pEE, iColumn, pSkuSet);
#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessState_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Function: ProcessILevelCondition
//		This function processes <ILevel> node that has a Condition attribute
//		specified and insert into Condition table.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessILevelCondition(PIXMLDOMNode &pNodeFeature, LPTSTR szFeature,
							   SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;
	PIXMLDOMNodeList pNodeListILevelConditions = NULL;
	long iListLength = 0;
	// used to validate the one SKU doesn't refer to the same Ref 
	// more than once. (Ref is part of the primary key in the Condition
	// table.
	map<LPTSTR/*Ref*/, SkuSet *, Cstring_less> mapValidateUniqueRef; 

#ifdef DEBUG
	_tprintf(TEXT("Inside Function: ProcessILevelCondition\n"));
#endif

	assert(pNodeFeature != NULL);

	// get the list of <ILevel Condition="..."> nodes
	if(SUCCEEDED(hr = GetChildrenNodes(pNodeFeature, 
									   rgXMSINodes[ILEVELCONDITION].szNodeName,
									   pNodeListILevelConditions)))
	{
		if(FAILED(hr = pNodeListILevelConditions->get_length(&iListLength)))
		{
			_tprintf(TEXT("Internal Error: Failed to make DOM API call:")
				 TEXT("get_length\n"));
			iListLength = 0;
		}
	}

	// process each ILevelCondition node in the list
	for (long l=0; l<iListLength; l++)
	{
		PIXMLDOMNode pNodeILevelCondition = NULL;
		if (SUCCEEDED(hr = 
			pNodeListILevelConditions->get_item(l, &pNodeILevelCondition)))
		{	
			assert(pNodeILevelCondition != NULL);
			// Get the SkuSet specified for this ILevelCondition node
			SkuSet *pSkuSetILevelCondition = NULL;
			if (SUCCEEDED(hr = GetSkuSet(pNodeILevelCondition, 
										 &pSkuSetILevelCondition)))
			{
				assert (pSkuSetILevelCondition != NULL);

				// if this node doesn't have a SKU filter specified,
				//  it inherits the SKU filter from its parent
				// Also get rid of those Skus specified in this node
				// but not in its parent
				*pSkuSetILevelCondition &= *pSkuSet;

				// only keep processing if the SkuSet is not empty
				if (!pSkuSetILevelCondition->testClear())
				{
					// create Condition table
					hr = CreateTable_SKU(TEXT("Condition"), 
										 pSkuSetILevelCondition);
					IntStringValue isValCondition;
					isValCondition.szVal = NULL;
					// get the value of Condition attribute
					if (SUCCEEDED(hr))
					{
						hr = ProcessAttribute(pNodeILevelCondition, 
											  TEXT("Condition"), STRING,
											  &isValCondition, 
											  pSkuSetILevelCondition);
					}

					if (SUCCEEDED(hr))
					{
						// get the Value of the Ref attribute
						IntStringValue isValRef;
						if (SUCCEEDED
							(hr = ProcessAttribute(pNodeILevelCondition,
												   TEXT("Ref"),
												   STRING, &isValRef, 
												   pSkuSetILevelCondition)))
						{
							if (NULL == isValRef.szVal)
							{
								_tprintf(
									TEXT("Compile Error: Missing required ")
									TEXT("attribute \'Ref\' of")
									TEXT(" <ILevel Condition=\"%s\">\n"),
									isValCondition.szVal);

								hr = E_FAIL;
							}
						}

						if (SUCCEEDED(hr))
						{
							// check for Uniqueness of Ref
							if (mapValidateUniqueRef.count(isValRef.szVal))
							{
								SkuSet skuSetTemp 
									= *mapValidateUniqueRef[isValRef.szVal] &
									  *pSkuSetILevelCondition;

								if (!skuSetTemp.testClear())
								{
									// Error happened. Duplicate <Feature, Ref>
									// for the same SKU
									_tprintf(TEXT("Compile Error:")
											 TEXT("<ILevel Ref=\"%s\" ")
											 TEXT("Condition=\"%s\"> ")
											 TEXT("Duplicate ILevel for SKU "),
											 isValRef.szVal, 
											 isValCondition.szVal);
									PrintSkuIDs(&skuSetTemp);
									hr = E_FAIL;
								}
								else
								{
									// update the SkuSet that contains this Ref
									*mapValidateUniqueRef[isValRef.szVal] |=
										*pSkuSetILevelCondition;
								}
							}
							else
							{
								// make a copy of pSkuSetILevelCondition
								// and insert into the map
								SkuSet *pSkuSetTemp = new SkuSet(g_cSkus);
								*pSkuSetTemp = *pSkuSetILevelCondition;
								mapValidateUniqueRef.insert(
									LS_ValType(isValRef.szVal, 
											   pSkuSetTemp));
							}
						}

						// get the real values of the Ref. It is a list
						// of values since <InstallLevel> is Skuable.
						if (SUCCEEDED(hr))
						{
							SkuSetValues *pSkuSetValuesRetVal = NULL;
							// The ILevel referred should be in the 
							// data structure already
							assert(0 != g_mapInstallLevelRefs_SKU.count
															(isValRef.szVal));

							// return a list of <SkuSet, InstallLevel> pairs
							hr = g_mapInstallLevelRefs_SKU[isValRef.szVal]->
										GetValueSkuSet(pSkuSetILevelCondition, 
													   &pSkuSetValuesRetVal);

							if (FAILED(hr))
							{
								_tprintf(
									TEXT("are trying to reference %s which is ")
									TEXT("undefined inside them\n"),
									 isValRef.szVal);
							}
							else
							{
								// Finally we can insert into the DB
								SkuSetVal *pSkuSetValTemp = NULL;
								for (pSkuSetValTemp = 
											pSkuSetValuesRetVal->Start();
									 pSkuSetValTemp != 
											pSkuSetValuesRetVal->End();
									 pSkuSetValTemp = 
											pSkuSetValuesRetVal->Next())
								{
									hr = InsertCondition(szFeature, 
												pSkuSetValTemp->isVal.intVal,
												isValCondition.szVal, 
												pSkuSetValTemp->pSkuSet,
												-1);
									if(FAILED(hr))	break;
								}
								delete pSkuSetValuesRetVal;
							}
						}

						if (0 == mapValidateUniqueRef.count(isValRef.szVal))
							delete[] isValRef.szVal;
					}
					delete[] isValCondition.szVal;
				}
				delete pSkuSetILevelCondition;
			}
		}
		else
		{
			_tprintf(TEXT("Internal Error: Failed to make ")
					 TEXT("DOM API call: get_item\n"));
			break;
		}
		if (FAILED(hr))	break;
	}

	// Free memory referenced from map
	map<LPTSTR, SkuSet *, Cstring_less>::iterator it;
	for (it = mapValidateUniqueRef.begin(); 
		 it != mapValidateUniqueRef.end(); 
		 ++it)
	{
		delete[] (*it).first;
		delete (*it).second;
	}

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessILevelCondition\n"));
#endif

	return hr;
}  

////////////////////////////////////////////////////////////////////////////
// The following set of functions: ProcessUseModule, ProcessModule, and
// ProcessComponentRel are used to form 3 kinds of information:
//		1) a Component list that stores all the components to be processed
//		   together with their associated SkuSet;
//		2) for each component: a list of feature ids for the FeatureComponent
//		   table and the ownership information for Shortcuts, Classes, 
//		   Typelibs, Extensions, and QualifiedComponents;
//		3) for each SKU, a list of Module IDs that will be installed in 
//		   that SKU. This is used for checking the DependOn relationship
////////////////////////////////////////////////////////////////////////////

// check if all the Skus in the SkuSet own the Module. Need to check
// the SkuSet information of the given Module and its ancestors up to
// <Modules> entity.
//
// Issue: Not implemented for now. 
HRESULT CheckModuleSku(PIXMLDOMNode &pNodeModule, SkuSet *ppSkuSet)
{
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessUseModule
//   This function:
//         1) Process <UseModule> entity to get the Module reference
//		   2) Process the <TakeOwnership> entity
//         3) Call ProcessModule and pass along the ownership information
//			  thus trigger the process described above
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessUseModule_SKU(PIXMLDOMNode &pNodeUseModule, 
							 IntStringValue isValFeature,  
							 SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;
	IntStringValue isValRef;
	isValRef.szVal = NULL;
	PIXMLDOMNode pNodeModule = NULL;
	ElementEntry *pEEOwnership = NULL;

	assert(pNodeUseModule != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeUseModule)));
#endif

	pEEOwnership = new ElementEntry(1, pSkuSet);
	assert(pEEOwnership);
	// Process <TakeOwnerShip>
	hr = ProcessChildrenArray_H_XIES(pNodeUseModule, rgNodeFuncs_UseModule,
									 cNodeFuncs_UseModule, pEEOwnership, 
									 pSkuSet);

	if (SUCCEEDED(hr))
	{
		// Get Ref attribute of <UseModule>
		if (SUCCEEDED(hr = ProcessAttribute(pNodeUseModule,  
										rgXMSINodes[USEMODULE].szAttributeName,
										STRING, &isValRef, pSkuSet)))
		{
			if (NULL == isValRef.szVal)
			{
				_tprintf(TEXT("Compile Error: Missing required attribute")
						 TEXT("\'%s\' of <%s>\n"), 
						 rgXMSINodes[USEMODULE].szAttributeName,
						 rgXMSINodes[USEMODULE].szNodeName);
				hr = E_FAIL;
			}
		}

		if (SUCCEEDED(hr))
		{
			// Form the XPath query:  
			//			ProductFamily/Modules//Module[ @ID = "sz"]
			int iLength = _tcslen(isValRef.szVal);
			LPTSTR szXPath = new TCHAR[iLength+61];
			assert(szXPath);
			_stprintf(szXPath, 
				TEXT("/ProductFamily/Modules//Module[ @ID = \"%s\"]"), 
				isValRef.szVal);
			
			BSTR bstrXPath = NULL;

			if (NULL != (bstrXPath = LPTSTRToBSTR(szXPath)))
			{
				// get the referred <Module> node and pass it to 
				//	ProcessModule
				if(SUCCEEDED(hr = 
					pNodeUseModule->selectSingleNode(bstrXPath,
														&pNodeModule)))
				{
					// check if every SKU in *pSkuSet owns the
					// Module referred to. 
					hr = CheckModuleSku(pNodeModule, pSkuSet);

					if (SUCCEEDED(hr))
					{
						SkuSetValues *pSkuSetValuesOwnership = 
							pEEOwnership->GetColumnValue(1);

						FOM *pFOM = new FOM;
						pFOM->szFeature = isValFeature.szVal;
						pFOM->szModule = isValRef.szVal;

						hr = ProcessModule_SKU(pNodeModule, pFOM,
										   pSkuSetValuesOwnership, pSkuSet);
						delete pFOM;
					}
				}
				SysFreeString(bstrXPath);
			}
			else 
			{
				hr = E_FAIL;
				_tprintf(TEXT("Internal Error: string conversion ")
						 TEXT("failed.\n"));
			}

			delete[] szXPath;
			delete[] isValRef.szVal;
		}
	}

	delete pEEOwnership;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessUseModule\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessTakeOwnership
//		This function processes <TakeOwnership> entity under <UseModule>.
//		It forms a bit field represent the ownership information of 5 different
//		entities: ShortCut, Class, TypeLib, Extenstion, QualifiedComponent
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessTakeOwnership(PIXMLDOMNode &pNodeTakeOwnership, int iColumn, 
							 ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeTakeOwnership != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeTakeOwnership)));
#endif

	// Process all on/off children elements <OwnShortcuts>
	// <OwnClasses> <OwnTypeLibs> <OwnExtensions> <OwnQualifiedComponents>
	hr = ProcessOnOffAttributes_SKU(pNodeTakeOwnership, 
									rgAttrBits_TakeOwnership,
									cAttrBits_TakeOwnership, 
									pEE, iColumn, pSkuSet);

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessTakeOwnership\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessModule
//   This is a recursive function:
//         1) Process <Module> entity;
//         2) Call ProcessComponentRel on all the components belonged to this 
//				<Module>;
//         3) Recursively process all children <Module>s;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessModule_SKU(PIXMLDOMNode &pNodeModule, FOM *pFOM, 
						  SkuSetValues *pSkuSetValuesOwnership, 
						  SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;
	assert(pFOM);

	IntStringValue isValID;
	// get ID attribute
	if(SUCCEEDED(hr = ProcessAttribute(pNodeModule, TEXT("ID"), STRING, 
									   &isValID, pSkuSet))) 
	{
		if (NULL == isValID.szVal)
		{
			_tprintf(
			TEXT("Compile Error: Missing required attribute \'ID\' on <%s>\n"),
				rgXMSINodes[MODULE].szNodeName);
			hr = E_FAIL;
		}
		else
			_tprintf(TEXT("Processing Module ID = %s\n"), isValID.szVal);
	}

	if (SUCCEEDED(hr))
	{
		// add this module ID to the module list of each SKU object
		// in *pSkuSet
		for (int i=0; i<g_cSkus; i++)
		{
			if (pSkuSet->test(i))
				g_rgpSkus[i]->SetOwnedModule(pFOM->szModule);
		}
		
		// skuSetCheckModule will contain those SKUs in which there is no
		// <Module> child of this <Module>
		SkuSet skuSetCheckModule(g_cSkus);
		// Retrieve the list of children <Component>s and process all of them
		hr = ProcessChildrenList_SKU(pNodeModule, COMPONENT, false, pFOM, 
									 pSkuSetValuesOwnership, 
									 ProcessComponentRel,
									 pSkuSet, &skuSetCheckModule);

		// Recursively Process all the children <Module>s of this <Module>
		if (SUCCEEDED(hr))
		{
			// skuSetCheckModule will contain those SKUs in which there is no
			// <Module> child of this <Module>
			SkuSet skuSetCheckComponent(g_cSkus);
			hr = ProcessChildrenList_SKU(pNodeModule, MODULE, false, pFOM, 
										 pSkuSetValuesOwnership, 
										 ProcessModule_SKU,
										 pSkuSet, &skuSetCheckComponent);
			if (SUCCEEDED(hr))
			{
				// check for empty Module declaration
				SkuSet skuSetTemp = skuSetCheckComponent & skuSetCheckModule;
				if (!skuSetTemp.testClear())
				{
					//the SKUs in skuSetTemp have an empty module
					_tprintf(TEXT("Compile Error: Empty Module ID = %s ")
							 TEXT("for SKU "), isValID.szVal);
					PrintSkuIDs(&skuSetTemp);
					hr = E_FAIL;
				}
			}
		}
		delete[] isValID.szVal;
	}
	
#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessModule_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessComponentRel
//   This functions established all component-related relationships w/o
//	 processing the sub-entities of the component:
//         1) If this component hasn't been processed yet, create a new
//			  Component object and insert into the global map;
//         2) Update the set of SKUs that will install this Component;
//		   3) Update the set of features that use this Component;
//		   4) Update the owner ship information of this Component;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessComponentRel(PIXMLDOMNode &pNodeComponent, FOM *pFOM,
						  SkuSetValues *pSkuSetValuesOwnership, 
						  SkuSet *pSkuSet)
{
	assert(pFOM);

	HRESULT hr = S_OK;
	Component *pComponent = NULL;

	// Get Component ID
	IntStringValue isValID;
	isValID.szVal = NULL;
	if(SUCCEEDED(hr = ProcessAttribute(pNodeComponent, TEXT("ID"), STRING,
									   &isValID, pSkuSet)))
	{
		if (NULL == isValID.szVal)
		{
			_tprintf(
			TEXT("Compile Error: Missing required attribute \'ID\' on <%s>\n"),
				rgXMSINodes[COMPONENT].szNodeName);
			hr = E_FAIL;
		}
	}
	
#ifdef DEBUG
	if (isValID.szVal)
		_tprintf(TEXT("Processing Component ID = %s\n"), isValID.szVal);
#endif

	if (SUCCEEDED(hr))
	{
		// if this component hasn't been touched before, create a new
		// Component object and insert into the global map
		if (0 == g_mapComponents.count(isValID.szVal))
		{
			pComponent = new Component();
			assert(pComponent);

			g_mapComponents.insert(LC_ValType(isValID.szVal, pComponent));
		}
		else
			pComponent = g_mapComponents[isValID.szVal];

		pComponent->m_pNodeComponent = pNodeComponent;
		// update the set of SKUs that will install this Component
		pComponent->SetSkuSet(pSkuSet);
		// update the set of Features that use this Component
		pComponent->SetUsedByFeature(pFOM->szFeature, pSkuSet);
		// update the ownership information
		if (pSkuSetValuesOwnership)
		{
			hr = pComponent->SetOwnership(pFOM, pSkuSetValuesOwnership);
			if (FAILED(hr))
				_tprintf(TEXT("when processing Component ID= %s\n"),
						 isValID.szVal);
		}
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessComponentRel\n"));
#endif

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\elemententry.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       ElementEntry.cpp
//
//    This file contains the implementation of ElementEntry class
//--------------------------------------------------------------------------

#include "wmc.h"

////////////////////////////////////////////////////////////////////////////
// Constructor: take the number of columns in the DB
////////////////////////////////////////////////////////////////////////////
ElementEntry::ElementEntry(int cColumns, SkuSet *pSkuSetAppliesTo)
{
	m_cColumns = cColumns;

	m_pSkuSetAppliesTo = new SkuSet(g_cSkus);
	assert(m_pSkuSetAppliesTo != NULL);
	*m_pSkuSetAppliesTo = *pSkuSetAppliesTo;

	m_pSkuSetCommon = new SkuSet(g_cSkus);
	assert(m_pSkuSetCommon != NULL);
	*m_pSkuSetCommon = *pSkuSetAppliesTo;

	m_rgCommonValues = new SkuSetVal*[cColumns];
	for(int j=0; j<cColumns; j++)
		m_rgCommonValues[j] = NULL;

	assert(m_rgCommonValues != NULL);

	m_rgValTypes = new ValType[cColumns];
	assert(m_rgValTypes != NULL);

	m_rgpSkuSetValuesXVals = new SkuSetValues*[cColumns];
	assert(m_rgpSkuSetValuesXVals != NULL);
	for(int i=0; i<cColumns; i++)
		m_rgpSkuSetValuesXVals[i] = NULL;

	m_rgNodeIndices = new NodeIndex[cColumns];
	assert(m_rgNodeIndices != NULL);

	m_rgpSkuSetValidate = new SkuSet*[cColumns];
	assert(m_rgpSkuSetValidate);
	for(int k=0; k<cColumns; k++)
		m_rgpSkuSetValidate[k] = NULL;

	m_rgpSkuSetUnique = new SkuSet*[cColumns];
	assert(m_rgpSkuSetUnique);
	for(int m=0; m<cColumns; m++)
		m_rgpSkuSetUnique[m] = NULL;
}

////////////////////////////////////////////////////////////////////////////
// Destructor: 
////////////////////////////////////////////////////////////////////////////
ElementEntry::~ElementEntry()
{
	if (m_pSkuSetAppliesTo) delete m_pSkuSetAppliesTo;
	if (m_pSkuSetCommon) delete m_pSkuSetCommon;
	if (m_rgCommonValues)
	{
		for (int i=0; i<m_cColumns; i++)
		{
			if (m_rgCommonValues[i])
			{
				delete m_rgCommonValues[i]->pSkuSet;
				if (STRING == m_rgValTypes[i])
					delete[] m_rgCommonValues[i]->isVal.szVal;
				delete m_rgCommonValues[i];
			}
		}
		delete[] m_rgCommonValues;
	}

	if (m_rgValTypes) delete[] m_rgValTypes;
	if (m_rgpSkuSetValuesXVals) 
	{
		for (int i=0; i<m_cColumns; i++)
		{
			if (m_rgpSkuSetValuesXVals[i])
				delete m_rgpSkuSetValuesXVals[i];
		}
		delete[] m_rgpSkuSetValuesXVals;
	}

	if (m_rgpSkuSetValidate)
	{
		for(int i=0; i<m_cColumns; i++)
		{
			if (m_rgpSkuSetValidate[i])
				delete m_rgpSkuSetValidate[i];
		}
		delete[] m_rgpSkuSetValidate;
	}

	if (m_rgpSkuSetUnique)
	{
		for(int i=0; i<m_cColumns; i++)
		{
			if (m_rgpSkuSetUnique[i])
				delete m_rgpSkuSetUnique[i];
		}
		delete[] m_rgpSkuSetUnique;
	}
}

////////////////////////////////////////////////////////////////////////////
// GetValType: return the ValueType (INTEGER or STRING) of a column
//				(column count from 1)
////////////////////////////////////////////////////////////////////////////
ValType 
ElementEntry::GetValType(int iColumn)
{
	assert(iColumn <=m_cColumns && iColumn>0);
	assert(m_rgValTypes);
	return m_rgValTypes[iColumn-1];
}

////////////////////////////////////////////////////////////////////////////
// SetValType: set the ValueType (INTEGER or STRING) of a column
////////////////////////////////////////////////////////////////////////////
void 
ElementEntry::SetValType(ValType vt, int iColumn)
{
	assert(iColumn <=m_cColumns && iColumn>0);
	assert(m_rgValTypes);
	m_rgValTypes[iColumn-1] = vt;
}

////////////////////////////////////////////////////////////////////////////
// GetNodeIndex: return the NodeIndex of a column (column count from 1)
////////////////////////////////////////////////////////////////////////////
NodeIndex
ElementEntry::GetNodeIndex(int iColumn)
{
	assert(iColumn <=m_cColumns && iColumn>0);
	assert(m_rgNodeIndices);
	return m_rgNodeIndices[iColumn-1];
}

////////////////////////////////////////////////////////////////////////////
// SetNodeIndex: set the NodeIndex of a column (column count from 1)
////////////////////////////////////////////////////////////////////////////
void 
ElementEntry::SetNodeIndex(NodeIndex ni, int iColumn)
{
	assert(iColumn <=m_cColumns && iColumn>0);
	assert(m_rgNodeIndices);

	int iIndex = iColumn-1;
	m_rgNodeIndices[iIndex] = ni;
	if (m_rgpSkuSetUnique[iIndex])
		m_rgpSkuSetUnique[iIndex]->clear();
}


////////////////////////////////////////////////////////////////////////////
// SetValue: set the exceptional value of a column (column count from 1)
//			 The caller should free *pSkuSetAppliesTo
////////////////////////////////////////////////////////////////////////////
HRESULT
ElementEntry::SetValue(IntStringValue isVal, int iColumn, SkuSet *pSkuSetAppliesTo)
{
	assert(iColumn <=m_cColumns && iColumn>0);
	assert(m_rgCommonValues);
	assert(m_rgpSkuSetValuesXVals);

	HRESULT hr = S_OK;
	int iIndex = iColumn-1;

	SkuSet *pSkuSetTemp = new SkuSet(g_cSkus);
	assert(pSkuSetTemp);

	// get rid of the SKUs specified in children but not in parent
	*pSkuSetTemp = (*m_pSkuSetAppliesTo) & (*pSkuSetAppliesTo);

	// this value is no good for any SKU under consideration
	if (pSkuSetTemp->testClear())
		return S_FALSE;

	// if there is no common value specified for this column
	// this value becomes the common value
	if (!m_rgCommonValues[iIndex])
	{
		m_rgCommonValues[iIndex] = new SkuSetVal;
		assert(m_rgCommonValues[iIndex]);

		m_rgCommonValues[iIndex]->pSkuSet = pSkuSetTemp;
		m_rgCommonValues[iIndex]->isVal = isVal;

		// allocate memory to store the SkuSet for checking
		// the uniqueness of column values per SKU
		assert(!m_rgpSkuSetValidate[iIndex]);
		m_rgpSkuSetValidate[iIndex] = new SkuSet(g_cSkus);
		assert(m_rgpSkuSetValidate[iIndex]);

		*m_rgpSkuSetValidate[iIndex] = *pSkuSetTemp;

		return hr;
	}

	// Check the uniqueness of the column value in each SKU
	assert(m_rgpSkuSetValidate[iIndex]);
	SkuSet skuSetTemp = (*pSkuSetTemp) & *(m_rgpSkuSetValidate[iIndex]);

	if (!skuSetTemp.testClear())
	{
		_tprintf(TEXT("Error: <%s> appears more than ")
			TEXT("once in SKU: "), 
			rgXMSINodes[m_rgNodeIndices[iIndex]].szNodeName);
		for (int j=0; j<g_cSkus; j++)
		{
			if (skuSetTemp.test(j))
				_tprintf(TEXT("%s "), g_rgpSkus[j]->GetID());
		}
		_tprintf(TEXT("\n"));

		//For now, completely break when such error happens
		hr = E_FAIL;
		if (STRING == m_rgValTypes[iIndex])
			delete[] isVal.szVal;
		return hr;
	}

	// update the set of Skus that have this column value set
	*(m_rgpSkuSetValidate[iIndex]) |= *pSkuSetTemp;

	// allocate memory for the exceptional value
	if (!m_rgpSkuSetValuesXVals[iIndex])
	{
		m_rgpSkuSetValuesXVals[iIndex] = new SkuSetValues;
		assert(m_rgpSkuSetValuesXVals);
		m_rgpSkuSetValuesXVals[iIndex]->SetValType(m_rgValTypes[iIndex]);
	}

	// allocate memory and construct a SkuSetVal object
	SkuSetVal *pSkuSetVal = new SkuSetVal;
	assert(pSkuSetVal);

	// there is an exceptional column value. Prepare the values
	// for the newly constructed SkuSetVal object to be stored.
	// swap common and special values if necessary
	if (m_rgCommonValues[iIndex]->pSkuSet->countSetBits() 
					>= pSkuSetTemp->countSetBits())
	{
		pSkuSetVal->pSkuSet = pSkuSetTemp;
		pSkuSetVal->isVal = isVal;
	}
	else // swap common and special values
	{
		*pSkuSetVal = *(m_rgCommonValues[iIndex]);

		m_rgCommonValues[iIndex]->pSkuSet = pSkuSetTemp;
		m_rgCommonValues[iIndex]->isVal = isVal;
	}

	// insert into vector
	m_rgpSkuSetValuesXVals[iIndex]->DirectInsert(pSkuSetVal);

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// SetValueSkuSetValues: Store a list of values (a SkuSetValues object)
//						 for a column
//						 Caller should allocate and free *pSkuSetValues
////////////////////////////////////////////////////////////////////////////
HRESULT
ElementEntry::SetValueSkuSetValues(SkuSetValues *pSkuSetValues, int iColumn)
{
	HRESULT hr = S_OK;

	assert(pSkuSetValues);
	int iIndex = iColumn - 1;
	ValType vt = m_rgValTypes[iIndex];

	assert(pSkuSetValues->GetValType() == vt);

	SkuSetVal *pSkuSetVal = NULL;
	for (pSkuSetVal = pSkuSetValues->Start(); 
		 pSkuSetVal != pSkuSetValues->End(); 
		 pSkuSetVal = pSkuSetValues->Next())
	{
		if (pSkuSetVal)
		{
			IntStringValue isVal;
			if(STRING == vt)
			{
				if (pSkuSetVal->isVal.szVal)
					isVal.szVal = _tcsdup(pSkuSetVal->isVal.szVal);
				else
					isVal.szVal = NULL;
				assert(isVal.szVal);
			}
			else
				isVal.intVal = pSkuSetVal->isVal.intVal;

			hr = SetValue(isVal, iColumn, pSkuSetVal->pSkuSet);

			if (FAILED(hr))
				break;
		}
	}

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// SetValueSplit: set the exceptional value of a column (column count from 1)
//				  The caller should free *pSkuSetAppliesTo.
//				  This function is used for the following situation:
//					1) When the column value is decided by more than one type 
//					   of node in the WIML file. The passed-in function pointer 
//					   tells how to update the column value;
////////////////////////////////////////////////////////////////////////////
HRESULT
ElementEntry::SetValueSplit(IntStringValue isVal, int iColumn, SkuSet *pSkuSetAppliesTo,
							HRESULT (*UpdateFunc)
								(IntStringValue *pIsValOut, IntStringValue isVal1, IntStringValue isVal2))
{
	assert(iColumn <=m_cColumns && iColumn>0);
	assert(m_rgpSkuSetValuesXVals);

	HRESULT hr = S_OK;
	int iIndex = iColumn-1;

	SkuSet *pSkuSetTemp = new SkuSet(g_cSkus);
	assert(pSkuSetTemp);

	// get rid of the SKUs specified in children but not in parent
	*pSkuSetTemp = (*m_pSkuSetAppliesTo) & (*pSkuSetAppliesTo);

	// this value is no good for any SKU under consideration
	if (pSkuSetTemp->testClear())
		return S_FALSE;

	// allocate memory to store the SkuSet for checking
	// the uniqueness of column values per SKU
	if (!m_rgpSkuSetUnique[iIndex])
		m_rgpSkuSetUnique[iIndex] = new SkuSet(g_cSkus);

	assert(m_rgpSkuSetUnique[iIndex]);


	// allocate memory to store the SkuSet for checking
	// not missing of required column values per SKU
	if (!m_rgpSkuSetValidate[iIndex])
		m_rgpSkuSetValidate[iIndex] = new SkuSet(g_cSkus);

	assert(m_rgpSkuSetValidate[iIndex]);

	// Check the uniqueness of the column value in each SKU
	if (1 == rgXMSINodes[m_rgNodeIndices[iIndex]].uiOccurence)
	{
		SkuSet skuSetTemp = (*pSkuSetTemp) & *(m_rgpSkuSetUnique[iIndex]);
		if (!skuSetTemp.testClear())
		{
			_tprintf(TEXT("Error: <%s> appears more than ")
				TEXT("once in SKU: "), 
				rgXMSINodes[m_rgNodeIndices[iIndex]].szNodeName);
			for (int j=0; j<g_cSkus; j++)
			{
				if (skuSetTemp.test(j))
					_tprintf(TEXT("%s "), g_rgpSkus[j]->GetID());
			}
			_tprintf(TEXT("\n"));

			//For now, completely break when such error happens
			hr = E_FAIL;
			if (STRING == m_rgValTypes[iIndex])
				delete[] isVal.szVal;
			return hr;
		}
	}

	// update the SkuSets used for error checking
	*(m_rgpSkuSetValidate[iIndex]) |= *pSkuSetTemp;
	*(m_rgpSkuSetUnique[iIndex]) |= *pSkuSetTemp;

	// allocate memory for the exceptional value
	if (!m_rgpSkuSetValuesXVals[iIndex])
	{
		m_rgpSkuSetValuesXVals[iIndex] = new SkuSetValues;
		assert(m_rgpSkuSetValuesXVals);
		m_rgpSkuSetValuesXVals[iIndex]->SetValType(m_rgValTypes[iIndex]);
	}

	// insert into vector
	hr = m_rgpSkuSetValuesXVals[iIndex]->SplitInsert(pSkuSetTemp, isVal, UpdateFunc);


	return hr;
}

////////////////////////////////////////////////////////////////////////////
// GetValue: Get the exceptional value of a column (column count from 1)
////////////////////////////////////////////////////////////////////////////
IntStringValue
ElementEntry::GetValue(int iColumn, int iPos)
{
	assert(iColumn <=m_cColumns && iColumn>0);
	// it is not efficient to get a common value this way!
	assert(!m_pSkuSetCommon->test(iPos));

	int iIndex = iColumn - 1;

	// check the common value of this column
	if (m_rgCommonValues[iIndex])
	{
		if (m_rgCommonValues[iIndex]->pSkuSet->test(iPos))
			return m_rgCommonValues[iIndex]->isVal;
	}

	// check the exceptional values
	if (m_rgpSkuSetValuesXVals[iIndex])
	{
		return m_rgpSkuSetValuesXVals[iIndex]->GetValue(iPos);
	}

	IntStringValue isVal;
	if (INTEGER == m_rgValTypes[iIndex])
		isVal.intVal = MSI_NULL_INTEGER;
	else
		isVal.szVal = NULL;

	return isVal;
}

////////////////////////////////////////////////////////////////////////////
// finalize the common values and the common set 
// also check for missing required entities
////////////////////////////////////////////////////////////////////////////
HRESULT 
ElementEntry::Finalize()
{
	HRESULT hr = S_OK;

	for(int iIndex=0; iIndex<m_cColumns; iIndex++)
	{
		NodeIndex nodeIndex = m_rgNodeIndices[iIndex];

		// check for missing required entities error
		if(rgXMSINodes[nodeIndex].bIsRequired)
		{
			SkuSet skuSetTemp(g_cSkus);
			if(!m_rgpSkuSetValidate[iIndex])
				skuSetTemp.setAllBits();
			else 
				skuSetTemp = SkuSetMinus(*m_pSkuSetAppliesTo, 
										*m_rgpSkuSetValidate[iIndex]);

			if (!skuSetTemp.testClear())
			{
				_tprintf(TEXT("Compile Error: Missing required Node <%s> ")
								TEXT("in SKU: "), 
								rgXMSINodes[nodeIndex].szNodeName);
							
				for (int j=0; j<g_cSkus; j++)
				{
					if (skuSetTemp.test(j))
						_tprintf(TEXT("%s "), g_rgpSkus[j]->GetID());
				}
				_tprintf(TEXT("\n"));

				//For now, completely break when such error happens
				hr = E_FAIL;
				break;
			}
		}

		// if the common value is not set, but the exceptional value is
		// set. This column is formed by SetValueSplit. Need to find
		// the most common value stored and put it in m_rgCommonValues
		if (!m_rgCommonValues[iIndex] && m_rgpSkuSetValuesXVals[iIndex])
		{
			// find the most common one
			SkuSetVal *pSkuSetVal =
				m_rgpSkuSetValuesXVals[iIndex]->GetMostCommon();

			// insert into the common array
			m_rgCommonValues[iIndex] = pSkuSetVal;

			// delete from the side chain
			m_rgpSkuSetValuesXVals[iIndex]->Erase(pSkuSetVal);

			// update the common set of all column values
			*m_pSkuSetCommon &= *(m_rgCommonValues[iIndex]->pSkuSet);
		}

		if (m_rgCommonValues[iIndex])
		{
			// finalize the common value for each column: it might be NULL
			// How many Skus have this column value set?
			int cSkusHasValue = m_rgpSkuSetValidate[iIndex]->countSetBits();
			// How many Skus are there?
			int cSkus = m_pSkuSetAppliesTo->countSetBits();

			if (cSkusHasValue < cSkus-cSkusHasValue)
			{
				// allocate memory for a vector for the exceptional value
				if (m_rgpSkuSetValuesXVals[iIndex] == NULL)
				{
					m_rgpSkuSetValuesXVals[iIndex] = new SkuSetValues;
					assert(m_rgpSkuSetValuesXVals);
					m_rgpSkuSetValuesXVals[iIndex]->SetValType(m_rgValTypes[iIndex]);
				}
				m_rgpSkuSetValuesXVals[iIndex]->DirectInsert(m_rgCommonValues[iIndex]);	

				// allocate memory and construct a SkuSetVal object
				SkuSetVal *pSkuSetVal = new SkuSetVal;
				assert(pSkuSetVal);
				pSkuSetVal->pSkuSet = new SkuSet();

				*(pSkuSetVal->pSkuSet) = (*m_pSkuSetAppliesTo) & 
									(~(*(m_rgCommonValues[iIndex]->pSkuSet)));

				if (INTEGER == m_rgValTypes[iIndex])
				{
					(pSkuSetVal->isVal).intVal = 0;
				}
				else
				{
					(pSkuSetVal->isVal).szVal = NULL;
				}

				m_rgCommonValues[iIndex] = pSkuSetVal;
			}
		
			// the common set of all column values is the intersection
			// of the common sets of all the columns
			*m_pSkuSetCommon &= *(m_rgCommonValues[iIndex]->pSkuSet);
		}
	}	
	
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// GetCommonValue: return the common value of a column (column count from 1)
////////////////////////////////////////////////////////////////////////////
IntStringValue
ElementEntry::GetCommonValue(int iColumn)
{
	assert(iColumn <=m_cColumns && iColumn>0);

	IntStringValue isVal;
	int iIndex = iColumn - 1;

	// no value has been specified for this column
	if (!m_rgCommonValues[iIndex])
	{
		if (INTEGER == m_rgValTypes[iIndex])
		{
			isVal.intVal = MSI_NULL_INTEGER;
		}
		else
		{
			isVal.szVal = NULL;
		}
		return isVal;
	}

	return m_rgCommonValues[iIndex]->isVal;
}

////////////////////////////////////////////////////////////////////////////
// return the SkuSet that the common values apply to
////////////////////////////////////////////////////////////////////////////
SkuSet 
ElementEntry::GetCommonSkuSet()
{
	return *m_pSkuSetCommon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\query.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       query.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// query.h
//		A simple MSI View wrapper
// 

#ifndef _MSI_SQL_QUERY_H_
#define _MSI_SQL_QUERY_H_

#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#include "msiquery.h"

/////////////////////////////////////////////////////////////////////////////
// CQuery

class CQuery
{
public:
	CQuery();
	~CQuery();

	// basic operations
	UINT Open(MSIHANDLE hDatabase, LPCTSTR szSQLFormat, ...);
	UINT Close();
	UINT Execute(MSIHANDLE hParams = NULL);
	UINT Fetch(MSIHANDLE* phRecord);
	UINT Modify(MSIMODIFY eInfo, MSIHANDLE hRec);
	UINT GetError();
	inline MSIDBERROR GetError(LPTSTR szBuf, unsigned long &cchBuf)
	{ return ::MsiViewGetError(m_hView, szBuf, &cchBuf); }
	inline bool IsOpen() { return (m_hView != 0); }
	
	UINT GetColumnInfo(MSICOLINFO eInfo, MSIHANDLE* phRec);

	// "advanced" operations
	UINT OpenExecute(MSIHANDLE hDatabase, MSIHANDLE hParam, 
		LPCTSTR szSQLFormat, ...);
	UINT FetchOnce(MSIHANDLE hDatabase, MSIHANDLE hParam, 
		MSIHANDLE* phRecord, LPCTSTR szSQLFormat, ...);

private:
	MSIHANDLE m_hView;
};	// end of CQuery

/////////////////////////////////////////////////////////////////////////////
// CManageTable -- Simple class to manage a table held in memory.  Ensures
//                 that a table is "freed" from memory for each hold count
//                 that the class knows about.  
//
//  use fAlreadyLocked=true to specify that the table that is being managed
//   has already had a hold applied
class CManageTable
{
public:
	 CManageTable(MSIHANDLE hDatabase, LPCTSTR szTable, bool fAlreadyLocked);
	~CManageTable();

	// basic operations
	UINT LockTable();       // add a hold count to the table
	UINT UnLockTable();     // release a hold count from the table
	void AddLockCount();    // some other query added a hold count, 
							//	so increase the lock count
	void RemoveLockCount(); // some other query removed a hold count, 
							// so decrease the lock count

private: // private data
	int       m_iLockCount;  // hold count on table, release called in 
							 // destructor for each hold count until 0
	TCHAR	  m_szTable[64]; // name of table held in memory
	MSIHANDLE m_hDatabase;   // handle to database
};

#endif	// _MSI_SQL_QUERY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\sku.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       Sku.cpp
//
//    This file contains the implementation of Sku class
//--------------------------------------------------------------------------

#include "wmc.h"

////////////////////////////////////////////////////////////////////////////
// Destructor: release all the key values stored in the set
//             release KeyPath string stored
////////////////////////////////////////////////////////////////////////////
Sku::~Sku()
{
	if (m_szID)
		delete[] m_szID;

	set<LPTSTR, Cstring_less>::iterator it = m_setModules.begin();
	for(; it != m_setModules.end(); ++it)
	{
		if (*it)
			delete[] (*it);
	}

	FreeCQueries();
	CloseDBHandles();
}

////////////////////////////////////////////////////////////////////////////
// FreeCQueries: close all the stored CQueries and release all the 
//               stored table names
////////////////////////////////////////////////////////////////////////////
void
Sku::FreeCQueries()
{
	map<LPTSTR, CQuery *, Cstring_less>::iterator it;
	for (it = m_mapCQueries.begin(); it != m_mapCQueries.end(); ++it)
	{
		delete[] (*it).first;
		(*it).second->Close();
		delete (*it).second;
	}
}

////////////////////////////////////////////////////////////////////////////
// CloseDBHandles: close DB Handles
////////////////////////////////////////////////////////////////////////////
void
Sku::CloseDBHandles()
{
	if (m_hSummaryInfo) MsiCloseHandle(m_hSummaryInfo);
	if (m_hDatabase) MsiCloseHandle(m_hDatabase);
	if (m_hTemplate) MsiCloseHandle(m_hTemplate);
}

////////////////////////////////////////////////////////////////////////////
// TableExists: returns true if the table has been created for this SKU
////////////////////////////////////////////////////////////////////////////
bool
Sku::TableExists(LPTSTR szTable)
{
	return (0 != m_mapCQueries.count(szTable));
}

////////////////////////////////////////////////////////////////////////////
// CreateCQuery: create a CQuery and store it together with the table name.
//				 This also marks that a table has been created.
////////////////////////////////////////////////////////////////////////////
HRESULT
Sku::CreateCQuery(LPTSTR szTable)
{
	HRESULT hr = S_OK;

	if (!TableExists(szTable))
	{
		CQuery *pCQuery = new CQuery();
		if (pCQuery != NULL)
		{
			if (ERROR_SUCCESS != 
				pCQuery->OpenExecute(m_hDatabase, NULL, TEXT("SELECT * FROM %s"), 
											szTable))
			{
				_tprintf(TEXT("Internal Error: Failed to call OpenExecute to create a ")
						 TEXT("CQuery for %s table"), szTable);
				hr = E_FAIL;
			}
			else
			{
				LPTSTR sz = _tcsdup(szTable);
				assert(szTable);
				if (sz != NULL)
					m_mapCQueries.insert(LQ_ValType(sz, pCQuery));
				else
				{
					_tprintf(TEXT("Error: Out of memory\n"));
					hr = E_FAIL;
				}
			}
		}
		else 
		{
			_tprintf(TEXT("Internal Error: Failed to create a new CQuery\n"));
			hr = E_FAIL;
		}
	}
	else
	{
#ifdef DEBUG
		_tprintf(TEXT("Table already exisits in this SKU!\n"));
#endif
		hr = S_FALSE;
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// SetOwnedModule: Add the passed-in module to the set of modules owned by
//                   this SKU
////////////////////////////////////////////////////////////////////////////
void 
Sku::SetOwnedModule(LPTSTR szModule)
{
	LPTSTR szTemp = _tcsdup(szModule);
	assert(szTemp);
	m_setModules.insert(szTemp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\query.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       query.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// query.cpp
//		Implements a simple class wrapper around a MSI view. 
// 

// this ensures that UNICODE and _UNICODE are always defined together for this
// object file
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#else
#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE
#endif
#endif
#endif

#include <windows.h>
#include <assert.h>
#include "query.h"

///////////////////////////////////////////////////////////
// constructor
CQuery::CQuery()
{
	// invalidate the handles
	m_hView = NULL;
}	// end of constructor

///////////////////////////////////////////////////////////
// destructor
CQuery::~CQuery()
{
	// if the view wasn't closed
	if (m_hView)
		::MsiCloseHandle(m_hView);
}	// end of destructor

///////////////////////////////////////////////////////////
// Open
// Pre:	database handle is valid
// Pos:	m_hView is open on databse
UINT CQuery::Open(MSIHANDLE hDatabase, LPCTSTR szSQLFormat, ...)
{
	size_t dwBuf = 512;
	TCHAR *szSQL = new TCHAR[dwBuf];
	if (!szSQL)
		return ERROR_FUNCTION_FAILED;
	
	// store the result SQL string
	va_list listSQL; 
	va_start(listSQL, szSQLFormat); 
	while (-1 == _vsntprintf(szSQL, dwBuf, szSQLFormat, listSQL))
	{
		dwBuf *= 2;
		delete[] szSQL;
		szSQL = new TCHAR[dwBuf];
		if (!szSQL)
		{
			va_end(listSQL);
			return ERROR_FUNCTION_FAILED;
		}
	}
	va_end(listSQL);

	if (m_hView)
		::MsiCloseHandle(m_hView);

	// open the view
	UINT iResult = ::MsiDatabaseOpenView(hDatabase, szSQL, &m_hView);

	delete[] szSQL;

	return iResult;
}	// end of Open

///////////////////////////////////////////////////////////
// Close
// Pre:	none
// Pos:	view handle is closed
//			SQL string is blanked
UINT CQuery::Close()
{
	UINT iResult = ERROR_SUCCESS;		// assume everything will be okay

	// close the handle and null the handle
	iResult = ::MsiViewClose(m_hView);
	
	return iResult;
}	// end of Close

///////////////////////////////////////////////////////////
// Execute
// Pre:	view handle is open
// Pos:	view is executed
//			result is returned
UINT CQuery::Execute(MSIHANDLE hParams /*= NULL*/)
{
	// execute the view and return the result
	return ::MsiViewExecute(m_hView, hParams);
}	// end of Execute

///////////////////////////////////////////////////////////
// OpenExecute
// Pre:	database handle is valid
// Pos:	m_hView is open and executed on databse
UINT CQuery::OpenExecute(MSIHANDLE hDatabase, MSIHANDLE hParam, 
						 LPCTSTR szSQLFormat, ...)
{
	size_t dwBuf = 512;
	TCHAR *szSQL = new TCHAR[dwBuf];
	if (!szSQL)
		return ERROR_FUNCTION_FAILED;
	
	// store the result SQL string
	va_list listSQL; 
	va_start(listSQL, szSQLFormat); 
	while (-1 == _vsntprintf(szSQL, dwBuf, szSQLFormat, listSQL))
	{
		dwBuf *= 2;
		delete[] szSQL;
		szSQL = new TCHAR[dwBuf];
		if (!szSQL)
		{
			va_end(listSQL);
			return ERROR_FUNCTION_FAILED;
		}
	}
	va_end(listSQL);

	if (m_hView)
		::MsiCloseHandle(m_hView);

	// open the view
	UINT iResult = ::MsiDatabaseOpenView(hDatabase, szSQL, &m_hView);

	delete[] szSQL;

	if (ERROR_SUCCESS != iResult)
		return iResult;

	return Execute(hParam);
}	// end of OpenExecute

///////////////////////////////////////////////////////////
// Fetch
// Pre:	view handle is open
//			view is executed
// Pos:	record is returned
//			result is returned
UINT CQuery::Fetch(MSIHANDLE* phRecord)
{
	// fetch from the view and return the result
	return ::MsiViewFetch(m_hView, phRecord);
}	// end of Fetch

///////////////////////////////////////////////////////////
// FetchOnce
// Pre:	database handle is valid
// Pos:	m_hView is open, executed, and one record is fetched
UINT CQuery::FetchOnce(MSIHANDLE hDatabase, MSIHANDLE hParam, 
					   MSIHANDLE* phRecord, LPCTSTR szSQLFormat, ...)
{
	size_t dwBuf = 512;
	TCHAR *szSQL = new TCHAR[dwBuf];
	if (!szSQL)
		return ERROR_FUNCTION_FAILED;
	
	// store the result SQL string
	va_list listSQL; 
	va_start(listSQL, szSQLFormat); 
	while (-1 == _vsntprintf(szSQL, dwBuf, szSQLFormat, listSQL))
	{
		dwBuf *= 2;
		delete[] szSQL;
		szSQL = new TCHAR[dwBuf];
		if (!szSQL)
		{
			va_end(listSQL);
			return ERROR_FUNCTION_FAILED;
		}
	}
	va_end(listSQL);

	if (m_hView)
		::MsiCloseHandle(m_hView);

	// open the view
	UINT iResult = ::MsiDatabaseOpenView(hDatabase, szSQL, &m_hView);
	delete[] szSQL;
	if (ERROR_SUCCESS != iResult)
		return iResult;
	
	if (ERROR_SUCCESS != (iResult = Execute(hParam)))
		return iResult;

	return Fetch(phRecord);
}	// end of FetchOnce

///////////////////////////////////////////////////////////
// Modify
// Pre:	view handle is open
//			view is executed
// Pos:	modification is done
//			result is returned
UINT CQuery::Modify(MSIMODIFY eInfo, MSIHANDLE hRec)
{
	// execute the view and return the result
	return ::MsiViewModify(m_hView, eInfo, hRec);
}	// end of GetColumnInfo

///////////////////////////////////////////////////////////
// GetError
// Pre:	view handle is open
//			view is executed

UINT CQuery::GetError()
{
	TCHAR szDummyBuf[1024];
	unsigned long cchDummyBuf = sizeof(szDummyBuf)/sizeof(TCHAR);
	// execute the view and return the result
	return ::MsiViewGetError(m_hView, szDummyBuf, &cchDummyBuf);
}	// end of GetColumnInfo

///////////////////////////////////////////////////////////
// GetColumnInfo
// Pre:	view handle is open
//			view is executed
// Pos:	record is returned
//			result is returned
UINT CQuery::GetColumnInfo(MSICOLINFO eInfo, MSIHANDLE* phRec)
{
	// execute the view and return the result
	return ::MsiViewGetColumnInfo(m_hView, eInfo, phRec);
}	// end of GetColumnInfo


/////////////////////////////////////////////////////////////////////////////
// query.cpp -- CManageTable implementation
//		Implements a simple class wrapper around a MSI table for managing
//      hold counts and will clean up all hold counts it has managed upon
//      release.  Upon creation, can specify that a table has already
//      been held in memory prior to the Class managing it.  It will add
//      a hold count for this case and then release upon class destruction 
// 
CManageTable::CManageTable(MSIHANDLE hDatabase, LPCTSTR szTable,
						   bool fAlreadyLocked) : m_hDatabase(hDatabase),
						   m_iLockCount(0)
{
	assert(m_hDatabase != 0);

	if (fAlreadyLocked)
		m_iLockCount++; // add a hold count for the table, we're managing after a HOLD
	if (lstrlen(szTable) +1 > sizeof(m_szTable)/sizeof(TCHAR))
		m_szTable[0] = '\0'; // set failure state, buffer not big enough for string
	else
		lstrcpy(m_szTable, szTable);
}

CManageTable::~CManageTable()
{
	// check failure state
	if (m_szTable[0] == '\0')
	{
		m_iLockCount = 0;
		return;
	}

	// clean up all hold counts that this class is managing upon release
	CQuery qUnLock;
	for (int i = 1; i <= m_iLockCount; i++)
	{
		qUnLock.OpenExecute(m_hDatabase, 0, 
								TEXT("ALTER TABLE `%s` FREE"), m_szTable);
	}
	m_iLockCount = 0; // reset
}

UINT CManageTable::LockTable()
{
	// check failure state
	if (m_szTable[0] == '\0')
		return ERROR_FUNCTION_FAILED;

	assert(m_iLockCount >= 0);
	CQuery qLock;
	UINT iStat = qLock.OpenExecute(m_hDatabase, 0,
								TEXT("ALTER TABLE `%s` HOLD"), m_szTable);
	if (ERROR_SUCCESS == iStat)
		m_iLockCount++; // only add to lock count if successful
	return iStat;
}

UINT CManageTable::UnLockTable()
{
	// check failure state
	if (m_szTable[0] == '\0')
		return ERROR_FUNCTION_FAILED;

	assert(m_iLockCount > 0);
	CQuery qUnLock;
	UINT iStat = qUnLock.OpenExecute(m_hDatabase, 0,
								TEXT("ALTER TABLE `%s` FREE"), m_szTable);
	if (ERROR_SUCCESS == iStat)
		m_iLockCount--; // only release lock count if successful
	return iStat;
}

void CManageTable::AddLockCount()
{
	m_iLockCount++; // HOLD added to this table by an external query
}

void CManageTable::RemoveLockCount()
{
	m_iLockCount--; // FREED by an external query
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\mainfuncs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       mainFuncs.h
//              This file contains the main function and functions that 
//				process <Information> <Directories> <InstallLEvels <Features> 
//              and their subentities
//--------------------------------------------------------------------------

#ifndef XMSI_MAINFUNCS_H
#define XMSI_MAINFUNCS_H

#include "wmc.h"
#include "Utilities.h"

HRESULT ProcessStart(BSTR);
HRESULT ProcessProductFamily(PIXMLDOMNode &);
	HRESULT ProcessSkuManagement(PIXMLDOMNode &);
		HRESULT ProcessSkus(PIXMLDOMNode &pNodeSkus, int *pcSkus);
			HRESULT ProcessSku(PIXMLDOMNode &pNodeSku, int iIndex, int cSkus);
		HRESULT ProcessSkuGroups(PIXMLDOMNode &pNodeSkuGroups, int cSkus);
			HRESULT ProcessSkuGroup(PIXMLDOMNode &pNodeSkuGroup, LPTSTR szID,
								   set<LPTSTR, Cstring_less> *pSet, int cSkus);
	HRESULT ProcessInformation_SKU(PIXMLDOMNode &pNodeInformation, 
						   const IntStringValue *isVal_In, SkuSet *pskuSet);
		HRESULT ProcessInstallerVersionRequired_SKU
				(PIXMLDOMNode &pNodeInstallerVersionRequired, 
						   const IntStringValue *isVal_In, SkuSet *pskuSet);
		HRESULT ProcessPackageFilename_SKU(PIXMLDOMNode &pNodePackageFilename, 
										const IntStringValue *isVal_In, 
										SkuSet *pskuSet);
		HRESULT ProcessInformationChildren_SKU(PIXMLDOMNode &pNodeInfoChild, 
									   const IntStringValue *pisVal_In, 
									   SkuSet *pskuSet);
	HRESULT ProcessDirectories_SKU(PIXMLDOMNode &pNodeDirectories, 
								   const IntStringValue *pIsVal, 
								   SkuSet *pSkuSet);
		HRESULT ProcessDirectory_SKU(PIXMLDOMNode &pNodeDirectory, 
		 							 IntStringValue isValParentDir, 
									 SkuSet *pSkuSet);
			HRESULT ProcessName(PIXMLDOMNode &pNodeName, int iColumn, 
								ElementEntry *pEE, SkuSet *pSkuSet);
			HRESULT ProcessTargetDir(PIXMLDOMNode &pNodeTargetDir, int iColumn, 
									 ElementEntry *pEE, SkuSet *pSkuSet);
			HRESULT ProcessTargetProperty(PIXMLDOMNode &pNodeTargetProperty, 
										 int iColumn, ElementEntry *pEE,
										 SkuSet *pSkuSet);
	HRESULT ProcessInstallLevels_SKU(PIXMLDOMNode &pNodeInstallLevels, 
									const IntStringValue *pisVal, 
									SkuSet *pSkuSet);
	HRESULT ProcessFeatures_SKU(PIXMLDOMNode &pNodeFeatures, 
						const IntStringValue *pisVal, SkuSet *pSkuSet);
		HRESULT ProcessFeature_SKU(PIXMLDOMNode &pNodeFeature, 
								   IntStringValue isValParentFeature, 
								   SkuSet *pSkuSet);
			HRESULT ProcessDisplayState_SKU(PIXMLDOMNode &pNodeDisplayState, 
											int iColumn, ElementEntry *pEE, 
											SkuSet *pSkuSet);
			HRESULT ProcessState_SKU(PIXMLDOMNode &pNodeState, int iColumn, 
							 ElementEntry *pEE, SkuSet *pSkuSet);
			HRESULT ProcessILevelCondition(PIXMLDOMNode &pNodeFeature, 
										   LPTSTR szFeature, SkuSet *pSkuSet);
			HRESULT ProcessUseModule_SKU(PIXMLDOMNode &pNodeUseModule, 
										 IntStringValue isValFeature,  
										 SkuSet *pSkuSet);
				HRESULT ProcessTakeOwnership(PIXMLDOMNode &pNodeTakeOwnership, 
					int iColumn, ElementEntry *pEE, SkuSet *pSkuSet);
				HRESULT ProcessModule_SKU(PIXMLDOMNode &pNodeModule, FOM *pFOM, 
										  SkuSetValues *pSkuSetValuesOwnership,
										  SkuSet *pSkuSet);
				HRESULT ProcessComponentRel(PIXMLDOMNode &pNodeModule, 
										FOM *pFOM,
										SkuSetValues *pSkuSetValuesOwnership,
										SkuSet *pSkuSet);
HRESULT ProcessComponents();
///////////////////////////////////////////////////////////////////////////////
// Data structures dealing with creating DB tables
typedef struct
{
	UINT uiInstallerVersion;
	LPTSTR szTemplateDB;
} TemplateDB;

TemplateDB rgTemplateDBs[] = {
	{120,	TEXT("d:\\nt\\admin\\darwin\\src\\msitools\\xmsi\\Schema.msi")	}
};

class TemplateDBSchema
{
public:
	MSIHANDLE m_hTemplate;
	TemplateDBSchema():m_hTemplate(NULL)
	{
		m_pmapszSQLCreates = new map<LPTSTR, LPTSTR, Cstring_less>();
		assert(m_pmapszSQLCreates != NULL);
	}

private:
	map<LPTSTR, LPTSTR, Cstring_less> *m_pmapszSQLCreates;
};
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// <ProductFamily>
Node_Func_H_XIS rgNodeFuncs_ProductFamily_SKU[] = {
	{		INFORMATION,				ProcessInformation_SKU			},
	{		DIRECTORIES,				ProcessDirectories_SKU			},
	{		INSTALLLEVELS,				ProcessInstallLevels_SKU		},
	{		FEATURES,					ProcessFeatures_SKU				}
};
const int cNodeFuncs_ProductFamily_SKU =
			 sizeof(rgNodeFuncs_ProductFamily_SKU)/sizeof(Node_Func_H_XIS);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// <Information>

Node_Func_H_XIS rgNodeFuncs_Information_SKU[]= {
	{		INSTALLERVERSIONREQUIRED,	ProcessInstallerVersionRequired_SKU	},
	{		PACKAGEFILENAME,			ProcessPackageFilename_SKU			}
};

const int cNodeFuncs_Information_SKU = 
			sizeof(rgNodeFuncs_Information_SKU)/sizeof(Node_Func_H_XIS);

Node_Func_H_XIS rgNodeFuncs_Information2_SKU[]= {
	{	CODEPAGE,		ProcessInformationChildren_SKU	},
	{	PRODUCTNAME,	ProcessInformationChildren_SKU	},
	{	PRODUCTCODE,	ProcessInformationChildren_SKU	},
	{	UPGRADECODE,	ProcessInformationChildren_SKU	},
	{	PRODUCTVERSION,	ProcessInformationChildren_SKU	},
	{	MANUFACTURER,	ProcessInformationChildren_SKU	},
	{	KEYWORDS,		ProcessInformationChildren_SKU	},
	{	TEMPLATE,		ProcessInformationChildren_SKU	}
};

const int cNodeFuncs_Information2_SKU = 
			sizeof(rgNodeFuncs_Information2_SKU)/sizeof(Node_Func_H_XIS);

// All of the following children of <Information> will be processed by 
//	a generic function
INFO_CHILD rgChildren_Information[] = {
/* NodeIndex		szPropertyName		uiDesintation	uiPropertyID  vt		bIsGUID	*/
{CODEPAGE,		TEXT("Codepage"),		SUMMARY_INFO,	PID_CODEPAGE, VT_I2,	false	},
{PRODUCTNAME,	TEXT("ProductName"),	BOTH,			PID_SUBJECT,  VT_LPSTR,	false	},
{PRODUCTCODE,	TEXT("ProductCode"),	PROPERTY_TABLE,	0,			  VT_LPSTR,	true	},
{UPGRADECODE,	TEXT("UpgradeCode"),	PROPERTY_TABLE,	0,			  VT_LPSTR,	true	},
{PRODUCTVERSION,TEXT("ProductVersion"),	PROPERTY_TABLE,	0,			  VT_LPSTR,	false	},
{MANUFACTURER,	TEXT("Manufacturer"),	BOTH,			PID_AUTHOR,	  VT_LPSTR,	false	},
{KEYWORDS,		TEXT("Keywords"),		SUMMARY_INFO,	PID_KEYWORDS, VT_LPSTR,	false	},
{TEMPLATE,		TEXT("Template"),		SUMMARY_INFO,	PID_TEMPLATE, VT_LPSTR,	false	}
};


const int cChildren_Information = 
				sizeof(rgChildren_Information)/sizeof(INFO_CHILD);

AttrBit_SKU rgAttrBits_WordCount[] = {
{	LONGFILENAMES,		1	},
{	SOURCECOMPRESSED,	2	}
};

const int cAttrBits_WordCount = 
			sizeof(rgAttrBits_WordCount)/sizeof(AttrBit_SKU);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// <Directory>
//	 
Node_Func_H_XIES rgNodeFuncs_Directory[] = {
/*	NodeIndex		ProcessFunc				ValueType		   column #		*/
{	NAME,			ProcessName,			 STRING,		2/*DefaultDir*/	},
{	TARGETDIR,		ProcessTargetDir,		 STRING,		2/*DefaultDir*/	},
{	TARGETPROPERTY,	ProcessTargetProperty,	 STRING,		1/*Directory*/	}
};


const int cNodeFuncs_Directory = 
	sizeof(rgNodeFuncs_Directory)/sizeof(Node_Func_H_XIES);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// <Feature>
//	 
Node_Func_H_XIES rgNodeFuncs_Feature_SKU[] = {
/*	 NodeIndex			ProcessFunc			ValueType		   column #	*/
{	TITLE,			ProcessSimpleElement,	 STRING,		1/*Title*/		 },
{	DESCRIPTION,	ProcessSimpleElement,	 STRING,		2/*Description*/ },
{	DISPLAYSTATE,	ProcessDisplayState_SKU, INTEGER,		3/*Display*/	 },
{	ILEVEL,			ProcessRefElement,		 INSTALL_LEVEL,	4/*Level*/		 },
{	DIR,			ProcessRefElement,		 STRING,		5/*Description*/ },
{	STATE,			ProcessState_SKU,		 INTEGER,		6/*DisplayState*/}
};


const int cNodeFuncs_Feature_SKU = 
	sizeof(rgNodeFuncs_Feature_SKU)/sizeof(Node_Func_H_XIES);

EnumBit rgEnumBits_Favor_Feature[] = {
{	TEXT("Local"),		0									},
{	TEXT("Source"),		msidbFeatureAttributesFavorSource	},
{	TEXT("Parent"),		msidbFeatureAttributesFollowParent	}
};

const int cEnumBits_Favor_Feature = 
			sizeof(rgEnumBits_Favor_Feature)/sizeof(EnumBit);

EnumBit rgEnumBits_Advertise_Feature[] = {
{	TEXT("None"),				0											 },
{	TEXT("Favor"),				msidbFeatureAttributesFavorAdvertise		 },
{	TEXT("Disallow"),			msidbFeatureAttributesDisallowAdvertise		 },
{	TEXT("NoUnsupported"),		msidbFeatureAttributesNoUnsupportedAdvertise },
{	TEXT("FavorNoUnSupported"),	msidbFeatureAttributesFavorAdvertise |
								msidbFeatureAttributesNoUnsupportedAdvertise },
};

const int cEnumBits_Advertise_Feature = 
			sizeof(rgEnumBits_Advertise_Feature)/sizeof(EnumBit);

AttrBit_SKU rgAttrBits_Feature[] = {
{	DISALLOWABSENT,		msidbFeatureAttributesUIDisallowAbsent	},
};

const int cAttrBits_Feature = 
			sizeof(rgAttrBits_Feature)/sizeof(AttrBit_SKU);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// <UseModule>
//	 
Node_Func_H_XIES rgNodeFuncs_UseModule[] = {
/*	 NodeIndex			ProcessFunc			ValueType		  column #	*/
{  TAKEOWNERSHIP,	ProcessTakeOwnership,	 INTEGER,			1	},
};

const int cNodeFuncs_UseModule = 
	sizeof(rgNodeFuncs_UseModule)/sizeof(Node_Func_H_XIES);

AttrBit_SKU rgAttrBits_TakeOwnership[] = {
{	OWNSHORTCUTS,				1	},
{	OWNCLASSES,					2	},
{	OWNTYPELIBS,				4	},
{	OWNEXTENSIONS,				8	},
{	OWNQUALIFIEDCOMPONENTS,		16	},
};

const int cAttrBits_TakeOwnership = 
			sizeof(rgAttrBits_TakeOwnership)/sizeof(AttrBit_SKU);
//////////////////////////////////////////////////////////////////////////////

LPTSTR g_szInputSkuFilter = NULL;
SkuSet *g_pskuSet = NULL;
int g_cSkus = 0;
Sku **g_rgpSkus = NULL;
IXMLDOMNode *g_pNodeProductFamily = NULL;

// assume the user doesn't want to see the extra information
bool g_bVerbose = false;			
// assume the user doesn't only want to validate the input WIML package
bool g_bValidationOnly = false;	
FILE *g_pLogFile = NULL;	// assume the user doesn't specify a log file

map<LPTSTR, SkuSet *, Cstring_less> g_mapSkuSets;
map<LPTSTR, SkuSetValues *, Cstring_less> g_mapDirectoryRefs_SKU;
map<LPTSTR, SkuSetValues *, Cstring_less> g_mapInstallLevelRefs_SKU;
map<LPTSTR, Component *, Cstring_less> g_mapComponents;

// for each table type, there is a counter that keeps 
// incrementing when each time the function is called
// with that particular table name
map<LPTSTR, int, Cstring_less> g_mapTableCounter;


NODE rgXMSINodes[] = 
{
/* a handy place holder */
	{ NULL, NULL, false, -1},

{TEXT("ProductFamily"),		NULL,	true,	1},		
	{TEXT("SkuManagement"),		NULL,	true,	1},	
		{TEXT("SKUs"),		NULL,	true,	1},
			{TEXT("SKU"),	TEXT("ID"),		true,	0},
		{TEXT("SkuGroups"),		NULL,	false,	1},
			{TEXT("SkuGroup"),	TEXT("ID"),	false,	0},
	{TEXT("Information"),		NULL,	true,	1},
		{TEXT("ProductName"),				TEXT("Value"),	true,	1},
		{TEXT("ProductCode"),				TEXT("Value"),	true,	1},
		{TEXT("UpgradeCode"),				TEXT("Value"),	true,	1},
		{TEXT("ProductVersion"),			TEXT("Value"),	true,	1},
		{TEXT("Manufacturer"),				TEXT("Value"),	true,	1},
		{TEXT("Keywords"),					TEXT("Value"),	true,	1},
		{TEXT("Template"),					TEXT("Value"),	true,	1},
		{TEXT("InstallerVersionRequired"),	TEXT("Value"),	true,	1},
		{TEXT("LongFilenames"),				NULL,			false,	1},
		{TEXT("SourceCompressed"),			NULL,			false,	1},
		{TEXT("Codepage"),					TEXT("Value"),	true,	1},
		{TEXT("SummaryCodepage"),			TEXT("Value"),	false,	1},
		{TEXT("PackageFilename"),			TEXT("Value"),	false,	1},
	{TEXT("Directories"),		NULL,	true,	1},
		{TEXT("Directory"),		TEXT("ID"),		false,	0},
			{TEXT("Name"),				NULL,		true,	1},
			{TEXT("TargetDir"),			NULL,		false,	1},
			{TEXT("TargetProperty"),	TEXT("Value"),	false, 1},
	{TEXT("InstallLevels"),		NULL,	true,	1},
		{TEXT("InstallLevel"),	TEXT("ID"),		true,	0},
	{TEXT("Features"),			NULL,	true,	1},
		{TEXT("Feature"),	TEXT("ID"),		true,	0},		
			{TEXT("Title"),				TEXT("Value"),		false,	1},
			{TEXT("Description"),		TEXT("Value"),		false,	1},
			{TEXT("DisplayState"),		TEXT("Value"),		false,	1},
/* there are 2 nodes corresponde to <ILevel> entity. The first one is given 
	the NodeIndex ILEVEL which correspondes Level column in Feature table. 
	The second one is given the NodeIndex ILEVELCONDITION which corresponds to
	the Level column in Condition table */
			{TEXT("ILevel[not(@Condition)]"),	TEXT("Ref"),	true,	1},
			{TEXT("ILevel[@Condition]"),		TEXT("Ref"),	false,	0},
			{TEXT("Dir"),				TEXT("Ref"),		false,	1},
			{TEXT("State"),				NULL,				false,	1},
				{TEXT("Favor"),				TEXT("Value"),		false,	1},
				{TEXT("Advertise"),			TEXT("Value"),		false,	1},
				{TEXT("DisallowAbsent"),	NULL,				false,	1},
			{TEXT("UseModule"),				TEXT("Ref"),	false,	0},
				{TEXT("TakeOwnership"),		NULL,			false,	1},
					{TEXT("OwnShortcuts"),		NULL,				false,	1},
					{TEXT("OwnClasses"),		NULL,				false,	1},
					{TEXT("OwnTypeLibs"),		NULL,				false,	1},
					{TEXT("OwnExtensions"),		NULL,				false,	1},
					{TEXT("OwnQualifiedComponents"),	NULL,		false,	1},
	{TEXT("Modules"),			NULL,	true,	1},
		{TEXT("Module"),		TEXT("ID"),		true,	0},		
			{TEXT("Component"),		TEXT("ID"),		true,	0},	
				{TEXT("GUID"),					TEXT("Value"),		true,	1},
				{TEXT("ComponentDir"),			TEXT("Ref"),		true,	1},
				{TEXT("CreateFolder"),			TEXT("Ref"),		false,	0},
					{TEXT("LockPermission"),	NULL,				false,	0},
				{TEXT("ComponentAttributes"),	NULL,				false,	1},
					{TEXT("RunFrom"),			TEXT("Value"),		false,	1},
					{TEXT("SharedDllRefCount"),	NULL,				false,	1},
					{TEXT("Permanent"),			NULL,				false,	1},
					{TEXT("Transitive"),		NULL,				false,	1},
					{TEXT("NeverOverwrite"),	NULL,				false,	1},
				{TEXT("Condition"),				TEXT("Value"),		false,	1},
				{TEXT("File"),				TEXT("ID"),		false,	0},
					{TEXT("FileName"),			NULL,			true,	1},
					{TEXT("FileSize"),			TEXT("Value"),	false,	1},
					{TEXT("FileVersion"),		NULL,			false,	1},
					{TEXT("FileLanguage"),		TEXT("Value"),	false,	1},
					{TEXT("FileAttributes"),	NULL,			false,	1},
						{TEXT("ReadOnly"),		NULL,			false,	1},
						{TEXT("Hidden"),		NULL,			false,	1},
						{TEXT("System"),		NULL,			false,	1},
						{TEXT("Vital"),			NULL,			false,	1},
						{TEXT("Checksum"),		NULL,			false,	1},
						{TEXT("Compressed"),	TEXT("Value"),	false,	1},
					{TEXT("Font"),				TEXT("Title"),	false,	1},
					{TEXT("BindImage"),			TEXT("Path"),	false,	1},
					{TEXT("SelfReg"),			TEXT("Cost"),	false,	1},
				{TEXT("MoveFile"),				TEXT("ID"),		false,	0},
					{TEXT("SourceName"),		TEXT("Value"),	false,	1},
					{TEXT("DestName"),			TEXT("Value"),	false,	1},
					{TEXT("SourceFolder"),		TEXT("Value"),	false,	1},
					{TEXT("DestFolder"),		TEXT("Value"),	true,	1},
					{TEXT("CopyFile"),			NULL,			false,	1},
				{TEXT("RemoveFile"),			TEXT("ID"),		false,	0},
					{TEXT("FName"),				TEXT("Value"),	false,	1},
					{TEXT("DirProperty"),		TEXT("Value"),	true,	1},
					{TEXT("InstallMode"),		TEXT("Value"),	true,	1},
				{TEXT("IniFile"),				TEXT("ID"),		false,	0},
					{TEXT("FName"),				TEXT("Value"),	true,	1},
					{TEXT("DirProperty"),		TEXT("Value"),	false,	1},
					{TEXT("Section"),			TEXT("Value"),	true,	1},
					{TEXT("Key"),				TEXT("Value"),	true,	1},
					{TEXT("Value"),				TEXT("Value"),	true,	1},
					{TEXT("Action"),			TEXT("Type"),	true,	1},
				{TEXT("RemoveIniFile"),			TEXT("ID"),		false,	0},
					{TEXT("FName"),				TEXT("Value"),	true,	1},
					{TEXT("DirProperty"),		TEXT("Value"),	false,	1},
					{TEXT("Value"),				TEXT("Value"),	false,	1},
					{TEXT("Action"),			TEXT("Type"),	true,	1},
				{TEXT("Registry"),				NULL,			false,	0},
					{TEXT("Delete"),			NULL,			false,	0},
					{TEXT("Create"),			NULL,			false,	0},
};

#endif //XMSI_MAINFUNCS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\skufilterexprnode.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:     SKUFilterExprNode.h
// 
//    This file contains the definition of Class SKUFilterExprNode --
//	    a temporary solution for parsing Sku filter expressions	
//--------------------------------------------------------------------------


#ifndef XMSI_SKUFILTEREXPRNODE_H
#define XMSI_SKUFILTEREXPRNODE_H

#include <Windows.h>
#include <tchar.h>
#include <stdio.h>
#include <assert.h>
#include "SkuSet.h"

class SKUFilterExprNode  
{
private:

    static LPCTSTR letterCharB; // list of valid chars for the beginning of an identifier
    static LPCTSTR letterChar;  // list of valid chars for an identifier

    SKUFilterExprNode(SKUFilterExprNode* parent);
    bool SKUFilterExprNode::ConsumeChar(LPTSTR *input, TCHAR c, bool force);
    bool SKUFilterExprNode::ParseExpression(LPTSTR *input);
    bool SKUFilterExprNode::ParseTerm(LPTSTR *input);
    bool SKUFilterExprNode::ParseFactor(LPTSTR *input);
    bool SKUFilterExprNode::ParsePrimitive(LPTSTR *input);

public:

	SkuSet *m_pSkuSet;
    LPTSTR name,                 // the identifier at the node if the node is Leaf
          errpos;               // NULL is subtree was successfully parsed, otherwise points to error char in input
    TCHAR errstr[21];            // contains an error message is errpos!=0
    enum {  Leaf,
            Union,
            Intersection,
            Inversion } ntype;  // the type of the node
    enum ExprType { 
            Filter,
            Expression,         // type for commanding the parser what grammar part to parse next
            Term, 
            Factor, 
            Primitive };
    SKUFilterExprNode *left, *right;    // the two subtrees

	SKUFilterExprNode(LPTSTR *input, ExprType etype);
	virtual ~SKUFilterExprNode();
    bool SKUFilterExprNode::SKUFilterPass(LPTSTR id);
	void Print();

    static bool IsValidSKUGroupID(LPTSTR id);
};

#endif // XMSI_SKUFILTEREXPRNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\skufilterexprnode.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       SKUFilterExprNode.cpp
//
//    This file contains the implementation of SKUFilterExprNode class 
//
// This class implements the SKU Filter language parser and the
// SKU filter logic.
//
// USAGE:
//    - create a root node like this:
//      SKUFilterExprNode *root = new SKUFilterExprNode(&input, SKUFilterExprNode::Filter);
//      with input being a char* pointing to the beginning of the NULL terminated
//      filter expression C string, e.g.
//      char *input = argv[1];
//      When the constructor returns the expression was already parsed and an
//      Astract Syntax Tree created.
//    - if (root->errpos == 0) the expression could be parsed correctly. In this case
//      you can use the Filter with "SKUFilterPass".
//      if (root->errpos != 0) the expression could not be parsed correctly. The AST is invalid
//      in this case. root->errpos then points to the char that caused the parser to fail.
//      root->errstr then contains a C string error message.
//    - In any case, don't forget to free the tree with "delete root".
//
// MECHANICS:
//      The class implements a node of the AST for the following LL(1) grammar.
//
//      Letter 		::= ['a'-'z']|['A'-'Z']
//      Identifier 	::= ('_'|Letter) ('_'|Letter|['0'-'9'])*
//      Primitive	::= Identifier | '(' Expression ')'
//      Factor		::= '!' Primitive | Primitive
//      Term 		::= Factor TermTail
//      TermTail	::= '+' Factor TermTail | Lambda
//      Expression	::= Term ExprTail
//      ExprTail 	::= ',' Term ExprTail | Lambda
//      Filter		::= Expression
//
//      The parser is a simple recursive descent parser building a binary AST, descending
//      to the right, e.g. A+B+C results in
//                                                  +
//                                                 / \
//                                                A   +
//                                                   / \
//                                                  B   C 
//--------------------------------------------------------------------------

#include "SKUFilterExprNode.h"
#include "wmc.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

// initialization of the static constants
// letterCharB contains all characters that are allowed to appear at the beginning of a
// SKU/SKUGroup identifier. letterChar all valid chars.
LPCTSTR SKUFilterExprNode::letterCharB = TEXT("_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
LPCTSTR SKUFilterExprNode::letterChar  = TEXT("_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");


SKUFilterExprNode::SKUFilterExprNode(SKUFilterExprNode* parent)
// a private, special kind of copy constructor. Called whenever a node discovers
// that it has to "push down" the AST created so far because a higher level operator
// was discovered. Nodes always "push down" to the left and continue parsing in the
// right subtree.
// This "copy" constructor almost does the job of a normal copy constructor, except
// it MOVES the name to the child instead of COPYING it.
{
    assert(parent);
    left   = parent->left;      // copy all attributes
    right  = parent->right;
    name   = parent->name;
//----------------------------------------------------------------------------
	m_pSkuSet = new SkuSet(*(parent->m_pSkuSet));
//----------------------------------------------------------------------------
    ntype  = parent->ntype;
    errpos = NULL;                 // we don't need to copy, errpos is known to be zero

    parent->name = NULL;           // kill old name pointer, we don't want the parent to keep the name
}

SKUFilterExprNode::SKUFilterExprNode(LPTSTR *input, ExprType antype)
// the main constructor and the main routine of the parser
// after initializing the routine continues parsing of the input
// with the Grammar part that it is instructed through the "antype" parameter.
//
// INPUT MUSTN'T BE NULL AND MUSTN'T POINT TO A NULL POINTER!!!
// (it is allowed to point to a pointer to a empty string though!)
{
    assert(input && *input); // make sure input is ok
    left = right = NULL;
    name = errpos = NULL;
//-----------------------------------------------------------------------------
	m_pSkuSet = new SkuSet(g_cSkus);
	assert(m_pSkuSet != NULL);
//-----------------------------------------------------------------------------

    ntype = Leaf;

    switch (antype) {
    case Filter:
        // the outer wrapper case, only called on the root from the outside
        while (_istspace(**input)) (*input)++;              // skip whitespace
        if (ParseExpression(input) && **input) {        // parse the expression and make
            _stprintf(errstr, TEXT("Syntax Error!"));   // sure that afterwards there are no
            errpos = *input;                            // input characters left, i.e. **input==0
        }
        break;
    case Expression:
        ParseExpression(input); // we are a subnode having to accept an Expression
        break;
    case Term:
        ParseTerm(input);       // we are a subnode having to accept an Term
        break;
    case Factor:
        ParseFactor(input);     // we are a subnode having to accept an Factor
        break;
    case Primitive:
        ParsePrimitive(input);  // we are a subnode having to accept an Primitive
        break;
    }
    // after parsing our subtree we might have encoutered an error in one of out
    // subtrees ... therefore we have to propagate to error up to our level
    if (left && left->errpos) {
        errpos  = left->errpos;
        _tcscpy(errstr, left->errstr);
    } else if (right && right->errpos) {
        errpos  = right->errpos;
        _tcscpy(errstr, right->errstr);;
    }
}

SKUFilterExprNode::~SKUFilterExprNode()
// simple destructor, recursively freeing our subtrees and then our name string
{
    if (left)
	{
		delete left;
		left = NULL;
	}
    if (right) 
	{
		delete right;
		right = NULL;
	}
    if (name) 
	{
		delete[] name;
		name = NULL;
	}

	if (m_pSkuSet)
	{
		delete m_pSkuSet;
		m_pSkuSet = NULL;
	}
}

bool SKUFilterExprNode::ConsumeChar(LPTSTR *input, TCHAR c, bool forceError)
// small helper routine
// If c is the current character it is consumed with any following whitespace and
// TRUE returned. If c is not the current character the input is left as is and
// FALSE returned. If forceError is set to TRUE an additional error message is created
// in this case.
{
    if (**input == c) {
        (*input)++;                         // consume c
        while (_istspace(**input)) (*input)++;  // consume any following whitespace
        return true;
    } else 
        if (forceError) {
            _stprintf(errstr, TEXT("\'%c\' expected!"), c);
            errpos = *input;
        }
    return false;
}

bool SKUFilterExprNode::ParseExpression(LPTSTR *input)
// parses an expression and returns TRUE on success, FALSE on failure.
{
    bool ok = true;
    if (ParseTerm(input)) {                     // parse a Term
        if (**input && **input != TEXT(')')) {            // if there is input left and it's not a ')'
            if (ConsumeChar(input,TEXT(','),true)) {          // it has to be a ','
                left  = new SKUFilterExprNode(this);        // if it is push down to the left
                right = new SKUFilterExprNode(input, Expression);// and continue to the right
                ntype = Union;                      // at this level we are a Union
//-----------------------------------------------------------------------------
				*m_pSkuSet = *(left->m_pSkuSet) | *(right->m_pSkuSet);
//-----------------------------------------------------------------------------
                ok = right && (right->errpos == 0); // propagate a potential error
            } else ok = false;
        }
    } else ok = false; // the Term is invalid and so are we
    return ok;
}

bool SKUFilterExprNode::ParseTerm(LPTSTR *input)
// parses a term and returns TRUE on success, FALSE on failure.
{
    bool ok = true;
    if (ParseFactor(input)) {                           // parse a Factor
        if (**input && ConsumeChar(input, TEXT('+'), false)) {  // if there is input left and it's a '+'
            left  = new SKUFilterExprNode(this);        // push down to the left
            right = new SKUFilterExprNode(input, Term); // and continue to the right
            ntype = Intersection;                       // at this level we are an Intersection
//-----------------------------------------------------------------------------
				*m_pSkuSet = *(left->m_pSkuSet) & *(right->m_pSkuSet);
//-----------------------------------------------------------------------------
            ok = right && (right->errpos == 0);         // propagate a potential error
        }
    } else ok = false; // the Factor is invalid and so are we
    return ok;
}

bool SKUFilterExprNode::ParseFactor(LPTSTR *input)
// parses a factor and returns TRUE on success, FALSE on failure.
{
    bool ok = false;
    if (ConsumeChar(input,TEXT('!'),false)) {                 // if we start with a '!'
        ntype = Inversion;                              // we an Inversion
        left = new SKUFilterExprNode(input, Primitive); // create new node and parse the Primitive
        ok = left && (left->errpos == 0);       // propagate a potential error
//-----------------------------------------------------------------------------
		*m_pSkuSet = ~(*(left->m_pSkuSet));
//-----------------------------------------------------------------------------
    } else ok = ParsePrimitive(input); // we are not an Inversion so we simply go ahead with the Primitive
    return ok;
}

bool SKUFilterExprNode::ParsePrimitive(LPTSTR *input)
// parses a primitive and returns TRUE on success, FALSE on failure.
{
    LPTSTR p;
    int l;

    if (!ConsumeChar(input, TEXT('('), false)) {    // if we are not starting with a '(' we simply parse the identifier
        p = *input;                         // save the beginning of the identifier
        if (*p && _tcschr(letterCharB,*p)) { // check whether the first char is valid

            // advance input to one char after the last character of the identifier
            while ((**input) && (_tcschr(letterChar,**input))) (*input)++; 

            l = *input - p;                     // calculate length of identifier
            name = new TCHAR[l+1];        // allocate name + null byte
            assert(name);                      // make sure we have the memory
            _tcsncpy(name, p, l);                // copy name
            *(name + l) = NULL;                    // manually set null byte
            while (_istspace(**input)) (*input)++;  // skip trailing whitespace
            ntype = Leaf;                       // we are a Leaf (yeah!)
            if (!IsValidSKUGroupID(name)) {     // check whether the name is a known SKU group or SKU
                _stprintf(errstr, TEXT("Unknown SKU Group!"));
                errpos = p;
                return false;
            } else
			{
//-----------------------------------------------------------------------------
				// needs to make a copy so that the destructor of SKUFilterNode
				// won't destroy the SkuSet stored globally
				*m_pSkuSet = *g_mapSkuSets[name];
//-----------------------------------------------------------------------------
				return true;                 // it is a valid SKU group, so we are fine
			}
        }
    } else {
        // we had a '(' so we expect a valid expression and then a closing ')'
        return ParseExpression(input) && ConsumeChar(input, TEXT(')'), true);
    }
    // if we didn't return yet at this point, we haven't found a proper identifier
    _stprintf(errstr, TEXT("Identifier expected!"));
    errpos = *input;
    return false;
}

void SKUFilterExprNode::Print()
// simply prints the AST in a "(OR,A,(OR,B,C))" kind of fashion
{
    switch (ntype) {
        case Leaf:
            _tprintf(TEXT("%s"),name);
            return;
        case Union:
            _tprintf(TEXT("(OR,"),name);
            break;
        case Intersection:
            _tprintf(TEXT("(AND,"),name);
            break;
        case Inversion:
            _tprintf(TEXT("(NOT,"),name);
            break;
        default:
            return;
    }
    if (left) left->Print();
    if (right) {
        _tprintf(TEXT(","));
        right->Print();
    }
    _tprintf(TEXT(")"));
}

bool SKUFilterExprNode::IsValidSKUGroupID(LPTSTR id)
// checks whether ID is a valid SKU group or SKU identifier
{
    // insert the appropriate code here
    return (0 != g_mapSkuSets.count(id));
}

bool SKUFilterExprNode::SKUFilterPass(LPTSTR id)
// performs the actual Filter logic after the AST has been built
// returns false if the the parameter does not pass the filter or the
// AST is invalid, otherwise TRUE.
{
    bool ok = false;
    if (!errpos) {
        switch (ntype) {
            case Leaf:
                // insert the appropriate code here:
                // set ok to true if id is member of the SKU group [name]
                // or if id is the actual SKU [name]
                break;
            case Union:
                assert(left && right);
                ok = left->SKUFilterPass(id) || right->SKUFilterPass(id);
                break;
            case Intersection:
                assert(left && right);
                ok = left->SKUFilterPass(id) && right->SKUFilterPass(id);
                break;
            case Inversion:
                assert(left);
                ok = !left->SKUFilterPass(id);
                break;
        }
    }
    return ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\skuset.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:     SkuSet.h
// 
//    This file contains the definition of Class SkuSet. It is basically
//	  a bit field with arbitrary length.
//--------------------------------------------------------------------------


#ifndef XMSI_SKUSET_H
#define XMSI_SKUSET_H

#include <Windows.h>
#include <tchar.h>
#include <stdio.h>
#include <limits.h>
#include <assert.h>

// # bits of ULONG
const int SKUSET_UNIT_SIZE=sizeof(ULONG)*CHAR_BIT;

class SkuSet {

	friend SkuSet operator & (const SkuSet &a, const SkuSet &b);
	friend SkuSet operator | (const SkuSet &a, const SkuSet &b);
	friend SkuSet operator ^ (const SkuSet &a, const SkuSet &b);
	friend SkuSet operator ~ (const SkuSet &a);
	friend bool testClear(const SkuSet &a);
	// minus(a, b) is the same as: a &(a^b). The result bit field
	// consists of those bits that are set in a but not set 
	// in b
	friend SkuSet SkuSetMinus(const SkuSet &a, const SkuSet &b);

public:
	SkuSet():m_iLength(0), m_iSize(0), m_rgulBitField(NULL){}

	SkuSet(int iLength);
	SkuSet(const SkuSet &);
	~SkuSet();

	// copy assignment operator
	SkuSet & operator=(const SkuSet &);

	// overload bitwise assignment operators
	const SkuSet & operator&=(const SkuSet &);
	const SkuSet & operator|=(const SkuSet &);
	const SkuSet & operator^=(const SkuSet &);

	// overload ==, !=
	bool operator==(const SkuSet &);
	bool operator!=(const SkuSet &);

	// set a certain bit in the bitfield
	void set(int iPos);

	// set all bits in the bitfield
	void setAllBits() {for(int i=0; i<m_iLength; i++) set(i); }
	
	// test a certain bit in the bitfield
	bool test(int iPos);

	// return the # set bits
	int countSetBits();

	// test if this bitfield is all cleared (no bit set)
	bool testClear();

	// clear the bitfield to all 0s
	void clear() {for(int i=0; i<m_iSize; i++) m_rgulBitField[i] = 0; }

	void print();

	// member access function
	int getLength(){return m_iLength;}
	int getSize(){return m_iSize;}
private:
	int m_iLength; // the length of the bit field
	int m_iSize;   // # integers that is used to represent the bit field
	ULONG *m_rgulBitField;
};

#endif //XMSI_SKUSET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\sources.inc ===
TARGETNAME=wmc
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)
USE_NATIVE_EH=1

TARGETPATH=$(MSI_BUILD_TARGET)
TARGETLIBS=\
        $(BUILD_DIR)\msi.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\gdi32.lib \
	$(SDK_LIB_PATH)\winspool.lib \
	$(SDK_LIB_PATH)\comdlg32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\shell32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\odbc32.lib \
	$(SDK_LIB_PATH)\odbccp32.lib \
	$(SDK_LIB_PATH)\urlmon.lib \
	$(SDK_LIB_PATH)\msvcprt.lib
	 

C_DEFINES=$(C_DEFINES) -D_EXE

INCLUDES=$(BUILD_COMMONDIR);$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\query.cpp \
	..\SkuSet.cpp\
	..\SKUFilterExprNode.cpp \
	..\CommandOpt.cpp\
	..\Sku.cpp\
	..\SkuSetVals.cpp \
	..\ElementEntry.cpp\
	..\Component.cpp\
	..\utilities.cpp \
	..\componentFuncs.cpp \
	..\mainFuncs.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\skuset.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       SkuSet.cpp
//
//    This file contains the implementation of SkuSet class 
//--------------------------------------------------------------------------

#include "SkuSet.h"
#include "math.h"

////////////////////////////////////////////////////////////////////////////
// Constructor: take the length of the bit field 
////////////////////////////////////////////////////////////////////////////
SkuSet::SkuSet(int iLength)
{
	m_iLength = iLength;
	int i = SKUSET_UNIT_SIZE;

	m_iSize = (int)ceil((double)m_iLength/SKUSET_UNIT_SIZE);

	m_rgulBitField = new ULONG[m_iSize];
	assert(m_rgulBitField);

	clear();
}

////////////////////////////////////////////////////////////////////////////
// Copy Constructor
////////////////////////////////////////////////////////////////////////////
SkuSet::SkuSet(const SkuSet &rhs)
{
	m_iLength = rhs.m_iLength;
	m_iSize = rhs.m_iSize;
	m_rgulBitField = new ULONG[m_iSize];
	assert(m_rgulBitField != NULL);
	for (int i=0; i<m_iSize; i++)
		m_rgulBitField[i] = rhs.m_rgulBitField[i];
}

////////////////////////////////////////////////////////////////////////////
// Destructor: release the integer array used for the bit field
////////////////////////////////////////////////////////////////////////////
SkuSet::~SkuSet()
{
	if (m_rgulBitField)
	{
		delete[] m_rgulBitField;
	}
}

////////////////////////////////////////////////////////////////////////////
// copy assignment operator
////////////////////////////////////////////////////////////////////////////
SkuSet & 
SkuSet::operator=(const SkuSet &rhs)
{
	assert(rhs.m_rgulBitField != NULL);

	if (this != &rhs)
	{
		if (m_rgulBitField) 
		{
			delete[] m_rgulBitField;
			m_rgulBitField = NULL;
		}
	
		m_iLength = rhs.m_iLength;
		m_iSize = rhs.m_iSize;
		m_rgulBitField = new ULONG[m_iSize];
		assert(m_rgulBitField != NULL);
		for (int i=0; i<m_iSize; i++)
			m_rgulBitField[i] = rhs.m_rgulBitField[i];
	}
	return *this;
}

////////////////////////////////////////////////////////////////////////////
// Overloaded bitwise operators: &=, |=, ^=, ~=
////////////////////////////////////////////////////////////////////////////
const SkuSet & 
SkuSet::operator&=(const SkuSet &rhs)
{
	assert(rhs.m_rgulBitField != NULL);
	assert (this != &rhs);
	assert(m_iLength == rhs.m_iLength);

	for (int i=0; i<m_iSize; i++)
		m_rgulBitField[i] &= (rhs.m_rgulBitField[i]);

	return *this;
}

const SkuSet & 
SkuSet::operator|=(const SkuSet &rhs)
{
	assert(rhs.m_rgulBitField != NULL);
	assert (this != &rhs);
	assert(m_iLength == rhs.m_iLength);

	for (int i=0; i<m_iSize; i++)
		m_rgulBitField[i] |= (rhs.m_rgulBitField[i]);

	return *this;
}

const SkuSet & 
SkuSet::operator^=(const SkuSet &rhs)
{
	assert(rhs.m_rgulBitField != NULL);
	assert (this != &rhs);
	assert(m_iLength == rhs.m_iLength);

	for (int i=0; i<m_iSize; i++)
		m_rgulBitField[i] ^= (rhs.m_rgulBitField[i]);

	return *this;
}

////////////////////////////////////////////////////////////////////////////
// Overloaded bitwise assignment operators: &=, |=, ^=
////////////////////////////////////////////////////////////////////////////
bool 
SkuSet::operator==(const SkuSet &rhs)
{
	assert(rhs.m_rgulBitField != NULL);

	if (this == &rhs)
		return true;

	assert(m_iLength == rhs.m_iLength);

	for (int i=0; i<m_iSize; i++)
	{
		if (m_rgulBitField[i] != rhs.m_rgulBitField[i])
			return false;
	}

	return true;
}
	
bool 
SkuSet::operator!=(const SkuSet &rhs)
{
	return !((*this)==rhs);
}

////////////////////////////////////////////////////////////////////////////
// turn on the iPos bit
////////////////////////////////////////////////////////////////////////////
void
SkuSet::set(int iPos)
{
	assert(iPos < m_iLength);
	
	int iIndex = iPos/SKUSET_UNIT_SIZE;
	int iPosition = iPos % SKUSET_UNIT_SIZE;
	UINT iMask = 1 << iPosition;

#ifdef DEBUG
	if ((m_rgulBitField[iIndex] & iMask) == 1)
		_tprintf(TEXT("Warning: this bit is set already\n"));
#endif

	m_rgulBitField[iIndex] |= iMask;
}

////////////////////////////////////////////////////////////////////////////
// return true if iPos bit is set, false otherwise
////////////////////////////////////////////////////////////////////////////
bool
SkuSet::test(int iPos)
{
	assert(iPos < m_iLength);
	
	int iIndex = iPos/SKUSET_UNIT_SIZE;
	int iPosition = iPos % SKUSET_UNIT_SIZE;
	UINT iMask = 1 << iPosition;

	return ((m_rgulBitField[iIndex] & iMask) == iMask);
}

////////////////////////////////////////////////////////////////////////////
// return # set bits
////////////////////////////////////////////////////////////////////////////
int
SkuSet::countSetBits()
{
	assert (m_rgulBitField != NULL);

	int iRetVal=0;
	ULONG iMask = 1 << (SKUSET_UNIT_SIZE - 1);

	for(int i=m_iSize-1; i>=0; i--)
	{
		ULONG ul = m_rgulBitField[i];

		for (int j=1; j<=SKUSET_UNIT_SIZE; j++)
		{
			if ((ul & iMask) == iMask)
				iRetVal++;
			ul <<= 1;
		}
	}
	return iRetVal;
}

////////////////////////////////////////////////////////////////////////////
// test if all the bits in the SkuSet is cleared
////////////////////////////////////////////////////////////////////////////
bool
SkuSet::testClear()
{
	for(int i=0; i<m_iSize; i++) 
	{
		if (0 != m_rgulBitField[i])
			return false;
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////
// For debug purpose, print out the bit field
////////////////////////////////////////////////////////////////////////////
void
SkuSet::print()
{
	assert (m_rgulBitField != NULL);

	ULONG iMask = 1 << (SKUSET_UNIT_SIZE - 1);

	for(int i=m_iSize-1; i>=0; i--)
	{
		ULONG ul = m_rgulBitField[i];

		for (int j=1; j<=SKUSET_UNIT_SIZE; j++)
		{
			if ((ul & iMask) == 0)
				_tprintf(TEXT("0"));
			else
				_tprintf(TEXT("1"));
			ul <<= 1;
			if (j % CHAR_BIT == 0)
				_tprintf(TEXT(" "));
		}

	}

	_tprintf(TEXT("\n"));
}


//----------------------------------------------------------------------------
// bitwise operators for SkuSet
SkuSet operator & (const SkuSet &a, const SkuSet &b)
{
	assert(a.m_rgulBitField != NULL);
	SkuSet retVal = a;
	retVal &= b;

	return retVal;
}

SkuSet operator | (const SkuSet &a, const SkuSet &b)
{
	assert(a.m_rgulBitField != NULL);
	SkuSet retVal = a;
	retVal |= b;

	return retVal;
}

SkuSet operator ^ (const SkuSet &a, const SkuSet &b)
{
	assert(a.m_rgulBitField != NULL);
	SkuSet retVal = a;
	retVal ^= b;

	return retVal;
}


// minus(a,b) is the same as: a &(a^b). The result bit field
// consists of those bits that are set in a but not set 
// in b
SkuSet SkuSetMinus(const SkuSet &a, const SkuSet &b)
{
	assert(a.m_rgulBitField != NULL);
	assert(b.m_rgulBitField != NULL);

	SkuSet retVal = a;
	for (int i=0; i<retVal.m_iSize; i++)
		retVal.m_rgulBitField[i] = 
			retVal.m_rgulBitField[i] & 
					(retVal.m_rgulBitField[i] ^ b.m_rgulBitField[i]);

	return retVal;
}

SkuSet operator ~ (const SkuSet &a)
{
	assert(a.m_rgulBitField != NULL);

	SkuSet retVal = a;
	for (int i=0; i<retVal.m_iSize; i++)
		retVal.m_rgulBitField[i] = ~(retVal.m_rgulBitField[i]);

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\skusetvals.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       SkuSetValues.cpp
//
//    This file contains the implementation of SkuSetValues class
//--------------------------------------------------------------------------

#include "wmc.h"

////////////////////////////////////////////////////////////////////////////
// Constructor: 
////////////////////////////////////////////////////////////////////////////
SkuSetValues::SkuSetValues()
{
	m_pVecSkuSetVals = new vector<SkuSetVal *>;
	assert(m_pVecSkuSetVals);

	m_iter = m_pVecSkuSetVals->begin();
}

////////////////////////////////////////////////////////////////////////////
// Destructor: 
////////////////////////////////////////////////////////////////////////////
SkuSetValues::~SkuSetValues()
{
	if (m_pVecSkuSetVals) 
	{
		for (m_iter = m_pVecSkuSetVals->begin(); 
			 m_iter != m_pVecSkuSetVals->end(); 
			 m_iter++)	 
		{
			if (*m_iter)
			{
				delete (*m_iter)->pSkuSet;
				switch (m_vt) 
				{
					case STRING:
						delete[] (*m_iter)->isVal.szVal;
						break;
					case STRING_LIST:
					{
						// free all the strings stored on the list
						set<LPTSTR, Cstring_less>::iterator it;
						set<LPTSTR, Cstring_less> *pSetString;
						pSetString = (*m_iter)->isVal.pSetString;
						if (pSetString)
						{
							for(it = pSetString->begin(); 
								it != pSetString->end(); ++it)
							{
								if (*it)
									delete[] (*it);
							}
							delete pSetString;
						}
						break;
					}
					case FM_PAIR:
					{
						FOM *pFOM = (*m_iter)->isVal.pFOM;
						if (pFOM)
						{
							//delete stored feature name
							if (pFOM->szFeature)
								delete[] pFOM->szFeature;
							//delete stored module name
							if (pFOM->szModule)
								delete[] pFOM->szModule;
							delete pFOM;
						}
						break;
					}
				}
				delete *m_iter;
			}
		}

		delete m_pVecSkuSetVals;
	}
}

////////////////////////////////////////////////////////////////////////////
// DirectInsert: store the pointer (caller should allocate memory)
////////////////////////////////////////////////////////////////////////////
void
SkuSetValues::DirectInsert(SkuSetVal *pSkuSetVal)
{
	assert(pSkuSetVal);


	if (pSkuSetVal->pSkuSet->testClear())
	{
#ifdef DEBUG
		_tprintf(TEXT("\nAttempting to store a SkuSetVal associated with an")
				TEXT(" EMPTY SkuSet\n\n"));
#endif
		return;
	}

	m_pVecSkuSetVals->push_back(pSkuSetVal);
}

////////////////////////////////////////////////////////////////////////////
// DirectInsert: construct a new SkuSetVal object using the passed-in values
//				(caller should allocate memory for *pSkuSet)
////////////////////////////////////////////////////////////////////////////
void
SkuSetValues::DirectInsert(SkuSet *pSkuSet, IntStringValue isVal)
{
	assert(pSkuSet);

	SkuSetVal *pSkuSetVal = new SkuSetVal;
	assert(pSkuSetVal);

	pSkuSetVal->isVal = isVal;
	pSkuSetVal->pSkuSet = pSkuSet;

	DirectInsert(pSkuSetVal);
}

////////////////////////////////////////////////////////////////////////////
// CollapseInsert: Sometimes when inserting into the list of <SkuSet, Value>
//				   data structure, we want to collapse the SkuSets with the
//				   same value into one slot. One example is when inserting
//				   into a data structure storing references (to Directories,
//				   to InstallLevels, etc.)
//				   when NoRepeat is set to true, the compiler will check 
//				   that for any given SKU, the value to be inserted is not 
//				   on the list already. This solves the problem of checking
//				   the uniqueness of an attribute - sometimes an attribute
//				   corresponds to a DB column(primary key) instead of the 
//				   element that the attribute belongs to
////////////////////////////////////////////////////////////////////////////
HRESULT
SkuSetValues::CollapseInsert(SkuSet *pSkuSet, IntStringValue isVal, bool NoDuplicate)
{
	HRESULT hr = S_OK;
	vector<SkuSetVal *>::iterator iter;

	assert(pSkuSet);

	if (pSkuSet->testClear())
	{
#ifdef DEBUG
		_tprintf(TEXT("\nAttempting to store a SkuSetVal associated with an")
				TEXT(" EMPTY SkuSet\n\n"));
#endif
		return S_FALSE;
	}

	SkuSet *b = pSkuSet;
	SkuSet *a = NULL;

	if (m_pVecSkuSetVals->empty())
	{
		SkuSetVal *pSV = new SkuSetVal;
		assert(pSV);
		pSV->pSkuSet = pSkuSet;
		pSV->isVal = isVal;
		m_pVecSkuSetVals->push_back(pSV);
	}
	else
	{
		for (iter = m_pVecSkuSetVals->begin();
			 iter != m_pVecSkuSetVals->end();
			 iter++)
		{
			assert(*iter);
			a = (*iter)->pSkuSet;

			// same value
			if ( ((STRING == m_vt) && (0 == _tcscmp((*iter)->isVal.szVal, isVal.szVal))) ||
				 ((INTEGER == m_vt) && (isVal.intVal == (*iter)->isVal.intVal)) )
			{
				// check for no duplicate value
				if (NoDuplicate)
				{
					SkuSet skuSetTemp = (*a) & (*b);
					if (!skuSetTemp.testClear())
					{
						if (STRING == m_vt)
							_tprintf(TEXT("Compile Error: Value %s exists already\n"), 
											isVal.szVal);
						else
							_tprintf(TEXT("Compile Error: Value %d exists already\n"), 
											isVal.intVal);
						hr = E_FAIL;
						break;
					}
				}

				// update the SkuSet stored to include the newly added SKUs
				*((*iter)->pSkuSet) |= *b;
				b->clear();
				break;
			}
		}

		if (SUCCEEDED(hr) && !b->testClear())
		{
			// there is no chance to collapse, insert the new value
			SkuSetVal *pSV = new SkuSetVal;
			pSV->pSkuSet = b;
			pSV->isVal = isVal;
			// Store the new value
			m_pVecSkuSetVals->push_back(pSV);
		}
		else
		{
			if (STRING == m_vt)
				delete[] isVal.szVal;
			delete b;
			pSkuSet = NULL;
		}
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// SplitInsert: go through the value stored on the vector so far
//				a : SkuSet stored; b : SkuSet to be added
//			    Get 3 new SkuSets: 
//					1) a-b: should remain the old attr value;
//					2) a&b: should update to old|new
//					3)b-a: used as new b to process the next element
//				Insert the newly generated SkuSets a-b, a&b into the vector
//				if they are not empty.
//				Finally if b is not empty, insert b into the vector
//				*pSkuSet is destroyed after the function call.
////////////////////////////////////////////////////////////////////////////
HRESULT
SkuSetValues::SplitInsert(SkuSet *pSkuSet, IntStringValue isVal, 
						  HRESULT (*UpdateFunc)
							(IntStringValue *pisValOut, IntStringValue isValOld, 
												IntStringValue isValNew))
{
	assert(pSkuSet);
	extern void PrintSkuIDs(SkuSet *);

	if (pSkuSet->testClear())
	{
#ifdef DEBUG
		_tprintf(TEXT("\nAttempting to store a SkuSetVal associated with an")
				TEXT(" EMPTY SkuSet\n\n"));
#endif
		return S_FALSE;
	}

	HRESULT hr = S_OK;
	SkuSet *a = NULL;
	SkuSet *b = pSkuSet;
	vector<SkuSetVal *> vecTemp; // temporary storage to move SkuSetVals around
	vector<SkuSetVal *>::iterator iter;

	// first time insertion or this is the first entity that
	// corresponds to a column value, just insert directly
	if (m_pVecSkuSetVals->empty() || (!UpdateFunc))
	{
		SkuSetVal *pSV = new SkuSetVal;
		assert(pSV);
		pSV->pSkuSet = pSkuSet;
		if (STRING_LIST == m_vt)
		{
			// construct a new set and put the first Feature in the set
			set<LPTSTR, Cstring_less> *pSetStringFirst = 
										new set<LPTSTR, Cstring_less>;
			assert(pSetStringFirst);
			pSetStringFirst->insert(isVal.szVal);
			isVal.pSetString = pSetStringFirst;
		}
		pSV->isVal = isVal;
		m_pVecSkuSetVals->push_back(pSV);
	}
	else
	{
		for (iter = m_pVecSkuSetVals->begin();
			 iter != m_pVecSkuSetVals->end();
			 iter++)
		{
			assert(*iter);
			a = (*iter)->pSkuSet;

			(*iter)->isVal;

			// test for special case: a, b completely overlap
			if ( *a == *b)
			{ 
				// Get the updated value
				IntStringValue isValTemp;
				hr = UpdateFunc(&isValTemp, (*iter)->isVal, isVal);
				if (FAILED(hr))
				{
					_tprintf(TEXT("in SKU: "));
					PrintSkuIDs(a);
					delete b;
					switch (m_vt)
					{
						case STRING:
						case STRING_LIST:
							if (isVal.szVal)
								delete[] isVal.szVal;
							break;
						case FM_PAIR:
							delete[] (isVal.pFOM)->szFeature;
							delete[] (isVal.pFOM)->szModule;
							delete isVal.pFOM;
							break;
					}					
					break;
				}

				// old value is no longer good, destroy it
				switch (m_vt)
				{
					case STRING:
						if ((*iter)->isVal.szVal)
							delete[] (*iter)->isVal.szVal;
						break;
					case FM_PAIR:
						delete[] ((*iter)->isVal.pFOM)->szFeature;
						delete[] ((*iter)->isVal.pFOM)->szModule;
						delete (*iter)->isVal.pFOM;
						break;
					case STRING_LIST:
					{
						// free all the strings stored on the list
						set<LPTSTR, Cstring_less>::iterator it;
						set<LPTSTR, Cstring_less> *pSetString;
						pSetString = (*iter)->isVal.pSetString;
						if (pSetString)
						{
							for(it = pSetString->begin(); 
								it != pSetString->end(); ++it)
							{
								if (*it)
									delete[] (*it);
							}
							delete pSetString;
						}						
						break;
					}
				}

				(*iter)->isVal = isValTemp;

				// the rest of the elements on the list should
				// all be kept
				for (; iter != m_pVecSkuSetVals->end(); iter++)
					vecTemp.push_back(*iter);
				b->clear();
				break;
			}

			// a & b
			SkuSet *pSkuSet_a_and_b = new SkuSet(g_cSkus);
			assert(pSkuSet_a_and_b);
			*pSkuSet_a_and_b = (*a) & (*b);
			if(!pSkuSet_a_and_b->testClear())
			{
				SkuSetVal *pSV = new SkuSetVal;
				assert(pSV);
				pSV->pSkuSet = pSkuSet_a_and_b;
				// update the collided value
				if (UpdateFunc)
					hr = UpdateFunc(&(pSV->isVal), (*iter)->isVal, isVal);
				if (FAILED(hr))
				{
					_tprintf(TEXT("in SKU: "));
					PrintSkuIDs(pSkuSet_a_and_b);
					delete pSkuSet_a_and_b;
					delete pSV;
					delete b;
					switch (m_vt)
					{
						case STRING:
						case STRING_LIST: 
							if (isVal.szVal)
								delete[] isVal.szVal;
							break;
						case FM_PAIR:
							delete[] (isVal.pFOM)->szFeature;
							delete[] (isVal.pFOM)->szModule;
							delete isVal.pFOM;
							break;
					}					
					break;
				}
				// store the splitted part
				vecTemp.push_back(pSV);
			}
			else
			{
				delete pSkuSet_a_and_b;
				//a is to stay
				vecTemp.push_back(*iter);
				//a, b don't overlap at all, no need to process a-b
				continue;
			}

			// a - b
			SkuSet *pSkuSet_a_minus_b = new SkuSet(g_cSkus);
			assert(pSkuSet_a_minus_b);
			*pSkuSet_a_minus_b = SkuSetMinus(*a, *b);

			if(!pSkuSet_a_minus_b->testClear())
			{
				SkuSetVal *pSV = new SkuSetVal;
				assert(pSV);
				pSV->pSkuSet = pSkuSet_a_minus_b;
				// keep the original value
				pSV->isVal = (*iter)->isVal;
				// store the splitted part
				vecTemp.push_back(pSV);
			}
			else
			{
				delete pSkuSet_a_minus_b;
				// the old element is completely replaced
				// by the new one
				// release the memory used by the unwanted element
				// old value is no longer good, destroy it
				// Issue: wrap the following switch clause in a function
				switch (m_vt)
				{
					case STRING:
						if ((*iter)->isVal.szVal)
							delete[] (*iter)->isVal.szVal;
						break;
					case FM_PAIR:
						delete[] ((*iter)->isVal.pFOM)->szFeature;
						delete[] ((*iter)->isVal.pFOM)->szModule;
						delete (*iter)->isVal.pFOM;
						break;
					case STRING_LIST:
					{
						// free all the strings stored on the list
						set<LPTSTR, Cstring_less>::iterator it;
						set<LPTSTR, Cstring_less> *pSetString;
						pSetString = (*iter)->isVal.pSetString;
						if (pSetString)
						{
							for(it = pSetString->begin(); 
								it != pSetString->end(); ++it)
							{
								if (*it)
									delete[] (*it);
							}
							delete pSetString;
						}						
						break;
					}
				}
			}

			// b - a
			*b = SkuSetMinus(*b, *a);
			delete (*iter)->pSkuSet;
			delete (*iter);
		}

		if (SUCCEEDED(hr))
		{
			if (!b->testClear())
			{
				// this is the first time for the SKUs in b to get a value
				// form a SkuSetVal element and insert it into the list
				SkuSetVal *pSV = new SkuSetVal;
				pSV->pSkuSet = b;
				// if the value to be stored should be a STRING_LIST, 
				// need to change the input new value from a LPTSTR
				// to a StringSet
				if (STRING_LIST == m_vt)
				{
					set<LPTSTR, Cstring_less> *pSetStringNew
						= new set<LPTSTR, Cstring_less>;
					assert(pSetStringNew);
					pSetStringNew->insert(isVal.szVal);
					isVal.pSetString = pSetStringNew;
				}
				pSV->isVal = isVal;
				// Store the new value
				vecTemp.push_back(pSV);
			}
			else
			{
				// input value is useless now since there is no SKU that
				// should take that value. destroy it.
				switch (m_vt)
				{
					case STRING:
					case STRING_LIST: // even the value to be stored is STRING_LIST
									 // the input value is just a LPTSTR
						if (isVal.szVal)
							delete[] isVal.szVal;
						break;
					case FM_PAIR:
						delete[] (isVal.pFOM)->szFeature;
						delete[] (isVal.pFOM)->szModule;
						delete isVal.pFOM;
						break;
				}
				delete b;
				pSkuSet = NULL;
			}
			// erase the processed elements
			m_pVecSkuSetVals->erase(m_pVecSkuSetVals->begin(), m_pVecSkuSetVals->end());

			//insert the newly generated elements
			m_pVecSkuSetVals->insert(m_pVecSkuSetVals->begin(), vecTemp.begin(), 
										vecTemp.end());
		}
	}

	return hr;
}
	
////////////////////////////////////////////////////////////////////////////
// SplitInsert: (caller should allocate memory for *pSkuSetVal)
//				simply calls the other overloaded function
////////////////////////////////////////////////////////////////////////////
HRESULT
SkuSetValues::SplitInsert(SkuSetVal *pSkuSetVal, 
						  HRESULT (*UpdateFunc)
								(IntStringValue *pIsValOut, IntStringValue isValOld, 
								 IntStringValue isValNew))
{
	assert(pSkuSetVal);
	IntStringValue isVal = pSkuSetVal->isVal;
	SkuSet *pSkuSet = pSkuSetVal->pSkuSet;

	return SplitInsert(pSkuSet, isVal, UpdateFunc);
}

////////////////////////////////////////////////////////////////////////////
// return the value(s) of a set of Skus in the form of
// a SkuSetValues object. Return E_FAIL and set passed-in object to NULL
// if some of the SKUs don't exist in the data structure since this function
// will be mainly used to query stored references. *pSkuSet is untouched.
////////////////////////////////////////////////////////////////////////////
HRESULT 
SkuSetValues::GetValueSkuSet(SkuSet *pSkuSet, 
							SkuSetValues **ppSkuSetValuesRetVal)
{
	extern void PrintSkuIDs(SkuSet *pSkuSet);
	assert(pSkuSet);
	HRESULT hr = S_OK;
	vector<SkuSetVal *>::iterator iter;

	if (pSkuSet->testClear())
	{
#ifdef DEBUG
		_tprintf(TEXT("Warning: attempt to call GetValueSkuSet with")
				 TEXT(" an empty SkuSet\n"));
#endif
		return S_FALSE;
	}

	if (!*ppSkuSetValuesRetVal)
		*ppSkuSetValuesRetVal = new SkuSetValues;
	
	assert(*ppSkuSetValuesRetVal);

	// when the type is FM_PAIR, only the Feature information is needed
	// so the type will be set to STRING
	if (FM_PAIR == m_vt)
		(*ppSkuSetValuesRetVal)->SetValType(STRING);
	else
		(*ppSkuSetValuesRetVal)->SetValType(m_vt);

	SkuSet *b = new SkuSet(g_cSkus);
	*b = *pSkuSet;
	SkuSet *a = NULL;

	for (iter = m_pVecSkuSetVals->begin();
		 iter != m_pVecSkuSetVals->end();
		 iter++)
	{
		assert(*iter);
		a = (*iter)->pSkuSet;
		// test for special case: a, b completely overlap
		if ( *a == *b)
		{ 
			// make a completely copy of *iter
			// Issue: it might be easier to make SkuSetVal a class 
			//		  rather than a struct and give it a copy constructor
			SkuSet *pSkuSetNew = new SkuSet(g_cSkus);
			*pSkuSetNew = *b;
			IntStringValue isValNew;
			switch (m_vt)
			{
				case STRING:
					isValNew.szVal = _tcsdup((*iter)->isVal.szVal);
					assert(isValNew.szVal);
					break;
				case INSTALL_LEVEL:
					// for the sake of InstallLevelRefs
					if(-1 == (*iter)->isVal.intVal)
						(*iter)->isVal.intVal = 0;
					else
						isValNew = (*iter)->isVal;
					break;
				case FM_PAIR:
				{// only Feature is needed 
					isValNew.szVal = 
								_tcsdup(((*iter)->isVal.pFOM)->szFeature);
					assert(isValNew.szVal);
					break;
				}
				case INTEGER:
					isValNew = (*iter)->isVal;
			}

			// insert the copy into the return data structure
			// Issue: it might speed up the future processing if 
			//		  call CollapseInsert to do the insertion 
			(*ppSkuSetValuesRetVal)->DirectInsert(pSkuSetNew, isValNew);

			b->clear();
			break;
		}

		// a & b
		SkuSet *pSkuSet_a_and_b = new SkuSet(g_cSkus);
		assert(pSkuSet_a_and_b);
		*pSkuSet_a_and_b = (*a) & (*b);
		if(!pSkuSet_a_and_b->testClear())
		{
			IntStringValue isValNew;
			switch (m_vt)
			{
				case STRING:
					isValNew.szVal = _tcsdup((*iter)->isVal.szVal);
					assert(isValNew.szVal);
					break;
				case INSTALL_LEVEL:
					// for the sake of InstallLevelRefs
					if(-1 == (*iter)->isVal.intVal)
						(*iter)->isVal.intVal = 0;
					else
						isValNew = (*iter)->isVal;
					break;
				case FM_PAIR:
				{
					FOM *pFOMNew = new FOM;
					pFOMNew->szFeature = 
								_tcsdup(((*iter)->isVal.pFOM)->szFeature);
					assert(pFOMNew->szFeature);
					pFOMNew->szModule = 
								_tcsdup(((*iter)->isVal.pFOM)->szModule);
					assert(pFOMNew->szModule);
					isValNew.pFOM = pFOMNew;
					break;
				}
				case INTEGER:
					isValNew = (*iter)->isVal;
			}
			// insert this part into the return data structure
			(*ppSkuSetValuesRetVal)->DirectInsert(pSkuSet_a_and_b, isValNew);			
		}
		else
		{
			delete pSkuSet_a_and_b;
		}

		// b - a
		*b = SkuSetMinus(*b, *a);
	}

	if (!b->testClear())
	{
		// this is an error: some of the Skus under interest don't
		// have a value specified. If it is references that are stored,
		// this means that those SKUs are refering to sth that don't 
		// belong to them. If this is a KeyPath, it means that some SKUs
		// don't have a KeyPath specified for this Component. If it is
		// Ownership information, it means that some SKUs don't have 
		// Ownership information specified for this component. All of these 
		// are errors to be caught.
		_tprintf(TEXT("Compile Error: Following SKUs: "));
		PrintSkuIDs(b);
		// let the caller finish the error message
		hr = E_FAIL;
	}
	delete b;

	if (FAILED(hr))
	{
		delete *ppSkuSetValuesRetVal;
		*ppSkuSetValuesRetVal = NULL;
	}
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// GetValue: return the value stored for any given SKU
////////////////////////////////////////////////////////////////////////////
IntStringValue 
SkuSetValues::GetValue(int iPos)
{
	assert(m_pVecSkuSetVals);

	vector<SkuSetVal *>::iterator iter;

	for (iter = m_pVecSkuSetVals->begin(); 
		 iter != m_pVecSkuSetVals->end(); 
		 iter++)	 
	{
		if (*iter)
		{
			if ((*iter)->pSkuSet->test(iPos))
				return (*iter)->isVal;
		}
	}

	IntStringValue isVal;

	if (INTEGER == m_vt)
		isVal.intVal = MSI_NULL_INTEGER;
	else
		isVal.szVal = NULL;

	return isVal;
}

////////////////////////////////////////////////////////////////////////////
// GetMostCommon: return the pointer to the SkuSetVal that stores the most 
//				  common value (its SkuSet has the most bits set)
////////////////////////////////////////////////////////////////////////////
SkuSetVal *
SkuSetValues::GetMostCommon()
{
	assert(m_pVecSkuSetVals);

	vector<SkuSetVal *>::iterator iter;
	SkuSetVal *skuSetValRetVal = NULL;
	int cSetBitsMax = 0;

	for (iter = m_pVecSkuSetVals->begin(); 
		 iter != m_pVecSkuSetVals->end(); 
		 iter++)	 
	{
		if (*iter)
		{
			int i = (*iter)->pSkuSet->countSetBits();
			if (i>cSetBitsMax)
			{
				cSetBitsMax = i;
				skuSetValRetVal = *iter;
			}				
		}
	}

	return skuSetValRetVal;
}

////////////////////////////////////////////////////////////////////////////
// Start: return the first value stored
////////////////////////////////////////////////////////////////////////////
SkuSetVal *
SkuSetValues::Start()
{
	m_iter = m_pVecSkuSetVals->begin();
	return *m_iter;
}

////////////////////////////////////////////////////////////////////////////
// Next: return the next value
////////////////////////////////////////////////////////////////////////////
SkuSetVal *
SkuSetValues::Next()
{
	m_iter++;
	return *m_iter;
}

////////////////////////////////////////////////////////////////////////////
// End: return the last value stored
////////////////////////////////////////////////////////////////////////////
SkuSetVal *
SkuSetValues::End()
{
	return *m_pVecSkuSetVals->end();
}

////////////////////////////////////////////////////////////////////////////
// Empty: return true if the vector is empty; false otherwise
////////////////////////////////////////////////////////////////////////////
bool
SkuSetValues::Empty()
{
	return m_pVecSkuSetVals->empty();
}

////////////////////////////////////////////////////////////////////////////
// Erase: erase the element from the storage W/O freeing memory
////////////////////////////////////////////////////////////////////////////
void
SkuSetValues::Erase(SkuSetVal *pSkuSetVal)
{
	vector<SkuSetVal *>::iterator iter =
		find(m_pVecSkuSetVals->begin(), m_pVecSkuSetVals->end(), pSkuSetVal);

	if (iter != m_pVecSkuSetVals->end())
		m_pVecSkuSetVals->erase(iter);
}

////////////////////////////////////////////////////////////////////////////
// Print: for debug purpose
////////////////////////////////////////////////////////////////////////////
void
SkuSetValues::Print()
{
	vector<SkuSetVal *>::iterator iter;

	_tprintf(TEXT("\n"));

	for (iter = m_pVecSkuSetVals->begin(); 
		 iter != m_pVecSkuSetVals->end(); 
		 iter++)	 
	{
		if (*iter)
		{
			(*iter)->pSkuSet->print();
			switch (m_vt)
			{
				case STRING:
					_tprintf(TEXT("%s\n"), (*iter)->isVal.szVal);
					break;
				case INTEGER:
				case INSTALL_LEVEL:
					_tprintf(TEXT("%d\n"), (*iter)->isVal.intVal);
					break;
				case FM_PAIR:
					_tprintf(TEXT("Feature: %s\tModule: %s\n"), 
						((*iter)->isVal.pFOM)->szFeature,
						((*iter)->isVal.pFOM)->szModule);
					break;
				case STRING_LIST:
				{
					set<LPTSTR, Cstring_less>::iterator it;
					set<LPTSTR, Cstring_less> *pSetString;
					pSetString = (*iter)->isVal.pSetString;
					if (pSetString)
					{
						for(it = pSetString->begin(); 
							it != pSetString->end(); ++it)
						{
							if (*it)
								_tprintf(TEXT("%s "), *it);
						}
						_tprintf(TEXT("\n"));
					}
					break;
				}
			}
		}
	}

	_tprintf(TEXT("\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\res\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\utilities.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:      helper.cpp
// 
//    This file contains the utility functions used by the wmc
//    project.
//--------------------------------------------------------------------------

#include "Utilities.h"
#include "SKUFilterExprNode.h"

////////////////////////////////////////////////////////////////////////////
// CleanUp: free the memory from the global data structure
////////////////////////////////////////////////////////////////////////////
void CleanUp()
{
	// free Directory reference
	map<LPTSTR, SkuSetValues *, Cstring_less>::iterator it_LS;

	for (it_LS = g_mapDirectoryRefs_SKU.begin(); 
		 it_LS != g_mapDirectoryRefs_SKU.end(); 
		 ++it_LS)
	{
		if ((*it_LS).first)
			delete[] (*it_LS).first;
		if ((*it_LS).second)
			delete (*it_LS).second;
	}

	// free InstallLevel reference
	for (it_LS = g_mapInstallLevelRefs_SKU.begin(); 
		 it_LS != g_mapInstallLevelRefs_SKU.end(); 
		 ++it_LS)
	{
		if ((*it_LS).first)
			delete[] (*it_LS).first;
		if ((*it_LS).second)
			delete (*it_LS).second;
	}

	// free Component Objects
	map<LPTSTR, Component *, Cstring_less>::iterator it_LC;

	for (it_LC = g_mapComponents.begin(); 
		 it_LC != g_mapComponents.end(); 
		 ++it_LC)
	{
		if ((*it_LC).first)
			delete[] (*it_LC).first;
		if ((*it_LC).second)
			delete (*it_LC).second;
	}

	map<LPTSTR, SkuSet *, Cstring_less>::iterator it_LSS;

	// free SkuSet Objects
	for (it_LSS = g_mapSkuSets.begin(); 
		 it_LSS != g_mapSkuSets.end(); 
		 ++it_LSS)
	{
		if ((*it_LSS).first)
			delete[] (*it_LSS).first;
		if ((*it_LSS).second)
			delete (*it_LSS).second;
	}

	// free the map storing FileID - SkuSet relationships
	for (it_LSS = g_mapFiles.begin(); 
		 it_LSS != g_mapFiles.end(); 
		 ++it_LSS)
	{
		if ((*it_LSS).first)
			delete[] (*it_LSS).first;
		if ((*it_LSS).second)
			delete (*it_LSS).second;
	}

	map<LPTSTR, int, Cstring_less>::iterator it_LI;
	// free string stored inside g_mapTableCounter
	for (it_LI = g_mapTableCounter.begin(); 
		 it_LI != g_mapTableCounter.end(); 
		 ++it_LI)
	{
		if ((*it_LI).first)
			delete[] (*it_LI).first;
	}

	// free Sku objects
	if (g_rgpSkus)
	{
		for (int i=0; i<g_cSkus; i++)
		{
			if (g_rgpSkus[i])
				delete g_rgpSkus[i];
		}
	}
}
////////////////////////////////////////////////////////////////////////////
// compares the relationship of the 2 modules in the module tree. Return 
// the comparison result through iResult. if szModule1 is an ancestor
// of szModule2, *iResult is set to -1. if szModule1 is a descendant of 
// szModule2, *iResult is set to 1. if szModule1 is the same as szModule2 
// or the 2 modules doesn't belong to the same Module subtree, iResult is
// set to 0. This is an error to catch for the caller.
////////////////////////////////////////////////////////////////////////////
HRESULT CompareModuleRel(LPTSTR szModule1, LPTSTR szModule2, int *iResult)
{
	HRESULT hr = S_OK;
	PIXMLDOMNode pNodeModule1 = NULL;
	PIXMLDOMNode pNodeModule2 = NULL;

	// comparing the same modules
	if (0 == _tcscmp(szModule1, szModule2))
	{
		*iResult = 0;
		return S_FALSE;
	}

	int iLength = _tcslen(
					TEXT("/ProductFamily/Modules//Module[ @ID = \"\"]"));
	int iLength1 = _tcslen(szModule1);
	int iLength2 = _tcslen(szModule2);

	// form the XPath for searching for szModule1 inside the whole doc
	LPTSTR szXPath_Root_1 = new TCHAR[iLength1+iLength+1];
	assert(szXPath_Root_1);
	_stprintf(szXPath_Root_1, 
		TEXT("/ProductFamily/Modules//Module[ @ID = \"%s\"]"), szModule1);

	// check for szModule1 < szModule2 first (1 is an ancestor of 2)
	if (SUCCEEDED(hr = GetChildNode(g_pNodeProductFamily, szXPath_Root_1, 
									pNodeModule1)))
	{
		delete[] szXPath_Root_1;
		assert(S_FALSE != hr);

		//form the XPath for searching for szModule2 inside the current context
		LPTSTR szXPath_1_2 = new TCHAR[iLength2+25];
		assert(szXPath_1_2);
		_stprintf(szXPath_1_2, TEXT(".//Module[ @ID = \"%s\"]"), szModule2);

		if (SUCCEEDED(hr = 
			GetChildNode(pNodeModule1, szXPath_1_2, pNodeModule2)))
		{
			delete[] szXPath_1_2;
			if (S_FALSE != hr)
			{
				// found szModule2 inside the subtree rooted at szModule1
				*iResult = -1;
				return hr;
			}
		}
		else
			delete[] szXPath_1_2;
	}
	else
	{
		delete[] szXPath_Root_1;
	}

	// check for szModule1 > szModule2 (1 is a descendant of 2)
	if (SUCCEEDED(hr))
	{
		//form the XPath for searching for szModule2 inside the whole doc
		LPTSTR szXPath_Root_2 = new TCHAR[iLength2+iLength+1];
		assert(szXPath_Root_2);
		_stprintf(szXPath_Root_2, 
			TEXT("/ProductFamily/Modules//Module[ @ID = \"%s\"]"), szModule2);

		if (SUCCEEDED(hr = GetChildNode(g_pNodeProductFamily, szXPath_Root_2, 
										pNodeModule2)))
		{
			delete[] szXPath_Root_2;
			assert(S_FALSE != hr);

			// form the XPath for searching for szModule1 inside the current 
			//	context
			LPTSTR szXPath_2_1 = new TCHAR[iLength1+25];
			assert(szXPath_2_1);
			_stprintf(szXPath_2_1, TEXT(".//Module[ @ID = \"%s\"]"),szModule1);

			if (SUCCEEDED(hr = 
				GetChildNode(pNodeModule2, szXPath_2_1, pNodeModule1)))
			{
				delete[] szXPath_2_1;
				if (S_FALSE != hr)
				{
					// found szModule1 inside the subtree rooted at szModule2
					*iResult = 1;
					return hr;
				}
			}
			else
				delete[] szXPath_2_1;
		}
		else
			delete[] szXPath_Root_1;
	}

	// szModule1 and szModule2 don't exist in the same subtree
	*iResult = 0;

	return hr;

}

////////////////////////////////////////////////////////////////////////////
// PrintSkuNames: Given a SkuSet, print out the IDs of all SKUs in the set
////////////////////////////////////////////////////////////////////////////
void PrintSkuIDs(SkuSet *pSkuSet)
{
	for (int i=0; i<g_cSkus; i++)
	{
		if (pSkuSet->test(i))
			_tprintf(TEXT("%s "), g_rgpSkus[i]->GetID());
	}
	_tprintf(TEXT("\n"));
}

////////////////////////////////////////////////////////////////////////////
// ProcessSkuFilter
//    Given a Sku filter string, return the SkuSet that represents the result
//		Sku Group.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessSkuFilter(LPTSTR szSkuFilter, SkuSet **ppskuSet)
{
	HRESULT hr = S_OK;
	LPTSTR sz = szSkuFilter;

#ifdef DEBUG
	_tprintf(TEXT("Inside Function ProcessSkuFilter\n"));
#endif

	printf("Sku filter: %s\n", szSkuFilter);
	*ppskuSet = new SkuSet(g_cSkus);
	assert(*ppskuSet != NULL);

	if (szSkuFilter == NULL)
	{
		// no filter = a sku group contains all SKUs
		(*ppskuSet)->setAllBits();
	}
	else
	{
		SKUFilterExprNode *pSKUFilterNode 
			= new SKUFilterExprNode(&sz, SKUFilterExprNode::Filter);
		assert(pSKUFilterNode != NULL);
        if (!pSKUFilterNode->errpos) 
		{
			**ppskuSet = *(pSKUFilterNode->m_pSkuSet);
        } 
		else
		{
			_tprintf(TEXT("Sku Filter : %s\n"), szSkuFilter);
			TCHAR sz[32];
            _stprintf(sz, TEXT("Error      : %%%dc %%s\n"), 
								pSKUFilterNode->errpos-szSkuFilter+1);
            _tprintf(sz,TEXT('^'),pSKUFilterNode->errstr);

			hr = E_FAIL;
        }
        delete pSKUFilterNode;
	}

#ifdef DEBUG
	if (FAILED(hr)) 
	{
		_tprintf(TEXT("Error in function: ProcessSkuFilter\n"));
		delete *ppskuSet;
		*ppskuSet = NULL;
	}

#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// GetSkuSet
//    Given a node:
//		1) Get the Sku Filter specified with the node;
//		2) Process the filter and get the result SkuSet;
//		3) Return the SkuSet via ppskuSet;
////////////////////////////////////////////////////////////////////////////
HRESULT GetSkuSet(PIXMLDOMNode &pNode, SkuSet **ppskuSet)
{
	HRESULT hr = S_OK;
	IntStringValue isVal;

	if (SUCCEEDED(hr = ProcessAttribute(pNode, TEXT("SKU"), STRING, 
										&isVal, NULL)))
	{
		hr = ProcessSkuFilter(isVal.szVal, ppskuSet);

		if (isVal.szVal)
			delete[] isVal.szVal;
	}

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: GetSkuSet\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// ProcessAttribute
//    Given a parent node, an attribute name and an attribute type (int or
//	  string),  this function returns the string value of the attribute 
//	  via isVal. If the attribute doesn't exist, value returned will be
//	  NULL if vt = STRING, or 0 if vt = INTEGER. If the attribute doesn't
//	  exist, return S_FALSE.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessAttribute(PIXMLDOMNode &pNodeParent, LPCTSTR szAttributeName,
						 ValType vt, IntStringValue *pisVal, 
						 const SkuSet *pskuSet)
{
	HRESULT hr = S_OK;
	VARIANT vAttrValue;
	LPTSTR sz = NULL;

	assert(pNodeParent != NULL);
#ifdef DEBUG
	_tprintf(TEXT("Inside ProcessAttribute: "));
	assert(SUCCEEDED(PrintNodeName(pNodeParent)));
#endif

	VariantInit(&vAttrValue);
	// Get the specified attribute of the specified node
	if (SUCCEEDED(hr = GetAttribute(pNodeParent, szAttributeName, vAttrValue)))
	{
		// the specified attribute exists
		if (S_FALSE != hr)
		{
			if (NULL != (sz = BSTRToLPTSTR(vAttrValue.bstrVal)))
			{
				switch (vt) {
				case INTEGER:
					pisVal->intVal = _ttoi(sz);
					delete[] sz;
					break;
				case STRING:
					pisVal->szVal = sz;
					break;
				}
			}
			else
			{
				_tprintf(TEXT("Internal Error: String conversion failed\n"));
				hr = E_FAIL;
			}
		}
	}

	VariantClear(&vAttrValue);

	// make sure the value returned reflects the fact of failure
	if (FAILED(hr) || (S_FALSE == hr))
	{
		switch (vt) {
		case INTEGER:
			pisVal->intVal = 0;
			break;
		case STRING:
			pisVal->szVal = NULL;
		}
	}

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessStringAttribute\n"));
#endif

	return hr;
}	


////////////////////////////////////////////////////////////////////////////
// Function: ProcessShortLong
//   This function processes nodes with Short attribute and long attribute
//         1) form a C-style string: Short|Long
// Issue: Check the format of short file name (8+3)
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessShortLong_SKU(PIXMLDOMNode &pNode, IntStringValue *pIsValOut,
							 SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNode != NULL);
#ifdef DEBUG
	_tprintf(TEXT("Inside ProcessShortLong_SKU: \n"));
	assert(SUCCEEDED(PrintNodeName(pNode)));
#endif

	// Short file name has to present
	if (SUCCEEDED(hr = ProcessAttribute(pNode, TEXT("Short"), STRING, 
										pIsValOut, pSkuSet)))
	{
		if (S_FALSE == hr)
		{
			// Issue: put node name in the error message
			_tprintf(
				TEXT("Compile Error: missing required attribute Short ")
				TEXT("for SKU: "));
			PrintSkuIDs(pSkuSet);
			hr = E_FAIL;
		}
	}

	// concatenate short name and long name if a long name is present
	if (SUCCEEDED(hr))
	{
		IntStringValue isValLong;
		isValLong.szVal = NULL;
		// Long file name is provided, Return value is Short|Long
		if (SUCCEEDED(hr = ProcessAttribute(pNode, TEXT("Long"),
							STRING, &isValLong, pSkuSet)) && (S_FALSE != hr))
		{
			LPTSTR szLong = isValLong.szVal;
			LPTSTR szShort = pIsValOut->szVal;
			pIsValOut->szVal = 
					new TCHAR[_tcslen(szShort) + _tcslen(szLong) + 2];
			if (!pIsValOut->szVal)
			{
				_tprintf(TEXT("Error: Out of memory\n"));
				hr = E_FAIL;
			}
			else
				_stprintf(pIsValOut->szVal, TEXT("%s|%s"), szShort, szLong);
			delete[] szShort;
			delete[] szLong;
		}
	}		

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessShortLong_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Process KeyPath attribute of an element
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessKeyPath(PIXMLDOMNode &pNode, LPTSTR szComponent, 
					   LPTSTR szKeyPath, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNode != NULL);

	printf("szComponent = %s\n", szComponent);

	// Get KeyPath attribute
	IntStringValue isValKeyPath;
	hr = ProcessAttribute(pNode, TEXT("KeyPath"), STRING, &isValKeyPath, 
						  pSkuSet);

	if (SUCCEEDED(hr) && (S_FALSE != hr))
	{
		LPTSTR sz = isValKeyPath.szVal;
		if (0 == _tcscmp(sz, TEXT("Yes")))
		{
			// store the KeyPath information in the global component object
			printf("szComponent = %s\n", szComponent);
			 
			assert(g_mapComponents.count(szComponent));
			hr = g_mapComponents[szComponent]->SetKeyPath(szKeyPath, pSkuSet);
		}
		else if (0 != _tcscmp(sz, TEXT("No")))
		{
			_tprintf(TEXT("Compile Error: the value of a KeyPath atribute")
					 TEXT("should be either \"Yes\" or \"No\""));
			hr = E_FAIL;
		}
		delete[] sz;
	}

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessKeyPath\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessSimpleElement
// This function processes the type of nodes that correspond to one DB column
// and need no more complicated logic than simply retrieving an attribute 
// value. The logic for checking for missing required entities and uniquness
// is included inside the ElementEntry object.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessSimpleElement(PIXMLDOMNode &pNode, int iColumn, 
							 ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNode != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNode)));
#endif

	// Get the value of the element.
	IntStringValue isVal;
	ValType vt = pEE->GetValType(iColumn);
	NodeIndex ni = pEE->GetNodeIndex(iColumn);

	hr = ProcessAttribute(pNode, rgXMSINodes[ni].szAttributeName, vt, 
						  &isVal, pSkuSet);

	// insert the value into the ElementEntry.
	if (SUCCEEDED(hr))
		hr = pEE->SetValue(isVal, iColumn, pSkuSet);

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessSimpleElement\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessRefElement
//   This function processes the type of node whose value is a reference.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessRefElement(PIXMLDOMNode &pNodeRef,  int iColumn, 
							 ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeRef != NULL);
	assert(pEE);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeRef)));
#endif

	IntStringValue isValRef;
	NodeIndex ni = pEE->GetNodeIndex(iColumn);

	// Get the Value of the Ref attribute
	if (SUCCEEDED(hr = ProcessAttribute(pNodeRef, 
										rgXMSINodes[ni].szAttributeName,
										STRING, &isValRef, pSkuSet)))
	{
		if (NULL == isValRef.szVal)
		{
			_tprintf(
			TEXT("Compile Error: Missing required attribute \'%s\' of <%s>\n"), 
				rgXMSINodes[ni].szAttributeName, rgXMSINodes[ni].szNodeName);
			hr = E_FAIL;
		}
		else
		{
			SkuSetValues *pSkuSetValuesRetVal = NULL;
			if (ni == ILEVEL)
			{
				// The dir referred should be in the data structure already
				assert(0 != g_mapInstallLevelRefs_SKU.count(isValRef.szVal));

				// return a list of <SkuSet, InstallLevel> pairs
				hr = g_mapInstallLevelRefs_SKU[isValRef.szVal]->
								GetValueSkuSet(pSkuSet, &pSkuSetValuesRetVal);
			}
			else if (ni == DIR || ni == COMPONENTDIR)
			{
				// The dir referred should be in the data structure already
				assert(0 != g_mapDirectoryRefs_SKU.count(isValRef.szVal));

				// return a list of <SkuSet, InstallLevel> pairs
				hr = g_mapDirectoryRefs_SKU[isValRef.szVal]->
								GetValueSkuSet(pSkuSet, &pSkuSetValuesRetVal);
			}

			if (FAILED(hr))
			{
				_tprintf(TEXT("are trying to reference %s which is ")
						 TEXT("undefined inside them\n"),
						 isValRef.szVal);
			}
			else
			{
				// store the returned list into *pEE
				hr = pEE->SetValueSkuSetValues(pSkuSetValuesRetVal, iColumn);
				if (pSkuSetValuesRetVal)
					delete pSkuSetValuesRetVal;
			}

			delete[] isValRef.szVal;
		}
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessILevel_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Function: ProcessChildrenList
//   Given a parent node and a child node name, this function finds all the
//   children node of that name and sequentially process them using the 
//   function passed in.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessChildrenList_SKU(PIXMLDOMNode &pNodeParent, 
								NodeIndex niChild, bool bIsRequired,
								IntStringValue isVal, 
								HRESULT (*ProcessFunc)
									(PIXMLDOMNode &, IntStringValue isVal, 
										SkuSet *pSkuSet), 
								SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	PIXMLDOMNodeList pNodeListChildren = NULL;
	long iListLength = 0;
	// used to validate: a required node really appears in each SKU
	SkuSet *pSkuSetValidate = NULL;

	assert(pNodeParent != NULL);

	// get the list of children nodes
	if(SUCCEEDED(hr = GetChildrenNodes(pNodeParent, 
									rgXMSINodes[niChild].szNodeName, 
									pNodeListChildren)))
	{
		if(FAILED(hr = pNodeListChildren->get_length(&iListLength)))
		{
			_tprintf(TEXT("Internal Error: Failed to make DOM API call:")
				 TEXT("get_length\n"));
			iListLength = 0;
		}
	}

	if (SUCCEEDED(hr) && bIsRequired)
	{
		pSkuSetValidate = new SkuSet(g_cSkus);
		assert(pSkuSetValidate);
	}  

	// process each child node in the list
	for (long l=0; l<iListLength; l++)
	{
		PIXMLDOMNode pNodeChild = NULL;
		if (SUCCEEDED(hr = pNodeListChildren->get_item(l, &pNodeChild)))
		{	
			assert(pNodeChild != NULL);
			// Get the SkuSet specified for this child
			SkuSet *pSkuSetChild = NULL;
			if (SUCCEEDED(hr = GetSkuSet(pNodeChild, &pSkuSetChild)))
			{
				assert (pSkuSetChild != NULL);

				// if the child node doesn't have a SKU filter specified,
				//  it inherits the SKU filter from its parent
				// Also get rid of those Skus specified in the child
				// but not in its parent
				*pSkuSetChild &= *pSkuSet;

				// only keep processing if the SkuSet is not empty
				if (!pSkuSetChild->testClear())
				{
					if (bIsRequired)
						// mark down the Skus that have this child node
						*pSkuSetValidate |= *pSkuSetChild;

					// process the child node;
					hr = ProcessFunc(pNodeChild, isVal, pSkuSetChild);
				}

				delete pSkuSetChild;
				pSkuSetChild = NULL;
			}

			if (FAILED(hr))
				break;
		}
		else
		{
			_tprintf(TEXT("Internal Error: Failed to make ")
					 TEXT("DOM API call: get_item\n"));
			break;
		}
	}

	// check if the requied node exists in every SKU
	if (SUCCEEDED(hr) && bIsRequired) 
	{
		SkuSet skuSetTemp = SkuSetMinus(*pSkuSet, *pSkuSetValidate);

		if (!skuSetTemp.testClear())
		{
			_tprintf(TEXT("Compile Error: Missing required Node <%s> ")
							TEXT("in SKU: "), 
							rgXMSINodes[niChild].szNodeName);
			PrintSkuIDs(&skuSetTemp);
			_tprintf(TEXT("\n"));

			//For now, completely break when such error happens
			hr = E_FAIL;
		}
	}

	if (SUCCEEDED(hr) && bIsRequired)
		delete pSkuSetValidate;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessChildrenList_SKU\n"));
#endif

	return hr;
}  

////////////////////////////////////////////////////////////////////////////
// Function: ProcessChildrenList
//		Overloaded function. This function is essentially the same as the
//		previous one except that it returns the SkuSet that contains the
//		SKUs that doesn't have this child node. 
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessChildrenList_SKU(PIXMLDOMNode &pNodeParent, 
								NodeIndex niChild, bool bIsRequired,
								IntStringValue isVal, 
								HRESULT (*ProcessFunc)
									(PIXMLDOMNode &, IntStringValue isVal, 
										SkuSet *pSkuSet), 
								SkuSet *pSkuSet, SkuSet *pSkuSetCheck)
{
	HRESULT hr = S_OK;

	PIXMLDOMNodeList pNodeListChildren = NULL;
	long iListLength = 0;
	// used to validate: a required node really appears in each SKU
	SkuSet *pSkuSetValidate = NULL;

	assert(pNodeParent != NULL);

	// get the list of children nodes
	if(SUCCEEDED(hr = GetChildrenNodes(pNodeParent, 
									rgXMSINodes[niChild].szNodeName, 
									pNodeListChildren)))
	{
		if(FAILED(hr = pNodeListChildren->get_length(&iListLength)))
		{
			_tprintf(TEXT("Internal Error: Failed to make DOM API call:")
				 TEXT("get_length\n"));
			iListLength = 0;
		}
	}

	if (SUCCEEDED(hr))
	{
		pSkuSetValidate = new SkuSet(g_cSkus);
		assert(pSkuSetValidate);
	}  

	// process each child node in the list
	for (long l=0; l<iListLength; l++)
	{
		PIXMLDOMNode pNodeChild = NULL;
		if (SUCCEEDED(hr = pNodeListChildren->get_item(l, &pNodeChild)))
		{	
			assert(pNodeChild != NULL);
			// Get the SkuSet specified for this child
			SkuSet *pSkuSetChild = NULL;
			if (SUCCEEDED(hr = GetSkuSet(pNodeChild, &pSkuSetChild)))
			{
				assert (pSkuSetChild != NULL);

				// if the child node doesn't have a SKU filter specified,
				//  it inherits the SKU filter from its parent
				// Also get rid of those Skus specified in the child
				// but not in its parent
				*pSkuSetChild &= *pSkuSet;

				// only keep processing if the SkuSet is not empty
				if (!pSkuSetChild->testClear())
				{
					// mark down the Skus that have this child node
					*pSkuSetValidate |= *pSkuSetChild;

					// process the child node;
					hr = ProcessFunc(pNodeChild, isVal, pSkuSetChild);
				}

				delete pSkuSetChild;
				pSkuSetChild = NULL;
			}

			if (FAILED(hr))
				break;
		}
		else
		{
			_tprintf(TEXT("Internal Error: Failed to make ")
					 TEXT("DOM API call: get_item\n"));
			break;
		}
	}

	// check if the requied node exists in every SKU
	if (SUCCEEDED(hr))
	{
		*pSkuSetCheck = SkuSetMinus(*pSkuSet, *pSkuSetValidate);

		if (!pSkuSetCheck->testClear() && bIsRequired)
		{
			_tprintf(TEXT("Compile Error: Missing required Node <%s> ")
							TEXT("in SKU: "), 
							rgXMSINodes[niChild].szNodeName);
			PrintSkuIDs(pSkuSetCheck);
			_tprintf(TEXT("\n"));

			//For now, completely break when such error happens
			hr = E_FAIL;
		}
	}

	if (SUCCEEDED(hr))
		delete pSkuSetValidate;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessChildrenList_SKU\n"));
#endif

	return hr;
}  

////////////////////////////////////////////////////////////////////////////
// Function: ProcessChildrenList
//	An overloaded function. Essentially this function is the same as 
//	the one above. The only difference is the information passed through
//	this function to the function that process the children. 
//  This function is used for process <Module>s and <Component>s 
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessChildrenList_SKU(PIXMLDOMNode &pNodeParent, 
								NodeIndex niChild, bool bIsRequired,
								FOM *pFOM, SkuSetValues *pSkuSetValues, 
								HRESULT (*ProcessFunc)
									(PIXMLDOMNode &, FOM *pFOM, 
									 SkuSetValues *pSkuSetValues, 
									 SkuSet *pSkuSet), 
								SkuSet *pSkuSet, SkuSet *pSkuSetCheck)
{
	HRESULT hr = S_OK;

	PIXMLDOMNodeList pNodeListChildren = NULL;
	long iListLength = 0;
	// used to validate: a required node really appears in each SKU
	SkuSet *pSkuSetValidate = NULL;

	assert(pNodeParent != NULL);

	// get the list of children nodes
	if(SUCCEEDED(hr = GetChildrenNodes(pNodeParent, 
									rgXMSINodes[niChild].szNodeName, 
									pNodeListChildren)))
	{
		if(FAILED(hr = pNodeListChildren->get_length(&iListLength)))
		{
			_tprintf(TEXT("Internal Error: Failed to make DOM API call:")
				 TEXT("get_length\n"));
			iListLength = 0;
		}
	}

	if (SUCCEEDED(hr))
	{
		pSkuSetValidate = new SkuSet(g_cSkus);
		assert(pSkuSetValidate);
	}  

	// process each child node in the list
	for (long l=0; l<iListLength; l++)
	{
		PIXMLDOMNode pNodeChild = NULL;
		if (SUCCEEDED(hr = pNodeListChildren->get_item(l, &pNodeChild)))
		{	
			assert(pNodeChild != NULL);
			// Get the SkuSet specified for this child
			SkuSet *pSkuSetChild = NULL;
			if (SUCCEEDED(hr = GetSkuSet(pNodeChild, &pSkuSetChild)))
			{
				assert (pSkuSetChild != NULL);

				// if the child node doesn't have a SKU filter specified,
				//  it inherits the SKU filter from its parent
				// Also get rid of those Skus specified in the child
				// but not in its parent
				*pSkuSetChild &= *pSkuSet;

				// only keep processing if the SkuSet is not empty
				if (!pSkuSetChild->testClear())
				{
					// mark down the Skus that have this child node
					*pSkuSetValidate |= *pSkuSetChild;

					// process the child node;
					hr = ProcessFunc(pNodeChild, pFOM, pSkuSetValues, 
									 pSkuSetChild);
				}

				delete pSkuSetChild;
				pSkuSetChild = NULL;
			}

			if (FAILED(hr))
				break;
		}
		else
		{
			_tprintf(TEXT("Internal Error: Failed to make ")
					 TEXT("DOM API call: get_item\n"));
			break;
		}
	}

	// check if the requied node exists in every SKU
	if (SUCCEEDED(hr)) 
	{
		*pSkuSetCheck = SkuSetMinus(*pSkuSet, *pSkuSetValidate);

		if (!pSkuSetCheck->testClear() && bIsRequired)
		{
			_tprintf(TEXT("Compile Error: Missing required Node <%s> ")
							TEXT("in SKU: "), 
							rgXMSINodes[niChild].szNodeName);
			
			PrintSkuIDs(pSkuSetCheck);
			_tprintf(TEXT("\n"));

			//For now, completely break when such error happens
			hr = E_FAIL;
		}
	}

	if (SUCCEEDED(hr))
		delete pSkuSetValidate;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessChildrenList_SKU\n"));
#endif

	return hr;
}  

////////////////////////////////////////////////////////////////////////////
// Function: ProcessChildrenArray_H_XIS
//   Given a parent node(<ProductFamily> or <Information>) and an array of 
//	 nodeFuncs, this function loops through the array and sequentially process 
//   them using the functions given in the array
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessChildrenArray_H_XIS(PIXMLDOMNode &pNodeParent, 
								  Node_Func_H_XIS *rgNodeFuncs,
								  UINT cNodeFuncs, 
								  const IntStringValue *pisVal_In, 
								  SkuSet *pskuSet)
{
	HRESULT hr = S_OK;
	IntStringValue isVal;

	assert(pNodeParent != NULL);

	for (int i=0; i<cNodeFuncs; i++)
	{
		isVal.intVal = i;

		PIXMLDOMNodeList pNodeListChildren = NULL;
		long iListLength = 0;
		NodeIndex nodeIndex = rgNodeFuncs[i].enumNodeIndex;
		// Get the list of nodes with the same name
		if(SUCCEEDED(hr = GetChildrenNodes(pNodeParent, 
									rgXMSINodes[nodeIndex].szNodeName, 
										pNodeListChildren)))
		{
			if(FAILED(hr = pNodeListChildren->get_length(&iListLength)))
			{
				_tprintf(TEXT("Internal Error: Failed to make DOM API call:")
					 TEXT("get_length\n"));
				break;
			}
		}
		else
			break;

		// used to validate:
		//    (1) a required node really appears in each SKU;
		//    (2) a node that is supposed to appear ONCE really
		//			appears once for each SKU; 
		SkuSet *pskuSetValidate = new SkuSet(g_cSkus);
		assert(pskuSetValidate);

		// process each child node in the list
		for (long l=0; l<iListLength; l++)
		{
			PIXMLDOMNode pNodeChild = NULL;
			if (SUCCEEDED(hr = pNodeListChildren->get_item(l, &pNodeChild)))
			{	
				assert(pNodeChild != NULL);
				// Get the SkuSet specified for this child
				SkuSet *pskuSetChild = NULL;
				if (SUCCEEDED(hr = GetSkuSet(pNodeChild, &pskuSetChild)))
				{
					assert (pskuSetChild != NULL);

					// if the child node doesn't have a SKU filter specified,
					//  it inherits the SKU filter from its parent
					*pskuSetChild &= *pskuSet;

					// only keep processing if the SkuSet is not empty
					if (!pskuSetChild->testClear())
					{
						// check for the uniqueness of this child in each SKU
						if (1 == rgXMSINodes[nodeIndex].uiOccurence)
						{
							SkuSet skuSetTemp = 
								(*pskuSetValidate) & (*pskuSetChild);

							if (!skuSetTemp.testClear())
							{
								_tprintf(TEXT("Error: <%s> appears more than ")
									TEXT("once in SKU: "), 
									rgXMSINodes[nodeIndex].szNodeName);
								for (int j=0; j<g_cSkus; j++)
								{
									if (skuSetTemp.test(j))
										_tprintf(TEXT("%s "), 
												g_rgpSkus[j]->GetID());
								}
								_tprintf(TEXT("\n"));

								// For now, completely break when such error 
								// happens
								hr = E_FAIL;
							}
						}
						*pskuSetValidate |= *pskuSetChild;

						// process the node;
						hr = (rgNodeFuncs[i].pNodeProcessFunc)
									(pNodeChild, &isVal, pskuSetChild);
					}

					delete pskuSetChild;
					pskuSetChild = NULL;
				}

				if (FAILED(hr))
					break;
			}
			else
			{
				_tprintf(TEXT("Internal Error: Failed to make ")
						 TEXT("DOM API call: get_item\n"));
				break;
			}
		}
		
		if (FAILED(hr))
			break;

		// check if the requied node exists in every SKU
		if (SUCCEEDED(hr) && rgXMSINodes[nodeIndex].bIsRequired) 
		{
		    SkuSet skuSetTemp = SkuSetMinus(*pskuSet, *pskuSetValidate);

			if (!skuSetTemp.testClear())
			{
				_tprintf(TEXT("Compile Error: Missing required Node <%s> ")
								TEXT("in SKU: "), 
								rgXMSINodes[nodeIndex].szNodeName);
				for (int j=0; j<g_cSkus; j++)
				{
					if (skuSetTemp.test(j))
						_tprintf(TEXT("%s "), g_rgpSkus[j]->GetID());
				}
				_tprintf(TEXT("\n"));

				//For now, completely break when such error happens
				hr = E_FAIL;
				break;
			}
		}

		delete pskuSetValidate;
	}


#ifdef DEBUG	
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ")
							 TEXT("ProcessChildrenArray_H_XS\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Function: ProcessChildrenArray_H_XIES
//   Given a parent node(<Feature> <Component> <File>) and an array of 
//	 nodeFuncs, this function loops through the array and sequentially process 
//   them using the functions given in the array
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessChildrenArray_H_XIES(PIXMLDOMNode &pNodeParent, 
									Node_Func_H_XIES *rgNodeFuncs,
									UINT cNodeFuncs, 
									ElementEntry *pEE,
									SkuSet *pskuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeParent != NULL);

	for (int i=0; i<cNodeFuncs; i++)
	{
		PIXMLDOMNodeList pNodeListChildren = NULL;
		long iListLength = 0;
		NodeIndex nodeIndex = rgNodeFuncs[i].enumNodeIndex;
		int iColumn = rgNodeFuncs[i].iColumn;
		pEE->SetNodeIndex(nodeIndex, iColumn);
		pEE->SetValType(rgNodeFuncs[i].vt, iColumn);
		
		// skip those elements that don't have one particular function
		// processing them (e.g., KeyPath for Component)
		if (rgNodeFuncs[i].pNodeProcessFunc == NULL)
			continue;

		// Get the list of nodes with the same name
		if(SUCCEEDED(hr = GetChildrenNodes(pNodeParent, 
									rgXMSINodes[nodeIndex].szNodeName, 
										pNodeListChildren)))
		{
			if(FAILED(hr = pNodeListChildren->get_length(&iListLength)))
			{
				_tprintf(TEXT("Internal Error: Failed to make DOM API call:")
					 TEXT("get_length\n"));
				break;
			}
		}
		else
			break;

		// process each child node in the list
		for (long l=0; l<iListLength; l++)
		{
			PIXMLDOMNode pNodeChild = NULL;
			if (SUCCEEDED(hr = pNodeListChildren->get_item(l, &pNodeChild)))
			{	
				assert(pNodeChild != NULL);
				// Get the SkuSet specified for this child
				SkuSet *pskuSetChild = NULL;
				if (SUCCEEDED(hr = GetSkuSet(pNodeChild, &pskuSetChild)))
				{
					assert (pskuSetChild != NULL);

					// if the child node doesn't have a SKU filter specified,
					//  it inherits the SKU filter from its parent
					*pskuSetChild &= *pskuSet;

					if (!pskuSetChild->testClear())
					{
						if (rgNodeFuncs[i].pNodeProcessFunc != NULL)
							// process the node;
							hr = (rgNodeFuncs[i].pNodeProcessFunc)
									(pNodeChild, iColumn, pEE, pskuSetChild);
					}
					delete pskuSetChild;
					pskuSetChild = NULL;
				}

				if (FAILED(hr))
					break;
			}
			else
			{
				_tprintf(TEXT("Internal Error: Failed to make ")
						 TEXT("DOM API call: get_item\n"));
				break;
			}
		}

		if (FAILED(hr))
			break;
	}


#ifdef DEBUG	
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ")
							 TEXT("ProcessChildrenArray_H_XIES\n"));
#endif

	return hr;
}


// Helper function: tells how to update an IntStringValue storing bitfields
HRESULT IsValBitWiseOR(IntStringValue *pisValOut, IntStringValue isValOld, 
					   IntStringValue isValNew)
{
	pisValOut->intVal = isValOld.intVal | isValNew.intVal;

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
// Function: ProcessOnOffAttributes_SKU
//		This function processes an array of On/Off elements, each of which
//		corresponds to a certain bit in a bit field (Attributes of Component,
//		File, etc.)
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessOnOffAttributes_SKU(PIXMLDOMNode &pNodeParent, 
								   AttrBit_SKU *rgAttrBits,
								   UINT cAttrBits, 
								   ElementEntry *pEE, int iColumn,
								   SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeParent != NULL);
#ifdef DEBUG
	_tprintf(TEXT("Inside Function: ProcessOnOffAttributes_SKU\n"));
#endif

	for (int i=0; i<cAttrBits; i++)
	{
		PIXMLDOMNodeList pNodeListChildren = NULL;
		long iListLength = 0;
		NodeIndex nodeIndex = rgAttrBits[i].enumNodeIndex;
		pEE->SetNodeIndex(nodeIndex, iColumn);
		// Get the list of nodes with the same name
		if(SUCCEEDED(hr = GetChildrenNodes(pNodeParent, 
									rgXMSINodes[nodeIndex].szNodeName, 
										pNodeListChildren)))
		{
			if(FAILED(hr = pNodeListChildren->get_length(&iListLength)))
			{
				_tprintf(TEXT("Internal Error: Failed to make DOM API call:")
					 TEXT("get_length\n"));
				break;
			}
		}
		else
			break;

		// process each child node in the list
		for (long l=0; l<iListLength; l++)
		{
			PIXMLDOMNode pNodeChild = NULL;
			if (SUCCEEDED(hr = pNodeListChildren->get_item(l, &pNodeChild)))
			{	
				assert(pNodeChild != NULL);
				// Get the SkuSet specified for this child
				SkuSet *pSkuSetChild = NULL;
				if (SUCCEEDED(hr = GetSkuSet(pNodeChild, &pSkuSetChild)))
				{
					assert (pSkuSetChild != NULL);
					*pSkuSetChild &= *pSkuSet;
					if (!pSkuSetChild->testClear())
					{
						IntStringValue isVal;
						isVal.intVal = rgAttrBits[i].uiBit;
						hr = pEE->SetValueSplit(isVal, iColumn, pSkuSetChild, 
												IsValBitWiseOR);
					}
				}
				delete pSkuSetChild;

				if (FAILED(hr))
					break;
			}
			else
			{
				_tprintf(TEXT("Internal Error: Failed to make ")
						 TEXT("DOM API call: get_item\n"));
				break;
			}
		}
	}


#ifdef DEBUG	
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ")
							 TEXT("ProcessOnOffAttributes_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Function: ProcessEnumAttributes
//		This function processes a single element which can take a value of 
//		among an enumeration that corresponds to certain bits in a bit field.
//		(Attributes of Component, File, etc.)
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessEnumAttributes(PIXMLDOMNode &pNodeParent, 
								  NodeIndex ni, EnumBit *rgEnumBits,
								  UINT cEnumBits, ElementEntry *pEE, 
								  int iColumn, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeParent != NULL);
	assert(pEE);
#ifdef DEBUG
	_tprintf(TEXT("Inside Function: ProcessEnumAttributes\n"));
#endif

	PIXMLDOMNodeList pNodeListChildren = NULL;
	long iListLength = 0;

	pEE->SetNodeIndex(ni, iColumn);

	// Get the list of nodes that represent the same entity in
	// different SKUs
	if(SUCCEEDED(hr = GetChildrenNodes(pNodeParent, 
									rgXMSINodes[ni].szNodeName, 
									pNodeListChildren)))
	{
		if(FAILED(hr = pNodeListChildren->get_length(&iListLength)))
		{
			_tprintf(TEXT("Internal Error: Failed to make DOM API call:")
					 TEXT("get_length\n"));
		}
	}

	// process each node
	if (SUCCEEDED(hr))
	{
		// process each child node in the list
		for (long l=0; l<iListLength; l++)
		{
			PIXMLDOMNode pNodeChild = NULL;
			if (SUCCEEDED(hr = pNodeListChildren->get_item(l, &pNodeChild)))
			{	
				assert(pNodeChild != NULL);
				// Get the SkuSet specified for this child
				SkuSet *pSkuSetChild = NULL;
				if (SUCCEEDED(hr = GetSkuSet(pNodeChild, &pSkuSetChild)))
				{
					assert (pSkuSetChild != NULL);

					*pSkuSetChild &= *pSkuSet;

					// no need to process an element that is good for
					// no SKUs
					if (pSkuSetChild->testClear())
					{
						delete pSkuSetChild;
						break;
					}
					
					// get Value attribute of this node
					IntStringValue isValAttr;
					hr = ProcessAttribute(pNodeChild, 
										  rgXMSINodes[ni].szAttributeName, 
										  STRING, &isValAttr, pSkuSetChild);

					if (SUCCEEDED(hr))
					{
						if (NULL == isValAttr.szVal)
						{
							_tprintf(
						TEXT("Compile Error: Missing required attribute")
						TEXT("\'%s\' of <%s>\n"), 
								rgXMSINodes[ni].szAttributeName, 
								rgXMSINodes[ni].szNodeName);
							hr = E_FAIL;
						}
						else
						{
							IntStringValue isVal;
							for (int i=0; i<cEnumBits; i++)
							{
								if (0==_tcscmp(isValAttr.szVal, 
												rgEnumBits[i].EnumValue))
								{
									isVal.intVal = rgEnumBits[i].uiBit;
									hr = pEE->SetValueSplit(isVal, iColumn, 
												pSkuSetChild, IsValBitWiseOR);
								}
							}
							delete[] isValAttr.szVal;
						}
					}

					delete pSkuSetChild;
					if (FAILED(hr)) break;
				}
				else
					break;

			}
			else
			{
				_tprintf(TEXT("Internal Error: Failed to make ")
						 TEXT("DOM API call: get_item\n"));
				break;
			}
		}
	}


#ifdef DEBUG	
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ")
							 TEXT("ProcessEnumAttributes\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper Function: Return a unique number
////////////////////////////////////////////////////////////////////////////
ULONG GetUniqueNumber()
{
	static ULONG ulNum = 1;
	return ulNum++;
}
	
////////////////////////////////////////////////////////////////////////////
// Helper Function: Return a unique name by postfixing szName with a 
//					unique number
////////////////////////////////////////////////////////////////////////////
LPTSTR GetName(LPTSTR szTable)
{
	int ci = 0;
	LPTSTR szUniqueName = NULL;

	if (0 == g_mapTableCounter.count(szTable))
	{
		// first time see this Table
		LPTSTR szTableTemp = _tcsdup(szTable);
		assert(szTableTemp);

		g_mapTableCounter.insert(LI_ValType(szTableTemp, 1));
		ci = 1;
	}
	else
		ci = ++g_mapTableCounter[szTable];

	// convert the counter into a string
	TCHAR szCI[64];
	_itot(ci, szCI, 10);

	int iLengthCI = _tcslen(szCI);
	assert(iLengthCI<=5);

	TCHAR szPostFix[6];
	for (int i=0; i<5-iLengthCI; i++)
	{
		szPostFix[i] = TEXT('0');
	}

	szPostFix[i] = TEXT('\0');
	_tcscat(szPostFix, szCI);

	int iLength = _tcslen(szTable) + 5;
	szUniqueName = new TCHAR[iLength+4]; // for __ and .
	if (!szUniqueName)
	{
		_tprintf(TEXT("Error: Out of memory\n"));
		return NULL;
	}

	_stprintf(szUniqueName, TEXT("__%s.%s"), szTable, szPostFix);

	return szUniqueName;
}

		


/*
LPTSTR GetName(LPCTSTR szName)
{
	ULONG ul = GetUniqueNumber();
	int iLength = 0;
	LPTSTR szUniqueName = NULL;

	TCHAR szUL[64];
	_itot(ul, szUL, 10);

	iLength = _tcslen(szName);
	iLength += _tcslen(szUL);

	szUniqueName = new TCHAR[iLength+1];
	if (!szUniqueName)
	{
		_tprintf(TEXT("Error: Out of memory\n"));
		return NULL;
	}

	_stprintf(szUniqueName, TEXT("%s%s"), szName, szUL);

	return szUniqueName;
}
*/
////////////////////////////////////////////////////////////////////////////
// Helper Function: print the content of a map 
////////////////////////////////////////////////////////////////////////////
void PrintMap_LI(map<LPTSTR, int, Cstring_less> &LI_map)
{
	map<LPTSTR, int, Cstring_less>::iterator it;

	_tprintf(TEXT("\n**********************************************\n"));
	
	for (it = LI_map.begin(); it != LI_map.end(); ++it)
		_tprintf(TEXT("Key: %s\t Value: %d\n"), (*it).first, (*it).second);

	_tprintf(TEXT("\n**********************************************\n"));
}

void PrintMap_LL(map<LPTSTR, LPTSTR, Cstring_less> &LL_map)
{
	map<LPTSTR, LPTSTR, Cstring_less>::iterator it;

	_tprintf(TEXT("\n**********************************************\n"));
	
	for (it = LL_map.begin(); it != LL_map.end(); ++it)
		_tprintf(TEXT("Key: %s\t Value: %s\n"), (*it).first, (*it).second);

	_tprintf(TEXT("\n**********************************************\n"));
}

void PrintMap_LC(map<LPTSTR, Component *, Cstring_less> &LC_map)
{
	map<LPTSTR, Component *, Cstring_less>::iterator it;

	_tprintf(TEXT("\n**********************************************\n"));
	
	for (it = LC_map.begin(); it != LC_map.end(); ++it)
	{
		_tprintf(TEXT("Key: %s\n Value: \n"), (*it).first);
		((*it).second)->Print();
	}

	_tprintf(TEXT("\n**********************************************\n"));
}

void PrintMap_DirRef(map<LPTSTR, SkuSetValues *, Cstring_less> &map_DirRef)
{
	map<LPTSTR, SkuSetValues *, Cstring_less>::iterator it;

	_tprintf(TEXT("\n**********************************************\n"));
	
	for (it = map_DirRef.begin(); it != map_DirRef.end(); ++it)
	{
		_tprintf(TEXT("Key: %s\n Value:\n"), (*it).first);
		((*it).second)->Print();
	}

	_tprintf(TEXT("\n**********************************************\n"));
}


void PrintMap_LS(map<LPTSTR, SkuSet *, Cstring_less> &LS_map)
{
	map<LPTSTR, SkuSet *, Cstring_less>::iterator it;

	_tprintf(TEXT("\n**********************************************\n"));
	
	for (it = LS_map.begin(); it != LS_map.end(); ++it)
	{
		_tprintf(TEXT("Key: %s\t Value:\n"), (*it).first);
		((*it).second)->print();
	}

	_tprintf(TEXT("\n**********************************************\n"));
}

////////////////////////////////////////////////////////////////////////////
// Helper Function: 
////////////////////////////////////////////////////////////////////////////
UINT WmcRecordGetString(MSIHANDLE hRecord, unsigned int iField, 
								LPTSTR &szValueBuf, DWORD *pcchValueBuf)
{
	UINT errorCode = ERROR_SUCCESS;

	if ( (errorCode = MsiRecordGetString(hRecord, iField, szValueBuf, 
										pcchValueBuf)) == ERROR_MORE_DATA)
		{
			delete[] szValueBuf;
			szValueBuf = new TCHAR[(*pcchValueBuf)+1];
			if (!szValueBuf)
			{
				_tprintf(TEXT("Error: Out of Memory\n"));
				return ERROR_FUNCTION_FAILED;
			}
			(*pcchValueBuf)++;
			errorCode = MsiRecordGetString(hRecord, iField, szValueBuf,
											pcchValueBuf);
		}

	return errorCode;
}

////////////////////////////////////////////////////////////////////////////
// Helper Function: Convert LPTSTR to BSTR
////////////////////////////////////////////////////////////////////////////
BSTR LPTSTRToBSTR(LPCTSTR szName)
{

#ifdef UNICODE
	return SysAllocString(szName);
#else
	
    WCHAR wszURL[MAX_PATH];
    if (0 == MultiByteToWideChar(CP_ACP, 0, szName, -1, wszURL, MAX_PATH))
	{
		_tprintf(TEXT("Internal Error: API call \'MultiByteToWideChar\'") 
				 TEXT("failed.\n"));
 		return NULL; // API call failed
	}
	else 
		return SysAllocString(wszURL);
#endif //UNICODE
}

////////////////////////////////////////////////////////////////////////////
// Helper Function: Convert BSTR to LPTSTR
////////////////////////////////////////////////////////////////////////////
LPTSTR BSTRToLPTSTR(BSTR bString)
{

#ifdef UNICODE
	LPTSTR sz = new TCHAR[_tcslen(bString) + 1];
	_tcscpy(sz, bString);
	return sz;
#else
	int i = SysStringLen(bString);
    LPSTR szString = new CHAR[i + 1];
	if (!szString)
	{
		_tprintf("Error: Out of Memory\n");
		return NULL;
	}
	
    if (0 == WideCharToMultiByte(CP_ACP, 0, bString, -1, szString, i+1, 
									NULL, false))
	{
		// API call failed
		delete[] szString;
		return NULL;
	}
	else
		return szString;
#endif //UNICODE
}

////////////////////////////////////////////////////////////////////////////
// Helper Function: convert GUID to LPTSTR
////////////////////////////////////////////////////////////////////////////
HRESULT GUIDToLPTSTR(LPGUID pGUID, LPTSTR &szGUID)
{
	HRESULT hr = S_OK;
	if (!pGUID)
		return E_INVALIDARG;
	//Build GUID string
	LPTSTR szDSGUID = new TCHAR [128];
	if (!szDSGUID)
	{
		_tprintf(TEXT("Internal Error: Out of memory.\n"));
		return E_FAIL;
	}
	DWORD dwLen =  sizeof(*pGUID);
	LPBYTE lpByte = (LPBYTE) pGUID;
	//Copy a blank string to make it a zero length string.
	_tcscpy( szDSGUID, TEXT(""));
	//Loop through to add each byte to the string.
	for( DWORD dwItem = 0L; dwItem < dwLen ; dwItem++ )
	{
		if(4 == dwItem || 6 == dwItem || 8 == dwItem || 10 == dwItem)
			_stprintf(szDSGUID+_tcslen(szDSGUID), TEXT("-"));
	
		//Append to szDSGUID, double-byte, byte at dwItem index.
		_stprintf(szDSGUID + _tcslen(szDSGUID), TEXT("%02x"), lpByte[dwItem]);
		if( _tcslen( szDSGUID ) > 128 )
			break;
	}

	//Allocate memory for string
	szGUID = new TCHAR[_tcslen(szDSGUID)+1];
	if (!szDSGUID)
	{
		_tprintf(TEXT("Internal Error: Out of memory.\n"));
		return E_FAIL;
	}
	if (szGUID)
		_tcscpy(szGUID, szDSGUID);
	else
	  hr=E_FAIL;
	//Caller must free pszGUID
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper Function: convert a UUID string to all uppercases and add '{' '}'
//                  to the beginning and end of the string
////////////////////////////////////////////////////////////////////////////
HRESULT FormatGUID(LPTSTR &szUuid)
{
	HRESULT hr = S_OK;
	LPTSTR szValue = NULL;
	LPTSTR szValueCurlyBraces = NULL;

	szValue = _tcsupr(szUuid);
	szValueCurlyBraces = new TCHAR[_tcslen(szValue) + 3]; 
	if (!szValueCurlyBraces)
	{
		_tprintf(TEXT("Error: Out of Memory\n"));
		return E_FAIL;
	}
	_stprintf(szValueCurlyBraces, TEXT("{%s}"), szValue);
	delete[] szUuid;
	szUuid = szValueCurlyBraces;

#ifdef DEBUG
	if (FAILED(hr))	_tprintf(TEXT("Error in function: FormatGUID\n"));
#endif
    
	return hr;

}

////////////////////////////////////////////////////////////////////////////
// Helper function: return the child node of pParent with the specified name 
//                  via pChild. S_FALSE is returned if no node found.
////////////////////////////////////////////////////////////////////////////
HRESULT GetChildNode(PIXMLDOMNode &pParent, LPCTSTR szChildName, 
					 PIXMLDOMNode &pChild)
{
    HRESULT hr=S_OK;
	BSTR pBQuery=NULL;

	assert(pParent!=NULL);

	if (NULL == (pBQuery = LPTSTRToBSTR(szChildName)))
	{
		_tprintf(TEXT("Internal Error: String conversion failed\n"));
		hr = E_FAIL;
	}
	else
	{
		if (FAILED(hr = pParent->selectSingleNode(pBQuery, &pChild)))
		{
			_tprintf(TEXT("Internal Error: DOM API call \'selectSingleNode\'")
					 TEXT("failed\n"));
		}
		
		// NOTE: do NOT alter hr value after this line. 

		SysFreeString(pBQuery);
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: GetChildNode\n"));
#endif
    
	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Overloaded function:
//			return the child node of pParent with the specified name 
//          via pChild. S_FALSE is returned if no node found.
////////////////////////////////////////////////////////////////////////////
HRESULT GetChildNode(IXMLDOMNode *pParent, LPCTSTR szChildName, 
					 PIXMLDOMNode &pChild)
{
    HRESULT hr=S_OK;
	BSTR pBQuery=NULL;

	assert(pParent!=NULL);

	if (NULL == (pBQuery = LPTSTRToBSTR(szChildName)))
	{
		_tprintf(TEXT("Internal Error: String conversion failed\n"));
		hr = E_FAIL;
	}
	else
	{
		if (FAILED(hr = pParent->selectSingleNode(pBQuery, &pChild)))
		{
			_tprintf(TEXT("Internal Error: DOM API call \'selectSingleNode\'")
					 TEXT("failed\n"));
		}
		
		// NOTE: do NOT alter hr value after this line. 

		SysFreeString(pBQuery);
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: GetChildNode\n"));
#endif
    
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: return a list of all the children node of pParent with 
//					the specified name via pChild
////////////////////////////////////////////////////////////////////////////
HRESULT GetChildrenNodes(PIXMLDOMNode &pParent, LPCTSTR szChildrenName, 
						 PIXMLDOMNodeList &pChildren)
{
    HRESULT hr=S_OK;
	BSTR pBQuery=NULL;

	assert(pParent != NULL);

	if (NULL == (pBQuery = LPTSTRToBSTR(szChildrenName)))
	{
		_tprintf(TEXT("Internal Error: String conversion failed\n"));
		hr = E_FAIL;
	}
	else
	{
		if (FAILED(hr = pParent->selectNodes(pBQuery, &pChildren)))
		{
			_tprintf(TEXT("Internal Error: DOM API call \'selectNodes\'")
					 TEXT("failed\n"));
		}
		
		SysFreeString(pBQuery);
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: GetChildrenNodes\n"));
#endif
    
	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Helper function: for debug purpose, print out the name of pNode
////////////////////////////////////////////////////////////////////////////
HRESULT PrintNodeName(PIXMLDOMNode &pNode)
{
    HRESULT hr=S_OK;
	BSTR pBNodeName = NULL;

	if (FAILED(hr = pNode->get_nodeName(&pBNodeName)))
	{
		_tprintf(TEXT
				("Internal Error: DOM API call \'get_nodeName\' failed\n"));
	}
	else
	{
		_tprintf(TEXT("Processing tag: %ls\n"), pBNodeName);
	}

	if (pBNodeName)
		SysFreeString(pBNodeName);
	
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: PrintNodeName\n"));

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: return the value of pNode's attribute with name 
//                  szAttrName via vAttrValue
////////////////////////////////////////////////////////////////////////////
HRESULT GetAttribute(PIXMLDOMNode &pNode, LPCTSTR szAttrName, 
						VARIANT &vAttrValue)
{
    HRESULT hr=S_OK;
	PIXMLDOMElement pElement=NULL;
	BSTR pBAttrName=NULL;

	assert(pNode != NULL);

	if (FAILED(hr = pNode->QueryInterface(IID_IXMLDOMElement, 
												(void **)&pElement)))
	{
		_tprintf(TEXT
				("Internal Error: DOM API call \'QueryInterface\' failed\n"));
	}
	else if (NULL == (pBAttrName = LPTSTRToBSTR(szAttrName)))
	{
		_tprintf(TEXT("Internal Error: string conversion failed\n"));
		hr = E_FAIL;
	}
	else
	{
		if (FAILED(hr = pElement->getAttribute(pBAttrName, &vAttrValue)))
		{
			_tprintf(
				TEXT("Internal Error: DOM API call \'getAttribute\' failed\n"));
		}

		//NOTE: do NOT alter hr value after this line!
		
		SysFreeString(pBAttrName);
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: GetAttribute\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: return the value of pNode's ID attribute via szID.
//                  if pNode doesn't have a ID attribute, szID = NULL 
////////////////////////////////////////////////////////////////////////////
HRESULT GetID(PIXMLDOMNode &pNode, LPCTSTR &szID)
{
    HRESULT hr=S_OK;
	VARIANT vVal;

	assert (pNode != NULL);

	VariantInit(&vVal);
	if(SUCCEEDED(hr = GetAttribute(pNode, TEXT("ID"), vVal))) 
	{
		if(S_FALSE != hr)
		{
			if (NULL == (szID = BSTRToLPTSTR(vVal.bstrVal)))
			{
				_tprintf(TEXT("Internal Error: string conversion failed\n"));
				hr = E_FAIL;
				szID = NULL;
			}
		}
		else // ID attribute doesn't exist
		{
			szID = NULL;
		}
	}

	VariantClear(&vVal);	

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: GetID\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Function: Load an XML Document from the specified file or URL synchronously.
////////////////////////////////////////////////////////////////////////////
HRESULT LoadDocumentSync(PIXMLDOMDocument2 &pDoc, BSTR pBURL)
{
    HRESULT         hr = S_OK;
    PIXMLDOMParseError  pXMLError = NULL;
    VARIANT         vURL;
    VARIANT_BOOL    vb = VARIANT_FALSE;

    if (FAILED(hr = pDoc->put_async(VARIANT_FALSE)))
	{
		_tprintf(TEXT("Internal Error: DOM API call put_async failed \n"));
	}
	else if(FAILED(hr = pDoc->put_validateOnParse(VARIANT_TRUE)))
	{
		_tprintf(TEXT
			("Internal Error: DOM API call put_validateOnParse failed\n"));
	}
	else
	{
		// Load xml document from the given URL or file path
		VariantInit(&vURL);
		vURL.vt = VT_BSTR;
		vURL.bstrVal = pBURL;
		if (FAILED(hr = pDoc->load(vURL, &vb)))
		{
			_tprintf(TEXT("Internal Error: DOM API call load failed \n"));
		}
		else if (vb == VARIANT_FALSE)
		{
			hr = CheckLoad(pDoc);
		}
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: LoadDocumentSync\n"));
#endif
    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Report parsing error information
////////////////////////////////////////////////////////////////////////////
HRESULT ReportError(PIXMLDOMParseError &pXMLError)
{
    long line, linePos;
    LONG errorCode;
    BSTR pBURL=NULL, pBReason=NULL;
    HRESULT hr = E_FAIL;

    if ( SUCCEEDED(pXMLError->get_line(&line)) && 
		SUCCEEDED(pXMLError->get_linepos(&linePos)) &&
		SUCCEEDED(pXMLError->get_errorCode(&errorCode)) &&
		SUCCEEDED(pXMLError->get_url(&pBURL)) &&
		SUCCEEDED(pXMLError->get_reason(&pBReason)) )
	{
	    _ftprintf(stderr, TEXT("%S"), pBReason);
	    if (line > 0)
	    {
	        _tprintf(TEXT("Error found by MSXML parser:")
					 TEXT("on line %d, position %d in \"%S\".\n"), 
						line, linePos, pBURL);
		}
	}
	else 
	{
		_tprintf(
			TEXT("Internal Error: DOM API call on IMLDOMParseError failed\n"));
	}

    if (pBURL)
		SysFreeString(pBURL);
	if (pBReason)
		SysFreeString(pBReason);

    return hr;
}


////////////////////////////////////////////////////////////////////////////
// Helper function: Check load results
////////////////////////////////////////////////////////////////////////////
HRESULT CheckLoad(PIXMLDOMDocument2 &pDoc)
{
    PIXMLDOMParseError  pXMLError = NULL;
    LONG errorCode = E_FAIL;
    HRESULT hr = S_OK;

    if (FAILED(hr = pDoc->get_parseError(&pXMLError)))
	{
		_tprintf(TEXT("Internal Error: DOM API call get_parseError failed\n"));
	}
	else if (FAILED(hr = pXMLError->get_errorCode(&errorCode)))
	{
		_tprintf(TEXT("Internal Error: DOM API call get_errorCode failed\n"));
	}
	else 
	{
	    if (errorCode != 0)
		{
	        hr = ReportError(pXMLError);
		}
		else
		{
			_ftprintf(stderr, TEXT("XML document loaded successfully\n"));
	    }
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: CheckLoad\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper Function: Print error returned by MSI API function 
////////////////////////////////////////////////////////////////////////////
void PrintError(UINT errorCode)
{
	switch (errorCode) {

	case ERROR_ACCESS_DENIED:
		_tprintf(TEXT("***ERROR_ACCESS_DENIED***\n"));
		break;
	case ERROR_BAD_PATHNAME:
		_tprintf(TEXT("***ERROR_BAD_PATHNAME***\n"));
		break;
	case ERROR_BAD_QUERY_SYNTAX:
		_tprintf(TEXT("***ERROR_BAD_QUERY_SYNTAX***\n"));
		break;
	case ERROR_CREATE_FAILED:
		_tprintf(TEXT("***ERROR_CREATE_FAILED***\n"));
		break;
	case ERROR_FUNCTION_FAILED:
		_tprintf(TEXT("***ERROR_FUNCTION_FAILED***\n"));
		break;
	case ERROR_INVALID_DATA:
		_tprintf(TEXT("***ERROR_INVALID_DATA***\n"));
		break;		
	case ERROR_INVALID_FIELD:
		_tprintf(TEXT("***ERROR_INVALID_FIELD***\n"));
		break;
	case ERROR_INVALID_HANDLE:
		_tprintf(TEXT("***ERROR_INVALID_HANDLE***\n"));
		break;
	case ERROR_INVALID_HANDLE_STATE:
		_tprintf(TEXT("***ERROR_INVALID_HANDLE_STATE***\n"));
		break;
	case ERROR_INVALID_PARAMETER:
		_tprintf(TEXT("***ERROR_INVALID_PARAMETER***\n"));
		break;
	case ERROR_MORE_DATA:
		_tprintf(TEXT("***ERROR_MORE_DATA***\n"));
		break;
	case ERROR_NO_MORE_ITEMS:
		_tprintf(TEXT("***ERROR_NO_MORE_ITEMS***\n"));
		break;
	case ERROR_OPEN_FAILED:
		_tprintf(TEXT("***ERROR_OPEN_FAILED***\n"));
		break;
	case ERROR_SUCCESS:
		_tprintf(TEXT("***ERROR_SUCCESS***\n"));
		break;
	default:
		_tprintf(TEXT("Unrecognized Error\n"));
		break;
	}
}

////////////////////////////////////////////////////////////////////////////
// GetSQLCreateQuery: 
//		Given a template DB and a table name, return the SQL query string
//		for creating that table via pszSQLCreate
////////////////////////////////////////////////////////////////////////////
HRESULT GetSQLCreateQuery(LPTSTR szTable, MSIHANDLE hDBTemplate, 
						  LPTSTR *pszSQLCreate)
{
	// Issue: in the future, should cache SQLQuery per Template DB
	//		  use a map indexed by installerversion
    HRESULT hr = S_OK;
	UINT errorCode = ERROR_SUCCESS;
	LPTSTR szTemp = NULL;

	int cColumn = -1, i =1; // Record field count
	LPTSTR szSQLCreate = NULL;

	PMSIHANDLE hView = NULL;
	PMSIHANDLE hRecColName = NULL;
	PMSIHANDLE hRecColType = NULL;
	PMSIHANDLE hRecPrimaryKeys = NULL;

	CQuery qDBSchema;

	szSQLCreate = new TCHAR[_tcslen(szTable) + 20];
	assert(szSQLCreate!=NULL);

	_stprintf(szSQLCreate, TEXT("CREATE TABLE `%s` ("), szTable);

	if ((errorCode = qDBSchema.Open(hDBTemplate, TEXT("SELECT * From %s"), 
										szTable))
			!= ERROR_SUCCESS)
	{
		_tprintf(TEXT("Error: failed to open CQuery qDBSchema\n"));
		goto CleanUp;
	}
		
	if ((errorCode = qDBSchema.GetColumnInfo(MSICOLINFO_NAMES, &hRecColName))
			!= ERROR_SUCCESS)
	{
		_tprintf(TEXT("Error: failed to get column info - names\n"));
		goto CleanUp;
	}

	if ((errorCode = qDBSchema.GetColumnInfo(MSICOLINFO_TYPES, &hRecColType)) 
		!= ERROR_SUCCESS)
	{
		_tprintf(TEXT("Error: failed to get column info - types\n"));
		goto CleanUp;
	}

	cColumn = MsiRecordGetFieldCount(hRecColName);
	if (-1 == cColumn)
	{
		_tprintf(TEXT("ERROR: Failed to get field count. \n"));
		hr = E_FAIL;
		goto CleanUp;
	}
	
	for (i=1; i<=cColumn; i++)
	{
		// get the name of the ith column
		LPTSTR szColumnName = new TCHAR[256];
		DWORD cchColumnName = 256;

		if ( (errorCode = WmcRecordGetString(hRecColName, i, szColumnName,
											&cchColumnName))
				!= ERROR_SUCCESS)
		{
			_tprintf(TEXT("Error: failed when calling WmcRecordGetString\n"));
			delete[] szColumnName;
			goto CleanUp;
		}
	
		szTemp = szSQLCreate;
		szSQLCreate = new TCHAR[_tcslen(szTemp) + _tcslen(szColumnName) + 3];
		assert(szSQLCreate!=NULL);
		_stprintf(szSQLCreate, TEXT("%s`%s`"), szTemp, szColumnName);
		
		delete[] szColumnName;
		delete[] szTemp;
		szTemp=NULL;

		// get the description of the ith column
		LPTSTR szColumnType = new TCHAR[256];
		DWORD cchColumnType = 256;

		if ( (errorCode = WmcRecordGetString(hRecColType, i, szColumnType, 
												&cchColumnType))
					!= ERROR_SUCCESS)
		{
			_tprintf(TEXT("Error: failed when calling WmcRecordGetString\n"));
			delete[] szColumnType;
			goto CleanUp;
		}

		switch (*szColumnType) {
			case 's' :
			case 'S' :
			case 'l' :
			case 'L' :
				if ( (2 == _tcslen(szColumnType)) && ('0' == *(szColumnType+1)) )
				{
					szTemp = szSQLCreate;
					szSQLCreate = new TCHAR[_tcslen(szTemp) + 10];
					assert(szSQLCreate!=NULL);
					_stprintf(szSQLCreate, TEXT("%s LONGCHAR"), szTemp);
					delete[] szTemp;
					szTemp = NULL;
				}
				else
				{
					szTemp = szSQLCreate;
					szSQLCreate = 
						new TCHAR[_tcslen(szTemp)+_tcslen(szColumnType)-1 + 9];
					assert(szSQLCreate!=NULL);
					_stprintf(szSQLCreate, TEXT("%s CHAR (%s)"), szTemp, 
									szColumnType+1);
					delete[] szTemp;
					szTemp = NULL;
				}
				break;
			case 'i' :
			case 'I' :
				if ( '2' == *(szColumnType+1) )		
				{
					szTemp = szSQLCreate;
					szSQLCreate = new TCHAR[_tcslen(szTemp) + 7];
					assert(szSQLCreate!=NULL);
					_stprintf(szSQLCreate, TEXT("%s SHORT"), szTemp);
					delete[] szTemp;
					szTemp = NULL;
				}

				else if ( '4' == *(szColumnType+1) )
				{
					szTemp = szSQLCreate;
					szSQLCreate = new TCHAR[_tcslen(szTemp) + 6];
					assert(szSQLCreate!=NULL);
					_stprintf(szSQLCreate, TEXT("%s LONG"), szTemp);
					delete[] szTemp;
					szTemp = NULL;
				}
				else // should not happen
				{
					_tprintf(TEXT("Error: invalid character returned from")
							 TEXT("MsiGetColumnInfo\n"));
					errorCode = ERROR_INVALID_DATA;
					goto CleanUp;
				}
				break;
			case 'v' :
				{
					szTemp = szSQLCreate;
					szSQLCreate = new TCHAR[_tcslen(szTemp) + 8];
					assert(szSQLCreate!=NULL);
					_stprintf(szSQLCreate, TEXT("%s OBJECT"), szTemp);
					delete[] szTemp;
					szTemp = NULL;
				}
				break;
			case 'g' :
			case 'j' :
				//Issue: is temporary column possible?
			default: // should not happen
				_tprintf(TEXT("Error: invalid character returned from")
						 TEXT("MsiGetColumnInfo\n"));
				errorCode = ERROR_INVALID_DATA;
				goto CleanUp;
		}

		if (_istlower(*szColumnType))
		{
			szTemp = szSQLCreate;
			szSQLCreate = new TCHAR[_tcslen(szTemp) + 10];
			assert(szSQLCreate!=NULL);
			_stprintf(szSQLCreate, TEXT("%s NOT NULL"), szTemp);
			delete[] szTemp;
			szTemp = NULL;
		}

		if ( ('l' == *szColumnType) || ('L' == *szColumnType) )
		{
			szTemp = szSQLCreate;
			szSQLCreate = new TCHAR[_tcslen(szTemp) + 13];
			assert(szSQLCreate!=NULL);
			_stprintf(szSQLCreate, TEXT("%s LOCALIZABLE"), szTemp);
			delete[] szTemp;
			szTemp = NULL;
		}

		if (i < cColumn)
		{
			szTemp = szSQLCreate;
			szSQLCreate = new TCHAR[_tcslen(szTemp) + 3];
			assert(szSQLCreate!=NULL);
			_stprintf(szSQLCreate, TEXT("%s, "), szTemp);
			delete[] szTemp;
			szTemp = NULL;
		}

		delete[] szColumnType;
	}
	
	szTemp = szSQLCreate;
	szSQLCreate = new TCHAR[_tcslen(szTemp) + 14];
	assert(szSQLCreate!=NULL);
	_stprintf(szSQLCreate, TEXT("%s PRIMARY KEY "), szTemp);
	delete[] szTemp;
	szTemp = NULL;

	if ( (errorCode = MsiDatabaseGetPrimaryKeys(hDBTemplate, szTable, 
													&hRecPrimaryKeys))
			!= ERROR_SUCCESS)
	{
		_tprintf(TEXT("Error: failed to get primary keys\n"));
		goto CleanUp;
	}

	cColumn = MsiRecordGetFieldCount(hRecPrimaryKeys);

	if (-1 == cColumn)
	{
		_tprintf(TEXT("ERROR: Failed to get field count. \n"));
		hr = E_FAIL;
		goto CleanUp;
	}
	
	for (i=1; i<=cColumn; i++)
	{
		LPTSTR szPrimaryKey = new TCHAR[256];
		DWORD cchPrimaryKey = 256;

		if ( (errorCode = WmcRecordGetString(hRecPrimaryKeys, i, szPrimaryKey,
												&cchPrimaryKey))
					!= ERROR_SUCCESS)
		{
			_tprintf(TEXT("Error: failed when calling WmcRecordGetString\n"));
			delete[] szPrimaryKey;
			goto CleanUp;
		}
	
		szTemp = szSQLCreate;
		szSQLCreate = new TCHAR[_tcslen(szTemp) + _tcslen(szPrimaryKey) + 3];
		assert(szSQLCreate!=NULL);
		_stprintf(szSQLCreate, TEXT("%s`%s`"), szTemp, szPrimaryKey);
		delete[] szTemp;
		szTemp = NULL;

		if (i < cColumn)
		{
			szTemp = szSQLCreate;
			szSQLCreate = new TCHAR[_tcslen(szTemp) + 3];
			assert(szSQLCreate!=NULL);
			_stprintf(szSQLCreate, TEXT("%s, "), szTemp);
			delete[] szTemp;
			szTemp = NULL;
		}
		delete[] szPrimaryKey;
	}

	szTemp = szSQLCreate;
	szSQLCreate = new TCHAR[_tcslen(szTemp) + 2];
	assert(szSQLCreate!=NULL);
	_stprintf(szSQLCreate, TEXT("%s)"), szTemp);
	delete[] szTemp;
	szTemp = NULL;


CleanUp:

	if (FAILED(hr) || (errorCode != ERROR_SUCCESS)) {
		_tprintf(TEXT("Error in function: GetSQLCreateQuery when creating query for table: %s\n")
			, szTable);
		if (szSQLCreate)
			delete[] szSQLCreate;
		*pszSQLCreate = NULL;
		hr = E_FAIL;
	}
	else
	{
		*pszSQLCreate = szSQLCreate;
	}

	if (szTemp)
		delete[] szTemp;

	qDBSchema.Close();

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// CreateTable: 
////////////////////////////////////////////////////////////////////////////
HRESULT CreateTable_SKU(LPTSTR szTable, SkuSet *pskuSet)
{
    HRESULT hr = S_OK;
	UINT errorCode = ERROR_SUCCESS;

	// Find all the SKUs that need to create the Property table 
	for (int i=0; i<g_cSkus; i++)
	{
		if (pskuSet->test(i))
		{
			// only create table if the table doesn't already exist
			if (!g_rgpSkus[i]->TableExists(szTable))
			{
				LPTSTR szSQLCreate = NULL;
				CQuery qCreateTable;
				
				// use the template DB to form the SQL query for table creation
				hr = GetSQLCreateQuery(szTable, g_rgpSkus[i]->m_hTemplate, 
										&szSQLCreate);

				if (SUCCEEDED(hr))
				{
					// now use the formed SQL string to create the table in the 
					// output database
					if (ERROR_SUCCESS !=
						(errorCode = qCreateTable.OpenExecute
										(g_rgpSkus[i]->m_hDatabase, 
												NULL, szSQLCreate)))
					{
						_tprintf(TEXT("Error: Failed to use the formed SQL")
								 TEXT("string to create the table %s\n"), 
								 szTable);
						PrintError(errorCode);
						hr = E_FAIL;
						break;
					}
					else 
					{
						// create a CQuery to be used for future insertion 
						// into this table and cache it in the Sku object
						hr = g_rgpSkus[i]->CreateCQuery(szTable);
						qCreateTable.Close();
					}

					delete[] szSQLCreate;
					if (FAILED(hr)) break;
				}
			}
		}
	}

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert a record into the specified table in the database
//				    This function will either perform insertion for a set
//					of Skus or just for a single Sku, depending on whether
//					pskuSet == NULL or not.
////////////////////////////////////////////////////////////////////////////
HRESULT InsertDBTable_SKU(LPTSTR szTable, PMSIHANDLE &hRec, SkuSet *pskuSet,
						  int iSkuIndex)
{
	HRESULT hr = S_OK;
	UINT errorCode = ERROR_SUCCESS;

	// if pskuSet is NULL, it means that only insertion into ONE SKU
	// (indexed by iSkuIndex) is needed
	if (!pskuSet)
	{
		assert((iSkuIndex >=0) && (iSkuIndex<g_cSkus));
		// never attempt to insert into a table that hasn't been created yet
		assert(g_rgpSkus[iSkuIndex]->TableExists(szTable));

		// Obtain the CQuery stored in the map
		CQuery *pCQuery = g_rgpSkus[iSkuIndex]->GetInsertQuery(szTable);
		
		if (ERROR_SUCCESS != 
				(errorCode = pCQuery->Modify(MSIMODIFY_INSERT, hRec)))
		{
			PrintError(errorCode);
			_tprintf(TEXT("Error: Failed to insert into %s table for SKU %s\n"), 
				szTable, g_rgpSkus[iSkuIndex]->GetID());
			hr = E_FAIL;
		}

		return hr;
	}

	for (int i=0; i<g_cSkus; i++)
	{
		if (pskuSet->test(i))
		{
			// never attempt to insert into a table that hasn't been created
			// yet
			assert(g_rgpSkus[i]->TableExists(szTable));

			// Obtain the CQuery stored in the map
			CQuery *pCQuery = g_rgpSkus[i]->GetInsertQuery(szTable);
			
			if (ERROR_SUCCESS != 
				(errorCode = pCQuery->Modify(MSIMODIFY_INSERT, hRec)))
			{
				PrintError(errorCode);
				_tprintf(TEXT("Error: Failed to insert into %s table for ")
						 TEXT("SKU %s\n"), 
					szTable, g_rgpSkus[i]->GetID());
				hr = E_FAIL;
				break;
			}
		}
	}

	return hr;
}
////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the Property table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertProperty(LPCTSTR szProperty, LPCTSTR szValue, SkuSet *pskuSet,
					   int iSkuIndex)
{
    HRESULT hr=S_OK;
	
	PMSIHANDLE hRec = MsiCreateRecord(2);

	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szProperty) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szValue))
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string ")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("Property"), hRec, pskuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertPropertyTable\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the Directory table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertDirectory(LPCTSTR szDirectory, LPCTSTR szDirectory_Parent, 
						LPCTSTR szDefaultDir, SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(3);

	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szDirectory) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szDirectory_Parent) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szDefaultDir) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string ")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("Directory"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertDirectory\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the Feature table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertFeature(LPCTSTR szFeature, LPCTSTR szFeatureParent, 
					  LPCTSTR szTitle, LPCTSTR szDescription, int iDisplay, 
					  int iInstallLevel, LPCTSTR szDirectory, UINT iAttribute,
					  SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	if (MSI_NULL_INTEGER == iAttribute)
		iAttribute = 0;

	PMSIHANDLE hRec = MsiCreateRecord(8);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFeature) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szFeatureParent) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szTitle) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 4, szDescription) ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 5, iDisplay) ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 6, iInstallLevel) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 7, szDirectory) ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 8, iAttribute) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("Feature"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertFeature\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the Condition table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertCondition(LPCTSTR szFeature_, int iLevel, LPCTSTR szCondition, 
					  SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(3);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFeature_) ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 2, iLevel) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szCondition) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord")
					 TEXT(" parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("Condition"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertCondition\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the FeatureComponents table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertFeatureComponents(LPCTSTR szFeature, LPCTSTR szComponent, 
								SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;
	assert(szFeature && szComponent);

	PMSIHANDLE hRec = MsiCreateRecord(2);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFeature) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szComponent) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("FeatureComponents"), hRec, pSkuSet,
								iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: InsertFeatureComponents\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the Component table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertComponent(LPCTSTR szComponent, LPCTSTR szComponentId, 
						LPCTSTR szDirectory_, UINT iAttributes, 
						LPCTSTR szCondition, LPCTSTR szKeyPath, 
						SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	if (MSI_NULL_INTEGER == iAttributes)
		iAttributes = 0;
	PMSIHANDLE hRec = MsiCreateRecord(6);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szComponent) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szComponentId) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szDirectory_) ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 4, iAttributes) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 5, szCondition) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 6, szKeyPath) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("Component"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertComponent\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the CreateFolder table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertCreateFolder(LPCTSTR szDirectory, LPCTSTR szComponent, 
						   SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(2);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szDirectory) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szComponent) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("CreateFolder"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertCreateFolder\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the LockPermissions table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertLockPermissions(LPCTSTR szLockObject, LPCTSTR szTable, 
							  LPCTSTR szDomain, LPCTSTR szUser,
			  				  int iPermission, SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(5);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szLockObject) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szTable)	   ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szDomain)	   ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 4, szUser)	   ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec,5, iPermission))
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("LockPermissions"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertLockPermissions\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the File table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertFile(LPCTSTR szFile, LPCTSTR szComponentId,
				   LPCTSTR szFileName, UINT uiFileSize, LPCTSTR szVersion, 
				   LPCTSTR szLanguage, UINT iAttributes, INT iSequence,
				   SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(8);

	if (MSI_NULL_INTEGER == uiFileSize) {
		uiFileSize = 0;
	}

	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFile) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szComponentId) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szFileName) ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 4, uiFileSize) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 5, szVersion) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 6, szLanguage) || 
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 7, iAttributes) ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 8, iSequence) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("File"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertFile\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the Font table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertFont(LPCTSTR szFile_, LPCTSTR szFontTitle, SkuSet *pSkuSet,
				   int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(2);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFile_) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szFontTitle) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("Font"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertFont\n"));
#endif

    return hr;
}


////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the BindImage table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertBindImage(LPCTSTR szFile_, LPCTSTR szPath, SkuSet *pSkuSet, 
						int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(2);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFile_) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szPath) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("BindImage"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertBindImage\n"));
#endif

    return hr;
}


////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the SelfReg table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertSelfReg(LPCTSTR szFile_, UINT uiCost, SkuSet *pSkuSet, 
					  int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(2);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFile_) ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 2, uiCost) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string") 
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("SelfReg"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertSelfReg\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the MoveFile table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertMoveFile(LPCTSTR szFileKey, LPCTSTR szComponent_, 
					   LPCTSTR szSourceName, LPCTSTR szDestName, 
					   LPCTSTR szSourceFolder, LPCTSTR szDestFolder,
					   UINT uiOptions, SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(7);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFileKey)		 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szComponent_)	 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szSourceName)	 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 4, szDestName)	 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 5, szSourceFolder) ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 6, szDestFolder)	 ||
		    ERROR_SUCCESS != MsiRecordSetInteger(hRec, 7, uiOptions) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string") 
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("MoveFile"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertMoveFile\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the RemoveFile table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertRemoveFile(LPCTSTR szFileKey, LPCTSTR szComponent_, 
					   LPCTSTR szFileName, LPCTSTR szDirProperty, 
					   UINT uiInstallMode, SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(7);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFileKey)		 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szComponent_)	 ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szFileName)	 ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 4, szDirProperty)	 ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 5, uiInstallMode) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string") 
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("RemoveFile"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertRemoveFile\n"));
#endif

    return hr;
}


////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the IniFile table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertIniFile(LPCTSTR szIniFile, LPCTSTR szFileName, 
					  LPCTSTR szDirProperty, LPCTSTR szSection, LPCTSTR szKey,
					  LPCTSTR szValue, UINT uiAction, LPCTSTR szComponent_,
					  SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(8);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szIniFile)		 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szFileName)	 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szDirProperty)	 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 4, szSection)		 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 5, szKey)			 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 6, szValue)		 ||
		    ERROR_SUCCESS != MsiRecordSetInteger(hRec, 7, uiAction)		 ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 8, szComponent_)	)
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string") 
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("IniFile"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertIniFile\n"));
#endif

    return hr;
}

//ISSUE: this function is virtually the same as the InsertIniFIle. 
//		 Make them one function?
////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the RemoveIniFile table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertRemoveIniFile(LPCTSTR szRemoveIniFile, LPCTSTR szFileName, 
						    LPCTSTR szDirProperty, LPCTSTR szSection, 
							LPCTSTR szKey, LPCTSTR szValue, UINT uiAction, 
							LPCTSTR szComponent_, SkuSet *pSkuSet, 
							int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(8);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szRemoveIniFile)||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szFileName)	 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szDirProperty)	 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 4, szSection)		 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 5, szKey)			 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 6, szValue)		 ||
		    ERROR_SUCCESS != MsiRecordSetInteger(hRec, 7, uiAction)		 ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 8, szComponent_)	)
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string") 
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("RemoveIniFile"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertRemoveIniFile\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the RemoveRegistry table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertRegistry(LPCTSTR szRegistry, int iRoot, LPCTSTR szKey, 
					   LPCTSTR szName, LPCTSTR szValue, LPCTSTR szComponent_, 
					   SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(6);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szRegistry)	  ||
		    ERROR_SUCCESS != MsiRecordSetInteger(hRec, 2, iRoot)		  ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szKey)			  ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 4, szName)		  ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 5, szValue)		  ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 6, szComponent_)	)
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string") 
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("Registry"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertRegistry\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the RemoveRegistry table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertRemoveRegistry(LPCTSTR szRemoveRegistry, int iRoot, 
						     LPCTSTR szKey, LPCTSTR szName, 
							 LPCTSTR szComponent_, SkuSet *pSkuSet, 
							 int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(5);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szRemoveRegistry)||
		    ERROR_SUCCESS != MsiRecordSetInteger(hRec, 2, iRoot)		  ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szKey)			  ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 4, szName)		  ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 5, szComponent_)	)
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string") 
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("RemoveRegistry"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertRemoveRegistry\n"));
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\res\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\utilities.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       Utilities.h
//              
//				Utility functions
//--------------------------------------------------------------------------

#ifndef XMSI_UTILITIES_H
#define XMSI_UTILITIES_H

#include "wmc.h"

////////////////////////////////////////////////////////////////////////////
//	Free the memory used by the global data structures
////////////////////////////////////////////////////////////////////////////
void CleanUp();

////////////////////////////////////////////////////////////////////////////
//	Commit changes made to the DB. Final step for the compiler
////////////////////////////////////////////////////////////////////////////
UINT CommitChanges();

////////////////////////////////////////////////////////////////////////////
//	Dynamically generate a GUID
////////////////////////////////////////////////////////////////////////////
HRESULT GeneratePackageCode(MSIHANDLE hSummaryInfo);

////////////////////////////////////////////////////////////////////////////
//  Given a Sku filter string, return the SkuSet that represents the result
//		Sku Group.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessSkuFilter(LPTSTR szInputSkuFilter, SkuSet **ppskuSet);

////////////////////////////////////////////////////////////////////////////
// GetSkuSet
//    Given a node:
//		1) Get the Sku Filter specified with the node;
//		2) Process the filter and get the result SkuSet;
//		3) Return the SkuSet via ppskuSet;
////////////////////////////////////////////////////////////////////////////
HRESULT GetSkuSet(PIXMLDOMNode &pNode, SkuSet **ppskuSet);

////////////////////////////////////////////////////////////////////////////
// ProcessAttribute
//    Given a parent node, an attribute name and an attribute type (int or
//	  string),  this function returns the string value of the attribute 
//	  via isVal. If the attribute doesn't exist, value returned will be
//	  NULL if vt = STRING, or 0 if vt = INTEGER
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessAttribute(PIXMLDOMNode &pNodeParent, LPCTSTR szAttributeName,
						 ValType vt, IntStringValue *isVal, 
						 const SkuSet *pskuSet);

////////////////////////////////////////////////////////////////////////////
//   Process nodes with Short attribute and long attribute and form a C-style 
//   string: Short|Long
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessShortLong_SKU(PIXMLDOMNode &pNode, IntStringValue *pIsValOut,
							 SkuSet *pSkuSet);

////////////////////////////////////////////////////////////////////////////
// Process the On/Off entities which set certain bit in a attribute
// value. 
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessOnOffAttributes_SKU(PIXMLDOMNode &pNodeParent, 
								   AttrBit_SKU *rgAttrBits,
								   UINT cAttrBits, 
								   ElementEntry *pEE, int iColumn,
								   SkuSet *pSkuSet);

HRESULT ProcessSimpleElement(PIXMLDOMNode &pNode, int iColumn, 
							 ElementEntry *pEE, SkuSet *pSkuSet);

HRESULT ProcessRefElement(PIXMLDOMNode &pNodeRef,  int iColumn, 
 						  ElementEntry *pEE, SkuSet *pSkuSet);

////////////////////////////////////////////////////////////////////////////
// Process KeyPath attribute of an element
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessKeyPath(PIXMLDOMNode &pNode, LPTSTR szComponent, 
					   LPTSTR szKeyPath, SkuSet *pSkuSet);

////////////////////////////////////////////////////////////////////////////
// Function: ProcessEnumAttributes
//		This function processes a single element which can take a value of 
//		among an enumeration that corresponds to certain bits in a bit field.
//		(Attributes of Component, File, etc.)
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessEnumAttributes(PIXMLDOMNode &pNodeParent, 
								  NodeIndex ni, EnumBit *rgEnumBits,
								  UINT cEnumBits, ElementEntry *pEE, 
								  int iColumn, SkuSet *pSkuSet);

////////////////////////////////////////////////////////////////////////////
//   Given a parent node and a child node name, this function finds all the
//   children node of that name and sequentially process them using the 
//   function passed in.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessChildrenList_SKU(PIXMLDOMNode &pNodeParent, 
								NodeIndex niChild, bool bIsRequired,
								IntStringValue isVal, 
								HRESULT (*ProcessFunc)
									(PIXMLDOMNode &, IntStringValue isVal, 
										SkuSet *pSkuSet), 
								SkuSet *pSkuSet);

HRESULT ProcessChildrenList_SKU(PIXMLDOMNode &pNodeParent, 
								NodeIndex niChild, bool bIsRequired,
								IntStringValue isVal, 
								HRESULT (*ProcessFunc)
									(PIXMLDOMNode &, IntStringValue isVal, 
										SkuSet *pSkuSet), 
								SkuSet *pSkuSet, SkuSet *pSkuSetCheck);

HRESULT ProcessChildrenList_SKU(PIXMLDOMNode &pNodeParent, 
								NodeIndex niChild, bool bIsRequired,
								FOM *pFOM, SkuSetValues *pSkuSetValues, 
								HRESULT (*ProcessFunc)
									(PIXMLDOMNode &, FOM *pFOM, 
									 SkuSetValues *pSkuSetValues, 
									 SkuSet *pSkuSet), 
								SkuSet *pSkuSet, SkuSet *pSkuSetCheck);

////////////////////////////////////////////////////////////////////////////
//   Given a parent node(<ProductFamily> or <Information>) and an array of 
//	 nodeFuncs, this function loops through the array and sequentially process 
//   them using the functions given in the array
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessChildrenArray_H_XIS(PIXMLDOMNode &pNodeParent, 
								 Node_Func_H_XIS *rgNodeFuncs, UINT cNodeFuncs,
								 const IntStringValue *isVal_In,
								 SkuSet *pskuSet);

////////////////////////////////////////////////////////////////////////////
// Function: ProcessChildrenArray_H_XIES
//   Given a parent node(<Feature> <Component> <File>) and an array of 
//	 nodeFuncs, this function loops through the array and sequentially process 
//   them using the functions given in the array
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessChildrenArray_H_XIES(PIXMLDOMNode &pNodeParent, 
									Node_Func_H_XIES *rgNodeFuncs,
									UINT cNodeFuncs, 
									ElementEntry *pEE,
									SkuSet *pskuSet);


////////////////////////////////////////////////////////////////////////////
// Helper function: Insert a record into the specified table in the database
//				    This function will either perform insertion for a set
//					of Skus or just for a single Sku, depending on whether
//					pskuSet == NULL or not.
////////////////////////////////////////////////////////////////////////////
HRESULT InsertDBTable_SKU(LPTSTR szTable, PMSIHANDLE &hRec, SkuSet *pskuSet,
						  int iSkuIndex);

//////////////////////////////////////////////////////////////////////////////
//Functions that insert into a certain type of DB table
HRESULT InsertProperty(LPCTSTR szProperty, LPCTSTR szValue, SkuSet *pskuSet,
					   int iSkuIndex);

HRESULT InsertDirectory(LPCTSTR szDirectory, LPCTSTR szDirectory_Parent, 
						LPCTSTR szDefaultDir, SkuSet *pSkuSet, int iSkuIndex);
HRESULT InsertFeature(LPCTSTR szFeature, LPCTSTR szFeatureParent, 
					  LPCTSTR szTitle, LPCTSTR szDescription, int iDisplay, 
					  int iInstallLevel, LPCTSTR szDirectory, UINT iAttribute,
					  SkuSet *pSkuSet, int iSkuIndex);
HRESULT InsertCondition(LPCTSTR szFeature_, int iLevel, LPCTSTR szCondition, 
					  SkuSet *pSkuSet, int iSkuIndex);
HRESULT InsertFeatureComponents(LPCTSTR szFeature, LPCTSTR szComponent, 
								SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertComponent(LPCTSTR szComponent, LPCTSTR szComponentId, 
						LPCTSTR szDirectory_, UINT iAttributes, 
						LPCTSTR szCondition, LPCTSTR szKeyPath, 
						SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertCreateFolder(LPCTSTR szDirectory, LPCTSTR szComponent, 
						   SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertLockPermissions(LPCTSTR szLockObject, LPCTSTR szTable, 
							  LPCTSTR szDomain, LPCTSTR szUser,
			  				  int uiPermission, SkuSet *pSkuSet, 
							  int iSkuIndex);

HRESULT InsertFile(LPCTSTR szFile, LPCTSTR szComponentId,
				   LPCTSTR szFileName, UINT uiFileSize, LPCTSTR szVersion, 
				   LPCTSTR szLanguage, UINT iAttributes, INT iSequence,
				   SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertFont(LPCTSTR szFile_, LPCTSTR szFontTitle, SkuSet *pSkuSet,
				   int iSkuIndex);

HRESULT InsertBindImage(LPCTSTR szFile_, LPCTSTR szPath, SkuSet *pSkuSet, 
						int iSkuIndex);

HRESULT InsertSelfReg(LPCTSTR szFile_, UINT uiCost, SkuSet *pSkuSet, 
					  int iSkuIndex);

HRESULT InsertMoveFile(LPCTSTR szFileKey, LPCTSTR szComponent_, 
					   LPCTSTR szSourceName, LPCTSTR szDestName, 
					   LPCTSTR szSourceFolder, LPCTSTR szDestFolder,
					   UINT uiOptions, SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertRemoveFile(LPCTSTR szFileKey, LPCTSTR szComponent_, 
					   LPCTSTR szFileName, LPCTSTR szDirProperty, 
					   UINT uiInstallMode, SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertIniFile(LPCTSTR szIniFile, LPCTSTR szFileName, 
					  LPCTSTR szDirProperty, LPCTSTR szSection, LPCTSTR szKey,
					  LPCTSTR szValue, UINT uiAction, LPCTSTR szComponent_,
					  SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertRemoveIniFile(LPCTSTR szRemoveIniFile, LPCTSTR szFileName, 
						    LPCTSTR szDirProperty, LPCTSTR szSection, LPCTSTR szKey,
							LPCTSTR szValue, UINT uiAction, LPCTSTR szComponent_,
							SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertRegistry(LPCTSTR szRegistry, int iRoot, LPCTSTR szKey, 
					   LPCTSTR szName, LPCTSTR szValue, LPCTSTR szComponent_, 
					   SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertRemoveRegistry(LPCTSTR szRemoveRegistry, int iRoot, 
						     LPCTSTR szKey, LPCTSTR szName, 
							 LPCTSTR szComponent_, SkuSet *pSkuSet, 
							 int iSkuIndex);
///////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Read in the scheme from a template DB and create a DB Table with 
// specified name
////////////////////////////////////////////////////////////////////////////
HRESULT CreateTable_SKU(LPTSTR szTable, SkuSet *pskuSet);

////////////////////////////////////////////////////////////////////////////
// GetSQLCreateQuery: 
//		Given a template DB and a table name, return the SQL query string
//		for creating that table via pszSQLCreate
////////////////////////////////////////////////////////////////////////////
HRESULT GetSQLCreateQuery(LPTSTR szTable, MSIHANDLE hDBTemplate, LPTSTR *pszSQLCreate);

////////////////////////////////////////////////////////////////////////////
// return the child node of pParent with the specified name via pChild
////////////////////////////////////////////////////////////////////////////
HRESULT GetChildNode(PIXMLDOMNode &pParent, LPCTSTR szChildName, 
					 PIXMLDOMNode &pChild);
HRESULT GetChildNode(IXMLDOMNode *pParent, LPCTSTR szChildName, 
					 PIXMLDOMNode &pChild);
////////////////////////////////////////////////////////////////////////////
// return a list of all the children node of pParent with the specified name
// via pChild
////////////////////////////////////////////////////////////////////////////
HRESULT GetChildrenNodes(PIXMLDOMNode &pParent, LPCTSTR szChildName,
						 PIXMLDOMNodeList &pChildren);

////////////////////////////////////////////////////////////////////////////
// for debug purpose, print out the name of pNode, map ...
HRESULT PrintNodeName(PIXMLDOMNode &pNode);

void PrintMap_LI(map<LPTSTR, int, Cstring_less> &LI_map);
void PrintMap_LL(map<LPTSTR, LPTSTR, Cstring_less> &LL_map);
void PrintMap_LC(map<LPTSTR, Component *, Cstring_less> &LC_map);
void PrintMap_LS(map<LPTSTR, SkuSet *, Cstring_less> &LS_map);

void PrintMap_DirRef(map<LPTSTR, SkuSetValues *, Cstring_less> &map_DirRef);

void PrintError(UINT errorCode);
void PrintSkuIDs(SkuSet *pSkuSet);
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// return the value of pNode's attribute with name szAttrName via vAttrValue
////////////////////////////////////////////////////////////////////////////
HRESULT GetAttribute(PIXMLDOMNode &pNode, LPCTSTR szAttrName, 
					 VARIANT &vAttrValue);

////////////////////////////////////////////////////////////////////////////
// Return the value of pNode's ID attribute via szID
////////////////////////////////////////////////////////////////////////////
HRESULT GetID(PIXMLDOMNode &pNode, LPCTSTR &szID);

////////////////////////////////////////////////////////////////////////////
// Load an XML Document from the specified file or URL synchronously.
////////////////////////////////////////////////////////////////////////////
HRESULT LoadDocumentSync(PIXMLDOMDocument2 &pDoc, BSTR pBURL);

////////////////////////////////////////////////////////////////////////////
// Report parsing error information
////////////////////////////////////////////////////////////////////////////
HRESULT ReportError(PIXMLDOMParseError &pXMLError);

////////////////////////////////////////////////////////////////////////////
// Check load results
////////////////////////////////////////////////////////////////////////////
HRESULT CheckLoad(PIXMLDOMDocument2 &pDoc);

////////////////////////////////////////////////////////////////////////////
// an enhancement of MsiRecordGetString. szValueBuf will be automatically 
// increased if necessary 
////////////////////////////////////////////////////////////////////////////
UINT WmcRecordGetString(MSIHANDLE hRecord, unsigned int iField,
						LPTSTR &szValueBuf, DWORD *pcchValueBuf);

////////////////////////////////////////////////////////////////////////////
// String converstion functions

BSTR LPTSTRToBSTR(LPCTSTR szFName);

LPTSTR BSTRToLPTSTR(BSTR bString);

HRESULT GUIDToLPTSTR(LPGUID pGUID, LPTSTR &szGUID);
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Return a unique name by postfixing szName with a unique number
////////////////////////////////////////////////////////////////////////////
LPTSTR GetName(LPTSTR szName);

////////////////////////////////////////////////////////////////////////////
// Return a unique number (each time return a number 1 bigger than last time
////////////////////////////////////////////////////////////////////////////
ULONG GetUniqueNumber();

////////////////////////////////////////////////////////////////////////////
// convert a UUID string to all uppercases and add '{' '}' to the beginning 
// and end of the string
////////////////////////////////////////////////////////////////////////////
HRESULT FormatGUID(LPTSTR &szValue);

////////////////////////////////////////////////////////////////////////////
// compares the relationship of the 2 modules in the module tree. Return 
// the comparison result through iResult. if szModule1 is an ancestor
// of szModule2, *iResult is set to -1. if szModule1 is a descendant of 
// szModule2, *iResult is set to 1. if szModule1 is the same as szModule2 
// or the 2 modules doesn't belong to the same Module subtree, iResult is
// set to 0. This is an error to catch.
////////////////////////////////////////////////////////////////////////////
HRESULT CompareModuleRel(LPTSTR szModule1, LPTSTR szModule2, int *iResult);

#endif //XMSI_UTILITIES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\res\sources.inc ===
!INCLUDE ..\..\MsiMake.inc
TARGETNAME=
SOURCES=
TARGETTYPE=NOTARGET
NTTARGETFILE0=ResAll
SYNCHRONIZE_BLOCK=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\wmc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       wmc.h
//              Main header file for the wmc project
//--------------------------------------------------------------------------

#ifndef XMSI_WMC_H
#define XMSI_WMC_H

#include <Windows.h>
#include <assert.h>
#include <stdio.h>   // printf/wprintf
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#include <stdlib.h>  // exit
#include <objbase.h>
#include <initguid.h>
#include <map>
#include <set>
#include <vector>
#include <algorithm> // find

#include "MsiQuery.h"
#include "Msidefs.h"
#include "msxml.h"

#include "CommandOpt.h"
#include "query.h"
#include "SkuSet.h"

using namespace std;

//____________________________________________________________________________
//
// COM pointer encapsulation to force the Release call at destruction
// The encapsulated pointer is also Release'd on assignment of a new value.
// The object may be used where either a pointer is expected.
// This object behaves as a pointer when using operators: ->, *, and &.
// A non-null pointer may be tested for simply by using: if(PointerObj).
// Typedefs may be defined for the individual template instantiations
//____________________________________________________________________________

template <class T> class CComPointer
{
 public:
		CComPointer() : m_pi(NULL) {}
        CComPointer(T* pi) : m_pi(pi){}
        CComPointer(IUnknown& ri, const IID& riid) 
		{
			ri.QueryInterface(riid, (void**)&m_pi);
		}
        CComPointer(const CComPointer<T>& r) // copy constructor, calls AddRef
        {
			if(r.m_pi)
				((IUnknown*)r.m_pi)->AddRef();
			m_pi = r.m_pi;
        }
		// release ref count at destruction
		~CComPointer() {if (m_pi) ((IUnknown*)m_pi)->Release();} 
		
		// copy assignment, calls AddRef
        CComPointer<T>& operator =(const CComPointer<T>& r) 
        {
            if(r.m_pi)
                    ((IUnknown*)r.m_pi)->AddRef();
            if (m_pi) ((IUnknown*)m_pi)->Release();
            m_pi=r.m_pi;
            return *this;
	    }
        CComPointer<T>& operator =(T* pi)
        {
			if (m_pi) ((IUnknown*)m_pi)->Release(); m_pi = pi; return *this;
		}

		// returns pointer, no ref count change
        operator T*() {return m_pi;}    
		// allow use of -> to call member functions
        T* operator ->() {return m_pi;}  
		// allow dereferencing (can't be null)
        T& operator *()  {return *m_pi;} 
        T** operator &() 
		{
			if (m_pi) ((IUnknown*)m_pi)->Release(); m_pi = 0; return &m_pi;
		}
 private:
        T* m_pi;
};

//////////////////////////////////////////////////////////////////////////////
// Smart pointer definition for each MSXML interfaces
typedef CComPointer<IXMLDOMDocument/*2*/> PIXMLDOMDocument2;
typedef CComPointer<IXMLDOMNode> PIXMLDOMNode;
typedef CComPointer<IXMLDOMNodeList> PIXMLDOMNodeList;
typedef CComPointer<IXMLDOMElement> PIXMLDOMElement;
typedef CComPointer<IXMLDOMParseError> PIXMLDOMParseError;
//////////////////////////////////////////////////////////////////////////////


// the required less operator for map and set definitions that use LPTSTR
// as keys
struct Cstring_less {
	 bool operator()(LPCTSTR p, LPCTSTR q) const { return _tcscmp(p, q)<0; }
};

/* used to hold a Feature name and a module name that has the following
	relationship: the feature claims ownership of the module through a 
	<UseModule> tag */
typedef struct
{
	LPTSTR szFeature;
	LPTSTR szModule;
} FOM; /*FeatureOwnModule */

/* used to hold a Table value and a LockObject value to be used by 
   ProcessLockPermissions */
typedef struct
{
	LPTSTR szTable;
	LPTSTR szLockObject;
} TableLockObj;

/* used to hold a ComponentID, a Root of Registry, a Key of Registry
   to be passed from ProcessRegistry to ProcessDelete and ProcessCreate
*/
typedef struct
{
	LPTSTR szComponent;
	int iRoot;
	LPTSTR szKey;
} CompRootKey;

/* Most of the values passed among functions are either int or LPTSTR.
   Also the values of the columns in the DB are also int or string.
   So use a union to represent such values */
typedef enum 
{
	INTEGER=0, 
	INSTALL_LEVEL, 
	STRING, 
	STRING_LIST, 
	FM_PAIR,
	TABLELOCKOBJ,
	COMPROOTKEY,
} ValType;

typedef union
{
	int intVal;
	LPTSTR szVal;
	set<LPTSTR, Cstring_less> *pSetString;
	FOM *pFOM;
	TableLockObj *pTableLockObj;
	CompRootKey *pCompRootKey;
} IntStringValue;

/* the following structure is used to store a value that is associated with
	a set of SKUs */
typedef struct 
{
	SkuSet *pSkuSet;
	IntStringValue isVal;
} SkuSetVal;

/* where the information should go: Property table, summary info, or both */
typedef enum {PROPERTY_TABLE = 0, SUMMARY_INFO, BOTH }INFODESTINATION;

/* ISSUE: define the following under XMSI own namespace */
typedef enum
{
	PLACEHOLDER = 0,
	PRODUCTFAMILY,
	SKUMANAGEMENT,
	SKUS,
	SKU,
	SKUGROUPS,
	SKUGROUP,
	INFORMATION,
	PRODUCTNAME,
	PRODUCTCODE,
	UPGRADECODE,
	PRODUCTVERSION,
	MANUFACTURER,
	KEYWORDS,
	TEMPLATE,
	INSTALLERVERSIONREQUIRED,
	LONGFILENAMES,
	SOURCECOMPRESSED,
	CODEPAGE,
	SUMMARYCODEPAGE,
	PACKAGEFILENAME,
	DIRECTORIES,
	DIRECTORY,
	NAME,
	TARGETDIR,
	TARGETPROPERTY,
	INSTALLLEVELS,
	XMSI_INSTALLLEVEL,
	FEATURES,
	FEATURE,
	TITLE,
	DESCRIPTION,
	DISPLAYSTATE,
	ILEVEL,
	ILEVELCONDITION,
	DIR,
	STATE,
	FAVOR,
	ADVERTISE,
	DISALLOWABSENT,
	USEMODULE,
	TAKEOWNERSHIP,
	OWNSHORTCUTS,
	OWNCLASSES,
	OWNTYPELIBS,
	OWNEXTENSIONS,
	OWNQUALIFIEDCOMPONENTS,
	MODULES,
	MODULE,
	COMPONENT,
	XMSI_GUID,
	COMPONENTDIR,
	CREATEFOLDER,
	LOCKPERMISSION,
	COMPONENTATTRIBUTES,
	RUNFROM,
	SHAREDDLLREFCOUNT,
	PERMANENT,
	TRANSITIVE,
	NEVEROVERWRITE,
	CONDITION,
	XMSI_FILE,
	FILENAME,
	FILESIZE,
	FILEVERSION,
	FILELANGUAGE,
	FILEATTRIBUTES,
	READONLY,
	HIDDEN,
	SYSTEM,
	VITAL,
	CHECKSUM,
	COMPRESSED,
	FONT,
	BINDIMAGE,
	SELFREG,
	MOVEFILE,
	SOURCENAME,
	DESTNAME,
	SOURCEFOLDER,
	DESTFOLDER,
	COPYFILE,
	REMOVEFILE,
	FNAME_REMOVEFILE,
	DIRPROPERTY,
	XMSI_INSTALLMODE,
	INIFILE,
	FNAME_INIFILE,
	DIRPROPERTY_INIFILE,
	SECTION,
	KEY,	
	VALUE_INIFILE,	
	ACTION,
	REMOVEINIFILE,
	FNAME_REMOVEINIFILE,
	DIRPROPERTY_REMOVEINIFILE,
	VALUE_REMOVEINIFILE,
	ACTION_REMOVEINIFILE,
	XMSI_REGISTRY,
	XMSI_DELETE,
	XMSI_CREATE
} NodeIndex;

////////////////////////////////////////////////////////////////////////////
// class definitions

// this class stores a sequence of <SkuSet, IntStringValue> pairs and
// provides a set of interfaces to access the stored information.

class SkuSetValues
{
public:
	SkuSetValues();

	~SkuSetValues();

	/* call DirectInsert when it is sure that the SkuSet
	   to be inserted doesn't overlap with any SkuSet stored. */

	// store the pointer (caller should allocate memory)
	void DirectInsert(SkuSetVal *pSkuSetVal);
	// construct a new SkuSetVal object using the passed-in values
	// (caller should allocate memory for *pSkuSet)
	void DirectInsert(SkuSet *pSkuSet, IntStringValue isVal);

	/* call SplitInsert when the SkuSet to be inserted might overlap
	   with the SkuSets stored. During insertion, the collisions will be
	   solved by splitting the existing SkuSet. This often happens when 
	   more than one node in the XML file corresponds to one column value 
	   in the DB. So this function also takes a function pointer that tells
	   how to update the value stored if a collision happens */

	// caller allocates memory for *pSkuSetVal
	HRESULT SplitInsert(SkuSetVal *pSkuSetVal, 
						HRESULT (*UpdateFunc)
							(IntStringValue *pIsValOut, 
							 IntStringValue isVal1, 
							 IntStringValue isVal2));

	// caller allocates memory for *pSkuSet 
	HRESULT SplitInsert(SkuSet *pSkuSet, IntStringValue isVal, 
				HRESULT (*UpdateFunc)(IntStringValue *pIsValOut, IntStringValue isVal1, 
									  IntStringValue isVal2));

	// CollapseInsert: Sometimes when inserting into the list of <SkuSet, Value>
	//				   data structure, we want to collapse the SkuSets with the
	//				   same value into one slot. One example is when inserting
	//				   into a data structure storing references (to Directories,
	//				   to InstallLevels, etc.)
	//				   when NoRepeat is set to true, the compiler will check 
	//				   that for any given SKU, the value to be inserted is not 
	//				   on the list already. This solves the problem of checking
	//				   the uniqueness of an attribute - sometimes an attribute
	//				   corresponds to a DB column(primary key) instead of the 
	//				   element that the attribute belongs to
	HRESULT SkuSetValues::CollapseInsert(SkuSet *pSkuSet, IntStringValue isVal, 
										bool NoDuplicate);

	// return the value(s) of a set of Skus in the form of
	// a SkuSetValues object. Returhn E_FAIL if some of the SKUs
	// don't exist in the data structure since this function
	// will be mainly used to query stored references.
	HRESULT GetValueSkuSet(SkuSet *pSkuSet, 
							SkuSetValues **ppSkuSetValuesRetVal);

	// return the value stored for any given SKU
	IntStringValue GetValue(int iPos);

	// return the pointer to the SkuSetVal that stores the most common
	// value (its SkuSet has the most bits set)
	SkuSetVal *GetMostCommon();

	// Following access functions mimic an iterator
	SkuSetVal *Start();
	SkuSetVal *End();
	SkuSetVal *Next();

	bool Empty();

	// erase the element from the storage W/O freeing memory
	void Erase(SkuSetVal *pSkuSetVal);

	// The type of the value store
	void SetValType(ValType vt) {m_vt = vt;}
	ValType GetValType() {return m_vt;}

	void Print();
private:
	vector<SkuSetVal *> *m_pVecSkuSetVals;
	vector<SkuSetVal *>::iterator m_iter;

	ValType m_vt;
};

/* This class stores the per Sku information */
class Sku {
public:

	MSIHANDLE m_hDatabase;  // handle to the output database
	MSIHANDLE m_hTemplate;  // handle to the template database
	MSIHANDLE m_hSummaryInfo; // handle to the output summary information
	
	Sku():m_szID(NULL), 
		  m_hDatabase(NULL), 
		  m_hTemplate(NULL), 
		  m_hSummaryInfo(), 
		  m_mapCQueries() {}

	Sku(LPTSTR sz):m_hDatabase(NULL), 
				   m_hTemplate(NULL), 
				   m_hSummaryInfo(NULL),
				   m_mapCQueries(),
				   m_setModules() {m_szID = _tcsdup(sz); assert(m_szID);}

	~Sku();

	void FreeCQueries();
	
	void CloseDBHandles();

	bool TableExists(LPTSTR szTable);

	CQuery *GetInsertQuery(LPTSTR szTable)
	{
		if (0 == m_mapCQueries.count(szTable))
		{
			return NULL;
		}
		else
			return m_mapCQueries[szTable];
	}
	
	HRESULT CreateCQuery(LPTSTR szTable);

	void SetOwnedModule(LPTSTR szModule);

	bool OwnModule(LPTSTR szModule) 
	{return (0 != m_setModules.count(szModule));}

	// member access functions
	LPTSTR GetID() {return m_szID;}
	void SetID(LPTSTR sz) {m_szID = _tcsdup(sz);}

private:
	UINT m_index;  // the position of this SKU in the bit field
	LPTSTR m_szID;   // the Sku ID

	// Store the CQueries for DB table insertion (one CQuery per table)
	map<LPTSTR, CQuery *, Cstring_less> m_mapCQueries;

	// Store all the modules owned by this SKU
	set<LPTSTR, Cstring_less> m_setModules; 
};


// Represent an element that 
//			(1) corresponds to a row in the DB
//			(2) has Skuable children
//
// Notice:
//	 The following sequence has to be strictly enforced
//	for now:
//		(1) Call SetNodeIndex and SetValType;
//		(2) Call SetValue. Finish processing all children.
//			if there are more than one child correspoding to one column,
//			make sure to call SetNodeIndex at the beginning of processing
//			each child. SetNodeIndex guarantees 2 things:
//				(a) If there is an error happened, it is used to get the
//					node name;
//				(b) It resets the SkuSet that is used to check for
//					uniqueness
//			Failing to call SetNodeIndex will result in error!
//			
//		(3) Call Finalize;
//		(4) Call GetCommonValue and GetCommonSet
//		(5) Call GetValue
//	 Also: don't call GetValue on a Sku that belongs to 
//		the CommonSet

class ElementEntry
{
public:
	IntStringValue m_isValInfo; // very often some infomation needs to 
								// be passed into the children node
								// (Component ID, e.g.)
	ElementEntry():m_cColumns(0), m_rgValTypes(NULL), m_pSkuSetAppliesTo(NULL),
				   m_rgCommonValues(NULL), m_pSkuSetCommon(NULL),
				   m_rgpSkuSetValuesXVals(NULL), m_rgNodeIndices(NULL)
	{}

	ElementEntry(int cColumns, SkuSet *pSkuSetAppliesTo);

	~ElementEntry();

	ValType GetValType(int iColumn);
	void SetValType(ValType vt, int iColumn);

	NodeIndex GetNodeIndex(int iColumn);
	void SetNodeIndex(NodeIndex ni, int iColumn);

	/* the following 2 functions set the value of a column for a group 
		of Skus */

	// When the column value is decided by one kind of node in the WIML file
	HRESULT SetValue(IntStringValue isVal, int iColumn, 
					 SkuSet *pskuSetAppliesTo);

	// Store a list of values (a SkuSetValues object) for a column
	// Caller should allocate and free *pSkuSetValues
	HRESULT SetValueSkuSetValues(SkuSetValues *pSkuSetValues, int iColumn);

	// When the column value is decided by more than one type of node in the
	// WIML file. The passed-in function pointer tells how to update the 
	// column value.
	HRESULT SetValueSplit(IntStringValue isVal, int iColumn, 
						  SkuSet *pskuSetAppliesTo,
						  HRESULT (*UpdateFunc)
								(IntStringValue *pIsValOut, 
								 IntStringValue isVal1, 
								 IntStringValue isVal2));

	// return the value of a column for a specific SKU
	IntStringValue GetValue(int iColumn, int iPos);
	// return the common value of a column
	IntStringValue GetCommonValue(int iColumn);
	// return the SkuSet that the common values apply to
	SkuSet GetCommonSkuSet();
	// finalize the common values and the common set 
	// also check for missing required entities
	HRESULT Finalize();

	// should be called before calling Finalize on 
	// columns that are set by SetValueSplit
	SkuSetValues *GetColumnValue(int iColumn) 
	{ return m_rgpSkuSetValuesXVals[iColumn-1]; }

private:
	int m_cColumns;	// # columns in the DB table for this element
	ValType *m_rgValTypes; // an array storing the value type of each column
	SkuSet *m_pSkuSetAppliesTo; // The set of Skus this entry covers
	SkuSetVal **m_rgCommonValues; // common case values
	SkuSet *m_pSkuSetCommon; // the set of Skus that share the common values
	SkuSetValues **m_rgpSkuSetValuesXVals;	// an array of pointers to 
											// SkuSetValues 
											// storing the values that are
											// different from the common
											// ones
	NodeIndex *m_rgNodeIndices; // the NodeIndex of the node corresponding 
								// to each column
	SkuSet **m_rgpSkuSetValidate; // an array of pointers to SkuSets to 
								  // store all the Skus that have the
								  // column value set already
	SkuSet **m_rgpSkuSetUnique; // for those columns that will be decided
									// by more than one node. Need 2 SkuSets
									// to validate: one checking for uniqueness
									// one checking for not missing

};


// the Component class stores information related to processing <Component>
// entity
class Component {
public:
	PIXMLDOMNode m_pNodeComponent;
	Component();

	~Component();

	void SetSkuSet(SkuSet *pSkuSet);
	SkuSet *GetSkuSet();

	void SetUsedByFeature(LPTSTR szFeature, SkuSet *pSkuSet);
	SkuSetValues *GetFeatureUse();

	HRESULT SetOwnership(FOM *pFOM, SkuSetValues *pSkuSetValuesOwnership);
	HRESULT GetOwnership(NodeIndex ni, SkuSet *pSkuSet, 
						SkuSetValues **ppSkuSetValuesRetVal);

	HRESULT SetKeyPath(LPTSTR szKeyPath, SkuSet *pSkuSet);
	HRESULT GetKeyPath(SkuSet *pSkuSet, SkuSetValues **ppSkuSetValuesRetVal);

	void Print();

private:

	// the set of Skus that include this component
	SkuSet *m_pSkuSet;

	// store the ID of all the <Feature>s that use this component. essentially,
	// this is a list of lists of Feature IDs stored together with SkuSets
	SkuSetValues *m_pSkuSetValuesFeatureUse;

	// an array of SkuSetValues storing the ownership info of this component
	SkuSetValues *m_rgpSkuSetValuesOwnership[5];

	// Store the Keypath information 
	SkuSetValues *m_pSkuSetValuesKeyPath;
};
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// value_type definition for maps used 
typedef map<LPTSTR, int, Cstring_less>::value_type LI_ValType;
typedef map<LPTSTR, LPTSTR, Cstring_less>::value_type LL_ValType;
typedef map<LPTSTR, CQuery *, Cstring_less>::value_type LQ_ValType;
typedef map<LPTSTR, SkuSet *, Cstring_less>::value_type LS_ValType;
typedef map<LPTSTR, Component *, Cstring_less>::value_type LC_ValType;
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// struct definitions
typedef struct {
	NodeIndex enumNodeIndex;
	LPTSTR szPropertyName;
	INFODESTINATION enumDestination; 
	UINT uiPropertyID;
	VARTYPE vt;
	bool bIsGUID;
} INFO_CHILD;

typedef HRESULT (*PF_H_XIS)(PIXMLDOMNode &,
						   const IntStringValue *isVal_In, SkuSet *);

typedef HRESULT (*PF_H_XIES)(PIXMLDOMNode &, int iColumn,
							  ElementEntry *pEE, SkuSet *);

typedef struct {
	NodeIndex enumNodeIndex;
	PF_H_XIS pNodeProcessFunc;
} Node_Func_H_XIS;

typedef struct {
	NodeIndex enumNodeIndex;
	PF_H_XIES pNodeProcessFunc;
	ValType   vt; 
	int       iColumn;
} Node_Func_H_XIES;

typedef struct {
	NodeIndex enumNodeIndex;
	UINT uiBit;
} AttrBit_SKU;

typedef struct {
	LPTSTR EnumValue;
	UINT uiBit;
} EnumBit;

typedef struct {
	LPTSTR szNodeName;
	LPTSTR szAttributeName;
	bool   bIsRequired;
	UINT   uiOccurence; /* if uiOccurence = 0, this node can occur 0+ times 
							if bIsRequired=false, or 1+ times 
							if bIsRequire = true */
} NODE;
////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Global Variables
// Issue: Handles to databases and summary infos have to be associated 
//		  with SKU in the future

extern bool g_bVerbose;			
extern bool g_bValidationOnly;	
extern FILE *g_pLogFile;	

// used to store Sku groups
// Key: SkuGroupID		Value: pointer to a SkuSet object
extern map<LPTSTR, SkuSet *, Cstring_less> g_mapSkuSets;

// used to store Directory references
// Key: DirectoryID		Value: Primary key in table Directory
extern map<LPTSTR, SkuSetValues *, Cstring_less> g_mapDirectoryRefs_SKU;

// used to store InstallLevel references
// Key: InstallLevel ID		Value: numeric value of install level
extern map<LPTSTR, SkuSetValues *, Cstring_less> g_mapInstallLevelRefs_SKU;

// used to store Components
// Key: Component table primary key		Value: pointer to a Component object
extern map<LPTSTR, Component *, Cstring_less> g_mapComponents;

extern map<LPTSTR, SkuSet *, Cstring_less> g_mapFiles;

// for each table type, there is a counter that is
// incremented when each time the GetName function is called
// with that particular table name
extern map<LPTSTR, int, Cstring_less> g_mapTableCounter;


extern NODE rgXMSINodes[];

extern const int cAttrBits_TakeOwnership;
extern AttrBit_SKU rgAttrBits_TakeOwnership[];

// the array of SKU objects
extern Sku **g_rgpSkus;

// number of SKUs
extern int g_cSkus;

// the root node of the document
extern IXMLDOMNode *g_pNodeProductFamily;

////////////////////////////////////////////////////////////




#endif // XMSI_WMC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\res\autoapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       autoapi.cpp
//
//--------------------------------------------------------------------------

#define TYPELIB_MAJOR_VERSION 1  // released version, not rmj
#define TYPELIB_MINOR_VERSION 0  // released version, not rmm

#ifdef RC_INVOKED
1 typelib AutoApi.tlb
#endif

#include "AutoApi.h"   // help context ID definitions, dispatch IDs
#define MAKE_VERSION(a,b) a##.##b
[
    uuid(000C1092-0000-0000-C000-000000000046), // LIBID_MsiApiTypeLib
    helpfile("Msi.CHM"),
#ifdef DEBUG
    helpstring("Microsoft Windows Installer Object Library - Debug"),
#else
    helpstring("Microsoft Windows Installer Object Library"),
#endif
    lcid(0x0409),
    version( MAKE_VERSION(TYPELIB_MAJOR_VERSION, TYPELIB_MINOR_VERSION) )
]
library WindowsInstaller
{
    importlib("stdole32.tlb");
    dispinterface Installer;
    dispinterface Record;
    dispinterface SummaryInfo;
    dispinterface Database;
    dispinterface View;
    dispinterface Session;
    dispinterface UIPreview;
    dispinterface FeatureInfo;
    dispinterface StringList;
    dispinterface RecordList;

#ifdef DEBUG
#define enumcontext(x) helpcontext(x)
#else  // save size in ship type library
#define enumcontext(x)
#define helpstring(x)
#endif

typedef enum {
    [enumcontext(HELPID_MsiRecord_IntegerData)] msiDatabaseNullInteger  = 0x80000000,
} Constants;

typedef [helpcontext(HELPID_MsiInstall_OpenDatabase), helpstring("OpenDatabase creation options")] enum {
    [enumcontext(HELPID_MsiInstall_OpenDatabase)] msiOpenDatabaseModeReadOnly     = 0,
    [enumcontext(HELPID_MsiInstall_OpenDatabase)] msiOpenDatabaseModeTransact     = 1,
    [enumcontext(HELPID_MsiInstall_OpenDatabase)] msiOpenDatabaseModeDirect       = 2,
    [enumcontext(HELPID_MsiInstall_OpenDatabase)] msiOpenDatabaseModeCreate       = 3,
    [enumcontext(HELPID_MsiInstall_OpenDatabase)] msiOpenDatabaseModeCreateDirect = 4,
    [enumcontext(HELPID_MsiInstall_OpenDatabase)] msiOpenDatabaseModePatchFile    = 32,
} MsiOpenDatabaseMode;

typedef [helpcontext(HELPID_MsiDatabase_DatabaseState), helpstring("Read-only or read-write state for database")] enum {
    [enumcontext(HELPID_MsiDatabase_DatabaseState)] msiDatabaseStateRead  = 0,
    [enumcontext(HELPID_MsiDatabase_DatabaseState)] msiDatabaseStateWrite = 1
} MsiDatabaseState;

typedef [helpcontext(HELPID_MsiView_ColumnInfo), helpstring("Column attribute to return for View.ColumnInfo")] enum {
    [enumcontext(HELPID_MsiView_ColumnInfo)] msiColumnInfoNames = 0,
    [enumcontext(HELPID_MsiView_ColumnInfo)] msiColumnInfoTypes = 1
} MsiColumnInfo;

typedef [helpcontext(HELPID_MsiRecord_ReadStream), helpstring("Conversion options for Record.ReadStream")] enum {
    [enumcontext(HELPID_MsiRecord_ReadStream)] msiReadStreamInteger = 0,
    [enumcontext(HELPID_MsiRecord_ReadStream)] msiReadStreamBytes   = 1,
    [enumcontext(HELPID_MsiRecord_ReadStream)] msiReadStreamAnsi    = 2,
    [enumcontext(HELPID_MsiRecord_ReadStream)] msiReadStreamDirect  = 3,
} MsiReadStream;

typedef [helpcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo), helpstring("Error suppression flags for Database.CreateTransformSummaryInfo")] enum {
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformErrorNone                   = 0,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformErrorAddExistingRow         = 1,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformErrorDeleteNonExistingRow   = 2,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformErrorAddExistingTable       = 4,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformErrorDeleteNonExistingTable = 8,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformErrorUpdateNonExistingRow   = 16,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformErrorChangeCodePage         = 32,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformErrorViewTransform          = 256,
} MsiTransformError;

typedef [helpcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo), helpstring("Validation option flags for Database.CreateTransformSummaryInfo")] enum {
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationNone           = 0,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationLanguage       = 1,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationProduct        = 2,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationPlatform       = 4,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationMajorVer       = 8,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationMinorVer       = 16,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationUpdateVer      = 32,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationLess           = 64,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationLessOrEqual    = 128,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationEqual          = 256,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationGreaterOrEqual = 512,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationGreater        = 1024,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationUpgradeCode    = 2048,
} MsiTransformValidation;

typedef [helpcontext(HELPID_MsiView_Modify), helpstring("Operation for View.Modify")] enum {
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifySeek           =-1,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyRefresh        = 0,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyInsert         = 1,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyUpdate         = 2,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyAssign         = 3,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyReplace        = 4,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyMerge          = 5,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyDelete         = 6,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyInsertTemporary= 7,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyValidate       = 8,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyValidateNew    = 9,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyValidateField  = 10,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyValidateDelete = 11,
} MsiViewModify;

typedef [helpcontext(HELPID_MsiEngine_EvaluateCondition), helpstring("Return status from Session.EvaluateCondition")] enum {
    [enumcontext(HELPID_MsiEngine_EvaluateCondition)] msiEvaluateConditionFalse = 0,
    [enumcontext(HELPID_MsiEngine_EvaluateCondition)] msiEvaluateConditionTrue  = 1,
    [enumcontext(HELPID_MsiEngine_EvaluateCondition)] msiEvaluateConditionNone  = 2,
    [enumcontext(HELPID_MsiEngine_EvaluateCondition)] msiEvaluateConditionError = 3
} MsiEvaluateCondition;

typedef [helpcontext(HELPID_MsiEngine_DoAction), helpstring("Return status from Session.DoAction and Session.Sequence")] enum {
    [enumcontext(HELPID_MsiEngine_DoAction)] msiDoActionStatusNoAction     = 0,
    [enumcontext(HELPID_MsiEngine_DoAction)] msiDoActionStatusSuccess      = 1,
    [enumcontext(HELPID_MsiEngine_DoAction)] msiDoActionStatusUserExit     = 2,
    [enumcontext(HELPID_MsiEngine_DoAction)] msiDoActionStatusFailure      = 3,
    [enumcontext(HELPID_MsiEngine_DoAction)] msiDoActionStatusSuspend      = 4,
    [enumcontext(HELPID_MsiEngine_DoAction)] msiDoActionStatusFinished     = 5,
    [enumcontext(HELPID_MsiEngine_DoAction)] msiDoActionStatusWrongState   = 6,
    [enumcontext(HELPID_MsiEngine_DoAction)] msiDoActionStatusBadActionData= 7
} MsiDoActionStatus;

typedef [helpcontext(HELPID_MsiEngine_Message), helpstring("Session.Message types and options")] enum {
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeFatalExit       = 0x00000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeError           = 0x01000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeWarning         = 0x02000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeUser            = 0x03000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeInfo            = 0x04000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeFilesInUse      = 0x05000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeResolveSource   = 0x06000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeOutOfDiskSpace  = 0x07000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeActionStart     = 0x08000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeActionData      = 0x09000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeProgress        = 0x0A000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeCommonData      = 0x0B000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeOk              = 0,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeOkCancel        = 1,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeAbortRetryIgnore= 2,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeYesNoCancel     = 3,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeYesNo           = 4,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeRetryCancel     = 5,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeDefault1        = 0x000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeDefault2        = 0x100,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeDefault3        = 0x200
} MsiMessageType;

typedef [helpcontext(HELPID_MsiEngine_Message), helpstring("Return codes from Session.Message")] enum {
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusError  =-1,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusNone   = 0,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusOk     = 1,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusCancel = 2,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusAbort  = 3,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusRetry  = 4,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusIgnore = 5,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusYes    = 6,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusNo     = 7
} MsiMessageStatus;

typedef [helpcontext(HELPID_MsiInstallState), helpstring("Install states for products and features")] enum {
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateNotUsed      = -7,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateBadConfig    = -6,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateIncomplete   = -5,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateSourceAbsent = -4,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateInvalidArg   = -2,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateUnknown      = -1,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateBroken       =  0,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateAdvertised   =  1,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateRemoved      =  1,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateAbsent       =  2,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateLocal        =  3,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateSource       =  4,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateDefault      =  5,
} MsiInstallState;

typedef [helpcontext(HELPID_MsiReinstallMode), helpstring("Reinstall option bit flags")] enum {
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeFileMissing      = 0x0002,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeFileOlderVersion = 0x0004,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeFileEqualVersion = 0x0008,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeFileExact        = 0x0010,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeFileVerify       = 0x0020,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeFileReplace      = 0x0040,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeMachineData      = 0x0080,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeUserData         = 0x0100,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeShortcut         = 0x0200,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModePackage          = 0x0400,
} MsiReinstallMode;

typedef [helpcontext(HELPID_MsiInstallMode), helpstring("Install options for ProvideComponent, UseFeature")] enum {
    [enumcontext(HELPID_MsiInstallMode)] msiInstallModeNoSourceResolution = -3,
    [enumcontext(HELPID_MsiInstallMode)] msiInstallModeNoDetection = -2,
    [enumcontext(HELPID_MsiInstallMode)] msiInstallModeExisting    = -1,
    [enumcontext(HELPID_MsiInstallMode)] msiInstallModeDefault     =  0,
} MsiInstallMode;

typedef [helpcontext(HELPID_MsiInstall_UILevel), helpstring("UI mode for installation")] enum {
    [enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelNoChange = 0,
    [enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelDefault  = 1,
    [enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelNone     = 2,
    [enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelBasic    = 3,
    [enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelReduced  = 4,
    [enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelFull     = 5,
	[enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelHideCancel = 0x20,
    [enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelProgressOnly  = 0x40,
    [enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelEndDialog= 0x80,
} MsiUILevel;

typedef [helpcontext(HELPID_MsiEngine_FeatureCost), helpstring("Extent of feature cost relative to tree")] enum {
    [enumcontext(HELPID_MsiEngine_FeatureCost)] msiCostTreeSelfOnly = 0,
    [enumcontext(HELPID_MsiEngine_FeatureCost)] msiCostTreeChildren = 1,
    [enumcontext(HELPID_MsiEngine_FeatureCost)] msiCostTreeParents  = 2,
} MsiCostTree;

typedef [helpcontext(HELPID_MsiInstall_ApplyPatch), helpstring("Type of image to patch")] enum {
    [enumcontext(HELPID_MsiInstall_ApplyPatch)] msiInstallTypeDefault      = 0,
    [enumcontext(HELPID_MsiInstall_ApplyPatch)] msiInstallTypeNetworkImage = 1,
    [enumcontext(HELPID_MsiInstall_ApplyPatch)] msiInstallTypeSingleInstance = 2,
}MsiInstallType;

typedef [helpcontext(HELPID_MsiEngine_Mode), helpstring("Install session mode bits")] enum {
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeAdmin           =  0,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeAdvertise       =  1,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeMaintenance     =  2,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeRollbackEnabled =  3,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeLogEnabled      =  4,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeOperations      =  5,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeRebootAtEnd     =  6,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeRebootNow       =  7,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeCabinet         =  8,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeSourceShortNames=  9,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeTargetShortNames= 10,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeWindows9x       = 12,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeZawEnabled      = 13,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeScheduled       = 16,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeRollback        = 17,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeCommit          = 18,
}MsiRunMode;

typedef [helpcontext(HELPID_MsiInstall_FileSignatureInfo), helpstring("FileSignatureInfo Error flags")] enum {
	[enumcontext(HELPID_MsiInstall_FileSignatureInfo)] msiSignatureOptionInvalidHashFatal = 1,
}MsiSignatureOption;

typedef [helpcontext(HELPID_MsiInstall_FileSignatureInfo), helpstring("FileSignatureInfo format type")] enum {
	[enumcontext(HELPID_MsiInstall_FileSignatureInfo)] msiSignatureInfoCertificate = 0,
	[enumcontext(HELPID_MsiInstall_FileSignatureInfo)] msiSignatureInfoHash        = 1,
}MsiSignatureInfo;

    [
        uuid(000C1090-0000-0000-C000-000000000046),  // IID_IMsiApiInstall
        helpcontext(HELPID_MsiInstall_Object), helpstring("Top-level Windows Installer object")
    ]
    dispinterface Installer
    {
        properties:
            [id(DISPID_MsiInstall_UILevel), helpcontext(HELPID_MsiInstall_UILevel), helpstring("The UI level used to open a package")]
                MsiUILevel UILevel;
        methods:
            [id(DISPID_MsiInstall_CreateRecord), helpcontext(HELPID_MsiInstall_CreateRecord), helpstring("Creates a cleared record object")]
                Record* CreateRecord([in] long Count);
            [id(DISPID_MsiInstall_OpenPackage), helpcontext(HELPID_MsiInstall_OpenPackage), helpstring("Creates an installer instance from a package path")]
                Session* OpenPackage([in] variant PackagePath);
            [id(DISPID_MsiInstall_OpenProduct), helpcontext(HELPID_MsiInstall_OpenProduct), helpstring("Creates an installer instance from a product code")]
                Session* OpenProduct([in] BSTR ProductCode);
            [id(DISPID_MsiInstall_OpenDatabase), helpcontext(HELPID_MsiInstall_OpenDatabase), helpstring("Creates a database object from a file path")]
                Database* OpenDatabase([in] BSTR DatabasePath, [in] variant OpenMode);
            [id(DISPID_MsiInstall_SummaryInformation), propget, helpcontext(HELPID_MsiInstall_SummaryInformation), helpstring("Returns the summary information object for a database or transform")]
                SummaryInfo* SummaryInformation([in] BSTR PackagePath, [in, defaultvalue(0)] long UpdateCount);
            [id(DISPID_MsiInstall_EnableLog), helpcontext(HELPID_MsiInstall_EnableLog), helpstring("Set the logging mode and file")]
                void EnableLog([in] BSTR LogMode, [in] BSTR LogFile);
            [id(DISPID_MsiInstall_InstallProduct), helpcontext(HELPID_MsiInstall_InstallProduct), helpstring("Installs a new package")]
                void InstallProduct([in] BSTR PackagePath, [in, defaultvalue(0)] BSTR PropertyValues);
            [id(DISPID_MsiInstall_Version), propget, helpcontext(HELPID_MsiInstall_Version), helpstring("The MSI build version string")]
                BSTR Version();
            [id(DISPID_MsiInstall_LastErrorRecord), helpcontext(HELPID_MsiInstall_LastErrorRecord), helpstring("Returns last cached error record object")]
                Record* LastErrorRecord();
            [id(DISPID_MsiInstall_RegistryValue), helpcontext(HELPID_MsiInstall_RegistryValue), helpstring("Returns a value from the registry")]
                BSTR RegistryValue([in] variant Root, [in] BSTR Key, [in, optional] VARIANT Value);
            [id(DISPID_MsiInstall_FileAttributes), helpcontext(HELPID_MsiInstall_FileAttributes), helpstring("Returns file attributes for path")]
                long FileAttributes([in] BSTR FilePath);
            [id(DISPID_MsiInstall_FileSize), helpcontext(HELPID_MsiInstall_FileSize), helpstring("Returns file size for path")]
                long FileSize([in] BSTR FilePath);
            [id(DISPID_MsiInstall_FileVersion), helpcontext(HELPID_MsiInstall_FileVersion), helpstring("Returns file version or languages for path")]
                BSTR FileVersion([in] BSTR FilePath, [in, optional] VARIANT Language);
            [id(DISPID_MsiInstall_Environment), propget, helpcontext(HELPID_MsiInstall_Environment), helpstring("The value of an environment variable")]
                BSTR Environment([in] BSTR Variable);
            [id(DISPID_MsiInstall_Environment), propput]
                void Environment([in] BSTR Variable, [in] BSTR Value);
            [id(DISPID_MsiInstall_ProductState), propget, helpcontext(HELPID_MsiInstall_ProductState), helpstring("Current installed state the product")]
                MsiInstallState ProductState([in] BSTR Product);
            [id(DISPID_MsiInstall_ProductInfo), propget, helpcontext(HELPID_MsiInstall_ProductInfo), helpstring("Value for specified registered product attribute")]
                BSTR ProductInfo([in] BSTR Product, [in] BSTR Attribute);
            [id(DISPID_MsiInstall_ConfigureProduct), helpcontext(HELPID_MsiInstall_ConfigureProduct), helpstring("Alters the installed state for the product")]
                void ConfigureProduct([in] BSTR Product, [in] long InstallLevel, [in] MsiInstallState InstallState);
            [id(DISPID_MsiInstall_ReinstallProduct), helpcontext(HELPID_MsiInstall_ReinstallProduct), helpstring("Reinstalls the product in various modes")]
                void ReinstallProduct([in] BSTR Product, [in] MsiReinstallMode ReinstallMode);
            [id(DISPID_MsiInstall_CollectUserInfo), helpcontext(HELPID_MsiInstall_CollectUserInfo), helpstring("Runs a product action (dialog) that requests user information")]
                void CollectUserInfo([in] BSTR Product);
            [id(DISPID_MsiInstall_ApplyPatch), helpcontext(HELPID_MsiInstall_ApplyPatch), helpstring("Applies a patch to the product")]
                void ApplyPatch([in] BSTR PatchPackage, [in] BSTR InstallPackage, [in] MsiInstallType InstallType, [in] BSTR CommandLine);
            [id(DISPID_MsiInstall_FeatureParent), propget, helpcontext(HELPID_MsiInstall_FeatureParent), helpstring("The parent feature for the specified feature")]
                BSTR FeatureParent([in] BSTR Product, [in] BSTR Feature);
            [id(DISPID_MsiInstall_FeatureState), propget, helpcontext(HELPID_MsiInstall_FeatureState), helpstring("The installed state for the specified feature")]
                MsiInstallState FeatureState([in] BSTR Product, [in] BSTR Feature);
            [id(DISPID_MsiInstall_UseFeature), helpcontext(HELPID_MsiInstall_UseFeature), helpstring("Insures feature is present, bumps usage count")]
                void UseFeature([in] BSTR Product, [in] BSTR Feature, [in] MsiInstallMode InstallMode);
            [id(DISPID_MsiInstall_FeatureUsageCount), propget, helpcontext(HELPID_MsiInstall_FeatureUsageCount), helpstring("Usage count for specified feature")]
                long FeatureUsageCount([in] BSTR Product, [in] BSTR Feature);
            [id(DISPID_MsiInstall_FeatureUsageDate), propget, helpcontext(HELPID_MsiInstall_FeatureUsageDate), helpstring("Last used date for specified feature")]
                date FeatureUsageDate([in] BSTR Product, [in] BSTR Feature);
            [id(DISPID_MsiInstall_ConfigureFeature), helpcontext(HELPID_MsiInstall_ConfigureFeature), helpstring("Alters the installed state for a feature")]
                void ConfigureFeature([in] BSTR Product, [in] BSTR Feature, [in] MsiInstallState InstallState);
            [id(DISPID_MsiInstall_ReinstallFeature), helpcontext(HELPID_MsiInstall_ReinstallFeature), helpstring("Reinstalls a specified feature")]
                void ReinstallFeature([in] BSTR Product, [in] BSTR Feature, [in] MsiReinstallMode ReinstallMode);
            [id(DISPID_MsiInstall_ProvideComponent), helpcontext(HELPID_MsiInstall_ProvideComponent), helpstring("Insures a feature to be present, returns component path")]
                BSTR ProvideComponent([in] BSTR Product, [in] BSTR Feature, [in] BSTR Component, [in] long InstallMode);
            [id(DISPID_MsiInstall_ComponentPath), propget, helpcontext(HELPID_MsiInstall_ComponentPath), helpstring("Returns the path for a specified component for a specified product")]
                BSTR ComponentPath([in] BSTR Product, [in] BSTR Component);
            [id(DISPID_MsiInstall_ProvideQualifiedComponent), helpcontext(HELPID_MsiInstall_ProvideQualifiedComponent), helpstring("Returns path to a componentn, specified by a category and qualifier, installing as necessary")]
                BSTR ProvideQualifiedComponent([in] BSTR Category, [in] BSTR Qualifier, [in] long InstallMode);
            [id(DISPID_MsiInstall_QualifierDescription), propget, helpcontext(HELPID_MsiInstall_QualifierDescription), helpstring("Descriptive text for a give qualifier")]
                BSTR QualifierDescription([in] BSTR Category, [in] BSTR Qualifier);
            [id(DISPID_MsiInstall_ComponentQualifiers), propget, helpcontext(HELPID_MsiInstall_ComponentQualifiers), helpstring("The set of registered qualifiers for a category")]
                StringList* ComponentQualifiers([in] BSTR Category);
            [id(DISPID_MsiInstall_Products), propget, helpcontext(HELPID_MsiInstall_Products), helpstring("The set of registered products, user + machine")]
                StringList* Products();
            [id(DISPID_MsiInstall_Features), propget, helpcontext(HELPID_MsiInstall_Features), helpstring("The set of registered features for a product")]
                StringList* Features([in] BSTR Product);
            [id(DISPID_MsiInstall_Components), propget, helpcontext(HELPID_MsiInstall_Components), helpstring("The set of registered components for the system")]
                StringList* Components();
            [id(DISPID_MsiInstall_ComponentClients), propget, helpcontext(HELPID_MsiInstall_ComponentClients), helpstring("The set of products that have installed the component")]
                StringList* ComponentClients([in] BSTR Component);
            [id(DISPID_MsiInstall_Patches), propget, helpcontext(HELPID_MsiInstall_Patches), helpstring("The set of patches applied to the product")]
                StringList* Patches([in] BSTR Product);
            [id(DISPID_MsiInstall_RelatedProducts), propget, helpcontext(HELPID_MsiInstall_RelatedProducts), helpstring("The set of related products")]
                StringList* RelatedProducts([in] BSTR UpgradeCode);
            [id(DISPID_MsiInstall_PatchInfo), propget, helpcontext(HELPID_MsiInstall_PatchInfo), helpstring("Returns the value for specified registered patch attribute")]
                BSTR PatchInfo([in] BSTR Patch, [in] BSTR Attribute);
            [id(DISPID_MsiInstall_PatchTransforms), propget, helpcontext(HELPID_MsiInstall_PatchTransforms), helpstring("Returns the list of transforms applied for patch")]
                BSTR PatchTransforms([in] BSTR Product, [in] BSTR Patch);
            [id(DISPID_MsiInstall_AddSource), helpcontext(HELPID_MsiInstall_AddSource), helpstring("Adds a source to the list of valid network sources for the product")]
                void AddSource([in] BSTR Product, [in] BSTR User, [in] BSTR Source);
            [id(DISPID_MsiInstall_ClearSourceList), helpcontext(HELPID_MsiInstall_ClearSourceList), helpstring("Removes all network sources from the list")]
                void ClearSourceList([in] BSTR Product, [in] BSTR User);
            [id(DISPID_MsiInstall_ForceSourceListResolution), helpcontext(HELPID_MsiInstall_ForceSourceListResolution),
                helpstring("Forces the installer to use the source resiliency system for the product the next time a source for the install is needed")]
                void ForceSourceListResolution([in] BSTR Product, [in] BSTR User);
            [id(DISPID_MsiInstall_GetShortcutTarget), propget, helpcontext(HELPID_MsiInstall_GetShortcutTarget),
                helpstring("Retrieves product code, feature id, and component code if available from a shortcut")]
                Record* GetShortcutTarget([in] BSTR ShortcutPath);
            [id(DISPID_MsiInstall_FileHash), helpcontext(HELPID_MsiInstall_FileHash), helpstring("Returns 128-bit hash for path, stored in a 4-field Record")]
                Record* FileHash([in] BSTR FilePath, [in] long Options);
            [id(DISPID_MsiInstall_FileSignatureInfo), helpcontext(HELPID_MsiInstall_FileSignatureInfo), helpstring("Returns the encoded signer certificate or hash of a digitally signed file")]
                SAFEARRAY(unsigned char) FileSignatureInfo([in] BSTR FilePath, [in] long Options, [in] MsiSignatureInfo Format);
    };

    [
        uuid(000C1093-0000-0000-C000-000000000046),  // IID_IMsiApiRecord
        helpcontext(HELPID_MsiRecord_Object), helpstring("Object holding a set of values")
    ]
    dispinterface Record
    {
        properties:
        methods:
            [id(DISPID_MsiRecord_StringData), propget, helpcontext(HELPID_MsiRecord_StringData), helpstring("The string value of the indexed field")]
                BSTR StringData([in] long Field);
            [id(DISPID_MsiRecord_StringData), propput]
                void StringData([in] long Field, [in] BSTR Value);
            [id(DISPID_MsiRecord_IntegerData), propget, helpcontext(HELPID_MsiRecord_IntegerData), helpstring("The integer value of the indexed field")]
                long IntegerData([in] long Field);
            [id(DISPID_MsiRecord_IntegerData), propput]
                void IntegerData([in] long Field, [in] long Value);
            [id(DISPID_MsiRecord_SetStream), helpcontext(HELPID_MsiRecord_SetStream), helpstring("Copies a file into indicated field")]
                void SetStream([in] long Field, [in] BSTR FilePath);
            [id(DISPID_MsiRecord_ReadStream), helpcontext(HELPID_MsiRecord_ReadStream), helpstring("Copies bytes from a stream as a string")]
                BSTR ReadStream([in] long Field, [in] long Length, [in] MsiReadStream Format);
            [id(DISPID_MsiRecord_FieldCount), propget, helpcontext(HELPID_MsiRecord_FieldCount), helpstring("Number of fields in record")]
                long FieldCount();
            [id(DISPID_MsiRecord_IsNull), propget, helpcontext(HELPID_MsiRecord_IsNull), helpstring("True if indexed field contains a null value")]
                boolean IsNull([in] long Field);
            [id(DISPID_MsiRecord_DataSize), propget, helpcontext(HELPID_MsiRecord_DataSize), helpstring("Size in bytes of data for indicated field")]
                long DataSize([in] long Field);
            [id(DISPID_MsiRecord_ClearData), helpcontext(HELPID_MsiRecord_ClearData), helpstring("Clears all fields in record")]
                void ClearData();
            [id(DISPID_MsiRecord_FormatText), helpcontext(HELPID_MsiRecord_FormatText), helpstring("Format fields according to template in field 0")]
                BSTR FormatText();
    };

    [
        uuid(000C109D-0000-0000-C000-000000000046),  // IID_IMsiApiDatabase
        helpcontext(HELPID_MsiDatabase_Object), helpstring("Opened database object")
    ]
    dispinterface Database
    {
        properties:
        methods:
            [id(DISPID_MsiDatabase_DatabaseState), propget, helpcontext(HELPID_MsiDatabase_DatabaseState), helpstring("Returns the update state of the database")]
                MsiDatabaseState DatabaseState();
            [id(DISPID_MsiDatabase_SummaryInformation), propget, helpcontext(HELPID_MsiDatabase_SummaryInformation), helpstring("Returns the summary information object for the database")]
                SummaryInfo* SummaryInformation([in, defaultvalue(0)] long UpdateCount);
            [id(DISPID_MsiDatabase_OpenView), helpcontext(HELPID_MsiDatabase_OpenView), helpstring("Opens a view using a SQL string")]
                View* OpenView([in] BSTR Sql);
            [id(DISPID_MsiDatabase_Commit), helpcontext(HELPID_MsiDatabase_Commit), helpstring("Commits the database to persistent storage")]
                void Commit();
            [id(DISPID_MsiDatabase_PrimaryKeys), propget, helpcontext(HELPID_MsiDatabase_PrimaryKeys), helpstring("Returns a record contining the primary key names")]
                Record* PrimaryKeys([in] BSTR Table);
            [id(DISPID_MsiDatabase_Import), helpcontext(HELPID_MsiDatabase_Import), helpstring("Imports an archived table to the database")]
                void Import([in] BSTR Folder, [in] BSTR File);
            [id(DISPID_MsiDatabase_Export), helpcontext(HELPID_MsiDatabase_Export), helpstring("Exports a table to an archive file")]
                void Export([in] BSTR Table, [in] BSTR Folder, [in] BSTR File);
            [id(DISPID_MsiDatabase_Merge), helpcontext(HELPID_MsiDatabase_Merge), helpstring("Merges another database")]
                boolean Merge([in] Database* Database, [in, defaultvalue(0)] BSTR ErrorTable);
            [id(DISPID_MsiDatabase_GenerateTransform), helpcontext(HELPID_MsiDatabase_GenerateTransform), helpstring("Generates a transform using a reference database")]
                boolean GenerateTransform([in] Database* ReferenceDatabase, [in, defaultvalue(0)] BSTR TransformFile);
            [id(DISPID_MsiDatabase_ApplyTransform), helpcontext(HELPID_MsiDatabase_ApplyTransform), helpstring("Applies a transform to the database")]
                void ApplyTransform([in] BSTR TransformFile, [in] MsiTransformError ErrorConditions);
            [id(DISPID_MsiDatabase_EnableUIPreview), helpcontext(HELPID_MsiDatabase_EnableUIPreview), helpstring("Enables preview of UI dialogs and billboards")]
                UIPreview* EnableUIPreview();
            [id(DISPID_MsiDatabase_TablePersistent), propget, helpcontext(HELPID_MsiDatabase_TablePersistent), helpstring("Returns the persistent state of the table")]
                MsiEvaluateCondition TablePersistent([in] BSTR Table);
            [id(DISPID_MsiDatabase_CreateTransformSummaryInfo), helpcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo), helpstring("Creates transform summary information stream")]
                void CreateTransformSummaryInfo([in] Database* ReferenceDatabase, [in] BSTR TransformFile, [in] MsiTransformError ErrorConditions, [in] MsiTransformValidation Validation);
    };

    [
        uuid(000C109C-0000-0000-C000-000000000046),  // IID_IMsiApiView
        helpcontext(HELPID_MsiView_Object), helpstring("Opened database view object")
    ]
    dispinterface View
    {
        properties:
        methods:
            [id(DISPID_MsiView_Execute), helpcontext(HELPID_MsiView_Execute), helpstring("Executes the query with optional parameters")]
                void Execute([in, defaultvalue(0)] Record* Params);
            [id(DISPID_MsiView_Fetch), helpcontext(HELPID_MsiView_Fetch), helpstring("Fetches a record")]
                Record* Fetch();
            [id(DISPID_MsiView_Modify), helpcontext(HELPID_MsiView_Modify), helpstring("Modifies or validate the view data")]
                void Modify([in] MsiViewModify Mode, Record* Record);
            [id(DISPID_MsiView_ColumnInfo), propget, helpcontext(HELPID_MsiView_ColumnInfo), helpstring("Fetches column names or definitions")]
                Record* ColumnInfo([in] MsiColumnInfo Info);
            [id(DISPID_MsiView_Close), helpcontext(HELPID_MsiView_Close), helpstring("Closes the open view")]
                void Close();
            [id(DISPID_MsiView_GetError), helpcontext(HELPID_MsiView_GetError), helpstring("Gets the next validation column error")]
                BSTR GetError();
    };

    [
        uuid(000C109B-0000-0000-C000-000000000046),  // IID_IMsiApiSummaryInfo
        helpcontext(HELPID_MsiSummaryInfo_Object), helpstring("Object accessing database summary information stream")
    ]
    dispinterface SummaryInfo
    {
        properties:
        methods:
            [id(DISPID_MsiSummaryInfo_Property), propget, helpcontext(HELPID_MsiSummaryInfo_Property), helpstring("Property")]
                variant Property([in] long Pid);
            [id(DISPID_MsiSummaryInfo_Property), propput]
                void Property([in] long Pid, [in] variant Value);
            [id(DISPID_MsiSummaryInfo_PropertyCount), propget, helpcontext(HELPID_MsiSummaryInfo_PropertyCount), helpstring("PropertyCount")]
                long PropertyCount();
            [id(DISPID_MsiSummaryInfo_Persist), helpcontext(HELPID_MsiSummaryInfo_Persist), helpstring("Persist      ")]
                void Persist();
    };

    [
        uuid(000C109A-0000-0000-C000-000000000046),  // IID_IMsiApiUIPreview
        helpcontext(HELPID_MsiUIPreview_Object), helpstring("Object allowing dialogs to be viewed")
    ]
    dispinterface UIPreview
    {
        properties:
        methods:
            [id(DISPID_MsiUIPreview_Property), propget, helpcontext(HELPID_MsiEngine_Property), helpstring("The string value of the indicated property")]
                BSTR Property([in] BSTR Name);
            [id(DISPID_MsiUIPreview_Property), propput]
                void Property([in] BSTR Name, [in] BSTR Value);
            [id(DISPID_MsiUIPreview_ViewDialog), helpcontext(HELPID_MsiUIPreview_ViewDialog   ), helpstring("Displays a UI Dialog")]
                void ViewDialog([in] BSTR Dialog);
            [id(DISPID_MsiUIPreview_ViewBillboard), helpcontext(HELPID_MsiUIPreview_ViewBillboard), helpstring("Displays a UI Billboard")]
                void ViewBillboard([in] BSTR Control, [in] BSTR Billboard);
    };

    [
        uuid(000C109E-0000-0000-C000-000000000046),  // IID_IMsiApiEngine
        helpcontext(HELPID_MsiEngine_Object), helpstring("Active install session object")
    ]
    dispinterface Session
    {
        properties:
        methods:
            [id(DISPID_MsiEngine_Application), propget, helpcontext(HELPID_MsiEngine_Application), helpstring("The installer object")]
                Installer* Installer();
            [id(DISPID_MsiEngine_Property), propget, helpcontext(HELPID_MsiEngine_Property), helpstring("The string value of the indicated property")]
                BSTR Property([in] BSTR Name);
            [id(DISPID_MsiEngine_Property), propput]
                void Property([in] BSTR Name, [in] BSTR Value);
            [id(DISPID_MsiEngine_Language), propget, helpcontext(HELPID_MsiEngine_Language), helpstring("The language ID used by the current install")]
                long Language();
            [id(DISPID_MsiEngine_Mode), propget, helpcontext(HELPID_MsiEngine_Mode), helpstring("The boolean value of the indicated mode flag")]
                boolean Mode([in] MsiRunMode Flag);
            [id(DISPID_MsiEngine_Mode), propput]
                void Mode([in] MsiRunMode Flag, [in] boolean Value);
            [id(DISPID_MsiEngine_Database), propget, helpcontext(HELPID_MsiEngine_Database), helpstring("Returns the active database")]
                Database* Database();
            [id(DISPID_MsiEngine_SourcePath), propget, helpcontext(HELPID_MsiEngine_SourcePath), helpstring("The source path for a folder")]
                BSTR SourcePath([in] BSTR Folder);
            [id(DISPID_MsiEngine_TargetPath), propget, helpcontext(HELPID_MsiEngine_TargetPath), helpstring("The target path for a folder")]
                BSTR TargetPath([in] BSTR Folder);
            [id(DISPID_MsiEngine_TargetPath), propput]
                void TargetPath([in] BSTR Folder, [in] BSTR Path);
            [id(DISPID_MsiEngine_DoAction), helpcontext(HELPID_MsiEngine_DoAction), helpstring("Performs indicated action")]
                MsiDoActionStatus DoAction([in] BSTR Action);
            [id(DISPID_MsiEngine_Sequence), helpcontext(HELPID_MsiEngine_Sequence), helpstring("Executes actions in a sequence table")]
                MsiDoActionStatus Sequence([in] BSTR Table, [in, optional] VARIANT Mode);
            [id(DISPID_MsiEngine_EvaluateCondition), helpcontext(HELPID_MsiEngine_EvaluateCondition), helpstring("Evaluates a conditional expression")]
                MsiEvaluateCondition EvaluateCondition([in] BSTR Expression);
            [id(DISPID_MsiEngine_FormatRecord), helpcontext(HELPID_MsiEngine_FormatRecord), helpstring("Formats record data with a template string")]
                BSTR FormatRecord([in] Record* Record);
            [id(DISPID_MsiEngine_Message), helpcontext(HELPID_MsiEngine_Message), helpstring("Processes and dispatches a message record")]
                MsiMessageStatus Message([in] MsiMessageType Kind, [in] Record* Record);
            [id(DISPID_MsiEngine_FeatureCurrentState), propget, helpcontext(HELPID_MsiEngine_FeatureCurrentState), helpstring("The current installed state for a feature")]
                MsiInstallState FeatureCurrentState([in] BSTR Feature);
            [id(DISPID_MsiEngine_FeatureRequestState), propget, helpcontext(HELPID_MsiEngine_FeatureRequestState), helpstring("The requested installed state for a feature")]
                MsiInstallState FeatureRequestState([in] BSTR Feature);
            [id(DISPID_MsiEngine_FeatureRequestState), propput]
                void FeatureRequestState([in] BSTR Feature, [in] MsiInstallState State);
            [id(DISPID_MsiEngine_FeatureValidStates), propget, helpcontext(HELPID_MsiEngine_FeatureValidStates), helpstring("The permitted installed states for a feature")]
                long FeatureValidStates([in] BSTR Feature);
            [id(DISPID_MsiEngine_FeatureCost), propget, helpcontext(HELPID_MsiEngine_FeatureCost), helpstring("The disk space cost for a feature")]
                long FeatureCost([in] BSTR Feature, [in] MsiCostTree CostTree, [in] MsiInstallState State);
            [id(DISPID_MsiEngine_ComponentCurrentState), propget, helpcontext(HELPID_MsiEngine_ComponentCurrentState), helpstring("The current installed state for a component")]
                MsiInstallState ComponentCurrentState([in] BSTR Component);
            [id(DISPID_MsiEngine_ComponentRequestState), propget, helpcontext(HELPID_MsiEngine_ComponentRequestState), helpstring("The requested installed state for a component")]
                MsiInstallState ComponentRequestState([in] BSTR Component);
            [id(DISPID_MsiEngine_ComponentRequestState), propput]
                void ComponentRequestState([in] BSTR Component, [in] MsiInstallState State);
            [id(DISPID_MsiEngine_SetInstallLevel), helpcontext(HELPID_MsiEngine_SetInstallLevel), helpstring("Sets the install level for a new product")]
                void SetInstallLevel([in] long Level);
            [id(DISPID_MsiEngine_VerifyDiskSpace), propget, helpcontext(HELPID_MsiEngine_VerifyDiskSpace), helpstring("Whether sufficient disk space exists for the current install")]
                boolean VerifyDiskSpace();
            [id(DISPID_MsiEngine_ProductProperty), propget, helpcontext(HELPID_MsiEngine_ProductProperty), helpstring("Specified property value from an opened product")]
                BSTR ProductProperty([in] BSTR Property);
            [id(DISPID_MsiEngine_FeatureInfo), propget, helpcontext(HELPID_MsiEngine_FeatureInfo), helpstring("Object containing information for specified product feature")]
                FeatureInfo* FeatureInfo([in] BSTR Feature);
            [id(DISPID_MsiEngine_ComponentCosts), propget, helpcontext(HELPID_MsiEngine_ComponentCosts), helpstring("The set of record objects that hold information on volume names, costs and temporary costs")]
                RecordList* ComponentCosts([in] BSTR Component, [in] MsiInstallState State);
    };

    [
        uuid(000C109F-0000-0000-C000-000000000046),  // IID_IMsiApiFeatureInfo
        helpcontext(HELPID_MsiFeatureInfo_Object), helpstring("Feature attributes from Session.FeatureInfo")
    ]
    dispinterface FeatureInfo
    {
        properties:
            [id(DISPID_MsiFeatureInfo_Attributes), helpcontext(HELPID_MsiFeatureInfo_Attributes), helpstring("Installation option bits for feature")]
                long Attributes;
        methods:
            [id(DISPID_MsiFeatureInfo_Title)      , propget, helpcontext(HELPID_MsiFeatureInfo_Title), helpstring("Short title for feature, key")]
                BSTR Title();
            [id(DISPID_MsiFeatureInfo_Description), propget, helpcontext(HELPID_MsiFeatureInfo_Description), helpstring("Description of feature, localized")]
                BSTR Description();

    };

    [
        uuid(000C1095-0000-0000-C000-000000000046),  // IID_IMsiApiCollection
        helpcontext(HELPID_MsiCollection_Object), helpstring("Collection of string installer registration data")
    ]
    dispinterface StringList
    {
        properties:
        methods:
            [id(DISPID_NEWENUM)      ]
                IUnknown* _NewEnum();
            [id(DISPID_VALUE), propget, helpcontext(HELPID_MsiCollection_Item)]
                BSTR Item(long Index);
            [id(DISPID_MsiCollection_Count), propget, helpcontext(HELPID_MsiCollection_Count)]
                long Count();
    };

    [
        uuid(000C1096-0000-0000-C000-000000000046),  // iidMsiRecordCollection
        helpcontext(HELPID_MsiRecordCollection_Object), helpstring("Collection of record data")
    ]
    dispinterface RecordList
    {
        properties:
        methods:
            [id(DISPID_NEWENUM)      ]
                IUnknown* _NewEnum();
            [id(DISPID_VALUE), propget, helpcontext(HELPID_MsiCollection_Item)]
                RECORD* Item(long Index);
            [id(DISPID_MsiCollection_Count), propget, helpcontext(HELPID_MsiCollection_Count)]
                long Count();
    };

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\res\make.inc ===
!INCLUDE ..\..\MsiMake.inc

RES_INTL_DIR=$(RES_DIR)\intl

ResAll: $(BUILD_DIR) \
	$(BUILD_COMMONDIR) \
	$(RES_OBJDIR)\msi.rcv \
	$(RES_OBJDIR)\msiAll.res \
	$(RES_OBJDIR)\enumsi.res # for localization only, not used in builds

clean:
	del $(BUILD_DIR)\*.bsc
	del $(BUILD_DIR)\*.exe
	del $(BUILD_DIR)\*.dll
	del $(BUILD_DIR)\*.pdb
	del $(BUILD_DIR)\*.lib
	del $(BUILD_DIR)\*.exp

	
#Create target directories if not already existing
#-------------------------------------------------
$(BUILD_DIR): 
	md $(BUILD_DIR)

$(BUILD_COMMONDIR):
	md $(BUILD_COMMONDIR)

#Build our msi.rcv token file
#----------------------------
$(RES_OBJDIR)\msi.rcv: $(INC_DIR)\rcv.src $(INC_DIR)\rcv.tok
	@if not exist $(RES_OBJDIR) md $(RES_OBJDIR)
	$(TOOLS_DIR)\tok -q -f $(INC_DIR)\rcv.tok $(INC_DIR)\rcv.src > $@



{$(RES_DIR)}.rc{$(RES_OBJDIR)}.res:
	rc $(C_DEFINES) -d_RC32 -Fo$*.res -i $(INC_DIR) -i $(BUILD_COMMONDIR) -i $(SDK_INC_PATH) -i $(RES_OBJDIR) -dNEUTRAL_SUBLANGUAGE $< 


$(RES_OBJDIR)\msiAll.res: $(RES_OBJDIR)\msi.res $(RES_OBJDIR)\msiENU.res $(RES_INTL_DIR)\msi???.res $(RES_OBJDIR)\enuerr.rc $(RES_OBJDIR)\autoapii.tlb
	copy /b $(RES_OBJDIR)\msi.res + $(RES_OBJDIR)\msiENU.res + $(RES_INTL_DIR)\msi???.res /b $@

$(RES_OBJDIR)\msi.res: $(RES_OBJDIR)\msi.rcv $(RES_DIR)\msi.rc $(RES_OBJDIR)\autoapii.tlb

$(RES_OBJDIR)\autoapii.tlb: ..\autoapi.cpp $(INC_DIR)\autoapi.h $(INC_DIR)\msi.hh
	midl -char unsigned -ms_ext -c_ext $(C_DEFINES) -D__MKTYPLIB__  -tlb $@ /I$(INC_DIR) /I$(SDK_INC_PATH) -cpp_cmd $(MIDL_CPP) -mktyplib203 ..\autoapi.cpp
#	mktyplib $(C_DEFINES) /tlb $@ /w0 /I $(INC_DIR) ..\autoapi.cpp

$(RES_OBJDIR)\msiENU.res: $(RES_DIR)\msiENU.rc $(RES_OBJDIR)\enuerr.rc $(RES_OBJDIR)\EventENU.bin

# for localization only, not used in builds
$(RES_OBJDIR)\enumsi.res: ..\msiENU.rc
	rc $(C_DEFINES) -d_RC32 -Fo$(RES_OBJDIR)\enumsi.res -i $(INC_DIR) -i $(BUILD_COMMONDIR) -i $(SDK_INC_PATH) -i $(RES_OBJDIR) ..\msiENU.rc

$(RES_OBJDIR)\enuerr.rc: $(MSI_BUILDTOOLS_DIR)\genenuer.prl
	$(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genenuer.prl $(SDK_INC_PATH)\msi.h $@

$(RES_OBJDIR)\EventENU.bin $(INC_DIR)\Eventlog.h: $(RES_DIR)\Eventlog.mc
	mc -h $(RES_OBJDIR) -r $(RES_OBJDIR) $(RES_DIR)\Eventlog.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\samples\create.dll\sources.inc ===
TARGETNAME=create

!INCLUDE ..\..\..\MsiMake.inc

!if "$(MSI_BROWSER_INFO)"=="1"
BROWSER_INFO=1
!endif

TARGETTYPE=DYNLINK

USE_LIBCMT=1

USE_NOLIBS=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\create.def

INCLUDES=$(INC_DIR);$(SDK_INC_PATH);$(RES_OBJDIR)

TARGETLIBS=\
        $(SDK_LIB_PATH)\netapi32.lib \
		$(SDK_LIB_PATH)\user32.lib \
		$(SDK_LIB_PATH)\kernel32.lib \
        $(BUILD_DIR)\msi.lib

SOURCES=..\create.cpp \
		..\create.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\samples\custdll\sources.inc ===
TARGETNAME=custact1
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=DYNLINK
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

NO_BINPLACE=1

UMTYPE=windows
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\custact1.def

USE_LIBCMT=1

TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\msi.lib

C_DEFINES=$(C_DEFINES) 

INCLUDES=$(INCLUDES);$(INC_DIR)

SOURCES=..\custact1.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\samples\create.dll\create.cpp ===
#if 0  // makefile definitions
DESCRIPTION = CreateUserAccount on Local Machine
MODULENAME = create
FILEVERSION = Msi
ENTRY = CreateUserAccount
UNICODE=1
LINKLIBS = netapi32.lib
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

// Required headers
#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>
#ifndef RC_INVOKED    // start of source code

#include "msiquery.h"
#include "msidefs.h"
#include <windows.h>
#include <basetsd.h>
#include <stdlib.h>
#include <lm.h>

#define UNICODE 1

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, all rights reserved
//
//  File:       create.cpp
//
//  Notes: DLL custom action sample , must be used in conjunction with the DLL
//         custom actions included in process.cpp and remove.cpp
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//  - SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//      %vcbin%\nmake -f create.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//      1. Create a new Win32 DLL project
//      2. Add create.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib and netapi32.lib to the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//      5. Add /DUNICODE to the project options in the Project Settings dialog
//
//------------------------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// ClearSecret
//
//     Zeroes the secret data in the wszSecret buffer.  This is to reduce
//     the amount of time the secret data is kept in clear text in memory. 
//
void ClearSecret(WCHAR* wszSecret, DWORD cbSecret)
{
	if (!wszSecret)
		return; // nothing to do

	volatile char* vpch = (volatile char*)wszSecret;
	while (cbSecret)
	{
		*vpch = 0;
		vpch++;
		cbSecret--;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CreateUserAccount
//
//     Attempts to create a user account on the local machine according
//       to the "instructions" provided in the CustomActionData property
//
//     As a deferred custom action, you do not have access to the database.
//       The only source of infromation comes from a property that another
//       custom action can set to provide the information you need.  This
//       property is written into the script
//
UINT __stdcall CreateUserAccount(MSIHANDLE hInstall)
{
	const WCHAR* wszSep = L"\001";
	const int iCreationError = 25001;
	const int iCreationDuplicate = 25002;

	// Grab the CustomActionData property
	WCHAR* wszCAData = 0;
	DWORD cchCAData = 0;
	
	if (ERROR_MORE_DATA != MsiGetPropertyW(hInstall, IPROPNAME_CUSTOMACTIONDATA, L"", &cchCAData))
		return ERROR_INSTALL_FAILURE;
	
	wszCAData = new WCHAR[++cchCAData];
	if ( !wszCAData )
		return ERROR_INSTALL_FAILURE; // out of memory
	
	wszCAData[0] = 0;

	if (ERROR_SUCCESS != MsiGetPropertyW(hInstall, IPROPNAME_CUSTOMACTIONDATA, wszCAData, &cchCAData))
	{
		delete [] wszCAData;
		return ERROR_INSTALL_FAILURE; // error -- should never happen
	}

	USER_INFO_1 ui;
	ZeroMemory(&ui, sizeof(USER_INFO_1));

	DWORD dwLevel = 1; // represents USER_INFO_1 struct
	NET_API_STATUS nStatus = NERR_Success;

	//
	// Parse CustomActionDataProperty
	//
	WCHAR* wszUserName = wcstok(wszCAData, wszSep);
	if ( !wszUserName )
	{
		ClearSecret(wszCAData, cchCAData*sizeof(WCHAR));
		delete [] wszCAData;
		return ERROR_INSTALL_FAILURE;
	}
	WCHAR* wszPassWd   = wcstok(NULL, wszSep);
	if ( !wszPassWd )
	{
		ClearSecret(wszCAData, cchCAData*sizeof(WCHAR));
		delete [] wszCAData;
		return ERROR_INSTALL_FAILURE;
	}
	WCHAR* pwch = wcstok(NULL, wszSep);
	if ( !pwch )
	{
		ClearSecret(wszCAData, cchCAData*sizeof(WCHAR));
		delete [] wszCAData;
		return ERROR_INSTALL_FAILURE; // error -- should never happen
	}

	int iUserFlags = wcstol(pwch, 0, 10);
	
	//
	// Set up the USER_INFO_1 structure.
	//  USER_PRIV_USER: name identifies a user, 
	//    rather than an administrator or a guest.
	//  UF_SCRIPT: required for LAN Manager 2.0 and
	//    Windows NT/Windows 2000.
	//
	ui.usri1_name = wszUserName;
	ui.usri1_password = wszPassWd;
	ui.usri1_priv = USER_PRIV_USER;
	ui.usri1_flags = UF_SCRIPT | iUserFlags;
	ui.usri1_home_dir = NULL;
	ui.usri1_comment = NULL;
	ui.usri1_script_path = NULL;

	// Send ActionData message (template in ActionText table)
	PMSIHANDLE hRec = MsiCreateRecord(1);
	if ( !hRec || ERROR_SUCCESS != MsiRecordSetStringW(hRec, 1, wszUserName))
	{
		ClearSecret(wszCAData, cchCAData*sizeof(WCHAR));
		delete [] wszCAData;
		return ERROR_INSTALL_FAILURE;
	}
	
	int iRet = MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRec);
	if (IDCANCEL == iRet || IDABORT == iRet)
	{
		ClearSecret(wszCAData, cchCAData*sizeof(WCHAR));
		delete [] wszCAData;
		return ERROR_INSTALL_USEREXIT;
	}


	//
	// Call the NetUserAdd function, specifying level 1.
	//
	nStatus = NetUserAdd(NULL /*local machine*/, dwLevel, (LPBYTE)&ui, NULL);  

	if (nStatus != NERR_Success)
	{
		PMSIHANDLE hRecErr = MsiCreateRecord(3);
		if ( !hRecErr 
			|| ERROR_SUCCESS != MsiRecordSetInteger(hRecErr, 1, (nStatus == NERR_UserExists) ? iCreationDuplicate : iCreationError)
			|| ERROR_SUCCESS != MsiRecordSetStringW(hRecErr, 2, wszUserName)
			|| ERROR_SUCCESS != MsiRecordSetInteger(hRecErr, 3, nStatus))
		{
			ClearSecret(wszCAData, cchCAData*sizeof(WCHAR));
			delete [] wszCAData;
			return ERROR_INSTALL_FAILURE;
		}
		
		// ignore MsiProcessMessage return below because we are aborting the install
		MsiProcessMessage(hInstall, INSTALLMESSAGE_ERROR, hRecErr);
	
		ClearSecret(wszCAData, cchCAData*sizeof(WCHAR));
		delete [] wszCAData;
		return ERROR_INSTALL_FAILURE; // error
	}

	ClearSecret(wszCAData, cchCAData*sizeof(WCHAR));
	delete [] wszCAData;
	return ERROR_SUCCESS;
}

#else // RC_INVOKED, end of source code, start of resources
// resource definition go here

#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\samples\custexe\sources.inc ===
TARGETNAME=custexe1
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

NO_BINPLACE=1

UMTYPE=windows
UMENTRY=$(MSI_WINENTRY)

USE_LIBCMT=1

TARGETLIBS=\
        $(SDK_LIB_PATH)\msi.lib

C_DEFINES=$(C_DEFINES) -D_EXE

INCLUDES=$(INCLUDES);$(INC_DIR)

SOURCES=..\custexe1.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\samples\custdll\custact1.cpp ===
#pragma message("Simple Custom Action DLL.  Copyright (c) 1997 - 2001 Microsoft Corp.")
#if 0  // makefile definitions
DESCRIPTION = Custom Action Test DLL
MODULENAME = CustAct1
FILEVERSION = 0.20
ENTRY = Action1,Action129,Action193,Action257,Action513,Action769,Action1025,Action1281,Action1537,KitchenSink,GPFault,DllRegisterServer,DllUnregisterServer
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       custact1.cpp
//
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f custact1.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 DLL project
//      2. Add custact1.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib to the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//
//------------------------------------------------------------------------------------------

// test of external database access
#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>  // included for both CPP and RC passes
#ifndef RC_INVOKED    // start of CPP source code
#include <stdio.h>    // printf/wprintf
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include "MsiQuery.h" // must be in this directory or on INCLUDE path

HRESULT __stdcall DllRegisterServer()
{
	Beep(1000, 500);
	return 0;
}

HRESULT __stdcall DllUnregisterServer()
{
	Beep(500, 500);
	return 0;
}

static UINT Action(MSIHANDLE hInstall, int iType, const TCHAR* szPass)
{
	TCHAR szProperty[] = TEXT("TESTACTION");
	TCHAR szValue[200];
	DWORD cchValue = sizeof(szValue)/sizeof(TCHAR);
	if (MsiGetProperty(hInstall, szProperty, szValue, &cchValue) != ERROR_SUCCESS || szValue[0] == 0)
		lstrcpy(szValue, TEXT("(none)"));
	if (iType & 128)  // asyncronous action, cannot call MsiProcessMessage without blocking install
	{
		TCHAR szMessage[256];
		wsprintf(szMessage, TEXT("Action %i, called from %s, TESTACTION = %s\rOK to succeed, CANCEL to fail"),
				 iType, szPass, szValue);
		return ::MessageBox(0, szMessage, TEXT("Installer custom action test"), MB_OKCANCEL);
	}
	PMSIHANDLE hrec = ::MsiCreateRecord(34);
	::MsiRecordSetString(hrec, 0, TEXT("Called from [2], TESTACTION = [3]\rOK to succeed, CANCEL to fail"));
	::MsiRecordSetInteger(hrec, 1, iType);  // not really an error code
	::MsiRecordSetString(hrec, 2, szPass);
	::MsiRecordSetString(hrec, 3, szValue);
	return ::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER + MB_OKCANCEL), hrec)
		== IDOK ? ERROR_SUCCESS : ERROR_INSTALL_USEREXIT;
}

UINT __stdcall Action1   (MSIHANDLE hInstall) { return Action(hInstall,   1, TEXT("Always run")); }
UINT __stdcall Action129 (MSIHANDLE hInstall) { return Action(hInstall, 129, TEXT("Always, asynch in sequence")); }
UINT __stdcall Action193 (MSIHANDLE hInstall) { return Action(hInstall, 193, TEXT("Always, asynch for session")); }
UINT __stdcall Action257 (MSIHANDLE hInstall) { return Action(hInstall, 257, TEXT("Once, client preferred")); }
UINT __stdcall Action513 (MSIHANDLE hInstall) { return Action(hInstall, 513, TEXT("Once per process")); }
UINT __stdcall Action769 (MSIHANDLE hInstall) { return Action(hInstall, 769, TEXT("Client 2nd sequence")); }
UINT __stdcall Action1025(MSIHANDLE hInstall) { return Action(hInstall,1025, TEXT("Execution script")); }
UINT __stdcall Action1281(MSIHANDLE hInstall) { return Action(hInstall,1281, TEXT("Rollback script")); }
UINT __stdcall Action1537(MSIHANDLE hInstall) { return Action(hInstall,1537, TEXT("Commit script")); }

UINT __stdcall GPFault(MSIHANDLE hInstall)
{
	if (::MessageBox(0, TEXT("OK to GPFault,  CANCEL to skip"), TEXT("GPFault Text"), MB_OKCANCEL)
			== IDCANCEL)
		return ERROR_SUCCESS;
	TCHAR* sz = (TCHAR*)0;
	sz[0] = 0;
	return ERROR_INSTALL_FAILURE;
}

void CheckError(UINT ui)
{
	if (ERROR_SUCCESS != ui)
		MessageBox(0, TEXT("FAILURE"), 0, 0);
}

UINT __stdcall KitchenSink(MSIHANDLE hInstall) 
{ 
	char  rgchAnsi[100];
	WCHAR rgchWide[100];
	DWORD cchBufAnsi = sizeof(rgchAnsi)/sizeof(char);
	DWORD cchBufWide = sizeof(rgchWide)/sizeof(WCHAR);
	MSIHANDLE h;
	
	CheckError(MsiGetPropertyA(hInstall, "ProductName", rgchAnsi, &cchBufAnsi));
	if (0 != lstrcmpA(rgchAnsi, "TestDb") || cchBufAnsi != sizeof("TestDb")/sizeof(char)-1)
		CheckError(E_FAIL);

	CheckError(MsiGetPropertyW(hInstall, L"ProductName", rgchWide, &cchBufWide));
	if (0 != lstrcmpW(rgchWide, L"TestDb") || cchBufWide != sizeof(L"TestDb")/sizeof(WCHAR)-1)
		CheckError(E_FAIL);

	h = MsiCreateRecord(4);
	CheckError(h == 0 ? E_FAIL : S_OK);
	CheckError(MsiCloseHandle(h));

	CheckError(MsiCloseAllHandles());

	PMSIHANDLE hDatabase;
	hDatabase = MsiGetActiveDatabase(hInstall);
	CheckError(hDatabase == 0 ? E_FAIL : S_OK);

	PMSIHANDLE hView;
	CheckError(MsiDatabaseOpenViewA(hDatabase, "SELECT `Value` FROM `Property` WHERE `Property`=?", &hView));
	PMSIHANDLE hRecord = MsiCreateRecord(1);
	CheckError(MsiRecordSetStringA(hRecord, 1, "ProductName"));
	CheckError(MsiViewExecute(hView, hRecord));
	PMSIHANDLE hResults;
	CheckError(MsiViewFetch(hView, &hResults));
	
	cchBufAnsi = sizeof(rgchAnsi)/sizeof(char);
	CheckError(MsiRecordGetStringA(hResults, 1, rgchAnsi, &cchBufAnsi));
	if (0 != lstrcmpA(rgchAnsi, "TestDb") || cchBufAnsi != sizeof("TestDb")/sizeof(char) - 1)
		CheckError(E_FAIL);

	CheckError(MsiSetMode(hInstall, MSIRUNMODE_REBOOTATEND, TRUE));
	if (TRUE != MsiGetMode(hInstall, MSIRUNMODE_REBOOTATEND))
		CheckError(E_FAIL);
	CheckError(MsiSetMode(hInstall, MSIRUNMODE_REBOOTATEND, FALSE));
	if (FALSE != MsiGetMode(hInstall, MSIRUNMODE_REBOOTATEND))
		CheckError(E_FAIL);

	INSTALLSTATE installed, action;
	CheckError(MsiSetFeatureStateA(hInstall, "QuickTest", INSTALLSTATE_SOURCE));
	CheckError(MsiGetFeatureStateA(hInstall, "QuickTest", &installed, &action));
	if (installed != INSTALLSTATE_ABSENT || action != INSTALLSTATE_SOURCE)
		CheckError(E_FAIL);
	



	return ERROR_SUCCESS;

/*
	HRESULT         __stdcall ViewGetError(unsigned long hView, ichar* szColumnNameBuffer,unsigned long* pcchBuf, int *pMsidbError);
	
	HRESULT         __stdcall ViewModify(unsigned long hView, long eUpdateMode, unsigned long hRecord);
	HRESULT         __stdcall ViewClose(unsigned long hView);
	HRESULT         __stdcall OpenDatabase(const ichar* szDatabasePath, const ichar* szPersist,unsigned long *phDatabase);
	HRESULT         __stdcall DatabaseCommit(unsigned long hDatabase);
	HRESULT         __stdcall DatabaseGetPrimaryKeys(unsigned long hDatabase, const ichar * szTableName,unsigned long *phRecord);
	HRESULT         __stdcall RecordIsNull(unsigned long hRecord, unsigned int iField, boolean *pfIsNull);
	HRESULT         __stdcall RecordDataSize(unsigned long hRecord, unsigned int iField,unsigned int* puiSize);
	HRESULT         __stdcall RecordSetInteger(unsigned long hRecord, unsigned int iField, int iValue);
	HRESULT         __stdcall RecordSetString(unsigned long hRecord,	unsigned int iField, const ichar* szValue);
	HRESULT         __stdcall RecordGetInteger(unsigned long hRecord, unsigned int iField, int *piValue);
	HRESULT         __stdcall RecordGetString(unsigned long hRecord, unsigned int iField, ichar* szValueBuf,unsigned long *pcchValueBuf);
	HRESULT         __stdcall RecordGetFieldCount(unsigned long hRecord,unsigned int* piCount);
	HRESULT         __stdcall RecordSetStream(unsigned long hRecord, unsigned int iField, const ichar* szFilePath);
	HRESULT         __stdcall RecordReadStream(unsigned long hRecord, unsigned int iField, char *szDataBuf,unsigned long *pcbDataBuf);
	HRESULT         __stdcall RecordClearData(unsigned long hRecord);
	HRESULT         __stdcall GetSummaryInformation(unsigned long hDatabase, const ichar*  szDatabasePath, unsigned int    uiUpdateCount, unsigned long *phSummaryInfo);
	HRESULT         __stdcall SummaryInfoGetPropertyCount(unsigned long hSummaryInfo,	unsigned int *puiPropertyCount);
	HRESULT         __stdcall SummaryInfoSetProperty(unsigned long hSummaryInfo,unsigned intuiProperty, unsigned intuiDataType, int iValue, FILETIME *pftValue, const ichar* szValue); 
	HRESULT         __stdcall SummaryInfoGetProperty(unsigned long hSummaryInfo,unsigned intuiProperty,unsigned int *puiDataType, int *piValue, FILETIME *pftValue, ichar*  szValueBuf,unsigned long *pcchValueBuf);
	HRESULT         __stdcall SummaryInfoPersist(unsigned long hSummaryInfo);
	
	HRESULT         __stdcall SetProperty(unsigned long hInstall, const ichar* szName, const ichar* szValue);
	HRESULT         __stdcall GetLanguage(unsigned long hInstall,unsigned short* pLangId);
	HRESULT         __stdcall GetMode(unsigned long hInstall, long eRunMode, boolean* pfSet); 
	HRESULT         __stdcall SetMode(unsigned long hInstall, long eRunMode, boolean fState);
	HRESULT         __stdcall FormatRecord(unsigned long hInstall, unsigned long hRecord, ichar* szResultBuf,unsigned long *pcchResultBuf);
	HRESULT         __stdcall DoAction(unsigned long hInstall, const ichar* szAction);    
	HRESULT         __stdcall Sequence(unsigned long hInstall, const ichar* szTable, int iSequenceMode);   
	HRESULT         __stdcall ProcessMessage(unsigned long hInstall, long eMessageType, unsigned long hRecord, int* piRes);
	HRESULT         __stdcall EvaluateCondition(unsigned long hInstall, const ichar* szCondition, int *piCondition);
	HRESULT         __stdcall GetComponentState(unsigned long hInstall, const ichar* szComponent, long *piInstalled, long *piAction);
	HRESULT         __stdcall SetComponentState(unsigned long hInstall, const ichar*     szComponent, long iState);
	HRESULT         __stdcall GetFeatureCost(unsigned long hInstall, const ichar* szFeature, int iCostTree, long iState, int *piCost);
	HRESULT         __stdcall SetInstallLevel(unsigned long hInstall, int iInstallLevel);
	HRESULT         __stdcall GetFeatureValidStates(unsigned long hInstall, const ichar* szFeature,unsigned long *dwInstallStates);
	HRESULT         __stdcall DatabaseIsTablePersistent(unsigned long hDatabase, const ichar* szTableName, int *piCondition);
	HRESULT         __stdcall ViewGetColumnInfo(unsigned long hView, long eColumnInfo,unsigned long *phRecord);
	HRESULT         __stdcall GetLastErrorRecord(unsigned long *phRecord);
	HRESULT         __stdcall GetSourcePath(unsigned long hInstall, const ichar* szFolder, ichar* szPathBuf, unsigned long *pcchPathBuf);
	HRESULT         __stdcall GetTargetPath(unsigned long hInstall, const ichar* szFolder, ichar* szPathBuf, unsigned long *pcchPathBuf); 
	HRESULT         __stdcall SetTargetPath(unsigned long hInstall, const ichar* szFolder, const ichar* szFolderPath);
	HRESULT         __stdcall VerifyDiskSpace(unsigned long hInstall);

*/

}

#else // RC_INVOKED, end of CPP source code, start of resource definitions
// resource definition go here
#endif // RC_INVOKED
#if 0  // required at end of source file, to hide makefile terminator
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\samples\custexe\custexe1.cpp ===
#pragma message("Custom Action Test EXE.  Copyright (c) 1997 - 2001 Microsoft Corporation. All rights reserved.")
#if 0  // makefile definitions
DESCRIPTION = Custom Action Test EXE
MODULENAME  = CustExe1
FILEVERSION = 1.0,0,0
SUBSYSTEM = windows
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       custexe1.cpp
//
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f custexe1.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 Application project
//      2. Add custexe1.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib to the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//
//------------------------------------------------------------------------------------------

#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#define IDD_TEST 1
#ifndef RC_INVOKED   // start of CPP source code

INT_PTR CALLBACK DialogProc(HWND  hwndDlg, UINT uMsg, WPARAM wParam, LPARAM  lParam)
{
	switch (uMsg)
	{
	case WM_INITDIALOG: return TRUE; // indicate we did not set focus to the control
	case WM_COMMAND:
		switch (wParam)
		{
		case IDOK:     PostQuitMessage(0); return TRUE;
		case IDCANCEL: PostQuitMessage(1); return TRUE;
		}
		return FALSE;
	default: return FALSE;
	};
}

extern "C" int __stdcall _tWinMain(HINSTANCE hInst, HINSTANCE/*hPrev*/, TCHAR* szCmdLine, int/*show*/)
{
	if ((szCmdLine[0]=='-' || szCmdLine[0]=='/') && (szCmdLine[1]=='Q' || szCmdLine[1]=='q'))
		return 0;
	HWND hWnd = ::CreateDialog(hInst, MAKEINTRESOURCE(1), 0, DialogProc);
	if (hWnd == 0)
		return 2;
	::SetDlgItemText(hWnd, 8, szCmdLine);
//	::ShowWindow(hWnd, SW_SHOW); //!! why do we need this?
	MSG msg;
	while (::GetMessage(&msg, 0, 0, 0) == TRUE)
		::IsDialogMessage(hWnd, &msg);
	::DestroyWindow(hWnd);
	return (int) msg.wParam;
}

#else // RC_INVOKED, end of source code, start of resources
IDD_TEST DIALOG 150, 150, 160, 75
STYLE DS_MODALFRAME | DS_NOIDLEMSG | WS_POPUP | WS_CAPTION | WS_VISIBLE
CAPTION "Custom Action Test EXE"
FONT 12, "Arial"
{
 LTEXT      "",         8,         20,  7, 120, 40
 PUSHBUTTON "&Succeed", IDOK,      20, 50,  40, 16
 PUSHBUTTON "&Fail",    IDCANCEL, 100, 50,  40, 16
}
#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\samples\process.dll\sources.inc ===
TARGETNAME=process

!INCLUDE ..\..\..\MsiMake.inc

!if "$(MSI_BROWSER_INFO)"=="1"
BROWSER_INFO=1
!endif

TARGETTYPE=DYNLINK

USE_LIBCMT=1

USE_NOLIBS=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\process.def

INCLUDES=$(SDK_INC_PATH);$(INC_DIR);$(RES_OBJDIR)

TARGETLIBS=\
        $(SDK_LIB_PATH)\netapi32.lib \
		$(SDK_LIB_PATH)\user32.lib \
		$(SDK_LIB_PATH)\kernel32.lib \
        $(BUILD_DIR)\msi.lib

SOURCES=..\process.cpp \
		..\process.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\samples\process.dll\process.cpp ===
#if 0  // makefile definitions
DESCRIPTION = Process UserAccounts Database Table
MODULENAME = process
FILEVERSION = Msi
ENTRY = ProcessUserAccounts,UninstallUserAccounts
LINKLIBS = netapi32.lib
UNICODE=1
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

// Required headers
#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>
#ifndef RC_INVOKED    // start of source code

#include "msiquery.h"
#include <windows.h>
#include <basetsd.h>
#include <lm.h>
#include "strsafe.h"

#define UNICODE 1

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, all rights reserved.
//
//  File:       process.cpp
//
//  Notes: DLL custom actions, must be used in conjunction with the DLL
//         custom actions included in create.cpp and remove.cpp
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f process.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 DLL project
//      2. Add process.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.libto the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//      5. Add /DUNICODE to the project options in the Project Settings dialog
//
//------------------------------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////////////
// ClearSecret
//
//     Zeroes the secret data in the wszSecret buffer.  This is to reduce
//     the amount of time the secret data is kept in clear text in memory. 
//
void ClearSecret(WCHAR* wszSecret, DWORD cbSecret)
{
	if (!wszSecret)
		return; // nothing to do

	volatile char* vpch = (volatile char*)wszSecret;
	while (cbSecret)
	{
		*vpch = 0;
		vpch++;
		cbSecret--;
	}
}

//////////////////////////////////////////////////////////////////////////
// ProcessUserAccounts (resides in process.dll)
//
//     Process the UserAccounts custom table generating deferred actions
//       to handle account creation (requires elevated priviledges) and
//       rollback
//
UINT __stdcall ProcessUserAccounts(MSIHANDLE hInstall)
{
	PMSIHANDLE hDatabase = MsiGetActiveDatabase(hInstall);
	if ( !hDatabase )
		return ERROR_INSTALL_FAILURE;

	PMSIHANDLE hView = 0;
	
	//
	// constants -- custom action names, SQL query, separator
	//
	// wszCreateCA = name of deferred CA to create account
	// wszRollbackCA = name of rollback CA to rollback account creation
	//
	const WCHAR wszCreateCA[] = L"CreateAccount";
	const WCHAR wszRollbackCA[] = L"RollbackAccount";
	const WCHAR wszSQL[] = L"SELECT `UserName`, `Password`, `Attributes` FROM `CustomUserAccounts`";
	const WCHAR wchSep = '\001';

	UINT uiStat = ERROR_SUCCESS;
	if (ERROR_SUCCESS != (uiStat = MsiDatabaseOpenViewW(hDatabase, wszSQL, &hView)))
	{
		if (ERROR_BAD_QUERY_SYNTAX == uiStat
			&& MSICONDITION_NONE == MsiDatabaseIsTablePersistentW(hDatabase, L"CustomUserAccounts"))
			return ERROR_SUCCESS; // table not present
		else
			return ERROR_INSTALL_FAILURE; // error -- should never happen
	}
	if (ERROR_SUCCESS != (uiStat = MsiViewExecute(hView, 0)))
		return ERROR_INSTALL_FAILURE; // error -- should never happen

	// Fetch all entries from the CustomUserAccounts table
	PMSIHANDLE hRecFetch = 0;
	while (ERROR_SUCCESS == (uiStat = MsiViewFetch(hView, &hRecFetch)))
	{
		// Obtain user name
		WCHAR* wszUser = 0;
		DWORD cchUser = 0;
		if (ERROR_MORE_DATA != MsiRecordGetStringW(hRecFetch, 1, L"", &cchUser))
			return ERROR_INSTALL_FAILURE;

		wszUser = new WCHAR[++cchUser];
		if ( !wszUser )
			return ERROR_INSTALL_FAILURE; // out of memory

		if (ERROR_SUCCESS != MsiRecordGetStringW(hRecFetch, 1, wszUser, &cchUser))
		{
			delete [] wszUser;
			return ERROR_INSTALL_FAILURE; // error -- should never happen
		}
		
		// Obtain name of property containing password
		WCHAR* wszPassWdProp = 0;
		DWORD cchPassWdProp = 0;
		if (ERROR_MORE_DATA != MsiRecordGetStringW(hRecFetch, 2, L"", &cchPassWdProp))
		{
			delete [] wszUser;
			return ERROR_INSTALL_FAILURE;
		}

		wszPassWdProp = new WCHAR[++cchPassWdProp];
		if ( !wszPassWdProp )
		{
			delete [] wszUser;
			return ERROR_INSTALL_FAILURE; // out of memory
		}

		if (ERROR_SUCCESS != MsiRecordGetStringW(hRecFetch, 2, wszPassWdProp, &cchPassWdProp))
		{
			delete [] wszUser;
			delete [] wszPassWdProp;
			return ERROR_INSTALL_FAILURE; // error -- should never happen
		}

		// Obtain property value containing password
		WCHAR* wszAccountPassWd = 0;
		DWORD cchAccountPassWd = 0;
		if (ERROR_MORE_DATA != MsiGetProperty(hInstall, wszPassWdProp, L"", &cchAccountPassWd))
		{
			delete [] wszUser;
			delete [] wszPassWdProp;
			return ERROR_INSTALL_FAILURE;
		}

		wszAccountPassWd = new WCHAR[++cchAccountPassWd];
		if ( !wszAccountPassWd )
		{
			delete [] wszUser;
			delete [] wszPassWdProp;
			return ERROR_INSTALL_FAILURE;
		}

		ZeroMemory(wszAccountPassWd, cchAccountPassWd*sizeof(WCHAR));

		if (ERROR_SUCCESS != MsiGetProperty(hInstall, wszPassWdProp, wszAccountPassWd, &cchAccountPassWd)
			|| *wszAccountPassWd == 0) // do not allow blank password
		{
			delete [] wszUser;
			delete [] wszPassWdProp;
			delete [] wszAccountPassWd;
			return ERROR_INSTALL_FAILURE;
		}
		
		// Obtain attributes of user account
		WCHAR* wszAttrib  = 0;
		DWORD cchAttrib = 0;
		if (ERROR_MORE_DATA != MsiRecordGetStringW(hRecFetch, 3, L"", &cchAttrib))
		{
			delete [] wszUser;
			delete [] wszPassWdProp;
			ClearSecret(wszAccountPassWd, cchAccountPassWd*sizeof(WCHAR));
			delete [] wszAccountPassWd;
			return ERROR_INSTALL_FAILURE;
		}

		wszAttrib = new WCHAR[++cchAttrib];
		if ( !wszAttrib )
		{
			delete [] wszUser;
			delete [] wszPassWdProp;
			ClearSecret(wszAccountPassWd, cchAccountPassWd*sizeof(WCHAR));
			delete [] wszAccountPassWd;
			return ERROR_INSTALL_FAILURE; // out of memory
		}

		if (ERROR_SUCCESS != MsiRecordGetStringW(hRecFetch, 3, wszAttrib, &cchAttrib))
		{
			delete [] wszUser;
			delete [] wszPassWdProp;
			ClearSecret(wszAccountPassWd, cchAccountPassWd*sizeof(WCHAR));
			delete [] wszAccountPassWd;
			delete [] wszAttrib;
			return ERROR_INSTALL_FAILURE; // error -- should never happen
		}

		// Generate the customized property that the deferred action will read
		DWORD cchBuf = cchUser + cchAccountPassWd + cchAttrib + 4;
		WCHAR* wszBuf = new WCHAR[cchBuf];
		if ( !wszBuf )
		{
			delete [] wszUser;
			delete [] wszPassWdProp;
			ClearSecret(wszAccountPassWd, cchAccountPassWd*sizeof(WCHAR));
			delete [] wszAccountPassWd;
			delete [] wszAttrib;
			return ERROR_INSTALL_FAILURE; // out of memory
		}

		wszBuf[0] = 0;

		if (FAILED(StringCchPrintfW(wszBuf, cchBuf, L"%s%c%s%c%s", wszUser, wchSep, wszAccountPassWd, wchSep, wszAttrib)))
		{
			delete [] wszUser;
			delete [] wszPassWdProp;
			ClearSecret(wszAccountPassWd, cchAccountPassWd*sizeof(WCHAR));
			delete [] wszAccountPassWd;
			delete [] wszAttrib;
			delete [] wszBuf;
			return ERROR_INSTALL_FAILURE;
		}

		// clear wszAccountPassWd
		ClearSecret(wszAccountPassWd, cchAccountPassWd*sizeof(WCHAR));


		// Add action data (template is in ActionText table), but do not display temp passwd
		PMSIHANDLE hRecInfo = MsiCreateRecord(2);
		if ( !hRecInfo 
            || ERROR_SUCCESS != MsiRecordSetStringW(hRecInfo, 1, wszUser)
			|| ERROR_SUCCESS != MsiRecordSetStringW(hRecInfo, 2, wszAttrib))
		{
			delete [] wszUser;
			delete [] wszPassWdProp;
			delete [] wszAccountPassWd;
			delete [] wszAttrib;
			ClearSecret(wszBuf, cchBuf*sizeof(WCHAR));
			delete [] wszBuf;
			return ERROR_INSTALL_FAILURE;
		}
		
		int iRet = MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRecInfo);
		if (IDCANCEL == iRet || IDABORT == iRet)
		{
			delete [] wszUser;
			delete [] wszPassWdProp;
			delete [] wszAccountPassWd;
			delete [] wszAttrib;
			ClearSecret(wszBuf, cchBuf*sizeof(WCHAR));
			delete [] wszBuf;
			return ERROR_INSTALL_USEREXIT;
		}

		// Rollback custom action goes first
		// Create a rollback custom action (in case install is stopped and rolls back)
		// Rollback custom action can't read tables, so we have to set a property
		if (ERROR_SUCCESS != MsiSetPropertyW(hInstall, wszRollbackCA, wszUser)
			|| ERROR_SUCCESS != MsiDoActionW(hInstall, wszRollbackCA)
			|| ERROR_SUCCESS != MsiSetPropertyW(hInstall, wszRollbackCA, L""))
		{
			delete [] wszUser;
			delete [] wszPassWdProp;
			delete [] wszAccountPassWd;
			delete [] wszAttrib;
			ClearSecret(wszBuf, cchBuf*sizeof(WCHAR));
			delete [] wszBuf;
			return ERROR_INSTALL_FAILURE;
		}

		// Create a deferred custom action (gives us the right priviledges to create the user account)
		// Deferred custom actions can't read tables, so we have to set a property
		if (ERROR_SUCCESS != MsiSetPropertyW(hInstall, wszCreateCA, wszBuf)
			|| ERROR_SUCCESS != MsiDoActionW(hInstall, wszCreateCA)
			|| ERROR_SUCCESS != MsiSetPropertyW(hInstall, wszCreateCA, L""))
		{
			delete [] wszUser;
			delete [] wszPassWdProp;
			delete [] wszAccountPassWd;
			delete [] wszAttrib;
			ClearSecret(wszBuf, cchBuf*sizeof(WCHAR));
			delete [] wszBuf;
			return ERROR_INSTALL_FAILURE;
		}


		ClearSecret(wszBuf, cchBuf*sizeof(WCHAR));
		delete [] wszBuf;
		delete [] wszUser;
		delete [] wszPassWdProp;
		delete [] wszAccountPassWd;
		delete [] wszAttrib;
	}
	return (ERROR_NO_MORE_ITEMS != uiStat) ? ERROR_INSTALL_FAILURE : ERROR_SUCCESS;
}

//////////////////////////////////////////////////////////////////////////
// UninstallUserAccounts (resides in process.dll)
//
//     Process the UserAccounts custom table generating deferred actions
//       to handle removal of user accounts
//
UINT __stdcall UninstallUserAccounts(MSIHANDLE hInstall)
{
	//
	// constants -- custom action name SQL query
	//
	// wszRemoveCA = name of deferred CA to remove user account
	//
	const WCHAR wszRemoveCA[] = L"RemoveAccount";
	const WCHAR wszSQL[] = L"SELECT `UserName` FROM `CustomUserAccounts`";

	PMSIHANDLE hDatabase = MsiGetActiveDatabase(hInstall);
	if ( !hDatabase )
		return ERROR_INSTALL_FAILURE;

	PMSIHANDLE hView = 0;

	UINT uiStat = ERROR_SUCCESS;
	if (ERROR_SUCCESS != (uiStat = MsiDatabaseOpenViewW(hDatabase, wszSQL, &hView)))
	{
		if (ERROR_BAD_QUERY_SYNTAX == uiStat 
			&& MSICONDITION_NONE == MsiDatabaseIsTablePersistentW(hDatabase, L"CustomUserAccounts"))
			return ERROR_SUCCESS; // table not present
		else
			return ERROR_INSTALL_FAILURE;
	}

	if (ERROR_SUCCESS != MsiViewExecute(hView, 0))
		return ERROR_INSTALL_FAILURE; // error -- should never happen

	// Fetch all entries from the UserAccounts custom table
	PMSIHANDLE hRecFetch = 0;
	while (ERROR_SUCCESS == (uiStat = MsiViewFetch(hView, &hRecFetch)))
	{
		// Obtain user name
		DWORD cchUser = 0;
		if (ERROR_MORE_DATA == MsiRecordGetStringW(hRecFetch, 1, L"", &cchUser))
		{
			WCHAR* wszUser = new WCHAR[++cchUser]; // add 1 for null-terminator which is not included in return count
			if (wszUser)
			{
				if (ERROR_SUCCESS == MsiRecordGetStringW(hRecFetch, 1, wszUser, &cchUser))
				{
					// Send ActionData message (template is in ActionText table)
					PMSIHANDLE hRecInfo = MsiCreateRecord(1);
					if ( !hRecInfo
						|| ERROR_SUCCESS != MsiRecordSetStringW(hRecInfo, 1, wszUser))
					{
						delete [] wszUser;
						return ERROR_INSTALL_FAILURE;
					}

					int iRet = MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRecInfo);
					if (IDCANCEL == iRet || IDABORT == iRet)
					{
						delete [] wszUser;
						return ERROR_INSTALL_USEREXIT;
					}

					// We can't do a rollback custom action here (well, we could, but it wouldn't be correct)
					// After a user account has been deleted, it cannot be recreated exactly as it was before
					// because it will have been assigned a new SID.  In the case of uninstall, we won't
					// rollback the deletion.

					// Create a deferred custom action (gives us the right priviledges to create the user account)
					// Deferred custom actions can't read tables, so we have to set a property
					if (ERROR_SUCCESS != MsiSetPropertyW(hInstall, wszRemoveCA, wszUser)
						|| ERROR_SUCCESS != MsiDoActionW(hInstall, wszRemoveCA)
						|| ERROR_SUCCESS != MsiSetPropertyW(hInstall, wszRemoveCA, L""))
					{
						delete [] wszUser;
						return ERROR_INSTALL_FAILURE;
					}
				}
				delete [] wszUser;
			}
			else
				return ERROR_INSTALL_FAILURE;
		}
		else
			return ERROR_INSTALL_FAILURE;
	}
	if (ERROR_NO_MORE_ITEMS != uiStat)
		return ERROR_INSTALL_FAILURE; // error -- should never happen

	return ERROR_SUCCESS;
}

#else // RC_INVOKED, end of source code, start of resources
// resource definition go here

#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\samples\remove.dll\sources.inc ===
TARGETNAME=remove

!INCLUDE ..\..\..\MsiMake.inc

!if "$(MSI_BROWSER_INFO)"=="1"
BROWSER_INFO=1
!endif

TARGETTYPE=DYNLINK

USE_LIBCMT=1

USE_NOLIBS=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\remove.def

INCLUDES=$(INC_DIR);$(SDK_INC_PATH);$(RES_OBJDIR)

TARGETLIBS=\
        $(SDK_LIB_PATH)\netapi32.lib \
		$(SDK_LIB_PATH)\user32.lib \
		$(SDK_LIB_PATH)\kernel32.lib \
        $(BUILD_DIR)\msi.lib

SOURCES=..\remove.cpp \
		..\remove.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\samples\testdb\sources.inc ===
TARGETNAME=testdb
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

NO_BINPLACE=1

UMTYPE=console
UMENTRY=Entry
UMENTRYABS=Entry

USE_NOLIBS=1

TARGETLIBS=\
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\msi.lib

C_DEFINES=$(C_DEFINES) -D_EXE

INCLUDES=$(INCLUDES);$(INC_DIR)

SOURCES=\
    ..\testdb.rc    \
    ..\testdb.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\samples\remove.dll\remove.cpp ===
#if 0  // makefile definitions
DESCRIPTION = RemoveUserAccount from Local Machine
MODULENAME = remove
FILEVERSION = Msi
ENTRY = RemoveUserAccount
UNICODE=1
LINKLIBS = netapi32.lib
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

// Required headers
#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>
#ifndef RC_INVOKED    // start of source code

#include "msiquery.h"
#include "msidefs.h"
#include <windows.h>
#include <basetsd.h>
#include <lm.h>

#define UNICODE 1

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, all rights reserved.
//
//  File: remove.cpp
//
//  Notes: DLL custom action, must be used in conjunction with the DLL
//         custom actions included in process.cpp and create.cpp
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//  - SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//      %vcbin%\nmake -f remove.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//      1. Create a new Win32 DLL project
//      2. Add remove.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib and netapi32.lib to the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//      5. Add /DUNICODE to the project options in the Project Settings dialog
//
//------------------------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////////////
// RemoveUserAccount
//
//     Attempts to remove a user account on the local machine according
//       to the "instructions" provided in the CustomActionData property
//
//     As a deferred custom action, you do not have access to the database.
//       The only source of information comes from a property that an immediate
//       custom action can set to provide the information you need.  This
//       property is written into the script
//
UINT __stdcall RemoveUserAccount(MSIHANDLE hInstall)
{
	// determine mode in which we are called
	BOOL bRollback = MsiGetMode(hInstall, MSIRUNMODE_ROLLBACK); // true for rollback, else regular deferred version (for uninstall)

	BOOL fSuccess = FALSE;

	// id's for error and warning messages
	const int iRemoveError = 25003;
	const int iRemoveWarning = 25004;

	// Grab the CustomActionData property
	DWORD cchCAData = 0;

	if (ERROR_MORE_DATA == MsiGetPropertyW(hInstall, IPROPNAME_CUSTOMACTIONDATA, L"", &cchCAData))
	{
		WCHAR* wszCAData = new WCHAR[++cchCAData]; // add 1 for null-terminator which is not included in size on return
		if (wszCAData)
		{
			if (ERROR_SUCCESS == MsiGetPropertyW(hInstall, IPROPNAME_CUSTOMACTIONDATA, wszCAData, &cchCAData))
			{
				// send ActionData message (template in ActionText table)
				// send ActionData message (template in ActionText table)
				PMSIHANDLE hRec = MsiCreateRecord(1);
				if (!hRec 
					|| ERROR_SUCCESS != MsiRecordSetStringW(hRec, 1, wszCAData))
				{
					delete [] wszCAData;
					return ERROR_INSTALL_FAILURE;
				}

				int iRet = MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRec);
				if (IDCANCEL == iRet || IDABORT == iRet)
				{
					delete [] wszCAData;
					return ERROR_INSTALL_USEREXIT;
				}

				//
				// Call the NetUserDel function, 
				//
				NET_API_STATUS nStatus = NetUserDel(NULL /*local machine*/, wszCAData /*user name*/);
				
				if (NERR_Success != nStatus)
				{
					PMSIHANDLE hRecErr = MsiCreateRecord(3);
					if ( !hRecErr 
						|| ERROR_SUCCESS != MsiRecordSetStringW(hRecErr, 2, wszCAData))
					{
						delete [] wszCAData;
						return ERROR_INSTALL_FAILURE;
					}

					// In rollback mode, NERR_UserNotFound means cancel button depressed in middle of deferred CA trying to create this account
					if (bRollback && NERR_UserNotFound == nStatus)
					{
						fSuccess = TRUE;
					}
					else if (NERR_UserNotFound == nStatus)
					{
						// treat this as a warning, but success since we are attempting to delete and it is not present
						if (ERROR_SUCCESS != MsiRecordSetInteger(hRecErr, 1, iRemoveWarning))
						{
							delete [] wszCAData;
							return ERROR_INSTALL_FAILURE;
						}

						// just pop up an OK button
						// OPTIONALLY, could specify multiple buttons and cancel
						// install based on user selection by handling the return value
						// from MsiProcessMessage, but here we are ignoring the MsiProcessMessage return
						MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_WARNING|MB_ICONWARNING|MB_OK), hRecErr);
						fSuccess = TRUE;
					}
					else
					{
						if (ERROR_SUCCESS == MsiRecordSetInteger(hRecErr, 1, iRemoveError)
							&& ERROR_SUCCESS == MsiRecordSetInteger(hRecErr, 3, nStatus))
						{
							// returning failure anyway, so ignoring MsiProcessMessage return
							MsiProcessMessage(hInstall, INSTALLMESSAGE_ERROR, hRecErr);
						}
					}
				}
				else // NERR_Success
				{
					fSuccess = TRUE;
				}
			}

			delete [] wszCAData;
		}
	}

	return fSuccess ? ERROR_SUCCESS : ERROR_INSTALL_FAILURE;
}


#else // RC_INVOKED, end of source code, start of resources
// resource definition go here

#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\samples\testdb\testdb.cpp ===
#include <windows.h>
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE

void Entry(){MessageBox(0, TEXT("This is testdb.exe"), TEXT("Test"), MB_OK);}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\samples\tutorial.dll\sources.inc ===
TARGETNAME=tutorial

!INCLUDE ..\..\..\MsiMake.inc

!if "$(MSI_BROWSER_INFO)"=="1"
BROWSER_INFO=1
!endif

TARGETTYPE=DYNLINK

USE_LIBCMT=1

USE_NOLIBS=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\tutorial.def

INCLUDES=$(SDK_INC_PATH);$(INC_DIR);$(RES_OBJDIR)

TARGETLIBS=\
		$(SDK_LIB_PATH)\user32.lib \
		$(SDK_LIB_PATH)\kernel32.lib \
		$(SDK_LIB_PATH)\shell32.lib \
        $(BUILD_DIR)\msi.lib

SOURCES=..\tutorial.cpp \
		..\tutorial.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\samples\tutorial.dll\tutorial.cpp ===
#if 0  // makefile definitions
DESCRIPTION = LaunchTutorial custom action sample
MODULENAME = tutorial
FILEVERSION = Msi
LINKLIBS = shell32.lib
ENTRY = LaunchTutorial
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

// Required headers
#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>
#ifndef RC_INVOKED    // start of source code

#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#include <shellapi.h>
#include "msiquery.h"
#include "strsafe.h"

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, All rights reserved.
//
//  File:       tutorial.cpp
//
//  Purpose: DLL custom action sample code to demonstrate how to launch an
//           installed file at the end of setup
//
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f tutorial.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 DLL project
//      2. Add tutorial.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib to the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//
//------------------------------------------------------------------------------------------


//////////////////////////////////////////////////////////////////////////////
// LaunchTutorial
//
// Launches a installed file at the end of setup
//
UINT __stdcall LaunchTutorial(MSIHANDLE hInstall)
{
	BOOL fSuccess = FALSE;

	// szTutorialFileKey is the primary key of the file in the
	// File table that identifies the file we wish to launch
	const TCHAR szTutorialFileKey[] = TEXT("[#Tutorial]");

	PMSIHANDLE hRecTutorial = MsiCreateRecord(1);

	if ( !hRecTutorial
		|| ERROR_SUCCESS != MsiRecordSetString(hRecTutorial, 0, szTutorialFileKey))
		return ERROR_INSTALL_FAILURE;

	// determine buffer size
	DWORD cchPath = 0;
	if (ERROR_MORE_DATA == MsiFormatRecord(hInstall, hRecTutorial, TEXT(""), &cchPath))
	{
		// add 1 to cchPath since return count from MsiFormatRecord does not include terminating null
		TCHAR* szPath = new TCHAR[++cchPath];
		if (szPath)
		{
			if (ERROR_SUCCESS == MsiFormatRecord(hInstall, hRecTutorial, szPath, &cchPath))
			{
				// ensure quoted path to ShellExecute
				DWORD cchQuotedPath = lstrlen(szPath) + 1 + 2; // szPath + null terminator + enclosing quotes
				TCHAR* szQuotedPath = new TCHAR[cchQuotedPath];
				if (szQuotedPath
					&& SUCCEEDED(StringCchCopy(szQuotedPath, cchQuotedPath, TEXT("\"")))
					&& SUCCEEDED(StringCchCat(szQuotedPath, cchQuotedPath, szPath))
					&& SUCCEEDED(StringCchCat(szQuotedPath, cchQuotedPath, TEXT("\""))))
				{
					// set up ShellExecute structure
					// file is the full path to the installed file
					SHELLEXECUTEINFO sei;
					ZeroMemory(&sei, sizeof(SHELLEXECUTEINFO));
					sei.fMask = SEE_MASK_FLAG_NO_UI; // don't show error UI, we'll just silently fail
					sei.hwnd = 0;
					sei.lpVerb = NULL; // use default verb, typically open
					sei.lpFile = szQuotedPath;
					sei.lpParameters = NULL;
					sei.lpDirectory = NULL;
					sei.nShow = SW_SHOWNORMAL;
					sei.cbSize = sizeof(sei);

					// spawn the browser to display HTML tutorial
					fSuccess = ShellExecuteEx(&sei);

					delete [] szQuotedPath;
				}
			}
			delete [] szPath;
		}
	}

	return (fSuccess) ? ERROR_SUCCESS : ERROR_INSTALL_FAILURE;
}

#else // RC_INVOKED, end of source code, start of resources
// resource definition go here

#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\tools\inc\corerror.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*********************************************************************
 **                                                                 **
 ** CorError.h - lists the HResults used by the .NET Framework's    **
 **              Common Language Runtime.                           **
 ** Created: September 3, 1999.                                     **
 **                                                                 **
 *********************************************************************/


#ifndef __COMMON_LANGUAGE_RUNTIME_HRESULTS__
#define __COMMON_LANGUAGE_RUNTIME_HRESULTS__

/*********************************************************************

  We use the Univeral Runtime's facility code (0x13).  See URTError.h 
  for the details on how HResults are broken up throughout the .Net
  Development Platform

  For the Common Language Runtime (the .Net Development Platform's 
  back-end), we've been given the range 0x1yyy for now.  That range 
  was further divided for different groups within the runtime:

  0x10yy for Execution Engine errors
  0x11yy for Metadata, TypeLib Export, and CLDB errors
  0x12yy for MD Validator
  0x13yy for Debugger and Profiler errors
  0x14yy for Security errors
  0x15yy for Classlib errors (BCL only)
  0x16yy for more Classlib errors (BCL only)
  0x17yy for shim errors
  0x18yy for Verifier errors
  0x19yy for Framework
  0x1Ayy for Framework
  0x1Byy for MD Validator
  0x30yy for VSA errors

*********************************************************************/

#include <winerror.h>

#ifndef FACILITY_URT
#define FACILITY_URT            0x13
#endif

#ifndef EMAKEHR
#define SMAKEHR(val)            MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_URT, val)
#define EMAKEHR(val)            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_URT, val)
#endif


// ******************
// FACILITY_UTF
// ******************


// ******************
// Metadata errors
// ******************

//**** ICeeFileGen errors.
#define CEE_E_ENTRYPOINT                EMAKEHR(0x1000)     // The entry point info is invalid.
#define CEE_E_CVTRES_NOT_FOUND          EMAKEHR(0x1001)     // cannot find cvtres.exe

//**** EE errors
#define MSEE_E_LOADLIBFAILED            EMAKEHR(0x1010)     // Failed to delay load library %s (Win32 error: %d).
#define MSEE_E_GETPROCFAILED            EMAKEHR(0x1011)     // Failed to get entry point %s (Win32 error: %d).
#define MSEE_E_MULTCOPIESLOADED         EMAKEHR(0x1012)     // Multiple copies of MSCOREE.dll have been loaded by the same process.
// the following two are COR to match the name used in the library
#define COR_E_APPDOMAINUNLOADED         EMAKEHR(0x1014)     // access unloaded appdomain
#define COR_E_CANNOTUNLOADAPPDOMAIN     EMAKEHR(0x1015)     // Error while unloading an appdomain
#define MSEE_E_ASSEMBLYLOADINPROGRESS   EMAKEHR(0x1016)     // Assembly is being currently being loaded
#define MSEE_E_CANNOTCREATEAPPDOMAIN    EMAKEHR(0x1017)     // Attempt to create appdomain failed
#define COR_E_FIXUPSINEXE					EMAKEHR(0x1019)		// Attempt to load an unverifiable exe with fixups (IAT with more than 2 sections or a TLS section)

//**** Assembly Cache errors
#define COR_E_MODULE_HASH_CHECK_FAILED EMAKEHR(0x1039)      // The check of the module's hash failed.
#define FUSION_E_REF_DEF_MISMATCH       EMAKEHR(0x1040)     // The located assembly's manifest definition does not match the assembly reference.
#define FUSION_E_INVALID_PRIVATE_ASM_LOCATION EMAKEHR(0x1041) // The private assembly was located outside the appbase directory.
#define FUSION_E_ASM_MODULE_MISSING     EMAKEHR(0x1042)     // A module specified in the manifest was not found.
#define FUSION_E_UNEXPECTED_MODULE_FOUND EMAKEHR(0x1043)    // Modules which are not in the manifest were streamed in.
#define FUSION_E_PRIVATE_ASM_DISALLOWED EMAKEHR(0x1044)     // A strongly-named assembly is required.
#define FUSION_E_SIGNATURE_CHECK_FAILED EMAKEHR(0x1045)     // The check of the signature failed.
#define FUSION_E_DATABASE_ERROR         EMAKEHR(0x1046)     // An unexpected error was encountered in the Assembly Cache database.
#define FUSION_E_INVALID_NAME           EMAKEHR(0x1047)     // The given assembly name or codebase was invalid.



//=============================================================================
// THE VALIDATOR IS CURRENTLY USING ERROR CODES STARTING WITH 0x1050 ONWARDS.
// LOOK AT ERROR CODES STARTING FROM VLDTR_E_AS_NAMENULL.  JUST A NOTE IN CASE
// THE EE EVER COMES TO THE POINT OF NEEDING THOSE!!!
//=============================================================================

//**** Generic errors.
#define CLDB_E_FILE_BADREAD             EMAKEHR(0x1100)     // Error occured during a read.
#define CLDB_E_FILE_BADWRITE            EMAKEHR(0x1101)     // Error occured during a write.
#define CLDB_E_FILE_READONLY            EMAKEHR(0x1103)     // File is read only.
#define CLDB_E_NAME_ERROR               EMAKEHR(0x1105)     // An ill-formed name was given.
#define CLDB_S_TRUNCATION               SMAKEHR(0x1106)     // STATUS: Data value was truncated.
#define CLDB_E_TRUNCATION               EMAKEHR(0x1106)     // ERROR:  Data value was truncated.
#define CLDB_E_FILE_OLDVER              EMAKEHR(0x1107)     // Old version error.
#define CLDB_E_RELOCATED                EMAKEHR(0x1108)     // A shared mem open failed to open at the originally
                                                    //  assigned memory address.
#define CLDB_S_NULL                     SMAKEHR(0x1109)     // NULL data value.
#define CLDB_E_SMDUPLICATE              EMAKEHR(0x110A)     // Create of shared memory failed.  A memory mapping of the same name already exists.
#define CLDB_E_NO_DATA                  EMAKEHR(0x110B)     // There isn't .CLB data in the memory or stream.
#define CLDB_E_READONLY                 EMAKEHR(0x110C)     // Database is read only.
#define CLDB_E_INCOMPATIBLE             EMAKEHR(0x110D)     // The importing scope is not comptabile with the emitting scope

//**** Schema errors.
#define CLDB_E_FILE_CORRUPT             EMAKEHR(0x110E)     // File is corrupt.
#define CLDB_E_SCHEMA_VERNOTFOUND       EMAKEHR(0x110F)   // Version %d of schema '%s' not found.
#define CLDB_E_BADUPDATEMODE            EMAKEHR(0x1110)     // cannot open a incrementally build scope for full update

//**** Index errors.
#define CLDB_E_INDEX_NONULLKEYS         EMAKEHR(0x1121)     // Null value not allowed in unique index or primary key.
#define CLDB_E_INDEX_DUPLICATE          EMAKEHR(0x1122)     // Unique index %s has been violated.
#define CLDB_E_INDEX_BADTYPE            EMAKEHR(0x1123)     // The columns data type is not allowed in an index.
#define CLDB_E_INDEX_NOTFOUND           EMAKEHR(0x1124)     // Index %s not found.
#define CLDB_S_INDEX_TABLESCANREQUIRED  SMAKEHR(0x1125) // Table scan required to run query.

//**** Record errors.
#define CLDB_E_RECORD_NOTFOUND          EMAKEHR(0x1130)     // Record wasn't found on lookup.
#define CLDB_E_RECORD_OVERFLOW          EMAKEHR(0x1131)     // Too many records were returned for criteria.
#define CLDB_E_RECORD_DUPLICATE         EMAKEHR(0x1132)     // Record is a duplicate.
#define CLDB_E_RECORD_PKREQUIRED        EMAKEHR(0x1133)    // Primary key value is required.
#define CLDB_E_RECORD_DELETED           EMAKEHR(0x1134)     // Record is valid but deleted.
#define CLDB_E_RECORD_OUTOFORDER        EMAKEHR(0x1135)    // Record is emitted out of order.

//**** Column errors.
#define CLDB_E_COLUMN_OVERFLOW          EMAKEHR(0x1140)     // Data too large.
#define CLDB_E_COLUMN_READONLY          EMAKEHR(0x1141)     // Column cannot be changed.
#define CLDB_E_COLUMN_SPECIALCOL        EMAKEHR(0x1142)    // Too many RID or primary key columns, 1 is max.
#define CLDB_E_COLUMN_PKNONULLS         EMAKEHR(0x1143)     // Primary key column %s may not allow the null value.

//**** Table errors.
#define CLDB_E_TABLE_CANTDROP           EMAKEHR(0x1150)     // Can't auto-drop table while open.

//**** Object errors.
#define CLDB_E_OBJECT_NOTFOUND          EMAKEHR(0x1151)     // Object was not found in the database.
#define CLDB_E_OBJECT_COLNOTFOUND       EMAKEHR(0x1152)   // The column was not found.

//**** Vector errors.
#define CLDB_E_VECTOR_BADINDEX          EMAKEHR(0x1153)     // The index given was invalid.

//**** Heap errors;
#define CLDB_E_TOO_BIG                  EMAKEHR(0x1154)     // A blob or string was too big.

//**** IMeta* errors.

#define META_E_DUPLICATE                EMAKEHR(0x1180)     // Attempt to define an object that already exists.
#define META_E_GUID_REQUIRED            EMAKEHR(0x1181)     // A guid was not provided where one was required.
#define META_E_TYPEDEF_MISMATCH         EMAKEHR(0x1182)     // Merge: an import typedef matched ns.name, but not version and guid.
#define META_E_MERGE_COLLISION          EMAKEHR(0x1183)     // Merge: conflict between import and emit

#define META_E_METHD_NOT_FOUND          EMAKEHR(0x1187) // Merge: Class already in emit scope, but member not found
#define META_E_FIELD_NOT_FOUND          EMAKEHR(0x1188) // Merge: Class already in emit scope, but member not found
#define META_S_PARAM_MISMATCH           SMAKEHR(0x1189) // Merge: Parameter information mismatched.
#define META_E_PARAM_MISMATCH           EMAKEHR(0x1189) // Merge: Parameter information mismatched.
#define META_E_BADMETADATA              EMAKEHR(0x118A) // Merge: Inconsistency in meta data import scope
#define META_E_INTFCEIMPL_NOT_FOUND     EMAKEHR(0x118B) // Merge: Class already in emit scope, but interfaceimpl not found
#define META_E_CLASS_LAYOUT_INCONSISTENT EMAKEHR(0x118D) // Merge: Class is duplicated but class layout information is not consistent
#define META_E_FIELD_MARSHAL_NOT_FOUND  EMAKEHR(0x118E) // Merge: Field is duplicated but we cannot find the matching FieldMarshal information
#define META_E_METHODSEM_NOT_FOUND      EMAKEHR(0x118F) // Merge: 
#define META_E_EVENT_NOT_FOUND          EMAKEHR(0x1190) // Merge: Method is duplicated but we cannot find the matching event info.
#define META_E_PROP_NOT_FOUND           EMAKEHR(0x1191) // Merge: Method is duplicated but we cannot find the maching property info.
#define META_E_BAD_SIGNATURE            EMAKEHR(0x1192) // Bad binary signature
#define META_E_BAD_INPUT_PARAMETER      EMAKEHR(0x1193) // Bad input parameters
#define META_E_METHDIMPL_INCONSISTENT   EMAKEHR(0x1194) // Merge: duplicated methods have inconsistent ImplFlags
#define META_E_MD_INCONSISTENCY         EMAKEHR(0x1195) // Merge: Inconsistency in meta data

#define META_E_CANNOTRESOLVETYPEREF     EMAKEHR(0x1196) // Cannot resolve typeref
#define META_S_DUPLICATE                SMAKEHR(0x1197) // Attempt to define an object that already exists in valid scenerios.
#define META_E_STRINGSPACE_FULL         EMAKEHR(0x1198) // No logical space left to create more user strings.

#define META_E_UNEXPECTED_REMAP         EMAKEHR(0x1199) // A TokenRemap occurred which we weren't prepared to handle.

#define META_E_HAS_UNMARKALL            EMAKEHR(0x119A) // Unmark all has been called already
#define META_E_MUST_CALL_UNMARKALL      EMAKEHR(0x119B) // Must call UnmarkAll first before marking.

#define TLBX_E_CANT_LOAD_MODULE         EMAKEHR(0x11A0) // TypeLib export: can't open the module to export.
#define TLBX_E_CANT_LOAD_CLASS          EMAKEHR(0x11A1) // TypeLib export: can't load a class.  
#define TLBX_E_NULL_MODULE              EMAKEHR(0x11A2) // TypeLib export: the hMod of a loaded class is 0; can't export it.
#define TLBX_E_NO_CLSID_KEY             EMAKEHR(0x11A3) // TypeLib export: no CLSID or Interface subkey to HKCR.
#define TLBX_E_CIRCULAR_EXPORT          EMAKEHR(0x11A4) // TypeLib export: attempt to export a CLB imported from a TLB.
#define TLBX_E_CIRCULAR_IMPORT          EMAKEHR(0x11A5) // TypeLib import: attempt to import a TLB exported from a CLB.
#define TLBX_E_BAD_NATIVETYPE           EMAKEHR(0x11A6) // TypeLib export: bad Native type in method signature.
#define TLBX_E_BAD_VTABLE               EMAKEHR(0x11A7) // TypeLib import: non-increasing vtable (duplicate slots).
#define TLBX_E_CRM_NON_STATIC           EMAKEHR(0x11A8) // TypeLib export: the COM register method is non static.
#define TLBX_E_CRM_INVALID_SIG          EMAKEHR(0x11A9) // TypeLib export: the specified COM register method does not have the correct signature.
#define TLBX_E_CLASS_LOAD_EXCEPTION     EMAKEHR(0x11AA) // TypeLib export: can't load, have the class load exception.
#define TLBX_E_UNKNOWN_SIGNATURE        EMAKEHR(0x11AB) // TypeLib export: unknown element in signature.
#define TLBX_E_REFERENCED_TYPELIB       EMAKEHR(0x11AC) // TypeLib import: reference to an external typelib.
#define TLBX_S_REFERENCED_TYPELIB       SMAKEHR(0x11AC) // TypeLib import: reference to an external typelib.
#define TLBX_E_INVALID_NAMESPACE        EMAKEHR(0x11AD) // TypeLib import: an imported typelib has an invalid namespace name.
#define TLBX_E_LAYOUT_ERROR             EMAKEHR(0x11AE) // Typelib export: an error on Layout()
#define TLBX_E_NOTIUNKNOWN              EMAKEHR(0x11AF) // Typelib import: Interface not derived from IUnknown.
#define TLBX_E_NONVISIBLEVALUECLASS     EMAKEHR(0x11B0) // Typelib export: Non COM visible value type in method signature.
#define TLBX_E_LPTSTR_NOT_ALLOWED       EMAKEHR(0x11B1) // Typelib export: Types which contain the native type NATIVE_TYPE_LPTSTR are not allowed to be exported to COM.
#define TLBX_E_AUTO_CS_NOT_ALLOWED      EMAKEHR(0x11B2) // Typelib export: Types with a char set of auto are not allowed to be exported to COM.
#define TLBX_S_NOSTDINTERFACE           SMAKEHR(0x11B3) // Typelib export: Found an interface marked as IID_IDispatch or IID_IUnknown.
#define TLBX_S_DUPLICATE_DISPID         SMAKEHR(0x11B4) // Typelib export: duplicate dispid found; ignored.
#define TLBX_E_ENUM_VALUE_INVALID       EMAKEHR(0x11B5) // Typelib export: The enum value is not legal for a typelib.
#define TLBX_E_DUPLICATE_IID            EMAKEHR(0x11B6) // Typelib export: Duplicate IID
#define TLBX_E_NO_NESTED_ARRAYS         EMAKEHR(0x11B7) // Tyeplib export: detected nested arrays.
#define TLBX_E_PARAM_ERROR_NAMED        EMAKEHR(0x11B8) // Typelib import: param type couldn't be converted.
#define TLBX_E_PARAM_ERROR_UNNAMED      EMAKEHR(0x11B9) // Typelib import: param type couldn't be converted -- param name unknown.
#define TLBX_E_AGNOST_SIGNATURE         EMAKEHR(0x11BA) // TypeLib export: size agnostic element in signature.
#define TLBX_E_CONVERT_FAIL             EMAKEHR(0x11BB) // TypeLib export: exporter failed.
#define TLBX_W_DUAL_NOT_DISPATCH        EMAKEHR(0x11BC) // Typelib import: [dual] interface not derived from IDispatch.
#define TLBX_E_BAD_SIGNATURE            EMAKEHR(0x11BD) // Typelib export: unconvertable signature (use specific error for reporting!)
#define TLBX_E_ARRAY_NEEDS_NT_FIXED     EMAKEHR(0x11BE) // Typelib export: non-fixed array in struct
#define TLBX_E_CLASS_NEEDS_NT_INTF      EMAKEHR(0x11BF) // Typelib export: non-interface class in struct

#define TLBX_E_INVALID_TYPEINFO         EMAKEHR(0x1160) // Typelib import: invalid type, not converted.
#define TLBX_E_INVALID_TYPEINFO_UNNAMED EMAKEHR(0x1161) // Typelib import: invalid type, not converted -- name unknown.
#define TLBX_E_CTX_NESTED               EMAKEHR(0x1162) // Typelib export: Format string for nested contexts.
#define TLBX_E_ERROR_MESSAGE            EMAKEHR(0x1163) // Typelib export: Error message wrapper.
#define TLBX_E_CANT_SAVE                EMAKEHR(0x1164) // Typelib export: cant "SaveAllChanges()"
#define TLBX_W_LIBNOTREGISTERED         EMAKEHR(0x1165) // Typelib export: type library is not registered.
#define TLBX_E_CANTLOADLIBRARY          EMAKEHR(0x1166) // Typelib export: type library cannot be loaded.
#define TLBX_E_BAD_VT_TYPE              EMAKEHR(0x1167) // Typelib import: invalid VT_*, not converted.
#define TLBX_E_NO_MSCOREE_TLB           EMAKEHR(0x1168) // Typelib export: can't load mscoree.tlb
#define TLBX_E_BAD_MSCOREE_TLB          EMAKEHR(0x1169) // Typelib export: can't get a required typeinfo from mscoree.tlb.
#define TLBX_E_TLB_EXCEPTION            EMAKEHR(0x116a) // Typelib import: fault reading a typelib.
#define TLBX_E_MULTIPLE_LCIDS           EMAKEHR(0x116b) // Typelib import: Multiple LCID's parameters on a method.
#define TLBX_I_TYPEINFO_IMPORTED        SMAKEHR(0x116c) // Typelib import: progress report.
#define TLBX_E_AMBIGUOUS_RETURN         EMAKEHR(0x116d) // Typelib import: duplicate or ambiguous return types.
#define TLBX_E_DUPLICATE_TYPE_NAME      EMAKEHR(0x116e) // Typelib import: duplicate name (due to user-defined name).
#define TLBX_I_USEIUNKNOWN              SMAKEHR(0x116f) // Typelib export: substituted IUnknown for type.
#define TLBX_I_UNCONVERTABLE_ARGS       SMAKEHR(0x1170) // Typelib import: signature can't be converted (eg, struct**)
#define TLBX_I_UNCONVERTABLE_FIELD      SMAKEHR(0x1171) // Typelib import: signature can't be converted (eg, struct**)
#define TLBX_I_NONSEQUENTIALSTRUCT      EMAKEHR(0x1172) // Typelib export: Can't convert non-sequential structs.
#define TLBX_W_WARNING_MESSAGE          SMAKEHR(0x1173) // Typelib export: Warning message wrapper. 
#define TLBX_I_RESOLVEREFFAILED         EMAKEHR(0x1174) // Typelib import: The resolve ref call failed.
#define TLBX_E_ASANY                    EMAKEHR(0x1175) // Typelib export: Encounterd "AsAny" -- ignored.
#define TLBX_E_INVALIDLCIDPARAM         EMAKEHR(0x1176) // Typelib export: Encounterd an LCID attribute set to an invalid param.
#define TLBX_E_LCIDONDISPONLYITF        EMAKEHR(0x1177) // Typelib export: Encounterd an LCID attribute on a disp only interface.
#define TLBX_E_NONPUBLIC_FIELD          EMAKEHR(0x1178) // Typelib export: Non-public field in public struct.
#define TLBX_I_TYPE_EXPORTED            SMAKEHR(0x1179) // Typelib export: type exported
#define TLBX_I_DUPLICATE_DISPID         SMAKEHR(0x117A) // Typelib export: duplicate dispid -- auto corrected.
#define TLBX_E_BAD_NAMES                EMAKEHR(0x117B) // Typelib export: bad names list.
#define TLBX_I_REF_TYPE_AS_STRUCT       SMAKEHR(0x117C) // Typelib export: referenct tyep had layout, exported as struct.
                    
                    
#define META_E_CA_INVALID_TARGET        EMAKEHR(0x11C0) // Known custom attribute on invalid target.
#define META_E_CA_INVALID_VALUE         EMAKEHR(0x11C1) // Known custom attribute had invalid value.
#define META_E_CA_INVALID_BLOB          EMAKEHR(0x11C2) // Known custom attribute blob is bad format.
#define META_E_CA_REPEATED_ARG          EMAKEHR(0x11C3) // Known custom attribute blob has repeated named argument.
#define META_E_CA_UNKNOWN_ARGUMENT      EMAKEHR(0x11C4) // Known custom attrubte named arg not recognized.
#define META_E_CA_VARIANT_NYI           EMAKEHR(0x11C5) // Known attribute named argument doesn't support variant.
#define META_E_CA_ARRAY_NYI             EMAKEHR(0x11C6) // Known attribute named argument doesn't support array.
#define META_E_CA_UNEXPECTED_TYPE       EMAKEHR(0x11C7) // Known attribute parser found unexpected type.
#define META_E_CA_INVALID_ARGTYPE       EMAKEHR(0x11C8) // Known attribute parser only handles fields -- no properties.
#define META_E_CA_INVALID_ARG_FOR_TYPE  EMAKEHR(0x11C9) // Known attribute parser found an argument that is invalid for the object it is applied to.
#define META_E_CA_INVALID_UUID          EMAKEHR(0x11CA) // The format of the UUID was invalid.
#define META_E_CA_INVALID_MARSHALAS_FIELDS EMAKEHR(0x11CB) // The MarshalAs attribute has fields set that are not valid for the specified unmanaged type.
#define META_E_CA_NT_FIELDONLY          EMAKEHR(0x11CC) // The specified unmanaged type is only valid on fields.
#define META_E_CA_NEGATIVE_PARAMINDEX   EMAKEHR(0x11CD) // The parameter index cannot be negative.
#define META_E_CA_NEGATIVE_MULTIPLIER   EMAKEHR(0x11CE) // The multiplier cannot be negative.
#define META_E_CA_NEGATIVE_CONSTSIZE    EMAKEHR(0x11CF) // The constant size cannot be negative.
#define META_E_CA_FIXEDSTR_SIZE_REQUIRED EMAKEHR(0x11D0) // A fixed string requires a size.
#define META_E_CA_CUSTMARSH_TYPE_REQUIRED EMAKEHR(0x11D1) // A custom marshaler requires the custom marshaler type.
#define META_E_CA_FILENAME_REQUIRED     EMAKEHR(0x11d2) // A DllImport attribute requires a filename.

// Return values from validator functions.
#define VLDTR_S_WRN                     SMAKEHR(0x1200) // Warnings found in the validator.
#define VLDTR_S_ERR                     SMAKEHR(0x1201) // Errors found in the validator.
#define VLDTR_S_WRNERR                  SMAKEHR(0x1202) // Warnings and errors found in the validator.

// Validator structural errors.                 
#define VLDTR_E_RID_OUTOFRANGE          EMAKEHR(0x1203) // Rid is out of range.
#define VLDTR_E_CDTKN_OUTOFRANGE        EMAKEHR(0x1204) // Coded token type is out of range.
#define VLDTR_E_CDRID_OUTOFRANGE        EMAKEHR(0x1205) // Coded rid is out of range.
#define VLDTR_E_STRING_INVALID          EMAKEHR(0x1206) // String offset is invalid.
#define VLDTR_E_GUID_INVALID            EMAKEHR(0x1207) // GUID offset is invalid.
#define VLDTR_E_BLOB_INVALID            EMAKEHR(0x1208) // Blob offset if invalid.

// Validator semantic errors.                   
#define VLDTR_E_MOD_MULTI               EMAKEHR(0x1209) // Multiple module records found.
#define VLDTR_E_MOD_NULLMVID            EMAKEHR(0x120A) // Module has null MVID.
#define VLDTR_E_TR_NAMENULL             EMAKEHR(0x120B) // TypeRef name is NULL.
#define VLDTR_E_TR_DUP                  EMAKEHR(0x120C) // TypeRef has a dup.
#define VLDTR_E_TD_NAMENULL             EMAKEHR(0x120D) // TypeDef name is NULL.
#define VLDTR_E_TD_DUPNAME              EMAKEHR(0x120E) // TypeDef has a dup based on name+namespace.
#define VLDTR_E_TD_DUPGUID              EMAKEHR(0x120F) // TypeDef has a dup based on GUID.
#define VLDTR_E_TD_NOTIFACEOBJEXTNULL   EMAKEHR(0x1210) // TypeDef that's not an Interface and not System.Object extends nil parent.
#define VLDTR_E_TD_OBJEXTENDSNONNULL    EMAKEHR(0x1211) // System.Object extends a non-nil parent.
#define VLDTR_E_TD_EXTENDSSEALED        EMAKEHR(0x1212) // TypeDef extends sealed class.
#define VLDTR_E_TD_DLTNORTSPCL          EMAKEHR(0x1213) // TypeDef is Deleted but not marked with RTSpecialName.
#define VLDTR_E_TD_RTSPCLNOTDLT         EMAKEHR(0x1214) // TypeDef is marked RTSpecialName, but is not a Deleted record.
#define VLDTR_E_MI_DECLPRIV             EMAKEHR(0x1215) // MethodImpl's Decl is private
#define VLDTR_E_AS_BADNAME              EMAKEHR(0x1216) // Assembly [Ref] name has path and/or extension.
#define VLDTR_E_FILE_SYSNAME            EMAKEHR(0x1217) // File has a system name (con, com, aux, etc.).
#define VLDTR_E_MI_BODYSTATIC           EMAKEHR(0x1218) // MethodImpl's body is static.
#define VLDTR_E_TD_IFACENOTABS          EMAKEHR(0x1219) // TypeDef is marked Interface but not Abstract.
#define VLDTR_E_TD_IFACEPARNOTNIL       EMAKEHR(0x121A) // TypeDef is marked Interface but parent is not Nil.
#define VLDTR_E_TD_IFACEGUIDNULL        EMAKEHR(0x121B) // TypeDef is marked Interface but GUID is NULL.
#define VLDTR_E_MI_DECLFINAL            EMAKEHR(0x121C) // TMethodImpl's Decl is final.
#define VLDTR_E_TD_VTNOTSEAL            EMAKEHR(0x121D) // TypeDef is marked ValueType but not marked Sealed.
#define VLDTR_E_PD_BADFLAGS             EMAKEHR(0x121E) // Param has extra bits in flags.
#define VLDTR_E_IFACE_DUP               EMAKEHR(0x121F) // InterfaceImpl has a dup.
#define VLDTR_E_MR_NAMENULL             EMAKEHR(0x1220) // MemberRef name is NULL.
#define VLDTR_E_MR_VTBLNAME             EMAKEHR(0x1221) // MemberRef has an invalid name, _VtblGap*.
#define VLDTR_E_MR_DELNAME              EMAKEHR(0x1222) // MemberRef has an invalid name, _Deleted*.
#define VLDTR_E_MR_PARNIL               EMAKEHR(0x1223) // MemberRef parent Nil in a PE file.
#define VLDTR_E_MR_BADCALLINGCONV       EMAKEHR(0x1224) // MemberRef has invalid calling convention.
#define VLDTR_E_MR_NOTVARARG            EMAKEHR(0x1225) // MemberRef has Method parent but calling convention is not VARARG.
#define VLDTR_E_MR_NAMEDIFF             EMAKEHR(0x1226) // MemberRef name different from parent MethodDef.
#define VLDTR_E_MR_SIGDIFF              EMAKEHR(0x1227) // MemberRef signature different from parent MethodDef.
#define VLDTR_E_MR_DUP                  EMAKEHR(0x1228) // MemberRef has a dup.
#define VLDTR_E_CL_TDAUTO               EMAKEHR(0x1229) // ClassLayout parent TypeDef is marked AutoLayout.
#define VLDTR_E_CL_BADPCKSZ             EMAKEHR(0x122A) // ClassLayout has bad PackingSize.
#define VLDTR_E_CL_DUP                  EMAKEHR(0x122B) // ClassLayout has dup.
#define VLDTR_E_FL_BADOFFSET            EMAKEHR(0x122C) // FieldLayout2 has bad offset.
#define VLDTR_E_FL_TDNIL                EMAKEHR(0x122D) // FieldLayout2 has field with nil parent.
#define VLDTR_E_FL_NOCL                 EMAKEHR(0x122E) // FieldLayout2 has no ClassLayout record.
#define VLDTR_E_FL_TDNOTEXPLCT          EMAKEHR(0x122F) // FieldLayout2 parent TypeDef is not marked with ExplicitLayout.
#define VLDTR_E_FL_FLDSTATIC            EMAKEHR(0x1230) // FieldLayout2 has field marked Static.
#define VLDTR_E_FL_DUP                  EMAKEHR(0x1231) // FieldLayout2 has a dup.
#define VLDTR_E_MODREF_NAMENULL         EMAKEHR(0x1232) // ModuleRef name is NULL.
#define VLDTR_E_MODREF_DUP              EMAKEHR(0x1233) // ModuleRef has a dup.
#define VLDTR_E_TR_BADSCOPE             EMAKEHR(0x1234) // TypeRef has a bad resolution scope.
#define VLDTR_E_TD_NESTEDNOENCL         EMAKEHR(0x1235) // TypeDef marked nested has no encloser.
#define VLDTR_E_TD_EXTTRRES             EMAKEHR(0x1236) // TypeDef extends a TypeRef which resolves to a TypeDef in the same module.
#define VLDTR_E_SIGNULL                 EMAKEHR(0x1237) // Signature specified is zero-sized.
#define VLDTR_E_SIGNODATA               EMAKEHR(0x1238) // Signature does not have enough data at specified byte.
#define VLDTR_E_MD_BADCALLINGCONV       EMAKEHR(0x1239) // Method signature has invalid calling convention.
#define VLDTR_E_MD_THISSTATIC           EMAKEHR(0x123A) // Method is marked static but has HASTHIS/EXPLICITTHIS set on the calling convention.
#define VLDTR_E_MD_NOTTHISNOTSTATIC     EMAKEHR(0x123B) // Method is not marked static but is not HASTHIS/EXPLICITTHIS.
#define VLDTR_E_MD_NOARGCNT             EMAKEHR(0x123C) // Method signature is missing the argument count.
#define VLDTR_E_SIG_MISSELTYPE          EMAKEHR(0x123D) // Signature missing element type.
#define VLDTR_E_SIG_MISSTKN             EMAKEHR(0x123E) // Signature missing token.
#define VLDTR_E_SIG_TKNBAD              EMAKEHR(0x123F) // Signature has bad token.
#define VLDTR_E_SIG_MISSFPTR            EMAKEHR(0x1240) // Signature is missing function pointer.
#define VLDTR_E_SIG_MISSFPTRARGCNT      EMAKEHR(0x1241) // Signature has function pointer missing argument count.
#define VLDTR_E_SIG_MISSRANK            EMAKEHR(0x1242) // Signature is missing rank specification.
#define VLDTR_E_SIG_MISSNSIZE           EMAKEHR(0x1243) // Signature is missing count of sized dimensions.
#define VLDTR_E_SIG_MISSSIZE            EMAKEHR(0x1244) // Signature is missing size of dimension.
#define VLDTR_E_SIG_MISSNLBND           EMAKEHR(0x1245) // Signature is missing count of lower bounds.
#define VLDTR_E_SIG_MISSLBND            EMAKEHR(0x1246) // Signature is missing a lower bound.
#define VLDTR_E_SIG_BADELTYPE           EMAKEHR(0x1247) // Signature has bad element type.
#define VLDTR_E_SIG_MISSVASIZE          EMAKEHR(0x1248) // Signature has value array missing size.
#define VLDTR_E_FD_BADCALLINGCONV       EMAKEHR(0x1249) // Field signature has invalid calling convention.
#define VLDTR_E_MD_NAMENULL             EMAKEHR(0x124A) // Method name is NULL.
#define VLDTR_E_MD_PARNIL               EMAKEHR(0x124B) // Method has parent NIL.
#define VLDTR_E_MD_DUP                  EMAKEHR(0x124C) // Method has dup.
#define VLDTR_E_FD_NAMENULL             EMAKEHR(0x124D) // Field name is NULL.
#define VLDTR_E_FD_PARNIL               EMAKEHR(0x124E) // Field parent is Nil.
#define VLDTR_E_FD_DUP                  EMAKEHR(0x124F) // Field has dup.
#define VLDTR_E_AS_MULTI                EMAKEHR(0x1250) // Multiple Assembly records found.
#define VLDTR_E_AS_NAMENULL             EMAKEHR(0x1251) // Assembly name is NULL.
#define VLDTR_E_SIG_TOKTYPEMISMATCH     EMAKEHR(0x1252) // E_T_VALUETYPE<class token> or E_T_CLASS<vtype token>.
#define VLDTR_E_CL_TDINTF               EMAKEHR(0x1253) // Class layout on an Interface.
#define VLDTR_E_ASOS_OSPLTFRMIDINVAL    EMAKEHR(0x1254) // AssemblyOS platform ID invalid.
#define VLDTR_E_AR_NAMENULL             EMAKEHR(0x1255) // AssemblyRef name is NULL.
#define VLDTR_E_TD_ENCLNOTNESTED        EMAKEHR(0x1256) // TypeDef not nested has encloser.
#define VLDTR_E_AROS_OSPLTFRMIDINVAL    EMAKEHR(0x1257) // AssemblyRefOS has invalid platform ID.
#define VLDTR_E_FILE_NAMENULL           EMAKEHR(0x1258) // File name is NULL.
#define VLDTR_E_CT_NAMENULL             EMAKEHR(0x1259) // ComType name is NULL.
#define VLDTR_E_TD_EXTENDSCHILD         EMAKEHR(0x125A) // TypeDef extends its own child.
#define VLDTR_E_MAR_NAMENULL            EMAKEHR(0x125B) // ManifestResource name is NULL.
#define VLDTR_E_FILE_DUP                EMAKEHR(0x125C) // File has dup.
#define VLDTR_E_FILE_NAMEFULLQLFD       EMAKEHR(0x125D) // File name is fully qualified.
#define VLDTR_E_CT_DUP                  EMAKEHR(0x125E) // ComType has dup.
#define VLDTR_E_MAR_DUP                 EMAKEHR(0x125F) // ManifestResource has dup.
#define VLDTR_E_MAR_NOTPUBPRIV          EMAKEHR(0x1260) // ManifestResource is neither Public not Private.
#define VLDTR_E_TD_ENUMNOVALUE          EMAKEHR(0x1261) // Enum has no "value__" field.
#define VLDTR_E_TD_ENUMVALSTATIC        EMAKEHR(0x1262) // Enum's "value__" field is static.
#define VLDTR_E_TD_ENUMVALNOTSN         EMAKEHR(0x1263) // Enum's "value__" field is not SpecialName.
#define VLDTR_E_TD_ENUMFLDNOTST         EMAKEHR(0x1264) // Enum's field is not static.
#define VLDTR_E_TD_ENUMFLDNOTLIT        EMAKEHR(0x1265) // Enum's field is not literal.
#define VLDTR_E_TD_ENUMNOLITFLDS        EMAKEHR(0x1266) // Enum has no literal fields.
#define VLDTR_E_TD_ENUMFLDSIGMISMATCH   EMAKEHR(0x1267) // Enum's field sig does not match value__ sig.
#define VLDTR_E_TD_ENUMVALNOT1ST        EMAKEHR(0x1268) // Enum's "value__" field is not first.
#define VLDTR_E_FD_NOTVALUERTSN         EMAKEHR(0x1269) // Field is RTSpecialName but name is not "value__".
#define VLDTR_E_FD_VALUEPARNOTENUM      EMAKEHR(0x126A) // Field "value__" in not Enum class.
#define VLDTR_E_FD_INSTINIFACE          EMAKEHR(0x126B) // Instance field in interface.
#define VLDTR_E_FD_NOTPUBINIFACE        EMAKEHR(0x126C) // Non-public field in interface.
#define VLDTR_E_FMD_GLOBALNOTPUBPRIVSC  EMAKEHR(0x126D) // Global field/method neither Public nor PrivateScope.
#define VLDTR_E_FMD_GLOBALNOTSTATIC     EMAKEHR(0x126E) // Global field/method not static.
#define VLDTR_E_FD_GLOBALNORVA          EMAKEHR(0x126F) // Global field has no RVA.
#define VLDTR_E_MD_CTORZERORVA          EMAKEHR(0x1270) // .ctor,.cctor has zero RVA.
#define VLDTR_E_FD_MARKEDNOMARSHAL      EMAKEHR(0x1271) // Field is marked marshaled but has no marshaling rec.
#define VLDTR_E_FD_MARSHALNOTMARKED     EMAKEHR(0x1272) // Field has marshaling rec but is not marked marshaled.
#define VLDTR_E_FD_MARKEDNODEFLT        EMAKEHR(0x1273) // Field is marked HasDefault but has no const value.
#define VLDTR_E_FD_DEFLTNOTMARKED       EMAKEHR(0x1274) // Field has const value rec but is not marked HasDefault.
#define VLDTR_E_FMD_MARKEDNOSECUR       EMAKEHR(0x1275) // Field/method is marked HasSecurity but has no security rec.
#define VLDTR_E_FMD_SECURNOTMARKED      EMAKEHR(0x1276) // Field/method has security rec but is not marked HasSecurity.
#define VLDTR_E_FMD_PINVOKENOTSTATIC    EMAKEHR(0x1277) // Field/method is PInvoke but is not marked Static.
#define VLDTR_E_FMD_MARKEDNOPINVOKE     EMAKEHR(0x1278) // Field/method is marked PInvoke but has no ImplMap.
#define VLDTR_E_FMD_PINVOKENOTMARKED    EMAKEHR(0x1279) // Field/method has ImplMap but is not marked PInvoke.
#define VLDTR_E_FMD_BADIMPLMAP          EMAKEHR(0x127A) // Field/method has invalid ImplMap
#define VLDTR_E_IMAP_BADMODREF          EMAKEHR(0x127B) // ImplMap has invalid ModuleRef
#define VLDTR_E_IMAP_BADMEMBER          EMAKEHR(0x127C) // ImplMap has invalid MemberForwarded
#define VLDTR_E_IMAP_BADIMPORTNAME      EMAKEHR(0x127D) // ImplMap has invalid ImportName
#define VLDTR_E_IMAP_BADCALLCONV        EMAKEHR(0x127E) // ImplMap has invalid call conv
#define VLDTR_E_FMD_BADACCESSFLAG       EMAKEHR(0x127F) // Field/method has invalid access flag
#define VLDTR_E_FD_INITONLYANDLITERAL   EMAKEHR(0x1280) // Field is InitOnly and Literal
#define VLDTR_E_FD_LITERALNOTSTATIC     EMAKEHR(0x1281) // Field is Literal but not Static
#define VLDTR_E_FMD_RTSNNOTSN           EMAKEHR(0x1282) // Field/method is RTSpec.Name but not Spec.Name
#define VLDTR_E_MD_ABSTPARNOTABST       EMAKEHR(0x1283) // Method is abstract, parent is not
#define VLDTR_E_MD_NOTSTATABSTININTF    EMAKEHR(0x1284) // Method not static or abstract in interface
#define VLDTR_E_MD_NOTPUBININTF         EMAKEHR(0x1285) // Method not public in interface
#define VLDTR_E_MD_CTORININTF           EMAKEHR(0x1286) // ctor in interface
#define VLDTR_E_MD_GLOBALCTORCCTOR      EMAKEHR(0x1287) // global ctor or cctor
#define VLDTR_E_MD_CTORSTATIC           EMAKEHR(0x1288) // static ctor
#define VLDTR_E_MD_CTORNOTSNRTSN        EMAKEHR(0x1289) // ctor,cctor not marked SpecialName,RTSpecialName
#define VLDTR_E_MD_CTORVIRT             EMAKEHR(0x128A) // virtual ctor,cctor
#define VLDTR_E_MD_CTORABST             EMAKEHR(0x128B) // abstract ctor,cctor
#define VLDTR_E_MD_CCTORNOTSTATIC       EMAKEHR(0x128C) // instance cctor
#define VLDTR_E_MD_ZERORVA              EMAKEHR(0x128D) // RVA=0, method not abstract or pinvoke or runtime, or reverse
#define VLDTR_E_MD_FINNOTVIRT           EMAKEHR(0x128E) // Method is final and not virtual
#define VLDTR_E_MD_STATANDFINORVIRT     EMAKEHR(0x128F) // Method is static and final or virtual
#define VLDTR_E_MD_ABSTANDFINAL         EMAKEHR(0x1290) // Method is abstract and final
#define VLDTR_E_MD_ABSTANDIMPL          EMAKEHR(0x1291) // Method is abstract and implemented
#define VLDTR_E_MD_ABSTANDPINVOKE       EMAKEHR(0x1292) // Method is abstract and pinvoke
#define VLDTR_E_MD_ABSTNOTVIRT          EMAKEHR(0x1293) // Method is abstract and not virtual
#define VLDTR_E_MD_NOTABSTNOTIMPL       EMAKEHR(0x1294) // Method is not abstract and not implemented
#define VLDTR_E_MD_NOTABSTBADFLAGSRVA   EMAKEHR(0x1295) // Method is not abstract and not (RVA!=0 or pinvoke or runtime)
#define VLDTR_E_MD_PRIVSCOPENORVA       EMAKEHR(0x1296) // Method is PrivateScope and has RVA==0
#define VLDTR_E_MD_GLOBALABSTORVIRT     EMAKEHR(0x1297) // Global method is abstract or virtual
#define VLDTR_E_SIG_LONGFORM            EMAKEHR(0x1298) // Signature uses long form
#define VLDTR_E_MD_MULTIPLESEMANTICS    EMAKEHR(0x1299) // Method has multiple semantics (warning)
#define VLDTR_E_MD_INVALIDSEMANTICS     EMAKEHR(0x129A) // Method has invalid semantics (not event or prop)
#define VLDTR_E_MD_SEMANTICSNOTEXIST    EMAKEHR(0x129B) // Method has semantics assoc that does not exist
#define VLDTR_E_MI_DECLNOTVIRT          EMAKEHR(0x129C) // MethodImpl's Decl is not virtual
#define VLDTR_E_FMD_GLOBALITEM          EMAKEHR(0x129D) // Global field/method (warning,CLS)
#define VLDTR_E_MD_MULTSEMANTICFLAGS    EMAKEHR(0x129E) // Method has multiple semantic flags set
#define VLDTR_E_MD_NOSEMANTICFLAGS      EMAKEHR(0x129F) // Method has no semantic flags set
#define VLDTR_E_FD_FLDINIFACE           EMAKEHR(0x12A0) // Field in Interface (warning, CLS)
#define VLDTR_E_AS_HASHALGID            EMAKEHR(0x12A1) // Unrecognized Hash Alg ID (warning)
#define VLDTR_E_AS_PROCID               EMAKEHR(0x12A2) // Unrecognized Processor ID in Assembly(warning)
#define VLDTR_E_AR_PROCID               EMAKEHR(0x12A3) // Unrecognized Processor ID in AssemblyRef(warning)
#define VLDTR_E_CN_PARENTRANGE          EMAKEHR(0x12A4) // Constant: parent token out of range
#define VLDTR_E_AS_BADFLAGS             EMAKEHR(0x12A5) // Invalid flags in Assembly
#define VLDTR_E_TR_HASTYPEDEF           EMAKEHR(0x12A6) // There is TypeDef with same name as TypeRef (warning)
#define VLDTR_E_IFACE_BADIMPL           EMAKEHR(0x12A7) // In InterfaceImpl, the implementing token is not TypeDef
#define VLDTR_E_IFACE_BADIFACE          EMAKEHR(0x12A8) // In InterfaceImpl, the implemented token is not TypeDef or TypeRef
#define VLDTR_E_TD_SECURNOTMARKED       EMAKEHR(0x12A9) // TypeDef has security rec but not marked HasSecurity
#define VLDTR_E_TD_MARKEDNOSECUR        EMAKEHR(0x12AA) // TypeDef marked HasSecurity but has no security rec
#define VLDTR_E_MD_CCTORHASARGS         EMAKEHR(0x12AB) // .cctor has arguments
#define VLDTR_E_CT_BADIMPL              EMAKEHR(0x12AC) // COMType has invalid Implementation
#define VLDTR_E_MI_ALIENBODY            EMAKEHR(0x12AD) // MethodImpl has body from other class
#define VLDTR_E_MD_CCTORCALLCONV        EMAKEHR(0x12AE) // .cctor has invalid calling convention
#define VLDTR_E_MI_BADCLASS             EMAKEHR(0x12AF) // MethodImpl has invalid Class token
#define VLDTR_E_MI_CLASSISINTF          EMAKEHR(0x12B0) // MethodImpl declared in Interface
#define VLDTR_E_MI_BADDECL              EMAKEHR(0x12B1) // MethodImpl has invalid MethodDeclaration token
#define VLDTR_E_MI_BADBODY              EMAKEHR(0x12B2) // MethodImpl has invalid MethodBody token
#define VLDTR_E_MI_DUP                  EMAKEHR(0x12B3) // MethodImpl has duplicate
#define VLDTR_E_FD_BADPARENT            EMAKEHR(0x12B4) // Bad field parent
#define VLDTR_E_MD_PARAMOUTOFSEQ        EMAKEHR(0x12B5) // Param out of sequence (warning)
#define VLDTR_E_MD_PARASEQTOOBIG        EMAKEHR(0x12B6) // Param's sequence num exceeds num of args
#define VLDTR_E_MD_PARMMARKEDNOMARSHAL  EMAKEHR(0x12B7) // Param marked HasMarshal, has no marshaling info
#define VLDTR_E_MD_PARMMARSHALNOTMARKED EMAKEHR(0x12B8) // Param has marshaling info, not marked HasMarshal
#define VLDTR_E_MD_PARMMARKEDNODEFLT    EMAKEHR(0x12BA) // Param marked HasDefault, has no const value
#define VLDTR_E_MD_PARMDEFLTNOTMARKED   EMAKEHR(0x12BB) // Param has const value, not marked HasDefault
#define VLDTR_E_PR_BADSCOPE             EMAKEHR(0x12BC) // Prop has invalid scope
#define VLDTR_E_PR_NONAME               EMAKEHR(0x12BD) // Prop has no name
#define VLDTR_E_PR_NOSIG                EMAKEHR(0x12BE) // Prop has no signature
#define VLDTR_E_PR_DUP                  EMAKEHR(0x12BF) // Prop has a duplicate
#define VLDTR_E_PR_BADCALLINGCONV       EMAKEHR(0x12C0) // Prop has bad calling convention
#define VLDTR_E_PR_MARKEDNODEFLT        EMAKEHR(0x12C1) // Prop marked HasDefault, has no const value
#define VLDTR_E_PR_DEFLTNOTMARKED       EMAKEHR(0x12C2) // Prop has const value, not marked HasDefault
#define VLDTR_E_PR_BADSEMANTICS         EMAKEHR(0x12C3) // Prop has method not (Setter,Getter, or Other)
#define VLDTR_E_PR_BADMETHOD            EMAKEHR(0x12C4) // Prop has method with invalid token
#define VLDTR_E_PR_ALIENMETHOD          EMAKEHR(0x12C5) // Prop has method from another class
#define VLDTR_E_CN_BLOBNOTNULL          EMAKEHR(0x12C6) // Const has non-null blob when it should not
#define VLDTR_E_CN_BLOBNULL             EMAKEHR(0x12C7) // Const has null value blob
#define VLDTR_E_EV_BADSCOPE             EMAKEHR(0x12C8) // Event has invalid scope
#define VLDTR_E_EV_NONAME               EMAKEHR(0x12CA) // Event has no name
#define VLDTR_E_EV_DUP                  EMAKEHR(0x12CB) // Event has a duplicate
#define VLDTR_E_EV_BADEVTYPE            EMAKEHR(0x12CC) // Event has invalid EventType
#define VLDTR_E_EV_EVTYPENOTCLASS       EMAKEHR(0x12CD) // Event's EventType is not a class
#define VLDTR_E_EV_BADSEMANTICS         EMAKEHR(0x12CE) // Event has method not (AddOn,RemoveOn,Fire,Other)
#define VLDTR_E_EV_BADMETHOD            EMAKEHR(0x12CF) // Event has method with invalid token
#define VLDTR_E_EV_ALIENMETHOD          EMAKEHR(0x12D0) // Event has method from another class
#define VLDTR_E_EV_NOADDON              EMAKEHR(0x12D1) // Event has no AddOn method
#define VLDTR_E_EV_NOREMOVEON           EMAKEHR(0x12D2) // Event has no RemoveOn method
#define VLDTR_E_CT_DUPTDNAME            EMAKEHR(0x12D3) // ExportedType has same name as TypeDef
#define VLDTR_E_MAR_BADOFFSET           EMAKEHR(0x12D4) // MRes refers to non-PE file with offset !=0
#define VLDTR_E_DS_BADOWNER             EMAKEHR(0x12D5) // Decl.security has invalid owner token
#define VLDTR_E_DS_BADFLAGS             EMAKEHR(0x12D6) // Decl.security has invalid action flags
#define VLDTR_E_DS_NOBLOB               EMAKEHR(0x12D7) // Decl.security has no permission blob
#define VLDTR_E_MAR_BADIMPL             EMAKEHR(0x12D8) // Manifest resource has invalid Implementation
#define VLDTR_E_MR_VARARGCALLINGCONV    EMAKEHR(0x12DA) // MemberRef has VARARG calling conv. (CLS warning)
#define VLDTR_E_MD_CTORNOTVOID          EMAKEHR(0x12DB) // .ctor,.cctor returning not void
#define VLDTR_E_EV_FIRENOTVOID          EMAKEHR(0x12DC) // Fire method returning not void
#define VLDTR_E_AS_BADLOCALE            EMAKEHR(0x12DD) // Invalid locale
#define VLDTR_E_CN_PARENTTYPE           EMAKEHR(0x12DE) // Constant has parent of invalid type
#define VLDTR_E_SIG_SENTINMETHODDEF     EMAKEHR(0x12DF) // E_T_SENTINEL in MethodDef signature
#define VLDTR_E_SIG_SENTMUSTVARARG      EMAKEHR(0x12E0) // E_T_SENTINEL <=> VARARG
#define VLDTR_E_SIG_MULTSENTINELS       EMAKEHR(0x12E1) // Multiple E_T_SENTINELs
#define VLDTR_E_SIG_LASTSENTINEL        EMAKEHR(0x12E2) // E_T_SENTINEL not followed by type
#define VLDTR_E_SIG_MISSARG             EMAKEHR(0x12E3) // Signature missing argument
#define VLDTR_E_SIG_BYREFINFIELD        EMAKEHR(0x12E4) // Field of ByRef type
#define VLDTR_E_MD_SYNCMETHODINVTYPE    EMAKEHR(0x12E5) // Synchronized method in value class
#define VLDTR_E_TD_NAMETOOLONG          EMAKEHR(0x12E6) // TypeDef name too long
#define VLDTR_E_AS_PROCDUP              EMAKEHR(0x12E7) // Duplicate Assembly Processor
#define VLDTR_E_ASOS_DUP                EMAKEHR(0x12E8) // Duplicate Assembly OS (ID+ver.major+ver.minor)
#define VLDTR_E_MAR_BADFLAGS            EMAKEHR(0x12E9) // Manifest Resource has bad flags
#define VLDTR_E_CT_NOTYPEDEFID          EMAKEHR(0x12EA) // COMType has nil TypeDefId
#define VLDTR_E_FILE_BADFLAGS           EMAKEHR(0x12EB) // File has bad flags
#define VLDTR_E_FILE_NULLHASH           EMAKEHR(0x12EC) // File has no hash blob
#define VLDTR_E_MOD_NONAME              EMAKEHR(0x12ED) // Module has no name
#define VLDTR_E_MOD_NAMEFULLQLFD        EMAKEHR(0x12EE) // Module has fully-qualified name
#define VLDTR_E_TD_RTSPCLNOTSPCL        EMAKEHR(0x12EF) // TypeDef is tdRTSpecialName but not tdSpecialName
#define VLDTR_E_TD_EXTENDSIFACE         EMAKEHR(0x12F0) // TypeDef extends interface
#define VLDTR_E_MD_CTORPINVOKE          EMAKEHR(0x12F1) // .ctor,.cctor is PInvokeImpl
#define VLDTR_E_TD_SYSENUMNOTCLASS      EMAKEHR(0x12F2) // System.Enum is not a class
#define VLDTR_E_TD_SYSENUMNOTEXTVTYPE   EMAKEHR(0x12F3) // System.Enum extends not System.ValueType
#define VLDTR_E_MI_SIGMISMATCH          EMAKEHR(0x12F4) // MethodImpl's Decl and Body signatures mismatch
#define VLDTR_E_TD_ENUMHASMETHODS       EMAKEHR(0x12F5) // TypeDef extends System.Enum but has methods
#define VLDTR_E_TD_ENUMIMPLIFACE        EMAKEHR(0x12F6) // TypeDef extends System.Enum but impls interface(s)
#define VLDTR_E_TD_ENUMHASPROP          EMAKEHR(0x12F7) // TypeDef extends System.Enum but has prop(s)
#define VLDTR_E_TD_ENUMHASEVENT         EMAKEHR(0x12F8) // TypeDef extends System.Enum but has event(s)
#define VLDTR_E_TD_BADMETHODLST         EMAKEHR(0x12F9) // TypeDef has MethodList > Nmethods+1
#define VLDTR_E_TD_BADFIELDLST          EMAKEHR(0x12FA) // TypeDef has FieldList > Nfields+1
#define VLDTR_E_CN_BADTYPE              EMAKEHR(0x12FB) // Constant has wrong type
#define VLDTR_E_TD_ENUMNOINSTFLD        EMAKEHR(0x12FC) // Enum has no instance fields
#define VLDTR_E_TD_ENUMMULINSTFLD       EMAKEHR(0x12FD) // Enum has multiple instance fields
             
                                  
#define VLDTR_E_INTERRUPTED             EMAKEHR(0x12FE) // Validator has been interrupted by the VEHandler.
#define VLDTR_E_NOTINIT                 EMAKEHR(0x12FF) // Validator failed to initialize correctly.

#define VLDTR_E_IFACE_NOTIFACE          EMAKEHR(0x1B00) // Interface in InterfaceImpl is not marked tdInterface
#define VLDTR_E_FD_RVAHASNORVA          EMAKEHR(0x1B01) // Field marked fdHasFieldRVA but has no RVA rec
#define VLDTR_E_FD_RVAHASZERORVA        EMAKEHR(0x1B02) // Field marked fdHasFieldRVA has RVA =0
#define VLDTR_E_MD_RVAANDIMPLMAP        EMAKEHR(0x1B03) // Method has both RVA !=0 and ImplMap
#define VLDTR_E_TD_EXTRAFLAGS           EMAKEHR(0x1B04) // TypeDef has extraneous bits in flags
#define VLDTR_E_TD_EXTENDSITSELF        EMAKEHR(0x1B05) // TypeDef extends itself
#define VLDTR_E_TD_SYSVTNOTEXTOBJ       EMAKEHR(0x1B06) // System.ValueType does not extend System.Object
#define VLDTR_E_TD_EXTTYPESPEC          EMAKEHR(0x1B07) // Class extends TypeSpec (warning)
#define VLDTR_E_TD_VTNOSIZE             EMAKEHR(0x1B09) // Value Class has zero size
#define VLDTR_E_TD_IFACESEALED          EMAKEHR(0x1B0A) // Interface is sealed
#define VLDTR_E_NC_BADNESTED            EMAKEHR(0x1B0B) // Bad "nested" token in NestedClass
#define VLDTR_E_NC_BADENCLOSER          EMAKEHR(0x1B0C) // Bad "enclosing" token in NestedClass
#define VLDTR_E_NC_DUP                  EMAKEHR(0x1B0D) // Duplicate NestedClass record
#define VLDTR_E_NC_DUPENCLOSER          EMAKEHR(0x1B0E) // Duplicate NestedClass with different encloser
#define VLDTR_E_FRVA_ZERORVA            EMAKEHR(0x1B0F) // RVA=0 in FieldRVA record
#define VLDTR_E_FRVA_BADFIELD           EMAKEHR(0x1B10) // Invalid field token in FieldRVA record
#define VLDTR_E_FRVA_DUPRVA             EMAKEHR(0x1B11) // Duplicate RVA in FieldRVA record
#define VLDTR_E_FRVA_DUPFIELD           EMAKEHR(0x1B12) // Duplicate field in FieldRVA record
#define VLDTR_E_EP_BADTOKEN             EMAKEHR(0x1B13) // Bad token as entry point in CLR header
#define VLDTR_E_EP_INSTANCE             EMAKEHR(0x1B14) // Entry point in CLR header is a token of instance method
#define VLDTR_E_TD_ENUMFLDBADTYPE       EMAKEHR(0x1B15) // Enum has non-integral underlying type
#define VLDTR_E_MD_BADRVA               EMAKEHR(0x1B16) // Method has bogus RVA
#define VLDTR_E_FD_LITERALNODEFAULT     EMAKEHR(0x1B17) // Literal field has no const value
#define VLDTR_E_IFACE_METHNOTIMPL       EMAKEHR(0x1B18) // Class implementing an interface doesn't impl.one of methods
#define VLDTR_E_CA_BADPARENT            EMAKEHR(0x1B19) // CA has invalid owner
#define VLDTR_E_CA_BADTYPE              EMAKEHR(0x1B1A) // CA has invalid type
#define VLDTR_E_CA_NOTCTOR              EMAKEHR(0x1B1B) // CA type is not .ctor
#define VLDTR_E_CA_BADSIG               EMAKEHR(0x1B1C) // CA type has bad signature
#define VLDTR_E_CA_NOSIG                EMAKEHR(0x1B1D) // CA type has no signature
#define VLDTR_E_CA_BADPROLOG            EMAKEHR(0x1B1E) // CA blob has bad prolog (not 0x01 0x00)
#define VLDTR_E_MD_BADLOCALSIGTOK       EMAKEHR(0x1B1F) // Method has invalid LocalSig token
#define VLDTR_E_MD_BADHEADER            EMAKEHR(0x1B20) // Method has invalid header
#define VLDTR_E_EP_TOOMANYARGS          EMAKEHR(0x1B21) // Entry point has more than one arg
#define VLDTR_E_EP_BADRET               EMAKEHR(0x1B22) // Entry point has bad return type
#define VLDTR_E_EP_BADARG               EMAKEHR(0x1B23) // Entry point has bad argument
#define VLDTR_E_SIG_BADVOID             EMAKEHR(0x1B24) // Illegal "void" in signature


//**** Common Language Runtime Debugging Services errors
#define CORDBG_E_UNRECOVERABLE_ERROR                    EMAKEHR(0x1300) // Unrecoverable API error.
#define CORDBG_E_PROCESS_TERMINATED                     EMAKEHR(0x1301) // Process was terminated.
#define CORDBG_E_PROCESS_NOT_SYNCHRONIZED               EMAKEHR(0x1302) // Process not synchronized.
#define CORDBG_E_CLASS_NOT_LOADED                       EMAKEHR(0x1303) // A class is not loaded.
#define CORDBG_E_IL_VAR_NOT_AVAILABLE                   EMAKEHR(0x1304) // An IL variable is not available at the
                                                                        // current native IP.
#define CORDBG_E_BAD_REFERENCE_VALUE                    EMAKEHR(0x1305) // A reference value was found to be bad
                                                                        // during dereferencing.
#define CORDBG_E_FIELD_NOT_AVAILABLE                    EMAKEHR(0x1306) // A field in a class is not available,
                                                                        // because the runtime optimized it away.
#define CORDBG_E_NON_NATIVE_FRAME                       EMAKEHR(0x1307) // "Native frame only" operation on
                                                                        // non-native frame
#define CORDBG_E_NONCONTINUABLE_EXCEPTION               EMAKEHR(0x1308) // Continue on non-continuable exception
#define CORDBG_E_CODE_NOT_AVAILABLE                     EMAKEHR(0x1309) // The code is currently unavailable
#define CORDBG_E_FUNCTION_NOT_IL                        EMAKEHR(0x130A) // Attempt to get a ICorDebugFunction for
                                                                        // a function that is not IL.
#define CORDBG_S_BAD_START_SEQUENCE_POINT               SMAKEHR(0x130B) // Attempt to SetIP not at a sequence point
#define CORDBG_S_BAD_END_SEQUENCE_POINT                 SMAKEHR(0x130C) // Attempt to SetIP when not going to a
                                                                        // sequence point.  If both this and
                                                                        // CORDBG_E_BAD_START_SEQUENCE_POINT are
                                                                        // true, only CORDBG_E_BAD_START_SEQUENCE_POINT
                                                                        // will be reported.
#define CORDBG_S_INSUFFICIENT_INFO_FOR_SET_IP           SMAKEHR(0x130D) // SetIP is possible, but the debugger doesn't
                                                                        // have enough info to fix variable locations,
                                                                        // GC refs, or anything else. Use at your own
                                                                        // risk.
#define CORDBG_E_CANT_SET_IP_INTO_FINALLY               EMAKEHR(0x130E) // SetIP isn't possible, because SetIP would
                                                                        // move EIP from outside of an exception
                                                                        // handling finally clause to a point inside
                                                                        // of one.
#define CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY             EMAKEHR(0x130F) // SetIP isnt possible because it would move 
                                                                        // EIP from within an exception handling finally 
                                                                        // clause to a point outside of one.
#define CORDBG_E_CANT_SET_IP_INTO_CATCH                 EMAKEHR(0x1310) // SetIP isn't possible, because SetIP would
                                                                        // move EIP from outside of an exception
                                                                        // handling catch clause to a point inside of
                                                                        // one.
#define CORDBG_E_SET_IP_NOT_ALLOWED_ON_NONLEAF_FRAME    EMAKEHR(0x1311) // Setip cannot be done on any frame except
                                                                        // the leaf frame.
#define CORDBG_E_SET_IP_IMPOSSIBLE                      EMAKEHR(0x1312) // SetIP isn't allowed. For example, there is
                                                                        // insufficient memory to perform SetIP.
#define CORDBG_E_FUNC_EVAL_BAD_START_POINT              EMAKEHR(0x1313) // Func eval can't work if we're, for example,
                                                                        // not stopped at a GC safe point.
#define CORDBG_E_INVALID_OBJECT                         EMAKEHR(0x1314) // This object value is no longer valid.  
#define CORDBG_E_FUNC_EVAL_NOT_COMPLETE                 EMAKEHR(0x1315) // If you call CordbEval::GetResult before the
                                                                        // func eval has finished, you'll get this
                                                                        // result.
#define CORDBG_S_FUNC_EVAL_HAS_NO_RESULT                SMAKEHR(0x1316) // Some Func evals will lack a return value,
                                                                        // such as those whose return type is void.
#define CORDBG_S_VALUE_POINTS_TO_VOID                   SMAKEHR(0x1317) // The Debugging API doesn't support
                                                                        // dereferencing pointers of type void.
#define CORDBG_E_INPROC_NOT_IMPL                        EMAKEHR(0x1318) // The inproc version of the debugging API
                                                                        // doesn't implement this function,
#define CORDBG_S_FUNC_EVAL_ABORTED                      SMAKEHR(0x1319) // The func eval completed, but was aborted.
#define CORDBG_E_STATIC_VAR_NOT_AVAILABLE               EMAKEHR(0x131A) // A static variable isn't available because
                                                                        // it hasn't been initialized yet.
#define CORDBG_E_OBJECT_IS_NOT_COPYABLE_VALUE_CLASS     EMAKEHR(0x131B) // Can't copy a VC with object refs in it.
#define CORDBG_E_CANT_SETIP_INTO_OR_OUT_OF_FILTER       EMAKEHR(0x131C) // SetIP can't leave or enter a filter
#define CORDBG_E_CANT_CHANGE_JIT_SETTING_FOR_ZAP_MODULE EMAKEHR(0x131D) // You can't change JIT settings for ZAP
                                                                        // modules.
#define CORDBG_E_BAD_THREAD_STATE                       EMAKEHR(0x132d) // The state of the thread is invalid.
#define CORDBG_E_DEBUGGER_ALREADY_ATTACHED              EMAKEHR(0x132e) // This process has already been attached to
#define CORDBG_E_SUPERFLOUS_CONTINUE                    EMAKEHR(0x132f) // Returned from a call to Continue that was
                                                                        // Not matched with a stopping event.
#define CORDBG_E_SET_VALUE_NOT_ALLOWED_ON_NONLEAF_FRAME EMAKEHR(0x1330) // Can't perfrom SetValue on non-leaf frames.
#define CORDBG_E_ENC_EH_MAX_NESTING_LEVEL_CANT_INCREASE EMAKEHR(0x1331) // When doing EnC, some JITters don't let you
                                                                        // increase the maximum level to which
                                                                        // exception handling can be nested.
#define CORDBG_E_ENC_MODULE_NOT_ENC_ENABLED             EMAKEHR(0x1332) // Tried to do EnC on a module that wasn't
                                                                        // started in EnC mode.
#define CORDBG_E_SET_IP_NOT_ALLOWED_ON_EXCEPTION        EMAKEHR(0x1333) // Setip cannot be done on any exception
#define CORDBG_E_VARIABLE_IS_ACTUALLY_LITERAL           EMAKEHR(0x1334) // The 'variable' doesn't exist because it is a
                                                                        // literal optimized away by the compiler - ask
                                                                        // Metadata for it's default value, instead.
#define CORDBG_E_PROCESS_DETACHED                       EMAKEHR(0x1335) // Process has been detached from
#define CORDBG_E_ENC_METHOD_SIG_CHANGED                 EMAKEHR(0x1336) // Not allowed to change the signature of an
                                                                        // existing method - compiler should make new method
                                                                        // instead.
#define CORDBG_E_ENC_METHOD_NO_LOCAL_SIG                EMAKEHR(0x1337) // Can't get the local signature for the method
                                                                        // we're trying to EnC.
#define CORDBG_E_ENC_CANT_ADD_FIELD_TO_VALUECLASS       EMAKEHR(0x1338) // Adding a field to a value class is prohibitted,
                                                                        // since we can't guarantee the new field is contiguous to
                                                                        // VC's on the stack, embedded in other objects, etc.
#define CORDBG_E_ENC_CANT_CHANGE_FIELD                  EMAKEHR(0x1339) // Once you've got a field, you're not allowed to change
                                                                        // it, since that would change the size of the type it belongs to.
#define CORDBG_E_ENC_RE_ADD_CLASS                       EMAKEHR(0x133A) // AddAvailableClassHaveLock will return this if we're trying to
                                                                        // to add a class that's been previously added.  If we've got a
                                                                        // "delta-PE" that includes everything from the original PE, then
                                                                        // we can ignore this return value. It's the same as S_OK in that case.
#define CORDBG_E_FIELD_NOT_STATIC                       EMAKEHR(0x133B) // Returned if someone tries to call GetStaticFieldValue
                                                                        // on a non-static field
#define CORDBG_E_FIELD_NOT_INSTANCE                     EMAKEHR(0x133C) // Returned if someone tries to call GetStaticFieldValue
                                                                        // on a non-instance field
#define CORDBG_E_ENC_ZAPPED_WITHOUT_ENC                 EMAKEHR(0x133D) // If a zap file was created without the EnC flag set, then
                                                                        // we can't do EnC on it, no matter what.
#define CORDBG_E_ENC_BAD_METHOD_INFO                    EMAKEHR(0x133E) // Lacking information about method.
#define CORDBG_E_ENC_JIT_CANT_UPDATE                    EMAKEHR(0x133F) // The JIT is unable to update the method.
#define CORDBG_E_ENC_MISSING_CLASS                      EMAKEHR(0x1340) // An internal structure about the class is missing
#define CORDBG_E_ENC_INTERNAL_ERROR                     EMAKEHR(0x1341) // Generic message for "Something user doesn't control went wrong" message.
#define CORDBG_E_ENC_HANGING_FIELD                      EMAKEHR(0x1342) // The field was added via enc after the class was loaded, and so instead of
                                                                        // the field being contiguous with the other fields, it's 'hanging' off the 
                                                                        // instance, so the right side will have to go & get (instance-specific 
                                                                        // info based on the particular object. 
#define CORDBG_E_MODULE_NOT_LOADED                      EMAKEHR(0x1343) // If the module isn't loaded, including if it's been unloaded.

#define CORDBG_E_ENC_CANT_CHANGE_SUPERCLASS             EMAKEHR(0x1344) // Not allowed to change which class something inherits from
#define CORDBG_E_UNABLE_TO_SET_BREAKPOINT               EMAKEHR(0x1345) // Can't set a breakpoint here.
#define CORDBG_E_DEBUGGING_NOT_POSSIBLE                 EMAKEHR(0x1346) // Debugging isn't possible due to an incompatability within the CLR implementation.
#define CORDBG_E_KERNEL_DEBUGGER_ENABLED                EMAKEHR(0x1347) // Debugging isn't possible because a kernel debugger is enabled on the system.
#define CORDBG_E_KERNEL_DEBUGGER_PRESENT                EMAKEHR(0x1348) // Debugging isn't possible because a kernel debugger is present on the system.
#define CORDBG_E_HELPER_THREAD_DEAD                     EMAKEHR(0x1349) // The debugger's internal helper thread is dead.
#define CORDBG_E_INTERFACE_INHERITANCE_CANT_CHANGE      EMAKEHR(0x134A) // Not allowed to change interface inheritance.
#define CORDBG_E_INCOMPATIBLE_PROTOCOL                  EMAKEHR(0x134B) // The debugger's protocol is incompatible with the debuggee.
#define CORDBG_E_TOO_MANY_PROCESSES                     EMAKEHR(0x134C) // The debugger can only handle a finite number of debuggees.
#define CORDBG_E_INTEROP_NOT_SUPPORTED                  EMAKEHR(0x134D) // Interop is not allowed on a win9x platform

//**** Common Language Runtime Profiling Services errors
#define CORPROF_E_FUNCTION_NOT_COMPILED EMAKEHR(0x1350)     // Function not yet compiled.
#define CORPROF_E_DATAINCOMPLETE        EMAKEHR(0x1351)     // The ID is not fully loaded/defined yet.
#define CORPROF_E_NOT_REJITABLE_METHODS EMAKEHR(0x1352)     // The Module is not configured for updateable methods.
#define CORPROF_E_CANNOT_UPDATE_METHOD  EMAKEHR(0x1353)     // The Method could not be updated for re-jit.
#define CORPROF_E_FUNCTION_NOT_IL       EMAKEHR(0x1354)     // The Method has no associated IL
#define CORPROF_E_NOT_MANAGED_THREAD    EMAKEHR(0x1355)     // The thread has never run managed code before
#define CORPROF_E_CALL_ONLY_FROM_INIT   EMAKEHR(0x1356)     // The function may only be called during profiler init
#define CORPROF_E_INPROC_NOT_ENABLED    EMAKEHR(0x1357)     // Inprocess debugging must be enabled during init
                                                            // Also returned when BeginInprocDebugging not called
                                                            // before using the inprocess debugging services
#define CORPROF_E_JITMAPS_NOT_ENABLED   EMAKEHR(0x1358)     // Can't get a JIT map becuase they are not enabled
#define CORPROF_E_INPROC_ALREADY_BEGUN  EMAKEHR(0x1359)     // If a profiler tries to call BeginInprocDebugging more than
                                                            // once, it will get this error.
#define CORPROF_E_INPROC_NOT_AVAILABLE  EMAKEHR(0x135A)     // States that inprocess debugging not allowed at this point
                                                            // (for example during GC callbacks or RuntimeSuspention callbacks
#define CORPROF_E_NOT_YET_AVAILABLE     EMAKEHR(0x135B)     // This is a general error used to indicated that the information
                                                            // requested is not yet available
//**** Security errors
#define SECURITY_E_XML_TO_ASN_ENCODING  EMAKEHR(0x1400)     // Failed to convert XML to ASN 
#define SECURITY_E_INCOMPATIBLE_SHARE   EMAKEHR(0x1401)     // Loading this assembly would produce a different grant set from other instances
#define SECURITY_E_UNVERIFIABLE         EMAKEHR(0x1402)     // Unverifable code failed policy check
#define SECURITY_E_INCOMPATIBLE_EVIDENCE EMAKEHR(0x1403)     // Assembly already loaded without additional security evidence.

//**** Reserved.
#define CLDB_E_INTERNALERROR            EMAKEHR(0x1fff)

// ******************
// Debugger & Profiler errors
// ******************


// ******************
// Security errors
// ******************

#define CORSEC_E_DECODE_SET             EMAKEHR(0x1410)         // Failure decoding permission set
#define CORSEC_E_ENCODE_SET             EMAKEHR(0x1411)         // Failure encoding permission set
#define CORSEC_E_UNSUPPORTED_FORMAT     EMAKEHR(0x1412)         // Unrecognized encoding format
#define SN_CRYPTOAPI_CALL_FAILED        EMAKEHR(0x1413)         // StrongName APIs not supported on system
#define CORSEC_E_CRYPTOAPI_CALL_FAILED  EMAKEHR(0x1413)         // StrongName APIs not supported on system
#define SN_NO_SUITABLE_CSP              EMAKEHR(0x1414)         // StrongName APIs couldn't locate a matching CSP
#define CORSEC_E_NO_SUITABLE_CSP        EMAKEHR(0x1414)         // StrongName APIs couldn't locate a matching CSP
#define CORSEC_E_INVALID_ATTR           EMAKEHR(0x1415)         // Invalid security custom attribute
#define CORSEC_E_POLICY_EXCEPTION       EMAKEHR(0x1416)         // PolicyException thrown
#define CORSEC_E_MIN_GRANT_FAIL         EMAKEHR(0x1417)         // Failed to grant minimum permission requests
#define CORSEC_E_NO_EXEC_PERM           EMAKEHR(0x1418)         // Failed to grant permission to execute
#define CORSEC_E_XMLSYNTAX              EMAKEHR(0x1419)         // XML Syntax error
#define CORSEC_E_INVALID_STRONGNAME     EMAKEHR(0x141a)         // Strong name validation failed
#define CORSEC_E_MISSING_STRONGNAME     EMAKEHR(0x141b)         // Assembly is not strong named
#define CORSEC_E_CONTAINER_NOT_FOUND    EMAKEHR(0x141c)         // Strong name key container not found
#define CORSEC_E_INVALID_IMAGE_FORMAT   EMAKEHR(0x141d)         // Invalid assembly file format

//**** crypto errors 1430 -- 143f

#define CORSEC_E_CRYPTO                 EMAKEHR(0x1430)         // generic CryptographicException
#define CORSEC_E_CRYPTO_UNEX_OPER       EMAKEHR(0x1431)         // generic CryptographicUnexpectedOperationException

//**** security custom attribute errors 143d -- 144f

#define CORSECATTR_E_BAD_ACTION_ASM             EMAKEHR(0x143d) // SecurityAction type invalid on assembly
#define CORSECATTR_E_BAD_ACTION_OTHER           EMAKEHR(0x143e) // SecurityAction type invalid on types and methods
#define CORSECATTR_E_BAD_PARENT                 EMAKEHR(0x143f) // Security custom attribute attached to invalid parent
#define CORSECATTR_E_TRUNCATED                  EMAKEHR(0x1440) // Bad custom attribute serialized blob
#define CORSECATTR_E_BAD_VERSION                EMAKEHR(0x1441) // Bad custom attribute serialized blob version
#define CORSECATTR_E_BAD_ACTION                 EMAKEHR(0x1442) // Invalid security action code
#define CORSECATTR_E_NO_SELF_REF                EMAKEHR(0x1443) // CA ref to CA def'd in same assembly
#define CORSECATTR_E_BAD_NONCAS                 EMAKEHR(0x1444) // Use of non-CAS perm with invalid action
#define CORSECATTR_E_ASSEMBLY_LOAD_FAILED       EMAKEHR(0x1445) // Failed to load assembly containing CA (or req'd CA type)
#define CORSECATTR_E_ASSEMBLY_LOAD_FAILED_EX    EMAKEHR(0x1446) // Failed to load assembly containing CA (or req'd CA type)
#define CORSECATTR_E_TYPE_LOAD_FAILED           EMAKEHR(0x1447) // Failed to load CA type (or reqd CA type)
#define CORSECATTR_E_TYPE_LOAD_FAILED_EX        EMAKEHR(0x1448) // Failed to load CA type (or reqd CA type)
#define CORSECATTR_E_ABSTRACT                   EMAKEHR(0x1449) // CA type is abstract
#define CORSECATTR_E_UNSUPPORTED_TYPE           EMAKEHR(0x144a) // Unsupported type for field/property setter
#define CORSECATTR_E_UNSUPPORTED_ENUM_TYPE      EMAKEHR(0x144b) // Unsupported base type for enum field/property
#define CORSECATTR_E_NO_FIELD                   EMAKEHR(0x144c) // Couldn't find a CA field
#define CORSECATTR_E_NO_PROPERTY                EMAKEHR(0x144d) // Couldn't find a CA property
#define CORSECATTR_E_EXCEPTION                  EMAKEHR(0x144e) // Unexpected exception
#define CORSECATTR_E_EXCEPTION_HR               EMAKEHR(0x144f) // Unexpected exception


//**** Isolated Storage Errors 1450 - 14FF
#define ISS_E_ISOSTORE                   EMAKEHR(0x1450L)

#define ISS_E_OPEN_STORE_FILE            EMAKEHR(0x1460L)
#define ISS_E_OPEN_FILE_MAPPING          EMAKEHR(0x1461L)
#define ISS_E_MAP_VIEW_OF_FILE           EMAKEHR(0x1462L)
#define ISS_E_GET_FILE_SIZE              EMAKEHR(0x1463L)
#define ISS_E_CREATE_MUTEX               EMAKEHR(0x1464L)
#define ISS_E_LOCK_FAILED                EMAKEHR(0x1465L)
#define ISS_E_FILE_WRITE                 EMAKEHR(0x1466L)
#define ISS_E_SET_FILE_POINTER           EMAKEHR(0x1467L)
#define ISS_E_CREATE_DIR                 EMAKEHR(0x1468L)
#define ISS_E_STORE_NOT_OPEN             EMAKEHR(0x1469L)

#define ISS_E_CORRUPTED_STORE_FILE       EMAKEHR(0x1480L)
#define ISS_E_STORE_VERSION              EMAKEHR(0x1481L)
#define ISS_E_FILE_NOT_MAPPED            EMAKEHR(0x1482L)
#define ISS_E_BLOCK_SIZE_TOO_SMALL       EMAKEHR(0x1483L)
#define ISS_E_ALLOC_TOO_LARGE            EMAKEHR(0x1484L)
#define ISS_E_USAGE_WILL_EXCEED_QUOTA    EMAKEHR(0x1485L)
#define ISS_E_TABLE_ROW_NOT_FOUND        EMAKEHR(0x1486L)

#define ISS_E_DEPRECATE                  EMAKEHR(0x14A0L)
#define ISS_E_CALLER                     EMAKEHR(0x14A1L)
#define ISS_E_PATH_LENGTH                EMAKEHR(0x14A2L)
#define ISS_E_MACHINE                    EMAKEHR(0x14A3L)


#define ISS_E_ISOSTORE_START             EMAKEHR(0x1450L)
#define ISS_E_ISOSTORE_END               EMAKEHR(0x14FFL)

// ******************
// Classlib errors
// ******************


//
// MessageId: COR_E_APPLICATION
//
// MessageText: 
//
// The base class for all "less serious" exceptions.
//
#define COR_E_APPLICATION  EMAKEHR(0x1600L) 
 

//
// MessageId: COR_E_ARGUMENT
//
// MessageText: 
//
// An argument does not meet the contract of the method.
//
#define COR_E_ARGUMENT  E_INVALIDARG        // 0x80070057
 

//
// MessageId: COR_E_ARGUMENTOUTOFRANGE
//
// MessageText: 
//
// An argument was out of its legal range.
//
#define COR_E_ARGUMENTOUTOFRANGE  EMAKEHR(0x1502L) 


//
// MessageId: COR_E_ARITHMETIC
//
// MessageText: 
//
// Overflow or underflow in mathematical operations.
//
#define COR_E_ARITHMETIC  HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW)     // 0x80070216
 

//
// MessageId: COR_E_ARRAYTYPEMISMATCH
//
// MessageText: 
//
// Attempted to store an object of the wrong type in an array
//
#define COR_E_ARRAYTYPEMISMATCH  EMAKEHR(0x1503L) 


//
// MessageId: COR_E_CONTEXTMARSHAL
//
// MessageText: 
//
// 
//
#define COR_E_CONTEXTMARSHAL  EMAKEHR(0x1504L) 

 
//
// MessageId: COR_E_DIVIDEBYZERO
//
// MessageText: 
//
// Attempted to divide a number by zero.
//
#define COR_E_DIVIDEBYZERO  DISP_E_DIVBYZERO
 

//
// MessageId: COR_E_EXCEPTION
//
// MessageText: 
//
// Base class for all exceptions in the runtime
//
#define COR_E_EXCEPTION  EMAKEHR(0x1500L) 
 

//
// MessageId: COR_E_EXECUTIONENGINE
//
// MessageText: 
//
// An internal error happened in the Common Language Runtime's Execution Engine
//
#define COR_E_EXECUTIONENGINE  EMAKEHR(0x1506L) 
 

//
// MessageId: COR_E_FIELDACCESS
//
// MessageText: 
//
// Access to this field is denied.
//
#define COR_E_FIELDACCESS  EMAKEHR(0x1507L) 
 

//
// MessageId: COR_E_FORMAT
//
// MessageText: 
//
// The format of one arguments does not meet the contract of the method.
//
#define COR_E_FORMAT  EMAKEHR(0x1537L)
 

//
// MessageId: COR_E_BADIMAGEFORMAT
//
// MessageText: 
//
// The format of DLL or executable being loaded is invalid.
//
#define COR_E_BADIMAGEFORMAT  _HRESULT_TYPEDEF_(0x8007000BL) 
 
 
//
// MessageId: COR_E_ASSEMBLYEXPECTED
//
// MessageText: 
//
// The module was expected to contain an assembly manifest.
//
#define COR_E_ASSEMBLYEXPECTED  EMAKEHR(0x1018L)

//
// MessageId: COR_E_TYPEUNLOADED
//
// MessageText: 
//
// The type had been unloaded.
//
#define COR_E_TYPEUNLOADED   EMAKEHR(0x1013L)

//
// MessageId: COR_E_INDEXOUTOFRANGE
//
// MessageText: 
//
// Attempted to access an element within an array by using an index that is 
// not within the bound of that array.
//
#define COR_E_INDEXOUTOFRANGE  EMAKEHR(0x1508L) 
 

//
// MessageId: COR_E_INVALIDCAST
//
// MessageText: 
//
// Indicates a bad cast condition
//
#define COR_E_INVALIDCAST  E_NOINTERFACE        // 0x80004002
 

//
// MessageId: COR_E_INVALIDOPERATION
//
// MessageText: 
//
// An operation is not legal in the current state.
//
#define COR_E_INVALIDOPERATION  EMAKEHR(0x1509L) 
 

//
// MessageId: COR_E_INVALIDPROGRAM
//
// MessageText: 
//
// A program contained invalid IL or bad metadata.  Usually this is a compiler bug.
//
#define COR_E_INVALIDPROGRAM  EMAKEHR(0x153AL) 


//
// MessageId: COR_E_MEMBERACCESS
//
// MessageText: 
//
// Access to this member is denied.
//
#define COR_E_MEMBERACCESS  EMAKEHR(0x151AL)


//
// MessageId: COR_E_METHODACCESS
//
// MessageText: 
//
// Access to this method is denied.
//
#define COR_E_METHODACCESS  EMAKEHR(0x1510L) 
 

//
// MessageId: COR_E_MISSINGFIELD
//
// MessageText: 
//
// An attempt was made to dynamically access a field that does not exist.
//
#define COR_E_MISSINGFIELD  EMAKEHR(0x1511L) 
 

//
// MessageId: COR_E_MISSINGMANIFESTRESOURCE
//
// MessageText: 
//
// An expected resource in the assembly manifest was missing.
//
#define COR_E_MISSINGMANIFESTRESOURCE  EMAKEHR(0x1532L) 


//
// MessageId: COR_E_MISSINGMEMBER
//
// MessageText: 
//
// An attempt was made to dynamically invoke or access a field or method
// that does not exist.
//
#define COR_E_MISSINGMEMBER  EMAKEHR(0x1512L) 


//
// MessageId: COR_E_MISSINGMETHOD
//
// MessageText: 
//
// An attempt was made to dynamically invoke a method that does not exist
//
#define COR_E_MISSINGMETHOD  EMAKEHR(0x1513L) 
 

//
// MessageId: COR_E_MULTICASTNOTSUPPORTED
//
// MessageText: 
//
// Attempted to combine delegates that are not multicast
//
#define COR_E_MULTICASTNOTSUPPORTED  EMAKEHR(0x1514L) 
 

//
// MessageId: COR_E_NOTFINITENUMBER
//
// MessageText: 
//
//  Thrown if value (a floating point number) is either the not a number value (NaN) or +- infinity value
//  VB needs this stuff 
#define COR_E_NOTFINITENUMBER     EMAKEHR(0x1528L)


//
// MessageId: COR_E_DUPLICATEWAITOBJECT
//
// MessageText: 
//
// An object appears more than once in the wait objects array.
//
#define COR_E_DUPLICATEWAITOBJECT   EMAKEHR(0x1529L)


//
// MessageId: COR_E_PLATFORMNOTSUPPORTED
//
// MessageText: 
//
// The method is not supported on this platform
//
#define COR_E_PLATFORMNOTSUPPORTED  EMAKEHR(0x1539L) 

//
// MessageId: COR_E_NOTSUPPORTED
//
// MessageText: 
//
// The method is not supported
//
#define COR_E_NOTSUPPORTED  EMAKEHR(0x1515L) 
 
//
// MessageId: COR_E_NULLREFERENCE
//
// MessageText: 
//
// Dereferencing a null reference. In general class libraries should not throw this
//
#define COR_E_NULLREFERENCE  E_POINTER      // 0x80004003
 

//
// MessageId: COR_E_OUTOFMEMORY
//
// MessageText: 
//
// The EE thows this exception when no more memory is avaible to continue execution
//
#define COR_E_OUTOFMEMORY  E_OUTOFMEMORY        // 0x8007000E
 

//
// MessageId: COR_E_OVERFLOW
//
// MessageText: 
//
// An arithmetic, casting, or conversion operation overflowed or underflowed.
//
#define COR_E_OVERFLOW  EMAKEHR(0x1516L) 
 

//
// MessageId: COR_E_RANK
//
// MessageText: 
//
// An array has the wrong number of dimensions for a particular operation.
//
#define COR_E_RANK  EMAKEHR(0x1517L) 
 

//
// MessageId: COR_E_REMOTING
//
// MessageText: 
//
// An error relating to remoting occurred.
//
#define COR_E_REMOTING  EMAKEHR(0x150BL)
#define COR_E_SERVER  EMAKEHR(0x150EL) 

//
// MessageId: COR_E_SERVICEDCOMPONENT
//
// MessageText: 
//
// An error relating to ServicedComponent occurred.
//
#define COR_E_SERVICEDCOMPONENT  EMAKEHR(0x150FL)

             
//
// MessageId: COR_E_SECURITY
//
// MessageText: 
//
// An error relating to security occured.
//
#define COR_E_SECURITY  EMAKEHR(0x150AL) 
 

//
// MessageID: COR_E_SERIALIZATION
//
// MessageText:
//
// An error relating to serialization has occurred.
//
#define COR_E_SERIALIZATION EMAKEHR(0x150CL)


//
// MessageId: COR_E_STACKOVERFLOW
//
// MessageText: 
//
// Is raised by the EE when the execution stack overflows as it is attempting to ex
//
#define COR_E_STACKOVERFLOW  HRESULT_FROM_WIN32(ERROR_STACK_OVERFLOW)       // 0x800703E9


//
// MessageId: COR_E_SYNCHRONIZATIONLOCK
//
// MessageText: 
//
// Wait(), Notify() or NotifyAll() was called from an unsynchronized ** block of c
//
#define COR_E_SYNCHRONIZATIONLOCK  EMAKEHR(0x1518L) 


//
// MessageId: COR_E_SYSTEM
//
// MessageText: 
//
// The base class for the runtime's "less serious" exceptions
//
#define COR_E_SYSTEM  EMAKEHR(0x1501L) 


//
// MessageId: COR_E_THREADABORTED
//
// MessageText: 
//
// Thrown into a thread to cause it to abort. Not catchable. 
//
#define COR_E_THREADABORTED  EMAKEHR(0x1530L) 

 
//
// MessageId: COR_E_THREADINTERRUPTED
//
// MessageText: 
//
// Indicates that the thread was interrupted from a waiting state
//
#define COR_E_THREADINTERRUPTED  EMAKEHR(0x1519L) 


//
// MessageId: COR_E_THREADSTATE
//
// MessageText: 
//
// Indicate that the Thread class is in an invalid state for the method call
//
#define COR_E_THREADSTATE  EMAKEHR(0x1520L) 
 

//
// MessageId: COR_E_THREADSTOP
//
// MessageText: 
//
// Thrown into a thread to cause it to stop. This exception is typically not caught
//
#define COR_E_THREADSTOP  EMAKEHR(0x1521L) 
 

//
// MessageId: COR_E_TYPEINITIALIZATION
//
// MessageText: 
//
// An exception was thrown by a type's initializer (.cctor).
//
#define COR_E_TYPEINITIALIZATION  EMAKEHR(0x1534L) 


//
// MessageId: COR_E_TYPELOAD
//
// MessageText: 
//
// Could not find or load a specific type (class, enum, etc).
//
#define COR_E_TYPELOAD  EMAKEHR(0x1522L) 


//
// MessageId: COR_E_ENTRYPOINTNOTFOUND
//
// MessageText: 
//
// Could not find the specified DllImport entry point
//
#define COR_E_ENTRYPOINTNOTFOUND  EMAKEHR(0x1523L) 


//
// MessageId: COR_E_DLLNOTFOUND
//
// MessageText: 
//
// Could not find the specified DllImport DLL.
//
#define COR_E_DLLNOTFOUND  EMAKEHR(0x1524L) 


//
// MessageId: COR_E_UNAUTHORIZEDACCESS
//
// MessageText: 
//
// Access is denied.
//
#define COR_E_UNAUTHORIZEDACCESS  E_ACCESSDENIED    // 0x80070005


//
// MessageId: COR_E_VERIFICATION
//
// MessageText: 
//
// A verification failure occurred
//
#define COR_E_VERIFICATION  EMAKEHR(0x150DL) 


//
// MessageId: COR_E_INVALIDCOMOBJECT
//
// MessageText: 
//
// An invalid __ComObject has been used.
//
#define COR_E_INVALIDCOMOBJECT     EMAKEHR(0x1527L)


//
// MessageId: COR_E_MARSHALDIRECTIVE
//
// MessageText: 
//
// The marshaling directives are invalid.
//
#define COR_E_MARSHALDIRECTIVE     EMAKEHR(0x1535L)


//
// MessageId: COR_E_INVALIDOLEVARIANTTYPE
//
// MessageText: 
//
// The type of an OLE variant that was passed into the runtime is invalid.
//
#define COR_E_INVALIDOLEVARIANTTYPE    EMAKEHR(0x1531L)


//
// MessageId: COR_E_SAFEARRAYTYPEMISMATCH
//
// MessageText: 
//
// A mismatch has occured between the runtime type of the array and the 
// sub type recorded in the metadata.
//
#define COR_E_SAFEARRAYTYPEMISMATCH    EMAKEHR(0x1533L)


//
// MessageId: COR_E_SAFEARRAYRANKMISMATCH
//
// MessageText: 
//
// A mismatch has occured between the runtime rank of the array and the 
// rank recorded in the metadata.
//
#define COR_E_SAFEARRAYRANKMISMATCH    EMAKEHR(0x1538L)


//
// MessageId: COR_E_TARGETPARAMCOUNT
//
// MessageText: 
//
// There was a mismatch between number of arguments provided and the number expected
//
#define COR_E_TARGETPARAMCOUNT     DISP_E_BADPARAMCOUNT
 

//
// MessageId: COR_E_AMBIGUOUSMATCH
//
// MessageText: 
//
// While late binding to a method via reflection, could not resolve between 
// multiple overloads of a method.
//
#define COR_E_AMBIGUOUSMATCH  _HRESULT_TYPEDEF_(0x8000211DL) 
 

//
// MessageId: COR_E_INVALIDFILTERCRITERIA
//
// MessageText: 
//
// The given filter criteria does not match the filter contract.
//
#define COR_E_INVALIDFILTERCRITERIA  EMAKEHR(0x1601L) 
 

//
// MessageId: COR_E_REFLECTIONTYPELOAD
//
// MessageText: 
//
// Could not find or load a specific class that was requested through Reflection
//
#define COR_E_REFLECTIONTYPELOAD  EMAKEHR(0x1602L) 


//
// MessageId: COR_E_TARGET
//
// MessageText: 
//
// - If you attempt to invoke a non-static method with a null Object - If you atte
//
#define COR_E_TARGET  EMAKEHR(0x1603L) 
 

//
// MessageId: COR_E_TARGETINVOCATION
//
// MessageText: 
//
// If the method called throws an exception
//
#define COR_E_TARGETINVOCATION  EMAKEHR(0x1604L)


//
// MessageId: COR_E_CUSTOMATTRIBUTEFORMAT
//
// MessageText: 
//
// If the binary format of a custom attribute is invalid.
//
#define COR_E_CUSTOMATTRIBUTEFORMAT  EMAKEHR(0x1605L)


//
// MessageId: COR_E_ENDOFSTREAM
//
// MessageText: 
//
// Thrown when the End of file is reached
//
#define COR_E_ENDOFSTREAM  HRESULT_FROM_WIN32(ERROR_HANDLE_EOF) 
 

//
// MessageId: COR_E_FILELOAD
//
// MessageText: 
//
// 
//
#define COR_E_FILELOAD  EMAKEHR(0x1621L)


//
// MessageId: COR_E_FILENOTFOUND
//
// MessageText: 
//
// 
//
#define COR_E_FILENOTFOUND  HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)

//
// MessageId: COR_E_IO
//
// MessageText: 
//
// Some sort of I/O error.
//
#define COR_E_IO  EMAKEHR(0x1620L) 
 

//
// MessageId: COR_E_DIRECTORYNOTFOUND
//
// MessageText: 
//
// The specified path couldn't be found.
//
#define COR_E_DIRECTORYNOTFOUND  HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)


//
// MessageId: COR_E_PATHTOOLONG
//
// MessageText: 
//
// The specified path was too long.
// 
#define COR_E_PATHTOOLONG  HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE)



//**** Shim errors 1700 - 1750
// 
#define CLR_E_SHIM_RUNTIMELOAD            EMAKEHR(0x1700)     // Failed to load the runtime
#define CLR_E_SHIM_RUNTIMEEXPORT          EMAKEHR(0x1701)     // Failed to find a required export in the runtime
#define CLR_E_SHIM_INSTALLROOT            EMAKEHR(0x1702)     // Install root is not defined
#define CLR_E_SHIM_INSTALLCOMP            EMAKEHR(0x1703)     // Expected component of the runtime is not available

//**** Verifier Errors 1800 - 18FF
// See src/dlls/mscorrc/mscorrc.rc for a description of each error

#define VER_E_HRESULT           EMAKEHR(0x1801)
#define VER_E_OFFSET            EMAKEHR(0x1802)
#define VER_E_OPCODE            EMAKEHR(0x1803)
#define VER_E_OPERAND           EMAKEHR(0x1804)
#define VER_E_TOKEN             EMAKEHR(0x1805)
#define VER_E_EXCEPT            EMAKEHR(0x1806)
#define VER_E_STACK_SLOT        EMAKEHR(0x1807)
#define VER_E_LOC               EMAKEHR(0x1808)
#define VER_E_ARG               EMAKEHR(0x1809)
#define VER_E_FOUND             EMAKEHR(0x180A)
#define VER_E_EXPECTED          EMAKEHR(0x180B)

#define VER_E_UNKNOWN_OPCODE    EMAKEHR(0x1810)
#define VER_E_SIG_CALLCONV      EMAKEHR(0x1811)
#define VER_E_SIG_ELEMTYPE      EMAKEHR(0x1812)

#define VER_E_RET_SIG           EMAKEHR(0x1814)
#define VER_E_FIELD_SIG         EMAKEHR(0x1815)

#define VER_E_INTERNAL          EMAKEHR(0x1818)
#define VER_E_STACK_TOO_LARGE   EMAKEHR(0x1819)
#define VER_E_ARRAY_NAME_LONG   EMAKEHR(0x181A)

#define VER_E_FALLTHRU          EMAKEHR(0x1820)
#define VER_E_TRY_GTEQ_END      EMAKEHR(0x1821)
#define VER_E_TRYEND_GT_CS      EMAKEHR(0x1822)
#define VER_E_HND_GTEQ_END      EMAKEHR(0x1823)
#define VER_E_HNDEND_GT_CS      EMAKEHR(0x1824)
#define VER_E_FLT_GTEQ_CS       EMAKEHR(0x1825)
#define VER_E_TRY_START         EMAKEHR(0x1826)
#define VER_E_HND_START         EMAKEHR(0x1827)
#define VER_E_FLT_START         EMAKEHR(0x1828)
#define VER_E_TRY_OVERLAP       EMAKEHR(0x1829)
#define VER_E_TRY_EQ_HND_FIL    EMAKEHR(0x182A)
#define VER_E_TRY_SHARE_FIN_FAL EMAKEHR(0x182B)
#define VER_E_HND_OVERLAP       EMAKEHR(0x182C)
#define VER_E_HND_EQ            EMAKEHR(0x182D)
#define VER_E_FIL_OVERLAP       EMAKEHR(0x182E)
#define VER_E_FIL_EQ            EMAKEHR(0x182F)
#define VER_E_FIL_CONT_TRY      EMAKEHR(0x1830)
#define VER_E_FIL_CONT_HND      EMAKEHR(0x1831)
#define VER_E_FIL_CONT_FIL      EMAKEHR(0x1832)
#define VER_E_FIL_GTEQ_CS       EMAKEHR(0x1833)
#define VER_E_FIL_START         EMAKEHR(0x1834)
#define VER_E_FALLTHRU_EXCEP    EMAKEHR(0x1835)
#define VER_E_FALLTHRU_INTO_HND EMAKEHR(0x1836)
#define VER_E_FALLTHRU_INTO_FIL EMAKEHR(0x1837)
#define VER_E_LEAVE             EMAKEHR(0x1838)
#define VER_E_RETHROW           EMAKEHR(0x1839)
#define VER_E_ENDFINALLY        EMAKEHR(0x183A)
#define VER_E_ENDFILTER         EMAKEHR(0x183B)
#define VER_E_ENDFILTER_MISSING EMAKEHR(0x183C)
#define VER_E_BR_INTO_TRY       EMAKEHR(0x183D)
#define VER_E_BR_INTO_HND       EMAKEHR(0x183E)
#define VER_E_BR_INTO_FIL       EMAKEHR(0x183F)
#define VER_E_BR_OUTOF_TRY      EMAKEHR(0x1840)
#define VER_E_BR_OUTOF_HND      EMAKEHR(0x1841)
#define VER_E_BR_OUTOF_FIL      EMAKEHR(0x1842)
#define VER_E_BR_OUTOF_FIN      EMAKEHR(0x1843)
#define VER_E_RET_FROM_TRY      EMAKEHR(0x1844)
#define VER_E_RET_FROM_HND      EMAKEHR(0x1845)
#define VER_E_RET_FROM_FIL      EMAKEHR(0x1846)
#define VER_E_BAD_JMP_TARGET    EMAKEHR(0x1847)
#define VER_E_PATH_LOC          EMAKEHR(0x1848)
#define VER_E_PATH_THIS         EMAKEHR(0x1849)
#define VER_E_PATH_STACK        EMAKEHR(0x184A)
#define VER_E_PATH_STACK_DEPTH  EMAKEHR(0x184B)
#define VER_E_THIS              EMAKEHR(0x184C)
#define VER_E_THIS_UNINIT_EXCEP EMAKEHR(0x184D)
#define VER_E_THIS_UNINIT_STORE EMAKEHR(0x184E)
#define VER_E_THIS_UNINIT_RET   EMAKEHR(0x184F)
#define VER_E_THIS_UNINIT_V_RET EMAKEHR(0x1850)
#define VER_E_THIS_UNINIT_BR    EMAKEHR(0x1851)
#define VER_E_LDFTN_CTOR        EMAKEHR(0x1852)
#define VER_E_STACK_NOT_EQ      EMAKEHR(0x1853)
#define VER_E_STACK_UNEXPECTED  EMAKEHR(0x1854)
#define VER_E_STACK_EXCEPTION   EMAKEHR(0x1855)
#define VER_E_STACK_OVERFLOW    EMAKEHR(0x1856)
#define VER_E_STACK_UNDERFLOW   EMAKEHR(0x1857)
#define VER_E_STACK_EMPTY       EMAKEHR(0x1858)
#define VER_E_STACK_UNINIT      EMAKEHR(0x1859)
#define VER_E_STACK_I_I4_I8     EMAKEHR(0x185A)
#define VER_E_STACK_R_R4_R8     EMAKEHR(0x185B)
#define VER_E_STACK_NO_R_I8     EMAKEHR(0x185C)
#define VER_E_STACK_NUMERIC     EMAKEHR(0x185D)
#define VER_E_STACK_OBJREF      EMAKEHR(0x185E)
#define VER_E_STACK_P_OBJREF    EMAKEHR(0x185F)
#define VER_E_STACK_BYREF       EMAKEHR(0x1860)
#define VER_E_STACK_METHOD      EMAKEHR(0x1861)
#define VER_E_STACK_ARRAY_SD    EMAKEHR(0x1862)
#define VER_E_STACK_VALCLASS    EMAKEHR(0x1863)
#define VER_E_STACK_P_VALCLASS  EMAKEHR(0x1864)
#define VER_E_STACK_NO_VALCLASS EMAKEHR(0x1865)
#define VER_E_LOC_DEAD          EMAKEHR(0x1866)
#define VER_E_LOC_NUM           EMAKEHR(0x1867)
#define VER_E_ARG_NUM           EMAKEHR(0x1868)
#define VER_E_TOKEN_RESOLVE     EMAKEHR(0x1869)
#define VER_E_TOKEN_TYPE        EMAKEHR(0x186A)
#define VER_E_TOKEN_TYPE_MEMBER EMAKEHR(0x186B)
#define VER_E_TOKEN_TYPE_FIELD  EMAKEHR(0x186C)
#define VER_E_TOKEN_TYPE_SIG    EMAKEHR(0x186D)
#define VER_E_UNVERIFIABLE      EMAKEHR(0x186E)
#define VER_E_LDSTR_OPERAND     EMAKEHR(0x186F)
#define VER_E_RET_PTR_TO_STACK  EMAKEHR(0x1870)
#define VER_E_RET_VOID          EMAKEHR(0x1871)
#define VER_E_RET_MISSING       EMAKEHR(0x1872)
#define VER_E_RET_EMPTY         EMAKEHR(0x1873)
#define VER_E_RET_UNINIT        EMAKEHR(0x1874)
#define VER_E_ARRAY_ACCESS      EMAKEHR(0x1875)
#define VER_E_ARRAY_V_STORE     EMAKEHR(0x1876)
#define VER_E_ARRAY_SD          EMAKEHR(0x1877)
#define VER_E_ARRAY_SD_PTR      EMAKEHR(0x1878)
#define VER_E_ARRAY_FIELD       EMAKEHR(0x1879)
#define VER_E_ARGLIST           EMAKEHR(0x187A)
#define VER_E_VALCLASS          EMAKEHR(0x187B)
#define VER_E_METHOD_ACCESS     EMAKEHR(0x187C)
#define VER_E_FIELD_ACCESS      EMAKEHR(0x187D)
#define VER_E_DEAD              EMAKEHR(0x187E)
#define VER_E_FIELD_STATIC      EMAKEHR(0x187F)
#define VER_E_FIELD_NO_STATIC   EMAKEHR(0x1880)
#define VER_E_ADDR              EMAKEHR(0x1881)
#define VER_E_ADDR_BYREF        EMAKEHR(0x1882)
#define VER_E_ADDR_LITERAL      EMAKEHR(0x1883)
#define VER_E_INITONLY          EMAKEHR(0x1884)
#define VER_E_THROW             EMAKEHR(0x1885)
#define VER_E_CALLVIRT_VALCLASS EMAKEHR(0x1886)
#define VER_E_CALL_SIG          EMAKEHR(0x1887)
#define VER_E_CALL_STATIC       EMAKEHR(0x1888)
#define VER_E_CTOR              EMAKEHR(0x1889)
#define VER_E_CTOR_VIRT         EMAKEHR(0x188A)
#define VER_E_CTOR_OR_SUPER     EMAKEHR(0x188B)
#define VER_E_CTOR_MUL_INIT     EMAKEHR(0x188C)
#define VER_E_SIG               EMAKEHR(0x188D)
#define VER_E_SIG_ARRAY         EMAKEHR(0x188E)
#define VER_E_SIG_ARRAY_PTR     EMAKEHR(0x188F)
#define VER_E_SIG_ARRAY_BYREF   EMAKEHR(0x1890)
#define VER_E_SIG_ELEM_PTR      EMAKEHR(0x1891)
#define VER_E_SIG_VARARG        EMAKEHR(0x1892)
#define VER_E_SIG_VOID          EMAKEHR(0x1893)
#define VER_E_SIG_BYREF_BYREF   EMAKEHR(0x1894)
#define VER_E_CODE_SIZE_ZERO    EMAKEHR(0x1896)
#define VER_E_BAD_VARARG        EMAKEHR(0x1897)
#define VER_E_TAIL_CALL         EMAKEHR(0x1898)
#define VER_E_TAIL_BYREF        EMAKEHR(0x1899)
#define VER_E_TAIL_RET          EMAKEHR(0x189A)
#define VER_E_TAIL_RET_VOID     EMAKEHR(0x189B)
#define VER_E_TAIL_RET_TYPE     EMAKEHR(0x189C)
#define VER_E_TAIL_STACK_EMPTY  EMAKEHR(0x189D)
#define VER_E_METHOD_END        EMAKEHR(0x189E)
#define VER_E_BAD_BRANCH        EMAKEHR(0x189F)
#define VER_E_FIN_OVERLAP       EMAKEHR(0x18A0)
#define VER_E_LEXICAL_NESTING   EMAKEHR(0x18A1)
#define VER_E_VOLATILE          EMAKEHR(0x18A2)
#define VER_E_UNALIGNED         EMAKEHR(0x18A3)
#define VER_E_INNERMOST_FIRST   EMAKEHR(0x18A4)
#define VER_E_CALLI_VIRTUAL     EMAKEHR(0x18A5)
#define VER_E_CALL_ABSTRACT     EMAKEHR(0x18A6)
#define VER_E_STACK_UNEXP_ARRAY EMAKEHR(0x18A7)
#define VER_E_NOT_IN_GC_HEAP    EMAKEHR(0x18A8)
#define VER_E_TRY_N_EMPTY_STACK EMAKEHR(0x18A9)
#define VER_E_DLGT_CTOR         EMAKEHR(0x18AA)
#define VER_E_DLGT_BB           EMAKEHR(0x18AB)
#define VER_E_DLGT_PATTERN      EMAKEHR(0x18AC)
#define VER_E_DLGT_LDFTN        EMAKEHR(0x18AD)
#define VER_E_FTN_ABSTRACT      EMAKEHR(0x18AE)
#define VER_E_SIG_C_VC          EMAKEHR(0x18AF)
#define VER_E_SIG_VC_C          EMAKEHR(0x18B0)
#define VER_E_BOX_PTR_TO_STACK  EMAKEHR(0x18B1)
#define VER_E_SIG_BYREF_TB_AH   EMAKEHR(0x18B2)
#define VER_E_SIG_ARRAY_TB_AH   EMAKEHR(0x18B3)
#define VER_E_ENDFILTER_STACK   EMAKEHR(0x18B4)
#define VER_E_DLGT_SIG_I        EMAKEHR(0x18B5)
#define VER_E_DLGT_SIG_O        EMAKEHR(0x18B6)
#define VER_E_RA_PTR_TO_STACK   EMAKEHR(0x18B7)
#define VER_E_CATCH_VALUE_TYPE  EMAKEHR(0x18B8)
#define VER_E_FIL_PRECEED_HND   EMAKEHR(0x18B9)
#define VER_E_LDVIRTFTN_STATIC  EMAKEHR(0x18BA)
#define VER_E_CALLVIRT_STATIC   EMAKEHR(0x18BB)
#define VER_E_INITLOCALS        EMAKEHR(0x18BC)
#define VER_E_BR_TO_EXCEPTION   EMAKEHR(0x18BD)
#define VER_E_CALL_CTOR         EMAKEHR(0x18BE)

#define VER_E_BAD_PE            EMAKEHR(0x18F0)
#define VER_E_BAD_MD            EMAKEHR(0x18F1)
#define VER_E_BAD_APPDOMAIN     EMAKEHR(0x18F2)
#define VER_E_TYPELOAD          EMAKEHR(0x18F3)
#define VER_E_PE_LOAD           EMAKEHR(0x18F4)

//
// ATTENTION: Range 0x1900 - 0x1AFF is reserved for Framework errors
//            Range 0x1B00 - 0x1BFF is reserved for MD Validator errors (see above VLDTR_E_...)
//
#endif // __COMMON_LANGUAGE_RUNTIME_HRESULTS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\tools\inc\pbt.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*
*  TITLE:       PBT.H
*
*  VERSION:     1.0
*
*  DATE:        15 Jan 1994
*
*  Definitions for the Virtual Power Management Device.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  15 Jan 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_PBT
#define _INC_PBT

#ifndef WM_POWERBROADCAST
#define WM_POWERBROADCAST               0x218
#endif

#define PBT_APMQUERYSUSPEND             0x0000
#define PBT_APMQUERYSTANDBY             0x0001

#define PBT_APMQUERYSUSPENDFAILED       0x0002
#define PBT_APMQUERYSTANDBYFAILED       0x0003

#define PBT_APMSUSPEND                  0x0004
#define PBT_APMSTANDBY                  0x0005

#define PBT_APMRESUMECRITICAL           0x0006
#define PBT_APMRESUMESUSPEND            0x0007
#define PBT_APMRESUMESTANDBY            0x0008

#define PBTF_APMRESUMEFROMFAILURE       0x00000001

#define PBT_APMBATTERYLOW               0x0009
#define PBT_APMPOWERSTATUSCHANGE        0x000A

#define PBT_APMOEMEVENT                 0x000B

#endif // _INC_PBT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\tools\inc\fusion.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for fusion.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __fusion_h__
#define __fusion_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAssemblyName_FWD_DEFINED__
#define __IAssemblyName_FWD_DEFINED__
typedef interface IAssemblyName IAssemblyName;
#endif 	/* __IAssemblyName_FWD_DEFINED__ */


#ifndef __IApplicationContext_FWD_DEFINED__
#define __IApplicationContext_FWD_DEFINED__
typedef interface IApplicationContext IApplicationContext;
#endif 	/* __IApplicationContext_FWD_DEFINED__ */


#ifndef __IAssembly_FWD_DEFINED__
#define __IAssembly_FWD_DEFINED__
typedef interface IAssembly IAssembly;
#endif 	/* __IAssembly_FWD_DEFINED__ */


#ifndef __IAssemblyBindSink_FWD_DEFINED__
#define __IAssemblyBindSink_FWD_DEFINED__
typedef interface IAssemblyBindSink IAssemblyBindSink;
#endif 	/* __IAssemblyBindSink_FWD_DEFINED__ */


#ifndef __IAssemblyBinding_FWD_DEFINED__
#define __IAssemblyBinding_FWD_DEFINED__
typedef interface IAssemblyBinding IAssemblyBinding;
#endif 	/* __IAssemblyBinding_FWD_DEFINED__ */


#ifndef __IFusionBindLog_FWD_DEFINED__
#define __IFusionBindLog_FWD_DEFINED__
typedef interface IFusionBindLog IFusionBindLog;
#endif 	/* __IFusionBindLog_FWD_DEFINED__ */


#ifndef __IAssemblyManifestImport_FWD_DEFINED__
#define __IAssemblyManifestImport_FWD_DEFINED__
typedef interface IAssemblyManifestImport IAssemblyManifestImport;
#endif 	/* __IAssemblyManifestImport_FWD_DEFINED__ */


#ifndef __IAssemblyModuleImport_FWD_DEFINED__
#define __IAssemblyModuleImport_FWD_DEFINED__
typedef interface IAssemblyModuleImport IAssemblyModuleImport;
#endif 	/* __IAssemblyModuleImport_FWD_DEFINED__ */


#ifndef __IAssemblyCacheItem_FWD_DEFINED__
#define __IAssemblyCacheItem_FWD_DEFINED__
typedef interface IAssemblyCacheItem IAssemblyCacheItem;
#endif 	/* __IAssemblyCacheItem_FWD_DEFINED__ */


#ifndef __IAssemblyEnum_FWD_DEFINED__
#define __IAssemblyEnum_FWD_DEFINED__
typedef interface IAssemblyEnum IAssemblyEnum;
#endif 	/* __IAssemblyEnum_FWD_DEFINED__ */


#ifndef __IAssemblyScavenger_FWD_DEFINED__
#define __IAssemblyScavenger_FWD_DEFINED__
typedef interface IAssemblyScavenger IAssemblyScavenger;
#endif 	/* __IAssemblyScavenger_FWD_DEFINED__ */


#ifndef __IAssemblyCache_FWD_DEFINED__
#define __IAssemblyCache_FWD_DEFINED__
typedef interface IAssemblyCache IAssemblyCache;
#endif 	/* __IAssemblyCache_FWD_DEFINED__ */


#ifndef __IHistoryAssembly_FWD_DEFINED__
#define __IHistoryAssembly_FWD_DEFINED__
typedef interface IHistoryAssembly IHistoryAssembly;
#endif 	/* __IHistoryAssembly_FWD_DEFINED__ */


#ifndef __IHistoryReader_FWD_DEFINED__
#define __IHistoryReader_FWD_DEFINED__
typedef interface IHistoryReader IHistoryReader;
#endif 	/* __IHistoryReader_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_fusion_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// fusion.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Fusion Interfaces.

#define STREAM_FORMAT_COMPLIB_MODULE    0
#define STREAM_FORMAT_COMPLIB_MANIFEST  1
#define STREAM_FORMAT_WIN32_MODULE      2
#define STREAM_FORMAT_WIN32_MANIFEST    4










EXTERN_C const IID IID_IAssemblyName;       
EXTERN_C const IID IID_IApplicationContext;       
EXTERN_C const IID IID_IAssembly;           
EXTERN_C const IID IID_IAssemblyBindSink;   
EXTERN_C const IID IID_IAssemblyBinding;   
EXTERN_C const IID IID_IAssemblyManifestImport;
EXTERN_C const IID IID_IAssemblyModuleImport;  
EXTERN_C const IID IID_IAssemblyCacheItem;  
EXTERN_C const IID IID_IAssemblyScavenger;      
EXTERN_C const IID IID_IAssemblyCache;      
EXTERN_C const IID IID_IHistoryAssembly;      
EXTERN_C const IID IID_IHistoryReader;      
#ifndef _LPFUSION_DEFINED
#define _LPFUSION_DEFINED
#define IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH (0x00000001)
#define QUERYASMINFO_FLAG_VALIDATE             (0x1)
#define ASSEMBLYINFO_FLAG_INSTALLED (0x00000001)
#define ASSEMBLYINFO_FLAG_PAYLOADRESIDENT (0x00000002)
typedef struct _ASSEMBLY_INFO
    {
    ULONG cbAssemblyInfo;
    DWORD dwAssemblyFlags;
    ULARGE_INTEGER uliAssemblySizeInKB;
    LPWSTR pszCurrentAssemblyPathBuf;
    ULONG cchBuf;
    } 	ASSEMBLY_INFO;

#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED (1)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE (2)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED (3)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING (4)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED (1)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED (2)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED (3)


extern RPC_IF_HANDLE __MIDL_itf_fusion_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusion_0000_v0_0_s_ifspec;

#ifndef __IAssemblyName_INTERFACE_DEFINED__
#define __IAssemblyName_INTERFACE_DEFINED__

/* interface IAssemblyName */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyName *LPASSEMBLYNAME;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0001
    {	ASM_NAME_PUBLIC_KEY	= 0,
	ASM_NAME_PUBLIC_KEY_TOKEN	= ASM_NAME_PUBLIC_KEY + 1,
	ASM_NAME_HASH_VALUE	= ASM_NAME_PUBLIC_KEY_TOKEN + 1,
	ASM_NAME_NAME	= ASM_NAME_HASH_VALUE + 1,
	ASM_NAME_MAJOR_VERSION	= ASM_NAME_NAME + 1,
	ASM_NAME_MINOR_VERSION	= ASM_NAME_MAJOR_VERSION + 1,
	ASM_NAME_BUILD_NUMBER	= ASM_NAME_MINOR_VERSION + 1,
	ASM_NAME_REVISION_NUMBER	= ASM_NAME_BUILD_NUMBER + 1,
	ASM_NAME_CULTURE	= ASM_NAME_REVISION_NUMBER + 1,
	ASM_NAME_PROCESSOR_ID_ARRAY	= ASM_NAME_CULTURE + 1,
	ASM_NAME_OSINFO_ARRAY	= ASM_NAME_PROCESSOR_ID_ARRAY + 1,
	ASM_NAME_HASH_ALGID	= ASM_NAME_OSINFO_ARRAY + 1,
	ASM_NAME_ALIAS	= ASM_NAME_HASH_ALGID + 1,
	ASM_NAME_CODEBASE_URL	= ASM_NAME_ALIAS + 1,
	ASM_NAME_CODEBASE_LASTMOD	= ASM_NAME_CODEBASE_URL + 1,
	ASM_NAME_NULL_PUBLIC_KEY	= ASM_NAME_CODEBASE_LASTMOD + 1,
	ASM_NAME_NULL_PUBLIC_KEY_TOKEN	= ASM_NAME_NULL_PUBLIC_KEY + 1,
	ASM_NAME_CUSTOM	= ASM_NAME_NULL_PUBLIC_KEY_TOKEN + 1,
	ASM_NAME_NULL_CUSTOM	= ASM_NAME_CUSTOM + 1,
	ASM_NAME_MVID	= ASM_NAME_NULL_CUSTOM + 1,
	ASM_NAME_32_BIT_ONLY	= ASM_NAME_MVID + 1,
	ASM_NAME_MAX_PARAMS	= ASM_NAME_32_BIT_ONLY + 1
    } 	ASM_NAME;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0002
    {	ASM_BINDF_FORCE_CACHE_INSTALL	= 0x1,
	ASM_BINDF_RFS_INTEGRITY_CHECK	= 0x2,
	ASM_BINDF_RFS_MODULE_CHECK	= 0x4,
	ASM_BINDF_BINPATH_PROBE_ONLY	= 0x8,
	ASM_BINDF_SHARED_BINPATH_HINT	= 0x10
    } 	ASM_BIND_FLAGS;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0003
    {	ASM_DISPLAYF_VERSION	= 0x1,
	ASM_DISPLAYF_CULTURE	= 0x2,
	ASM_DISPLAYF_PUBLIC_KEY_TOKEN	= 0x4,
	ASM_DISPLAYF_PUBLIC_KEY	= 0x8,
	ASM_DISPLAYF_CUSTOM	= 0x10,
	ASM_DISPLAYF_PROCESSORARCHITECTURE	= 0x20,
	ASM_DISPLAYF_LANGUAGEID	= 0x40
    } 	ASM_DISPLAY_FLAGS;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0004
    {	ASM_CMPF_NAME	= 0x1,
	ASM_CMPF_MAJOR_VERSION	= 0x2,
	ASM_CMPF_MINOR_VERSION	= 0x4,
	ASM_CMPF_BUILD_NUMBER	= 0x8,
	ASM_CMPF_REVISION_NUMBER	= 0x10,
	ASM_CMPF_PUBLIC_KEY_TOKEN	= 0x20,
	ASM_CMPF_CULTURE	= 0x40,
	ASM_CMPF_CUSTOM	= 0x80,
	ASM_CMPF_ALL	= ASM_CMPF_NAME | ASM_CMPF_MAJOR_VERSION | ASM_CMPF_MINOR_VERSION | ASM_CMPF_REVISION_NUMBER | ASM_CMPF_BUILD_NUMBER | ASM_CMPF_PUBLIC_KEY_TOKEN | ASM_CMPF_CULTURE | ASM_CMPF_CUSTOM,
	ASM_CMPF_DEFAULT	= 0x100
    } 	ASM_CMP_FLAGS;


EXTERN_C const IID IID_IAssemblyName;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")
    IAssemblyName : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ DWORD PropertyId,
            /* [out] */ LPVOID pvProperty,
            /* [out][in] */ LPDWORD pcbProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finalize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [out] */ LPOLESTR szDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName,
            /* [in] */ DWORD dwDisplayFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToObject( 
            /* [in] */ REFIID refIID,
            /* [in] */ IAssemblyBindSink *pAsmBindSink,
            /* [in] */ IApplicationContext *pApplicationContext,
            /* [in] */ LPCOLESTR szCodeBase,
            /* [in] */ LONGLONG llFlags,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD cbReserved,
            /* [out] */ LPVOID *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out][in] */ LPDWORD lpcwBuffer,
            /* [out] */ WCHAR *pwzName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ LPDWORD pdwVersionHi,
            /* [out] */ LPDWORD pdwVersionLow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ IAssemblyName *pName,
            /* [in] */ DWORD dwCmpFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAssemblyName **pName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyNameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyName * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyName * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IAssemblyName * This,
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IAssemblyName * This,
            /* [in] */ DWORD PropertyId,
            /* [out] */ LPVOID pvProperty,
            /* [out][in] */ LPDWORD pcbProperty);
        
        HRESULT ( STDMETHODCALLTYPE *Finalize )( 
            IAssemblyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IAssemblyName * This,
            /* [out] */ LPOLESTR szDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName,
            /* [in] */ DWORD dwDisplayFlags);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            IAssemblyName * This,
            /* [in] */ REFIID refIID,
            /* [in] */ IAssemblyBindSink *pAsmBindSink,
            /* [in] */ IApplicationContext *pApplicationContext,
            /* [in] */ LPCOLESTR szCodeBase,
            /* [in] */ LONGLONG llFlags,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD cbReserved,
            /* [out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IAssemblyName * This,
            /* [out][in] */ LPDWORD lpcwBuffer,
            /* [out] */ WCHAR *pwzName);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            IAssemblyName * This,
            /* [out] */ LPDWORD pdwVersionHi,
            /* [out] */ LPDWORD pdwVersionLow);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqual )( 
            IAssemblyName * This,
            /* [in] */ IAssemblyName *pName,
            /* [in] */ DWORD dwCmpFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyName * This,
            /* [out] */ IAssemblyName **pName);
        
        END_INTERFACE
    } IAssemblyNameVtbl;

    interface IAssemblyName
    {
        CONST_VTBL struct IAssemblyNameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyName_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyName_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyName_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyName_SetProperty(This,PropertyId,pvProperty,cbProperty)	\
    (This)->lpVtbl -> SetProperty(This,PropertyId,pvProperty,cbProperty)

#define IAssemblyName_GetProperty(This,PropertyId,pvProperty,pcbProperty)	\
    (This)->lpVtbl -> GetProperty(This,PropertyId,pvProperty,pcbProperty)

#define IAssemblyName_Finalize(This)	\
    (This)->lpVtbl -> Finalize(This)

#define IAssemblyName_GetDisplayName(This,szDisplayName,pccDisplayName,dwDisplayFlags)	\
    (This)->lpVtbl -> GetDisplayName(This,szDisplayName,pccDisplayName,dwDisplayFlags)

#define IAssemblyName_BindToObject(This,refIID,pAsmBindSink,pApplicationContext,szCodeBase,llFlags,pvReserved,cbReserved,ppv)	\
    (This)->lpVtbl -> BindToObject(This,refIID,pAsmBindSink,pApplicationContext,szCodeBase,llFlags,pvReserved,cbReserved,ppv)

#define IAssemblyName_GetName(This,lpcwBuffer,pwzName)	\
    (This)->lpVtbl -> GetName(This,lpcwBuffer,pwzName)

#define IAssemblyName_GetVersion(This,pdwVersionHi,pdwVersionLow)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersionHi,pdwVersionLow)

#define IAssemblyName_IsEqual(This,pName,dwCmpFlags)	\
    (This)->lpVtbl -> IsEqual(This,pName,dwCmpFlags)

#define IAssemblyName_Clone(This,pName)	\
    (This)->lpVtbl -> Clone(This,pName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyName_SetProperty_Proxy( 
    IAssemblyName * This,
    /* [in] */ DWORD PropertyId,
    /* [in] */ LPVOID pvProperty,
    /* [in] */ DWORD cbProperty);


void __RPC_STUB IAssemblyName_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetProperty_Proxy( 
    IAssemblyName * This,
    /* [in] */ DWORD PropertyId,
    /* [out] */ LPVOID pvProperty,
    /* [out][in] */ LPDWORD pcbProperty);


void __RPC_STUB IAssemblyName_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_Finalize_Proxy( 
    IAssemblyName * This);


void __RPC_STUB IAssemblyName_Finalize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetDisplayName_Proxy( 
    IAssemblyName * This,
    /* [out] */ LPOLESTR szDisplayName,
    /* [out][in] */ LPDWORD pccDisplayName,
    /* [in] */ DWORD dwDisplayFlags);


void __RPC_STUB IAssemblyName_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_BindToObject_Proxy( 
    IAssemblyName * This,
    /* [in] */ REFIID refIID,
    /* [in] */ IAssemblyBindSink *pAsmBindSink,
    /* [in] */ IApplicationContext *pApplicationContext,
    /* [in] */ LPCOLESTR szCodeBase,
    /* [in] */ LONGLONG llFlags,
    /* [in] */ LPVOID pvReserved,
    /* [in] */ DWORD cbReserved,
    /* [out] */ LPVOID *ppv);


void __RPC_STUB IAssemblyName_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetName_Proxy( 
    IAssemblyName * This,
    /* [out][in] */ LPDWORD lpcwBuffer,
    /* [out] */ WCHAR *pwzName);


void __RPC_STUB IAssemblyName_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetVersion_Proxy( 
    IAssemblyName * This,
    /* [out] */ LPDWORD pdwVersionHi,
    /* [out] */ LPDWORD pdwVersionLow);


void __RPC_STUB IAssemblyName_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_IsEqual_Proxy( 
    IAssemblyName * This,
    /* [in] */ IAssemblyName *pName,
    /* [in] */ DWORD dwCmpFlags);


void __RPC_STUB IAssemblyName_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_Clone_Proxy( 
    IAssemblyName * This,
    /* [out] */ IAssemblyName **pName);


void __RPC_STUB IAssemblyName_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyName_INTERFACE_DEFINED__ */


#ifndef __IApplicationContext_INTERFACE_DEFINED__
#define __IApplicationContext_INTERFACE_DEFINED__

/* interface IApplicationContext */
/* [unique][uuid][object][local] */ 

// App context configuration variables
#define ACTAG_APP_BASE_URL            L"APPBASE"
#define ACTAG_MACHINE_CONFIG          L"MACHINE_CONFIG"
#define ACTAG_APP_PRIVATE_BINPATH     L"PRIVATE_BINPATH"
#define ACTAG_APP_SHARED_BINPATH      L"SHARED_BINPATH"
#define ACTAG_APP_SNAPSHOT_ID         L"SNAPSHOT_ID"
#define ACTAG_APP_CONFIG_FILE         L"APP_CONFIG_FILE"
#define ACTAG_APP_ID                  L"APPLICATION_ID"
#define ACTAG_APP_SHADOW_COPY_DIRS    L"SHADOW_COPY_DIRS"
#define ACTAG_APP_DYNAMIC_BASE        L"DYNAMIC_BASE"
#define ACTAG_APP_CACHE_BASE          L"CACHE_BASE"
#define ACTAG_APP_NAME                L"APP_NAME"
#define ACTAG_DEV_PATH                L"DEV_PATH"
// App context flag overrides
#define ACTAG_FORCE_CACHE_INSTALL     L"FORCE_CACHE_INSTALL"
#define ACTAG_RFS_INTEGRITY_CHECK     L"RFS_INTEGRITY_CHECK"
#define ACTAG_RFS_MODULE_CHECK        L"RFS_MODULE_CHECK"
#define ACTAG_BINPATH_PROBE_ONLY      L"BINPATH_PROBE_ONLY"
typedef /* [unique] */ IApplicationContext *LPAPPLICATIONCONTEXT;

typedef /* [public] */ 
enum __MIDL_IApplicationContext_0001
    {	APP_CTX_FLAGS_INTERFACE	= 0x1
    } 	APP_FLAGS;


EXTERN_C const IID IID_IApplicationContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7c23ff90-33af-11d3-95da-00a024a85b51")
    IApplicationContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetContextNameObject( 
            /* [in] */ LPASSEMBLYNAME pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContextNameObject( 
            /* [out] */ LPASSEMBLYNAME *ppName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ LPCOLESTR szName,
            /* [in] */ LPVOID pvValue,
            /* [in] */ DWORD cbValue,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ LPCOLESTR szName,
            /* [out] */ LPVOID pvValue,
            /* [out][in] */ LPDWORD pcbValue,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDynamicDirectory( 
            /* [out] */ LPWSTR wzDynamicDir,
            /* [out][in] */ LPDWORD pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppCacheDirectory( 
            /* [out] */ LPWSTR wzAppCacheDir,
            /* [out][in] */ LPDWORD pdwSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IApplicationContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IApplicationContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IApplicationContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetContextNameObject )( 
            IApplicationContext * This,
            /* [in] */ LPASSEMBLYNAME pName);
        
        HRESULT ( STDMETHODCALLTYPE *GetContextNameObject )( 
            IApplicationContext * This,
            /* [out] */ LPASSEMBLYNAME *ppName);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            IApplicationContext * This,
            /* [in] */ LPCOLESTR szName,
            /* [in] */ LPVOID pvValue,
            /* [in] */ DWORD cbValue,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IApplicationContext * This,
            /* [in] */ LPCOLESTR szName,
            /* [out] */ LPVOID pvValue,
            /* [out][in] */ LPDWORD pcbValue,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDynamicDirectory )( 
            IApplicationContext * This,
            /* [out] */ LPWSTR wzDynamicDir,
            /* [out][in] */ LPDWORD pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppCacheDirectory )( 
            IApplicationContext * This,
            /* [out] */ LPWSTR wzAppCacheDir,
            /* [out][in] */ LPDWORD pdwSize);
        
        END_INTERFACE
    } IApplicationContextVtbl;

    interface IApplicationContext
    {
        CONST_VTBL struct IApplicationContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApplicationContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IApplicationContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IApplicationContext_SetContextNameObject(This,pName)	\
    (This)->lpVtbl -> SetContextNameObject(This,pName)

#define IApplicationContext_GetContextNameObject(This,ppName)	\
    (This)->lpVtbl -> GetContextNameObject(This,ppName)

#define IApplicationContext_Set(This,szName,pvValue,cbValue,dwFlags)	\
    (This)->lpVtbl -> Set(This,szName,pvValue,cbValue,dwFlags)

#define IApplicationContext_Get(This,szName,pvValue,pcbValue,dwFlags)	\
    (This)->lpVtbl -> Get(This,szName,pvValue,pcbValue,dwFlags)

#define IApplicationContext_GetDynamicDirectory(This,wzDynamicDir,pdwSize)	\
    (This)->lpVtbl -> GetDynamicDirectory(This,wzDynamicDir,pdwSize)

#define IApplicationContext_GetAppCacheDirectory(This,wzAppCacheDir,pdwSize)	\
    (This)->lpVtbl -> GetAppCacheDirectory(This,wzAppCacheDir,pdwSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IApplicationContext_SetContextNameObject_Proxy( 
    IApplicationContext * This,
    /* [in] */ LPASSEMBLYNAME pName);


void __RPC_STUB IApplicationContext_SetContextNameObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_GetContextNameObject_Proxy( 
    IApplicationContext * This,
    /* [out] */ LPASSEMBLYNAME *ppName);


void __RPC_STUB IApplicationContext_GetContextNameObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_Set_Proxy( 
    IApplicationContext * This,
    /* [in] */ LPCOLESTR szName,
    /* [in] */ LPVOID pvValue,
    /* [in] */ DWORD cbValue,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IApplicationContext_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_Get_Proxy( 
    IApplicationContext * This,
    /* [in] */ LPCOLESTR szName,
    /* [out] */ LPVOID pvValue,
    /* [out][in] */ LPDWORD pcbValue,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IApplicationContext_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_GetDynamicDirectory_Proxy( 
    IApplicationContext * This,
    /* [out] */ LPWSTR wzDynamicDir,
    /* [out][in] */ LPDWORD pdwSize);


void __RPC_STUB IApplicationContext_GetDynamicDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_GetAppCacheDirectory_Proxy( 
    IApplicationContext * This,
    /* [out] */ LPWSTR wzAppCacheDir,
    /* [out][in] */ LPDWORD pdwSize);


void __RPC_STUB IApplicationContext_GetAppCacheDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IApplicationContext_INTERFACE_DEFINED__ */


#ifndef __IAssembly_INTERFACE_DEFINED__
#define __IAssembly_INTERFACE_DEFINED__

/* interface IAssembly */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssembly *LPASSEMBLY;

typedef /* [public][public] */ 
enum __MIDL_IAssembly_0001
    {	ASMLOC_UNKNOWN	= 0,
	ASMLOC_GAC	= ASMLOC_UNKNOWN + 1,
	ASMLOC_DOWNLOAD_CACHE	= ASMLOC_GAC + 1,
	ASMLOC_RUN_FROM_SOURCE	= ASMLOC_DOWNLOAD_CACHE + 1
    } 	ASM_LOCATION;


EXTERN_C const IID IID_IAssembly;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ff08d7d4-04c2-11d3-94aa-00c04fc308ff")
    IAssembly : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyNameDef( 
            /* [out] */ IAssemblyName **ppAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextAssemblyNameRef( 
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyName **ppAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextAssemblyModule( 
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyModuleImport **ppModImport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModuleByName( 
            /* [in] */ LPCOLESTR szModuleName,
            /* [out] */ IAssemblyModuleImport **ppModImport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManifestModulePath( 
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyPath( 
            /* [size_is][out] */ LPOLESTR pStr,
            /* [out][in] */ LPDWORD lpcwBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyLocation( 
            /* [out] */ ASM_LOCATION *pAsmLocation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssembly * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssembly * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssembly * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyNameDef )( 
            IAssembly * This,
            /* [out] */ IAssemblyName **ppAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssemblyNameRef )( 
            IAssembly * This,
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyName **ppAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssemblyModule )( 
            IAssembly * This,
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyModuleImport **ppModImport);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleByName )( 
            IAssembly * This,
            /* [in] */ LPCOLESTR szModuleName,
            /* [out] */ IAssemblyModuleImport **ppModImport);
        
        HRESULT ( STDMETHODCALLTYPE *GetManifestModulePath )( 
            IAssembly * This,
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyPath )( 
            IAssembly * This,
            /* [size_is][out] */ LPOLESTR pStr,
            /* [out][in] */ LPDWORD lpcwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyLocation )( 
            IAssembly * This,
            /* [out] */ ASM_LOCATION *pAsmLocation);
        
        END_INTERFACE
    } IAssemblyVtbl;

    interface IAssembly
    {
        CONST_VTBL struct IAssemblyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssembly_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssembly_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssembly_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssembly_GetAssemblyNameDef(This,ppAssemblyName)	\
    (This)->lpVtbl -> GetAssemblyNameDef(This,ppAssemblyName)

#define IAssembly_GetNextAssemblyNameRef(This,nIndex,ppAssemblyName)	\
    (This)->lpVtbl -> GetNextAssemblyNameRef(This,nIndex,ppAssemblyName)

#define IAssembly_GetNextAssemblyModule(This,nIndex,ppModImport)	\
    (This)->lpVtbl -> GetNextAssemblyModule(This,nIndex,ppModImport)

#define IAssembly_GetModuleByName(This,szModuleName,ppModImport)	\
    (This)->lpVtbl -> GetModuleByName(This,szModuleName,ppModImport)

#define IAssembly_GetManifestModulePath(This,szModulePath,pccModulePath)	\
    (This)->lpVtbl -> GetManifestModulePath(This,szModulePath,pccModulePath)

#define IAssembly_GetAssemblyPath(This,pStr,lpcwBuffer)	\
    (This)->lpVtbl -> GetAssemblyPath(This,pStr,lpcwBuffer)

#define IAssembly_GetAssemblyLocation(This,pAsmLocation)	\
    (This)->lpVtbl -> GetAssemblyLocation(This,pAsmLocation)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssembly_GetAssemblyNameDef_Proxy( 
    IAssembly * This,
    /* [out] */ IAssemblyName **ppAssemblyName);


void __RPC_STUB IAssembly_GetAssemblyNameDef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetNextAssemblyNameRef_Proxy( 
    IAssembly * This,
    /* [in] */ DWORD nIndex,
    /* [out] */ IAssemblyName **ppAssemblyName);


void __RPC_STUB IAssembly_GetNextAssemblyNameRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetNextAssemblyModule_Proxy( 
    IAssembly * This,
    /* [in] */ DWORD nIndex,
    /* [out] */ IAssemblyModuleImport **ppModImport);


void __RPC_STUB IAssembly_GetNextAssemblyModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetModuleByName_Proxy( 
    IAssembly * This,
    /* [in] */ LPCOLESTR szModuleName,
    /* [out] */ IAssemblyModuleImport **ppModImport);


void __RPC_STUB IAssembly_GetModuleByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetManifestModulePath_Proxy( 
    IAssembly * This,
    /* [size_is][out] */ LPOLESTR szModulePath,
    /* [out][in] */ LPDWORD pccModulePath);


void __RPC_STUB IAssembly_GetManifestModulePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetAssemblyPath_Proxy( 
    IAssembly * This,
    /* [size_is][out] */ LPOLESTR pStr,
    /* [out][in] */ LPDWORD lpcwBuffer);


void __RPC_STUB IAssembly_GetAssemblyPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetAssemblyLocation_Proxy( 
    IAssembly * This,
    /* [out] */ ASM_LOCATION *pAsmLocation);


void __RPC_STUB IAssembly_GetAssemblyLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssembly_INTERFACE_DEFINED__ */


#ifndef __IAssemblyBindSink_INTERFACE_DEFINED__
#define __IAssemblyBindSink_INTERFACE_DEFINED__

/* interface IAssemblyBindSink */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyBindSink *LPASSEMBLY_BIND_SINK;

typedef /* [public] */ 
enum __MIDL_IAssemblyBindSink_0001
    {	ASM_NOTIFICATION_START	= 0,
	ASM_NOTIFICATION_PROGRESS	= ASM_NOTIFICATION_START + 1,
	ASM_NOTIFICATION_SUSPEND	= ASM_NOTIFICATION_PROGRESS + 1,
	ASM_NOTIFICATION_ATTEMPT_NEXT_CODEBASE	= ASM_NOTIFICATION_SUSPEND + 1,
	ASM_NOTIFICATION_BIND_LOG	= ASM_NOTIFICATION_ATTEMPT_NEXT_CODEBASE + 1,
	ASM_NOTIFICATION_DONE	= ASM_NOTIFICATION_BIND_LOG + 1
    } 	ASM_NOTIFICATION;


EXTERN_C const IID IID_IAssemblyBindSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("af0bc960-0b9a-11d3-95ca-00a024a85b51")
    IAssemblyBindSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ DWORD dwNotification,
            /* [in] */ HRESULT hrNotification,
            /* [in] */ LPCWSTR szNotification,
            /* [in] */ DWORD dwProgress,
            /* [in] */ DWORD dwProgressMax,
            /* [in] */ IUnknown *pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyBindSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyBindSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyBindSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyBindSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            IAssemblyBindSink * This,
            /* [in] */ DWORD dwNotification,
            /* [in] */ HRESULT hrNotification,
            /* [in] */ LPCWSTR szNotification,
            /* [in] */ DWORD dwProgress,
            /* [in] */ DWORD dwProgressMax,
            /* [in] */ IUnknown *pUnk);
        
        END_INTERFACE
    } IAssemblyBindSinkVtbl;

    interface IAssemblyBindSink
    {
        CONST_VTBL struct IAssemblyBindSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyBindSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyBindSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyBindSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyBindSink_OnProgress(This,dwNotification,hrNotification,szNotification,dwProgress,dwProgressMax,pUnk)	\
    (This)->lpVtbl -> OnProgress(This,dwNotification,hrNotification,szNotification,dwProgress,dwProgressMax,pUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyBindSink_OnProgress_Proxy( 
    IAssemblyBindSink * This,
    /* [in] */ DWORD dwNotification,
    /* [in] */ HRESULT hrNotification,
    /* [in] */ LPCWSTR szNotification,
    /* [in] */ DWORD dwProgress,
    /* [in] */ DWORD dwProgressMax,
    /* [in] */ IUnknown *pUnk);


void __RPC_STUB IAssemblyBindSink_OnProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyBindSink_INTERFACE_DEFINED__ */


#ifndef __IAssemblyBinding_INTERFACE_DEFINED__
#define __IAssemblyBinding_INTERFACE_DEFINED__

/* interface IAssemblyBinding */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyBinding *LPASSEMBLY_BINDINDING;


EXTERN_C const IID IID_IAssemblyBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cfe52a80-12bd-11d3-95ca-00a024a85b51")
    IAssemblyBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Control( 
            /* [in] */ HRESULT hrControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoDefaultUI( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyBinding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Control )( 
            IAssemblyBinding * This,
            /* [in] */ HRESULT hrControl);
        
        HRESULT ( STDMETHODCALLTYPE *DoDefaultUI )( 
            IAssemblyBinding * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IAssemblyBindingVtbl;

    interface IAssemblyBinding
    {
        CONST_VTBL struct IAssemblyBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyBinding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyBinding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyBinding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyBinding_Control(This,hrControl)	\
    (This)->lpVtbl -> Control(This,hrControl)

#define IAssemblyBinding_DoDefaultUI(This,hWnd,dwFlags)	\
    (This)->lpVtbl -> DoDefaultUI(This,hWnd,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyBinding_Control_Proxy( 
    IAssemblyBinding * This,
    /* [in] */ HRESULT hrControl);


void __RPC_STUB IAssemblyBinding_Control_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyBinding_DoDefaultUI_Proxy( 
    IAssemblyBinding * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAssemblyBinding_DoDefaultUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyBinding_INTERFACE_DEFINED__ */


#ifndef __IFusionBindLog_INTERFACE_DEFINED__
#define __IFusionBindLog_INTERFACE_DEFINED__

/* interface IFusionBindLog */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IFusionBindLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("67E9F87D-8B8A-4a90-9D3E-85ED5B2DCC83")
    IFusionBindLog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResultCode( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBindLog( 
            /* [in] */ DWORD dwDetailLevel,
            /* [out] */ LPSTR pszDebugLog,
            /* [out][in] */ DWORD *pcbDebugLog) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFusionBindLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFusionBindLog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFusionBindLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFusionBindLog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultCode )( 
            IFusionBindLog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindLog )( 
            IFusionBindLog * This,
            /* [in] */ DWORD dwDetailLevel,
            /* [out] */ LPSTR pszDebugLog,
            /* [out][in] */ DWORD *pcbDebugLog);
        
        END_INTERFACE
    } IFusionBindLogVtbl;

    interface IFusionBindLog
    {
        CONST_VTBL struct IFusionBindLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFusionBindLog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFusionBindLog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFusionBindLog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFusionBindLog_GetResultCode(This)	\
    (This)->lpVtbl -> GetResultCode(This)

#define IFusionBindLog_GetBindLog(This,dwDetailLevel,pszDebugLog,pcbDebugLog)	\
    (This)->lpVtbl -> GetBindLog(This,dwDetailLevel,pszDebugLog,pcbDebugLog)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFusionBindLog_GetResultCode_Proxy( 
    IFusionBindLog * This);


void __RPC_STUB IFusionBindLog_GetResultCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFusionBindLog_GetBindLog_Proxy( 
    IFusionBindLog * This,
    /* [in] */ DWORD dwDetailLevel,
    /* [out] */ LPSTR pszDebugLog,
    /* [out][in] */ DWORD *pcbDebugLog);


void __RPC_STUB IFusionBindLog_GetBindLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFusionBindLog_INTERFACE_DEFINED__ */


#ifndef __IAssemblyManifestImport_INTERFACE_DEFINED__
#define __IAssemblyManifestImport_INTERFACE_DEFINED__

/* interface IAssemblyManifestImport */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyManifestImport *LPASSEMBLY_MANIFEST_IMPORT;


EXTERN_C const IID IID_IAssemblyManifestImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("de9a68ba-0fa2-11d3-94aa-00c04fc308ff")
    IAssemblyManifestImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyNameDef( 
            /* [out] */ IAssemblyName **ppAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextAssemblyNameRef( 
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyName **ppAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextAssemblyModule( 
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyModuleImport **ppImport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModuleByName( 
            /* [in] */ LPCOLESTR szModuleName,
            /* [out] */ IAssemblyModuleImport **ppModImport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManifestModulePath( 
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyManifestImportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyManifestImport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyManifestImport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyManifestImport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyNameDef )( 
            IAssemblyManifestImport * This,
            /* [out] */ IAssemblyName **ppAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssemblyNameRef )( 
            IAssemblyManifestImport * This,
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyName **ppAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssemblyModule )( 
            IAssemblyManifestImport * This,
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyModuleImport **ppImport);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleByName )( 
            IAssemblyManifestImport * This,
            /* [in] */ LPCOLESTR szModuleName,
            /* [out] */ IAssemblyModuleImport **ppModImport);
        
        HRESULT ( STDMETHODCALLTYPE *GetManifestModulePath )( 
            IAssemblyManifestImport * This,
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath);
        
        END_INTERFACE
    } IAssemblyManifestImportVtbl;

    interface IAssemblyManifestImport
    {
        CONST_VTBL struct IAssemblyManifestImportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyManifestImport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyManifestImport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyManifestImport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyManifestImport_GetAssemblyNameDef(This,ppAssemblyName)	\
    (This)->lpVtbl -> GetAssemblyNameDef(This,ppAssemblyName)

#define IAssemblyManifestImport_GetNextAssemblyNameRef(This,nIndex,ppAssemblyName)	\
    (This)->lpVtbl -> GetNextAssemblyNameRef(This,nIndex,ppAssemblyName)

#define IAssemblyManifestImport_GetNextAssemblyModule(This,nIndex,ppImport)	\
    (This)->lpVtbl -> GetNextAssemblyModule(This,nIndex,ppImport)

#define IAssemblyManifestImport_GetModuleByName(This,szModuleName,ppModImport)	\
    (This)->lpVtbl -> GetModuleByName(This,szModuleName,ppModImport)

#define IAssemblyManifestImport_GetManifestModulePath(This,szModulePath,pccModulePath)	\
    (This)->lpVtbl -> GetManifestModulePath(This,szModulePath,pccModulePath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetAssemblyNameDef_Proxy( 
    IAssemblyManifestImport * This,
    /* [out] */ IAssemblyName **ppAssemblyName);


void __RPC_STUB IAssemblyManifestImport_GetAssemblyNameDef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetNextAssemblyNameRef_Proxy( 
    IAssemblyManifestImport * This,
    /* [in] */ DWORD nIndex,
    /* [out] */ IAssemblyName **ppAssemblyName);


void __RPC_STUB IAssemblyManifestImport_GetNextAssemblyNameRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetNextAssemblyModule_Proxy( 
    IAssemblyManifestImport * This,
    /* [in] */ DWORD nIndex,
    /* [out] */ IAssemblyModuleImport **ppImport);


void __RPC_STUB IAssemblyManifestImport_GetNextAssemblyModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetModuleByName_Proxy( 
    IAssemblyManifestImport * This,
    /* [in] */ LPCOLESTR szModuleName,
    /* [out] */ IAssemblyModuleImport **ppModImport);


void __RPC_STUB IAssemblyManifestImport_GetModuleByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetManifestModulePath_Proxy( 
    IAssemblyManifestImport * This,
    /* [size_is][out] */ LPOLESTR szModulePath,
    /* [out][in] */ LPDWORD pccModulePath);


void __RPC_STUB IAssemblyManifestImport_GetManifestModulePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyManifestImport_INTERFACE_DEFINED__ */


#ifndef __IAssemblyModuleImport_INTERFACE_DEFINED__
#define __IAssemblyModuleImport_INTERFACE_DEFINED__

/* interface IAssemblyModuleImport */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyModuleImport *LPASSEMBLY_MODULE_IMPORT;


EXTERN_C const IID IID_IAssemblyModuleImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("da0cd4b0-1117-11d3-95ca-00a024a85b51")
    IAssemblyModuleImport : public IStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModuleName( 
            /* [size_is][out] */ LPOLESTR szModuleName,
            /* [out][in] */ LPDWORD pccModuleName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHashAlgId( 
            /* [out] */ LPDWORD pdwHashAlgId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHashValue( 
            /* [size_is][out] */ BYTE *pbHashValue,
            /* [out][in] */ LPDWORD pcbHashValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ LPDWORD pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModulePath( 
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsAvailable( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToObject( 
            /* [in] */ IAssemblyBindSink *pBindSink,
            /* [in] */ IApplicationContext *pAppCtx,
            /* [in] */ LONGLONG llFlags,
            /* [out] */ LPVOID *ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyModuleImportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyModuleImport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyModuleImport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyModuleImport * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IAssemblyModuleImport * This,
            /* [length_is][size_is][out] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            IAssemblyModuleImport * This,
            /* [size_is][in] */ const void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IAssemblyModuleImport * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            IAssemblyModuleImport * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            IAssemblyModuleImport * This,
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER *pcbRead,
            /* [out] */ ULARGE_INTEGER *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IAssemblyModuleImport * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            IAssemblyModuleImport * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockRegion )( 
            IAssemblyModuleImport * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRegion )( 
            IAssemblyModuleImport * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            IAssemblyModuleImport * This,
            /* [out] */ STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyModuleImport * This,
            /* [out] */ IStream **ppstm);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleName )( 
            IAssemblyModuleImport * This,
            /* [size_is][out] */ LPOLESTR szModuleName,
            /* [out][in] */ LPDWORD pccModuleName);
        
        HRESULT ( STDMETHODCALLTYPE *GetHashAlgId )( 
            IAssemblyModuleImport * This,
            /* [out] */ LPDWORD pdwHashAlgId);
        
        HRESULT ( STDMETHODCALLTYPE *GetHashValue )( 
            IAssemblyModuleImport * This,
            /* [size_is][out] */ BYTE *pbHashValue,
            /* [out][in] */ LPDWORD pcbHashValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IAssemblyModuleImport * This,
            /* [out] */ LPDWORD pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetModulePath )( 
            IAssemblyModuleImport * This,
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath);
        
        BOOL ( STDMETHODCALLTYPE *IsAvailable )( 
            IAssemblyModuleImport * This);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            IAssemblyModuleImport * This,
            /* [in] */ IAssemblyBindSink *pBindSink,
            /* [in] */ IApplicationContext *pAppCtx,
            /* [in] */ LONGLONG llFlags,
            /* [out] */ LPVOID *ppv);
        
        END_INTERFACE
    } IAssemblyModuleImportVtbl;

    interface IAssemblyModuleImport
    {
        CONST_VTBL struct IAssemblyModuleImportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyModuleImport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyModuleImport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyModuleImport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyModuleImport_Read(This,pv,cb,pcbRead)	\
    (This)->lpVtbl -> Read(This,pv,cb,pcbRead)

#define IAssemblyModuleImport_Write(This,pv,cb,pcbWritten)	\
    (This)->lpVtbl -> Write(This,pv,cb,pcbWritten)


#define IAssemblyModuleImport_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition)

#define IAssemblyModuleImport_SetSize(This,libNewSize)	\
    (This)->lpVtbl -> SetSize(This,libNewSize)

#define IAssemblyModuleImport_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten)

#define IAssemblyModuleImport_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define IAssemblyModuleImport_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define IAssemblyModuleImport_LockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType)

#define IAssemblyModuleImport_UnlockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType)

#define IAssemblyModuleImport_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#define IAssemblyModuleImport_Clone(This,ppstm)	\
    (This)->lpVtbl -> Clone(This,ppstm)


#define IAssemblyModuleImport_GetModuleName(This,szModuleName,pccModuleName)	\
    (This)->lpVtbl -> GetModuleName(This,szModuleName,pccModuleName)

#define IAssemblyModuleImport_GetHashAlgId(This,pdwHashAlgId)	\
    (This)->lpVtbl -> GetHashAlgId(This,pdwHashAlgId)

#define IAssemblyModuleImport_GetHashValue(This,pbHashValue,pcbHashValue)	\
    (This)->lpVtbl -> GetHashValue(This,pbHashValue,pcbHashValue)

#define IAssemblyModuleImport_GetFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetFlags(This,pdwFlags)

#define IAssemblyModuleImport_GetModulePath(This,szModulePath,pccModulePath)	\
    (This)->lpVtbl -> GetModulePath(This,szModulePath,pccModulePath)

#define IAssemblyModuleImport_IsAvailable(This)	\
    (This)->lpVtbl -> IsAvailable(This)

#define IAssemblyModuleImport_BindToObject(This,pBindSink,pAppCtx,llFlags,ppv)	\
    (This)->lpVtbl -> BindToObject(This,pBindSink,pAppCtx,llFlags,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_GetModuleName_Proxy( 
    IAssemblyModuleImport * This,
    /* [size_is][out] */ LPOLESTR szModuleName,
    /* [out][in] */ LPDWORD pccModuleName);


void __RPC_STUB IAssemblyModuleImport_GetModuleName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_GetHashAlgId_Proxy( 
    IAssemblyModuleImport * This,
    /* [out] */ LPDWORD pdwHashAlgId);


void __RPC_STUB IAssemblyModuleImport_GetHashAlgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_GetHashValue_Proxy( 
    IAssemblyModuleImport * This,
    /* [size_is][out] */ BYTE *pbHashValue,
    /* [out][in] */ LPDWORD pcbHashValue);


void __RPC_STUB IAssemblyModuleImport_GetHashValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_GetFlags_Proxy( 
    IAssemblyModuleImport * This,
    /* [out] */ LPDWORD pdwFlags);


void __RPC_STUB IAssemblyModuleImport_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_GetModulePath_Proxy( 
    IAssemblyModuleImport * This,
    /* [size_is][out] */ LPOLESTR szModulePath,
    /* [out][in] */ LPDWORD pccModulePath);


void __RPC_STUB IAssemblyModuleImport_GetModulePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IAssemblyModuleImport_IsAvailable_Proxy( 
    IAssemblyModuleImport * This);


void __RPC_STUB IAssemblyModuleImport_IsAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_BindToObject_Proxy( 
    IAssemblyModuleImport * This,
    /* [in] */ IAssemblyBindSink *pBindSink,
    /* [in] */ IApplicationContext *pAppCtx,
    /* [in] */ LONGLONG llFlags,
    /* [out] */ LPVOID *ppv);


void __RPC_STUB IAssemblyModuleImport_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyModuleImport_INTERFACE_DEFINED__ */


#ifndef __IAssemblyCacheItem_INTERFACE_DEFINED__
#define __IAssemblyCacheItem_INTERFACE_DEFINED__

/* interface IAssemblyCacheItem */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblyCacheItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9e3aaeb4-d1cd-11d2-bab9-00c04f8eceae")
    IAssemblyCacheItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateStream( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszStreamName,
            /* [in] */ DWORD dwFormat,
            /* [in] */ DWORD dwFormatFlags,
            /* [out] */ IStream **ppIStream,
            /* [optional][in] */ ULARGE_INTEGER *puliMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ ULONG *pulDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortItem( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCacheItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCacheItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCacheItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStream )( 
            IAssemblyCacheItem * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszStreamName,
            /* [in] */ DWORD dwFormat,
            /* [in] */ DWORD dwFormatFlags,
            /* [out] */ IStream **ppIStream,
            /* [optional][in] */ ULARGE_INTEGER *puliMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IAssemblyCacheItem * This,
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ ULONG *pulDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *AbortItem )( 
            IAssemblyCacheItem * This);
        
        END_INTERFACE
    } IAssemblyCacheItemVtbl;

    interface IAssemblyCacheItem
    {
        CONST_VTBL struct IAssemblyCacheItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCacheItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCacheItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCacheItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCacheItem_CreateStream(This,dwFlags,pszStreamName,dwFormat,dwFormatFlags,ppIStream,puliMaxSize)	\
    (This)->lpVtbl -> CreateStream(This,dwFlags,pszStreamName,dwFormat,dwFormatFlags,ppIStream,puliMaxSize)

#define IAssemblyCacheItem_Commit(This,dwFlags,pulDisposition)	\
    (This)->lpVtbl -> Commit(This,dwFlags,pulDisposition)

#define IAssemblyCacheItem_AbortItem(This)	\
    (This)->lpVtbl -> AbortItem(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_CreateStream_Proxy( 
    IAssemblyCacheItem * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszStreamName,
    /* [in] */ DWORD dwFormat,
    /* [in] */ DWORD dwFormatFlags,
    /* [out] */ IStream **ppIStream,
    /* [optional][in] */ ULARGE_INTEGER *puliMaxSize);


void __RPC_STUB IAssemblyCacheItem_CreateStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_Commit_Proxy( 
    IAssemblyCacheItem * This,
    /* [in] */ DWORD dwFlags,
    /* [optional][out] */ ULONG *pulDisposition);


void __RPC_STUB IAssemblyCacheItem_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_AbortItem_Proxy( 
    IAssemblyCacheItem * This);


void __RPC_STUB IAssemblyCacheItem_AbortItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCacheItem_INTERFACE_DEFINED__ */


#ifndef __IAssemblyEnum_INTERFACE_DEFINED__
#define __IAssemblyEnum_INTERFACE_DEFINED__

/* interface IAssemblyEnum */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblyEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21b8916c-f28e-11d2-a473-00c04f8ef448")
    IAssemblyEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNextAssembly( 
            /* [out] */ IApplicationContext **ppAppCtx,
            /* [out] */ IAssemblyName **ppName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAssemblyEnum **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssembly )( 
            IAssemblyEnum * This,
            /* [out] */ IApplicationContext **ppAppCtx,
            /* [out] */ IAssemblyName **ppName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyEnum * This,
            /* [out] */ IAssemblyEnum **ppEnum);
        
        END_INTERFACE
    } IAssemblyEnumVtbl;

    interface IAssemblyEnum
    {
        CONST_VTBL struct IAssemblyEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyEnum_GetNextAssembly(This,ppAppCtx,ppName,dwFlags)	\
    (This)->lpVtbl -> GetNextAssembly(This,ppAppCtx,ppName,dwFlags)

#define IAssemblyEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IAssemblyEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyEnum_GetNextAssembly_Proxy( 
    IAssemblyEnum * This,
    /* [out] */ IApplicationContext **ppAppCtx,
    /* [out] */ IAssemblyName **ppName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAssemblyEnum_GetNextAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyEnum_Reset_Proxy( 
    IAssemblyEnum * This);


void __RPC_STUB IAssemblyEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyEnum_Clone_Proxy( 
    IAssemblyEnum * This,
    /* [out] */ IAssemblyEnum **ppEnum);


void __RPC_STUB IAssemblyEnum_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyEnum_INTERFACE_DEFINED__ */


#ifndef __IAssemblyScavenger_INTERFACE_DEFINED__
#define __IAssemblyScavenger_INTERFACE_DEFINED__

/* interface IAssemblyScavenger */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblyScavenger;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21b8916c-f28e-11d2-a473-00ccff8ef448")
    IAssemblyScavenger : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ScavengeAssemblyCache( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCacheDiskQuotas( 
            /* [out] */ DWORD *pdwZapQuotaInGAC,
            /* [out] */ DWORD *pdwDownloadQuotaAdmin,
            /* [out] */ DWORD *pdwDownloadQuotaUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCacheDiskQuotas( 
            /* [in] */ DWORD dwZapQuotaInGAC,
            /* [in] */ DWORD dwDownloadQuotaAdmin,
            /* [in] */ DWORD dwDownloadQuotaUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentCacheUsage( 
            /* [out] */ DWORD *dwZapUsage,
            /* [out] */ DWORD *dwDownloadUsage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyScavengerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyScavenger * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyScavenger * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyScavenger * This);
        
        HRESULT ( STDMETHODCALLTYPE *ScavengeAssemblyCache )( 
            IAssemblyScavenger * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCacheDiskQuotas )( 
            IAssemblyScavenger * This,
            /* [out] */ DWORD *pdwZapQuotaInGAC,
            /* [out] */ DWORD *pdwDownloadQuotaAdmin,
            /* [out] */ DWORD *pdwDownloadQuotaUser);
        
        HRESULT ( STDMETHODCALLTYPE *SetCacheDiskQuotas )( 
            IAssemblyScavenger * This,
            /* [in] */ DWORD dwZapQuotaInGAC,
            /* [in] */ DWORD dwDownloadQuotaAdmin,
            /* [in] */ DWORD dwDownloadQuotaUser);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentCacheUsage )( 
            IAssemblyScavenger * This,
            /* [out] */ DWORD *dwZapUsage,
            /* [out] */ DWORD *dwDownloadUsage);
        
        END_INTERFACE
    } IAssemblyScavengerVtbl;

    interface IAssemblyScavenger
    {
        CONST_VTBL struct IAssemblyScavengerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyScavenger_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyScavenger_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyScavenger_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyScavenger_ScavengeAssemblyCache(This)	\
    (This)->lpVtbl -> ScavengeAssemblyCache(This)

#define IAssemblyScavenger_GetCacheDiskQuotas(This,pdwZapQuotaInGAC,pdwDownloadQuotaAdmin,pdwDownloadQuotaUser)	\
    (This)->lpVtbl -> GetCacheDiskQuotas(This,pdwZapQuotaInGAC,pdwDownloadQuotaAdmin,pdwDownloadQuotaUser)

#define IAssemblyScavenger_SetCacheDiskQuotas(This,dwZapQuotaInGAC,dwDownloadQuotaAdmin,dwDownloadQuotaUser)	\
    (This)->lpVtbl -> SetCacheDiskQuotas(This,dwZapQuotaInGAC,dwDownloadQuotaAdmin,dwDownloadQuotaUser)

#define IAssemblyScavenger_GetCurrentCacheUsage(This,dwZapUsage,dwDownloadUsage)	\
    (This)->lpVtbl -> GetCurrentCacheUsage(This,dwZapUsage,dwDownloadUsage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyScavenger_ScavengeAssemblyCache_Proxy( 
    IAssemblyScavenger * This);


void __RPC_STUB IAssemblyScavenger_ScavengeAssemblyCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyScavenger_GetCacheDiskQuotas_Proxy( 
    IAssemblyScavenger * This,
    /* [out] */ DWORD *pdwZapQuotaInGAC,
    /* [out] */ DWORD *pdwDownloadQuotaAdmin,
    /* [out] */ DWORD *pdwDownloadQuotaUser);


void __RPC_STUB IAssemblyScavenger_GetCacheDiskQuotas_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyScavenger_SetCacheDiskQuotas_Proxy( 
    IAssemblyScavenger * This,
    /* [in] */ DWORD dwZapQuotaInGAC,
    /* [in] */ DWORD dwDownloadQuotaAdmin,
    /* [in] */ DWORD dwDownloadQuotaUser);


void __RPC_STUB IAssemblyScavenger_SetCacheDiskQuotas_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyScavenger_GetCurrentCacheUsage_Proxy( 
    IAssemblyScavenger * This,
    /* [out] */ DWORD *dwZapUsage,
    /* [out] */ DWORD *dwDownloadUsage);


void __RPC_STUB IAssemblyScavenger_GetCurrentCacheUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyScavenger_INTERFACE_DEFINED__ */


#ifndef __IAssemblyCache_INTERFACE_DEFINED__
#define __IAssemblyCache_INTERFACE_DEFINED__

/* interface IAssemblyCache */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblyCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e707dcde-d1cd-11d2-bab9-00c04f8eceae")
    IAssemblyCache : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UninstallAssembly( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [in] */ PVOID pvReserved,
            /* [optional][out] */ ULONG *pulDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAssemblyInfo( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [out][in] */ ASSEMBLY_INFO *pAsmInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAssemblyCacheItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved,
            /* [out] */ IAssemblyCacheItem **ppAsmItem,
            /* [optional][in] */ LPCWSTR pszAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAssemblyScavenger( 
            /* [out] */ IAssemblyScavenger **ppAsmScavenger) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallAssembly( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszManifestFilePath,
            /* [in] */ PVOID pvReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCache * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *UninstallAssembly )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [in] */ PVOID pvReserved,
            /* [optional][out] */ ULONG *pulDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAssemblyInfo )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [out][in] */ ASSEMBLY_INFO *pAsmInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAssemblyCacheItem )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved,
            /* [out] */ IAssemblyCacheItem **ppAsmItem,
            /* [optional][in] */ LPCWSTR pszAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAssemblyScavenger )( 
            IAssemblyCache * This,
            /* [out] */ IAssemblyScavenger **ppAsmScavenger);
        
        HRESULT ( STDMETHODCALLTYPE *InstallAssembly )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszManifestFilePath,
            /* [in] */ PVOID pvReserved);
        
        END_INTERFACE
    } IAssemblyCacheVtbl;

    interface IAssemblyCache
    {
        CONST_VTBL struct IAssemblyCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCache_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCache_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCache_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCache_UninstallAssembly(This,dwFlags,pszAssemblyName,pvReserved,pulDisposition)	\
    (This)->lpVtbl -> UninstallAssembly(This,dwFlags,pszAssemblyName,pvReserved,pulDisposition)

#define IAssemblyCache_QueryAssemblyInfo(This,dwFlags,pszAssemblyName,pAsmInfo)	\
    (This)->lpVtbl -> QueryAssemblyInfo(This,dwFlags,pszAssemblyName,pAsmInfo)

#define IAssemblyCache_CreateAssemblyCacheItem(This,dwFlags,pvReserved,ppAsmItem,pszAssemblyName)	\
    (This)->lpVtbl -> CreateAssemblyCacheItem(This,dwFlags,pvReserved,ppAsmItem,pszAssemblyName)

#define IAssemblyCache_CreateAssemblyScavenger(This,ppAsmScavenger)	\
    (This)->lpVtbl -> CreateAssemblyScavenger(This,ppAsmScavenger)

#define IAssemblyCache_InstallAssembly(This,dwFlags,pszManifestFilePath,pvReserved)	\
    (This)->lpVtbl -> InstallAssembly(This,dwFlags,pszManifestFilePath,pvReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCache_UninstallAssembly_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAssemblyName,
    /* [in] */ PVOID pvReserved,
    /* [optional][out] */ ULONG *pulDisposition);


void __RPC_STUB IAssemblyCache_UninstallAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_QueryAssemblyInfo_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAssemblyName,
    /* [out][in] */ ASSEMBLY_INFO *pAsmInfo);


void __RPC_STUB IAssemblyCache_QueryAssemblyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_CreateAssemblyCacheItem_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ PVOID pvReserved,
    /* [out] */ IAssemblyCacheItem **ppAsmItem,
    /* [optional][in] */ LPCWSTR pszAssemblyName);


void __RPC_STUB IAssemblyCache_CreateAssemblyCacheItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_CreateAssemblyScavenger_Proxy( 
    IAssemblyCache * This,
    /* [out] */ IAssemblyScavenger **ppAsmScavenger);


void __RPC_STUB IAssemblyCache_CreateAssemblyScavenger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_InstallAssembly_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszManifestFilePath,
    /* [in] */ PVOID pvReserved);


void __RPC_STUB IAssemblyCache_InstallAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCache_INTERFACE_DEFINED__ */


#ifndef __IHistoryAssembly_INTERFACE_DEFINED__
#define __IHistoryAssembly_INTERFACE_DEFINED__

/* interface IHistoryAssembly */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHistoryAssembly;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e6096a07-e188-4a49-8d50-2a0172a0d205")
    IHistoryAssembly : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyName( 
            /* [out] */ LPWSTR wzAsmName,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPublicKeyToken( 
            /* [out] */ LPWSTR wzPublicKeyToken,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCulture( 
            /* [out] */ LPWSTR wzCulture,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReferenceVersion( 
            /* [out] */ LPWSTR wzVerRef,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivationDate( 
            /* [out] */ LPWSTR wzActivationDate,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppCfgVersion( 
            /* [out] */ LPWSTR pwzVerAppCfg,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPublisherCfgVersion( 
            /* [out] */ LPWSTR pwzVerPublisherCfg,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAdminCfgVersion( 
            /* [out] */ LPWSTR pwzAdminCfg,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHistoryAssemblyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHistoryAssembly * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHistoryAssembly * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHistoryAssembly * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyName )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR wzAsmName,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetPublicKeyToken )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR wzPublicKeyToken,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetCulture )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR wzCulture,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetReferenceVersion )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR wzVerRef,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationDate )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR wzActivationDate,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppCfgVersion )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR pwzVerAppCfg,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetPublisherCfgVersion )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR pwzVerPublisherCfg,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdminCfgVersion )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR pwzAdminCfg,
            /* [out][in] */ DWORD *pdwSize);
        
        END_INTERFACE
    } IHistoryAssemblyVtbl;

    interface IHistoryAssembly
    {
        CONST_VTBL struct IHistoryAssemblyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHistoryAssembly_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHistoryAssembly_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHistoryAssembly_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHistoryAssembly_GetAssemblyName(This,wzAsmName,pdwSize)	\
    (This)->lpVtbl -> GetAssemblyName(This,wzAsmName,pdwSize)

#define IHistoryAssembly_GetPublicKeyToken(This,wzPublicKeyToken,pdwSize)	\
    (This)->lpVtbl -> GetPublicKeyToken(This,wzPublicKeyToken,pdwSize)

#define IHistoryAssembly_GetCulture(This,wzCulture,pdwSize)	\
    (This)->lpVtbl -> GetCulture(This,wzCulture,pdwSize)

#define IHistoryAssembly_GetReferenceVersion(This,wzVerRef,pdwSize)	\
    (This)->lpVtbl -> GetReferenceVersion(This,wzVerRef,pdwSize)

#define IHistoryAssembly_GetActivationDate(This,wzActivationDate,pdwSize)	\
    (This)->lpVtbl -> GetActivationDate(This,wzActivationDate,pdwSize)

#define IHistoryAssembly_GetAppCfgVersion(This,pwzVerAppCfg,pdwSize)	\
    (This)->lpVtbl -> GetAppCfgVersion(This,pwzVerAppCfg,pdwSize)

#define IHistoryAssembly_GetPublisherCfgVersion(This,pwzVerPublisherCfg,pdwSize)	\
    (This)->lpVtbl -> GetPublisherCfgVersion(This,pwzVerPublisherCfg,pdwSize)

#define IHistoryAssembly_GetAdminCfgVersion(This,pwzAdminCfg,pdwSize)	\
    (This)->lpVtbl -> GetAdminCfgVersion(This,pwzAdminCfg,pdwSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetAssemblyName_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR wzAsmName,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetAssemblyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetPublicKeyToken_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR wzPublicKeyToken,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetPublicKeyToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetCulture_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR wzCulture,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetCulture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetReferenceVersion_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR wzVerRef,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetReferenceVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetActivationDate_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR wzActivationDate,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetActivationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetAppCfgVersion_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR pwzVerAppCfg,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetAppCfgVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetPublisherCfgVersion_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR pwzVerPublisherCfg,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetPublisherCfgVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetAdminCfgVersion_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR pwzAdminCfg,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetAdminCfgVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHistoryAssembly_INTERFACE_DEFINED__ */


#ifndef __IHistoryReader_INTERFACE_DEFINED__
#define __IHistoryReader_INTERFACE_DEFINED__

/* interface IHistoryReader */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHistoryReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1d23df4d-a1e2-4b8b-93d6-6ea3dc285a54")
    IHistoryReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFilePath( 
            /* [out] */ LPWSTR wzFilePath,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationName( 
            /* [out] */ LPWSTR wzAppName,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEXEModulePath( 
            /* [out] */ LPWSTR wzExePath,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumActivations( 
            /* [out] */ DWORD *pdwNumActivations) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivationDate( 
            /* [in] */ DWORD dwIdx,
            /* [out] */ FILETIME *pftDate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRunTimeVersion( 
            /* [in] */ FILETIME *pftActivationDate,
            /* [out] */ LPWSTR wzRunTimeVersion,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumAssemblies( 
            /* [in] */ FILETIME *pftActivationDate,
            /* [out] */ DWORD *pdwNumAsms) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHistoryAssembly( 
            /* [in] */ FILETIME *pftActivationDate,
            /* [in] */ DWORD dwIdx,
            /* [out] */ IHistoryAssembly **ppHistAsm) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHistoryReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHistoryReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHistoryReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHistoryReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilePath )( 
            IHistoryReader * This,
            /* [out] */ LPWSTR wzFilePath,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationName )( 
            IHistoryReader * This,
            /* [out] */ LPWSTR wzAppName,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetEXEModulePath )( 
            IHistoryReader * This,
            /* [out] */ LPWSTR wzExePath,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumActivations )( 
            IHistoryReader * This,
            /* [out] */ DWORD *pdwNumActivations);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationDate )( 
            IHistoryReader * This,
            /* [in] */ DWORD dwIdx,
            /* [out] */ FILETIME *pftDate);
        
        HRESULT ( STDMETHODCALLTYPE *GetRunTimeVersion )( 
            IHistoryReader * This,
            /* [in] */ FILETIME *pftActivationDate,
            /* [out] */ LPWSTR wzRunTimeVersion,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumAssemblies )( 
            IHistoryReader * This,
            /* [in] */ FILETIME *pftActivationDate,
            /* [out] */ DWORD *pdwNumAsms);
        
        HRESULT ( STDMETHODCALLTYPE *GetHistoryAssembly )( 
            IHistoryReader * This,
            /* [in] */ FILETIME *pftActivationDate,
            /* [in] */ DWORD dwIdx,
            /* [out] */ IHistoryAssembly **ppHistAsm);
        
        END_INTERFACE
    } IHistoryReaderVtbl;

    interface IHistoryReader
    {
        CONST_VTBL struct IHistoryReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHistoryReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHistoryReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHistoryReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHistoryReader_GetFilePath(This,wzFilePath,pdwSize)	\
    (This)->lpVtbl -> GetFilePath(This,wzFilePath,pdwSize)

#define IHistoryReader_GetApplicationName(This,wzAppName,pdwSize)	\
    (This)->lpVtbl -> GetApplicationName(This,wzAppName,pdwSize)

#define IHistoryReader_GetEXEModulePath(This,wzExePath,pdwSize)	\
    (This)->lpVtbl -> GetEXEModulePath(This,wzExePath,pdwSize)

#define IHistoryReader_GetNumActivations(This,pdwNumActivations)	\
    (This)->lpVtbl -> GetNumActivations(This,pdwNumActivations)

#define IHistoryReader_GetActivationDate(This,dwIdx,pftDate)	\
    (This)->lpVtbl -> GetActivationDate(This,dwIdx,pftDate)

#define IHistoryReader_GetRunTimeVersion(This,pftActivationDate,wzRunTimeVersion,pdwSize)	\
    (This)->lpVtbl -> GetRunTimeVersion(This,pftActivationDate,wzRunTimeVersion,pdwSize)

#define IHistoryReader_GetNumAssemblies(This,pftActivationDate,pdwNumAsms)	\
    (This)->lpVtbl -> GetNumAssemblies(This,pftActivationDate,pdwNumAsms)

#define IHistoryReader_GetHistoryAssembly(This,pftActivationDate,dwIdx,ppHistAsm)	\
    (This)->lpVtbl -> GetHistoryAssembly(This,pftActivationDate,dwIdx,ppHistAsm)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHistoryReader_GetFilePath_Proxy( 
    IHistoryReader * This,
    /* [out] */ LPWSTR wzFilePath,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryReader_GetFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetApplicationName_Proxy( 
    IHistoryReader * This,
    /* [out] */ LPWSTR wzAppName,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryReader_GetApplicationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetEXEModulePath_Proxy( 
    IHistoryReader * This,
    /* [out] */ LPWSTR wzExePath,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryReader_GetEXEModulePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetNumActivations_Proxy( 
    IHistoryReader * This,
    /* [out] */ DWORD *pdwNumActivations);


void __RPC_STUB IHistoryReader_GetNumActivations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetActivationDate_Proxy( 
    IHistoryReader * This,
    /* [in] */ DWORD dwIdx,
    /* [out] */ FILETIME *pftDate);


void __RPC_STUB IHistoryReader_GetActivationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetRunTimeVersion_Proxy( 
    IHistoryReader * This,
    /* [in] */ FILETIME *pftActivationDate,
    /* [out] */ LPWSTR wzRunTimeVersion,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryReader_GetRunTimeVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetNumAssemblies_Proxy( 
    IHistoryReader * This,
    /* [in] */ FILETIME *pftActivationDate,
    /* [out] */ DWORD *pdwNumAsms);


void __RPC_STUB IHistoryReader_GetNumAssemblies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetHistoryAssembly_Proxy( 
    IHistoryReader * This,
    /* [in] */ FILETIME *pftActivationDate,
    /* [in] */ DWORD dwIdx,
    /* [out] */ IHistoryAssembly **ppHistAsm);


void __RPC_STUB IHistoryReader_GetHistoryAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHistoryReader_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_fusion_0122 */
/* [local] */ 

STDAPI CreateHistoryReader(LPCWSTR wzFilePath, IHistoryReader **ppHistReader);
STDAPI LookupHistoryAssembly(LPCWSTR pwzFilePath, FILETIME *pftActivationDate, LPCWSTR pwzAsmName, LPCWSTR pwzPublicKeyToken, LPCWSTR wzCulture, LPCWSTR pwzVerRef, IHistoryAssembly **pHistAsm);
STDAPI GetHistoryFileDirectory(LPWSTR wzDir, DWORD *pdwSize);
STDAPI AddAssemblyToCacheW(HWND hwnd, HINSTANCE hinst, LPWSTR lpszCmdLine, int nCmdShow);
STDAPI AddAssemblyToCacheA(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);
STDAPI RemoveAssemblyFromCacheW(HWND hwnd, HINSTANCE hinst, LPWSTR lpszCmdLine, int nCmdShow);
STDAPI RemoveAssemblyFromCacheA(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);
STDAPI CreateAssemblyNameObject(LPASSEMBLYNAME *ppAssemblyNameObj, LPCWSTR szAssemblyName, DWORD dwFlags, LPVOID pvReserved);             
STDAPI CreateApplicationContext(IAssemblyName *pName, LPAPPLICATIONCONTEXT *ppCtx);             
STDAPI CreateAssemblyCache(IAssemblyCache **ppAsmCache, DWORD dwReserved); 
STDAPI CreateAssemblyEnum(IAssemblyEnum **pEnum, IApplicationContext *pAppCtx, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);      
STDAPI SetSchemaVersion(DWORD dwNewMinorVersion, DWORD dwCacheId, BOOL fIsNameRes); 
typedef /* [public] */ 
enum __MIDL___MIDL_itf_fusion_0122_0001
    {	CANOF_PARSE_DISPLAY_NAME	= 0x1,
	CANOF_SET_DEFAULT_VALUES	= 0x2
    } 	CREATE_ASM_NAME_OBJ_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_fusion_0122_0002
    {	ASM_CACHE_ZAP	= 0x1,
	ASM_CACHE_GAC	= 0x2,
	ASM_CACHE_DOWNLOAD	= 0x4
    } 	ASM_CACHE_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_fusion_0122_0003
    {	SH_INIT_FOR_GLOBAL	= 0,
	SH_INIT_FOR_USER	= SH_INIT_FOR_GLOBAL + 1
    } 	SH_INIT_FLAGS;

#endif


extern RPC_IF_HANDLE __MIDL_itf_fusion_0122_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusion_0122_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\dll\dllmain.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// dcpromo setup entry points
//
// 2-11-98 sburns



#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
HINSTANCE hDLLModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME = L"dcpromos";

DWORD DEFAULT_LOGGING_OPTIONS =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_HEADER;



BOOL
APIENTRY
DllMain(
   HINSTANCE   hInstance,
   DWORD       dwReason,
   PVOID       /* lpReserved */ )
{
   switch (dwReason)
   {
      case DLL_PROCESS_ATTACH:
      {
         hResourceModuleHandle = hInstance;
         hDLLModuleHandle = hInstance;

         LOG(L"DLL_PROCESS_ATTACH");
         break;
      }
      case DLL_PROCESS_DETACH:
      {
         LOG(L"DLL_PROCESS_DETACH");

         break;
      }
      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
      default:
      {
         break;
      }
   }

   return TRUE;
}



DWORD
APIENTRY
DcPromoSaveDcStateForUpgrade(PCWSTR answerFile)
{
   LOG_FUNCTION(DcPromoSaveDcStateForUpgrade);

   DWORD result = ERROR_SUCCESS;

   if (!IsDSRunning())
   {
      LOG(L"Calling DsRoleServerSaveStateForUpgrade");
      LOG(String::format(L"AnswerFile : %1",
         answerFile ? answerFile : L"(null)"));

      result = ::DsRoleServerSaveStateForUpgrade(answerFile);

      LOG(String::format(L"Error 0x%1!X! (!0 => error)", result));
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\dll\muiresource.h ===
#define IDS_DC_POLICY_DESC              1448
#define IDS_DOMAIN_POLICY_DESC          1450
#define IDS_LOCAL_POLICY_DESC           1452
#define IDS_DS_SITE_DESC                1454
#define IDS_DS_USERS_DESC               1456
#define IDS_DS_DOMAINS_DESC             1458
#define IDS_DC_POLICY_LINK              1447
#define IDS_DOMAIN_POLICY_LINK          1449
#define IDS_LOCAL_POLICY_LINK           1451
#define IDS_DS_SITE_LINK                1453
#define IDS_DS_USERS_LINK               1455
#define IDS_DS_DOMAINS_LINK             1457
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\adpass.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Admin password page
//
// 2-4-98 sburns



#ifndef ADPASS_HPP_INCLUDED
#define ADPASS_HPP_INCLUDED



#include "page.hpp"
#include "PasswordEditBox.hpp"



class AdminPasswordPage : public DCPromoWizardPage
{
   public:

   AdminPasswordPage();

   protected:

   virtual ~AdminPasswordPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   AdminPasswordPage(const AdminPasswordPage&);
   const AdminPasswordPage& operator=(const AdminPasswordPage&);

   // NTRAID#NTBUG9-202238-2000/11/07-sburns
   
   PasswordEditBox password;
   PasswordEditBox confirm;
};



#endif   // ADPASS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\adpass.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Admin password page
//
// 2-4-98 sburns



#include "headers.hxx"
#include "adpass.hpp"
#include "resource.h"
#include "state.hpp"
#include "ds.hpp"
#include "common.hpp"




AdminPasswordPage::AdminPasswordPage()
   :
   DCPromoWizardPage(
      IDD_ADMIN_PASSWORD,
      IDS_PASSWORD_PAGE_TITLE,
      IDS_PASSWORD_PAGE_SUBTITLE)
{
   LOG_CTOR(AdminPasswordPage);
}



AdminPasswordPage::~AdminPasswordPage()
{
   LOG_DTOR(AdminPasswordPage);
}



void
AdminPasswordPage::OnInit()
{
   LOG_FUNCTION(AdminPasswordPage::OnInit);

   // NTRAID#NTBUG9-202238-2000/11/07-sburns
   
   password.Init(Win::GetDlgItem(hwnd, IDC_PASSWORD));
   confirm.Init(Win::GetDlgItem(hwnd, IDC_CONFIRM));

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      EncryptedString pwd =
         state.GetEncryptedAnswerFileOption(AnswerFile::OPTION_ADMIN_PASSWORD);

      Win::SetDlgItemText(hwnd, IDC_PASSWORD, pwd);
      Win::SetDlgItemText(hwnd, IDC_CONFIRM,  pwd);
   }
}


   
static
String
getPasswordMessage()
{
   LOG_FUNCTION(getPasswordMessage);

   State& state = State::GetInstance();
   unsigned id = IDS_ENTER_DOMAIN_ADMIN_PASSWORD;
   switch (state.GetOperation())
   {
      case State::FOREST:
      case State::TREE:
      case State::CHILD:
      {
         // do nothing, id is already set.
         break;
      }
      case State::ABORT_BDC_UPGRADE:
      case State::DEMOTE:
      {
         id = IDS_ENTER_LOCAL_ADMIN_PASSWORD;
         break;
      }
      case State::REPLICA:
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return String::load(id);
}



bool
AdminPasswordPage::OnSetActive()
{
   LOG_FUNCTION(AdminPasswordPage::OnSetActive);
   
   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      // fully-qualify the Validate call, as it is virtual...

      int nextPage = AdminPasswordPage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   Win::SetDlgItemText(hwnd, IDC_MESSAGE, getPasswordMessage());

   return true;
}



int
AdminPasswordPage::Validate()
{
   LOG_FUNCTION(AdminPasswordPage::Validate);

   int result = -1;
   
   EncryptedString password;

   if (IsValidPassword(hwnd, IDC_PASSWORD, IDC_CONFIRM, false, password))
   {
      State& state = State::GetInstance();
      state.SetAdminPassword(password);

      switch (state.GetOperation())
      {
         case State::ABORT_BDC_UPGRADE:
         case State::DEMOTE:
         {
            result = IDD_CONFIRMATION;
            break;
         }
         case State::REPLICA:
         case State::FOREST:
         case State::TREE:
         case State::CHILD:
         case State::NONE:
         default:
         {
            ASSERT(false);
            break;
         }
      }
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\applicationpartitionconfirmationpage.hpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// Confirm removal of Application Partitions page
//
// 26 Jul 2001 sburns



#ifndef APPLICATIONPARTITIONCONFIRMATIONPAGE_HPP_INCLUDED
#define APPLICATIONPARTITIONCONFIRMATIONPAGE_HPP_INCLUDED



#include "page.hpp"



class ApplicationPartitionConfirmationPage : public DCPromoWizardPage
{
   public:

   ApplicationPartitionConfirmationPage();

   protected:

   virtual ~ApplicationPartitionConfirmationPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   Enable();

   // not defined; no copying allowed

   ApplicationPartitionConfirmationPage(
      const ApplicationPartitionConfirmationPage&);
      
   const ApplicationPartitionConfirmationPage&
   operator=(const ApplicationPartitionConfirmationPage&);
};



#endif   // APPLICATIONPARTITIONCONFIRMATIONPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\applicationpartitionconfirmationpage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// Confirm removal of Application Partitions page
//
// 26 Jul 2001 sburns



#include "headers.hxx"
#include "ApplicationPartitionConfirmationPage.hpp"
#include "resource.h"
#include "state.hpp"




ApplicationPartitionConfirmationPage::ApplicationPartitionConfirmationPage()
   :
   DCPromoWizardPage(
      IDD_APP_PARTITION_CONFIRM,
      IDS_APP_PARTITION_CONFIRM_TITLE,
      IDS_APP_PARTITION_CONFIRM_SUBTITLE)
{
   LOG_CTOR(ApplicationPartitionConfirmationPage);
}



ApplicationPartitionConfirmationPage::~ApplicationPartitionConfirmationPage()
{
   LOG_DTOR(ApplicationPartitionConfirmationPage);
}



void
ApplicationPartitionConfirmationPage::OnInit()
{
   LOG_FUNCTION(ApplicationPartitionConfirmationPage::OnInit);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(AnswerFile::OPTION_REMOVE_APP_PARTITIONS);
      if (option.icompare(AnswerFile::VALUE_YES) == 0)
      {
         Win::CheckDlgButton(hwnd, IDC_CONFIRM, BST_CHECKED);
         return;
      }
   }

   Win::CheckDlgButton(hwnd, IDC_CONFIRM, BST_UNCHECKED);   
}



void
ApplicationPartitionConfirmationPage::Enable()
{
// LOG_FUNCTION(ApplicationPartitionConfirmationPage::Enable);

   int next = Win::IsDlgButtonChecked(hwnd, IDC_CONFIRM) ? PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | next);
}



bool
ApplicationPartitionConfirmationPage::OnSetActive()
{
   LOG_FUNCTION(ApplicationPartitionConfirmationPage::OnSetActive);

   State& state = State::GetInstance();
   
   if (
         state.RunHiddenUnattended()

      // we don't re-evaluate whether this machine is has the last copy of
      // and ndnc (i.e. call state.IsLastAppPartitionReplica) again because
      // that evaluation could be kinda expensive if there are many ndncs
      // on this box, and we just did it on the previous page, and
      // ** we don't want to get a different result that what we showed **
      
      || !state.GetAppPartitionList().size())
   {
      LOG(L"Planning to skip ApplicationPartitionConfirmationPage");

      Wizard& wizard = GetWizard();

      if (wizard.IsBacktracking())
      {
         // backup once again

         wizard.Backtrack(hwnd);
         return true;
      }
   
      int nextPage = ApplicationPartitionConfirmationPage::Validate();
      if (nextPage != -1)
      {
         LOG(L"skipping ApplicationPartitionConfirmationPage");
         wizard.SetNextPageID(hwnd, nextPage);
         return true;
      }

      state.ClearHiddenWhileUnattended();
   }

   Enable();
   
   return true;
}



bool
ApplicationPartitionConfirmationPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(CredentialsPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_CONFIRM:
      {
         if (code == BN_CLICKED)
         {
            SetChanged(controlIDFrom);
            Enable();
            return true;
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



int
ApplicationPartitionConfirmationPage::Validate()
{
   LOG_FUNCTION(ApplicationPartitionConfirmationPage::Validate);

   State& state = State::GetInstance();
   ASSERT(state.GetOperation() == State::DEMOTE);

   int nextPage = -1;
   
   if (
         !state.GetAppPartitionList().size()
      || Win::IsDlgButtonChecked(hwnd, IDC_CONFIRM))
   {
      // jump to credentials page if the user checked the "last dc in domain"
      // checkbox, unless this is last dc in forest root domain. 318736, 391440

      const Computer& computer = state.GetComputer();
      bool isForestRootDomain =
         (computer.GetDomainDnsName().icompare(computer.GetForestDnsName()) == 0);

      nextPage =    
            state.IsLastDCInDomain() && !isForestRootDomain
         ?  IDD_GET_CREDENTIALS
         :  IDD_ADMIN_PASSWORD;
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\answerfile.cpp ===
// Copyright (C) 2002 Microsoft Corporation
//
// answerfile reader object
//
// 5 April 2002 sburns



#include "headers.hxx"
#include "AnswerFile.hpp"
#include "resource.h"



static const String SECTION_NAME(L"DCInstall");




const String AnswerFile::OPTION_ADMIN_PASSWORD                (L"AdministratorPassword");      
const String AnswerFile::OPTION_ALLOW_ANON_ACCESS             (L"AllowAnonymousAccess");       
const String AnswerFile::OPTION_AUTO_CONFIG_DNS               (L"AutoConfigDNS");              
const String AnswerFile::OPTION_CHILD_NAME                    (L"ChildName");                  
const String AnswerFile::OPTION_CRITICAL_REPLICATION_ONLY     (L"CriticalReplicationOnly");    
const String AnswerFile::OPTION_DATABASE_PATH                 (L"DatabasePath");               
const String AnswerFile::OPTION_DISABLE_CANCEL_ON_DNS_INSTALL (L"DisableCancelForDnsInstall");  
const String AnswerFile::OPTION_DNS_ON_NET                    (L"DNSOnNetwork");               
const String AnswerFile::OPTION_GC_CONFIRM                    (L"ConfirmGc");                  
const String AnswerFile::OPTION_IS_LAST_DC                    (L"IsLastDCInDomain");           
const String AnswerFile::OPTION_LOG_PATH                      (L"LogPath");                    
const String AnswerFile::OPTION_NEW_DOMAIN                    (L"NewDomain");                  
const String AnswerFile::OPTION_NEW_DOMAIN_NAME               (L"NewDomainDNSName");           
const String AnswerFile::OPTION_NEW_DOMAIN_NETBIOS_NAME       (L"DomainNetbiosName");          
const String AnswerFile::OPTION_PARENT_DOMAIN_NAME            (L"ParentDomainDNSName");        
const String AnswerFile::OPTION_PASSWORD                      (L"Password");                   
const String AnswerFile::OPTION_REBOOT                        (L"RebootOnSuccess");            
const String AnswerFile::OPTION_REMOVE_APP_PARTITIONS         (L"RemoveApplicationPartitions");
const String AnswerFile::OPTION_REPLICATION_SOURCE            (L"ReplicationSourceDC");        
const String AnswerFile::OPTION_REPLICA_DOMAIN_NAME           (L"ReplicaDomainDNSName");       
const String AnswerFile::OPTION_REPLICA_OR_MEMBER             (L"ReplicaOrMember");            
const String AnswerFile::OPTION_REPLICA_OR_NEW_DOMAIN         (L"ReplicaOrNewDomain");         
const String AnswerFile::OPTION_SAFE_MODE_ADMIN_PASSWORD      (L"SafeModeAdminPassword");      
const String AnswerFile::OPTION_SET_FOREST_VERSION            (L"SetForestVersion");           
const String AnswerFile::OPTION_SITE_NAME                     (L"SiteName");                   
const String AnswerFile::OPTION_SOURCE_PATH                   (L"ReplicationSourcePath");      
const String AnswerFile::OPTION_SYSKEY                        (L"Syskey");                     
const String AnswerFile::OPTION_SYSVOL_PATH                   (L"SYSVOLPath");                 
const String AnswerFile::OPTION_USERNAME                      (L"UserName");                   
const String AnswerFile::OPTION_USER_DOMAIN                   (L"UserDomain");                 


const String AnswerFile::VALUE_CHILD          (L"Child");              
const String AnswerFile::VALUE_DOMAIN         (L"Domain");             
const String AnswerFile::VALUE_NO             (L"No");                 
const String AnswerFile::VALUE_NO_DONT_PROMPT (L"NoAndNoPromptEither");
const String AnswerFile::VALUE_REPLICA        (L"Replica");            
const String AnswerFile::VALUE_TREE           (L"Tree");               
const String AnswerFile::VALUE_YES            (L"Yes");                



static StringList PASSWORD_OPTIONS_LIST;
static bool passwordOptionsListInitialized = false;



void
GetAllKeys(const String& filename, StringList& resultList) 
{
   LOG_FUNCTION(GetAllKeys);
   ASSERT(FS::IsValidPath(filename));

   resultList.clear();
   
   // our first call is with a large buffer, hoping that it will suffice...

#ifdef DBG

   // on chk builds, use a small buffer size so that our growth algorithm
   // gets exercised
   
   unsigned      bufSizeInCharacters = 3;

#else
   unsigned      bufSizeInCharacters = 1023;
#endif

   PWSTR      buffer   = 0;   

   do
   {
      buffer = new WCHAR[bufSizeInCharacters + 1];

      // REVIEWED-2002/02/22-sburns byte count correctly passed in
      
      ::ZeroMemory(buffer, (bufSizeInCharacters + 1) * sizeof WCHAR);

      DWORD result =

      // REVIEWED-2002/02/22-sburns call correctly passes size in characters.
            
         ::GetPrivateProfileString(
            SECTION_NAME.c_str(),
            0,
            L"default",
            buffer,
            bufSizeInCharacters,
            filename.c_str());

      if (!result)
      {
         break;
      }

      // A value was found.  check to see if it was truncated. Since lpKeyName
      // was null, check result against character count - 2

      if (result == bufSizeInCharacters - 2)
      {
         // buffer was too small, so the value was truncated.  Resize the
         // buffer and try again.

         // no need to scribble out the buffer: we're retrieving key names,
         // not values.
         
         delete[] buffer;

         bufSizeInCharacters *= 2;
         if (bufSizeInCharacters > USHRT_MAX)   // effectively ~32K max
         {
            // too big. way too big. We'll make do with the truncated value.

            ASSERT(false);
            break;
         }
         continue;
      }

      // copy out the strings results into list elements

      PWSTR p = buffer;
      while (*p)
      {
         resultList.push_back(p);

         // REVIEWED-2002/04/08-sburns wcslen is ok, since we arrange for
         // the buffer to be null terminated
         
         p += wcslen(p) + 1;
      }

      break;
   }

   //lint -e506   ok that this looks like "loop forever"
      
   while (true);

   delete[] buffer;
}



AnswerFile::AnswerFile(const String& filename_)
   :
   filename(filename_),
   isSafeModePasswordPresent(false)
{
   LOG_CTOR(AnswerFile);

   // the caller is expected to have verified this
   
   ASSERT(FS::PathExists(filename));

   GetAllKeys(filename, keysPresent);

   isSafeModePasswordPresent = IsKeyPresent(OPTION_SAFE_MODE_ADMIN_PASSWORD);
   
   // remove read-only file attribute

   DWORD attrs = 0;
   HRESULT hr = Win::GetFileAttributes(filename, attrs);
   if (SUCCEEDED(hr) && attrs & FILE_ATTRIBUTE_READONLY)
   {
      LOG(L"Removing readonly attribute on " + filename);
      
      hr = Win::SetFileAttributes(filename, attrs & ~FILE_ATTRIBUTE_READONLY);

      // if this failed, well, we tried. The user runs the risk of cleartext
      // passwords left in his file.
      
      LOG_HRESULT(hr);
   }
   
   // Read all the password options into the encrypted value map, erasing
   // them as we go.

   if (!passwordOptionsListInitialized)
   {
      ASSERT(PASSWORD_OPTIONS_LIST.empty());
      PASSWORD_OPTIONS_LIST.clear();
      PASSWORD_OPTIONS_LIST.push_back(OPTION_PASSWORD);
      PASSWORD_OPTIONS_LIST.push_back(OPTION_ADMIN_PASSWORD);
      PASSWORD_OPTIONS_LIST.push_back(OPTION_SYSKEY);
      PASSWORD_OPTIONS_LIST.push_back(OPTION_SAFE_MODE_ADMIN_PASSWORD);
      passwordOptionsListInitialized = true;
   }

   String empty;
   for (
      StringList::iterator i = PASSWORD_OPTIONS_LIST.begin();
      i != PASSWORD_OPTIONS_LIST.end();
      ++i)
   {
      if (IsKeyPresent(*i))
      {
         ovMap[*i] = EncryptedReadKey(*i);                
         hr = WriteKey(*i, empty);
      
         if (FAILED(hr))
         {
            popup.Error(
               Win::GetDesktopWindow(),
               hr,
               String::format(
                  IDS_FAILED_PASSWORD_WRITE_TO_ANSWERFILE,
                  i->c_str(),
                  filename.c_str()));
         }
      }
   }
}



AnswerFile::~AnswerFile()
{
   LOG_DTOR(AnswerFile);
}



String
AnswerFile::ReadKey(const String& key) const
{
   LOG_FUNCTION2(AnswerFile::ReadKey, key);
   ASSERT(!key.empty());

   String result =
      
      // REVIEWED-2002/02/22-sburns no cch/cb issue here.
      
      Win::GetPrivateProfileString(SECTION_NAME, key, String(), filename);

   // Don't log the value, as it may be a password.
   // LOG(L"value=" + result);

   return result.strip(String::BOTH);
}



EncryptedString
AnswerFile::EncryptedReadKey(const String& key) const
{
   LOG_FUNCTION2(AnswerFile::EncodedReadKey, key);
   ASSERT(!key.empty());

   EncryptedString retval;

#ifdef DBG

   // on chk builds, use a small buffer size so that our growth algorithm
   // gets exercised
   
   unsigned      bufSizeInCharacters = 3;

#else
   unsigned      bufSizeInCharacters = 1023;
#endif
      
   PWSTR         buffer  = 0;   

   do
   {
      // +1 for extra null-termination paranoia
      
      buffer = new WCHAR[bufSizeInCharacters + 1];

      // REVIEWED-2002/02/22-sburns byte count correctly passed in
      
      ::ZeroMemory(buffer, (bufSizeInCharacters + 1) * sizeof WCHAR);

      DWORD result =

      // REVIEWED-2002/02/22-sburns call correctly passes size in characters.
            
         ::GetPrivateProfileString(
            SECTION_NAME.c_str(),
            key.c_str(),
            L"",
            buffer,
            bufSizeInCharacters,
            filename.c_str());

      if (!result)
      {
         break;
      }

      // A value was found.  check to see if it was truncated. neither
      // lpAppName nor lpKeyName were null, so check result against character
      // count - 1
      
      if (result == bufSizeInCharacters - 1)
      {
         // buffer was too small, so the value was truncated.  Resize the
         // buffer and try again.

         // Since the buffer may have contained passwords, scribble it
         // out
         
         // REVIEWED-2002/02/22-sburns byte count correctly passed in
         
         ::SecureZeroMemory(buffer, (bufSizeInCharacters + 1) * sizeof WCHAR);
      
         delete[] buffer;

         bufSizeInCharacters *= 2;
         if (bufSizeInCharacters > USHRT_MAX)   // effectively ~32K max
         {
            // too big. way too big. We'll make do with the truncated value.

            ASSERT(false);
            break;
         }
         continue;
      }

      // don't need to trim whitespace, GetPrivateProfileString does that
      // for us.

      retval.Encrypt(buffer);

      break;
   }
   while (true);

   // Since the buffer may have contained passwords, scribble it
   // out
   
   // REVIEWED-2002/02/22-sburns byte count correctly passed in
   
   ::SecureZeroMemory(buffer, (bufSizeInCharacters + 1) * sizeof WCHAR);
   
   delete[] buffer;

   // Don't log the value, as it may be a password.
   // LOG(L"value=" + result);

   return retval;
}
   


HRESULT
AnswerFile::WriteKey(const String& key, const String& value) const
{
   LOG_FUNCTION2(AnswerFile::WriteKey, key);
   ASSERT(!key.empty());

   HRESULT hr =
      Win::WritePrivateProfileString(SECTION_NAME, key, value, filename);

   return hr;   
}



bool
AnswerFile::IsKeyPresent(const String& key) const
{
   LOG_FUNCTION2(AnswerFile::IsKeyPresent, key);
   ASSERT(!key.empty());

   bool result = false;
   
   // If GetAllKeys failed, then we won't find the option in the keys list
   // and will assume that the option is not specified. This is the best
   // we can do in the case where we can't read the keys.
   
   if (
         std::find(keysPresent.begin(), keysPresent.end(), key)
      != keysPresent.end() )
   {
      result = true;
   }

   LOG_BOOL(result);

   return result;
}
      
   

bool
IsPasswordOption(const String& option)
{
   ASSERT(passwordOptionsListInitialized);

   bool result = false;
   
   if (
      std::find(
         PASSWORD_OPTIONS_LIST.begin(),
         PASSWORD_OPTIONS_LIST.end(),
         option)
      != PASSWORD_OPTIONS_LIST.end() )
   {
      result = true;
   }

   return result;
}
   


String
AnswerFile::GetOption(const String& option) const
{
   LOG_FUNCTION2(AnswerFile::GetOption, option);

   String result = ReadKey(option);

   if (!IsPasswordOption(option))
   {
      LOG(result);
   }
   else
   {
      // should use GetEncryptedAnswerFileOption for passwords

      ASSERT(false);
   }

   return result;
}



EncryptedString
AnswerFile::GetEncryptedOption(const String& option) const
{
   LOG_FUNCTION2(AnswerFile::GetEncryptedOption, option);

   OptionEncryptedValueMap::const_iterator ci = ovMap.find(option);
   if (ci != ovMap.end())
   {
      return ci->second;
   }

   return EncryptedString();
}



bool
AnswerFile::IsSafeModeAdminPwdOptionPresent() const
{
   LOG_FUNCTION(AnswerFile::IsSafeModeAdminPwdOptionPresent);
   LOG_BOOL(isSafeModePasswordPresent);

   return isSafeModePasswordPresent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\applicationpartitionpage.hpp ===
// Copyright (C) 2001 Microsoft Corporation
//
// Application Partition (aka. Non-Domain Naming Context) page
//
// 24 Jul 2001 sburns



#ifndef APPLICATIONPARTITIONPAGE_HPP_INCLUDED
#define APPLICATIONPARTITIONPAGE_HPP_INCLUDED



#include "page.hpp"



class ApplicationPartitionPage : public DCPromoWizardPage
{
   public:

   ApplicationPartitionPage();

   protected:

   virtual ~ApplicationPartitionPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lparam);
   
   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   PopulateListView();

   // not defined; no copying allowed

   ApplicationPartitionPage(const ApplicationPartitionPage&);
   const ApplicationPartitionPage& operator=(const ApplicationPartitionPage&);
};



#endif   // APPLICATIONPARTITIONPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\autoconfigurednspage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// auto config dns page
//
// 3-17-98 sburns



#include "headers.hxx"
#include "page.hpp"
#include "AutoConfigureDnsPage.hpp"
#include "resource.h"
#include "state.hpp"



AutoConfigureDnsPage::AutoConfigureDnsPage()
   :
   DCPromoWizardPage(
      IDD_AUTO_CONFIG_DNS,
      IDS_AUTO_CONFIG_DNS_PAGE_TITLE,
      IDS_AUTO_CONFIG_DNS_PAGE_SUBTITLE)
{
   LOG_CTOR(AutoConfigureDnsPage);
}



AutoConfigureDnsPage::~AutoConfigureDnsPage()
{
   LOG_CTOR(AutoConfigureDnsPage);
}



void
AutoConfigureDnsPage::OnInit()
{
   LOG_FUNCTION(AutoConfigureDnsPage::OnInit);

   State& state = State::GetInstance();
   int button = IDC_AUTO_CONFIG;

   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(State::OPTION_AUTO_CONFIG_DNS);

      if (option.icompare(State::VALUE_YES) == 0)
      {
         button = IDC_AUTO_CONFIG;
      }
      else
      {
         button = IDC_DONT_AUTO_CONFIG;
      }

   }

   Win::CheckDlgButton(hwnd, button, BST_CHECKED);
}



bool
AutoConfigureDnsPage::OnSetActive()
{
   LOG_FUNCTION(AutoConfigureDnsPage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = AutoConfigureDnsPage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }

   return true;
}



int
AutoConfigureDnsPage::Validate()
{
   LOG_FUNCTION(AutoConfigureDnsPage::Validate);

   bool autoConfig = Win::IsDlgButtonChecked(hwnd, IDC_AUTO_CONFIG);
   State& state = State::GetInstance();

   state.SetAutoConfigureDNS(autoConfig);

   return IDD_RAS_FIXUP;
}



bool
AutoConfigureDnsPage::OnWizBack()
{
   LOG_FUNCTION(AutoConfigureDnsPage::OnWizBack);

   // make sure we reset the auto-config flag => the only way it gets set
   // it on the 'next' button.
   State::GetInstance().SetAutoConfigureDNS(false);

   return DCPromoWizardPage::OnWizBack();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\autoconfigurednspage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// auto config dns page
//
// 3-17-98 sburns



#ifndef AUTOCONFIGUREDNSPAGE_HPP_INCLUDED
#define AUTOCONFIGUREDNSPAGE_HPP_INCLUDED



class AutoConfigureDnsPage : public DCPromoWizardPage
{
   public:

   AutoConfigureDnsPage();

   protected:

   virtual ~AutoConfigureDnsPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // WizardPage overrides

   virtual
   bool
   OnWizBack();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   AutoConfigureDnsPage(const AutoConfigureDnsPage&);
   const AutoConfigureDnsPage& operator=(const AutoConfigureDnsPage&);
};



#endif   // AUTOCONFIGUREDNSPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\answerfile.hpp ===
// Copyright (C) 2002 Microsoft Corporation
//
// answerfile reader object
//
// 5 April 2002 sburns



#ifndef ANSWERFILE_HPP_INCLUDED
#define ANSWERFILE_HPP_INCLUDED



class AnswerFile
{
   public:

   static const String OPTION_ADMIN_PASSWORD;
   static const String OPTION_ALLOW_ANON_ACCESS;
   static const String OPTION_AUTO_CONFIG_DNS;
   static const String OPTION_CHILD_NAME;
   static const String OPTION_CRITICAL_REPLICATION_ONLY;
   static const String OPTION_DATABASE_PATH;
   static const String OPTION_DISABLE_CANCEL_ON_DNS_INSTALL;
   static const String OPTION_DNS_ON_NET;
   static const String OPTION_GC_CONFIRM;
   static const String OPTION_IS_LAST_DC;
   static const String OPTION_LOG_PATH;
   static const String OPTION_NEW_DOMAIN;
   static const String OPTION_NEW_DOMAIN_NAME;
   static const String OPTION_NEW_DOMAIN_NETBIOS_NAME;
   static const String OPTION_PARENT_DOMAIN_NAME;
   static const String OPTION_PASSWORD;
   static const String OPTION_REBOOT;
   static const String OPTION_REMOVE_APP_PARTITIONS;
   static const String OPTION_REPLICATION_SOURCE;
   static const String OPTION_REPLICA_DOMAIN_NAME;
   static const String OPTION_REPLICA_OR_MEMBER;
   static const String OPTION_REPLICA_OR_NEW_DOMAIN;
   static const String OPTION_SAFE_MODE_ADMIN_PASSWORD;
   static const String OPTION_SET_FOREST_VERSION;
   static const String OPTION_SITE_NAME;
   static const String OPTION_SOURCE_PATH;
   static const String OPTION_SYSKEY;
   static const String OPTION_SYSVOL_PATH;
   static const String OPTION_USERNAME;
   static const String OPTION_USER_DOMAIN;

   static const String VALUE_CHILD;
   static const String VALUE_DOMAIN;
   static const String VALUE_NO;
   static const String VALUE_NO_DONT_PROMPT;
   static const String VALUE_REPLICA;
   static const String VALUE_TREE;
   static const String VALUE_YES;


   // Constructs a new instance of the class.
   //    
   // filename - fully-qualified pathname to an existing file from which the
   // options are read.
   //    
   // If the file has the read-only attribute set, it will be removed.
   
   explicit
   AnswerFile(const String& filename);


   
   ~AnswerFile();



   String
   GetOption(const String& option) const;



   EncryptedString
   GetEncryptedOption(const String& option) const;



   bool
   IsSafeModeAdminPwdOptionPresent() const;



   private:
   

   
   bool
   IsKeyPresent(const String& key) const;

   String
   ReadKey(const String& key) const;

   EncryptedString
   EncryptedReadKey(const String& key) const;

   HRESULT
   WriteKey(const String& key, const String& value) const;

   typedef
      std::map<
         String,
         EncryptedString,
         String::LessIgnoreCase,
         Burnslib::Heap::Allocator< EncryptedString > >
      OptionEncryptedValueMap;

   OptionEncryptedValueMap ovMap;
   StringList              keysPresent;
   String                  filename;                 
   bool                    isSafeModePasswordPresent;
};



#endif   // ANSWERFILE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\applicationpartitionpage.cpp ===
// Copyright (C) 2001 Microsoft Corporation
//
// Application Partition (aka. Non-Domain Naming Context) page
//
// 24 Jul 2001 sburns



#include "headers.hxx"
#include "ApplicationPartitionPage.hpp"
#include "resource.h"
#include "state.hpp"



ApplicationPartitionPage::ApplicationPartitionPage()
   :
   DCPromoWizardPage(
      IDD_APP_PARTITION,
      IDS_APP_PARTITION_PAGE_TITLE,
      IDS_APP_PARTITION_PAGE_SUBTITLE)
      
   // partitionList is populated on-demand in OnSetActive
      
{
   LOG_CTOR(ApplicationPartitionPage);
}



ApplicationPartitionPage::~ApplicationPartitionPage()
{
   LOG_DTOR(ApplicationPartitionPage);
}



void
ApplicationPartitionPage::OnInit()
{
   LOG_FUNCTION(ApplicationPartitionPage::OnInit);

   HWND view = Win::GetDlgItem(hwnd, IDC_NDNC_LIST);

   // Build a list view with two columns, one for the DN of the ndncs for
   // which this box is the last replica, another for the description(s) of
   // those ndncs.

   Win::ListView_SetExtendedListViewStyle(view, LVS_EX_FULLROWSELECT);
   
   // add a column to the list view for the DN
      
   LVCOLUMN column;

   // REVIEWED-2002/02/22-sburns call correctly passes byte count.
   
   ::ZeroMemory(&column, sizeof column);

   column.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
   column.fmt = LVCFMT_LEFT;

   int width = 0;
   String::load(IDS_NDNC_LIST_NAME_COLUMN_WIDTH).convert(width);
   column.cx = width;

   String label = String::load(IDS_NDNC_LIST_NAME_COLUMN);
   column.pszText = const_cast<wchar_t*>(label.c_str());

   Win::ListView_InsertColumn(view, 0, column);

   // add a column to the list view for description.

   String::load(IDS_NDNC_LIST_DESC_COLUMN_WIDTH).convert(width);
   column.cx = width;
   label = String::load(IDS_NDNC_LIST_DESC_COLUMN);
   column.pszText = const_cast<wchar_t*>(label.c_str());

   Win::ListView_InsertColumn(view, 1, column);
}



// Unwraps the safearray of variants inside a variant, extracts the strings
// inside them, and catenates the strings together with semicolons in between.
// Return empty string on error.
// 
// variant - in, the variant containing a safearray of variants of bstr.

String
GetNdncDescriptionHelper(VARIANT* variant)
{
   LOG_FUNCTION(GetNdncDescriptionHelper);
   ASSERT(variant);
   ASSERT(V_VT(variant) == (VT_ARRAY | VT_VARIANT));

   String result;

   SAFEARRAY* psa = V_ARRAY(variant);

   do
   {
      ASSERT(psa);
      ASSERT(psa != (SAFEARRAY*)-1);

      if (!psa || psa == (SAFEARRAY*)-1)
      {
         LOG(L"variant not safe array");
         break;
      }

      if (::SafeArrayGetDim(psa) != 1)
      {
         LOG(L"safe array: wrong number of dimensions");
         break;
      }

      VARTYPE vt = VT_EMPTY;
      HRESULT hr = ::SafeArrayGetVartype(psa, &vt);
      if (FAILED(hr) || vt != VT_VARIANT)
      {
         LOG(L"safe array: wrong element type");
         break;
      }

      long lower = 0;
      long upper = 0;
     
      hr = ::SafeArrayGetLBound(psa, 1, &lower);
      BREAK_ON_FAILED_HRESULT2(hr, L"can't get lower bound");      

      hr = ::SafeArrayGetUBound(psa, 1, &upper);
      BREAK_ON_FAILED_HRESULT2(hr, L"can't get upper bound");      
      
      VARIANT varItem;
      ::VariantInit(&varItem);

      for (long i = lower; i <= upper; ++i)
      {
         hr = ::SafeArrayGetElement(psa, &i, &varItem);
         if (FAILED(hr))
         {
            LOG(String::format(L"index %1!d! failed", i));
            continue;
         }

         result += V_BSTR(&varItem);

         if (i < upper)
         {   
            result += L";";
         }

         ::VariantClear(&varItem);
      }
      
   }
   while (0);

   LOG(result);
   
   return result;   
}



// bind to an ndnc, read it's description(s), and return them catenated
// together.  Return empty string on error.
// 
// ndncDn - in, DN of the ndnc

String
GetNdncDescription(const String& ndncDn)
{
   LOG_FUNCTION2(GetNdncDescription, ndncDn);
   ASSERT(!ndncDn.empty());

   String result;

   do
   {
      String path = L"LDAP://" + ndncDn;

      SmartInterface<IADs> iads(0);
      IADs* dumb = 0;
      
      HRESULT hr =
         ::ADsGetObject(
            path.c_str(),
            __uuidof(iads),
            reinterpret_cast<void**>(&dumb));
      BREAK_ON_FAILED_HRESULT2(hr, L"ADsGetObject failed on " + path);

      iads.Acquire(dumb);

      // description is a multivalued attrbute for no apparent good reason.
      // so we need to walk an array of values.
      
      _variant_t variant;
      hr = iads->GetEx(AutoBstr(L"description"), &variant);
      BREAK_ON_FAILED_HRESULT2(hr, L"read description failed");

      result = GetNdncDescriptionHelper(&variant);
   }
   while (0);

   LOG(result);

   return result;
}



void
ApplicationPartitionPage::PopulateListView()
{
   LOG_FUNCTION(ApplicationPartitionPage::PopulateListView);

   HWND view = Win::GetDlgItem(hwnd, IDC_NDNC_LIST);
   
   Win::ListView_DeleteAllItems(view);
   
   // Load up the edit box with the DNs we discovered

   LVITEM item;

   // REVIEWED-2002/02/22-sburns call correctly passes byte count.

   ::ZeroMemory(&item, sizeof item);

   const StringList& ndncList = State::GetInstance().GetAppPartitionList();

   if (!ndncList.size())
   {
      // put "none" in the list

      static const String NONE = String::load(IDS_NONE);
      
      item.mask     = LVIF_TEXT;
      item.pszText  = const_cast<wchar_t*>(NONE.c_str());
      item.iSubItem = 0;

      item.iItem = Win::ListView_InsertItem(view, item);
   }
   else
   {
      for (
         StringList::iterator i = ndncList.begin();
         i != ndncList.end();
         ++i)
      {
         item.mask     = LVIF_TEXT;
         item.pszText  = const_cast<wchar_t*>(i->c_str());
         item.iSubItem = 0;

         item.iItem = Win::ListView_InsertItem(view, item);

         // add the description sub-item to the list control

         String description = GetNdncDescription(*i);
      
         item.mask = LVIF_TEXT; 
         item.pszText = const_cast<wchar_t*>(description.c_str());
         item.iSubItem = 1;
      
         Win::ListView_SetItem(view, item);
      }
   }
}



bool
ApplicationPartitionPage::OnSetActive()
{
   LOG_FUNCTION(ApplicationPartitionPage::OnSetActive);

   Win::WaitCursor wait;

   State&  state  = State::GetInstance();
   Wizard& wizard = GetWizard();         

   // we re-evaluate this each time we hit the page to make sure the list
   // we present reflects the current state of the machine.
   
   bool wasLastReplica = state.GetAppPartitionList().size() ? true : false;
   bool isLastReplica  = state.IsLastAppPartitionReplica();

   if (
         state.RunHiddenUnattended()
      || (!wasLastReplica && !isLastReplica) )
   {
      LOG(L"Planning to skip ApplicationPartitionPage");

      if (wizard.IsBacktracking())
      {
         // backup once again

         wizard.Backtrack(hwnd);
         return true;
      }

      int nextPage = ApplicationPartitionPage::Validate();
      if (nextPage != -1)
      {
         LOG(L"skipping ApplicationPartitionPage");
         wizard.SetNextPageID(hwnd, nextPage);
         return true;
      }

      state.ClearHiddenWhileUnattended();
   }

   // at this point, we know that the machine is the last replica of
   // at least one ndnc.  Populate the list box.

   PopulateListView();
      
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



bool
ApplicationPartitionPage::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   /* lParam */ )
{
//   LOG_FUNCTION(ApplicationPartitionPage::OnNotify);

   bool result = false;
   
   if (controlIDFrom == IDC_HELP_LINK)
   {
      switch (code)
      {
         case NM_CLICK:
         case NM_RETURN:
         {
            LOG(L"launching ndnc help");
            
            Win::HtmlHelp(
               hwnd,
               L"adconcepts.chm::/ADHelpDemoteWithNDNC.htm",
               HH_DISPLAY_TOPIC,
               0);
            result = true;
         }
         default:
         {
            // do nothing
            
            break;
         }
      }
   }
   
   return result;
}



bool
ApplicationPartitionPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(ApplicationPartitionPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_REFRESH:
      {
         if (code == BN_CLICKED)
         {
            Win::WaitCursor wait;

            State::GetInstance().IsLastAppPartitionReplica();
            PopulateListView();
            return true;
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



int
ApplicationPartitionPage::Validate() 
{
   LOG_FUNCTION(ApplicationPartitionPage::Validate);

   return IDD_APP_PARTITION_CONFIRM;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\badcomputernamedialog.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Dlg to inform user of a bad computer name
//
// 21 Aug 2000 sburns



#ifndef BADCOMPUTERNAMEDIALOG_HPP_INCLUDED
#define BADCOMPUTERNAMEDIALOG_HPP_INCLUDED


                        
class BadComputerNameDialog : public Dialog
{
   public:

   explicit
   BadComputerNameDialog(const String& message_);

   virtual ~BadComputerNameDialog();

   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIdFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   String message;

   // not defined: no copying allowed

   BadComputerNameDialog(const BadComputerNameDialog&);
   const BadComputerNameDialog& operator=(const BadComputerNameDialog&);
};



#endif   // BADCOMPUTERNAMEDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\badcomputernamedialog.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Dlg to inform user of a bad computer name
//
// 21 Aug 2000 sburns


#include "headers.hxx"
#include "BadComputerNameDialog.hpp"
#include "resource.h"



static const DWORD HELP_MAP[] =
{
   0, 0
};



BadComputerNameDialog::BadComputerNameDialog(
   const String& message_)
   :
   Dialog(IDD_BAD_COMPUTER_NAME, HELP_MAP),
   message(message_)
{
   LOG_CTOR(BadComputerNameDialog);
   ASSERT(!message.empty());
}



BadComputerNameDialog::~BadComputerNameDialog()
{
   LOG_DTOR(BadComputerNameDialog);
}



bool
BadComputerNameDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIdFrom,
   unsigned    code)
{
   switch (controlIdFrom)
   {
      case IDCANCEL:
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            // the value with which we end this dialog is not important:
            // there is only one choice to the user: ACK

            Win::EndDialog(hwnd, 1);
            return true;
         }
         break;
      }
      case IDC_SHOW_HELP:
      {
         if (code == BN_CLICKED)
         {
            Win::HtmlHelp(
               hwnd,
               L"DNSConcepts.chm",
               HH_DISPLAY_TOPIC, 
               reinterpret_cast<DWORD_PTR>(L"error_dcpromo.htm"));
            return true;
         }
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return false;
}



void
BadComputerNameDialog::OnInit()
{
   LOG_FUNCTION(BadComputerNameDialog::OnInit);

   Win::SetDlgItemText(hwnd, IDC_TEXT, message);   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\capslockballoontip.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Caps lock warning Balloon tip window
//
// 7 Nov 2000 sburns (that would be election day)
//
// added to fix NTRAID#NTBUG9-202238-2000/11/06-sburns



#ifndef CAPSLOCKBALLOONTIP_HPP_INCLUDED
#define CAPSLOCKBALLOONTIP_HPP_INCLUDED



// Class used to show a balloon-style tool tip window that complains to the
// user that caps lock is on.  Used by PasswordEditBox.

class CapsLockBalloonTip
{
   public:



   CapsLockBalloonTip();



   // destroys the tool tip window, if it still exists
      
   ~CapsLockBalloonTip();


   // Initialize the tool tip, but don't show it.
   // 
   // parentWindow - in, the parent window handle of the control to have the
   // tool tip.  (The password edit control window).
   
   HRESULT
   Init(HWND parentWindow);
   


   // Show or hide the tip window.
   //
   // notHidden - in, if true, show the window.  If false, hide it.

   void
   Show(bool notHidden);
   

   
   private:

   // not implemented: no copying allowed

   CapsLockBalloonTip(const CapsLockBalloonTip&);
   const CapsLockBalloonTip& operator=(const CapsLockBalloonTip&);

   String title;
   String text;
   bool   visible;
   HWND   tipWindow;
   HWND   parentWindow;
};



#endif   // CAPSLOCKBALLOONTIP_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\capslockballoontip.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Caps lock warning Balloon tip window
//
// 7 Nov 2000 sburns (that would be election day)
//
// added to fix NTRAID#NTBUG9-202238-2000/11/06-sburns
//
// most of this is stolen and cleaned up from johnstep's common cred ui
// ds/win32/credui



#include "headers.hxx"
#include "CapsLockBalloonTip.hpp"
#include "resource.h"



CapsLockBalloonTip::CapsLockBalloonTip()
   :
   title(String::load(IDS_CAPS_LOCK_TIP_TITLE)),
   text(String::load(IDS_CAPS_LOCK_TIP_TEXT)),
   tipWindow(0),
   parentWindow(0),
   visible(false)
{
   LOG_CTOR(CapsLockBalloonTip);
   ASSERT(!title.empty());
   ASSERT(!text.empty());
}



CapsLockBalloonTip::~CapsLockBalloonTip()
{
   LOG_DTOR(CapsLockBalloonTip);

   if (Win::IsWindow(tipWindow))
   {
      Win::DestroyWindow(tipWindow);
      tipWindow = 0;
   }
}



HRESULT
CapsLockBalloonTip::Init(HWND parentWindow_)
{
   LOG_FUNCTION(CapsLockBalloonTip::Init);
   ASSERT(Win::IsWindow(parentWindow_));

   // should not call init on the same instance twice
   
   ASSERT(!parentWindow);
   ASSERT(!tipWindow);

   if (Win::IsWindow(tipWindow))
   {
      Win::DestroyWindow(tipWindow);
   }

   HRESULT hr = S_OK;

   do
   {
      hr = Win::CreateWindowEx(
         WS_EX_TOPMOST,
         TOOLTIPS_CLASS,
         L"",
         WS_POPUP | TTS_NOPREFIX | TTS_BALLOON,
         CW_USEDEFAULT,
         CW_USEDEFAULT,
         CW_USEDEFAULT,
         CW_USEDEFAULT,
         parentWindow_,
         0,
         0,
         tipWindow);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(tipWindow);
               
      parentWindow = parentWindow_;

      TOOLINFO info;

      // REVIEWED-2002/02/22-sburns call correctly passes byte count.

      ::ZeroMemory(&info, sizeof info);

      // we want to specify the stem position, so we set TTF_TRACK.  We use
      // the HWND of the parent window as the tool id, because that is what
      // v.5 of comctl32 requires (or the balloon never appears).  This is
      // a bug that has been fixed in v.6, but until fusion manifests are
      // working properly, you can't get v.6
      //
      // (when manifests are working, then we could remove TTF_IDISHWND and
      // set uId to be some fixed integer)
      
      info.uFlags   = TTF_IDISHWND | TTF_TRACK;   
      info.hwnd     = parentWindow;
      info.uId      = reinterpret_cast<UINT_PTR>(parentWindow); 
      info.lpszText = const_cast<PWCHAR>(text.c_str());

      Win::ToolTip_AddTool(tipWindow, info);
      Win::ToolTip_SetTitle(tipWindow, TTI_WARNING, title);
   }
   while (0);

   return hr;
}



void
CapsLockBalloonTip::Show(bool notHidden)
{
//   LOG_FUNCTION(CapsLockBalloonTip::Show);

   TOOLINFO info;

   // REVIEWED-2002/02/22-sburns call correctly passes byte count.
   
   ::ZeroMemory(&info, sizeof info);

   // set these members the same as in the Init method, in order to
   // identify the proper tool.
   
   info.hwnd = parentWindow; 
   info.uId = reinterpret_cast<UINT_PTR>(parentWindow); 
   
   if (notHidden)
   {
      if (!visible && Win::IsWindowEnabled(parentWindow))
      {
         Win::SetFocus(parentWindow);

         RECT rect;
         Win::GetWindowRect(parentWindow, rect);

         Win::ToolTip_TrackPosition(
            tipWindow,

            // put the stem at the point 90% along the x axis
            
            rect.left + 90 * (rect.right - rect.left) / 100,

            // and 76% along the y axis of the edit control
            
            rect.top + 76 * (rect.bottom - rect.top) / 100);

         Win::ToolTip_TrackActivate(tipWindow, true, info);   

         visible = true;
      }
   }
   else
   {
      // hide the tip window
      
      if (visible)
      {
         Win::ToolTip_TrackActivate(tipWindow, false, info);   
         visible = false;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\checkdomainupgradedpage.hpp ===
// Copyright (C) 2001 Microsoft Corporation
//
// verify that the domain of this upgraded BDC has been upgraded to
// Active Directory, and that we can find a DS DC for that domain
// NTRAID#NTBUG9-490197-2001/11/20-sburns
//
// 20 Nov 2001 sburns



#ifndef CHECKDOMAINUPGRADEDPAGE_HPP_INCLUDED
#define CHECKDOMAINUPGRADEDPAGE_HPP_INCLUDED



class CheckDomainUpgradedPage : public DCPromoWizardPage
{
   public:

   CheckDomainUpgradedPage();

   protected:

   virtual ~CheckDomainUpgradedPage();

   // Dialog overrides

   // virtual
   // bool
   // OnNotify(
   //    HWND     windowFrom,
   //    UINT_PTR controlIDFrom,
   //    UINT     code,
   //    LPARAM   lParam);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   bool
   CheckDsDcFoundAndUpdatePageText();

   // not defined; no copying allowed
   CheckDomainUpgradedPage(const CheckDomainUpgradedPage&);
   const CheckDomainUpgradedPage& operator=(const CheckDomainUpgradedPage&);
};



#endif   // CHECKDOMAINUPGRADEDPAGE_HPP_INCLUDED{
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\checkportavailability.hpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// Check availability of ports used by Active Directory
//
// 1 Nov 2000 sburns



#ifndef CHECKPORTAVAILABILITY_HPP_INCLUDED
#define CHECKPORTAVAILABILITY_HPP_INCLUDED



// Return true if all the IP ports used by the DS are available on this
// machine, false if not. If the result is false, then also pop up a dialog
// listing the ports that are in use.
// 
// NTRAID#NTBUG9-129955-2000/11/01-sburns

bool
AreRequiredPortsAvailable();



class PortsUnavailableErrorDialog : public Dialog
{
   public:

   PortsUnavailableErrorDialog(StringList& portsInUseList);

   virtual
   ~PortsUnavailableErrorDialog();

   private:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // not defined: no copying allowed

   PortsUnavailableErrorDialog(const PortsUnavailableErrorDialog&);
   const PortsUnavailableErrorDialog& operator=(const PortsUnavailableErrorDialog&);

   StringList& portsInUseList;
};



#endif   // CHECKPORTAVAILABILITY_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\checkdomainupgradedpage.cpp ===
// Copyright (C) 2001 Microsoft Corporation
//
// verify that the domain of this upgraded BDC has been upgraded to
// Active Directory, and that we can find a DS DC for that domain
// NTRAID#NTBUG9-490197-2001/11/20-sburns
//
// 20 Nov 2001 sburns



#include "headers.hxx"
#include "page.hpp"
#include "CheckDomainUpgradedPage.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"



CheckDomainUpgradedPage::CheckDomainUpgradedPage()
   :
   DCPromoWizardPage(
      IDD_CHECK_DOMAIN_UPGRADED,
      IDS_CHECK_DOMAIN_UPGRADED_TITLE,
      IDS_CHECK_DOMAIN_UPGRADED_SUBTITLE)
{
   LOG_CTOR(CheckDomainUpgradedPage);
}



CheckDomainUpgradedPage::~CheckDomainUpgradedPage()
{
   LOG_DTOR(CheckDomainUpgradedPage);
}



// bool
// CheckDomainUpgradedPage::OnNotify(
//    HWND     /* windowFrom */ ,
//    UINT_PTR controlIDFrom,
//    UINT     code,
//    LPARAM   /* lParam */ )
// {
// //   LOG_FUNCTION(CheckDomainUpgradedPage::OnNotify);
// 
//    bool result = false;
//    
//    if (controlIDFrom == IDC_JUMP)
//    {
//       switch (code)
//       {
//          case NM_CLICK:
//          case NM_RETURN:
//          {
//             ShowTroubleshooter(hwnd, IDS_CONFIG_DNS_HELP_TOPIC);
//             result = true;
//          }
//          default:
//          {
//             // do nothing
//             
//             break;
//          }
//       }
//    }
//    
//    return result;
// }



void
CheckDomainUpgradedPage::OnInit()
{
   LOG_FUNCTION(CheckDomainUpgradedPage::OnInit);
}



bool
CheckDomainUpgradedPage::OnSetActive()
{
   LOG_FUNCTION(CheckDomainUpgradedPage::OnSetActive);

   State& state = State::GetInstance();

   ASSERT(state.GetRunContext() == State::BDC_UPGRADE);
   ASSERT(state.GetOperation() == State::REPLICA);
   
   if (state.RunHiddenUnattended() || CheckDsDcFoundAndUpdatePageText())
   {
      LOG(L"planning to Skip CheckDomainUpgradedPage");

      Wizard& wiz = GetWizard();

      if (wiz.IsBacktracking())
      {
         // backup once again
         wiz.Backtrack(hwnd);
         return true;
      }

      int nextPage = CheckDomainUpgradedPage::Validate();
      if (nextPage != -1)
      {
         LOG(L"skipping CheckDomainUpgradedPage");         
         wiz.SetNextPageID(hwnd, nextPage);
         return true;
      }

      state.ClearHiddenWhileUnattended();
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



int
CheckDomainUpgradedPage::Validate()
{
   LOG_FUNCTION(CheckDomainUpgradedPage::Validate);

   int nextPage = -1;

   if (CheckDsDcFoundAndUpdatePageText())
   {
      nextPage = IDD_GET_CREDENTIALS;
   }
   else
   {
      String message = String::load(IDS_CONVERT_PDC_FIRST);

      popup.Info(hwnd, message);
   }

   return nextPage;
}



// Returns true if the domain that this machine was a BDC for has been
// upgraded to Active Directory, false if not, or if we can't tell.  We tell
// by attempting to find a DS DC for the domain.  We set the page text and
// save the domain name based on our attempt.
 
bool
CheckDomainUpgradedPage::CheckDsDcFoundAndUpdatePageText()
{
   LOG_FUNCTION(CheckDomainUpgradedPage::CheckDsDcFoundAndUpdatePageText);

   State& state             = State::GetInstance();                      
   bool   result            = false;                                     
   int    messageId         = IDS_DOMAIN_NOT_UPGRADED_OR_NETWORK_ERROR;                     
   String domainNetbiosName = state.GetComputer().GetDomainNetbiosName();
  
   Win::WaitCursor wait;
   
   do
   {
      // First, attempt to find a DS DC
   
      DOMAIN_CONTROLLER_INFO* info = 0;
      HRESULT hr =
         MyDsGetDcName(
            0,
            domainNetbiosName,
            DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME,
            info);
      if (SUCCEEDED(hr) && info)
      {
         if ((info->Flags & DS_DNS_DOMAIN_FLAG) && info->DomainName)
         {
            // we found a DS domain

            state.SetReplicaDomainDNSName(info->DomainName);
            messageId = IDS_DOMAIN_WAS_UPGRADED;
            result    = true;                   
         }
         ::NetApiBufferFree(info);

         break;
      }
   
      // That attempt failed, so try again for any DC (DS or otherwise) for
      // the domain.

      // This is not a Dr. DNS (DiagnoseDcNotFound) failure case, since the
      // code to get the domain name is not using the DNS domain name.
      
      hr = MyDsGetDcName(0, domainNetbiosName, 0, info);
      if (SUCCEEDED(hr) && info)
      {
         // If that succeeds, then we know the that domain is not upgraded
         // yet, or that a DS DC of the domain is not reachable via its
         // netbios name, which is probably a net connectivity problem or
         // WINS problem.

         ::NetApiBufferFree(info);

         messageId = IDS_DOMAIN_NOT_UPGRADED_OR_NETWORK_ERROR;
         
         break;
      }

      // Here, we can't find a DC of any kind for the domain.          

      // If that fails, then we can't find any dc for the domain, and
      // have a net connectivty or WINS problem.
      
      messageId = IDS_NETWORK_ERROR;
   }
   while (0);

   Win::SetDlgItemText(
      hwnd,
      IDC_MESSAGE,
      String::format(messageId, domainNetbiosName.c_str()));

   return result;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\checkportavailability.cpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// Check availability of ports used by Active Directory
//
// 1 Nov 2000 sburns



#include "headers.hxx"
#include "state.hpp"
#include "resource.h"
#include "CheckPortAvailability.hpp"



static const DWORD HELP_MAP[] =
{
   0, 0
};



PortsUnavailableErrorDialog::PortsUnavailableErrorDialog(
   StringList& portsInUseList_)
   :
   Dialog(IDD_PORTS_IN_USE_ERROR, HELP_MAP),
   portsInUseList(portsInUseList_)
{
   LOG_CTOR(PortsUnavailableErrorDialog);

   ASSERT(portsInUseList.size());
}



PortsUnavailableErrorDialog::~PortsUnavailableErrorDialog()
{
   LOG_DTOR(PortsUnavailableErrorDialog);
}



void
PortsUnavailableErrorDialog::OnInit()
{
   LOG_FUNCTION(PortsUnavailableErrorDialog::OnInit);

   // Load up the edit box with the DNs we aliased in the ctor.

   String text;
   for (
      StringList::iterator i = portsInUseList.begin();
      i != portsInUseList.end();
      ++i)
   {
      text += *i + L"\r\n";
   }

   Win::SetDlgItemText(hwnd, IDC_PORT_LIST, text);
}



bool
PortsUnavailableErrorDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(PortsUnavailableErrorDialog::OnCommand);

   if (code == BN_CLICKED)
   {
      switch (controlIDFrom)
      {
         case IDOK:
         case IDCANCEL:
         {
            Win::EndDialog(hwnd, controlIDFrom);
            return true;
         }
         default:
         {
            // do nothing
         }
      }
   }

   return false;
}



// Determine the service name, aliases of that name, and protocol used for a
// given port number.  Return S_OK on success, else return a failure code.
//
// winsock must have been initialized prior to calling this function.
// 
// portNumber - in, the port number for which the info should be determined.
// 
// name - out, the name of the service that runs on that port
// 
// aliases - out, other names for the service that runs on the port
// 
// protocol - out, the name of the protocol used on the port.

HRESULT
GetServiceOnPort(
   int         portNumber,
   String&     name,
   StringList& aliases,
   String&     protocol)
{
   LOG_FUNCTION2(GetServiceOnPort, String::format(L"%1!d!", portNumber));
   ASSERT(portNumber);

   HRESULT hr = S_OK;
   name.erase();
   aliases.clear();
   protocol.erase();

   int portNetByteOrder = htons((u_short) portNumber);
   servent* se = ::getservbyport(portNetByteOrder, 0);
   if (!se)
   {
      hr = Win32ToHresult((DWORD) ::WSAGetLastError());
   }
   else
   {
      if (se->s_name)
      {
         name = se->s_name;
      }
      if (se->s_proto)
      {
         protocol = se->s_proto;
      }

      char** a = se->s_aliases;
      while (*a)
      {
         aliases.push_back(*a);
         ++a;
      }
   }

#ifdef LOGGING_BUILD
   LOG_HRESULT(hr);
   LOG(name);
   for (
      StringList::iterator i = aliases.begin();
      i != aliases.end();
      ++i)
   {
      LOG(*i);
   }
   LOG(protocol);
#endif

   return hr;
}



// S_FALSE if an application has the port open in exclusive mode, S_OK if not,
// and error otherwise.
//
// winsock must have been initialized prior to calling this function.
//
// portNumber - in, port to check.

HRESULT
CheckPortAvailability(int portNumber)
{
   LOG_FUNCTION2(CheckPortAvailability, String::format(L"%1!d!", portNumber));
   ASSERT(portNumber);

   HRESULT hr = S_OK;

   do
   {
      sockaddr_in local;

      // REVIEWED-2002/02/22-sburns call correctly passes byte count.
      
      ::ZeroMemory(&local, sizeof local);
      
      local.sin_family      = AF_INET;       
      local.sin_port        = htons((u_short) portNumber);
      local.sin_addr.s_addr = INADDR_ANY;    

      SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
   
      if (sock == INVALID_SOCKET)
      {
         LOG(L"can't build socket");
         hr = Win32ToHresult((DWORD) ::WSAGetLastError());
         break;
      }

      if (
         bind(
            sock,
            (sockaddr*) &local,
            sizeof local) == SOCKET_ERROR)
      {
         LOG(L"bind failed");

         DWORD sockerr = ::WSAGetLastError();

         if (sockerr == WSAEADDRINUSE)
         {
            // a process on this box already has the socket open in
            // exclusive mode.

            hr = S_FALSE;
         }
         else
         {
            hr = Win32ToHresult(sockerr);
         }
         break;
      }

      // at this point, the bind was successful
      
      ASSERT(hr == S_OK);
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}

   

// Create a string that represents the port and the service name(s) running on
// that port.  This string is presented in the ui.
// 
// winsock must have been initialized prior to calling this function.
//
// portNumber - in, port to check.

String
MakeUnavailablePortListEntry(int portNumber)
{
   LOG_FUNCTION(MakeUnavailablePortListEntry);
   ASSERT(portNumber);

   String entry;

   do
   {
      String name;
      String protocol;
      StringList aliases;
      
      HRESULT hr = GetServiceOnPort(portNumber, name, aliases, protocol);   
      if (FAILED(hr))
      {
         // make a simple entry with just the port number

         entry = String::format(L"%1!d!", portNumber);
         break;
      }
                  
      if (aliases.size())
      {
         // combine the aliases into a comma-separated list

         String aliasParam;
         size_t j = 0;
         for (
            StringList::iterator i = aliases.begin();
            i != aliases.end();
            ++i, ++j)
         {
            aliasParam += *i;
            if (j < (aliases.size() - 1))
            {
               aliasParam += L", ";
            }
         }

         entry =
            String::format(
               L"%1!d! %2 (%3)",
               portNumber,
               name.c_str(),
               aliasParam.c_str());
      }
      else
      {
         // no aliases
         
         entry = String::format(L"%1!d! %2", portNumber, name.c_str());
      }
   }
   while (0);

   LOG(entry);

   return entry;
}



// Determine if any of a set of tcp ports required by the DS is already in use
// by another application on this machine.  Return S_OK if the list can be
// made, a failure code otherwise.
// 
// portsInUseList - out, a list of strings representing the ports in use and
// the name(s) of the services that are running on them, suitable for UI
// presentation.

HRESULT
EnumerateRequiredPortsInUse(StringList& portsInUseList)
{
   LOG_FUNCTION(EnumerateRequiredPortsInUse);

   portsInUseList.clear();
   HRESULT hr = S_FALSE;
   bool cleanupWinsock = false;

   do
   {
      WSADATA data;
      hr = Win32ToHresult((DWORD) ::WSAStartup(MAKEWORD(2,0), &data));
      BREAK_ON_FAILED_HRESULT(hr);

      cleanupWinsock = true;

      static const int REQUIRED_PORTS[] =
      {
         88,   // TCP/UDP Kerberos
         389,  // TCP LDAP
         636,  // TCP sldap
         3268, // TCP ldap/GC
         3269, // TCP sldap/GC
         0
      };

      const int* port = REQUIRED_PORTS;
      while (*port)
      {
         HRESULT hr2 = CheckPortAvailability(*port);
         if (hr2 == S_FALSE)
         {
            // Make an entry in the "in use" list
            
            portsInUseList.push_back(MakeUnavailablePortListEntry(*port));
         }
         
         // we ignore any other type of failure and check the remaining
         // ports.
         
         ++port;
      }
   }
   while (0);

   if (cleanupWinsock)
   {
      ::WSACleanup();
   }

#ifdef LOGGING_BUILD
   LOG_HRESULT(hr);

   for (
      StringList::iterator i = portsInUseList.begin();
      i != portsInUseList.end();
      ++i)
   {
      LOG(*i);
   }
#endif

   return hr;
}
   

    
bool
AreRequiredPortsAvailable()
{
   LOG_FUNCTION(AreRequiredPortsAvailable);

   bool result = true;

   do
   {
      State::RunContext context = State::GetInstance().GetRunContext();
      if (context == State::NT5_DC)
      {
         // already a DC, so we don't care about the port status, as the
         // only thing the user will be able to do is demote the box.

         LOG(L"already a DC -- port check skipped");
         ASSERT(result);

         break;
      }

      // Find the list of IP ports required by the DS that are already in use
      // (if any).  If we find some, gripe at the user.

      StringList portsInUseList;
      HRESULT hr = EnumerateRequiredPortsInUse(portsInUseList);
      if (FAILED(hr))
      {
         // if we can't figure out if the required ports are in use, then
         // just muddle on -- the user will have to clean up after the
         // promote.

         ASSERT(result);
         break;
      }

      if (hr == S_FALSE || portsInUseList.size() == 0)
      {
         LOG(L"No required ports already in use");
         ASSERT(result);
         
         break;
      }

      result = false;
         
      // there should be at least one port in the list.

      ASSERT(portsInUseList.size());

      PortsUnavailableErrorDialog(portsInUseList).ModalExecute(
         Win::GetDesktopWindow());
   }
   while (0);

   LOG(result ? L"true" : L"false");

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\childpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// new child page
//
// 1-5-98 sburns



#ifndef CHILDPAGE_HPP_INCLUDED
#define CHILDPAGE_HPP_INCLUDED



class ChildPage : public DCPromoWizardPage
{
   public:

   ChildPage();

   protected:

   virtual ~ChildPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   HWND currentFocus;
   
   // not defined; no copying allowed

   ChildPage(const ChildPage&);
   const ChildPage& operator=(const ChildPage&);
};



#endif   // CHILDPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\common.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// code common to several pages
//
// 12-16-97 sburns



String
BrowseForDomain(HWND parent);



String
BrowseForFolder(HWND parent, int titleResID);



// Returns true if the available space on the path is >= minSpaceMB.
// "available" means "taking into account quotas."
// 
// path - Fully qualified path to test.
// 
// minSpaceMB - minimum disk space in megabytes to ensure is availble on that
// path.

bool
CheckDiskSpace(const String& path, unsigned minSpaceMB);



// Return true if either of the netbios or fully-qualified computer names of
// the machine have been changed since the last time the computer was
// restarted, false otherwise.

bool
ComputerWasRenamedAndNeedsReboot();



// Check if a screen saver or low power sleep mode is enabled.  If one is,
// disable it.  Also tell winlogon not to allow locking the console if
// necessary.  
// 
// This is to prevent the computer or user from locking the console while a
// lenthy operation is taking place.  Since the user may be logged on as an
// account that the operation destroys, once the machine is locked, there's no
// way to unlock it. 290581, 311161

void
DisableConsoleLocking();



// Enable winlogon console locking

void
EnableConsoleLocking();



// Locates a domain controller for the domain specified by the user on the
// credential page.  Returns S_OK and sets computerName if a domain controller
// is found, otherwise the error returned by DsGetDcName, converted to an
// HRESULT.
//
// domainName - the name of the domain for which a DC should be located.
//
// computerName - string to receive the domain controller name, set to empty
// on error.

HRESULT
GetDcName(const String& domainName, String& computerName);



// Return the drive letter of the first NTFS 5 drive on the system (as "X:\"),
// or empty if no such drive can be found.

String
GetFirstNtfs5HardDrive();



// Return the DNS domain name of the forest root domain for the forest that
// contains the given domain.  Return empty string if that name can't be
// determined.
// 
// domain - in, netbios or DNS domain name of a domain in a forest.
//
// hr - in/out, if the caller is curious about the failure code, he can
// retrieve it by passing a non-null pointer here.

String
GetForestName(const String& domain, HRESULT* hr = 0);



// Return the DNS name of the domain that is the parent domain of the given
// domain, or return the empty string if the domain is not a child domain
// (i.e. is a tree root domain).
// 
// childDomainDNSName - DNS name of the candidate child domain.  It is assumed
// that this domain exits.
// 
// bindWithCredentials - true: discover the parent domain by using the the
// credentials information collected on the CredentialsPage.  false: use the
// current logged-on user's credentials.

String
GetParentDomainDnsName(
   const String&  childDomainDNSName,
   bool           bindWithCredentials);



bool
IsChildDomain(bool bindWithCredentials);



bool
IsRootDomain(bool bindWithCredentials);



bool
IsForestRootDomain();



// Returns true if the password and confirmation match, and the password
// meets the password policy in effect on the local machine. Otherwise,
// reports the reason the password is rejected, clears the edit controls,
// and returns false.
//
// dialog - handle to the window with the password and confirmation edit
// controls to test.
//
// passwordResId - resource ID of the password edit control.
//
// confirmResId - resource ID of the password confirmation edit control.
//
// isForSafeMode - true if the password is used for a promotion operation
// i.e. the password is a candidate safe mode admin password.  In this case,
// the policy check is skipped if the password is blank, the wizard is
// running in unattended mode, and no password was specified in the
// answerfile. false otherwise, which means the policy check will always 
// be made.
//
// validatedPassword - out, if the password is accepted, then it is returned
// in this parameter. If the password is rejected, the parameter is set to
// the empty string.

bool
IsValidPassword(
   HWND             dialog,           
   int              passwordResId,    
   int              confirmResId,
   bool             isForSafeMode,
   EncryptedString& validatedPassword);



String
MassageUserName(const String& domainName, const String& userName);



HRESULT
ReadDomains(StringList& domains);



// Sets the font of a given control in a dialog.
// 
// parentDialog - Dialog containing the control.
// 
// controlID - Res ID of the control for which the font will be
// changed.
// 
// font - handle to the new font for the control.

void
SetControlFont(HWND parentDialog, int controlID, HFONT font);



// Sets the font of a control to a large point bold font as per Wizard '97
// spec.
// 
// dialog - handle to the dialog that is the parent of the control
// 
// bigBoldResID - resource id of the control to change

void
SetLargeFont(HWND dialog, int bigBoldResID);



void
ShowTroubleshooter(HWND parent, int topicResID);





// Validates a given file path for proper syntax and other requirements. If
// validation fails, presents appropriate error messages to the user, and sets
// the input focus to a given control. Returns true if the validation succeed,
// false if not.
// 
// path - file path to be validatated.
// 
// parent - handle to the window containing the edit box that: contains the
// name to be validated and receives focus if the validation fails.
//
// editResId - the resource id of the edit control containing the domain name
// to be validated (if the domainName parameter is empty), also receives input
// focus if validation fails.
// 
// requiresNtfs5 - true if the path must refer to an NTFS 5 volume.
// 
// requiresAsciiCharacters - true if the path may only contain 7-bit ASCII
// characters.
//
// requiresUncompressedFolder - true if the path may not be compressed.

bool
ValidateDcInstallPath(
   const String&  path,
   HWND           parent,
   int            editResId,
   bool           requiresNtfs5 = false,
   bool           requiresAsciiCharacters = false,
   bool           requiresUncompressedFolder = false);



bool
ValidateChildDomainLeafNameLabel(
   HWND dialog,        
   int  editResID,     
   bool gripeOnNonRfc);



// Checks the candidate password against the password policy in effect on the
// local machine. Returns S_OK if the password is acceptable, or one of:
// 
// Win32ToHresult(NERR_PasswordTooShort)
// Win32ToHresult(NERR_PasswordTooLong)
// Win32ToHresult(NERR_PasswordNotComplexEnough)
// Win32ToHresult(NERR_PasswordFilterError)
// 
// or some other error that indicates that the policy check failed.
// 
// password - the candidate password
// 
// userName - the name of the account on which the password would be applied.
// This is used to ensure that the password does not include the account name.
// If the account does not exist, pass an empty String.
      
HRESULT
ValidatePasswordAgainstPolicy(
   const EncryptedString&  password,
   const String&           userName);



bool
ValidateSiteName(HWND dialog, int editResID);



// Determine if the domain name provided refers to an existing DS domain.
// Return true if it does, false if not (or if it does not refer to the domain
// the user expected).
//
// dialog - handle to the dialog containing the edit box that: contains the
// name to be validated and receives focus if the validation fails.
// 
// domainName - the domain name to validate.  If the empty string, then the
// name is taken from the edit control identified by editResID.
// 
// editResID - the resource id of the edit control containing the domain name
// to be validated (if the domainName parameter is empty), also receives input
// focus if validation fails.
//
// domainDNSName - if domainName is a netbios domain name, and it refers to a
// DS domain, then this parameter receives the DNS domain name of the domain.
// In this case, the user is prompted to confirm whether or not he intended to
// refer to the domain (because a netbios name is also a legal DNS name).  If
// the user indicates yes, that was his intention, then validation succeeds
// and the caller should use the value returned through this parameter as the
// DNS domain name.  If the answer is no, validation fails, and this parameter
// is empty.  If domainName does not refer to a DS domain, validation fails,
// and this parameter is empty.

bool
ValidateDomainExists(
   HWND           dialog,
   const String&  domainName,
   int            editResID,
   String&        domainDNSName);


// Overloads ValidateDomainExists such that the domain name to be
// validated is taken from the edit control specified by editResID.

bool
ValidateDomainExists(HWND dialog, int editResID, String& domainDNSName);

bool
ValidateDomainDoesNotExist(
   HWND           dialog,
   const String&  domainName,
   int            editResID);



bool
ValidateDomainDoesNotExist(
   HWND           dialog,
   int            editResID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\configurednsclientpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// dns client configuration page
//
// 12-22-97 sburns



#ifndef CONFIGUREDNSCLIENTPAGE_HPP_INCLUDED
#define CONFIGUREDNSCLIENTPAGE_HPP_INCLUDED



class ConfigureDnsClientPage : public DCPromoWizardPage
{
   public:

   ConfigureDnsClientPage();

   protected:

   virtual ~ConfigureDnsClientPage();

   // Dialog overrides

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lParam);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   ConfigureDnsClientPage(const ConfigureDnsClientPage&);
   const ConfigureDnsClientPage& operator=(const ConfigureDnsClientPage&);
};



#endif   // CONFIGUREDNSCLIENTPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\childpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// new child page
//
// 12-22-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "ChildPage.hpp"
#include "resource.h"
#include "dns.hpp"
#include "common.hpp"
#include "state.hpp"
#include <ValidateDomainName.hpp>
#include <ValidateDomainName.h>

ChildPage::ChildPage()
   :
   DCPromoWizardPage(
      IDD_NEW_CHILD,
      IDS_CHILD_PAGE_TITLE,
      IDS_CHILD_PAGE_SUBTITLE),
   currentFocus(0)   
{
   LOG_CTOR(ChildPage);
}



ChildPage::~ChildPage()
{
   LOG_DTOR(ChildPage);
}



void
ChildPage::OnInit()
{
   LOG_FUNCTION(ChildPage::OnInit);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_PARENT),
      DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY);
   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_LEAF),
      Dns::MAX_LABEL_LENGTH);
      
   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_PARENT,
         state.GetAnswerFileOption(AnswerFile::OPTION_PARENT_DOMAIN_NAME));
      Win::SetDlgItemText(
         hwnd,
         IDC_LEAF,
         state.GetAnswerFileOption(AnswerFile::OPTION_CHILD_NAME));
   }
   else
   {
      // default domain is that to which the server is joined.

      Win::SetDlgItemText(
         hwnd,
         IDC_PARENT,
         state.GetComputer().GetDomainDnsName());
      
      // @@ if PDC_UPGRADE, set the pdc flat name as the leaf name here
   }
}


static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   int next =
         (  !Win::GetTrimmedDlgItemText(dialog, IDC_PARENT).empty()
         && !Win::GetTrimmedDlgItemText(dialog, IDC_LEAF).empty() )
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);
}


   
bool
ChildPage::OnCommand(
   HWND        windowFrom,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(ChildPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_BROWSE:
      {
         if (code == BN_CLICKED)
         {
            String domain = BrowseForDomain(hwnd);
            if (!domain.empty())
            {
               Win::SetDlgItemText(hwnd, IDC_PARENT, domain);
            }

            // For some reason, the base dialog code (or perhaps the propsheet
            // code) will set the focus to the next button on the sheet (which
            // in this case is the Back button).  That's s-tupid.  The focus
            // should remain on whatever control had it previously.

            Win::PostMessage(
               Win::GetParent(hwnd),
               WM_NEXTDLGCTL,
               reinterpret_cast<WPARAM>(currentFocus),
               TRUE);
               
            return true;
         }
         else if (code == BN_SETFOCUS)
         {
            currentFocus = windowFrom;
            ASSERT(currentFocus == Win::GetDlgItem(hwnd, IDC_BROWSE));

            // sometimes the default style is stolem by the wizard navigation
            // buttons. Insist that if we're getting focus, we've also got the
            // default style. We have to use PostMessage here to that our
            // changes arrive after the message processing of the prop sheet
            // (essentially to steal the default style back again).
            
            Win::PostMessage(
               windowFrom,

               // we use this message instead of DM_SETDEFID, as this works
               // and DM_SETDEFID does not. See the sdk docs for a possible
               // reason why.
               
               BM_SETSTYLE,
               BS_DEFPUSHBUTTON,
               TRUE);

            // unfortunately, sometimes the prop sheet will set the default
            // style on one of the wizard navigation buttons. This brittle
            // hack will take care of that.  I discovered the control IDs
            // by using spy++.
            // I'm not proud of this, but, hey, we've got a product to ship
            // and of course, every bug in comctl32 is by design.
               
            Win::PostMessage(
               Win::GetDlgItem(Win::GetParent(hwnd), Wizard::BACK_BTN_ID),
               BM_SETSTYLE,
               BS_PUSHBUTTON,
               TRUE);
               
            Win::PostMessage(
               Win::GetDlgItem(Win::GetParent(hwnd), Wizard::NEXT_BTN_ID),
               BM_SETSTYLE,
               BS_PUSHBUTTON,
               TRUE);
         }
         break;
      }
      case IDC_LEAF:
      case IDC_PARENT:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);

            String parent = Win::GetTrimmedDlgItemText(hwnd, IDC_PARENT);
            String leaf = Win::GetTrimmedDlgItemText(hwnd, IDC_LEAF);
            String domain = leaf + L"." + parent;

            Win::SetDlgItemText(hwnd, IDC_DOMAIN, domain);
            enable(hwnd);
            return true;                                                     
         }
         else if (code == EN_SETFOCUS)
         {
            currentFocus = windowFrom;
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



bool
ChildPage::OnSetActive()
{
   LOG_FUNCTION(ChildPage::OnSetActive);
   ASSERT(State::GetInstance().GetOperation() == State::CHILD);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = ChildPage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }

   enable(hwnd);
   return true;
}

   

int
ChildPage::Validate()
{
   LOG_FUNCTION(ChildPage::Validate);

   String parent = Win::GetTrimmedDlgItemText(hwnd, IDC_PARENT);
   String leaf = Win::GetTrimmedDlgItemText(hwnd, IDC_LEAF);
   String domain = leaf + L"." + parent;

   State& state = State::GetInstance();
   int nextPage = -1;

   // SPB:251431 do validation even if this page is untouched, as upstream
   // pages may have been changed in such a fashion that re-validation is
   // required.

   // if (!WasChanged(IDC_PARENT) && !WasChanged(IDC_LEAF))
   // {
   //    return nextPage;
   // }

   do
   {
      if (parent.empty())
      {
         popup.Gripe(hwnd, IDC_PARENT, IDS_MUST_ENTER_PARENT);
         break;
      }

      if (leaf.empty())
      {
         popup.Gripe(hwnd, IDC_LEAF, IDS_MUST_ENTER_LEAF);
         break;
      }

      bool parentIsNonRfc = false;
      if (
         !ValidateDomainDnsNameSyntax(
            hwnd,
            IDC_PARENT,
            popup,

            // only warn on non RFC names if running interactively

            !state.RunHiddenUnattended(),
            
            &parentIsNonRfc))
      {
         break;
      }

      if (
         !ValidateChildDomainLeafNameLabel(
            hwnd,
            IDC_LEAF,

            // only gripe if the parent is RFC and we're not hidden
            // NTRAID#NTBUG9-523532-2002/04/19-sburns
      
            !state.RunHiddenUnattended() && !parentIsNonRfc) )
      {
         break;
      }

      // now ensure that the parent domain exists

      String dnsName;
      if (!ValidateDomainExists(hwnd, IDC_PARENT, dnsName))
      {
         break;
      }
      if (!dnsName.empty())
      {
         // the user specified the netbios name of the domain, and
         // confirmed it, so use the dns domain name returned.

         parent = dnsName;
         domain = leaf + L"." + parent;
         Win::SetDlgItemText(hwnd, IDC_PARENT, dnsName);
         Win::SetDlgItemText(hwnd, IDC_DOMAIN, domain);
      }

      if (!state.IsDomainInForest(parent))
      {
         popup.Gripe(
            hwnd,
            IDC_DOMAIN,
            String::format(
               IDS_DOMAIN_NOT_IN_FOREST,
               parent.c_str(),
               state.GetUserForestName().c_str()));
         break;
      }
         
      if (domain.length() > DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY)
      {
         String message =
            String::format(
               IDS_DNS_NAME_TOO_LONG,
               domain.c_str(),
               DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY,
               DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8);
         popup.Gripe(hwnd, IDC_LEAF, message);
         break;
      }

      // validate the resulting child domain name, not warning on non-RFCness

      if (
         !ValidateDomainDnsNameSyntax(
            hwnd,
            domain,
            IDC_LEAF,
            popup,

            // only gripe if the parent is RFC and we're not hidden
            // NTRAID#NTBUG9-523532-2002/04/19-sburns
            
            !parentIsNonRfc && !state.RunHiddenUnattended()) )
      {
         break;
      }

      // now ensure that the child domain name does not exist

      if (!ValidateDomainDoesNotExist(hwnd, domain, IDC_LEAF))
      {
         break;
      }

      // valid

      ClearChanges();
      state.SetParentDomainDNSName(Win::GetTrimmedDlgItemText(hwnd, IDC_PARENT));
      state.SetNewDomainDNSName(domain);

      nextPage =
            state.GetRunContext() == State::PDC_UPGRADE
         ?  IDD_PATHS
         :  IDD_NETBIOS_NAME;
   }
   while (0);

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\configurednsclientpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// dns client configuration page
//
// 12-22-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "ConfigureDnsClientPage.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"



ConfigureDnsClientPage::ConfigureDnsClientPage()
   :
   DCPromoWizardPage(
      IDD_CONFIG_DNS_CLIENT,
      IDS_CONFIG_DNS_CLIENT_PAGE_TITLE,
      IDS_CONFIG_DNS_CLIENT_PAGE_SUBTITLE)
{
   LOG_CTOR(ConfigureDnsClientPage);
}



ConfigureDnsClientPage::~ConfigureDnsClientPage()
{
   LOG_DTOR(ConfigureDnsClientPage);
}



// NTRAID#NTBUG9-467553-2001/09/17-sburns

bool
ConfigureDnsClientPage::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   /* lParam */ )
{
//   LOG_FUNCTION(ConfigureDnsClientPage::OnNotify);

   bool result = false;
   
   if (controlIDFrom == IDC_JUMP)
   {
      switch (code)
      {
         case NM_CLICK:
         case NM_RETURN:
         {
            ShowTroubleshooter(hwnd, IDS_CONFIG_DNS_HELP_TOPIC);
            result = true;
         }
         default:
         {
            // do nothing
            
            break;
         }
      }
   }
   
   return result;
}



void
ConfigureDnsClientPage::OnInit()
{
   LOG_FUNCTION(ConfigureDnsClientPage::OnInit);
}



bool
ConfigureDnsClientPage::OnSetActive()
{
   LOG_FUNCTION(ConfigureDnsClientPage::OnSetActive);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended() || Dns::IsClientConfigured())
   {
      LOG(L"planning to Skip Configure DNS Client page");

      Wizard& wiz = GetWizard();

      if (wiz.IsBacktracking())
      {
         // backup once again
         wiz.Backtrack(hwnd);
         return true;
      }

      int nextPage = ConfigureDnsClientPage::Validate();
      if (nextPage != -1)
      {
         LOG(L"skipping DNS Client Page");         
         wiz.SetNextPageID(hwnd, nextPage);
         return true;
      }

      state.ClearHiddenWhileUnattended();
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



int
ConfigureDnsClientPage::Validate()
{
   LOG_FUNCTION(ConfigureDnsClientPage::Validate);

   int nextPage = -1;

   if (Dns::IsClientConfigured())
   {
      State& state = State::GetInstance();
      if (state.GetRunContext() == State::BDC_UPGRADE)
      {
         ASSERT(state.GetOperation() == State::REPLICA);

         nextPage = IDD_CHECK_DOMAIN_UPGRADED;
      }
      else
      {
         switch (state.GetOperation())
         {
            case State::FOREST:
            case State::TREE:
            case State::CHILD:
            case State::REPLICA:
            {
               nextPage = IDD_GET_CREDENTIALS;
               break;
            }
            case State::ABORT_BDC_UPGRADE:
            case State::DEMOTE:
            case State::NONE:
            default:
            {
               ASSERT(false);
               break;
            }
         }
      }
   }
   else
   {
      String message = String::load(IDS_CONFIG_DNS_FIRST);

      popup.Info(hwnd, message);
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\common.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// code common to several pages
//
// 12-16-97 sburns



#include "headers.hxx"
#include "common.hpp"
#include "resource.h"
#include "state.hpp"
#include "ds.hpp"
#include <DiagnoseDcNotFound.hpp>
#include <ValidateDomainName.h>


// Creates the fonts for setLargeFonts().
// 
// hDialog - handle to a dialog to be used to retrieve a device
// context.
// 
// bigBoldFont - receives the handle of the big bold font created.

void
InitFonts(
   HWND     hDialog,
   HFONT&   bigBoldFont)
{
   ASSERT(Win::IsWindow(hDialog));

   HRESULT hr = S_OK;

   do
   {
      NONCLIENTMETRICS ncm;

      // REVIEWED-2002/02/22-sburns call correctly passes byte count.
      
      ::ZeroMemory(&ncm, sizeof ncm);

      ncm.cbSize = sizeof ncm;

      // ISSUE-2002/02/27-sburns Seems to me that the second param here needs
      // to be sizeof ncm
      
      hr = Win::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
      BREAK_ON_FAILED_HRESULT(hr);

      LOGFONT bigBoldLogFont = ncm.lfMessageFont;
      bigBoldLogFont.lfWeight = FW_BOLD;

      String fontName = String::load(IDS_BIG_BOLD_FONT_NAME);

      // ensure null termination 260237

      // REVIEWED-2002/02/22-sburns call correctly passes byte count.
      
      ::ZeroMemory(bigBoldLogFont.lfFaceName, LF_FACESIZE * sizeof WCHAR);
      
      size_t fnLen = fontName.length();
      fontName.copy(
         bigBoldLogFont.lfFaceName,

         // don't copy over the last null

         min(LF_FACESIZE - 1, fnLen));

      unsigned fontSize = 0;
      String::load(IDS_BIG_BOLD_FONT_SIZE).convert(fontSize);
      ASSERT(fontSize);
 
      HDC hdc = 0;
      hr = Win::GetDC(hDialog, hdc);
      BREAK_ON_FAILED_HRESULT(hr);

      bigBoldLogFont.lfHeight =
         - ::MulDiv(
            static_cast<int>(fontSize),
            Win::GetDeviceCaps(hdc, LOGPIXELSY),
            72);

      hr = Win::CreateFontIndirect(bigBoldLogFont, bigBoldFont);
      BREAK_ON_FAILED_HRESULT(hr);

      Win::ReleaseDC(hDialog, hdc);
   }
   while (0);
}



void
SetControlFont(HWND parentDialog, int controlID, HFONT font)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(controlID);
   ASSERT(font);

   HWND control = Win::GetDlgItem(parentDialog, controlID);

   if (control)
   {
      Win::SetWindowFont(control, font, true);
   }
}



void
SetLargeFont(HWND dialog, int bigBoldResID)
{
   ASSERT(Win::IsWindow(dialog));
   ASSERT(bigBoldResID);

   static HFONT bigBoldFont = 0;
   if (!bigBoldFont)
   {
      InitFonts(dialog, bigBoldFont);
   }

   SetControlFont(dialog, bigBoldResID, bigBoldFont);
}


HRESULT
GetDcName(const String& domainName, String& resultDcName)
{
   LOG_FUNCTION(GetDcName);
   ASSERT(!domainName.empty());

   resultDcName.erase();

   HRESULT hr = S_OK;

   do
   {
      DOMAIN_CONTROLLER_INFO* info = 0;
      hr =
         MyDsGetDcName(
            0,
            domainName,  

            // pass the force rediscovery flag to make sure we don't pick up
            // a dc that is down 262221

            DS_DIRECTORY_SERVICE_REQUIRED | DS_FORCE_REDISCOVERY,
            info);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(info->DomainControllerName);

      if (info->DomainControllerName)
      {
         // we found an NT5 domain

         resultDcName =
            Computer::RemoveLeadingBackslashes(info->DomainControllerName);

         LOG(resultDcName);
      }

      ::NetApiBufferFree(info);

      if (resultDcName.empty())
      {
         hr = Win32ToHresult(ERROR_DOMAIN_CONTROLLER_NOT_FOUND);
      }
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



HRESULT
BrowserSetComputer(const SmartInterface<IDsBrowseDomainTree>& browser)            
{
   LOG_FUNCTION(BrowserSetComputer);

   HRESULT hr = S_OK;
   do
   {
      State& state = State::GetInstance();

      String username =
            MassageUserName(
               state.GetUserDomainName(),
               state.GetUsername());
      EncryptedString password = state.GetPassword();

      String computer;
      hr =
         GetDcName(
            state.GetUserDomainName(),
            computer);
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"Calling IDsBrowseDomainTree::SetComputer");
      LOG(String::format(L"pszComputerName : %1", computer.c_str()));
      LOG(String::format(L"pszUserName     : %1", username.c_str()));

      WCHAR* cleartext = password.GetClearTextCopy();
      
      hr =
         browser->SetComputer(
            computer.c_str(),
            username.c_str(),
            cleartext);
           
      password.DestroyClearTextCopy(cleartext);
                  
      LOG_HRESULT(hr);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



HRESULT
ReadDomainsHelper(bool bindWithCredentials, Callback* callback)
{
   LOG_FUNCTION(ReadDomainsHelper);

   HRESULT hr = S_OK;

   do
   {
      AutoCoInitialize coInit;
      hr = coInit.Result();
      BREAK_ON_FAILED_HRESULT(hr);

      SmartInterface<IDsBrowseDomainTree> browser;
      hr = browser.AcquireViaCreateInstance(
            CLSID_DsDomainTreeBrowser,
            0,
            CLSCTX_INPROC_SERVER,
            IID_IDsBrowseDomainTree);
      BREAK_ON_FAILED_HRESULT(hr);

      if (bindWithCredentials)
      {
         LOG(L"binding with credentials");

         hr = BrowserSetComputer(browser);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      LOG(L"Calling IDsBrowseDomainTree::GetDomains");
         
      DOMAIN_TREE* tree = 0;
      hr = browser->GetDomains(&tree, 0);
      BREAK_ON_FAILED_HRESULT(hr);
      ASSERT(tree);

      if (tree && callback)
      {
         //lint -e534   ignore return value
         callback->Execute(tree);
      }

      hr = browser->FreeDomains(&tree);
      ASSERT(SUCCEEDED(hr));
   }
   while (0);

   return hr;
}



String
BrowseForDomain(HWND parent)
{
   LOG_FUNCTION(BrowseForDomain);
   ASSERT(Win::IsWindow(parent));

   String retval;
   HRESULT hr = S_OK;
   
   do
   {
      Win::WaitCursor cursor;

      AutoCoInitialize coInit;
      hr = coInit.Result();
      BREAK_ON_FAILED_HRESULT(hr);

      // CODEWORK: the credential page could cache an instance of the browser,
      // rebuilding and setting the search root when only when new credentials
      // are entered.  Since the browser caches the last result, this would
      // make subsequent retreivals of the domain much faster.
      // addendum: tho the revised browser seems pretty quick

      SmartInterface<IDsBrowseDomainTree> browser;
      hr = browser.AcquireViaCreateInstance(
            CLSID_DsDomainTreeBrowser,
            0,
            CLSCTX_INPROC_SERVER,
            IID_IDsBrowseDomainTree);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = BrowserSetComputer(browser);
      BREAK_ON_FAILED_HRESULT(hr);

      PWSTR result = 0;
      hr = browser->BrowseTo(parent, &result, 0);
      BREAK_ON_FAILED_HRESULT(hr);

      if (result)
      {
         retval = result;
         ::CoTaskMemFree(result);
      }
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(parent, hr, IDS_CANT_BROWSE_FOREST);
   }

   return retval;
}



class RootDomainCollectorCallback : public Callback
{
   public:

   explicit
   RootDomainCollectorCallback(StringList& domains_)
      :
      Callback(),
      domains(domains_)
   {
      ASSERT(domains.empty());
      domains.clear();
   }

   virtual
   ~RootDomainCollectorCallback()
   {
   }
   
   virtual
   int
   Execute(void* param)
   {
      ASSERT(param);

      // root domains are all those on the sibling link of the root
      // node of the domain tree.

      DOMAIN_TREE* tree = reinterpret_cast<DOMAIN_TREE*>(param);
      if (tree)
      {
         for (
            DOMAIN_DESC* desc = &(tree->aDomains[0]);
            desc;
            desc = desc->pdNextSibling)
         {
            LOG(
               String::format(
                  L"pushing root domain %1",
                  desc->pszName));

            domains.push_back(desc->pszName);
         }
      }

      return 0;
   }

   private:

   StringList& domains;
};




HRESULT
ReadRootDomains(bool bindWithCredentials, StringList& domains)
{
   LOG_FUNCTION(ReadRootDomains);

   RootDomainCollectorCallback rdcc(domains);

   return
      ReadDomainsHelper(
         bindWithCredentials,
         &rdcc);
}



bool
IsRootDomain(bool bindWithCredentials)
{
   LOG_FUNCTION(IsRootDomain);

   static bool computed = false;
   static bool isRoot = false;

   if (!computed)
   {
      StringList domains;
      if (SUCCEEDED(ReadRootDomains(bindWithCredentials, domains)))
      {
         String domain =
            State::GetInstance().GetComputer().GetDomainDnsName();
         for (
            StringList::iterator i = domains.begin();
            i != domains.end();
            ++i)
         {
            if (Dns::CompareNames((*i), domain) == DnsNameCompareEqual)
            {
               LOG(String::format(L"found match: %1", (*i).c_str()));

               ASSERT(!(*i).empty());

               isRoot = true;
               break;
            }
         }

         computed = true;
      }
   }

   LOG(isRoot ? L"is root" : L"is not root");

   return isRoot;
}



// first = child, second = parent

typedef std::pair<String, String> StringPair;

typedef
   std::list<
      StringPair,
      Burnslib::Heap::Allocator<StringPair> >
   ChildParentList;

class ChildDomainCollectorCallback : public Callback
{
   public:

   explicit
   ChildDomainCollectorCallback(ChildParentList& domains_)
      :
      Callback(),
      domains(domains_)
   {
      ASSERT(domains.empty());
      domains.clear();
   }

   virtual
   ~ChildDomainCollectorCallback()
   {
   }
   
   virtual
   int
   Execute(void* param)
   {
      LOG_FUNCTION(ChildDomainCollectorCallback::Execute);

      ASSERT(param);

      DOMAIN_TREE* tree = reinterpret_cast<DOMAIN_TREE*>(param);
      if (tree)
      {
         typedef
            std::deque<
               DOMAIN_DESC*,
               Burnslib::Heap::Allocator<DOMAIN_DESC*> >
            DDDeque;
            
         std::stack<DOMAIN_DESC*, DDDeque> s;

         // first we push all the nodes for all root domains.  These are
         // the nodes on the sibling link of the tree root.  Hereafter,
         // the sibling link is only used to chase child domains.

         for (
            DOMAIN_DESC* desc = &(tree->aDomains[0]);
            desc;
            desc = desc->pdNextSibling)
         {
            LOG(
               String::format(
                  L"pushing root domain %1",
                  desc->pszName));

            s.push(desc);
         }

         // next, we work thru the stack, looking for nodes that have
         // nodes on their child links.  When we find such a node, we
         // collect in the child list all the children on that link, and
         // push them so that they will in turn be evaluated.

         DWORD count = 0;
         while (!s.empty())
         {
            DOMAIN_DESC* desc = s.top();
            s.pop();
            ASSERT(desc);

            if (desc)
            {
               count++;
               LOG(String::format(L"evaluating %1", desc->pszName));

               String parentname = desc->pszName;

               for (
                  DOMAIN_DESC* child = desc->pdChildList;
                  child;
                  child = child->pdNextSibling)
               {
                  s.push(child);
                  
                  String childname = child->pszName;

                  LOG(
                     String::format(
                        L"parent: %1 child: %2",
                        parentname.c_str(),
                        childname.c_str()));

                  domains.push_back(std::make_pair(childname, parentname));
               }
            }
         }

         ASSERT(count == tree->dwCount);
      }

      return 0;
   }

   private:

   ChildParentList& domains;
};



HRESULT
ReadChildDomains(bool bindWithCredentials, ChildParentList& domains)
{
   LOG_FUNCTION(ReadChildDomains);

   ChildDomainCollectorCallback cdcc(domains);

   return
      ReadDomainsHelper(
         bindWithCredentials,
         &cdcc);
}



String
GetParentDomainDnsName(
   const String&  childDomainDNSName,
   bool           bindWithCredentials)
{
   LOG_FUNCTION2(GetParentDomainDnsName, childDomainDNSName);
   ASSERT(!childDomainDNSName.empty());

   ChildParentList domains;

   if (SUCCEEDED(ReadChildDomains(bindWithCredentials, domains)))
   {
      for (
         ChildParentList::iterator i = domains.begin();
         i != domains.end();
         ++i)
      {
         if (
            Dns::CompareNames(
               (*i).first,
               childDomainDNSName) == DnsNameCompareEqual)
         {
            LOG(
               String::format(
                  L"found parent: %1",
                  (*i).second.c_str()));

            ASSERT(!(*i).second.empty());

            return (*i).second;
         }
      }
   }

   LOG(L"domain is not a child");

   return String();
}



class DomainCollectorCallback : public Callback
{
   public:

   explicit
   DomainCollectorCallback(StringList& domains_)
      :
      Callback(),
      domains(domains_)
   {
      ASSERT(domains.empty());
      domains.clear();
   }

   virtual
   ~DomainCollectorCallback()
   {
   }
   
   virtual
   int
   Execute(void* param)
   {
      LOG_FUNCTION(DomainCollectorCallback::Execute);

      ASSERT(param);

      DOMAIN_TREE* tree = reinterpret_cast<DOMAIN_TREE*>(param);
      if (tree)
      {
         for (DWORD i = 0; i < tree->dwCount; ++i)
         {
            PCWSTR name = tree->aDomains[i].pszName;

            LOG(String::format(L"domain found: %1", name));

            domains.push_back(name);
         }
      }

      return 0;
   }

   private:

   StringList& domains;
};



HRESULT
ReadDomains(StringList& domains)
{
   LOG_FUNCTION(ReadDomains);

   DomainCollectorCallback dcc(domains);

   return ReadDomainsHelper(true, &dcc);
}



String
BrowseForFolder(HWND parent, int titleResID)
{
   LOG_FUNCTION(BrowseForFolder);
   ASSERT(Win::IsWindow(parent));
   ASSERT(titleResID > 0);

   String       result;
   HRESULT      hr      = S_OK;
   LPMALLOC     pmalloc = 0;   
   LPITEMIDLIST drives  = 0;   
   LPITEMIDLIST pidl    = 0;   

   do
   {
      hr = Win::SHGetMalloc(pmalloc);
      if (FAILED(hr) || !pmalloc)
      {
         break;
      }

      // get a pidl for the local drives (really My Computer)

      hr = Win::SHGetSpecialFolderLocation(parent, CSIDL_DRIVES, drives);
      BREAK_ON_FAILED_HRESULT(hr);

      BROWSEINFO info;

      // REVIEWED-2002/02/25-sburns proper byte count is passed.
      
      ::ZeroMemory(&info, sizeof info);
      
      String title = String::load(titleResID);
      wchar_t buf[MAX_PATH + 1];

      // REVIEWED-2002/02/25-sburns proper byte count is passed.
            
      ::ZeroMemory(buf, sizeof buf);

      info.hwndOwner      = parent;      
      info.pidlRoot       = drives;        
      info.pszDisplayName = buf;        
      info.lpszTitle      = title.c_str();              
      info.ulFlags        = BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS;

      // REVIEWED-2002/02/25-sburns pszDisplayName in info is at least
      // MAX_PATH characters long.
      
      pidl = Win::SHBrowseForFolder(info);

      if (pidl)
      {
         result = Win::SHGetPathFromIDList(pidl);
      }

   }
   while (0);

   if (pmalloc)
   {
      pmalloc->Free(pidl);
      pmalloc->Free(drives);
      pmalloc->Release();
   }
            
   return result;
}



bool
CheckDriveType(const String& path)
{
   LOG_FUNCTION(CheckDriveType);
   ASSERT(!path.empty());

   UINT type = Win::GetDriveType(path);
   switch (type)
   {
      case DRIVE_FIXED:
      {
         return true;
      }
      case DRIVE_REMOVABLE:
      {
         // only legal iff volume = system volume
         String vol = FS::GetRootFolder(path);
         String sys = FS::GetRootFolder(Win::GetSystemDirectory());
         if (vol.icompare(sys) == 0)
         {
            return true;
         }
         break;
      }
      default:
      {
         // all others bad
         break;         
      }
   }


   return false;
}



bool
PathHasNonAsciiCharacters(const String& path, String& message)
{
   LOG_FUNCTION2(PathHasNonAsciiCharacters, path);
   ASSERT(!path.empty());

   bool result = false;

   // This set is all 7-bit ascii characters above ascii 31 that are
   // not illegal FAT filename characters, plus : and \

   static const String ALLOWED_ASCII(
      L" !#$%&'()-."
      L"0123456789"
      L":@"
      L"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      L"\\^_`"
      L"abcdefghijklmnopqrstuvwxyz"
      L"{}~" );

   String illegalsFound;
   String::size_type pos = 0;

   while ((pos = path.find_first_not_of(ALLOWED_ASCII, pos)) != String::npos)
   {
      String illegal(1, path[pos]);
      if (illegalsFound.find_first_of(illegal) == String::npos)
      {
         illegalsFound += illegal;
         illegalsFound += L" ";
      }
      ++pos;
   }

   if (!illegalsFound.empty())
   {
      message =
         String::format(
            IDS_NON_ASCII_PATH_CHARS,
            path.c_str(),
            illegalsFound.c_str());
      result = true;      
   }

   LOG_BOOL(result);

   return result;
}
   


bool
ValidateDcInstallPath(
   const String&  path,
   HWND           parent,
   int            editResId,
   bool           requiresNtfs5,
   bool           requiresAsciiCharacters,
   bool           requiresUncompressedFolder)
{
   LOG_FUNCTION(ValidateDcInstallPath);
   ASSERT(!path.empty());
   ASSERT(editResId);
   ASSERT(Win::IsWindow(parent));

   bool result = false;
   String message;
   do
   {
      if (
            (path.icompare(Win::GetWindowsDirectory()) == 0)
         || (path.icompare(Win::GetSystemWindowsDirectory()) == 0) )
      {
         message = String::format(IDS_PATH_IS_WINDIR, path.c_str());
         break;
      }

      if (path.icompare(Win::GetSystemDirectory()) == 0)
      {
         message = String::format(IDS_PATH_IS_SYSTEM32, path.c_str());
         break;
      }

      if (FS::GetPathSyntax(path) != FS::SYNTAX_ABSOLUTE_DRIVE)
      {
         message = String::format(IDS_BAD_PATH_FORMAT, path.c_str());
         break;
      }

      if (requiresAsciiCharacters)
      {
         if (PathHasNonAsciiCharacters(path, message))
         {
            ASSERT(!message.empty());
            break;
         }
      }
      
      if (!CheckDriveType(path))
      {
         message = String::format(IDS_BAD_DRIVE_TYPE, path.c_str());
         break;
      }

      if (requiresNtfs5 && (FS::GetFileSystemType(path) != FS::NTFS5))
      {
         message = String::format(IDS_NOT_NTFS5, path.c_str());
         break;
      }

      // prohibit paths that contain mounted volumes 325264
      // even when they don't exist 435428
                       
      String mountRoot;
      HRESULT hr = FS::GetVolumePathName(path, mountRoot);

      ASSERT(SUCCEEDED(hr));

      // '3' == length of root of a "normal" volume ("C:\")

      if (mountRoot.length() > 3)
      {
         message =
            String::format(
               IDS_PATH_CONTAINS_MOUNTED_VOLUMES,
               path.c_str(),
               mountRoot.c_str());
         break;
      }

      DWORD attrs = 0;
      hr = Win::GetFileAttributes(path, attrs);

      if (SUCCEEDED(hr))
      {
         // path exists

         // reject paths that refer an existing file

         if (!(attrs & FILE_ATTRIBUTE_DIRECTORY))
         {
            message = String::format(IDS_PATH_NOT_DIRECTORY, path.c_str());
            break;
         }

         // if necessary, reject paths that are compressed

         if ((attrs & FILE_ATTRIBUTE_COMPRESSED) && requiresUncompressedFolder)
         {
            message = String::format(IDS_PATH_IS_COMPRESSED, path.c_str());
            break;
         }
         
         if (!FS::IsFolderEmpty(path))
         {
            if (
               popup.MessageBox(
                  parent,
                  String::format(IDS_EMPTY_PATH, path.c_str()),
                  MB_ICONWARNING | MB_YESNO) == IDNO)
            {
               // don't gripe...silently disapprove

               HWND edit = Win::GetDlgItem(parent, editResId);
               Win::SendMessage(edit, EM_SETSEL, 0, -1);
               Win::SetFocus(edit);
               break;
            }
         }
      }

      result = true;
   }
   while (0);

   if (!message.empty())
   {
      popup.Gripe(parent, editResId, message);
   }
      
   return result;
}



bool
DoLabelValidation(
   HWND dialog,        
   int  editResID,     
   int  badSyntaxResID,
   bool gripeOnNonRFC = true,
   bool gripeOnNumericLabel = true) 
{
   LOG_FUNCTION(DoLabelValidation);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(editResID > 0);

   bool valid = false;
   String label = Win::GetTrimmedDlgItemText(dialog, editResID);
   switch (Dns::ValidateDnsLabelSyntax(label))
   {
      case Dns::NON_RFC:
      {
         if (gripeOnNonRFC)
         {
            // warn about non-rfc names
            popup.Info(
               dialog,
               String::format(IDS_NON_RFC_NAME, label.c_str()));
         }

         // fall thru
      }
      case Dns::VALID:
      {
         valid = true;
         break;
      }
      case Dns::TOO_LONG:
      {
         popup.Gripe(
            dialog,
            editResID,
            String::format(
               IDS_DNS_LABEL_TOO_LONG,
               label.c_str(),
               Dns::MAX_LABEL_LENGTH));
         break;
      }
      case Dns::NUMERIC:
      {
         if (!gripeOnNumericLabel)
         {
            valid = true;
            break;
         }

         // fall thru
      }
      case Dns::BAD_CHARS:
      case Dns::INVALID:
      default:
      {
         popup.Gripe(
            dialog,
            editResID,
            String::format(badSyntaxResID, label.c_str()));
         break;
      }
   }

   return valid;
}



bool
ValidateChildDomainLeafNameLabel(
   HWND dialog,        
   int  editResID,     
   bool gripeOnNonRfc)
{
   LOG_FUNCTION(ValidateChildDomainLeafNameLabel);

   String name = Win::GetTrimmedDlgItemText(dialog, editResID);
   if (name.empty())
   {
      popup.Gripe(dialog, editResID, IDS_BLANK_LEAF_NAME);
      return false;
   }

   // If parent is non-RFC, then so will be the child.  The user has been
   // griped to already, so don't gripe twice
   // 291558

   return
      DoLabelValidation(
         dialog,
         editResID,
         IDS_BAD_LABEL_SYNTAX,
         gripeOnNonRfc,

         // allow numeric labels. NTRAID#NTBUG9-321168-2001/02/20-sburns
         
         false);
}



bool
ValidateSiteName(HWND dialog, int editResID)
{
   LOG_FUNCTION(ValidateSiteName);

   String name = Win::GetTrimmedDlgItemText(dialog, editResID);
   if (name.empty())
   {
      popup.Gripe(dialog, editResID, IDS_BLANK_SITE_NAME);
      return false;
   }

   // A site name is just a DNS label

   return DoLabelValidation(dialog, editResID, IDS_BAD_SITE_SYNTAX);
}



void
ShowTroubleshooter(HWND parent, int topicResID)
{
   LOG_FUNCTION(ShowTroubleshooter);
   ASSERT(Win::IsWindow(parent));

   String file = String::load(IDS_HTML_HELP_FILE);
   String topic = String::load(topicResID);
   ASSERT(!topic.empty());

   LOG(String::format(L"file: %1 topic: %2", file.c_str(), topic.c_str()));

   Win::HtmlHelp(
      parent,
      file, 
      HH_DISPLAY_TOPIC,
      reinterpret_cast<DWORD_PTR>(topic.c_str()));
}



String
MassageUserName(const String& domainName, const String& userName)
{
   LOG_FUNCTION2(MassageUserName, userName);
   ASSERT(!userName.empty());

   String result = userName;

   do
   {
      if (userName.find(L"@") != String::npos)
      {
         // userName includes an @, looks like a UPN to us, so don't
         // mess with it further 17699

         LOG(L"looks like a UPN");
         break;
      }

      if (!domainName.empty())
      {
         static const String DOMAIN_SEP_CHAR = L"\\";
         String name = userName;
         size_t pos = userName.find(DOMAIN_SEP_CHAR);

         if (pos != String::npos)
         {
            // remove the domain name in the userName string and replace it
            // with the domainName String

            name = userName.substr(pos + 1);
            ASSERT(!name.empty());
         }

         result = domainName + DOMAIN_SEP_CHAR + name;
         break;
      }

      // otherwise, the username appears as "foo\bar", so we don't touch it.
   }
   while (0);

   LOG(result);

   return result;
}



bool
IsChildDomain(bool bindWithCredentials)
{
   LOG_FUNCTION(IsChildDomain);

   static bool computed = false;
   static String parent;

   if (!computed)
   {
      parent =
         GetParentDomainDnsName(
            State::GetInstance().GetComputer().GetDomainDnsName(),
            bindWithCredentials);
      computed = true;
   }

   LOG(
         parent.empty()
      ?  String(L"not a child")
      :  String::format(L"is child.  parent: %1", parent.c_str()));

   return !parent.empty();
}



bool
IsForestRootDomain()
{
   LOG_FUNCTION(IsForestRootDomain);

   const Computer& c = State::GetInstance().GetComputer();

   bool result = (c.GetDomainDnsName() == c.GetForestDnsName());

   LOG(
      String::format(
         L"%1 a forest root domain",
         result ? L"is" : L"is not"));

   return result;
}



bool
ValidateDomainExists(HWND dialog, int editResID, String& domainDnsName)
{
   return ValidateDomainExists(dialog, String(), editResID, domainDnsName);
}



bool
ValidateDomainExists(
   HWND           dialog,
   const String&  domainName,
   int            editResId,
   String&        domainDnsName)
{
   LOG_FUNCTION(ValidateDomainExists);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(editResId > 0);

   String name =
         domainName.empty()
      ?  Win::GetTrimmedDlgItemText(dialog, editResId)
      :  domainName;

   // The invoking code should verify this condition, but we will handle
   // it just in case.

   ASSERT(!name.empty());

   domainDnsName.erase();

   Win::WaitCursor cursor;

   bool valid      = false;
   DOMAIN_CONTROLLER_INFO* info = 0;

   do
   {
      if (name.empty())
      {
         popup.Gripe(
            dialog,
            editResId,
            String::load(IDS_MUST_ENTER_DOMAIN));
         break;
      }
      
      // determine whether we can reach a DC for the domain, and whether it is
      // a DS dc, and whether the name we're validating is truly the DNS name
      // of the domain.

      LOG(L"Validating " + name);
      HRESULT hr =
         MyDsGetDcName(
            0, 
            name,

            // force discovery to ensure that we don't pick up a cached
            // entry for a domain that may no longer exist

            DS_FORCE_REDISCOVERY | DS_DIRECTORY_SERVICE_PREFERRED,
            info);
      if (FAILED(hr) || !info)
      {
         ShowDcNotFoundErrorDialog(
            dialog,
            editResId,
            name,
            String::load(IDS_WIZARD_TITLE),
            String::format(IDS_DC_NOT_FOUND, name.c_str()),

            // name might be netbios
            
            false);
            
         break;
      }

      if (!(info->Flags & DS_DS_FLAG))
      {
         // domain is not a DS domain, or the locator could not find a DS DC
         // for that domain, so the candidate name is bad

         ShowDcNotFoundErrorDialog(
            dialog,
            editResId,
            name,
            String::load(IDS_WIZARD_TITLE),            
            String::format(IDS_DC_NOT_FOUND, name.c_str()),

            // name might be netbios
            
            false);
            
         break;
      }

      LOG(name + L" refers to DS domain");

      // here we rely on the fact that if DsGetDcName is provided a flat
      // domain name, then info->DomainName will also be the (same,
      // normalized) flat name.  Likewise, if provided a DNS domain name,
      // info->DomainName will be the (same, normalized) DNS domain name.

      if (info->Flags & DS_DNS_DOMAIN_FLAG)
      {
         // we can infer that name is a DNS domain name, since
         // info->DomainName is a DNS domain name.

         LOG(L"name is the DNS name");
         ASSERT(
               Dns::CompareNames(name, info->DomainName)
            == DnsNameCompareEqual);

         valid = true;
         break;
      }

      LOG(name + L" is not the DNS domain name");

      // the candidate name is not the DNS name of the domain.  Make another
      // call to DsGetDcName to determine the DNS domain name so we can get
      // the user to confirm.

      DOMAIN_CONTROLLER_INFO* info2 = 0;
      hr = MyDsGetDcName(0, name, DS_RETURN_DNS_NAME, info2);
      if (FAILED(hr) || !info2)
      {
         ShowDcNotFoundErrorDialog(
            dialog,
            editResId,
            name,
            String::load(IDS_WIZARD_TITLE),            
            String::format(IDS_DC_NOT_FOUND, name.c_str()),

            // name is probably netbios
            false);
            
         break;
      }

      String message =
         String::format(
            IDS_CONFIRM_DNS_NAME,
            name.c_str(),
            info2->DomainName);

      if (
         popup.MessageBox(
            dialog,
            message,
            MB_YESNO) == IDYES)
      {
         domainDnsName = info2->DomainName;

         // The user accept the dns name as the name he meant to enter. As one
         // last step, we call DsGetDcName with the dns domain name. If this
         // fails, then we are in the situation where a DC can be found with
         // netbios but not dns.  So the user has a dns configuration problem.
         // 28298

         DOMAIN_CONTROLLER_INFO* info3 = 0;
         hr =
            MyDsGetDcName(
               0, 
               domainDnsName,

               // force discovery to ensure that we don't pick up a cached
               // entry for a domain that may no longer exist

               DS_FORCE_REDISCOVERY | DS_DIRECTORY_SERVICE_PREFERRED,
               info3);
         if (FAILED(hr) || !info3)
         {
            ShowDcNotFoundErrorDialog(
               dialog,
               editResId,
               domainDnsName,
               String::load(IDS_WIZARD_TITLE),
               String::format(IDS_DC_NOT_FOUND, domainDnsName.c_str()),

               // we know the name is not netbios
               
               true);

            domainDnsName.erase();
            break;
         }
   
         ::NetApiBufferFree(info3);
         valid = true;
      }

      // the user rejected the dns name, so they are admitting that what
      // they entered was bogus.  Don't pop up an error box in this case,
      // as we have pestered the user enough.

      ::NetApiBufferFree(info2);
   }
   while (0);

   if (info)
   {
      ::NetApiBufferFree(info);
   }

#ifdef DBG
   if (!valid)
   {
      ASSERT(domainDnsName.empty());
   }
#endif

   return valid;
}



bool
ValidateDomainDoesNotExist(
   HWND           dialog,
   int            editResID)
{
   return ValidateDomainDoesNotExist(dialog, String(), editResID);
}



bool
ValidateDomainDoesNotExist(
   HWND           dialog,
   const String&  domainName,
   int            editResID)
{
   LOG_FUNCTION(ValidateDomainDoesNotExist);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(editResID > 0);

   // this can take awhile.

   Win::WaitCursor cursor;

   String name =
         domainName.empty()
      ?  Win::GetTrimmedDlgItemText(dialog, editResID)
      :  domainName;

   // The invoking code should verify this condition, but we will handle
   // it just in case.

   ASSERT(!name.empty());

   bool valid = true;
   String message;
   do
   {
      if (name.empty())
      {
         message = String::load(IDS_MUST_ENTER_DOMAIN);
         valid = false;
         break;
      }
      if (IsDomainReachable(name) || DS::IsDomainNameInUse(name))
      {
         message = String::format(IDS_DOMAIN_NAME_IN_USE, name.c_str());
         valid = false;
         break;
      }

      // otherwise the domain does not exist
   }
   while (0);

   if (!valid)
   {
      popup.Gripe(dialog, editResID, message);
   }

   return valid;
}



void
DisableConsoleLocking()
{
   LOG_FUNCTION(disableConsoleLocking);

   HRESULT hr = S_OK;
   do
   {
      BOOL screenSaverEnabled = FALSE;

      hr = 

         // REVIEWED-2002/02/27-sburns the docs are vague, but we know that
         // screenSaverEnabled as a BOOL works.

         Win::SystemParametersInfo(
            SPI_GETSCREENSAVEACTIVE,
            0,
            &screenSaverEnabled,
            0);
      BREAK_ON_FAILED_HRESULT(hr);

      if (screenSaverEnabled)
      {
         // disable it.

         screenSaverEnabled = FALSE;
         hr =

         // ISSUE-2002/02/27-sburns it looks to me from the docs that the
         // second param should be used, and not the third
         
            Win::SystemParametersInfo(
               SPI_SETSCREENSAVEACTIVE,
               0,
               &screenSaverEnabled,
               SPIF_SENDCHANGE);

         ASSERT(SUCCEEDED(hr));
      }
   }
   while (0);


   // turn off lock computer option in winlogon

   do
   {
      RegistryKey key;

      hr =
         key.Create(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
      BREAK_ON_FAILED_HRESULT(hr);

      // '2' means "disable for this session, reset to 0 on reboot."

      hr = key.SetValue(L"DisableLockWorkstation", 2);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);
}




void
EnableConsoleLocking()
{
   LOG_FUNCTION(EnableConsoleLocking);

#ifdef DBG
   State& state = State::GetInstance();
   ASSERT(
      state.GetRunContext() != State::PDC_UPGRADE &&
      state.GetRunContext() != State::BDC_UPGRADE);
#endif 

   // CODEWORK: we don't re-enable the screensaver (we need to remember
   // if it was enabled when we called DisableConsoleLocking)

   HRESULT hr = S_OK;
   do
   {
      RegistryKey key;

      hr =
         key.Create(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
      BREAK_ON_FAILED_HRESULT(hr);

      // 0 means "enable"

      hr = key.SetValue(L"DisableLockWorkstation", 0);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);
}



bool
CheckDiskSpace(const String& path, unsigned minSpaceMB)
{
   LOG_FUNCTION(checkDiskSpace);
   ASSERT(FS::IsValidPath(path));

   String vol = FS::GetRootFolder(path);

   ULONGLONG spaceInBytes;

   // REVIEWED-2002/02/25-sburns byte count is correctly passed.
   
   ::ZeroMemory(&spaceInBytes, sizeof ULONGLONG);

   HRESULT hr = FS::GetAvailableSpace(vol, spaceInBytes);

   if (SUCCEEDED(hr))
   {
      // prefast is happiest if we start out with the same-width integers
      // before we shift one, hence the cast.
      // NTRAID#NTBUG9-540413-2002/03/12-sburns
      
      ULONGLONG spaceInMb = spaceInBytes / ( (ULONGLONG) 1 << 20);

      if (spaceInMb >= minSpaceMB)
      {
         return true;
      }
   }

   return false;
}



String
GetFirstNtfs5HardDrive()
{
   LOG_FUNCTION(GetFirstNtfs5HardDrive);

   String result;
   do
   {
      StringVector dl;
      HRESULT hr = FS::GetValidDrives(std::back_inserter(dl));
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(dl.size());
      for (
         StringVector::iterator i = dl.begin();
         i != dl.end();
         ++i)
      {
         LOG(*i);

         if (
               FS::GetFileSystemType(*i) == FS::NTFS5
            && Win::GetDriveType(*i) == DRIVE_FIXED )
         {
            // found one.  good to go

            LOG(String::format(L"%1 is NTFS5", i->c_str()));

            result = *i;
            break;
         }
      }
   }
   while (0);

   LOG(result);

   return result;
}



bool
ComputerWasRenamedAndNeedsReboot()
{
   LOG_FUNCTION(ComputerWasRenamedAndNeedsReboot);
   
   bool result = false;

   do
   {
      String active = Computer::GetActivePhysicalNetbiosName();
      String future = Computer::GetFuturePhysicalNetbiosName();
      
      if (active.icompare(future) != 0)
      {
         // a name change is pending reboot.

         LOG(L"netbios name was changed");
         LOG(active);
         LOG(future);
      
         result = true;
         break;
      }

      // At this point, the netbios names are the same, or there is no future
      // netbios name.  So check the DNS names.

      if (IsTcpIpInstalled())
      {
         // DNS names only exist if tcp/ip is installed.

         active = Computer::GetActivePhysicalFullDnsName();
         future = Computer::GetFuturePhysicalFullDnsName();

         if (Dns::CompareNames(active, future) == DnsNameCompareNotEqual)
         {
            LOG(L"dns name was changed");
            LOG(active);
            LOG(future);
         
            result = true;
            break;
         }
      }

      // At this point, we have confirmed that there is no pending name
      // change.

      LOG(L"No pending computer name change");   
   }
   while (0);
   
   LOG_BOOL(result);
   
   return result;
}



String
GetForestName(const String& domain, HRESULT* hrOut)
{
   LOG_FUNCTION2(GetForestName, domain);
   ASSERT(!domain.empty());

   String dnsForestName;

   DOMAIN_CONTROLLER_INFO* info = 0;
   HRESULT hr =
      MyDsGetDcName(
         0,
         domain,
         DS_RETURN_DNS_NAME,
         info);
   if (SUCCEEDED(hr) && info)
   {
      ASSERT(info->DnsForestName);
      
      if (info->DnsForestName)
      {
         dnsForestName = info->DnsForestName;
      }
      ::NetApiBufferFree(info);
   }

   if (hrOut)
   {
      *hrOut = hr;
   }
   
   return dnsForestName;
}



HRESULT
ValidatePasswordAgainstPolicy(
   const EncryptedString&  password,
   const String&           userName)
{
   LOG_FUNCTION(ValidatePasswordAgainstPolicy);

   HRESULT hr = S_OK;   

   PWSTR cleartext = password.GetClearTextCopy();
   
   NET_VALIDATE_PASSWORD_RESET_INPUT_ARG inArg;
   ::ZeroMemory(&inArg, sizeof inArg);

   inArg.ClearPassword = cleartext;

   // UserAccountName is used by one of the complexity checking tests to
   // ensure that the candidate password does not contain that string
   
   inArg.UserAccountName =
         userName.empty()

         // ISSUE-2002/04/19-sburns This should be null since UmitA has
         // fixed his bug to allow this parameter to be null

      ?  L"aklsdjiwuerowierlkmclknlaksjdqweiquroijlkasjlkq" // 0
      :  (PWSTR) userName.c_str();

   // HashedPassword is only used when checking password histories.   
   
   NET_VALIDATE_OUTPUT_ARG* outArg = 0;
   
   hr =
      Win32ToHresult(
         ::NetValidatePasswordPolicy(
             0,
             0,
             NetValidatePasswordReset,
             &inArg,
             (void**) &outArg));

   password.DestroyClearTextCopy(cleartext);
          
   if (SUCCEEDED(hr) && outArg)
   {
      hr = Win32ToHresult(outArg->ValidationStatus);
      NetApiBufferFree(outArg);
   }

   LOG_HRESULT(hr);

   return hr;
}



bool
IsValidPassword(
   HWND             dialog,           
   int              passwordResID,    
   int              confirmResID,
   bool             isForSafeMode,
   EncryptedString& validatedPassword)
{
   LOG_FUNCTION(IsValidPassword);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(passwordResID);
   ASSERT(confirmResID);

   validatedPassword.Clear();
   bool result  = false;
   int  message = 0;    
   
   do
   {
      EncryptedString password =
         Win::GetEncryptedDlgItemText(dialog, passwordResID);
      EncryptedString confirm  =
         Win::GetEncryptedDlgItemText(dialog, confirmResID); 

      if (password != confirm)
      {
         message = IDS_PASSWORD_MISMATCH;
         break;
      }

      State& state = State::GetInstance();
      
      if (
            isForSafeMode
         && password.IsEmpty()
         && state.RunHiddenUnattended()
         && !state.IsSafeModeAdminPwdOptionPresent() )
      {
         // password is blank, we're running with an answerfile, and the
         // user did not specify a password in the answerfile.  In this
         // case, we will use the local admin password as the domain admin
         // password. So we should skip the policy check.
         // NTRAID#NTBUG9-619502-2002/05/09-sburns

         // this branch empty on purpose.
      }
      else
      {
         // CODEWORK: in v2 of this code, extract the name of the local admin
         // sid
      
         HRESULT hr = ValidatePasswordAgainstPolicy(password, String());
         if (FAILED(hr))
         {
            // we translate the error codes into our own message IDs because
            // the system error messages are too horrible to bear, and those
            // that own them aren't inclined to change them.
         
            switch (HRESULT_CODE(hr))
            {
               case NERR_PasswordTooShort:
               {
                  message = IDS_PASSWORD_TOO_SHORT;
                  break;
               }
               case NERR_PasswordTooLong:
               {
                  message = IDS_PASSWORD_TOO_LONG;
                  break;
               }
               case NERR_PasswordNotComplexEnough:
               {
                  message = IDS_PASSWORD_TOO_SIMPLE;
                  break;
               }
               case NERR_PasswordFilterError:
               {
                  message = IDS_PASSWORD_TOO_COARSE;
                  break;
               }
               default:
               {
                  // in this case, the validation itself failed, so we accept
                  // the candidate password. Note that this is no worse than
                  // not checking the policy in the first place, and the
                  // ramifications are that the account will get a possibly
                  // weaker password than policy would like.

                  break;
               }
            }

            if (message)
            {
               break;
            }
         }
      }
      
      result = true;
      
      // at this point, the password has successfully run the gauntlet.
      
      validatedPassword = password;
   }
   while (0);

   if (!result)
   {
      String blank;
      Win::SetDlgItemText(dialog, passwordResID, blank);
      Win::SetDlgItemText(dialog, confirmResID, blank);
      popup.Gripe(dialog, passwordResID, message);
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\confirmationpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// confirmation page
//
// 12-22-97 sburns



#ifndef CONFIRM_HPP_INCLUDED
#define CONFIRM_HPP_INCLUDED



#include "page.hpp"
#include "MultiLineEditBoxThatForwardsEnterKey.hpp"



class ConfirmationPage : public DCPromoWizardPage
{
   public:

   ConfirmationPage();

   protected:

   virtual ~ConfirmationPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIdFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   bool
   OnWizNext();

   virtual
   int
   Validate();

   private:

   bool needToKillSelection;
   MultiLineEditBoxThatForwardsEnterKey multiLineEdit;
   
   // not defined; no copying allowed
   ConfirmationPage(const ConfirmationPage&);
   const ConfirmationPage& operator=(const ConfirmationPage&);
};



#endif   // CONFIRM_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\confirmationpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// confirmation page
//
// 12-22-97 sburns



#include "headers.hxx"
#include "ConfirmationPage.hpp"
#include "common.hpp"
#include "resource.h"
#include "ProgressDialog.hpp"
#include "ds.hpp"
#include "state.hpp"
#include "GetCredentialsDialog.hpp"
#include "postop.hpp"
#include <DiagnoseDcNotFound.hpp>



void PromoteThreadProc(ProgressDialog& progress);



ConfirmationPage::ConfirmationPage()
   :
   DCPromoWizardPage(
      IDD_CONFIRMATION,
      IDS_CONFIRMATION_PAGE_TITLE,
      IDS_CONFIRMATION_PAGE_SUBTITLE),
   needToKillSelection(false)      
{
   LOG_CTOR(ConfirmationPage);
}



ConfirmationPage::~ConfirmationPage()
{
   LOG_DTOR(ConfirmationPage);
}



void
ConfirmationPage::OnInit()
{
   LOG_FUNCTION(ConfirmationPage::OnInit);

   // Since the multi-line edit control has a bug that causes it to eat
   // enter keypresses, we will subclass the control to make it forward
   // those keypresses to the page as WM_COMMAND messages
   // This workaround from phellyar.
   // NTRAID#NTBUG9-232092-2000/11/22-sburns

   multiLineEdit.Init(Win::GetDlgItem(hwnd, IDC_MESSAGE));
}



int
ConfirmationPage::Validate()
{
   LOG_FUNCTION(ConfirmationPage::Validate);

   // this function should never be called, as we override OnWizNext.
   ASSERT(false);

   return 0;
}



static
String
GetMessage()
{
   LOG_FUNCTION(GetMessage);

   String message;
   State& state = State::GetInstance();

   String netbiosName;
   State::RunContext context = state.GetRunContext();

   if (
         context == State::BDC_UPGRADE
      || context == State::PDC_UPGRADE)
   {
      netbiosName = state.GetComputer().GetDomainNetbiosName();
   }
   else
   {
      netbiosName = state.GetNewDomainNetbiosName();
   }

   switch (state.GetOperation())
   {
      case State::REPLICA:
      {
         message =
            String::format(
               IDS_CONFIRM_MESSAGE_REPLICA,
               state.GetReplicaDomainDNSName().c_str());

         if (state.ReplicateFromMedia())
         {
            message +=
               String::format(
                  IDS_CONFIRM_MESSAGE_REPLICATE_FROM_MEDIA,
                  state.GetReplicationSourcePath().c_str());
         }
               
         break;
      }
      case State::FOREST:
      {
         message =
            String::format(
               IDS_CONFIRM_MESSAGE_FOREST,
               state.GetNewDomainDNSName().c_str(),
               netbiosName.c_str());
         break;
      }
      case State::TREE:
      {
         message =
            String::format(
               IDS_CONFIRM_MESSAGE_TREE,
               state.GetNewDomainDNSName().c_str(),
               netbiosName.c_str(),
               state.GetParentDomainDnsName().c_str());
         break;
      }
      case State::CHILD:
      {
         message =
            String::format(
               IDS_CONFIRM_MESSAGE_CHILD,
               state.GetNewDomainDNSName().c_str(),
               netbiosName.c_str(),
               state.GetParentDomainDnsName().c_str());
         break;
      }
      case State::DEMOTE:
      {
         String domain = state.GetComputer().GetDomainDnsName();
         if (state.IsLastDCInDomain())
         {
            message =
               String::format(
                  IDS_CONFIRM_MESSAGE_DEMOTE_LAST_DC,
                  domain.c_str());
         }
         else
         {
            if (state.IsForcedDemotion())
            {
               message = String::load(IDS_CONFIRM_MESSAGE_FORCE_DEMOTE);
            }
            else
            {
               message =
                  String::format(IDS_CONFIRM_MESSAGE_DEMOTE, domain.c_str());
            }
         }

         if (state.GetAppPartitionList().size())
         {
            message += String::format(IDS_CONFIRM_MESSAGE_APP_PARTITION);
         }
         
         break;
      }
      case State::ABORT_BDC_UPGRADE:
      {
         message =
            String::format(
               IDS_CONFIRM_ABORT_BDC_UPGRADE,
               netbiosName.c_str());
         break;
      }
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return message;
}



bool
ConfirmationPage::OnSetActive()
{
   LOG_FUNCTION(ConfirmationPage::OnSetActive);
   ASSERT(State::GetInstance().GetOperation() != State::NONE);

   State& state = State::GetInstance();
   String message = GetMessage();

   State::Operation operation = state.GetOperation();
   switch (operation)
   {
      case State::REPLICA:
      case State::FOREST:
      case State::TREE:
      case State::CHILD:
      {
         // write the path options into the text box

         String pathText =
            String::format(
               IDS_CONFIRM_PATHS_MESSAGE,
               state.GetDatabasePath().c_str(),
               state.GetLogPath().c_str(),
               state.GetSYSVOLPath().c_str());

         message += pathText;

         if (state.ShouldInstallAndConfigureDns())
         {
            // NTRAID#NTBUG9-446484-2001/10/11-sburns

            if (state.ShouldConfigDnsClient())
            {
               message += String::load(IDS_CONFIRM_INSTALL_DNS_AND_CLIENT);
            }
            else
            {
               message += String::load(IDS_CONFIRM_INSTALL_DNS);
            }
         }

         if (operation != State::REPLICA)
         {
            if (state.ShouldAllowAnonymousAccess())
            {
               // Only show the anon access message in forest, tree, child
               // 394387

               message += String::load(IDS_CONFIRM_DO_RAS_FIXUP);
            }

            message += String::load(IDS_DOMAIN_ADMIN_PASSWORD);
         }

         break;
      }
      case State::DEMOTE:
      case State::ABORT_BDC_UPGRADE:
      {
         // hide the path controls: do nothing

         break;
      }
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   Win::SetDlgItemText(hwnd, IDC_MESSAGE, message);
   needToKillSelection = true;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   if (state.RunHiddenUnattended())
   {
      return ConfirmationPage::OnWizNext();
   }

   return true;
}




void
DoOperation(
   HWND                       parentDialog,
   ProgressDialog::ThreadProc threadProc,
   int                        animationResID)
{
   LOG_FUNCTION(DoOperation);
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(threadProc);
   ASSERT(animationResID > 0);

   // the ProgressDialog::OnInit actually starts the thread.
   ProgressDialog dialog(threadProc, animationResID);
   if (
         dialog.ModalExecute(parentDialog)
      == static_cast<int>(ProgressDialog::THREAD_SUCCEEDED))
   {
      LOG(L"OPERATION SUCCESSFUL");
   }
   else
   {
      LOG(L"OPERATION FAILED");
   }
}



int
DetermineAnimation()
{
   LOG_FUNCTION(DetermineAnimation);

   State& state = State::GetInstance();
   int aviID = IDR_AVI_DOMAIN;

   switch (state.GetOperation())
   {
      case State::REPLICA:
      {
         aviID = IDR_AVI_REPLICA;
         break;
      }
      case State::DEMOTE:
      {
         aviID = IDR_AVI_DEMOTE;
         break;
      }
      case State::FOREST:
      case State::TREE:
      case State::CHILD:
      case State::ABORT_BDC_UPGRADE:
      case State::NONE:
      default:
      {
         // do nothing
         break;
      }
   }

   return aviID;
}



bool
ConfirmationPage::OnWizNext()
{
   LOG_FUNCTION(ConfirmationPage::OnWizNext);

   State& state = State::GetInstance();
   
   DoOperation(hwnd, PromoteThreadProc, DetermineAnimation());
   if (state.GetNeedsReboot())
   {
      Win::PropSheet_RebootSystem(Win::GetParent(hwnd));
   }

   int nextPage = IDD_FAILURE;
   
   if (!state.IsOperationRetryAllowed())
   {
      nextPage = IDD_FINISH;
   }
   
   GetWizard().SetNextPageID(hwnd, nextPage);
      
   return true;
}



// noRoleMessageResId - resource ID of the string to use to format messages
// when no role change error message is available.
// 
// roleMessageResId - resource ID of the string to use to format messages when
// a role change error message is available.
// 
// "is available" => an operation results message has been set on the global
// state object.

String
ComposeFailureMessageHelper(
   const Win::Error& error,
   unsigned          noRoleMessageResId,
   unsigned          roleMessageResId)
{
   State& state         = State::GetInstance();              
   String win32_message = error.GetMessage();                
   String opMessage     = state.GetOperationResultsMessage();
   String message;

   if (
         error.GetHresult() == Win32ToHresult(ERROR_DS_CANT_ON_NON_LEAF)
      && state.GetOperation() == State::DEMOTE)
   {
      // supercede the meaningless error text for this situation.

      win32_message = String::load(IDS_DEMOTE_DOMAIN_HAS_DEPENDENTS);
   }

   if (error.GetHresult() == Win32ToHresult(ERROR_CANCELLED))
   {
      // this message may be a failure message from the operation that was
      // taking place when the cancel request was received.  In that case,
      // since the cancel has occurred, we don't care about this message

      opMessage.erase();
   }

   if (error.GetHresult() == Win32ToHresult(ERROR_BAD_NETPATH))
   {
      // n27117

      win32_message = String::load(IDS_RAS_BAD_NETPATH);
   }

   if (opMessage.empty())
   {
      message =
         String::format(
            noRoleMessageResId,
            win32_message.c_str());
   }
   else
   {
      message =
         String::format(
            roleMessageResId,
            win32_message.c_str(),
            opMessage.c_str());
   }

   return message;
}
  


void
ComposeFailureMessage(
   const Win::Error& error,
   bool              wasDisjoined,
   const String&     originalDomainName)

{
   LOG_FUNCTION(ComposeFailureMessage);

   String message =
      ComposeFailureMessageHelper(
         error,
         IDS_OPERATION_FAILED_NO_RESULT_MESSAGE,
         IDS_OPERATION_FAILED);

   if (wasDisjoined)
   {
      message += String::format(IDS_DISJOINED, originalDomainName.c_str());
   }

   State& state = State::GetInstance();
   
   if (
         state.GetOperationResultsFlags()
      &  DSROLE_IFM_RESTORED_DATABASE_FILES_MOVED)
   {
      message += L"\r\n\r\n" + String::load(IDS_MUST_RESTORE_IFM_FILES_AGAIN);
   }

   state.SetFailureMessage(message);
}



String
GetSbsLimitMessage()
{
   LOG_FUNCTION(GetSbsLimitMessage);

   static const String SBSLIMIT_DLL(L"sbslimit.dll");

   String message;

   HMODULE sbsDll = 0;
   HRESULT hr =
      Win::LoadLibraryEx(SBSLIMIT_DLL, LOAD_LIBRARY_AS_DATAFILE, sbsDll);
   if (FAILED(hr))
   {
      LOG(L"Unable to load SBSLIMIT_DLL");

      // fall back to a message of our own

      message = String::load(IDS_SBS_LIMITATION_MESSAGE);
   }
   else
   {
      // string 3 is the dcpromo message

      message = Win::LoadString(3, sbsDll);

      HRESULT unused = Win::FreeLibrary(sbsDll);

      ASSERT(SUCCEEDED(unused));
   }

   return message;
}



// Check if this is a Small Business Server product; if so, present throw an
// error, as SBS should only allow new forest & demote.  Rather brutal to do
// it in this fashion, but SBS users should not be using dcpromo directly.
// 353854, 353856 

void
CheckSmallBusinessServerLimitations(HWND hwnd)
throw (DS::Error)
{
   LOG_FUNCTION(CheckSmallBusinessServerLimitations);
   ASSERT(Win::IsWindow(hwnd));

   State& state = State::GetInstance();
   State::Operation op = state.GetOperation();

   switch (op)
   {
      case State::TREE:
      case State::CHILD:
      case State::REPLICA:
      {
         // Tree and child operations are not allowed with the SBS product.
         // Replica is allowed, if it is of a forest root domain.

         OSVERSIONINFOEX info;
         HRESULT hr = Win::GetVersionEx(info);
         BREAK_ON_FAILED_HRESULT(hr);

         if (info.wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED)
         {
            if (op == State::REPLICA)
            {
               String domain = state.GetReplicaDomainDNSName();

               // Since domain has been previously validated by calling
               // DsGetDcName, we don't anticipate that GetForestName will
               // have any difficulty.
               
               hr = S_OK;
               String forest = GetForestName(domain, &hr);
               if (FAILED(hr))
               {
                  ShowDcNotFoundErrorDialog(
                     hwnd,
                     -1,
                     domain,
                     String::load(IDS_WIZARD_TITLE),            
                     String::format(IDS_DC_NOT_FOUND, domain.c_str()),
                     false);

                  throw
                     DS::Error(
                        hr,
                        String::format(
                           IDS_UNABLE_TO_DETERMINE_FOREST,
                           domain.c_str()),
                        String::load(IDS_WIZARD_TITLE));
               }
                              
               DNS_RELATE_STATUS compare = Dns::CompareNames(domain, forest);
               if (compare == DnsNameCompareEqual)
               {
                  LOG(L"replica is of forest root, allowing promote");
                  break;
               }
            }

            // This machine is an SBS machine under restricted license.
            // Extract an error message from an SBS dll.

            LOG(L"Is SBS Restricted");

            String message = GetSbsLimitMessage();

            // do not call state.SetOperationResultsMessage with this
            // message, rather, include it in the thrown error.

            throw
               DS::Error(
                  S_OK,    // don't trigger cred retry
                  message,
                  String::load(IDS_SMALL_BUSINESS_LIMIT));
         }

         break;
      }
      case State::DEMOTE:
      case State::FOREST:
      case State::ABORT_BDC_UPGRADE:
      case State::NONE:
      default:
      {
         // do nothing
         break;
      }
   }
}



// Picks the name of a domain controller suitable for the creation of a
// replica.  Since a server must be a member of the domain before it can be
// made a replica of that domain, the server may also be joined to the domain
// before the replica operation is attempted.
// 
// We need to ensure that the domain controller used to join the domain is the
// same domain controller used to replicate the domain.  Also, since a machine
// account for the server may already exist on one or more -- but not
// necessarily all -- domain controllers, we need to pick a domain controller
// that has that machine account.  406462
// 
// domainName - DNS domain name of domain for which a replica is to be found.
// 
// resultDcName - receives the located name, or the empty string on failure.

HRESULT
GetJoinAndReplicaDcName(const String& domainName, String& resultDcName)
{
   LOG_FUNCTION(GetJoinAndReplicaDcName);
   ASSERT(!domainName.empty());

   resultDcName.erase();

   HRESULT hr = S_OK;

   do
   {
      // determine the local computer's domain machine account name.  This is the
      // name of the local computer, plus a "$"
   
      String netbiosName = Win::GetComputerNameEx(ComputerNameNetBIOS);
      String accountName = netbiosName + L"$";

      LOG(accountName);

      // look for a domain controller that has a machine account for the local
      // computer.  Not all domain controllers may have this account, due to
      // replication latency.

      DOMAIN_CONTROLLER_INFO* info = 0;
      hr =
         MyDsGetDcNameWithAccount(
            0,
            accountName,
            UF_WORKSTATION_TRUST_ACCOUNT | UF_SERVER_TRUST_ACCOUNT,
            domainName,
            DS_DIRECTORY_SERVICE_REQUIRED | DS_FORCE_REDISCOVERY,
            info);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(info->DomainControllerName);

      if (info->DomainControllerName)
      {
         resultDcName =
            Computer::RemoveLeadingBackslashes(info->DomainControllerName);

         LOG(resultDcName);
      }

      ::NetApiBufferFree(info);

      if (!resultDcName.empty())
      {
         return hr;
      }
   }
   while (0);

   // either there is no domain controller reachable with the required
   // account, or the account does not exist, or DsGetDcName returned an
   // empty name

   LOG(L"Falling back to non-account DsGetDcName");

   return GetDcName(domainName, resultDcName);
}



void
EvaluateRoleChangeState()
throw (DS::Error)
{
   LOG_FUNCTION(EvaluateRoleChangeState);

   int messageResId = 0;   

   DSROLE_OPERATION_STATE opState = ::DsRoleOperationIdle;
   DSROLE_OPERATION_STATE_INFO* info = 0;
   HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
   if (SUCCEEDED(hr) && info)
   {
      opState = info->OperationState;
      ::DsRoleFreeMemory(info);
   }
   else
   {
      throw
         DS::Error(
            hr,
            String::load(IDS_UNABLE_TO_DETERMINE_OP_STATE),
            String::load(IDS_WIZARD_TITLE));
   }
   
   switch (opState)
   {
      case ::DsRoleOperationIdle:
      {
         // do nothing
         
         break;
      }
      case ::DsRoleOperationActive:
      {
         // a role change operation is underway
         
         messageResId = IDS_ROLE_CHANGE_IN_PROGRESS;
         break;
      }
      case ::DsRoleOperationNeedReboot:
      {
         // a role change has already taken place, need to reboot before
         // attempting another.
         
         messageResId = IDS_ROLE_CHANGE_NEEDS_REBOOT;
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   if (messageResId)
   {
      throw
         DS::Error(
            S_OK,
            String::load(messageResId),
            String::load(IDS_WIZARD_TITLE));
   }
}



// Verify that the current role of the machine is correct for the type of
// operation we're about to attempt.  Throw an exception if it is not.

void
DoubleCheckRoleChangeState()
throw (DS::Error)
{
   LOG_FUNCTION(DoubleCheckRoleChangeState);

   // Make sure that an operation is not in progress or pending reboot.
   
   EvaluateRoleChangeState();
   
   State& state = State::GetInstance();
   Computer& computer = state.GetComputer();

   HRESULT hr = computer.Refresh();
   if (FAILED(hr))
   {
      throw
         DS::Error(
            hr,
            String::load(IDS_UNABLE_TO_DETERMINE_COMPUTER_CONFIG),
            String::load(IDS_WIZARD_TITLE));
   }
   
   switch (state.GetOperation())
   {
      case State::TREE:
      case State::CHILD:
      case State::REPLICA:
      case State::FOREST:
      case State::ABORT_BDC_UPGRADE:
      {
         // Make sure the machine is not already a DC. If the machine is
         // an NT4 DC finishing upgrade, then its role will be member
         // server, not domain controller.

         if (computer.IsDomainController())
         {
            throw
               DS::Error(
                  S_OK,
                  String::load(IDS_MACHINE_IS_ALREADY_DC),
                  String::load(IDS_WIZARD_TITLE));
         }

         break;
      }
      case State::DEMOTE:
      {
         // Make sure the machine is still a DC

         if (!computer.IsDomainController())
         {
            throw
               DS::Error(
                  S_OK,
                  String::load(IDS_MACHINE_IS_NOT_ALREADY_DC),
                  String::load(IDS_WIZARD_TITLE));
         }

         break;
      }
      case State::NONE:
      default:
      {
         ASSERT(false);
         
         // do nothing

         break;
      }
   }
}



// thread launched by ProgressDialog::OnInit.
// CODEWORK: Man, this function has evolved into a real mess.

void 
PromoteThreadProc(ProgressDialog& progress)
{
   LOG_FUNCTION(PromoteThreadProc);

   //
   // Access to members of ProgressDialog is not, by default, threadsafe.
   // However, since the only members we access are atomic data types, this
   // is not a problem.  Note also that calls to ProgressDialog Update
   // methods usually resolve to calls to SendMessage on UI elements of the
   // dialog.  This too is threadsafe, as SendMessage is always executed
   // in the thread that created the window (tho it may block the calling
   // thread).
   //

   UINT   message      = ProgressDialog::THREAD_SUCCEEDED;
   bool   retry        = false;                           
   bool   wasDisjoined = false;                           
   State& state        = State::GetInstance();            
   String originalDomainName;

   // a reference, as we will refresh the object
   
   Computer& computer = state.GetComputer();
   State::RunContext context = state.GetRunContext();

   do
   {
      LOG(L"top of retry loop");

      DisableConsoleLocking();

      // clear the state of the operation attempt
      
      bool exceptionWasThrown = false;
      Win::Error errorThrown(0, 0);
      message = ProgressDialog::THREAD_SUCCEEDED;
      retry = false;
      state.SetOperationResultsMessage(String());
      state.SetOperationResultsFlags(0);

      progress.UpdateText(IDS_STARTING);

      try
      {
         CheckSmallBusinessServerLimitations(progress.GetHWND());

         // Double check that the role of the machine is still ok for the
         // operation to proceed.  This is mostly a paranoid check, but there
         // have been cases during development where the promotion actually
         // succeeded, but reported a failure, and attempting the operation
         // again trashes the DS.  Such problems indicate the presence of
         // other serious bugs, but if we can cheaply avoid zorching a DC,
         // then bully for us.
         // NTRAID#NTBUG9-345115-2001/03/23-sburns
         
         DoubleCheckRoleChangeState();
         
         switch (state.GetOperation())
         {
            case State::REPLICA:
            {
               // if we're using an answerfile, look for a replication partner
               // there. 107143

               String replDc;
               if (state.UsingAnswerFile())
               {
                  replDc =
                     state.GetAnswerFileOption(
                        AnswerFile::OPTION_REPLICATION_SOURCE);
                  state.SetReplicationPartnerDC(replDc);
               }

               if (context != State::BDC_UPGRADE)
               {
                  String replicaDnsDomainName =
                     state.GetReplicaDomainDNSName();
                  if (!computer.IsJoinedToDomain(replicaDnsDomainName) )
                  {
                     // need to join the domain we will replicate. Determine
                     // the name of a domain controller to use for join and
                     // replication. 270233

                     if (replDc.empty())
                     {
                        // answerfile did not specify a dc.  So pick one
                        // ourselves.

                        HRESULT hr =
                           GetJoinAndReplicaDcName(
                              replicaDnsDomainName,
                              replDc);
                        if (FAILED(hr))
                        {
                           throw
                              DS::Error(
                                 hr,
                                 IDS_JOIN_DOMAIN_FAILED);
                        }
                        state.SetReplicationPartnerDC(replDc);
                     }

                     if (computer.IsJoinedToDomain())
                     {
                        originalDomainName =
                           computer.GetDomainNetbiosName();
                     }

                     progress.UpdateText(IDS_CHANGING_DOMAIN);

                     // this will unjoin if necessary

                     DS::JoinDomain(
                        replicaDnsDomainName,
                        replDc,
                        state.GetUsername(),
                        state.GetPassword(),
                        state.GetUserDomainName());

                     if (ComputerWasRenamedAndNeedsReboot())
                     {
                        // If we make it to this point, the machine was joined
                        // to a domain, and the name changed as a side-effect,
                        // and will need to be rebooted even if the promote
                        // fails. Set a flag to note that fact.
                        // NTRAID#NTBUG9-346120-2001/04/04-sburns

                        state.SetNeedsReboot();
                     }
                     
                     HRESULT hr = computer.Refresh();
                     ASSERT(SUCCEEDED(hr));

                     if (!originalDomainName.empty())
                     {
                        wasDisjoined = true;
                     }
                  }
                  
                  DS::CreateReplica(progress);
               }
               else
               {
                  DS::UpgradeBDC(progress);
               }
               break;
            }
            case State::FOREST:
            case State::TREE:
            case State::CHILD:
            {
               if (context != State::PDC_UPGRADE)
               {
                  if (computer.IsJoinedToDomain())
                  {
                     // need to unjoin the domain we belong to

                     originalDomainName = computer.GetDomainNetbiosName();
                     ASSERT(!originalDomainName.empty());

                     progress.UpdateText(
                        String::format(IDS_DISJOINING_PROGRESS,
                        originalDomainName.c_str()));

                     if (!DS::DisjoinDomain())
                     {
                        // the computer account was not removed.
                        if (!state.RunHiddenUnattended())
                        {
                           popup.Info(
                              progress.GetHWND(), 
                              String::load(IDS_COULDNT_REMOVE_COMPUTER_ACCOUNT_TEXT));
                        }
                     }

                     if (ComputerWasRenamedAndNeedsReboot())
                     {
                        // If we make it to this point, the machine was
                        // disjoined from a domain, and the name changed as a
                        // side-effect, and will need to be rebooted even if
                        // the promote fails. Set a flag to note that fact.
                        // NTRAID#NTBUG9-346120-2001/04/04-sburns

                        state.SetNeedsReboot();
                     }
                     
                     HRESULT hr = computer.Refresh();
                     ASSERT(SUCCEEDED(hr));

                     wasDisjoined = true;
                  }

                  DS::CreateNewDomain(progress);
               }
               else
               {
                  DS::UpgradePDC(progress);
               }
               break;
            }
            case State::ABORT_BDC_UPGRADE:
            {
               ASSERT(state.GetRunContext() == State::BDC_UPGRADE);
               DS::AbortBDCUpgrade();
               break;
            }
            case State::DEMOTE:
            {
               DS::DemoteDC(progress);
               break;
            }
            case State::NONE:
            default:
            {
               ASSERT(false);
               message = ProgressDialog::THREAD_FAILED;
            }
         }

         //
         // At this point, the operation was successfully completed.
         // 

         DoPostOperationStuff(progress);
         state.SetOperationResults(State::SUCCESS);
         state.SetNeedsReboot();
      }
      catch (const Win::Error& err)
      {
         LOG(L"Exception caught");

         exceptionWasThrown = true;
         errorThrown = err;

         LOG(L"catch completed");
      }

      if (exceptionWasThrown)
      {
         LOG(L"handling exception");

         // go interactive from now on

         state.ClearHiddenWhileUnattended();    // 22935

         if (
               state.GetRunContext() != State::PDC_UPGRADE
            && state.GetRunContext() != State::BDC_UPGRADE)
         {
            // re-enable console locking if not a downlevel upgrade 28496

            EnableConsoleLocking();
         }

         state.SetOperationResults(State::FAILURE);
         progress.UpdateText(String());
         message = ProgressDialog::THREAD_FAILED;

         HRESULT errorThrownHresult = errorThrown.GetHresult();

         if (!state.IsOperationRetryAllowed())
         {
            // The operation failure was such that the user should not be
            // allowed to retry it. In this case, we skip our special-case
            // handling of known failure codes (as expressed by the other else
            // if clauses here), and just report the failure.
            //         
            // NTRAID#NTBUG9-296872-2001/01/29-sburns
            
            retry = false;
         }
         else if (
               errorThrownHresult == Win32ToHresult(ERROR_ACCESS_DENIED)
            || errorThrownHresult == Win32ToHresult(ERROR_LOGON_FAILURE)
            || errorThrownHresult == Win32ToHresult(ERROR_NOT_AUTHENTICATED)
            || errorThrownHresult == Win32ToHresult(RPC_S_SEC_PKG_ERROR)
            || errorThrownHresult == Win32ToHresult(ERROR_DS_DRA_ACCESS_DENIED)
            || errorThrownHresult == Win32ToHresult(ERROR_INVALID_PASSWORD)
            || errorThrownHresult == Win32ToHresult(ERROR_PASSWORD_EXPIRED)
            || errorThrownHresult == Win32ToHresult(ERROR_ACCOUNT_DISABLED)
            || errorThrownHresult == Win32ToHresult(ERROR_ACCOUNT_LOCKED_OUT) )
         {
            // bad credentials.  ask for new ones

            String failureMessage =
               ComposeFailureMessageHelper(
                  errorThrown,
                  IDS_OPERATION_FAILED_GET_CRED_NO_RESULT,
                  IDS_OPERATION_FAILED_GET_CRED);

            GetCredentialsDialog dlg(failureMessage);
            if (dlg.ModalExecute(progress) == IDOK)
            {
               retry = true;

               // jump to top of operation loop

               continue;
            }

            LOG(L"credential retry canceled");

            ComposeFailureMessage(
               errorThrown,
               wasDisjoined,
               originalDomainName);
               
            break;
         }
         else if (errorThrownHresult == Win32ToHresult(ERROR_DOMAIN_EXISTS))
         {
            LOG(L"domain exists: prompting for re-install");

            // ask if the user wishes to reinstall the domain.

            if (
               popup.MessageBox(
                  progress.GetHWND(),
                  String::format(
                     IDS_REINSTALL_DOMAIN_MESSAGE,
                     state.GetNewDomainDNSName().c_str()),
                  MB_YESNO | MB_ICONWARNING) == IDYES)
            {
               state.SetDomainReinstallFlag(true);
               retry = true;

               // jump to top of operation loop

               continue;
            }

            LOG(L"reinstall domain retry canceled");
         }
         else if (
            errorThrownHresult ==
               Win32ToHresult(ERROR_DOMAIN_CONTROLLER_EXISTS))
         {
            LOG(L"domain controller exists: prompting to force promote");

            // ask if the user wants to re-install the domain controller

            if (
               popup.MessageBox(
                  progress.GetHWND(),
                  String::format(
                     IDS_REINSTALL_DOMAIN_CONTROLLER_MESSAGE,
                     state.GetComputer().GetNetbiosName().c_str()),
                     MB_YESNO | MB_ICONWARNING) == IDYES)
            {
               state.SetDomainControllerReinstallFlag(true);
               retry = true;

               // jump to the top of the operation loop

               continue;
            }

            LOG(L"reinstall domain controller retry canceled");
         }

         // if we're retrying, then we should have jumped to the top of
         // the loop.

         ASSERT(!retry);
         
         ComposeFailureMessage(
            errorThrown,
            wasDisjoined,
            originalDomainName);

// NTRAID#NTBUG9-416968-2001/06/14-sburns            
#ifdef DBG
         if (state.IsExitOnFailureMode())
         {
            // Farewell.

            LOG(L"exit-on-failure mode active: time to die.");

            ::ExitProcess(0);
         }
#endif         
                     
         Win::MessageBox(
            progress.GetHWND(),
            state.GetFailureMessage(),
            errorThrown.GetSummary(), // title the error was built with
            MB_OK | MB_ICONERROR | MB_SYSTEMMODAL);
      }
   }
   while (retry);

#ifdef DBG
   if (message == ProgressDialog::THREAD_FAILED)
   {
      ASSERT(state.GetOperationResultsCode() == State::FAILURE);
   }
   else
   {
      ASSERT(state.GetOperationResultsCode() == State::SUCCESS);
   }
#endif

   LOG(L"posting message to progress window");

   HRESULT hr = Win::PostMessage(progress.GetHWND(), message, 0, 0);

   ASSERT(SUCCEEDED(hr));

   // do not call _endthread here, or stack will not be properly cleaned up
}



bool
ConfirmationPage::OnCommand(
   HWND        windowFrom,
   unsigned    controlIdFrom,
   unsigned    code)
{
   bool result = false;
   
   switch (controlIdFrom)
   {
      case IDCANCEL:
      {
         // multi-line edit control eats escape keys.  This is a workaround
         // from ericb, to forward the message to the prop sheet.

         Win::SendMessage(
            Win::GetParent(hwnd),
            WM_COMMAND,
            MAKEWPARAM(controlIdFrom, code),
            (LPARAM) windowFrom);
         break;   
      }
      case IDC_MESSAGE:
      {
         switch (code)
         {
            case EN_SETFOCUS:
            {
               if (needToKillSelection)
               {
                  // kill the text selection

                  Win::Edit_SetSel(windowFrom, -1, -1);
                  needToKillSelection = false;
                  result = true;
               }
               break;
            }
            case MultiLineEditBoxThatForwardsEnterKey::FORWARDED_ENTER:
            {
               // our subclasses mutli-line edit control will send us
               // WM_COMMAND messages when the enter key is pressed.  We
               // reinterpret this message as a press on the default button of
               // the prop sheet.
               // This workaround from phellyar.
               // NTRAID#NTBUG9-232092-2000/11/22-sburns
   
               HWND propSheet = Win::GetParent(hwnd);
               int defaultButtonId =
                  Win::Dialog_GetDefaultButtonId(propSheet);
   
               // we expect that there is always a default button on the prop sheet
                  
               ASSERT(defaultButtonId);
   
               Win::SendMessage(
                  propSheet,
                  WM_COMMAND,
                  MAKELONG(defaultButtonId, BN_CLICKED),
                  0);
   
               result = true;
               break;
            }
         }
         break;
      }
      default:
      {
         // do nothing
         
         break;
      }
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\credentialspage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// get credentials page
//
// 12-22-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "CredentialsPage.hpp"
#include "resource.h"
#include "state.hpp"
#include "ds.hpp"
#include "CredentialUiHelpers.hpp"
#include "common.hpp"
#include <DiagnoseDcNotFound.hpp>



CredentialsPage::CredentialsPage()
   :
   DCPromoWizardPage(
      IDD_GET_CREDENTIALS,
      IDS_CREDENTIALS_PAGE_TITLE,
      IDS_CREDENTIALS_PAGE_SUBTITLE),
   readAnswerfile(false),
   hwndCred(0),
   lastWizardButtonsState(PSWIZB_BACK)
{
   LOG_CTOR(CredentialsPage);

   CredUIInitControls();
}



CredentialsPage::~CredentialsPage()
{
   LOG_DTOR(CredentialsPage);
}



void
CredentialsPage::OnInit()
{
   LOG_FUNCTION(CredentialsPage::OnInit);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_DOMAIN),
      Dns::MAX_NAME_LENGTH);
}



void
CredentialsPage::Enable()
{
// LOG_FUNCTION(CredentialsPage::Enable);

   DWORD nextState =
         PSWIZB_BACK
      |  ((  !CredUi::GetUsername(Win::GetDlgItem(hwnd, IDC_CRED)).empty() 
         && !Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN).empty() )
         ?  PSWIZB_NEXT : 0);

   // only set the buttons when the state changes to prevent button
   // flicker when the user is typing in the user name field
   // NTRAID#NTBUG9-504441-2001/12/07-sburns
   
   if (nextState != lastWizardButtonsState)
   {
      Win::PropSheet_SetWizButtons(
         Win::GetParent(hwnd),
         nextState);
      lastWizardButtonsState = nextState;
   }
}


   
bool
CredentialsPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(CredentialsPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_CRED:
      {
         if (code == CRN_USERNAMECHANGE)
         {
            SetChanged(controlIDFrom);
            Enable();
            return true;
         }
         break;
      }
      case IDC_DOMAIN:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);

            Enable();
            return true;
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



bool
CredentialsPage::ShouldSkipPage()
{
   LOG_FUNCTION(CredentialsPage::ShouldSkipPage);

   State& state = State::GetInstance();
   State::Operation oper = state.GetOperation();

   bool result = false;

   switch (oper)
   {
      case State::FOREST:
      {
         // never need credentials for new forest.

         result = true;
         break;
      }
      case State::DEMOTE:
      {
         // The demote page should circumvent this page if necessary, so if
         // we make it here, don't skip the page.

         break;
      }
      case State::ABORT_BDC_UPGRADE:
      case State::REPLICA:
      case State::TREE:
      case State::CHILD:
      {
         break;
      }
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return result;
}



int
CredentialsPage::DetermineNextPage()
{
   LOG_FUNCTION(CredentialsPage::DetermineNextPage);

   State& state = State::GetInstance();

   int id = IDD_PATHS;
   switch (state.GetOperation())
   {
      case State::DEMOTE:
      case State::ABORT_BDC_UPGRADE:
      {
         id = IDD_ADMIN_PASSWORD;
         break;
      }
      case State::FOREST:
      {
         id = IDD_NEW_FOREST;
         break;
      }
      case State::REPLICA:
      {
         if (state.GetRunContext() == State::BDC_UPGRADE)
         {
            id = IDD_PATHS;
         }
         else
         {
            id = IDD_REPLICA;
         }
         break;
      }
      case State::TREE:
      {
         id = IDD_NEW_TREE;
         break;
      }
      case State::CHILD:
      {
         id = IDD_NEW_CHILD;
         break;
      }
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return id;
}



String
GetMessage()
{
   String message;
   State& state = State::GetInstance();

   switch (state.GetOperation())
   {
      case State::ABORT_BDC_UPGRADE:
      {
         message = String::load(IDS_ABORT_BDC_UPGRADE_CREDENTIALS);
         break;
      }
      case State::TREE:
      case State::CHILD:
      case State::REPLICA:
      {
         message = String::load(IDS_PROMOTION_CREDENTIALS);
         break;
      }
      case State::DEMOTE:
      {
         // 318736 demote requires enterprise admin credentials -- for
         // root and child domains alike.

         message =
            String::format(
               IDS_ROOT_DOMAIN_CREDENTIALS,
               state.GetComputer().GetForestDnsName().c_str());
         break;
      }
      case State::FOREST:
      {
         // do nothing, the page will be skipped.

         break;
      }
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return message;
}



String
DefaultUserDomainName()
{
   String d;
   State& state = State::GetInstance();
   const Computer& computer = state.GetComputer();

   switch (state.GetOperation())
   {
      case State::ABORT_BDC_UPGRADE:
      {
         // NTRAID#NTBUG9-469647-2001/09/21-sburns
         
         d = computer.GetDomainNetbiosName();
         break;
      }
      case State::FOREST:
      {
         // do nothing

         break;
      }
      case State::DEMOTE:     // 301361
      case State::TREE:
      {
         d = computer.GetForestDnsName();
         break;
      }
      case State::CHILD:
      {
         d = computer.GetDomainDnsName();
         break;
      }
      case State::REPLICA:
      {
         d = computer.GetDomainDnsName();
         if (d.empty() && state.ReplicateFromMedia())
         {
            d = state.GetReplicaDomainDNSName();
         }
         break;
      }
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return d;
}



bool
AreSmartCardsAllowed()
{
   LOG_FUNCTION(AreSmartCardsAllowed);

   bool result = false;
   
   // Only use the smartcard flag when the machine is joined to a domain. On a
   // standalone machine, the smartcard won't have access to any domain
   // authority to authenticate it.
   // NTRAID#NTBUG9-287538-2001/01/23-sburns
   
   State&    state    = State::GetInstance();
   Computer& computer = state.GetComputer(); 

   if (
         computer.IsJoinedToDomain()

         // can only use smartcards on replica promotions
         // NTRAID#NTBUG9-311150-2001/02/19-sburns
         
      && state.GetOperation() == State::REPLICA)
   {
      result = true;
   }

   LOG_BOOL(result);

   return result;
}
   


void      
CredentialsPage::CreateCredentialControl()
{
   LOG_FUNCTION(CredentialsPage::CreateCredentialControl);

   HWND hwndPlaceholder = Win::GetDlgItem(hwnd, IDC_CRED_PLACEHOLDER);

   // Idea: Destroy the existing cred control, create a new one in the
   // same place as the placeholder

   RECT placeholderRect;
   Win::GetWindowRect(hwndPlaceholder, placeholderRect);

   // Don't use ScreenToClient: it's not BiDi-smart.
   // Win::ScreenToClient(hwnd, placeholderRect);
   // NTRAID#NTBUG9-524054-2003/01/20-sburns

   ::MapWindowPoints(HWND_DESKTOP, hwnd, (LPPOINT) &placeholderRect, 2);
      
      
   if (hwndCred)
   {
      Win::DestroyWindow(hwndCred);
      hwndCred = 0;
   }

   Win::CreateWindowEx(
      0,
      L"SysCredential",
      L"", 
      WS_CHILD | WS_VISIBLE | WS_TABSTOP | 0x30, // 0x50010030, 
      placeholderRect.left,
      placeholderRect.top,
      placeholderRect.right - placeholderRect.left,
      placeholderRect.bottom - placeholderRect.top,
      hwnd,
      (HMENU) IDC_CRED,
      0,
      hwndCred);

   Win::SetWindowPos(
      hwndCred,
      HWND_TOP,
      0,0,0,0,
      SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER | SWP_NOSENDCHANGING);

   DWORD flags = CRS_NORMAL | CRS_USERNAMES;
   if (AreSmartCardsAllowed())
   {
      flags |= CRS_SMARTCARDS;
   }
   Credential_InitStyle(hwndCred, flags);

   Credential_SetUserNameMaxChars(hwndCred, DS::MAX_USER_NAME_LENGTH);
   Credential_SetPasswordMaxChars(hwndCred, DS::MAX_PASSWORD_LENGTH);
}



bool
CredentialsPage::OnSetActive()
{
   LOG_FUNCTION(CredentialsPage::OnSetActive);

   Win::WaitCursor cursor;

   CreateCredentialControl();
   
   State&  state    = State::GetInstance();
   Wizard& wiz      = GetWizard();         

   if (ShouldSkipPage())
   {
      LOG(L"skipping CredentialsPage");

      if (wiz.IsBacktracking())
      {
         // backup once again

         wiz.Backtrack(hwnd);
      }
      else
      {
         wiz.SetNextPageID(hwnd, DetermineNextPage());
      }

      return true;
   }

   if (!readAnswerfile && state.UsingAnswerFile())
   {
      CredUi::SetUsername(
         hwndCred,
         state.GetAnswerFileOption(AnswerFile::OPTION_USERNAME));
      CredUi::SetPassword(
         hwndCred,
         state.GetEncryptedAnswerFileOption(AnswerFile::OPTION_PASSWORD));

      String domain =
         state.GetAnswerFileOption(AnswerFile::OPTION_USER_DOMAIN);
      
      if (domain.empty())
      {
         domain = DefaultUserDomainName();
      }
      Win::SetDlgItemText(
         hwnd,
         IDC_DOMAIN,
         domain);

      readAnswerfile = true;
   }
   else
   {
      // use the credentials last entered (for browsing, etc.)

      // Only set the state of the control if we're not allowing smartcards.
      // If we set the username, and the name actually corresponds to a
      // smartcard cert, then setting the name will cause the control to
      // attempt to match that name to a cert on the card in the reader. That
      // causes the control to appear frozen for awhile.  Instead of setting
      // the username, the user will have to re-select the card or re-type
      // the username.
      // NTRAID#NTBUG9-499120-2001/11/28-sburns
      
      if (!AreSmartCardsAllowed())
      {
         CredUi::SetUsername(hwndCred, state.GetUsername());
         CredUi::SetPassword(hwndCred, state.GetPassword());
      }

      Win::SetDlgItemText(hwnd, IDC_DOMAIN, state.GetUserDomainName());
   }

   if (state.RunHiddenUnattended())
   {
      int nextPage = CredentialsPage::Validate();
      if (nextPage != -1)
      {
         wiz.SetNextPageID(hwnd, nextPage);
         return true;
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   // cause the button state to be re-evaluated on page activation
   // NTRAID#NTBUG9-509806-2002/01/03-sburns
   
   lastWizardButtonsState = 0;
   Enable();

   Win::SetDlgItemText(hwnd, IDC_MESSAGE, GetMessage());

   if (Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN).empty())
   {
      // supply a default domain if none already present

      Win::SetDlgItemText(hwnd, IDC_DOMAIN, DefaultUserDomainName());
   }

   return true;
}



int
CredentialsPage::Validate()
{
   LOG_FUNCTION(CredentialsPage::Validate);

   int nextPage = -1;
   
   do
   {
      if (
            !WasChanged(IDC_CRED)
         && !WasChanged(IDC_DOMAIN))
      {
         // nothing changed => nothing to validate

         nextPage = DetermineNextPage();
         break;
      }

      State& state = State::GetInstance();

      String username = CredUi::GetUsername(hwndCred);

      if (username.empty())
      {
         popup.Gripe(hwnd, IDC_CRED, IDS_MUST_ENTER_USERNAME);
         break;
      }

      String domain = Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN);
      if (domain.empty())
      {
         popup.Gripe(hwnd, IDC_DOMAIN, IDS_MUST_ENTER_USER_DOMAIN);
         break;
      }

      Win::WaitCursor cursor;

      // the domain must be an NT 5 domain: no user of a downlevel domain
      // could perform operations in an NT 5 forest.  We get the forest name
      // of the domain ('cause that may be useful for the new tree scenario)
      // as a means of validating the domain name.  If the domain does not
      // exist, or is not an NT5 domain, then this call will fail.

      String forest = GetForestName(domain);
      if (forest.empty())
      {
         ShowDcNotFoundErrorDialog(
            hwnd,
            IDC_DOMAIN,
            domain,
            String::load(IDS_WIZARD_TITLE),            
            String::format(IDS_DC_NOT_FOUND, domain.c_str()),
            false);
         break;
      }

      if (state.GetOperation() == State::TREE)
      {
         // For the new tree case, we need to validate the forest name (a dns
         // domain name) by ensuring that we can find a writable DS DC in that
         // domain. The user may have supplied a netbios domain name, and it
         // is possible that the domain's DNS registration is broken.  Since
         // we will use the forest name as the parent domain name in the call
         // to DsRoleDcAsDc, we need to make sure we can find DCs with that
         // name. 122886

         DOMAIN_CONTROLLER_INFO* info = 0;
         HRESULT hr =
            MyDsGetDcName(
               0, 
               forest,

               // force discovery to ensure that we don't pick up a cached
               // entry for a domain that may no longer exist, writeable
               // and DS because we happen to know that's what the
               // DsRoleDcAsDc API will require.

                  DS_FORCE_REDISCOVERY
               |  DS_WRITABLE_REQUIRED
               |  DS_DIRECTORY_SERVICE_REQUIRED,
               info);
         if (FAILED(hr) || !info)
         {
            ShowDcNotFoundErrorDialog(
               hwnd,
               IDC_DOMAIN,
               forest,
               String::load(IDS_WIZARD_TITLE),               
               String::format(IDS_DC_FOR_ROOT_NOT_FOUND, forest.c_str()),

               // we know the name can't be netbios: forest names are always
               // DNS names
            
               true);
            break;
         }

         ::NetApiBufferFree(info);
      }

      state.SetUserForestName(forest);

      // set these now so we can read the domain topology

      state.SetUsername(username);
      state.SetPassword(CredUi::GetPassword(hwndCred));
      state.SetUserDomainName(domain);

      // cache the domain topology: this is used to validate new tree,
      // child, and replica domain names in later pages.  It's also a
      // pretty good validation of the credentials.

      HRESULT hr = state.ReadDomains();
      if (FAILED(hr))
      {
         if (  hr == Win32ToHresult(ERROR_NO_SUCH_DOMAIN)
            || hr == Win32ToHresult(ERROR_DOMAIN_CONTROLLER_NOT_FOUND))
         {
            // this could happen, I suppose, but it seems very unlikely
            // since ReadDomains calls DsGetDcName in the same fashion that
            // all the preceeding calls do, and would catch this problem.
            
            ShowDcNotFoundErrorDialog(
               hwnd,
               IDC_DOMAIN,
               domain,
               String::load(IDS_WIZARD_TITLE),            
               String::format(IDS_DC_NOT_FOUND, domain.c_str()),
               false);
            break;
         }
         else if (hr == Win32ToHresult(RPC_S_SERVER_UNAVAILABLE))
         {
            // One way to hit this is change the IP address(es) of the DC(s),
            // but not update their DNS registrations. Thus, DNS points to the
            // wrong address. I would have thought that DsGetDcName would
            // account for that, but whatever....
            // NTRAID#NTBUG9-494232-2001/11/21-sburns            
            
            popup.Gripe(
               hwnd,
               IDC_DOMAIN,
               hr,
               String::format(IDS_UNABLE_TO_READ_FOREST_WITH_LINK));
            break;
         }

         popup.Gripe(
            hwnd,
            IDC_DOMAIN,
            hr,
            String::format(IDS_UNABLE_TO_READ_FOREST));
         break;
      }

      // valid

      ClearChanges();

      nextPage = DetermineNextPage();
   }
   while (0);

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\credentialuihelpers.hpp ===
// Copyright (c) 2000 Microsoft Corporation
// 
// Wrappers of wincrui.h APIs
// 
// 19 July 2000 sburns



#ifndef CREDENTIALUIHELPERS_HPP_INCLUDED
#define CREDENTIALUIHELPERS_HPP_INCLUDED



namespace CredUi
{
   String
   GetUsername(HWND credControl);

   HRESULT
   SetUsername(HWND credControl, const String& username);

   EncryptedString
   GetPassword(HWND credControl);

   HRESULT
   SetPassword(HWND credControl, const EncryptedString& password);
}  // namespace CredUi



#endif   // #ifndef CREDENTIALUIHELPERS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\credentialspage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// credentials page
//
// 12-22-97 sburns



#ifndef CREDENTIALSPAGE_HPP_INCLUDED
#define CREDENTIALSPAGE_HPP_INCLUDED



class CredentialsPage : public DCPromoWizardPage
{
   public:

   CredentialsPage();

   protected:

   virtual ~CredentialsPage();



   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();



   // PropertyPage overrides

   virtual
   bool
   OnSetActive();



   // DCPromoWizardPage overrides

   virtual
   int
   Validate();



   private:


   
   // Deletes the existing cred control, creates a new one, and sets the style
   // flags appropriately. Called by OnSetActive.
   // NTRAID#NTBUG9-493134-2001/11/14-sburns
   
   void
   CreateCredentialControl();

   void
   Enable();
   
   bool
   ShouldSkipPage();
   
   int
   DetermineNextPage();


   
   bool  readAnswerfile;        
   HWND  hwndCred;              
   DWORD lastWizardButtonsState;

   // not defined; no copying allowed
   CredentialsPage(const CredentialsPage&);
   const CredentialsPage& operator=(const CredentialsPage&);
};



#endif   // CREDENTIALSPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\credentialuihelpers.cpp ===
// Copyright (c) 2000 Microsoft Corporation
// 
// Wrappers of wincrui.h APIs
// 
// 19 July 2000 sburns



#include "headers.hxx"
#include "CredentialUiHelpers.hpp"



String
CredUi::GetUsername(HWND credControl)
{
//   LOG_FUNCTION(CredUi::GetUsername);
   ASSERT(Win::IsWindow(credControl));

   String result;
   LONG length = Credential_GetUserNameLength(credControl);

   // Length may be -1 if the control is not ready to supply the username.
   // This can happen with smartcards due to the asynchonous event nature
   // of the smartcard system.
   //
   // N.B.: if length == -1, then Credential_GetUserName may return FALSE.
   
   if (length > 0)
   {
      result.resize(length + 1, 0);
      BOOL succeeded =
         Credential_GetUserName(credControl, 
         const_cast<WCHAR*>(result.c_str()),
         length);
      ASSERT(succeeded);

      if (succeeded)
      {
         // ISSUE-2002/02/25-sburns could probably remove this call to
         // wcslen and replace with length
         
         result.resize(wcslen(result.c_str()));
      }
      else
      {
         result.erase();
      }
   }

//   LOG(result);

   return result;
}



EncryptedString
CredUi::GetPassword(HWND credControl)
{
   LOG_FUNCTION(CredUi::GetPassword);
   ASSERT(Win::IsWindow(credControl));

   EncryptedString result;

   // add 1 for super-paranoid null terminator.
   
   size_t length = Credential_GetPasswordLength(credControl) + 1;

   if (length)
   {
      WCHAR* cleartext = new WCHAR[length];

      // REVIEWED-2002/02/25-sburns byte count correctly passed.
      
      ::ZeroMemory(cleartext, sizeof WCHAR * length);
      
      BOOL succeeded =
         Credential_GetPassword(
            credControl,
            cleartext,
            length - 1);
      ASSERT(succeeded);

      result.Encrypt(cleartext);

      // make sure we scribble out the cleartext.
      
      // REVIEWED-2002/02/25-sburns byte count correctly passed.

      ::SecureZeroMemory(cleartext, sizeof WCHAR * length);
      delete[] cleartext;
   }

   // don't log the password...

   return result;
}
   


HRESULT
CredUi::SetUsername(HWND credControl, const String& username)
{
   LOG_FUNCTION(CredUi::SetUsername);
   ASSERT(Win::IsWindow(credControl));

   HRESULT hr = S_OK;

   // username may be empty

   BOOL succeeded = Credential_SetUserName(credControl, username.c_str());
   ASSERT(succeeded);

   // BUGBUG what if it failed?  Is GetLastError valid?

   return hr;
}



HRESULT
CredUi::SetPassword(HWND credControl, const EncryptedString& password)
{
   LOG_FUNCTION(CredUi::SetPassword);
   ASSERT(Win::IsWindow(credControl));

   HRESULT hr = S_OK;

   // password may be empty

   WCHAR* cleartext = password.GetClearTextCopy();
   BOOL succeeded = Credential_SetPassword(credControl, cleartext);
   ASSERT(succeeded);

   password.DestroyClearTextCopy(cleartext);

   // BUGBUG what if it failed?  Is GetLastError valid?
   
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\demotepage.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// demote page
//
// 1-20-98 sburns



#ifndef DEMOTE_HPP_INCLUDED
#define DEMOTE_HPP_INCLUDED



class DemotePage : public DCPromoWizardPage
{
   public:

   DemotePage();

   protected:

   virtual ~DemotePage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   DemotePage(const DemotePage&);
   const DemotePage& operator=(const DemotePage&);

   void
   SetBulletFont();

   HFONT bulletFont;
};



#endif   // DEMOTE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\dnsonnetpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// test DNS configured page
//
// 12-18-97 sburns



#include "headers.hxx"
#include "DnsOnNetPage.hpp"
#include "resource.h"
#include "state.hpp"



DnsOnNetPage::DnsOnNetPage()
   :
   DCPromoWizardPage(
      IDD_DNS_ON_NET,
      IDS_DNS_ON_NET_PAGE_TITLE,
      IDS_DNS_ON_NET_PAGE_SUBTITLE)
{
   LOG_CTOR(DnsOnNetPage);
}



DnsOnNetPage::~DnsOnNetPage()
{
   LOG_DTOR(DnsOnNetPage);
}



void
DnsOnNetPage::OnInit()
{
   LOG_FUNCTION(DnsOnNetPage::OnInit);

   if (State::GetInstance().UsingAnswerFile())
   {
      String option =
         State::GetInstance().GetAnswerFileOption(
            AnswerFile::OPTION_DNS_ON_NET);
      if (option.icompare(AnswerFile::VALUE_NO) == 0)
      {
         Win::CheckDlgButton(hwnd, IDC_DNS_NOT_ON_NET, BST_CHECKED);
         return;
      }
   }

   // it's important that this be the default in case the page is skipped.
   Win::CheckDlgButton(hwnd, IDC_CONFIG_CLIENT, BST_CHECKED);
}



bool
DnsOnNetPage::OnSetActive()
{
   LOG_FUNCTION(DnsOnNetPage::OnSetActive);

   // put up a wait cursor, as DNS detection may take a teeny bit of time

   Win::CursorSetting cursor(IDC_WAIT);

   State& state = State::GetInstance();
   if (Dns::IsClientConfigured() || state.RunHiddenUnattended())
   {
      Wizard& wiz = GetWizard();

      // skip this page
      if (wiz.IsBacktracking())
      {
         // backtrack once more
         wiz.Backtrack(hwnd);
         return true;
      }

      int nextPage = DnsOnNetPage::Validate();
      if (nextPage != -1)
      {
         wiz.SetNextPageID(hwnd, nextPage);
         return true;
      }

      state.ClearHiddenWhileUnattended();
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}



int
DnsOnNetPage::Validate() 
{
   LOG_FUNCTION(DnsOnNetPage::Validate);

   bool dnsOnNet = !Win::IsDlgButtonChecked(hwnd, IDC_DNS_NOT_ON_NET);
   State& state = State::GetInstance();

   state.SetDNSOnNetwork(dnsOnNet);
   
   return dnsOnNet ? IDD_CONFIG_DNS_CLIENT : IDD_NEW_FOREST;
}



bool
DnsOnNetPage::OnWizBack()
{
   LOG_FUNCTION(DnsOnNetPage::OnWizBack);

   // make sure we clear the dns on net flag => the only way it gets cleared
   // it on the 'next' button.

   State::GetInstance().SetDNSOnNetwork(true);

   return DCPromoWizardPage::OnWizBack();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\dcpromo.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// domain controller promotion wizard, Mark II
//
// 12-12-97 sburns



#include "headers.hxx"
#include "common.hpp"
#include "adpass.hpp"
#include "ApplicationPartitionPage.hpp"
#include "ApplicationPartitionConfirmationPage.hpp"
#include "BadComputerNameDialog.hpp"
#include "CheckDomainUpgradedPage.hpp"
#include "CheckPortAvailability.hpp"
#include "ChildPage.hpp"
#include "CredentialsPage.hpp"
#include "ConfirmationPage.hpp"
#include "DemotePage.hpp"
#include "DynamicDnsPage.hpp"
#include "ConfigureDnsClientPage.hpp"
#include "DnsOnNetPage.hpp"
#include "FailurePage.hpp"
#include "finish.hpp"
#include "ForcedDemotionPage.hpp"
#include "ForestPage.hpp"
#include "ForestVersionPage.hpp"
#include "GcConfirmationPage.hpp"
#include "NetbiosNamePage.hpp"
#include "NewDomainPage.hpp"
#include "NewSitePage.hpp"
#include "NonDomainNc.hpp"
#include "NonRfcComputerNameDialog.hpp"
#include "PathsPage.hpp"
#include "Paths2Page.hpp"
#include "PickSitePage.hpp"
#include "rasfixup.hpp"
// #include "ReadmePage.hpp"
#include "RebootDialog.hpp"
#include "ReplicaOrNewDomainPage.hpp"
#include "ReplicateFromMediaPage.hpp"
#include "ReplicaPage.hpp"
#include "ReplicaOrMemberPage.hpp"
#include "resource.h"
#include "safemode.hpp"
#include "SecureCommWarningPage.hpp"
#include "state.hpp"
#include "InstallTcpIpPage.hpp"
#include "TreePage.hpp"
#include "WelcomePage.hpp"
#include <ntverp.h>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;   // no context help available



// don't change this: it is also the name of a mutex that the net id ui
// uses to determine if dcpromo is running.

const wchar_t* RUNTIME_NAME = L"dcpromoui";

DWORD DEFAULT_LOGGING_OPTIONS =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_HEADER;


// a system modal popup thingy
Popup popup(IDS_WIZARD_TITLE, true);

// this is the mutex that indicates the dcpromo is running.

HANDLE dcpromoRunningMutex = INVALID_HANDLE_VALUE;



// these are the valid exit codes returned from the dcpromo.exe process

enum ExitCode
{
   // the operation failed.

   EXIT_CODE_UNSUCCESSFUL = 0,

   // the operation succeeded

   EXIT_CODE_SUCCESSFUL = 1,

   // the operation succeeded, and the user opted not to have the wizard
   // restart the machine, either manually or by specifying
   // RebootOnSuccess=NoAndNoPromptEither in the answerfile

   EXIT_CODE_SUCCESSFUL_NO_REBOOT = 2,

   // the operation failed, but the machine needs to be rebooted anyway

   EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT = 3
};



// Checks the platform and os version number.  Returns the resource ID of the
// string to present to the user if platform/os ver requirements are not met,
// or 0 if they are met.

unsigned
CheckPlatform()
{
   LOG_FUNCTION(CheckPlatform);

   unsigned retval = 0;

   Computer::Role role = State::GetInstance().GetComputer().GetRole();
   switch (role)
   {
      case Computer::STANDALONE_WORKSTATION:
      case Computer::MEMBER_WORKSTATION:
      {
         retval = IDS_WORKSTATION_NOT_SUPPORTED;
         break;
      }
      case Computer::STANDALONE_SERVER:
      case Computer::MEMBER_SERVER:
      case Computer::PRIMARY_CONTROLLER:
      case Computer::BACKUP_CONTROLLER:
      {
         // check OS version

         OSVERSIONINFOEX info;
         HRESULT hr = Win::GetVersionEx(info);
         BREAK_ON_FAILED_HRESULT(hr);

         if (
            
            // require the same version for which we were built.
            // NTRAID#NTBUG9-591686-2002/04/12-sburns
            
               info.dwPlatformId != VER_PLATFORM_WIN32_NT
            || !(    info.dwMajorVersion == VER_PRODUCTMAJORVERSION
                  && info.dwMinorVersion == VER_PRODUCTMINORVERSION))
         {
            retval = IDS_NT51_REQUIRED;
            break;   
         }

         if (
               // if a web blade ...
               
               info.wSuiteMask & VER_SUITE_BLADE

               // or, an appliance ...
               
            || (info.wSuiteMask & VER_SUITE_EMBEDDED_RESTRICTED

               // that is not advanced or data center server ... 
               
               && !(info.wSuiteMask & (VER_SUITE_ENTERPRISE | VER_SUITE_DATACENTER)) ) )
         {
            // .. then don't allow promotion.
            
            // NTRAID#NTBUG9-195265-2001/04/03-sburns
            // NTRAID#NTBUG9-590937-2002/04/15-sburns
            
            retval = IDS_WEB_BLADE_NOT_SUPPORTED;
            break;
         }

         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return retval;
}



// Checks the role change state of the machine.  Returns the resource ID of
// the string to present to the user if the state is such that another role
// change cannot be attempted, or 0 if a role change attempt may proceed.

unsigned
CheckRoleChangeState()
{
   LOG_FUNCTION(CheckRoleChangeState);

   unsigned retval = 0;

   // check to see if a role change has taken place, or is in progress.

   DSROLE_OPERATION_STATE_INFO* info = 0;
   HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
   if (SUCCEEDED(hr) && info)
   {
      switch (info->OperationState)
      {
         case DsRoleOperationIdle:
         {
            // do nothing
            break;
         }
         case DsRoleOperationActive:
         {
            // a role change operation is underway
            retval = IDS_ROLE_CHANGE_IN_PROGRESS;
            break;
         }
         case DsRoleOperationNeedReboot:
         {
            // a role change has already taken place, need to reboot before
            // attempting another.
            retval = IDS_ROLE_CHANGE_NEEDS_REBOOT;
            break;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }

      ::DsRoleFreeMemory(info);
   }

   return retval;
}



// Checks for the presence of at least 1 logical drive formatted with NTFS5.
// Returns the resource ID of the string to present to the user if no such
// drive is found (which implies that the user will not be able to pick a
// sysvol path that is formatted w/ NTFS5, which implies that proceeding would
// be a waste of time.

unsigned
CheckForNtfs5()
{
   LOG_FUNCTION(CheckForNtfs5);

   if (GetFirstNtfs5HardDrive().empty())
   {
      return IDS_NO_NTFS5_DRIVES;
   }

   return 0;
}



// Checks if the machine is running in safeboot mode.  You can't run dcpromo
// while in safeboot mode.

unsigned
CheckSafeBootMode()
{
   LOG_FUNCTION(CheckSafeBootMode);

   static const String
      SAFEBOOT_KEY(L"System\\CurrentControlSet\\Control\\Safeboot\\Option");

   do
   {
      RegistryKey key;

      HRESULT hr = key.Open(HKEY_LOCAL_MACHINE, SAFEBOOT_KEY);
      BREAK_ON_FAILED_HRESULT(hr);

      DWORD mode = 0;
      hr = key.GetValue(L"OptionValue", mode);

      if (mode)
      {
         return IDS_SAFEBOOT_MODE;
      }
   }
   while (0);

   return 0;
}



unsigned
CheckCertService()
{
   LOG_FUNCTION(CheckCertService);

   // If not a downlevel DC upgrade, then refuse to run until cert service
   // is removed.  356399
   
   State::RunContext context = State::GetInstance().GetRunContext();
   if (context != State::BDC_UPGRADE && context != State::PDC_UPGRADE)
   {
      if (NTService(L"CertSvc").IsInstalled())
      {
         return IDS_CERT_SERVICE_IS_INSTALLED;
      }
   }

   return 0;
}



unsigned
CheckWindirSpace()
{
   LOG_FUNCTION(CheckWindirSpace);

   // if you change this, change the error message resource too.

   static const unsigned WINDIR_MIN_SPACE_MB = 20;

   String windir = Win::GetSystemWindowsDirectory();

   if (!CheckDiskSpace(windir, 20))
   {
      return IDS_WINDIR_LOW_SPACE;
   }

   return 0;
}



// NTRAID#NTBUG9-199759-2000/10/27-sburns

unsigned
CheckComputerWasRenamedAndNeedsReboot()
{
   LOG_FUNCTION(CheckComputerWasRenamedAndNeedsReboot);

   if (ComputerWasRenamedAndNeedsReboot())
   {
      return IDS_NAME_CHANGE_NEEDS_REBOOT;
   }

   return 0;
}



// Start the Network Identification UI (aka Computer Name UI).  After calling
// this function, the app must not initiate a role change.  It should
// terminate.

void
LaunchNetId()
{
   LOG_FUNCTION(LaunchNetId);
   ASSERT(dcpromoRunningMutex != INVALID_HANDLE_VALUE);

   // net id ui attempts acquisition of our mutex to determine if we are
   // running.  So, before starting the net id ui, we need to close the
   // mutex.  Otherwise, we would create a race condition between the start of
   // the net id ui and the closure of this app.  (And yes, cynical reader, I
   // did think of that before actually encountering a problem.)

   do
   {
      Win::CloseHandle(dcpromoRunningMutex);

      // It would be extraordinarily unlikely, but in case the mutex close
      // fails, we're gonna start the net id ui anyway and risk the race
      // condition.

      String sys32Folder = Win::GetSystemDirectory();

      PROCESS_INFORMATION procInfo;

      // REVIEWED-2002/02/25-sburns correct byte count passed
      
      ::ZeroMemory(&procInfo, sizeof procInfo);

      STARTUPINFO startup;

      // REVIEWED-2002/02/25-sburns correct byte count passed
      
      ::ZeroMemory(&startup, sizeof startup);

      LOG(L"Calling CreateProcess");

      String commandLine(L"shell32.dll,Control_RunDLL sysdm.cpl,,1");
      
      // REVIEWED-2002/02/26-sburns wrapper requires full path to app

      HRESULT hr =
         Win::CreateProcess(
            sys32Folder + L"\\rundll32.exe",
            commandLine,
            0,
            String(),
            startup,
            procInfo);
      BREAK_ON_FAILED_HRESULT(hr);

      Win::CloseHandle(procInfo.hThread);
      Win::CloseHandle(procInfo.hProcess);
   }
   while (0);
}
   


// Return false if the local machine's dns hostname is bad, also pop up an
// error dialog.  Return true if the name is OK.  A bad name is one we believe
// will have problems being registered in DNS after a promotion.  The user
// must fix a bad name before proceeding.

bool
IsComputerNameOk()
{
   LOG_FUNCTION(IsComputerNameOk);

   bool result = true;

   do
   {
      State& state = State::GetInstance();
      State::RunContext context = state.GetRunContext();
      if (
            context == State::BDC_UPGRADE
         || context == State::PDC_UPGRADE
         || context == State::NT5_DC
         || !IsTcpIpInstalled() )
      {
         // If the machine is already a DC, then we don't worry about the name.
         // 
         // If the machine is a downlevel DC undergoing upgrade, then the name
         // can't be changed until dcpromo is complete.  So, we say nothing now,
         // but remind the user to rename the machine in the Finish Page.
         //
         // If TCP/IP is not installed, then the machine has no hostname
         // to check.  In this case, we will check for that with the
         // InstallTcpIpPage

         ASSERT(result == true);
        
         break;
      }

      // Then check the computer name to ensure that it can be registered in
      // DNS.

      String hostname =
         Win::GetComputerNameEx(::ComputerNamePhysicalDnsHostname);

      DNS_STATUS status =
         MyDnsValidateName(hostname, ::DnsNameHostnameLabel);

      switch (status)
      {
         case DNS_ERROR_NON_RFC_NAME:
         {
            // Don't pester the user if we're running unattended
            // NTRAID#NTBUG9-538475-2002/04/19-sburns

            if (state.RunHiddenUnattended())
            {
               LOG(L"skipping non-RFC computer name warning");
               
               // continue on with the non-rfc name

               ASSERT(result == true);
               break;
            }
         
            INT_PTR dlgResult = 
               NonRfcComputerNameDialog(hostname).ModalExecute(0);

            switch (dlgResult)
            {
               case NonRfcComputerNameDialog::CONTINUE:
               {
                  // continue on with the non-rfc name

                  ASSERT(result == true);
                     
                  break;
               }
               default:
               {
                  // close the wizard and rename.

                  result = false;

                  // after calling this, we must not allow any promote
                  // operation.  We will fall out of this function, then
                  // end the app.

                  LaunchNetId();
                  break;
               }
            }

            break;
         }
         case DNS_ERROR_NUMERIC_NAME:
         {
            result = false;

            String message =
               String::format(
                  IDS_COMPUTER_NAME_IS_NUMERIC,
                  hostname.c_str());

            BadComputerNameDialog(message).ModalExecute(0);

            break;
         }
         case DNS_ERROR_INVALID_NAME_CHAR:
         case ERROR_INVALID_NAME:
         {
            result = false;

            String message =
               String::format(
                  IDS_COMPUTER_NAME_HAS_BAD_CHARS,
                  hostname.c_str());

            BadComputerNameDialog(message).ModalExecute(0);
            
            break;
         }
         case ERROR_SUCCESS:
         default:
         {
               
            break;
         }
      }
   }
   while (0);

   LOG(result ? L"true" : L"false");

   return result;
}
      


// Reboots the machine with the special dcpromo reason codes
// NTRAID#NTBUG9-689581-2002/08/19-sburns

HRESULT
DcpromoReboot()
{
   LOG_FUNCTION(DcpromoReboot);

   HRESULT hr = S_OK;

   AutoTokenPrivileges privs(SE_SHUTDOWN_NAME);
   hr = privs.Enable();

   DWORD minorReason = SHTDN_REASON_MINOR_DC_PROMOTION;
   switch (State::GetInstance().GetOperation())
   {
      case State::REPLICA:
      case State::FOREST:
      case State::TREE:
      case State::CHILD:
      {
         // do nothing
         
         break;
      }
      case State::DEMOTE:
      case State::ABORT_BDC_UPGRADE:
      {
         // we treat abort bdc upgrade as a demotion because it is one,
         // in the sense that the machine was once a DC and now it is not.
         
         minorReason = SHTDN_REASON_MINOR_DC_DEMOTION;
         break;
      }
      case State::NONE:
      default:
      {
         // we're insane.
         
         ASSERT(false);
         LOG(L"unknown operation!");
         return E_UNEXPECTED;
      }
   }

   BOOL succeeded =
      ::InitiateSystemShutdownEx(
         0,
         const_cast<PWSTR>(String::load(IDS_REBOOT_MESSAGE).c_str()),

         // zero timeout -- BAM! you're dead! -- this to avoid a winlogon
         // race condition.
         // NTRAID#NTBUG9-727439-2002/10/24-sburns
         0, // 15,
         
         FALSE,
         TRUE,
            SHTDN_REASON_FLAG_PLANNED
         |  SHTDN_REASON_MAJOR_OPERATINGSYSTEM
         |  minorReason);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   LOG_HRESULT(hr);

   if (FAILED(hr))
   {
      popup.Error(
         Win::GetDesktopWindow(),
         hr,
         IDS_CANT_REBOOT);
   }
   
   return hr;
}



// NTRAID#NTBUG9-346120-2001/04/04-sburns

ExitCode
HandleRebootCases()
{
   LOG_FUNCTION(HandleRebootCases);
   
   // There are two possible reasons for needing to reboot the machine:
   // the operation was successful, or the operation failed, but in the
   // attempt the machine's joined state changed.

   State& state = State::GetInstance();

   ExitCode exitCode =
         (state.GetOperationResultsCode() == State::SUCCESS)
      ?  EXIT_CODE_SUCCESSFUL
      :  EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT;

   switch (exitCode)
   {
      case EXIT_CODE_SUCCESSFUL:
      {
         if (state.RunHiddenUnattended())
         {
            String option =
               state.GetAnswerFileOption(AnswerFile::OPTION_REBOOT);
            if (option.icompare(AnswerFile::VALUE_YES) == 0)
            {
               ASSERT(exitCode == EXIT_CODE_SUCCESSFUL);
               HRESULT hr = DcpromoReboot();
               if (FAILED(hr))
               {
                  exitCode = EXIT_CODE_SUCCESSFUL_NO_REBOOT;
               }
                  
               break;
            }
            else if (option.icompare(AnswerFile::VALUE_NO_DONT_PROMPT) == 0)
            {
               // user opted not to reboot the machine via answerfile
         
               LOG(L"Not rebooting, and not prompting either");

               exitCode = EXIT_CODE_SUCCESSFUL_NO_REBOOT;   
               break;
            }
         }

         RebootDialog dlg(false);
         if (dlg.ModalExecute(0))
         {
            // user opted to reboot the machine
      
            HRESULT hr = DcpromoReboot();
            if (FAILED(hr))
            {
               exitCode = EXIT_CODE_SUCCESSFUL_NO_REBOOT;
            }
         }
         else
         {
            // user opted not to reboot the machine
      
            exitCode = EXIT_CODE_SUCCESSFUL_NO_REBOOT;
         }
         break;
      }
      case EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT:
      {
         // If the operation failed, then the wizard has gone into interactive
         // mode.
         
         RebootDialog dlg(true);
         if (dlg.ModalExecute(0))
         {
            // user opted to reboot the machine
        
            exitCode = EXIT_CODE_UNSUCCESSFUL;
            HRESULT hr = DcpromoReboot();
            if (FAILED(hr))
            {
               exitCode = EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT;
            }
         }
         else
         {
            // user opted not to reboot the machine
      
            ASSERT(exitCode == EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT);
         }
         
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return exitCode;
}



ExitCode
RunWizard()
{
   LOG_FUNCTION(RunWizard);

   Wizard wiz(
      IDS_WIZARD_TITLE,
      IDB_BANNER16,
      IDB_BANNER256,
      IDB_WATERMARK16,
      IDB_WATERMARK256);

   // Welcome must be first
   
   wiz.AddPage(new WelcomePage());

   // These are not in any particular order...
   // CODEWORK: Someday it might be useful to split this into two separate
   // sets of pages for promote and demote.

   wiz.AddPage(new AdminPasswordPage());
   wiz.AddPage(new ApplicationPartitionPage());
   wiz.AddPage(new ApplicationPartitionConfirmationPage());
   wiz.AddPage(new CheckDomainUpgradedPage());
   wiz.AddPage(new ChildPage());
   wiz.AddPage(new ConfigureDnsClientPage());
   wiz.AddPage(new ConfirmationPage());
   wiz.AddPage(new CredentialsPage());
   wiz.AddPage(new DemotePage());
   wiz.AddPage(new DnsOnNetPage());
   wiz.AddPage(new DynamicDnsPage());
   wiz.AddPage(new FailurePage());
   wiz.AddPage(new FinishPage());
   wiz.AddPage(new ForcedDemotionPage());
   wiz.AddPage(new ForestPage());
   wiz.AddPage(new ForestVersionPage());
   wiz.AddPage(new GcConfirmationPage());
   wiz.AddPage(new InstallTcpIpPage());
   wiz.AddPage(new NetbiosNamePage());
   wiz.AddPage(new NewDomainPage());
   wiz.AddPage(new NewSitePage());
   wiz.AddPage(new Paths2Page());
   wiz.AddPage(new PathsPage());
   wiz.AddPage(new PickSitePage());
   wiz.AddPage(new RASFixupPage());
   // wiz.AddPage(new ReadmePage());
   wiz.AddPage(new ReplicaOrMemberPage());
   wiz.AddPage(new ReplicaOrNewDomainPage());
   wiz.AddPage(new ReplicaPage());
   wiz.AddPage(new ReplicateFromMediaPage());
   wiz.AddPage(new SafeModePasswordPage());
   wiz.AddPage(new SecureCommWarningPage());
   wiz.AddPage(new TreePage());

   ExitCode exitCode = EXIT_CODE_UNSUCCESSFUL;

   switch (wiz.ModalExecute(Win::GetDesktopWindow()))
   {
      case -1:
      {
         popup.Error(
            Win::GetDesktopWindow(),
            E_FAIL,
            IDS_PROP_SHEET_FAILED);
         break;
      }
      case ID_PSREBOOTSYSTEM:
      {
         exitCode = HandleRebootCases();
         break;
      }
      default:
      {
         // do nothing.
         break;
      }
   }

   return exitCode;
}



// NTRAID#NTBUG9-350777-2001/04/24-sburns

bool
ShouldCancelBecauseMachineIsAppServer()
{
   LOG_FUNCTION(ShouldCancelBecauseMachineIsAppServer);

   bool result = false;
   
   do
   {
      State& state = State::GetInstance();
      State::RunContext context = state.GetRunContext();
      if (context == State::NT5_DC)
      {
         // already a DC: nothing to gripe about.
         
         break;
      }
      
      OSVERSIONINFOEX info;
      HRESULT hr = Win::GetVersionEx(info);
      BREAK_ON_FAILED_HRESULT(hr);

      // you're running app server if you're running terminal server and
      // not single user terminal server.
      
      bool isAppServer =
            (info.wSuiteMask & VER_SUITE_TERMINAL)
         && !(info.wSuiteMask & VER_SUITE_SINGLEUSERTS);

      if (isAppServer)
      {
         // warn the user that promotion will whack the ts policy settings

         LOG(L"machine has app server installed");

         if (!state.RunHiddenUnattended())
         {
            if (
               popup.MessageBox(
                  Win::GetDesktopWindow(),
                  IDS_APP_SERVER_WARNING,
                  MB_OKCANCEL) == IDCANCEL)
            {
               // user wishes to bail out.
            
               result = true;
               break;
            }
         }
      }
   }
   while (0);

   LOG_BOOL(result);

   return result;
}              

   

ExitCode
Start()
{
   LOG_FUNCTION(Start);

   ExitCode exitCode = EXIT_CODE_UNSUCCESSFUL;
   unsigned id = 0;
   do
   {
      // do the admin check first of all, cause others may fail for non-admin
      // 292749

      id = IsCurrentUserAdministrator() ? 0 : IDS_NOT_ADMIN;
      if (id)
      {
         break;
      }

      // If cert service is installed, we will probably break it on promote
      // or demote.
      // 324653

      id = CheckCertService();
      if (id)
      {
         break;
      }

      id = CheckSafeBootMode();
      if (id)
      {
         break;
      }

      // do the role change check before the platform check, as the platform
      // check may be unreliable after a demote.

      id = CheckRoleChangeState();
      if (id)
      {
         break;
      }

      id = CheckPlatform();
      if (id)
      {
         break;
      }

      id = CheckForNtfs5();
      if (id)
      {
         break;
      }

      id = CheckWindirSpace();
      if (id)
      {
         break;
      }

      id = CheckComputerWasRenamedAndNeedsReboot();
      if (id)
      {
         break;
      }
   }
   while(0);

   do
   {
      if (id)
      {
         popup.Error(
            Win::GetDesktopWindow(),
            String::load(id));
         break;
      }

      if (!IsComputerNameOk())
      {
         break;
      }

      if (ShouldCancelBecauseMachineIsAppServer())
      {
         break;
      }
      
      // NTRAID#NTBUG9-129955-2000/11/02-sburns left commented out until
      // PM decides what the real fix to this bug is.
      
      // if (!AreRequiredPortsAvailable())
      // {
      //    break;
      // }

      exitCode = RunWizard();
   }
   while (0);

   LOG(String::format(L"exitCode = %1!d!", static_cast<int>(exitCode)));
   
   return exitCode;
}



void
ShowCommandLineHelp()
{
   // CODEWORK: replace this with WinHelp, someday

   popup.MessageBox(Win::GetDesktopWindow(), IDS_COMMAND_LINE_HELP, MB_OK);
}



int WINAPI
WinMain(
   HINSTANCE   hInstance,
   HINSTANCE   /* hPrevInstance */ ,
   PSTR        /* lpszCmdLine */ ,
   int         /* nCmdShow */)
{
   hResourceModuleHandle = hInstance;

   ExitCode exitCode = EXIT_CODE_UNSUCCESSFUL;

   try
   {
      HRESULT hr =

         // ISSUE-2002/02/25-sburns This is a global named object. See
         // NTRAID#NTBUG9-525195-2002/02/25-sburns
         
         Win::CreateMutex(
            0,
            true,

            // The mutex name has the "Global" prefix so ts users will see it.
            // NTRAID#NTBUG9-404808-2001/05/29-sburns

            // If you ever change this, change IsDcpromoRunning in
            // burnslib\src\dsutil.cpp too.
            // NTRAID#NTBUG9-498351-2001/11/21-sburns

            String(L"Global\\") + RUNTIME_NAME,
            dcpromoRunningMutex);
      if (hr == Win32ToHresult(ERROR_ALREADY_EXISTS))
      {
         // Close the mutex so that the truly clueless admin won't get confused
         // that the popup we're about to raise should be closed before he tries
         // to launch the wizard again.  Sheesh!
         // NTRAID#NTBUG9-404808-2001/05/29-sburns (bis)

         Win::CloseHandle(dcpromoRunningMutex);
         popup.Error(Win::GetDesktopWindow(), IDS_ALREADY_RUNNING);
      }
      else
      {
         AutoCoInitialize coInit;
         hr = coInit.Result();
         ASSERT(SUCCEEDED(hr));

         // change structure instance name so as not to accidentally offend
         // the sensibilities of the delicate reader.
         // NTRAID#NTBUG9-382719-2001/05/01-sburns
      
         INITCOMMONCONTROLSEX init_structure_not_to_contain_a_naughty_word;
         init_structure_not_to_contain_a_naughty_word.dwSize =
            sizeof(init_structure_not_to_contain_a_naughty_word);      
         init_structure_not_to_contain_a_naughty_word.dwICC  =
            ICC_ANIMATE_CLASS | ICC_USEREX_CLASSES;

         BOOL init =
            ::InitCommonControlsEx(&init_structure_not_to_contain_a_naughty_word);
         ASSERT(init);
         
         State::Init();

         if (State::GetInstance().NeedsCommandLineHelp())
         {
            ShowCommandLineHelp();
         }
         else
         {
            exitCode = Start();
         }

         State::Destroy();
      }
   }
   catch (Error& err)
   {
      popup.Error(Win::GetDesktopWindow(), err.GetMessage());
   }
   catch (...)
   {
      LOG(L"unhandled exception caught");

      popup.Error(Win::GetDesktopWindow(), IDS_UNHANDLED_EXCEPTION);
   }

   return static_cast<int>(exitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\dnsonnetpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// test DNS configured page
//
// 12-18-97 sburns



#ifndef DNSNET_HPP_INCLUDED
#define DNSNET_HPP_INCLUDED



#include "page.hpp"



class DnsOnNetPage : public DCPromoWizardPage
{
   public:

   DnsOnNetPage();

   protected:

   virtual ~DnsOnNetPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // WizardPage overrides

   virtual
   bool
   OnWizBack();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   DnsOnNetPage(const DnsOnNetPage&);
   const DnsOnNetPage& operator=(const DnsOnNetPage&);
};



#endif   // DNSNET_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\demotepage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// demote page
//
// 1-20-98 sburns



#include "headers.hxx"
#include "page.hpp"
#include "DemotePage.hpp"
#include "resource.h"
#include "state.hpp"
#include "ds.hpp"
#include "common.hpp"



DemotePage::DemotePage()
   :
   DCPromoWizardPage(
      IDD_DEMOTE,
      IDS_DEMOTE_PAGE_TITLE,
      IDS_DEMOTE_PAGE_SUBTITLE),
   bulletFont(0)
{
   LOG_CTOR(DemotePage);
}



DemotePage::~DemotePage()
{
   LOG_DTOR(DemotePage);

   HRESULT hr = S_OK;

   if (bulletFont)
   {
      hr = Win::DeleteObject(bulletFont);

      ASSERT(SUCCEEDED(hr));
   }
}



void
DemotePage::SetBulletFont()
{
   LOG_FUNCTION(DemotePage::SetBulletFont);

   HRESULT hr = S_OK;
   do
   {
      NONCLIENTMETRICS ncm;

      // REVIEWED-2002/02/25-sburns byte count correctly passed.
      
      ::ZeroMemory(&ncm, sizeof ncm);
      
      ncm.cbSize = sizeof ncm;

      // ISSUE-2002/02/27-sburns Seems to me that the second param here needs
      // to be sizeof ncm
      
      hr = Win::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
      BREAK_ON_FAILED_HRESULT(hr);

      LOGFONT logFont = ncm.lfMessageFont;

      logFont.lfWeight = FW_BOLD;

      String fontName = String::load(IDS_BULLET_FONT_NAME);

      // ensure null termination

      // according to the docs for LOGFONT, the face size is limited to
      // 32 characters.
      
      ASSERT(LF_FACESIZE <= 32);

      // REVIEWED-2002/02/25-sburns byte count correctly passed.
      
      ::ZeroMemory(logFont.lfFaceName, LF_FACESIZE * sizeof WCHAR);
      
      size_t fnLen = fontName.length();

      // REVIEWED-2002/02/25-sburns character count correctly passed.

      fontName.copy(
         logFont.lfFaceName,

         // don't copy over the last null

         min(LF_FACESIZE - 1, fnLen));
    
      hr = Win::CreateFontIndirect(logFont, bulletFont);
      BREAK_ON_FAILED_HRESULT(hr);

      SetControlFont(hwnd, IDC_BULLET1, bulletFont);
      SetControlFont(hwnd, IDC_BULLET2, bulletFont);
   }
   while (0);
}



void
DemotePage::OnInit()
{
   LOG_FUNCTION(DemotePage::OnInit);

   // 361172
   //
   // CODEWORK: the bullets aren't very impressive.  I'm told an icon is
   // a better way to do this

   SetBulletFont();

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(AnswerFile::OPTION_IS_LAST_DC);
      if (option.icompare(AnswerFile::VALUE_YES) == 0)
      {
         Win::CheckDlgButton(hwnd, IDC_LAST, BST_CHECKED);
         return;
      }
   }
   else
   {
      // determine if this machine is a GC, if so pop up a warning message

      if (state.IsGlobalCatalog())
      {
         popup.Info(GetHWND(), IDS_DEMOTE_GC_WARNING);
      }
   }

   // you may ask yourself: "Why not set the state of the checkbox based
   // on the result of IsReallyLastDcInDomain?"  Because demoting the
   // last DC deletes the domain, too.  We want the user to be very
   // deliberate when checking that checkbox.
}



bool
DemotePage::OnSetActive()
{
   LOG_FUNCTION(DemotePage::OnSetActive);

   State& state = State::GetInstance();
   
   if (state.RunHiddenUnattended())
   {
      int nextPage = DemotePage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



bool
OtherDcFound(const String& domainName)
{
   LOG_FUNCTION2(OtherDcFound, domainName);
   ASSERT(!domainName.empty());

   bool result = false;
   HRESULT hr = S_OK;

   do
   {
      DOMAIN_CONTROLLER_INFO* info = 0;
      hr =
         MyDsGetDcName(
            0,
            domainName,  
               DS_FORCE_REDISCOVERY
            |  DS_AVOID_SELF
            |  DS_DIRECTORY_SERVICE_REQUIRED,
            info);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(info->DomainControllerName);

      ::NetApiBufferFree(info);

      result = true;
   }
   while (0);

   LOG_HRESULT(hr);
   LOG(result ? L"true" : L"false");

   return result;
}



int
DemotePage::Validate()
{
   LOG_FUNCTION(DemotePage::Validate);

   State& state = State::GetInstance();
   ASSERT(state.GetOperation() == State::DEMOTE);

   bool isLast = Win::IsDlgButtonChecked(hwnd, IDC_LAST);

   if (isLast)
   {
      if (!state.IsReallyLastDcInDomain())
      {
         // user checked the box, but we found other dc objects in the DS.
         // verify that the user really meant to check the checkbox.

         if (
            popup.MessageBox(
               hwnd,
               String::format(
                  IDS_VERIFY_LAST_DC,
                  state.GetComputer().GetDomainDnsName().c_str()),
               MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2) != IDYES)
         {
            state.SetIsLastDCInDomain(false);
            return -1;
         }
      }
   }
   else
   {
      // the user unchecked the box, check for other DCs for that domain

      Win::WaitCursor cursor;

      if (!OtherDcFound(state.GetComputer().GetDomainDnsName()))
      {
         if (
            popup.MessageBox(
               hwnd,
               String::format(
                  IDS_VERIFY_NOT_LAST_DC,
                  state.GetComputer().GetDomainDnsName().c_str()),
               MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2) != IDYES)
         {
            // user clicked no or cancel

            state.SetIsLastDCInDomain(false);
            return -1;
         }

         // The user clicked "yes, proceed even if I lose changes"

         // CODEWORK: set flag to allow demote and abandon local changes
         // here... (currently that's provided as the /forceremoval option,
         // which we're not currently thinking should be broadly advertised
         // yet.

      }
   }

   state.SetIsLastDCInDomain(isLast);

   return IDD_APP_PARTITION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\dnssetup.hpp ===
// Copyright (C) 1998 Microsoft Corporation
//
// DNS installation and configuration code 
//
// 6-16-98 sburns



#ifndef DNSSETUP_HPP_INCLUDED
#define DNSSETUP_HPP_INCLUDED



// Installs and configures the DNS service on the machine. Returns true if
// successful, false if not.  Only valid in new forest, new tree, or new
// child (i.e. first dc in new domain) scenarios.
// 
// progressDialog - in, reference to the ProgressDialog to which status
// message updates will be posted.
// 
// domainDNSName - in, the DNS name of domain being installed.
// 
// isFirstDcInForest - in, true if the scenario is first dc in a new forest,
// false otherwise.

bool
InstallAndConfigureDns(
   ProgressDialog&   progressDialog,
   const String&     domainDNSName,
   bool              isFirstDcInForest);



#endif   // DNSSETUP_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\ds.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// DS API wrappers
//
// 12-16-97 sburns



#include "headers.hxx"
#include "ds.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"
#include "ProgressDialog.hpp"



// CODEWORK: remove the exception throwing architecture.



DS::Error::Error(HRESULT hr_, int summaryResID)
   :
   Win::Error(hr_, summaryResID)
{
}



DS::Error::Error(HRESULT hr_, const String& msg, const String& sum)
   :
   Win::Error(hr_, msg, sum)
{
}



bool
DS::IsDomainNameInUse(const String& domainName)
{
   LOG_FUNCTION(DS::IsDomainNameInUse);
   ASSERT(!domainName.empty());

   bool result = false;
   if (!domainName.empty())
   {
      HRESULT hr = MyNetValidateName(domainName, ::NetSetupNonExistentDomain);
      if (hr == Win32ToHresult(ERROR_DUP_NAME))
      {
         result = true;
      }
   }

   LOG(
      String::format(
         L"The domain name %1 %2 in use.",
         domainName.c_str(),
         result ? L"is" : L"is NOT"));

   return result;
}



bool
DS::DisjoinDomain()
throw (DS::Error)
{
   LOG_FUNCTION(DS::DisjoinDomain);

   // make 1st attempt assuming that the current user has account
   // deletion priv on the domain.

   LOG(L"Calling NetUnjoinDomain (w/ account delete)");

   HRESULT hr =
      Win32ToHresult(
         ::NetUnjoinDomain(
            0, // this server
            0, // current account,
            0, // current password
            NETSETUP_ACCT_DELETE));

   LOG_HRESULT(hr);

   if (FAILED(hr))
   {
      // make another attempt, not removing the computer account

      LOG(L"Calling NetUnjoinDomain again, w/o account delete");

      hr = Win32ToHresult(::NetUnjoinDomain(0, 0, 0, 0));

      LOG_HRESULT(hr);

      if (SUCCEEDED(hr))
      {
         // the unjoin was successful, but the computer account was
         // left behind.

         return false;
      }
   }

   if (FAILED(hr))
   {
      throw DS::Error(hr, IDS_DISJOIN_DOMAIN_FAILED);
   }

   return true;
}



void
DS::JoinDomain(
   const String&           domainDNSName, 
   const String&           dcName,        
   const String&           userName,      
   const EncryptedString&  password,      
   const String&           userDomainName)
throw (DS::Error)
{
   LOG_FUNCTION(DS::JoinDomain);
   ASSERT(!domainDNSName.empty());
   ASSERT(!userName.empty());

   // password may be empty

   ULONG flags =
         NETSETUP_JOIN_DOMAIN
      |  NETSETUP_ACCT_CREATE
      |  NETSETUP_DOMAIN_JOIN_IF_JOINED
      |  NETSETUP_ACCT_DELETE;

   String massagedUserName = MassageUserName(userDomainName, userName);
   String domain = domainDNSName;

   if (!dcName.empty())
   {
      domain += L"\\" + dcName;
   }

   HRESULT hr =
      MyNetJoinDomain(
         domain.c_str(),
         massagedUserName.c_str(),
         password,
         flags);

   LOG_HRESULT(hr);

   if (FAILED(hr))
   {
      State& state = State::GetInstance();      
      state.SetOperationResultsMessage(
         String::format(IDS_UNABLE_TO_JOIN_DOMAIN, domainDNSName.c_str()));

      throw DS::Error(hr, IDS_JOIN_DOMAIN_FAILED);
   }
}



DWORD
MyDsRoleCancel(DSROLE_SERVEROP_HANDLE& handle)
{
   LOG(L"Calling DsRoleCancel");
   LOG(L"lpServer     : (null)");

   DWORD status = ::DsRoleCancel(0, handle);

   LOG(String::format(L"Error 0x%1!X! (!0 => error)", status));

   return status;
}



DWORD
MyDsRoleGetDcOperationProgress(
   DSROLE_SERVEROP_HANDLE& handle,
   DSROLE_SERVEROP_STATUS*& status)
{
   // LOG(L"Calling DsRoleGetDcOperationProgress");

   status = 0;
   DWORD err = ::DsRoleGetDcOperationProgress(0, handle, &status);

   // LOG(
   //    String::format(
   //       L"Error 0x%1!X! (!0 => error, 0x%2!X! = ERROR_IO_PENDING)",
   //       err,
   //       ERROR_IO_PENDING));

   // if (status)
   // {
   //    LOG(
   //       String::format(
   //          L"OperationStatus : 0x%1!X!",
   //          status->OperationStatus));
   //    LOG(status->CurrentOperationDisplayString);
   // }

   // DWORD err = ERROR_IO_PENDING;
   // status = new DSROLE_SERVEROP_STATUS;
   // status->CurrentOperationDisplayString = L"proceeding";
   // status->OperationStatus = 0;

   return err;
}



void
DoProgressLoop(
   DSROLE_SERVEROP_HANDLE& handle,
   ProgressDialog&         progressDialog)
throw (DS::Error)
{
   LOG_FUNCTION(DoProgressLoop);

   State& state = State::GetInstance();

   if (state.GetOperation() == State::DEMOTE)
   {
      // not cancelable -- turn off the cancel button.

      progressDialog.UpdateButton(String());
   }
   else
   {
      // turn on the cancel button.

      progressDialog.UpdateButton(IDS_PROGRESS_CANCEL);
   }

   DWORD  netErr                     = 0;    
   bool   criticalComplete           = false;
   bool   buttonUpdatedToFinishLater = false;
   String lastMessage;              
   ProgressDialog::WaitCode cancelButton;

   do
   {
      // wait 1500ms or for the user to hit cancel

      cancelButton = progressDialog.WaitForButton(1500);

      // get the current status of the operation

      DSROLE_SERVEROP_STATUS* status = 0;
      netErr = MyDsRoleGetDcOperationProgress(handle, status);

      if (netErr != ERROR_SUCCESS && netErr != ERROR_IO_PENDING)
      {
         // operation complete

         break;
      }

      if (!status)
      {
         LOG(L"Operation status not returned!");
         ASSERT(false);
         continue;
      }

      // update the message display

      String message = status->CurrentOperationDisplayString;
      if (message != lastMessage)
      {
         progressDialog.UpdateText(message);
         lastMessage = message;
      }

      // save the status flags for later use.

      ULONG statusFlags = status->OperationStatus;

      ::DsRoleFreeMemory(status);

      do
      {
         if (cancelButton != ProgressDialog::PRESSED)
         {
            break;
         }

         // if we make it here, user pressed the cancel button

         LOG(L"DoProgressLoop: handling cancel");
         
         ASSERT(state.GetOperation() != State::DEMOTE);

         if (criticalComplete)
         {
            // inform the user that the install is done, and that they're
            // cancelling the non-critical replication.

            popup.Info(
               progressDialog.GetHWND(),
               String::load(IDS_CANCEL_NON_CRITICAL_REPLICATION));

            // this should return ERROR_SUCCESS, and the promotion will
            // be considered complete.

            progressDialog.UpdateText(IDS_CANCELLING_REPLICATION);
            progressDialog.UpdateAnimation(IDR_AVI_DEMOTE);
            netErr = MyDsRoleCancel(handle);

            // fall out of the inner, then the outer, loop.  Then we will
            // get the operation results, which should indicate that the
            // promotion is complete, and non-critical replication was
            // canceled.

            break;
         }

         // Still doing promote, verify that the user really wants to roll
         // back to server state.

         if (
            popup.MessageBox(
               progressDialog.GetHWND(),
               String::load(IDS_CANCEL_PROMOTE),
               MB_YESNO | MB_ICONWARNING) == IDYES)
         {
            // this should return ERROR_SUCCESS, and the promotion will
            // be rolled back.

            progressDialog.UpdateText(IDS_CANCELLING);
            progressDialog.UpdateAnimation(IDR_AVI_DEMOTE);            
            netErr = MyDsRoleCancel(handle);

            // fall out of the inner, then the outer, loop.  Then we will
            // get the operation results, which should indicate that the
            // promotion was cancelled as a failure code.  We handle this
            // failure code in the same manner as all others.

            break;
         }

         // user decided to press on.  reset the cancel button

         progressDialog.UpdateButton(IDS_PROGRESS_CANCEL);
         progressDialog.RevertToOriginalAnimation();
         buttonUpdatedToFinishLater = false;
      }
      while (0);

      criticalComplete =
            criticalComplete
         || statusFlags & DSROLE_CRITICAL_OPERATIONS_COMPLETED;

      if (criticalComplete)
      {
         if (cancelButton == ProgressDialog::PRESSED)
         {
            // we add this message without actually checking the operation
            // results flags because for all we know, the replication will
            // finish before we get around to checking.  It is still correct
            // to say the the replication has stopped, and will start after
            // reboot.  This is always the case.

            state.AddFinishMessage(
               String::load(IDS_NON_CRITICAL_REPLICATION_CANCELED));
         }
         else
         {
            if (!buttonUpdatedToFinishLater)
            {
               progressDialog.UpdateButton(IDS_FINISH_REPLICATION_LATER);
               buttonUpdatedToFinishLater = true;
            }
         }
      }
   }
   while (netErr == ERROR_IO_PENDING);

   progressDialog.UpdateButton(String());
   buttonUpdatedToFinishLater = false;

   LOG(L"Progress loop complete.");

   if (netErr == ERROR_SUCCESS)
   {
      // we successfully endured the wait.  let's see how it turned out.

      DSROLE_SERVEROP_RESULTS* results;

      LOG(L"Calling DsRoleGetDcOperationResults");

      netErr = ::DsRoleGetDcOperationResults(0, handle, &results);

      LOG(String::format(L"Error 0x%1!X! (!0 => error)", netErr));

      if (netErr == ERROR_SUCCESS)
      {
         // we got the results

         ASSERT(results);
         if (results)
         {
            LOG(L"Operation results:");
            LOG(
               String::format(
                  L"OperationStatus      : 0x%1!X! !0 => error",
                  results->OperationStatus));
            LOG(
               String::format(
                  L"DisplayString        : %1",
                  results->OperationStatusDisplayString));
            LOG(
               String::format(
                  L"ServerInstalledSite  : %1",
                  results->ServerInstalledSite));
            LOG(
               String::format(
                  L"OperationResultsFlags: 0x%1!X!",
                  results->OperationResultsFlags));

            netErr = results->OperationStatus;

            // here, netErr will be some error code if the promote was
            // cancelled and successfully rolled back.  Since it may be
            // possible that the cancel was too late (e.g. the user took
            // too long to confirm the cancel), the promote may have
            // finished.  If that's the case, tell the user that the cancel
            // failed.

            if (
                  netErr == ERROR_SUCCESS
               && cancelButton == ProgressDialog::PRESSED)
            {
               // the promote finished, and the cancel button was pressed.

               if (!criticalComplete)  // 363590
               {
                  // we didn't find out if the non-critical replication phase
                  // started.  So the cancel button still said 'Cancel', and
                  // yet, the operation finished. so, this means that the
                  // promote simply completed before the cancel was received.

                  popup.Info(
                     progressDialog.GetHWND(),
                     IDS_CANCEL_TOO_LATE);
               }
            }

            String message =
                  results->OperationStatusDisplayString
               ?  results->OperationStatusDisplayString
               :  L"";
            String site =
                  results->ServerInstalledSite
               ?  results->ServerInstalledSite
               :  L"";

            progressDialog.UpdateText(message);

            if (!site.empty())
            {
               state.SetInstalledSite(site);
            }
            if (!message.empty())
            {
               state.SetOperationResultsMessage(message);
            }

            state.SetOperationResultsFlags(results->OperationResultsFlags);
            
            if (
                  results->OperationResultsFlags
               &  DSROLE_NON_FATAL_ERROR_OCCURRED)
            {
               state.AddFinishMessage(
                  String::load(IDS_NON_FATAL_ERRORS_OCCURRED));
            }
            if (
                  (results->OperationResultsFlags
                   & DSROLE_NON_CRITICAL_REPL_NOT_FINISHED)
               && cancelButton != ProgressDialog::PRESSED )
            {
               // cancel not pressed and critial replication bombed

               state.AddFinishMessage(
                  String::load(IDS_NON_CRITICAL_REPL_FAILED));
            }
            if (
                  results->OperationResultsFlags
               &  DSROLE_IFM_RESTORED_DATABASE_FILES_MOVED)
            {
               LOG(L"restored files were moved");

               if (netErr != ERROR_SUCCESS)
               {
                  // only need to mention this in the case of a fatal failure;
                  // e.g. don't add this finish text if non-fatal errors
                  // occurred.
                  // NTRAID#NTBUG9-330378-2001/02/28-sburns
                  
                  state.AddFinishMessage(
                     String::load(IDS_MUST_RESTORE_IFM_FILES_AGAIN));
               }
            }

            ::DsRoleFreeMemory(results);
         }
      }
   }

   if (netErr != ERROR_SUCCESS)
   {
      // couldn't get progress updates, or couldn't get results,
      // or result was a failure

      throw DS::Error(Win32ToHresult(netErr), IDS_WIZARD_TITLE);
   }
}



void
EmptyFolder(const String& path)
throw (DS::Error)
{
   LOG_FUNCTION2(EmptyFolder, path);
   ASSERT(FS::PathExists(path));

   // check for files/subfolders once again (we checked the first time on
   // validating the path), in case something has written to the folder
   // since we validated it last.

   if (!FS::IsFolderEmpty(path))
   {
      // nuke the files in the directory

      LOG(String::format(L"Emptying %1", path.c_str()));

      String wild = path;

      // REVIEW: wild[wild.length() - 1] is the same as *(wild.rbegin())
      // which is cheaper?
      
      if (wild[wild.length() - 1] != L'\\')
      {
         wild += L"\\";
      }

      wild += L"*.*";

      FS::Iterator iter(
         wild,
            FS::Iterator::INCLUDE_FILES
         |  FS::Iterator::RETURN_FULL_PATHS);

      HRESULT hr = S_OK;
      String current;

      while ((hr = iter.GetCurrent(current)) == S_OK)
      {
         LOG(String::format(L"Deleting %1", current.c_str()));

         hr = Win::DeleteFile(current);
         if (FAILED(hr))
         {
            int msgId = IDS_EMPTY_DIR_FAILED;

            if (hr == Win32ToHresult(ERROR_ACCESS_DENIED))
            {
               msgId = IDS_EMPTY_DIR_FAILED_ACCESS_DENIED;
            }

            throw 
               DS::Error(
                  S_OK, // so as not to trigger credentials dialog
                  String::format(
                     msgId,
                     GetErrorMessage(hr).c_str(),
                     path.c_str()),
                  String::load(IDS_ERROR_PREPARING_OPERATION));
         }

         hr = iter.Increment();
         BREAK_ON_FAILED_HRESULT(hr);
      }
   }
}



HRESULT
SetupPaths()
{
   LOG_FUNCTION(SetupPaths);

   State& state      = State::GetInstance();   
   String dbPath     = state.GetDatabasePath();
   String logPath    = state.GetLogPath();     
   String sysvolPath = state.GetSYSVOLPath();  

   ASSERT(!dbPath.empty());
   ASSERT(!logPath.empty());
   ASSERT(!sysvolPath.empty());

   HRESULT hr = S_OK;

   do
   {
      if (FS::PathExists(dbPath))
      {
         EmptyFolder(dbPath);
      }
      else
      {
         hr = FS::CreateFolder(dbPath);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      if (FS::PathExists(logPath))
      {
         EmptyFolder(logPath);
      }
      else
      {
         hr = FS::CreateFolder(logPath);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      if (FS::PathExists(sysvolPath))
      {
         EmptyFolder(sysvolPath);
      }
      else
      {
         hr = FS::CreateFolder(sysvolPath);
         BREAK_ON_FAILED_HRESULT(hr);
      }
   }
   while (0);

   return hr;
}



// Sets the promotion flags based on options set in the unattended execution
// answerfile.
// 
// state - IN reference to the global State object
// 
// flags - IN/OUT promote API flags, may be modified on exit

void
SetAnswerFilePromoteFlags(
   State& state,
   ULONG& flags)
{
   LOG_FUNCTION(SetAnswerFilePromoteFlags);

   if (state.UsingAnswerFile())
   {
      // set flags based on unattended execution options

      // if the safe mode admin password is not specified, then we set a
      // flag to cause the promote APIs to copy the current local admin
      // password.

      EncryptedString safeModePassword = state.GetSafeModeAdminPassword();

      if (safeModePassword.IsEmpty() && state.RunHiddenUnattended())
      {
         // user did not supply a safemode password, and he did not have
         // an opportunity to do so (if the wizard went interactive)

         if (!state.IsSafeModeAdminPwdOptionPresent())
         {
            // the safe mode pwd key is not present in the answerfile

            flags |= DSROLE_DC_DEFAULT_REPAIR_PWD;
         }
      }

      String option =
         state.GetAnswerFileOption(
            AnswerFile::OPTION_CRITICAL_REPLICATION_ONLY);
      if (option.icompare(AnswerFile::VALUE_YES) == 0)
      {
         flags |= DSROLE_DC_CRITICAL_REPLICATION_ONLY;
      }
   }

   LOG(String::format(L"0x%1!X!", flags));
}



void
DS::CreateReplica(ProgressDialog& progressDialog, bool invokeForUpgrade)
throw (DS::Error)
{
   LOG_FUNCTION(DS::CreateReplica);

   State& state = State::GetInstance();

   String domain           = state.GetReplicaDomainDNSName(); 
   String dbPath           = state.GetDatabasePath();         
   String logPath          = state.GetLogPath();              
   String sysvolPath       = state.GetSYSVOLPath();           
   String site             = state.GetSiteName();             
   String username         = state.GetUsername();             
   String replicationDc    = state.GetReplicationPartnerDC(); 
   String sourcePath       = state.GetReplicationSourcePath();
   bool   useSourcePath    = state.ReplicateFromMedia();

   EncryptedString syskey           = state.GetSyskey();               
   EncryptedString safeModePassword = state.GetSafeModeAdminPassword();
   EncryptedString password         = state.GetPassword();             

   bool useCurrentUserCreds = username.empty();
   ULONG flags =
         DSROLE_DC_FORCE_TIME_SYNC
      |  DSROLE_DC_CREATE_TRUST_AS_REQUIRED;

   if (invokeForUpgrade)
   {
      flags |= DSROLE_DC_DOWNLEVEL_UPGRADE;
   }
   if (state.GetDomainControllerReinstallFlag())
   {
      flags |= DSROLE_DC_ALLOW_DC_REINSTALL;
   }

   SetAnswerFilePromoteFlags(state, flags);

   if (useSourcePath)
   {
      if (state.GetRestoreGc())
      {
         flags |= DSROLE_DC_REQUEST_GC;
      }

   }

   ASSERT(!domain.empty());

   if (!useCurrentUserCreds)
   {
      String user_domain = state.GetUserDomainName();
      username = MassageUserName(user_domain, username);
   }

   HRESULT hr = S_OK;
   do
   {
      hr = SetupPaths();
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"Calling DsRoleDcAsReplica");
      LOG(               L"lpServer               : (null)");
      LOG(String::format(L"lpDnsDomainName        : %1", domain.c_str()));
      LOG(String::format(L"lpReplicaServer        : %1", replicationDc.empty() ? L"(null)" : replicationDc.c_str()));
      LOG(String::format(L"lpSiteName             : %1", site.empty() ? L"(null)" : site.c_str()));
      LOG(String::format(L"lpDsDatabasePath       : %1", dbPath.c_str()));
      LOG(String::format(L"lpDsLogPath            : %1", logPath.c_str()));
      LOG(String::format(L"lpRestorePath          : %1", useSourcePath ? sourcePath.c_str() : L"(null)"));
      LOG(String::format(L"lpSystemVolumeRootPath : %1", sysvolPath.c_str()));
      LOG(String::format(L"lpAccount              : %1", useCurrentUserCreds ? L"(null)" : username.c_str()));
      LOG(String::format(L"Options                : 0x%1!X!", flags));

      WCHAR* safeModePasswordCopy = 0;
      if (!safeModePassword.IsEmpty())
      {
         safeModePasswordCopy = safeModePassword.GetClearTextCopy();
      }
      
      WCHAR* passwordCopy = 0;
      if (!useCurrentUserCreds)
      {
         passwordCopy = password.GetClearTextCopy();
      }
      
      // The api wants to scribble over the syskey, so we make a copy for
      // it to do so.

      WCHAR* syskeyCopy = 0;
      if (useSourcePath && !syskey.IsEmpty())
      {
         syskeyCopy = syskey.GetClearTextCopy();
      }

      DSROLE_SERVEROP_HANDLE handle = 0;
      hr =
         Win32ToHresult(
            ::DsRoleDcAsReplica(
               0, // this server
               domain.c_str(),

               // possibly empty, e.g. if we didn't join a domain...

               replicationDc.empty() ? 0 : replicationDc.c_str(),
               site.empty() ? 0 : site.c_str(),
               dbPath.c_str(),
               logPath.c_str(),
               useSourcePath ? sourcePath.c_str() : 0,
               sysvolPath.c_str(),
               syskeyCopy,
               (useCurrentUserCreds ? 0 : username.c_str()),
               passwordCopy,
               safeModePasswordCopy,
               flags,
               &handle));

      if (safeModePasswordCopy)
      {
         safeModePassword.DestroyClearTextCopy(safeModePasswordCopy);
      }

      if (passwordCopy)
      {
         password.DestroyClearTextCopy(passwordCopy);
      }

      if (syskeyCopy)
      {
         syskey.DestroyClearTextCopy(syskeyCopy);
      }

      BREAK_ON_FAILED_HRESULT(hr);

      DoProgressLoop(handle, progressDialog);
   }
   while (0);

   if (FAILED(hr))
   {
      throw DS::Error(hr, IDS_WIZARD_TITLE);
   }
}



void
DS::CreateNewDomain(ProgressDialog& progressDialog)
throw (DS::Error)
{
   LOG_FUNCTION(DS::CreateNewDomain);

   State& state = State::GetInstance();

   String domain           = state.GetNewDomainDNSName();     
   String flatName         = state.GetNewDomainNetbiosName(); 
   String site             = state.GetSiteName();             
   String dbPath           = state.GetDatabasePath();         
   String logPath          = state.GetLogPath();              
   String sysvolPath       = state.GetSYSVOLPath();           
   String parent           = state.GetParentDomainDnsName();  
   String username         = state.GetUsername();             

   EncryptedString password         = state.GetPassword();             
   EncryptedString safeModePassword = state.GetSafeModeAdminPassword();
   EncryptedString adminPassword    = state.GetAdminPassword();        

   State::Operation operation = state.GetOperation();
   bool useParent =
      (  operation == State::TREE
      || operation == State::CHILD);
   bool useCurrentUserCreds = username.empty();

   ULONG flags =
         DSROLE_DC_CREATE_TRUST_AS_REQUIRED
      |  DSROLE_DC_FORCE_TIME_SYNC;

   if (state.GetDomainReinstallFlag())
   {
      flags |= DSROLE_DC_ALLOW_DOMAIN_REINSTALL;
   }

   if (state.GetDomainControllerReinstallFlag())
   {
      flags |= DSROLE_DC_ALLOW_DC_REINSTALL;
   }

   if (operation == State::TREE)
   {
      flags |= DSROLE_DC_TRUST_AS_ROOT;

      ASSERT(!parent.empty());
   }

   SetAnswerFilePromoteFlags(state, flags);

   if (state.ShouldAllowAnonymousAccess())
   {
      flags |= DSROLE_DC_ALLOW_ANONYMOUS_ACCESS;
   }

   if (operation == State::FOREST)
   {
      flags |= DSROLE_DC_NO_NET;

      ASSERT(!site.empty());
   }

#ifdef DBG

   else if (operation == State::CHILD)
   {
      ASSERT(!parent.empty());
   }

   ASSERT(!domain.empty());
   ASSERT(!flatName.empty());

   // parent may be empty

#endif

   if (!useCurrentUserCreds)
   {
      String userDomain = state.GetUserDomainName();
      username = MassageUserName(userDomain, username);
   }

   HRESULT hr = S_OK;
   do
   {
      hr = SetupPaths();
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"Calling DsRoleDcAsDc");
      LOG(               L"lpServer               : (null)");
      LOG(String::format(L"lpDnsDomainName        : %1", domain.c_str()));
      LOG(String::format(L"lpFlatDomainName       : %1", flatName.c_str()));
      LOG(String::format(L"lpSiteName             : %1", site.empty() ? L"(null)" : site.c_str()));
      LOG(String::format(L"lpDsDatabasePath       : %1", dbPath.c_str()));
      LOG(String::format(L"lpDsLogPath            : %1", logPath.c_str()));
      LOG(String::format(L"lpSystemVolumeRootPath : %1", sysvolPath.c_str()));
      LOG(String::format(L"lpParentDnsDomainName  : %1", useParent ? parent.c_str() : L"(null)"));
      LOG(               L"lpParentServer         : (null)");
      LOG(String::format(L"lpAccount              : %1", useCurrentUserCreds ? L"(null)" : username.c_str()));
      LOG(String::format(L"Options                : 0x%1!X!", flags));

      WCHAR* safeModePasswordCopy = 0;
      if (!safeModePassword.IsEmpty())
      {
         safeModePasswordCopy = safeModePassword.GetClearTextCopy();
      }

      WCHAR* adminPasswordCopy = 0;
      if (!adminPassword.IsEmpty())
      {
         adminPasswordCopy = adminPassword.GetClearTextCopy();
      }

      WCHAR* passwordCopy = 0;
      if (!useCurrentUserCreds)
      {
         passwordCopy = password.GetClearTextCopy();
      }
      
      DSROLE_SERVEROP_HANDLE handle = 0;
      hr = 
         Win32ToHresult(
            DsRoleDcAsDc(
               0, // this server
               domain.c_str(),
               flatName.c_str(),
               adminPasswordCopy,
               site.empty() ? 0 : site.c_str(),
               dbPath.c_str(),
               logPath.c_str(),
               sysvolPath.c_str(),
               (useParent ? parent.c_str() : 0),
               0, // let API pick a server
               (useCurrentUserCreds ? 0 : username.c_str()),
               passwordCopy,
               safeModePasswordCopy,
               flags,
               &handle));
      BREAK_ON_FAILED_HRESULT(hr);

      if (safeModePasswordCopy)
      {
         safeModePassword.DestroyClearTextCopy(safeModePasswordCopy);
      }

      if (adminPasswordCopy)
      {
         adminPassword.DestroyClearTextCopy(adminPasswordCopy);
      }

      if (passwordCopy)
      {
         password.DestroyClearTextCopy(passwordCopy);
      }

      DoProgressLoop(handle, progressDialog);
   }
   while (0);

   if (FAILED(hr))
   {
      throw DS::Error(hr, IDS_WIZARD_TITLE);
   }
}



void
DS::UpgradeBDC(ProgressDialog& progressDialog)
throw (DS::Error)
{
   LOG_FUNCTION(DS::UpgradeBDC);

   // seems non-intuitive to abort the upgrade to do the upgrade, but here
   // the abort removes dcpromo autostart, and turns the machine into a
   // standalone server.  Then we proceed to make it a replica.

   DS::AbortBDCUpgrade(true);
   DS::CreateReplica(progressDialog, true);
}



void
DS::UpgradePDC(ProgressDialog& progressDialog)
throw (DS::Error)
{
   LOG_FUNCTION(DS::UpgradePDC);

   State& state = State::GetInstance();
   ASSERT(state.GetRunContext() == State::PDC_UPGRADE);

   String domain           = state.GetNewDomainDNSName();     
   String site             = state.GetSiteName();             
   String dbPath           = state.GetDatabasePath();         
   String logPath          = state.GetLogPath();              
   String sysvolPath       = state.GetSYSVOLPath();           
   String parent           = state.GetParentDomainDnsName();  
   String username         = state.GetUsername();             

   EncryptedString password         = state.GetPassword();             
   EncryptedString safeModePassword = state.GetSafeModeAdminPassword();

   State::Operation operation = state.GetOperation();
   bool useParent =
      (  operation == State::TREE
      || operation == State::CHILD);
   bool useCurrentUserCreds = username.empty();

   ULONG flags = DSROLE_DC_CREATE_TRUST_AS_REQUIRED;

   if (state.GetDomainReinstallFlag())
   {
      flags |= DSROLE_DC_ALLOW_DOMAIN_REINSTALL;
   }

   if (state.GetDomainControllerReinstallFlag())
   {
      flags |= DSROLE_DC_ALLOW_DC_REINSTALL;
   }

   if (state.GetSetForestVersionFlag())
   {
      flags |= DSROLE_DC_SET_FOREST_CURRENT;
   }

   if (operation == State::TREE)
   {
      flags |= DSROLE_DC_TRUST_AS_ROOT | DSROLE_DC_FORCE_TIME_SYNC;
      ASSERT(!parent.empty());
   }
   else if (operation == State::CHILD)
   {
      flags |= DSROLE_DC_FORCE_TIME_SYNC;
      ASSERT(!parent.empty());
   }

   SetAnswerFilePromoteFlags(state, flags);

   if (state.ShouldAllowAnonymousAccess())
   {
      flags |= DSROLE_DC_ALLOW_ANONYMOUS_ACCESS;
   }

#ifdef DBG
   ASSERT(!domain.empty());

   // parent may be empty

   if (operation == State::FOREST)
   {
      ASSERT(!site.empty());
   }
#endif

   if (!useCurrentUserCreds)
   {
      String userDomain = state.GetUserDomainName();
      username = MassageUserName(userDomain, username);
   }

   HRESULT hr = S_OK;
   do
   {
      hr = SetupPaths();
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"Calling DsRoleUpgradeDownlevelServer");
      LOG(String::format(L"lpDnsDomainName        : %1", domain.c_str()));
      LOG(String::format(L"lpSiteName             : %1", site.empty() ? L"(null)" : site.c_str()));
      LOG(String::format(L"lpDsDatabasePath       : %1", dbPath.c_str()));
      LOG(String::format(L"lpDsLogPath            : %1", logPath.c_str()));
      LOG(String::format(L"lpSystemVolumeRootPath : %1", sysvolPath.c_str()));
      LOG(String::format(L"lpParentDnsDomainName  : %1", useParent ? parent.c_str() : L"(null)"));
      LOG(               L"lpParentServer         : (null)");
      LOG(String::format(L"lpAccount              : %1", useCurrentUserCreds ? L"(null)" : username.c_str()));
      LOG(String::format(L"Options                : 0x%1!X!", flags));

      WCHAR* safeModePasswordCopy = 0;
      if (!safeModePassword.IsEmpty())
      {
         safeModePasswordCopy = safeModePassword.GetClearTextCopy();
      }
      
      WCHAR* passwordCopy = 0;
      if (!useCurrentUserCreds)
      {
         passwordCopy = password.GetClearTextCopy();
      }

      DSROLE_SERVEROP_HANDLE handle = 0;
      hr =
         Win32ToHresult(   
            ::DsRoleUpgradeDownlevelServer(
               domain.c_str(),
               site.empty() ? 0 : site.c_str(),
               dbPath.c_str(),
               logPath.c_str(),
               sysvolPath.c_str(),
               (useParent ? parent.c_str() : 0),
               0, // let API pick a server
               (useCurrentUserCreds ? 0 : username.c_str()),
               passwordCopy,
               safeModePasswordCopy,
               flags,
               &handle));
      BREAK_ON_FAILED_HRESULT(hr);

      if (safeModePasswordCopy)
      {
         safeModePassword.DestroyClearTextCopy(safeModePasswordCopy);
      }
      
      if (passwordCopy)
      {
         password.DestroyClearTextCopy(passwordCopy);
      }

      DoProgressLoop(handle, progressDialog);
   }
   while (0);

   if (FAILED(hr))
   {
      throw DS::Error(hr, IDS_UPGRADE_DC_FAILED);
   }
}



// Converts the list of ndncs into a form more easily digestible by the demote
// API: an array of null-terminated arrays of WCHAR, with the last element a
// null.  The result must be deallocated by DeallocateAppPartitionList.
// 
// entryCount - out, receieves the number of strings allocated.

PCWSTR*
AllocateAppPartitionList(int& entryCount)
{
   LOG_FUNCTION(AllocateAppPartitionList);

   const StringList& ndncList = State::GetInstance().GetAppPartitionList();
   entryCount = 0;

   if (!ndncList.size())
   {
      // empty list

      return 0;
   }

   PWSTR* result = new PWSTR[ndncList.size() + 1];

   // REVIEWED-2002/02/26-sburns correct byte count passed.
   
   ::ZeroMemory(result, (ndncList.size() + 1) * sizeof PWSTR);
   
   for (
      StringList::iterator i = ndncList.begin();
      i != ndncList.end();
      ++i)
   {
      ASSERT(i->length());
      
      size_t len = i->length() + 1;
      result[entryCount] = new WCHAR[len];

      // REVIEWED-2002/02/26-sburns correct byte count passed.
      
      ::ZeroMemory(result[entryCount], len * sizeof WCHAR);

      i->copy(result[entryCount], len - 1);
      ++entryCount;
   }

   return const_cast<PCWSTR*>(result);
}



void
DeallocateAppPartitionList(PCWSTR*& partitionList)
{
   LOG_FUNCTION(DeallocateAppPartitionList);

   if (partitionList)
   {
      PCWSTR* listCopy = partitionList;

      while (*listCopy)
      {
         delete *listCopy;
 //        *listCopy = 0;
         ++listCopy;
      }
   
      delete partitionList;
      partitionList = 0;
   }
}
      


void
DS::DemoteDC(ProgressDialog& progressDialog)
throw (DS::Error)
{
   LOG_FUNCTION(DS::DemoteDC);

   State& state = State::GetInstance();

   String username            = state.GetUsername();     
   bool   useCurrentUserCreds = username.empty();        
   bool   isLastDc            = state.IsLastDCInDomain();
   bool   isForcedDemotion    = state.IsForcedDemotion();
   EncryptedString adminPassword= state.GetAdminPassword();
   EncryptedString password     = state.GetPassword();     

   if (!useCurrentUserCreds)
   {
      String userDomain = state.GetUserDomainName();
      username = MassageUserName(userDomain, username);
   }

   ULONG options = DSROLE_DC_CREATE_TRUST_AS_REQUIRED;
   if (isLastDc)
   {
      options |= DSROLE_DC_DELETE_PARENT_TRUST;
   }

   if (isForcedDemotion)
   {
      // Update our list of application partitions so that we can remove
      // all of them
      
      state.IsLastAppPartitionReplica();
      options |= DSROLE_DC_FORCE_DEMOTE;

      // pretend to be the last DC if we're forcing the demotion.
      
      isLastDc = true;
   }

   int appPartitionCount = 0;
   PCWSTR* appPartitionList = AllocateAppPartitionList(appPartitionCount);
   
#ifdef LOGGING_BUILD   
   LOG(L"Calling DsRoleDemoteDc");
   LOG(               L"lpServer               : (null)");
   LOG(               L"lpDnsDomainName        : (null)");
   LOG(String::format(L"ServerRole             : %1", isLastDc ? L"DsRoleServerStandalone" : L"DsRoleServerMember"));
   LOG(String::format(L"lpAccount              : %1", useCurrentUserCreds ? L"(null)" : username.c_str()));
   LOG(String::format(L"Options                : 0x%1!X!", options));
   LOG(String::format(L"fLastDcInDomain        : %1", isLastDc ? L"true" : L"false"));
   LOG(String::format(L"cRemoteNCs             : %1!d!", appPartitionCount));

   for (int i = 0; i < appPartitionCount; ++i)
   {
      LOG(String::format(L"pszRemoveNCs           : %1", appPartitionList[i]));
   }
#endif // LOGGING_BUILD      

   WCHAR* adminPasswordCopy = 0;
   if (!adminPassword.IsEmpty())
   {
      adminPasswordCopy = adminPassword.GetClearTextCopy();
   }
   
   WCHAR* passwordCopy = 0;
   if (!useCurrentUserCreds)
   {
      passwordCopy = password.GetClearTextCopy();
   }

   DSROLE_SERVEROP_HANDLE handle = 0;
   HRESULT hr =
      Win32ToHresult(
         ::DsRoleDemoteDc(
            0, // this server
            0, // "default" domain hosted by this server
            isLastDc ? DsRoleServerStandalone : DsRoleServerMember,
            (useCurrentUserCreds ? 0 : username.c_str()),
            passwordCopy,
            options,
            isLastDc ? TRUE : FALSE,
            appPartitionCount,
            appPartitionList,
            adminPasswordCopy,
            &handle));
   LOG_HRESULT(hr);

   DeallocateAppPartitionList(appPartitionList);

   if (adminPasswordCopy)
   {
      adminPassword.DestroyClearTextCopy(adminPasswordCopy);
   }
   
   if (passwordCopy)
   {
      password.DestroyClearTextCopy(passwordCopy);
   }

   if (SUCCEEDED(hr))
   {
      DoProgressLoop(handle, progressDialog);
   }
   else
   {
      throw DS::Error(hr, IDS_DEMOTE_DC_FAILED);
   }
}



void
DS::AbortBDCUpgrade(bool abortForReplica)
throw (DS::Error)
{
   LOG_FUNCTION(DS::AbortBDCUpgrade);

   State& state = State::GetInstance();
   ASSERT(state.GetRunContext() == State::BDC_UPGRADE);

   String username            = state.GetUsername();     
   bool   useCurrentUserCreds = username.empty();        

   EncryptedString adminPassword       = state.GetAdminPassword();
   EncryptedString password            = state.GetPassword();     
   
   if (!useCurrentUserCreds)
   {
      String userDomain = state.GetUserDomainName();
      username = MassageUserName(userDomain, username);
   }

   ULONG options =
      abortForReplica ? DSROLEP_ABORT_FOR_REPLICA_INSTALL : 0;

   LOG(L"Calling DsRoleAbortDownlevelServerUpgrade");
   LOG(String::format(L"lpAccount : %1", useCurrentUserCreds ? L"(null)" : username.c_str()));
   LOG(String::format(L"Options   : 0x%1!X!", options));

   WCHAR* adminPasswordCopy = 0;
   if (!adminPassword.IsEmpty())
   {
      adminPasswordCopy = adminPassword.GetClearTextCopy();
   }
   
   WCHAR* passwordCopy = 0;
   if (!useCurrentUserCreds)
   {
      passwordCopy = password.GetClearTextCopy();
   }

   HRESULT hr =
      Win32ToHresult(
         ::DsRoleAbortDownlevelServerUpgrade(
            adminPasswordCopy,
            (useCurrentUserCreds ? 0 : username.c_str()),
            passwordCopy,
            options));
   LOG_HRESULT(hr);

   if (adminPasswordCopy)
   {
      adminPassword.DestroyClearTextCopy(adminPasswordCopy);
   }
   
   if (passwordCopy)
   {
      password.DestroyClearTextCopy(passwordCopy);
   }
   
   if (FAILED(hr))
   {
      throw DS::Error(hr, IDS_ABORT_UPGRADE_FAILED);
   }
}



DS::PriorServerRole
DS::GetPriorServerRole(bool& isUpgrade)
{
   LOG_FUNCTION(DS::GetPriorServerRole);

   isUpgrade = false;
   DSROLE_UPGRADE_STATUS_INFO* info = 0;

   HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
   if (SUCCEEDED(hr) && info)
   {
      isUpgrade =
         ( (info->OperationState & DSROLE_UPGRADE_IN_PROGRESS)
         ? true
         : false );
      DSROLE_SERVER_STATE state = info->PreviousServerState;

      ::DsRoleFreeMemory(info);

      switch (state)
      {
         case DsRoleServerPrimary:
         {
            return PDC;
         }
         case DsRoleServerBackup:
         {
            return BDC;
         }
         case DsRoleServerUnknown:
         default:
         {
            return UNKNOWN;
         }
      }
   }

   return UNKNOWN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\ds.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// DS API wrappers
//
// 12-16-97 sburns



#ifndef DS_HPP_INCLUDED
#define DS_HPP_INCLUDED



class ProgressDialog;



namespace DS
{
   const int MAX_NETBIOS_NAME_LENGTH = DNLEN;
   const int MAX_USER_NAME_LENGTH = UNLEN;
   const int MAX_PASSWORD_LENGTH = PWLEN;

   class Error : public Win::Error
   {
      public:

      // Constructs a new instance.
      // 
      // hr - The HRESULT this error represents.
      // 
      // summaryResID - ID of the string resource that corresponds to
      // the summary text to be returned by GetSummary().

      Error(HRESULT hr, int summaryResID);

      Error(HRESULT hr, const String& message, const String& summary);
   };

   // abortForReplica - true if this call is a precursor to calling
   // CreateReplica (used to upgrade a BDC to a replica), false if the call is
   // to leave the server as a member server.

   void
   AbortBDCUpgrade(bool abortForReplica = false)
   throw (DS::Error);

   void
   DemoteDC(ProgressDialog& progressDialog)
   throw (DS::Error);

   void
   CreateNewDomain(ProgressDialog& progressDialog)
   throw (DS::Error);

   void
   CreateReplica(
      ProgressDialog&   progressDialog,
      bool              invokeForUpgrade = false)
   throw (DS::Error);

   bool
   DisjoinDomain()
   throw (DS::Error);

   // Returns true if the domain is located, false if the name is unknown
   // or some other error occurred.
   //
   // domainDNSName - DNS or Netbios name of domain to search for.

   bool
   DomainExists(const String& domainName);

   enum PriorServerRole
   {
      UNKNOWN,
      PDC,
      BDC
   };

   PriorServerRole
   GetPriorServerRole(bool& isUpgrade);

   bool
   IsDomainNameInUse(const String& domainName);

   bool
   IsDSRunning();

   void
   JoinDomain(
      const String&           domainDNSName, 
      const String&           dcName,        
      const String&           userName,      
      const EncryptedString&  password,      
      const String&           userDomainName)
   throw (DS::Error);

   void
   UpgradeBDC(ProgressDialog& progressDialog)
   throw (DS::Error);

   void
   UpgradePDC(ProgressDialog& progressDialog)
   throw (DS::Error);
}



#endif   // DS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\dnssetup.cpp ===
// Copyright (C) 1998 Microsoft Corporation
//
// DNS installation and configuration code 
//
// 6-16-98 sburns



#include "headers.hxx"
#include "resource.h"
#include "ProgressDialog.hpp"
#include "state.hpp"



static const DWORD HELP_MAP[] =
{
   0, 0
};
static const int NAP_TIME = 3000; // in ms



int
millisecondsToSeconds(int millis)
{
   static const int MILLIS_PER_SECOND = 1000;

   return millis / MILLIS_PER_SECOND;
}



bool
pollForDNSServiceStart(ProgressDialog& progressDialog)
{
   LOG_FUNCTION(PollForDNSServiceStart);

   for (int waitCount = 0; /* empty */ ; waitCount++)
   {
      progressDialog.UpdateText(
         String::format(
            IDS_WAITING_FOR_SERVICE_START,
            millisecondsToSeconds(NAP_TIME * waitCount)));

      if (progressDialog.WaitForButton(NAP_TIME) == ProgressDialog::PRESSED)
      {
         progressDialog.UpdateButton(String());
         popup.Info(
            progressDialog.GetHWND(),
            String::load(IDS_SKIP_DNS_MESSAGE));
         break;
      }

      if (Dns::IsServiceRunning())
      {
         // success!
         return true;
      }
   }

   return false;
}



bool
pollForDNSServiceInstallAndStart(ProgressDialog& progressDialog)
{
   LOG_FUNCTION(pollForDNSServiceInstallAndStart);

   State& state = State::GetInstance();
   bool shouldTimeout = false;
   if (state.RunHiddenUnattended())
   {
      // need to timeout in case the user cancelled the installer.
      // NTRAID#NTBUG9-424845-2001/07/02-sburns

      shouldTimeout = true;   
   }

   static const int MAX_WAIT_COUNT = 60;     // NAP_TIME * 60 = 3 minutes
   
   for (
      int waitCount = 0;
      !(shouldTimeout && (waitCount > MAX_WAIT_COUNT));
      ++waitCount)   
   {
      progressDialog.UpdateText(
         String::format(
            IDS_WAITING_FOR_SERVICE_INSTALL,
            millisecondsToSeconds(NAP_TIME * waitCount)));

      if (progressDialog.WaitForButton(NAP_TIME) == ProgressDialog::PRESSED)
      {
         progressDialog.UpdateButton(String());
         popup.Info(
            progressDialog.GetHWND(),
            String::load(IDS_SKIP_DNS_MESSAGE));
         break;
      }

      if (Dns::IsServiceInstalled())
      {
         // Service is installed.  Now check to see if it is running.
         
         return pollForDNSServiceStart(progressDialog);
      }
   }

   return false;
}



HRESULT
createTempFile(const String& name, int textResID)
{
   LOG_FUNCTION2(createTempFile, name);
   ASSERT(!name.empty());
   ASSERT(textResID);
   ASSERT(FS::IsValidPath(name));

   HRESULT hr = S_OK;
   HANDLE h = INVALID_HANDLE_VALUE;

   do
   {
      hr =

         // REVIEWED-2002/02/26-sburns name is full path, we overwrite any
         // squatters, default ACLs are ok
      
         FS::CreateFile(
            name,
            h,

            // REVIEWED-2002/02/28-sburns this level of access is correct.
            
            GENERIC_WRITE,
            0, 
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED);
      BREAK_ON_FAILED_HRESULT(hr);

      // write to file with Unicode text and end of file character.
      // NTRAID#NTBUG9-495994-2001/11/21-sburns

      hr =
         FS::Write(
            h,
               (wchar_t) 0xFEFF           // Unicode Byte-order marker
            +  String::load(textResID)
            +  L"\032");                  // end of file
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   Win::CloseHandle(h);

   return hr;
}



HRESULT
spawnDNSInstaller(PROCESS_INFORMATION& info)
{
   LOG_FUNCTION(spawnDNSInstaller);

   HRESULT hr = S_OK;

   // CODEWORK: use GetTempPath?
   // ISSUE-2002/03/01-sburns yes, probably, even though the contents
   // are not interesting.

   String sysFolder    = Win::GetSystemDirectory();
   String infPath      = sysFolder + L"\\dcpinf.000"; 
   String unattendPath = sysFolder + L"\\dcpunat.001";

   // create the inf and unattend files for the oc manager
   do
   {
      hr = createTempFile(infPath, IDS_INSTALL_DNS_INF_TEXT);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = createTempFile(unattendPath, IDS_INSTALL_DNS_UNATTEND_TEXT);
      BREAK_ON_FAILED_HRESULT(hr);

      // NTRAID#NTBUG9-417879-2001/06/18-sburns

      State& state = State::GetInstance();      
      String cancelOption;      
      if (state.RunHiddenUnattended())
      {
         String option =
            state.GetAnswerFileOption(
               AnswerFile::OPTION_DISABLE_CANCEL_ON_DNS_INSTALL);
         if (option.icompare(AnswerFile::VALUE_YES) == 0)
         {
            cancelOption = L"/c";
         }
      }
            
      String commandLine =
         String::format(
            L"/i:%1 /u:%2 /x %3"

            // /z added per NTRAID#NTBUG9-440798-2001/07/23-sburns

            L" /z:netoc_show_unattended_messages",

            infPath.c_str(),
            unattendPath.c_str(),
            cancelOption.c_str());
            
      STARTUPINFO startup;

      // REVIEWED-2002/02/25-sburns correct byte count passed.
      
      ::ZeroMemory(&startup, sizeof startup);

      LOG(L"Calling CreateProcess");
      LOG(commandLine);

      // REVIEWED-2002/02/26-sburns wrapper requires full path to app

      hr =
         Win::CreateProcess(
            sysFolder + L"\\sysocmgr.exe",
            commandLine,
            0,
            String(),
            startup,
            info);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



bool
installDNS(ProgressDialog& progressDialog)
{
   LOG_FUNCTION(installDNS);

   if (Dns::IsServiceInstalled())
   {
      LOG(L"DNS service is already installed");

      if (Dns::IsServiceRunning())
      {
         LOG(L"DNS service is already running");
         return true;
      }

      // @@ start the DNS service Dns::StartService?
   }

   progressDialog.UpdateText(String::load(IDS_INSTALLING_DNS));

   PROCESS_INFORMATION info;
   HRESULT hr = spawnDNSInstaller(info);
         
   if (FAILED(hr))
   {
      progressDialog.UpdateText(
         String::load(IDS_PROGRESS_ERROR_INSTALLING_DNS));
      popup.Error(
         progressDialog.GetHWND(),
         hr,
         IDS_ERROR_LAUNCHING_INSTALLER);
      return false;   
   }

   progressDialog.UpdateButton(IDS_PROGRESS_BUTTON_SKIP_DNS);

   // monitor the state of the installer process.
   for (int waitCount = 0; /* empty */ ; waitCount++)   
   {
      progressDialog.UpdateText(
         String::format(
            IDS_WAITING_FOR_INSTALLER,
            millisecondsToSeconds(NAP_TIME * waitCount)));

      if (progressDialog.WaitForButton(NAP_TIME) == ProgressDialog::PRESSED)
      {
         progressDialog.UpdateButton(String());
         popup.Info(
            progressDialog.GetHWND(),
            String::load(IDS_SKIP_DNS_MESSAGE));
         break;
      }

      DWORD exitCode = 0;         
      hr = Win::GetExitCodeProcess(info.hProcess, exitCode);
      if (FAILED(hr))
      {
         LOG(L"GetExitCodeProcess failed");
         LOG_HRESULT(hr);

         progressDialog.UpdateText(
            String::load(IDS_PROGRESS_ERROR_INSTALLING_DNS));
         popup.Error(
            progressDialog.GetHWND(),
            hr,
            IDS_ERROR_QUERYING_INSTALLER);
         return false;
      }

      if (exitCode != STILL_ACTIVE)
      {
         // installer has terminated.  Now check the status of the DNS
         // service
         return pollForDNSServiceInstallAndStart(progressDialog);
      }
   }

   // user bailed out
   return false;
}



bool
InstallAndConfigureDns(
   ProgressDialog&      progressDialog,
   const String&        domainDNSName,
   bool                 isFirstDcInForest)
{
   LOG_FUNCTION2(InstallAndConfigureDns, domainDNSName);
   ASSERT(!domainDNSName.empty());

   if (!installDNS(progressDialog))
   {
      return false;
   }

   progressDialog.UpdateText(String::load(IDS_CONFIGURING_DNS));

   SafeDLL dnsMgr(String::load(IDS_DNSMGR_DLL_NAME));

   FARPROC proc = 0;
   HRESULT hr = dnsMgr.GetProcAddress(L"DnsSetup", proc);

   if (SUCCEEDED(hr))
   {
      String p1 = domainDNSName;
      if (*(p1.rbegin()) != L'.')
      {
         // add trailing dot
         p1 += L'.';
      }

      String p2 = p1 + L"dns";

      DWORD flags = 0;

      if (isFirstDcInForest)
      {
         // NTRAID#NTBUG9-359894-2001/06/09-sburns
         
         flags |= DNS_SETUP_ZONE_CREATE_FOR_DCPROMO_FOREST;
      }

      if (State::GetInstance().ShouldConfigDnsClient())
      {
         // NTRAID#NTBUG9-489252-2001/11/08-sburns
         
         flags |= DNS_SETUP_AUTOCONFIG_CLIENT;
      }

      LOG(L"Calling DnsSetup");
      LOG(String::format(L"lpszFwdZoneName     : %1", p1.c_str()));
      LOG(String::format(L"lpszFwdZoneFileName : %1", p2.c_str()));
      LOG(               L"lpszRevZoneName     : (null)");
      LOG(               L"lpszRevZoneFileName : (null)");
      LOG(String::format(L"dwFlags             : 0x%1!x!", flags));

      typedef HRESULT (*DNSSetup)(PCWSTR, PCWSTR, PCWSTR, PCWSTR, DWORD);      
      DNSSetup dnsproc = reinterpret_cast<DNSSetup>(proc);

      hr = dnsproc(p1.c_str(), p2.c_str(), 0, 0, flags);

      LOG_HRESULT(hr);
   }
   else
   {
      LOG(L"unable to locate DnsSetup proc address");
   }

   if (FAILED(hr))
   {
      // unable to configure DNS, but it was installed.
      progressDialog.UpdateText(
         String::load(IDS_PROGRESS_ERROR_CONFIGURING_DNS));
      popup.Error(
         progressDialog.GetHWND(),
         hr,
         String::format(IDS_ERROR_CONFIGURING_DNS, domainDNSName.c_str()));

      return false;
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\dynamicdnspage.hpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// Dynamic DNS detection/diagnostic page
//
// 22 Aug 2000 sburns



#ifndef DYNAMICDNSPAGE_HPP_INCLUDED
#define DYNAMICDNSPAGE_HPP_INCLUDED



#include "MultiLineEditBoxThatForwardsEnterKey.hpp"



class DynamicDnsPage : public DCPromoWizardPage
{
   public:

   DynamicDnsPage() throw (Win::Error);

   protected:

   virtual ~DynamicDnsPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIdFrom,
      unsigned    code);

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lParam);

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // WizardPage overrides

   virtual
   bool
   OnWizBack();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   enum DiagnosticCode
   {
      // These codes correspond to the message numbers in the spec diagram
      // of the diagnostic algorithm.

      SUCCESS                   = 1,
      SERVER_CANT_UPDATE        = 2,
      ERROR_TESTING_SERVER      = 3,
      UNEXPECTED_FINDING_SERVER = 4,
      ERROR_FINDING_SERVER      = 6,
      ZONE_IS_ROOT              = 8,
      TIMEOUT                   = 11
   };

   DiagnosticCode
   DiagnoseDnsRegistration(
      const String&  newDomainDnsName,
      DNS_STATUS&    errorCode,
      String&        authZone,
      String&        authServer,
      String&        authServerIpAddress);

   void
   DoDnsTestAndUpdatePage();

   void
   SelectRadioButton(int buttonResId);

   void
   UpdateMessageWindow(const String& message);

   void
   ShowButtons(bool hidden);

   DiagnosticCode                       diagnosticResultCode; 
   String                               details;              
   String                               helpTopicLink;        
   bool                                 needToKillSelection;  
   LONG                                 originalMessageHeight;
   unsigned                             testPassCount;        
   MultiLineEditBoxThatForwardsEnterKey multiLineEdit;        
   
   static HINSTANCE richEditHInstance;

   // not defined; no copying allowed

   DynamicDnsPage(const DynamicDnsPage&);
   const DynamicDnsPage& operator=(const DynamicDnsPage&);
};



#endif   // DYNAMICDNSPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\failurepage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// failure page
//
// 12-22-97 sburns



#ifndef FAILUREPAGE_HPP_INCLUDED
#define FAILUREPAGE_HPP_INCLUDED



#include "MultiLineEditBoxThatForwardsEnterKey.hpp"



class FailurePage : public DCPromoWizardPage
{
   public:

   FailurePage();

   protected:

   virtual ~FailurePage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIdFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   bool needToKillSelection;
   MultiLineEditBoxThatForwardsEnterKey multiLineEdit;
   
   // not defined; no copying allowed
   FailurePage(const FailurePage&);
   const FailurePage& operator=(const FailurePage&);
};



#endif   // FAILUREPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\dynamicdnspage.cpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// Dynamic DNS detection/diagnostic page
//
// 22 Aug 2000 sburns



#include "headers.hxx"
#include "page.hpp"
#include "DynamicDnsPage.hpp"
#include "resource.h"
#include "state.hpp"



HINSTANCE DynamicDnsPage::richEditHInstance = 0;



DynamicDnsPage::DynamicDnsPage()
   :
   DCPromoWizardPage(
      IDD_DYNAMIC_DNS,
      IDS_DYNAMIC_DNS_PAGE_TITLE,
      IDS_DYNAMIC_DNS_PAGE_SUBTITLE),
   diagnosticResultCode(UNEXPECTED_FINDING_SERVER),
   needToKillSelection(false),
   originalMessageHeight(0),
   testPassCount(0)
{
   LOG_CTOR(DynamicDnsPage);

   WSADATA data;
   DWORD err = ::WSAStartup(MAKEWORD(2,0), &data);

   // if winsock startup fails, that's a shame.  The gethostbyname will
   // not work, but there's not much we can do about that.

   ASSERT(!err);

   if (!richEditHInstance)
   {
      // You have to load the rich edit dll to get the window class, etc.
      // to register.  Otherwise the dialog will fail create, and the page
      // will not appear.

      HRESULT hr = Win::LoadLibrary(L"riched20.dll", richEditHInstance);
      ASSERT(SUCCEEDED(hr));

      if (FAILED(hr))
      {
         // we've no choice than crash the app.

         throw Win::Error(hr, IDS_RICHEDIT_LOAD_FAILED);
      }
   }
}



DynamicDnsPage::~DynamicDnsPage()
{
   LOG_DTOR(DynamicDnsPage);

   ::WSACleanup();

   Win::FreeLibrary(richEditHInstance);
}



void
DynamicDnsPage::ShowButtons(bool shown)
{
   LOG_FUNCTION(DynamicDnsPage::ShowButtons);

   HWND ignoreButton = Win::GetDlgItem(hwnd, IDC_IGNORE);
   HWND richEdit     = Win::GetDlgItem(hwnd, IDC_MESSAGE);
   
   int state = shown ? SW_SHOW : SW_HIDE;

   Win::ShowWindow(Win::GetDlgItem(hwnd, IDC_RETRY),       state);
   Win::ShowWindow(Win::GetDlgItem(hwnd, IDC_INSTALL_DNS), state);
   Win::ShowWindow(ignoreButton, state);

   RECT r;
   Win::GetWindowRect(richEdit, r);

   // Convert r to coords relative to the parent window.

   Win::MapWindowPoints(0, hwnd, r);       
   
   if (shown)
   {
      // If we're showing the buttons, collapse the rich edit to it's normal
      // height.

      Win::MoveWindow(
         richEdit,
         r.left,
         r.top,
         r.right - r.left,
         originalMessageHeight,
         true);
   }
   else
   {
      // If we're hiding the buttons, expand the rich edit to include their
      // real estate.

      RECT r1;
      Win::GetWindowRect(ignoreButton, r1);
      Win::MapWindowPoints(0, hwnd, r1);       
      
      Win::MoveWindow(
         richEdit,
         r.left,
         r.top,
         r.right - r.left,
         r1.bottom - r.top,
         true);
   }
}



void
DynamicDnsPage::SelectRadioButton(int buttonResId)
{
   // If the order of the buttons changes, then this must be changed.  The
   // buttons also need to have consecutively numbered res IDs in the tab
   // order.

   Win::CheckRadioButton(hwnd, IDC_RETRY, IDC_IGNORE, buttonResId);
}



void
DynamicDnsPage::OnInit()
{
   LOG_FUNCTION(DynamicDnsPage::OnInit);

   HWND richEdit = Win::GetDlgItem(hwnd, IDC_MESSAGE);
   
   // ask for link messages
   
   Win::RichEdit_SetEventMask(richEdit, ENM_LINK);

   // save the normal size of the message box so we can restore it later.
   
   RECT r;
   Win::GetWindowRect(richEdit, r);

   originalMessageHeight = r.bottom - r.top;

   Win::SendMessage(
      richEdit,
      EM_SETBKGNDCOLOR,
      0,
      Win::GetSysColor(COLOR_BTNFACE));
   
   SelectRadioButton(IDC_IGNORE);

   // Hide the radio buttons initially

   ShowButtons(false);

   multiLineEdit.Init(Win::GetDlgItem(hwnd, IDC_MESSAGE));

   // pick the proper radio button label

   if (State::GetInstance().ShouldConfigDnsClient())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_INSTALL_DNS,
         IDS_INSTALL_DNS_RADIO_LABEL_WITH_CLIENT);
   }
   else
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_INSTALL_DNS,
         IDS_INSTALL_DNS_RADIO_LABEL);
   }
}



// Adds a trailing '.' to the supplied name if one is not already present.
// 
// name - in, name to add a trailing '.' to, if it doesn't already have one.
// If this value is the empty string, then '.' is returned.

String
FullyQualifyDnsName(const String& name)
{
   LOG_FUNCTION2(FullyQualifyDnsName, name);

   if (name.empty())
   {
      return L".";
   }

   // needs a trailing dot

   // REVIEW: name[name.length() - 1] is the same as *(name.rbegin())
   // which is cheaper?
   
   if (name[name.length() - 1] != L'.')
   {
      return name + L".";
   }

   // already has a trailing dot

   return name;
}



// Scans a linked list of DNS_RECORDs, returning a pointer to the first record
// of type SOA, or 0 if no record of that type is in the list.
// 
// recordList - in, linked list of DNS_RECORDs, as returned from DnsQuery

DNS_RECORD*
FindSoaRecord(DNS_RECORD* recordList)
{
   LOG_FUNCTION(FindSoaRecord);
   ASSERT(recordList);

   DNS_RECORD* result = recordList;
   while (result)
   {
      if (result->wType == DNS_TYPE_SOA)
      {
         LOG(L"SOA record found");

         break;
      }

      result = result->pNext;
   }

   return result;
}



// Returns the textual representation of the IP address for the given server
// name, in the form "xxx.xxx.xxx.xxx", or the empty string if not IP address
// can be determined.
// 
// serverName - in, the host name of the server for which to find the IP
// address.  If the value is the empty string, then the empty string is
// returned from the function.

String
GetIpAddress(const String& serverName)
{
   LOG_FUNCTION2(GetIpAddress, serverName);
   ASSERT(!serverName.empty());

   String result;

   do
   {
      if (serverName.empty())
      {
         break;
      }

      LOG(L"Calling gethostbyname");

      AnsiString ansi;
      serverName.convert(ansi);

      HOSTENT* host = gethostbyname(ansi.c_str());
      if (host && host->h_addr_list[0])
      {
         struct in_addr a;
         
         ::CopyMemory(&a.S_un.S_addr, host->h_addr_list[0], sizeof a.S_un.S_addr);
         result = inet_ntoa(a);

         break;
      }

      LOG(String::format(L"WSAGetLastError = 0x%1!0X", WSAGetLastError()));
   }
   while (0);

   LOG(result);

   return result;
}



// Find the DNS server that is authoritative for registering the given server
// name, i.e. what server would register the name.  Returns NO_ERROR on
// success, or a DNS status code (a win32 error) on failure.  On failure, the
// out parameters are all empty strings.
// 
// serverName - in, candidate name for registration.  This value should not be the
// empty string.
// 
// authZone - out, the zone the name would be registered in.
// 
// authServer - out, the name of the DNS server that would have the
// registration.
// 
// authServerIpAddress - out, textual representation of the IP address of the
// server named by authServer.

DNS_STATUS
FindAuthoritativeServer(
   const String& serverName,
   String&       authZone,
   String&       authServer,
   String&       authServerIpAddress)
{
   LOG_FUNCTION2(FindAuthoritativeServer, serverName);
   ASSERT(!serverName.empty());

   authZone.erase();
   authServer.erase();
   authServerIpAddress.erase();

   // ensure that the server name ends with a "." so that we have a stop
   // point for our loop

   String currentName = FullyQualifyDnsName(serverName);

   DNS_STATUS result = NO_ERROR;
   DNS_RECORD* queryResults = 0;

   while (!currentName.empty())
   {
      result =
         MyDnsQuery(
            currentName,
            DNS_TYPE_SOA,
            DNS_QUERY_BYPASS_CACHE,
            queryResults);
      if (
            result == ERROR_TIMEOUT
         || result == DNS_ERROR_RCODE_SERVER_FAILURE)
      {
         // we bail out entirely

         LOG(L"failed to find autoritative server.");

         break;
      }

      // search for an SOA RR

      DNS_RECORD* soaRecord =
         queryResults ? FindSoaRecord(queryResults) : 0;
      if (soaRecord)
      {
         // collect return values, and we're done.

         LOG(L"autoritative server found");

         authZone            = soaRecord->pName;                      
         authServer          = soaRecord->Data.SOA.pNamePrimaryServer;
         authServerIpAddress = GetIpAddress(authServer);              

         break;
      }

      // no SOA record found.

      if (currentName == L".")
      {
         // We've run out of names to query.  This situation is so unlikely
         // that the DNS server would have to be seriously broken to put
         // us in this state.  So this is almost an assert case.

         LOG(L"Root zone reached without finding SOA record!");
         
         result = DNS_ERROR_ZONE_HAS_NO_SOA_RECORD;
         break;
      }

      // whack off the leftmost label, and iterate again on the parent
      // zone.

      currentName = Dns::GetParentDomainName(currentName);

      MyDnsRecordListFree(queryResults);
      queryResults = 0;
   }

   MyDnsRecordListFree(queryResults);

   LOG(String::format(L"result = %1!08X!", result));
   LOG(L"authZone            = " + authZone);           
   LOG(L"authServer          = " + authServer);         
   LOG(L"authServerIpAddress = " + authServerIpAddress);

   return result;
}

            

DNS_STATUS
MyDnsUpdateTest(const String& name)
{
   LOG_FUNCTION2(MyDnsUpdateTest, name);
   ASSERT(!name.empty());

   LOG(L"Calling DnsUpdateTest");
   LOG(               L"hContextHandle : 0");
   LOG(String::format(L"pszName        : %1", name.c_str()));
   LOG(               L"fOptions       : 0");
   LOG(               L"aipServers     : 0");

   DNS_STATUS status =
      ::DnsUpdateTest(
         0,
         const_cast<wchar_t*>(name.c_str()),
         0,
         0);

   LOG(String::format(L"status = %1!08X!", status));
   LOG(MyDnsStatusString(status));

   return status;
}



// Returns result code that corresponds to what messages to be displayed and
// what radio buttons to make available as a result of the diagnostic.
// 
// Also returns thru out parameters information to be included in the
// messages.
//
// serverName - in, the name of the domain contoller to be registered.
// 
// errorCode - out, the DNS error code (a win32 error) encountered when
// running the diagnostic.
//
// authZone - out, the zone the name would be registered in.
// 
// authServer - out, the name of the DNS server that would have the
// registration.
// 
// authServerIpAddress - out, textual representation of the IP address of the
// server named by authServer.

DynamicDnsPage::DiagnosticCode
DynamicDnsPage::DiagnoseDnsRegistration(
   const String&  serverName,
   DNS_STATUS&    errorCode,
   String&        authZone,
   String&        authServer,
   String&        authServerIpAddress)
{
   LOG_FUNCTION(DynamicDnsPage::DiagnoseDnsRegistration);
   ASSERT(!serverName.empty());

   DiagnosticCode result = UNEXPECTED_FINDING_SERVER;
      
   errorCode =
      FindAuthoritativeServer(
         serverName,
         authZone,
         authServer,
         authServerIpAddress);

   switch (errorCode)
   {
      case NO_ERROR:
      {
         if (authZone == L".")
         {
            // Message 8

            LOG(L"authZone is root");

            result = ZONE_IS_ROOT;
         }
         else
         {
            errorCode = MyDnsUpdateTest(serverName);

            switch (errorCode)
            {
               case DNS_ERROR_RCODE_NO_ERROR:
               case DNS_ERROR_RCODE_YXDOMAIN:
               {
                  // Message 1

                  LOG(L"DNS registration support verified.");

                  result = SUCCESS;
                  break;
               }
               case DNS_ERROR_RCODE_NOT_IMPLEMENTED:
               case DNS_ERROR_RCODE_REFUSED:
               {
                  // Message 2

                  LOG(L"Server does not support update");

                  result = SERVER_CANT_UPDATE;
                  break;
               }
               default:
               {
                  // Message 3

                  result = ERROR_TESTING_SERVER;
                  break;
               }
            }
         }

         break;            
      }
      case DNS_ERROR_RCODE_SERVER_FAILURE:
      {
         // Message 6

         result = ERROR_FINDING_SERVER;
         break;
      }
      case ERROR_TIMEOUT:
      {
         // Message 11

         result = TIMEOUT;
         break;
      }
      default:
      {
         // Message 4

         LOG(L"Unexpected error");

         result = UNEXPECTED_FINDING_SERVER;
         break;
      }
   }

   LOG(String::format(L"DiagnosticCode = %1!x!", result));

   return result;
}



// void
// DumpSel(HWND richEdit)
// {
//    CHARRANGE range;
//    RichEdit_GetSel(richEdit, range);
//    
//    LOG(String::format("cpMin = %1!d! cpMax = %1!d!", range.cpMin, range.cpMax));
// }



void
DynamicDnsPage::UpdateMessageWindow(const String& message)
{
   LOG_FUNCTION(UpdateMessageWindow);
   ASSERT(!message.empty());

   // this should have been set before we get here
   
   ASSERT(!details.empty());

   HWND richEdit = Win::GetDlgItem(hwnd, IDC_MESSAGE);

   // Clear out the window of any prior contents. This is needed because in
   // the code that follows, we take advantage of the fact that the set text
   // functions create an empty selection to the end of the text, and
   // subsequent ST_SELECTION type calls to set text will append at that
   // point.
   
   Win::RichEdit_SetText(richEdit, ST_DEFAULT, L"");

   static const String RTF_HEADER_ON(   
      L"{\\rtf"                // RTF header
      L"\\pard"                // start default paragraph style
      L"\\sa100"               // whitespace after paragraph = 100 twips
      L"\\b ");                // bold on

   static const String RTF_HEADER_OFF(      
      L"\\b0"                  // bold off
      L"\\par "                // end paragraph
      L"}");                   // end RTF

   Win::RichEdit_SetRtfText(
      richEdit,
      ST_SELECTION,
         RTF_HEADER_ON
      +  String::load(IDS_DIAGNOSTIC_RESULTS)
      +  RTF_HEADER_OFF);
      
   Win::RichEdit_SetText(
      richEdit,
      ST_SELECTION,
         String::format(
               (testPassCount == 1)
            ?  IDS_DIAGNOSTIC_COUNTER_1
            :  IDS_DIAGNOSTIC_COUNTER_N,
            testPassCount)
      +  L"\r\n\r\n"
      +  message
      + L"\r\n\r\n");

   if (!helpTopicLink.empty())
   {
      // We have help to show, so insert a line with a link to click for it.
      
      Win::RichEdit_SetText(
         richEdit,
         ST_SELECTION,
         String::load(IDS_DIAGNOSTIC_HELP_LINK_PRE));
   
      // At this point, we want to insert the help link and set it to the link
      // style.  We do this by tracking the position of the link text, and
      // then selecting that text, and then setting the selection to the link
      // style.

      CHARRANGE beginRange;
      Win::RichEdit_GetSel(richEdit, beginRange);

      Win::RichEdit_SetText(
         richEdit,
         ST_SELECTION,
         String::load(IDS_DIAGNOSTIC_HELP_LINK));
   
      CHARRANGE endRange;
      Win::RichEdit_GetSel(richEdit, endRange);

      ASSERT(endRange.cpMin > beginRange.cpMax);
   
      Win::Edit_SetSel(richEdit, beginRange.cpMax, endRange.cpMin);

      CHARFORMAT2 format;

      // REVIEWED-2002/02/26-sburns correct byte count passed.
      
      ::ZeroMemory(&format, sizeof format);

      format.dwMask    = CFM_LINK;
      format.dwEffects = CFE_LINK;
   
      Win::RichEdit_SetCharacterFormat(richEdit, SCF_SELECTION, format);

      // set the selection back to the end of where the link was inserted.
   
      Win::RichEdit_SetSel(richEdit, endRange);
   
      // now continue to the end
   
      Win::RichEdit_SetText(
         richEdit,
         ST_SELECTION,
         String::load(IDS_DIAGNOSTIC_HELP_LINK_POST) + L"\r\n\r\n");
   }
      
   Win::RichEdit_SetRtfText(
      richEdit,
      ST_SELECTION,
         RTF_HEADER_ON
      +  String::load(IDS_DETAILS)
      +  RTF_HEADER_OFF);

   Win::RichEdit_SetText(richEdit, ST_SELECTION, details + L"\r\n\r\n");
}

  


// do the test, update the text on the page, update the radio buttons
// enabled state, choose a radio button default if neccessary

void
DynamicDnsPage::DoDnsTestAndUpdatePage()
{
   LOG_FUNCTION(DynamicDnsPage::DoDnsTestAndUpdatePage);

   // this might take a while.

   Win::WaitCursor cursor;

   State& state  = State::GetInstance();       
   String domain = state.GetNewDomainDNSName();

   DNS_STATUS errorCode = 0;
   String authZone;
   String authServer;
   String authServerIpAddress;
   String serverName = L"_ldap._tcp.dc._msdcs." + domain;

   diagnosticResultCode =
      DiagnoseDnsRegistration(
         serverName,
         errorCode,
         authZone,
         authServer,
         authServerIpAddress);
   ++testPassCount;

   String message;
   int    defaultButton = IDC_IGNORE;

   switch (diagnosticResultCode)
   {
      // Message 1

      case SUCCESS:
      {
         message = String::load(IDS_DYN_DNS_MESSAGE_SUCCESS);

         String errorMessage;
         if (errorCode == DNS_ERROR_RCODE_YXDOMAIN)
         {
            // NTRAID#NTBUG9-586579-2002/04/15-sburns
            
            errorMessage =
               String::format(
                  IDS_DNS_ERROR_RCODE_YXDOMAIN_ADDENDA,
                  serverName.c_str(),
                  authZone.c_str(),
                  serverName.c_str());
         }
         else
         {
            errorMessage = GetErrorMessage(Win32ToHresult(errorCode));
         }
            
         details =
            String::format(

               // NTRAID#NTBUG9-485456-2001/10/24-sburns
               
               IDS_DYN_DNS_DETAIL_FULL_SANS_CODE,
               authServer.c_str(),
               authServerIpAddress.c_str(),
               authZone.c_str(),
               errorMessage.c_str());
         helpTopicLink = L"";
         defaultButton = IDC_IGNORE;
         ShowButtons(false);

         break;
      }

      // Message 2   

      case SERVER_CANT_UPDATE:   
      {
         message = String::load(IDS_DYN_DNS_MESSAGE_SERVER_CANT_UPDATE);
         details =
            String::format(
               IDS_DYN_DNS_DETAIL_FULL,
               authServer.c_str(),
               authServerIpAddress.c_str(),
               authZone.c_str(),
               GetErrorMessage(Win32ToHresult(errorCode)).c_str(),
               errorCode,
               MyDnsStatusString(errorCode).c_str());

         if (Dns::CompareNames(authZone, domain) == DnsNameCompareEqual)
         {
            helpTopicLink =
               L"DNSConcepts.chm::/sag_DNS_tro_dynamic_message2a.htm";
         }
         else
         {
            helpTopicLink =
               L"DNSConcepts.chm::/sag_DNS_tro_dynamic_message2b.htm";
         }
         
         defaultButton = IDC_RETRY;
         ShowButtons(true);

         break;
      }

      // Message 3

      case ERROR_TESTING_SERVER:
      {
         message = String::load(IDS_DYN_DNS_MESSAGE_ERROR_TESTING_SERVER);
         details =
            String::format(
               IDS_DYN_DNS_DETAIL_FULL,
               authServer.c_str(),
               authServerIpAddress.c_str(),
               authZone.c_str(),
               GetErrorMessage(Win32ToHresult(errorCode)).c_str(),
               errorCode,
               MyDnsStatusString(errorCode).c_str());
         helpTopicLink = "DNSConcepts.chm::/sag_DNS_tro_dynamic_message3.htm";
         defaultButton = IDC_RETRY;
         ShowButtons(true);
         break;
      }

      // Message 6

      case ERROR_FINDING_SERVER:
      {
         ASSERT(authServer.empty());
         ASSERT(authZone.empty());
         ASSERT(authServerIpAddress.empty());

         message = String::load(IDS_DYN_DNS_MESSAGE_ERROR_FINDING_SERVER);
         details =
            String::format(
               IDS_DYN_DNS_DETAIL_SCANT,
               serverName.c_str(),
               GetErrorMessage(Win32ToHresult(errorCode)).c_str(),
               errorCode,
               MyDnsStatusString(errorCode).c_str());
         helpTopicLink = "DNSConcepts.chm::/sag_DNS_tro_dynamic_message6.htm";
         defaultButton = IDC_INSTALL_DNS;
         ShowButtons(true);
         break;
      }

      // Message 8

      case ZONE_IS_ROOT:   
      {
         message =
            String::format(
               IDS_DYN_DNS_MESSAGE_ZONE_IS_ROOT,
               domain.c_str(),
               domain.c_str());
         details =
            String::format(
               IDS_DYN_DNS_DETAIL_ROOT_ZONE,
               authServer.c_str(),
               authServerIpAddress.c_str());
         helpTopicLink = L"DNSConcepts.chm::/sag_DNS_tro_dynamic_message8.htm";
         defaultButton = IDC_INSTALL_DNS;
         ShowButtons(true);
         break;
      }

      // Message 11

      case TIMEOUT:
      {
         message = String::load(IDS_DYN_DNS_MESSAGE_TIMEOUT);
         details =
            String::format(
               IDS_DYN_DNS_DETAIL_SCANT,
               serverName.c_str(),
               GetErrorMessage(Win32ToHresult(errorCode)).c_str(),
               errorCode,
               MyDnsStatusString(errorCode).c_str());
         helpTopicLink = L"DNSConcepts.chm::/sag_DNS_tro_dynamic_message11.htm";
         defaultButton = IDC_INSTALL_DNS;
         ShowButtons(true);
         break;
      }

      // Message 4

      case UNEXPECTED_FINDING_SERVER:

      // Anything else

      default:
      {
         
#ifdef DBG
         ASSERT(authServer.empty());
         ASSERT(authZone.empty());
         ASSERT(authServerIpAddress.empty());

         if (diagnosticResultCode != UNEXPECTED_FINDING_SERVER)
         {
            ASSERT(false);
         }
#endif

         message = String::load(IDS_DYN_DNS_MESSAGE_UNEXPECTED);

         details =
            String::format(
               IDS_DYN_DNS_DETAIL_SCANT,
               serverName.c_str(),
               GetErrorMessage(Win32ToHresult(errorCode)).c_str(),
               errorCode,
               MyDnsStatusString(errorCode).c_str());
         helpTopicLink = L"DNSConcepts.chm::/sag_DNS_tro_dynamic_message4.htm";
         defaultButton = IDC_RETRY;
         ShowButtons(true);
         break;
      }

   }

   UpdateMessageWindow(message);

   // success always forces the ignore option

   if (diagnosticResultCode == SUCCESS)
   {
      SelectRadioButton(IDC_IGNORE);
   }
   else
   {
      // On the first pass only, decide what radio button to set.  On
      // subsequent passes, the user will have had the chance to change the
      // button selection, so we don't change his selections.

      if (testPassCount == 1)
      {
         int button = defaultButton;

         ASSERT(diagnosticResultCode != SUCCESS);

         // if the test failed, and the wizard is running unattended, then
         // consult the answer file for the user's preference in dealing
         // with the failure.

         if (state.UsingAnswerFile())
         {
            String option =
               state.GetAnswerFileOption(AnswerFile::OPTION_AUTO_CONFIG_DNS);

            if (
                  option.empty()
               || (option.icompare(AnswerFile::VALUE_YES) == 0) )
            {
               button = IDC_INSTALL_DNS;
            }
            else
            {
               button = IDC_IGNORE;
            }
         }

         SelectRadioButton(button);
      }
   }
}



bool
DynamicDnsPage::OnSetActive()
{
   LOG_FUNCTION(DynamicDnsPage::OnSetActive);

   State& state = State::GetInstance();
   State::Operation oper = state.GetOperation(); 

   // these are the only operations for which this page is valid; i.e.
   // new domain scenarios

   if (
         oper == State::FOREST
      || oper == State::CHILD
      || oper == State::TREE)
   {
      DoDnsTestAndUpdatePage();
      needToKillSelection = true;
   }

   if (
         (  oper != State::FOREST
         && oper != State::CHILD
         && oper != State::TREE)
      || state.RunHiddenUnattended() )
   {
      LOG(L"Planning to Skip DynamicDnsPage");

      Wizard& wizard = GetWizard();

      if (wizard.IsBacktracking())
      {
         // backup once again

         wizard.Backtrack(hwnd);
         return true;
      }

      int nextPage = Validate();
      if (nextPage != -1)
      {
         LOG(L"skipping DynamicDnsPage");
         wizard.SetNextPageID(hwnd, nextPage);
         return true;
      }

      state.ClearHiddenWhileUnattended();
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



void
DumpButtons(HWND dialog)
{
   LOG(String::format(L"retry  : (%1)", Win::IsDlgButtonChecked(dialog, IDC_RETRY) ? L"*" : L" "));
   LOG(String::format(L"ignore : (%1)", Win::IsDlgButtonChecked(dialog, IDC_IGNORE) ? L"*" : L" "));
   LOG(String::format(L"install: (%1)", Win::IsDlgButtonChecked(dialog, IDC_INSTALL_DNS) ? L"*" : L" "));
}



int
DynamicDnsPage::Validate()
{
   LOG_FUNCTION(DynamicDnsPage::Validate);

   int nextPage = -1;

   do
   {
      State& state = State::GetInstance();
      State::Operation oper = state.GetOperation(); 
      
      DumpButtons(hwnd);

      if (
            oper != State::FOREST
         && oper != State::CHILD
         && oper != State::TREE)
      {
         // by definition valid, as the page does not apply

         State::GetInstance().SetAutoConfigureDNS(false);
         nextPage = IDD_RAS_FIXUP;
         break;
      }
      
      if (
            diagnosticResultCode == SUCCESS
         || Win::IsDlgButtonChecked(hwnd, IDC_IGNORE))
      {
         // You can go about your business.  Move along, move long.

         // Force ignore, even if the user previously had encountered a
         // failure and chose retry or install DNS. We do this in case the
         // user backed up in the wizard and corrected the domain name.

         State::GetInstance().SetAutoConfigureDNS(false);
         nextPage = IDD_RAS_FIXUP;
         break;
      }

      // if the radio button selection = retry, then do the test over again,
      // and stick to this page.

      if (Win::IsDlgButtonChecked(hwnd, IDC_RETRY))
      {
         DoDnsTestAndUpdatePage();
         break;
      }

      ASSERT(Win::IsDlgButtonChecked(hwnd, IDC_INSTALL_DNS));

      State::GetInstance().SetAutoConfigureDNS(true);
      nextPage = IDD_RAS_FIXUP;
      break;
   }
   while (0);

   LOG(String::format(L"nextPage = %1!d!", nextPage));

   return nextPage;
}



bool
DynamicDnsPage::OnWizBack()
{
   LOG_FUNCTION(DynamicDnsPage::OnWizBack);

   // make sure we reset the auto-config flag => the only way it gets set
   // it on the 'next' button.
   
   State::GetInstance().SetAutoConfigureDNS(false);

   return DCPromoWizardPage::OnWizBack();
}



bool
DynamicDnsPage::OnCommand(
   HWND        windowFrom,
   unsigned    controlIdFrom,
   unsigned    code)
{
   bool result = false;
   
   switch (controlIdFrom)
   {
      case IDC_MESSAGE:
      {
         switch (code)
         {
            case EN_SETFOCUS:
            {
               if (needToKillSelection)
               {
                  // kill the text selection

                  Win::Edit_SetSel(windowFrom, 0, 0);
                  needToKillSelection = false;
                  result = true;
               }
               break;
            }
            case MultiLineEditBoxThatForwardsEnterKey::FORWARDED_ENTER:
            {
               // our subclasses mutli-line edit control will send us
               // WM_COMMAND messages when the enter key is pressed.  We
               // reinterpret this message as a press on the default button of
               // the prop sheet.
               // This workaround from phellyar.
               // NTRAID#NTBUG9-232092-2000/11/22-sburns

               HWND propSheet = Win::GetParent(hwnd);
               int defaultButtonId =
                  Win::Dialog_GetDefaultButtonId(propSheet);

               // we expect that there is always a default button on the prop sheet
               
               ASSERT(defaultButtonId);

               Win::SendMessage(
                  propSheet,
                  WM_COMMAND,
                  MAKELONG(defaultButtonId, BN_CLICKED),
                  0);

               result = true;
               break;
            }
            default:
            {
               // do nothing

               break;
            }
         }
         
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return result;
}



bool
DynamicDnsPage::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   lParam)
{
   bool result = false;
   
   if (controlIDFrom == IDC_MESSAGE)
   {
      switch (code)
      {
         case EN_LINK:
         {
            ENLINK *enlink = reinterpret_cast<ENLINK*>(lParam);
            
            if (enlink && enlink->msg == WM_LBUTTONUP)
            {
               ASSERT(!helpTopicLink.empty());

               if (!helpTopicLink.empty())
               {
                  Win::HtmlHelp(hwnd, helpTopicLink, HH_DISPLAY_TOPIC, 0);
               }
            }
            break;
         }
         default:
         {
            // do nothing

            break;
         }
      }
   }
   
   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\failurepage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// failure page
//
// 12-22-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "FailurePage.hpp"
#include "resource.h"
#include "state.hpp"



FailurePage::FailurePage()
   :
   DCPromoWizardPage(
      IDD_FAILURE,
      IDS_FAILURE_PAGE_TITLE,
      IDS_FAILURE_PAGE_SUBTITLE),
   needToKillSelection(false)         
{
   LOG_CTOR(FailurePage);
}



FailurePage::~FailurePage()
{
   LOG_DTOR(FailurePage);
}



void
FailurePage::OnInit()
{
   LOG_FUNCTION(FailurePage::OnInit);

   // Since the multi-line edit control has a bug that causes it to eat
   // enter keypresses, we will subclass the control to make it forward
   // those keypresses to the page as WM_COMMAND messages
   // This workaround from phellyar.
   // NTRAID#NTBUG9-232092-2001/07/23-sburns

   multiLineEdit.Init(Win::GetDlgItem(hwnd, IDC_MESSAGE));
}



bool
FailurePage::OnSetActive()
{
   LOG_FUNCTION(FailurePage::OnSetActive);

   State& state = State::GetInstance();
   if (
         state.GetOperationResultsCode() == State::SUCCESS
      || state.RunHiddenUnattended() )
   {
      LOG(L"planning to Skip failure page");

      Wizard& wiz = GetWizard();

      if (wiz.IsBacktracking())
      {
         // backup once again
         wiz.Backtrack(hwnd);
         return true;
      }

      int nextPage = FailurePage::Validate();
      if (nextPage != -1)
      {
         wiz.SetNextPageID(hwnd, nextPage);
         return true;
      }

      state.ClearHiddenWhileUnattended();
   }

   Win::SetDlgItemText(hwnd, IDC_MESSAGE, state.GetFailureMessage());
   needToKillSelection = true;   

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



int
FailurePage::Validate()
{
   LOG_FUNCTION(FailurePage::Validate);

   return IDD_FINISH;
}



bool
FailurePage::OnCommand(
   HWND        windowFrom,
   unsigned    controlIdFrom,
   unsigned    code)
{
   bool result = false;
   
   switch (controlIdFrom)
   {
      case IDCANCEL:
      {
         // multi-line edit control eats escape keys.  This is a workaround
         // from ericb, to forward the message to the prop sheet.

         Win::SendMessage(
            Win::GetParent(hwnd),
            WM_COMMAND,
            MAKEWPARAM(controlIdFrom, code),
            (LPARAM) windowFrom);
         break;   
      }
      case IDC_MESSAGE:
      {
         switch (code)
         {
            case EN_SETFOCUS:
            {
               if (needToKillSelection)
               {
                  // kill the text selection

                  Win::Edit_SetSel(windowFrom, -1, -1);
                  needToKillSelection = false;
                  result = true;
               }
               break;
            }
            case MultiLineEditBoxThatForwardsEnterKey::FORWARDED_ENTER:
            {
               // our subclasses mutli-line edit control will send us
               // WM_COMMAND messages when the enter key is pressed.  We
               // reinterpret this message as a press on the default button of
               // the prop sheet.
               // This workaround from phellyar.
               // NTRAID#NTBUG9-232092-2001/07/23-sburns

               // CODEWORK: There are several instances of this code so far;
               // looks like it merits a common base class.
   
               HWND propSheet = Win::GetParent(hwnd);
               int defaultButtonId =
                  Win::Dialog_GetDefaultButtonId(propSheet);
   
               // we expect that there is always a default button on the prop sheet
                  
               ASSERT(defaultButtonId);
   
               Win::SendMessage(
                  propSheet,
                  WM_COMMAND,
                  MAKELONG(defaultButtonId, BN_CLICKED),
                  0);
   
               result = true;
               break;
            }
         }
         break;
      }
      default:
      {
         // do nothing
         
         break;
      }
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\finish.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// finish page
//
// 12-19-97 sburns



#ifndef FINISH_HPP_INCLUDED
#define FINISH_HPP_INCLUDED



#include "MultiLineEditBoxThatForwardsEnterKey.hpp"



class FinishPage : public WizardPage
{
   public:

   FinishPage();

   protected:

   virtual ~FinishPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIdFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   virtual
   bool
   OnWizFinish();

   private:

   bool needToKillSelection;
   MultiLineEditBoxThatForwardsEnterKey multiLineEdit;

   // not defined; no copying allowed
   
   FinishPage(const FinishPage&);
   const FinishPage& operator=(const FinishPage&);
};



#endif   // FINISH_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\finish.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// finish page
//
// 12-19-97 sburns



#include "headers.hxx"
#include "finish.hpp"
#include "resource.h"
#include "common.hpp"
#include "state.hpp"



FinishPage::FinishPage()
   :
   WizardPage(
      IDD_FINISH,
      IDS_FINISH_PAGE_TITLE,
      IDS_FINISH_PAGE_SUBTITLE,
      false),
   needToKillSelection(false)   
{
   LOG_CTOR(FinishPage);
}



FinishPage::~FinishPage()
{
   LOG_DTOR(FinishPage);
}



void
FinishPage::OnInit()
{
   LOG_FUNCTION(FinishPage::OnInit);

   SetLargeFont(hwnd, IDC_BIG_BOLD_TITLE);
   Win::PropSheet_CancelToClose(Win::GetParent(hwnd));

   // Since the multi-line edit control has a bug that causes it to eat
   // enter keypresses, we will subclass the control to make it forward
   // those keypresses to the page as WM_COMMAND messages
   // This workaround from phellyar.
   // NTRAID#NTBUG9-232092-2001/07/02-sburns

   multiLineEdit.Init(Win::GetDlgItem(hwnd, IDC_MESSAGE));
}



static
String
getCompletionMessage()
{
   LOG_FUNCTION(getCompletionMessage);

   String message;
   State& state = State::GetInstance();
   State::Operation operation = state.GetOperation();

   if (state.GetOperationResultsCode() == State::SUCCESS)
   {
      switch (operation)
      {
         case State::REPLICA:
         case State::FOREST:
         case State::TREE:
         case State::CHILD:
         {
            String domain =
                  operation == State::REPLICA
               ?  state.GetReplicaDomainDNSName()
               :  state.GetNewDomainDNSName();
            message = String::format(IDS_FINISH_PROMOTE, domain.c_str());

            String site = state.GetInstalledSite();
            if (!site.empty())
            {
               message +=
                  String::format(
                     IDS_FINISH_SITE,
                     site.c_str());
            }
            break;
         }
         case State::DEMOTE:
         {
            message = String::load(IDS_FINISH_DEMOTE);
            break;
         }
         case State::ABORT_BDC_UPGRADE:
         {
            message = String::load(IDS_FINISH_ABORT_BDC_UPGRADE);
            break;
         }
         case State::NONE:
         default:
         {
            ASSERT(false);
            break;
         }
      }
   }
   else
   {
      switch (operation)
      {
         case State::REPLICA:
         case State::FOREST:
         case State::TREE:
         case State::CHILD:
         {
            message = String::load(IDS_FINISH_FAILURE);
            break;
         }
         case State::DEMOTE:
         {
            message = String::load(IDS_FINISH_DEMOTE_FAILURE);
            break;
         }
         case State::ABORT_BDC_UPGRADE:
         {
            message = String::load(IDS_FINISH_ABORT_BDC_UPGRADE_FAILURE);
            break;
         }
         case State::NONE:
         default:
         {
            ASSERT(false);
            break;
         }
      }
   }

   return message + L"\r\n\r\n" + state.GetFinishMessages();
}



bool
FinishPage::OnSetActive()
{
   LOG_FUNCTION(FinishPage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_FINISH);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      Win::PropSheet_PressButton(Win::GetParent(hwnd), PSBTN_FINISH);
   }
   else
   {
      Win::SetDlgItemText(hwnd, IDC_MESSAGE, getCompletionMessage());
      needToKillSelection = true;
   }

   return true;
}



bool
FinishPage::OnCommand(
   HWND        windowFrom,
   unsigned    controlIdFrom,
   unsigned    code)
{
   bool result = false;
   
   switch (controlIdFrom)
   {
      case IDCANCEL:
      {
         // multi-line edit control eats escape keys.  This is a workaround
         // from ericb, to forward the message to the prop sheet.

         Win::SendMessage(
            Win::GetParent(hwnd),
            WM_COMMAND,
            MAKEWPARAM(controlIdFrom, code),
            (LPARAM) windowFrom);
         break;   
      }
      case IDC_MESSAGE:
      {
         switch (code)
         {
            case EN_SETFOCUS:
            {
               if (needToKillSelection)
               {
                  // kill the text selection

                  Win::Edit_SetSel(windowFrom, -1, -1);
                  needToKillSelection = false;
                  result = true;
               }
               break;
            }
            case MultiLineEditBoxThatForwardsEnterKey::FORWARDED_ENTER:
            {
               // our subclasses mutli-line edit control will send us
               // WM_COMMAND messages when the enter key is pressed.  We
               // reinterpret this message as a press on the default button of
               // the prop sheet.
               // This workaround from phellyar.
               // NTRAID#NTBUG9-232092-2001/07/02-sburns

               // CODEWORK: There are several instances of this code so far;
               // looks like it merits a common base class.
   
               HWND propSheet = Win::GetParent(hwnd);
               int defaultButtonId =
                  Win::Dialog_GetDefaultButtonId(propSheet);
   
               // we expect that there is always a default button on the prop sheet
                  
               ASSERT(defaultButtonId);
   
               Win::SendMessage(
                  propSheet,
                  WM_COMMAND,
                  MAKELONG(defaultButtonId, BN_CLICKED),
                  0);
   
               result = true;
               break;
            }
         }
         break;
      }
      default:
      {
         // do nothing
         
         break;
      }
   }

   return result;
}


            
bool
FinishPage::OnWizFinish()
{
   LOG_FUNCTION(FinishPage::OnWizFinish);

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\forceddemotionpage.hpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// forced demotion page
// NTRAID#NTBUG9-496409-2001/11/29-sburns
//
// 29 Nov 2001 sburns



#ifndef FORCEDDEMOTION_HPP_INCLUDED
#define FORCEDDEMOTION_HPP_INCLUDED



class ForcedDemotionPage : public DCPromoWizardPage
{
   public:

   ForcedDemotionPage();

   protected:

   virtual ~ForcedDemotionPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lParam);

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   ForcedDemotionPage(const ForcedDemotionPage&);
   const ForcedDemotionPage& operator=(const ForcedDemotionPage&);
};



#endif   // FORCEDDEMOTION_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\forestpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// new forest page
//
// 1-6-98 sburns



#ifndef FORESTPAGE_HPP_INCLUDED
#define FORESTPAGE_HPP_INCLUDED



class ForestPage : public DCPromoWizardPage
{
   public:

   ForestPage();

   protected:

   virtual ~ForestPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   ForestPage(const ForestPage&);
   const ForestPage& operator=(const ForestPage&);
};



#endif   // FORESTPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\forceddemotionpage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// forced demotion page
// NTRAID#NTBUG9-496409-2001/11/29-sburns
//
// 29 Nov 2001 sburns



#include "headers.hxx"
#include "page.hpp"
#include "ForcedDemotionPage.hpp"
#include "resource.h"
#include "state.hpp"



ForcedDemotionPage::ForcedDemotionPage()
   :
   DCPromoWizardPage(
      IDD_FORCE_DEMOTE,
      IDS_FORCE_DEMOTE_PAGE_TITLE,
      IDS_FORCE_DEMOTE_PAGE_SUBTITLE)
{
   LOG_CTOR(ForcedDemotionPage);
}



ForcedDemotionPage::~ForcedDemotionPage()
{
   LOG_DTOR(ForcedDemotionPage);
}



void
ForcedDemotionPage::OnInit()
{
   LOG_FUNCTION(ForcedDemotionPage::OnInit);
}



bool
ForcedDemotionPage::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   /* lParam */ )
{
//   LOG_FUNCTION(ForcedDemotionPage::OnNotify);

   bool result = false;
   
   if (controlIDFrom == IDC_JUMP)
   {
      switch (code)
      {
         case NM_CLICK:
         case NM_RETURN:
         {
            LOG(L"launching metadata help");
            
            Win::HtmlHelp(
               hwnd,
               L"adconcepts.chm::/sag_delservermetadata.htm",
               HH_DISPLAY_TOPIC,
               0);
            result = true;
         }
         default:
         {
            // do nothing
            
            break;
         }
      }
   }
   
   return result;
}


   
bool
ForcedDemotionPage::OnSetActive()
{
   LOG_FUNCTION(ForcedDemotionPage::OnSetActive);

   State& state = State::GetInstance();

   ASSERT(state.IsForcedDemotion());
   
   if (state.RunHiddenUnattended())
   {
      int nextPage = ForcedDemotionPage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



int
ForcedDemotionPage::Validate()
{
   LOG_FUNCTION(ForcedDemotionPage::Validate);

   State& state = State::GetInstance();
   ASSERT(state.GetOperation() == State::DEMOTE);

   return IDD_ADMIN_PASSWORD;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\forestpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// new forest page
//
// 1-6-98 sburns



#include "headers.hxx"
#include "resource.h"
#include "page.hpp"
#include "ForestPage.hpp"
#include "state.hpp"
#include "common.hpp"
#include <ValidateDomainName.hpp>
#include <ValidateDomainName.h>


ForestPage::ForestPage()
   :
   DCPromoWizardPage(
      IDD_NEW_FOREST,
      IDS_NEW_FOREST_PAGE_TITLE,
      IDS_NEW_FOREST_PAGE_SUBTITLE)
{
   LOG_CTOR(ForestPage);
}



ForestPage::~ForestPage()
{
   LOG_DTOR(ForestPage);
}



void
ForestPage::OnInit()
{
   LOG_FUNCTION(ForestPage::OnInit);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_DOMAIN),
      DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_DOMAIN,
         state.GetAnswerFileOption(AnswerFile::OPTION_NEW_DOMAIN_NAME));
   }
}



static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   int next =
         !Win::GetTrimmedDlgItemText(dialog, IDC_DOMAIN).empty()
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);
}



bool
ForestPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(ForestPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_DOMAIN:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            enable(hwnd);
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



bool
ForestPage::OnSetActive()
{
   LOG_FUNCTION(ForestPage::OnSetActive);
   ASSERT(State::GetInstance().GetOperation() == State::FOREST);
      
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = ForestPage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   enable(hwnd);
   return true;
}


int
ForestPage::Validate()
{
   LOG_FUNCTION(ForestPage::Validate);

   String domain = Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN);
   if (domain.empty())
   {
      popup.Gripe(hwnd, IDC_DOMAIN, IDS_MUST_ENTER_DOMAIN);
      return -1;
   }

   State& state = State::GetInstance();
   int nextPage =
         state.GetRunContext() == State::PDC_UPGRADE
      ?  IDD_FOREST_VERSION
      :  IDD_NETBIOS_NAME;

   if (WasChanged(IDC_DOMAIN))
   {
      if (
            !ValidateDomainDnsNameSyntax(
               hwnd,
               IDC_DOMAIN,
               popup,

               // only warn on non RFC names if running interactively

               !state.RunHiddenUnattended())
         || !ConfirmNetbiosLookingNameIsReallyDnsName(hwnd, IDC_DOMAIN, popup)

         // do this test last, as it is expensive

         || !ForestValidateDomainDoesNotExist(hwnd, IDC_DOMAIN, popup))
      {
         nextPage = -1;
      }
      else
      {
         ClearChanges();
      }
   }

   if (nextPage != -1)
   {
      state.SetNewDomainDNSName(domain);
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\forestversionpage.cpp ===
// Copyright (C) 1997-2001 Microsoft Corporation
//
// allow user to set forest version
// NTRAID#NTBUG9-159663-2001/04/18-sburns
//
// 18 Apr 2001 sburns



#include "headers.hxx"
#include "resource.h"
#include "page.hpp"
#include "ForestVersionPage.hpp"
#include "state.hpp"



ForestVersionPage::ForestVersionPage()
   :
   DCPromoWizardPage(
      IDD_FOREST_VERSION,
      IDS_FOREST_VERSION_PAGE_TITLE,
      IDS_FOREST_VERSION_PAGE_SUBTITLE)
{
   LOG_CTOR(ForestVersionPage);
}



ForestVersionPage::~ForestVersionPage()
{
   LOG_DTOR(ForestVersionPage);
}



void
ForestVersionPage::OnInit()
{
   LOG_FUNCTION(ForestVersionPage::OnInit);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(AnswerFile::OPTION_SET_FOREST_VERSION);
      if (option.icompare(AnswerFile::VALUE_YES) == 0)
      {
         Win::CheckDlgButton(hwnd, IDC_WINDOTNET, BST_CHECKED);
         return;
      }
   }

   Win::CheckDlgButton(hwnd, IDC_WIN2K, BST_CHECKED);
}



// bool
// ForestVersionPage::OnCommand(
//    HWND        /* windowFrom */ ,
//    unsigned    controlIDFrom,
//    unsigned    code)
// {
// //   LOG_FUNCTION(ForestVersionPage::OnCommand);
// 
//    switch (controlIDFrom)
//    {
//       case IDC_WIN2K:
//       case IDC_WINDOTNET:
//       {
//          if (code == BN_CLICKED)
//          {
//             SetChanged(controlIDFrom);
//             return true;
//          }
//       }
//       default:
//       {
//          // do nothing
// 
//          break;
//       }
//    }
// 
//    return false;
// }



bool
ForestVersionPage::OnSetActive()
{
   LOG_FUNCTION(ForestVersionPage::OnSetActive);
   ASSERT(State::GetInstance().GetOperation() == State::FOREST);
      
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      // skip the page.

      LOG(L"skipping ForestVersionPage");

      Wizard& wiz = GetWizard();

      if (wiz.IsBacktracking())
      {
         // backup once again

         wiz.Backtrack(hwnd);
         return true;
      }

      int nextPage = ForestVersionPage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   return true;
}



int
ForestVersionPage::Validate()
{
   LOG_FUNCTION(ForestVersionPage::Validate);

   State& state = State::GetInstance();

   int nextPage = IDD_PATHS;
   state.SetSetForestVersionFlag(Win::IsDlgButtonChecked(hwnd, IDC_WINDOTNET));

   LOG(String::format(L"next = %1!d!", nextPage));
      
   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\gcconfirmationpage.hpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// confirm user want gc for replicate from media
//
// 28 Apr 2000 sburns



#ifndef GCCONFIRMATIONPAGE_HPP_INCLUDED
#define GCCONFIRMATIONPAGE_HPP_INCLUDED



class GcConfirmationPage : public DCPromoWizardPage
{
   public:

   GcConfirmationPage();

   protected:

   virtual ~GcConfirmationPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   GcConfirmationPage(const GcConfirmationPage&);
   const GcConfirmationPage& operator=(const GcConfirmationPage&);
};



#endif   // GCCONFIRMATIONPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\gcconfirmationpage.cpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// confirm user want gc for replicate from media
//
// 28 Apr 2000 sburns



#include "headers.hxx"
#include "resource.h"
#include "page.hpp"
#include "GcConfirmationPage.hpp"
#include "state.hpp"



GcConfirmationPage::GcConfirmationPage()
   :
   DCPromoWizardPage(
      IDD_GC_CONFIRM,
      IDS_GC_CONFIRM_PAGE_TITLE,
      IDS_GC_CONFIRM_PAGE_SUBTITLE)
{
   LOG_CTOR(GcConfirmationPage);
}



GcConfirmationPage::~GcConfirmationPage()
{
   LOG_DTOR(GcConfirmationPage);
}



void
GcConfirmationPage::OnInit()
{
   LOG_FUNCTION(GcConfirmationPage::OnInit);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(AnswerFile::OPTION_GC_CONFIRM);
      if (option.icompare(AnswerFile::VALUE_YES) == 0)
      {
         Win::CheckDlgButton(hwnd, IDC_GC_YES, BST_CHECKED);
         return;
      }
   }

   Win::CheckDlgButton(hwnd, IDC_GC_NO, BST_CHECKED);
}



bool
GcConfirmationPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(GcConfirmationPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_GC_YES:
      case IDC_GC_NO:
      {
         if (code == BN_CLICKED)
         {
            SetChanged(controlIDFrom);
            return true;
         }
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return false;
}



bool
GcConfirmationPage::OnSetActive()
{
   LOG_FUNCTION(GcConfirmationPage::OnSetActive);
   ASSERT(State::GetInstance().GetOperation() == State::REPLICA);
      
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended() || !state.IsAdvancedMode())
   {
      // skip the page.

      LOG(L"skipping GcConfirmationPage");

      Wizard& wiz = GetWizard();

      if (wiz.IsBacktracking())
      {
         // backup once again

         wiz.Backtrack(hwnd);
         return true;
      }

      int nextPage = GcConfirmationPage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   return true;
}



int
GcConfirmationPage::Validate()
{
   LOG_FUNCTION(GcConfirmationPage::Validate);

   State& state = State::GetInstance();

   int nextPage = IDD_CONFIG_DNS_CLIENT;
   state.SetRestoreGc(Win::IsDlgButtonChecked(hwnd, IDC_GC_YES));

   LOG(String::format(L"next = %1!d!", nextPage));
      
   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\indicate.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Progress Indicator class
//
// 12-29-97 sburns



#include "headers.hxx"
#include "indicate.hpp"



ProgressIndicator::ProgressIndicator(
   HWND  parentDialog,
   int   messageTextResID)
   :
   parentDialog(parentDialog_)
{
   LOG_CTOR(ProgressIndicator);

   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(messageTextResID > 0);

   messageText = Win::GetDlgItem(parentDialog, messageTextResID);
   ASSERT(Win::IsWindow(messageText));

   showState = true;
   showControls(false);
}



ProgressIndicator::~ProgressIndicator()
{
   LOG_DTOR(ProgressIndicator);
}



void
ProgressIndicator::Update(const String& message)
{
   showControls(true);
   Win::SetWindowText(messageText, message);
}



void
ProgressIndicator::showControls(bool newState)
{
   if (newState != showState)
   {
      Win::ShowWindow(messageText, newState);
      showState = newState;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\forestversionpage.hpp ===
// Copyright (C) 1997-2001 Microsoft Corporation
//
// allow user to set forest version 
//
// 18 Apr 2001 sburns



#ifndef FORESTVERSIONPAGE_HPP_INCLUDED
#define FORESTVERSIONPAGE_HPP_INCLUDED



class ForestVersionPage : public DCPromoWizardPage
{
   public:

   ForestVersionPage();

   protected:

   virtual ~ForestVersionPage();

   // Dialog overrides

   // virtual
   // bool
   // OnCommand(
   //    HWND        windowFrom,
   //    unsigned    controlIDFrom,
   //    unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   ForestVersionPage(const ForestVersionPage&);
   const ForestVersionPage& operator=(const ForestVersionPage&);
};



#endif   // FORESTVERSIONPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\getcredentialsdialog.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Dlg to get credentials for browsing domain forest
//
// 1-8-98 sburns



#ifndef GETCREDENTIALSDIALOG_HPP_INCLUDED
#define GETCREDENTIALSDIALOG_HPP_INCLUDED


                        
class GetCredentialsDialog : public Dialog
{
   public:

   explicit
   GetCredentialsDialog(const String& failureMessage);

   virtual ~GetCredentialsDialog();

   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   void
   Enable();

   String failureMessage;

   // not defined: no copying allowed

   GetCredentialsDialog(const GetCredentialsDialog&);
   const GetCredentialsDialog& operator=(const GetCredentialsDialog&);
};



#endif   // GETCREDENTIALSDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\getcredentialsdialog.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Dlg to get credentials for browsing domain forest
//
// 1-8-98 sburns



#include "headers.hxx"
#include "GetCredentialsDialog.hpp"
#include "resource.h"
#include "state.hpp"
#include "ds.hpp"
#include "common.hpp"
#include "CredentialUiHelpers.hpp"



static const DWORD HELP_MAP[] =
{
   0, 0
};



GetCredentialsDialog::GetCredentialsDialog(const String& failureMessage_)
   :
   Dialog(IDD_NEW_CREDENTIALS, HELP_MAP),
   failureMessage(failureMessage_)
{
   LOG_CTOR(GetCredentialsDialog);
   ASSERT(!failureMessage.empty());

   CredUIInitControls();
}



GetCredentialsDialog::~GetCredentialsDialog()
{
   LOG_DTOR(GetCredentialsDialog);
}



void
GetCredentialsDialog::Enable()
{
// LOG_FUNCTION(GetCredentialsDialog::Enable);

   bool okEnabled =
         !CredUi::GetUsername(Win::GetDlgItem(hwnd, IDC_CRED)).empty()
      && !Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN).empty();

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDOK), okEnabled);
}



String
GetCredentialMessage()
{
   LOG_FUNCTION(GetCredentialMessage);

   int id = 0;
   String arg;
   State& state = State::GetInstance();

   switch (state.GetOperation())
   {
      case State::REPLICA:
      {
         id = IDS_REPLICA_CREDENTIALS;
         arg = state.GetReplicaDomainDNSName();
         break;
      }
      case State::TREE:
      {
         id = IDS_SIBLING_CREDENTIALS;
         arg = state.GetParentDomainDnsName();
         break;
      }
      case State::CHILD:
      {
         id = IDS_PARENT_CREDENTIALS;
         arg = state.GetParentDomainDnsName();
         break;
      }
      case State::DEMOTE:
      {
         const Computer& computer = state.GetComputer();         
         arg =
            GetParentDomainDnsName(computer.GetDomainDnsName(), false);
         if (!arg.empty())
         {
            // dc is for a child domain

            if (state.IsLastDCInDomain())
            {
               id = IDS_PARENT_DEMOTE_CREDENTIALS;
            }
            else
            {
               arg = computer.GetDomainDnsName();
               id = IDS_DOMAIN_DEMOTE_CREDENTIALS;
            }
         }
         else
         {
            // dc is for forest root or tree root domain

            arg = computer.GetForestDnsName();
            id = IDS_ROOT_DOMAIN_CREDENTIALS;
         }
         break;
      }
      case State::ABORT_BDC_UPGRADE:
      {
         id = IDS_ABORT_BDC_UPGRADE_CREDENTIALS;
         arg.erase();
         break;
      }
      case State::FOREST:
      case State::NONE:
      default:
      {
         // This may happen if the promote APIs can't create files, in
         // which case, the APIs should return an appropriate message.
         
         break;
      }
   }

   if (id)
   {
      return String::format(id, arg.c_str());
   }

   return String();
}



String
GetDefaultUserDomainName()
{
   LOG_FUNCTION(GetDefaultUserDomainName);

   String def;
   State& state = State::GetInstance();   
   switch (state.GetOperation())
   {
      case State::REPLICA:
      {
         def = state.GetReplicaDomainDNSName();
         break;
      }
      case State::TREE:
      case State::CHILD:
      {
         def = state.GetParentDomainDnsName();
         break;
      }
      case State::DEMOTE:
      {
         String parent = 
            GetParentDomainDnsName(
               State::GetInstance().GetComputer().GetDomainDnsName(), false);

         if (state.IsLastDCInDomain() && !parent.empty())
         {
            def = parent;
         }
         else
         {
            def = state.GetComputer().GetDomainDnsName();
         }
         break;
      }
      case State::FOREST:
      case State::ABORT_BDC_UPGRADE:
      {
         // no default.
         
         break;
      }
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return def;
}
   


void
GetCredentialsDialog::OnInit()
{
   LOG_FUNCTION(GetCredentialsDialog::OnInit);

   HWND hwndCred = Win::GetDlgItem(hwnd, IDC_CRED);
   Credential_SetUserNameMaxChars(hwndCred, DS::MAX_USER_NAME_LENGTH);
   Credential_SetPasswordMaxChars(hwndCred, DS::MAX_PASSWORD_LENGTH);

   // Only use the smartcard flag when the machine is joined to a domain. On a
   // standalone machine, the smartcard won't have access to any domain
   // authority to authenticate it.
   // NTRAID#NTBUG9-287538-2001/01/23-sburns
   
   State& state = State::GetInstance();
   Computer& computer = state.GetComputer();
   
   DWORD flags = CRS_NORMAL | CRS_USERNAMES;
   if (
         computer.IsJoinedToDomain()

         // can only use smartcards on replica promotions
         // NTRAID#NTBUG9-311150-2001/02/19-sburns
         
      && state.GetOperation() == State::REPLICA)
   {
      flags |= CRS_SMARTCARDS;
   }
   Credential_InitStyle(hwndCred, flags);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_DOMAIN),
      Dns::MAX_NAME_LENGTH);

   Win::SetDlgItemText(hwnd, IDC_FAILURE_MESSAGE, failureMessage);
   Win::SetDlgItemText(hwnd, IDC_MESSAGE, GetCredentialMessage());

   String domain = state.GetUserDomainName();
   if (domain.empty())
   {
      domain = GetDefaultUserDomainName();
   }
   Win::SetDlgItemText(hwnd, IDC_DOMAIN, domain);      

   CredUi::SetUsername(hwndCred, state.GetUsername());
   CredUi::SetPassword(hwndCred, state.GetPassword());

   Enable();
}



bool
GetCredentialsDialog::OnCommand(
   HWND     /* windowFrom */ ,   
   unsigned controlIDFrom,
   unsigned code)         
{
//   LOG_FUNCTION(GetCredentialsDialog::OnCommand);

   switch (controlIDFrom)
   {
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            // transfer the dialog contents to the state object.

            State& state = State::GetInstance();
            HWND hwndCred = Win::GetDlgItem(hwnd, IDC_CRED);

            state.SetUsername(CredUi::GetUsername(hwndCred));
            state.SetPassword(CredUi::GetPassword(hwndCred));
            state.SetUserDomainName(
               Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN));

            HRESULT unused = Win::EndDialog(hwnd, controlIDFrom);

            ASSERT(SUCCEEDED(unused));

            return true;
         }

         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            HRESULT unused = Win::EndDialog(hwnd, controlIDFrom);

            ASSERT(SUCCEEDED(unused));

            return true;
         }

         break;
      }
      case IDC_DOMAIN:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);         
            Enable();
            return true;
         }

         break;
      }
      case IDC_CRED:
      {
         if (code == CRN_USERNAMECHANGE)
         {
            SetChanged(controlIDFrom);         
            Enable();
            return true;
         }

         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\indicate.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Progress Indicator class
//
// 12-29-97 sburns



#ifndef INDICATE_HPP_INCLUDED
#define INDICATE_HPP_INCLUDED



class ProgressIndicator
{
   public:

   // obtain the HWND of a dialog containing a static text control and
   // a progress bar control.  Then, constuct a ProgressIndicator
   // object from the HWND and the resource ids of the controls.

   ProgressIndicator(
      HWND  parentDialog,
      int   messageTextResID);

   ~ProgressIndicator();

   void
   Update(const String& message);

   private:

   void
   showControls(bool newState);

   HWND  parentDialog;
   HWND  messageText;
   bool  showState;

   // not implemented: no copying allowed
   ProgressIndicator(const ProgressIndicator&);
   const ProgressIndicator& operator=(const ProgressIndicator&);
};



#endif   // PROGRESS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\installtcpippage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// install tcp/ip page
//
// 12-18-97 sburns



#ifndef INSTALLTCPIPPAGE_HPP_INCLUDED
#define INSTALLTCPIPPAGE_HPP_INCLUDED



#include "page.hpp"



class InstallTcpIpPage : public DCPromoWizardPage
{
   public:

   InstallTcpIpPage();

   protected:

   virtual ~InstallTcpIpPage();

   // Dialog overrides

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lparam);
   
   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   InstallTcpIpPage(const InstallTcpIpPage&);
   const InstallTcpIpPage& operator=(const InstallTcpIpPage&);
};



#endif   // INSTALLTCPIPPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\installtcpippage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// install tcp/ip page
//
// 12-18-97 sburns



#include "headers.hxx"
#include "InstallTcpIpPage.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"



// artshel recommends that we use WSAIoctl + SIO_ADDRESS_LIST_QUERY instead of
// GetIpAddrTable because "it's more "official" and less likely to change,
// which means less work for everyone when we upgrade/revise IPHLPAPI," but
// confirms that for Whistler, they are equivalent.
// NTRAID#NTBUG9--2001/04/24-sburns

// sample code:

// // 
// // DWORD
// // GetIPv4Addresses(
// //     IN LPSOCKET_ADDRESS_LIST *ppList)
// // {
// //     LPSOCKET_ADDRESS_LIST pList = NULL;
// //     ULONG                 ulSize = 0;
// //     DWORD                 dwErr;
// //     DWORD                 dwBytesReturned;
// //     SOCKET                s;
// // 
// //     *ppList = NULL;
// // 
// //     s = socket(AF_INET, SOCK_DGRAM, 0);
// //     if (s == INVALID_SOCKET)
// //         return WSAGetLastError();
// // 
// //     for (;;) {
// //         dwErr = WSAIoctl(s, SIO_ADDRESS_LIST_QUERY, NULL, 0, pList, ulSize, 
// //                          &dwBytesReturned, NULL, NULL);
// // 
// //         if (!dwErr) {
// //             break;
// //         }
// // 
// //         if (pList) {
// //             FREE(pList);
// //             pList = NULL;
// //         }
// //     
// //         dwErr = WSAGetLastError();
// //         if (dwErr != WSAEFAULT)
// //             break;
// //     
// //         pList = MALLOC(dwBytesReturned);
// //         if (!pList) {
// //             dwErr = ERROR_NOT_ENOUGH_MEMORY;
// //             break;
// //         }
// // 
// //         ulSize = dwBytesReturned;
// //     }
// // 
// //     closesocket(s);
// // 
// //     *ppList = pList;
// //     return dwErr;
// // }



// Returns true if tcp/ip is "working" (can send/receive packets on at least
// one IP address.

bool
IsTcpIpFunctioning()
{
   LOG_FUNCTION(IsTcpIpFunctioning);

   bool result = false;

   // As per nksrin, we will call GetIpAddrTable.  If no addresses are in
   // the table, then the IP stack is not in a state to send/rcv packets
   // with the rest of the world

   HRESULT hr = S_OK;
   BYTE* buf = 0;
   do
   {
      // first, determine the size of the table

      ULONG tableSize = 0;
      DWORD err = ::GetIpAddrTable(0, &tableSize, FALSE);
      if (err != ERROR_INSUFFICIENT_BUFFER)
      {
         LOG(L"GetIpAddrTable for table size failed");
         LOG_HRESULT(Win32ToHresult(err));
         break;
      }

      // allocate space for the table.

      buf = new BYTE[tableSize + 1];

      // REVIEWED-2002/02/26-sburns correct byte count passed.
      
      ::ZeroMemory(buf, tableSize + 1);
      
      PMIB_IPADDRTABLE table = reinterpret_cast<PMIB_IPADDRTABLE>(buf);

      LOG(L"Calling GetIpAddrTable");

      hr =
         Win32ToHresult(
            ::GetIpAddrTable(
               table,
               &tableSize,
               FALSE));
      BREAK_ON_FAILED_HRESULT2(hr, L"GetIpAddrTable failed");

      LOG(String::format(L"dwNumEntries: %1!d!", table->dwNumEntries));

      for (DWORD i = 0; i < table->dwNumEntries; ++i)
      {
         DWORD addr = table->table[i].dwAddr;
         LOG(String::format(L"entry %1!d!", i));
         LOG(String::format(
            L"dwAddr %1!X! (%2!d!.%3!d!.%4!d!.%5!d!)",
            addr,
				((BYTE*)&addr)[0],
				((BYTE*)&addr)[1],
				((BYTE*)&addr)[2],
				((BYTE*)&addr)[3]));

         // skip loopback, etc.

         if (
               INADDR_ANY        == addr
            || INADDR_BROADCAST  == addr
            || INADDR_LOOPBACK   == addr
            || 0x0100007f        == addr )
         {
            LOG(L"is loopback/broadcast -- skipping");

            continue;
         }

         // Exclude MCAST addresses (class D).

         if (
               IN_CLASSA(htonl(addr))
            || IN_CLASSB(htonl(addr))
            || IN_CLASSC(htonl(addr)) )
         {
            LOG(L"is class A/B/C");

            result = true;
            break;
         }

         LOG(L"not class A/B/C -- skipping");
      }
   }
   while (0);

   delete[] buf;

   LOG(String::format(L"TCP/IP %1 functioning", result ? L"is" : L"is NOT"));

   return result;
}



InstallTcpIpPage::InstallTcpIpPage()
   :
   DCPromoWizardPage(
      IDD_INSTALL_TCPIP,
      IDS_INSTALL_TCPIP_PAGE_TITLE,
      IDS_INSTALL_TCPIP_PAGE_SUBTITLE)
{
   LOG_CTOR(InstallTcpIpPage);
}



InstallTcpIpPage::~InstallTcpIpPage()
{
   LOG_DTOR(InstallTcpIpPage);
}



void
InstallTcpIpPage::OnInit()
{
   LOG_FUNCTION(InstallTcpIpPage::OnInit);
}



bool
InstallTcpIpPage::OnSetActive()
{
   LOG_FUNCTION(InstallTcpIpPage::OnSetActive);

   State& state = State::GetInstance();   
   if (
         state.RunHiddenUnattended()
      || (IsTcpIpInstalled() && IsTcpIpFunctioning()) )
   {
      LOG(L"Planning to Skip InstallTcpIpPage");

      Wizard& wizard = GetWizard();

      if (wizard.IsBacktracking())
      {
         // backup once again

         wizard.Backtrack(hwnd);
         return true;
      }

      int nextPage = Validate();
      if (nextPage != -1)
      {
         LOG(L"skipping InstallTcpIpPage");
         wizard.SetNextPageID(hwnd, nextPage);
         return true;
      }

      state.ClearHiddenWhileUnattended();
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



bool
InstallTcpIpPage::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   /* lParam */ )
{
//   LOG_FUNCTION(InstallTcpIpPage::OnNotify);

   bool result = false;
   
   if (controlIDFrom == IDC_JUMP)
   {
      switch (code)
      {
         case NM_CLICK:
         case NM_RETURN:
         {
            ShowTroubleshooter(hwnd, IDS_INSTALL_TCPIP_HELP_TOPIC);
            result = true;
         }
         default:
         {
            // do nothing
            
            break;
         }
      }
   }
   
   return result;
}



int
InstallTcpIpPage::Validate() 
{
   LOG_FUNCTION(InstallTcpIpPage::Validate);

   int nextPage = -1;
   if (IsTcpIpInstalled() && IsTcpIpFunctioning())
   {
      State& state = State::GetInstance();
      switch (state.GetRunContext())
      {
         case State::BDC_UPGRADE:
         {
            ASSERT(state.GetOperation() == State::REPLICA);
            nextPage = IDD_REPLICATE_FROM_MEDIA; // IDD_CONFIG_DNS_CLIENT;
            break;
         }
         case State::PDC_UPGRADE:
         {
            nextPage = IDD_NEW_DOMAIN;
            break;
         }
         case State::NT5_STANDALONE_SERVER:
         case State::NT5_MEMBER_SERVER:
         {
            nextPage = IDD_REPLICA_OR_DOMAIN;
            break;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }
   }
   else
   {
      String message = String::load(IDS_INSTALL_TCPIP_FIRST);

      popup.Info(hwnd, message);
   }


   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\netbiosnamepage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// netbios domain name page
//
// 1-6-98 sburns



#ifndef NETBIOSNAMEPAGE_HPP_INCLUDED
#define NETBIOSNAMEPAGE_HPP_INCLUDED



class NetbiosNamePage : public DCPromoWizardPage
{
   public:

   NetbiosNamePage();

   protected:

   virtual ~NetbiosNamePage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage oveerrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   NetbiosNamePage(const NetbiosNamePage&);
   const NetbiosNamePage& operator=(const NetbiosNamePage&);
};



#endif   // NETBIOSNAMEPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\multilineeditboxthatforwardsenterkey.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// multi-line edit box control wrapper
//
// 22 Nov 2000 sburns
//
// added to fix NTRAID#NTBUG9-232092-2000/11/22-sburns



#ifndef MULTILINEEDITBOXTHATFORWARDSENTERKEY_HPP_INCLUDED
#define MULTILINEEDITBOXTHATFORWARDSENTERKEY_HPP_INCLUDED



#include "ControlSubclasser.hpp"



// Class for hooking the window proc of a multi-line edit control to cause
// it to forward enter keypresses to its parent window as WM_COMMAND
// messages.

class MultiLineEditBoxThatForwardsEnterKey : public ControlSubclasser
{
   public:

   static const WORD FORWARDED_ENTER = 1010;
   
   MultiLineEditBoxThatForwardsEnterKey();

   virtual 
   ~MultiLineEditBoxThatForwardsEnterKey();



   // subclasses the edit control
   //
   // editControl - in, handle to the edit control to be hooked.  This must be
   // a handle to an edit control, or we assert and throw rotten eggs.
   
   HRESULT
   Init(HWND editControl);



   // Invoked upon receipt of any window message.
   // 
   // message - in, the message code passed to the dialog window.
   // 
   // wparam - in, the WPARAM parameter accompanying the message.
   // 
   // lparam - in, the LPARAM parameter accompanying the message.
   
   LRESULT
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);
   


   private:

   // not implemented: no copying allowed

   MultiLineEditBoxThatForwardsEnterKey(
      const MultiLineEditBoxThatForwardsEnterKey&);
   const MultiLineEditBoxThatForwardsEnterKey&
   operator=(const MultiLineEditBoxThatForwardsEnterKey&);
};



#endif   // MULTILINEEDITBOXTHATFORWARDSENTERKEY_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\multilineeditboxthatforwardsenterkey.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// multi-line edit box control wrapper
//
// 22 Nov 2000 sburns
//
// added to fix NTRAID#NTBUG9-232092-2000/11/22-sburns



#include "headers.hxx"
#include "MultiLineEditBoxThatForwardsEnterKey.hpp"



MultiLineEditBoxThatForwardsEnterKey::MultiLineEditBoxThatForwardsEnterKey()
{
   LOG_CTOR(MultiLineEditBoxThatForwardsEnterKey);
}



MultiLineEditBoxThatForwardsEnterKey::~MultiLineEditBoxThatForwardsEnterKey()
{
   LOG_DTOR(MultiLineEditBoxThatForwardsEnterKey);
}



HRESULT
MultiLineEditBoxThatForwardsEnterKey::Init(HWND editControl)
{
   LOG_FUNCTION(MultiLineEditBoxThatForwardsEnterKey::Init);

#ifdef DBG
   String className = Win::GetClassName(editControl);
   ASSERT(className == L"Edit" || className == L"RichEdit20W");
#endif   

   HRESULT hr = ControlSubclasser::Init(editControl);

   return hr;
}



LRESULT
MultiLineEditBoxThatForwardsEnterKey::OnMessage(
   UINT   message,
   WPARAM wparam, 
   LPARAM lparam) 
{
   // LOG_FUNCTION(MultiLineEditBoxThatForwardsEnterKey::OnMessage);

   switch (message)
   {
      case WM_KEYDOWN:
      {
		  switch (wparam)
         {
            case VK_RETURN:
            {
               // Send the parent window a WM_COMMAND message with IDOK as
               // the notification code.
               
               Win::SendMessage(
                  Win::GetParent(hwnd),
                  WM_COMMAND,
                  MAKELONG(::GetDlgCtrlID(hwnd), FORWARDED_ENTER),
                  reinterpret_cast<LPARAM>(hwnd));
               break;
            }
            default:
            {
               // do nothing

               break;
            }
         }

         break;
      }
      case EM_SETSEL:
      {
         // If just so happens that when the control gets focus, it selects
         // all of its text. When it does this, instead of passing -1 as
         // the LPARAM, it passes 7fffffff. Since we hate that full select
         // behavior, and ES_NOHIDESEL doesn't appear to affect it, we detect
         // it and snuff the message.
         // NTRAID#NTBUG9-498571-2001/11/21-sburns
         
         if ((wparam == 0) && ((int) lparam == 0x7fffffff))
         {
            // eat the message.
            
            return 0;
         }
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return ControlSubclasser::OnMessage(message, wparam, lparam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\newdomainpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// New domain page
//
// 9 Feb 2000 sburns



#include "headers.hxx"
#include "page.hpp"
#include "NewDomainPage.hpp"
#include "resource.h"
#include "state.hpp"



NewDomainPage::NewDomainPage()
   :
   DCPromoWizardPage(
      IDD_NEW_DOMAIN,
      IDS_NEW_DOMAIN_PAGE_TITLE,
      IDS_NEW_DOMAIN_PAGE_SUBTITLE)
{
   LOG_CTOR(NewDomainPage);
}



NewDomainPage::~NewDomainPage()
{
   LOG_DTOR(NewDomainPage);
}



int
CheckForWin2kOptions(const State& state)
{
   LOG_FUNCTION(CheckForWin2kOptions);

   int result = IDC_FOREST;

   // look for old (win2k) options

   String treeOrChild  = state.GetAnswerFileOption(L"TreeOrChild").to_upper(); 
   String createOrJoin = state.GetAnswerFileOption(L"CreateOrJoin").to_upper();

   static const String TREE(L"TREE");
   static const String CREATE(L"CREATE");

   do
   {
      // we set defaults such that they are the same as in win2k

      if (treeOrChild != TREE)
      {
         result = IDC_CHILD;
         break;
      }

      if (createOrJoin != CREATE)
      {
         result = IDC_TREE;
      }
   }
   while (0);

   return result;
}



void
NewDomainPage::OnInit()
{
   LOG_FUNCTION(NewDomainPage::OnInit);

   State& state = State::GetInstance();

   int button = IDC_FOREST;
   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(AnswerFile::OPTION_NEW_DOMAIN);

      // NewDomain trumps the old TreeOrChild/CreateOrJoin options.

      if (option.empty())
      {
         button = CheckForWin2kOptions(state);
      }
      else if (option.icompare(AnswerFile::VALUE_TREE) == 0)
      {
         button = IDC_TREE;
      }
      else if (option.icompare(AnswerFile::VALUE_CHILD) == 0)
      {
         button = IDC_CHILD;
      }
   }

   Win::CheckDlgButton(hwnd, button, BST_CHECKED);
}



bool
NewDomainPage::OnSetActive()
{
   LOG_FUNCTION(NewDomainPage::OnSetActive);
   
   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = NewDomainPage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



int
NewDomainPage::Validate()
{
   LOG_FUNCTION(NewDomainPage::Validate);

   State& state = State::GetInstance();
   int nextPage = -1;

   if (Win::IsDlgButtonChecked(hwnd, IDC_CHILD))
   {
      state.SetOperation(State::CHILD);
      nextPage = IDD_CONFIG_DNS_CLIENT;
   }
   else if (Win::IsDlgButtonChecked(hwnd, IDC_TREE))
   {
      state.SetOperation(State::TREE);
      nextPage = IDD_CONFIG_DNS_CLIENT;
   }
   else if (Win::IsDlgButtonChecked(hwnd, IDC_FOREST))
   {
      state.SetOperation(State::FOREST);
      nextPage = IDD_DNS_ON_NET;
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\netbiosnamepage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// netbios domain name page
//
// 1-6-98 sburns



#include "headers.hxx"
#include "page.hpp"
#include "NetbiosNamePage.hpp"
#include "common.hpp"
#include "resource.h"
#include "state.hpp"
#include "ds.hpp"
#include <ValidateDomainName.hpp>
#include <ValidateDOmainName.h>


NetbiosNamePage::NetbiosNamePage()
   :
   DCPromoWizardPage(
      IDD_NETBIOS_NAME,
      IDS_NETBIOS_NAME_PAGE_TITLE,
      IDS_NETBIOS_NAME_PAGE_SUBTITLE)
{
   LOG_CTOR(NetbiosNamePage);
}



NetbiosNamePage::~NetbiosNamePage()
{
   LOG_DTOR(NetbiosNamePage);
}



void
NetbiosNamePage::OnInit()
{
   LOG_FUNCTION(NetbiosNamePage::OnInit);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_NETBIOS),
      DS::MAX_NETBIOS_NAME_LENGTH);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_NETBIOS,
         state.GetAnswerFileOption(
            AnswerFile::OPTION_NEW_DOMAIN_NETBIOS_NAME));
   }
}



static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   int next =
         !Win::GetTrimmedDlgItemText(dialog, IDC_NETBIOS).empty()
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);
}



bool
NetbiosNamePage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(NetbiosNamePage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_NETBIOS:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            enable(hwnd);
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



HRESULT
MyDsRoleDnsNameToFlatName(
   const String&  domainDNSName,
   String&        result,
   bool&          nameWasTweaked)
{
   LOG_FUNCTION(MyDsRoleDnsNameToFlatName);
   ASSERT(!domainDNSName.empty());

   nameWasTweaked = false;
   result.erase();

   LOG(L"Calling DsRoleDnsNameToFlatName");
   LOG(               L"lpServer  : (null)");
   LOG(String::format(L"lpDnsName : %1", domainDNSName.c_str()));

   PWSTR flatName = 0;
   ULONG flags = 0;
   HRESULT hr =
      Win32ToHresult(
         ::DsRoleDnsNameToFlatName(
            0, // this server
            domainDNSName.c_str(),
            &flatName,
            &flags));

   LOG_HRESULT(hr);

   if (SUCCEEDED(hr) && flatName)
   {
      LOG(String::format(L"lpFlatName   : %1", flatName));
      LOG(String::format(L"lpStatusFlag : %1!X!", flags));

      result = flatName;
      if (result.length() > DNLEN)
      {
         result.resize(DNLEN);
      }
      ::DsRoleFreeMemory(flatName);

      // the name was tweaked if it is not the default.  338443

      nameWasTweaked = !(flags & DSROLE_FLATNAME_DEFAULT);
   }

   return hr;
}



// return true if the name generated has already been validated, false
// if not.

bool
GenerateDefaultNetbiosName(HWND parent)
{
   LOG_FUNCTION(GenerateDefaultNetbiosName);
   ASSERT(Win::IsWindow(parent));

   Win::CursorSetting cursor(IDC_WAIT);

   bool result = false;

   String dnsDomainName = State::GetInstance().GetNewDomainDNSName();
   bool nameWasTweaked = false;
   String generatedName;
   HRESULT hr = 
      MyDsRoleDnsNameToFlatName(
         dnsDomainName,
         generatedName,
         nameWasTweaked);
   if (FAILED(hr))
   {
      // if the api call failed, the name could not have been validated.

      result = false;

      // fall back to just the first 15 characters of the first label

      generatedName =
         dnsDomainName.substr(0, min(DNLEN, dnsDomainName.find(L'.')));

      LOG(String::format(L"falling back to %1", generatedName.c_str()));
   }
   else
   {
      // the api validated the name for us.

      result = true;
   }

   generatedName.to_upper();

   if (generatedName.is_numeric())
   {
      // the generated name is all-numeric.  This is not allowed.  So we
      // toss it out.   368777 bis

      generatedName.erase();
      nameWasTweaked = false;
   }

   Win::SetDlgItemText(
      parent,
      IDC_NETBIOS,
      generatedName);

   // inform the user that the default NetBIOS name was adjusted due
   // to name collision on the network

   if (nameWasTweaked)
   {
      popup.Info(
         parent,
         String::format(
            IDS_GENERATED_NAME_WAS_TWEAKED,
            generatedName.c_str()));
   }

   return result;
}



bool
NetbiosNamePage::OnSetActive()
{
   LOG_FUNCTION(NetbiosNamePage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   // do this here instead of in init to regenerate a default name if the
   // user has not annointed one already.

   if (
         !state.UsingAnswerFile()
      && state.GetNewDomainNetbiosName().empty())
   {
      // 338443

      if (GenerateDefaultNetbiosName(hwnd))
      {
         // Clear the changes so we don't validate the generated name: it's
         // supposed to already be valid.

         ClearChanges();
      }
   }
      
   enable(hwnd);
   return true;
}


  
int
NetbiosNamePage::Validate()
{
   LOG_FUNCTION(NetbiosNamePage::Validate);

   int nextPage = IDD_PATHS; 

   if (WasChanged(IDC_NETBIOS))
   {
      if (!ValidateDomainNetbiosName(hwnd, IDC_NETBIOS, popup))
      {
         nextPage = -1;
      }
   }

   if (nextPage != -1)
   {
      ClearChanges();
      State& state = State::GetInstance();
      state.SetNewDomainNetbiosName(
         Win::GetTrimmedDlgItemText(hwnd, IDC_NETBIOS));
   }
      
   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\newdomainpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// New domain page
//
// 9 Feb 2000 sburns



#ifndef NEWDOMAINPAGE_HPP_INCLUDED
#define NEWDOMAINPAGE_HPP_INCLUDED



class NewDomainPage : public DCPromoWizardPage
{
   public:

   NewDomainPage();

   protected:

   virtual ~NewDomainPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   NewDomainPage(const NewDomainPage&);
   const NewDomainPage& operator=(const NewDomainPage&);
};



#endif   // NEWDOMAINPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\newsitepage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// new site page
//
// 1-6-98 sburns



#include "headers.hxx"
#include "page.hpp"
#include "NewSitePage.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"
#include "dns.hpp"



NewSitePage::NewSitePage()
   :
   DCPromoWizardPage(
      IDD_NEW_SITE,
      IDS_NEW_SITE_PAGE_TITLE,
      IDS_NEW_SITE_PAGE_SUBTITLE)
{
   LOG_CTOR(NewSitePage);
}



NewSitePage::~NewSitePage()
{
   LOG_DTOR(NewSitePage);
}



void
NewSitePage::OnInit()
{
   LOG_FUNCTION(NewSitePage::OnInit);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_SITE),
      Dns::MAX_LABEL_LENGTH);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_SITE,
         state.GetAnswerFileOption(AnswerFile::OPTION_SITE_NAME));
   }

   if (Win::GetTrimmedDlgItemText(hwnd, IDC_SITE).empty())
   {
      // assign a default site name

      Win::SetDlgItemText(
         hwnd,
         IDC_SITE,
         String::load(IDS_FIRST_SITE));
   }
}



void
NewSitePage::Enable()
{
   int next =
         !Win::GetTrimmedDlgItemText(hwnd, IDC_SITE).empty()
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | next);
}


   
bool
NewSitePage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(NewSitePage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_SITE:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);            
            Enable();
            return true;
         }
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return false;
}



bool
NewSitePage::OnSetActive()
{
   LOG_FUNCTION(NewSitePage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   Wizard& wizard = GetWizard();

   if (wizard.IsBacktracking())
   {
      // backup once again

      wizard.Backtrack(hwnd);
   }
   else
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         wizard.SetNextPageID(hwnd, nextPage);
         return true;
      }
      else
      {
         State::GetInstance().ClearHiddenWhileUnattended();
      }
   }

   Enable();
   return true;
}



int
NewSitePage::Validate()
{
   LOG_FUNCTION(NewSitePage::Validate);

   State& state = State::GetInstance();

   // this page is only used in new forest scenarios

   ASSERT(state.GetOperation() == State::FOREST);

   int nextPage = -1;
   String site = Win::GetTrimmedDlgItemText(hwnd, IDC_SITE);
   if (!site.empty())
   {
      if (ValidateSiteName(hwnd, IDC_SITE))
      {
         state.SetSiteName(Win::GetTrimmedDlgItemText(hwnd, IDC_SITE));
         nextPage = IDD_RAS_FIXUP;
      }
   }
   else
   {
      popup.Gripe(hwnd, IDC_SITE, IDS_MUST_SPECIFY_SITE);
   }

   if (nextPage != -1)
   {
      if (!state.IsDNSOnNetwork())
      {
         nextPage = IDD_RAS_FIXUP;
      }
      else
      {
         nextPage = IDD_DYNAMIC_DNS;
      }
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\newsitepage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// new site page
//
// 1-6-98 sburns



#ifndef NEWSITEPAGE_HPP_INCLUDED
#define NEWSITEPAGE_HPP_INCLUDED



class NewSitePage : public DCPromoWizardPage
{
   public:

   NewSitePage();

   protected:

   virtual ~NewSitePage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   Enable();

   // not defined; no copying allowed

   NewSitePage(const NewSitePage&);
   const NewSitePage& operator=(const NewSitePage&);
};



#endif   // NEWSITEPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\nondomainnc.hpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// Non-domain Naming Context checking code
//
// 13 July 2000 sburns, from code supplied by jeffparh



#ifndef NONDOMAINNC_HPP_INCLUDED
#define NONDOMAINNC_HPP_INCLUDED



HRESULT
IsLastNonDomainNamingContextReplica(StringList& ndncDnList);



#endif   // NONDOMAINNC_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\nonrfccomputernamedialog.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Dlg to inform user of a non-rfc computer name
//
// 18 Aug 2000 sburns



#ifndef NONRFCCOMPUTERNAMEDIALOG_HPP_INCLUDED
#define NONRFCCOMPUTERNAMEDIALOG_HPP_INCLUDED


                        
class NonRfcComputerNameDialog : public Dialog
{
   public:

   explicit
   NonRfcComputerNameDialog(const String& computerName_);

   virtual ~NonRfcComputerNameDialog();

   enum ResultCode
   {
      CONTINUE,
      RENAME
   };
      
   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIdFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   String computerName;

   // not defined: no copying allowed

   NonRfcComputerNameDialog(const NonRfcComputerNameDialog&);
   const NonRfcComputerNameDialog& operator=(const NonRfcComputerNameDialog&);
};



#endif   // NONRFCCOMPUTERNAMEDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\nonrfccomputernamedialog.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Dlg to inform user of a non-rfc computer name
//
// 18 Aug 2000 sburns


#include "headers.hxx"
#include "NonRfcComputerNameDialog.hpp"
#include "resource.h"



static const DWORD HELP_MAP[] =
{
   0, 0
};



NonRfcComputerNameDialog::NonRfcComputerNameDialog(
   const String& computerName_)
   :
   Dialog(IDD_NON_RFC_COMPUTER_NAME, HELP_MAP),
   computerName(computerName_)
{
   LOG_CTOR(NonRfcComputerNameDialog);
   ASSERT(!computerName.empty());
}



NonRfcComputerNameDialog::~NonRfcComputerNameDialog()
{
   LOG_DTOR(NonRfcComputerNameDialog);
}



bool
NonRfcComputerNameDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIdFrom,
   unsigned    code)
{
   switch (controlIdFrom)
   {
      case IDCANCEL:
      case IDC_CONTINUE:
      {
         if (code == BN_CLICKED)
         {
            Win::EndDialog(hwnd, CONTINUE);
            return true;
         }
         break;
      }
      case IDC_RENAME:
      {
         if (code == BN_CLICKED)
         {
            Win::EndDialog(hwnd, RENAME);
            return true;
         }
         break;
      }
      case IDC_SHOW_HELP:
      {
         if (code == BN_CLICKED)
         {
            Win::HtmlHelp(
               hwnd,
               L"DNSConcepts.chm",
               HH_DISPLAY_TOPIC, 
               reinterpret_cast<DWORD_PTR>(L"error_dcpromo.htm"));
            return true;
         }
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return false;
}



void
NonRfcComputerNameDialog::OnInit()
{
   LOG_FUNCTION(NonRfcComputerNameDialog::OnInit);

   String message =
      String::format(IDS_COMPUTER_NAME_NON_RFC, computerName.c_str());

   Win::SetDlgItemText(hwnd, IDC_TEXT, message);   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\page.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// dcpromo2 wizard base class
//
// 1-15-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "resource.h"
#include "state.hpp"



DCPromoWizardPage::DCPromoWizardPage(
   int   dialogResID,
   int   titleResID,
   int   subtitleResID,   
   bool  isInteriorPage)
   :
   WizardPage(dialogResID, titleResID, subtitleResID, isInteriorPage)
{
   LOG_CTOR(DCPromoWizardPage);
}

   

DCPromoWizardPage::~DCPromoWizardPage()
{
   LOG_DTOR(DCPromoWizardPage);
}



bool
DCPromoWizardPage::OnWizNext()
{
   LOG_FUNCTION(DCPromoWizardPage::OnWizNext);

   GetWizard().SetNextPageID(hwnd, Validate());
   return true;
}



bool
DCPromoWizardPage::OnQueryCancel()
{
   LOG_FUNCTION(DCPromoWizardPage::OnQueryCancel);

   State& state = State::GetInstance();

   int id = IDS_CONFIRM_CANCEL;
   switch (state.GetRunContext())
   {
      case State::BDC_UPGRADE:
      case State::PDC_UPGRADE:
      {
         id = IDS_CONFIRM_UPGRADE_CANCEL;
         break;
      }
      case State::NT5_DC:
      case State::NT5_STANDALONE_SERVER:
      case State::NT5_MEMBER_SERVER:
      default:
      {
         // do nothing
         break;
      }
   }

   Win::SetWindowLongPtr(
      hwnd,
      DWLP_MSGRESULT,
         (popup.MessageBox(hwnd, id, MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING) == IDYES)
      ?  FALSE
      :  TRUE);

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\page.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// dcpromo2 wizard base class
//
// 1-15-97 sburns



#ifndef PAGE_HPP_INCLUDED
#define PAGE_HPP_INCLUDED



class DCPromoWizardPage : public WizardPage
{
   public:

   virtual
   bool
   OnWizNext();

   protected:

   DCPromoWizardPage(
      int   dialogResID,
      int   titleResID,
      int   subtitleResID,   
      bool  isInteriorPage = true);

   virtual ~DCPromoWizardPage();

   // PropertyPage overrides

   virtual
   bool
   OnQueryCancel();

   virtual
   int
   Validate() = 0;

   private:

   // not defined: no copying allowed
   DCPromoWizardPage(const DCPromoWizardPage&);
   const DCPromoWizardPage& operator=(const DCPromoWizardPage&);
};



#endif   // PAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\nondomainnc.cpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// Non-domain Naming Context checking code
//
// 13 July 2000 sburns, from code supplied by jeffparh



#include "headers.hxx"
#include "state.hpp"
#include "resource.h"
#include "NonDomainNc.hpp"



#ifdef LOGGING_BUILD
   #define LOG_LDAP(msg, ldap) LOG(msg); LOG(String::format(L"LDAP error %1!ld!", (ldap)))
#else
   #define LOG_LDAP(msg, ldap)
#endif



HRESULT
LdapToHresult(int ldapError)
{
   // CODEWORK: I'm told that ldap_get_option for LDAP_OPT_SERVER_ERROR or
   // LDAP_OPT_SERVER_EXT_ERROR (or perhaps LDAP_OPT_ERROR_STRING?) will give
   // an error result with "higher fidelity"
   
   return Win32ToHresult(::LdapMapErrorToWin32(ldapError));
}



// provided by jeffparh

DWORD
IsLastReplicaOfNC(
    IN  LDAP *  hld,
    IN  LPWSTR  pszConfigNC,
    IN  LPWSTR  pszNC,
    IN  LPWSTR  pszNtdsDsaDN,
    OUT BOOL *  pfIsLastReplica
    )
/*++

Routine Description:

    Determine whether any DSAs other than that with DN pszNtdsDsaDN hold
    replicas of a particular NC.

Arguments:

    hld (IN) - LDAP handle to execute search with.
    
    pszConfigNC (IN) - DN of the config NC.  Used as a base for the search.
    
    pszNC (IN) - NC for which to check for other replicas.
    
    pszNtdsDsaDN (IN) - DN of the DSA object known to currently have a replica
        of the NC.  We are specifically looking for replicas *other than* this
        one.
        
    pfIsLastReplica (OUT) - On successful return, TRUE iff no DSAs hold replicas
        of pszNC other than that with DN pszNtdsDsaDN.

Return Values:

    Win error.

--*/
{
   LOG_FUNCTION2(IsLastReplicaOfNC, pszNC ? pszNC : L"(null)");
   ASSERT(hld);
   ASSERT(pszConfigNC);
   ASSERT(pszNC);
   ASSERT(pszNtdsDsaDN);
   ASSERT(pfIsLastReplica);

   if (
         !hld
      || !pszConfigNC
      || !pszNC
      || !pszNtdsDsaDN
      || !pfIsLastReplica)
   {
      return ERROR_INVALID_PARAMETER;
   }

    // Just checking for existence -- don't really want any attributes
    // returned.

    static LPWSTR rgpszDsaAttrsToRead[] = {
        L"__invalid_attribute_name__",
        NULL
    };

    // FUTURE-2002/03/22-BrettSh - NO_DOT_NET_BETA3_COMPAT_NEEDED - When
    // we don't need to be compat with Beta3, we can change this section:
    //    (|(msDS-HasMasterNCs=%ls)(hasMasterNCs=%ls))
    // to:
    //    (msDS-HasMasterNCs=%ls)
    static WCHAR szFilterFormat[]
        = L"(&(objectCategory=ntdsDsa)(|(msDS-HasMasterNCs=%ls)(hasMasterNCs=%ls))(!(distinguishedName=%ls)))";

   *pfIsLastReplica = TRUE;
   
    int                 ldStatus = 0;
    DWORD               err = 0;
    LDAPMessage *       pDsaResults = NULL;
    LDAPMessage *       pDsaEntry = NULL;
    size_t              cchFilter;
    PWSTR               pszFilter;
    LDAP_TIMEVAL        lTimeout = {3*60, 0};   // three minutes

   do
   {
        cchFilter = sizeof(szFilterFormat) / sizeof(*szFilterFormat)

        // ISSUE-2002/02/27-sburns if the swprintf below is replaced with
        // String::format, then these wcslen calls can be eliminated.

                    + wcslen(pszNtdsDsaDN)
                    + wcslen(pszNC)
                    + wcslen(pszNC);

        pszFilter = (PWSTR) new BYTE[sizeof(WCHAR) * cchFilter];

        // ISSUE-2002/02/27-sburns should use strsafe function here, or
        // String::format
        
        swprintf(pszFilter, szFilterFormat, pszNC, pszNC, pszNtdsDsaDN);

        // Search config NC for any ntdsDsa object that hosts this NC other
        // than that with dn pszNtdsDsaDN.  Note that we cap the search at one
        // returned object -- we're not really trying to enumerate, just
        // checking for existence.

        ldStatus = ldap_search_ext_sW(hld, pszConfigNC, LDAP_SCOPE_SUBTREE,
                                      pszFilter, rgpszDsaAttrsToRead, 0,
                                      NULL, NULL, &lTimeout, 1, &pDsaResults);
        if (pDsaResults)
        {
            // Ignore any error (such as LDAP_SIZELIMIT_EXCEEDED) when the
            // search returns results.

            ldStatus = 0;
            
            pDsaEntry = ldap_first_entry(hld, pDsaResults);
            
            *pfIsLastReplica = (NULL == pDsaEntry);
        } else if (ldStatus)
        {
            // Search failed and returned no results.

            LOG_LDAP(L"Config NC search failed", ldStatus);
            break;
        } else
        {
            // No error, no results.  This shouldn't happen.

            LOG("ldap_search_ext_sW returned no results and no error!");
            ASSERT(false);
        }
   }
   while (0);

   if (NULL != pDsaResults) {
      ldap_msgfree(pDsaResults);
   }

   if (pszFilter)
   {
      delete[] pszFilter;
   }

   if (!err && ldStatus) {
     err = LdapMapErrorToWin32(ldStatus);
   }
    
   return err;
}



// S_OK if this machine (the localhost) is the last replica of at least one
// non-domain NC, S_FALSE if not, or error otherwise.  If S_OK, then the
// StringList will contain the DNs of the non domain NCs for which this
// machine is the last replica.
//
// based on code from jeffparh
//
// hld (IN) - LDAP handle bound to DSA to evaluate.
//
// result (OUT) - string list to receive DNs of the non-domain NCs.

HRESULT
IsLastNdncReplica(LDAP* hld, StringList& result)
{
   LOG_FUNCTION(IsLastNdncReplica);
   ASSERT(hld);
   ASSERT(result.empty());

   HRESULT      hr          = S_FALSE;
   LDAPMessage* rootResults = 0;      
   PWSTR*       configNc    = 0;      
   PWSTR*       schemaNc    = 0;      
   PWSTR*       domainNc    = 0;      
   PWSTR*       masterNcs   = 0;      
   PWSTR*       ntdsDsaDn   = 0;      

   do
   {
      // Gather basic rootDSE info.

      static PWSTR ROOT_ATTRS_TO_READ[] =
      {
         LDAP_OPATT_NAMING_CONTEXTS_W,
         LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W,
         LDAP_OPATT_CONFIG_NAMING_CONTEXT_W,
         LDAP_OPATT_SCHEMA_NAMING_CONTEXT_W,
         LDAP_OPATT_DS_SERVICE_NAME_W,
         0
      };

      LOG(L"Calling ldap_search_s");

      int ldStatus =
         ldap_search_sW(
            hld,
            0,
            LDAP_SCOPE_BASE,
            L"(objectClass=*)",
            ROOT_ATTRS_TO_READ,
            0,
            &rootResults);
      if (ldStatus)
      {
         LOG_LDAP(L"RootDSE search failed", ldStatus);
         hr = LdapToHresult(ldStatus);
         break;
      }

      configNc  = ldap_get_valuesW(hld, rootResults, LDAP_OPATT_CONFIG_NAMING_CONTEXT_W); 
      schemaNc  = ldap_get_valuesW(hld, rootResults, LDAP_OPATT_SCHEMA_NAMING_CONTEXT_W); 
      domainNc  = ldap_get_valuesW(hld, rootResults, LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W);
      masterNcs = ldap_get_valuesW(hld, rootResults, LDAP_OPATT_NAMING_CONTEXTS_W);       
      ntdsDsaDn = ldap_get_valuesW(hld, rootResults, LDAP_OPATT_DS_SERVICE_NAME_W);       

      if (
            (0 == configNc)
         || (0 == schemaNc)
         || (0 == domainNc)
         || (0 == masterNcs)
         || (0 == ntdsDsaDn))
      {
         LOG(L"Can't find key rootDSE attributes!");

         hr = Win32ToHresult(ERROR_DS_UNAVAILABLE);
         break;
      }

      // There is only one value for each of these attributes...

      ASSERT(1 == ldap_count_valuesW(configNc));
      ASSERT(1 == ldap_count_valuesW(schemaNc));
      ASSERT(1 == ldap_count_valuesW(domainNc));
      ASSERT(1 == ldap_count_valuesW(ntdsDsaDn));

      DWORD masterNcCount = ldap_count_valuesW(masterNcs);
      
      LOG(String::format(L"masterNcCount = %1!d!", masterNcCount));
         
      // '3' => 1 nc for config, 1 nc for schema, 1 nc for this DC's own
      // domain.

      if (masterNcCount <= 3)
      {
         // DSA holds no master NCs other than config, schema, and its own
         // domain.  Thus, it is not the last replica of any NDNC.

         LOG(L"This dsa holds no master NCs other than config, schema, and domain");
         
         ASSERT(3 == masterNcCount);
         ASSERT(0 == ldStatus);
         ASSERT(hr == S_FALSE);

         break;
      }

      // Loop through non-config/schema/domain NCs to determine those for
      // which the DSA is the last replica.

      for (int i = 0; 0 != masterNcs[i]; ++i)
      {
         PWSTR nc = masterNcs[i];

         LOG(L"Evaluating " + String(nc));

         ASSERT(nc);
         ASSERT(configNc);
         ASSERT(*configNc);
         ASSERT(schemaNc);
         ASSERT(*schemaNc);
         ASSERT(domainNc);
         ASSERT(*domainNc);
         
         if (

            // REVIEWED-2002/02/27-sburns we're properly checking these
            // strings for null in the for loop test and in a check above
            // (in addition to the ASSERTs)

                (0 != wcscmp(nc, *configNc))
             && (0 != wcscmp(nc, *schemaNc))
             && (0 != wcscmp(nc, *domainNc)))
         {
            // A non-config/schema/domain NC.

            LOG(L"Calling IsLastReplicaOfNC on " + String(nc));

            BOOL isLastReplica = FALSE;
            DWORD err =
               IsLastReplicaOfNC(
                  hld,
                  *configNc,
                  nc,
                  *ntdsDsaDn,
                  &isLastReplica);
            if (err)
            {
               LOG(L"IsLastReplicaOfNC() failed");

               hr = Win32ToHresult(err);
               break;
            }

            if (isLastReplica)
            {
               // This DSA is indeed the last replica of this particular
               // NC.  Return the DN of this NC to our caller.

               LOG(L"last replica of " + String(nc));

               result.push_back(nc);
            }
            else
            {
               LOG(L"not last replica of " + String(nc));
            }
         }
      }

      // If we broke out of the prior loop with an error, jump out to the
      // cleanup section.

      BREAK_ON_FAILED_HRESULT(hr);

      hr = result.size() > 0 ? S_OK : S_FALSE;
   }
   while (0);

   if (rootResults)
   {
      ldap_msgfree(rootResults);
   }
   
   if (0 != configNc)
   {
      ldap_value_freeW(configNc);
   }

   if (0 != schemaNc)
   {
      ldap_value_freeW(schemaNc);
   }

   if (0 != domainNc)
   {
      ldap_value_freeW(domainNc);
   }

   if (0 != masterNcs)
   {
      ldap_value_freeW(masterNcs);
   }

   if (0 != ntdsDsaDn)
   {
      ldap_value_freeW(ntdsDsaDn);
   }

#ifdef LOGGING_BUILD
   LOG_HRESULT(hr);

   for (
      StringList::iterator i = result.begin();
      i != result.end();
      ++i)
   {
      LOG(*i);
   }
#endif

   return hr;
}



// S_OK if this machine (the localhost) is the last replica of at least one
// non-domain NC, S_FALSE if not, or error otherwise.
//
// result - If S_OK is returned, receives the DNs of the non domain NCs for
// which this machine is the last replica.  Should be empty on entry.

HRESULT
IsLastNonDomainNamingContextReplica(StringList& result)
{
   LOG_FUNCTION(IsLastNonDomainNamingContextReplica);
   ASSERT(result.empty());

   result.clear();

   HRESULT hr  = S_FALSE;
   LDAP*   hld = 0;   

   do
   {
      // Connect to target DSA.

      LOG(L"Calling ldap_open");

      hld = ldap_openW(L"localhost", LDAP_PORT);
      if (!hld)
      {
         LOG("Cannot open LDAP connection to localhost");
         hr = Win32ToHresult(ERROR_DS_UNAVAILABLE);
         break;
      }

      // Bind using logged-in user's credentials.

      int ldStatus = ldap_bind_s(hld, 0, 0, LDAP_AUTH_NEGOTIATE);
      if (ldStatus)
      {
         LOG_LDAP(L"LDAP bind failed", ldStatus);

         hr = LdapToHresult(ldStatus);
         break;
      }

      // go do the real work
          
      hr = IsLastNdncReplica(hld, result);
   }
   while (0);

   if (hld)
   {
      ldap_unbind(hld);
   }

   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\passwordeditbox.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// password edit control wrapper
//
// 6 Nov 2000 sburns
//
// added to fix NTRAID#NTBUG9-202238-2000/11/06-sburns
//
// most of this is stolen from johnstep's common cred ui
// ds/win32/credui



#include "headers.hxx"
#include "PasswordEditBox.hpp"
#include "ds.hpp"



PasswordEditBox::PasswordEditBox()
{
   LOG_CTOR(PasswordEditBox);
}



PasswordEditBox::~PasswordEditBox()
{
   LOG_DTOR(PasswordEditBox);
}



HRESULT
PasswordEditBox::Init(HWND editControl)
{
   LOG_FUNCTION(PasswordEditBox::Init);
   ASSERT(Win::GetClassName(editControl) == L"Edit");

//    By commenting out this code, we disable the subclassing and therefore
//    the caps lock warning bubble.  We do this because it appears that the
//    edit box common control now offers that same functionality.
//    NTRAID#NTBUG9-255537-2000/12/12-sburns to disable the code
//    NTRAID#NTBUG9-255568-2000/12/12-sburns to remove the code from the source
//    tree entirely.
//    
//    HRESULT hr = ControlSubclasser::Init(editControl);
//    if (SUCCEEDED(hr))
//    {
//       // set the options on the edit control
//       

   // NTRAID#NTBUG9-503798-2001/12/06-sburns
   
   Win::Edit_LimitText(editControl, DS::MAX_PASSWORD_LENGTH);

// 
//       // (could also set the password style bit here, if we wanted.)
// 
//       balloonTip.Init(hwnd);
//    }
// 
//    return hr;

   return S_OK;
}



bool
IsCapsLockOn()
{
//   LOG_FUNCTION(IsCapsLockOn);

   return (::GetKeyState(VK_CAPITAL) & 1) ? true : false;
}



LRESULT
PasswordEditBox::OnMessage(UINT message, WPARAM wparam, LPARAM lparam)
{
   // LOG_FUNCTION(PasswordEditBox::OnMessage);

   switch (message)
   {
      case WM_KEYDOWN:
      {

		  if (wparam == VK_CAPITAL)
         {
            // user pressed caps lock key

            balloonTip.Show(IsCapsLockOn());
         }
         else
         {
            // they hit some other key, so get rid of the tool tip
            
            balloonTip.Show(false);
         }

         break;
      }
      case WM_SETFOCUS:
      {
        // Make sure no one can steal the focus while a user is entering their
        // password

        ::LockSetForegroundWindow(LSFW_LOCK);

        balloonTip.Show(IsCapsLockOn());
       
        break;
      }
      case WM_PASTE:
      {
         balloonTip.Show(false);
         break;
      }
      case WM_KILLFOCUS:
      {
         balloonTip.Show(false);
         
        // Make sure other processes can set foreground window once again.

        ::LockSetForegroundWindow(LSFW_UNLOCK);

        break;
      }
   }

   return ControlSubclasser::OnMessage(message, wparam, lparam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\paths2page.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// paths, part 2 page
//
// 1-8-97 sburns



#ifndef PATHS2PAGE_HPP_INCLUDED
#define PATHS2PAGE_HPP_INCLUDED



class Paths2Page : public DCPromoWizardPage
{
   public:

   Paths2Page();

   protected:

   virtual ~Paths2Page();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   Enable();

   // not defined; no copying allowed
   Paths2Page(const Paths2Page&);
   const Paths2Page& operator=(const Paths2Page&);

   bool touchWizButtons;
};



#endif   // PATHS2_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\passwordeditbox.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// password edit control wrapper
//
// 6 Nov 2000 sburns
//
// added to fix NTRAID#NTBUG9-202238-2000/11/06-sburns



#ifndef PASSWORDEDITBOX_HPP_INCLUDED
#define PASSWORDEDITBOX_HPP_INCLUDED



#include "CapsLockBalloonTip.hpp"
#include "ControlSubclasser.hpp"



// Class for hooking the window proc of an edit control to add a balloon
// tooltip that is shown when the caps lock key is pressed.

class PasswordEditBox : public ControlSubclasser
{
   public:

   PasswordEditBox();

   virtual 
   ~PasswordEditBox();



   // subclasses the edit control, inits the balloon tip, and sets the text
   // limit appropriately.
   //
   // editControl - in, handle to the edit control to be hooked.  This must be
   // a handle to an edit control, or we fire an assertion.
   
   HRESULT
   Init(HWND editControl);



   // Invoked upon receipt of any window message.
   // 
   // message - in, the message code passed to the dialog window.
   // 
   // wparam - in, the WPARAM parameter accompanying the message.
   // 
   // lparam - in, the LPARAM parameter accompanying the message.
   
   LRESULT
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);
   


   private:

   // not implemented: no copying allowed

   PasswordEditBox(const PasswordEditBox&);
   const PasswordEditBox& operator=(const PasswordEditBox&);

   CapsLockBalloonTip balloonTip;        
};



#endif   // PASSWORDEDITBOX_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\pathspage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// paths page
//
// 12-22-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "PathsPage.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"



// NTRAID#NTBUG9-468577-2001/09/17-sburns
// NTRAID#NTBUG9-475838-2001/10/02-sburns

static const int DB_AND_LOG_MAX_PATH =
      MAX_PATH
   -  13       // for 8.3 named files under the path
   -  18;      // for worst case UNC name of the path, 'cause NTBackup is broken.



PathsPage::PathsPage()
   :
   DCPromoWizardPage(
      IDD_PATHS,
      IDS_PATHS_PAGE_TITLE,
      IDS_PATHS_PAGE_SUBTITLE),
   touchWizButtons(true)   
{
   LOG_CTOR(PathsPage);
}



PathsPage::~PathsPage()
{
   LOG_DTOR(PathsPage);
}



void
PathsPage::OnInit()
{
   LOG_FUNCTION(PathsPage::OnInit);

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_DB),  DB_AND_LOG_MAX_PATH);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_LOG), DB_AND_LOG_MAX_PATH);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_DB,
         Win::ExpandEnvironmentStrings(
            state.GetAnswerFileOption(AnswerFile::OPTION_DATABASE_PATH)));
      Win::SetDlgItemText(
         hwnd,
         IDC_LOG,
         Win::ExpandEnvironmentStrings(
            state.GetAnswerFileOption(AnswerFile::OPTION_LOG_PATH)));
   }

   String root = Win::GetSystemWindowsDirectory();
   if (Win::GetTrimmedDlgItemText(hwnd, IDC_DB).empty())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_DB,
         root + String::load(IDS_DB_SUFFIX));
   }
   if (Win::GetTrimmedDlgItemText(hwnd, IDC_LOG).empty())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_LOG,
         root + String::load(IDS_LOG_SUFFIX));
   }
}



void
PathsPage::Enable()
{
   // touchWizButtons is managed in the OnCommand handler for EN_KILLFOCUS.
   // Turns out that if you call PropSheet_SetWizButtons while handling a kill
   // focus event, you mess up the tab processing so that the focus jumps to
   // the default wizard button. That's really cool -- NOT!
   
   if (touchWizButtons)
   {
      int next =
            (  !Win::GetTrimmedDlgItemText(hwnd, IDC_DB).empty()
            && !Win::GetTrimmedDlgItemText(hwnd, IDC_LOG).empty() )
         ?  PSWIZB_NEXT : 0;

      Win::PropSheet_SetWizButtons(Win::GetParent(hwnd), PSWIZB_BACK | next);
   }
}


   
bool
PathsPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIdFrom,
   unsigned    code)
{
//   LOG_FUNCTION(PathsPage::OnCommand);

   bool result = false;
   
   switch (controlIdFrom)
   {
      case IDC_BROWSE_DB:
      {
         if (code == BN_CLICKED)
         {
            String path = BrowseForFolder(hwnd, IDS_DB_BROWSE_TITLE);
            if (!path.empty())
            {
               Win::SetDlgItemText(hwnd, IDC_DB, path);
            }

            result = true;
         }
         break;
      }
      case IDC_BROWSE_LOG:
      {
         if (code == BN_CLICKED)
         {
            String path = BrowseForFolder(hwnd, IDS_LOG_BROWSE_TITLE);
            if (!path.empty())
            {
               Win::SetDlgItemText(hwnd, IDC_LOG, path);
            }

            result = true;
         }
         break;
      }
      case IDC_DB:
      case IDC_LOG:
      {
         switch (code)
         {
            case EN_CHANGE:
            {
               SetChanged(controlIdFrom);            
               Enable();
               result = true;
               
               break;
            }
            case EN_KILLFOCUS:
            {
               // Since the normalization fully-expands relative paths, the
               // full pathname may not match what the user entered.  So we
               // update the edit box contents to make sure they realize what
               // the relative path expands to.
               // NTRAID#NTBUG9-216148-2000/11/01-sburns

               String text = Win::GetTrimmedDlgItemText(hwnd, controlIdFrom);
               if (!text.empty())
               {
                  // turn off setting of wizard buttons so that the call to
                  // Enable made by the EN_CHANGE handler (which will be
                  // called when we set the edit box text) will not call
                  // PropSheet_SetWizButtons, which will mess up the tab
                  // processing.
               
                  touchWizButtons = false;
                  Win::SetDlgItemText(
                     hwnd,
                     controlIdFrom,
                     FS::NormalizePath(text));
                  touchWizButtons = true;
               }

               result = true;
               break;
            }
            default:
            {
               // do nothing

               break;
            }
         }
      
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return result;
}



bool
PathsPage::OnSetActive()
{
   LOG_FUNCTION(PathsPage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   Enable();
   return true;
}



int
PathsPage::Validate()
{
   LOG_FUNCTION(PathsPage::Validate);

   State& state = State::GetInstance();

   String dbPath  = FS::NormalizePath(Win::GetTrimmedDlgItemText(hwnd, IDC_DB)); 
   String logPath = FS::NormalizePath(Win::GetTrimmedDlgItemText(hwnd, IDC_LOG));

   // If you change these, make sure you change the low disk space messages in
   // the resource file!

   static const unsigned DB_MIN_SPACE_MB = 200;
   static const unsigned LOG_MIN_SPACE_MB = 50;

   int  nextPage = -1;    
   bool valid    = false; 
   int  editId   = IDC_DB;
   String message;
   do                                                      
   {
//       // if replicating from media, destination folders may not be the
//       // source path.
// 
//       if (state.ReplicateFromMedia())
//       {
//          String p = state.GetReplicationSourcePath();
//          if (p.icompare(dbPath) == 0)
//          {
//             message = String::format(IDS_DB_CANT_MATCH_SOURCE_PATH, dbPath.c_str());
//             break;
//          }
//       }

      if (ValidateDcInstallPath(dbPath, hwnd, IDC_DB, false, true, true))
      {
         // grab the "X:\" part of the path

         String dbVolume   = FS::GetRootFolder(dbPath);   
         String logVolume  = FS::GetRootFolder(logPath);  
         bool   sameVolume = (dbVolume.icompare(logVolume) == 0);

         if (
            !CheckDiskSpace(
               dbVolume,
               DB_MIN_SPACE_MB + (sameVolume ? LOG_MIN_SPACE_MB : 0)) )
         {
            message = String::load(IDS_LOW_SPACE_DB);
            break;
         }
         if (dbPath.icompare(logPath) != 0)
         {
            // the paths are different, so check the log path

            editId = IDC_LOG;
            if (
               ValidateDcInstallPath(
                  logPath,
                  hwnd,
                  IDC_LOG,
                  false,
                  true,

                  // require uncompressed folder for log, too.
                  // NTRAID#NTBUG9-523532-2002/04/19-sburns
                  
                  true))
            {
               if (!CheckDiskSpace(logVolume, LOG_MIN_SPACE_MB))
               {
                  message = String::load(IDS_LOW_SPACE_LOG);
                  break;
               }

               // if (state.ReplicateFromMedia())
               // {
               //    String p = state.GetReplicationSourcePath();
               //    if (p.icompare(logPath) == 0)
               //    {
               //       message =
               //          String::format(
               //             IDS_LOG_CANT_MATCH_SOURCE_PATH,
               //             logPath.c_str());
               //       break;
               //    }
               // }

               // paths differ, both are valid

               valid = true;
            }
         }
         else
         {
            // paths are the same, and we validated dbPath already

            valid = true;
         }
      }
   }
   while (0);

   if (!message.empty())
   {
      popup.Gripe(hwnd, editId, message);
   }
      
   if (valid)
   {         
      state.SetDatabasePath(dbPath);
      state.SetLogPath(logPath);
      nextPage = IDD_PATHS2;
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\pathspage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// paths page
//
// 12-22-97 sburns



#ifndef PATHSPAGE_HPP_INCLUDED
#define PATHSPAGE_HPP_INCLUDED



class PathsPage : public DCPromoWizardPage
{
   public:

   PathsPage();

   protected:

   virtual ~PathsPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   Enable();
   
   // not defined; no copying allowed

   PathsPage(const PathsPage&);
   const PathsPage& operator=(const PathsPage&);

   bool touchWizButtons;
};



#endif   // PATHSPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\picksitepage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// pick site page
//
// 12-22-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "PickSitePage.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"
#include "dns.hpp"



PickSitePage::PickSitePage()
   :
   DCPromoWizardPage(
      IDD_PICK_SITE,
      IDS_PICK_SITE_PAGE_TITLE,
      IDS_PICK_SITE_PAGE_SUBTITLE)
{
   LOG_CTOR(PickSitePage);
}



PickSitePage::~PickSitePage()
{
   LOG_DTOR(PickSitePage);
}



void
PickSitePage::OnInit()
{
   LOG_FUNCTION(PickSitePage::OnInit);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_SITE),
      Dns::MAX_LABEL_LENGTH);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_SITE,
         state.GetAnswerFileOption(AnswerFile::OPTION_SITE_NAME));
   }
}



void
PickSitePage::Enable()
{
   int next =
         !Win::GetTrimmedDlgItemText(hwnd, IDC_SITE).empty()
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | next);
}


   
bool
PickSitePage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(PickSitePage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_SITE:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);            
            Enable();
            return true;
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



bool
PickSitePage::OnSetActive()
{
   LOG_FUNCTION(PickSitePage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   Wizard& wizard = GetWizard();

   if (wizard.IsBacktracking())
   {
      // backup once again
      wizard.Backtrack(hwnd);
   }
   else
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         wizard.SetNextPageID(hwnd, nextPage);
         return true;
      }
      else
      {
         State::GetInstance().ClearHiddenWhileUnattended();
      }
   }

   Enable();
   return true;
}



int
PickSitePage::Validate()
{
   LOG_FUNCTION(PickSitePage::Validate);

   State& state = State::GetInstance();
   ASSERT(state.IsDNSOnNetwork());

   int nextPage = IDD_RAS_FIXUP;
   String site = Win::GetTrimmedDlgItemText(hwnd, IDC_SITE);
   if (site.empty())
   {
      LOG(L"Site not specified.");
   }
   else
   {
      if (!ValidateSiteName(hwnd, IDC_SITE))
      {
         nextPage = -1;
      }
   }
   state.SetSiteName(Win::GetTrimmedDlgItemText(hwnd, IDC_SITE));

   if (nextPage != -1)
   {
      if (state.GetOperation() != State::REPLICA)
      {
         nextPage = IDD_DYNAMIC_DNS;
      }
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\paths2page.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// paths, part 2 page
//
// 1-8-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "Paths2Page.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"



// NTRAID#NTBUG9-468577-2001/09/17-sburns

static const int SYSVOL_MAX_PATH = 90;



Paths2Page::Paths2Page()
   :
   DCPromoWizardPage(
      IDD_PATHS2,
      IDS_PATHS2_PAGE_TITLE,
      IDS_PATHS2_PAGE_SUBTITLE),
   touchWizButtons(true)   
{
   LOG_CTOR(Paths2Page);
}



Paths2Page::~Paths2Page()
{
   LOG_DTOR(Paths2Page);
}



String
DetermineDefaultSysvolPath()
{
   LOG_FUNCTION(DetermineDefaultSysvolPath);

   // prefer windir, but if that's not ntfs 5, find one that is.

   String result = Win::GetSystemWindowsDirectory();

   if (FS::GetFileSystemType(result) != FS::NTFS5)
   {
      result = GetFirstNtfs5HardDrive();
   }
   else
   {
      result += L"\\";
   }

   LOG(result);

   return result;
}



void
Paths2Page::OnInit()
{
   LOG_FUNCTION(Paths2Page::OnInit);

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_SYSVOL), SYSVOL_MAX_PATH);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_SYSVOL,
         Win::ExpandEnvironmentStrings(
            state.GetAnswerFileOption(AnswerFile::OPTION_SYSVOL_PATH)));
   }

   String root = DetermineDefaultSysvolPath();
   if (Win::GetTrimmedDlgItemText(hwnd, IDC_SYSVOL).empty())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_SYSVOL,
         root + String::load(IDS_SYSVOL_SUFFIX));
   }
}



void
Paths2Page::Enable()
{
   // touchWizButtons is managed in the OnCommand handler for EN_KILLFOCUS.
   // Turns out that if you call PropSheet_SetWizButtons while handling a kill
   // focus event, you mess up the tab processing so that the focus jumps to
   // the default wizard button. That's really cool -- NOT!
   
   if (touchWizButtons)
   {
      int next =
            !Win::GetTrimmedDlgItemText(hwnd, IDC_SYSVOL).empty()
         ?  PSWIZB_NEXT : 0;

      Win::PropSheet_SetWizButtons(Win::GetParent(hwnd), PSWIZB_BACK | next);
   }
}


   
bool
Paths2Page::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIdFrom,
   unsigned    code)
{
//   LOG_FUNCTION(Paths2Page::OnCommand);

   bool result = false;
   
   switch (controlIdFrom)
   {
      case IDC_BROWSE:
      {
         if (code == BN_CLICKED)
         {
            String path = BrowseForFolder(hwnd, IDS_SYSVOL_BROWSE_TITLE);
            if (!path.empty())
            {
               Win::SetDlgItemText(hwnd, IDC_SYSVOL, path);
            }

            result = true;
         }
         break;
      }
      case IDC_SYSVOL:
      {
         switch (code)
         {
            case EN_CHANGE:
            {
               SetChanged(controlIdFrom);            
               Enable();
               result = true;
            
               break;
            }
            case EN_KILLFOCUS:
            {
               // Since the normalization fully-expands relative paths, the
               // full pathname may not match what the user entered.  So we
               // update the edit box contents to make sure they realize what
               // the relative path expands to.
               // NTRAID#NTBUG9-216148-2000/11/01-sburns

               String text = Win::GetTrimmedDlgItemText(hwnd, controlIdFrom);
               if (!text.empty())
               {
                  // turn off setting of wizard buttons so that the call to
                  // Enable made by the EN_CHANGE handler (which will be
                  // called when we set the edit box text) will not call
                  // PropSheet_SetWizButtons, which will mess up the tab
                  // processing.
               
                  touchWizButtons = false;
                  Win::SetDlgItemText(
                     hwnd,
                     controlIdFrom,
                     FS::NormalizePath(text));
                  touchWizButtons = true;
               }

               result = true;
               break;
            }
            default:
            {
               // do nothing

               break;
            }
         }
      
         break;
      }
      default:
      {
         // do nothing
         
         break;
      }
   }

   return false;
}



bool
Paths2Page::OnSetActive()
{
   LOG_FUNCTION(Paths2Page::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   Enable();
   return true;
}



// returns true if the path is valid, false if not.  Pesters the user on
// validation failures.

bool
ValidateSYSVOLPath(const String& path, HWND parent, unsigned editResID)
{
   LOG_FUNCTION(validateSysvolPath);
   ASSERT(Win::IsWindow(parent));
   ASSERT(!path.empty());

   // check that the path is not the same as the database or log paths
   // previously entered.  313059

   State& state = State::GetInstance();
   String db = state.GetDatabasePath();
   if (db.icompare(path) == 0)
   {
      popup.Gripe(
         parent,
         editResID,
         String::format(IDS_SYSVOL_CANT_MATCH_DB, db.c_str()));
      return false;
   }

   String log = state.GetLogPath();
   if (log.icompare(path) == 0)
   {
      popup.Gripe(
         parent,
         editResID,
         String::format(IDS_SYSVOL_CANT_MATCH_LOG, log.c_str()));
      return false;
   }

   // check that the path is not a parent folder of the database or log
   // paths previously entered. 320685

   if (FS::IsParentFolder(path, db))
   {
      popup.Gripe(
         parent,
         editResID,
         String::format(IDS_SYSVOL_CANT_BE_DB_PARENT, db.c_str()));
      return false;
   }

   if (FS::IsParentFolder(path, log))
   {
      popup.Gripe(
         parent,
         editResID,
         String::format(IDS_SYSVOL_CANT_BE_LOG_PARENT, log.c_str()));
      return false;
   }

//    // if replicating from media, destination sysvol folder may not be any
//    // of the source paths.
// 
//    if (state.ReplicateFromMedia())
//    {
//       String p = state.GetReplicationSourcePath();
//       if (p.icompare(path) == 0)
//       {
//          popup.Gripe(
//             parent,
//             editResID,
//             String::format(IDS_SYSVOL_CANT_MATCH_SOURCE_PATH, p.c_str()));
//          return false;
//       }
//    }

   // if you change this, change the error message resource too.

   static const unsigned SYSVOL_MIN_SPACE_MB = 100;

   if (!CheckDiskSpace(path, SYSVOL_MIN_SPACE_MB))
   {
      popup.Gripe(
         parent,
         editResID,
         String::format(IDS_SYSVOL_LOW_SPACE, log.c_str()));
      return false;
   }

   return true;
}
      


int
Paths2Page::Validate()
{
   LOG_FUNCTION(Paths2Page::Validate);

   int nextPage = -1;
   String path =
      FS::NormalizePath(Win::GetTrimmedDlgItemText(hwnd, IDC_SYSVOL));
   if (

         // require uncompressed folder
         // NTRAID#NTBUG9-523532-2002/04/19-sburns
         
         ValidateDcInstallPath(path, hwnd, IDC_SYSVOL, true, false, true)
      && ValidateSYSVOLPath(path, hwnd, IDC_SYSVOL) )
   {
      State& state = State::GetInstance();
      state.SetSYSVOLPath(path);
      if (state.GetOperation() == State::FOREST)
      {
         nextPage = IDD_NEW_SITE;
      }
      else
      {
         nextPage = IDD_PICK_SITE;
      }
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\postop.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Post-operation code
//
// 1 Dec 1999 sburns



#ifndef POSTOP_HPP_INCLUDED
#define POSTOP_HPP_INCLUDED



void
DoPostOperationStuff(ProgressDialog& progress);



#endif   // POSTOP_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\picksitepage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// pick site page
//
// 12-22-97 sburns



#ifndef PICKSITEPAGE_HPP_INCLUDED
#define PICKSITEPAGE_HPP_INCLUDED



class PickSitePage : public DCPromoWizardPage
{
   public:

   PickSitePage();

   protected:

   virtual ~PickSitePage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   Enable();

   // not defined; no copying allowed

   PickSitePage(const PickSitePage&);
   const PickSitePage& operator=(const PickSitePage&);
};



#endif   // PICKSITEPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\progressdialog.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Dialog to display promotion progress
//
// 12-29-97 sburns



#include "headers.hxx"
#include "ProgressDialog.hpp"
#include "indicate.hpp"
#include "resource.h"



const UINT ProgressDialog::THREAD_SUCCEEDED = WM_USER + 999; 
const UINT ProgressDialog::THREAD_FAILED    = WM_USER + 1000;

// this string must match that in the CLASS specification of the
// dialog template in the .rc file!
static TCHAR PROGRESS_DIALOG_CLASS_NAME[] = L"dcpromo_progress";


static const DWORD HELP_MAP[] =
{
   0, 0
};



struct WrapperThreadProcParams
{
   ProgressDialog*             dialog;
   ProgressDialog::ThreadProc  realProc;
};



void _cdecl
wrapperThreadProc(void* p)
{
   ASSERT(p);

   WrapperThreadProcParams* params =
      reinterpret_cast<WrapperThreadProcParams*>(p);
   ASSERT(params->dialog);
   ASSERT(params->realProc);

   params->realProc(*(params->dialog));
}
   


ProgressDialog::ProgressDialog(
   ThreadProc   threadProc_,
   int          animationResId_)
   :
   Dialog(IDD_PROGRESS, HELP_MAP),
   animationResId(animationResId_),
   threadProc(threadProc_),
   threadParams(0),
   buttonEventHandle(0)
{
   LOG_CTOR(ProgressDialog);
   ASSERT(threadProc);
   ASSERT(animationResId > 0);

   // we subclass the window so we can change the cursor to the wait cursor

   WNDCLASSEX wndclass;

   // REVIEWED-2002/02/26-sburns correct byte count passed
   
   ::ZeroMemory(&wndclass, sizeof wndclass);

   static const wchar_t* DIALOG_WINDOW_CLASS_NAME = L"#32770";

   HRESULT hr = Win::GetClassInfoEx(DIALOG_WINDOW_CLASS_NAME, wndclass);
   ASSERT(SUCCEEDED(hr));

   wndclass.lpfnWndProc   = ::DefDlgProc;              
   wndclass.hInstance     = Win::GetModuleHandle();    
   wndclass.lpszClassName = PROGRESS_DIALOG_CLASS_NAME;

   hr = Win::LoadCursor(IDC_WAIT, wndclass.hCursor);
   ASSERT(SUCCEEDED(hr));

   ATOM unused = 0;
   hr = Win::RegisterClassEx(wndclass, unused);
   ASSERT(SUCCEEDED(hr));

   // REVIEWED-2002/02/26-sburns this is an unnamed event, so no squatting
   // attack exposure
   
   hr = Win::CreateEvent(0, false, false, buttonEventHandle);
   
   // in the case that the CreateEvent fails (very unlikely), there's not
   // much we can do. In this case, the result will be that nothing will
   // happen when the user clicks the cancel button.
   
   ASSERT(SUCCEEDED(hr));
}



ProgressDialog::~ProgressDialog()
{
   LOG_DTOR(ProgressDialog);

   delete threadParams;

   Win::UnregisterClass(PROGRESS_DIALOG_CLASS_NAME, Win::GetModuleHandle());
}


   
void
ProgressDialog::UpdateText(const String& message)
{
   LOG_FUNCTION2(ProgressDialog::UpdateText, message);

   Win::ShowWindow(
      Win::GetDlgItem(hwnd, IDC_MESSAGE),
      message.empty() ? SW_HIDE : SW_SHOW);
   Win::SetDlgItemText(hwnd, IDC_MESSAGE, message);
}



void
ProgressDialog::UpdateText(int textStringResID)
{
   LOG_FUNCTION(ProgressDialog::UpdateText);   
   ASSERT(textStringResID > 0);

   UpdateText(String::load(textStringResID));
}



void
ProgressDialog::UpdateButton(int textStringResID)
{
   LOG_FUNCTION(ProgressDialog::UpdateButton);
   ASSERT(textStringResID > 0);

   UpdateButton(String::load(textStringResID));
}



void
ProgressDialog::UpdateButton(const String& text)
{
   LOG_FUNCTION2(ProgressDialog::UpdateButton, text);   
   HWND button = Win::GetDlgItem(hwnd, IDC_BUTTON);

   DWORD waitResult = WAIT_FAILED;
   HRESULT hr = Win::WaitForSingleObject(buttonEventHandle, 0, waitResult);

   ASSERT(SUCCEEDED(hr));

   if (waitResult == WAIT_OBJECT_0)
   {
      // event is still signalled, so reset it.

      Win::ResetEvent(buttonEventHandle);
   }
      
   bool empty = text.empty();

   // Hide the button before we adjust the geometry.  On slow or heavily
   // loaded machines, the repaints show a noticable delay that has frightened
   // at least one user.
   // NTRAID#NTBUG9-353799-2001/04/05-sburns

   Win::ShowWindow(button, SW_HIDE);
   Win::EnableWindow(button, false);

   if (empty)
   {
      // leave the button hidden and disabled.
      
      return;
   }

   // resize and recenter the button

   RECT buttonRect;
   Win::GetWindowRect(button, buttonRect);
   Win::ScreenToClient(hwnd, buttonRect);

   HDC hdc = GetWindowDC(button);
   SIZE textExtent;
   Win::GetTextExtentPoint32(hdc, text, textExtent);
   Win::ReleaseDC(button, hdc);

   // add a bit of whitespace to the button label
   // NTRAID#NTBUG9-40855-2001/02/28-sburns

   textExtent.cx += 40;   

   RECT dialogRect;
   hr = Win::GetClientRect(hwnd, dialogRect);

   ASSERT(SUCCEEDED(hr));

   Win::MoveWindow(
      button,
         dialogRect.left
      +  (dialogRect.right - dialogRect.left - textExtent.cx)
      /  2,
      buttonRect.top,  
      textExtent.cx, 
      buttonRect.bottom - buttonRect.top,
      true);

   // display the button only after we have adjusted it's geometry

   Win::SetDlgItemText(hwnd, IDC_BUTTON, text);
   Win::ShowWindow(button, SW_SHOW);
   Win::EnableWindow(button, true);
}   



void
ProgressDialog::OnDestroy()
{
   LOG_FUNCTION(ProgressDialog::OnDestroy);

   // we don't delete things here, as a WM_DESTROY message may never be sent

   Win::Animate_Close(Win::GetDlgItem(hwnd, IDC_ANIMATION));
}



void
ProgressDialog::OnInit()
{
   LOG_FUNCTION(ProgressDialog::OnInit);

   Win::Animate_Open(
      Win::GetDlgItem(hwnd, IDC_ANIMATION),
      MAKEINTRESOURCE(animationResId));

   UpdateText(String());
   UpdateButton(String());

   // deleted in the dtor, not in the wrapperThreadProc, in case the
   // wrapperThreadProc terminates abnormally.

   threadParams           = new WrapperThreadProcParams;
   threadParams->dialog   = this;      
   threadParams->realProc = threadProc;

   _beginthread(wrapperThreadProc, 0, threadParams);
}



bool
ProgressDialog::OnCommand(
   HWND        windowFrom,
   unsigned    controlIDFrom,
   unsigned    code)
{
   if (code == BN_CLICKED)
   {
      switch (controlIDFrom)
      {
         case IDC_BUTTON:
         {
            LOG(L"ProgressDialog::OnCommand -- cancel button pressed");
            
            // Since the response to the button press may be some time
            // coming, disable the button to prevent the user from pressing
            // it over and over in a frantic panic.

            Win::EnableWindow(windowFrom, false);
            Win::SetEvent(buttonEventHandle);
            break;
         }
         default:
         {
            // do nothing
         }
      }
   }

   return false;
}



bool
ProgressDialog::OnMessage(
   UINT     message,
   WPARAM   /* wparam */ ,
   LPARAM   /* lparam */ )
{
//   LOG_FUNCTION(ProgressDialog::OnMessage);

   switch (message)
   {
      case THREAD_SUCCEEDED:
      {
         Win::Animate_Stop(Win::GetDlgItem(hwnd, IDC_ANIMATION));
         UpdateText(String::load(IDS_OPERATION_DONE));

         HRESULT unused = Win::EndDialog(hwnd, THREAD_SUCCEEDED);

         ASSERT(SUCCEEDED(unused));

         return true;
      }
      case THREAD_FAILED:
      {
         Win::Animate_Stop(Win::GetDlgItem(hwnd, IDC_ANIMATION));         
         UpdateText(String::load(IDS_OPERATION_TERMINATED));

         HRESULT unused = Win::EndDialog(hwnd, THREAD_FAILED);

         ASSERT(SUCCEEDED(unused));

         return true;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



ProgressDialog::WaitCode
ProgressDialog::WaitForButton(int timeoutMillis)
{
//   LOG_FUNCTION(ProgressDialog::WaitForButton);

   DWORD result = WAIT_FAILED;
   HRESULT hr =
      Win::WaitForSingleObject(buttonEventHandle, timeoutMillis, result);

   ASSERT(SUCCEEDED(hr));

   switch (result)
   {
      case WAIT_OBJECT_0:
      {
         return PRESSED;
      }
      case WAIT_TIMEOUT:
      {
         return TIMEOUT;
      }
      case WAIT_FAILED:
      {
         // we squeltch the failure, and equate it to timeout
         // fall thru
      }
      default:
      {
         ASSERT(false);
      }
   }

   return TIMEOUT;
}



void
ProgressDialog::RevertToOriginalAnimation()
{
   LOG_FUNCTION(ProgressDialog::RevertToOriginalAnimation);
   
   Win::Animate_Close(Win::GetDlgItem(hwnd, IDC_ANIMATION));
   Win::Animate_Open(
      Win::GetDlgItem(hwnd, IDC_ANIMATION),
      MAKEINTRESOURCE(animationResId));
}



void
ProgressDialog::UpdateAnimation(int newAnimationResId)
{
   LOG_FUNCTION(ProgressDialog::UpdateAnimation);

   Win::Animate_Close(Win::GetDlgItem(hwnd, IDC_ANIMATION));
   Win::Animate_Open(
      Win::GetDlgItem(hwnd, IDC_ANIMATION),
      MAKEINTRESOURCE(newAnimationResId));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\rasfixup.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// downlevel RAS server fixup page
//
// 11-23-98 sburns



#ifndef RASFIXUP_HPP_INCLUDED
#define RASFIXUP_HPP_INCLUDED



#include "page.hpp"



class RASFixupPage : public DCPromoWizardPage
{
   public:

   RASFixupPage();

   protected:

   virtual ~RASFixupPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   RASFixupPage(const RASFixupPage&);
   const RASFixupPage& operator=(const RASFixupPage&);
};



#endif   // RASFIXUP_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\rasfixup.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// downlevel RAS server fixup page
//
// 11-23-98 sburns



#include "headers.hxx"
#include "rasfixup.hpp"
#include "resource.h"
#include "state.hpp"



RASFixupPage::RASFixupPage()
   :
   DCPromoWizardPage(
      IDD_RAS_FIXUP,
      IDS_RAS_FIXUP_PAGE_TITLE,
      IDS_RAS_FIXUP_PAGE_SUBTITLE)
{
   LOG_CTOR(RASFixupPage);
}



RASFixupPage::~RASFixupPage()
{
   LOG_DTOR(RASFixupPage);
}



void
RASFixupPage::OnInit()
{
   LOG_FUNCTION(RASFixupPage::OnInit);

   State& state = State::GetInstance();

   // If we're upgrading an NT 4 PDC, then the expectation is that the
   // customer is more likely to have an app-compat problem, so we default to
   // the allow-access option.  Otherwise, we default to the more secure (but
   // less compatible) option.
   // NTRAID#NTBUG9-539263-2002/04/16-sburns

   int defaultButton =
         state.GetRunContext() == State::PDC_UPGRADE
      ?  IDC_ALLOW_ANON_ACCESS
      :  IDC_DENY_ANON_ACCESS;
   
   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(AnswerFile::OPTION_ALLOW_ANON_ACCESS);

      int button = defaultButton;

      if (option.icompare(AnswerFile::VALUE_YES) == 0)
      {
         button = IDC_ALLOW_ANON_ACCESS;
      }
      else if (option.icompare(AnswerFile::VALUE_NO) == 0)
      {
         button = IDC_DENY_ANON_ACCESS;
      }

      Win::CheckDlgButton(
         hwnd,
         button,
         BST_CHECKED);
      return;
   }
   
   Win::CheckDlgButton(hwnd, defaultButton, BST_CHECKED);
   Win::PostMessage(
      Win::GetParent(hwnd),
      WM_NEXTDLGCTL,
      (WPARAM) Win::GetDlgItem(hwnd, defaultButton),
      TRUE);
}



bool
RASFixupPage::OnSetActive()
{
   LOG_FUNCTION(RASFixupPage::OnSetActive);

   State& state = State::GetInstance();
   bool skip = true;

   switch (state.GetOperation())
   {
      case State::FOREST:
      case State::TREE:
      case State::CHILD:
      {
         skip = false;
         break;
      }
      case State::REPLICA:
      case State::ABORT_BDC_UPGRADE:
      case State::DEMOTE:
      case State::NONE:
      {
         // do nothing: i.e. skip this page
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   if (state.RunHiddenUnattended() || skip)  // 268231
   {
      LOG(L"planning to skip RAS fixup page");

      Wizard& wizard = GetWizard();

      if (wizard.IsBacktracking())
      {
         // backup once again
         wizard.Backtrack(hwnd);
         return true;
      }

      int nextPage = Validate();
      if (nextPage != -1)
      {
         LOG(L"skipping RAS Fixup Page");         
         wizard.SetNextPageID(hwnd, nextPage);
         return true;
      }

      state.ClearHiddenWhileUnattended();
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



int
RASFixupPage::Validate()
{
   LOG_FUNCTION(RASFixupPage::Validate);

   State& state = State::GetInstance();
   if (Win::IsDlgButtonChecked(hwnd, IDC_ALLOW_ANON_ACCESS))
   {
      state.SetShouldAllowAnonymousAccess(true);
   }
   else
   {
      ASSERT(Win::IsDlgButtonChecked(hwnd, IDC_DENY_ANON_ACCESS));
      state.SetShouldAllowAnonymousAccess(false);
   }

   return IDD_SAFE_MODE_PASSWORD;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\progressdialog.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Dialog to display promotion progress
//
// 12-29-97 sburns



#ifndef PROGRESSDIALOG_HPP_INCLUDED
#define PROGRESSDIALOG_HPP_INCLUDED


                    
class ProgressDialog : public Dialog
{
   public:

   // one of these is returned from ModalExecute
   static const UINT THREAD_SUCCEEDED;
   static const UINT THREAD_FAILED;

   typedef void (*ThreadProc) (ProgressDialog& dialog);

   // threadProc - pointer to a thread procedure that will be started when
   // the dialog is initialized (OnInit).  The procedure will be passed a
   // pointer to this instance.
   //
   // animationResID - resource ID of the AVI resource to be played while
   // the dialog is shown.

   ProgressDialog(
      ThreadProc   threadProc,
      int          animationResID);

   virtual ~ProgressDialog();



   // Restores the original animation that the dialog what created with.
   
   void
   RevertToOriginalAnimation();


   
   // Changes the animation AVI being shown in the dialog.
   //
   // animationResID - resource ID of the replacement AVI resource to be
   // played while the dialog is shown. This will replace the current
   // animation being shown.
   
   void
   UpdateAnimation(int newAnimationResId);


   
   void
   UpdateText(const String& message);

   void
   UpdateText(int textStringResID);

   void
   UpdateButton(const String& text);

   void
   UpdateButton(int textStringResID);

   enum WaitCode
   {
      PRESSED = 0,
      TIMEOUT = WAIT_TIMEOUT
   };

   // blocks calling thread until the button is pressed or the timeout
   // expires.

   WaitCode
   WaitForButton(int timeoutMillis);

   private:

   // Dialog overrides

   virtual
   void
   OnDestroy();

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   virtual
   bool
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

   ThreadProc                       threadProc;
   int                              animationResId;
   struct WrapperThreadProcParams*  threadParams;
   HANDLE                           buttonEventHandle;

   // not defined: no copying allowed

   ProgressDialog(const ProgressDialog&);
   const ProgressDialog& operator=(const ProgressDialog&);
};



#endif   // PROGRESSDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\postop.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Post-operation code
//
// 1 Dec 1999 sburns



#include "headers.hxx"
#include "ProgressDialog.hpp"
#include "state.hpp"
#include "shortcut.hpp"
#include "dnssetup.hpp"
#include "resource.h"



void
InstallDisplaySpecifiers(ProgressDialog& dialog)
{
   LOG_FUNCTION(InstallDisplaySpecifiers);

   State& state = State::GetInstance();

   // applies only to 1st dc in forest
   ASSERT(state.GetOperation() == State::FOREST);
 
   HRESULT hr = S_OK;
   do
   {
      // install display specifiers for all locales supported by the
      // product.  298923, 380160

      RegistryKey key;

      // REVIEWED-2002/02/28-sburns we should not adjust the SD on this key,
      // as we don't own it.
      
      hr = key.Create(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE);
      BREAK_ON_FAILED_HRESULT(hr);

      String exePath = Win::GetSystemDirectory() + L"\\dcphelp.exe";
               
      // REVIEWED-2002/02/27-sburns we're using the full path to the exe.
                     
      hr = key.SetValue(L"dcpromo disp spec import", exePath);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         dialog.GetHWND(),
         hr,
         IDS_LANGUAGE_FIXUP_FAILED);
      state.AddFinishMessage(
         String::load(IDS_LANGUAGE_FIXUP_FAILED_FINISH));
   }
}



void
DoDnsConfiguration(ProgressDialog& dialog)
{
   LOG_FUNCTION(DoDnsConfiguration);

   State& state = State::GetInstance();

   // applies only in new domain scenarios
   
   ASSERT(
         state.GetOperation() == State::FOREST
      || state.GetOperation() == State::TREE
      || state.GetOperation() == State::CHILD);

   if (state.ShouldInstallAndConfigureDns())
   {
      String domain = state.GetNewDomainDNSName();
      if (
         !InstallAndConfigureDns(
            dialog,
            domain,
            state.GetOperation() == State::FOREST) )
      {
         state.AddFinishMessage(String::load(IDS_ERROR_DNS_CONFIG_FAILED));
      }
   }
}



// Disables media sense so that the tcp/ip stack doesn't unload if the
// net card is yanked.  This to allow laptop demos of the DS.  353687

void
DisableMediaSense()
{
   LOG_FUNCTION(DisableMediaSense);

   HRESULT hr = S_OK;
   do
   {
      RegistryKey key;

      static String
         TCPIP_KEY(L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters");

      // We should not attempt to create this key if it is not already
      // present: if it is not there, then tcp/ip is not installed, and
      // setting this media sense value is pointless. So we use Open here.
               
      hr = key.Open(HKEY_LOCAL_MACHINE, TCPIP_KEY, KEY_SET_VALUE);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = key.SetValue(L"DisableDHCPMediaSense", 1);
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"DHCP Media sense disabled");
   }
   while (0);

#ifdef LOGGING_BUILD
   if (FAILED(hr))
   {
      LOG(L"DHCP Media sense NOT disabled");
   }
#endif

}
   


// Disables an old LSA notification thing. 326033

void
DisablePassfiltDll()
{
   LOG_FUNCTION(DisablePassfiltDll);

   HRESULT hr = S_OK;
   do
   {
      RegistryKey key;

      static const String
         LSA_KEY(L"System\\CurrentControlSet\\Control\\Lsa");

      static const String NOTIFICATION_VALUE(L"Notification Packages");
         
      hr =
         key.Open(
            HKEY_LOCAL_MACHINE,

            // REVIEWED-2002/02/28-sburns this level of access is correct.
               
            LSA_KEY,
            KEY_READ | KEY_WRITE | KEY_QUERY_VALUE);
      BREAK_ON_FAILED_HRESULT(hr);

      StringList values;
      hr = key.GetValue(NOTIFICATION_VALUE, std::back_inserter(values));
      BREAK_ON_FAILED_HRESULT(hr);

      // remove all instances of "passfilt.dll" from the set of strings, if
      // present.  
      static String PASSFILT(L"passfilt.dll");
      size_t startElements = values.size();

      StringList::iterator last = values.end();
      for (
         StringList::iterator i = values.begin();
         i != last;
         /* empty */ )
      {
         if (i->icompare(PASSFILT) == 0)
         {
            values.erase(i++);
         }
         else
         {
            ++i;
         }
      }

      // if changed, write it back to the registry
      if (values.size() != startElements)
      {
         hr = key.SetValue(NOTIFICATION_VALUE, values.begin(), values.end());
         BREAK_ON_FAILED_HRESULT(hr);

         LOG(L"passfilt.dll removed");
      }
      else
      {
         LOG(L"passfilt.dll not found");
      }
   }
   while (0);

#ifdef LOGGING_BUILD
   if (FAILED(hr))
   {
      LOG(L"Notification Packages not updated due to error.");
   }
#endif

}



// If the promotion was for a downlevel DC upgrade, then check if the local
// machine's dns hostname is bad, if so, add a message to the finish page.  A
// bad name is one we believe will have problems being registered in DNS after
// a promotion.
// 
// Since the computer cannot be renamed during a downlevel upgrade, we defer
// this message til the end of the upgrade.  (If the machine is not a
// downlevel upgrade, then the wizard startup code detects the bad name and
// blocks until the name is fixed.

void
CheckComputerNameOnDownlevelUpgrade()
{
   LOG_FUNCTION(CheckComputerNameOnDownlevelUpgrade);

   State& state = State::GetInstance();

   State::RunContext context = state.GetRunContext();
   if (
         context != State::BDC_UPGRADE
      && context != State::PDC_UPGRADE)
   {
      // machine is not a downlevel DC upgrade, so we need do nothing

      return;
   }
   
   // Then check the computer name to ensure that it can be registered in
   // DNS.

   String hostname =
      Win::GetComputerNameEx(::ComputerNamePhysicalDnsHostname);

   DNS_STATUS status =
      MyDnsValidateName(hostname, ::DnsNameHostnameLabel);

   switch (status)
   {
      case DNS_ERROR_NON_RFC_NAME:
      {
         state.AddFinishMessage(
            String::format(
               IDS_FINISH_NON_RFC_COMPUTER_NAME,
               hostname.c_str()));
         break;   
      }
      case DNS_ERROR_NUMERIC_NAME:
      {
         state.AddFinishMessage(
            String::format(
               IDS_FINISH_NUMERIC_COMPUTER_NAME,
               hostname.c_str()));
         break;
      }
      case DNS_ERROR_INVALID_NAME_CHAR:
      case ERROR_INVALID_NAME:
      {
         state.AddFinishMessage(
            String::format(
               IDS_FINISH_BAD_COMPUTER_NAME,
               hostname.c_str()));
         break;
      }
      case ERROR_SUCCESS:
      default:
      {
            
         break;
      }
   }
}



void
DoPostOperationStuff(ProgressDialog& progress)
{
   LOG_FUNCTION(DoPostOperationStuff);

   State& state = State::GetInstance();                  

   switch (state.GetOperation())
   {
      case State::FOREST:
      {
         // a new forest has been created

         InstallDisplaySpecifiers(progress);       // 228682

         // fall-thru
      }
      case State::TREE:
      case State::CHILD:
      {
         // a new domain has been created

         DoDnsConfiguration(progress);

         // fall-thru
      }
      case State::REPLICA:
      {
         // DoToolsInstallation(progress);   // 220660

         PromoteConfigureToolShortcuts(progress);

         DisableMediaSense();             // 353687
         DisablePassfiltDll();            // 326033
         
         // NTRAID#NTBUG9-268715-2001/01/04-sburns
         CheckComputerNameOnDownlevelUpgrade(); 
         
         break;
      }
      case State::ABORT_BDC_UPGRADE:
      case State::DEMOTE:
      {
         DemoteConfigureToolShortcuts(progress);   // 366738
         break;
      }
      case State::NONE:
      {
         ASSERT(false);
         break;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\readmepage.hpp ===
// Copyright (C) 2002 Microsoft Corporation
//
// readme page
// NTRAID#NTBUG9-510384-2002/01/04-sburns
//
// 04 January 2002 sburns



#ifndef READMEPAGE_HPP_INCLUDED
#define READMEPAGE_HPP_INCLUDED



class ReadmePage : public DCPromoWizardPage
{
   public:

   ReadmePage();

   protected:

   virtual ~ReadmePage();

   // Dialog overrides

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lParam);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   InitializeBullets();

   HFONT bulletFont;
   
   // not defined; no copying allowed
   ReadmePage(const ReadmePage&);
   const ReadmePage& operator=(const ReadmePage&);
};



#endif   // READMEPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\rebootdialog.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Dlg to confirm reboot
//
// 12-12-97 sburns



#include "headers.hxx"
#include "RebootDialog.hpp"
#include "resource.h"



static const DWORD HELP_MAP[] =
{
   0, 0
};



RebootDialog::RebootDialog(bool forFailure)
   :
   Dialog(
      forFailure ? IDD_REBOOT_FAILURE : IDD_REBOOT,
      HELP_MAP)
{
   LOG_CTOR(RebootDialog);
}



RebootDialog::~RebootDialog()
{
   LOG_DTOR(RebootDialog);
}



bool
RebootDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(RebootDialog::OnCommand);

   if (code == BN_CLICKED)
   {
      switch (controlIDFrom)
      {
         case IDC_RESTART_NOW:
         {
            HRESULT unused = Win::EndDialog(hwnd, 1);

            ASSERT(SUCCEEDED(unused));

            return true;
         }
         case IDCANCEL:
         case IDC_RESTART_LATER:
         {
            HRESULT unused = Win::EndDialog(hwnd, 0);

            ASSERT(SUCCEEDED(unused));

            return true;
         }
         default:
         {
            // do nothing
         }
      }
   }

   return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\readmepage.cpp ===
// Copyright (C) 2002 Microsoft Corporation
//
// readme page
// NTRAID#NTBUG9-510384-2002/01/04-sburns
// To be restored in Lornhorn NTRAID#NTBUG9-524242-2002/01/22-sburns
//
// 04 January 2002 sburns



#include "headers.hxx"
#include "page.hpp"
#include "ReadmePage.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"



ReadmePage::ReadmePage()
   :
   DCPromoWizardPage(
      IDD_README,
      IDS_README_PAGE_TITLE,
      IDS_README_PAGE_SUBTITLE),
   bulletFont(0)   
{
   LOG_CTOR(ReadmePage);
}



ReadmePage::~ReadmePage()
{
   LOG_DTOR(ReadmePage);

   if (bulletFont)
   {
      HRESULT hr = Win::DeleteObject(bulletFont);
      ASSERT(SUCCEEDED(hr));
   }
}



bool
ReadmePage::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   /* lParam */ )
{
//   LOG_FUNCTION(ReadmePage::OnNotify);

   bool result = false;
   
   switch (code)
   {
      case NM_CLICK:
      case NM_RETURN:
      {
         switch (controlIDFrom)
         {
            case IDC_PRIMER_LINK:
            {
               Win::HtmlHelp(
                  hwnd,
                  L"adconcepts.chm::/sag_AD_DCInstallTopNode.htm",
                  HH_DISPLAY_TOPIC,
                  0);
               result = true;
               break;
            }
            case IDC_DEPLOY_LINK:
            {
               HRESULT hr =
                  Win32ToHresult(
                     (DWORD) (UINT_PTR) ShellExecute(
                        0,
                        L"open",
                        L"http://www.microsoft.com/activedirectory",
                        0,
                        0,
   
                        // this brings the new window to the foreground
                        // with focus
            
                        SW_SHOWNORMAL ));
               if (FAILED(hr))
               {
                  LOG(
                     String::format(
                        L"Failed to launch webpage: hr = 0x%1!x!",
                        hr));
               }

               result = true;
               break;
            }
            default:
            {
               // do nothing
               
               break;
            }
         }
      }
      default:
      {
         // do nothing
         
         break;
      }
   }
   
   return result;
}



void
ReadmePage::OnInit()
{
   LOG_FUNCTION(ReadmePage::OnInit);

   InitializeBullets();
}



void
ReadmePage::InitializeBullets()
{
   LOG_FUNCTION(BeforeBeginPage::InitializeBulletedList);
   ASSERT(!bulletFont);
   
   bulletFont =
      ::CreateFont(
         0,
         0,
         0,
         0,
         FW_NORMAL,
         0,
         0,
         0,
         SYMBOL_CHARSET,
         OUT_CHARACTER_PRECIS,
         CLIP_CHARACTER_PRECIS,
         PROOF_QUALITY,
         VARIABLE_PITCH | FF_DONTCARE,
         L"Marlett");

   if (bulletFont)
   {
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET1), bulletFont, true);
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET2), bulletFont, true);
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET3), bulletFont, true);
   }
   else
   {
      LOG(String::format(
             L"Failed to create font for bullet list: hr = %1!x!",
             Win::GetLastErrorAsHresult()));
   }
}



bool
ReadmePage::OnSetActive()
{
   LOG_FUNCTION(ReadmePage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   Win::PostMessage(
      Win::GetParent(hwnd),
      WM_NEXTDLGCTL,
      (WPARAM) Win::GetDlgItem(Win::GetParent(hwnd), Wizard::NEXT_BTN_ID),
      TRUE);
      
   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   return true;
}



int
ReadmePage::Validate()
{
   LOG_FUNCTION(ReadmePage::Validate);
   int nextPage = -1;

   State& state = State::GetInstance();
   switch (state.GetRunContext())
   {
      case State::PDC_UPGRADE:
      case State::NT5_STANDALONE_SERVER:
      case State::NT5_MEMBER_SERVER:
      {
         nextPage = IDD_INSTALL_TCPIP;
         break;
      }
      case State::BDC_UPGRADE:
      {
         nextPage = IDD_REPLICA_OR_MEMBER;
         break;
      }
      case State::NT5_DC:
      {
         // The welcome page should not have sent the user to this page
         // in the demote case.
         
         ASSERT(false);
         
         state.SetOperation(State::DEMOTE);

         // NTRAID#NTBUG9-496409-2001/11/29-sburns
         
         if (state.IsForcedDemotion())
         {
            nextPage = IDD_FORCE_DEMOTE;
         }
         else
         {
            nextPage = IDD_DEMOTE;
         }
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\replicaormemberpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// welcome page
//
// 12-16-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "ReplicaOrMemberPage.hpp"
#include "resource.h"
#include "ds.hpp"
#include "state.hpp"



ReplicaOrMemberPage::ReplicaOrMemberPage()
   :
   DCPromoWizardPage(
      IDD_REPLICA_OR_MEMBER,
      IDS_REPLICA_OR_MEMBER_PAGE_TITLE,
      IDS_REPLICA_OR_MEMBER_PAGE_SUBTITLE)
{
   LOG_CTOR(ReplicaOrMemberPage);
}



ReplicaOrMemberPage::~ReplicaOrMemberPage()
{
   LOG_DTOR(ReplicaOrMemberPage);
}



void
ReplicaOrMemberPage::OnInit()
{
   LOG_FUNCTION(ReplicaOrMemberPage::OnInit);

   State& state = State::GetInstance();

   Win::SetDlgItemText(
      hwnd,
      IDC_PROMPT,
      String::format(
         IDS_BDC_UPGRADE_PROMPT,
         state.GetComputer().GetDomainNetbiosName().c_str()));

   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(AnswerFile::OPTION_REPLICA_OR_MEMBER);
      if (option.icompare(AnswerFile::VALUE_REPLICA) == 0)
      {
         Win::CheckDlgButton(hwnd, IDC_REPLICA, BST_CHECKED);
         return;
      }
   }

   Win::CheckDlgButton(hwnd, IDC_MEMBER, BST_CHECKED);
}



bool
ReplicaOrMemberPage::OnSetActive()
{
   LOG_FUNCTION(ReplicaOrMemberPage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   return true;
}



int
ReplicaOrMemberPage::Validate()
{
   LOG_FUNCTION(ReplicaOrMemberPage::Validate);

   State& state = State::GetInstance();
   int nextPage = -1;
   if (Win::IsDlgButtonChecked(hwnd, IDC_REPLICA))
   {
      state.SetOperation(State::REPLICA);
      nextPage = IDD_INSTALL_TCPIP;
   }
   else
   {
      ASSERT(Win::IsDlgButtonChecked(hwnd, IDC_MEMBER));
      state.SetOperation(State::ABORT_BDC_UPGRADE);
      nextPage = IDD_GET_CREDENTIALS;
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\replicaormemberpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// replica or member server page
//
// 12-16-97 sburns



#ifndef REPLMEM_HPP_INCLUDED
#define REPLMEM_HPP_INCLUDED



#include "page.hpp"



class ReplicaOrMemberPage : public DCPromoWizardPage
{
   public:

   ReplicaOrMemberPage();

   protected:

   virtual ~ReplicaOrMemberPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   ReplicaOrMemberPage(const ReplicaOrMemberPage&);
   const ReplicaOrMemberPage& operator=(const ReplicaOrMemberPage&);
};



#endif   // REPLMEM_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\replicaornewdomainpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// replica or new domain page
//
// 12-19-97 sburns



#ifndef REPLICAORNEWDOMAINPAGE_HPP_INCLUDED
#define REPLICAORNEWDOMAINPAGE_HPP_INCLUDED



class ReplicaOrNewDomainPage : public DCPromoWizardPage
{
   public:

   ReplicaOrNewDomainPage();

   protected:

   virtual ~ReplicaOrNewDomainPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   ReplicaOrNewDomainPage(const ReplicaOrNewDomainPage&);
   const ReplicaOrNewDomainPage& operator=(const ReplicaOrNewDomainPage&);

   HICON warnIcon;
};



#endif   // REPLICAORNEWDOMAINPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\rebootdialog.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Dlg to confirm reboot
//
// 12-12-97 sburns



#ifndef REBOOTDIALOG_HPP_INCLUDED
#define REBOOTDIALOG_HPP_INCLUDED


                        
class RebootDialog : public Dialog
{
   public:


   
   // forFailure - true if a reboot is needed but the operation failed anyway.
   
   RebootDialog(bool forFailure);


   
   virtual ~RebootDialog();


   
   private:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   // not defined: no copying allowed

   RebootDialog(const RebootDialog&);
   const RebootDialog& operator=(const RebootDialog&);
};



#endif   // REBOOTDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\replicaornewdomainpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// replica or new domain page
//
// 12-19-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "ReplicaOrNewDomainPage.hpp"
#include "resource.h"
#include "ds.hpp"
#include "state.hpp"



ReplicaOrNewDomainPage::ReplicaOrNewDomainPage()
   :
   DCPromoWizardPage(
      IDD_REPLICA_OR_DOMAIN,
      IDS_REPLICA_OR_DOMAIN_PAGE_TITLE,
      IDS_REPLICA_OR_DOMAIN_PAGE_SUBTITLE),
   warnIcon(0)
{
   LOG_CTOR(ReplicaOrNewDomainPage);
}



ReplicaOrNewDomainPage::~ReplicaOrNewDomainPage()
{
   LOG_DTOR(ReplicaOrNewDomainPage);

   if (warnIcon)
   {
      Win::DestroyIcon(warnIcon);
   }
}



void
ReplicaOrNewDomainPage::OnInit()
{
   LOG_FUNCTION(ReplicaOrNewDomainPage::OnInit);

   HRESULT hr = Win::LoadImage(IDI_WARN, warnIcon);
   ASSERT(SUCCEEDED(hr));

   Win::SendMessage(
      Win::GetDlgItem(hwnd, IDC_WARNING_ICON),
      STM_SETICON,
      reinterpret_cast<WPARAM>(warnIcon),
      0);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(AnswerFile::OPTION_REPLICA_OR_NEW_DOMAIN);
      Win::CheckDlgButton(
         hwnd,
            (option.icompare(AnswerFile::VALUE_DOMAIN) == 0)
         ?  IDC_NEW_DOMAIN
         :  IDC_REPLICA,
         BST_CHECKED);
      return;
   }

   Win::CheckDlgButton(hwnd, IDC_NEW_DOMAIN, BST_CHECKED);
}



bool
ReplicaOrNewDomainPage::OnSetActive()
{
   LOG_FUNCTION(ReplicaOrNewDomainPage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }

   return true;
}



int
ReplicaOrNewDomainPage::Validate()
{
   LOG_FUNCTION(ReplicaOrNewDomainPage::Validate);

   State& state = State::GetInstance();
   int nextPage = -1;
   if (Win::IsDlgButtonChecked(hwnd, IDC_REPLICA))
   {
      state.SetOperation(State::REPLICA);
      nextPage = IDD_REPLICATE_FROM_MEDIA; // IDD_CONFIG_DNS_CLIENT;
   }
   else
   {
      ASSERT(Win::IsDlgButtonChecked(hwnd, IDC_NEW_DOMAIN));
      state.SetOperation(State::NONE);
      nextPage = IDD_NEW_DOMAIN;
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\replicapage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// replica page
//
// 12-22-97 sburns



#ifndef REPLICAPAGE_HPP_INCLUDED
#define REPLICAPAGE_HPP_INCLUDED



class ReplicaPage : public DCPromoWizardPage
{
   public:

   ReplicaPage();

   protected:

   virtual ~ReplicaPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   Enable();

   bool
   ShouldSkipPage();

   // not defined; no copying allowed

   ReplicaPage(const ReplicaPage&);
   const ReplicaPage& operator=(const ReplicaPage&);
};



#endif   // REPLICAPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\replicapage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// replica page
//
// 12-22-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "ReplicaPage.hpp"
#include "resource.h"
#include "ds.hpp"
#include "common.hpp"
#include "state.hpp"
#include "dns.hpp"
#include <ValidateDomainName.hpp>
#include <ValidateDomainName.h>


ReplicaPage::ReplicaPage()
   :
   DCPromoWizardPage(
      IDD_REPLICA,
      IDS_REPLICA_PAGE_TITLE,
      IDS_REPLICA_PAGE_SUBTITLE)
{
   LOG_CTOR(ReplicaPage);
}



ReplicaPage::~ReplicaPage()
{
   LOG_DTOR(ReplicaPage);
}



void
ReplicaPage::Enable()
{
   int next =
         !Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN).empty()
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | next);
}



bool
ReplicaPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(ReplicaPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_BROWSE:
      {
         if (code == BN_CLICKED)
         {
            String domain = BrowseForDomain(hwnd);
            if (!domain.empty())
            {
               Win::SetDlgItemText(hwnd, IDC_DOMAIN, domain);
            }

            return true;
         }
         break;
      }
      case IDC_DOMAIN:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);            
            Enable();
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



void
ReplicaPage::OnInit()
{
   LOG_FUNCTION(ReplicaPage::OnInit);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_DOMAIN),
      DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY);

   State& state = State::GetInstance();

   if (state.UsingAnswerFile())
   {
      // Ignore the answerfile if we got the domain name from the
      // ReplicateFromMediaPage.

      if (
            !state.ReplicateFromMedia()
         || state.GetReplicaDomainDNSName().empty())
      {
         Win::SetDlgItemText(
            hwnd,
            IDC_DOMAIN,
            state.GetAnswerFileOption(
               AnswerFile::OPTION_REPLICA_DOMAIN_NAME));
      }
   }
   else
   {
      // default domain is that the server is joined to.

      Win::SetDlgItemText(
         hwnd,
         IDC_DOMAIN,
         state.GetComputer().GetDomainDnsName());
   }
}



bool
ReplicaPage::ShouldSkipPage()
{
   LOG_FUNCTION(ReplicaPage::ShouldSkipPage);

   bool result = false;

   State& state = State::GetInstance();

   do
   {
      // check to see if we got the domain name from the
      // ReplicateFromMediaPage. If so, then we don't need to show this
      // page.

      if (
            state.ReplicateFromMedia()
         && !state.GetReplicaDomainDNSName().empty() )
      {
         // dns domain name is from the ReplicateFromMediaPage, which
         // saved that name in the state instance.  So put that name
         // in the ui.

         Win::SetDlgItemText(
            hwnd,
            IDC_DOMAIN,
            state.GetReplicaDomainDNSName());

         result = true;
         break;
      }

      if (state.RunHiddenUnattended())
      {
         result = true;
         break;
      }
   }
   while (0);

   LOG(result ? L"true" : L"false");

   return result;
}
   


bool
ReplicaPage::OnSetActive()
{
   LOG_FUNCTION(ReplicaPage::OnSetActive);
   ASSERT(State::GetInstance().GetOperation() == State::REPLICA);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   State& state = State::GetInstance();
   if (ShouldSkipPage())
   {
      LOG(L"skipping ReplicaPage");

      Wizard& wiz = GetWizard();

      if (wiz.IsBacktracking())
      {
         // backup once again
         wiz.Backtrack(hwnd);
         return true;
      }

      int nextPage = ReplicaPage::Validate();
      if (nextPage != -1)
      {
         wiz.SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }

   Enable();
   return true;
}



int
ReplicaPage::Validate()
{
   LOG_FUNCTION(ReplicaPage::Validate);

   int nextPage = -1;

   // SPB:251431 do validation even if this page is untouched, as upstream
   // pages may have been changed in such a fashion that re-validation is
   // required.
   // if (!WasChanged(IDC_DOMAIN))
   // {
   //    return nextPage;
   // }

   do
   {
      String domain = Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN);
      if (domain.empty())
      {
         popup.Gripe(hwnd, IDC_DOMAIN, IDS_MUST_ENTER_DOMAIN);
         break;
      }

      State& state = State::GetInstance();

      if (
         !ValidateDomainDnsNameSyntax(
            hwnd,
            IDC_DOMAIN,
            popup,
            
            // only warn on non RFC names if running interactively

            !state.RunHiddenUnattended()) )
      {
         break;
      }

      // now ensure that the domain exists

      String dnsName;
      if (!ValidateDomainExists(hwnd, IDC_DOMAIN, dnsName))
      {
         break;
      }
      if (!dnsName.empty())
      {
         // the user specified the netbios name of the domain, and
         // confirmed it, so use the dns domain name returned.

         Win::SetDlgItemText(hwnd, IDC_DOMAIN, dnsName);
         domain = dnsName;
      }
         
      if (!state.IsDomainInForest(domain))
      {
         popup.Gripe(
            hwnd,
            IDC_DOMAIN,
            String::format(
               IDS_DOMAIN_NOT_IN_FOREST,
               domain.c_str(),
               state.GetUserForestName().c_str()));
         break;
      }
         
      // valid

      ClearChanges();
      state.SetReplicaDomainDNSName(domain);

      nextPage = IDD_PATHS;
   }
   while (0);

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\replicatefrommediapage.hpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// install replica from media page
//
// 7 Feb 2000 sburns



#ifndef REPLICATEFROMMEDIAPAGE_HPP_INCLUDED
#define REPLICATEFROMMEDIAPAGE_HPP_INCLUDED



class ReplicateFromMediaPage : public DCPromoWizardPage
{
   public:

   ReplicateFromMediaPage();

   protected:

   virtual ~ReplicateFromMediaPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   Enable();

   // not defined; no copying allowed

   ReplicateFromMediaPage(const ReplicateFromMediaPage&);
   const ReplicateFromMediaPage& operator=(const ReplicateFromMediaPage&);
};



#endif   // REPLICATEFROMMEDIAPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\replicatefrommediapage.cpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// install replica from media page
//
// 7 Feb 2000 sburns



#include "headers.hxx"
#include "resource.h"
#include "common.hpp"
#include "page.hpp"
#include "ReplicateFromMediaPage.hpp"
#include "state.hpp"
#include "SyskeyDiskDialog.hpp"
#include "SyskeyPromptDialog.hpp"



ReplicateFromMediaPage::ReplicateFromMediaPage()
   :
   DCPromoWizardPage(
      IDD_REPLICATE_FROM_MEDIA,
      IDS_REPLICATE_FROM_MEDIA_PAGE_TITLE,
      IDS_REPLICATE_FROM_MEDIA_PAGE_SUBTITLE)
{
   LOG_CTOR(ReplicateFromMediaPage);
}



ReplicateFromMediaPage::~ReplicateFromMediaPage()
{
   LOG_DTOR(ReplicateFromMediaPage);
}



String
FirstFixedDisk()
{
   LOG_FUNCTION(FirstFixedDisk);

   String result;

   do
   {
      StringVector dl;
      HRESULT hr = FS::GetValidDrives(std::back_inserter(dl));
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(dl.size());

      for (
         StringVector::iterator i = dl.begin();
         i != dl.end();
         ++i)
      {
         String rootPath = *i + L"\\";

         if (Win::GetDriveType(rootPath) == DRIVE_FIXED)
         {
            result = *i;
            break;
         }
      }
   }
   while (0);

   if (result.empty())
   {
      // This is deadcode, really, cause we're sure to find a fixed volume
      // somewhere

      result = FS::GetRootFolder(Win::GetSystemDirectory()).substr(0, 3);
   }

   LOG(result);

   return result;
}



void
ReplicateFromMediaPage::OnInit()
{
   LOG_FUNCTION(ReplicateFromMediaPage::OnInit);

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_SOURCE), MAX_PATH);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(AnswerFile::OPTION_SOURCE_PATH);
      if (!option.empty())
      {
         Win::CheckDlgButton(hwnd, IDC_USE_FILES, BST_CHECKED);
      
         Win::SetDlgItemText(
            hwnd,
            IDC_SOURCE,
            Win::ExpandEnvironmentStrings(option));

         return;
      }
   }

   Win::CheckDlgButton(hwnd, IDC_USE_NET, BST_CHECKED);

   String root = FirstFixedDisk();
   Win::SetDlgItemText(
      hwnd,
      IDC_SOURCE,
      root + String::load(IDS_SOURCE_SUFFIX));
}



void
ReplicateFromMediaPage::Enable()
{
   int next = PSWIZB_NEXT;

   bool useFiles = Win::IsDlgButtonChecked(hwnd, IDC_USE_FILES);

   if (useFiles)
   {
      // if using files, the edit box must have some text.

      if (Win::GetTrimmedDlgItemText(hwnd, IDC_SOURCE).empty())
      {
         next = 0;
      }
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | next);

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_SOURCE), useFiles);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_BROWSE), useFiles);
}



bool
ReplicateFromMediaPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(ReplicateFromMediaPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_USE_NET:
      case IDC_USE_FILES:
      {
         if (code == BN_CLICKED)
         {
            SetChanged(controlIDFrom);
            Enable();
            return true;
         }
      }
      case IDC_BROWSE:
      {
         if (code == BN_CLICKED)
         {
            String path = BrowseForFolder(hwnd, IDS_SOURCE_BROWSE_TITLE);
            if (!path.empty())
            {
               Win::SetDlgItemText(hwnd, IDC_SOURCE, path);
            }

            return true;
         }
         break;
      }
      case IDC_SOURCE:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            Enable();
            return true;
         }
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return false;
}



bool
ReplicateFromMediaPage::OnSetActive()
{
   LOG_FUNCTION(ReplicateFromMediaPage::OnSetActive);
   ASSERT(State::GetInstance().GetOperation() == State::REPLICA);
      
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended() || !state.IsAdvancedMode())
   {
      LOG(L"skipping ReplicateFromMediaPage");

      Wizard& wiz = GetWizard();

      if (wiz.IsBacktracking())
      {
         // backup once again
         wiz.Backtrack(hwnd);
         return true;
      }

      int nextPage = ReplicateFromMediaPage::Validate();
      if (nextPage != -1)
      {
         wiz.SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }

   Enable();
   return true;
}



bool
ValidateSourcePath(HWND parent, const String& path, int editResId)
{
   LOG_FUNCTION2(ValidateSourcePath, path);

   bool result = false;

   do
   {
      if (path.empty())
      {
         popup.Gripe(
            parent,
            editResId,
            IDS_MUST_ENTER_SOURCE_PATH);
         break;
      }

      // Path must have a drive letter

      FS::PathSyntax syn = FS::GetPathSyntax(path);
      if (syn != FS::SYNTAX_ABSOLUTE_DRIVE)
      {
         popup.Gripe(
            parent,
            editResId,
            String::format(IDS_BAD_PATH_FORMAT, path.c_str()));
         break;
      }

      // mapped network drives are not ok.  This is because the DsRole apis
      // copy the restored files on the server side of the api, in the
      // system context.
      // NTRAID#NTBUG9-309422-2001/02/12-sburns
      
      UINT type = Win::GetDriveType(path);
      switch (type)
      {
         // allow CDs and removeable media, too
         // NTRAID#NTBUG9-648713-2002/06/25-sburns
         
         case DRIVE_FIXED:
         case DRIVE_CDROM:
         case DRIVE_RAMDISK:
         case DRIVE_REMOVABLE:
         {
            result = true;
            break;
         }
         case DRIVE_UNKNOWN:
         case DRIVE_NO_ROOT_DIR:
         case DRIVE_REMOTE:
         default:
         {
            popup.Gripe(
               parent,
               editResId,
               String::format(IDS_BAD_DRIVE_TYPE, path.c_str()));
            break;
         }
      }
   }
   while (0);

   LOG(result ? L"true" : L"false")
         
   return result;
}



// Return true on success, false on failure

bool
GetDatabaseFacts(HWND parent, const String& sourcePath)
{
   LOG_FUNCTION2(GetDatabaseFacts, sourcePath);
   DSROLE_IFM_OPERATION_HANDLE IfmHandle;
   ASSERT(Win::IsWindow(parent));
   ASSERT(!sourcePath.empty());

   bool result = false;
   
   PWSTR dnsDomainName = 0;

   State& state = State::GetInstance();
   state.SetIsBackupGc(false);
   state.SetSyskeyLocation(State::STORED);
   // If there was an IfmHandle already, free it.
   state.FreeIfmHandle(); 

   LOG(L"Calling DsRoleGetDatabaseFacts");
   LOG(String::format(L"lpRestorePath: %1", sourcePath.c_str()));

   ULONG facts = 0;
   HRESULT hr = 
      Win32ToHresult(
         ::DsRoleGetDatabaseFacts(
            0,    // this server
            sourcePath.c_str(),
            &dnsDomainName,
            &facts,
            &IfmHandle));

   LOG_HRESULT(hr);

   if (SUCCEEDED(hr) && IfmHandle)
   {
      LOG(String::format(L"lpDNSDomainName: %1", dnsDomainName ? dnsDomainName : L"(null)"));
      LOG(String::format(L"State          : 0x%1!X!", facts));

      if (IfmHandle) {
          state.SetIfmHandle(IfmHandle);
      }

      if (dnsDomainName)
      {
         // Save this domain name.  This will allow us to skip the ReplicaPage
         // since we now know the domain name.
         state.SetReplicaDomainDNSName(dnsDomainName);
         MIDL_user_free(dnsDomainName);
      }

      if (facts & DSROLE_DC_IS_GC)
      {
         LOG(L"is gc");

         state.SetIsBackupGc(true);
      }

      if (facts & DSROLE_KEY_DISK)
      {
         LOG(L"syskey on disk");

         state.SetSyskeyLocation(State::DISK);
      }
      else if (facts & DSROLE_KEY_PROMPT)
      {
         LOG(L"prompt for syskey");

         state.SetSyskeyLocation(State::PROMPT);
      }
      else if (facts & DSROLE_KEY_STORED)
      {
         LOG(L"syskey stored");

         // we set this as the default value, above.
      }
      else
      {
         // The api is insane.

         ASSERT(false);

         LOG(L"unexpected State value");
      }

      result = true;
   }
   else
   {
       if (SUCCEEDED(hr)) {
           ASSERT(IfmHandle == NULL);
           ASSERT(!"DsRoleGetDatabaseFacts() should never return success w/o an out param");
           hr = Win32ToHresult(ERROR_INVALID_PARAMETER);
           LOG_HRESULT(hr);
       }

      popup.Error(
         parent,
         hr,
         String::format(IDS_GET_FACTS_FAILED, sourcePath.c_str()));
   }

   LOG(result ? L"true" : L"false");

   return result;
}



int
ReplicateFromMediaPage::Validate()
{
   LOG_FUNCTION(ReplicateFromMediaPage::Validate);

   State& state = State::GetInstance();

   int nextPage = -1;

   bool useFiles = Win::IsDlgButtonChecked(hwnd, IDC_USE_FILES);

   do
   {
      // Don't check WasChanged for the radio buttons because when running
      // unattended, CheckDlgButton does not send a parent BN_CLICKED
      // notification, so WasChanged will not be set properly.
      // NTRAID#NTBUG9-602141-2002/04/15-sburns
      
      state.SetReplicateFromMedia(useFiles);

      if (!useFiles)
      {
         LOG(L"not using source media for replication");

         nextPage = IDD_CONFIG_DNS_CLIENT;
         break;
      }

      String sourcePath = Win::GetTrimmedDlgItemText(hwnd, IDC_SOURCE);

      if (ValidateSourcePath(hwnd, sourcePath, IDC_SOURCE) )
      {
         String s =
            FS::NormalizePath(Win::GetTrimmedDlgItemText(hwnd, IDC_SOURCE));

         state.SetReplicationSourcePath(s);
      }
      else
      {
         break;
      }

      // check the restored backup for the syskey, the domain name, and the DC
      // type.

      if (!GetDatabaseFacts(hwnd, sourcePath))
      {
         break;
      }

      State::SyskeyLocation loc = state.GetSyskeyLocation();
      if (loc == State::DISK)
      {
         // Check if the disk is already inserted
         // NTRAID#NTBUG9-522250-2002/01/23-sburns
         
         if (FAILED(SyskeyDiskDialog::LocateSyskey(0)))
         {
            if (SyskeyDiskDialog().ModalExecute(hwnd) != IDOK)
            {
               break;
            }
         }
      }
      else if (loc == State::PROMPT)
      {
         if (SyskeyPromptDialog().ModalExecute(hwnd) != IDOK)
         {
            break;
         }
      }

      // The syskey is present, do we need to jump to the GC confirmation?

      if (state.IsBackupGc())
      {
         nextPage = IDD_GC_CONFIRM;
         break;
      }

      // The syskey is present, the backup is not a gc, so move along

      nextPage = IDD_CONFIG_DNS_CLIENT;
   }
   while (0);

   if (nextPage != -1)
   {
      // only clear changes when the user has specified valid options.
      // otherwise, we want to go thru the validation until he gets it
      // right.

      ClearChanges();
   }
    
   LOG(String::format(L"next = %1!d!", nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_WIZARD_TITLE                2
#define IDS_BIG_BOLD_FONT_NAME          3
#define IDS_BIG_BOLD_FONT_SIZE          4
#define IDS_WORKSTATION_NOT_SUPPORTED   5
#define IDS_CONVERT_PDC_FIRST           8
#define IDS_COULDNT_REMOVE_COMPUTER_ACCOUNT_TEXT 11
#define IDS_OPERATION_FAILED            13
#define IDS_OPERATION_DONE              15
#define IDS_OPERATION_TERMINATED        16
#define IDS_DISJOIN_DOMAIN_FAILED       17
#define IDS_JOIN_DOMAIN_FAILED          18
#define IDS_FIRST_SITE                  24
#define IDS_CHILD_PAGE_TITLE            25
#define IDS_CHILD_PAGE_SUBTITLE         26
#define IDS_CONFIRMATION_PAGE_TITLE     27
#define IDS_CONFIRMATION_PAGE_SUBTITLE  28
#define IDS_CREDENTIALS_PAGE_TITLE      29
#define IDS_CREDENTIALS_PAGE_SUBTITLE   30
#define IDS_CONFIG_DNS_CLIENT_PAGE_TITLE 31
#define IDS_CONFIG_DNS_CLIENT_PAGE_SUBTITLE 32
#define IDS_DNS_ON_NET_PAGE_TITLE       35
#define IDS_DNS_ON_NET_PAGE_SUBTITLE    36
#define IDS_FAILURE_PAGE_SUBTITLE       37
#define IDS_FAILURE_PAGE_TITLE          38
#define IDS_FINISH_PAGE_SUBTITLE        39
#define IDS_FINISH_PAGE_TITLE           40
#define IDS_NEW_FOREST_PAGE_SUBTITLE    41
#define IDS_NEW_FOREST_PAGE_TITLE       42
#define IDS_NETBIOS_NAME_PAGE_SUBTITLE  45
#define IDS_NETBIOS_NAME_PAGE_TITLE     46
#define IDS_NEW_SITE_PAGE_SUBTITLE      47
#define IDS_NEW_SITE_PAGE_TITLE         48
#define IDS_PATHS_PAGE_SUBTITLE         49
#define IDS_PATHS_PAGE_TITLE            50
#define IDS_PICK_SITE_PAGE_SUBTITLE     51
#define IDS_PICK_SITE_PAGE_TITLE        52
#define IDS_REPLICA_OR_DOMAIN_PAGE_SUBTITLE 53
#define IDS_REPLICA_OR_DOMAIN_PAGE_TITLE 54
#define IDS_REPLICA_PAGE_SUBTITLE       55
#define IDS_REPLICA_PAGE_TITLE          56
#define IDS_REPLICA_OR_MEMBER_PAGE_SUBTITLE 57
#define IDS_REPLICA_OR_MEMBER_PAGE_TITLE 58
#define IDS_INSTALL_TCPIP_PAGE_SUBTITLE 59
#define IDS_INSTALL_TCPIP_PAGE_TITLE    60
#define IDS_WELCOME_PAGE_SUBTITLE       63
#define IDS_WELCOME_PAGE_TITLE          64
#define IDS_TREE_PAGE_SUBTITLE          65
#define IDS_TREE_PAGE_TITLE             66
#define IDS_CANT_BROWSE_FOREST          67
#define IDS_PATHS2_PAGE_SUBTITLE        68
#define IDS_PATHS2_PAGE_TITLE           69
#define IDS_DB_BROWSE_TITLE             70
#define IDS_LOG_BROWSE_TITLE            71
#define IDS_SYSVOL_BROWSE_TITLE         72
#define IDS_PATH_IS_WINDIR              76
#define IDS_PATH_IS_SYSTEM32            77
#define IDS_BAD_PATH_FORMAT             78
#define IDS_BAD_DRIVE_TYPE              79
#define IDS_PATH_NOT_DIRECTORY          80
#define IDS_EMPTY_PATH                  81
#define IDS_LOW_SPACE_DB                83
#define IDS_LOW_SPACE_LOG               84
#define IDS_NOT_NTFS5                   85
#define IDS_NOT_ADMIN                   86
#define IDS_DNS_LABEL_TOO_LONG          87
#define IDS_MUST_ENTER_USERNAME         88
#define IDS_MUST_ENTER_USER_DOMAIN      89
#define IDS_NT51_REQUIRED               90
#define IDS_INTRO1_DEMOTE               91
#define IDS_INTRO2_DEMOTE               92
#define IDS_INTRO1_INSTALL              93
#define IDS_INTRO2_INSTALL              94
#define IDS_INTRO2_BDC_UPGRADE          95
#define IDS_INTRO2_PDC_UPGRADE          96
#define IDS_BAD_LABEL_SYNTAX            99
#define IDS_BAD_SITE_SYNTAX             100
#define IDS_CONFIG_DNS_FIRST            101
#define IDS_DEMOTE_DC_FAILED            102
#define IDI_WARN                        102
#define IDS_REPLICA_CREDENTIALS         103
#define IDD_BAD_COMPUTER_NAME           103
#define IDS_SIBLING_CREDENTIALS         104
#define IDR_AVI_DEMOTE                  104
#define IDS_PARENT_CREDENTIALS          105
#define IDD_UNATTEND_SPLASH             105
#define IDS_PARENT_DEMOTE_CREDENTIALS   106
#define IDS_DEMOTE_PAGE_SUBTITLE        107
#define IDD_WELCOME                     108
#define IDS_DEMOTE_PAGE_TITLE           108
#define IDB_BANNER16                    109
#define IDB_BANNER256                   110
#define IDS_AUTO_CONFIG_DNS_PAGE_TITLE  110
#define IDB_WATERMARK16                 111
#define IDB_WATERMARK256                112
#define IDS_AUTO_CONFIG_DNS_PAGE_SUBTITLE 112
#define IDD_PATHS                       123
#define IDD_PROGRESS                    138
#define IDD_REBOOT                      139
#define IDD_INSTALL_TCPIP               140
#define IDD_REPLICA_OR_MEMBER           141
#define IDD_CONFIRMATION                142
#define IDD_DNS_ON_NET                  143
#define IDD_CONFIG_DNS_CLIENT           144
#define IDD_NEW_DOMAIN                  145
#define IDD_REPLICA_OR_DOMAIN           146
#define IDD_GET_CREDENTIALS             147
#define IDD_REPLICA                     148
#define IDD_NEW_CHILD                   150
#define IDD_NEW_TREE                    152
#define IDD_PICK_SITE                   153
#define IDD_FINISH                      154
#define IDD_FAILURE                     156
#define IDD_NEW_SITE                    157
#define IDD_NEW_FOREST                  158
#define IDD_NETBIOS_NAME                159
#define IDD_NEW_CREDENTIALS             161
#define IDD_PATHS2                      162
#define IDD_DEMOTE                      163
#define IDD_ADMIN_PASSWORD              164
#define IDD_AUTO_CONFIG_DNS             165
#define IDD_RAS_FIXUP                   167
#define IDD_SAFE_MODE_PASSWORD          168
#define IDD_REPLICATE_FROM_MEDIA        169
#define IDD_SYSKEY                      170
#define IDD_SYSKEY_PROMPT               170
#define IDD_GC_CONFIRM                  171
#define IDD_SYSKEY_DISK                 172
#define IDD_DYNAMIC_DNS                 174
#define IDD_NON_RFC_COMPUTER_NAME       176
#define IDD_PORTS_IN_USE_ERROR          178
#define IDD_REBOOT_FAILURE              179
#define IDD_FOREST_VERSION              180
#define IDD_APP_PARTITION_CONFIRM       181
#define IDD_APP_PARTITION               182
#define IDD_DYNAMIC_DNS1                183
#define IDD_CHECK_DOMAIN_UPGRADED       183
#define IDD_FORCE_DEMOTE                184
#define IDD_README                      185
#define IDS_CONFIRM_MESSAGE_REPLICA     500
#define IDS_CONFIRM_MESSAGE_FOREST      501
#define IDS_CONFIRM_MESSAGE_TREE        502
#define IDS_CONFIRM_MESSAGE_CHILD       503
#define IDS_CONFIRM_MESSAGE_DEMOTE_LAST_DC 504
#define IDS_CONFIRM_MESSAGE_DEMOTE      505
#define IDS_MUST_SPECIFY_SITE           506
#define IDC_MEMBER                      1000
#define IDC_REPLICA                     1001
#define IDC_BUTTON                      1002
#define IDC_DNS_NOT_ON_NET              1003
#define IDC_CONFIG_CLIENT               1004
#define IDC_TREE                        1005
#define IDC_CHILD                       1006
#define IDC_BROWSE_DB                   1007
#define IDC_NEW_DOMAIN                  1008
#define IDC_DOMAIN                      1009
#define IDC_FOREST                      1009
#define IDC_PROMPT                      1010
#define IDC_SOURCE                      1011
#define IDC_PARENT                      1012
#define IDC_LEAF                        1013
#define IDC_BROWSE                      1014
#define IDC_SYSKEY                      1019
#define IDC_SITE                        1020
#define IDC_GC_YES                      1020
#define IDC_GC_NO                       1021
#define IDC_NETBIOS                     1023
#define IDC_MESSAGE                     1024
#define IDC_USE_NET                     1025
#define IDC_JUMP                        1027
#define IDC_NDNC_LIST                   1027
#define IDC_INTRO1                      1028
#define IDC_CRED                        1028
#define IDC_HELP_LINK                   1028
#define IDC_INTRO2                      1029
#define IDC_TEXT                        1030
#define IDC_RETRY                       1031
#define IDC_INSTALL_DNS                 1032
#define IDC_LAST                        1032
#define IDC_IGNORE                      1033
#define IDC_CONFIRM                     1034
#define IDC_DETAILS                     1034
#define IDC_RENAME                      1036
#define IDC_SHOW_HELP                   1037
#define IDC_TEST_PASS                   1040
#define IDC_AUTO_CONFIG                 1041
#define IDC_DONT_AUTO_CONFIG            1042
#define IDC_PORT_LIST                   1046
#define IDC_CONTINUE                    1047
#define IDC_ALLOW_ANON_ACCESS           1050
#define IDC_DENY_ANON_ACCESS            1051
#define IDC_REFRESH                     1051
#define IDC_FAILURE_MESSAGE             1052
#define IDC_WARNING_ICON                1053
#define IDC_BULLET1                     1054
#define IDC_WIN2K                       1054
#define IDC_BULLET2                     1055
#define IDC_WINDOTNET                   1055
#define IDC_CRED_PLACEHOLDER            1056
#define IDC_BULLET3                     1056
#define IDC_PRIMER_LINK                 1059
#define IDC_DEPLOY_LINK                 1060
#define IDC_DB                          1100
#define IDC_LOG                         1101
#define IDC_SYSVOL                      1102
#define IDC_BIG_BOLD_TITLE              1146
#define IDC_RESTART_NOW                 1154
#define IDC_RESTART_LATER               1155
#define IDC_ANIMATION                   1159
#define IDR_AVI_DOMAIN                  1304
#define IDR_AVI_REPLICA                 1305
#define IDS_BLANK_LEAF_NAME             1306
#define IDS_BLANK_SITE_NAME             1307
#define IDS_INSTALL_TCPIP_HELP_TOPIC    1310
#define IDS_CONFIG_DNS_HELP_TOPIC       1311
#define IDS_HTML_HELP_FILE              1312
#define IDS_PASSWORD_PAGE_SUBTITLE      1313
#define IDS_PASSWORD_PAGE_TITLE         1314
#define IDS_PASSWORD_MISMATCH           1315
#define IDS_DB_SUFFIX                   1317
#define IDS_LOG_SUFFIX                  1318
#define IDS_SYSVOL_SUFFIX               1319
#define IDS_ENTER_LOCAL_ADMIN_PASSWORD  1320
#define IDS_ENTER_DOMAIN_ADMIN_PASSWORD 1321
#define IDS_UPGRADE_DC_FAILED           1322
#define IDS_ABORT_UPGRADE_FAILED        1323
#define IDS_CONFIRM_ABORT_BDC_UPGRADE   1325
#define IDS_INTRO1_DC_UPGRADE           1326
#define IDS_ALREADY_RUNNING             1328
#define IDS_DNSMGR_DLL_NAME             1330
#define IDS_CONFIRM_PATHS_MESSAGE       1332
#define IDS_FINISH_FAILURE              1333
#define IDS_FINISH_PROMOTE              1334
#define IDS_FINISH_SITE                 1335
#define IDS_FINISH_DEMOTE               1336
#define IDS_FINISH_ABORT_BDC_UPGRADE    1337
#define IDS_ERROR_DNS_CONFIG_FAILED     1338
#define IDS_ERROR_CONFIGURING_DNS       1339
#define IDS_ERROR_PREPARING_OPERATION   1340
#define IDS_EMPTY_DIR_FAILED            1341
#define IDS_FINISH_DEMOTE_FAILURE       1342
#define IDS_FINISH_ABORT_BDC_UPGRADE_FAILURE 1343
#define IDS_ERROR_CONFIGURING_SHORTCUTS 1345
#define IDS_SHORTCUTS_NOT_CONFIGURED    1346
#define IDS_CONFIGURING_SHORTCUTS       1347
#define IDS_OPERATION_FAILED_NO_RESULT_MESSAGE 1349
#define IDS_DISJOINED                   1360
#define IDS_INSTALL_TCPIP_FIRST         1361
#define IDS_ABORT_BDC_UPGRADE_CREDENTIALS 1363
#define IDS_NON_FATAL_ERRORS_OCCURRED   1364
#define IDS_CANT_REBOOT                 1365
#define IDS_INSTALLING_DNS              1368
#define IDS_CONFIGURING_DNS             1370
#define IDS_PROGRESS_ERROR_INSTALLING_DNS 1371
#define IDS_PROGRESS_ERROR_CONFIGURING_DNS 1372
#define IDS_WAITING_FOR_INSTALLER       1373
#define IDS_WAITING_FOR_SERVICE_INSTALL 1374
#define IDS_WAITING_FOR_SERVICE_START   1375
#define IDS_ERROR_QUERYING_INSTALLER    1376
#define IDS_ERROR_LAUNCHING_INSTALLER   1377
#define IDS_SKIP_DNS_MESSAGE            1379
#define IDS_CONFIRM_INSTALL_DNS         1381
#define IDS_PROGRESS_BUTTON_SKIP_DNS    1382
#define IDS_INSTALL_DNS_INF_TEXT        1383
#define IDS_INSTALL_DNS_UNATTEND_TEXT   1384
#define IDS_UNABLE_TO_READ_FOREST       1388
#define IDS_DOMAIN_NOT_IN_FOREST        1389
#define IDS_SUPERIOR_TO_TREE            1390
#define IDS_INFERIOR_TO_TREE            1391
#define IDS_PROP_SHEET_FAILED           1392
#define IDS_PROGRESS_CANCEL             1393
#define IDS_FINISH_REPLICATION_LATER    1394
#define IDS_PROMOTION_CREDENTIALS       1395
#define IDS_ROOT_DOMAIN_CREDENTIALS     1396
#define IDS_REINSTALL_DOMAIN_MESSAGE    1399
#define IDS_CANCEL_NON_CRITICAL_REPLICATION 1400
#define IDS_CANCEL_PROMOTE              1401
#define IDS_NON_CRITICAL_REPLICATION_CANCELED 1402
#define IDS_CANCEL_TOO_LATE             1403
#define IDS_CANCELLING                  1404
#define IDS_CANCELLING_REPLICATION      1405
#define IDS_DEMOTE_DOMAIN_HAS_DEPENDENTS 1406
#define IDS_STARTING                    1407
#define IDS_RAS_FIXUP_PAGE_TITLE        1408
#define IDS_RAS_FIXUP_PAGE_SUBTITLE     1409
#define IDS_CONFIRM_DO_RAS_FIXUP        1412
#define IDS_ROLE_CHANGE_IN_PROGRESS     1413
#define IDS_ROLE_CHANGE_NEEDS_REBOOT    1414
#define IDS_LANGUAGE_FIXUP_FAILED       1415
#define IDS_LANGUAGE_FIXUP_FAILED_FINISH 1416
#define IDS_NON_CRITICAL_REPL_FAILED    1417
#define IDS_MUST_ENTER_PARENT           1418
#define IDS_MUST_ENTER_LEAF             1419
#define IDS_NO_NTFS5_DRIVES             1421
#define IDS_DEMOTE_GC_WARNING           1422
#define IDS_CONFIRM_CANCEL              1423
#define IDS_CONFIRM_UPGRADE_CANCEL      1424
#define IDS_CONFIRM_DNS_NAME            1425
#define IDS_SAFEBOOT_MODE               1427
#define IDS_SYSVOL_CANT_MATCH_DB        1428
#define IDS_SYSVOL_CANT_MATCH_LOG       1429
#define IDS_SYSVOL_CANT_BE_LOG_PARENT   1430
#define IDS_SYSVOL_CANT_BE_DB_PARENT    1431
#define IDS_DISJOINING_PROGRESS         1433
#define IDS_PATH_CONTAINS_MOUNTED_VOLUMES 1434
#define IDS_CERT_SERVICE_IS_INSTALLED   1435
#define IDS_SAFE_MODE_PASSWORD_PAGE_TITLE 1436
#define IDS_SAFE_MODE_PASSWORD_PAGE_SUBTITLE 1437
#define IDS_SMALL_BUSINESS_LIMIT        1438
#define IDS_GENERATED_NAME_WAS_TWEAKED  1439
#define IDS_OPERATION_FAILED_GET_CRED   1440
#define IDS_OPERATION_FAILED_GET_CRED_NO_RESULT 1441
#define IDS_CHANGING_DOMAIN             1442
#define IDS_UNABLE_TO_JOIN_DOMAIN       1443
#define IDS_BULLET_FONT_NAME            1444
#define IDS_SBS_LIMITATION_MESSAGE      1445
#define IDS_COMMAND_LINE_HELP           1460
#define IDC_USE_FILES                   1461
#define IDC_BROWSE_LOG                  1462
#define IDC_PASSWORD                    1463
#define IDS_REPLICATE_FROM_MEDIA_PAGE_TITLE 1465
#define IDS_REPLICATE_FROM_MEDIA_PAGE_SUBTITLE 1466
#define IDS_SOURCE_SUFFIX               1467
#define IDS_SOURCE_BROWSE_TITLE         1470
#define IDS_NEW_DOMAIN_PAGE_TITLE       1473
#define IDS_NEW_DOMAIN_PAGE_SUBTITLE    1474
#define IDS_BDC_UPGRADE_PROMPT          1476
#define IDS_CONFIRM_MESSAGE_REPLICATE_FROM_MEDIA 1477
#define IDS_DB_CANT_MATCH_SOURCE_PATH   1478
#define IDS_LOG_CANT_MATCH_SOURCE_PATH  1481
#define IDS_SYSVOL_CANT_MATCH_SOURCE_PATH 1484
#define IDS_RESERVED_NAME_SUFFIX        1487
#define IDS_RESERVED_NAME               1488
#define IDS_SYSVOL_LOW_SPACE            1489
#define IDS_WINDIR_LOW_SPACE            1490
#define IDS_RAS_BAD_NETPATH             1492
#define IDS_VERIFY_LAST_DC              1493
#define IDS_EMPTY_DIR_FAILED_ACCESS_DENIED 1494
#define IDS_VERIFY_NOT_LAST_DC          1496
#define IDS_MUST_ENTER_SYSKEY           1499
#define IDS_GC_CONFIRM_PAGE_TITLE       1500
#define IDS_GC_CONFIRM_PAGE_SUBTITLE    1501
#define IDS_MUST_ENTER_SOURCE_PATH      1502
#define IDS_GET_FACTS_FAILED            1503
#define IDS_SYSKEY_NOT_FOUND            1504
#define IDS_ANSWERFILE_NOT_FOUND        1505
#define IDS_DC_FOR_ROOT_NOT_FOUND       1506
#define IDS_SAFEMODE_PASSWORD_REQUIRED  1508
#define IDS_COMPUTER_NAME_HAS_BAD_CHARS 1509
#define IDS_COMPUTER_NAME_NON_RFC       1511
#define IDS_COMPUTER_NAME_IS_NUMERIC    1512
#define IDS_DYNAMIC_DNS_PAGE_TITLE      1514
#define IDS_DYNAMIC_DNS_PAGE_SUBTITLE   1515
#define IDS_DYN_DNS_MESSAGE_SUCCESS     1516
#define IDS_DYN_DNS_DETAIL_FULL         1517
#define IDS_DYN_DNS_MESSAGE_SERVER_CANT_UPDATE 1518
#define IDS_DYN_DNS_MESSAGE_ZONE_IS_ROOT 1519
#define IDS_DYN_DNS_MESSAGE_ERROR_TESTING_SERVER 1520
#define IDS_DYN_DNS_MESSAGE_ERROR_FINDING_SERVER 1521
#define IDS_DYN_DNS_DETAIL_SCANT        1522
#define IDS_DYN_DNS_DETAIL_ROOT_ZONE    1523
#define IDS_REINSTALL_DOMAIN_CONTROLLER_MESSAGE 1524
#define IDS_TEST_PASS_COUNT             1525
#define IDS_DC_NOT_FOUND                1526
#define IDS_DYN_DNS_MESSAGE_TIMEOUT     1527
#define IDS_DYN_DNS_MESSAGE_UNEXPECTED  1528
#define IDS_DOMAIN_ADMIN_PASSWORD       1529
#define IDS_NAME_CHANGE_NEEDS_REBOOT    1530
#define IDS_CAPS_LOCK_TIP_TITLE         1531
#define IDS_CAPS_LOCK_TIP_TEXT          1532
#define IDS_NDNC_LIST_NAME_COLUMN_WIDTH 1533
#define IDS_NDNC_LIST_NAME_COLUMN       1534
#define IDS_NDNC_LIST_DESC_COLUMN_WIDTH 1535
#define IDS_NDNC_LIST_DESC_COLUMN       1536
#define IDS_FINISH_NON_RFC_COMPUTER_NAME 1537
#define IDS_FINISH_NUMERIC_COMPUTER_NAME 1538
#define IDS_FINISH_BAD_COMPUTER_NAME    1539
#define IDS_MUST_RESTORE_IFM_FILES_AGAIN 1540
#define IDS_UNABLE_TO_DETERMINE_OP_STATE 1541
#define IDS_UNABLE_TO_DETERMINE_COMPUTER_CONFIG 1542
#define IDS_MACHINE_IS_ALREADY_DC       1543
#define IDS_MACHINE_IS_NOT_ALREADY_DC   1544
#define IDS_WEB_BLADE_NOT_SUPPORTED     1545
#define IDS_APP_SERVER_WARNING          1546
#define IDS_FOREST_VERSION_PAGE_TITLE   1547
#define IDS_FOREST_VERSION_PAGE_SUBTITLE 1548
#define IDS_UNABLE_TO_DETERMINE_FOREST  1549
#define IDS_APP_PARTITION_PAGE_TITLE    1551
#define IDS_APP_PARTITION_PAGE_SUBTITLE 1552
#define IDS_APP_PARTITION_CONFIRM_TITLE 1553
#define IDS_APP_PARTITION_CONFIRM_SUBTITLE 1554
#define IDS_CONFIRM_MESSAGE_APP_PARTITION 1555
#define IDS_NONE                        1556
#define IDS_NON_ASCII_PATH_CHARS        1559
#define IDS_RICHEDIT_LOAD_FAILED        1560
#define IDS_UNHANDLED_EXCEPTION         1561
#define IDS_DIAGNOSTIC_COUNTER_1          1562
#define IDS_DETAILS                     1563
#define IDS_DIAGNOSTIC_HELP_LINK_PRE    1564
#define IDS_DIAGNOSTIC_HELP_LINK        1565
#define IDS_DIAGNOSTIC_HELP_LINK_POST   1566
#define IDS_CONFIRM_INSTALL_DNS_AND_CLIENT 1567
#define IDS_INSTALL_DNS_RADIO_LABEL_WITH_CLIENT 1568
#define IDS_INSTALL_DNS_RADIO_LABEL     1569
#define IDS_DYN_DNS_DETAIL_FULL_SANS_CODE 1570
#define IDS_CHECK_DOMAIN_UPGRADED_TITLE 1571
#define IDS_CHECK_DOMAIN_UPGRADED_SUBTITLE 1572
#define IDS_DOMAIN_WAS_UPGRADED         1573
#define IDS_DOMAIN_NOT_UPGRADED_OR_NETWORK_ERROR 1574
#define IDS_NETWORK_ERROR               1575
#define IDS_UNABLE_TO_READ_FOREST_WITH_LINK 1576
#define IDS_DOMAIN_DEMOTE_CREDENTIALS   1577
#define IDS_FORCE_DEMOTE_PAGE_TITLE     1578
#define IDS_FORCE_DEMOTE_PAGE_SUBTITLE  1579
#define IDS_CONFIRM_MESSAGE_FORCE_DEMOTE 1580
#define IDS_DEMOTE_SPLASH_MESSAGE       1581
#define IDS_PROMOTE_SPLASH_MESSAGE      1582
#define IDS_README_PAGE_TITLE           1583
#define IDS_README_PAGE_SUBTITLE        1584
#define IDS_PATH_IS_COMPRESSED          1585
#define IDS_FAILED_PASSWORD_WRITE_TO_ANSWERFILE 1586
#define IDS_DNS_ERROR_RCODE_YXDOMAIN_ADDENDA 1587
#define IDS_PASSWORD_TOO_SHORT 1588
#define IDS_PASSWORD_TOO_LONG  1589
#define IDS_PASSWORD_TOO_SIMPLE 1590
#define IDS_PASSWORD_TOO_COARSE 1591
#define IDS_DIAGNOSTIC_COUNTER_N 1592
#define IDS_DIAGNOSTIC_RESULTS 1593
#define IDS_REBOOT_MESSAGE 1594
#define IDD_SECWARN 1595
#define IDC_LINK 1596
#define IDS_SECWARN_PAGE_TITLE 1597
#define IDS_SECWARN_PAGE_SUBTITLE  1598


#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1060
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\safemode.hpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// Safe Mode Administrator password page
//
// 6-3-99 sburns



#ifndef SAFEMODE_HPP_INCLUDED
#define SAFEMODE_HPP_INCLUDED



#include "page.hpp"
#include "PasswordEditBox.hpp"



class SafeModePasswordPage : public DCPromoWizardPage
{
   public:

   SafeModePasswordPage();

   protected:

   virtual ~SafeModePasswordPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lParam);

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   SafeModePasswordPage(const SafeModePasswordPage&);
   const SafeModePasswordPage& operator=(const SafeModePasswordPage&);

   // NTRAID#NTBUG9-202238-2000/11/07-sburns
   
   PasswordEditBox password;
   PasswordEditBox confirm;
};



#endif   // SAFEMODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\securecommwarningpage.cpp ===
// Copyright (C) 2002 Microsoft Corporation
//
// Warn about SMB signing page.  dc install is a pretty messy business,
// isn't it?
//
// 15 October 2002 sburns



#include "headers.hxx"
#include "page.hpp"
#include "SecureCommWarningPage.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"



SecureCommWarningPage::SecureCommWarningPage()
   :
   DCPromoWizardPage(
      IDD_SECWARN,
      IDS_SECWARN_PAGE_TITLE,
      IDS_SECWARN_PAGE_SUBTITLE),
   bulletFont(0)   
{
   LOG_CTOR(SecureCommWarningPage);
}



SecureCommWarningPage::~SecureCommWarningPage()
{
   LOG_DTOR(SecureCommWarningPage);

   if (bulletFont)
   {
      HRESULT hr = Win::DeleteObject(bulletFont);
      ASSERT(SUCCEEDED(hr));
   }
}



bool
SecureCommWarningPage::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   /* lParam */ )
{
//   LOG_FUNCTION(SecureCommWarningPage::OnNotify);

   bool result = false;
   
   switch (code)
   {
      case NM_CLICK:
      case NM_RETURN:
      {
         switch (controlIDFrom)
         {
            case IDC_LINK:
            {
               Win::HtmlHelp(
                  hwnd,
                  L"adconcepts.chm::/adhelp3.htm",
                  HH_DISPLAY_TOPIC,
                  0);
               result = true;
               break;
            }
            default:
            {
               // do nothing
               
               break;
            }
         }
      }
      default:
      {
         // do nothing
         
         break;
      }
   }
   
   return result;
}



void
SecureCommWarningPage::OnInit()
{
   LOG_FUNCTION(SecureCommWarningPage::OnInit);

   InitializeBullets();
}



void
SecureCommWarningPage::InitializeBullets()
{
   LOG_FUNCTION(SecureCommWarningPage::InitializeBullets);
   ASSERT(!bulletFont);
   
   bulletFont =
      ::CreateFont(
         0,
         0,
         0,
         0,
         FW_NORMAL,
         0,
         0,
         0,
         SYMBOL_CHARSET,
         OUT_CHARACTER_PRECIS,
         CLIP_CHARACTER_PRECIS,
         PROOF_QUALITY,
         VARIABLE_PITCH | FF_DONTCARE,
         L"Marlett");

   if (bulletFont)
   {
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET1), bulletFont, true);
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET2), bulletFont, true);
   }
   else
   {
      LOG(String::format(
             L"Failed to create font for bullet list: hr = %1!x!",
             Win::GetLastErrorAsHresult()));
   }
}



bool
SecureCommWarningPage::OnSetActive()
{
   LOG_FUNCTION(SecureCommWarningPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   Win::PostMessage(
      Win::GetParent(hwnd),
      WM_NEXTDLGCTL,
      (WPARAM) Win::GetDlgItem(Win::GetParent(hwnd), Wizard::NEXT_BTN_ID),
      TRUE);
      
   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   return true;
}



int
SecureCommWarningPage::Validate()
{
   LOG_FUNCTION(SecureCommWarningPage::Validate);
   int nextPage = -1;

   State& state = State::GetInstance();
   switch (state.GetRunContext())
   {
      case State::PDC_UPGRADE:
      case State::NT5_STANDALONE_SERVER:
      case State::NT5_MEMBER_SERVER:
      {
         nextPage = IDD_INSTALL_TCPIP;
         break;
      }
      case State::BDC_UPGRADE:
      {
         nextPage = IDD_REPLICA_OR_MEMBER;
         break;
      }
      case State::NT5_DC:
      {
         // The welcome page should not have sent the user to this page
         // in the demote case.
         
         ASSERT(false);
         
         state.SetOperation(State::DEMOTE);

         // NTRAID#NTBUG9-496409-2001/11/29-sburns
         
         if (state.IsForcedDemotion())
         {
            nextPage = IDD_FORCE_DEMOTE;
         }
         else
         {
            nextPage = IDD_DEMOTE;
         }
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\shortcut.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Post-operation shortcut (shell link) code
//
// 1 Dec 1999 sburns



#ifndef SHORTCUT_HPP_INCLUDED
#define SHORTCUT_HPP_INCLUDED



// add/remove shortcuts appropriately for a newly-promoted domain controller.

void
PromoteConfigureToolShortcuts(ProgressDialog& dialog);



// add/remove shortcuts appropriately for a newly-demoted domain controller.
// (the inverse of PromoteConfigureToolShortcuts)

void
DemoteConfigureToolShortcuts(ProgressDialog& dialog);



#endif   // SHORTCUT_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\securecommwarningpage.hpp ===
// Copyright (C) 2002 Microsoft Corporation
//
// Warn about SMB signing page.  
//
// 15 October 2002 sburns



#ifndef SECURECOMMWARNINGPAGE_HPP_INCLUDED
#define SECURECOMMWARNINGPAGE_HPP_INCLUDED



class SecureCommWarningPage : public DCPromoWizardPage
{
   public:

   SecureCommWarningPage();

   protected:

   virtual ~SecureCommWarningPage();

   // Dialog overrides

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lParam);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   InitializeBullets();

   HFONT bulletFont;
   
   // not defined; no copying allowed
   SecureCommWarningPage(const SecureCommWarningPage&);
   const SecureCommWarningPage& operator=(const SecureCommWarningPage&);
};



#endif   // SECURECOMMWARNINGPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\safemode.cpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// Safe Mode Administrator password page
//
// 6-3-99 sburns



#include "headers.hxx"
#include "safemode.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"
#include "ds.hpp"



SafeModePasswordPage::SafeModePasswordPage()
   :
   DCPromoWizardPage(
      IDD_SAFE_MODE_PASSWORD,
      IDS_SAFE_MODE_PASSWORD_PAGE_TITLE,
      IDS_SAFE_MODE_PASSWORD_PAGE_SUBTITLE)
{
   LOG_CTOR(SafeModePasswordPage);
}



SafeModePasswordPage::~SafeModePasswordPage()
{
   LOG_DTOR(SafeModePasswordPage);
}



// NTRAID#NTBUG9-510389-2002/01/22-sburns

bool
SafeModePasswordPage::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   /* lParam */ )
{
//   LOG_FUNCTION(WelcomePage::OnNotify);

   bool result = false;
   
   switch (code)
   {
      case NM_CLICK:
      case NM_RETURN:
      {
         switch (controlIDFrom)
         {
            case IDC_HELP_LINK:
            {
               Win::HtmlHelp(
                  hwnd,
                  L"adconcepts.chm::/adhelpdcpromo_DSrestorepage.htm",
                  HH_DISPLAY_TOPIC,
                  0);
               result = true;
               break;
            }
            default:
            {
               // do nothing
               
               break;
            }
         }
      }
      default:
      {
         // do nothing
         
         break;
      }
   }
   
   return result;
}



void
SafeModePasswordPage::OnInit()
{
   LOG_FUNCTION(SafeModePasswordPage::OnInit);

   // NTRAID#NTBUG9-202238-2000/11/07-sburns
   
   password.Init(Win::GetDlgItem(hwnd, IDC_PASSWORD));
   confirm.Init(Win::GetDlgItem(hwnd, IDC_CONFIRM));
   
   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      EncryptedString pwd =
         state.GetEncryptedAnswerFileOption(
            AnswerFile::OPTION_SAFE_MODE_ADMIN_PASSWORD);
         
      Win::SetDlgItemText(hwnd, IDC_PASSWORD, pwd);
      Win::SetDlgItemText(hwnd, IDC_CONFIRM, pwd);
   }

   Win::PostMessage(
      Win::GetParent(hwnd),
      WM_NEXTDLGCTL,
      reinterpret_cast<WPARAM>(Win::GetDlgItem(hwnd, IDC_PASSWORD)),
      TRUE);
}



bool
SafeModePasswordPage::OnSetActive()
{
   LOG_FUNCTION(SafeModePasswordPage::OnSetActive);
   
   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      if (
            (  state.GetRunContext() == State::BDC_UPGRADE
            || state.GetRunContext() == State::PDC_UPGRADE)
         && !state.IsSafeModeAdminPwdOptionPresent())
      {
         // If you are upgrading a downlevel DC, and running unattended, then
         // you must specify a safemode password.  In a non-upgrade case, if
         // the user does not specify a safemode password, we pass a flag to
         // the promote APIs to copy the current user's password as the
         // safemode password.  In the upgrade case, the system is running
         // under a bogus account with a random password, so copying that
         // random password would be a bad idea.  So we force the user to
         // supply a password.

         state.ClearHiddenWhileUnattended();
         popup.Gripe(
            hwnd,
            IDC_PASSWORD,
            IDS_SAFEMODE_PASSWORD_REQUIRED);
      }
      else
      {         
         int nextPage = Validate();
         if (nextPage != -1)
         {
            GetWizard().SetNextPageID(hwnd, nextPage);
         }
         else
         {
            state.ClearHiddenWhileUnattended();
         }
      }
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



int
SafeModePasswordPage::Validate()
{
   LOG_FUNCTION(SafeModePasswordPage::Validate);

   int result = -1;

   EncryptedString password;

   if (IsValidPassword(hwnd, IDC_PASSWORD, IDC_CONFIRM, true, password))
   {
      State::GetInstance().SetSafeModeAdminPassword(password);
      result = IDD_CONFIRMATION;
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\shortcut.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Post-operation shortcut (shell link) code
//
// 1 Dec 1999 sburns



#include "headers.hxx"
#include "ProgressDialog.hpp"
#include "state.hpp"
#include "resource.h"
#include "..\dll\muiresource.h"  // resIds for shortcuts



// @@ need to make sure that, when deleting shortcuts, we consider the case
// were the shortcuts may have been added by the adminpak from the 5.0 release
// of the product, not by ourselves in a later release.
//
// This case is: promote with version 5.0, upgrade to later version, demote


static const String SHORTCUT_DLL(L"dcpromo.dll");

struct ShortcutParams
{
   // resource id of the link file name and also the link name in the menu.
   // These are from muiresource.h.  The string resources themselves are bound
   // to dcpromo.dll
   
   int            linkNameResId;

   // resource id of the description string (also the info tip string) for
   // the shortcut.  These are from muiresource.h.  The string resources
   // themselves are bound to dcpromo.dll
   
   int            descResId;
   
   const wchar_t* target;
   const wchar_t* params;
   const wchar_t* iconDll;
};



// "Add" from the point of view of promotion: these are removed on demotion.

static ShortcutParams shortcutsToAdd[] =
   {
      {
         // Active Directory Sites and Services

         IDS_DS_SITE_LINK,
         IDS_DS_SITE_DESC,
         L"dssite.msc",
         L"",

         // the .msc file contains the proper icon, so we don't need to
         // specify a dll from whence to retrieve an icon.

         L""   
      },
      {
         // Active Directory Users and Computers

         IDS_DS_USERS_LINK,
         IDS_DS_USERS_DESC,
         L"dsa.msc",
         L"",
         L""
      },
      {
         // Active Directory Domains and Trusts

         IDS_DS_DOMAINS_LINK,
         IDS_DS_DOMAINS_DESC,
         L"domain.msc",
         L"",
         L""
      },
      {
         // Domain Controller Security Policy

         // if you change this name, be sure to change the code in
         // PromoteConfigureToolShortcuts too
        
         IDS_DC_POLICY_LINK,
         
         IDS_DC_POLICY_DESC,
         L"dcpol.msc",
         L"",
         L""
      },
      {
         // Domain Security Policy         

         // if you change this name, be sure to change the code in
         // PromoteConfigureToolShortcuts too
         
         IDS_DOMAIN_POLICY_LINK,
         IDS_DOMAIN_POLICY_DESC,
         L"dompol.msc",
         L"",
         L""
      }
   };



// "Delete" from the point of view of promotion: these are added back again
// on demotion.

static ShortcutParams shortcutsToDelete[] =
   {
      {
         // Local Security Policy

         IDS_LOCAL_POLICY_LINK,
         IDS_LOCAL_POLICY_DESC,
         L"secpol.msc",
         L"/s",
         L"wsecedit.dll"
      }
   };



// Extracts the target of a shortcut: that to which the shortcut points.
// Returns S_OK on success, and sets result to that target.  On error, a COM
// error code is returned and result is empty.
// 
// shellLink - pointer to instance of object implementing IShellLink, which
// has been associated with a shortcut file.
// 
// result - receives the result -- the shortcut target path -- on sucess.

HRESULT
GetShortcutTargetPath(
   const SmartInterface<IShellLink>&   shellLink,
   String&                             result)
{
   LOG_FUNCTION(GetShortcutTargetPath);
   ASSERT(shellLink);

   result.erase();

   WCHAR target[MAX_PATH + 1];

   // REVIEWED-2002/02/26-sburns correct byte count passed
   
   // remove superfluous '&' NTRAID#NTBUG9-540418-2002/03/12-sburns
   
   ::ZeroMemory(target, sizeof WCHAR * (MAX_PATH + 1));

   // REVIEWED-2002/02/26-sburns passing correct character count.
   
   HRESULT hr = shellLink->GetPath(target, MAX_PATH, 0, SLGP_SHORTPATH);

   if (SUCCEEDED(hr))
   {
      result = target;
   }

   return hr;
}



// Return true if the supplied target of a shortcut is such that it identifies
// the shortcut as one of those installed on promote.  Return false if not one
// such.
// 
// target - target path of the shortcut (i.e. path to that which the shortcut
// points)

bool
IsAdminpakShortcut(const String& target)
{
   LOG_FUNCTION2(IsAdminpakShortcut, target);

   // don't assert that target has a value. Some shortcuts don't, if they're
   // broken.
   // 
   // ASSERT(!target.empty());

   // If the target is of the form %systemroot%\Installer\{guid}\foo.ico,
   // then it is one of the adminpak dcpromo shortcuts.

   static String baseNames[] =
      {
         L"DTMgmt.ico",
         L"ADSSMgr.ico",
         L"ADMgr.ico",
         L"ADDcPol.ico",
         L"ADDomPol.ico"
      };

   static String root(Win::GetSystemWindowsDirectory() + L"\\Installer\\{");

   bool result = false;

   String prefix(target, 0, root.length());
   if (root.icompare(prefix) == 0)
   {
      // the prefix matches.

      String leaf = FS::GetPathLeafElement(target);
      for (int i = 0; i < (sizeof(baseNames) / sizeof(String)) ; ++i)
      {
         if (leaf.icompare(baseNames[i]) == 0)
         {
            result = true;
            break;
         }
      }
   }

   LOG(
      String::format(
         L"%1 an adminpak shortcut",
         result ? L"is" : L"is not"));

   return result;
}



bool
IsPromoteToolShortcut(const String& target)
{
   LOG_FUNCTION2(IsPromoteToolShortcut, target);
   ASSERT(!target.empty());

   // Check target against the values we used to create the shortcuts.  The
   // values we used specified a fully-qualified path to the system32 folder,
   // and we will compare the target to the full path.

   String targetPrefix = Win::GetSystemDirectory() + L"\\";

   for (
      int i = 0;
      i < sizeof(shortcutsToAdd) / sizeof(ShortcutParams);
      ++i)
   {
      if (target.icompare(targetPrefix + shortcutsToAdd[i].target) == 0)
      {
         return true;
      }
   }

   return false;
}



// Return true if the given shortcut one of those installed on promote.
// Return false if not one of those shortcuts, or on error.
// 
// shellLink - smart interface pointer to an object implementing IShellLink.
// 
// lnkPath - full file path of the shortcut (.lnk) file to be evaluated.

bool
ShouldDeleteShortcut(
   const SmartInterface<IShellLink>&   shellLink,
   const String&                       lnkPath)
{
   LOG_FUNCTION2(ShouldDeleteShortcut, lnkPath);
   ASSERT(!lnkPath.empty());
   ASSERT(shellLink);

   // Shortcut file names are localized, so we can't delete them based on
   // their names.  idea:  Open the shortcut, see what it's target is,
   // and based on that, determine if it's one we should delete.

   HRESULT hr = S_OK;
   bool result = false;
   do
   {
      // Load the shortcut file

      // REVIEWED-2002/02/26-sburns we open with minimum access, and are only
      // reading 
      
      SmartInterface<IPersistFile> ipf;
      hr = ipf.AcquireViaQueryInterface(shellLink);
      BREAK_ON_FAILED_HRESULT(hr);

      // ISSUE-2002/02/26-sburns should we specify STGM_SHARE_DENY_WRITE?
      
      hr = ipf->Load(lnkPath.c_str(), STGM_READ);
      BREAK_ON_FAILED_HRESULT(hr);

      // Get the target lnkPath

      String target;
      hr = GetShortcutTargetPath(shellLink, target);
      BREAK_ON_FAILED_HRESULT(hr);

      if (IsAdminpakShortcut(target))
      {
         result = true;
         break;
      }

      // Not an adminpak shortcut.  Might be one of the ones created by
      // PromoteConfigureToolShortcuts (ourselves).

      if (IsPromoteToolShortcut(target))
      {
         result = true;
         break;
      }

      // if we make it here, the shortcut is not one we should delete.
   }
   while (0);

   LOG(
      String::format(
         L"%1 delete shortcut",
         result ? L"should" : L"should not"));

   return result;
}



HRESULT
CreateShortcut(
   const SmartInterface<IShellLink>&   shellLink,
   const String&                       destFolderPath,
   int                                 linkNameResId,
   HINSTANCE                           linkNameResModule,
   int                                 descResId,
   const String&                       target,
   const String&                       params,
   const String&                       iconDll)
{
   LOG_FUNCTION2(CreateShortcut, target);
   ASSERT(shellLink);

   // the path should exist already: it's the one we grabbed at startup
   
   ASSERT(FS::PathExists(destFolderPath));
   
   ASSERT(!target.empty());
   ASSERT(linkNameResId);
   ASSERT(descResId);
   ASSERT(linkNameResModule);

   // params and iconDll may be empty

   HRESULT hr = S_OK;
   do
   {
      String sys32Folder = Win::GetSystemDirectory();
      String targetPath = sys32Folder + L"\\" + target;

      // REVIEWED-2002/05/06-sburns we're using full paths to the target
      
      hr = shellLink->SetPath(targetPath.c_str());
      BREAK_ON_FAILED_HRESULT(hr);

      hr = shellLink->SetWorkingDirectory(sys32Folder.c_str());
      BREAK_ON_FAILED_HRESULT(hr);

      hr =
         shellLink->SetDescription(
            String::format(

               // MUI-aware shortcuts take a description that is really a
               // pointer to a resource dll and a resource ID.
               // NTRAID#NTBUG9-185055-2001/06/21-sburns
            
               L"@%%systemroot%%\\system32\\dcpromo.dll,-%1!d!",
               descResId).c_str());
      BREAK_ON_FAILED_HRESULT(hr);

      hr = shellLink->SetArguments(params.c_str());
      BREAK_ON_FAILED_HRESULT(hr);

      if (!iconDll.empty())
      {
         hr =
            shellLink->SetIconLocation(
               (sys32Folder + L"\\" + iconDll).c_str(), 0);
      }

      SmartInterface<IPersistFile> ipf;
      hr = ipf.AcquireViaQueryInterface(shellLink);
      BREAK_ON_FAILED_HRESULT(hr);

      String destPath =
            destFolderPath
         +  L"\\"
         +  String::load(linkNameResId, linkNameResModule)
         +  L".lnk";

      // REVIEWED-2002/02/27-sburns we are composing a full path to the file
      
      ASSERT(FS::IsValidPath(destPath));
        
      hr = ipf->Save(destPath.c_str(), TRUE);
      BREAK_ON_FAILED_HRESULT(hr);

      // MUI-aware shortcuts need a localized name.
      // NTRAID#NTBUG9-185055-2001/06/21-sburns

      hr =
         SHSetLocalizedName(
            const_cast<PWSTR>(destPath.c_str()),
            L"%systemroot%\\system32\\dcpromo.dll",
            linkNameResId);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   LOG_HRESULT(hr);
      
   return hr;
}



HRESULT
DeleteShortcut(
   const String&  folder,
   int            linkNameResId,
   HINSTANCE      linkNameResModule)
{
   LOG_FUNCTION(DeleteShortcut);
   ASSERT(!folder.empty());
   ASSERT(linkNameResId);
   ASSERT(linkNameResModule);
      
   HRESULT hr = S_OK;
   do
   {     
      String linkPath =
            folder
         +  L"\\"
         +  String::load(linkNameResId, linkNameResModule)
         +  L".lnk";

      LOG(linkPath);

      if (FS::PathExists(linkPath))
      {
         hr = Win::DeleteFile(linkPath);
         BREAK_ON_FAILED_HRESULT(hr);
      }
   }
   while (0);

   return hr;
}



// Remove the shortcuts to the DS administration tools that were installed on
// promote.

void
DemoteConfigureToolShortcuts(ProgressDialog& dialog)
{
   LOG_FUNCTION(DemoteConfigureToolShortcuts);

   HRESULT hr         = S_OK;                
   HMODULE dcpromoDll = 0;                   
   State&  state      = State::GetInstance();
   do
   {
      String path = state.GetAdminToolsShortcutPath();
      if (path.empty())
      {
         // We were unable to determine the path at startup.

         hr = Win32ToHresult(ERROR_PATH_NOT_FOUND);
         break;
      }

      // (may) Need to init com for this thread.  

      AutoCoInitialize coInit;
      hr = coInit.Result();
      BREAK_ON_FAILED_HRESULT(hr);
               
      SmartInterface<IShellLink> shellLink;
      hr =
         shellLink.AcquireViaCreateInstance(
            CLSID_ShellLink,
            0,
            CLSCTX_INPROC_SERVER);
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"enumerating shortcuts");

      FS::Iterator iter(
         path + L"\\*.lnk",
            FS::Iterator::INCLUDE_FILES
         |  FS::Iterator::RETURN_FULL_PATHS);

      String current;
      while ((hr = iter.GetCurrent(current)) == S_OK)
      {
         if (ShouldDeleteShortcut(shellLink, current))
         {
            LOG(String::format(L"Deleting %1", current.c_str()));

            // we don't bail out on an error here because we want to
            // try to delete as many shortcuts as possible.

            HRESULT unused = Win::DeleteFile(current);
            LOG_HRESULT(unused);
         }

         hr = iter.Increment();
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // add the shortcut(s) removed during promote

      hr = 
         Win::LoadLibraryEx(
            SHORTCUT_DLL,
            LOAD_LIBRARY_AS_DATAFILE,
            dcpromoDll);
      BREAK_ON_FAILED_HRESULT2(hr, L"Unable to load dcpromo.dll");
      
      for (
         int i = 0;
         i < sizeof(shortcutsToDelete) / sizeof(ShortcutParams);
         ++i)
      {
         // don't break on error -- push on to attempt to create the
         // entire set.

         CreateShortcut(
            shellLink,
            path,
            shortcutsToDelete[i].linkNameResId,
            dcpromoDll,            
            shortcutsToDelete[i].descResId,
            shortcutsToDelete[i].target,
            shortcutsToDelete[i].params,
            shortcutsToDelete[i].iconDll);
      }
   }
   while (0);

   Win::FreeLibrary(dcpromoDll);
   
   if (FAILED(hr))
   {
      popup.Error(
         dialog.GetHWND(),
         hr,
         IDS_ERROR_CONFIGURING_SHORTCUTS);
      state.AddFinishMessage(
         String::load(IDS_SHORTCUTS_NOT_CONFIGURED));
   }
}



// Take a domain name in canonical (dotted) form, e.g. domain.foo.com, and
// translate it to the fully-qualified DN form, e.g. DC=domain,DC=foo,DC=com
//
// domainCanonical - in, domain name in canonical form
//
// domainDN - out, domain name in DN form

HRESULT
CannonicalToDn(const String& domainCanonical, String& domainDN)
{
   LOG_FUNCTION2(CannonicalToDn, domainCanonical);
   ASSERT(!domainCanonical.empty());

   domainDN.erase();
   HRESULT hr = S_OK;
   
   do
   {
      if (domainCanonical.empty())
      {
         hr = E_INVALIDARG;
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // add a trailing '/' to signal DsCrackNames to do a syntactical
      // munge of the string, rather than hit the wire.

      // add 1 for the null terminator, 1 for the trailing '/'
      
      PWSTR name = new WCHAR[domainCanonical.length() + 2];

      // REVIEWED-2002/02/27-sburns correct byte count passed.
      
      ::ZeroMemory(name, (domainCanonical.length() + 2) * sizeof WCHAR);
      
      domainCanonical.copy(name, domainCanonical.length());
      name[domainCanonical.length()] = L'/';
      
      DS_NAME_RESULT* nameResult = 0;
      hr =
         Win32ToHresult(
            ::DsCrackNames(

               // no handle: this is a string munge
               
               reinterpret_cast<void*>(-1),
               
               DS_NAME_FLAG_SYNTACTICAL_ONLY,
               DS_CANONICAL_NAME,
               DS_FQDN_1779_NAME,
               1,
               &name,
               &nameResult));
      delete[] name;
      BREAK_ON_FAILED_HRESULT(hr);      

      ASSERT(nameResult);
      if (nameResult)
      {
         ASSERT(nameResult->cItems == 1);
         DS_NAME_RESULT_ITEM* items = nameResult->rItems;

         // if we don't get a struct back, then DsCrackNames is broken.
         
         ASSERT(items);

         if (items)
         {
            LOG(String::format(L"status : 0x%1!X!",   items[0].status));
            LOG(String::format(L"pName  : %1",        items[0].pName));

            ASSERT(items[0].status == DS_NAME_NO_ERROR);

            if (items[0].pName)
            {
               domainDN = items[0].pName;
            }
            if (domainDN.empty())
            {
               hr = E_FAIL;
            }
         }
         
         ::DsFreeNameResult(nameResult);
      }
   }
   while (0);

   LOG_HRESULT(hr);
   
   return hr;
}
    

    
// Create all the admin tools shortcuts that are needed after a promote.
//
// path - in, where to create the shortcuts
//
// shellLink - in, initialized shellLink interface to create the shortcuts
// with.

HRESULT
PromoteCreateShortcuts(
   const String&                 path,
   SmartInterface<IShellLink>&   shellLink,
   HINSTANCE                     dcpromoDll)
{
   LOG_FUNCTION(PromoteCreateShortcuts);
   ASSERT(!path.empty());
   ASSERT(shellLink);
   ASSERT(dcpromoDll);

   HRESULT hr = S_OK;
   
   do
   {
      State& state = State::GetInstance();

      // for the policy shortcuts, we will need to know the domain DN, so
      // determine that here.  
      // NTRAID#NTBUG9-232442-2000/11/15-sburns
      
      String domainCanonical;
      State::Operation oper = state.GetOperation();
      if (
            oper == State::FOREST
         || oper == State::TREE
         || oper == State::CHILD)
      {
         domainCanonical = state.GetNewDomainDNSName();
      }
      else if (oper == State::REPLICA)
      {
         domainCanonical = state.GetReplicaDomainDNSName();
      }
      else
      {
         // we should not be calling this function on non-promote scenarios
      
         ASSERT(false);
         hr = E_FAIL;
         BREAK_ON_FAILED_HRESULT(hr);
      }
   
      String domainDn;
      bool skipPolicyShortcuts = false;

      hr = CannonicalToDn(domainCanonical, domainDn);
      if (FAILED(hr))
      {
         LOG(L"skipping install of policy shortcuts");
         skipPolicyShortcuts = true;
      }

      for (
         int i = 0;
         i < sizeof(shortcutsToAdd) / sizeof(ShortcutParams);
         ++i)
      {
         // set the correct parameters for domain and dc security policy tools.
      
         String params;
      
         if (shortcutsToAdd[i].linkNameResId == IDS_DC_POLICY_LINK)
         {
            if (skipPolicyShortcuts)
            {
               continue;
            }
         
            params =
               String::format(
                  L"/gpobject:\"LDAP://CN={%1},CN=Policies,CN=System,%2\"",
                  STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID,
                  domainDn.c_str());
         }
         else if (shortcutsToAdd[i].linkNameResId == IDS_DOMAIN_POLICY_LINK)
         {
            if (skipPolicyShortcuts)
            {
               continue;
            }

            params =
               String::format(
                  L"/gpobject:\"LDAP://CN={%1},CN=Policies,CN=System,%2\"",
                  STR_DEFAULT_DOMAIN_GPO_GUID,
                  domainDn.c_str());
         }
         else
         {
            params = shortcutsToAdd[i].params;
         }

         // don't break on errors -- push on to attempt to create the
         // entire set.
   
         CreateShortcut(
            shellLink,
            path,
            shortcutsToAdd[i].linkNameResId,
            dcpromoDll,
            shortcutsToAdd[i].descResId,
            shortcutsToAdd[i].target,
            params,
            shortcutsToAdd[i].iconDll);
      }
   }
   while (0);

   LOG_HRESULT(hr);
      
   return hr;      
}



void
PromoteConfigureToolShortcuts(ProgressDialog& dialog)
{
   LOG_FUNCTION(PromoteConfigureToolShortcuts);

   dialog.UpdateText(String::load(IDS_CONFIGURING_SHORTCUTS));

   HRESULT hr         = S_OK;                
   State&  state      = State::GetInstance();
   HMODULE dcpromoDll = 0;                   

   do
   {
      String path = state.GetAdminToolsShortcutPath();
      if (path.empty())
      {
         // We were unable to determine the path at startup.

         hr = Win32ToHresult(ERROR_PATH_NOT_FOUND);
         break;
      }

      // Need to init com for this thread.  

      AutoCoInitialize coInit;
      hr = coInit.Result();
      BREAK_ON_FAILED_HRESULT(hr);
               
      SmartInterface<IShellLink> shellLink;
      hr =
         shellLink.AcquireViaCreateInstance(
            CLSID_ShellLink,
            0,
            CLSCTX_INPROC_SERVER);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = 
         Win::LoadLibraryEx(
            SHORTCUT_DLL,
            LOAD_LIBRARY_AS_DATAFILE,
            dcpromoDll);
      BREAK_ON_FAILED_HRESULT2(hr, L"Unable to load dcpromo.dll");

      // add the shortcuts to the ds administration tools

      PromoteCreateShortcuts(path, shellLink, dcpromoDll);

      // remove the shortcuts to local tools

      for (
         int i = 0;
         i < sizeof(shortcutsToDelete) / sizeof(ShortcutParams);
         ++i)
      {
         // don't break on error -- push on to attempt to delete the
         // entire set.

         DeleteShortcut(
            path,
            shortcutsToDelete[i].linkNameResId,
            dcpromoDll);
      }
   }
   while (0);

   Win::FreeLibrary(dcpromoDll);

   if (FAILED(hr))
   {
      popup.Error(
         dialog.GetHWND(),
         hr,
         IDS_ERROR_CONFIGURING_SHORTCUTS);
      state.AddFinishMessage(
         String::load(IDS_SHORTCUTS_NOT_CONFIGURED));
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\state.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// wizard state object
//
// 12-15-97 sburns



#include "headers.hxx"
#include "state.hpp"
#include "resource.h"
#include "ds.hpp"
#include "common.hpp"
#include "NonDomainNc.hpp"

static State* stateInstance;



void
State::Init()
{
   ASSERT(!stateInstance);

   stateInstance = new State;
}



void
State::Destroy()
{
   delete stateInstance;
};



State&
State::GetInstance()
{
   ASSERT(stateInstance);

   return *stateInstance;
}
   


// Determines the full file path of the folder where administration (incl. DS)
// tools shortcuts are placed.  On success, returns S_OK and sets result to
// the path.  On failure, returns a COM error and sets results to empty.
// 
// result - receives the folder path on success.

HRESULT
GetAdminToolsPath(String& result)
{
   LOG_FUNCTION(GetAdminToolsPath);

   result.erase();

   // +1 for null-termination paranoia
   
   WCHAR buf[MAX_PATH + 1];

   // REVIEWED-2002/02/28-sburns correct byte count passed.
   
   ::ZeroMemory(buf, (MAX_PATH + 1) * sizeof WCHAR);
   
   HRESULT hr =
      ::SHGetFolderPath(
         0,
         CSIDL_COMMON_ADMINTOOLS,
         0,
         SHGFP_TYPE_CURRENT,
         buf);

   if (SUCCEEDED(hr))
   {
      result = buf;
   }

   return hr;
}



// Sets result = true if the registry option to not configure the dns client
// to point to itself is absent or non-zero, false otherwise.
// NTRAID#NTBUG9-446484-2001/10/11-sburns

void   
InitDnsClientConfigFlag(bool& result)
{
   LOG_FUNCTION(InitDnsClientConfigFlag);
   
   result = true;
   
   do
   {
      static String keyname =
         String(REG_ADMIN_RUNTIME_OPTIONS) + RUNTIME_NAME;
         
      RegistryKey key;

      HRESULT hr = key.Open(HKEY_LOCAL_MACHINE, keyname);
      BREAK_ON_FAILED_HRESULT(hr);

      DWORD mode = 0;
      hr = key.GetValue(L"ConfigureDnsClient", mode);
      BREAK_ON_FAILED_HRESULT(hr);

      result = mode ? true : false;
   }
   while (0);

   LOG_BOOL(result);
}



State::State()
   :
   adminPassword(),
   allowAnonAccess(false),
   answerFile(0),
   autoConfigDns(false),
   computer(),
   context(),
   dbPath(),
   domainsInForest(),
   failureMessage(),
   finishMessages(),
   installedSite(),
   isAdvancedMode(false),
   isBackupGc(false),
   isDnsOnNet(true),
   
#ifdef DBG   
   isExitOnFailureMode(false),
#endif

   isForcedDemotion(false),
   isLastDc(false),
   isUpgrade(false),
   logPath(),
   needsCommandLineHelp(false),
   needsReboot(false),
   newDomainDnsName(),
   newDomainFlatName(),
   operation(NONE),
   operationResultsMessage(),
   operationResultsStatus(FAILURE),
   operationResultsFlags(0),
   parentDomainDnsName(),
   password(),
   reinstallDomain(false),
   reinstallDomainController(false),
   replicaDnsDomainName(),
   replicateFromMedia(false),
   replicationPartnerDc(),
   restoreGc(false),
   runHiddenWhileUnattended(true),
   safeModeAdminPassword(),
   setForestVersion(false),
   shortcutPath(),
   shouldConfigDnsClient(true),
   siteName(),
   splash(0),                     
   sourcePath(),
   sysvolPath(),
   syskey(),
   syskeyLocation(STORED),
   useCurrentCredentials(false),    
   userDomain(),
   userForest(),                
   username()
{
   LOG_CTOR(State);

   HRESULT hr = computer.Refresh();

   // we're confident this will work, as the computer refers to the
   // local machine.

   ASSERT(SUCCEEDED(hr));
   LOG_HRESULT(hr);

   DetermineRunContext();
   
   ArgMap args;
   MapCommandLineArgs(args);

   if (args.size() < 2)
   {
      LOG(L"no options specified");
   }
   else
   {
      // check for answerfile specification

      static const wchar_t* ANSWER1 = L"answer";
      static const wchar_t* ANSWER2 = L"u";
      static const wchar_t* ANSWER3 = L"upgrade";

      if (
            args.find(ANSWER1) != args.end()
         || args.find(ANSWER2) != args.end()
         || args.find(ANSWER3) != args.end() )
      {
         bool isDefaultAnswerfile = false;

         String filename = args[ANSWER1];
         if (filename.empty())
         {
            filename = args[ANSWER2];
         }
         if (filename.empty())
         {
            filename = args[ANSWER3];
         }
         if (filename.empty())
         {
            // default value if none specified

            filename = L"%systemdrive%\\dcpromo-ntupg.inf";

            // if this file does not exist, don't pop up an error message.

            isDefaultAnswerfile = true;
         }

         SetupAnswerFile(filename, isDefaultAnswerfile);

         args.erase(ANSWER1);
         args.erase(ANSWER2);
         args.erase(ANSWER3);
      }

      // check for /adv

      static const wchar_t* ADV = L"adv";

      if (args.find(ADV) != args.end())
      {
         LOG(L"Enabling advanced mode");

         isAdvancedMode = true;
         args.erase(ADV);
      }

#ifdef DBG      
      // check for /ExitOnFailure
      // NTRAID#NTBUG9-416968-2001/06/14-sburns

      static const wchar_t* EXIT_ON_FAIL = L"ExitOnFailure";

      if (args.find(EXIT_ON_FAIL) != args.end())
      {
         LOG(L"Enabling exit-on-failure mode");

         isExitOnFailureMode = true;
         args.erase(EXIT_ON_FAIL);
      }
#endif      

      // check for /forceremoval
      // NTRAID#NTBUG9-496409-2001/11/29-sburns

      static const wchar_t* FORCE = L"forceremoval";

      if (args.find(FORCE) != args.end())
      {
         LOG(L"Enabling forced demotion mode");

         isForcedDemotion = true;
         args.erase(FORCE);
      }
      
      // anything left over gets you command line help, (one arg will always
      // remain: the name of the exe)

      if (args.size() > 1)
      {
         LOG(L"Unrecognized command line options specified");

         needsCommandLineHelp = true;
      }
   }

   // Disable locking of the console as early as possible to narrow the
   // window of opportunity for the user (or the system) to lock the
   // console before a valid machine security state is reached.  We do this
   // early only for upgrades, because upgrades autologon and autostart
   // dcpromo, and the console may sit idle for some time. 311161

   if (context == PDC_UPGRADE || context == BDC_UPGRADE)
   {
      DisableConsoleLocking();
   }

   // We must call this at startup, because once a demote operation is
   // complete, it may not be possible for the shell to determine this
   // path. 366738

   hr = GetAdminToolsPath(shortcutPath);
   ASSERT(SUCCEEDED(hr));
   LOG_HRESULT(hr);

   // Set the current directory to the root directory. This is to make the
   // pathname normalization on the paths pages seem less astonishing. It
   // will cause normalization to be relative to the root directory,
   // rather than the user's home directory (which is typically the current
   // directory when the app is launched from Start->Run)
   // NTRAID#NTBUG9-470687-2001/09/21-sburns
   
   String curdir;
   hr = Win::GetCurrentDirectory(curdir);
   if (SUCCEEDED(hr))
   {
      // NTRAID#NTBUG9-547394-2002/03/26-sburns
      
      switch (FS::GetPathSyntax(curdir))
      {
         case FS::SYNTAX_ABSOLUTE_DRIVE:
         {
            // this is the typical case.

            break;
         }
         default:
         {
            curdir = Win::GetSystemWindowsDirectory();
            break;
         }
      }
      
      hr = Win::SetCurrentDirectory(curdir.substr(0, 3));
      ASSERT(SUCCEEDED(hr));
      LOG_HRESULT(hr);
   }

   InitDnsClientConfigFlag(shouldConfigDnsClient);

   IfmHandle = NULL;
}



void
State::SetupAnswerFile(
   const String&  filename,
   bool           isDefaultAnswerfile)
{
   LOG_FUNCTION2(State::SetupAnswerFile, filename);

   String f = Win::ExpandEnvironmentStrings(filename);
   f = FS::NormalizePath(f);

   LOG(L"answerfile resolved to: " + f);

   if (FS::PathExists(f))
   {
      // file found.

      LOG(L"answerfile found");
      answerFile = new AnswerFile(f);
      
      splash =
         new UnattendSplashDialog(
               context == State::NT5_DC
            ?  IDS_DEMOTE_SPLASH_MESSAGE
            :  IDS_PROMOTE_SPLASH_MESSAGE);
      splash->ModelessExecute(Win::GetDesktopWindow());         
   }
   else
   {
      LOG(L"answerfile NOT found");

      if (!isDefaultAnswerfile)
      {
         popup.Error(
            Win::GetDesktopWindow(),
            String::format(IDS_ANSWERFILE_NOT_FOUND, f.c_str()));
      }
   }
}



#ifdef LOGGING_BUILD
   static const String CONTEXTS[] =
   {
      L"NT5_DC",
      L"NT5_STANDALONE_SERVER",
      L"NT5_MEMBER_SERVER",
      L"BDC_UPGRADE",
      L"PDC_UPGRADE"
   };
#endif



void
State::DetermineRunContext()
{
   LOG_FUNCTION(State::DetermineRunContext);

   DS::PriorServerRole priorRole = DS::GetPriorServerRole(isUpgrade);

   if (isUpgrade && priorRole != DS::UNKNOWN)
   {
      switch (priorRole)
      {
         case DS::PDC:
         {
            context = PDC_UPGRADE;
            break;
         }
         case DS::BDC:
         {
            context = BDC_UPGRADE;
            break;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }
   }
   else
   {
      switch (computer.GetRole())
      {
         case Computer::STANDALONE_SERVER:
         {
            context = NT5_STANDALONE_SERVER;
            break;
         }
         case Computer::MEMBER_SERVER:
         {
            context = NT5_MEMBER_SERVER;
            break;
         }
         case Computer::PRIMARY_CONTROLLER:
         case Computer::BACKUP_CONTROLLER:
         {
            // we're already an NT5 DC
            context = NT5_DC;
            break;
         }
         case Computer::STANDALONE_WORKSTATION:
         case Computer::MEMBER_WORKSTATION:
         default:
         {
            // we checked for this at startup
            ASSERT(false);
            break;
         }
      }
   }

   LOG(CONTEXTS[context]);
}



State::~State()
{
   LOG_DTOR(State);

   FreeIfmHandle();

   delete answerFile;

   // closes the splash dialog, if visible.
   delete splash;
}



State::RunContext
State::GetRunContext() const
{
   LOG_FUNCTION2(State::GetRunContext, CONTEXTS[context]);

   return context;
}



bool
State::UsingAnswerFile() const
{
   return answerFile != 0;
}



String
State::GetAnswerFileOption(const String& option) const
{
   LOG_FUNCTION2(GetAnswerFileOption, option);
   ASSERT(UsingAnswerFile());

   String result;
   if (answerFile)
   {
      result = answerFile->GetOption(option);
   }

   return result;
}



EncryptedString
State::GetEncryptedAnswerFileOption(const String& option) const
{
   LOG_FUNCTION2(GetEncryptedAnswerFileOption, option);
   ASSERT(UsingAnswerFile());

   EncryptedString result;
   if (answerFile)
   {
      result = answerFile->GetEncryptedOption(option);
   }

   return result;
}
   


#ifdef LOGGING_BUILD
   static const String OPERATIONS[] =
   {
      L"NONE",
      L"REPLICA",
      L"FOREST",
      L"TREE",
      L"CHILD",
      L"DEMOTE",
      L"ABORT_BDC_UPGRADE"
   };
#endif



void
State::SetOperation(Operation oper)
{
   LOG_FUNCTION2(State::SetOperation, OPERATIONS[oper]);

   operation = oper;
}



State::Operation
State::GetOperation() const
{
   LOG_FUNCTION2(State::GetOperation, OPERATIONS[operation]);

   // if aborting BDC upgrade, context must be BDC upgrade

   ASSERT(operation == ABORT_BDC_UPGRADE ? context == BDC_UPGRADE : true);

   return operation;
}

void
State::SetIfmHandle(DSROLE_IFM_OPERATION_HANDLE IfmHandleIn)
{
    ASSERT(IfmHandle == NULL || IfmHandleIn == 0);
    if (IfmHandle) {
        // need to free any existing handle
        ::DsRoleIfmHandleFree(0, // this server
                              &IfmHandle);
        IfmHandle = NULL;
    }
    IfmHandle = IfmHandleIn;
}

void
State::SetReplicaDomainDNSName(const String& dnsName)
{
   LOG_FUNCTION2(State:::SetReplicaDomainDNSName, dnsName);
   ASSERT(!dnsName.empty());

   replicaDnsDomainName = dnsName;

   // if the user is changing the domain to be replicated, then any
   // previous replication partner DC may no longer apply.
   // see ntbug9 #158726

   SetReplicationPartnerDC(L"");
}
   


String
State::GetDatabasePath() const
{
   LOG_FUNCTION2(State::GetDatabasePath, dbPath);

   return dbPath;
}   



String
State::GetLogPath() const
{
   LOG_FUNCTION2(State::GetLogPath, logPath);

   return logPath;
}



String
State::GetSYSVOLPath() const
{
   LOG_FUNCTION2(State::GetSYSVOLPath, sysvolPath);

   return sysvolPath;
}
 


void
State::SetDatabasePath(const String& path)
{
   LOG_FUNCTION2(State::SetDatabasePath, path);
   ASSERT(!path.empty());

   dbPath = path;
}

   

void
State::SetLogPath(const String& path)
{
   LOG_FUNCTION2(State::SetLogPath, path);
   ASSERT(!path.empty());

   logPath = path;
}



void
State::SetSYSVOLPath(const String& path)
{
   LOG_FUNCTION2(State::SetSYSVOLPath, path);
   ASSERT(!path.empty());

   sysvolPath = path;
}
   


String
State::GetUsername() const
{
   LOG_FUNCTION2(State::GetUsername, username);

   // don't assert that this is !empty -- we may use existing credentials

   return username;
}

   

EncryptedString
State::GetPassword() const
{
   // don't log the password...

   LOG_FUNCTION(State::GetPassword);

   // don't assert that this is !empty -- we may use existing credentials

   return password;
}



void
State::SetUsername(const String& name)
{
   LOG_FUNCTION2(State::SetUsername, name);
   ASSERT(!name.empty());

   username = name;
}



void
State::SetPassword(const EncryptedString& password_)
{
   LOG_FUNCTION(State::SetPassword);
   // password_ may be empty
//   ASSERT(!password_.empty());

   password = password_;
}



String
State::GetReplicaDomainDNSName() const
{
   LOG_FUNCTION2(
      State::GetReplicaDomainDNSName,
      replicaDnsDomainName);

   return replicaDnsDomainName;
}



String
State::GetSiteName() const
{
   LOG_FUNCTION2(State::GetSiteName, siteName);

   return siteName;
}



void
State::SetSiteName(const String& site)
{
   LOG_FUNCTION2(State::SetSiteName, site);
   
   siteName = site;
}



void
State::SetOperationResults(OperationResult result)
{
   LOG_FUNCTION2(
      State::SetOperationResults,
      String::format(L"result %1",
      result == SUCCESS ? L"SUCCESS" : L"FAILURE"));

   operationResultsStatus = result;
}



void
State::SetOperationResultsMessage(const String& message)
{
   LOG_FUNCTION2(State::SetOperationResultsMessage, message);

   operationResultsMessage = message;
}



String
State::GetParentDomainDnsName() const
{
   LOG_FUNCTION2(
      State::GetParentDomainDnsName,
      parentDomainDnsName);

   return parentDomainDnsName;
}



String
State::GetNewDomainDNSName() const
{
   LOG_FUNCTION2(State::GetNewDomainDNSName, newDomainDnsName);

   return newDomainDnsName;
}



String
State::GetNewDomainNetbiosName() const
{
   LOG_FUNCTION2(
      State::GetNewDomainNetbiosName,
      newDomainFlatName);

   return newDomainFlatName;
}



void
State::SetParentDomainDNSName(const String& name)
{
   LOG_FUNCTION2(State::SetParentDomainDNSName, name);
   ASSERT(!name.empty());

   parentDomainDnsName = name;
}



void
State::SetNewDomainDNSName(const String& name)
{
   LOG_FUNCTION2(State::SetNewDomainDNSName, name);
   ASSERT(!name.empty());

   newDomainDnsName = name;

   // This will cause the flat name to be re-generated

   newDomainFlatName.erase();
}



void
State::SetNewDomainNetbiosName(const String& name)
{
   LOG_FUNCTION2(State::SetNewDomainNetbiosName, name);
   ASSERT(!name.empty());

   newDomainFlatName = name;
}
   


void
State::SetUserDomainName(const String& name)
{
   LOG_FUNCTION2(State::SetUserDomainName, name);

   // name may be empty;

   userDomain = name;
}



String
State::GetUserDomainName() const
{
   LOG_FUNCTION2(State::GetUserDomainName, userDomain);

   return userDomain;
}



void
State::ClearHiddenWhileUnattended()
{
   LOG_FUNCTION(State::ClearHiddenWhileUnattended);

   runHiddenWhileUnattended = false;

   // closes the splash dialog, if visible.

   if (splash)
   {
      // this will delete splash, too

      splash->SelfDestruct();
      splash = 0;
   }
}



bool
State::RunHiddenUnattended() const
{
//   LOG_FUNCTION(State::RunHiddenUnattended);

   return UsingAnswerFile() && runHiddenWhileUnattended;
}



bool
State::IsLastDCInDomain() const
{
   LOG_FUNCTION2(State::IsLastDCInDomain, isLastDc ? L"true" : L"false");

   return isLastDc;
}



void
State::SetIsLastDCInDomain(bool yesNo)
{
   LOG_FUNCTION2(
      State::SetIsLastDCInDomain,
      yesNo ? L"is last dc" : L"is NOT last dc");

   isLastDc = yesNo;
}



void
State::SetAdminPassword(const EncryptedString& password)
{
   LOG_FUNCTION(State::SetAdminPassword);

   adminPassword = password;
}



EncryptedString
State::GetAdminPassword() const
{
   LOG_FUNCTION(State::GetAdminPassword);

   return adminPassword;
}



String
State::GetOperationResultsMessage() const
{
   LOG_FUNCTION2(
      State::GetOperationResultsMessage,
      operationResultsMessage);

   return operationResultsMessage;
}



State::OperationResult
State::GetOperationResultsCode() const
{
   LOG_FUNCTION2(
      State::GetOperationResultsCode,
      operationResultsStatus == SUCCESS ? L"SUCCESS" : L"FAILURE");

   return operationResultsStatus;
}



bool
State::AutoConfigureDNS() const
{
   LOG_FUNCTION2(
      State::AutoConfigureDNS,
      autoConfigDns ? L"true" : L"false");

   return autoConfigDns;
}

      

void
State::SetAutoConfigureDNS(bool yesNo)
{
   LOG_FUNCTION2(
      State::SetAutoConfigureDNS,
      yesNo ? L"true" : L"false");

   autoConfigDns = yesNo;
}



bool
State::IsDNSOnNetwork() const
{
   LOG_FUNCTION2(
      State::IsDNSOnNetwork,
      isDnsOnNet ? L"true" : L"false");

   return isDnsOnNet;
}



void
State::SetDNSOnNetwork(bool yesNo)
{
   LOG_FUNCTION2(
      State::SetDNSOnNetwork,
      yesNo ? L"true" : L"false");

   isDnsOnNet = yesNo;
}



String
State::GetInstalledSite() const
{
   LOG_FUNCTION2(State::GetInstalledSite, installedSite);

   // should be set before we ask for it...
   ASSERT(!installedSite.empty());

   return installedSite;
}



void
State::SetInstalledSite(const String& site)
{
   LOG_FUNCTION2(State::SetInstalledSite, site);
   ASSERT(!site.empty());

   installedSite = site;
}
   

   
void
State::AddFinishMessage(const String& message)
{
   LOG_FUNCTION2(State::AddFinishMessage, message);
   ASSERT(!message.empty());

   if (finishMessages.empty())
   {
      finishMessages += message;
   }
   else
   {
      // add a blank line between each message

      finishMessages += L"\r\n\r\n" + message;
   }
}



String
State::GetFinishMessages() const
{
   LOG_FUNCTION2(State::GetFinishMessages, finishMessages);

   return finishMessages;
}
   


Computer&
State::GetComputer()
{
   return computer;
}



void
State::SetFailureMessage(const String& message)
{
   LOG_FUNCTION2(State::SetFailureMessage, message);
   ASSERT(!message.empty());

   failureMessage = message;
}


   
String
State::GetFailureMessage() const
{
   LOG_FUNCTION2(State::GetFailureMessage, failureMessage);

   return failureMessage;
}



bool
State::ShouldInstallAndConfigureDns() const
{
   if (AutoConfigureDNS() || !IsDNSOnNetwork())
   {
      return true;
   }

   return false;
}
   


String
State::GetUserForestName() const
{
   LOG_FUNCTION2(State::GetUserForestName, userForest);
   ASSERT(!userForest.empty());

   return userForest;
}



void
State::SetUserForestName(const String& forest)
{
   LOG_FUNCTION2(State::SetUserForestName, forest);
   ASSERT(!forest.empty());

   userForest = forest;
}



bool
State::IsDomainInForest(const String& domain) const
{
   LOG_FUNCTION2(State::IsDomainInForest, domain);
   ASSERT(!domain.empty());

   for (
      DomainList::iterator i = domainsInForest.begin();
      i != domainsInForest.end();
      i++)
   {
      DNS_NAME_COMPARE_STATUS compare = Dns::CompareNames(*i, domain);
      if (compare == DnsNameCompareEqual)
      {
         LOG(L"domain is in forest");
         return true;
      }
   }

   return false;
}



HRESULT
State::ReadDomains()
{
   LOG_FUNCTION(State::ReadDomains);

   domainsInForest.clear();
   return ::ReadDomains(domainsInForest);
}



DNS_NAME_COMPARE_STATUS
State::DomainFitsInForest(const String& domain, String& conflictingDomain)
{
   LOG_FUNCTION(domainFitsInForest);
   ASSERT(!domain.empty());

   conflictingDomain.erase();

   DNS_NAME_COMPARE_STATUS relation = DnsNameCompareNotEqual;
   for (
      DomainList::iterator i = domainsInForest.begin();
      i != domainsInForest.end();
      i++)
   {
      relation = Dns::CompareNames(domain, *i);
      switch (relation)
      {
         case DnsNameCompareNotEqual:
         {
            continue;
         }
         case DnsNameCompareEqual:
         {
            ASSERT(domain == *i);
            // fall thru
         }
         case DnsNameCompareLeftParent:
         case DnsNameCompareRightParent:
         case DnsNameCompareInvalid:
         default:
         {
            conflictingDomain = *i;
            break;
         }
      }

      break;
   }

   return relation;
}



bool
State::GetDomainReinstallFlag() const
{
   LOG_FUNCTION2(
      State::GetDomainReinstallFlag,
      reinstallDomain ? L"true" : L"false");

   return reinstallDomain;
}

   

void
State::SetDomainReinstallFlag(bool newValue)
{
   LOG_FUNCTION2(
      State::SetDomainReinstallFlag,
      newValue ? L"true" : L"false");

   reinstallDomain = newValue;
}



bool
State::ShouldAllowAnonymousAccess() const
{
   LOG_FUNCTION2(
      State::ShouldAllowAnonymousAccess,
      allowAnonAccess ? L"true" : L"false");
   
   return allowAnonAccess;
}



void
State::SetShouldAllowAnonymousAccess(bool yesNo)
{
   LOG_FUNCTION2(
      State::ShouldAllowAnonymousAccess,
      yesNo ? L"true" : L"false");

   allowAnonAccess = yesNo;
}



String
State::GetReplicationPartnerDC() const
{
   LOG_FUNCTION2(State::GetReplicationPartnerDC, replicationPartnerDc);

   return replicationPartnerDc;
}



void
State::SetReplicationPartnerDC(const String dcName)
{
   LOG_FUNCTION2(State::SetReplicationPartnerDC, dcName);

   replicationPartnerDc = dcName;
}



// Retrieve domain controller info for all DCs in the domain that this dc
// is a controller.  (The result set should include this dc)
// Caller should free the result with DsFreeDomainControllerInfo

HRESULT
State::GetDomainControllerInfoForMyDomain(
   DS_DOMAIN_CONTROLLER_INFO_2W*& info,
   DWORD&                         dcCount) 
{
   LOG_FUNCTION(State::GetDomainControllerInfoForMyDomain);

   // if this assertion does not hold, then the DsBind call below should
   // fail.

   ASSERT(GetComputer().IsDomainController());

   dcCount = 0;
   info = 0;

   HRESULT hr = S_OK;
   HANDLE hds = 0;
   do
   {
      String domainDnsName = GetComputer().GetDomainDnsName();
      String dcName = Win::GetComputerNameEx(ComputerNameDnsFullyQualified);

      ASSERT(!domainDnsName.empty());
      ASSERT(!dcName.empty());

      // Bind to self

      hr =
         MyDsBind(
            dcName,
            domainDnsName,
            hds);
      BREAK_ON_FAILED_HRESULT(hr);

      // find all the dc's for my domain.  the list should contain dcName.
      // level 2 contains the "is gc" flag

      hr =
         MyDsGetDomainControllerInfo(
            hds,
            domainDnsName,
            dcCount,
            info);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (hds)
   {
      ::DsUnBind(&hds);
      hds = 0;
   }

   return hr;
}



// returns true if no other domain controller for this DCs domain can be
// found in the DS.  False otherwise

bool
State::IsReallyLastDcInDomain()
{
   LOG_FUNCTION(State::IsReallyLastDcInDomain);

   // Assume we are alone in the universe.

   bool result = true;

   do
   {
      // find all the dc's for my domain.  the list should contain dcName.
      
      DS_DOMAIN_CONTROLLER_INFO_2W* info = 0;
      DWORD count = 0;

      HRESULT hr = GetDomainControllerInfoForMyDomain(info, count);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(count);
      ASSERT(info);

      // if there are more than 1 entry (more than the one for this dc),
      // then the DS believes that there are other DCs for this domain.

      if (count > 1)
      {
         result = false;
      }

#ifdef DBG

      // double check that we found ourselves.

      if (result && info[0].DnsHostName)
      {
         LOG(info[0].DnsHostName);

         String dcName =
            Win::GetComputerNameEx(ComputerNameDnsFullyQualified);

         ASSERT(
            Dns::CompareNames(info[0].DnsHostName, dcName)
            == DnsNameCompareEqual);
      }

#endif 

      MyDsFreeDomainControllerInfo(count, info);
   }
   while (0);
   
   LOG(
      String::format(
         L"This box %1 the sole DC for the domain",
         result ? L"is" : L"is NOT"));

   return result;
}



// Returns true if this computer is a global catalog

bool
State::IsGlobalCatalog()
{
   LOG_FUNCTION(State::IsGlobalCatalog);

   if (!GetComputer().IsDomainController())
   {
      // can't possibly be a GC if not a DC

      return false;
   }

   bool result = false;
   do
   {
      String dcName = Win::GetComputerNameEx(ComputerNameDnsFullyQualified);

      // find all the dc's for my domain.  the list should contain dcName.
      // level 2 contains the "is gc" flag
      
      DS_DOMAIN_CONTROLLER_INFO_2W* info = 0;
      DWORD count = 0;

      HRESULT hr = GetDomainControllerInfoForMyDomain(info, count);
      BREAK_ON_FAILED_HRESULT(hr);

      // there should be at least 1 entry (ourself)

      ASSERT(count);
      ASSERT(info);

      for (size_t i = 0; i < count; i++)
      {
         if (info[i].DnsHostName)   // 340723
         {
            LOG(info[i].DnsHostName);

            if (
                  Dns::CompareNames(info[i].DnsHostName, dcName)
               == DnsNameCompareEqual)
            {
               // we found ourselves in the list

               LOG(L"found!");
               result = info[i].fIsGc ? true : false;
               break;
            }
         }
      }

      MyDsFreeDomainControllerInfo(count, info);
   }
   while (0);

   LOG(
      String::format(
         L"This box %1 a global catalog",
         result ? L"is" : L"is NOT"));

   return result;
}



EncryptedString
State::GetSafeModeAdminPassword() const
{
   LOG_FUNCTION(State::GetSafeModeAdminPassword);

   // don't trace the password!

   return safeModeAdminPassword;
}



void
State::SetSafeModeAdminPassword(const EncryptedString& pwd)
{
   LOG_FUNCTION(State::SetSafeModeAdminPassword);

   // don't trace the password!
   // pwd may be empty.

   safeModeAdminPassword = pwd;
}



String
State::GetAdminToolsShortcutPath() const
{
   LOG_FUNCTION2(State::GetAdminToolsShortcutPath, shortcutPath);

   return shortcutPath;
}



bool
State::NeedsCommandLineHelp() const
{
   return needsCommandLineHelp;
}



bool
State::IsAdvancedMode() const
{
   return isAdvancedMode;
}



void
State::SetReplicateFromMedia(bool yesNo)
{
   LOG_FUNCTION2(
      State::SetReplicateFromMedia,
      yesNo ? L"true" : L"false");

   replicateFromMedia = yesNo;
}



void
State::SetReplicationSourcePath(const String& path)
{
   LOG_FUNCTION2(State::SetReplicationSourcePath, path);

   sourcePath = path;
}



bool
State::ReplicateFromMedia() const
{
   LOG_FUNCTION2(
      State::ReplicateFromMedia,
      replicateFromMedia ? L"true" : L"false");

   return replicateFromMedia;
}



String
State::GetReplicationSourcePath() const
{
   LOG_FUNCTION2(State::GetReplicationSourcePath, sourcePath);

   return sourcePath;
}



void
State::SetSyskeyLocation(SyskeyLocation loc)
{
   LOG_FUNCTION2(State::SetSyskeyLocation,
         loc == DISK
      ?  L"disk"
      :  ((loc == PROMPT) ? L"prompt" : L"stored"));

   syskeyLocation = loc;
}



State::SyskeyLocation
State::GetSyskeyLocation() const
{
   LOG_FUNCTION2(
      State::IsSyskeyPresent,
         syskeyLocation == DISK
      ?  L"disk"
      :  ((syskeyLocation == PROMPT) ? L"prompt" : L"stored"));

   return syskeyLocation;
}



void
State::SetIsBackupGc(bool yesNo)
{
   LOG_FUNCTION2(State::SetIsBackupGc, yesNo ? L"true" : L"false");

   isBackupGc = yesNo;
}



bool
State::IsBackupGc() const
{
   LOG_FUNCTION2(State::IsBackupGc, isBackupGc ? L"true" : L"false");

   return isBackupGc;
}



void
State::SetSyskey(const EncryptedString& syskey_)
{
   // don't log the syskey!

   LOG_FUNCTION(State::SetSyskey);
   ASSERT(!syskey_.IsEmpty());

   syskey = syskey_;
}



EncryptedString
State::GetSyskey() const
{
   // don't log the syskey!

   LOG_FUNCTION(State::GetSyskey);

   return syskey;
}



void
State::SetRestoreGc(bool yesNo)
{
   LOG_FUNCTION2(State::SetRestoreGc, yesNo ? L"true" : L"false");

   restoreGc = yesNo;
}



bool
State::GetRestoreGc() const
{
   LOG_FUNCTION2(State::GetRestoreGc, restoreGc ? L"true" : L"false");

   return restoreGc;
}



bool
State::IsSafeModeAdminPwdOptionPresent() const
{
   LOG_FUNCTION(State::IsSafeModeAdminPwdOptionPresent);
   ASSERT(UsingAnswerFile());

   bool result = false;

   if (answerFile)
   {
      result = answerFile->IsSafeModeAdminPwdOptionPresent();
   }

   LOG(result ? L"true" : L"false");

   return result;
}



void
State::SetDomainControllerReinstallFlag(bool newValue)
{
   LOG_FUNCTION2(
      State::SetDomainControllerReinstallFlag,
      newValue ? L"true" : L"false");

   reinstallDomainController = newValue;
}



bool
State::GetDomainControllerReinstallFlag() const
{
   LOG_FUNCTION2(
      State::GetDomainControllerReinstallFlag,
      reinstallDomain ? L"true" : L"false");

   return reinstallDomainController;
}



void
State::SetOperationResultsFlags(ULONG flags)
{
   LOG_FUNCTION2(
      State::SetOperationResultsFlags,
      String::format(L"0x%1!X!", flags));

   operationResultsFlags = flags;
}



ULONG
State::GetOperationResultsFlags() const
{
   LOG_FUNCTION2(
      State::GetOperationResultsFlags,
      String::format(L"0x%1!X!", operationResultsFlags));

   return operationResultsFlags;
}



bool
State::IsOperationRetryAllowed() const
{
   LOG_FUNCTION(State::IsOperationRetryAllowed);

   bool result = true;
      
   if (operationResultsFlags & DSROLE_IFM_RESTORED_DATABASE_FILES_MOVED)
   {
      // don't allow the user to retry the operation again, as one consequence
      // of the failure is that the moved files are now trashed.  The user
      // must re-restore the files in order to attempt the operation again.
      // NTRAID#NTBUG9-296872-2001/01/29-sburns

      LOG(L"ifm files moved, retry not allowed");

      result = false;
   }

// NTRAID#NTBUG9-416968-2001/06/14-sburns   
#ifdef DBG
   if (IsExitOnFailureMode())
   {
      // don't allow retry on failure in this mode.  This will cause the
      // retry logic in the promote thread to be skipped.
      // 

      LOG(L"exit-on-failure mode trumps retry");
      
      result = false;
   }
#endif   
      
   LOG(result ? L"true" : L"false");

   return result;
}



// needing a reboot is a "sticky" setting: there's no way to turn it off.
// if you once needed to reboot the machine, you will always need to reboot
// the machine.  (at least, for now).

void
State::SetNeedsReboot()
{
   LOG_FUNCTION(State::SetNeedsReboot);
   
   needsReboot = true;
}



bool
State::GetNeedsReboot() const
{
   LOG_FUNCTION2(State::GetNeedsReboot, needsReboot ? L"true" : L"false");

   return needsReboot;
}
   

   
void
State::SetSetForestVersionFlag(bool setVersion)
{
   LOG_FUNCTION2(
      State::SetSetForestVersionFlag,
      setVersion ? L"true" : L"false");

   setForestVersion = setVersion;   
}



bool
State::GetSetForestVersionFlag() const
{
   LOG_FUNCTION2(
      State::GetSetForestVersionFlag,
      setForestVersion ? L"true" : L"false");

   return setForestVersion;   
}



// NTRAID#NTBUG9-416968-2001/06/14-sburns            
#ifdef DBG
bool
State::IsExitOnFailureMode() const
{
   LOG_FUNCTION2(
      State::IsExitOnFailureMode,
      isExitOnFailureMode ? L"true" : L"false");

   return isExitOnFailureMode;
}

#endif



bool      
State::IsLastAppPartitionReplica()
{
   LOG_FUNCTION(State::IsLastAppPartitionReplica);

   bool result = false;
   partitionList.clear();
   
   do
   {
      RunContext context = GetInstance().GetRunContext();
      if (context != State::NT5_DC)
      {
         // not a DC, so can't be replica of any NCs

         LOG(L"not a DC");
         break;
      }

      // Find any non-domain NCs for which this DC is the last replica

      HRESULT hr = IsLastNonDomainNamingContextReplica(partitionList);
      if (FAILED(hr))
      {
         LOG(L"Failed to determine if the machine is last replica of NDNCs");
         ASSERT(result == false);

         // This is not an error condition that we'll deal with here.  We
         // will end up passing an empty list to the demote API, which will
         // then fail, and we will catch the failure.
         
         break;
      }

      if (hr == S_FALSE)
      {
         LOG(L"Not last replica of non-domain NCs");
         ASSERT(result == false);
         break;
      }

      result = true;
         
      // there should be at least one DN in the list.

      ASSERT(partitionList.size());
   }
   while (0);

   LOG(result ? L"true" : L"false");

   return result;
}



const StringList&
State::GetAppPartitionList() const
{
   LOG_FUNCTION(State::GetAppPartitionList);

   return partitionList;
}



// Returns true if the registry option to not configure the dns client to
// point to itself is absent or non-zero, false otherwise.
// NTRAID#NTBUG9-446484-2001/10/11-sburns

bool
State::ShouldConfigDnsClient() const
{
   LOG_FUNCTION(State::ShouldConfigDnsClient);

   LOG_BOOL(shouldConfigDnsClient);
   return shouldConfigDnsClient;
}



// NTRAID#NTBUG9-496409-2001/11/29-sburns

bool
State::IsForcedDemotion() const
{
   LOG_FUNCTION2(
      State::IsForcedDemotion,
      isForcedDemotion ? L"true" : L"false");

   return isForcedDemotion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\syskeydiskdialog.cpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// get syskey on diskette for replica from media page
//
// 25 Apr 2000 sburns



#include "headers.hxx"
#include "resource.h"
#include "page.hpp"
#include "SyskeyDiskDialog.hpp"
#include "state.hpp"



static const DWORD HELP_MAP[] =
{
   0, 0
};



SyskeyDiskDialog::SyskeyDiskDialog()
   :
   Dialog(IDD_SYSKEY_DISK, HELP_MAP)
{
   LOG_CTOR(SyskeyDiskDialog);
}



SyskeyDiskDialog::~SyskeyDiskDialog()
{
   LOG_DTOR(SyskeyDiskDialog);
}



void
SyskeyDiskDialog::OnInit()
{
   LOG_FUNCTION(SyskeyDiskDialog::OnInit);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      if (Validate())
      {
         Win::EndDialog(hwnd, IDOK);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }
}



bool
SyskeyDiskDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIdFrom,
   unsigned    code)
{
//   LOG_FUNCTION(SyskeyDiskDialog::OnCommand);

   switch (controlIdFrom)
   {
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            if (Validate())
            {
               Win::EndDialog(hwnd, controlIdFrom);
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            Win::EndDialog(hwnd, controlIdFrom);
         }
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return false;
}



HRESULT
SyskeyDiskDialog::LocateSyskey(HWND hwnd)
{
   LOG_FUNCTION(LocateSyskey);

   HRESULT hr = S_OK;

   do
   {
      if (FS::PathExists(L"A:\\StartKey.Key"))
      {
         LOG(L"syskey found on a:");

         // The only drive the syskey may be present on is A:. Winlogon
         // also hardcodes A:, which they may change someday, but not today.
         // NTRAID#NTBUG9-522068-2002/01/23-sburns

         EncryptedString es;
         es.Encrypt(L"A:");
         State::GetInstance().SetSyskey(es);
         break;
      }

      hr = E_FAIL;

      if (hwnd)
      {
         popup.Error(hwnd, IDS_SYSKEY_NOT_FOUND);
      }
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}



bool
SyskeyDiskDialog::Validate()
{
   LOG_FUNCTION(SyskeyDiskDialog::Validate);

   bool result = false;

   do
   {
      // look for the syskey

      HRESULT hr = LocateSyskey(hwnd);

      if (FAILED(hr))
      {
         // LocateSyskey will take care of emitting error messages, so
         // we just need to bail out here

         break;
      }

      result = true;
   }
   while (0);

   LOG(result ? L"true" : L"false");

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\state.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// wizard state object
//
// 12-15-97 sburns



#ifndef STATE_HPP_INCLUDED
#define STATE_HPP_INCLUDED



#include "AnswerFile.hpp"
#include "UnattendSplashDialog.hpp"



class State
{
   public:

   // call from WinMain to init the global instance

   static
   void
   Init();

   // call from WinMain to delete the global instance

   static
   void
   Destroy();

   static
   State&
   GetInstance();

   bool
   AutoConfigureDNS() const;

   void
   SetAutoConfigureDNS(bool yesNo);

   String
   GetNewDomainNetbiosName() const;

   void
   SetNewDomainNetbiosName(const String& name);

   String
   GetNewDomainDNSName() const;

   void
   SetNewDomainDNSName(const String& name);

   String
   GetUsername() const;

   EncryptedString
   GetPassword() const;

   void
   SetUsername(const String& name);

   void
   SetPassword(const EncryptedString& password);

   String
   GetDatabasePath() const;

   String
   GetLogPath() const;

   String
   GetSYSVOLPath() const;

   String
   GetSiteName() const;

   void
   SetDatabasePath(const String& path);

   void
   SetLogPath(const String& path);

   void
   SetSYSVOLPath(const String& path);
     
   enum RunContext
   {
      NT5_DC,                 // already an NT5 DC
      NT5_STANDALONE_SERVER,  // standalone to DC
      NT5_MEMBER_SERVER,      // member server to DC
      BDC_UPGRADE,            // NT4 BDC to NT5 DC
      PDC_UPGRADE             // NT4 PDC to NT5 DC
   };

   RunContext
   GetRunContext() const;

   bool
   UsingAnswerFile() const;

   String
   GetAnswerFileOption(const String& option) const;

   EncryptedString
   GetEncryptedAnswerFileOption(const String& option) const;
   
   String
   GetReplicaDomainDNSName() const;

   enum Operation
   {
      NONE,
      REPLICA,
      FOREST,
      TREE,
      CHILD,
      DEMOTE,
      ABORT_BDC_UPGRADE
   };

   Operation
   GetOperation() const;

   String
   GetParentDomainDnsName() const;

   void
   SetParentDomainDNSName(const String& name);

   enum OperationResult
   {
      SUCCESS,
      FAILURE
   };

   void
   SetOperationResults(OperationResult result);

   OperationResult
   GetOperationResultsCode() const;

   void
   SetOperationResultsMessage(const String& message);

   String
   GetOperationResultsMessage() const;

   void
   SetOperation(Operation oper);

   #define FreeIfmHandle()    SetIfmHandle(0)
   
   void
   SetIfmHandle(DSROLE_IFM_OPERATION_HANDLE IfmHandleIn);

   void
   SetReplicaDomainDNSName(const String& dnsName);

   void
   SetSiteName(const String& site);
       
   void
   SetUserDomainName(const String& name);

   String
   GetUserDomainName() const;

   void
   ClearHiddenWhileUnattended();

   bool
   RunHiddenUnattended() const;

   bool
   IsLastDCInDomain() const;

   void
   SetIsLastDCInDomain(bool yesNo);

   void
   SetAdminPassword(const EncryptedString& password);

   EncryptedString
   GetAdminPassword() const;

   bool
   IsDNSOnNetwork() const;

   void
   SetDNSOnNetwork(bool yesNo);

   String
   GetInstalledSite() const;

   void
   SetInstalledSite(const String& site);

   void
   AddFinishMessage(const String& message);

   String
   GetFinishMessages() const;

   Computer&
   GetComputer();

   void
   SetFailureMessage(const String& message);

   String
   GetFailureMessage() const;

   bool
   ShouldInstallAndConfigureDns() const;

   String
   GetUserForestName() const;

   void
   SetUserForestName(const String& forest);

   bool
   IsDomainInForest(const String& domain) const;

   HRESULT
   ReadDomains();

   DNS_NAME_COMPARE_STATUS
   DomainFitsInForest(const String& domain, String& conflictingDomain);

   bool
   GetDomainReinstallFlag() const;

   void
   SetDomainReinstallFlag(bool newValue);

   // true to indicate that the RAS permissions script should be run.

   bool
   ShouldAllowAnonymousAccess() const;

   void
   SetShouldAllowAnonymousAccess(bool yesNo);

   String
   GetReplicationPartnerDC() const;

   void
   SetReplicationPartnerDC(const String dcName);

   // returns true if the machine is hosts a global catalog

   bool
   IsGlobalCatalog();

   EncryptedString
   GetSafeModeAdminPassword() const;

   void
   SetSafeModeAdminPassword(const EncryptedString& pwd);

   String
   GetAdminToolsShortcutPath() const;

   bool
   NeedsCommandLineHelp() const;

   bool
   IsAdvancedMode() const;

   void
   SetReplicateFromMedia(bool yesNo);

   void
   SetReplicationSourcePath(const String& path);

   bool
   ReplicateFromMedia() const;

   String
   GetReplicationSourcePath() const;

   bool
   IsReallyLastDcInDomain();

   enum SyskeyLocation
   {
      STORED,     // stored w/ backup
      DISK,       // look on disk
      PROMPT      // prompt user
   };

   void
   SetSyskeyLocation(SyskeyLocation loc);

   SyskeyLocation
   GetSyskeyLocation() const;

   void
   SetIsBackupGc(bool yesNo);

   bool
   IsBackupGc() const;

   void
   SetSyskey(const EncryptedString& syskey);

   EncryptedString
   GetSyskey() const;

   void
   SetRestoreGc(bool yesNo);

   bool
   GetRestoreGc() const;

   bool
   IsSafeModeAdminPwdOptionPresent() const;

   bool
   GetDomainControllerReinstallFlag() const;

   void
   SetDomainControllerReinstallFlag(bool newValue);

   bool
   IsOperationRetryAllowed() const;

   ULONG
   GetOperationResultsFlags() const;

   void
   SetOperationResultsFlags(ULONG flags);

   void
   SetNeedsReboot();

   bool
   GetNeedsReboot() const;

   void
   SetSetForestVersionFlag(bool setVersion);

   bool
   GetSetForestVersionFlag() const;

#ifdef DBG   
   bool
   IsExitOnFailureMode() const;
#endif   

   bool
   ShouldConfigDnsClient() const;
   

   
   // Determines if the domain controller is the last replica of any
   // non-domain naming contexts (a.k.a. Application Partitions).  If so,
   // returns true.  If not, returns false.  Returns false if the machine is
   // not a DC.
   // 
   // Also saves the list of the DNs of each partition for which the machine
   // is the last replica, which can be retrieved with GetAppPartitionList.

   bool      
   State::IsLastAppPartitionReplica();

   const StringList&
   GetAppPartitionList() const;

   bool
   IsForcedDemotion() const;


  
   private:

   // can only be created/destroyed by Init/Destroy

   State();

   ~State();

   void
   DetermineRunContext();

   void
   SetupAnswerFile(const String& filename, bool isDefaultAnswerfile);

   HRESULT
   GetDomainControllerInfoForMyDomain(
      DS_DOMAIN_CONTROLLER_INFO_2W*& info,
      DWORD&                         dcCount);

   typedef StringList DomainList;

   EncryptedString       adminPassword;             
   bool                  allowAnonAccess;               
   AnswerFile*           answerFile;                
   bool                  autoConfigDns;            
   Computer              computer;                   
   RunContext            context;                    
   String                dbPath;                    
   DomainList            domainsInForest;          
   String                failureMessage;            
   String                finishMessages;            
   String                installedSite;             
   bool                  isAdvancedMode;
   bool                  isBackupGc;
   bool                  isDnsOnNet;                 

// NTRAID#NTBUG9-416968-2001/06/14-sburns   
#ifdef DBG
   bool                  isExitOnFailureMode;
#endif

   bool                  isForcedDemotion;   
   bool                  isLastDc;
   bool                  isUpgrade;                 
   String                logPath;                   
   bool                  needsCommandLineHelp;
   bool                  needsReboot;
   String                newDomainDnsName;        
   String                newDomainFlatName;       
   Operation             operation;                  
   String                operationResultsMessage;   
   OperationResult       operationResultsStatus;    
   ULONG                 operationResultsFlags;
   String                parentDomainDnsName;
   StringList            partitionList;
   EncryptedString       password;                   
   bool                  reinstallDomain;
   bool                  reinstallDomainController;
   
   String                replicaDnsDomainName;
   DSROLE_IFM_OPERATION_HANDLE IfmHandle;

   bool                  replicateFromMedia;
   String                replicationPartnerDc;
   bool                  restoreGc;
   bool                  runHiddenWhileUnattended;
   EncryptedString       safeModeAdminPassword;
   bool                  setForestVersion;
   String                shortcutPath;
   bool                  shouldConfigDnsClient;
   String                siteName;                  
   String                sourcePath;
   UnattendSplashDialog* splash;                     
   String                sysvolPath;
   EncryptedString       syskey;
   SyskeyLocation        syskeyLocation;               
   bool                  useCurrentCredentials;    
   String                userDomain;                
   String                userForest;                
   String                username;

   // not defined: no copying.

   State(const State&);
   State& operator=(const State&);
};



#endif   // STATE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\syskeydiskdialog.hpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// get syskey on diskette for replica from media page
//
// 25 Apr 2000 sburns



#ifndef SYSKEYDISKDIALOG_HPP_INCLUDED
#define SYSKEYDISKDIALOG_HPP_INCLUDED



class SyskeyDiskDialog : public Dialog
{
   public:

   SyskeyDiskDialog();

   virtual ~SyskeyDiskDialog();

   

   // Attempts to locate the syskey file on A:. If it is not found, return
   // E_FAIL. If it is, update the global state object with the location, and
   // return S_OK.
   // 
   // hwnd - If hwnd is non-null, then on failure, complain to the user about
   // the failure. If null, remain silent about the failure.
   
   static
   HRESULT
   LocateSyskey(HWND hwnd);



   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   bool
   Validate();

   // not defined; no copying allowed

   SyskeyDiskDialog(const SyskeyDiskDialog&);
   const SyskeyDiskDialog& operator=(const SyskeyDiskDialog&);
};



#endif   // SYSKEYDISKDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\syskeypromptdialog.hpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// get syskey from user for replica from media page
//
// 25 Apr 2000 sburns



#ifndef SYSKEYPROMPTDIALOG_HPP_INCLUDED
#define SYSKEYPROMPTDIALOG_HPP_INCLUDED



class SyskeyPromptDialog : public Dialog
{
   public:

   SyskeyPromptDialog();

   virtual ~SyskeyPromptDialog();

   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   bool
   Validate();

   // not defined; no copying allowed

   SyskeyPromptDialog(const SyskeyPromptDialog&);
   const SyskeyPromptDialog& operator=(const SyskeyPromptDialog&);
};



#endif   // SYSKEYPROMPTDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\syskeypromptdialog.cpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// get syskey for replica from media page
//
// 25 Apr 2000 sburns



#include "headers.hxx"
#include "resource.h"
#include "page.hpp"
#include "SyskeyPromptDialog.hpp"
#include "state.hpp"



static const DWORD HELP_MAP[] =
{
   0, 0
};



SyskeyPromptDialog::SyskeyPromptDialog()
   :
   Dialog(IDD_SYSKEY_PROMPT, HELP_MAP)

{
   LOG_CTOR(SyskeyPromptDialog);
}



SyskeyPromptDialog::~SyskeyPromptDialog()
{
   LOG_DTOR(SyskeyPromptDialog);
}



void
SyskeyPromptDialog::OnInit()
{
   LOG_FUNCTION(SyskeyPromptDialog::OnInit);

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_SYSKEY), PWLEN);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      EncryptedString option =
         state.GetEncryptedAnswerFileOption(AnswerFile::OPTION_SYSKEY);
      if (!option.IsEmpty())
      {
         Win::SetDlgItemText(hwnd, IDC_SYSKEY, option);
      }
   }

   if (state.RunHiddenUnattended())
   {
      if (Validate())
      {
         Win::EndDialog(hwnd, IDOK);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }
}



bool
SyskeyPromptDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIdFrom,
   unsigned    code)
{
//   LOG_FUNCTION(SyskeyPromptDialog::OnCommand);

   switch (controlIdFrom)
   {
      case IDC_SYSKEY:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIdFrom);
            return true;
         }
         break;
      }
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            if (Validate())
            {
               Win::EndDialog(hwnd, controlIdFrom);
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            Win::EndDialog(hwnd, controlIdFrom);
         }
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return false;
}



bool
SyskeyPromptDialog::Validate()
{
   LOG_FUNCTION(SyskeyPromptDialog::Validate);

   State& state = State::GetInstance();

   bool result = false;

   do
   {
      EncryptedString syskey =
         Win::GetEncryptedDlgItemText(hwnd, IDC_SYSKEY);

      if (syskey.IsEmpty())
      {
         popup.Gripe(hwnd, IDC_SYSKEY, IDS_MUST_ENTER_SYSKEY);
         break;
      }

      state.SetSyskey(syskey);
      result = true;
   }
   while (0);

   LOG(result ? L"true" : L"false");

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\treepage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// new tree page
//
// 1-7-98 sburns



#ifndef TREEPAGE_HPP_INCLUDED
#define TREEPAGE_HPP_INCLUDED



class TreePage : public DCPromoWizardPage
{
   public:

   TreePage();

   protected:

   virtual ~TreePage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   // private:

   // not defined; no copying allowed

   TreePage(const TreePage&);
   const TreePage& operator=(const TreePage&);
};



#endif   // TREEPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\treepage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// new tree page
//
// 1-7-98 sburns



#include "headers.hxx"
#include "page.hpp"
#include "TreePage.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"
#include "dns.hpp"
#include <ValidateDomainName.hpp>
#include <ValidateDomainName.h>



TreePage::TreePage()
   :
   DCPromoWizardPage(
      IDD_NEW_TREE,
      IDS_TREE_PAGE_TITLE,
      IDS_TREE_PAGE_SUBTITLE)
{
   LOG_CTOR(TreePage);
}



TreePage::~TreePage()
{
   LOG_DTOR(TreePage);
}



void
TreePage::OnInit()
{
   LOG_FUNCTION(TreePage::OnInit);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_DOMAIN),
      DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      // this will cause IDC_DOMAIN to be marked changed, so the validation
      // code will be called.
      Win::SetDlgItemText(
         hwnd,
         IDC_DOMAIN,
         state.GetAnswerFileOption(
            AnswerFile::OPTION_NEW_DOMAIN_NAME));
   }
}



static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   int next =
      !Win::GetTrimmedDlgItemText(dialog, IDC_DOMAIN).empty()
      ? PSWIZB_NEXT
      : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);
}



bool
TreePage::OnSetActive()
{
   LOG_FUNCTION(TreePage::OnSetActive);
   ASSERT(State::GetInstance().GetOperation() == State::TREE);
      
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   enable(hwnd);
   return true;
}



bool
TreePage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(TreePage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_DOMAIN:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);            
            enable(hwnd);
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



int
TreePage::Validate()
{
   LOG_FUNCTION(TreePage::Validate);

   String domain = Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN);
   if (domain.empty())
   {
      popup.Gripe(hwnd, IDC_DOMAIN, IDS_MUST_ENTER_DOMAIN);
      return -1;
   }

   State& state = State::GetInstance();
   int nextPage =
         state.GetRunContext() == State::PDC_UPGRADE
      ?  IDD_PATHS
      :  IDD_NETBIOS_NAME;

   // SPB:251431 do validation even if this page is untouched, as upstream
   // pages may have been changed in such a fashion that re-validation is
   // required.
   // if (!WasChanged(IDC_DOMAIN))
   // {
   //    return nextPage;
   // }

   do
   {
      // verify that the new domain name is properly formatted and does
      // not exist.

      if (
            !ValidateDomainDnsNameSyntax(
               hwnd,
               IDC_DOMAIN,
               popup,

               // only warn on non RFC names if running interactively

               !state.RunHiddenUnattended())
         || !ConfirmNetbiosLookingNameIsReallyDnsName(hwnd, IDC_DOMAIN, popup)

            // do this test last, as it is expensive
            
         || !ValidateDomainDoesNotExist(hwnd, IDC_DOMAIN) )
      {
         break;
      }

      domain = Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN);
      String conflictingDomain;
      switch (state.DomainFitsInForest(domain, conflictingDomain))
      {
         case DnsNameCompareLeftParent:
         {
            // can't encompass another tree

            popup.Gripe(
               hwnd,
               IDC_DOMAIN,
               String::format(
                  IDS_SUPERIOR_TO_TREE,
                  domain.c_str(),
                  conflictingDomain.c_str()));
            break;
         }
         case DnsNameCompareRightParent:
         {
            // should be a child domain instead

            popup.Gripe(
               hwnd,
               IDC_DOMAIN,
               String::format(
                  IDS_INFERIOR_TO_TREE,
                  domain.c_str(),
                  conflictingDomain.c_str()));
            break;
         }
         case DnsNameCompareEqual:
         {
            // shouldn't happen, ValidateDomainDNSName call above would
            // have caught it, unless all the DCs for the domain are
            // unreachable or offline.

            popup.Gripe(
               hwnd,
               IDC_DOMAIN,
               String::format(IDS_DOMAIN_NAME_IN_USE, domain.c_str()));
            break;
         }
         case DnsNameCompareInvalid:
         {
            // shouldn't happen, ValidateDomainDNSName call above would
            // have caught it.

            ASSERT(false);
            popup.Gripe(
               hwnd,
               IDC_DOMAIN,
               String::format(
                  IDS_BAD_DNS_SYNTAX,
                  domain.c_str(),
                  Dns::MAX_LABEL_LENGTH));
            break;
         }
         case DnsNameCompareNotEqual:
         {
            // valid

            ClearChanges();
            state.SetParentDomainDNSName(state.GetUserForestName());
            state.SetNewDomainDNSName(domain);
            return nextPage;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }
   }
   while (0);

   return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\unattendsplashdialog.cpp ===
// Copyright (C) 1998 Microsoft Corporation
//
// Splash screen for unattended mode
//
// 10-1-98 sburns



#include "headers.hxx"
#include "UnattendSplashDialog.hpp"
#include "resource.h"
#include "state.hpp"



const UINT SELF_DESTRUCT_MESSAGE = WM_USER + 200;



static const DWORD HELP_MAP[] =
{
   0, 0
};



UnattendSplashDialog::UnattendSplashDialog(int splashMessageResId)
   :
   Dialog(IDD_UNATTEND_SPLASH, HELP_MAP),
   messageResId(splashMessageResId)
{
   LOG_CTOR(UnattendSplashDialog);
   ASSERT(messageResId);
}



UnattendSplashDialog::~UnattendSplashDialog()
{
   LOG_DTOR(UnattendSplashDialog);
}



void
UnattendSplashDialog::OnInit()
{
   LOG_FUNCTION(UnattendSplashDialog::OnInit);

   // Since the window does not have a title bar, we need to give it some
   // text to appear on the button label on the shell task bar.

   Win::SetWindowText(hwnd, String::load(IDS_WIZARD_TITLE));

   // NTRAID#NTBUG9-502991-2001/12/07-sburns
   
   Win::SetDlgItemText(hwnd, IDC_MESSAGE, messageResId);
}



void
UnattendSplashDialog::SelfDestruct()
{
   LOG_FUNCTION(UnattendSplashDialog::SelfDestruct);
      
   // Post our window proc a self destruct message.  We use Post instead of
   // send, as we expect that in some cases, this function will be called from
   // a thread other than the one that created the window.  (It is illegal to
   // try to destroy a window from a thread that it not the thread that
   // created the window.)

   Win::PostMessage(hwnd, SELF_DESTRUCT_MESSAGE, 0, 0);
}
      


bool
UnattendSplashDialog::OnMessage(
   UINT     message,
   WPARAM   /* wparam */ ,
   LPARAM   /* lparam */ )
{
   if (message == SELF_DESTRUCT_MESSAGE)
   {
      delete this;
      return true;
   }

   return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\unattendsplashdialog.hpp ===
// Copyright (C) 1998 Microsoft Corporation
//
// Splash screen for unattended mode
//
// 10-1-98 sburns



#ifndef UNATTENDSPLASHDIALOG_HPP_INCLUDED
#define UNATTENDSPLASHDIALOG_HPP_INCLUDED



class UnattendSplashDialog : public Dialog
{
   public:

   UnattendSplashDialog(int splashMessageResId);

   virtual ~UnattendSplashDialog();

   // Cause the window to destroy itself and delete itself (call delete on
   // the this pointer.

   void
   SelfDestruct();

   // Dialog overrides

   virtual
   void
   OnInit();

   virtual
   bool
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

   private:

   int messageResId;
   
   // not defined; no copying allowed

   UnattendSplashDialog(const UnattendSplashDialog&);
   const UnattendSplashDialog& operator=(const UnattendSplashDialog&);
};



#endif   // UNATTENDSPLASHDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\welcomepage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// welcome page
//
// 12-15-97 sburns



#ifndef WELCOMEPAGE_HPP_INCLUDED
#define WELCOMEPAGE_HPP_INCLUDED



class WelcomePage : public DCPromoWizardPage
{
   public:

   WelcomePage();

   protected:

   virtual ~WelcomePage();

   // Dialog overrides

   virtual
   void
   OnInit();

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lParam);

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   WelcomePage(const WelcomePage&);
   const WelcomePage& operator=(const WelcomePage&);
};



#endif   // WELCOMEPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\exe\welcomepage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// welcome page
//
// 12-15-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "WelcomePage.hpp"
#include "resource.h"
#include "common.hpp"
#include "state.hpp"



WelcomePage::WelcomePage()
   :
   DCPromoWizardPage(
      IDD_WELCOME,
      IDS_WELCOME_PAGE_TITLE,
      IDS_WELCOME_PAGE_SUBTITLE,
      false)
{
   LOG_CTOR(WelcomePage);
}



WelcomePage::~WelcomePage()
{
   LOG_DTOR(WelcomePage);
}



// NTRAID#NTBUG9-510384-2002/01/22-sburns

bool
WelcomePage::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   /* lParam */ )
{
//   LOG_FUNCTION(WelcomePage::OnNotify);

   bool result = false;
   
   switch (code)
   {
      case NM_CLICK:
      case NM_RETURN:
      {
         switch (controlIDFrom)
         {
            case IDC_PRIMER_LINK:
            {
               Win::HtmlHelp(
                  hwnd,
                  L"adconcepts.chm::/sag_AD_DCInstallTopNode.htm",
                  HH_DISPLAY_TOPIC,
                  0);
               result = true;
               break;
            }
            default:
            {
               // do nothing
               
               break;
            }
         }
      }
      default:
      {
         // do nothing
         
         break;
      }
   }
   
   return result;
}



void
WelcomePage::OnInit()
{
   LOG_FUNCTION(WelcomePage::OnInit);

   SetLargeFont(hwnd, IDC_BIG_BOLD_TITLE);

   Win::PropSheet_SetTitle(
      Win::GetParent(hwnd),     
      0,
      String::load(IDS_WIZARD_TITLE));

   State& state        = State::GetInstance();
   int    intro1TextId = IDS_INTRO1_INSTALL;  
   String intro2Text;                   

   switch (state.GetRunContext())
   {
      case State::NT5_DC:
      {
         intro1TextId = IDS_INTRO1_DEMOTE;
         intro2Text   = String::load(IDS_INTRO2_DEMOTE);

         // no readme for demote.
         
         Win::ShowWindow(Win::GetDlgItem(hwnd, IDC_PRIMER_LINK), SW_HIDE);
         
         break;
      }
      case State::NT5_STANDALONE_SERVER:
      case State::NT5_MEMBER_SERVER:
      {
         intro2Text   = String::load(IDS_INTRO2_INSTALL);
         break;
      }
      case State::BDC_UPGRADE:
      {
         intro1TextId = IDS_INTRO1_DC_UPGRADE;
         intro2Text   = String::load(IDS_INTRO2_BDC_UPGRADE);
         break;
      }
      case State::PDC_UPGRADE:
      {
         intro1TextId = IDS_INTRO1_DC_UPGRADE;         
         intro2Text   =
            String::format(
               IDS_INTRO2_PDC_UPGRADE,
               state.GetComputer().GetDomainNetbiosName().c_str());
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   Win::SetDlgItemText(hwnd, IDC_INTRO1, String::load(intro1TextId));
   Win::SetDlgItemText(hwnd, IDC_INTRO2, intro2Text);
}



bool
WelcomePage::OnSetActive()
{
   LOG_FUNCTION(WelcomePage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd), PSWIZB_NEXT);

   Win::PostMessage(
      Win::GetParent(hwnd),
      WM_NEXTDLGCTL,
      (WPARAM) Win::GetDlgItem(Win::GetParent(hwnd), Wizard::NEXT_BTN_ID),
      TRUE);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   return true;
}



int
WelcomePage::Validate()
{
   LOG_FUNCTION(WelcomePage::Validate);
   int nextPage = -1;

   State& state = State::GetInstance();
   switch (state.GetRunContext())
   {
      case State::PDC_UPGRADE:
      case State::NT5_STANDALONE_SERVER:
      case State::NT5_MEMBER_SERVER:
      case State::BDC_UPGRADE:
      {
         nextPage = IDD_SECWARN;
         break;
      }
      case State::NT5_DC:
      {
         state.SetOperation(State::DEMOTE);

         // NTRAID#NTBUG9-496409-2001/11/29-sburns
         
         if (state.IsForcedDemotion())
         {
            nextPage = IDD_FORCE_DEMOTE;
         }
         else
         {
            nextPage = IDD_DEMOTE;
         }
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\accessiblewrapper.h ===
//****************************************************************************
//
//  Copyright (c) 2001-2002, Microsoft Corporation
//
//  File:  AccessibleWrapper.H
//
//  Copied from nt\shell\themes\themeui\SettingsPg.h
//
//****************************************************************************
#ifndef _ACCESSIBLE_WRAPPER_H_
#define _ACCESSIBLE_WRAPPER_H_
#include <oleacc.h>

class CAccessibleWrapper: public IAccessible
{
        // We need to do our own refcounting for this wrapper object
        ULONG          m_ref;

        // Need ptr to the IAccessible
        IAccessible *  m_pAcc;
        HWND           m_hwnd;

public:
        CAccessibleWrapper( HWND hwnd, IAccessible * pAcc);
        virtual ~CAccessibleWrapper();

        // IUnknown
        // (We do our own ref counting)
        virtual STDMETHODIMP            QueryInterface(REFIID riid, void** ppv);
        virtual STDMETHODIMP_(ULONG)    AddRef();
        virtual STDMETHODIMP_(ULONG)    Release();

        // IDispatch
        virtual STDMETHODIMP            GetTypeInfoCount(UINT* pctinfo);
        virtual STDMETHODIMP            GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
        virtual STDMETHODIMP            GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
            LCID lcid, DISPID* rgdispid);
        virtual STDMETHODIMP            Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
            DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
            UINT* puArgErr);

        // IAccessible
        virtual STDMETHODIMP            get_accParent(IDispatch ** ppdispParent);
        virtual STDMETHODIMP            get_accChildCount(long* pChildCount);
        virtual STDMETHODIMP            get_accChild(VARIANT varChild, IDispatch ** ppdispChild);

        virtual STDMETHODIMP            get_accName(VARIANT varChild, BSTR* pszName);
        virtual STDMETHODIMP            get_accValue(VARIANT varChild, BSTR* pszValue);
        virtual STDMETHODIMP            get_accDescription(VARIANT varChild, BSTR* pszDescription);
        virtual STDMETHODIMP            get_accRole(VARIANT varChild, VARIANT *pvarRole);
        virtual STDMETHODIMP            get_accState(VARIANT varChild, VARIANT *pvarState);
        virtual STDMETHODIMP            get_accHelp(VARIANT varChild, BSTR* pszHelp);
        virtual STDMETHODIMP            get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic);
        virtual STDMETHODIMP            get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut);
        virtual STDMETHODIMP            get_accFocus(VARIANT * pvarFocusChild);
        virtual STDMETHODIMP            get_accSelection(VARIANT * pvarSelectedChildren);
        virtual STDMETHODIMP            get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

        virtual STDMETHODIMP            accSelect(long flagsSel, VARIANT varChild);
        virtual STDMETHODIMP            accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
        virtual STDMETHODIMP            accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
        virtual STDMETHODIMP            accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
        virtual STDMETHODIMP            accDoDefaultAction(VARIANT varChild);

        virtual STDMETHODIMP            put_accName(VARIANT varChild, BSTR szName);
        virtual STDMETHODIMP            put_accValue(VARIANT varChild, BSTR pszValue);
};


#endif _ACCESSIBLE_WRAPPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dcpromo\helper\dcphelp.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// domain controller promotion wizard helper
//
// 8-13-99 sburns



#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME = L"dcpromohelp";

DWORD DEFAULT_LOGGING_OPTIONS =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_HEADER;



// Template function that actually calls ADsGetObject.
// 
// Interface - The IADsXXX interface of the object to be bound.
// 
// path - The ADSI path of the object to be bound.
// 
// ptr - A null smart pointer to be bound to the interface of the object.

template <class Interface> 
static
HRESULT
TemplateGetObject(
   const String&              path,
   SmartInterface<Interface>& ptr)
{
   LOG_FUNCTION2(TemplateGetObject, path);
   ASSERT(!path.empty());

   Interface* p = 0;
   HRESULT hr = 
      ::ADsGetObject(
         path.c_str(),
         __uuidof(Interface), 
         reinterpret_cast<void**>(&p));
   if (SUCCEEDED(hr))
   {
      ptr.Acquire(p);
   }

   return hr;
}



// Start csvde.exe with appropriate parameters, running without a window
//
// domainDn - full DN of the domain into which the display specifiers are
// to be imported. e.g. DC=foo,DC=bar,DC=com

HRESULT
StartCsvde(const String& domainDn)
{
   LOG_FUNCTION2(StartCsvde, domainDn);
   ASSERT(!domainDn.empty());

   // REVIEWED-2002/02/27-sburns we're passing full paths
   
   String windir   = Win::GetSystemWindowsDirectory();
   String logPath  = windir + L"\\debug";

   String sys32dir = Win::GetSystemDirectory();
   String csvPath  = sys32dir + L"\\mui\\dispspec\\dcpromo.csv";
   String exePath  = sys32dir + L"\\csvde.exe";

   String commandLine =
      String::format(
         L" -i -f %1 -c DOMAINPLACEHOLDER %2 -j %3",
         csvPath.c_str(),
         domainDn.c_str(),
         logPath.c_str());

   STARTUPINFO startupInfo;

   // REVIEWED-2002/02/27-sburns correct byte count passed
   
   ::ZeroMemory(&startupInfo, sizeof startupInfo);
   
   startupInfo.cb = sizeof(startupInfo);

   PROCESS_INFORMATION procInfo;

   // REVIEWED-2002/02/27-sburns correct byte count passed
   
   ::ZeroMemory(&procInfo, sizeof procInfo);

   LOG(L"Calling CreateProcess");
   LOG(exePath);
   LOG(commandLine);

   HRESULT hr =
      Win::CreateProcess(
         exePath,
         commandLine,
         CREATE_NO_WINDOW,
         String(),
         startupInfo,
         procInfo);
   LOG_HRESULT(hr);

   return hr;
}



HRESULT
DoIt()
{
   LOG_FUNCTION(DoIt);

   HRESULT hr = S_OK;
   do
   {
      AutoCoInitialize coInit;
      hr = coInit.Result();
      BREAK_ON_FAILED_HRESULT2(hr, L"CoInitialize failed");

      // make sure the DS is running.  If it is, then this implies that the
      // local machine is a DC, the local machine is not in safe boot mode,
      // and the local machine is at least version >= 5

      if (!IsDSRunning())
      {
         LOG(L"Active Directory is not running -- unable to proceed");

         hr = E_FAIL;
         break;
      }

      // bind to the RootDse on the local machine

      SmartInterface<IADs> iads(0);
      hr = TemplateGetObject<IADs>(L"LDAP://RootDse", iads);
      BREAK_ON_FAILED_HRESULT2(hr, L"bind to rootdse failed");

      // read the default naming context.  This is the DN of the domain for
      // which the machine is a domain controller.

      _variant_t variant;
      hr = iads->Get(AutoBstr(L"defaultNamingContext"), &variant);
      BREAK_ON_FAILED_HRESULT2(hr, L"bind to default naming context failed");

      String domainDn = V_BSTR(&variant);

      LOG(domainDn);
      ASSERT(!domainDn.empty());

      hr = StartCsvde(domainDn);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



int
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   int exitCode = 0;

   HANDLE mutex = 0;

   // REVIEWED-2002/02/27-sburns This is a global named object, and subject to
   // squatting, but the consquenences of that are administrative annoyance
   // (the admin will have to manually import the display specifiers).
   
   HRESULT hr = Win::CreateMutex(0, true, RUNTIME_NAME, mutex);
   if (hr == Win32ToHresult(ERROR_ALREADY_EXISTS))
   {
      LOG(L"already running.  That's weird.");
      exitCode = 1;
   }
   else
   {
      hr = DoIt();

      if (FAILED(hr))
      {
         LOG(GetErrorMessage(hr));

         exitCode = 2;
      }
   }

   return exitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\accessiblewrapper.cpp ===
//****************************************************************************
//
//  Copyright (c) 2001-2002, Microsoft Corporation
//
//  File:  AccessibleWrapper.cpp
//
//  Copied from nt\shell\themes\themeui\SettingsPg.h
//
//****************************************************************************
#include "stdafx.h"
#include "SchedMat.h"
#include "AccessibleWrapper.h"
#include "SchedBas.h"

// Pointer to IAccessible object must not be NULL.
CAccessibleWrapper::CAccessibleWrapper (HWND hwnd, IAccessible * pAcc)
    : m_ref( 1 ),
      m_pAcc( pAcc ),
      m_hwnd( hwnd )
{
    ASSERT( m_pAcc );
    m_pAcc->AddRef();
}

CAccessibleWrapper::~CAccessibleWrapper()
{
    m_pAcc->Release();
}


// IUnknown
// Implement refcounting ourselves
// Also implement QI ourselves, so that we return a ptr back to the wrapper.
STDMETHODIMP  CAccessibleWrapper::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if ((riid == IID_IUnknown)  ||
        (riid == IID_IDispatch) ||
        (riid == IID_IAccessible))
    {
        *ppv = (IAccessible *) this;
    }
    else
        return(E_NOINTERFACE);

    AddRef();
    return(NOERROR);
}


STDMETHODIMP_(ULONG) CAccessibleWrapper::AddRef()
{
    return ++m_ref;
}


STDMETHODIMP_(ULONG) CAccessibleWrapper::Release()
{
    ULONG ulRet = --m_ref;

    if( ulRet == 0 )
        delete this;

    return ulRet;
}

// IDispatch
// - pass all through m_pAcc

STDMETHODIMP  CAccessibleWrapper::GetTypeInfoCount(UINT* pctinfo)
{
    return m_pAcc->GetTypeInfoCount(pctinfo);
}


STDMETHODIMP  CAccessibleWrapper::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{
    return m_pAcc->GetTypeInfo(itinfo, lcid, pptinfo);
}


STDMETHODIMP  CAccessibleWrapper::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
            LCID lcid, DISPID* rgdispid)
{
    return m_pAcc->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
}

STDMETHODIMP  CAccessibleWrapper::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
            DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
            UINT* puArgErr)
{
    return m_pAcc->Invoke(dispidMember, riid, lcid, wFlags,
            pdispparams, pvarResult, pexcepinfo,
            puArgErr);
}

// IAccessible
// - pass all through m_pAcc

STDMETHODIMP  CAccessibleWrapper::get_accParent(IDispatch ** ppdispParent)
{
    return m_pAcc->get_accParent(ppdispParent);
}


STDMETHODIMP  CAccessibleWrapper::get_accChildCount(long* pChildCount)
{
    return m_pAcc->get_accChildCount(pChildCount);
}


STDMETHODIMP  CAccessibleWrapper::get_accChild(VARIANT varChild, IDispatch ** ppdispChild)
{
    return m_pAcc->get_accChild(varChild, ppdispChild);
}



STDMETHODIMP  CAccessibleWrapper::get_accName(VARIANT varChild, BSTR* pszName)
{
    if ( !pszName )
        return E_POINTER;

    if ( VT_I4 == varChild.vt && CHILDID_SELF == varChild.lVal )
    {
        const size_t  bufLen = 256;
        WCHAR szName[bufLen];

        if ( 0 == SendMessage (m_hwnd, SCHEDMSG_GETSELDESCRIPTION, bufLen,
                (LPARAM) szName) )
        {
            *pszName = SysAllocString (szName);
            if ( *pszName )
                return S_OK;
            else
                return E_OUTOFMEMORY;
        }
        else
            return E_FAIL;
    }
    else
        return m_pAcc->get_accName(varChild, pszName);
}


// NOTICE-2002/02/18-artm  CString methods can throw out of memory exceptions.
// 
// There is not a good way to handle these exceptions at this level.  The caller
// is responsible for handling these exceptions.
STDMETHODIMP  CAccessibleWrapper::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    // varChild.lVal specifies which sub-part of the component
    // is being queried.
    // CHILDID_SELF (0) specifies the overall component - other
    // non-0 values specify a child.
    if ( !pszValue )
        return E_POINTER;

    if( varChild.vt == VT_I4 && varChild.lVal == CHILDID_SELF )
    {
        LRESULT nPercentage = SendMessage (m_hwnd, SCHEDMSG_GETPERCENTAGE, 
                0, 0L);
        CString szValue;

		// FUTURE-2002/02/18-artm  Check return value from LoadString().
		// The code is "okay" as is b/c a failed LoadString() sets the CString
		// to the empty string (if the failure comes from not finding the resource).
		// Therefore, SysAllocString() at the end of the function will return
		// NULL when the resource string cannot be found, and this function
		// will report E_OUTOFMEMORY.
		// 
		// However, this behavior relies heavily on undocumented behavior of CString
		// and is not immediately obvious.  Should be changed in future to check the
		// return values.
        if ( -1 == nPercentage )
        {
            szValue.LoadString (IDS_MATRIX_ACC_VALUE_MULTIPLE_CELLS);
        }
        else
        {
            HWND hwndParent = GetParent (m_hwnd);
            if ( hwndParent )
            {
                LRESULT nIDD = SendMessage (hwndParent, BASEDLGMSG_GETIDD, 0, 0);
                switch ( nIDD )
                {
                case IDD_REPLICATION_SCHEDULE:
                    if ( 0 == nPercentage )
                        szValue.LoadString (IDS_REPLICATION_NOT_AVAILABLE);
                    else
                        szValue.LoadString (IDS_REPLICATION_AVAILABLE);
                    break;

                case IDD_DS_SCHEDULE:
                    switch (nPercentage)
                    {
                    case 0:
                        szValue.LoadString (IDS_DO_NOT_REPLICATE);
                        break;

                    case 25:
                        szValue.LoadString (IDS_REPLICATE_ONCE_PER_HOUR);
                        break;

                    case 50:
                        szValue.LoadString (IDS_REPLICATE_TWICE_PER_HOUR);
                        break;

                    case 100:
                        szValue.LoadString (IDS_REPLICATE_FOUR_TIMES_PER_HOUR);
                        break;

                    default:
                        break;
                    }
                    break;

                case IDD_DIRSYNC_SCHEDULE:
                    if ( 0 == nPercentage )
                        szValue.LoadString (IDS_DONT_SYNCHRONIZE);
                    else
                        szValue.LoadString (IDS_SYNCHRONIZE);
                    break;

                case IDD_DIALIN_HOURS:
                case IDD_LOGON_HOURS:
                    if ( 0 == nPercentage )
                        szValue.LoadString (IDS_LOGON_DENIED);
                    else
                        szValue.LoadString (IDS_LOGON_PERMITTED);
                    break;

                default:
                    break;
                }
            }
        }

        *pszValue = SysAllocString (szValue);
        if ( *pszValue )
            return S_OK;
        else
            return E_OUTOFMEMORY;
    }
    else
    {
        // Pass requests about the sub-components to the
        // 'original' IAccessible for us).
        return m_pAcc->get_accValue(varChild, pszValue);
    }
}


// NOTICE-2002/02/18-artm  CString methods can throw out of memory exceptions.
// 
// There is not a good way to handle these exceptions at this level.  The caller
// is responsible for handling these exceptions.
STDMETHODIMP  CAccessibleWrapper::get_accDescription(VARIANT varChild, BSTR* pbstrDescription)
{
    if ( !pbstrDescription )
        return E_POINTER;

	// NTRAID#NTBUG-547327-2002/02/19-artm   Need to check that have a valid pointer.

    if ( varChild.vt == VT_I4 && varChild.lVal == CHILDID_SELF )
    {
        CString szDescription;
        HWND hwndParent = GetParent (m_hwnd);
        if ( hwndParent )
        {
			// FUTURE-2002/02/18-artm  Check return value from LoadString().
			// The code is "okay" as is b/c a failed LoadString() sets the CString
			// to the empty string (if the failure comes from not finding the resource).
			// Therefore, SysAllocString() at the end of the function will return
			// NULL when the resource string cannot be found, and this function
			// will report E_OUTOFMEMORY.
			// 
			// However, this behavior relies heavily on undocumented behavior of CString
			// and is not immediately obvious.  Should be changed in future to check the
			// return values.
            LRESULT nIDD = SendMessage (hwndParent, BASEDLGMSG_GETIDD, 0, 0);
            switch ( nIDD )
            {
            case IDD_REPLICATION_SCHEDULE:
                szDescription.LoadString (IDS_REPLICATION_SCHEDULE_ACC_DESCRIPTION);
                break;

            case IDD_DS_SCHEDULE:
                szDescription.LoadString (IDS_DS_SCHEDULE_ACC_DESCRIPTION);
                break;

            case IDD_DIRSYNC_SCHEDULE:
                szDescription.LoadString (IDS_DIRSYNC_SCHEDULE_ACC_DESCRIPTION);
                break;

            case IDD_DIALIN_HOURS:
                szDescription.LoadString (IDS_DIALIN_HOURS_ACC_DESCRIPTION);
                break;

            case IDD_LOGON_HOURS:
                szDescription.LoadString (IDS_LOGON_HOURS_ACC_DESCRIPTION);
                break;

            default:
                break;
            }
        }

        *pbstrDescription = SysAllocString (szDescription);
        if ( *pbstrDescription )
            return S_OK;
        else
            return E_OUTOFMEMORY;
    }
    else
    {
        return m_pAcc->get_accDescription(varChild, pbstrDescription);
    }
}


STDMETHODIMP  CAccessibleWrapper::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    if ( !pvarRole )
        return E_POINTER;

    if ( VT_I4 == varChild.vt && CHILDID_SELF == varChild.lVal )
    {
        // reset the out variable
        V_VT(pvarRole) = VT_EMPTY;

        V_VT(pvarRole) = VT_I4;
        V_I4(pvarRole) = ROLE_SYSTEM_TABLE;
        return S_OK;
    }
    else
        return m_pAcc->get_accRole(varChild, pvarRole);
}


STDMETHODIMP  CAccessibleWrapper::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    if ( !pvarState )
        return E_POINTER;

    if ( VT_I4 == varChild.vt && CHILDID_SELF == varChild.lVal )
    {
        // reset the out variable
        V_VT(pvarState) = VT_EMPTY;

        V_VT(pvarState) = VT_I4;
        V_I4(pvarState) = STATE_SYSTEM_FOCUSED | STATE_SYSTEM_FOCUSABLE |
                STATE_SYSTEM_MULTISELECTABLE | STATE_SYSTEM_SELECTABLE |
                STATE_SYSTEM_SELECTED;
        return S_OK;
    }
    else
        return m_pAcc->get_accState(varChild, pvarState);
}


STDMETHODIMP  CAccessibleWrapper::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{
    return m_pAcc->get_accHelp(varChild, pszHelp);
}


STDMETHODIMP  CAccessibleWrapper::get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic)
{
    return m_pAcc->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
}


STDMETHODIMP  CAccessibleWrapper::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut)
{
    return m_pAcc->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
}


STDMETHODIMP  CAccessibleWrapper::get_accFocus(VARIANT * pvarFocusChild)
{
    return m_pAcc->get_accFocus(pvarFocusChild);
}


STDMETHODIMP  CAccessibleWrapper::get_accSelection(VARIANT * pvarSelectedChildren)
{
    return m_pAcc->get_accSelection(pvarSelectedChildren);
}


STDMETHODIMP  CAccessibleWrapper::get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction)
{
    return m_pAcc->get_accDefaultAction(varChild, pszDefaultAction);
}



STDMETHODIMP  CAccessibleWrapper::accSelect(long flagsSel, VARIANT varChild)
{
    return m_pAcc->accSelect(flagsSel, varChild);
}


STDMETHODIMP  CAccessibleWrapper::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    return m_pAcc->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
}


STDMETHODIMP  CAccessibleWrapper::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    return m_pAcc->accNavigate(navDir, varStart, pvarEndUpAt);
}


STDMETHODIMP  CAccessibleWrapper::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    return m_pAcc->accHitTest(xLeft, yTop, pvarChildAtPoint);
}


STDMETHODIMP  CAccessibleWrapper::accDoDefaultAction(VARIANT varChild)
{
    return m_pAcc->accDoDefaultAction(varChild);
}



STDMETHODIMP  CAccessibleWrapper::put_accName(VARIANT varChild, BSTR szName)
{
    return m_pAcc->put_accName(varChild, szName);
}


STDMETHODIMP  CAccessibleWrapper::put_accValue(VARIANT varChild, BSTR pszValue)
{
    return m_pAcc->put_accValue(varChild, pszValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       debug.cpp
//
//  Contents:   Debugging support
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <strsafe.h>

#if DBG == 1
static int indentLevel = 0;

#define DEBUGKEY    L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug\\LogHours"

#define DEBUG_OUTPUT_NONE       0
#define DEBUG_OUTPUT_ERROR      1
#define DEBUG_OUTPUT_WARNING    2
#define DEBUG_OUTPUT_TRACE      3
#define DEBUGLEVEL  L"debugOutput"

static bool             g_fDebugOutputLevelInit = false;
static unsigned long    g_ulDebugOutput = DEBUG_OUTPUT_NONE;

void __cdecl _TRACE (int level, const wchar_t *format, ... )
{
    if ( g_ulDebugOutput > DEBUG_OUTPUT_NONE )
    {
        va_list arglist;
        const size_t DEBUG_BUF_LEN = 512;
        WCHAR Buffer[DEBUG_BUF_LEN];
        Buffer[0] = 0;

        if ( level < 0 )
            indentLevel += level;
        //
        // Format the output into a buffer and then print it.
        //
        wstring strTabs;

        for (int nLevel = 0; nLevel < indentLevel; nLevel++)
            strTabs += L"  ";

        OutputDebugStringW (strTabs.c_str ());

        va_start(arglist, format);

        // Don't check return value - we don't care if this gets truncated as
        // it's just debugging output
        if ( SUCCEEDED (::StringCchVPrintf (Buffer,
                        DEBUG_BUF_LEN,
                        format,
                        arglist)) )
		{
			// ignore
		}
        if ( Buffer[0] )
            OutputDebugStringW (Buffer);

        va_end(arglist);

        if ( level > 0 )
            indentLevel += level;
    }
}



PCSTR
StripDirPrefixA(
    PCSTR pszPathName
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    // NOTICE-2002/02/18-artm  Unchecked pointer acceptable only b/c this is debug build.
    // Paramenter pszPathName can be unchecked here since this code is only included
    // in a debug build.  Otherwise, it would need to be checked for NULL, and the 
    // empty string case would need to be addressed.
    DWORD dwLen = lstrlenA(pszPathName);

    pszPathName += dwLen - 1;       // go to the end

    while (*pszPathName != '\\' && dwLen--)
    {
        pszPathName--;
    }

    return pszPathName + 1;
}

//+----------------------------------------------------------------------------
// Function:    CheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------
void CheckDebugOutputLevel ()
{
    if ( g_fDebugOutputLevelInit ) 
        return;
    g_fDebugOutputLevelInit = true;
    HKEY    hKey = 0;
    DWORD   dwDisposition = 0;

    // NOTICE-2002/02/18-artm  This code only included in debug build.
    // 
    // The NULL security structure is intentional so that the ACL's will be inherited
    // from HKEY_LOCAL_MACHINE.  This restricts access to local administrators.  If
    // this code is later included in a release build, reconsider the requirement of
    // running as local administrator.
    LONG lResult = ::RegCreateKeyEx (HKEY_LOCAL_MACHINE, // handle of an open key
            DEBUGKEY,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_NON_VOLATILE,      // special options flag
            KEY_ALL_ACCESS,    // desired security access
            NULL,     // address of key security structure
            &hKey,      // address of buffer for opened handle
            &dwDisposition);  // address of disposition value buffer

    // If key opened/created successfully, then read the existing debug level.
    if (lResult == ERROR_SUCCESS)
    {
        DWORD   dwSize = sizeof(unsigned long);
        lResult = RegQueryValueExW (hKey, DEBUGLEVEL, NULL, NULL,
                                (LPBYTE)&g_ulDebugOutput, &dwSize);

        if (lResult != ERROR_SUCCESS)
        {
            g_ulDebugOutput = DEBUG_OUTPUT_NONE;

            // If debug not set yet in registry (key created by this function),
            // initialize key value.
            if ( ERROR_FILE_NOT_FOUND == lResult )
            {
                RegSetValueExW (hKey, DEBUGLEVEL, 0, REG_DWORD,
                        (LPBYTE)&g_ulDebugOutput, sizeof (g_ulDebugOutput));
            }
        }
        RegCloseKey(hKey);
    }
}

#endif  // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\log.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       log.cpp
//
//  Contents:   Definition of CLogOnHoursDlg
//      Dialog displaying the weekly logging hours for a particular user.
//
//  HISTORY
//  17-Jul-97   t-danm      Creation.
/////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "resource.h"
#include "Log.h"
#include "resource.h"

#include "log_gmt.h"        // NetpRotateLogonHours ()


#define CB_LOGON_ARRAY_LENGTH   (7 * 24)    // Number of bytes in logon array.

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CLogOnHoursDlg dialog
CLogOnHoursDlg::CLogOnHoursDlg ( UINT nIDTemplate, CWnd* pParentWnd, bool fInputAsGMT, bool bAddDaylightBias) 
        : CScheduleBaseDlg (nIDTemplate, bAddDaylightBias, pParentWnd),
        m_fInputAsGMT (fInputAsGMT)
{
    Init();
}


CLogOnHoursDlg::CLogOnHoursDlg (CWnd* pParent, bool fInputAsGMT) : 
    CScheduleBaseDlg (CLogOnHoursDlg::IDD, false, pParent),
    m_fInputAsGMT (fInputAsGMT)
{
    Init();
}

void CLogOnHoursDlg::Init()
{
    //{{AFX_DATA_INIT (CLogOnHoursDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_prgbData21 = NULL;

}

void CLogOnHoursDlg::DoDataExchange (CDataExchange* pDX)
{
    CScheduleBaseDlg::DoDataExchange (pDX);
    //{{AFX_DATA_MAP(CLogOnHoursDlg)
        DDX_Control ( pDX, IDC_BUTTON_ADD_HOURS, m_buttonAdd );
        DDX_Control ( pDX, IDC_BUTTON_REMOVE_HOURS, m_buttonRemove );
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP (CLogOnHoursDlg, CScheduleBaseDlg)
    //{{AFX_MSG_MAP(CLogOnHoursDlg)
    ON_BN_CLICKED (IDC_BUTTON_ADD_HOURS, OnButtonAddHours)
    ON_BN_CLICKED (IDC_BUTTON_REMOVE_HOURS, OnButtonRemoveHours)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP ()


BOOL CLogOnHoursDlg::OnInitDialog () 
{
    CScheduleBaseDlg::OnInitDialog ();

    // Set up the "on" legend
    m_legendOn.Init ( this, IDC_STATIC_LEGEND_ON, &m_schedulematrix, 100);

    // Set up the "off" legend
    m_legendOff.Init ( this, IDC_STATIC_LEGEND_OFF, &m_schedulematrix, 0);

    if ( GetFlags () & SCHED_FLAG_READ_ONLY )
    {
        // Disable the add and remove buttons
        m_buttonAdd.EnableWindow (FALSE);
        m_buttonRemove.EnableWindow (FALSE);
    }


    return TRUE;
} // CLogOnHoursDlg::OnInitDialog ()

void CLogOnHoursDlg::OnOK () 
{
    if (m_prgbData21 != NULL)
    {
        BYTE rgbDataT[CB_LOGON_ARRAY_LENGTH];
        GetByteArray (OUT rgbDataT, sizeof (rgbDataT));
        ShrinkByteArrayToBitArray (IN rgbDataT, sizeof (rgbDataT), OUT m_prgbData21, CB_SCHEDULE_ARRAY_LENGTH);
        // Convert back the hours to GMT time.
        if ( m_fInputAsGMT )
            ConvertLogonHoursToGMT (INOUT m_prgbData21, m_bAddDaylightBias);
    }
    CScheduleBaseDlg::OnOK ();
}

void CLogOnHoursDlg::UpdateButtons ()
{
    UINT nHour = 0;
    UINT nDay = 0;
    UINT nNumHours = 0;
    UINT nNumDays = 0;

    m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
    bool fAllSet = false;       // fAllSet && fAllClear will be changed to true only if something is selected
    bool fAllClear = false;

    if (nNumHours > 0)
    {
        fAllSet = true;
        fAllClear = true;
        for (UINT iDayOfWeek = nDay; iDayOfWeek < nDay+nNumDays; iDayOfWeek++)
        {
            for (UINT iHour = nHour; iHour < nHour+nNumHours; iHour++)
            {
                if (100 == m_schedulematrix.GetPercentage (iHour, iDayOfWeek))
                {
                    fAllClear = false;
                }
                else
                {
                    fAllSet = false;
                }
            } // for
        } // for
    }

    ASSERT (! (fAllSet && fAllClear));  // these can't both be true!
    m_buttonAdd.SetCheck (fAllSet ? 1 : 0);
    m_buttonRemove.SetCheck (fAllClear ? 1 : 0);
}

void CLogOnHoursDlg::OnButtonAddHours () 
{
    UINT nHour = 0;
    UINT nDay = 0;
    UINT nNumHours = 0;
    UINT nNumDays = 0;

    m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
    if (nNumHours <= 0)
        return; // Nothing selected
    m_schedulematrix.SetPercentage (100, nHour, nDay, nNumHours, nNumDays);
    UpdateButtons ();
}

void CLogOnHoursDlg::OnButtonRemoveHours () 
{
    UINT nHour = 0;
    UINT nDay = 0;
    UINT nNumHours = 0;
    UINT nNumDays = 0;

    m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
    if (nNumHours <= 0)
        return; // Nothing selected
    m_schedulematrix.SetPercentage (0, nHour, nDay, nNumHours, nNumDays);
    UpdateButtons ();
}




/////////////////////////////////////////////////////////////////////
//  SetLogonBitArray ()
//
//  Set the bit array representing the logon hours for a user.
//
//  The parameter rgbData is used as both an input and output parameter.
//
void CLogOnHoursDlg::SetLogonBitArray (INOUT BYTE rgbData[CB_SCHEDULE_ARRAY_LENGTH])
{
    // Catch development errors early.  The code that dereferences m_prgbData21 
    // is robust so the check here is not necessary for release build.
    ASSERT (rgbData);
    m_prgbData21 = rgbData;
} // SetLogonBitArray ()


/////////////////////////////////////////////////////////////////////
//  ShrinkByteArrayToBitArray ()
//
//  Convert an array of bytes into an array of bits.  Each
//  byte will be stored as one bit in the array of bits.
//
//  INTERFACE NOTES
//  The first bit of the array of bits is the boolean
//  value of the first byte of the array of bytes.
//
HRESULT 
ShrinkByteArrayToBitArray (
    const BYTE rgbDataIn[],     // IN: Array of bytes
    int cbDataIn,               // IN: Number of bytes in rgbDataIn
    BYTE rgbDataOut[],          // OUT: Array of bits (stored as an array of bytes)
    int cbDataOut)              // IN: Number of bytes in output buffer
{
    // NOTICE-NTRAID#NTBUG9-547746-2002/03/12-artm  Need to check not NULL in release code.
    // Both rbgDataIn and rgbDataOut need to be checked for NULL before using.
    // In array must be 8 times the size of out array
    ASSERT (cbDataIn == cbDataOut*8);
    if ( cbDataIn != cbDataOut*8 )
        return E_INVALIDARG;

    ASSERT (rgbDataIn);
    ASSERT (rgbDataOut);
    if ( !rgbDataIn || !rgbDataOut )
        return E_POINTER;

    // NOTICE-NTRAID#NTBUG9-547718  Size of rgbDataOut verified above.
    //
    // Use cbDataOut to check that rgbDataOut is CB_SCHEDULE_ARRAY_LENGTH in size.  If not
    // use a return value to indicate failure.
    const BYTE * pbSrc = rgbDataIn;
    BYTE * pbDst = rgbDataOut;
    while (cbDataIn > 0 && cbDataOut > 0)
    {
        BYTE b = 0;
        for (int i = 8; i > 0; i--)
        {
            // NOTICE-NTRAID#NTBUG-547746-2002/02/18-artm   Assert should be supplemented with release code.
            //
            // The logic in this assert is part of the algorithm, and should be in
            // the release code as part of the for loop's conditional check.  
            // We are guaranteed to never get here as long as the check above for
            // "cbDataIn != cbDataOut*8" is in the code.  Thus, the below ASSERT() should
            // never fire.
            ASSERT (cbDataIn > 0);
            cbDataIn--;
            b >>= 1;

            if ( *pbSrc )
                b |= 0x80;      // bit 0 is on the right, as in: 7 6 5 4 3 2 1 0
            pbSrc++;
        }
        *pbDst++ = b;
        cbDataOut--;
    } // while

    return S_OK;
} // ShrinkByteArrayToBitArray ()


/////////////////////////////////////////////////////////////////////
HRESULT
ExpandBitArrayToByteArray (
    const BYTE rgbDataIn[],     // IN: Array of bits (stored as an array of bytes)
    int cbDataIn,               // IN: Number of bytes in rgbDataIn
    BYTE rgbDataOut[],          // OUT: Array of bytes
    int cbDataOut)              // IN: Number of bytes in output buffer
{
    // NOTICE-NTRAID#NTBUG9-547746-2002/03/12-artm  Need to check not NULL in release code.
    // Both rbgDataIn and rgbDataOut need to be checked for NULL before using.
    // Out array must be 8 times the size of in array
    ASSERT (cbDataOut == cbDataIn*8);
    if ( cbDataOut != cbDataIn*8 )
        return E_INVALIDARG;
    ASSERT (rgbDataIn);
    ASSERT (rgbDataOut);
    if ( !rgbDataIn || !rgbDataOut )
        return E_POINTER;

    // NOTICE-NTRAID#NTBUG9-547718  Size of rgbDataOut verified.
    //
    // Use cbDataOut to check that rgbDataOut is large enough.


    const BYTE * pbSrc = rgbDataIn;
    BYTE * pbDst = rgbDataOut;
    while (cbDataIn > 0)
    {
        // NOTICE-NTRAID#NTBUG-547746-2002/02/18-artm   Assert should be supplemented with release code.
        //
        // The logic in this assert is part of the algorithm, and should be in
        // the release code as part of the for loop's conditional check.  

        ASSERT (cbDataIn > 0);
        cbDataIn--;
        BYTE b = *pbSrc;
        pbSrc++;
        for (int i = 8; i > 0 && cbDataOut > 0; i--, cbDataOut--)
        {
            *pbDst = (BYTE) ((b & 0x01) ? 1 : 0);   // bit 0 is on the right of each bit
            pbDst++;
            b >>= 1;
        }
    } // while

    return S_OK;
} // ExpandBitArrayToByteArray ()


/////////////////////////////////////////////////////////////////////
//  Converts the logon hours from local time to GMT.
void 
ConvertLogonHoursToGMT (
    INOUT BYTE rgbData[CB_SCHEDULE_ARRAY_LENGTH], 
    IN bool bAddDaylightBias)
{
    VERIFY ( ::NetpRotateLogonHours (rgbData, CB_SCHEDULE_ARRAY_LENGTH * 8, TRUE, bAddDaylightBias) );
}

/////////////////////////////////////////////////////////////////////
//  Converts the logon hours from GMT to local time.
void
ConvertLogonHoursFromGMT (
    INOUT BYTE rgbData[CB_SCHEDULE_ARRAY_LENGTH], 
    IN bool bAddDaylightBias)
{
    VERIFY ( ::NetpRotateLogonHours (rgbData, CB_SCHEDULE_ARRAY_LENGTH * 8, FALSE, bAddDaylightBias) );
}




/////////////////////////////////////////////////////////////////////
//  LogonScheduleDialog ()
//
//  Invoke a dialog to set/modify a schedule, for example
//      -- the logon hours for a particular user
//      -- the schedule for a connection
//
//  RETURNS
//  Return S_OK if the user clicked on the OK button.
//  Return S_FALSE if the user clicked on the Cancel button.
//  Return E_OUTOFMEMORY if there is not enough memory.
/// Return E_UNEXPECTED if an expected error occured (eg: bad parameter)
//
//  INTERFACE NOTES
//  Each bit in the array represents one hour.  As a result, the
//  expected length of the array should be (24 / 8) * 7 = 21 bytes.
//  For convenience, the first day of the week is Sunday and
//  the last day is Saturday.
//  Consequently, the first bit of the array represents the schedule
//  for Sunday during period 12 AM to 1 AM.
//  - If *pprgbData is NULL, then the routine will allocate
//    an array of 21 bytes using LocalAlloc ().  The caller
//    is responsible of releasing the memory using LocalFree ().
//  - If *pprgbData is not NULL, the routine re-use the array as its
//    output parameter.
//
//  HISTORY
//  17-Jul-97   t-danm      Creation.
//  16-Sep-97   jonn        Changed to UiScheduleDialog
//

HRESULT
LogonScheduleDialog(
    HWND hwndParent,        // IN: Parent's window handle
    BYTE ** pprgbData,      // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
    LPCTSTR pszTitle)       // IN: Dialog title
{
    return LogonScheduleDialogEx (hwndParent, pprgbData, pszTitle, SCHED_FLAG_INPUT_GMT);
}

HRESULT
LogonScheduleDialogEx(
    HWND hwndParent,        // IN: Parent's window handle
    BYTE ** pprgbData,      // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
    LPCTSTR pszTitle,       // IN: Dialog title
    DWORD  dwFlags)     
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // All of these asserts are backed up by validation checks. 
    ASSERT(::IsWindow(hwndParent));
    ASSERT(pprgbData != NULL);
    // NOTICE-NTRAID#NTBUG9-547381-2002/02/18-artm  pszTitle okay to be NULL
    // dlg.SetTitle() robustly handles NULL case
    ASSERT(pszTitle != NULL);
    ENDORSE(*pprgbData == NULL);    // TRUE => Use default logon hours (7x24)

    if (*pprgbData == NULL)
    {
        BYTE * pargbData;   // Pointer to allocated array of bytes
        pargbData = (BYTE *)LocalAlloc(0, CB_SCHEDULE_ARRAY_LENGTH);    // Allocate 21 bytes
        if (pargbData == NULL)
            return E_OUTOFMEMORY;
        // Set the logon hours to be valid 24 hours a day and 7 days a week.
        memset(OUT pargbData, -1, CB_SCHEDULE_ARRAY_LENGTH);
        *pprgbData = pargbData;
    }

    // If hwndParent passed in, create a CWnd to pass as the parent window
    CWnd* pWnd = 0;
    if ( ::IsWindow (hwndParent) )
    {
        pWnd = new CWnd;
        if ( pWnd )
        {
            pWnd->Attach (hwndParent);
        }
        else
            return E_OUTOFMEMORY;
    }
    HRESULT hr = S_OK;
    bool    fInputAsGMT = true;

    if ( dwFlags & SCHED_FLAG_INPUT_LOCAL_TIME )
        fInputAsGMT = false;
    CLogOnHoursDlg dlg (pWnd, fInputAsGMT);
    dlg.SetTitle (pszTitle);
    dlg.SetLogonBitArray(INOUT *pprgbData);
    dlg.SetFlags (dwFlags);
    if (IDOK != dlg.DoModal())
        hr = S_FALSE;

    if ( pWnd )
    {
        pWnd->Detach ();
        delete pWnd;
    }

    return hr;
} // LogonScheduleDialog()

HRESULT
DialinHoursDialog (
    HWND hwndParent,        // IN: Parent's window handle
    BYTE ** pprgbData,      // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
    LPCTSTR pszTitle)       // IN: Dialog title
{
    return DialinHoursDialogEx (hwndParent, pprgbData, pszTitle, SCHED_FLAG_INPUT_GMT);
}

HRESULT
DialinHoursDialogEx (
    HWND hwndParent,        // IN: Parent's window handle
    BYTE ** pprgbData,      // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
    LPCTSTR pszTitle,       // IN: Dialog title
    DWORD  dwFlags) 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    // These asserts are backed up by validation in release code.
    ASSERT(::IsWindow(hwndParent));
    ASSERT(pprgbData != NULL);
    // NOTICE-NTRAID#NTBUG9-547381-2002/02/18-artm  pszTitle okay to be NULL
    // dlg.SetTitle() robustly handles NULL.
    ASSERT(pszTitle != NULL);
    ENDORSE(*pprgbData == NULL);    // TRUE => Use default logon hours (7x24)

    if (*pprgbData == NULL)
    {
        BYTE * pargbData;   // Pointer to allocated array of bytes
        pargbData = (BYTE *)LocalAlloc(0, CB_SCHEDULE_ARRAY_LENGTH);    // Allocate 21 bytes
        if (pargbData == NULL)
            return E_OUTOFMEMORY;
        // Set the logon hours to be valid 24 hours a day and 7 days a week.
        memset(OUT pargbData, -1, CB_SCHEDULE_ARRAY_LENGTH);
        *pprgbData = pargbData;
    }

    // If hwndParent passed in, create a CWnd to pass as the parent window
    CWnd* pWnd = 0;
    if ( ::IsWindow (hwndParent) )
    {
        pWnd = new CWnd;
        if ( pWnd )
        {
            pWnd->Attach (hwndParent);
        }
        else
            return E_OUTOFMEMORY;
    }

    HRESULT hr = S_OK;
    bool    fInputAsGMT = true;

    if ( dwFlags & SCHED_FLAG_INPUT_LOCAL_TIME )
        fInputAsGMT = false;
    CDialinHours dlg (pWnd, fInputAsGMT);
    dlg.SetTitle (pszTitle);
    dlg.SetLogonBitArray(INOUT *pprgbData);
    dlg.SetFlags (dwFlags);
    if (IDOK != dlg.DoModal())
        hr = S_FALSE;

    if ( pWnd )
    {
        pWnd->Detach ();
        delete pWnd;
    }

    return hr;
} // DialinHoursDialog()

void CLogOnHoursDlg::InitMatrix()
{
    if ( m_prgbData21 )
    {
        BYTE rgbitData[CB_SCHEDULE_ARRAY_LENGTH];       // Array of logonhours bits
        // Make a copy of the logon hours (in case the user click on cancel button)
        memcpy (OUT rgbitData, IN m_prgbData21, sizeof (rgbitData));
        // Convert the hours from GMT to local hours.
        if ( m_fInputAsGMT )
            ConvertLogonHoursFromGMT (INOUT rgbitData, m_bAddDaylightBias);
        BYTE rgbDataT[CB_LOGON_ARRAY_LENGTH];
        if ( SUCCEEDED (ExpandBitArrayToByteArray (IN rgbitData, 
                CB_SCHEDULE_ARRAY_LENGTH, OUT rgbDataT, sizeof (rgbDataT))) )
        {
            m_cbArray = sizeof (rgbDataT);
        }
        // Initialize the matrix
        InitMatrix2 (IN rgbDataT);
    }
}

UINT CLogOnHoursDlg::GetPercentageToSet(const BYTE bData)
{
    ASSERT (TRUE == bData || FALSE == bData);
    return (TRUE == bData) ? 100 : 0;
}

BYTE CLogOnHoursDlg::GetMatrixPercentage(UINT nHour, UINT nDay)
{
    return (BYTE) ((100 == m_schedulematrix.GetPercentage (nHour, nDay)) ?
                    TRUE : FALSE);
}

UINT CLogOnHoursDlg::GetExpectedArrayLength()
{
    return CB_LOGON_ARRAY_LENGTH;
}

// Called when WM_TIMECHANGE is received
void CLogOnHoursDlg::TimeChange()
{
    m_buttonAdd.EnableWindow (FALSE);
    m_buttonRemove.EnableWindow (FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CDialinHours dialog


CDialinHours::CDialinHours(CWnd* pParent, bool fInputAsGMT)
    : CLogOnHoursDlg(CDialinHours::IDD, pParent, fInputAsGMT, false)
{
    //{{AFX_DATA_INIT(CDialinHours)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

BEGIN_MESSAGE_MAP(CDialinHours, CLogOnHoursDlg)
    //{{AFX_MSG_MAP(CDialinHours)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDialinHours message handlers


/////////////////////////////////////////////////////////////////////////////
// CDirSyncScheduleDlg dialog

CDirSyncScheduleDlg::CDirSyncScheduleDlg(CWnd* pParent /*=NULL*/)
    : CLogOnHoursDlg(CDirSyncScheduleDlg::IDD, pParent, true, false)
{
    //{{AFX_DATA_INIT(CDirSyncScheduleDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void CDirSyncScheduleDlg::DoDataExchange(CDataExchange* pDX)
{
    CLogOnHoursDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDirSyncScheduleDlg)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDirSyncScheduleDlg, CLogOnHoursDlg)
    //{{AFX_MSG_MAP(CDirSyncScheduleDlg)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CDirSyncScheduleDlg::OnInitDialog() 
{
    CLogOnHoursDlg::OnInitDialog();

    m_schedulematrix.SetSel (0, 0, 1, 1);

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDirSyncScheduleDlg message handlers
//
//  The data is passed in in GMT
//

HRESULT
DirSyncScheduleDialog(
    HWND hwndParent,        // IN: Parent's window handle
    BYTE ** pprgbData,      // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
    LPCTSTR pszTitle)       // IN: Dialog title
{
    return DirSyncScheduleDialogEx (hwndParent, pprgbData, pszTitle, 0);
} // DirSyncScheduleDialog()

HRESULT
DirSyncScheduleDialogEx(
    HWND hwndParent,        // IN: Parent's window handle
    BYTE ** pprgbData,      // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
    LPCTSTR pszTitle,       // IN: Dialog title
    DWORD   dwFlags)        // IN: Option flags
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    // These asserts are backed up by validation code in release.
    ASSERT(::IsWindow(hwndParent));
    ASSERT(pprgbData != NULL);
    // NOTICE-NTRAID#NTBUG9-547381-2002/02/18-artm  pszTitle okay to be NULL
    // dlg.SetTitle() robustly handles NULL.
    ASSERT(pszTitle != NULL);
    ENDORSE(*pprgbData == NULL);    // TRUE => Use default logon hours (7x24)

    if (*pprgbData == NULL)
    {
        BYTE * pargbData;   // Pointer to allocated array of bytes
        pargbData = (BYTE *)LocalAlloc(0, CB_SCHEDULE_ARRAY_LENGTH);    // Allocate 21 bytes
        if (pargbData == NULL)
            return E_OUTOFMEMORY;
        // Set the logon hours to be valid 24 hours a day and 7 days a week.
        memset(OUT pargbData, -1, CB_SCHEDULE_ARRAY_LENGTH);
        *pprgbData = pargbData;
    }

    // If hwndParent passed in, create a CWnd to pass as the parent window
    CWnd* pWnd = 0;
    if ( ::IsWindow (hwndParent) )
    {
        pWnd = new CWnd;
        if ( pWnd )
        {
            pWnd->Attach (hwndParent);
        }
        else
            return E_OUTOFMEMORY;
    }

    HRESULT             hr = S_OK;
    CDirSyncScheduleDlg dlg (pWnd);
    dlg.SetTitle (pszTitle);
    dlg.SetLogonBitArray(INOUT *pprgbData);
    dlg.SetFlags (dwFlags);
    if (IDOK != dlg.DoModal())
        hr = S_FALSE;

    if ( pWnd )
    {
        pWnd->Detach ();
        delete pWnd;
    }

    return hr;
} // DirSyncScheduleDialogEx()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       debug.h
//
//  Contents:   Debugging macros and prototypes
//
//----------------------------------------------------------------------------


#ifndef _DEBUG_H_
#define _DEBUG_H_


#if DBG == 1


void __cdecl _TRACE (int level, const wchar_t *format, ... );


//
// External functions
//

PCSTR StripDirPrefixA(PCSTR);



//
// These macros are used for asserting certain conditions. They are
// independent of the debugging level.
// These also require additional paranthesis to enclose the msg as
// shown below.
//

#ifdef _ASSERT
#undef _ASSERT
#undef _ASSERTMSG
#endif

#define _ASSERT(expr)                                                    \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
               _TRACE (0, L"Cert Template Snapin(Thread ID: %d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DebugBreak();                                           \
            }                                                           \
        }


#define _ASSERTMSG(expr, msg)                                            \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
                _TRACE (0, L"Cert Template Snapin(%d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                _TRACE (0, msg);                                           \
                _TRACE (0, "\n");                                         \
                DebugBreak();                                           \
            }                                                           \
        }

    void CheckDebugOutputLevel ();

#else // !DBG


#define _TRACE 
#define _ASSERTMSG(expr, msg)

#endif



#endif  // ifndef _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\log.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       log.h
//
//  Contents:   Definition of CLogOnHoursDlg
//
//----------------------------------------------------------------------------

#if !defined(AFX_LOGHOURS_H__0F68A435_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_)
#define AFX_LOGHOURS_H__0F68A435_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "SchedBas.h"

#ifndef INOUT
	#define INOUT
	#define ENDORSE(f)	// Macro which is the opposite of ASSERT()
#endif

/////////////////////////////////////////////////////////////////////////////
//
//	Exported Functions
//
#include "loghrapi.h"

/////////////////////////////////////////////////////////////////////////////
//
//	Private Functions
//

/////////////////////////////////////////////////////////////////////////////
HRESULT ShrinkByteArrayToBitArray(const BYTE rgbDataIn[], int cbDataIn, BYTE rgbDataOut[], int cbDataOut);
HRESULT ExpandBitArrayToByteArray(const BYTE rgbDataIn[], int cbDataIn, BYTE rgbDataOut[], int cbDataOut);


void ConvertLogonHoursToGMT(INOUT BYTE rgbData[21], IN bool bAddDaylightBias);
void ConvertLogonHoursFromGMT(INOUT BYTE rgbData[21], IN bool bAddDaylightBias);


/////////////////////////////////////////////////////////////////////////////
// CLogOnHoursDlg dialog
class CLogOnHoursDlg : public CScheduleBaseDlg
{
protected:
	CLogOnHoursDlg( UINT nIDTemplate, CWnd* pParentWnd, bool fInputAsGMT, bool bAddDaylightBias);

	void Init();

public:
	CLogOnHoursDlg(CWnd* pParent, bool fInputAsGMT);   // standard constructor

    virtual int GetIDD ()
    {
        return IDD;
    }

// Dialog Data
	//{{AFX_DATA(CLogOnHoursDlg)
	enum { IDD = IDD_LOGON_HOURS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLogOnHoursDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	// Generated message map functions
	//{{AFX_MSG(CLogOnHoursDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnButtonAddHours();
	afx_msg void OnButtonRemoveHours();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	CLegendCell m_legendOn;
	CLegendCell m_legendOff;
	CButton m_buttonAdd;
	CButton m_buttonRemove;
	BYTE * m_prgbData21;					// Pointer to an array of 21 bytes
public:	

protected:
	virtual void TimeChange();
	virtual UINT GetExpectedArrayLength();
	virtual BYTE GetMatrixPercentage (UINT nHour, UINT nDay);
	virtual UINT GetPercentageToSet (const BYTE bData);
	virtual void InitMatrix ();
	virtual void UpdateButtons();

public:
	void SetLogonBitArray(INOUT BYTE rgbData[21]);

private:
	const bool m_fInputAsGMT;
}; // CLogOnHoursDlg

/////////////////////////////////////////////////////////////////////////////
// CDialinHours dialog

class CDialinHours : public CLogOnHoursDlg
{
// Construction
public:
	CDialinHours(CWnd* pParent, bool fInputAsGMT);   // standard constructor

    virtual int GetIDD ()
    {
        return IDD;
    }

// Dialog Data
	//{{AFX_DATA(CDialinHours)
	enum { IDD = IDD_DIALIN_HOURS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDialinHours)
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDialinHours)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CDirSyncScheduleDlg dialog

class CDirSyncScheduleDlg : public CLogOnHoursDlg
{
// Construction
public:
	CDirSyncScheduleDlg(CWnd* pParent = NULL);   // standard constructor

    virtual int GetIDD ()
    {
        return IDD;
    }

// Dialog Data
	//{{AFX_DATA(CDirSyncScheduleDlg)
	enum { IDD = IDD_DIRSYNC_SCHEDULE };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDirSyncScheduleDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDirSyncScheduleDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


#endif // !defined(AFX_LOGHOURS_H__0F68A435_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\loghours.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       Loghours.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// LogHours.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include <locale.h>
#include "LogHours.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the 
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//

/////////////////////////////////////////////////////////////////////////////
// CLogHoursApp

BEGIN_MESSAGE_MAP(CLogHoursApp, CWinApp)
	//{{AFX_MSG_MAP(CLogHoursApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLogHoursApp construction

CLogHoursApp::CLogHoursApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

BOOL CLogHoursApp::InitInstance ()
{
	_wsetlocale (LC_ALL, L"");
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CLogHoursApp object

CLogHoursApp theApp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\loghours.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       LogHours.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
// LogHours.h : main header file for the LOGHOURS DLL
//

#if !defined(AFX_LOGHOURS_H__0F68A43B_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_)
#define AFX_LOGHOURS_H__0F68A43B_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CLogHoursApp
// See LogHours.cpp for the implementation of this class
//

class CLogHoursApp : public CWinApp
{
public:
	CLogHoursApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLogHoursApp)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CLogHoursApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	virtual BOOL InitInstance ();
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOGHOURS_H__0F68A43B_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\loghrapi.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       LogHrAPI.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
// loghours.h : header file

#if !defined(_LOGHOURS_H_)
#define _LOGHOURS_H_

#define CB_SCHEDULE_ARRAY_LENGTH	21		// Number of bytes in the schedule array.
#define cbDsScheduleArrayLength     84      // Number of bytes in the schedule array

/////////////////////////////////////////////////////////////////////////////
//
//	Exported Functions
//

//	UiScheduleDialog()
//
//	Invoke a dialog to set/modify a schedule, for example
//      -- the logon hours for a particular user
//      -- the schedule for a connection
//
//	RETURNS
//	Return S_OK if the user clicked on the OK button.
//	Return S_FALSE if the user clicked on the Cancel button.
//	Return E_OUTOFMEMORY if there is not enough memory.
///	Return E_UNEXPECTED if an expected error occured (eg: bad parameter)
//
//	INTERFACE NOTES
//	Each bit in the array represents one hour.  As a result, the
//	expected length of the array should be (24 / 8) * 7 = 21 bytes.
//	For convenience, the first day of the week is Sunday and
//	the last day is Saturday.
//	Consequently, the first bit of the array represents the schedule
//	for Sunday during period 12 AM to 1 AM.
//	- If *pprgbData is NULL, then the routine will allocate
//	  an array of 21 bytes using LocalAlloc().  The caller
//	  is responsible of releasing the memory using LocalFree().
//  - If *pprgbData is not NULL, the routine expect the array to contain
//	  21 bytes of data and re-uses the array as its output parameter.
//
//	HISTORY
//	17-Jul-97	t-danm		Creation.
//	16-Sep-97	jonn		Changed to UiScheduleDialog
//  26-Mar-98   bryanwal	Changed to ConnectionScheduleDialog
//

///////////////////////////////////////////////////////////////////////////////
// Flags for LogonScheduleDialogEx, DialinHoursDialogEx, 
//      ConnectionScheduleDialogEx, ReplicationScheduleDialogEx
///////////////////////////////////////////////////////////////////////////////
// The input data is in GMT
#define SCHED_FLAG_INPUT_GMT        0x00000000  // default

// The input data is in local time.
#define SCHED_FLAG_INPUT_LOCAL_TIME	0x00000001  // supported only in 
                                                // LogonScheduleDialogEx and 
                                                // DialinHoursDialogEx

#define SCHED_FLAG_READ_ONLY        0x00000002  // the dialog is read-only


// This version accepts data only in GMT
HRESULT LogonScheduleDialog(HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 21 bytes
                         LPCTSTR pszTitle);     // dialog title

// This version allows the caller to specify if the data is in GMT or local time
HRESULT LogonScheduleDialogEx (HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 21 bytes
                         LPCTSTR pszTitle,     // dialog title
                         DWORD  dwFlags);    


//  13-May-98   weijiang   
// clone of LogScheduleDialog, using different dialog template -- IDD_DIALINHOUR
// to set hours for dialin

// This version accepts data only in GMT
HRESULT DialinHoursDialog(HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 21 bytes
                         LPCTSTR pszTitle);     // dialog title
 
// This version allows the caller to specify if the data is in GMT or local time
HRESULT DialinHoursDialogEx (HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 21 bytes
                         LPCTSTR pszTitle,     // dialog title
                         DWORD  dwFlags);    

//	ConnectionScheduleDialog()
//
//	This function takes the same form as LogonScheduleDialog(), but it modifies
//	the schedule for DS replication.  This schedule has 4 bits per hours,
//	one for each 15-minute period, so the array contains 84 bytes instead of 21.
//
//  NOTE:  ConnectionScheduleDialog takes the schedule in GMT
//
//	HISTORY
//	02-Jan-98	jonn		Creation.
//  26-Mar-98   bryanwal	Changed to ConnectionScheduleDialog
//
HRESULT ConnectionScheduleDialog(HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 84 bytes
                         LPCTSTR pszTitle);     // dialog title

HRESULT ConnectionScheduleDialogEx(HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 84 bytes
                         LPCTSTR pszTitle,     // dialog title
                         DWORD   dwFlags);

// Same as ConnectionScheduleDialog, but 2 states are shown
HRESULT ReplicationScheduleDialog(HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 84 bytes
                         LPCTSTR pszTitle);     // dialog title

HRESULT ReplicationScheduleDialogEx(HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 84 bytes
                         LPCTSTR pszTitle,     // dialog title
                         DWORD   dwFlags);      // option flags

//	DirSyncScheduleDialog()
//
//	This function takes the same form as LogonScheduleDialog(), but it modifies
//	the schedule for Directory Synchronization.
//
//	HISTORY
//  11-Sep-98   bryanwal	Added DirSyncScheduleDialog
//
HRESULT DirSyncScheduleDialog(HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 84 bytes
                         LPCTSTR pszTitle);     // dialog title

HRESULT DirSyncScheduleDialogEx(HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 84 bytes
                         LPCTSTR pszTitle,     // dialog title
                         DWORD   dwFlags);      // option flags
#endif // !defined(_LOGHOURS_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\log_gmt.h ===
/*++

Copyright (c) 1987-2001  Microsoft Corporation

Module Name:

    log_gmt.h (originally named loghours.h)

Abstract:

    Private routines to support rotation of logon hours between local time
    and GMT time.

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:
	16-Mar-93		cliffv		Creation.
	22-Jul-97		t-danm		Copied from /nt/private/nw/convert/nwconv/loghours.c.

--*/



//
// Procedure forwards from loghours.c
//

BOOLEAN NetpRotateLogonHoursPhase1(
    IN BOOL		ConvertToGmt,
	IN bool		bAddDaylightBias,
    OUT PULONG	RotateCount);

BOOLEAN NetpRotateLogonHoursPhase2(
    IN PBYTE LogonHours,
    IN DWORD UnitsPerWeek,
    IN LONG  RotateCount);

BOOLEAN NetpRotateLogonHours(
    IN OUT PBYTE	rgbLogonHours,
    IN DWORD		cbitUnitsPerWeek,
    IN BOOL			fConvertToGmt,
	IN bool			bAddDaylightBias);

BOOLEAN NetpRotateLogonHoursBYTE(
    IN OUT PBYTE	rgbLogonHours,
    IN DWORD		cbitUnitsPerWeek,
    IN BOOL			fConvertToGmt,
	IN bool			bAddDaylightBias);

int GetFirstDayOfWeek ();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\log_gmt.cpp ===
/*++

Copyright (c) 1987-2002  Microsoft Corporation

Module Name:

    log_gmt.cpp (originally named loghours.c)

Abstract:

    Private routines to support rotation of logon hours between local time
    and GMT time.

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:
	16-Mar-93		cliffv		Creation.
	22-Jul-97		t-danm		Copied from /nt/private/nw/convert/nwconv/loghours.c
								and adapted to loghours.dll.

--*/

#include "stdafx.h"

#pragma warning (disable : 4514)
#pragma warning (push,3)

#include <limits.h>
#include <math.h>

#include <lmcons.h>
#include <lmaccess.h>
#pragma warning (pop)

#include "log_gmt.h"

#include "debug.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//#pragma hdrstop

/*++
Routine NetpRotateLogonHoursPhase1()

    Determine the amount to rotate the logon hours by to convert to/from GMT

Arguments:

    bConvertToGmt -
        True to convert the logon hours from local time to GMT relative
        False to convert the logon hours from GMT relative to local time

    pRotateCount - Returns the number of bits to shift by.
				Must be non NULL pointer.

Return Value:

    TRUE if the pRotateCount could be computed
    FALSE if a pRotateCount could not be computed

--*/
BOOLEAN
NetpRotateLogonHoursPhase1(
    IN BOOL		bConvertToGmt,
	IN bool		bAddDaylightBias,
    OUT PLONG	pRotateCount)
{
    if ( !pRotateCount )
        return FALSE;

    _TRACE (1, L"Entering NetpRotateLogonHoursPhase1\n");
    TIME_ZONE_INFORMATION	tzi;
    LONG					lBiasInHours = 0;
	LONG					lDSTBias = 0;
    const LONG              HOURS_IN_DAY = 24;

    //
    // Get the timezone data from the registry
    //

    DWORD	dwResult = GetTimeZoneInformation( &tzi );
    if ( TIME_ZONE_ID_INVALID == dwResult ) 
	{
		return FALSE;
    }

    //
    // Compute the amount to rotate the logon hours by
    //
    // Round the bias in minutes to the closest bias in hours.
    // Take into consideration that Bias can be negative.
    // Do this by forcing the Bias to be positive, rounding,
    // then adjusting it back negative again.
    //

	if ( bAddDaylightBias )
	{
		switch (dwResult)
		{
		case TIME_ZONE_ID_DAYLIGHT:
			lDSTBias = tzi.DaylightBias;
			break;

		case TIME_ZONE_ID_UNKNOWN:
		case TIME_ZONE_ID_STANDARD:
			lDSTBias = tzi.StandardBias;
			break;

		default:
			return FALSE;
		}
	}

	ASSERT( tzi.Bias > -(HOURS_IN_DAY*60) );
    lBiasInHours = ((tzi.Bias + lDSTBias + (HOURS_IN_DAY*60) + 30)/60) - HOURS_IN_DAY;


    if ( !bConvertToGmt ) 
	{
        lBiasInHours = - lBiasInHours;
    }

    /// TODO: Account for user changing the locale while the schedule grid is open
    // Adjust for first day of week, if nFirstDay == 6, then no adjustment is required
    // because the vector passed in starts on Sunday
    int nFirstDay = GetFirstDayOfWeek ();
    LONG lFirstDayShiftInHours = (bConvertToGmt ? 1 : -1);
    switch (nFirstDay)
    {
    case 0:
        lFirstDayShiftInHours *= 1 * HOURS_IN_DAY;
        break;

    case 1:
        lFirstDayShiftInHours *= 2 * HOURS_IN_DAY;
        break;

    case 2:
        lFirstDayShiftInHours *= 3 * HOURS_IN_DAY;
        break;

    case 3:
        lFirstDayShiftInHours *= 4 * HOURS_IN_DAY;
        break;

    case 4:
        lFirstDayShiftInHours *= 5 * HOURS_IN_DAY;
        break;

    case 5:
        lFirstDayShiftInHours *= 6 * HOURS_IN_DAY;
        break;

    case 6:
        lFirstDayShiftInHours *= 0 * HOURS_IN_DAY;
        break;

    default:
        ASSERT (0);
        break;
    }
    lBiasInHours += lFirstDayShiftInHours;

	// NOTICE-NTRAID#NTBUG9-547513-2002/02/19-artm  pRotateCount != NULL validated
	// Check was added at beginning of function.
    *pRotateCount = lBiasInHours;
    _TRACE (-1, L"Leaving NetpRotateLogonHoursPhase1\n");
    return TRUE;
} // NetpRotateLogonHoursPhase1()



/*++ 
Routine NetpRotateLogonHoursPhase2()

    Rotate the pLogonHours bit mask by the required amount.


Arguments:

    pLogonHours - Pointer to LogonHour bit mask

    dwUnitsPerWeek - Number of bits in the bit mask. Must be UNITS_PER_WEEK (168).

    lRotateCount - Number of bits to rotate by.  
        Negative means to rotate left.
        Positive means to rotate right.

Return Value:

    TRUE if the rotation succeeded.
    FALSE if a parameter was out of range

--*/
BOOLEAN
NetpRotateLogonHoursPhase2(
    IN PBYTE pLogonHours,
    IN DWORD dwUnitsPerWeek,
    IN LONG  lRotateCount)
{
    if ( !pLogonHours )
        return FALSE;

    _TRACE (1, L"Entering NetpRotateLogonHoursPhase2\n");
    //
    // Useful constants
    //
	const int BYTES_PER_WEEK = (UNITS_PER_WEEK/8);

    BYTE	byAlignedLogonHours[BYTES_PER_WEEK*2];
	::ZeroMemory (byAlignedLogonHours, BYTES_PER_WEEK*2);
    LONG	i = 0;

    BOOLEAN bRotateLeft = FALSE;

    //
    // Ensure there are 8 bits per byte,
    //  32 bits per DWORD and
    //  units per week is even number of bytes.
    //

#pragma warning(disable : 4127)
    ASSERT( CHAR_BIT == 8 );
    ASSERT( sizeof(DWORD) * CHAR_BIT == 32 );
    ASSERT( UNITS_PER_WEEK/8*8 == UNITS_PER_WEEK );
#pragma warning (default : 4127)


    //
    // Validate the input parameters
    //

    if ( dwUnitsPerWeek != UNITS_PER_WEEK ) 
	{
#pragma warning(disable : 4127)
        ASSERT( dwUnitsPerWeek == UNITS_PER_WEEK );
#pragma warning (default : 4127)
        return FALSE;
    }

    if ( lRotateCount == 0 ) 
	{
        return TRUE;
    }

	// NOTICE-NTRAID#NTBUG9-547513-2002/02/19-artm  pLogonHours != NULL was checked
	// Check was added to the beginning of the function.

    bRotateLeft = (lRotateCount < 0);
    lRotateCount = labs( lRotateCount );



	// New algorithm:  get numBytes by dividing lRotateCount/32.  Shift entire array 
	//	left or right by numBytes and then do the loop below for the remainder.
	//	Move bytes from the beginning to the end, or bytes from the end to the beginning
	//	depending on the rotation direction.
    LONG lNumBYTES = lRotateCount/8;
    if ( lNumBYTES > 0 )
    {
	    RtlCopyMemory (byAlignedLogonHours, pLogonHours, BYTES_PER_WEEK);

	    RtlCopyMemory (((PBYTE)byAlignedLogonHours) + BYTES_PER_WEEK,
					    pLogonHours,
					    BYTES_PER_WEEK );

        size_t  nBytesToEnd = sizeof (byAlignedLogonHours) - lNumBYTES;
        BYTE* pTemp = new BYTE[lNumBYTES];
        if ( pTemp )
        {
            //
            // Do the left rotate.
            //
            if ( bRotateLeft )
            {
                memcpy (pTemp, byAlignedLogonHours, lNumBYTES);

                memmove (byAlignedLogonHours, 
                        byAlignedLogonHours + lNumBYTES, 
                        nBytesToEnd);

                memcpy (byAlignedLogonHours + nBytesToEnd, 
                        pTemp, 
                        lNumBYTES);
            }
            else
            {
                // Do the right rotate
                memcpy (pTemp, 
                        byAlignedLogonHours + nBytesToEnd, 
                        lNumBYTES);

                memmove (byAlignedLogonHours + lNumBYTES, 
                        byAlignedLogonHours, 
                        nBytesToEnd);

                memcpy (byAlignedLogonHours, pTemp, lNumBYTES);
            }
            delete [] pTemp;
        }

        lRotateCount = lRotateCount%8;

        RtlCopyMemory (pLogonHours, byAlignedLogonHours, BYTES_PER_WEEK );
    }

	if ( lRotateCount )
	{
        //
        // Do the left rotate.
        //
		if (bRotateLeft) 
		{
			//
			// Copy the logon hours to a buffer.
			//
			//  Duplicate the entire pLogonHours buffer at the end of the 
			// byAlignedLogonHours buffer to make the rotation code trivial.
			//

			RtlCopyMemory (byAlignedLogonHours, pLogonHours, BYTES_PER_WEEK);

			RtlCopyMemory (((PBYTE)byAlignedLogonHours)+BYTES_PER_WEEK,
                    pLogonHours,
					BYTES_PER_WEEK);

			//
			// Actually rotate the data.
			//

			for ( i=0; i < BYTES_PER_WEEK; i++ ) 
			{
				byAlignedLogonHours[i] =
					(byAlignedLogonHours[i] >> (BYTE) lRotateCount) |
					(byAlignedLogonHours[i+1] << (BYTE) (8-lRotateCount));
			}

			//
			// Copy the logon hours back to the input buffer.
			//

			RtlCopyMemory (pLogonHours, byAlignedLogonHours, BYTES_PER_WEEK);
		} 
		else 
		{
		    //
		    // Do the right rotate.
		    //
			//
			// Copy the logon hours to a DWORD aligned buffer.
			//
			// Duplicate the last DWORD at the front of the buffer to make
			//  the rotation code trivial.
			//

            RtlCopyMemory (&byAlignedLogonHours[1], pLogonHours, BYTES_PER_WEEK);
            RtlCopyMemory (byAlignedLogonHours,
                    &pLogonHours[BYTES_PER_WEEK-1],
			        sizeof(BYTE));

			//
			// Actually rotate the data.
			//

			for (i = BYTES_PER_WEEK - 1; i >= 0; i-- ) 
			{
				byAlignedLogonHours[i+1] =
					(byAlignedLogonHours[i+1] << (BYTE) lRotateCount) |
					(byAlignedLogonHours[i] >> (BYTE) (8-lRotateCount));
			}

			//
			// Copy the logon hours back to the input buffer.
			//

			RtlCopyMemory (pLogonHours, &byAlignedLogonHours[1], BYTES_PER_WEEK);

		}
	}
    _TRACE (-1, L"Leaving NetpRotateLogonHoursPhase2\n");
    return TRUE;

} // NetpRotateLogonHoursPhase2()


/*++
Routine NetpRotateLogonHours()

    Rotate the pLogonHours bit mask to/from GMT relative time.


Arguments:

    pLogonHours - Pointer to LogonHour bit mask

    dwUnitsPerWeek - Number of bits in the bit mask. Must be UNITS_PER_WEEK (168).

    bConvertToGmt -
        True to convert the logon hours from local time to GMT relative
        False to convert the logon hours from GMT relative to local time

Return Value:

    TRUE if the rotation succeeded.
    FALSE if a parameter was out of range

--*/
BOOLEAN
NetpRotateLogonHours(
    IN OUT PBYTE	rgbLogonHours,		// Array of 21 bytes
    IN DWORD		cbitUnitsPerWeek,		// Must be 21 * 8 = 168
    IN BOOL			fConvertToGmt,
	IN bool			bAddDaylightBias)
{
    if ( !rgbLogonHours )
        return FALSE;

    LONG lRotateCount = 0;

    //
    // Break the functionality into two phases so that if the caller is doing
    //  this multiple time, he just calls Phase 1 once and Phase 2 multiple
    //  times.
    //

    if ( !NetpRotateLogonHoursPhase1 (fConvertToGmt, bAddDaylightBias, &lRotateCount) ) 
	{
        return FALSE;
	}

    return NetpRotateLogonHoursPhase2 (rgbLogonHours, cbitUnitsPerWeek, lRotateCount );
} // NetpRotateLogonHours()


/*++
Routine NetpRotateLogonHoursBYTE()

    Rotate the pLogonHours BYTE array to/from GMT relative time.
	Each BYTE is one hour. The contents of a BYTE must not change


Arguments:

    pLogonHours - Pointer to LogonHour bit mask

    dwUnitsPerWeek - Number of BYTES in the BYTE array. Must be UNITS_PER_WEEK (168).

    bConvertToGmt -
        True to convert the logon hours from local time to GMT relative
        False to convert the logon hours from GMT relative to local time

Return Value:

    TRUE if the rotation succeeded.
    FALSE if a parameter was out of range

--*/
BOOLEAN
NetpRotateLogonHoursBYTE(
    IN OUT PBYTE	rgbLogonHours,		// Array of 168 bytes
    IN DWORD		cbitUnitsPerWeek,		// Must be 21 * 8 = 168
    IN BOOL			fConvertToGmt,
	IN bool			bAddDaylightBias)
{
    if ( !rgbLogonHours )
        return FALSE;

    LONG lRotateCount = 0;

    //
    // Break the functionality into two phases so that if the caller is doing
    //  this multiple time, he just calls Phase 1 once and Phase 2 multiple
    //  times.
    //

    if ( !NetpRotateLogonHoursPhase1 (fConvertToGmt, bAddDaylightBias, &lRotateCount) ) 
	{
        return FALSE;
	}
	// NOTICE-NTRAID#NTBUG9-547513-2002/02/19-artm  Validate rgbLogonHours
	// Check correctly done at beginning of function.

	// FUTURE-2002/04/05-artm  cbitUnitsPerWeek should be validated
	// rgbLogonHours should not be NULL and cbitUnitsPerWeek should equal UNITS_PER_WEEK
	BOOLEAN bResult = TRUE;

	if ( lRotateCount != 0 )
	{
		size_t	numBytes = abs (lRotateCount);	
		PBYTE	pTemp = new BYTE[cbitUnitsPerWeek + numBytes];
		if ( pTemp )
		{
			if ( lRotateCount < 0 )  // shift left
			{
				// Copy the entire array and then start over with numBytes BYTES from
				// the start of the array to fill up to the end of the temp array.
				// Then shift over numBytes BYTES and copy 168 bytes from the temp
				// array back to the original array.
				memcpy (pTemp, rgbLogonHours, cbitUnitsPerWeek);
				memcpy (pTemp + cbitUnitsPerWeek, rgbLogonHours, numBytes);
				memcpy (rgbLogonHours, pTemp + numBytes, cbitUnitsPerWeek);
			}
			else	// lRotateCount > 0 -- shift right
			{
				// Copy numBytes BYTES from the end of the array and then copy 
				// the entire array to fill up to the end of the temp array.
				// The copy 168 bytes from the beginning of the temp array back
				// to the original array.
				memcpy (pTemp, rgbLogonHours + (cbitUnitsPerWeek - numBytes), numBytes);
				memcpy (pTemp + numBytes, rgbLogonHours, cbitUnitsPerWeek);
				memcpy (rgbLogonHours, pTemp, cbitUnitsPerWeek);
			}

			delete [] pTemp;
		}
		else
			bResult = FALSE;
	}

	return bResult;
} // NetpRotateLogonHours()


//****************************************************************************
//
//  GetFirstDayOfWeek
//
//  Use the locale API to get the "official" first day of the week.
//
//****************************************************************************
int GetFirstDayOfWeek()
{
    _TRACE (1, L"Entering GetFirstDayOfWeek\n");
    int    nFirstDay = -1;
    WCHAR  szBuf[10];

    int nRet = ::GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_IFIRSTDAYOFWEEK,
                            szBuf, sizeof(szBuf)/sizeof(WCHAR));
    if ( nRet > 0 )
    {
        int nDay = ::_wtoi( szBuf );
        if ( nDay < 0 || nDay > 6 )
        {
            _TRACE (0, L"Out of range, IFIRSTDAYOFWEEK = %d\n", nDay);
        }
        else
            nFirstDay = nDay;
    }
    else
    {
        _TRACE (0, L"GetLocaleInfo(IFIRSTDAYOFWEEK) failed - %d\n", GetLastError ());
    }

    _TRACE (-1, L"Leaving GetFirstDayOfWeek: first day = %d\n", nFirstDay);
    return nFirstDay;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by log.rc
//
#define IDD_LOGON_HOURS                 800
#define IDC_STATIC_LOGON_MATRIX         800
#define IDC_STATIC_DESCRIPTION          801
#define IDC_BUTTON_ADD_HOURS            802
#define IDC_BUTTON_REMOVE_HOURS         803
#define IDC_STATIC_LEGEND_NONE          806
#define IDC_STATIC_LEGEND_ONE           807
#define IDC_STATIC_LEGEND_TWO           808
#define IDC_STATIC_LEGEND_FOUR          809
#define IDC_STATIC_LEGEND_ON            810
#define IDC_STATIC_LEGEND_OFF           811
#define IDS_TOOL_SCHEDULE_FMT_DAILY     880
#define IDS_TOOL_SCHEDULE_FMT_WEEKLY_LONG 881
#define IDS_TOOL_SCHEDULE_FMT_WEEKLY_SHORT 882
#define IDS_TIMECHANGE                  883
#define IDS_ACTIVE_DIRECTORY_MANAGER    884
#define IDS_ALL_HEADER_TEXT             885
#define IDS_CLOSE                       886
#define IDS_SUNDAY                      887
#define IDS_MONDAY                      888
#define IDS_TUESDAY                     889
#define IDS_WEDNESDAY                   890
#define IDS_THURSDAY                    891
#define IDS_FRIDAY                      892
#define IDS_SATURDAY                    893
#define IDS_MATRIX_ACC_VALUE_MULTIPLE_CELLS 895
#define IDS_REPLICATION_NOT_AVAILABLE   896
#define IDS_REPLICATION_AVAILABLE       897
#define IDS_DO_NOT_REPLICATE            898
#define IDS_REPLICATE_ONCE_PER_HOUR     899
#define IDD_DS_SCHEDULE                 900
#define IDS_REPLICATE_TWICE_PER_HOUR    900
#define IDC_RADIO_NONE                  901
#define IDD_DIALIN_HOURS                901
#define IDS_REPLICATE_FOUR_TIMES_PER_HOUR 901
#define IDC_RADIO_ONE                   902
#define IDD_DIRSYNC_SCHEDULE            902
#define IDS_DONT_SYNCHRONIZE            902
#define IDC_RADIO_TWO                   903
#define IDD_REPLICATION_SCHEDULE        903
#define IDS_SYNCHRONIZE                 903
#define IDC_RADIO_FOUR                  904
#define IDS_LOGON_DENIED                904
#define IDS_LOGON_PERMITTED             905
#define IDS_REPLICATION_SCHEDULE_ACC_DESCRIPTION 906
#define IDS_DS_SCHEDULE_ACC_DESCRIPTION 907
#define IDS_DIRSYNC_SCHEDULE_ACC_DESCRIPTION 908
#define IDS_DIALIN_HOURS_ACC_DESCRIPTION 909
#define IDS_LOGON_HOURS_ACC_DESCRIPTION 910
#define IDS_LOCALECHANGE                911

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        801
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         808
#define _APS_NEXT_SYMED_VALUE           801
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\schedbas.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       SchedBas.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// SchedBas.cpp : implementation file
//

#include "stdafx.h"
#include "log.h"
#include <schedule.h>
#include "SchedBas.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//****************************************************************************
//
//  ReplaceFrameWithControl ()
//
//  Use the a dialog control to set the size of the Schedule Matrix.
//
//  HISTORY
//  17-Jul-97   t-danm      Copied from sample written by Scott Walker.
//
//****************************************************************************
void ReplaceFrameWithControl (CWnd *pWnd, UINT nFrameID, CWnd *pControl, 
                                          BOOL bAssignFrameIDToControl)
    {
    CWnd *pFrame;
    CRect rect;
    
    // FUTURE-2002/02/18-artm   Document that pWnd and pControl cannot be NULL.
    ASSERT (pWnd != NULL);
    ASSERT (pControl != NULL);

    // Get the frame control
    pFrame = pWnd->GetDlgItem (nFrameID);
    // FUTURE-2002/02/18-artm   Document that pFrame cannot be NULL.
    ASSERT (pFrame != NULL);
    
    // Get the frame rect
    pFrame->GetClientRect (&rect);
    pFrame->ClientToScreen (&rect);
    pWnd->ScreenToClient (&rect);

    // Set the control on the frame
    pControl->SetWindowPos (pFrame, rect.left, rect.top, rect.Width (), rect.Height (), 
        SWP_SHOWWINDOW);

    // set the control font to match the dialog font
    pControl->SetFont (pWnd->GetFont ());

    // hide the placeholder frame
    pFrame->ShowWindow (SW_HIDE);

    if (bAssignFrameIDToControl)
        pControl->SetDlgCtrlID ( nFrameID );
    } // ReplaceFrameWithControl


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CLogOnHoursDlg dialog

void CLegendCell::Init (CWnd* pParent, UINT nCtrlID, CScheduleMatrix* pMatrix, UINT nPercentage)
{
    // FUTURE-2002/02/18-artm  Document that pParent and pMatrix cannot be NULL.
    ASSERT (pParent && pMatrix );
    m_pMatrix = pMatrix;
    m_nPercentage = nPercentage;

    // ISSUE-2002/02/18-artm   Ignoring return value from SubclassDlgItem in release build.
    // subclass the window so that we get paint notifications
    VERIFY ( SubclassDlgItem ( nCtrlID, pParent ) );

    // Resize the legend cell to have the same interior size as the cells
    // in the schedule matrix
    CSize size = pMatrix->GetCellSize ();
    SetWindowPos ( NULL, 0, 0, size.cx+1, size.cy+1,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOZORDER );
}

void CLegendCell::OnPaint ()
{
    if (NULL == m_pMatrix)
    {
        ASSERT (0);
        return;
    }

    CRect rect;
    GetClientRect (rect);
    PAINTSTRUCT paintStruct;
    CDC *pdc = BeginPaint ( &paintStruct );

    m_pMatrix->DrawCell (
        pdc,
        rect,
        m_nPercentage,
        FALSE,
        m_pMatrix->GetBackColor (0,0),
        m_pMatrix->GetForeColor (0,0),
        m_pMatrix->GetBlendColor (0,0)
        );

    EndPaint (&paintStruct);
}

BEGIN_MESSAGE_MAP(CLegendCell, CStatic)
    //{{AFX_MSG_MAP(CLegendCell)
    ON_WM_PAINT ()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScheduleBaseDlg dialog


CScheduleBaseDlg::CScheduleBaseDlg(UINT nIDTemplate, bool bAddDaylightBias, CWnd* pParent /*=NULL*/)
    : CDialog(nIDTemplate, pParent),
    m_bSystemTimeChanged (false),
    m_dwFlags (0),
    m_bAddDaylightBias (bAddDaylightBias),
    m_nFirstDayOfWeek (::GetFirstDayOfWeek ()),
    m_cbArray (0)
{
    EnableAutomation();

    //{{AFX_DATA_INIT(CScheduleBaseDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void CScheduleBaseDlg::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CDialog::OnFinalRelease();
}

void CScheduleBaseDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CScheduleBaseDlg)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScheduleBaseDlg, CDialog)
    //{{AFX_MSG_MAP(CScheduleBaseDlg)
    //}}AFX_MSG_MAP
    ON_MN_SELCHANGE (IDC_SCHEDULE_MATRIX, OnSelChange)
    ON_WM_TIMECHANGE()
    ON_MESSAGE (BASEDLGMSG_GETIDD, OnGetIDD)
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CScheduleBaseDlg, CDialog)
    //{{AFX_DISPATCH_MAP(CScheduleBaseDlg)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IScheduleBaseDlg to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {701CFB38-AEF8-11D1-9864-00C04FB94F17}
static const IID IID_IScheduleBaseDlg =
{ 0x701cfb38, 0xaef8, 0x11d1, { 0x98, 0x64, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } };

BEGIN_INTERFACE_MAP(CScheduleBaseDlg, CDialog)
    INTERFACE_PART(CScheduleBaseDlg, IID_IScheduleBaseDlg, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScheduleBaseDlg message handlers

BOOL CScheduleBaseDlg::OnInitDialog() 
{
    _TRACE (1, L"Entering CScheduleBaseDlg::OnInitDialog\n");
    CDialog::OnInitDialog();
    
    CRect rect (0,0,0,0);

    // Set up the weekly matrix and slap it on the dialog.
    BOOL bRet = m_schedulematrix.Create (L"WeeklyMatrix", rect, this, IDC_SCHEDULE_MATRIX);
    if ( !bRet )
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"CScheduleMatrix::Create () failed: 0x%x\n", dwErr);
    }
    ::ReplaceFrameWithControl (this, IDC_STATIC_LOGON_MATRIX, &m_schedulematrix, FALSE);
    // Set the blending color for the whole matrix
    m_schedulematrix.SetBlendColor (c_crBlendColor, 0, 0, 24, 7);
    m_schedulematrix.SetForeColor (c_crBlendColor, 0, 0, 24, 7);
    

    SetWindowText (m_szTitle);

    InitMatrix ();

    UpdateUI ();
    
    if ( m_dwFlags & SCHED_FLAG_READ_ONLY )
    {
        // Change the Cancel button to Close
        CString strClose;

        // FUTURE-2002/02/18-artm   Check the return value from LoadString() in release build.

        // NOTICE-2002/02/18-artm  CString can throw out of memory exception.
        // There's no good way to handle exception at this level, so caller will be
        // responsible.
        VERIFY (strClose.LoadString (IDS_CLOSE));
        GetDlgItem (IDCANCEL)->SetWindowText (strClose);

        // Hide the OK button
        GetDlgItem (IDOK)->ShowWindow (SW_HIDE);
    }


    _TRACE (-1, L"Leaving CScheduleBaseDlg::OnInitDialog\n");
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CScheduleBaseDlg::SetTitle(LPCTSTR pszTitle)
{
    // NOTICE-NTRAID#NTBUG9-547381-2002/02/18-artm  String class handles NULL.
    // String class easily handles null pointer.
    m_szTitle = pszTitle;
}

void CScheduleBaseDlg::OnSelChange ()
{
    UpdateUI ();
}

void CScheduleBaseDlg::UpdateUI ()
{
    CString strDescr;
    m_schedulematrix.GetSelDescription (OUT strDescr);
    // FUTURE-2002/02/18-artm  Check return value of SetDlgItemText().
    SetDlgItemText (IDC_STATIC_DESCRIPTION, strDescr);
    UpdateButtons ();
}

/////////////////////////////////////////////////////////////////////
//  InitMatrix2 ()
//
//  Initialize the schedule matrix with an array of values
//  representing replication frequencies.
//
//  INTERFACE NOTES
//  Each byte of rgbData represent one hour.  The first day of
//  the week is Sunday and the last day is Saturday.
//
void CScheduleBaseDlg::InitMatrix2 (const BYTE rgbData[])
{
    // NTRAID#NTBUG9-547765-2002/02/18-artm   No way to validate rgbData under current interface.
    //
    // There is no way to check that rgbData is the correct length w/out
    // passing in a length parameter.  Also, there should be check that
    // rgbData is not NULL.
    ASSERT (rgbData);
    ASSERT ( m_cbArray == 7*24);
    if ( m_cbArray != 7*24 )
        return;

    bool bMatrixAllSelected = true;
    bool bMatrixAllClear = true;
    const BYTE * pbData = rgbData;
    size_t  nIndex = 0;
    for (int iDayOfWeek = 0; iDayOfWeek < 7 && nIndex < m_cbArray; iDayOfWeek++)
    {
        for (int iHour = 0; iHour < 24 && nIndex < m_cbArray; iHour++)
        {
            if (!*pbData)
                bMatrixAllSelected = false;
            else
                bMatrixAllClear = false;
            m_schedulematrix.SetPercentage (GetPercentageToSet (*pbData) , iHour, iDayOfWeek);
            pbData++;
            nIndex++;
        } // for
    } // for
    // If the whole matrix is selected, then set the selection to the whole matrix
    if ( bMatrixAllSelected || bMatrixAllClear )
        m_schedulematrix.SetSel (0, 0, 24, 7);
    else
        m_schedulematrix.SetSel (0, 0, 1, 1);
} // InitMatrix2 ()


/////////////////////////////////////////////////////////////////////
//  GetByteArray ()
//
//  Get an array of bytes from the schedule matrix.  Each byte
//  is a boolean value representing one hour of logon access to a user.
//
//  INTERFACE NOTES
//  Same as SetLogonByteArray ().
//
void CScheduleBaseDlg::GetByteArray (OUT BYTE rgbData[], const size_t cbArray)
{
    // NTRAID#NTBUG9-547765-2002/02/18-artm   No way to validate rgbData as written.
    //
    // Need a size parameter to verify correct size of rgbData, esp. 
    // since caller is taking responsibility for allocating array.
    // Also, need to check that rgbData is not NULL.
    ASSERT (rgbData);

    BYTE * pbData = rgbData;
    size_t  nIndex = 0;
    for (int iDayOfWeek = 0; iDayOfWeek < 7 && nIndex < cbArray; iDayOfWeek++)
    {
        for (int iHour = 0; iHour < 24 && nIndex < cbArray; iHour++)
        {
            *pbData = GetMatrixPercentage (iHour, iDayOfWeek);
            pbData++;
            nIndex++;
        } // for
    } // for
} // GetByteArray ()

// If the system time or time zone has changed prompt the user to close and reopen
// the dialog. Otherwise, if the dialog data was saved, data could be corrupted.
// Disable all controls.
void CScheduleBaseDlg::OnTimeChange()
{
    if ( !m_bSystemTimeChanged )
    {
        m_bSystemTimeChanged = true;

        CString caption;
        CString text;

        // FUTURE-2002/02/18-artm   Check return value of LoadString().

        // NOTICE-2002/02/18-artm   CString can throw out of memory exceptions.
        //
        // No good way to handle exceptions at this level; caller is responsible
        // for handling any out of memory exceptions.
        VERIFY (caption.LoadString (IDS_ACTIVE_DIRECTORY_MANAGER));
        VERIFY (text.LoadString (IDS_TIMECHANGE));
        MessageBox (text, caption, MB_ICONINFORMATION | MB_OK);
        GetDlgItem (IDCANCEL)->SetFocus ();
        GetDlgItem (IDOK)->EnableWindow (FALSE);
        m_schedulematrix.EnableWindow (FALSE);
        TimeChange ();
    }
}

void CScheduleBaseDlg::SetFlags(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
}

DWORD CScheduleBaseDlg::GetFlags() const
{
    return m_dwFlags;
}

LRESULT CScheduleBaseDlg::OnGetIDD (WPARAM /*wParam*/, LPARAM /*lParam*/)
{
    return GetIDD ();
}

void CScheduleBaseDlg::OnOK ()
{
    if ( m_nFirstDayOfWeek == ::GetFirstDayOfWeek () )
    {
        CDialog::OnOK ();
    }
    else
    {
        CString caption;
        CString text;

        // FUTURE-2002/02/18-artm   Check return value of LoadString().

        // NOTICE-2002/02/18-artm   CString can throw out of memory exceptions.
        //
        // No good way to handle exceptions at this level; caller is responsible
        // for handling any out of memory exceptions.
        VERIFY (caption.LoadString (IDS_ACTIVE_DIRECTORY_MANAGER));
        VERIFY (text.LoadString (IDS_LOCALECHANGE));
        MessageBox (text, caption, MB_ICONINFORMATION | MB_OK);
        GetDlgItem (IDCANCEL)->SetFocus ();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\scheddlg.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-2002
//
//  File:       SchedDlg.cpp
//
//  Contents:   Implementation of CConnectionScheduleDlg
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "SchedDlg.h"
#include "log_gmt.h"
#include "loghrapi.h"

#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// The schedule block has been redefined to have 1 byte for every hour.
// CODEWORK These should be defined in SCHEDULE.H.  JonN 2/9/98
//
#define INTERVAL_MASK       0x0F
#define RESERVED            0xF0
#define FIRST_15_MINUTES    0x01
#define SECOND_15_MINUTES   0x02
#define THIRD_15_MINUTES    0x04
#define FOURTH_15_MINUTES   0x08

const int NONE_PER_HOUR = 0;
const int ONE_PER_HOUR  = 33;
const int TWO_PER_HOUR  = 67;
const int FOUR_PER_HOUR = 100;
/////////////////////////////////////////////////////////////////////
//  ConnectionScheduleDialog ()
//
//  Invoke a dialog to set/modify a schedule, for example
//      -- the logon hours for a particular user
//      -- the schedule for a connection
//
//  RETURNS
//  Return S_OK if the user clicked on the OK button.
//  Return S_FALSE if the user clicked on the Cancel button.
//  Return E_OUTOFMEMORY if there is not enough memory.
/// Return E_UNEXPECTED if an expected error occured (eg: bad parameter)
//
//  INTERFACE NOTES
//  Each bit in the array represents one hour.  As a result, the
//  expected length of the array should be (24 / 8) * 7 = 21 bytes.
//  For convenience, the first day of the week is Sunday and
//  the last day is Saturday.
//  Consequently, the first bit of the array represents the schedule
//  for Sunday during period 12 AM to 1 AM.
//  - If *pprgbData is NULL, then the routine will allocate
//    an array of 21 bytes using LocalAlloc ().  The caller
//    is responsible of releasing the memory using LocalFree ().
//  - If *pprgbData is not NULL, the routine re-use the array as its
//    output parameter.
//
//  HISTORY
//  17-Jul-97   t-danm      Creation.
//  16-Sep-97   jonn        Changed to UiScheduleDialog
//

HRESULT
ConnectionScheduleDialog (
    HWND hwndParent,        // IN: Parent's window handle
    BYTE ** pprgbData,      // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
    LPCTSTR pszTitle)       // IN: Dialog title
{
    return ConnectionScheduleDialogEx (hwndParent, pprgbData, pszTitle, 0);
}

// NTRAID#NTBUG9-547415-2002/02/18-artm  Should catch out of memory exceptions and convert to HRESULT.
HRESULT
ConnectionScheduleDialogEx (
    HWND hwndParent,        // IN: Parent's window handle
    BYTE ** pprgbData,      // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
    LPCTSTR pszTitle,       // IN: Dialog title
    DWORD   dwFlags)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    // These asserts are backed up by validation code.
    ASSERT (::IsWindow (hwndParent));
    ASSERT (pprgbData);
    // NOTICE-NTRAID#NTBUG9-547381-2002/02/18-artm  pszTitle okay to be NULL
    // dlg.SetTitle() robustly handles NULL.
    ASSERT (pszTitle);
    ENDORSE (NULL == *pprgbData);   // TRUE => Use default logon hours (7x24)

    if (*pprgbData == NULL)
    {
        BYTE * pargbData;   // Pointer to allocated array of bytes
        // FUTURE-2002/02/18-artm  Use named constant instead of magic 7*24.
        pargbData = (BYTE *)LocalAlloc (0, 7*24);   // Allocate 168 bytes
        if ( !pargbData )
            return E_OUTOFMEMORY;
        // Set the logon hours to be valid 24 hours a day and 7 days a week.
        // FUTURE-2002/02/18-artm  Use named constant instead of magic 7*24.
        memset (OUT pargbData, -1, 7*24);
        *pprgbData = pargbData;
    }

    // If hwndParent passed in, create a CWnd to pass as the parent window
    CWnd* pWnd = 0;
    if ( ::IsWindow (hwndParent) )
    {
        pWnd = new CWnd;
        if ( pWnd )
        {
            pWnd->Attach (hwndParent);
        }
        else
            return E_OUTOFMEMORY;
    }

    HRESULT             hr = S_OK;
    CConnectionScheduleDlg  dlg (pWnd);
    dlg.SetTitle (pszTitle);
    dlg.SetConnectionByteArray (INOUT *pprgbData, 7*24);
    dlg.SetFlags (dwFlags);

    if (IDOK != dlg.DoModal ())
        hr = S_FALSE;

    // Delete CWnd
    if ( pWnd )
    {
        pWnd->Detach ();
        delete pWnd;
    }

    return hr;
} // ConnectionScheduleDialog ()



HRESULT
ReplicationScheduleDialog (
    HWND hwndParent,        // IN: Parent's window handle
    BYTE ** pprgbData,      // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
    LPCTSTR pszTitle)       // IN: Dialog title
{
    return ReplicationScheduleDialogEx (hwndParent, pprgbData, pszTitle, 0);
} // ReplicationScheduleDialog ()


// NTRAID#NTBUG9-547415-2002/02/18-artm  Should catch out of memory exceptions and convert to HRESULT.
HRESULT ReplicationScheduleDialogEx (
    HWND hwndParent,       // parent window
    BYTE ** pprgbData,     // pointer to pointer to array of 84 bytes
    LPCTSTR pszTitle,     // dialog title
    DWORD   dwFlags)      // option flags
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    // These asserts are backed up by validation code in release build.
    ASSERT (::IsWindow (hwndParent));
    ASSERT (pprgbData);
    // NOTICE-NTRAID#NTBUG9-547381-2002/02/18-artm  pszTitle okay to be NULL
    // dlg.SetTitle() robustly handles NULL.
    ASSERT (pszTitle);
    ENDORSE (NULL == *pprgbData);   // TRUE => Use default logon hours (7x24)

    if (*pprgbData == NULL)
    {
        BYTE * pargbData;   // Pointer to allocated array of bytes
        // FUTURE-2002/02/18-artm  Use named constant instead of magic 7*24.
        pargbData = (BYTE *)LocalAlloc (0, 7*24);   // Allocate 168 bytes
        if ( !pargbData )
            return E_OUTOFMEMORY;
        // FUTURE-2002/02/18-artm  Use named constant instead of magic 7*24.
        // Set the logon hours to be valid 24 hours a day and 7 days a week.
        memset (OUT pargbData, -1, 7*24);
        *pprgbData = pargbData;
    }

    // If hwndParent passed in, create a CWnd to pass as the parent window
    CWnd* pWnd = 0;
    if ( ::IsWindow (hwndParent) )
    {
        pWnd = new CWnd;
        if ( pWnd )
        {
            pWnd->Attach (hwndParent);
        }
        else
            return E_OUTOFMEMORY;
    }

    HRESULT             hr = S_OK;
    CReplicationScheduleDlg dlg (pWnd);
    dlg.SetTitle (pszTitle);
    dlg.SetConnectionByteArray (INOUT *pprgbData, 7*24);
    dlg.SetFlags (dwFlags);
    if (IDOK != dlg.DoModal ())
        hr = S_FALSE;

    // Delete CWnd
    if ( pWnd )
    {
        pWnd->Detach ();
        delete pWnd;
    }

    return hr;
}   // ReplicationScheduleDialogEx

/////////////////////////////////////////////////////////////////////////////
// CConnectionScheduleDlg dialog


CConnectionScheduleDlg::CConnectionScheduleDlg(CWnd* pParent)
    : CScheduleBaseDlg(CConnectionScheduleDlg::IDD, true, pParent),
    m_prgbData168 (0)
{
    EnableAutomation();

    //{{AFX_DATA_INIT(CConnectionScheduleDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void CConnectionScheduleDlg::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CScheduleBaseDlg::OnFinalRelease();
}

void CConnectionScheduleDlg::DoDataExchange(CDataExchange* pDX)
{
    CScheduleBaseDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConnectionScheduleDlg)
    DDX_Control(pDX, IDC_RADIO_NONE, m_buttonNone);
    DDX_Control(pDX, IDC_RADIO_ONE, m_buttonOne);
    DDX_Control(pDX, IDC_RADIO_TWO, m_buttonTwo);
    DDX_Control(pDX, IDC_RADIO_FOUR, m_buttonFour);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConnectionScheduleDlg, CScheduleBaseDlg)
    //{{AFX_MSG_MAP(CConnectionScheduleDlg)
    ON_BN_CLICKED(IDC_RADIO_FOUR, OnRadioFour)
    ON_BN_CLICKED(IDC_RADIO_NONE, OnRadioNone)
    ON_BN_CLICKED(IDC_RADIO_ONE, OnRadioOne)
    ON_BN_CLICKED(IDC_RADIO_TWO, OnRadioTwo)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CConnectionScheduleDlg, CScheduleBaseDlg)
    //{{AFX_DISPATCH_MAP(CConnectionScheduleDlg)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IDSScheduleDlg to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {701CFB36-AEF8-11D1-9864-00C04FB94F17}
static const IID IID_IDSScheduleDlg =
{ 0x701cfb36, 0xaef8, 0x11d1, { 0x98, 0x64, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } };

BEGIN_INTERFACE_MAP(CConnectionScheduleDlg, CScheduleBaseDlg)
    INTERFACE_PART(CConnectionScheduleDlg, IID_IDSScheduleDlg, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConnectionScheduleDlg message handlers

BOOL CConnectionScheduleDlg::OnInitDialog() 
{
    CScheduleBaseDlg::OnInitDialog();
    
    // Set up the "none" legend
    m_legendNone.Init (this, IDC_STATIC_LEGEND_NONE, &m_schedulematrix, NONE_PER_HOUR);

    // Set up the "one" legend
    m_legendOne.Init (this, IDC_STATIC_LEGEND_ONE, &m_schedulematrix, ONE_PER_HOUR);

    // Set up the "two" legend
    m_legendTwo.Init (this, IDC_STATIC_LEGEND_TWO, &m_schedulematrix, TWO_PER_HOUR);
    
    // Set up the "four" legend
    m_legendFour.Init (this, IDC_STATIC_LEGEND_FOUR, &m_schedulematrix, FOUR_PER_HOUR);
    
    if ( GetFlags () & SCHED_FLAG_READ_ONLY )
    {
        // Disable the grid settings buttons
        m_buttonNone.EnableWindow (FALSE);
        m_buttonOne.EnableWindow (FALSE);
        m_buttonTwo.EnableWindow (FALSE);
        m_buttonFour.EnableWindow (FALSE);
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CConnectionScheduleDlg::OnOK() 
{
    if ( m_prgbData168 )
    {
        GetByteArray (OUT m_prgbData168, m_cbArray);

        // Convert back the hours to GMT time.
        ConvertConnectionHoursToGMT (INOUT m_prgbData168, m_bAddDaylightBias);
    }
    
    CScheduleBaseDlg::OnOK();
}


void CConnectionScheduleDlg::UpdateButtons ()
{
    UINT nHour = 0;
    UINT nDay = 0;
    UINT nNumHours = 0;
    UINT nNumDays = 0;

    m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);

    // Assume in each case that all selected squares are all set one way until 
    // proven otherwise.  These are 'int' so that I can add them up afterwards
    // to assure that only one of the buttons will be checked.
    int fNoneAllSet = 1;
    int fOneAllSet = 1;
    int fTwoAllSet = 1;
    int fFourAllSet = 1;

    if (nNumHours > 0)
    {
        for (UINT iDayOfWeek = nDay; iDayOfWeek < nDay+nNumDays; iDayOfWeek++)
        {
            for (UINT iHour = nHour; iHour < nHour+nNumHours; iHour++)
            {
                switch (m_schedulematrix.GetPercentage (iHour, iDayOfWeek))
                {
                case NONE_PER_HOUR:
                    fOneAllSet = 0;
                    fTwoAllSet = 0;
                    fFourAllSet = 0;
                    break;

                case ONE_PER_HOUR:
                    fNoneAllSet = 0;
                    fTwoAllSet = 0;
                    fFourAllSet = 0;
                    break;

                case TWO_PER_HOUR:
                    fNoneAllSet = 0;
                    fOneAllSet = 0;
                    fFourAllSet = 0;
                    break;

                case FOUR_PER_HOUR:
                    fNoneAllSet = 0;
                    fOneAllSet = 0;
                    fTwoAllSet = 0;
                    break;

                default:
                    ASSERT (0);
                    break;
                }
            } // for
        } // for
    }
    else
    {
        fNoneAllSet = 0;
        fOneAllSet = 0;
        fTwoAllSet = 0;
        fFourAllSet = 0;
    }

    // Ensure that at most, only one of these is 'true'
    ASSERT ((fNoneAllSet + fOneAllSet + fTwoAllSet + fFourAllSet <= 1));
    m_buttonNone.SetCheck (fNoneAllSet);
    m_buttonOne.SetCheck (fOneAllSet);
    m_buttonTwo.SetCheck (fTwoAllSet);
    m_buttonFour.SetCheck (fFourAllSet);
}

void CConnectionScheduleDlg::OnRadioFour() 
{
    UINT nHour = 0;
    UINT nDay = 0;
    UINT nNumHours = 0;
    UINT nNumDays = 0;

    m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
    if (nNumHours <= 0)
        return; // Nothing selected
    m_schedulematrix.SetPercentage (FOUR_PER_HOUR, nHour, nDay, nNumHours, nNumDays);
    UpdateButtons ();
}

void CConnectionScheduleDlg::OnRadioNone() 
{
    UINT nHour = 0;
    UINT nDay = 0;
    UINT nNumHours = 0;
    UINT nNumDays = 0;

    m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
    if (nNumHours <= 0)
        return; // Nothing selected
    m_schedulematrix.SetPercentage (NONE_PER_HOUR, nHour, nDay, nNumHours, nNumDays);
    UpdateButtons ();
}

void CConnectionScheduleDlg::OnRadioOne() 
{
    UINT nHour = 0;
    UINT nDay = 0;
    UINT nNumHours = 0;
    UINT nNumDays = 0;

    m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
    if (nNumHours <= 0)
        return; // Nothing selected
    m_schedulematrix.SetPercentage (ONE_PER_HOUR, nHour, nDay, nNumHours, nNumDays);
    UpdateButtons ();
}

void CConnectionScheduleDlg::OnRadioTwo() 
{
    UINT nHour = 0;
    UINT nDay = 0;
    UINT nNumHours = 0;
    UINT nNumDays = 0;

    m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
    if (nNumHours <= 0)
        return; // Nothing selected
    m_schedulematrix.SetPercentage (TWO_PER_HOUR, nHour, nDay, nNumHours, nNumDays);
    UpdateButtons ();
}

void CConnectionScheduleDlg::InitMatrix()
{
    if ( m_prgbData168 )
    {
        BYTE rgData[SCHEDULE_DATA_ENTRIES];     // Array of logonhours bits
        // Make a copy of the connection hours (in case the user click on cancel button)
        memcpy (OUT rgData, IN m_prgbData168, sizeof (rgData));
        // Convert the hours from GMT to local hours.
        ConvertConnectionHoursFromGMT (INOUT rgData, m_bAddDaylightBias);
        // Initialize the matrix
        InitMatrix2 (IN rgData);
    }
}

void CConnectionScheduleDlg::SetConnectionByteArray(INOUT BYTE rgbData [SCHEDULE_DATA_ENTRIES], 
        const size_t cbArray)
{
    // NULL m_prgbData168 is checked for where it is dereferenced; ASSERT does not need to be backed up
    ASSERT (rgbData);

    if ( !IsBadWritePtr (rgbData, cbArray) )
    {
        m_prgbData168 = rgbData;
        m_cbArray = cbArray;
    }
}

// This table represent the numbers of bits set in the lower nibble of the BYTE.
// 0 bits -> 0
// 1 bit -> 25
// 2 or 3 bits -> 50
// 4 bits -> 100
static BYTE setConversionTable[16] = 
    {NONE_PER_HOUR, // 0000
    ONE_PER_HOUR,   // 0001
    ONE_PER_HOUR,   // 0010
    TWO_PER_HOUR,   // 0011
    ONE_PER_HOUR,   // 0100
    TWO_PER_HOUR,   // 0101
    TWO_PER_HOUR,   // 0110
    TWO_PER_HOUR,   // 0111
    ONE_PER_HOUR,   // 1000
    TWO_PER_HOUR,   // 1001
    TWO_PER_HOUR,   // 1010
    TWO_PER_HOUR,   // 1011
    TWO_PER_HOUR,   // 1100
    TWO_PER_HOUR,   // 1101
    TWO_PER_HOUR,   // 1110
    FOUR_PER_HOUR}; // 1111

UINT CConnectionScheduleDlg::GetPercentageToSet(const BYTE bData)
{
    ASSERT ((bData & 0x0F) < 16);
    return setConversionTable[bData & 0x0F];
}


BYTE CConnectionScheduleDlg::GetMatrixPercentage(UINT nHour, UINT nDay)
{
    BYTE    byResult = 0;

    switch (m_schedulematrix.GetPercentage (nHour, nDay))
    {
    case NONE_PER_HOUR:
        // value remains 0n
        break;

    case ONE_PER_HOUR:
        byResult = FIRST_15_MINUTES;
        break;

    case TWO_PER_HOUR:
        byResult = FIRST_15_MINUTES | THIRD_15_MINUTES;
        break;

    case FOUR_PER_HOUR:
        byResult = FIRST_15_MINUTES | SECOND_15_MINUTES | THIRD_15_MINUTES | FOURTH_15_MINUTES;
        break;

    default:
        ASSERT (0);
        break;
    }

    return byResult;
}

UINT CConnectionScheduleDlg::GetExpectedArrayLength()
{
    return SCHEDULE_DATA_ENTRIES;
}

// Called when WM_TIMECHANGE is received
void CConnectionScheduleDlg::TimeChange()
{
    m_buttonNone.EnableWindow (FALSE);
    m_buttonOne.EnableWindow (FALSE);
    m_buttonTwo.EnableWindow (FALSE);
    m_buttonFour.EnableWindow (FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CReplicationScheduleDlg dialog


CReplicationScheduleDlg::CReplicationScheduleDlg(CWnd* pParent)
    : CScheduleBaseDlg(CReplicationScheduleDlg::IDD, true, pParent),
    m_prgbData168 (0)
{
    EnableAutomation();

    //{{AFX_DATA_INIT(CReplicationScheduleDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void CReplicationScheduleDlg::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CScheduleBaseDlg::OnFinalRelease();
}

void CReplicationScheduleDlg::DoDataExchange(CDataExchange* pDX)
{
    CScheduleBaseDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CReplicationScheduleDlg)
    DDX_Control(pDX, IDC_RADIO_NONE, m_buttonNone);
    DDX_Control(pDX, IDC_RADIO_FOUR, m_buttonFour);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CReplicationScheduleDlg, CScheduleBaseDlg)
    //{{AFX_MSG_MAP(CReplicationScheduleDlg)
    ON_BN_CLICKED(IDC_RADIO_FOUR, OnRadioFour)
    ON_BN_CLICKED(IDC_RADIO_NONE, OnRadioNone)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CReplicationScheduleDlg, CScheduleBaseDlg)
    //{{AFX_DISPATCH_MAP(CReplicationScheduleDlg)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IDSScheduleDlg to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {8DE6E2DA-7B4E-11d2-AC13-00C04F79DDCA}
static const IID IID_IReplicationScheduleDlg = 
{ 0x8de6e2da, 0x7b4e, 0x11d2, { 0xac, 0x13, 0x0, 0xc0, 0x4f, 0x79, 0xdd, 0xca } };

BEGIN_INTERFACE_MAP(CReplicationScheduleDlg, CScheduleBaseDlg)
    INTERFACE_PART(CReplicationScheduleDlg, IID_IReplicationScheduleDlg, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CReplicationScheduleDlg message handlers

BOOL CReplicationScheduleDlg::OnInitDialog() 
{
    CScheduleBaseDlg::OnInitDialog();
    

    // Set up the "none" legend
    m_legendNone.Init (this, IDC_STATIC_LEGEND_NONE, &m_schedulematrix, NONE_PER_HOUR);

    // Set up the "four" legend
    m_legendFour.Init (this, IDC_STATIC_LEGEND_FOUR, &m_schedulematrix, FOUR_PER_HOUR);
    
    if ( GetFlags () & SCHED_FLAG_READ_ONLY )
    {
        // Disable the grid settings buttons
        m_buttonNone.EnableWindow (FALSE);
        m_buttonFour.EnableWindow (FALSE);
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CReplicationScheduleDlg::OnOK() 
{
    if ( m_prgbData168 )
    {
        GetByteArray (OUT m_prgbData168, m_cbArray);

        // Convert back the hours to GMT time.
        ConvertConnectionHoursToGMT (INOUT m_prgbData168, m_bAddDaylightBias);
    }
    
    CScheduleBaseDlg::OnOK();
}


void CReplicationScheduleDlg::UpdateButtons ()
{
    UINT nHour = 0;
    UINT nDay = 0;
    UINT nNumHours = 0;
    UINT nNumDays = 0;

    m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);

    // Assume in each case that all selected squares are all set one way until 
    // proven otherwise.  These are 'int' so that I can add them up afterwards
    // to assure that only one of the buttons will be checked.
    int fNoneAllSet = 1;
    int fFourAllSet = 1;

    if (nNumHours > 0)
    {
        for (UINT iDayOfWeek = nDay; iDayOfWeek < nDay+nNumDays; iDayOfWeek++)
        {
            for (UINT iHour = nHour; iHour < nHour+nNumHours; iHour++)
            {
                switch (m_schedulematrix.GetPercentage (iHour, iDayOfWeek))
                {
                case NONE_PER_HOUR:
                    fFourAllSet = 0;
                    break;

                case FOUR_PER_HOUR:
                    fNoneAllSet = 0;
                    break;

                default:
                    ASSERT (0);
                    break;
                }
            } // for
        } // for
    }
    else
    {
        fNoneAllSet = 0;
    }

    ASSERT (fNoneAllSet + fFourAllSet <= 1);
    m_buttonNone.SetCheck (fNoneAllSet);
    m_buttonFour.SetCheck (fFourAllSet);
}

void CReplicationScheduleDlg::OnRadioFour() 
{
    UINT nHour = 0;
    UINT nDay = 0;
    UINT nNumHours = 0;
    UINT nNumDays = 0;

    m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
    if (nNumHours <= 0)
        return; // Nothing selected
    m_schedulematrix.SetPercentage (FOUR_PER_HOUR, nHour, nDay, nNumHours, nNumDays);
    UpdateButtons ();
}

void CReplicationScheduleDlg::OnRadioNone() 
{
    UINT nHour = 0;
    UINT nDay = 0;
    UINT nNumHours = 0;
    UINT nNumDays = 0;

    m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
    if (nNumHours <= 0)
        return; // Nothing selected
    m_schedulematrix.SetPercentage (NONE_PER_HOUR, nHour, nDay, nNumHours, nNumDays);
    UpdateButtons ();
}


void CReplicationScheduleDlg::InitMatrix()
{
    if ( m_prgbData168 )
    {
        BYTE rgData[SCHEDULE_DATA_ENTRIES];     // Array of logonhours bits
        // Make a copy of the connection hours (in case the user click on cancel button)
        memcpy (OUT rgData, IN m_prgbData168, sizeof (rgData));
        // Convert the hours from GMT to local hours.
        ConvertConnectionHoursFromGMT (INOUT rgData, m_bAddDaylightBias);
        // Initialize the matrix
        InitMatrix2 (IN rgData);
    }
}

void CReplicationScheduleDlg::SetConnectionByteArray(INOUT BYTE rgbData [SCHEDULE_DATA_ENTRIES], const size_t cbArray)
{
    // Code supports NULL rgbData; ASSERT() is early bug detection.
    ASSERT (rgbData);
    if ( !IsBadWritePtr (rgbData, cbArray) )
    {
        m_prgbData168 = rgbData;
        m_cbArray = cbArray;
    }
}


// This table represent the numbers of bits set in the lower nibble of the BYTE.
// 0 bits -> 0
// 1 bit -> 25
// 2 or 3 bits -> 50
// 4 bits -> 100
static BYTE setConversionTableForReplication[16] = 
    {NONE_PER_HOUR, // 0000
    FOUR_PER_HOUR,  // 0001
    FOUR_PER_HOUR,  // 0010
    FOUR_PER_HOUR,  // 0011
    FOUR_PER_HOUR,  // 0100
    FOUR_PER_HOUR,  // 0101
    FOUR_PER_HOUR,  // 0110
    FOUR_PER_HOUR,  // 0111
    FOUR_PER_HOUR,  // 1000
    FOUR_PER_HOUR,  // 1001
    FOUR_PER_HOUR,  // 1010
    FOUR_PER_HOUR,  // 1011
    FOUR_PER_HOUR,  // 1100
    FOUR_PER_HOUR,  // 1101
    FOUR_PER_HOUR,  // 1110
    FOUR_PER_HOUR}; // 1111

UINT CReplicationScheduleDlg::GetPercentageToSet(const BYTE bData)
{
    ASSERT ((bData & 0x0F) < 16);
    return setConversionTableForReplication[bData & 0x0F];
}


BYTE CReplicationScheduleDlg::GetMatrixPercentage(UINT nHour, UINT nDay)
{
    BYTE    byResult = 0;

    switch (m_schedulematrix.GetPercentage (nHour, nDay))
    {
    case NONE_PER_HOUR:
        // value remains 0n
        break;

    case ONE_PER_HOUR:
    case TWO_PER_HOUR:
    case FOUR_PER_HOUR:
        byResult = FIRST_15_MINUTES | SECOND_15_MINUTES | THIRD_15_MINUTES | FOURTH_15_MINUTES;
        break;

    default:
        ASSERT (0);
        break;
    }

    return byResult;
}

UINT CReplicationScheduleDlg::GetExpectedArrayLength()
{
    return SCHEDULE_DATA_ENTRIES;
}

// Called when WM_TIMECHANGE is received
void CReplicationScheduleDlg::TimeChange()
{
    m_buttonNone.EnableWindow (FALSE);
    m_buttonFour.EnableWindow (FALSE);
}


/////////////////////////////////////////////////////////////////////
//  Converts the connection hours from local time to GMT.
void 
ConvertConnectionHoursToGMT (INOUT BYTE rgbData[SCHEDULE_DATA_ENTRIES], IN bool bAddDaylightBias)
{
    // FUTURE-2002/02/18-artm  Release code should check return value.
    VERIFY ( ::NetpRotateLogonHoursBYTE (rgbData, SCHEDULE_DATA_ENTRIES, TRUE, bAddDaylightBias) );
}

/////////////////////////////////////////////////////////////////////
//  Converts the connection hours from GMT to local time.
void
ConvertConnectionHoursFromGMT (INOUT BYTE rgbData[SCHEDULE_DATA_ENTRIES], IN bool bAddDaylightBias)
{
    // FUTURE-2002/02/18-artm  Release code should check return value.
    VERIFY ( ::NetpRotateLogonHoursBYTE (rgbData, SCHEDULE_DATA_ENTRIES, FALSE, bAddDaylightBias) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\scheddlg.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-2002.
//
//  File:       SchedDlg.h
//
//  Contents:   Definition of CConnectionScheduleDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_SCHEDDLG_H__701CFB37_AEF8_11D1_9864_00C04FB94F17__INCLUDED_)
#define AFX_SCHEDDLG_H__701CFB37_AEF8_11D1_9864_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SchedDlg.h : header file
//
#include <schedule.h>
#include "SchedBas.h"

#ifndef INOUT
    #define INOUT
    #define ENDORSE(f)  // Macro which is the opposite of ASSERT()
#endif

void ConvertConnectionHoursToGMT(INOUT BYTE rgbData[SCHEDULE_DATA_ENTRIES], IN bool bAddDaylightBias);
void ConvertConnectionHoursFromGMT(INOUT BYTE rgbData[SCHEDULE_DATA_ENTRIES], IN bool bAddDaylightBias);

/////////////////////////////////////////////////////////////////////////////
// CConnectionScheduleDlg dialog

class CConnectionScheduleDlg : public CScheduleBaseDlg
{
// Construction
public:
    void SetConnectionByteArray (INOUT BYTE rgbData[SCHEDULE_DATA_ENTRIES], const size_t cbArray);
    CConnectionScheduleDlg(CWnd* pParent);   // standard constructor

    virtual int GetIDD ()
    {
        return IDD;
    }

// Dialog Data
    //{{AFX_DATA(CConnectionScheduleDlg)
    enum { IDD = IDD_DS_SCHEDULE };
    CButton m_buttonNone;
    CButton m_buttonOne;
    CButton m_buttonTwo;
    CButton m_buttonFour;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConnectionScheduleDlg)
    public:
    virtual void OnFinalRelease();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual void TimeChange();
    virtual UINT GetExpectedArrayLength();
    virtual BYTE GetMatrixPercentage(UINT nHour, UINT nDay);
    virtual UINT GetPercentageToSet (const BYTE bData);
    virtual void InitMatrix ();

    // Generated message map functions
    //{{AFX_MSG(CConnectionScheduleDlg)
    afx_msg void OnRadioFour();
    afx_msg void OnRadioNone();
    afx_msg void OnRadioOne();
    afx_msg void OnRadioTwo();
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CConnectionScheduleDlg)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()

    CLegendCell m_legendNone;
    CLegendCell m_legendOne;
    CLegendCell m_legendTwo;
    CLegendCell m_legendFour;

    virtual void UpdateButtons ();
private:
    BYTE* m_prgbData168;
};


/////////////////////////////////////////////////////////////////////////////
// CReplicationScheduleDlg dialog

class CReplicationScheduleDlg : public CScheduleBaseDlg
{
// Construction
public:
    CReplicationScheduleDlg(CWnd* pParent);   // standard constructor

    void SetConnectionByteArray (INOUT BYTE rgbData[SCHEDULE_DATA_ENTRIES], const size_t cbArray);

    virtual int GetIDD ()
    {
        return IDD;
    }

// Dialog Data
    //{{AFX_DATA(CReplicationScheduleDlg)
    enum { IDD = IDD_REPLICATION_SCHEDULE };
    CButton m_buttonNone;
    CButton m_buttonFour;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CReplicationScheduleDlg)
    public:
    virtual void OnFinalRelease();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual void TimeChange();
    virtual UINT GetExpectedArrayLength();
    virtual BYTE GetMatrixPercentage(UINT nHour, UINT nDay);
    virtual UINT GetPercentageToSet (const BYTE bData);
    virtual void InitMatrix ();

    // Generated message map functions
    //{{AFX_MSG(CReplicationScheduleDlg)
    afx_msg void OnRadioFour();
    afx_msg void OnRadioNone();
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CReplicationScheduleDlg)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()

    CLegendCell m_legendNone;
    CLegendCell m_legendFour;

    virtual void UpdateButtons ();
private:
    BYTE* m_prgbData168;
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCHEDDLG_H__701CFB37_AEF8_11D1_9864_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\schedmat.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       Schedmat.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// schedmat.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"

#include "schedmat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


typedef HRESULT (WINAPI * PFNCREATESTDACCESSIBLEOBJECT)(HWND, LONG, REFIID, void **);
typedef HRESULT (WINAPI * PFNCREATESTDACCESSIBLEPROXY)(HWND, LPCTSTR, LONG, REFIID, void **);
typedef LRESULT (WINAPI * PFNLRESULTFROMOBJECT)(REFIID, WPARAM, LPUNKNOWN);

PFNCREATESTDACCESSIBLEOBJECT s_pfnCreateStdAccessibleObject = 0;
PFNCREATESTDACCESSIBLEPROXY s_pfnCreateStdAccessibleProxy = NULL;
PFNLRESULTFROMOBJECT s_pfnLresultFromObject = NULL;

BOOL g_fAttemptedOleAccLoad ;
HMODULE g_hOleAcc;

/////////////////////////////////////////////////////////////////////////////
// CMatrixCell

IMPLEMENT_DYNAMIC(CMatrixCell, CObject)

//****************************************************************************
//
//  CMatrixCell::CMatrixCell
//
//****************************************************************************
CMatrixCell::CMatrixCell()
{
    m_crBackColor = DEFBACKCOLOR;
    m_crForeColor = DEFFORECOLOR;
    m_nPercentage = 0;

    m_crBlendColor = DEFBLENDCOLOR;

    m_dwUserValue = 0;
    m_pUserDataPtr = NULL;

    m_dwFlags = 0;
}

//****************************************************************************
//
//  CMatrixCell::~CMatrixCell
//
//****************************************************************************
CMatrixCell::~CMatrixCell()
{
}

/////////////////////////////////////////////////////////////////////////////
// CScheduleMatrix

IMPLEMENT_DYNAMIC(CScheduleMatrix, CWnd)

//****************************************************************************
//
//  CScheduleMatrix::CScheduleMatrix
//
//****************************************************************************
CScheduleMatrix::CScheduleMatrix() :
    m_pWrapAcc (0)
{
    SetType(MT_WEEKLY);

    m_hFont = NULL;

    m_nSelHour = m_nSelDay = m_nNumSelHours = m_nNumSelDays = 0;
    m_nSaveHour = m_nSaveDay = m_nNumSaveHours = m_nNumSaveDays = 0;

    m_bShifted = FALSE;
}

//****************************************************************************
//
//  CScheduleMatrix::CScheduleMatrix
//
//****************************************************************************
CScheduleMatrix::CScheduleMatrix(UINT nType) :
    m_pWrapAcc (0)
{
    SetType(nType);

    m_hFont = NULL;

    m_nSelHour = m_nSelDay = m_nNumSelHours = m_nNumSelDays = 0;
    m_nSaveHour = m_nSaveDay = m_nNumSaveHours = m_nNumSaveDays = 0;

    m_bShifted = FALSE;
}

//****************************************************************************
//
//  CScheduleMatrix::~CScheduleMatrix
//
//****************************************************************************
CScheduleMatrix::~CScheduleMatrix()
{
    if ( m_pWrapAcc )
    {
        ::CoDisconnectObject (m_pWrapAcc, 0);
        m_pWrapAcc->Release ();
        m_pWrapAcc = 0;
    }

    if (g_hOleAcc)
    {
        ::FreeLibrary(g_hOleAcc);
        g_hOleAcc = NULL;
    }
}

BEGIN_MESSAGE_MAP(CScheduleMatrix, CWnd)
    //{{AFX_MSG_MAP(CScheduleMatrix)
    ON_WM_CREATE()
    ON_WM_SIZE()
    ON_WM_PAINT()
    ON_WM_SETFOCUS()
    ON_WM_KILLFOCUS()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_LBUTTONDBLCLK()
    ON_WM_MOUSEMOVE()
    ON_WM_GETDLGCODE()
    ON_WM_KEYDOWN()
    ON_WM_KEYUP()
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_SETFONT, OnSetFont)
    ON_MESSAGE(WM_GETFONT, OnGetFont)
    ON_MESSAGE(WM_GETOBJECT, OnGetObject)
    ON_MESSAGE(SCHEDMSG_GETSELDESCRIPTION, OnGetSelDescription)
    ON_MESSAGE(SCHEDMSG_GETPERCENTAGE, OnGetPercentage)
END_MESSAGE_MAP()

//****************************************************************************
//
//  CScheduleMatrix::Create
//
//****************************************************************************
BOOL CScheduleMatrix::Create(LPCTSTR lpszWindowName, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* /*pContext*/)
{
    CRect r(0,0,0,0);
    if (!m_HourLegend.Create(NULL, _T(""), WS_CHILD | WS_VISIBLE, r, pParentWnd, (UINT) -1, NULL))
        return FALSE;
    if (!m_PercentLabel.Create(NULL, _T(""), WS_CHILD | WS_VISIBLE, r, pParentWnd, (UINT) -1, NULL))
        return FALSE;

    m_PercentLabel.m_pMatrix = this;

    return CWnd::Create(NULL, lpszWindowName, WS_CHILD | WS_VISIBLE | WS_TABSTOP,
        rect, pParentWnd, nID, NULL);
}

/////////////////////////////////////////////////////////////////////////////
// CScheduleMatrix message handlers

//****************************************************************************
//
//  CScheduleMatrix::OnSize
//
//****************************************************************************
void CScheduleMatrix::OnSize(UINT nType, int cx, int cy)
{
    CWnd::OnSize(nType, cx, cy);

    SetMatrixMetrics(cx, cy);

    Invalidate();
}

//****************************************************************************
//
//  CScheduleMatrix::SetMatrixMetrics
//
//****************************************************************************
void CScheduleMatrix::SetMatrixMetrics(int cx, int cy)
{
    if (m_hWnd == NULL)
        return;

    CDC *pdc = GetDC();
    CFont *pOldFont = NULL;
    CFont *pFont = CFont::FromHandle(m_hFont);

    if (pFont != NULL)
        pOldFont = pdc->SelectObject(pFont);

    // Calculate some useful metrics
    int i;
    int nRows = (m_nType==MT_DAILY ? 1 : 8); // 8 rows = 7 days + header
    CSize size = pdc->GetTextExtent(_T("0"));
    int nCharHeight = size.cy;
    int nCharWidth = size.cx;
    int nDayWidth = 0;
    for (i=0; i<8; i++)
    {
        size = pdc->GetTextExtent(m_DayStrings[i]);
        nDayWidth = max(nDayWidth, size.cx + 2*nCharWidth);
        // If daily schedule, stop after first
        if (m_nType == MT_DAILY)
            break;
    }

    if (pOldFont != NULL)
        pdc->SelectObject(pOldFont);

    ReleaseDC(pdc);

    nDayWidth = max(nDayWidth, 2*nCharWidth);

    int nLegendHeight = nCharHeight + 4 + 16; // a little margin over char height plus icon height
    int nLabelHeight = (m_nType == MT_DAILY ? nCharHeight + 4 : 0);

    // Cell array should fill space after hour legend and %labels...
    int nBtnHeight = max(0, cy-nLegendHeight-nLabelHeight)/nRows;
    // ... but should at least accomodate label text and some margin
    nBtnHeight = max(nBtnHeight, nCharHeight + 4);

    m_nCellWidth = max(0, (cx - nDayWidth)/24);
    m_nCellHeight = nBtnHeight;

    // Leave an extra pixel for the lower right cell border
    int nArrayWidth = 24*m_nCellWidth + 1;
    int nArrayHeight = (m_nType==MT_DAILY ? 1 : 7)*m_nCellHeight + 1;

    // Adjust header width to absorb roundoff from cells
    nDayWidth = max(0, cx - nArrayWidth);
    // Adjust legend height to absorb roundoff from cells
    nLegendHeight = max(0,
        cy - (nArrayHeight + (m_nType==MT_DAILY ? 0 : nBtnHeight)) - nLabelHeight);

    m_rHourLegend.SetRect(0, 0, cx, nLegendHeight);
    if (m_nType == MT_DAILY)
    {
        m_rAllHeader.SetRect(0, nLegendHeight, nDayWidth, nLegendHeight+nBtnHeight);
        m_rHourHeader.SetRect(0,0,0,0);
        m_rDayHeader.SetRect(0,0,0,0);
        m_rCellArray.SetRect(nDayWidth, nLegendHeight, cx, cy-nLabelHeight);
        m_rPercentLabel.SetRect(0,cy-nLabelHeight,cx,cy);
    }
    else
    {
        m_rAllHeader.SetRect(0, nLegendHeight, nDayWidth, nLegendHeight+nBtnHeight);
        m_rHourHeader.SetRect(nDayWidth, nLegendHeight, cx, nLegendHeight+nBtnHeight);
        m_rDayHeader.SetRect(0, nLegendHeight+nBtnHeight, nDayWidth, cy);
        m_rCellArray.SetRect(nDayWidth, nLegendHeight + nBtnHeight, cx, cy);
        m_rPercentLabel.SetRect(0,0,0,0);
    }

    // Move the hour legend window into place
    if (m_HourLegend.GetSafeHwnd() != NULL)
    {
        CRect rHourLegend = m_rHourLegend;
        ClientToScreen(rHourLegend);
        GetParent()->ScreenToClient(rHourLegend);
        rHourLegend.right += nCharWidth;
        m_HourLegend.MoveWindow(rHourLegend);
        m_HourLegend.m_nCharHeight = nCharHeight;
        m_HourLegend.m_nCharWidth = nCharWidth;
        m_HourLegend.m_nCellWidth = m_nCellWidth;
        m_HourLegend.m_hFont = m_hFont;
        m_HourLegend.m_rLegend.SetRect(m_rCellArray.left, 0, m_rCellArray.right,
            nLegendHeight);
    }

    // Move the % label window into place
    if (m_PercentLabel.GetSafeHwnd() != NULL)
    {
        CRect rPercentLabel = m_rPercentLabel;
        ClientToScreen(rPercentLabel);
        GetParent()->ScreenToClient(rPercentLabel);
        m_PercentLabel.MoveWindow(rPercentLabel);
        m_PercentLabel.m_nCellWidth = m_nCellWidth;
        m_PercentLabel.m_hFont = m_hFont;
        m_PercentLabel.m_rHeader.SetRect(m_rAllHeader.left, 0, m_rAllHeader.right,
            nLabelHeight);
        m_PercentLabel.m_rLabels.SetRect(m_rCellArray.left, 0, m_rCellArray.right,
            nLabelHeight);
    }
}

//****************************************************************************
//
//  CScheduleMatrix::OnPaint
//
//****************************************************************************
void CScheduleMatrix::OnPaint()
{
    int i, j, x, y;
    CRect r, r2;
    BOOL bPressed;

    CPaintDC dc(this); // device context for painting

    CFont *pOldFont = NULL;
    CFont *pFont = CFont::FromHandle(m_hFont);

    if (pFont != NULL)
        pOldFont = dc.SelectObject(pFont);

    CBrush brFace(::GetSysColor(COLOR_3DFACE));
    CPen penFace(PS_SOLID, 0, ::GetSysColor(COLOR_3DFACE));

    CBrush *pbrOld = dc.SelectObject(&brFace);
    CPen *ppenOld = dc.SelectObject(&penFace);
    COLORREF crBkOld = dc.GetBkColor();
    COLORREF crTextOld = dc.GetTextColor();

    // Draw the All header

    if (GetCapture() == this && m_rAllHeader.PtInRect(m_ptDown))
        bPressed = TRUE;
    else
        bPressed = FALSE;
    DrawHeader(&dc, m_rAllHeader, m_DayStrings[0], bPressed);

    // Draw the hour header

    if (!m_rHourHeader.IsRectEmpty())
    {
        // First hour is special case
        r.SetRect(m_rHourHeader.left, m_rHourHeader.top,
            m_rHourHeader.left+m_nCellWidth+1, m_rHourHeader.bottom);
        if (GetCapture() == this && m_rHourHeader.PtInRect(m_ptDown) && CellInSel(0,0))
            bPressed = TRUE;
        else
            bPressed = FALSE;
        DrawHeader(&dc, r, NULL, bPressed);
        r = m_rHourHeader;
        r.left += 1;
        r.right = r.left + m_nCellWidth;
        for (i=1; i<24; i++)
        {
            r.OffsetRect(m_nCellWidth, 0);
            if (GetCapture() == this && m_rHourHeader.PtInRect(m_ptDown) && CellInSel(i,0))
                bPressed = TRUE;
            else
                bPressed = FALSE;
            DrawHeader(&dc, r, NULL, bPressed);
        }
    }

    // Draw the day header

    if (!m_rDayHeader.IsRectEmpty())
    {
        // First day is special case
        r.SetRect(m_rDayHeader.left, m_rDayHeader.top,
            m_rDayHeader.right, m_rDayHeader.top+m_nCellHeight+1);
        if (GetCapture() == this && m_rDayHeader.PtInRect(m_ptDown) && CellInSel(0,0))
            bPressed = TRUE;
        else
            bPressed = FALSE;
        DrawHeader(&dc, r, m_DayStrings[1], bPressed);
        r = m_rDayHeader;
        r.top += 1;
        r.bottom = r.top + m_nCellHeight;
        for (i=2; i<8; i++)
        {
            r.OffsetRect(0, m_nCellHeight);
            if (GetCapture() == this && m_rDayHeader.PtInRect(m_ptDown) && CellInSel(0,i-1))
                bPressed = TRUE;
            else
                bPressed = FALSE;
            DrawHeader(&dc, r, m_DayStrings[i], bPressed);
        }
    }

    // Draw the cell array

    int nDays = (m_nType==MT_DAILY ? 1 : 7);
    y = m_rCellArray.top;
    for (j=0; j<nDays; j++)
    {
        x = m_rCellArray.left;
        for (i=0; i<24; i++)
        {
            DrawCell(&dc, &m_CellArray[i][j], x, y, m_nCellWidth, m_nCellHeight);
            x += m_nCellWidth;
        }
        y += m_nCellHeight;
    }

    dc.SetBkColor(crBkOld);
    dc.SetTextColor(crTextOld);

    // Draw the lower right cell borders since no cell takes responsibility for it
    dc.MoveTo(m_rCellArray.left, m_rCellArray.bottom-1);
    dc.LineTo(m_rCellArray.right-1, m_rCellArray.bottom-1);
    dc.LineTo(m_rCellArray.right-1, m_rCellArray.top-1);

    // Draw selection indicator (hardwired black and white for max contrast).
    if (m_nNumSelHours != 0 && m_nNumSelDays != 0)
    {
        CRect rSel(m_nSelHour, m_nSelDay, m_nSelHour+m_nNumSelHours, m_nSelDay+m_nNumSelDays);
        CellToClient(rSel.left, rSel.top);
        CellToClient(rSel.right, rSel.bottom);
        rSel.right+=1;
        rSel.bottom+=1;
        CBrush brBlack(RGB(0,0,0)), brWhite(RGB(255,255,255));
        dc.FrameRect(rSel, &brBlack);
        if (GetFocus()==this)
            dc.DrawFocusRect(rSel);
        rSel.InflateRect(-1,-1);
        dc.FrameRect(rSel, &brBlack);
        rSel.InflateRect(-1,-1);
        dc.FrameRect(rSel, &brWhite);
    }

    if (pbrOld != NULL)
        dc.SelectObject(pbrOld);
    if (ppenOld != NULL)
        dc.SelectObject(ppenOld);
    
    if (pOldFont != NULL)
        dc.SelectObject(pOldFont);

    // Do not call CWnd::OnPaint() for painting messages
}

//****************************************************************************
//
//  CScheduleMatrix::CellToClient
//
//****************************************************************************
void CScheduleMatrix::CellToClient(LONG &nX, LONG &nY)
{
    nX = nX*m_nCellWidth + m_rCellArray.left;
    nY = nY*m_nCellHeight + m_rCellArray.top;
}

//****************************************************************************
//
//  CScheduleMatrix::ClientToCell
//
//****************************************************************************
void CScheduleMatrix::ClientToCell(LONG &nX, LONG &nY)
{
    nX = max(nX, m_rCellArray.left);
    nX = min(nX, m_rCellArray.right);
    nY = max(nY, m_rCellArray.top);
    nY = min(nY, m_rCellArray.bottom);
    nX = (nX-m_rCellArray.left)/m_nCellWidth;
    nY = (nY-m_rCellArray.top)/m_nCellHeight;
    nX = min(nX, 23);
    nY = min(nY, (m_nType == MT_DAILY ? 0 : 6));
}

//****************************************************************************
//
//  CScheduleMatrix::GetCellSize
//
//****************************************************************************
CSize CScheduleMatrix::GetCellSize()
{
    SIZE size;
    size.cx = m_nCellWidth;
    size.cy = m_nCellHeight;
    return size;
}

//****************************************************************************
//
//  CScheduleMatrix::DrawCell
//
//****************************************************************************
void CScheduleMatrix::DrawCell(CDC *pdc, LPCRECT pRect, UINT nPercent, BOOL bBlendState,
    COLORREF crBackColor, COLORREF crForeColor, COLORREF crBlendColor)
{
    if ( !pdc || !pRect )
        return;

    CRect r(pRect);
    CMatrixCell Cell;

    // FUTURE-2002/02/18-artm  Document that pdc cannot be NULL.

    // NOTICE-NTRAID#NTBUG9-547574-2002/02/18-artm   Need to validate that nPercent <= 100 in release build.
    //
    // A simple robust solution would be to set invalid values to 0 or 100.
    ASSERT(nPercent <= 100);
    if ( nPercent > 100 )
        nPercent = 100;
        
    Cell.m_nPercentage = nPercent;
//??
    Cell.m_dwFlags = MC_MERGELEFT | MC_MERGETOP;
    if (bBlendState)
        Cell.m_dwFlags |= MC_BLEND;
    Cell.m_crBackColor = crBackColor;
    Cell.m_crForeColor = crForeColor;
    Cell.m_crBlendColor = crBlendColor;

    CBrush brFace(::GetSysColor(COLOR_3DFACE));
    CPen penFace(PS_SOLID, 0, ::GetSysColor(COLOR_3DFACE));

    CBrush *pbrOld = pdc->SelectObject(&brFace);
    CPen *ppenOld = pdc->SelectObject(&penFace);
    COLORREF crBkOld = pdc->GetBkColor();
    COLORREF crTextOld = pdc->GetTextColor();

    DrawCell(pdc, &Cell, r.left, r.top, r.Width(), r.Height());

    pdc->SetBkColor(crBkOld);
    pdc->SetTextColor(crTextOld);

    // Draw the lower right cell border since cell doesn't take responsibility for it
    /* //??
    pdc->MoveTo(r.left, r.bottom-1);
    pdc->LineTo(r.right-1, r.bottom-1);
    pdc->LineTo(r.right-1, r.top-1);
    */

    if (pbrOld != NULL)
        pdc->SelectObject(pbrOld);
    if (ppenOld != NULL)
        pdc->SelectObject(ppenOld);
}

//****************************************************************************
//
//  CScheduleMatrix::DrawCell
//
//****************************************************************************
void CScheduleMatrix::DrawCell(CDC *pdc, CMatrixCell *pCell, int x, int y, int w, int h)
{
    if ( !pdc || !pCell )
        return;

    int x1 = 0;
    int y1 = 0;
    int nPercent = 0;
    CRect rBack;
    CRect rFore;
    CRect rBlend;
    CRect rClip;
    CRect rCell;
    CRect rWork;

    // Don't bother if not invalid
    pdc->GetClipBox(rClip);
    rCell.SetRect(x,y,x+w,y+h);
    if (!rWork.IntersectRect(rClip, rCell))
        return;

    // Calculate portions to devote to fore/back colors
    // Account for merge effect
    nPercent = MulDiv(pCell->m_nPercentage, h-(pCell->m_dwFlags & MC_MERGETOP?0:1), 100);
    if (pCell->m_dwFlags & MC_MERGELEFT)
    {
        x1 = x;
    }
    else
    {
        x1 = x + 1;
        pdc->MoveTo(x, y);
        pdc->LineTo(x, y+h);
    }
    if (pCell->m_dwFlags & MC_MERGETOP)
    {
        y1 = y;
    }
    else
    {
        y1 = y + 1;
        pdc->MoveTo(x, y);
        pdc->LineTo(x+w, y);
    }
    rBack.SetRect(x1, y1, x+w, y+h-nPercent);
    rFore.SetRect(x1, rBack.bottom, x+w, y+h);
    rBlend.SetRect(x1, y1, x+w, y+h);

    // Ensure a touch of color at the boundaries
    if (rBack.Height() == 0 && pCell->m_nPercentage != 100)
    {
        rBack.bottom+=1;
        rFore.top+=1;
    }
    if (rFore.Height() == 0 && pCell->m_nPercentage != 0)
    {
        rBack.bottom-=1;
        rFore.top-=1;
    }

    // Draw the histogram
    CBrush brBack(pCell->m_crBackColor);
    CBrush brFore(pCell->m_crForeColor);
    pdc->FillRect(rBack, &brBack);
    pdc->FillRect(rFore, &brFore);

    // Overlay the blend color
    if (pCell->m_dwFlags & MC_BLEND)
    {
        // Create the GDI work objects if necessary
        if (m_bmBlend.GetSafeHandle() == NULL)
        {
            SHORT BlendBits[] = {0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55};
            SHORT MaskBits[] = {0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA};
            m_bmBlend.CreateBitmap(8,8,1,1, BlendBits);
            m_bmMask.CreateBitmap(8,8,1,1, MaskBits);
            m_brBlend.CreatePatternBrush(&m_bmBlend);
            m_brMask.CreatePatternBrush(&m_bmMask);
        }

        pdc->SetTextColor(RGB(0,0,0));

        // Mask out the existing bits in the cell
        pdc->SetBkColor(RGB(255,255,255));
        pdc->SelectObject(&m_brMask);
        pdc->PatBlt(rBlend.left, rBlend.top, rBlend.Width(), rBlend.Height(), 0x00A000C9); //DPa

        // Add the blend color into the masked pixels
        pdc->SetBkColor(pCell->m_crBlendColor);
        pdc->SelectObject(&m_brBlend);
        pdc->PatBlt(rBlend.left, rBlend.top, rBlend.Width(), rBlend.Height(), 0x00FA0089); //DPo
    }
}

//****************************************************************************
//
//  CScheduleMatrix::DrawHeader
//
//****************************************************************************
void CScheduleMatrix::DrawHeader(CDC *pdc, LPCRECT lpRect, LPCTSTR pszText, BOOL bSelected)
{
    if ( !pdc || !lpRect )
        return;

    CBrush brFace(::GetSysColor(COLOR_3DFACE));
    COLORREF crTL, crBR;
    COLORREF crBkOld = pdc->GetBkColor();
    COLORREF crTextOld = pdc->GetTextColor();

    if (bSelected)
    {
        crTL = ::GetSysColor(COLOR_3DSHADOW);
        crBR = ::GetSysColor(COLOR_3DHIGHLIGHT);
    }
    else
    {
        crTL = ::GetSysColor(COLOR_3DHIGHLIGHT);
        crBR = ::GetSysColor(COLOR_3DSHADOW);
    }

    pdc->FillRect(lpRect, &brFace);
    pdc->Draw3dRect(lpRect, crTL, crBR);
    pdc->SetBkColor(::GetSysColor(COLOR_3DFACE));
    pdc->SetTextColor(::GetSysColor(COLOR_BTNTEXT));
    if (pszText != NULL)
        ::DrawTextEx(pdc->GetSafeHdc(), (LPTSTR)pszText, -1, (LPRECT)lpRect,
            DT_SINGLELINE | DT_CENTER | DT_VCENTER | DT_END_ELLIPSIS, NULL);

    pdc->SetBkColor(crBkOld);
    pdc->SetTextColor(crTextOld);
}

//****************************************************************************
//
//  CScheduleMatrix::OnSetFont
//
//****************************************************************************
LRESULT CScheduleMatrix::OnSetFont( WPARAM wParam, LPARAM lParam )
{
    m_hFont = (HFONT)wParam;
    m_HourLegend.m_hFont = m_hFont;

    CRect rClient;
    GetClientRect(rClient);
    SetMatrixMetrics(rClient.Width(), rClient.Height());
    Invalidate();

    if (HIWORD(lParam) != 0)
        UpdateWindow();

    return 0L;
}

//****************************************************************************
//
//  CScheduleMatrix::OnGetFont
//
//****************************************************************************
LRESULT CScheduleMatrix::OnGetFont( WPARAM /*wParam*/, LPARAM /*lParam*/ )
{
    return (LRESULT)m_hFont;
}


//****************************************************************************
//
//  CScheduleMatrix::SetSelValues
//
//****************************************************************************
BOOL CScheduleMatrix::SetSelValues(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    // Deselect allows "illegal" values

    if (!(nHour == 0 && nDay == 0 && nNumHours == 0 && nNumDays == 0))
    {
        UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
        ASSERT(nHour < 24);
        ASSERT(nDay < nDays);
        ASSERT(nNumHours>=1);
        ASSERT(nNumDays>=1);
        ASSERT(nHour + nNumHours <= 24);
        ASSERT(nDay + nNumDays <= nDays);
    }

    if (m_nSelHour != nHour || m_nSelDay != nDay ||
        m_nNumSelHours != nNumHours || m_nNumSelDays != nNumDays)
    {
        InvalidateCells(m_nSelHour, m_nSelDay, m_nNumSelHours, m_nNumSelDays, FALSE);

        m_nSelHour = nHour;
        m_nSelDay = nDay;
        m_nNumSelHours = nNumHours;
        m_nNumSelDays = nNumDays;

        InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);

        return TRUE;
    }

    return FALSE;
}

//****************************************************************************
//
//  CScheduleMatrix::SetSel
//
//****************************************************************************
BOOL CScheduleMatrix::SetSel(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    if (SetSelValues(nHour, nDay, nNumHours, nNumDays))
    {
        UpdateWindow();

        m_ptDown.x = nHour;
        m_ptDown.y = nDay;
        CellToClient(m_ptDown.x, m_ptDown.y);
        m_ptFocus.x = nHour + nNumHours - 1;
        m_ptFocus.y = nDay + nNumDays - 1;
        CellToClient(m_ptFocus.x, m_ptFocus.y);

        return TRUE;
    }

    return FALSE;
}

//****************************************************************************
//
//  CScheduleMatrix::SelectAll
//
//****************************************************************************
BOOL CScheduleMatrix::SelectAll()
{
    if (m_nType == MT_DAILY)
        return SetSel(0,0,23,1);

    return SetSel(0,0,23,7);
}

//****************************************************************************
//
//  CScheduleMatrix::DeselectAll
//
//****************************************************************************
BOOL CScheduleMatrix::DeselectAll()
{
    return SetSel(0,0,0,0);
}

//****************************************************************************
//
//  CScheduleMatrix::GetSel
//
//****************************************************************************
void CScheduleMatrix::GetSel(UINT & nHour, UINT & nDay, UINT & nNumHours, UINT & nNumDays)
{
    nHour = m_nSelHour;
    nDay = m_nSelDay;
    nNumHours = m_nNumSelHours;
    nNumDays = m_nNumSelDays;
}

//****************************************************************************
//
//  CScheduleMatrix::GetSelDescription
//
//****************************************************************************
void CScheduleMatrix::GetSelDescription(CString &sText)
{
    GetDescription(sText, m_nSelHour, m_nSelDay, m_nNumSelHours, m_nNumSelDays);
}


//****************************************************************************
//
//  CScheduleMatrix::FormatTime
//
//****************************************************************************
CString CScheduleMatrix::FormatTime(UINT nHour) const
{
    CString sTime;

    SYSTEMTIME  sysTime;
    ::ZeroMemory (&sysTime, sizeof (SYSTEMTIME));

    // Make sure that nHour is 0 to 24
    nHour = nHour % 24;
    sysTime.wHour = (WORD)nHour;

    // Get first time
    // Get length to allocate buffer of sufficient size
    int iLen = ::GetTimeFormat (
            LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
            TIME_NOSECONDS, //TIME_NOMINUTESORSECONDS, // flags specifying function options 
            &sysTime, // date to be formatted 
            0, // date format string 
            0, // buffer for storing formatted string 
            0); // size of buffer 
    ASSERT (iLen > 0);
    if ( iLen > 0 )
    {
        // NOTICE-2002/02/18-artm   CString sTime can throw out of memory exception.
        //
        // There is no good way to handle low memory situations at this level.
        // Responsibility of caller to handle.
        int iResult = ::GetTimeFormat (
                LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
                TIME_NOSECONDS, //TIME_NOMINUTESORSECONDS, // flags specifying function options 
                &sysTime, // date to be formatted 
                0, // date format string 
                sTime.GetBufferSetLength (iLen), // buffer for storing formatted string 
                iLen); // size of buffer 
        ASSERT (iResult);
        sTime.ReleaseBuffer ();
    }

    return sTime;
}

//****************************************************************************
//
//  CScheduleMatrix::GetDescription
//
//****************************************************************************
void CScheduleMatrix::GetDescription(CString &sText, UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    CString sDay1;
    CString sDay2;
    CString sHour1;
    CString sHour2;

    // NOTICE-2002/02/18-artm  CString can throw out of memory exceptions.
    // No good way to handle at this level; responsibility of caller to handle.
    if (nNumDays == 0 || nNumHours == 0)
    {
        sText.Empty();
        return;
    }

    // Get day strings
    sDay1 = m_DayStrings[nDay + 1];
    sDay2 = m_DayStrings[nDay + nNumDays];

    // Get time strings
    if ( sHour1.IsEmpty () )
        sHour1 = L"Error";

    // Get first time
    sHour1 = FormatTime (nHour);

    // Get second time
    sHour2 = FormatTime (nHour + nNumHours);

    if (m_nType == MT_DAILY)
    {
        sText.FormatMessage(IDS_TOOL_SCHEDULE_FMT_DAILY, (LPCTSTR)sHour1, (LPCTSTR)sHour2);
    }
    else
    {
        if (nNumDays == 1)
            sText.FormatMessage(IDS_TOOL_SCHEDULE_FMT_WEEKLY_SHORT, (LPCTSTR)sDay1,
                (LPCTSTR)sHour1, (LPCTSTR)sHour2);
        else
            sText.FormatMessage(IDS_TOOL_SCHEDULE_FMT_WEEKLY_LONG,
                (LPCTSTR)sDay1, (LPCTSTR)sDay2, (LPCTSTR)sHour1, (LPCTSTR)sHour2);
    }
}


//****************************************************************************
//
//  CScheduleMatrix::CellInSel
//
//****************************************************************************
BOOL CScheduleMatrix::CellInSel(UINT nHour, UINT nDay)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    // ASSERT()'s are early bug catching.  The implementation handles days and hours
    // that are out of range by returning FALSE.
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);

    if (m_nNumSelHours == 0 || m_nNumSelDays == 0)
        return FALSE;
    if (nHour < m_nSelHour || nHour >= m_nSelHour + m_nNumSelHours)
        return FALSE;
    if (nDay < m_nSelDay || nDay >= m_nSelDay + m_nNumSelDays)
        return FALSE;

    return TRUE;
}

//****************************************************************************
//
//  CScheduleMatrix::SetType
//
//****************************************************************************
void CScheduleMatrix::SetType(UINT nType)
{
    ASSERT(nType == MT_DAILY || nType == MT_WEEKLY);


    VERIFY (m_DayStrings[0].LoadString (IDS_ALL_HEADER_TEXT)); // "All" header
 
    int nFirstDay = GetFirstDayOfWeek ();    
    // Day names start at index 1
    int nIndex = 1;
    for (int nDay = nFirstDay; nDay < nFirstDay+7 && nIndex <= 7; nDay++, nIndex++)
    {
        int localeDay = nDay < 7 ? nDay : nDay - 7;
        
        LCTYPE  lctDays[7] = {LOCALE_SDAYNAME1, LOCALE_SDAYNAME2,
                    LOCALE_SDAYNAME3, LOCALE_SDAYNAME4, LOCALE_SDAYNAME5,
                    LOCALE_SDAYNAME6, LOCALE_SDAYNAME7};

        ASSERT (localeDay >= 0 && localeDay <= 6);
        m_DayStrings[nIndex] = GetLocaleDay (lctDays[localeDay]); 
    }

    m_nType = nType;
}


//****************************************************************************
//
//  CScheduleMatrix::GetLocaleDay
//
//  Use the locale API to get the "official" days of the week.
//
//****************************************************************************
CString CScheduleMatrix::GetLocaleDay (LCTYPE lcType) const
{
    // NOTICE-2002/02/18-artm  CString can throw out of memory exceptions.
    // No good way to handle at this level; responsibility of caller to handle.
    CString dayName;
    int     cchData = 64;
    int     iResult = 0;

    do {

        iResult = GetLocaleInfo(
                LOCALE_USER_DEFAULT,    // locale identifier
                lcType,       // information type
                const_cast <PWSTR>((PCWSTR) dayName.GetBufferSetLength (cchData)),  // information buffer
                cchData);       // size of buffer
        dayName.ReleaseBuffer ();
        if ( !iResult )
        {
            DWORD   dwErr = GetLastError ();
            switch (dwErr)
            {
            case ERROR_INSUFFICIENT_BUFFER:
                cchData += 64;
                break;

            default:
                ASSERT (0);
                switch (lcType)
                {
                case LOCALE_SDAYNAME1:
                    VERIFY (dayName.LoadString (IDS_MONDAY));
                    break;

                case LOCALE_SDAYNAME2:
                    VERIFY (dayName.LoadString (IDS_TUESDAY));
                    break;

                case LOCALE_SDAYNAME3:
                    VERIFY (dayName.LoadString (IDS_WEDNESDAY));
                    break;

                case LOCALE_SDAYNAME4:
                    VERIFY (dayName.LoadString (IDS_THURSDAY));
                    break;

                case LOCALE_SDAYNAME5:
                    VERIFY (dayName.LoadString (IDS_FRIDAY));
                    break;

                case LOCALE_SDAYNAME6:
                    VERIFY (dayName.LoadString (IDS_SATURDAY));
                    break;

                case LOCALE_SDAYNAME7:
                    VERIFY (dayName.LoadString (IDS_SUNDAY));
                    break;

                default:
                    ASSERT (0);
                    break;
                }
                break;
            }
        }
    } while (!iResult);

    return dayName;
}


//****************************************************************************
//
//  CScheduleMatrix::SetBackColor
//
//****************************************************************************
void CScheduleMatrix::SetBackColor(COLORREF crColor, UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            m_CellArray[nHour+i][nDay+j].m_crBackColor = crColor;
        }
    }

    InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::SetForeColor
//
//****************************************************************************
void CScheduleMatrix::SetForeColor(COLORREF crColor, UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            m_CellArray[nHour+i][nDay+j].m_crForeColor = crColor;
        }
    }

    InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::SetPercentage
//
//****************************************************************************
void CScheduleMatrix::SetPercentage(UINT nPercent, UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);
    ASSERT(nPercent <= 100);

    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            m_CellArray[nHour+i][nDay+j].m_nPercentage = nPercent;
        }
    }

    InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::SetBlendColor
//
//****************************************************************************
void CScheduleMatrix::SetBlendColor(COLORREF crColor, UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            m_CellArray[nHour+i][nDay+j].m_crBlendColor = crColor;
        }
    }

    InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::SetBlendState
//
//****************************************************************************
void CScheduleMatrix::SetBlendState(BOOL bState, UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            if (bState)
                m_CellArray[nHour+i][nDay+j].m_dwFlags |= MC_BLEND;
            else
                m_CellArray[nHour+i][nDay+j].m_dwFlags &= (MC_BLEND^0xFFFFFFFF);
        }
    }

    InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::SetUserValue
//
//****************************************************************************
void CScheduleMatrix::SetUserValue(DWORD dwValue, UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            m_CellArray[nHour+i][nDay+j].m_dwUserValue = dwValue;
        }
    }

    //?? If we ever have ownerdraw
    //?? InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::SetUserDataPtr
//
//****************************************************************************
void CScheduleMatrix::SetUserDataPtr(void * lpData, UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            m_CellArray[nHour+i][nDay+j].m_pUserDataPtr = lpData;
        }
    }

    //?? If we ever have ownerdraw
    //?? InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::MergeCells
//
//****************************************************************************
void CScheduleMatrix::MergeCells(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    DWORD dwFlags;
    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            dwFlags = m_CellArray[nHour+i][nDay+j].m_dwFlags;
            dwFlags |= MC_MERGE;
            dwFlags &= (MC_ALLEDGES^0xFFFFFFFF);
            if (i != 0)
                dwFlags |= MC_MERGELEFT;
            if (i == 0)
                dwFlags |= MC_LEFTEDGE;
            if (i == nNumHours-1)
                dwFlags |= MC_RIGHTEDGE;
            if (j != 0)
                dwFlags |= MC_MERGETOP;
            if (j == 0)
                dwFlags |= MC_TOPEDGE;
            if (j == nNumDays-1)
                dwFlags |= MC_BOTTOMEDGE;
            m_CellArray[nHour+i][nDay+j].m_dwFlags = dwFlags;
        }
    }

    InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::UnMergeCells
//
//****************************************************************************
void CScheduleMatrix::UnMergeCells(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    DWORD dwFlags;
    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            dwFlags = m_CellArray[nHour+i][nDay+j].m_dwFlags;
            dwFlags &= (MC_ALLEDGES^0xFFFFFFFF);
            dwFlags &= (MC_MERGE^0xFFFFFFFF);
            if (i != 0)
                dwFlags &= (MC_MERGELEFT^0xFFFFFFFF);
            if (j != 0)
                dwFlags &= (MC_MERGETOP^0xFFFFFFFF);
            m_CellArray[nHour+i][nDay+j].m_dwFlags = dwFlags;
        }
    }

    InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::GetMergeState
//
//****************************************************************************
UINT CScheduleMatrix::GetMergeState(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    // Returns:
    // 0 = Unmerged
    // 1 = Merged
    // 2 = Indeterminate (mixed)

    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    UINT i, j;
    DWORD dwFlags;
    BOOL bFoundMergedCell = FALSE, bFoundUnmergedCell = FALSE,
        bFoundBadEdge = FALSE, bFoundBadNonEdge = FALSE;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            dwFlags = m_CellArray[nHour+i][nDay+j].m_dwFlags;
            if (dwFlags & MC_MERGE)
                bFoundMergedCell = TRUE;
            else
                bFoundUnmergedCell = TRUE;
            if (i == 0 || i == nNumHours-1 || j == 0 || j == nNumDays-1)
            {
                // If cell is an edge, make sure it's marked appropriately
                if (i == 0 && !(dwFlags & MC_LEFTEDGE))
                    bFoundBadEdge = TRUE;
                if (i == nNumHours-1 && !(dwFlags & MC_RIGHTEDGE))
                    bFoundBadEdge = TRUE;
                if (j == 0 && !(dwFlags & MC_TOPEDGE))
                    bFoundBadEdge = TRUE;
                if (j == nNumDays-1 && !(dwFlags & MC_BOTTOMEDGE))
                    bFoundBadEdge = TRUE;
            }
            else
            {
                // If cell is not an edge, make sure it's not marked as such
                if (dwFlags & MC_ALLEDGES)
                    bFoundBadNonEdge = TRUE;
            }
        }
    }

    // If we found no merged cells, we are definitely unmerged
    if (!bFoundMergedCell)
        return MS_UNMERGED;
    // If we found only good, merged cells, we are definitely merged
    if (!bFoundUnmergedCell && !bFoundBadEdge && !bFoundBadNonEdge)
        return MS_MERGED;

    return MS_MIXEDMERGE;
}

//****************************************************************************
//
//  CScheduleMatrix::GetBackColor
//
//****************************************************************************
COLORREF CScheduleMatrix::GetBackColor(UINT nHour, UINT nDay)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);

    return m_CellArray[nHour][nDay].m_crBackColor;
}

//****************************************************************************
//
//  CScheduleMatrix::GetForeColor
//
//****************************************************************************
COLORREF CScheduleMatrix::GetForeColor(UINT nHour, UINT nDay)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);

    return m_CellArray[nHour][nDay].m_crForeColor;
}

//****************************************************************************
//
//  CScheduleMatrix::GetPercentage
//
//****************************************************************************
UINT CScheduleMatrix::GetPercentage(UINT nHour, UINT nDay)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);

    return m_CellArray[nHour][nDay].m_nPercentage;
}

//****************************************************************************
//
//  CScheduleMatrix::GetBlendColor
//
//****************************************************************************
COLORREF CScheduleMatrix::GetBlendColor(UINT nHour, UINT nDay)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);

    return m_CellArray[nHour][nDay].m_crBlendColor;
}

//****************************************************************************
//
//  CScheduleMatrix::GetBlendState
//
//****************************************************************************
BOOL CScheduleMatrix::GetBlendState(UINT nHour, UINT nDay)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);

    if (m_CellArray[nHour][nDay].m_dwFlags & MC_BLEND)
        return TRUE;

    return FALSE;
}

//****************************************************************************
//
//  CScheduleMatrix::GetUserValue
//
//****************************************************************************
DWORD CScheduleMatrix::GetUserValue(UINT nHour, UINT nDay)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);

    return m_CellArray[nHour][nDay].m_dwUserValue;
}

//****************************************************************************
//
//  CScheduleMatrix::GetUserDataPtr
//
//****************************************************************************
LPVOID CScheduleMatrix::GetUserDataPtr(UINT nHour, UINT nDay)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);

    return m_CellArray[nHour][nDay].m_pUserDataPtr;
}

//****************************************************************************
//
//  CScheduleMatrix::OnSetFocus
//
//****************************************************************************
void CScheduleMatrix::OnSetFocus(CWnd* pOldWnd)
{
    CWnd::OnSetFocus(pOldWnd);

    CDC *pdc = GetDC();
    CRect rSel(m_nSelHour, m_nSelDay, m_nSelHour+m_nNumSelHours, m_nSelDay+m_nNumSelDays);
    CellToClient(rSel.left, rSel.top);
    CellToClient(rSel.right, rSel.bottom);
    rSel.right+=1;
    rSel.bottom+=1;
    pdc->DrawFocusRect(rSel);
    ReleaseDC(pdc);
}

//****************************************************************************
//
//  CScheduleMatrix::OnKillFocus
//
//****************************************************************************
void CScheduleMatrix::OnKillFocus(CWnd* pNewWnd)
{
    CWnd::OnKillFocus(pNewWnd);

    CRect rSel(m_nSelHour, m_nSelDay, m_nSelHour+m_nNumSelHours, m_nSelDay+m_nNumSelDays);
    CellToClient(rSel.left, rSel.top);
    CellToClient(rSel.right, rSel.bottom);
    rSel.right+=1;
    rSel.bottom+=1;

    CDC *pdc = GetDC();
    if ( pdc )
    {
        pdc->DrawFocusRect(rSel);
        ReleaseDC(pdc);
    }
}

//****************************************************************************
//
//  CScheduleMatrix::OnLButtonDown
//
//****************************************************************************
void CScheduleMatrix::OnLButtonDown(UINT nFlags, CPoint point)
{
    SetFocus();
    SetCapture();

    m_ptDown = point;
    m_ptFocus = point;
    m_ptFocus.x = max(m_ptFocus.x, m_rCellArray.left);
    m_ptFocus.y = max(m_ptFocus.y, m_rCellArray.top);
    m_ptFocus.x = min(m_ptFocus.x, m_rCellArray.right);
    m_ptFocus.y = min(m_ptFocus.y, m_rCellArray.bottom);
    m_nSaveHour = m_nSelHour;
    m_nSaveDay = m_nSelDay;
    m_nNumSaveHours = m_nNumSelHours;
    m_nNumSaveDays = m_nNumSelDays;

    CWnd::OnLButtonDown(nFlags, point);

    // Invalidate for "button selection" effect in the headers.
    if (m_rAllHeader.PtInRect(m_ptDown))
        InvalidateRect(m_rAllHeader, FALSE);
    if (m_rHourHeader.PtInRect(m_ptDown))
        InvalidateRect(m_rHourHeader, FALSE);
    if (m_rDayHeader.PtInRect(m_ptDown))
        InvalidateRect(m_rDayHeader, FALSE);

    OnMouseMove(nFlags, point);
}

//****************************************************************************
//
//  CScheduleMatrix::OnLButtonDblClk
//
//****************************************************************************
void CScheduleMatrix::OnLButtonDblClk(UINT nFlags, CPoint point)
{
    // Same as button down
    OnLButtonDown(nFlags, point);

    CWnd::OnLButtonDblClk(nFlags, point);
}

//****************************************************************************
//
//  CScheduleMatrix::OnLButtonUp
//
//****************************************************************************
void CScheduleMatrix::OnLButtonUp(UINT nFlags, CPoint point)
{
    if (GetCapture() == this)
    {
        m_ptFocus = point;
        m_ptFocus.x = max(m_ptFocus.x, m_rCellArray.left);
        m_ptFocus.y = max(m_ptFocus.y, m_rCellArray.top);
        m_ptFocus.x = min(m_ptFocus.x, m_rCellArray.right);
        m_ptFocus.y = min(m_ptFocus.y, m_rCellArray.bottom);

        ReleaseCapture();

        // If drawing the "button selection" effect in the headers, redraw.
        if (m_rAllHeader.PtInRect(m_ptDown))
            InvalidateRect(m_rAllHeader, FALSE);
        if (m_rHourHeader.PtInRect(m_ptDown))
            InvalidateRect(m_rHourHeader, FALSE);
        if (m_rDayHeader.PtInRect(m_ptDown))
            InvalidateRect(m_rDayHeader, FALSE);

        if (m_nSaveHour != m_nSelHour || m_nSaveDay != m_nSelDay ||
            m_nNumSaveHours != m_nNumSelHours || m_nNumSaveDays != m_nNumSelDays)
        {
            GetParent()->SendMessage(WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), MN_SELCHANGE),
                (LPARAM)GetSafeHwnd());
        }
    }

    CWnd::OnLButtonUp(nFlags, point);
}

//****************************************************************************
//
//  CScheduleMatrix::OnMouseMove
//
//****************************************************************************
void CScheduleMatrix::OnMouseMove(UINT nFlags, CPoint point)
{
    if (GetCapture() == this)
    {
        m_ptFocus = point;
        //Bug 429139, Yang Gao, 7/20/2001
        if( m_ptFocus.x < m_rAllHeader.left || m_ptFocus.x > m_rCellArray.right ||
            m_ptFocus.y < m_rAllHeader.top || m_ptFocus.y > m_rCellArray.bottom )
        {
            CWnd::OnMouseMove(nFlags, point);
            return;
        }
        m_ptFocus.x = max(m_ptFocus.x, m_rCellArray.left);
        m_ptFocus.y = max(m_ptFocus.y, m_rCellArray.top);
        m_ptFocus.x = min(m_ptFocus.x, m_rCellArray.right);
        m_ptFocus.y = min(m_ptFocus.y, m_rCellArray.bottom);

        CRect rInvalid(0,0,0,0);
        CRect rSel(m_ptDown.x, m_ptDown.y, point.x, point.y);
        if (m_rDayHeader.PtInRect(m_ptDown))
        {
            rSel.right = m_rCellArray.right;
            rInvalid = m_rDayHeader;
        }

        if (m_rHourHeader.PtInRect(m_ptDown))
        {
            rSel.bottom = m_rCellArray.bottom;
            rInvalid = m_rHourHeader;
        }

        if (m_rAllHeader.PtInRect(m_ptDown))
        {
            rSel.right = m_rCellArray.right;
            rSel.bottom = m_rCellArray.bottom;
            rInvalid = m_rAllHeader;
        }
        ClientToCell(rSel.left, rSel.top);
        ClientToCell(rSel.right, rSel.bottom);
        rSel.NormalizeRect();
        rSel.right += 1;
        rSel.bottom += 1;
        rSel.right = min(rSel.right, 24);
        rSel.bottom = min(rSel.bottom, (m_nType == MT_DAILY ? 1 : 7));
        // If we've drifted out of the down area, reset selection
        CRect rDayHeader(m_rDayHeader);
        CRect rHourHeader(m_rHourHeader);
        CRect rAllHeader(m_rAllHeader);
        CRect rCellArray(m_rCellArray);
        int nBuffer = GetSystemMetrics(SM_CXVSCROLL);
        rDayHeader.InflateRect(nBuffer,nBuffer);
        rHourHeader.InflateRect(nBuffer,nBuffer);
        rAllHeader.InflateRect(nBuffer,nBuffer);
        rCellArray.InflateRect(nBuffer,nBuffer);
        if ((m_rDayHeader.PtInRect(m_ptDown) && !rDayHeader.PtInRect(point)) ||
            (m_rHourHeader.PtInRect(m_ptDown) && !rHourHeader.PtInRect(point)) ||
            (m_rAllHeader.PtInRect(m_ptDown) && !rAllHeader.PtInRect(point)) ||
            (m_rCellArray.PtInRect(m_ptDown) && !rCellArray.PtInRect(point)))
            rSel.SetRect(m_nSaveHour, m_nSaveDay, m_nSaveHour+m_nNumSaveHours,
                m_nSaveDay+m_nNumSaveDays);

        if (SetSelValues(rSel.left, rSel.top, rSel.Width(), rSel.Height()))
            InvalidateRect(rInvalid);
    }

    CWnd::OnMouseMove(nFlags, point);
}

//****************************************************************************
//
//  CScheduleMatrix::OnGetDlgCode
//
//****************************************************************************
UINT CScheduleMatrix::OnGetDlgCode()
{
    return (DLGC_WANTCHARS | DLGC_WANTARROWS);
}

//****************************************************************************
//
//  CScheduleMatrix::OnKeyDown
//
//****************************************************************************
void CScheduleMatrix::OnKeyDown(UINT nChar, UINT /*nRepCnt*/, UINT /*nFlags*/)
{
//    BOOL bShifted = 0x8000 & GetKeyState(VK_SHIFT);

    CPoint ptCell, ptOldCell, ptClient;
    ptCell = m_ptFocus;
    ClientToCell(ptCell.x, ptCell.y);
    ptOldCell = ptCell;

    BOOL bToggle = FALSE;

    switch (nChar)
    {
        case VK_SHIFT:
            m_bShifted = TRUE;
            break;;
        case VK_SPACE:
            bToggle = TRUE;
            break;
        case VK_LEFT:
            ptCell.x -= 1;
            break;
        case VK_RIGHT:
            ptCell.x += 1;
            break;
        case VK_UP:
            ptCell.y -= 1;
            break;
        case VK_DOWN:
            ptCell.y += 1;
            break;
        case VK_PRIOR:
            ptCell.y = -1;
            break;
        case VK_NEXT:
            ptCell.y = 6;
            break;
        case VK_HOME:
            ptCell.x = -1;
            ptCell.y = -1;
            break;
        case VK_END:
            ptCell.x = 23;
            ptCell.y = 6;
            break;
    }

    // Restrict keyboard control to the matrix...
    ptCell.x = max(0, ptCell.x);
    ptCell.x = min(23, ptCell.x);
    ptCell.y = max(0, ptCell.y);
    ptCell.y = min((m_nType == MT_DAILY ? 0 : 6), ptCell.y);

    ptClient = ptCell;
    CellToClient(ptClient.x, ptClient.y);

    if (bToggle)
    {
        OnLButtonDown(MK_LBUTTON, ptClient);
        OnLButtonUp(MK_LBUTTON, ptClient);
/*
        if (bShifted)
            Extend(ptClient);
        else
        {
            Press(ptClient, FALSE);
            Release(ptClient);
        }

        ptFocus = ptClient;
*/
    }
    else if (ptCell != ptOldCell)
    {
        if (m_bShifted)
        {
//            Extend(ptClient);
            if (GetCapture() != this)
            {
                CPoint ptOldClient(ptOldCell);
                CellToClient(ptOldClient.x, ptOldClient.y);
                OnLButtonDown(MK_LBUTTON, ptOldClient);
            }
            OnMouseMove(MK_LBUTTON, ptClient);
        }
        else
        {
            OnLButtonDown(MK_LBUTTON, ptClient);
            OnLButtonUp(MK_LBUTTON, ptClient);
            ptClient.x += m_nCellWidth;  //Raid 338028, 6/14/2001, Yanggao.
            ptClient.y += m_nCellHeight;
            ClientToScreen(&ptClient);
            ::SetCursorPos(ptClient.x, ptClient.y);
        }
/*
        if (bFocus)
            DrawFocus(FALSE, ptFocus, NULL);
        ptFocus = ptClient;
        if (bFocus)
            DrawFocus(TRUE, ptFocus, NULL);
*/
    }
}

//****************************************************************************
//
//  CScheduleMatrix::OnKeyUp
//
//****************************************************************************
void CScheduleMatrix::OnKeyUp(UINT nChar, UINT /*nRepCnt*/, UINT /*nFlags*/)
{
    switch (nChar)
    {
        case VK_SHIFT:
            m_bShifted = FALSE;
            OnLButtonUp(MK_LBUTTON, m_ptFocus);
            break;
        case VK_SPACE:
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
        case VK_PRIOR:
        case VK_NEXT:
        case VK_HOME:
        case VK_END:
//            Release(ptFocus);
            break;
    }
}

//****************************************************************************
//
//  CScheduleMatrix::InvalidateCells
//
//****************************************************************************
void CScheduleMatrix::InvalidateCells(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays,
    BOOL bErase)
{
    CRect r(nHour, nDay, nHour+nNumHours, nDay+nNumDays);
    CellToClient(r.left, r.top);
    CellToClient(r.right, r.bottom);
    r.right += 1;
    r.bottom += 1;

    InvalidateRect(r, bErase);
}

//****************************************************************************
//
//  CScheduleMatrix::OnGetObject
//
//****************************************************************************
LRESULT CScheduleMatrix::OnGetObject (WPARAM wParam, LPARAM lParam)
{
    if ( lParam == OBJID_CLIENT )
    {
        // At this point we will try to load oleacc and get the functions
        // we need.
        if (!g_fAttemptedOleAccLoad)
        {
            g_fAttemptedOleAccLoad = TRUE;

            ASSERT (0 == s_pfnCreateStdAccessibleObject);
            ASSERT(s_pfnCreateStdAccessibleProxy == NULL);
            ASSERT(s_pfnLresultFromObject == NULL);

            if ( !g_hOleAcc )
                g_hOleAcc = ::LoadLibrary (L"OLEACC");
            if (g_hOleAcc != NULL)
            {
                s_pfnCreateStdAccessibleObject = (PFNCREATESTDACCESSIBLEOBJECT)
                        GetProcAddress(g_hOleAcc, "CreateStdAccessibleObject");
                s_pfnCreateStdAccessibleProxy = (PFNCREATESTDACCESSIBLEPROXY)
                        GetProcAddress(g_hOleAcc, "CreateStdAccessibleProxyW");
                s_pfnLresultFromObject = (PFNLRESULTFROMOBJECT)
                        GetProcAddress(g_hOleAcc, "LresultFromObject");
            }
            if (s_pfnLresultFromObject == NULL || 
                    s_pfnCreateStdAccessibleProxy == NULL ||
                    0 == s_pfnCreateStdAccessibleObject)
            {
                if (g_hOleAcc)
                {
                    // No point holding on to Oleacc since we can't use it.
                    ::FreeLibrary(g_hOleAcc);
                    g_hOleAcc = NULL;
                }
                s_pfnLresultFromObject = NULL;
                s_pfnCreateStdAccessibleProxy = NULL;
                s_pfnCreateStdAccessibleObject = 0;
            }
        }


        if (g_hOleAcc && 
                s_pfnCreateStdAccessibleProxy && 
                s_pfnLresultFromObject && 
                s_pfnCreateStdAccessibleObject)
        {
            // Create default proxy.
            if ( !m_pWrapAcc )
            {
                IAccessible*    pAcc = NULL;
                HRESULT hr = s_pfnCreateStdAccessibleObject (
                    m_hWnd,
                    OBJID_CLIENT,
                    IID_PPV_ARG (IAccessible, &pAcc));
                if (SUCCEEDED(hr) && pAcc)
                {
                    // now wrap it up in our customized wrapper...
                    m_pWrapAcc = new CAccessibleWrapper (m_hWnd, pAcc);

                    // Release our ref to proxy (wrapper has its own addref'd ptr)...
                    pAcc->Release();
                }
            }

            if ( m_pWrapAcc )
            {
                // ...and return the wrapper via LresultFromObject...
                LRESULT lr = s_pfnLresultFromObject (IID_IAccessible, wParam, m_pWrapAcc);

                // Return the lresult, which 'contains' a reference to our wrapper object.
                return lr;
                // All done!
            }
        }
    }

    return 0;
}

//****************************************************************************
//
//  CScheduleMatrix::OnGetSelDescription
//
//  wParam - length of passed in string buffer
//  lParam - wide-char string buffer
//
//****************************************************************************
LRESULT CScheduleMatrix::OnGetSelDescription (WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    PWSTR   pszDescription = (PWSTR) lParam;
    if ( pszDescription )
    {
        UINT    nMaxLen = (UINT) wParam;    // size of buffer, including NULL
        CString szDescription;
        GetSelDescription (szDescription);

        // NTRAID#NTBUG9-547598-2002/02/18-artm  Potential buffer overrun from using wcsncpy.
        //
        // There is no guarantee that destination will be null terminated.
        // Finally, the length of source string is never checked to make sure it will fit in
        // destination string.
        // NOTES: 1) There is no possibility of buffer overrun here.  The only 
        // possibility is of non-NULL termination if the source string fills 
        // the destination buffer
        // 2) We cannot guarantee that the target buffer will contain enough 
        // space for the description string as the caller is responsible for 
        // the buffer size.  We would have to introduce a new message to get 
        // the size - perhaps this could be Longhorn work.
        wcsncpy (pszDescription, szDescription, nMaxLen);
        pszDescription[nMaxLen-1] = 0;  // ensure null-termination
    }
    else
        lResult = -1;

    return lResult;
}

//****************************************************************************
//
//  CScheduleMatrix::OnGetPercentage
//
//  wParam - return % of selected cell
//  lParam - unused
//
//****************************************************************************
LRESULT CScheduleMatrix::OnGetPercentage (WPARAM /*wParam*/, LPARAM /*lParam*/)
{
    LRESULT lResult = 0;
    if ( 1 == m_nNumSelHours && 1 == m_nNumSelDays )
        lResult = GetPercentage (m_nSelHour, m_nSelDay);
    else
        lResult = -1;

    return lResult;
}


/////////////////////////////////////////////////////////////////////////////
// CHourLegend

IMPLEMENT_DYNAMIC(CHourLegend, CWnd)

//****************************************************************************
//
//  CHourLegend::CHourLegend
//
//****************************************************************************
CHourLegend::CHourLegend()
{
    m_hiconSun = m_hiconMoon = NULL;

    m_hFont = NULL;
}

//****************************************************************************
//
//  CHourLegend::~CHourLegend
//
//****************************************************************************
CHourLegend::~CHourLegend()
{
    if ( m_hiconMoon )
    {
        DestroyIcon (m_hiconMoon);
        m_hiconMoon = 0;
    }
    if ( m_hiconSun )
    {
        DestroyIcon (m_hiconSun);
        m_hiconSun = 0;
    }
}


BEGIN_MESSAGE_MAP(CHourLegend, CWnd)
    //{{AFX_MSG_MAP(CHourLegend)
    ON_WM_PAINT()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHourLegend message handlers

//****************************************************************************
//
//  CHourLegend::OnPaint
//
//****************************************************************************
void CHourLegend::OnPaint()
{
    CRect rClient;

    CPaintDC dc(this); // device context for painting
    
    CFont *pOldFont = NULL;
    CFont *pFont = CFont::FromHandle(m_hFont);

    if (pFont != NULL)
        pOldFont = dc.SelectObject(pFont);

    CBrush brFace(::GetSysColor(COLOR_3DFACE));

    CBrush *pbrOld = dc.SelectObject(&brFace);

    GetClientRect(rClient);

    // Draw the hour legend

    if (m_hiconSun == NULL)
        m_hiconSun = (HICON)::LoadImage(AfxFindResourceHandle(_T("SUN16"), RT_GROUP_ICON),
            _T("SUN16"), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
    if (m_hiconMoon == NULL)
        m_hiconMoon = (HICON)::LoadImage(AfxFindResourceHandle(_T("MOON16"), RT_GROUP_ICON),
            _T("MOON16"), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
    dc.FillRect(rClient, &brFace);
    ::DrawIconEx(dc.GetSafeHdc(),m_rLegend.left-8,rClient.bottom - m_nCharHeight - 16 - 2,
        (HICON)m_hiconMoon,0,0,0,NULL,DI_NORMAL);
    ::DrawIconEx(dc.GetSafeHdc(),m_rLegend.left + m_rLegend.Width()/2 - 8,
        rClient.bottom - m_nCharHeight - 16 - 2,(HICON)m_hiconSun,0,0,0,NULL,DI_NORMAL);
    ::DrawIconEx(dc.GetSafeHdc(),m_rLegend.right-8,rClient.bottom - m_nCharHeight - 16 - 2,
        (HICON)m_hiconMoon,0,0,0,NULL,DI_NORMAL);

    // Draw the hour text

    COLORREF crBkOld = dc.GetBkColor();
    COLORREF crTextOld = dc.GetTextColor();
    COLORREF crText = ::GetSysColor(COLOR_BTNTEXT);
    COLORREF crFace = ::GetSysColor(COLOR_3DFACE);
    dc.SetBkColor(crFace);
    dc.SetTextColor(crText);

    int i, hr;
    CRect rText, rBullet;
    CString sHour;
    rText.SetRect(m_rLegend.left-m_nCharWidth, rClient.bottom - m_nCharHeight - 2,
        m_rLegend.left + m_nCharWidth, rClient.bottom - 2);
    rBullet.SetRect(m_rLegend.left + m_nCellWidth - 1, rClient.bottom - 2 - rText.Height()/2 - 1,
        m_rLegend.left + m_nCellWidth + 1, rClient.bottom - 2 - rText.Height()/2 + 1);


    // NOTICE-2002/02/18-artm  CString can throw out of memory exceptions.
    // No good way to handle at this level; responsibility of caller to handle.
    bool    bIs24HourClock = false;
    CString sFormat;
    int     iLen = ::GetLocaleInfo(
                LOCALE_USER_DEFAULT,      // locale identifier
                LOCALE_ITIME,    // type of information
                0,  // address of buffer for information
                0);  // size of buffer
    ASSERT (iLen > 0);
    if ( iLen > 0 )
    {
        int iResult = ::GetLocaleInfo(
                LOCALE_USER_DEFAULT,      // locale identifier
                LOCALE_ITIME,    // type of information
                sFormat.GetBufferSetLength (iLen),  // address of buffer for information
                iLen);  // size of buffer
        ASSERT (iResult);
        sFormat.ReleaseBuffer ();
        if ( sFormat == _TEXT("1") )
            bIs24HourClock = true;
    } 

    if ( bIs24HourClock )
        hr = 0;
    else
        hr = 12;
    for (i=0; i<=24; i+=2)
    {
        if ( bIs24HourClock )
        {
            if ( 24 == hr )
                hr = 0;
        }
        else if (hr > 12)
            hr = 2;
        sHour.Format(_T("%d"), hr);
        dc.SetBkColor(crFace);  //?? FillSolidRect seems to set BkColor
        ::DrawTextEx(dc.GetSafeHdc(), (LPTSTR)(LPCTSTR)sHour, -1, rText,
            DT_SINGLELINE | DT_CENTER | DT_VCENTER | DT_END_ELLIPSIS, NULL);
        dc.FillSolidRect(rBullet, crText); //?? FillSolidRect seems to set BkColor
        hr += 2;
        rText.OffsetRect(2*m_nCellWidth, 0);
        if (i < 24)
            rBullet.OffsetRect(2*m_nCellWidth, 0);
    }

    dc.SetBkColor(crBkOld);
    dc.SetTextColor(crTextOld);

    if (pbrOld != NULL)
        dc.SelectObject(pbrOld);
    
    if (pOldFont != NULL)
        dc.SelectObject(pOldFont);

    // Do not call CWnd::OnPaint() for painting messages
}

/////////////////////////////////////////////////////////////////////////////
// CPercentLabel

IMPLEMENT_DYNAMIC(CPercentLabel, CWnd)

//****************************************************************************
//
//  CPercentLabel::CPercentLabel
//
//****************************************************************************
CPercentLabel::CPercentLabel()
{
    m_pMatrix = NULL;
    m_hFont = NULL;
}

//****************************************************************************
//
//  CPercentLabel::~CPercentLabel
//
//****************************************************************************
CPercentLabel::~CPercentLabel()
{
}


BEGIN_MESSAGE_MAP(CPercentLabel, CWnd)
    //{{AFX_MSG_MAP(CPercentLabel)
    ON_WM_PAINT()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPercentLabel message handlers

//****************************************************************************
//
//  CPercentLabel::OnPaint
//
//****************************************************************************
void CPercentLabel::OnPaint()
{
    CRect rClient;

    CPaintDC dc(this); // device context for painting
    
    CFont *pOldFont = NULL;
    CFont *pFont = CFont::FromHandle(m_hFont);

    if (pFont != NULL)
        pOldFont = dc.SelectObject(pFont);

    CBrush brFace(::GetSysColor(COLOR_3DFACE));

    CBrush *pbrOld = dc.SelectObject(&brFace);

    GetClientRect(rClient);

    COLORREF crBkOld = dc.GetBkColor();
    COLORREF crTextOld = dc.GetTextColor();
    COLORREF crText = ::GetSysColor(COLOR_BTNTEXT);
    COLORREF crFace = ::GetSysColor(COLOR_3DFACE);
    dc.SetBkColor(crFace);
    dc.SetTextColor(crText);

    // Draw the header label

    // NOTICE-2002/02/18-artm  CString can throw out of memory exceptions.
    // No good way to handle at this level; responsibility of caller to handle.
    CString sText(_T("%"));
    ::DrawTextEx(dc.GetSafeHdc(), (LPTSTR)(LPCTSTR)sText, -1, m_rHeader,
        DT_SINGLELINE | DT_CENTER | DT_VCENTER | DT_END_ELLIPSIS, NULL);

    // Draw the percent label text

    int i;
    UINT nPercent;
    CRect rText, rBullet;
    rText.SetRect(m_rLabels.left, 0, m_rLabels.left + m_nCellWidth, rClient.bottom);
    for (i=0; i<24; i++)
    {
        nPercent = m_pMatrix->GetPercentage(i,0);
        // Don't draw percentages greater than 99
        if (nPercent <= 99)
        {
            sText.Format(_T("%d"), nPercent);
            ::DrawTextEx(dc.GetSafeHdc(), (LPTSTR)(LPCTSTR)sText, -1, rText,
                DT_SINGLELINE | DT_CENTER | DT_VCENTER | DT_END_ELLIPSIS, NULL);
        }
        rText.OffsetRect(m_nCellWidth, 0);
    }

    dc.SetBkColor(crBkOld);
    dc.SetTextColor(crTextOld);

    if (pbrOld != NULL)
        dc.SelectObject(pbrOld);
    
    if (pOldFont != NULL)
        dc.SelectObject(pOldFont);

    // Do not call CWnd::OnPaint() for painting messages
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\schedbas.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       SchedBas.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#if !defined(AFX_SCHEDBAS_H__701CFB39_AEF8_11D1_9864_00C04FB94F17__INCLUDED_)
#define AFX_SCHEDBAS_H__701CFB39_AEF8_11D1_9864_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SchedBas.h : header file
//
#include "stdafx.h"
#include "resource.h"
#include "schedmat.h"

///////////////////////////////////////////////////////////////////////////////
// Private functions
void ReplaceFrameWithControl (CWnd *pWnd, UINT nFrameID, CWnd *pControl, BOOL bAssignFrameIDToControl); 

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CLegendCell control
class CLegendCell : public CStatic
{
public:
    CLegendCell()
        : m_pMatrix( NULL ),
          m_nPercentage (0)
        {}

    void Init(CWnd* pParent, UINT nCtrlID, CScheduleMatrix* pMatrix, UINT nPercentage);

protected:
    CScheduleMatrix*    m_pMatrix;
    UINT                m_nPercentage;
    CSize               m_rectSize;

    // Generated message map functions
    //{{AFX_MSG(CLegendCell)
    afx_msg void OnPaint();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
#define IDC_SCHEDULE_MATRIX     20      // Id of the schedule matrix (arbitrary chosen)


/////////////////////////////////////////////////////////////////////////////
// CScheduleBaseDlg dialog
#define BASEDLGMSG_GETIDD   WM_APP+3

class CScheduleBaseDlg : public CDialog
{
// Construction
public:
    virtual int GetIDD () = 0;
    void SetFlags (DWORD dwFlags);
    void SetTitle (LPCTSTR pszTitle);
    CScheduleBaseDlg(UINT nIDTemplate, bool bAddDaylightBias, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CScheduleBaseDlg)
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CScheduleBaseDlg)
    public:
    virtual void OnFinalRelease();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    afx_msg LRESULT OnGetIDD (WPARAM wParam, LPARAM lParam);
    DWORD GetFlags () const;
    virtual void TimeChange () = 0;
    bool m_bSystemTimeChanged;
    virtual UINT GetExpectedArrayLength ()=0;
    virtual BYTE GetMatrixPercentage (UINT nHour, UINT nDay) = 0;
    void GetByteArray(OUT BYTE rgbData[], const size_t cbArray);
    void InitMatrix2 (const BYTE rgbData[]);
    virtual UINT GetPercentageToSet (const BYTE bData) = 0;
    virtual void UpdateButtons () = 0;
    virtual void InitMatrix () = 0;
    virtual void UpdateUI ();
    enum { c_crBlendColor = RGB(0, 0, 255) };   // Blending color of the schedule matrix
    CScheduleMatrix m_schedulematrix;
    const bool m_bAddDaylightBias;
    int m_nFirstDayOfWeek;
    size_t m_cbArray;

    // Generated message map functions
    //{{AFX_MSG(CScheduleBaseDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    afx_msg void OnSelChange();
    afx_msg void OnTimeChange();
    DECLARE_MESSAGE_MAP()
    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CScheduleBaseDlg)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()

private:
    DWORD m_dwFlags;
    CString m_szTitle;  // dialog title
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCHEDBAS_H__701CFB39_AEF8_11D1_9864_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\schedmat.h ===
//****************************************************************************
//
//  Copyright (c) 1997-2002, Microsoft Corporation
//
//  File:  SCHEDMAT.H
//
//  Definitions for the schedule matrix classes.  These classes provide a basic
//  schedule matrix control.  The classes defined here are:
//
//      CMatrixCell         A data structure class for the CScheduleMatrix.
//      CHourLegend         Support window class that draws the matrix legend.
//      CPercentLabel       Support window class that draws percentage labels.
//      CScheduleMatrix     A class that displays daily or weekly schedule data.
//
//  History:
//
//      Scott Walker, SEA   3/10     Created.
//
//****************************************************************************
#ifndef _SCHEDMAT_H_
#define _SCHEDMAT_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// schedmat.h : header file
//
#include "AccessibleWrapper.h"
#include "log_gmt.h"

// SCHEDMSG_GETSELDESCRIPTION   
// wParam - IN size of input buffer in wide-characters, including NULL
// lParam - IN address of pointer to widechar buffer
//        - OUT receives description of selected cells
#define SCHEDMSG_GETSELDESCRIPTION  WM_APP+1

#define SCHEDMSG_GETPERCENTAGE      WM_APP+2


#ifndef UITOOLS_CLASS
#define UITOOLS_CLASS
#endif

// Classes defined in this file
class CMatrixCell;
class CScheduleMatrix;

// Schedule matrix types
#define MT_DAILY  1        // 1x24 matrix
#define MT_WEEKLY 2        // 7x24 matrix

// GetMergeState return codes
#define MS_UNMERGED    0
#define MS_MERGED      1
#define MS_MIXEDMERGE  2

// Matrix notification codes
#define MN_SELCHANGE    (WM_USER + 175)
#define ON_MN_SELCHANGE(id, memberFxn) ON_CONTROL(MN_SELCHANGE, id, memberFxn)

/////////////////////////////////////////////////////////////////////////////
// CMatrixCell

#define DEFBACKCOLOR RGB(255,255,255)   // White
#define DEFFORECOLOR RGB(0,0,128)       // Dark blue
#define DEFBLENDCOLOR RGB(255,255,0)    // Yellow

// Cell flags
#define MC_MERGELEFT    0x00000001
#define MC_MERGETOP     0x00000002
#define MC_MERGE        0x00000004
#define MC_LEFTEDGE     0x00000010
#define MC_RIGHTEDGE    0x00000020
#define MC_TOPEDGE      0x00000040
#define MC_BOTTOMEDGE   0x00000080
#define MC_BLEND        0x00000100

#define MC_ALLEDGES (MC_LEFTEDGE | MC_RIGHTEDGE | MC_TOPEDGE | MC_BOTTOMEDGE)

class UITOOLS_CLASS CMatrixCell : public CObject
{
    DECLARE_DYNAMIC(CMatrixCell)
    friend CScheduleMatrix;

// Construction
public:
	CMatrixCell();
	virtual ~CMatrixCell();

protected:
    COLORREF m_crBackColor;
    COLORREF m_crForeColor;
    UINT m_nPercentage;

    COLORREF m_crBlendColor;

    DWORD m_dwUserValue;
    LPVOID m_pUserDataPtr;

    DWORD m_dwFlags;
};

/////////////////////////////////////////////////////////////////////////////
// CHourLegend window

class UITOOLS_CLASS CHourLegend : public CWnd
{
    DECLARE_DYNAMIC(CHourLegend)
    friend CScheduleMatrix;

// Construction
public:
	CHourLegend();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHourLegend)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHourLegend();

protected:
    HICON m_hiconSun, m_hiconMoon;
    HFONT m_hFont;
    int m_nCharHeight, m_nCharWidth;
    int m_nCellWidth;
    CRect m_rLegend;

    // Generated message map functions
protected:
	//{{AFX_MSG(CHourLegend)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CPercentLabel window

class UITOOLS_CLASS CPercentLabel : public CWnd
{
    DECLARE_DYNAMIC(CPercentLabel)
    friend CScheduleMatrix;

// Construction
public:
	CPercentLabel();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHourLegend)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CPercentLabel();

protected:
    CScheduleMatrix *m_pMatrix;
    HFONT m_hFont;
    int m_nCellWidth;
    CRect m_rHeader;
    CRect m_rLabels;

    // Generated message map functions
protected:
	//{{AFX_MSG(CPercentLabel)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CScheduleMatrix window

// Schedule matrix command IDs
#define SM_ID_DAYBASE 100

#define SM_ID_ALL (SM_ID_DAYBASE + 0)

#define SM_ID_MONDAY (SM_ID_DAYBASE + 1)
#define SM_ID_TUESDAY (SM_ID_DAYBASE + 2)
#define SM_ID_WEDNESDAY (SM_ID_DAYBASE + 3)
#define SM_ID_THURSDAY (SM_ID_DAYBASE + 4)
#define SM_ID_FRIDAY (SM_ID_DAYBASE + 5)
#define SM_ID_SATURDAY (SM_ID_DAYBASE + 6)
#define SM_ID_SUNDAY (SM_ID_DAYBASE + 7)

#define SM_ID_HOURBASE 110

//****************************************************************************
//
//  CLASS:  CScheduleMatrix
//
//  CScheduleMatrix inplements a basic schedule matrix control.  This control
//  provides the mechanics of a daily or weekly schedule UI but has no knowledge
//  about the data it maintains.  The matrix is an array of cells representing
//  the hours in a day and optionally the days in a week.  The cells can be
//  rendered in a variety of ways to represent programmer-defined meaning in
//  each cell.  The following display properties can be set for individual cells
//  or for a block of cells at once:
//
//  BackColor       Background color of the cell (defaults white).
//  ForeColor       ForeGround color of the cell (defaults dark blue).
//  Percentage      Percentage of foreground to background color.  This is
//                  rendered as a histogram in the cell.
//  BlendColor      50% dither color on a cell to represent some binary state
//                  of the cell as compared to another cell (defaults yellow).
//  BlendState      Specifies whether blend color is showing or not.
//
//  A block of cells can be "merged" together to form a discreet block of color
//  within the matrix grid.  This is useful for schedule applications that want
//  to assign a schedule function to a time range.  It is the responsibility
//  of the program to track these blocks and prevent or resolve any confusion
//  from overlapping "merged" blocks.
//
//  Each cell can contain two kinds of programmer-defined data that are
//  maintained with the cell but not touched by the matrix control:  a DWORD
//  value and a pointer value.  These values can be used to hold data representing
//  schedule information for each hour in the matrix.
//
//  The parent window receives a notification message (MN_SELCHANGE) whenever the
//  user modifies the current selection in the matrix.
//
//?? Later:  May add Icon and Text properties per cell.
//
//  PUBLIC MEMBERS:
//
//      CScheduleMatrix             Constructor.
//      ~CScheduleMatrix            Destructor.
//      SetType                     Sets the matrix type to MT_DAILY or MT_WEEKLY.
//      Create                      Creates the control window.
//
//      Selection:
//
//      DeselectAll                 Deselects all cells.
//      SelectAll                   Selects all cells.
//      SetSel                      Selects a block of cells.
//      GetSel                      Gets the current selection.
//      GetSelDescription           Gets text description of selection range
//      CellInSel                   Tests if a cell is in the current selection
//
//      GetCellSize                 Gets the size of a cell in the current matrix
//      DrawCell                    Draws a sample cell in specified DC
//
//      Block Data Functions:
//
//      SetBackColor                Sets color used to paint cell background.
//      SetForeColor                Sets color used to paint cell percentage.
//      SetPercentage               Sets percentage of foreground to background.
//      SetBlendColor               Sets color blended onto cells.
//      SetBlendState               Turns blend on or off.
//      SetUserValue                Sets user defined DWORD value.
//      SetUserDataPtr              Sets user defined data pointer.
//      MergeCells                  Graphically merges cells so they render as a block.
//      UnMergeCells                Cancels merging for a block of cells.
//      GetMergeState               Returns merge state for a block of cells
//
//      Cell Data Functions:
//
//      GetBackColor                Gets the back color of a cell.
//      GetForeColor                Gets the forecolor of a cell.
//      GetPercentage               Gets the percentage of foreground to background.
//      GetBlendColor               Gets the blend color of cell.
//      GetBlendState               Gets the blend state of a cell.
//      GetUserValue                Gets the user defined DWORD value of the cell.
//      GetUserDataPtr              Gets the user defined data pointer of the cell.
//
//============================================================================
//
//  CScheduleMatrix::CScheduleMatrix
//
//  Constructor.  The constructor creates the data structure associated with
//  the schedule matrix.  As with other CWnd objects, the control itself must
//  be instantiated with a call to Create.
//
//  Parameters I:
//
//      void                    Default constructor.  Constructs a MT_WEEKLY
//                              schedule matrix.
//
//  Parameters II:
//
//      DWORD dwType            Type constructor.  CScheduleMatrix with initial
//                              type:  MT_DAILY or MT_WEEKLY
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetType
//
//  Sets the type of the matrix to MT_WEEKLY or MT_DAILY.  Call this function
//  after construction but before Create.
//
//  Parameters:
//
//      DWORD dwType            Matrix Type:  MT_DAILY or MT_WEEKLY
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::Create
//
//  Create initializes the control's window and attaches it to the CScheduleMatrix.
//
//  Parameters:
//
//      DWORD dwStyle       Specifies the window style of the control.
//      const RECT& rect    Specifies the position and size of the control.
//      CWnd* pParentWnd    Specifies the parent window of the control.
//      UINT nID            Specifies the control ID.
//
//  Returns:
//
//      BOOL bResult        TRUE if successful.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::DeselectAll
//
//  Deselects all cells in the matrix.
//
//  Returns:
//
//      BOOL bChanged       TRUE if selection changes.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SelectAll
//
//  Selects all cells in the matrix.
//
//  Returns:
//
//      BOOL bChanged       TRUE if selection changes.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetSel
//
//  Sets the selection to the specified block.  The selection is a continuous
//  block of cells defined by a starting hour/day pair and extending over a
//  range of hours and days.
//
//  Parameters:
//
//      UINT nHour          Starting hour for the selection.
//      UINT nDay           Starting day for the selection.
//      UINT nNumHours      Range of selection along the hour axis. (Default=1).
//      UINT nNumDays       Range of selection along the day axis. (Default=1).
//
//  Returns:
//
//      BOOL bChanged       TRUE if selection changes.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetSel
//
//  Retrieves the current selection.
//
//  Parameters:
//
//      UINT &nHour         Receiver for starting hour for the selection.
//      UINT &nDay          Receiver for starting day for the selection.
//      UINT &nNumHours     Receiver for range of selection along the hour axis.
//      UINT &nNumDays      Receiver for range of selection along the day axis.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetDescription
//
//  Returns a textual description of the specified block of cells.  This is useful
//  for applications that wish to provide feedback about merged or grouped blocks
//  in the matrix.
//
//  Parameters:
//
//      CString &sText      Receiver for description text.
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetSelDescription
//
//  Returns a textual description of the current selection.  This is useful for
//  applications that wish to provide feedback about the selection.
//
//  Parameters:
//
//      CString &sText      Receiver for description text.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::CellInSel
//
//  Returns TRUE if the specified cell is selected (i.e. is in the block of
//  selected cells).
//
//  Parameters:
//
//      UINT nHour          Hour position of the cell.
//      UINT nDay           Day position of the cell.
//
//  Returns:
//
//      BOOL bSelected      TRUE if cell is selected.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetCellSize
//
//  Returns the size of a cell in the current matrix.  This function may be used
//  in conjunction with DrawCell (below) to render a sample cell for a legend.
//
//  Returns:
//
//      CSize size          Size of the cell.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::DrawCell
//
//  Renders a cell with the specified properties.  Use this function to create
//  a legend defining the cell states in the matrix.  The cell is drawn as a
//  histogram with the specified background and foreground colors in a proportion
//  specified by the percentage.  If blend state is TRUE, the blend color is
//  blended in with a 50% dither on top of the foreground and background.
//
//  Parameters:
//
//      CDC *pdc                Display context to draw into.
//      LPCRECT pRect           Cell boundaries in the specified DC.
//      UINT nPercent           Percentage if foreground to background color.
//      BOOL bBlendState        Draw blend dither if TRUE (Default = FALSE).
//      COLORREF crBackColor    Background color (Default = DEFBACKCOLOR).
//      COLORREF crForeColor    Foreground color (Default = DEFFORECOLOR).
//      COLORREF crBlendColor   Blend color (Default = DEFBLENDCOLOR).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetBackColor
//
//  Sets the background color for the specified block of cells.
//
//  Parameters:
//
//      COLORREF crColor    New color property for the block of cells.
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetForeColor
//
//  Sets the foreground color for the specified block of cells.
//
//  Parameters:
//
//      COLORREF crColor    New color property for the block of cells.
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetPercentage
//
//  Sets the percentage of foreground to background color for the specified block
//  of cells.  This percentage is rendered as a histogram of one color to the
//  other with foreground color on the bottom.
//
//  Parameters:
//
//      UINT nPercent       Percentage of foreground to background color.
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetBlendColor
//
//  Sets the blend color for the specified block of cells.  Blend color is
//  overlayed in a 50% dither pattern on the foreground and background colors
//  of the cells.
//
//  Parameters:
//
//      COLORREF crColor    New color property for the block of cells.
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetBlendState
//
//  If blend state is TRUE for a block of cells, then the blend color is applied
//  in a 50% dither pattern.
//
//  Parameters:
//
//      BOOL bState         Apply blend if TRUE.
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetUserValue
//
//  Store a user-defined DWORD with each cell in the block.
//
//  Parameters:
//
//      DWORD dwValue       User-defined value to store.
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetUserDataPtr
//
//  Store a user-defined pointer with each cell in the block.
//
//  Parameters:
//
//      LPVOID lpData       User-defined pointer to store.
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::MergeCells
//
//  Visually merges the specified block of cells to give them the appearance
//  of a contiguous block.  A merged block of cells does not contain the grid
//  lines that normally separate each cell.  Use this function to create
//  block areas that represent an event in the schedule.  Note that merged
//  blocks do not actually become a managed object in the matrix and that it
//  is therefore possible to merge a block of cells that intersects a
//  previously merged block.  It is the application's responsibility to track
//  these blocks and prevent or resolve any confusion from overlapping "merged"
//  blocks.
//
//  Parameters:
//
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::UnMergeCells
//
//  Removes the merge effect imposed by MergeCells.
//
//  Parameters:
//
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetMergeState
//
//  Retrieves the merge state of the specified block of cells.  A block can
//  have one of the following merge states:
//
//      MS_UNMERGED     No cell in the specified block is merged.
//      MS_MERGED       All cells in the specified block have been merged and
//                      in fact represent a "perfect" merge, i.e. all edges
//                      of the merged block have been accounted for.  An
//                      incomplete part of a merged block returns MS_MIXEDMERGE.
//      MS_MIXEDMERGE   The specified block is a mixture of merged and unmerged
//                      cells or an incomplete portion of a merged block has
//                      been specified.
//
//  Parameters:
//
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//  Returns:
//
//      UINT nState     MS_UNMERGED, MS_MERGED, or MS_MIXEDMERGE.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetBackColor
//
//  Retrieves the background color of the specified cell.
//
//  Parameters:
//
//      UINT nHour          Hour position of the cell.
//      UINT nDay           Day position of the cell.
//
//  Returns:
//
//      COLORREF crColor    Current color property for the cell.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetForeColor
//
//  Retrieves the foreground color of the specified cell.
//
//  Parameters:
//
//      UINT nHour          Hour position of the cell.
//      UINT nDay           Day position of the cell.
//
//  Returns:
//
//      COLORREF crColor    Current color property for the cell.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetPercentage
//
//  Retrieves the percentage of foreground to background color in the specified
//  cell.
//
//  Parameters:
//
//      UINT nHour          Hour position of the cell.
//      UINT nDay           Day position of the cell.
//
//  Returns:
//
//      UINT nPercent      Current percentage of foreground to background.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetBlendColor
//
//  Retrieves the blend color of the specified cell.
//
//  Parameters:
//
//      UINT nHour          Hour position of the cell.
//      UINT nDay           Day position of the cell.
//
//  Returns:
//
//      COLORREF crColor    Current color property for the cell.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetBlendState
//
//  Retrieves the blend state of the specified cell.  If blend state is TRUE,
//  the cell is currently being rendered with a 50% blend on top of the foreground
//  and background colors.
//
//  Parameters:
//
//      UINT nHour          Hour position of the cell.
//      UINT nDay           Day position of the cell.
//
//  Returns:
//
//      BOOL bState         TRUE if blend is turned on for this cell.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetUserValue
//
//  Returns the user-defined DWORD value associated with the specified cell.
//
//  Parameters:
//
//      UINT nHour          Hour position of the cell.
//      UINT nDay           Day position of the cell.
//
//  Returns:
//
//      DWORD dwValue       User-defined DWORD value.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetUserDataPtr
//
//  Returns the user-defined data pointer associated with the specified cell.
//
//  Parameters:
//
//      UINT nHour          Hour position of the cell.
//      UINT nDay           Day position of the cell.
//
//  Returns:
//
//      LPVOID lpData       User-defined pointer.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::~CScheduleMatrix
//
//  Destructor.
//
//****************************************************************************

class UITOOLS_CLASS CScheduleMatrix : public CWnd
{
    DECLARE_DYNAMIC(CScheduleMatrix)

// Construction
public:
	CScheduleMatrix();
	CScheduleMatrix(UINT nType);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CScheduleMatrix)
	public:
	//}}AFX_VIRTUAL
    virtual BOOL Create(LPCTSTR lpszWindowName, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);

// Implementation
public:
	void SetType(UINT nType);
    BOOL DeselectAll();
    BOOL SelectAll();
	BOOL SetSel(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays);
	void GetSel(UINT& nHour, UINT& nDay, UINT& nNumHours, UINT& nNumDays);
    void GetSelDescription(CString &sText);
    BOOL CellInSel(UINT nHour, UINT nDay);
    CSize GetCellSize();
    void DrawCell(CDC *pdc, LPCRECT pRect, UINT nPercent, BOOL bBlendState = FALSE,
        COLORREF crBackColor = DEFBACKCOLOR, COLORREF crForeColor = DEFFORECOLOR,
        COLORREF crBlendColor = DEFBLENDCOLOR);
	void SetBackColor(COLORREF crColor, UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	void SetForeColor(COLORREF crColor, UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	void SetPercentage(UINT nPercent, UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	void SetBlendColor(COLORREF crColor, UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	void SetBlendState(BOOL bState, UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	void SetUserValue(DWORD dwValue, UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	void SetUserDataPtr(LPVOID lpData, UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	void MergeCells(UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	void UnMergeCells(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays=1);
    UINT GetMergeState(UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	COLORREF GetBackColor(UINT nHour, UINT nDay);
	COLORREF GetForeColor(UINT nHour, UINT nDay);
	UINT GetPercentage(UINT nHour, UINT nDay);
	COLORREF GetBlendColor(UINT nHour, UINT nDay);
	BOOL GetBlendState(UINT nHour, UINT nDay);
	DWORD GetUserValue(UINT nHour, UINT nDay);
	LPVOID GetUserDataPtr(UINT nHour, UINT nDay);
    void GetDescription(CString &sText, UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	virtual ~CScheduleMatrix();

protected:
    CHourLegend m_HourLegend;
    CPercentLabel m_PercentLabel;
    UINT m_nType;

    // Data
    CMatrixCell m_CellArray[24][7];

    // Metrics
    UINT m_nCellWidth;
    UINT m_nCellHeight;
    CRect m_rHourLegend;
    CRect m_rAllHeader;
    CRect m_rHourHeader;
    CRect m_rDayHeader;
    CRect m_rCellArray;
    CRect m_rPercentLabel;

    CString m_DayStrings[8];

    // Selection
    UINT m_nSelHour, m_nSelDay, m_nNumSelHours, m_nNumSelDays;
    UINT m_nSaveHour, m_nSaveDay, m_nNumSaveHours, m_nNumSaveDays;

    // Work vars
    CBrush m_brBlend, m_brMask;
    CBitmap m_bmBlend, m_bmMask;
    HFONT m_hFont;
    CPoint m_ptDown, m_ptFocus;
    BOOL m_bShifted;

    // Generated message map functions
protected:
	CString FormatTime (UINT nHour) const;
	//{{AFX_MSG(CScheduleMatrix)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnPaint();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg UINT OnGetDlgCode();
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

    afx_msg LRESULT OnSetFont( WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetFont( WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetObject (WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetSelDescription (WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetPercentage (WPARAM wParam, LPARAM lParam);

	BOOL SetSelValues(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays);
    void InvalidateCells(UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1,
        BOOL bErase = TRUE);
    void SetMatrixMetrics(int cx, int cy);
    void CellToClient(LONG &nX, LONG &nY);
    void ClientToCell(LONG &nX, LONG &nY);
	void DrawCell(CDC *pdc, CMatrixCell *pCell, int x, int y, int w, int h);
	void DrawHeader(CDC *pdc, LPCRECT lpRect, LPCTSTR pszText, BOOL bSelected);
    void Press(CPoint pt, BOOL bExtend);
    void Extend(CPoint pt);
    void Release(CPoint pt);

    DECLARE_MESSAGE_MAP()

private:
    CString GetLocaleDay (LCTYPE lcType) const;

    IAccessible * m_pWrapAcc;
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _SCHEDMAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\stdafx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       stdafx.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// stdafx.cpp : source file that includes just the standard includes
//	LogHours.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\loghours\stdafx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       stdafx.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__0F68A43D_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_)
#define AFX_STDAFX_H__0F68A43D_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#pragma warning(push,3)

#include <xstring>
#include <list>
#include <vector>
#include <algorithm>

using namespace std;

#pragma warning(pop)

#include "debug.h"
#include "resource.h"

#define IID_PPV_ARG(Type, Expr) IID_##Type, \
	reinterpret_cast<void**>(static_cast<Type **>(Expr))

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0F68A43D_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\cdlink.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       cdlink.cxx
//
//  Contents:
//
//  Classes:    CDlink
//
//  History:    16-Oct-91  KevinRo Created
//
//--------------------------------------------------------------------------

#include "pch.h"

//+-------------------------------------------------------------------------
//
// Member:      CDLink::LinkAfter
//
// Purpose:     Links this after dlPrev and before dlPrev->_dlNext
//
// Returns:     this
//
// Note:        None.
//
//--------------------------------------------------------------------------
VOID CDLink::LinkAfter(CDLink * dlPrev)
{
    _dlPrev = dlPrev;

    if(dlPrev != NULL)
    {
        _dlNext = dlPrev->_dlNext;
        dlPrev->_dlNext = this;

        if(_dlNext != NULL) {
            _dlNext->_dlPrev = this;
        }
    }
    else
    {
        _dlNext = NULL;
    }
}
//+-------------------------------------------------------------------------
//
// Member:      CDLink::LinkBefore
//
// Purpose:     Links this Before dlNext and after dlNext->_dlPrev
//
// Returns:     this
//
//--------------------------------------------------------------------------
VOID CDLink::LinkBefore(CDLink * dlNext)
{
    _dlNext = dlNext;

    if(dlNext != NULL)
    {
        _dlPrev = dlNext->_dlPrev;

        dlNext->_dlPrev = this;

        if(_dlPrev != NULL) {
            _dlPrev->_dlNext = this;
        }
    }
    else
    {
        _dlPrev = NULL;
    }
}

//+-------------------------------------------------------------------------
//
// Member:      CDLink::Unlink()
//
// Purpose:     Removes this from double linked list
//
// Returns:     this
//
//--------------------------------------------------------------------------
VOID CDLink::UnLink()
{
    if(_dlNext != NULL) {
        _dlNext->_dlPrev = _dlPrev;
    }
    if(_dlPrev != NULL) {
        _dlPrev->_dlNext = _dlNext;
    }
    _dlNext = _dlPrev = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\dll.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       dll.h
//
//  Contents:   DLL refcounting classes, wait cursor class, and error reporting
//              functions.
//
//  Classes:    CDll, CDllRef
//
//  History:    1/24/1996   RaviR   Created
//              6/09/1997   EricB   Error Reporting.
//
//____________________________________________________________________________

#ifndef _DLL_H_
#define _DLL_H_

#define MAX_TITLE       80
#define MAX_MSG_LEN     512
#define MAX_ERRORMSG    MAX_MSG_LEN

void LoadErrorMessage(HRESULT hr, int nStr, PTSTR* pptsz);

class CDll
{
public:

    static ULONG AddRef() { return InterlockedIncrement((LONG*)&s_cObjs); }
    static ULONG Release() { return InterlockedDecrement((LONG*)&s_cObjs); }

    static void LockServer(BOOL fLock) {
        (fLock == TRUE) ? InterlockedIncrement((LONG*)&s_cLocks)
                        : InterlockedDecrement((LONG*)&s_cLocks);
    }

    static HRESULT CanUnloadNow(void) {
        return (0L == s_cObjs && 0L == s_cLocks) ? S_OK : S_FALSE;
    }

    static ULONG s_cObjs;
    static ULONG s_cLocks;

};  // class CDll


class CDllRef
{
public:

    CDllRef(void) { CDll::AddRef(); }
    ~CDllRef(void) { CDll::Release(); }

}; // class CDllRef


class CWaitCursor
{
public:
    CWaitCursor() {m_cOld=SetCursor(m_cWait=LoadCursor(NULL, IDC_WAIT));}
    ~CWaitCursor() {SetCursor(m_cOld);}

    void SetWait() {SetCursor(m_cWait);}
    void SetOld() {SetCursor(m_cOld);}

private:
    HCURSOR m_cWait;
    HCURSOR m_cOld;
} ;

// This wrapper function required to make prefast shut up when we are 
// initializing a critical section in a constructor.

void ExceptionPropagatingInitializeCriticalSection(LPCRITICAL_SECTION critsec);

#endif // _DLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\dsprop.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       dsprop.cxx
//
//  Contents:   Tables for common values for table-driven DS property pages
//
//  History:    14-July-97 Jimharr created from dsprop.cxx by ericb
//
//  Note:       Attribute LDAP display names, types, upper ranges, and so
//              forth, have been manually copied from schema.ini. Thus,
//              consistency is going to be difficult to maintain. If you know
//              of schema.ini changes that affect any of the attributes in
//              this file, then please make any necessary corrections here.
//
//              this file is #INCLUDE'd in shlprop.cxx & pagetable.cxx
//-----------------------------------------------------------------------------

// NOTE: We are handling unlimited length strings by allowing a fixed but huge length
#define ATTR_LEN_UNLIMITED  32000

//
// Attributes common to more than one object class.
//

//
// General page, icon
//
ATTR_MAP GenIcon = {IDC_DS_ICON, TRUE, FALSE, 0, {NULL, ADS_ATTR_UPDATE,
                    ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, GeneralPageIcon, NULL};
//
// Name
//
ATTR_MAP AttrName = {IDC_CN, TRUE, FALSE, 64,
                     {g_wzName, ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                      NULL, 0}, NULL, NULL};
//
// Description
//
ATTR_MAP Description = {IDC_DESCRIPTION_EDIT, FALSE, FALSE, 1024,
                        {g_wzDescription, ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};

//+----------------------------------------------------------------------------
// User Object common stuff.
//-----------------------------------------------------------------------------

//
// Address page, Address
//
ATTR_MAP UAddrAddress = {IDC_ADDRESS_EDIT, FALSE, FALSE, 1024,
                         {g_wzStreet, ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Address page, POBox (Post-Office-Box)
//
ATTR_MAP UAddrPOBox = {IDC_POBOX_EDIT, FALSE, FALSE, 40,
                       {g_wzPOB, ADS_ATTR_UPDATE,
                        ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Address page, City (Locality-Name)
//
ATTR_MAP UAddrCity = {IDC_CITY_EDIT, FALSE, FALSE, 128,
                      {g_wzCity, ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                       NULL, 0}, NULL, NULL};
//
// Address page, State (State-Or-Provence-Name)
//
ATTR_MAP UAddrState = {IDC_STATE_EDIT, FALSE, FALSE, 128,
                       {g_wzState, ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                        NULL, 0}, NULL, NULL};
//
// Address page, ZIP (Postal-Code)
//
ATTR_MAP UAddrZIP = {IDC_ZIP_EDIT, FALSE, FALSE, 40,
                     {g_wzZIP, ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Address page, CountryName
//
ATTR_MAP UAddrCntryName = {IDC_COUNTRY_COMBO, FALSE, FALSE, 3,
                         {g_wzCountryName, ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                         NULL, 0}, CountryName, NULL};
//
// Address page, CountryCode. Thus MUST be after UAddrCntryName.
//
ATTR_MAP UAddrCntryCode = {IDC_COUNTRY_COMBO, FALSE, FALSE, 3,
                         {g_wzCountryCode, ADS_ATTR_UPDATE, ADSTYPE_INTEGER,
                         NULL, 0}, CountryCode, NULL};
//
// Address page, Text-Country
//
ATTR_MAP UAddrTextCntry = {IDC_COUNTRY_COMBO, FALSE, FALSE, 128,
                     {g_wzTextCountry, ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, TextCountry, NULL};


//
// The list of attributes on the Address page.
//
PATTR_MAP rgpUAddrAttrMap[] = {{&UAddrAddress}, {&UAddrPOBox}, {&UAddrCity},
                               {&UAddrState}, {&UAddrCntryName},
                               {&UAddrCntryCode},{&UAddrTextCntry}, {&UAddrZIP}};
//
// Address page description.
//
DSPAGE UserAddress = {IDS_TITLE_ADDRESS, IDD_ADDRESS, 0, 0, NULL,
                      CreateTableDrivenPage,
                      sizeof(rgpUAddrAttrMap)/sizeof(PATTR_MAP),
                      rgpUAddrAttrMap};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\cstr.h ===
// This is copied from the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation, 1992 - 1999
// All rights reserved.
//
// This has been modified from the original MFC version to provide
// two classes: CStrW manipulates and stores only wide char strings,
// and CStr uses TCHARs.
// 

#ifndef __STR_H__
#define __STR_H__

#include <wchar.h>
#include <tchar.h>

#define STRAPI __stdcall
struct _STR_DOUBLE  { BYTE doubleBits[sizeof(double)]; };

BOOL STRAPI IsValidString(LPCSTR lpsz, int nLength);
BOOL STRAPI IsValidString(LPCWSTR lpsz, int nLength);

BOOL STRAPI IsValidAddressz(const void* lp, UINT nBytes, BOOL bReadWrite=TRUE);

int  STRAPI StrLoadString(HINSTANCE hInst, UINT nID, LPTSTR lpszBuf); 
int  STRAPI StrLoadStringW(HINSTANCE hInst, UINT nID, LPWSTR lpszBuf); 

class CStr
{
public:

// Constructors
        CStr();
        CStr(const CStr& stringSrc);
        CStr(TCHAR ch, int nRepeat = 1);
        CStr(LPCSTR lpsz);
        CStr(LPCWSTR lpsz);
        CStr(LPCTSTR lpch, int nLength);
        CStr(const unsigned char* psz);

// Attributes & Operations
        // as an array of characters
        int GetLength() const;
        BOOL IsEmpty() const;
        void Empty();                       // free up the data

        TCHAR GetAt(int nIndex) const;      // 0 based
        TCHAR operator[](int nIndex) const; // same as GetAt
        void SetAt(int nIndex, TCHAR ch);
        operator LPCTSTR() const;           // as a C string

        // overloaded assignment
        const CStr& operator=(const CStr& stringSrc);
        const CStr& operator=(TCHAR ch);
#ifdef UNICODE
        const CStr& operator=(char ch);
#endif
        const CStr& operator=(LPCSTR lpsz);
        const CStr& operator=(LPCWSTR lpsz);
        const CStr& operator=(const unsigned char* psz);

        // string concatenation
        const CStr& operator+=(const CStr& string);
        const CStr& operator+=(TCHAR ch);
#ifdef UNICODE
        const CStr& operator+=(char ch);
#endif
        const CStr& operator+=(LPCTSTR lpsz);

        friend CStr STRAPI operator+(const CStr& string1,
                        const CStr& string2);
        friend CStr STRAPI operator+(const CStr& string, TCHAR ch);
        friend CStr STRAPI operator+(TCHAR ch, const CStr& string);
#ifdef UNICODE
        friend CStr STRAPI operator+(const CStr& string, char ch);
        friend CStr STRAPI operator+(char ch, const CStr& string);
#endif
        friend CStr STRAPI operator+(const CStr& string, LPCTSTR lpsz);
        friend CStr STRAPI operator+(LPCTSTR lpsz, const CStr& string);

        // string comparison
        int Compare(LPCTSTR lpsz) const;         // straight character
        int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
        int Collate(LPCTSTR lpsz) const;         // NLS aware

        // simple sub-string extraction
        CStr Mid(int nFirst, int nCount) const;
        CStr Mid(int nFirst) const;
        CStr Left(int nCount) const;
        CStr Right(int nCount) const;

        CStr SpanIncluding(LPCTSTR lpszCharSet) const;
        CStr SpanExcluding(LPCTSTR lpszCharSet) const;

        // upper/lower/reverse conversion
        void MakeUpper();
        void MakeLower();
        void MakeReverse();

        // trimming whitespace (either side)
        void TrimRight();
        void TrimLeft();

        // searching (return starting index, or -1 if not found)
        // look for a single character match
        int Find(TCHAR ch) const;               // like "C" strchr
        int ReverseFind(TCHAR ch) const;
        int FindOneOf(LPCTSTR lpszCharSet) const;

        // look for a specific sub-string
        int Find(LPCTSTR lpszSub) const;        // like "C" strstr

        // simple formatting
        void Format(LPCTSTR lpszFormat, ...);

        // Windows support
        BOOL LoadString(HINSTANCE hInst, UINT nID);          // load from string resource
                                                                                // 255 chars max
        BSTR AllocSysString();
        BSTR SetSysString(BSTR* pbstr);

        // Access to string implementation buffer as "C" character array
        LPTSTR GetBuffer(int nMinBufLength);
        void ReleaseBuffer(int nNewLength = -1);
        LPTSTR GetBufferSetLength(int nNewLength);
        void FreeExtra();

// Implementation
public:
        ~CStr();
        int GetAllocLength() const;

protected:
        // lengths/sizes in characters
        //  (note: an extra character is always allocated)
        LPTSTR m_pchData;           // actual string (zero terminated)
        int m_nDataLength;          // does not include terminating 0
        int m_nAllocLength;         // does not include terminating 0

        // implementation helpers
        void Init();
        void AllocCopy(CStr& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
        BOOL AllocBuffer(int nLen);
        void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
        void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
        void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
        static void SafeDelete(LPTSTR& lpch);
        static int SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
bool STRAPI operator==(const CStr& s1, const CStr& s2);
bool STRAPI operator==(const CStr& s1, LPCTSTR s2);
bool STRAPI operator==(LPCTSTR s1, const CStr& s2);
bool STRAPI operator!=(const CStr& s1, const CStr& s2);
bool STRAPI operator!=(const CStr& s1, LPCTSTR s2);
bool STRAPI operator!=(LPCTSTR s1, const CStr& s2);
bool STRAPI operator<(const CStr& s1, const CStr& s2);
bool STRAPI operator<(const CStr& s1, LPCTSTR s2);
bool STRAPI operator<(LPCTSTR s1, const CStr& s2);
bool STRAPI operator>(const CStr& s1, const CStr& s2);
bool STRAPI operator>(const CStr& s1, LPCTSTR s2);
bool STRAPI operator>(LPCTSTR s1, const CStr& s2);
bool STRAPI operator<=(const CStr& s1, const CStr& s2);
bool STRAPI operator<=(const CStr& s1, LPCTSTR s2);
bool STRAPI operator<=(LPCTSTR s1, const CStr& s2);
bool STRAPI operator>=(const CStr& s1, const CStr& s2);
bool STRAPI operator>=(const CStr& s1, LPCTSTR s2);
bool STRAPI operator>=(LPCTSTR s1, const CStr& s2);

// conversion helpers
int mmc_wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int mmc_mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern const CStr strEmptyStringT;
extern TCHAR strChNilT;

// Compiler doesn't inline for DBG
/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

inline int CStr::SafeStrlen(LPCTSTR lpsz)
        { return (int)((lpsz == NULL) ? NULL : _tcslen(lpsz)); }
inline CStr::CStr(const unsigned char* lpsz)
        { Init(); *this = (LPCSTR)lpsz; }
inline const CStr& CStr::operator=(const unsigned char* lpsz)
        { *this = (LPCSTR)lpsz; return *this; }

#ifdef _UNICODE
inline const CStr& CStr::operator+=(char ch)
        { *this += (TCHAR)ch; return *this; }
inline const CStr& CStr::operator=(char ch)
        { *this = (TCHAR)ch; return *this; }
inline CStr STRAPI operator+(const CStr& string, char ch)
        { return string + (TCHAR)ch; }
inline CStr STRAPI operator+(char ch, const CStr& string)
        { return (TCHAR)ch + string; }
#endif

inline int CStr::GetLength() const
        { return m_nDataLength; }
inline int CStr::GetAllocLength() const
        { return m_nAllocLength; }
inline BOOL CStr::IsEmpty() const
        { return m_nDataLength == 0; }
inline CStr::operator LPCTSTR() const
        { return (LPCTSTR)m_pchData; }

// String support (windows specific)
// NOTICE-2002/02/19-ericb - SecurityPush: the following 3 methods fixed to do input param validation.
inline int CStr::Compare(LPCTSTR lpsz) const
   {
      if (!lpsz)
      {
         dspAssert(false);
         return _NLSCMPERROR;
      }
      return _tcscmp(m_pchData, lpsz); // MBCS/Unicode aware
   }
inline int CStr::CompareNoCase(LPCTSTR lpsz) const
   {
      if (!lpsz)
      {
         dspAssert(false);
         return _NLSCMPERROR;
      }
      return _tcsicmp(m_pchData, lpsz); // MBCS/Unicode aware
   }
// CStr::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CStr::Collate(LPCTSTR lpsz) const
   {
      if (!lpsz)
      {
         dspAssert(false);
         return _NLSCMPERROR;
      }
      return _tcscoll(m_pchData, lpsz); // locale sensitive
   }
inline void CStr::MakeUpper()
        { ::CharUpper(m_pchData); }
inline void CStr::MakeLower()
        { ::CharLower(m_pchData); }

inline void CStr::MakeReverse()
        { _tcsrev(m_pchData); }
// NOTICE-2002/02/19-ericb - SecurityPush: the following 3 methods fixed to do input param validation.
inline TCHAR CStr::GetAt(int nIndex) const
        {
                if (nIndex < 0 ||
                    nIndex >= m_nDataLength)
                {
                   dspAssert(false);
                   return 0;
                }

                return m_pchData[nIndex];
        }
inline TCHAR CStr::operator[](int nIndex) const
        {
                // same as GetAt

                if (nIndex < 0 ||
                    nIndex >= m_nDataLength)
                {
                   dspAssert(false);
                   return 0;
                }

                return m_pchData[nIndex];
        }
inline void CStr::SetAt(int nIndex, TCHAR ch)
        {
                if (nIndex < 0 ||
                    nIndex >= m_nDataLength)
                {
                   dspAssert(false);
                   return;
                }
                dspAssert(ch != 0);

                m_pchData[nIndex] = ch;
        }
inline bool STRAPI operator==(const CStr& s1, const CStr& s2)
        { return s1.Compare(s2) == 0; }
inline bool STRAPI operator==(const CStr& s1, LPCTSTR s2)
        { return s1.Compare(s2) == 0; }
inline bool STRAPI operator==(LPCTSTR s1, const CStr& s2)
        { return s2.Compare(s1) == 0; }
inline bool STRAPI operator!=(const CStr& s1, const CStr& s2)
        { return s1.Compare(s2) != 0; }
inline bool STRAPI operator!=(const CStr& s1, LPCTSTR s2)
        { return s1.Compare(s2) != 0; }
inline bool STRAPI operator!=(LPCTSTR s1, const CStr& s2)
        { return s2.Compare(s1) != 0; }
inline bool STRAPI operator<(const CStr& s1, const CStr& s2)
        { return s1.Compare(s2) < 0; }
inline bool STRAPI operator<(const CStr& s1, LPCTSTR s2)
        { return s1.Compare(s2) < 0; }
inline bool STRAPI operator<(LPCTSTR s1, const CStr& s2)
        { return s2.Compare(s1) > 0; }
inline bool STRAPI operator>(const CStr& s1, const CStr& s2)
        { return s1.Compare(s2) > 0; }
inline bool STRAPI operator>(const CStr& s1, LPCTSTR s2)
        { return s1.Compare(s2) > 0; }
inline bool STRAPI operator>(LPCTSTR s1, const CStr& s2)
        { return s2.Compare(s1) < 0; }
inline bool STRAPI operator<=(const CStr& s1, const CStr& s2)
        { return s1.Compare(s2) <= 0; }
inline bool STRAPI operator<=(const CStr& s1, LPCTSTR s2)
        { return s1.Compare(s2) <= 0; }
inline bool STRAPI operator<=(LPCTSTR s1, const CStr& s2)
        { return s2.Compare(s1) >= 0; }
inline bool STRAPI operator>=(const CStr& s1, const CStr& s2)
        { return s1.Compare(s2) >= 0; }
inline bool STRAPI operator>=(const CStr& s1, LPCTSTR s2)
        { return s1.Compare(s2) >= 0; }
inline bool STRAPI operator>=(LPCTSTR s1, const CStr& s2)
        { return s2.Compare(s1) <= 0; }

// General Exception for memory
class MemoryException
{
public:
        MemoryException(){}
        void DisplayMessage()
        {
        ::MessageBox(NULL, _T("Memory Exception"), _T("System Out of Memory"), MB_OK|MB_ICONSTOP);
        }
};

// General Exception for memory
class ResourceException
{
public:
        ResourceException()
        {
        ::MessageBox(NULL, _T("Resource Exception"), _T("Unable to Load Resource"), MB_OK|MB_ICONSTOP);
        }
};

class CStrW
{
public:

// Constructors
        CStrW();
        CStrW(const CStrW& stringSrc);
        CStrW(WCHAR ch, int nRepeat = 1);
        CStrW(LPCSTR lpsz);
        CStrW(LPCWSTR lpsz);
        CStrW(LPCWSTR lpch, int nLength);
        CStrW(const unsigned char* psz);

// Attributes & Operations
        // as an array of characters
        int GetLength() const;
        BOOL IsEmpty() const;
        void Empty();                       // free up the data

        WCHAR GetAt(int nIndex) const;      // 0 based
        WCHAR operator[](int nIndex) const; // same as GetAt
        void SetAt(int nIndex, WCHAR ch);
        operator LPCWSTR() const;           // as a C string
        operator PWSTR();                   // as a C string

        // overloaded assignment
        const CStrW& operator=(const CStrW& stringSrc);
        const CStrW& operator=(WCHAR ch);
#ifdef UNICODE
        const CStrW& operator=(char ch);
#endif
        const CStrW& operator=(LPCSTR lpsz);
        const CStrW& operator=(LPCWSTR lpsz);
        const CStrW& operator=(const unsigned char* psz);
   const CStrW& operator=(UNICODE_STRING unistr);
   const CStrW& operator=(UNICODE_STRING * punistr);

        // string concatenation
        const CStrW& operator+=(const CStrW& string);
        const CStrW& operator+=(WCHAR ch);
#ifdef UNICODE
        const CStrW& operator+=(char ch);
#endif
        const CStrW& operator+=(LPCWSTR lpsz);

        friend CStrW STRAPI operator+(const CStrW& string1,
                        const CStrW& string2);
        friend CStrW STRAPI operator+(const CStrW& string, WCHAR ch);
        friend CStrW STRAPI operator+(WCHAR ch, const CStrW& string);
#ifdef UNICODE
        friend CStrW STRAPI operator+(const CStrW& string, char ch);
        friend CStrW STRAPI operator+(char ch, const CStrW& string);
#endif
        friend CStrW STRAPI operator+(const CStrW& string, LPCWSTR lpsz);
        friend CStrW STRAPI operator+(LPCWSTR lpsz, const CStrW& string);

        // string comparison
        int Compare(LPCWSTR lpsz) const;         // straight character
        int CompareNoCase(LPCWSTR lpsz) const;   // ignore case
        int Collate(LPCWSTR lpsz) const;         // NLS aware

        // simple sub-string extraction
        CStrW Mid(int nFirst, int nCount) const;
        CStrW Mid(int nFirst) const;
        CStrW Left(int nCount) const;
        CStrW Right(int nCount) const;

        CStrW SpanIncluding(LPCWSTR lpszCharSet) const;
        CStrW SpanExcluding(LPCWSTR lpszCharSet) const;

        // upper/lower/reverse conversion
        void MakeUpper();
        void MakeLower();
        void MakeReverse();

        // trimming whitespace (either side)
        void TrimRight();
        void TrimLeft();

        // searching (return starting index, or -1 if not found)
        // look for a single character match
        int Find(WCHAR ch) const;               // like "C" strchr
        int ReverseFind(WCHAR ch) const;
        int FindOneOf(LPCWSTR lpszCharSet) const;

        // look for a specific sub-string
        int Find(LPCWSTR lpszSub) const;        // like "C" strstr

        // simple formatting
        void Format(LPCWSTR lpszFormat, ...);

   // formatting for localization (uses FormatMessage API)

   // format using FormatMessage API on passed string
   void FormatMessage(PCWSTR pwzFormat, ...);
   // format using FormatMessage API on referenced string resource
   void FormatMessage(HINSTANCE hInst, UINT nFormatID, ...);

        // Windows support
        BOOL LoadString(HINSTANCE hInst, UINT nID);          // load from string resource
                                                                                // 255 chars max
        BSTR AllocSysString();
        BSTR SetSysString(BSTR* pbstr);

        // Access to string implementation buffer as "C" character array
        PWSTR GetBuffer(int nMinBufLength);
        void ReleaseBuffer(int nNewLength = -1);
        PWSTR GetBufferSetLength(int nNewLength);
        void FreeExtra();

// Implementation
public:
        ~CStrW();
        int GetAllocLength() const;

protected:
        // lengths/sizes in characters
        //  (note: an extra character is always allocated)
        PWSTR m_pchData;           // actual string (zero terminated)
        int m_nDataLength;          // does not include terminating 0
        int m_nAllocLength;         // does not include terminating 0

        // implementation helpers
        void Init();
        void AllocCopy(CStrW& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
        BOOL AllocBuffer(int nLen);
        void AssignCopy(int nSrcLen, LPCWSTR lpszSrcData);
        void ConcatCopy(int nSrc1Len, LPCWSTR lpszSrc1Data, int nSrc2Len, LPCWSTR lpszSrc2Data);
        void ConcatInPlace(int nSrcLen, LPCWSTR lpszSrcData);
        static void SafeDelete(PWSTR& lpch);
        static int SafeStrlen(LPCWSTR lpsz);
};

// Compare helpers
bool STRAPI operator==(const CStrW& s1, const CStrW& s2);
bool STRAPI operator==(const CStrW& s1, LPCWSTR s2);
bool STRAPI operator==(LPCWSTR s1, const CStrW& s2);
bool STRAPI operator!=(const CStrW& s1, const CStrW& s2);
bool STRAPI operator!=(const CStrW& s1, LPCWSTR s2);
bool STRAPI operator!=(LPCWSTR s1, const CStrW& s2);
bool STRAPI operator<(const CStrW& s1, const CStrW& s2);
bool STRAPI operator<(const CStrW& s1, LPCWSTR s2);
bool STRAPI operator<(LPCWSTR s1, const CStrW& s2);
bool STRAPI operator>(const CStrW& s1, const CStrW& s2);
bool STRAPI operator>(const CStrW& s1, LPCWSTR s2);
bool STRAPI operator>(LPCWSTR s1, const CStrW& s2);
bool STRAPI operator<=(const CStrW& s1, const CStrW& s2);
bool STRAPI operator<=(const CStrW& s1, LPCWSTR s2);
bool STRAPI operator<=(LPCWSTR s1, const CStrW& s2);
bool STRAPI operator>=(const CStrW& s1, const CStrW& s2);
bool STRAPI operator>=(const CStrW& s1, LPCWSTR s2);
bool STRAPI operator>=(LPCWSTR s1, const CStrW& s2);

// conversion helpers
int mmc_wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int mmc_mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern const CStrW strEmptyStringW;
extern WCHAR strChNilW;

// Compiler doesn't inline for DBG
/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

inline int CStrW::SafeStrlen(LPCWSTR lpsz)
        { return (int)((lpsz == NULL) ? NULL : wcslen(lpsz)); }
inline CStrW::CStrW(const unsigned char* lpsz)
        { Init(); *this = (LPCSTR)lpsz; }
inline const CStrW& CStrW::operator=(const unsigned char* lpsz)
        { *this = (LPCSTR)lpsz; return *this; }

#ifdef _UNICODE
inline const CStrW& CStrW::operator+=(char ch)
        { *this += (WCHAR)ch; return *this; }
inline const CStrW& CStrW::operator=(char ch)
        { *this = (WCHAR)ch; return *this; }
inline CStrW STRAPI operator+(const CStrW& string, char ch)
        { return string + (WCHAR)ch; }
inline CStrW STRAPI operator+(char ch, const CStrW& string)
        { return (WCHAR)ch + string; }
#endif

inline int CStrW::GetLength() const
        { return m_nDataLength; }
inline int CStrW::GetAllocLength() const
        { return m_nAllocLength; }
inline BOOL CStrW::IsEmpty() const
        { return m_nDataLength == 0; }
inline CStrW::operator LPCWSTR() const
        { return (LPCWSTR)m_pchData; }
inline CStrW::operator PWSTR()
        { return m_pchData; }

// String support (windows specific)
// NOTICE-2002/02/19-ericb - SecurityPush: the following 3 methods fixed to do input param validation.
inline int CStrW::Compare(LPCWSTR lpsz) const
   {
      if (!lpsz)
      {
         dspAssert(false);
         return _NLSCMPERROR;
      }
      return wcscmp(m_pchData, lpsz); // MBCS/Unicode aware
   }
inline int CStrW::CompareNoCase(LPCWSTR lpsz) const
   {
      if (!lpsz)
      {
         dspAssert(false);
         return _NLSCMPERROR;
      }
      return _wcsicmp(m_pchData, lpsz); // MBCS/Unicode aware
   }
// CStrW::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CStrW::Collate(LPCWSTR lpsz) const
   {
      if (!lpsz)
      {
         dspAssert(false);
         return _NLSCMPERROR;
      }
      return wcscoll(m_pchData, lpsz); // locale sensitive
   }
inline void CStrW::MakeUpper()
        { ::CharUpperW(m_pchData); }
inline void CStrW::MakeLower()
        { ::CharLowerW(m_pchData); }

inline void CStrW::MakeReverse()
        { wcsrev(m_pchData); }
// NOTICE-2002/02/19-ericb - SecurityPush: the following 3 methods fixed to do input param validation.
inline WCHAR CStrW::GetAt(int nIndex) const
        {
                if (nIndex < 0 ||
                    nIndex >= m_nDataLength)
                {
                   dspAssert(false);
                   return 0;
                }

                return m_pchData[nIndex];
        }
inline WCHAR CStrW::operator[](int nIndex) const
        {
                // same as GetAt

                if (nIndex < 0 ||
                    nIndex >= m_nDataLength)
                {
                   dspAssert(false);
                   return 0;
                }

                return m_pchData[nIndex];
        }
inline void CStrW::SetAt(int nIndex, WCHAR ch)
        {
                if (nIndex < 0 ||
                    nIndex >= m_nDataLength)
                {
                   dspAssert(false);
                   return;
                }
                dspAssert(ch != 0);

                m_pchData[nIndex] = ch;
        }
inline bool STRAPI operator==(const CStrW& s1, const CStrW& s2)
        { return s1.Compare(s2) == 0; }
inline bool STRAPI operator==(const CStrW& s1, LPCWSTR s2)
        { return s1.Compare(s2) == 0; }
inline bool STRAPI operator==(LPCWSTR s1, const CStrW& s2)
        { return s2.Compare(s1) == 0; }
inline bool STRAPI operator!=(const CStrW& s1, const CStrW& s2)
        { return s1.Compare(s2) != 0; }
inline bool STRAPI operator!=(const CStrW& s1, LPCWSTR s2)
        { return s1.Compare(s2) != 0; }
inline bool STRAPI operator!=(LPCWSTR s1, const CStrW& s2)
        { return s2.Compare(s1) != 0; }
inline bool STRAPI operator<(const CStrW& s1, const CStrW& s2)
        { return s1.Compare(s2) < 0; }
inline bool STRAPI operator<(const CStrW& s1, LPCWSTR s2)
        { return s1.Compare(s2) < 0; }
inline bool STRAPI operator<(LPCWSTR s1, const CStrW& s2)
        { return s2.Compare(s1) > 0; }
inline bool STRAPI operator>(const CStrW& s1, const CStrW& s2)
        { return s1.Compare(s2) > 0; }
inline bool STRAPI operator>(const CStrW& s1, LPCWSTR s2)
        { return s1.Compare(s2) > 0; }
inline bool STRAPI operator>(LPCWSTR s1, const CStrW& s2)
        { return s2.Compare(s1) < 0; }
inline bool STRAPI operator<=(const CStrW& s1, const CStrW& s2)
        { return s1.Compare(s2) <= 0; }
inline bool STRAPI operator<=(const CStrW& s1, LPCWSTR s2)
        { return s1.Compare(s2) <= 0; }
inline bool STRAPI operator<=(LPCWSTR s1, const CStrW& s2)
        { return s2.Compare(s1) >= 0; }
inline bool STRAPI operator>=(const CStrW& s1, const CStrW& s2)
        { return s1.Compare(s2) >= 0; }
inline bool STRAPI operator>=(const CStrW& s1, LPCWSTR s2)
        { return s1.Compare(s2) >= 0; }
inline bool STRAPI operator>=(LPCWSTR s1, const CStrW& s2)
        { return s2.Compare(s1) <= 0; }

//
// Added by JonN 4/16/98
//
class CStrListItem
{
public:
    CStr str;
    CStrListItem* pnext;
};
void FreeCStrList( IN OUT CStrListItem** ppList );
void CStrListAdd( IN OUT CStrListItem** ppList, IN LPCTSTR lpsz );
int CountCStrList( IN CStrListItem** ppList );

#endif // __STR_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       debug.h
//
//  Contents:   Debug routines and miscelaneous stuff.
//
//  Classes:    None.
//
//  History:    24-Mar-97   EricB   Created
//
//  Notes on Error Handling: The general rule is that errors will be reported
//  to the user as close to the detection of the error as possible. There are
//  two exceptions to this rule. First, utility routines that don't take an
//  HWND parameter (or a page object pointer) don't report errors because we
//  want a window handle so that the error dialogs will be modal. Second,
//  there are some circumstances where the error needs to be interpreted at a
//  higher level. These exceptions should be noted where they occur.
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_HXX__
#define __DEBUG_HXX__

// macros

#define ByteOffset(base, offset) (((LPBYTE)base)+offset)

//+----------------------------------------------------------------------------
// Macro: LOAD_STRING
// Purpose: attempts to load a string, takes "action" if fails
//-----------------------------------------------------------------------------
#define LOAD_STRING(ids, wcs, len, action) \
    if (!LoadString(g_hInstance, ids, wcs, len - 1)) \
    { \
        DWORD dwErr = GetLastError(); \
        dspDebugOut((DEB_ERROR, "LoadString of " #ids " failed with error %lu\n", dwErr)); \
        action; \
    }

//+----------------------------------------------------------------------------
// Function: LoadStringReport
// Purpose: attempts to load a string, returns FALSE and gives error message
//          if a failure occurs.
//-----------------------------------------------------------------------------
BOOL LoadStringReport(int ids, PTSTR ptsz, int len, HWND hwnd);

//
// debugging support
//

#if DBG == 1

#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif

#ifdef __cplusplus
extern "C" {
#define EXTRNC "C"
#else
#define EXTRNC
#endif

// smprintf should only be called from xxDebugOut()

   void APINOT
   smprintf(
       unsigned long ulCompMask,
       char const *pszComp,
       char const *ppszfmt,
       va_list  ArgList);

   void          APINOT
   SmAssertEx(
       char const *pszFile,
       int iLine,
       char const *pszMsg);

   int APINOT
   PopUpError(
       char const *pszMsg,
       int iLine,
       char const *pszFile);

   void APINOT
   CheckInit(char * pInfoLevelString, unsigned long * InfoLevel);

#define DSP_DEBUG_BUF_SIZE (512)

#ifdef __cplusplus
}
#endif // __cplusplus

//
// Debug print macros
//

#define DEB_ERROR               0x00000001      // exported error paths
#define DEB_WARN                0x00000002      // exported warnings
#define DEB_TRACE               0x00000004      // exported trace messages

#define DEB_DBGOUT              0x00000010      // Output to debugger
#define DEB_STDOUT              0x00000020      // Output to stdout

#define DEB_IERROR              0x00000100      // internal error paths
#define DEB_IWARN               0x00000200      // internal warnings
#define DEB_ITRACE              0x00000400      // internal trace messages

#define DEB_USER1               0x00010000      // User defined
#define DEB_USER2               0x00020000      // User defined
#define DEB_USER3               0x00040000      // User defined
#define DEB_USER4               0x00080000      // User defined
#define DEB_USER5               0x00100000      // User defined
#define DEB_USER6               0x00200000      // User defined
#define DEB_USER7               0x00400000      // User defined
#define DEB_USER8               0x00800000      // User defined
#define DEB_USER9               0x01000000      // User defined
#define DEB_USER10              0x02000000      // User defined
#define DEB_USER11              0x04000000      // User defined
#define DEB_USER12              0x08000000      // User defined
#define DEB_USER13              0x10000000      // User defined
#define DEB_USER14              0x20000000      // User defined
#define DEB_USER15              0x40000000      // User defined

#define DEB_NOCOMPNAME          0x80000000      // suppress component name

#define DEB_FORCE               0x7fffffff      // force message

#define ASSRT_MESSAGE           0x00000001      // Output a message
#define ASSRT_BREAK             0x00000002      // Int 3 on assertion
#define ASSRT_POPUP             0x00000004      // And popup message

//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------

#ifndef DEF_INFOLEVEL
 #define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
#endif


#define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;\
        extern EXTRNC char* comp##InfoLevelString = #comp;


#ifdef __cplusplus

 #define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        CheckInit(comp##InfoLevelString, &comp##InfoLevel); \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            smprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

#else  // ! __cplusplus

 #define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        CheckInit(comp##InfoLevelString, &comp##InfoLevel);
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            smprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

#endif // ! __cplusplus

DECLARE_DEBUG(DsProp)

#define dspDebugOut(x) DsPropInlineDebugOut x
#define dspAssert(x) (void)((x) || (SmAssertEx(__FILE__, __LINE__, #x),0))

#include "dscmn.h"

#define ERR_OUT(msg, hr) \
    if (SUCCEEDED(hr)) { \
        dspDebugOut((DEB_ERROR, #msg "\n")); \
    } else { \
        dspDebugOut((DEB_ERROR, #msg " failed with error 0x%x\n", hr)); \
        ReportError(hr, 0, 0); \
    }

#define REPORT_ERROR(hr, hwnd) \
    dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> %08lx\n", \
                 __FILE__, __LINE__, hr)); \
    ReportError(hr, 0, hwnd);

#define REPORT_ERROR_FORMAT(hr, ids, hwnd) \
    dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> %08lx\n", \
                 __FILE__, __LINE__, hr)); \
    ReportError(hr, ids, hwnd);

#define ERR_MSG(id, hwnd) \
    dspDebugOut((DEB_ERROR, "**** ERROR <%s @line %d> msg string ID: %d\n", \
                 __FILE__, __LINE__, id)); \
    ErrMsg(id, hwnd);

#define CHECK_HRESULT(hr, action) \
    if (FAILED(hr)) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> %08lx\n", \
                     __FILE__, __LINE__, hr)); \
        action; \
    }

#define CHECK_HRESULT_REPORT(hr, hwnd, action) \
    if (FAILED(hr)) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> %08lx\n", \
                     __FILE__, __LINE__, hr)); \
        ReportError(hr, 0, hwnd); \
        action; \
    }

#define CHECK_NULL(ptr, action) \
    if (ptr == NULL) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> NULL ptr\n", \
                     __FILE__, __LINE__)); \
        action; \
    }

#define CHECK_NULL_REPORT(ptr, hwnd, action) \
    if (ptr == NULL) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> NULL ptr\n", \
                     __FILE__, __LINE__)); \
        ReportError(E_OUTOFMEMORY, 0, hwnd); \
        action; \
    }

#define CHECK_WIN32(err, action) \
    if (err != ERROR_SUCCESS) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> %d\n", \
                     __FILE__, __LINE__, err)); \
        action; \
    }

#define CHECK_WIN32_REPORT(err, hwnd, action) \
    if (err != ERROR_SUCCESS) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> %d\n", \
                     __FILE__, __LINE__, err)); \
        ReportError(err, 0, hwnd); \
        action; \
    }

#define CHECK_STATUS(err, action) \
    if (!NT_SUCCESS(err)) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> 0x%08x\n", \
                     __FILE__, __LINE__, err)); \
        action; \
    }

#define CHECK_STATUS_REPORT(err, hwnd, action) \
    if (!NT_SUCCESS(err)) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> 0x%08x\n", \
                     __FILE__, __LINE__, err)); \
        ReportError(RtlNtStatusToDosError(err), 0, hwnd); \
        action; \
    }

#define CHECK_LSA_STATUS(err, action) \
    if (!NT_SUCCESS(err)) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> 0x%08x\n", \
                     __FILE__, __LINE__, err)); \
        action; \
    }

#define CHECK_LSA_STATUS_REPORT(err, hwnd, action) \
    if (!NT_SUCCESS(err)) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> 0x%08x\n", \
                     __FILE__, __LINE__, err)); \
        ReportError(LsaNtStatusToWinError(err), 0, hwnd); \
        action; \
    }

#define TRACER(ClassName,MethodName) \
    dspDebugOut((DEB_TRACE, #ClassName"::"#MethodName"(0x%p)\n", this)); \
    if (DsPropInfoLevel & DEB_USER5) HeapValidate(GetProcessHeap(), 0, NULL);

#define TRACE(ClassName,MethodName) \
    dspDebugOut((DEB_USER1, #ClassName"::"#MethodName"(0x%p)\n", this)); \
    if (DsPropInfoLevel & DEB_USER5) HeapValidate(GetProcessHeap(), 0, NULL);

#define TRACE2(ClassName,MethodName) \
    dspDebugOut((DEB_USER2, #ClassName"::"#MethodName"(0x%p)\n", this)); \
    if (DsPropInfoLevel & DEB_USER5) HeapValidate(GetProcessHeap(), 0, NULL);

#define TRACE3(ClassName,MethodName) \
    dspDebugOut((DEB_USER3, #ClassName"::"#MethodName"(0x%p)\n", this)); \
    if (DsPropInfoLevel & DEB_USER5) HeapValidate(GetProcessHeap(), 0, NULL);

#define TRACE_FUNCTION(FunctionName) \
    dspDebugOut((DEB_USER1, #FunctionName"\n"));

#define TRACE_FUNCTION3(FunctionName) \
    dspDebugOut((DEB_USER3, #FunctionName"\n"));

#define DBG_OUT(String) \
    dspDebugOut((DEB_ITRACE, String "\n"));

#define DBG_OUT3(String) \
    dspDebugOut((DEB_USER3, String "\n"));

#else // DBG != 1

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)

#define dspDebugOut(x)

#define dspAssert(x) 

#include "dscmn.h"

#define ERR_OUT(msg, hr) \
        ReportError(hr, 0, 0);

#define REPORT_ERROR(hr, hwnd) ReportError(hr, 0, hwnd);

#define REPORT_ERROR_FORMAT(hr, ids, hwnd) ReportError(hr, ids, hwnd);

#define ERR_MSG(id, hwnd) \
    ErrMsg(id, hwnd);

#define CHECK_HRESULT(hr, action) \
    if (FAILED(hr)) { \
        action; \
    }

#define CHECK_HRESULT_H(hr, hwnd, action) \
    if (FAILED(hr)) { \
        action; \
    }

#define CHECK_HRESULT_REPORT(hr, hwnd, action) \
    if (FAILED(hr)) { \
        ReportError(hr, 0, hwnd); \
        action; \
    }

#define CHECK_NULL(ptr, action) \
    if (ptr == NULL) { \
        action; \
    }

#define CHECK_NULL_REPORT(ptr, hwnd, action) \
    if (ptr == NULL) { \
        ReportError(E_OUTOFMEMORY, 0, hwnd); \
        action; \
    }

#define CHECK_WIN32(err, action) \
    if (err != ERROR_SUCCESS) { \
        ReportError(err, 0); \
        action; \
    }

#define CHECK_WIN32_REPORT(err, hwnd, action) \
    if (err != ERROR_SUCCESS) { \
        ReportError(err, 0, hwnd); \
        action; \
    }

#define CHECK_STATUS(err, action) \
    if (!NT_SUCCESS(err)) { \
        action; \
    }

#define CHECK_STATUS_REPORT(err, hwnd, action) \
    if (!NT_SUCCESS(err)) { \
        ReportError(err, 0, hwnd); \
        action; \
    }

#define CHECK_LSA_STATUS(err, action) \
    if (!NT_SUCCESS(err)) { \
        action; \
    }

#define CHECK_LSA_STATUS_REPORT(err, hwnd, action) \
    if (!NT_SUCCESS(err)) { \
        ReportError(LsaNtStatusToWinError(err), 0, hwnd); \
        action; \
    }

#define TRACER(ClassName,MethodName)
#define TRACE(ClassName,MethodName)
#define TRACE2(ClassName,MethodName)
#define TRACE3(ClassName,MethodName)
#define TRACE_FUNCTION(FunctionName)
#define TRACE_FUNCTION3(FunctionName)
#define DBG_OUT(String)
#define DBG_OUT3(String)

#endif // DBG == 1

#endif // __DEBUG_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\group.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       group.cxx
//
//  Contents:   CDsGroupGenObjPage, the class that implements the group object
//              general property page, CDsGrpMembersPage for the group
//              membership page, and CDsGrpShlGenPage for the shell group
//              general page.
//
//  History:    10-April-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "group.h"

#include "qrybase.h"
#define BULK_ADD 1

#ifdef DSADMIN

#define DESCR_IDX   0
#define SAMNAME_IDX 1
#define EMAIL_IDX   2
#define COMMENT_IDX 3

//+----------------------------------------------------------------------------
//
//  Member:     CDsGroupGenObjPage::CDsGroupGenObjPage
//
//-----------------------------------------------------------------------------
CDsGroupGenObjPage::CDsGroupGenObjPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                       HWND hNotifyObj, DWORD dwFlags) :
    m_pCIcon(NULL),
    m_fMixed(TRUE),
    m_dwType(0),
    m_fTypeWritable(FALSE),
    m_fDescrWritable(FALSE),
    m_fSamNameWritable(FALSE),
    m_fEmailWritable(FALSE),
    m_fCommentWritable(FALSE),
    m_fTypeDirty(FALSE),
    m_fDescrDirty(FALSE),
    m_fSamNameDirty(FALSE),
    m_fEmailDirty(FALSE),
    m_fCommentDirty(FALSE),
    CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsGroupGenObjPage,CDsGroupGenObjPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsGroupGenObjPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsGroupGenObjPage::~CDsGroupGenObjPage
//
//-----------------------------------------------------------------------------
CDsGroupGenObjPage::~CDsGroupGenObjPage()
{
    TRACE(CDsGroupGenObjPage,~CDsGroupGenObjPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateGroupGenObjPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateGroupGenObjPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                      PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                      DWORD dwFlags, const CDSSmartBasePathsInfo& basePathsInfo,
                      HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateGroupGenObjPage);

    CDsGroupGenObjPage * pPageObj = new CDsGroupGenObjPage(pDsPage, pDataObj,
                                                           hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, basePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CDsGroupGenObjPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == g_uChangeMsg)
    {
        OnAttrChanged(wParam);
        return TRUE;
    }

    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case PSM_QUERYSIBLINGS:
        OnQuerySiblings(wParam, lParam);
        break;

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsGroupGenObjPage::OnInitDialog(LPARAM)
{
    TRACE(CDsGroupGenObjPage,OnInitDialog);
    HRESULT hr;
    PADS_ATTR_INFO pAttrs = NULL;
    DWORD cAttrs = 0;

    CWaitCursor Wait;

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    PTSTR ptzRDN;
    if (!UnicodeToTchar(m_pwszRDName, &ptzRDN))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        return S_OK;
    }

    SetDlgItemText(m_hPage, IDC_CN, ptzRDN);
    delete [] ptzRDN;

    //
    // Get the icon from the DS and put it on the page.
    //
    ATTR_DATA ad = {0, 0};

    hr = GeneralPageIcon(this, &GenIcon, NULL, 0, &ad, fInit);

    CHECK_HRESULT_REPORT(hr, m_hPage, return S_OK);

    m_pCIcon = (CDsIconCtrl *)ad.pVoid;

    m_fTypeWritable    = CheckIfWritable(g_wzGroupType);
    m_fDescrWritable   = CheckIfWritable(m_rgpAttrMap[DESCR_IDX]->AttrInfo.pszAttrName);
    m_fSamNameWritable = CheckIfWritable(m_rgpAttrMap[SAMNAME_IDX]->AttrInfo.pszAttrName);
    m_fEmailWritable   = CheckIfWritable(m_rgpAttrMap[EMAIL_IDX]->AttrInfo.pszAttrName);
    m_fCommentWritable = CheckIfWritable(m_rgpAttrMap[COMMENT_IDX]->AttrInfo.pszAttrName);

    //
    // Get description, SAM name, email address, and comment attributes.
    //
    SendDlgItemMessage(m_hPage, m_rgpAttrMap[DESCR_IDX]->nCtrlID, EM_LIMITTEXT,
                       m_rgpAttrMap[DESCR_IDX]->nSizeLimit, 0);
    SendDlgItemMessage(m_hPage, m_rgpAttrMap[SAMNAME_IDX]->nCtrlID, EM_LIMITTEXT,
                       m_rgpAttrMap[SAMNAME_IDX]->nSizeLimit, 0);
    SendDlgItemMessage(m_hPage, m_rgpAttrMap[EMAIL_IDX]->nCtrlID, EM_LIMITTEXT,
                       m_rgpAttrMap[EMAIL_IDX]->nSizeLimit, 0);
    SendDlgItemMessage(m_hPage, m_rgpAttrMap[COMMENT_IDX]->nCtrlID, EM_LIMITTEXT,
                       m_rgpAttrMap[COMMENT_IDX]->nSizeLimit, 0);

    PWSTR rgpwzAttrNames[] = {m_rgpAttrMap[DESCR_IDX]->AttrInfo.pszAttrName,
                              m_rgpAttrMap[SAMNAME_IDX]->AttrInfo.pszAttrName,
                              m_rgpAttrMap[EMAIL_IDX]->AttrInfo.pszAttrName,
                              m_rgpAttrMap[COMMENT_IDX]->AttrInfo.pszAttrName,
                              g_wzGroupType};

    hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames, 5, &pAttrs, &cAttrs);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, m_hPage))
    {
        return S_OK;
    }

    for (DWORD i = 0; i < cAttrs; i++)
    {
        dspAssert(pAttrs);
        dspAssert(pAttrs[i].pADsValues);
        PTSTR ptz;

        if (_wcsicmp(pAttrs[i].pszAttrName, m_rgpAttrMap[DESCR_IDX]->AttrInfo.pszAttrName) == 0)
        {
            // description.
            //
            if (!UnicodeToTchar(pAttrs[i].pADsValues->CaseIgnoreString, &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                FreeADsMem(pAttrs);
                return S_OK;
            }

            SetDlgItemText(m_hPage, m_rgpAttrMap[DESCR_IDX]->nCtrlID, ptz);

            delete [] ptz;
        }
        if (_wcsicmp(pAttrs[i].pszAttrName, m_rgpAttrMap[SAMNAME_IDX]->AttrInfo.pszAttrName) == 0)
        {
            // SAM name.
            //
            if (!UnicodeToTchar(pAttrs[i].pADsValues->CaseIgnoreString, &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                FreeADsMem(pAttrs);
                return S_OK;
            }

            SetDlgItemText(m_hPage, m_rgpAttrMap[SAMNAME_IDX]->nCtrlID, ptz);

            delete [] ptz;
        }
        if (_wcsicmp(pAttrs[i].pszAttrName, m_rgpAttrMap[EMAIL_IDX]->AttrInfo.pszAttrName) == 0)
        {
            // email address.
            //
            if (!UnicodeToTchar(pAttrs[i].pADsValues->CaseIgnoreString, &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                FreeADsMem(pAttrs);
                return S_OK;
            }

            SetDlgItemText(m_hPage, m_rgpAttrMap[EMAIL_IDX]->nCtrlID, ptz);

            delete [] ptz;
        }
        if (_wcsicmp(pAttrs[i].pszAttrName, m_rgpAttrMap[COMMENT_IDX]->AttrInfo.pszAttrName) == 0)
        {
            // comment.
            //
            if (!UnicodeToTchar(pAttrs[i].pADsValues->CaseIgnoreString, &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                FreeADsMem(pAttrs);
                return S_OK;
            }

            SetDlgItemText(m_hPage, m_rgpAttrMap[COMMENT_IDX]->nCtrlID, ptz);

            delete [] ptz;
        }
        if (_wcsicmp(pAttrs[i].pszAttrName, g_wzGroupType) == 0)
        {
            // group type.
            //
            m_dwType = pAttrs[i].pADsValues->Integer;
        }
    }

    if (pAttrs)
    {
        FreeADsMem(pAttrs);
    }

    //
    // Get the domain type and set the buttons accordingly.
    //
    GetDomainMode(this, &m_fMixed);

	 SetGroupTypeButtons();

    if (!m_fDescrWritable)
    {
       SendDlgItemMessage(m_hPage, m_rgpAttrMap[DESCR_IDX]->nCtrlID, EM_SETREADONLY, (WPARAM)TRUE, 0);
    }
    if (!m_fSamNameWritable)
    {
       SendDlgItemMessage(m_hPage, m_rgpAttrMap[SAMNAME_IDX]->nCtrlID, EM_SETREADONLY, (WPARAM)TRUE, 0);
    }
    if (!m_fEmailWritable)
    {
       SendDlgItemMessage(m_hPage, m_rgpAttrMap[EMAIL_IDX]->nCtrlID, EM_SETREADONLY, (WPARAM)TRUE, 0);
    }
    if (!m_fCommentWritable)
    {
       SendDlgItemMessage(m_hPage, m_rgpAttrMap[COMMENT_IDX]->nCtrlID, EM_SETREADONLY, (WPARAM)TRUE, 0);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::SetGroupTypeButtons
//
//  Synopsis:   Enables/Disables and checks the appropriate group type radio
//              buttons based on the domain mode, and groupType attribute
//
//-----------------------------------------------------------------------------
void CDsGroupGenObjPage::SetGroupTypeButtons()
{
    BOOL Sec = m_dwType & GROUP_TYPE_SECURITY_ENABLED;
    CheckDlgButton(m_hPage,
                   (Sec) ? IDC_RADIO_SEC_ENABLED :
                           IDC_RADIO_SEC_DISABLED,
                   BST_CHECKED);
    if (m_fMixed)
    {
        EnableWindow(GetDlgItem(m_hPage, (Sec) ? IDC_RADIO_SEC_DISABLED : 
                                                 IDC_RADIO_SEC_ENABLED), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_UNIVERSAL), FALSE);
    }
    UINT id;
    if (m_dwType & GROUP_TYPE_ACCOUNT_GROUP)
    {
        id = IDC_RADIO_ACCOUNT;
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_RESOURCE), FALSE);
    }
    else
    if (m_dwType & GROUP_TYPE_RESOURCE_GROUP)
    {
        id = IDC_RADIO_RESOURCE;
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_ACCOUNT), FALSE);
        if (m_dwType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
        {
            TCHAR szLabel[100];
            if (LoadStringReport(IDS_BUILTIN_GROUP, szLabel, 100, m_hPage))
            {
               SetWindowText(GetDlgItem(m_hPage, IDC_RADIO_RESOURCE), szLabel);
            }
        }
    }
    else
    if (m_dwType & GROUP_TYPE_UNIVERSAL_GROUP)
    {
        id = IDC_RADIO_UNIVERSAL;
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_ACCOUNT), m_fMixed ? FALSE : TRUE);
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_RESOURCE), m_fMixed ? FALSE : TRUE);
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_UNIVERSAL), TRUE);
    }
    else
    {
      //
      // Probably a default but we should never get here anyway
      //
      id = IDC_RADIO_ACCOUNT;
#if DBG == 1
        dspAssert(FALSE && "Unknown group type!");
#endif
    }

    CheckDlgButton(m_hPage, id, BST_CHECKED);

    bool    fIsSpecialAccount = false;

    IsSpecialAccount (fIsSpecialAccount);

    if (!m_fTypeWritable || 
        (m_dwType & GROUP_TYPE_BUILTIN_LOCAL_GROUP) ||
        fIsSpecialAccount)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_ACCOUNT), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_RESOURCE), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_UNIVERSAL), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_SEC_ENABLED), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_SEC_DISABLED), FALSE);
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::IsSpecialAccount
//
//  Synopsis:   Returns true if group RID indicates a special account
//
//-----------------------------------------------------------------------------
HRESULT CDsGroupGenObjPage::IsSpecialAccount(bool& fIsSpecialAccount)
{
    //
    // Get the group SID. This is a required attribute so bail if not found.
    //
    PWSTR rgpwzAttrNames[] = {g_wzObjectSID};
    PADS_ATTR_INFO pAttrs = NULL;
    DWORD cAttrs = 0;

    CWaitCursor Wait;

    HRESULT hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);

    if (!CHECK_ADS_HR(&hr, m_hPage))
    {
        return hr;
    }

    dspAssert(cAttrs);
    if (cAttrs != 1)
    {
        return E_FAIL;
    }
    dspAssert(pAttrs);

    PUCHAR saCount = GetSidSubAuthorityCount(pAttrs->pADsValues->OctetString.lpValue);
    DWORD dwGroupRID = *GetSidSubAuthority(pAttrs->pADsValues->OctetString.lpValue, (ULONG)*saCount - 1);
    dspDebugOut((DEB_ITRACE, "Group RID = %d\n", dwGroupRID));

    // This is the highest special account RID or alias in ntseapi.h
    if ( dwGroupRID <= DOMAIN_ALIAS_RID_RAS_SERVERS )
        fIsSpecialAccount = true;

    FreeADsMem(pAttrs);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsGroupGenObjPage::OnApply(void)
{
    TRACE(CDsGroupGenObjPage,OnApply);
    HRESULT hr = S_OK;
    ADSVALUE ADsValueType = {ADSTYPE_INTEGER, 0};
    ADS_ATTR_INFO AttrInfoDesc = m_rgpAttrMap[DESCR_IDX]->AttrInfo;
    ADS_ATTR_INFO AttrInfoSAMn = m_rgpAttrMap[SAMNAME_IDX]->AttrInfo;
    ADS_ATTR_INFO AttrInfoMail = m_rgpAttrMap[EMAIL_IDX]->AttrInfo;
    ADS_ATTR_INFO AttrInfoComm = m_rgpAttrMap[COMMENT_IDX]->AttrInfo;
    ADS_ATTR_INFO AttrInfoType = {g_wzGroupType, ADS_ATTR_UPDATE,
                                  ADSTYPE_INTEGER, &ADsValueType, 1};

    ADS_ATTR_INFO rgAttrs[5];
    DWORD cAttrs = 0;

    ADSVALUE ADsValueDesc = {m_rgpAttrMap[DESCR_IDX]->AttrInfo.dwADsType, NULL};
    ADSVALUE ADsValueSAMname = {m_rgpAttrMap[SAMNAME_IDX]->AttrInfo.dwADsType, NULL};
    ADSVALUE ADsValueComm = {m_rgpAttrMap[COMMENT_IDX]->AttrInfo.dwADsType, NULL};
    ADSVALUE ADsValueMail = {m_rgpAttrMap[EMAIL_IDX]->AttrInfo.dwADsType, NULL};

    //
    // Description.
    //
    AttrInfoDesc.pADsValues = &ADsValueDesc;
    AttrInfoDesc.dwNumValues = 1;
    LPTSTR ptsz;

    if (m_fDescrDirty)
    {
        dspAssert(m_fDescrWritable);

        ptsz = new TCHAR[m_rgpAttrMap[DESCR_IDX]->nSizeLimit + 1];
        CHECK_NULL(ptsz, return -1);

        if (GetDlgItemText(m_hPage, m_rgpAttrMap[DESCR_IDX]->nCtrlID,
                           ptsz, m_rgpAttrMap[DESCR_IDX]->nSizeLimit + 1) == 0)
        {
            // An empty control means remove the attribute value from the
            // object.
            //
            AttrInfoDesc.dwNumValues = 0;
            AttrInfoDesc.pADsValues = NULL;
            AttrInfoDesc.dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
            if (!TcharToUnicode(ptsz, &ADsValueDesc.CaseIgnoreString))
            {
                delete[] ptsz;
                return -1;
            }
        }
        delete[] ptsz;
        rgAttrs[cAttrs++] = AttrInfoDesc;
    }

    //
    // SAM name.
    //
    AttrInfoSAMn.pADsValues = &ADsValueSAMname;
    AttrInfoSAMn.dwNumValues = 1;

    if (m_fSamNameDirty)
    {
      dspAssert(m_fSamNameWritable);

      ptsz = new TCHAR[m_rgpAttrMap[SAMNAME_IDX]->nSizeLimit + 1];
      if (ptsz == NULL)
      {
        DO_DEL(ADsValueDesc.CaseExactString)
        return -1;
      }

      if (GetDlgItemText(m_hPage, m_rgpAttrMap[SAMNAME_IDX]->nCtrlID,
                         ptsz, m_rgpAttrMap[SAMNAME_IDX]->nSizeLimit + 1) == 0)
      {
        ErrMsg (IDS_ERR_DNLEVELNAME_MISSING, m_hPage);
        delete[] ptsz;
        hr = E_FAIL;
        goto Cleanup;
      }
      else
      {
        CStr csSAMName = ptsz;

        //
        // Now check for illegal characters
        //
        bool bSAMNameChanged = false;
        int iFind = csSAMName.FindOneOf(INVALID_ACCOUNT_NAME_CHARS);
        if (iFind != -1 && !csSAMName.IsEmpty())
        {
          PVOID apv[1] = {(LPWSTR)(LPCWSTR)csSAMName};
          if (IDYES == SuperMsgBox(m_hPage,
                                   IDS_GROUP_SAMNAME_ILLEGAL, 
                                   0, 
                                   MB_YESNO | MB_ICONWARNING,
                                   S_OK, 
                                   apv, 
                                   1,
                                   FALSE, 
                                   __FILE__, 
                                   __LINE__))
          {
            while (iFind != -1)
            {
              csSAMName.SetAt(iFind, L'_');
              iFind = csSAMName.FindOneOf(INVALID_ACCOUNT_NAME_CHARS);
              bSAMNameChanged = true;
            }
          }
          else
          {
            //
            // Set the focus to the edit box and select the text
            //
            SetFocus(GetDlgItem(m_hPage, m_rgpAttrMap[SAMNAME_IDX]->nCtrlID));
            SendDlgItemMessage(m_hPage, m_rgpAttrMap[SAMNAME_IDX]->nCtrlID, EM_SETSEL, 0, -1);

            delete[] ptsz;
            hr = E_FAIL;
            goto Cleanup;
          }
        }

        if (bSAMNameChanged)
        {
            //
            // Write the change back to the control
            //
            SetDlgItemText(m_hPage, m_rgpAttrMap[SAMNAME_IDX]->nCtrlID, const_cast<PWSTR>((LPCWSTR)csSAMName));
        }

        if (!AllocWStr((PWSTR)(PCWSTR)csSAMName, &ADsValueSAMname.CaseIgnoreString))
        {
          delete[] ptsz;
          DO_DEL(ADsValueDesc.CaseExactString)
          return -1;
        }

      }
      delete[] ptsz;
      rgAttrs[cAttrs++] = AttrInfoSAMn;
    }

    //
    // Email Address.
    //
    AttrInfoMail.pADsValues = &ADsValueMail;
    AttrInfoMail.dwNumValues = 1;

    if (m_fEmailWritable)
    {
      if (!m_fEmailDirty)
      {
          SendMessage(GetParent(GetHWnd()), PSM_QUERYSIBLINGS,
                      (WPARAM)m_rgpAttrMap[EMAIL_IDX]->AttrInfo.pszAttrName,
                      (LPARAM)GetHWnd());
      }

      // SendMessage is syncronous. If the sibling page has an updated email
      // attribute value, it will get written to this page's edit control
      // and the dirty state member will be set. So, check it now rather than
      // use a 'else' clause after the above 'if' clause.
      //
      if (m_fEmailDirty)
      {
        ptsz = new TCHAR[m_rgpAttrMap[EMAIL_IDX]->nSizeLimit + 1];
        if (ptsz == NULL)
        {
          DO_DEL(ADsValueDesc.CaseExactString)
          DO_DEL(ADsValueSAMname.CaseIgnoreString);
          return -1;
        }

        if (GetDlgItemText(m_hPage, m_rgpAttrMap[EMAIL_IDX]->nCtrlID,
                           ptsz, m_rgpAttrMap[EMAIL_IDX]->nSizeLimit + 1) == 0)
        {
          AttrInfoMail.dwNumValues = 0;
          AttrInfoMail.pADsValues = NULL;
          AttrInfoMail.dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
          if (!TcharToUnicode(ptsz, &ADsValueMail.CaseIgnoreString))
          {
            delete[] ptsz;
            hr = E_OUTOFMEMORY;
            goto Cleanup;
          }
          if (!FValidSMTPAddress(ADsValueMail.CaseIgnoreString))
          {
            ErrMsg(IDS_INVALID_MAIL_ADDR, GetHWnd());
            delete [] ptsz;
            hr = E_FAIL;
            goto Cleanup;
          }
        }
        delete[] ptsz;
        rgAttrs[cAttrs++] = AttrInfoMail;
      }
    }

    //
    // Comment.
    //
    AttrInfoComm.pADsValues = &ADsValueComm;
    AttrInfoComm.dwNumValues = 1;

    if (m_fCommentDirty)
    {
      dspAssert(m_fCommentWritable);

      ptsz = new TCHAR[m_rgpAttrMap[COMMENT_IDX]->nSizeLimit + 1];
      if (ptsz == NULL)
      {
        DO_DEL(ADsValueDesc.CaseExactString)
        DO_DEL(ADsValueSAMname.CaseIgnoreString);
        DO_DEL(ADsValueMail.CaseExactString)
        return -1;
      }

      if (GetDlgItemText(m_hPage, m_rgpAttrMap[COMMENT_IDX]->nCtrlID,
                         ptsz, m_rgpAttrMap[COMMENT_IDX]->nSizeLimit + 1) == 0)
      {
        AttrInfoComm.dwNumValues = 0;
        AttrInfoComm.pADsValues = NULL;
        AttrInfoComm.dwControlCode = ADS_ATTR_CLEAR;
      }
      else
      {
        if (!TcharToUnicode(ptsz, &ADsValueComm.CaseIgnoreString))
        {
          delete[] ptsz;
          DO_DEL(ADsValueDesc.CaseExactString)
          DO_DEL(ADsValueSAMname.CaseIgnoreString);
          DO_DEL(ADsValueMail.CaseExactString)
          return -1;
        }
      }
      delete[] ptsz;
      rgAttrs[cAttrs++] = AttrInfoComm;
    }

    //
    // set the group type flags
    //
    if (m_fTypeDirty)
    {
        dspAssert(m_fTypeWritable);

        BOOL Account = (IsDlgButtonChecked (m_hPage,IDC_RADIO_ACCOUNT)
                        == BST_CHECKED);
        BOOL Resource = (IsDlgButtonChecked (m_hPage,IDC_RADIO_RESOURCE)
                         == BST_CHECKED);
        BOOL Security = (IsDlgButtonChecked (m_hPage, IDC_RADIO_SEC_ENABLED)
                         == BST_CHECKED);
        if (Security)
        {
            ADsValueType.Integer = GROUP_TYPE_SECURITY_ENABLED;
        }
        else
        {
            if (m_dwType & GROUP_TYPE_SECURITY_ENABLED) 
            {
              TCHAR szTitle[80], szMessage[512];
              if (!LoadStringReport(IDS_MSG_TITLE, szTitle, 80, m_hPage))
                  {
                      hr = E_OUTOFMEMORY;
                      goto Cleanup;
                  }
              if (!LoadStringReport(IDS_MSG_DISABLING_SECURITY, szMessage, 512, m_hPage))
                  {
                      hr = E_OUTOFMEMORY;
                      goto Cleanup;
                  }
              
              LONG iRet = MessageBox(m_hPage, szMessage, szTitle, MB_YESNO |
                                     MB_ICONWARNING);
              
              if (iRet == IDNO)
                  {
                    //
                    // The user declined, so go back to prop sheet.
                    //
                    hr = S_FALSE;
                    goto Cleanup;
                  }
            }
            ADsValueType.Integer = 0;
        }

        if (Resource)
        {
            ADsValueType.Integer |= GROUP_TYPE_RESOURCE_GROUP;
        }
        else
        {
            if (Account)
            {
                ADsValueType.Integer |= GROUP_TYPE_ACCOUNT_GROUP;
            }
            else
            {
                ADsValueType.Integer |= GROUP_TYPE_UNIVERSAL_GROUP;
            }
        }
        rgAttrs[cAttrs++] = AttrInfoType;
    }

    //
    // Write the description, and group type.
    //
    DWORD cModified;

    hr = m_pDsObj->SetObjectAttributes(rgAttrs, cAttrs, &cModified);

    if (!CHECK_ADS_HR(&hr, m_hPage))
    {
        goto Cleanup;
    }

    // Store the new group type and change the group type buttons

    m_dwType = ADsValueType.Integer;
    SetGroupTypeButtons();

    m_fTypeDirty = m_fDescrDirty = m_fSamNameDirty = m_fEmailDirty = 
        m_fCommentDirty = FALSE;

Cleanup:
    DO_DEL(ADsValueDesc.CaseExactString)
    DO_DEL(ADsValueSAMname.CaseIgnoreString);
    DO_DEL(ADsValueMail.CaseExactString)
    DO_DEL(ADsValueComm.CaseExactString)
    
    if (hr == S_FALSE)
        return PSNRET_INVALID_NOCHANGEPAGE;
    else
        return (SUCCEEDED(hr)) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CDsGroupGenObjPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (m_fInInit)
    {
        return 0;
    }
    switch (codeNotify)
    {
    case BN_CLICKED:
        if ((id == IDC_RADIO_UNIVERSAL) ||
            (id == IDC_RADIO_RESOURCE) ||
            (id == IDC_RADIO_ACCOUNT))
        {
            int iCheck1, iCheck2;
            switch (id)
            {
            case IDC_RADIO_UNIVERSAL:
                iCheck1 = IDC_RADIO_RESOURCE;
                iCheck2 = IDC_RADIO_ACCOUNT;
                break;
            case IDC_RADIO_RESOURCE:
                iCheck1 = IDC_RADIO_UNIVERSAL;
                iCheck2 = IDC_RADIO_ACCOUNT;
                break;
            case IDC_RADIO_ACCOUNT:
                iCheck1 = IDC_RADIO_UNIVERSAL;
                iCheck2 = IDC_RADIO_RESOURCE;
                break;
            default:
                dspAssert(FALSE);
                iCheck1 = IDC_RADIO_RESOURCE;
                iCheck2 = IDC_RADIO_ACCOUNT;
                break;
            }
            CheckDlgButton(m_hPage, iCheck1, BST_UNCHECKED);
            CheckDlgButton(m_hPage, iCheck2, BST_UNCHECKED);
            m_fTypeDirty = TRUE;
            SetDirty();
        }
        if ((id == IDC_RADIO_SEC_ENABLED) ||
            (id == IDC_RADIO_SEC_DISABLED))
        {
            CheckDlgButton(m_hPage,
                           (id == IDC_RADIO_SEC_ENABLED) ?
                             IDC_RADIO_SEC_DISABLED : IDC_RADIO_SEC_ENABLED,
                           BST_UNCHECKED);
            m_fTypeDirty = TRUE;
            SetDirty();
        }
        break;

    case EN_CHANGE:
        switch (id)
        {
        case IDC_EMAIL_EDIT:
            m_fEmailDirty = TRUE;
            break;

        case IDC_DESCRIPTION_EDIT:
            m_fDescrDirty = TRUE;
            break;

        case IDC_SAM_NAME_EDIT:
            m_fSamNameDirty = TRUE;
            break;

        case IDC_EDIT_COMMENT:
            m_fCommentDirty = TRUE;
            break;
        }
        break;
    }
    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::OnNotify
//
//  Synopsis:   Handles list notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CDsGroupGenObjPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    if (m_fInInit)
    {
        return 0;
    }
    if (((LPNMHDR)lParam)->code == PSN_SETACTIVE)
    {
        dspDebugOut((DEB_ITRACE,
                    "(HWND: %08x) got PSN_SETACTIVE, sending PSM_QUERYSIBLINGS.\n",
                    GetHWnd()));
        SendMessage(GetParent(GetHWnd()), PSM_QUERYSIBLINGS,
                    (WPARAM)m_rgpAttrMap[EMAIL_IDX]->AttrInfo.pszAttrName,
                    (LPARAM)GetHWnd());
    }

    return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::OnQuerySiblings
//
//  Synopsis:   Inter-page communications for shared attributes.
//
//  lParam == the HWND of the sending window.
//  wParam == the name of the attribute whose status is sought.
//
//-----------------------------------------------------------------------------
void
CDsGroupGenObjPage::OnQuerySiblings(WPARAM wParam, LPARAM lParam)
{
    PWSTR pwz = NULL;
    int cch;

#if DBG == 1
    char szBuf[100];
    strcpy(szBuf, "(HWND: %08x) got PSM_QUERYSIBLINGS for '%ws'");
#endif

    if ((HWND)lParam != GetHWnd())
    {
        if (m_fEmailDirty && wParam &&
            _wcsicmp((PWSTR)wParam,
                     m_rgpAttrMap[EMAIL_IDX]->AttrInfo.pszAttrName) == 0)
        {
#if DBG == 1
            strcat(szBuf, " sending DSPROP_ATTRCHANGED_MSG");
#endif
            ADS_ATTR_INFO Attr;
            ADSVALUE ADsValue;

            cch = (int)SendDlgItemMessage(GetHWnd(),
                                          m_rgpAttrMap[EMAIL_IDX]->nCtrlID,
                                          WM_GETTEXTLENGTH, 0, 0);
            pwz = new WCHAR[++cch];
            CHECK_NULL_REPORT(pwz, GetHWnd(), return);

            Attr.dwNumValues = 1;
            Attr.pszAttrName = m_rgpAttrMap[EMAIL_IDX]->AttrInfo.pszAttrName;
            Attr.pADsValues = &ADsValue;
            Attr.pADsValues->dwType = m_rgpAttrMap[EMAIL_IDX]->AttrInfo.dwADsType;
            Attr.pADsValues->CaseIgnoreString = pwz;

            GetDlgItemText(GetHWnd(), m_rgpAttrMap[EMAIL_IDX]->nCtrlID,
                           Attr.pADsValues->CaseIgnoreString, cch);

            SendMessage((HWND)lParam, g_uChangeMsg, (WPARAM)&Attr, 0);

            delete [] pwz;
        }
    }
#if DBG == 1
    else
    {
        strcat(szBuf, " (it was sent by this page!)");
    }
    strcat(szBuf, "\n");
    dspDebugOut((DEB_ITRACE, szBuf, GetHWnd(), wParam));
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::OnAttrChanged
//
//  Synopsis:   Inter-page communications for shared attributes.
//
//  wParam == the PADS_ATTR_INFO struct for the changed attribute.
//
//-----------------------------------------------------------------------------
void
CDsGroupGenObjPage::OnAttrChanged(WPARAM wParam)
{
    PADS_ATTR_INFO pAttrInfo = (PADS_ATTR_INFO)wParam;

    dspAssert(pAttrInfo && pAttrInfo->pszAttrName && pAttrInfo->pADsValues &&
              pAttrInfo->pADsValues->CaseIgnoreString);
    dspDebugOut((DEB_ITRACE,
                 "(HWND: %08x) got DSPROP_ATTRCHANGED_MSG for '%ws'.\n",
                 GetHWnd(), pAttrInfo->pszAttrName));
    if (_wcsicmp(pAttrInfo->pszAttrName, m_rgpAttrMap[EMAIL_IDX]->AttrInfo.pszAttrName) == 0)
    {
        SetDlgItemText(GetHWnd(), m_rgpAttrMap[EMAIL_IDX]->nCtrlID,
                       pAttrInfo->pADsValues->CaseIgnoreString);
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsGroupGenObjPage::OnDestroy(void)
{
    ATTR_DATA ad = {0, (LPARAM)m_pCIcon};

    GeneralPageIcon(this, &GenIcon, NULL, 0, &ad, fOnDestroy);

    CDsPropPageBase::OnDestroy();
    // If an application processes this message, it should return zero.
    return 0;
}

#endif // DSADMIN

//+----------------------------------------------------------------------------
//
//  Member:     CDsGrpMembersPage::CDsGrpMembersPage
//
//-----------------------------------------------------------------------------
CDsGrpMembersPage::CDsGrpMembersPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                     HWND hNotifyObj, DWORD dwFlags) :
    m_pList(NULL),
    m_fMixed(TRUE),
    m_dwType(0),
    m_fMemberWritable(FALSE),
    m_dwGroupRID(0),
    m_fShowIcons(FALSE),
    m_pszSecurityGroupExtraClasses(NULL),
    m_dwSecurityGroupExtraClassesCount(0),
    m_pszNonSecurityGroupExtraClasses(NULL),
    m_dwNonSecurityGroupExtraClassesCount(0),
    m_hwndObjPicker(NULL),
    m_pInitInfo(NULL),
    CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsGrpMembersPage,CDsGrpMembersPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsGrpMembersPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsGrpMembersPage::~CDsGrpMembersPage
//
//-----------------------------------------------------------------------------
CDsGrpMembersPage::~CDsGrpMembersPage()
{
  TRACE(CDsGrpMembersPage,~CDsGrpMembersPage);
  DO_DEL(m_pList);

  if (m_pszSecurityGroupExtraClasses != NULL)
  {
    for (DWORD idx = 0; idx < m_dwSecurityGroupExtraClassesCount; idx++)
    {
      if (m_pszSecurityGroupExtraClasses[idx] != NULL)
      {
        delete[] m_pszSecurityGroupExtraClasses[idx];
        m_pszSecurityGroupExtraClasses[idx] = NULL;
      }
    }
    delete[] m_pszSecurityGroupExtraClasses;
  }
  if (m_pszNonSecurityGroupExtraClasses != NULL)
  {
    for (DWORD idx = 0; idx < m_dwNonSecurityGroupExtraClassesCount; idx++)
    {
      if (m_pszNonSecurityGroupExtraClasses[idx] != NULL)
      {
        delete[] m_pszNonSecurityGroupExtraClasses[idx];
        m_pszNonSecurityGroupExtraClasses[idx] = NULL;
      }
    }
    delete[] m_pszNonSecurityGroupExtraClasses;
  }
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsGrpMembersPage::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsGrpMembersPage::QueryInterface(REFIID riid, void ** ppvObject)
{
  TRACE2(CDsGrpMembersPage,QueryInterface);
  if (IID_ICustomizeDsBrowser == riid)
  {
    *ppvObject = (ICustomizeDsBrowser*)this;
  }
  else
  {
    return CDsPropPageBase::QueryInterface(riid, ppvObject);
  }
  AddRef();
  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsGrpMembersPage::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsGrpMembersPage::AddRef(void)
{
    dspDebugOut((DEB_USER2, "CDsGrpMembersPage::AddRef refcount going in %d\n", m_uRefs));
    return CDsPropPageBase::AddRef();
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsGrpMembersPage::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    zero if the reference count is zero or non-zero otherwise
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsGrpMembersPage::Release(void)
{
  dspDebugOut((DEB_USER2, "CDsGrpMembersPage::Release ref count going in %d\n", m_uRefs));
  return CDsPropPageBase::Release();
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::Initialize
//
//  Synopsis:   Initializes the ICustomizeDsBrowser interface
//
//-----------------------------------------------------------------------------
HRESULT CDsGrpMembersPage::Initialize(HWND         hwnd,
                                      PCDSOP_INIT_INFO pInitInfo,
                                      IBindHelper *pBindHelper)
{
  HRESULT hr = S_OK;

  dspAssert(IsWindow(hwnd));
  dspAssert(pBindHelper);

  m_hwndObjPicker = hwnd;
  m_pInitInfo = pInitInfo;
  m_pBinder = pBindHelper;

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::BuildQueryString
//
//  Synopsis:   Used to build the query string from the securityGroupExtraClasses
//              and nonSecurityGroupExtraClasses in the DisplaySpecifiers
//
//-----------------------------------------------------------------------------
HRESULT CDsGrpMembersPage::BuildQueryString(PWSTR* ppszFilterString)
{
  CStrW szFilterString = L"(|";

  BOOL bSecurityGroup = (m_dwType & GROUP_TYPE_SECURITY_ENABLED) ? TRUE : FALSE;
  if (bSecurityGroup)
  {
    if (m_dwSecurityGroupExtraClassesCount == 0)
    {
      return S_FALSE;
    }

    for (DWORD idx = 0; idx < m_dwSecurityGroupExtraClassesCount; idx++)
    {
      if (m_pszSecurityGroupExtraClasses[idx] != NULL)
      {
        szFilterString += L"(objectClass=";
        szFilterString += m_pszSecurityGroupExtraClasses[idx];
        szFilterString += L")";
      }
    }
  }
  else
  {
    if (m_dwNonSecurityGroupExtraClassesCount == 0)
    {
      return S_FALSE;
    }

    for (DWORD idx = 0; idx < m_dwNonSecurityGroupExtraClassesCount; idx++)
    {
      if (m_pszNonSecurityGroupExtraClasses[idx] != NULL)
      {
        szFilterString += L"(objectClass=";
        if(_wcsicmp(m_pszNonSecurityGroupExtraClasses[idx],L"MSMQ-Queue")==0)
        {
            szFilterString +=L"MSMQQueue";
        }
        else
        {
            szFilterString += m_pszNonSecurityGroupExtraClasses[idx];
        }
        szFilterString += L")";
      }
    }
  }

  szFilterString += L")";

  *ppszFilterString = new WCHAR[szFilterString.GetLength() + 1];
  CHECK_NULL_REPORT(*ppszFilterString, GetHWnd(), return E_OUTOFMEMORY);

  wcscpy(*ppszFilterString, szFilterString);
  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsSelectionListWrapper::CreateSelectionList
//
//  Synopsis:   Used to convert a CDsSelectionListWrapper to a PDS_SELECTION_LIST
//
//-----------------------------------------------------------------------------
PDS_SELECTION_LIST CDsSelectionListWrapper::CreateSelectionList(CDsSelectionListWrapper* pHead)
{
  if (pHead == NULL)
  {
    return NULL;
  }

  PDS_SELECTION_LIST pSelectionList = NULL;

  UINT nCount = CDsSelectionListWrapper::GetCount(pHead);
  if (nCount > 0)
  {
    pSelectionList = (PDS_SELECTION_LIST)malloc(sizeof(DS_SELECTION_LIST) + 
                                                (sizeof(DS_SELECTION) * (nCount - 1)));
    if (pSelectionList != NULL)
    {
      memset(pSelectionList, 0, sizeof(DS_SELECTION_LIST) + (sizeof(DS_SELECTION) * (nCount - 1)));

      pSelectionList->cItems = nCount;
      pSelectionList->cFetchedAttributes = 0;

      //
      // Now fill in the selection list by walking the wrapper list
      //
      UINT idx = 0;
      CDsSelectionListWrapper* pCurrentItem = pHead;
      while (pCurrentItem != NULL)
      {
        memcpy(&(pSelectionList->aDsSelection[idx]), pCurrentItem->m_pSelection, sizeof(DS_SELECTION));
        pCurrentItem = pCurrentItem->m_pNext;
        idx++;
      }
    }
  }
  return pSelectionList;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsSelectionListWrapper::CreateSelectionList
//
//  Synopsis:   Counts the number of items in the CDsSelectionListWrapper
//
//-----------------------------------------------------------------------------
UINT CDsSelectionListWrapper::GetCount(CDsSelectionListWrapper* pHead)
{
  CDsSelectionListWrapper* pCurrentItem = pHead;
  UINT nCount = 0;
  
  while (pCurrentItem != NULL)
  {
    nCount++;
    pCurrentItem = pCurrentItem->m_pNext;
  }
  return nCount;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsSelectionListWrapper::DetachItemsAndDeleteList
//
//  Synopsis:   Counts the number of items in the CDsSelectionListWrapper
//
//-----------------------------------------------------------------------------
void CDsSelectionListWrapper::DetachItemsAndDeleteList(CDsSelectionListWrapper* pHead)
{
  CDsSelectionListWrapper* pNextItem = pHead;
  
  CDsSelectionListWrapper* pDeleteItem = NULL;

  while (pNextItem != NULL)
  {
    pDeleteItem = pNextItem;
    pNextItem = pNextItem->m_pNext;
    delete pDeleteItem->m_pSelection;
    delete pDeleteItem;
  }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::CollectDsObjects
//
//  Synopsis:   Used by AddObjects and PrefixSearch to retrieve the dataobject
//              of the additional objects
//
//-----------------------------------------------------------------------------
HRESULT CDsGrpMembersPage::CollectDsObjects(PWSTR pszFilter,
                                            IDsObjectPickerScope *pDsScope,
                                            CDsPropDataObj *pdo)
{
  HRESULT hr = S_OK;

  dspAssert(pdo != NULL);
  if (pdo == NULL)
  {
    return E_POINTER;
  }

  //
  // Prepare the search object
  //
  PWSTR pszScopePath = NULL;
  hr = pDsScope->GetADsPath(&pszScopePath);
  CHECK_HRESULT(hr, return hr;);

  CDSSearch searchObj;
  hr = searchObj.Init(pszScopePath);
  CHECK_HRESULT(hr, return hr;);

  PWSTR pszAttributes[] = { g_wzADsPath };
  hr = searchObj.SetAttributeList(pszAttributes, 1);
  CHECK_HRESULT(hr, return hr);

  dspAssert(pszFilter != NULL);
  if (pszFilter == NULL)
  {
    return E_INVALIDARG;
  }

  hr = searchObj.SetFilterString(pszFilter);
  CHECK_HRESULT(hr, return hr);


  hr = searchObj.SetSearchScope(ADS_SCOPE_SUBTREE);
  CHECK_HRESULT(hr, return hr);

  //
  // Prepare the linked list for temporary storage of DS_SELECTION items
  //
  CDsSelectionListWrapper* pListHead = NULL;
  CDsSelectionListWrapper* pCurrentListItem = NULL;

  //
  // Get the path cracker
  //
  CComPtr<IADsPathname> spPathCracker;
  hr = GetADsPathname(spPathCracker);
  CHECK_HRESULT(hr, return hr);

  //
  // Execute the query
  //
  hr = searchObj.DoQuery();
  while (SUCCEEDED(hr))
  {
    hr = searchObj.GetNextRow();
		if (S_ADS_NOMORE_ROWS == hr)
		{
      hr = S_OK;
      break;
    }

    if (SUCCEEDED(hr))
    {
		  ADS_SEARCH_COLUMN PathColumn, ClassColumn;
		  ::ZeroMemory( &PathColumn, sizeof(PathColumn) );
      ::ZeroMemory(&ClassColumn, sizeof(ClassColumn));

      //
      // Get the ADsPath
      //
		  hr = searchObj.GetColumn(pszAttributes[0], &PathColumn);
      CHECK_HRESULT(hr, continue);
      dspAssert(PathColumn.pADsValues->dwType == ADSTYPE_CASE_IGNORE_STRING);

      //
      // Get the objectClass
      //
      CComPtr<IDirectoryObject> spDirObject;
      hr = DSAdminOpenObject(PathColumn.pADsValues->CaseIgnoreString,
                             IID_IDirectoryObject,
                             (PVOID*)&spDirObject);
      CHECK_HRESULT(hr, continue);
      
      //
      // Get the object info
      //
      ADS_OBJECT_INFO* pADsObjectInfo = NULL;
      hr = spDirObject->GetObjectInformation(&pADsObjectInfo);
      CHECK_HRESULT(hr, continue);
      dspAssert(pADsObjectInfo != NULL);

      PDS_SELECTION pSelection = new DS_SELECTION;
      CHECK_NULL(pSelection, return E_OUTOFMEMORY);

      ::ZeroMemory(pSelection, sizeof(DS_SELECTION));

      if (!AllocWStr(PathColumn.pADsValues->CaseIgnoreString, &(pSelection->pwzADsPath)))
      {
        CHECK_HRESULT(E_OUTOFMEMORY, return E_OUTOFMEMORY);
      }

      //
      // Assume that the class we are interested in is the first in the multivalued attribute
      //
      if (!AllocWStr(pADsObjectInfo->pszClassName, &(pSelection->pwzClass)))
      {
        CHECK_HRESULT(E_OUTOFMEMORY, return E_OUTOFMEMORY);
      }

      hr = spPathCracker->Set(CComBSTR(PathColumn.pADsValues->CaseIgnoreString), ADS_SETTYPE_FULL);
      CHECK_HRESULT(hr, continue);

      hr = spPathCracker->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
      CHECK_HRESULT(hr, continue);

      hr = spPathCracker->put_EscapedMode(ADS_ESCAPEDMODE_OFF_EX);
      CHECK_HRESULT(hr, continue);

      CComBSTR bstrName;
      hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstrName);
      CHECK_HRESULT(hr, continue);

      //
      // Return the display to full
      //
      hr = spPathCracker->SetDisplayType(ADS_DISPLAY_FULL);
      dspAssert(SUCCEEDED(hr));

      hr = spPathCracker->put_EscapedMode(ADS_ESCAPEDMODE_ON);
      dspAssert(SUCCEEDED(hr));

      if (!AllocWStr(bstrName, &(pSelection->pwzName)))
      {
        CHECK_HRESULT(E_OUTOFMEMORY, return E_OUTOFMEMORY);
      }

      CDsSelectionListWrapper* pNewItem = new CDsSelectionListWrapper;
      CHECK_NULL(pNewItem, return E_OUTOFMEMORY);

      pNewItem->m_pSelection = pSelection;

      //
      // Add selection item to list
      //
      if (pListHead == NULL)
      {
        pListHead = pNewItem;
        pCurrentListItem = pNewItem;
      }
      else
      {
        pCurrentListItem->m_pNext = pNewItem;
        pCurrentListItem = pNewItem;
      }

      searchObj.FreeColumn(&PathColumn);
      searchObj.FreeColumn(&ClassColumn);
    }
  }

  if (pListHead != NULL)
  {
    PDS_SELECTION_LIST pSelectionList = CDsSelectionListWrapper::CreateSelectionList(pListHead);
    if (pSelectionList != NULL)
    {
      hr = pdo->Init(pSelectionList);
      CHECK_HRESULT(hr, return hr);
    }
    CDsSelectionListWrapper::DetachItemsAndDeleteList(pListHead);
  }
  else
  {
    hr = S_FALSE;
  }
  return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::AddObjects
//
//  Synopsis:   Called by the Object Picker UI to add additional objects to the UI
//
//-----------------------------------------------------------------------------
HRESULT CDsGrpMembersPage::AddObjects(IDsObjectPickerScope *pDsScope,
                                      IDataObject **ppdo)
{
  HRESULT hr = S_OK;

  //
  // Prepare the data object
  //
  CDsPropDataObj* pDataObj = new CDsPropDataObj(GetHWnd(), m_fReadOnly);
  CHECK_NULL(pDataObj, return E_OUTOFMEMORY);

  *ppdo = pDataObj;

  PWSTR pszFilter = NULL;
  hr = BuildQueryString(&pszFilter);
  if (FAILED(hr) ||
      !pszFilter ||
      hr == S_FALSE)
  {
    delete pDataObj;
    pDataObj = NULL;
    *ppdo = NULL;
    hr = S_FALSE;
  }
  else
  {
    hr = CollectDsObjects(pszFilter, pDsScope, pDataObj);
  }

  if (pszFilter != NULL)
  {
    delete[] pszFilter;
    pszFilter = NULL;
  }

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::GetQueryInfoByScope
//
//  Synopsis:   Called by the Object Picker UI 
//
//-----------------------------------------------------------------------------
HRESULT CDsGrpMembersPage::GetQueryInfoByScope(IDsObjectPickerScope*,
                                               PDSQUERYINFO *ppdsqi) 
{ 
  return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::PrefixSearch
//
//  Synopsis:   Called by the Object Picker UI to get additional objects starting
//              with a specific string
//
//-----------------------------------------------------------------------------
HRESULT CDsGrpMembersPage::PrefixSearch(IDsObjectPickerScope *pDsScope,
                                        PCWSTR pwzSearchFor,
                                        IDataObject **ppdo)
{
  HRESULT hr = S_OK;

  //
  // Prepare the data object
  //
  CDsPropDataObj* pDataObj = new CDsPropDataObj(GetHWnd(), m_fReadOnly);
  CHECK_NULL(pDataObj, return E_OUTOFMEMORY);

  *ppdo = pDataObj;

  CStrW szFilter;
  PWSTR pszFilter = NULL;
  hr = BuildQueryString(&pszFilter);
  if (FAILED(hr) || 
      hr == S_FALSE ||
      pszFilter == NULL)
  {
    delete pDataObj;
    pDataObj = NULL;
    *ppdo = NULL;

    if (pszFilter)
    {
      delete[] pszFilter;
      pszFilter = NULL;
    }

    hr = S_FALSE;
  }
  else
  {
    szFilter = pszFilter;
  
    CStrW szEscapedSearchFor;

    GetFilterEscapedValue(pwzSearchFor, szEscapedSearchFor);

    CStrW szPrefix;
    szPrefix = L"(&(name=";
    szPrefix += szEscapedSearchFor;
    szPrefix += L"*)";

    szFilter = szPrefix + szFilter + L")";
    hr = CollectDsObjects(szFilter.GetBuffer(szFilter.GetLength() + 1), pDsScope, pDataObj);
  }

  return hr;
}


//+----------------------------------------------------------------------------
//
//  Function:   CreateGroupMembersPage
//
//  Synopsis:   Creates an instance of the group membership page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateGroupMembersPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                       PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                       DWORD dwFlags, const CDSSmartBasePathsInfo& basePathsInfo,
                       HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateGroupMembersPage);

    CDsGrpMembersPage * pPageObj = new CDsGrpMembersPage(pDsPage, pDataObj,
                                                         hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, basePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CDsGrpMembersPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return(FALSE);
    }

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT
CDsGrpMembersPage::OnInitDialog(LPARAM lParam)
{
    return OnInitDialog(lParam, TRUE);
}

HRESULT CDsGrpMembersPage::OnInitDialog(LPARAM, BOOL fShowIcons)
{
    TRACE(CDsGrpMembersPage,OnInitDialog);
    HRESULT hr;
    PADS_ATTR_INFO pAttrs = NULL;
    DWORD cAttrs = 0;

    m_fShowIcons = (0 != g_ulMemberFilterCount) ? fShowIcons : FALSE;

    CWaitCursor Wait;

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    PTSTR ptzRDN;
    if (!UnicodeToTchar(m_pwszRDName, &ptzRDN))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        return S_OK;
    }

    SetDlgItemText(m_hPage, IDC_CN, ptzRDN);
    delete [] ptzRDN;

    GetDomainMode(this, &m_fMixed);

    //
    // Get the group RID.
    //
    PWSTR rgpwzAttrNames[] = {L"primaryGroupToken"};

    hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);

    if (!CHECK_ADS_HR(&hr, m_hPage))
    {
        return S_OK;
    }

    dspAssert(cAttrs);

    if (cAttrs == 1)
    {
        dspAssert(pAttrs);

        m_dwGroupRID = pAttrs->pADsValues->Integer;

        FreeADsMem(pAttrs);
    }

    GetGroupType(this, &m_dwType);
    dspDebugOut((DEB_ITRACE, "Group Type = 0x%x\n", m_dwType));

    //
    // Get the membership list and fill the listview control.
    //
    m_pList = new CDsMembershipList(m_hPage, IDC_MEMBER_LIST);

    CHECK_NULL_REPORT(m_pList, m_hPage, return S_OK);

    hr = m_pList->Init(m_fShowIcons);

    CHECK_HRESULT(hr, return S_OK);

    hr = FillGroupList();

    CHECK_HRESULT(hr, return S_OK);

    m_fMemberWritable = CheckIfWritable(g_wzMemberAttr);

    if (!m_fMemberWritable)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_ADD_BTN), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BTN), FALSE);
    }

    //Set the focus and selection on first item in the list
    ListView_SetItemState(GetDlgItem(m_hPage, IDC_MEMBER_LIST), 0,
                          LVIS_SELECTED, LVIS_SELECTED);
    ListView_SetItemState(GetDlgItem(m_hPage, IDC_MEMBER_LIST), 0,
                          LVIS_FOCUSED, LVIS_FOCUSED);

    BOOL bSecurityGroup = (m_dwType & GROUP_TYPE_SECURITY_ENABLED) ? TRUE : FALSE;
    hr = LoadGroupExtraClasses(bSecurityGroup);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsGrpMembersPage::OnApply(void)
{
    TRACE(CDsGrpMembersPage,OnApply);
    HRESULT hr = S_OK;
    ADS_ATTR_INFO AttrInfo;
    PADS_ATTR_INFO pAttrs = &AttrInfo;

    AttrInfo.pszAttrName = g_wzMemberAttr;
    AttrInfo.dwADsType = ADSTYPE_DN_STRING;

    //
    // Read the list of members and do additions.
    //
    DWORD cModified;
    int i, cMembers = m_pList->GetCount();

    if (cMembers > 0)
    {
        AttrInfo.dwControlCode = ADS_ATTR_APPEND;
        PADSVALUE rgADsValues;

        rgADsValues = new ADSVALUE[cMembers];

        CHECK_NULL(rgADsValues, return PSNRET_INVALID_NOCHANGEPAGE);

        memset(rgADsValues, 0, cMembers * sizeof(ADSVALUE));

        pAttrs->pADsValues = rgADsValues;
        pAttrs->dwNumValues = 0;

        CMemberListItem * pItem;

        for (i = 0; i < cMembers; i++)
        {
            if (FAILED(m_pList->GetItem(i, &pItem)))
            {
                dspAssert(FALSE && "List Error");
                return PSNRET_INVALID_NOCHANGEPAGE;
            }
            if (!pItem)
            {
                dspAssert(pItem);
                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            if (pItem->m_fIsAlreadyMember)
            {
                continue;
            }

            dspAssert(pItem->m_pwzDN);

            rgADsValues[pAttrs->dwNumValues].DNString = pItem->m_pwzDN;
            rgADsValues[pAttrs->dwNumValues].dwType = ADSTYPE_DN_STRING;

            pAttrs->dwNumValues++;
        }

        if (pAttrs->dwNumValues)
        {
            hr = m_pDsObj->SetObjectAttributes(pAttrs, 1, &cModified);

            if (!CheckGroupUpdate(hr, m_hPage))
            {
                delete [] rgADsValues;
                return PSNRET_INVALID_NOCHANGEPAGE;
            }
        }
        delete [] rgADsValues;

        // Now mark all entries as members

        for (i = 0; i < cMembers; i++)
        {
            if (FAILED(m_pList->GetItem(i, &pItem)))
            {
                dspAssert(FALSE && "List Error");
                return PSNRET_INVALID_NOCHANGEPAGE;
            }
            if (!pItem)
            {
                dspAssert(pItem);
                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            pItem->m_fIsAlreadyMember = TRUE;
        }
    }

    //
    // Do removals.
    //
    DWORD cDelItems = m_DelList.GetItemCount();

    if (cDelItems)
    {
        AttrInfo.dwControlCode = ADS_ATTR_DELETE;
        PADSVALUE rgADsValues;

        rgADsValues = new ADSVALUE[cDelItems];

        CHECK_NULL(rgADsValues, return PSNRET_INVALID_NOCHANGEPAGE);

        memset(rgADsValues, 0, cDelItems * sizeof(ADSVALUE));

        pAttrs->pADsValues = rgADsValues;
        pAttrs->dwNumValues = 0;

        CMemberListItem * pDelItem = m_DelList.RemoveFirstItem();

        while (pDelItem)
        {
            if (pDelItem->m_fIsExternal)
            {
                hr = GetRealDN(pDelItem);

                CHECK_HRESULT_REPORT(hr, m_hPage, continue);
            }

            dspAssert(pDelItem->m_pwzDN);

            rgADsValues[pAttrs->dwNumValues].DNString = pDelItem->m_pwzDN;
            rgADsValues[pAttrs->dwNumValues].dwType = ADSTYPE_DN_STRING;

            pAttrs->dwNumValues++;

            pDelItem = m_DelList.RemoveFirstItem();
        }

        if (pAttrs->dwNumValues)
        {
            hr = m_pDsObj->SetObjectAttributes(pAttrs, 1, &cModified);

            if (!CheckGroupUpdate(hr, m_hPage, FALSE))
            {
                delete [] rgADsValues;
                return PSNRET_INVALID_NOCHANGEPAGE;
            }
        }
        delete [] rgADsValues;
    }

    return (SUCCEEDED(hr)) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CDsGrpMembersPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (m_fInInit)
    {
        return 0;
    }
    switch (codeNotify)
    {
    case BN_CLICKED:
        TRACE(CDsGrpMembersPage,OnCommand);
        if (id == IDC_ADD_BTN)
        {
            InvokeUserQuery();
        }
        if (id == IDC_REMOVE_BTN)
        {
            RemoveMember();
        }
        break;
    }
    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::OnNotify
//
//  Synopsis:   Handles list notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CDsGrpMembersPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    if (m_fInInit)
    {
        return 0;
    }
    switch (((LPNMHDR)lParam)->code)
    {
    case LVN_ITEMCHANGED:
        if (m_fMemberWritable)
        {
            LRESULT selected = SendDlgItemMessage(m_hPage, IDC_MEMBER_LIST, LVM_GETSELECTEDCOUNT, 0, 0);
            if (selected > 0)
            {
               EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BTN), TRUE);
            }
            else
            {
               EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BTN), FALSE);
            }
        }
        break;

    case NM_DBLCLK:
        //
        // Display properties for the selected item. First, find out
        // which item is selected.
        //
        CMemberListItem * pItem;

        if (!m_pList->GetCurListItem(NULL, NULL, &pItem))
        {
            break;
        }

        dspAssert(pItem);

        if (pItem->m_fIsExternal)
        {
            HRESULT hr = GetRealDN(pItem);

            if (hr == HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND))
            {
                MsgBox(IDS_CANT_VIEW_EXTERNAL, m_hPage);
                break;
            }
            CHECK_HRESULT_REPORT(hr, m_hPage, break);
        }

        if (pItem->m_ulScopeType & DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN)
        {
          //
          // We cannot show the properties for downlevel users
          //
          // Put a useful message up
          PTSTR ptzTitle, ptzMsg;
          if (!LoadStringToTchar(IDS_MSG_NO_DOWNLEVEL_PROPERTIES, &ptzMsg))
          {
            break;
          }
          if (!LoadStringToTchar(IDS_MSG_TITLE, &ptzTitle))
          {
            break;
          }
          MessageBox(m_hPage, ptzMsg, ptzTitle, MB_OK | MB_ICONEXCLAMATION);
          delete[] ptzTitle;
          delete[] ptzMsg;

          break;
        }
        PostPropSheet(pItem->m_pwzDN, this);
        break;
    }

    return CDsPropPageBase::OnNotify(wParam, lParam);
}

// NTRAID#NTBUG9-651756-2002/07/15-artm
//
// Helper function to copy LsaStrings to string objects.
//
#ifdef DSADMIN
HRESULT
CopyLsaString(const LSA_UNICODE_STRING& lsaString, CStrW& dest)
{
    TRACE_FUNCTION(CopyLsaString);
    dest.Empty();

    // Get string length in characters (+1 for NULL).
    int buffsize = (lsaString.Length / sizeof(WCHAR)) + 1;
    
    WCHAR* buffer = dest.GetBuffer(buffsize);
    
    if (!buffer)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = StringCchCopyN(
        buffer,
        buffsize,
        lsaString.Buffer,
        buffsize - 1);

    buffer = NULL;
    dest.ReleaseBuffer();

    // We don't expect that the copy should ever fail.
    dspAssert(SUCCEEDED(hr));

    return hr;
}


//
// Get the localized name and domain for a SID.
//
HRESULT
LocalizeSid(PSID psid, CStrW& localizedName, CStrW& localizedDomain)
{
    TRACE_FUNCTION(LocalizeSid);

    PLSA_TRANSLATED_NAME pTranslatedName            = NULL;
    PLSA_REFERENCED_DOMAIN_LIST pReferencedDomains  = NULL;

    HRESULT hr = S_OK;
    NTSTATUS nts = STATUS_SUCCESS;

    LSA_HANDLE hLsa = NULL;
    LSA_OBJECT_ATTRIBUTES lsaAttr;

    ::ZeroMemory(&lsaAttr, sizeof(lsaAttr));

    do
    {
        if (!psid || !IsValidSid(psid))
        {
            hr = E_INVALIDARG;
            break;
        }

        // Acquire the LSA resource.
        // We call this in the same way as object picker.
        nts = LsaOpenPolicy(NULL, &lsaAttr, POLICY_LOOKUP_NAMES, &hLsa);
        if (nts != STATUS_SUCCESS)
        {
            hr = HRESULT_FROM_NT(nts);
            break;
        }

        // Convert the SID to a localized name.
        nts = LsaLookupSids(hLsa,
                            1,
                            &psid,
                            &pReferencedDomains,
                            &pTranslatedName);
        if (nts != STATUS_SUCCESS)
        {
            hr = HRESULT_FROM_NT(nts);
            break;
        }

        // Verify assumption that the SID we had was valid.
        if (pTranslatedName->Use == SidTypeInvalid ||
            pTranslatedName->Use == SidTypeUnknown ||
            pTranslatedName->Use == SidTypeDomain)
        {
            dspAssert(pTranslatedName->Use != SidTypeInvalid);
            dspAssert(pTranslatedName->Use != SidTypeUnknown);
            dspAssert(pTranslatedName->Use != SidTypeDomain);
            hr = E_FAIL;
            break;
        }

        hr = CopyLsaString(pTranslatedName->Name, localizedName);
        CHECK_HRESULT(hr, break);

        // If there are no referenced domains for the localized name we
        // don't need to do any more work.
        if (pTranslatedName->DomainIndex < 0L)
        {
            break;
        }

        ULONG domainIndex = pTranslatedName->DomainIndex;

        // Should _never_ happen.  Implies a bug either in Lsa functions
        // or in their documentation.
        dspAssert(pReferencedDomains->Entries >= domainIndex);

        hr = CopyLsaString(
            pReferencedDomains->Domains[domainIndex].Name, 
            localizedDomain);
        CHECK_HRESULT(hr, break);

    } while (0);

    // Clean up any resources we've accumulated.
    if (pTranslatedName)
    {
        LsaFreeMemory(static_cast<PVOID>(pTranslatedName));
    }

    if (pReferencedDomains)
    {
        LsaFreeMemory(static_cast<PVOID>(pReferencedDomains));
    }

    if (hLsa)
    {
        nts = LsaClose(hLsa);
        hLsa = NULL;

        // No conceivable reason why this should fail.
        dspAssert(nts == STATUS_SUCCESS);
    }

    return hr;
}
#endif // DSADMIN


//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::InvokeUserQuery
//
//  Synopsis:   Bring up the query dialog to search for users and groups.
//
//-----------------------------------------------------------------------------
void
CDsGrpMembersPage::InvokeUserQuery(void)
{
    TRACE(CDsGrpMembersPage,InvokeUserQuery);
    HRESULT hr;
    UINT i;
    CWaitCursor WaitCursor;
    CSmartWStr cstrCleanDN;
    IDsObjectPicker * pObjSel;
    BOOL fIsObjSelInited, fNativeModeUSG = FALSE;
    CStr strExternMemberList;

    hr = GetObjSel(&pObjSel, &fIsObjSelInited);

    CHECK_HRESULT(hr, return);

    if (!fIsObjSelInited)
    {
        CStrW cstrDC;
        hr = GetLdapServerName(m_pDsObj, cstrDC);

        CHECK_HRESULT_REPORT(hr, m_hPage, return);
        dspDebugOut((DEB_ITRACE, "ObjSel targetted to %ws\n", (LPCWSTR)cstrDC));

        DSOP_SCOPE_INIT_INFO rgScopes[5];
        DSOP_INIT_INFO InitInfo;

        ZeroMemory(rgScopes, sizeof(rgScopes));
        ZeroMemory(&InitInfo, sizeof(InitInfo));

        // The first scope is the local domain. All group types can contain
        // users, computers, and contacts from the local domain.
        //
        rgScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN;
        rgScopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE |
                              DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                              DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;
        rgScopes[0].pwzDcName = cstrDC;
        rgScopes[0].FilterFlags.Uplevel.flBothModes =
            DSOP_FILTER_USERS | DSOP_FILTER_CONTACTS | DSOP_FILTER_COMPUTERS;

        // The second scope is the local forest.
        //
        rgScopes[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
        rgScopes[1].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                              DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;

        // The third scope is the GC.
        //
        rgScopes[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[2].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
        rgScopes[2].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                              DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;

        // The fourth scope is uplevel external trusted domains.
        //
        rgScopes[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[3].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN;
        rgScopes[3].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                              DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS |
                              DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP;

        // The fifth scope is downlevel external trusted domains.
        //
        rgScopes[4].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[4].flType = DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;
        rgScopes[4].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                              DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;

        if (m_dwType & GROUP_TYPE_ACCOUNT_GROUP) // Global group
        {
            if (!(m_fMixed && (m_dwType & GROUP_TYPE_SECURITY_ENABLED)))
            {
                // if it is not mixed-mode, security-enabled, add global.
                //
                rgScopes[0].FilterFlags.Uplevel.flBothModes |=
                    DSOP_FILTER_GLOBAL_GROUPS_DL |
                    DSOP_FILTER_GLOBAL_GROUPS_SE;
            }
            rgScopes[1].FilterFlags.Uplevel.flBothModes =
            rgScopes[2].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_CONTACTS;

            InitInfo.cDsScopeInfos = 3; // Enterprise scope.
        }
        else if (m_dwType & GROUP_TYPE_RESOURCE_GROUP) // Local group.
        {
            rgScopes[0].FilterFlags.Uplevel.flBothModes |=
                DSOP_FILTER_UNIVERSAL_GROUPS_DL |
                DSOP_FILTER_UNIVERSAL_GROUPS_SE |
                DSOP_FILTER_GLOBAL_GROUPS_DL |
                DSOP_FILTER_GLOBAL_GROUPS_SE;
            if (!(m_fMixed && (m_dwType & GROUP_TYPE_SECURITY_ENABLED)) &&
                !(m_dwType & GROUP_TYPE_BUILTIN_LOCAL_GROUP))
            {
                // If this is not a mixed-mode security-enabled local group
                // or a builtin group, then add local groups.
                //
                rgScopes[0].FilterFlags.Uplevel.flBothModes |=
                    DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
                    DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
            }

            rgScopes[1].FilterFlags.Uplevel.flBothModes =
            rgScopes[2].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_USERS | DSOP_FILTER_CONTACTS |
                DSOP_FILTER_COMPUTERS |
                DSOP_FILTER_UNIVERSAL_GROUPS_DL |
                DSOP_FILTER_UNIVERSAL_GROUPS_SE |
                DSOP_FILTER_GLOBAL_GROUPS_DL |
                DSOP_FILTER_GLOBAL_GROUPS_SE;

            //bug  37724
            if( m_dwType & GROUP_TYPE_BUILTIN_LOCAL_GROUP )
            {
                    rgScopes[0].FilterFlags.Uplevel.flBothModes |=
                    DSOP_FILTER_WELL_KNOWN_PRINCIPALS;
                    rgScopes[1].FilterFlags.Uplevel.flBothModes |=
                    DSOP_FILTER_WELL_KNOWN_PRINCIPALS;
                    rgScopes[2].FilterFlags.Uplevel.flBothModes |=
                    DSOP_FILTER_WELL_KNOWN_PRINCIPALS;
            }

            //
            // Uplevel external domains:
            //
            rgScopes[3].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_USERS | DSOP_FILTER_COMPUTERS |
                DSOP_FILTER_UNIVERSAL_GROUPS_DL |
                DSOP_FILTER_UNIVERSAL_GROUPS_SE |
                DSOP_FILTER_GLOBAL_GROUPS_DL |
                DSOP_FILTER_GLOBAL_GROUPS_SE;
            //
            // Downlevel external domains:
            //
            rgScopes[4].FilterFlags.flDownlevel =
                DSOP_DOWNLEVEL_FILTER_USERS |
                DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;

            InitInfo.cDsScopeInfos = 5; // Any trusted domain.
        }
        else if (m_dwType & GROUP_TYPE_UNIVERSAL_GROUP)
        {
            rgScopes[0].FilterFlags.Uplevel.flBothModes =
            rgScopes[1].FilterFlags.Uplevel.flBothModes =
            rgScopes[2].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_USERS | DSOP_FILTER_CONTACTS |
                DSOP_FILTER_COMPUTERS |
                DSOP_FILTER_UNIVERSAL_GROUPS_DL |
                DSOP_FILTER_UNIVERSAL_GROUPS_SE |
                DSOP_FILTER_GLOBAL_GROUPS_DL |
                DSOP_FILTER_GLOBAL_GROUPS_SE;

            InitInfo.cDsScopeInfos = 3; // Enterprise scope.
        }

        InitInfo.cbSize = sizeof(DSOP_INIT_INFO);
        InitInfo.aDsScopeInfos = rgScopes;
        InitInfo.pwzTargetComputer = cstrDC;
        InitInfo.flOptions = DSOP_FLAG_MULTISELECT;
        InitInfo.cAttributesToFetch = 2;
        LPCWSTR rgAttrNames[] = {g_wzObjectSID,
                                 g_wzUserAccountControl};
        InitInfo.apwzAttributeNames = rgAttrNames;

        hr = pObjSel->Initialize(&InitInfo);

        CHECK_HRESULT_REPORT(hr, m_hPage, return);

        ObjSelInited();
    }

    IDataObject * pdoSelections = NULL;

    CComPtr<IDsObjectPickerEx> spObjPickerEx;
    hr = pObjSel->QueryInterface(IID_IDsObjectPickerEx, (void**)&spObjPickerEx);
    CHECK_HRESULT_REPORT(hr, m_hPage, return);

    hr = spObjPickerEx->InvokeDialogEx(m_hPage, this, &pdoSelections);

//    hr = pObjSel->InvokeDialog(m_hPage, &pdoSelections);

    CHECK_HRESULT_REPORT(hr, m_hPage, return);

    if (hr == S_FALSE || !pdoSelections)
    {
        return;
    }

    // Security enabled universal groups shouldn't contain members
    // from mixed-mode domains BUT, we have to allow it for Exchange's
    // non-standard public folder security model.
    //
    if (!m_fMixed && (m_dwType & GROUP_TYPE_UNIVERSAL_GROUP) &&
        (m_dwType & GROUP_TYPE_SECURITY_ENABLED))
    {
        fNativeModeUSG = TRUE;
    }

    m_MixedModeMembers.Init(this);

    CSmartWStr cstrCleanGroup;
    FORMATETC fmte = {g_cfDsSelList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};

    hr = pdoSelections->GetData(&fmte, &medium);

    CHECK_HRESULT_REPORT(hr, m_hPage, return);

    PDS_SELECTION_LIST pSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);

    if (!pSelList)
    {
        goto ExitCleanup;
    }

    WaitCursor.SetWait();

    // Clean the group name so it can be compared with those returned by the
    // user's selection.
    //
    hr = SkipPrefix(m_pwszObjPathName, &cstrCleanGroup);

    CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

    //
    // Insert the returned items into the group.
    //
    for (i = 0; i < pSelList->cItems; i++)
    {
        CMemberListItem * pItemInDelList = NULL;
        PSID pSid = NULL;

        if (!pSelList->aDsSelection[i].pwzADsPath) continue;

        // Check for an object from an external trusted domain. These objects
        // have a path of the form "LDAP://<SID=01050xxxx>". SAM will create
        // an FSPO for this member and will then store that DN rather than the
        // above path. We won't know this DN until after the member is added,
        // so use its object-SID to identify it.
        //

#ifdef DSADMIN
        // NTRAID#NTBUG9-651756-2002/07/03-artm    Need to use SID for well known security principals.
        PCWSTR objectClass = pSelList->aDsSelection[i].pwzClass;
        bool isWellKnownSecurityPrincipal = false;
        if (objectClass && (_wcsicmp(objectClass, g_wzFPO) == 0) )
        {
            isWellKnownSecurityPrincipal = true;
        }
#endif //DSADMIN

        if ((pSelList->aDsSelection[i].flScopeType == DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN) ||
            (pSelList->aDsSelection[i].flScopeType == DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN) 
#ifdef DSADMIN
            || isWellKnownSecurityPrincipal
#endif //DSADMIN 
            )
        {
            dspAssert(pSelList->aDsSelection[i].pvarFetchedAttributes);
            if (pSelList->aDsSelection[i].pvarFetchedAttributes[0].vt != (VT_ARRAY | VT_UI1))
            {
                REPORT_ERROR(ERROR_DATATYPE_MISMATCH, m_hPage);
                continue;
            }
            pSid = pSelList->aDsSelection[i].pvarFetchedAttributes[0].parray->pvData;
            dspAssert(IsValidSid(pSid));
            //
            // Check if the item is in the delete list, if so remove it.
            //
            pItemInDelList = m_DelList.FindItemRemove(pSid);
        }
        else
        {
            hr = SkipPrefix(pSelList->aDsSelection[i].pwzADsPath, &cstrCleanDN);

            CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

            // See if the user is trying to add the group to itself.
            //
            if (_wcsicmp(cstrCleanDN, cstrCleanGroup) == 0)
            {
                if (pSelList->cItems == 1)
                {
                    ErrMsg(IDS_ERROR_GRP_SELF, m_hPage);
                    goto ExitCleanup;
                }
                continue;
            }

            // Check if the item is in the delete list, if so remove it.
            //
            pItemInDelList = m_DelList.FindItemRemove(cstrCleanDN);
        }

        if (pItemInDelList)
        {
            hr = m_pList->InsertIntoList(pItemInDelList);
        }
        else
        {
            // NTRAID#NTBUG9-651756-2002/07/03-artm
#ifdef DSADMIN
            if (isWellKnownSecurityPrincipal)
            {
                dspAssert(pSid);

                CStrW localizedName, domainName;

                hr = LocalizeSid(pSid, localizedName, domainName);
                CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

                // Dummy up the canonical version of the localized name.
                CStrW canonicalNameEx = domainName + L"\n" + localizedName;

                hr = m_pList->InsertIntoList(pSid, canonicalNameEx);
            }
            else if (pSid)
#else
            if (pSid)
#endif // DSADMIN
            {
                CComPtr<IADsPathname> spPathCracker;

                hr = GetADsPathname(spPathCracker);

                CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

                hr = spPathCracker->Set(CComBSTR(pSelList->aDsSelection[i].pwzADsPath),
                                        ADS_SETTYPE_FULL);

                CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);
                PWSTR pwzName;
                BSTR bstr;

                hr = spPathCracker->Retrieve(ADS_FORMAT_PROVIDER, &bstr);

                CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

                if (_wcsicmp(bstr, L"LDAP") == 0)
                {
                    SysFreeString(bstr);

                    hr = SkipPrefix(pSelList->aDsSelection[i].pwzADsPath, &cstrCleanDN);

                    CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

                    hr = CrackName(cstrCleanDN, &pwzName, GET_OBJ_CAN_NAME_EX, m_hPage);

                    CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

                    hr = m_pList->InsertIntoList(pSid, pwzName);

                    LocalFreeStringW(&pwzName);
                }
                else
                {
                    SysFreeString(bstr);

                    hr = spPathCracker->Retrieve(ADS_FORMAT_WINDOWS_DN, &bstr);

                    CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

                    hr = m_pList->InsertIntoList(pSid, bstr);

                    SysFreeString(bstr);
                }
            }
            else
            {
                int iIcon = -1;
                if (m_fShowIcons)
                {
                    BOOL fDisabled = FALSE;
                    if (pSelList->aDsSelection[i].pvarFetchedAttributes[1].vt == VT_I4)
                    {
                        fDisabled = pSelList->aDsSelection[i].pvarFetchedAttributes[1].lVal & UF_ACCOUNTDISABLE;
                    }
                    iIcon = g_ClassIconCache.GetClassIconIndex(pSelList->aDsSelection[i].pwzClass,
                                                               fDisabled);
                    if (iIcon == -1)
                    {
                      iIcon = g_ClassIconCache.AddClassIcon(pSelList->aDsSelection[i].pwzClass, 
                                                            fDisabled);
                    }
                }

                if (fNativeModeUSG &&
                    ((DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN == pSelList->aDsSelection[i].flScopeType) ||
                     (DSOP_SCOPE_TYPE_GLOBAL_CATALOG == pSelList->aDsSelection[i].flScopeType)))
                {
                    // member from domain in forest is DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                    // member from the same domain is DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                    //
                    m_MixedModeMembers.CheckMember(cstrCleanDN);
                }

                dspDebugOut((DEB_ITRACE, "New member scope is 0x%x\n", pSelList->aDsSelection[i].flScopeType));

                hr = m_pList->InsertIntoList(cstrCleanDN, iIcon);
            }
        }

        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_EXISTS))
        {
            continue;
        }
        CHECK_HRESULT(hr, goto ExitCleanup);
    }

    m_MixedModeMembers.ListExternalMembers(strExternMemberList);

    if (!strExternMemberList.IsEmpty())
    {
        CStr strMessage, strFormat;

        strFormat.LoadString(g_hInstance, IDS_USG_MIXED_WARNING);

        strMessage.Format(strFormat, strExternMemberList);

        ReportErrorWorker(m_hPage, (LPTSTR)(LPCTSTR)strMessage);
    }

    SetDirty();
ExitCleanup:
    GlobalUnlock(medium.hGlobal);
    ReleaseStgMedium(&medium);
    pdoSelections->Release();
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::FillGroupList
//
//  Synopsis:   Fill the list box with the names of the group members.
//
//-----------------------------------------------------------------------------
HRESULT
CDsGrpMembersPage::FillGroupList(void)
{
    TRACE(CDsGrpMembersPage,FillGroupList);
    return ::FillGroupList(this, m_pList, m_dwGroupRID);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::RemoveMember
//
//  Synopsis:   Removes the selected users.
//
//-----------------------------------------------------------------------------
void
CDsGrpMembersPage::RemoveMember(void)
{
    TRACE(CDsGrpMembersPage,RemoveMember);
    if (!m_pList)
    {
        return;
    }
    int* pIndex = NULL;
    CMemberListItem ** ppItem;
    int nNumSelected = 0;

    //
    // Compose the confirmation message and post it.
    //
    TCHAR szMsg[160];
    if (!LoadStringReport(IDS_RM_MBR_MSG, szMsg, 160, m_hPage))
    {
        return;
    }

    TCHAR szTitle[80];
    if (!LoadStringReport(IDS_MSG_TITLE, szTitle, 80, m_hPage))
    {
        return;
    }

    LONG iRet = MessageBox(m_hPage, szMsg, szTitle, MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2);

    if (iRet == IDNO)
    {
        // The user declined, so go home.
        //
        return;
    }

    CWaitCursor cWait;

    if (!m_pList->GetCurListItems(&pIndex, NULL, &ppItem, &nNumSelected))
    {
        return;
    }

    for (int idx = 0; idx < nNumSelected; idx++)
    {
      if (!ppItem[idx])
      {
        if (pIndex != NULL)
        {
          delete[] pIndex;
          pIndex = 0;
        }
        delete[] ppItem;
        return;
      }

      if (ppItem[idx]->m_fIsPrimary)
      {
          ErrMsg(IDS_RM_USR_PRI_GRP, m_hPage);
          continue;
      }


      //
      // Put the item into the delete list and remove it from the list box.
      //
      if (!m_DelList.AddItem(ppItem[idx]))
      {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);

        if (pIndex != NULL)
        {
          delete[] pIndex;
          pIndex = 0;
        }
        delete[] ppItem;
        return;
      }

      m_pList->RemoveListItem(pIndex[idx]);

      for (int idx2 = idx; idx2 < nNumSelected; idx2++)
      {
        if (pIndex[idx2] > pIndex[idx])
        {
          pIndex[idx2]--;
        }
      }

      SetDirty();
    }
    //
    // Disable the Remove button, since nothing in the list box should have
    // the selection at this point.
    //
    //Since Remove Button has focus now, set focus to add button
    //before disabling

    SetFocus(GetDlgItem(m_hPage,IDC_ADD_BTN));
    PostMessage(GetDlgItem(m_hPage, IDC_ADD_BTN), BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE, 0));

    PostMessage(GetDlgItem(m_hPage, IDC_REMOVE_BTN), BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
    EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BTN), FALSE);


    if (pIndex != NULL)
    {
      delete[] pIndex;
      pIndex = 0;
    }
    delete[] ppItem;

    return;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::GetRealDN
//
//  Synopsis:   If a member from an external domain that was added to the
//              group during this instance of the page, we won't yet have the
//              path to the FPO as the DN. So, search for the FPO using the
//              object-SID.
//
//-----------------------------------------------------------------------------
HRESULT
CDsGrpMembersPage::GetRealDN(CMemberListItem * pItem)
{
    return ::GetRealDN(this, pItem);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsGrpMembersPage::OnDestroy(void)
{
    if (m_pList)
    {
        m_pList->ClearList();
    }

    CDsPropPageBase::OnDestroy();
    // If an application processes this message, it should return zero.
    return 0;
}

HRESULT HrVariantToStringArray(const CComVariant& refvar, PWSTR** pppszStringArray, DWORD* pdwCount)
{
  HRESULT hr = S_OK;
  long start, end, current;
  *pdwCount = 0;
  *pppszStringArray = NULL;

	if (V_VT(&refvar) == VT_BSTR)
	{
		CComBSTR bstrVal = V_BSTR(&refvar);
    *pppszStringArray = new PWSTR[1];
    if (*pppszStringArray != NULL)
    {
      size_t length = wcslen(bstrVal);
      PWSTR pszVal = new WCHAR[length + 1];
      if (pszVal != NULL)
      {
        wcscpy(pszVal, bstrVal);
        (*pppszStringArray)[0] = pszVal;
      }
      else
      {
        delete[] *pppszStringArray;
        *pppszStringArray = NULL;
        *pdwCount = 0;
        return E_OUTOFMEMORY;
      }
    }
    *pdwCount = 1;
		return S_OK;
	}

  //
  // Check the VARIANT to make sure we have
  // an array of variants.
  //

  if ( V_VT(&refvar) != ( VT_ARRAY | VT_VARIANT ) )
  {
    dspAssert(FALSE);
    return E_UNEXPECTED;
  }
  SAFEARRAY *saAttributes = V_ARRAY( &refvar );

  //
  // Figure out the dimensions of the array.
  //

  hr = SafeArrayGetLBound( saAttributes, 1, &start );
  if( FAILED(hr) )
    return hr;

  hr = SafeArrayGetUBound( saAttributes, 1, &end );
  if( FAILED(hr) )
    return hr;

  CComVariant SingleResult;

  //
  // Process the array elements.
  //

  *pppszStringArray = new PWSTR[(end - start) + 1];
  if (*pppszStringArray != NULL)
  {
    for ( current = start; current <= end; current++) 
    {
      hr = SafeArrayGetElement( saAttributes, &current, &SingleResult );
      if( FAILED(hr) )
        return hr;
      if ( V_VT(&SingleResult) != VT_BSTR )
        return E_UNEXPECTED;

      CComBSTR bstrVal = V_BSTR(&SingleResult);
      size_t length = wcslen(bstrVal);
      PWSTR pszVal = new WCHAR[length + 1];
      if (pszVal != NULL)
      {
        wcscpy(pszVal, bstrVal);

        long lCount = static_cast<long>(*pdwCount);
        if (lCount < (end - start) + 1)
        {
          (*pppszStringArray)[(*pdwCount)++] = pszVal;
        }
      }
      else
      {
        return E_OUTOFMEMORY;
      }
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
    *pdwCount = 0;
  }

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::LoadGroupExtraClasses
//
//  Synopsis:   Read the extra classes that need to be displayed from the
//              DisplaySpecifiers
//
//-----------------------------------------------------------------------------
HRESULT CDsGrpMembersPage::LoadGroupExtraClasses(BOOL bSecurity)
{
  HRESULT hr = S_OK;
    
  dspAssert(m_pDsObj != NULL);
  if (m_pDsObj == NULL)
  {
    return E_INVALIDARG;
  }

  static LPCWSTR lpszSettingsObjectClass = L"dsUISettings";
  static LPCWSTR lpszSettingsObject = L"cn=DS-UI-Default-Settings";
  static LPCWSTR lpszSecurityGroupProperty = L"msDS-Security-Group-Extra-Classes";
  static LPCWSTR lpszNonSecurityGroupProperty = L"msDS-Non-Security-Group-Extra-Classes";

  //
  // Not AddRef'd so don't use a smart pointer
  //
  IDsDisplaySpecifier* pDispSpec;
  hr = GetIDispSpec(&pDispSpec);
  CHECK_HRESULT_REPORT(hr, GetHWnd(), return hr);

  //
  // get the display specifiers locale container (e.g. 409)
  //
  CComPtr<IADsContainer> spLocaleContainer;
  hr = pDispSpec->GetDisplaySpecifier(NULL, IID_IADsContainer, (void**)&spLocaleContainer);
  if (FAILED(hr))
  {
    return hr;
  }

  //
  // bind to the settings object
  //
  CComPtr<IDispatch> spIDispatchObject;
  hr = spLocaleContainer->GetObject(CComBSTR(lpszSettingsObjectClass), 
                                    CComBSTR(lpszSettingsObject), 
                                    &spIDispatchObject);
  if (FAILED(hr))
  {
    return hr;
  }

  CComPtr<IADs> spSettingsObject;
  hr = spIDispatchObject->QueryInterface(IID_IADs, (void**)&spSettingsObject);
  if (FAILED(hr))
  {
    return hr;
  }

  if (bSecurity)
  {
    //
    // get the security group extra classes as a CStringList
    //
    CComVariant var;
    hr = spSettingsObject->Get(CComBSTR(lpszSecurityGroupProperty), &var);
    if (SUCCEEDED(hr))
    {
      hr = HrVariantToStringArray(var, &m_pszSecurityGroupExtraClasses, &m_dwSecurityGroupExtraClassesCount);
    }
  }
  else
  {
    //
    // get the non-security group extra classes as a CStringList
    //
    CComVariant var;
    hr = spSettingsObject->Get(CComBSTR(lpszNonSecurityGroupProperty), &var);
    if (SUCCEEDED(hr))
    {
      hr = HrVariantToStringArray(var, &m_pszNonSecurityGroupExtraClasses, &m_dwNonSecurityGroupExtraClassesCount);
    }
  }
  return hr;
}
//+----------------------------------------------------------------------------
//
//  Function:   GetDomainMode
//
//  Synopsis:   Is the domain to which the indicated object belongs in mixed
//              or native mode?
//
//-----------------------------------------------------------------------------
HRESULT
GetDomainMode(CDsPropPageBase * pObj, PBOOL pfMixed)
{
    HRESULT hr;
    CComBSTR cbstrDomain;

    hr = GetDomainScope(pObj, &cbstrDomain);

    CHECK_HRESULT_REPORT(hr, pObj->GetHWnd(), return hr);

    return GetDomainMode(cbstrDomain, pObj->GetHWnd(), pfMixed);
}

HRESULT
GetDomainMode(PWSTR pwzDomain, HWND hWnd, PBOOL pfMixed)
{
    HRESULT hr;
    WCHAR wzMixedAttr[] = L"nTMixedDomain";
    PWSTR rgpwzAttrNames[] = {wzMixedAttr};
    CComPtr <IDirectoryObject> pDomObj;
    PADS_ATTR_INFO pAttrs = NULL;
    DWORD cAttrs = 0;

    dspDebugOut((DEB_ITRACE, "GetDomainMode targetted to %ws\n", pwzDomain));

    hr = DSAdminOpenObject(pwzDomain,
                           IID_IDirectoryObject, 
                           (void **)&pDomObj);

    CHECK_HRESULT_REPORT(hr, hWnd, return hr);

    hr = pDomObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);

    CHECK_HRESULT_REPORT(hr, hWnd, return hr);

    if (cAttrs && pAttrs && (_wcsicmp(pAttrs->pszAttrName, wzMixedAttr) == 0))
    {
        *pfMixed = (BOOL)pAttrs->pADsValues->Integer;

        FreeADsMem(pAttrs);
    }
    else
    {
        *pfMixed = 0;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetGroupType
//
//-----------------------------------------------------------------------------
HRESULT
GetGroupType(CDsPropPageBase * pObj, DWORD * pdwType)
{
    HRESULT hr;
    PWSTR rgpwzAttrNames[] = {g_wzGroupType};
    PADS_ATTR_INFO pAttrs = NULL;
    DWORD cAttrs = 0;

    hr = pObj->m_pDsObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);

    CHECK_HRESULT_REPORT(hr, pObj->GetHWnd(), return hr);

    if (cAttrs && pAttrs && (_wcsicmp(pAttrs->pszAttrName, g_wzGroupType) == 0))
    {
        *pdwType = pAttrs->pADsValues->Integer;

        FreeADsMem(pAttrs);
    }
    else
    {
        *pdwType = 0;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   FillGroupList
//
//  Synopsis:   Fill the list box with the names of the group members.
//
//-----------------------------------------------------------------------------
HRESULT
FillGroupList(CDsPropPageBase * pPage, CDsMembershipList * pList,
              DWORD dwGroupRID)
{
    TRACE_FUNCTION(FillGroupList);
    HRESULT hr = S_OK;
    Smart_PADS_ATTR_INFO spAttrs;
    DWORD i, cAttrs = 0;
    WCHAR wzMemberAttr[MAX_PATH] = L"member;range=0-*";
    const WCHAR wcSep = L'-';
    const WCHAR wcEnd = L'*';
    const WCHAR wzFormat[] = L"member;range=%ld-*";
    PWSTR pwzAttrName[] = {wzMemberAttr}, pwzPath;
    BOOL fMoreRemain = FALSE, fNameNotMapped = FALSE;
    CComPtr <IDirectorySearch> spDsSearch;

    //
    // Read the membership list from the object using range (incremental)
    // retrieval.
    //
    do
    {
        hr = pPage->m_pDsObj->GetObjectAttributes(pwzAttrName, 1, &spAttrs, &cAttrs);

        if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, pPage->GetHWnd()))
        {
            return hr;
        }

        if (cAttrs > 0 && spAttrs != NULL)
        {
            for (i = 0; i < spAttrs->dwNumValues; i++)
            {
                hr = pList->InsertIntoNewList(spAttrs->pADsValues[i].CaseIgnoreString);

                if (DS_NAME_ERROR_NO_MAPPING == HRESULT_CODE(hr))
                {
                    fNameNotMapped = TRUE;
                    hr = S_OK;
                }
                else
                {
                    CHECK_HRESULT(hr, return hr);
                }
            }
            //
            // Check to see if there is more data. If the last char of the
            // attribute name string is an asterisk, then we have everything.
            //
            size_t cchEnd = wcslen(spAttrs->pszAttrName);

            fMoreRemain = spAttrs->pszAttrName[cchEnd - 1] != wcEnd;

            if (fMoreRemain)
            {
                PWSTR pwz = wcsrchr(spAttrs->pszAttrName, wcSep);
                if (!pwz)
                {
                    dspAssert(FALSE && spAttrs->pszAttrName);
                    fMoreRemain = FALSE;
                }
                else
                {
                    pwz++; // move past the hyphen to the range end value.
                    dspAssert(*pwz);
                    long lEnd = _wtol(pwz);
                    lEnd++; // start with the next value.
                    wsprintfW(wzMemberAttr, wzFormat, lEnd);
                    dspDebugOut((DEB_ITRACE,
                                 "Range returned is %ws, now asking for %ws\n",
                                 spAttrs->pszAttrName, wzMemberAttr));
                }
            }
        }
    } while (fMoreRemain);

    //
    // Query for all users/computers who have this as their primary group.
    //
    // Filter out interdomain-trust accounts (0x30000002).
    // This value is defined in ds\src\dsamain\include\mappings.h
    //
    WCHAR wzSearchFormat[] = L"(&(primaryGroupID=%u)(sAMAccountType<=805306369))";

    CStrW strSearchFilter;
    strSearchFilter.Format(wzSearchFormat, dwGroupRID);

    BSTR bstrDomain;

    hr = GetDomainScope(pPage, &bstrDomain);

    CHECK_HRESULT(hr, return hr);

    pwzAttrName[0] = g_wzADsPath;

    CDSSearch Search;
    hr = Search.Init((LPCWSTR)bstrDomain);

    SysFreeString(bstrDomain);
    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    Search.SetFilterString(const_cast<LPWSTR>((LPCWSTR)strSearchFilter));

    Search.SetAttributeList(pwzAttrName, 1);
    Search.SetSearchScope(ADS_SCOPE_SUBTREE);

    hr = Search.DoQuery();

    while (SUCCEEDED(hr))
    {
        hr = Search.GetNextRow();

        if (hr == S_ADS_NOMORE_ROWS)
        {
            hr = S_OK;
            break;
        }

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        ADS_SEARCH_COLUMN Column = {0};

        hr = Search.GetColumn(g_wzADsPath, &Column);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        hr = pPage->SkipPrefix(Column.pADsValues->CaseIgnoreString, &pwzPath);

        Search.FreeColumn(&Column);
        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        hr = pList->InsertIntoNewList(pwzPath, TRUE);

        delete [] pwzPath;
        CHECK_HRESULT(hr, return hr);
    }

    if (pList->GetCount() < 1)
    {
        EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_REMOVE_BTN), FALSE);
    }
    else if (((CDsGrpMembersPage *)pPage)->m_fShowIcons)
    {
        // Get class and userAccountControl for the group members and use
        // those values to select icons.
        //
        pList->SetMemberIcons(pPage);
    }

    if (fNameNotMapped)
    {
        MsgBox(IDS_GRP_NO_NAME_MAPPING, pPage->GetHWnd());
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetRealDN
//
//  Synopsis:   If a member from an external domain that was added to the
//              group during this instance of the page, we won't yet have the
//              path to the FPO as the DN. So, search for the FPO using the
//              object-SID.
//
//-----------------------------------------------------------------------------
HRESULT
GetRealDN(CDsPropPageBase * pPage, CMemberListItem * pItem)
{
    HRESULT hr = S_OK;

    if (!pItem->GetSid())
    {
        return E_FAIL;
    }

    CComBSTR cbstrDomain;

    hr = GetDomainScope(pPage, &cbstrDomain);

    CHECK_HRESULT(hr, return hr);

    CStrW strDN;

    hr = FindFPO(pItem->GetSid(), cbstrDomain, strDN);
    //Don't show this eror here
    if(FAILED(hr))
        return hr;

    PWSTR pwzOldDN = pItem->m_pwzDN;

    if (!AllocWStr(const_cast<PWSTR>((LPCWSTR)strDN), &pItem->m_pwzDN))
    {
        REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
        return E_OUTOFMEMORY;
    }

    DO_DEL(pwzOldDN);

    pItem->m_fIsExternal = FALSE;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsGrpShlGenPage::CDsGrpShlGenPage
//
//-----------------------------------------------------------------------------
CDsGrpShlGenPage::CDsGrpShlGenPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                     HWND hNotifyObj, DWORD dwFlags) :
    m_pCIcon(NULL),
    m_fDescrWritable(FALSE),
    m_fDescrDirty(FALSE),
    CDsGrpMembersPage(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsGrpShlGenPage,CDsGrpShlGenPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsGrpShlGenPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsGrpShlGenPage::~CDsGrpShlGenPage
//
//-----------------------------------------------------------------------------
CDsGrpShlGenPage::~CDsGrpShlGenPage()
{
    TRACE(CDsGrpShlGenPage,~CDsGrpShlGenPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateGrpShlGenPage
//
//  Synopsis:   Creates an instance of the group shell general page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateGrpShlGenPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                    PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                    DWORD dwFlags, const CDSSmartBasePathsInfo& basePathsInfo,
                    HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateGroupMembersPage);

    CDsGrpShlGenPage * pPageObj = new CDsGrpShlGenPage(pDsPage, pDataObj,
                                                       hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, basePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpShlGenPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsGrpShlGenPage::OnInitDialog(LPARAM lParam)
{
    TRACE(CDsGrpShlGenPage,OnInitDialog);
    HRESULT hr;
    Smart_PADS_ATTR_INFO spAttrs;
    DWORD cAttrs = 0;

    CWaitCursor Wait;

    //
    // Get the icon from the DS and put it on the page.
    //
    ATTR_DATA ad = {0, 0};

    hr = GeneralPageIcon(this, &GenIcon, NULL, 0, &ad, fInit);

    CHECK_HRESULT_REPORT(hr, m_hPage, return S_OK);

    m_pCIcon = (CDsIconCtrl *)ad.pVoid;

    //
    // Get the name.
    //
    LPTSTR ptz;
    if (!UnicodeToTchar(m_pwszRDName, &ptz))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        return S_OK;
    }

    SetDlgItemText(m_hPage, IDC_CN, ptz);
    delete [] ptz;

    m_fDescrWritable = CheckIfWritable(g_wzDescription);

    //
    // Get the description
    //
    PWSTR rgpwzAttrNames[] = {g_wzDescription};

    hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, m_hPage))
    {
        return S_OK;
    }

    if (1 == cAttrs)
    {
        dspAssert(spAttrs);
        if (!UnicodeToTchar(spAttrs->pADsValues->CaseIgnoreString, &ptz))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            return S_OK;
        }
        SetDlgItemText(m_hPage, IDC_DESCRIPTION_EDIT, ptz);
        delete [] ptz;
    }

    if (m_fDescrWritable)
    {
        SendDlgItemMessage(m_hPage, IDC_DESCRIPTION_EDIT, EM_LIMITTEXT, DSPROP_DESCRIPTION_RANGE_UPPER, 0);
    }
    else
    {
        SendDlgItemMessage(m_hPage, IDC_DESCRIPTION_EDIT, EM_SETREADONLY, (WPARAM)TRUE, 0);
    }

    HRESULT hRes = CDsGrpMembersPage::OnInitDialog(lParam, FALSE);

#if !defined(DSADMIN)
    // in the Win95 shell, we do not want to have the buttons
    // because we do not have object picker
    MakeNotWritable();
    EnableWindow(GetDlgItem(m_hPage, IDC_ADD_BTN), FALSE);
#endif
    EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BTN), FALSE);

    return  hRes;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpShlGenPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CDsGrpShlGenPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (m_fInInit)
    {
        return 0;
    }
    if (EN_CHANGE == codeNotify && IDC_DESCRIPTION_EDIT == id)
    {
        m_fDescrDirty = TRUE;
    }
    TRACE(CDsGrpShlGenPage,OnCommand);
    return CDsGrpMembersPage::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpShlGenPage::OnApply
//
//  Synopsis:   Write changes
//
//-----------------------------------------------------------------------------
LRESULT CDsGrpShlGenPage::OnApply(void)
{
    TRACE(CDsGrpShlGenPage,OnApply);

    ADS_ATTR_INFO AttrInfoDesc = {g_wzDescription, ADS_ATTR_UPDATE,
                                  ADSTYPE_CASE_IGNORE_STRING, NULL, 0};
    ADSVALUE ADsValueDesc = {ADSTYPE_CASE_IGNORE_STRING, NULL};

    AttrInfoDesc.pADsValues = &ADsValueDesc;
    AttrInfoDesc.dwNumValues = 1;
    LPTSTR ptsz;

    if (m_fDescrDirty)
    {
        dspAssert(m_fDescrWritable);

        ptsz = new TCHAR[DSPROP_DESCRIPTION_RANGE_UPPER + 1];
        CHECK_NULL_REPORT(ptsz, m_hPage, return -1);

        if (GetDlgItemText(m_hPage, IDC_DESCRIPTION_EDIT, ptsz, DSPROP_DESCRIPTION_RANGE_UPPER + 1) == 0)
        {
            // An empty control means remove the attribute value from the
            // object.
            //
            AttrInfoDesc.dwNumValues = 0;
            AttrInfoDesc.pADsValues = NULL;
            AttrInfoDesc.dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
            if (!TcharToUnicode(ptsz, &ADsValueDesc.CaseIgnoreString))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                delete [] ptsz;
                return -1;
            }
        }
        delete [] ptsz;
        DWORD cModified;

        HRESULT hr = m_pDsObj->SetObjectAttributes(&AttrInfoDesc, 1, &cModified);

        if (!CHECK_ADS_HR(&hr, m_hPage))
        {
            goto Cleanup;
        }

        m_fDescrDirty = FALSE;
    }

Cleanup:
    DO_DEL(ADsValueDesc.CaseExactString);

    return CDsGrpMembersPage::OnApply();
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpShlGenPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsGrpShlGenPage::OnDestroy(void)
{
    ATTR_DATA ad = {0, (LPARAM)m_pCIcon};

    GeneralPageIcon(this, &GenIcon, NULL, 0, &ad, fOnDestroy);

    CDsGrpMembersPage::OnDestroy();
    // If an application processes this message, it should return zero.
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   CheckGroupUpdate
//
//  Synopsis:   Checks the result code to see if a group-specific error has
//              occured.
//
//-----------------------------------------------------------------------------
BOOL
CheckGroupUpdate(HRESULT hr, HWND hPage, BOOL fAdd, PWSTR pwzDN)
{
    if (SUCCEEDED(hr))
    {
        return TRUE;
    }
    if (hPage == NULL)
    {
        hPage = GetDesktopWindow();
    }
    DWORD dwErr = 0;
    WCHAR wszErrBuf[MAX_PATH+1];
    WCHAR wszNameBuf[MAX_PATH+1];
    ADsGetLastError(&dwErr, wszErrBuf, MAX_PATH, wszNameBuf, MAX_PATH);
    //
    // ERROR_DS_CONSTRAINT_VIOLATION is the error returned for
    // duplicate name.
    //
    if ((LDAP_RETCODE)dwErr == LDAP_CONSTRAINT_VIOLATION ||
        hr == HRESULT_FROM_WIN32(ERROR_DS_CONSTRAINT_VIOLATION))
    {
        PTSTR ptzTitle, ptzMsg;

        if (!LoadStringToTchar(IDS_MSG_TITLE, &ptzTitle))
        {
            goto FatalError;
        }
        if (!LoadStringToTchar((fAdd) ? IDS_ERRMSG_GROUP_CONSTRAINT :
                                        IDS_ERRMSG_GROUP_DELETE, &ptzMsg))
        {
            delete [] ptzTitle;
            goto FatalError;
        }
        MessageBox(hPage, ptzMsg, ptzTitle, MB_OK | MB_ICONEXCLAMATION);
        delete [] ptzTitle;
        delete [] ptzMsg;
    }
    else if (HRESULT_CODE(hr) == ERROR_DS_NO_SUCH_OBJECT && fAdd)
    {
      // Put a useful message up
      PTSTR ptzTitle = 0, ptzMsg = 0;
      if (!LoadStringToTchar(IDS_MSG_USER_NOT_PRESENT, &ptzMsg))
      {
        goto FatalError;
      }
      if (!LoadStringToTchar(IDS_MSG_TITLE, &ptzTitle))
      {
        goto FatalError;
      }
      MessageBox(hPage, ptzMsg, ptzTitle, MB_OK | MB_ICONEXCLAMATION);
      delete[] ptzTitle;
      delete[] ptzMsg;
    }
    else if (HRESULT_CODE(dwErr) == ERROR_DS_NO_ATTRIBUTE_OR_VALUE && !fAdd)
    {
      // No message needed
      return FALSE;
    }
    else if (HRESULT_CODE(dwErr) == ERROR_MEMBER_NOT_IN_ALIAS && !fAdd)
    {
      // Put a useful message up
      bool bShowGenericMessage = true;
      if (pwzDN)
      {
        //
        // Crack the DN into the name
        //
        CComPtr<IADsPathname> spPathcracker;
        hr = CoCreateInstance(CLSID_Pathname, 
                              NULL, 
                              CLSCTX_INPROC_SERVER,
                              IID_IADsPathname, 
                              (PVOID *)&spPathcracker);
        if (SUCCEEDED(hr))
        {
          hr = spPathcracker->Set(CComBSTR(pwzDN), ADS_SETTYPE_DN);
          if (SUCCEEDED(hr))
          {
            hr = spPathcracker->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
            if (SUCCEEDED(hr))
            {
              CComBSTR sbstrName;
              hr = spPathcracker->Retrieve(ADS_FORMAT_LEAF, &sbstrName);
              if (SUCCEEDED(hr))
              {
                ErrMsgParam(IDS_MSG_MEMBER_ALREADY_GONE, (LPARAM)(PWSTR)sbstrName, hPage);
                bShowGenericMessage = false;
              }
            }
          }
        }
      }

      if (bShowGenericMessage)
      {
        PTSTR ptzTitle = 0, ptzMsg = 0;
        if (!LoadStringToTchar(IDS_MSG_MEMBER_ALREADY_GONE2, &ptzMsg))
        {
          goto FatalError;
        }
        if (!LoadStringToTchar(IDS_MSG_TITLE, &ptzTitle))
        {
          goto FatalError;
        }
        MessageBox(hPage, ptzMsg, ptzTitle, MB_OK | MB_ICONEXCLAMATION);
        delete[] ptzTitle;
        delete[] ptzMsg;
      }
    }
    else
    {
        if (dwErr)
        {
            dspDebugOut((DEB_ERROR, 
                         "Extended Error 0x%x: %ws %ws.\n", dwErr,
                         wszErrBuf, wszNameBuf));
            ReportError(dwErr, IDS_ADS_ERROR_FORMAT, hPage);
        }
        else
        {
            dspDebugOut((DEB_ERROR, "Error %08lx\n", hr));
            ReportError(hr, IDS_ADS_ERROR_FORMAT, hPage);
        }
    }
    return FALSE;

FatalError:
    MessageBoxA(hPage, "A Fatal Error has occured!", "Active Directory Service",
                MB_OK | MB_ICONEXCLAMATION);

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:   FindFPO
//
//  Synopsis:   Given a SID, look for a corresponding FPO.
//
//-----------------------------------------------------------------------------
HRESULT
FindFPO(PSID pSid, PWSTR pwzDomain, CStrW & strFPODN)
{
    HRESULT hr;
    CDSSearch Srch;

    hr = Srch.Init(pwzDomain);

    CHECK_HRESULT(hr, return hr);

    PWSTR rgpwzAttrNames[] = {g_wzDN};

    hr = Srch.SetAttributeList(rgpwzAttrNames, 1);

    CHECK_HRESULT(hr, return hr);

    Srch.SetSearchScope(ADS_SCOPE_SUBTREE);

    WCHAR wzSearchFormat[] = L"(&(objectCategory=foreignSecurityPrincipal)(objectSid=%s))";
    PWSTR pwzSID;
    CStrW strSearchFilter;

    hr = ADsEncodeBinaryData((PBYTE)pSid,
                             GetLengthSid(pSid),
                             &pwzSID);

    CHECK_HRESULT(hr, return hr);

    strSearchFilter.Format(wzSearchFormat, pwzSID);

    FreeADsMem(pwzSID);

    Srch.SetFilterString(const_cast<LPWSTR>((LPCWSTR)strSearchFilter));

    hr = Srch.DoQuery();

    CHECK_HRESULT(hr, return hr);

    hr = Srch.GetNextRow();

    if (hr == S_ADS_NOMORE_ROWS)
    {
        // No object has a matching SID, the FPO must have been deleted.
        //
        return HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND);
    }
    CHECK_HRESULT(hr, return hr);
    ADS_SEARCH_COLUMN Column;

    hr = Srch.GetColumn(g_wzDN, &Column);

    CHECK_HRESULT(hr, return hr);

    strFPODN = Column.pADsValues->CaseIgnoreString;

    if (strFPODN.IsEmpty())
    {
        Srch.FreeColumn(&Column);
        return E_OUTOFMEMORY;
    }

    Srch.FreeColumn(&Column);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Class:      CMemberDomainMode
//
//  Purpose:    Maintains a list of all domains in the enterprise from which
//              members have been added along with those domains' mode. Keeps
//              a second list of members who have been added from mixed-mode
//              domains.
//
//-----------------------------------------------------------------------------

void
CMemberDomainMode::Init(CDsPropPageBase * pPage)
{
    m_pPage = pPage;

    m_MemberList.Clear();
}

HRESULT
CMemberDomainMode::CheckMember(PWSTR pwzMemberDN)
{
    HRESULT hr;
    CComBSTR cbstrDomain;
    BOOL fMixed = FALSE;

    hr = GetObjectsDomain(m_pPage, pwzMemberDN, &cbstrDomain);

    if (SUCCEEDED(hr) && cbstrDomain)
    {
      if (!m_DomainList.Find(cbstrDomain, &fMixed))
      {
          // The member's domain is not already in the list. Read the domain
          // mode and then add it.
          //
          hr = GetDomainMode(cbstrDomain, m_pPage->GetHWnd(), &fMixed);

          CHECK_HRESULT(hr, return hr);

          hr = m_DomainList.Insert(cbstrDomain, fMixed);

          CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return hr);
      }
    }

    if (fMixed)
    {
        PWSTR pwzCanEx;
        PTSTR ptzCanEx;
        CStr strName;

        hr = CrackName(pwzMemberDN, &pwzCanEx, GET_OBJ_CAN_NAME_EX, m_pPage->GetHWnd());

        CHECK_HRESULT(hr, return hr);

        if (!UnicodeToTchar(pwzCanEx, &ptzCanEx))
        {
            LocalFreeStringW(&pwzCanEx);
            REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
            return E_OUTOFMEMORY;
        }
        LocalFreeStringW(&pwzCanEx);

        CStr cstrFolder;

        GetNameParts(ptzCanEx, cstrFolder, strName);

        DO_DEL(ptzCanEx);

        hr = m_MemberList.Insert(strName);

        CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return hr);
    }

    return S_OK;
}

HRESULT
CMemberDomainMode::ListExternalMembers(CStr & strList)
{
    m_MemberList.GetList(strList);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  CMemberDomainMode helper classes
//
//-----------------------------------------------------------------------------

HRESULT
CMMMemberList::Insert(LPCTSTR ptzName)
{
    CMMMemberListItem * pItem = new CMMMemberListItem;

    if (!pItem)
    {
        return E_OUTOFMEMORY;
    }

    pItem->m_strName = ptzName;

    if (m_pListHead == NULL)
    {
        m_pListHead = pItem;
    }
    else
    {
        pItem->LinkAfter(m_pListHead);
    }
    return S_OK;
}

#define MAX_MMMLISTING  25

void
CMMMemberList::GetList(CStr & strList)
{
    int nCount = 0;

    strList.Empty();

    CMMMemberListItem * pItem = m_pListHead;

    while (pItem)
    {
        strList += pItem->m_strName;

        nCount++;

        pItem = pItem->Next();
        if (pItem)
        {
            if (nCount > MAX_MMMLISTING)
            {
                strList += TEXT("...");
                return;
            }
            else
            {
                strList += TEXT(", ");
            }
        }
    }
}

void
CMMMemberList::Clear(void)
{
    CMMMemberListItem * pItem = m_pListHead, * pNext;

    while (pItem)
    {
        pNext = pItem->Next();
        delete pItem;
        pItem = pNext;
    }

    m_pListHead = NULL;
}

CDomainModeList::~CDomainModeList(void)
{
    CDomainModeListItem * pItem = m_pListHead, * pNext;

    while (pItem)
    {
        pNext = pItem->Next();
        delete pItem;
        pItem = pNext;
    }
}

HRESULT
CDomainModeList::Insert(PWSTR pwzDomain, BOOL fMixed)
{
    CDomainModeListItem * pItem = new CDomainModeListItem;

    if (!pItem)
    {
        return E_OUTOFMEMORY;
    }

    pItem->m_strName = pwzDomain;
    pItem->m_fMixed = fMixed;

    if (m_pListHead == NULL)
    {
        m_pListHead = pItem;
    }
    else
    {
        pItem->LinkAfter(m_pListHead);
    }
    return S_OK;
}

BOOL
CDomainModeList::Find(LPCWSTR pwzDomain, PBOOL pfMixed)
{
    CDomainModeListItem * pItem = m_pListHead;

    while (pItem)
    {
        if (_wcsicmp(pwzDomain, pItem->m_strName) == 0)
        {
            *pfMixed = pItem->m_fMixed;
            return TRUE;
        }
        pItem = pItem->Next();
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\cstr.cpp ===
// This is copied from the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation, 1992 - 1999
// All rights reserved.
//
// This has been modified from the original MFC version to provide
// two classes: CStrW manipulates and stores only wide char strings,
// and CStr uses TCHARs.
// 

#include "pch.h"
#include "proppage.h"
#if !defined(UNICODE)
#include <stdio.h>
#endif
#include "cstr.h"

#if !defined(_wcsinc)
#define _wcsinc(_pc) ((_pc)+1)
#endif

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// For an empty string, m_???Data will point here
// (note: avoids a lot of NULL pointer tests when we call standard
//  C runtime libraries
TCHAR strChNilT = '\0';

// for creating empty key strings
const CStr strEmptyStringT;

void CStr::Init()
{
        m_nDataLength = m_nAllocLength = 0;
        m_pchData = (LPTSTR)&strChNilT;
}

// declared static
void CStr::SafeDelete(LPTSTR& lpch)
{
        if (lpch != (LPTSTR)&strChNilT &&
            lpch)
        {
                delete[] lpch;
                lpch = 0;
        }
}

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CStr::CStr()
{
        Init();
}

CStr::CStr(const CStr& stringSrc)
{
        // if constructing a String from another String, we make a copy of the
        // original string data to enforce value semantics (i.e. each string
        // gets a copy of its own

        m_pchData = 0;

        stringSrc.AllocCopy(*this, stringSrc.m_nDataLength, 0, 0);
}

BOOL CStr::AllocBuffer(int nLen)
 // always allocate one extra character for '\0' termination
 // assumes [optimistically] that data length will equal allocation length
{
        dspAssert(nLen >= 0);

        if (nLen == 0)
        {
                Init();
        }
        else
        {
                m_pchData = new TCHAR[nLen+1];       //REVIEW may throw an exception
        if (!m_pchData)
        {
            Empty();
            return FALSE;
        }
                m_pchData[nLen] = '\0';
                m_nDataLength = nLen;
                m_nAllocLength = nLen;
        }
    return TRUE;
}

void CStr::Empty()
{
        SafeDelete(m_pchData);
        Init();
        dspAssert(m_nDataLength == 0);
        dspAssert(m_nAllocLength == 0);
}

CStr::~CStr()
 //  free any attached data
{
        SafeDelete(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

static inline int SafeStrlenT(LPCTSTR lpsz)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        return (lpsz == NULL) ? 0 : lstrlen(lpsz);
}

void CStr::AllocCopy(CStr& dest, int nCopyLen, int nCopyIndex,
         int nExtraLen) const
{
        // will clone the data attached to this string
        // allocating 'nExtraLen' characters
        // Places results in uninitialized string 'dest'
        // Will copy the part or all of original data to start of new string

        int nNewLen = nCopyLen + nExtraLen;

        if (nNewLen == 0)
        {
        dest.SafeDelete(dest.m_pchData);
                dest.Init();
        }
        else
        {
                if (!dest.AllocBuffer(nNewLen)) return;
            memcpy(dest.m_pchData, &m_pchData[nCopyIndex], nCopyLen*sizeof(TCHAR));
        }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStr::CStr(LPCTSTR lpsz)
{
                int nLen;
                if ((nLen = SafeStrlenT(lpsz)) == 0)
                        Init();
                else
                {
                        if (!AllocBuffer(nLen))
            {
                Init();
                return;
            }
                    memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
                }
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef UNICODE
CStr::CStr(LPCSTR lpsz)
{
        int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
        if (nSrcLen == 0)
                Init();
        else
        {
                if (!AllocBuffer(nSrcLen))
        {
            Init();
            return;
        }
            mmc_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        }
}
#else //UNICODE
CStr::CStr(LPCWSTR lpsz)
{
        int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
        if (nSrcLen == 0)
                Init();
        else
        {
                if (!AllocBuffer(nSrcLen*2))
        {
            Init();
            return;
        }
            mmc_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
                ReleaseBuffer();
        }
}
#endif //!UNICODE


//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CStr&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CStr::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
        // check if it will fit
        if (nSrcLen > m_nAllocLength)
        {
                // it won't fit, allocate another one
                Empty();
                if (!AllocBuffer(nSrcLen)) return;
        }
        if (nSrcLen != 0)
                memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
        m_nDataLength = nSrcLen;
        m_pchData[nSrcLen] = '\0';
}

const CStr& CStr::operator=(const CStr& stringSrc)
{
        AssignCopy(stringSrc.m_nDataLength, stringSrc.m_pchData);
        return *this;
}

const CStr& CStr::operator=(LPCTSTR lpsz)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        AssignCopy(SafeStrlenT(lpsz), lpsz);
        return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef UNICODE
const CStr& CStr::operator=(LPCSTR lpsz)
{
        int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
        // check if it will fit
        if (nSrcLen > m_nAllocLength)
        {
                // it won't fit, allocate another one
                Empty();
                if (!AllocBuffer(nSrcLen)) return *this;
        }
        if (nSrcLen != 0)
                mmc_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        m_nDataLength = nSrcLen;
        m_pchData[nSrcLen] = '\0';
        return *this;
}
#else //!UNICODE
const CStr& CStr::operator=(LPCWSTR lpsz)
{
        int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
        nSrcLen *= 2;
        // check if it will fit
        if (nSrcLen > m_nAllocLength)
        {
                // it won't fit, allocate another one
                Empty();
                if (!AllocBuffer(nSrcLen)) return *this;
        }
        if (nSrcLen != 0)
        {
                mmc_wcstombsz(m_pchData, lpsz, nSrcLen+1);
                ReleaseBuffer();
        }
        return *this;
}
#endif  //!UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          String + String
// and for ? = TCHAR, LPCTSTR
//          String + ?
//          ? + String

void CStr::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
        int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new String object

        int nNewLen = nSrc1Len + nSrc2Len;
        if (!AllocBuffer(nNewLen)) return;
        memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
        memcpy(&m_pchData[nSrc1Len], lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
}

CStr STRAPI operator+(const CStr& string1, const CStr& string2)
{
        CStr s;
        s.ConcatCopy(string1.m_nDataLength, string1.m_pchData,
                string2.m_nDataLength, string2.m_pchData);
        return s;
}

CStr STRAPI operator+(const CStr& string, LPCTSTR lpsz)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        CStr s;
        s.ConcatCopy(string.m_nDataLength, string.m_pchData, SafeStrlenT(lpsz), lpsz);
        return s;
}

CStr STRAPI operator+(LPCTSTR lpsz, const CStr& string)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        CStr s;
        s.ConcatCopy(SafeStrlenT(lpsz), lpsz, string.m_nDataLength, string.m_pchData);
        return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CStr::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
        //  -- the main routine for += operators

        // if the buffer is too small, or we have a width mis-match, just
        //   allocate a new buffer (slow but sure)
        if (m_nDataLength + nSrcLen > m_nAllocLength)
        {
                // we have to grow the buffer, use the Concat in place routine
                LPTSTR lpszOldData = m_pchData;
                ConcatCopy(m_nDataLength, lpszOldData, nSrcLen, lpszSrcData);
                dspAssert(lpszOldData != NULL);
                SafeDelete(lpszOldData);
        }
        else
        {
                // fast concatenation when buffer big enough
                memcpy(&m_pchData[m_nDataLength], lpszSrcData, nSrcLen*sizeof(TCHAR));
                m_nDataLength += nSrcLen;
        }
        dspAssert(m_nDataLength <= m_nAllocLength);
        m_pchData[m_nDataLength] = '\0';
}

const CStr& CStr::operator+=(LPCTSTR lpsz)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        ConcatInPlace(SafeStrlenT(lpsz), lpsz);
        return *this;
}

const CStr& CStr::operator+=(TCHAR ch)
{
        ConcatInPlace(1, &ch);
        return *this;
}

const CStr& CStr::operator+=(const CStr& string)
{
        ConcatInPlace(string.m_nDataLength, string.m_pchData);
        return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CStr::GetBuffer(int nMinBufLength)
{
        dspAssert(nMinBufLength >= 0);

        if (nMinBufLength > m_nAllocLength)
        {
                // we have to grow the buffer
                LPTSTR lpszOldData = m_pchData;
                int nOldLen = m_nDataLength;        // AllocBuffer will tromp it

                if (!AllocBuffer(nMinBufLength)) return NULL;
                memcpy(m_pchData, lpszOldData, nOldLen*sizeof(TCHAR));
                m_nDataLength = nOldLen;
                m_pchData[m_nDataLength] = '\0';

                SafeDelete(lpszOldData);
        }

        // return a pointer to the character storage for this string
        dspAssert(m_pchData != NULL);
        return m_pchData;
}

void CStr::ReleaseBuffer(int nNewLength)
{
        if (nNewLength == -1)
                nNewLength = lstrlen(m_pchData); // zero terminated

        dspAssert(nNewLength <= m_nAllocLength);
        m_nDataLength = nNewLength;
        m_pchData[m_nDataLength] = '\0';
}

LPTSTR CStr::GetBufferSetLength(int nNewLength)
{
        dspAssert(nNewLength >= 0);

        GetBuffer(nNewLength);
        m_nDataLength = nNewLength;
        m_pchData[m_nDataLength] = '\0';
        return m_pchData;
}

void CStr::FreeExtra()
{
        dspAssert(m_nDataLength <= m_nAllocLength);
        if (m_nDataLength != m_nAllocLength)
        {
                LPTSTR lpszOldData = m_pchData;
                if (!AllocBuffer(m_nDataLength)) return;
                memcpy(m_pchData, lpszOldData, m_nDataLength*sizeof(TCHAR));
                dspAssert(m_pchData[m_nDataLength] == '\0');
                SafeDelete(lpszOldData);
        }
        dspAssert(m_pchData != NULL);
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CStr::Find(TCHAR ch) const
{
        // find first single character
        LPTSTR lpsz = _tcschr(m_pchData, ch);

        // return -1 if not found and index otherwise
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CStr::FindOneOf(LPCTSTR lpszCharSet) const
{
        dspAssert(IsValidString(lpszCharSet, FALSE));
        LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

///////////////////////////////////////////////////////////////////////////////
// String conversion helpers (these use the current system locale)

int mmc_wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
        if (count == 0 && mbstr != NULL)
                return 0;

        int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
                mbstr, static_cast<int>(count), NULL, NULL);
        dspAssert(mbstr == NULL || result <= (int)count);
        if (result > 0)
                mbstr[result-1] = 0;
        return result;
}

int mmc_mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
        if (count == 0 && wcstr != NULL)
                return 0;

        int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
                wcstr, static_cast<int>(count));
        dspAssert(wcstr == NULL || result <= (int)count);
        if (result > 0)
                wcstr[result-1] = 0;
        return result;
}


/////////////////////////////////////////////////////////////////////////////
// Windows extensions to strings

BOOL CStr::LoadString(HINSTANCE hInst, UINT nID)
{
        dspAssert(nID != 0);       // 0 is an illegal string ID

        // Note: resource strings limited to 511 characters
        TCHAR szBuffer[512];
        UINT nSize = StrLoadString(hInst, nID, szBuffer);
        AssignCopy(nSize, szBuffer);
        return nSize > 0;
}


int STRAPI StrLoadString(HINSTANCE hInst, UINT nID, LPTSTR lpszBuf)
{
        dspAssert(IsValidAddressz(lpszBuf, 512));  // must be big enough for 512 bytes
#ifdef DBG
        // LoadString without annoying warning from the Debug kernel if the
        //  segment containing the string is not present
        if (::FindResource(hInst, MAKEINTRESOURCE((nID>>4)+1), RT_STRING) == NULL)
        {
                lpszBuf[0] = '\0';
                return 0; // not found
        }
#endif //DBG
        int nLen = ::LoadString(hInst, nID, lpszBuf, 511);
    dspAssert(nLen);
        if (nLen == 0)
                lpszBuf[0] = '\0';
        return nLen;
}

BOOL STRAPI IsValidAddressz(const void* lp, UINT nBytes, BOOL bReadWrite)
{
        // simple version using Win-32 APIs for pointer validation.
        return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
                (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}


BOOL STRAPI IsValidString(LPCSTR lpsz, int nLength)
{
        if (lpsz == NULL)
                return FALSE;
        return ::IsBadStringPtrA(lpsz, nLength) == 0;
}

BOOL STRAPI IsValidString(LPCWSTR lpsz, int nLength)
{
        if (lpsz == NULL)
                return FALSE;

        return ::IsBadStringPtrW(lpsz, nLength) == 0;
}


#ifdef OLE_AUTOMATION
#ifdef  UNICODE
BSTR CStr::AllocSysString()
{
        BSTR bstr = ::SysAllocStringLen(m_pchData, m_nDataLength);
        if (bstr == NULL)
                ;//REVIEW AfxThrowMemoryException();

        return bstr;
}

BSTR CStr::SetSysString(BSTR* pbstr)
{
        dspAssert(IsValidAddressz(pbstr, sizeof(BSTR)));

        if (!::SysReAllocStringLen(pbstr, m_pchData, m_nDataLength))
                ; //REVIEW AfxThrowMemoryException();

        dspAssert(*pbstr != NULL);
        return *pbstr;
}
#endif
#endif // #ifdef OLE_AUTOMATION


///////////////////////////////////////////////////////////////////////////////
// Orginally from StrEx.cpp 


CStr::CStr(TCHAR ch, int nLength)
{
#ifndef UNICODE
        dspAssert(!IsDBCSLeadByte(ch));    // can't create a lead byte string
#endif
        if (nLength < 1)
        {
                // return empty string if invalid repeat count
                Init();
        }
        else
        {
                if (!AllocBuffer(nLength))
        {
            Init();
            return;
        }
#ifdef UNICODE
                for (int i = 0; i < nLength; i++)
                        m_pchData[i] = ch;
#else
                memset(m_pchData, ch, nLength);
#endif
        }
}

CStr::CStr(LPCTSTR lpch, int nLength)
{
        if (nLength == 0)
                Init();
        else
        {
                dspAssert(IsValidAddressz(lpch, nLength, FALSE));
                if (!AllocBuffer(nLength))
        {
            Init();
            return;
        }
            memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
        }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CStr& CStr::operator=(TCHAR ch)
{
#ifndef UNICODE
        dspAssert(!IsDBCSLeadByte(ch));    // can't set single lead byte
#endif
        AssignCopy(1, &ch);
        return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CStr STRAPI operator+(const CStr& string1, TCHAR ch)
{
        CStr s;
        s.ConcatCopy(string1.m_nDataLength, string1.m_pchData, 1, &ch);
        return s;
}

CStr STRAPI operator+(TCHAR ch, const CStr& string)
{
        CStr s;
        s.ConcatCopy(1, &ch, string.m_nDataLength, string.m_pchData);
        return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CStr CStr::Mid(int nFirst) const
{
        return Mid(nFirst, m_nDataLength - nFirst);
}

CStr CStr::Mid(int nFirst, int nCount) const
{
        dspAssert(nFirst >= 0);
        dspAssert(nCount >= 0);

        // out-of-bounds requests return sensible things
        if (nFirst + nCount > m_nDataLength)
                nCount = m_nDataLength - nFirst;
        if (nFirst > m_nDataLength)
                nCount = 0;

        CStr dest;
        AllocCopy(dest, nCount, nFirst, 0);
        return dest;
}

CStr CStr::Right(int nCount) const
{
        dspAssert(nCount >= 0);

        if (nCount > m_nDataLength)
                nCount = m_nDataLength;

        CStr dest;
        AllocCopy(dest, nCount, m_nDataLength-nCount, 0);
        return dest;
}

CStr CStr::Left(int nCount) const
{
        dspAssert(nCount >= 0);

        if (nCount > m_nDataLength)
                nCount = m_nDataLength;

        CStr dest;
        AllocCopy(dest, nCount, 0, 0);
        return dest;
}

// strspn equivalent
CStr CStr::SpanIncluding(LPCTSTR lpszCharSet) const
{
        dspAssert(IsValidString(lpszCharSet, FALSE));
        return Left(static_cast<int>(_tcsspn(m_pchData, lpszCharSet)));
}

// strcspn equivalent
CStr CStr::SpanExcluding(LPCTSTR lpszCharSet) const
{
        dspAssert(IsValidString(lpszCharSet, FALSE));
        return Left(static_cast<int>(_tcscspn(m_pchData, lpszCharSet)));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CStr::ReverseFind(TCHAR ch) const
{
        // find last single character
        LPTSTR lpsz = _tcsrchr(m_pchData, ch);

        // return -1 if not found, distance from beginning otherwise
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CStr::Find(LPCTSTR lpszSub) const
{
        dspAssert(IsValidString(lpszSub, FALSE));

        // find first matching substring
        LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

        // return -1 for not found, distance from beginning otherwise
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// String formatting

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

// formatting (using wsprintf style formatting)
void CStr::Format(LPCTSTR lpszFormat, ...)
{
        dspAssert(IsValidString(lpszFormat, FALSE));

        va_list argList;
        va_start(argList, lpszFormat);

        // make a guess at the maximum length of the resulting string
        size_t nMaxLen = 0;
        for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
        {
                // handle '%' character, but watch out for '%%'
                if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
                {
                        nMaxLen += _tclen(lpsz);
                        continue;
                }

                size_t nItemLen = 0;

                // handle '%' character with format
                int nWidth = 0;
                for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
                {
                        // check for valid flags
                        if (*lpsz == '#')
                                nMaxLen += 2;   // for '0x'
                        else if (*lpsz == '*')
                                nWidth = va_arg(argList, int);
                        else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
                                *lpsz == ' ')
                                ;
                        else // hit non-flag character
                                break;
                }
                // get width and skip it
                if (nWidth == 0)
                {
                        // width indicated by
                        nWidth = _ttoi(lpsz);
                        for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
                                ;
                }
                dspAssert(nWidth >= 0);

                int nPrecision = 0;
                if (*lpsz == '.')
                {
                        // skip past '.' separator (width.precision)
                        lpsz = _tcsinc(lpsz);

                        // get precision and skip it
                        if (*lpsz == '*')
                        {
                                nPrecision = va_arg(argList, int);
                                lpsz = _tcsinc(lpsz);
                        }
                        else
                        {
                                nPrecision = _ttoi(lpsz);
                                for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
                                        ;
                        }
                        dspAssert(nPrecision >= 0);
                }

                // should be on type modifier or specifier
                int nModifier = 0;
                switch (*lpsz)
                {
                // modifiers that affect size
                case 'h':
                        nModifier = FORCE_ANSI;
                        lpsz = _tcsinc(lpsz);
                        break;
                case 'l':
                        nModifier = FORCE_UNICODE;
                        lpsz = _tcsinc(lpsz);
                        break;

                // modifiers that do not affect size
                case 'F':
                case 'N':
                case 'L':
                        lpsz = _tcsinc(lpsz);
                        break;
                }

                // now should be on specifier
                switch (*lpsz | nModifier)
                {
                // single characters
                case 'c':
                case 'C':
                        nItemLen = 2;
                        (void)va_arg(argList, TCHAR);
                        break;
                case 'c'|FORCE_ANSI:
                case 'C'|FORCE_ANSI:
                        nItemLen = 2;
                        (void)va_arg(argList, char);
                        break;
                case 'c'|FORCE_UNICODE:
                case 'C'|FORCE_UNICODE:
                        nItemLen = 2;
                        (void)va_arg(argList, WCHAR);
                        break;

                // strings
                case 's':
                case 'S':
                        nItemLen = lstrlen(va_arg(argList, LPCTSTR));
                        nItemLen = __max(1, nItemLen);
                        break;
                case 's'|FORCE_ANSI:
                case 'S'|FORCE_ANSI:
                        nItemLen = lstrlenA(va_arg(argList, LPCSTR));
                        nItemLen = __max(1, nItemLen);
                        break;
#ifndef _MAC
                case 's'|FORCE_UNICODE:
                case 'S'|FORCE_UNICODE:
                        nItemLen = wcslen(va_arg(argList, LPWSTR));
                        nItemLen = __max(1, nItemLen);
                        break;
#endif
                }

                // adjust nItemLen for strings
                if (nItemLen != 0)
                {
                        nItemLen = __max(nItemLen, static_cast<UINT>(nWidth));
                        if (nPrecision != 0)
                                nItemLen = __min(nItemLen, static_cast<UINT>(nPrecision));
                }
                else
                {
                        switch (*lpsz)
                        {
                        // integers
                        case 'd':
                        case 'i':
                        case 'u':
                        case 'x':
                        case 'X':
                        case 'o':
                                (void)va_arg(argList, int);
                                nItemLen = 32;
                                nItemLen = __max(nItemLen, static_cast<UINT>(nWidth+nPrecision));
                                break;

                        case 'e':
                        case 'f':
                        case 'g':
                        case 'G':
                                (void)va_arg(argList, _STR_DOUBLE);
                                nItemLen = 128;
                                nItemLen = __max(nItemLen, static_cast<UINT>(nWidth+nPrecision));
                                break;

                        case 'p':
                                (void)va_arg(argList, void*);
                                nItemLen = 32;
                                nItemLen = __max(nItemLen, static_cast<UINT>(nWidth+nPrecision));
                                break;

                        // no output
                        case 'n':
                                (void)va_arg(argList, int*);
                                break;

                        default:
                                dspAssert(FALSE);  // unknown formatting option
                        }
                }

                // adjust nMaxLen for output nItemLen
                nMaxLen += nItemLen;
        }
        va_end(argList);

        // finally, set the buffer length and format the string
        va_start(argList, lpszFormat);  // restart the arg list
        GetBuffer(static_cast<int>(nMaxLen));
        if (_vstprintf(m_pchData, lpszFormat, argList) > static_cast<int>(nMaxLen))
        {
                dspAssert(FALSE);
        }
        ReleaseBuffer();
        va_end(argList);
}

void CStr::TrimRight()
{
        // find beginning of trailing spaces by starting at beginning (DBCS aware)
        LPTSTR lpsz = m_pchData;
        LPTSTR lpszLast = NULL;
        while (*lpsz != '\0')
        {
                if (_istspace(*lpsz))
                {
                        if (lpszLast == NULL)
                                lpszLast = lpsz;
                }
                else
                        lpszLast = NULL;
                lpsz = _tcsinc(lpsz);
        }

        if (lpszLast != NULL)
        {
                // truncate at trailing space start
                *lpszLast = '\0';
                m_nDataLength = (int)(lpszLast - m_pchData);
        }
}

void CStr::TrimLeft()
{
        // find first non-space character
        LPCTSTR lpsz = m_pchData;
        while (_istspace(*lpsz))
                lpsz = _tcsinc(lpsz);

        // fix up data and length
        int nDataLength = (int)(m_nDataLength - (lpsz - m_pchData));
        memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
        m_nDataLength = nDataLength;
}

///////////////////////////////////////////////////////////////////////////////
// String support for template collections

void STRAPI ConstructElements(CStr* pElements, int nCount)
{
        dspAssert(IsValidAddressz(pElements, nCount * sizeof(CStr)));

        for (; nCount--; ++pElements)
                memcpy(pElements, &strEmptyStringT, sizeof(*pElements));
}

void STRAPI DestructElements(CStr* pElements, int nCount)
{
        dspAssert(IsValidAddressz(pElements, nCount * sizeof(CStr)));

        for (; nCount--; ++pElements)
                pElements->Empty();
}

//
// Added by JonN 4/16/98
//
void FreeCStrList( IN OUT CStrListItem** ppList )
{
    dspAssert( NULL != ppList );
    while (NULL != *ppList)
    {
        CStrListItem* pTemp = (*ppList)->pnext;
        delete *ppList;
        *ppList = pTemp;
    }
}
void CStrListAdd( IN OUT CStrListItem** ppList, IN LPCTSTR lpsz )
{
        dspAssert( NULL != ppList );
        CStrListItem* pnewitem = new CStrListItem;
  if (pnewitem != NULL)
  {
          pnewitem->str = lpsz;
          pnewitem->pnext = *ppList;
          *ppList = pnewitem;
  }
}
int CountCStrList( IN CStrListItem** ppList )
{
        dspAssert( NULL != ppList );
        int cCount = 0;
        for (CStrListItem* pList = *ppList; NULL != pList; pList = pList->pnext)
        {
                cCount++;
        }
        return cCount;
}

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// For an empty string, m_???Data will point here
// (note: avoids a lot of NULL pointer tests when we call standard
//  C runtime libraries
WCHAR strChNilW = '\0';

// for creating empty key strings
const CStrW strEmptyStringW;

void CStrW::Init()
{
        m_nDataLength = m_nAllocLength = 0;
        m_pchData = (PWSTR)&strChNilW;
}

// declared static
void CStrW::SafeDelete(PWSTR& lpch)
{
        if (lpch != (PWSTR)&strChNilW &&
            lpch)
        {
                delete[] lpch;
                lpch = 0;
        }
}

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CStrW::CStrW()
{
        Init();
}

CStrW::CStrW(const CStrW& stringSrc)
{
        // if constructing a String from another String, we make a copy of the
        // original string data to enforce value semantics (i.e. each string
        // gets a copy of its own

        stringSrc.AllocCopy(*this, stringSrc.m_nDataLength, 0, 0);
}

BOOL CStrW::AllocBuffer(int nLen)
 // always allocate one extra character for '\0' termination
 // assumes [optimistically] that data length will equal allocation length
{
        dspAssert(nLen >= 0);

        if (nLen == 0)
        {
        Empty();
        }
        else
        {
                m_pchData = new WCHAR[nLen+1];       //REVIEW may throw an exception
        if (!m_pchData)
        {
            Empty();
            return FALSE;
        }
                m_pchData[nLen] = '\0';
                m_nDataLength = nLen;
                m_nAllocLength = nLen;
        }
    return TRUE;
}

void CStrW::Empty()
{
        SafeDelete(m_pchData);
        Init();
        dspAssert(m_nDataLength == 0);
        dspAssert(m_nAllocLength == 0);
}

CStrW::~CStrW()
 //  free any attached data
{
        SafeDelete(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

static inline int SafeStrlen(LPCWSTR lpsz)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        return (int)((lpsz == NULL) ? 0 : wcslen(lpsz));
}

void CStrW::AllocCopy(CStrW& dest, int nCopyLen, int nCopyIndex,
         int nExtraLen) const
{
        // will clone the data attached to this string
        // allocating 'nExtraLen' characters
        // Places results in uninitialized string 'dest'
        // Will copy the part or all of original data to start of new string

        int nNewLen = nCopyLen + nExtraLen;

        if (nNewLen == 0)
        {
                dest.Empty();
        }
        else
        {
                if (!dest.AllocBuffer(nNewLen)) return;
            memcpy(dest.m_pchData, &m_pchData[nCopyIndex], nCopyLen*sizeof(WCHAR));
        }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStrW::CStrW(LPCWSTR lpsz)
{
                int nLen;
                if ((nLen = SafeStrlen(lpsz)) == 0)
                        Init();
                else
                {
                        if (!AllocBuffer(nLen))
            {
                Init();
                return;
            }
                    memcpy(m_pchData, lpsz, nLen*sizeof(WCHAR));
                }
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

CStrW::CStrW(LPCSTR lpsz)
{
        int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
        if (nSrcLen == 0)
                Init();
        else
        {
                if (!AllocBuffer(nSrcLen))
        {
            Init();
            return;
        }
            mmc_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        }
}


//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CStrW&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CStrW::AssignCopy(int nSrcLen, LPCWSTR lpszSrcData)
{
        // NOTICE-2002/03/07-ericb: SecurityPush: check input param.
        if (!lpszSrcData)
        {
           nSrcLen = 0;
        }
        // check if it will fit
        if (nSrcLen > m_nAllocLength)
        {
                // it won't fit, allocate another one
                Empty();
                if (!AllocBuffer(nSrcLen)) return;
        }
        if (nSrcLen != 0)
                memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(WCHAR));
        m_nDataLength = nSrcLen;
        m_pchData[nSrcLen] = '\0';
}

const CStrW& CStrW::operator=(const CStrW& stringSrc)
{
        AssignCopy(stringSrc.m_nDataLength, stringSrc.m_pchData);
        return *this;
}

const CStrW& CStrW::operator=(LPCWSTR lpsz)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        AssignCopy(SafeStrlen(lpsz), lpsz);
        return *this;
}

const CStrW& CStrW::operator=(UNICODE_STRING unistr)
{
   AssignCopy(unistr.Length/2, unistr.Buffer);
   return *this;
}

const CStrW& CStrW::operator=(UNICODE_STRING * punistr)
{
   AssignCopy(punistr->Length/2, punistr->Buffer);
   return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

const CStrW& CStrW::operator=(LPCSTR lpsz)
{
        int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
        // check if it will fit
        if (nSrcLen > m_nAllocLength)
        {
                // it won't fit, allocate another one
                Empty();
                if (!AllocBuffer(nSrcLen)) return *this;
        }
        if (nSrcLen != 0)
                mmc_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        m_nDataLength = nSrcLen;
        m_pchData[nSrcLen] = '\0';
        return *this;
}

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          String + String
// and for ? = WCHAR, LPCWSTR
//          String + ?
//          ? + String

void CStrW::ConcatCopy(int nSrc1Len, LPCWSTR lpszSrc1Data,
        int nSrc2Len, LPCWSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new String object

        int nNewLen = nSrc1Len + nSrc2Len;
        if (!AllocBuffer(nNewLen)) return;
        memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(WCHAR));
        memcpy(&m_pchData[nSrc1Len], lpszSrc2Data, nSrc2Len*sizeof(WCHAR));
}

CStrW STRAPI operator+(const CStrW& string1, const CStrW& string2)
{
        CStrW s;
        s.ConcatCopy(string1.m_nDataLength, string1.m_pchData,
                string2.m_nDataLength, string2.m_pchData);
        return s;
}

CStrW STRAPI operator+(const CStrW& string, LPCWSTR lpsz)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        CStrW s;
        s.ConcatCopy(string.m_nDataLength, string.m_pchData, SafeStrlen(lpsz), lpsz);
        return s;
}

CStrW STRAPI operator+(LPCWSTR lpsz, const CStrW& string)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        CStrW s;
        s.ConcatCopy(SafeStrlen(lpsz), lpsz, string.m_nDataLength, string.m_pchData);
        return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CStrW::ConcatInPlace(int nSrcLen, LPCWSTR lpszSrcData)
{
        //  -- the main routine for += operators

        // if the buffer is too small, or we have a width mis-match, just
        //   allocate a new buffer (slow but sure)
        if (m_nDataLength + nSrcLen > m_nAllocLength)
        {
                // we have to grow the buffer, use the Concat in place routine
                PWSTR lpszOldData = m_pchData;
                ConcatCopy(m_nDataLength, lpszOldData, nSrcLen, lpszSrcData);
                dspAssert(lpszOldData != NULL);
                SafeDelete(lpszOldData);
        }
        else
        {
                // fast concatenation when buffer big enough
                memcpy(&m_pchData[m_nDataLength], lpszSrcData, nSrcLen*sizeof(WCHAR));
                m_nDataLength += nSrcLen;
        }
        dspAssert(m_nDataLength <= m_nAllocLength);
        m_pchData[m_nDataLength] = '\0';
}

const CStrW& CStrW::operator+=(LPCWSTR lpsz)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        ConcatInPlace(SafeStrlen(lpsz), lpsz);
        return *this;
}

const CStrW& CStrW::operator+=(WCHAR ch)
{
        ConcatInPlace(1, &ch);
        return *this;
}

const CStrW& CStrW::operator+=(const CStrW& string)
{
        ConcatInPlace(string.m_nDataLength, string.m_pchData);
        return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

PWSTR CStrW::GetBuffer(int nMinBufLength)
{
        dspAssert(nMinBufLength >= 0);

        if (nMinBufLength > m_nAllocLength)
        {
                // we have to grow the buffer
                PWSTR lpszOldData = m_pchData;
                int nOldLen = m_nDataLength;        // AllocBuffer will tromp it

                if (!AllocBuffer(nMinBufLength)) return NULL;
                memcpy(m_pchData, lpszOldData, nOldLen*sizeof(WCHAR));
                m_nDataLength = nOldLen;
                m_pchData[m_nDataLength] = '\0';

                SafeDelete(lpszOldData);
        }

        // return a pointer to the character storage for this string
        dspAssert(m_pchData != NULL);
        return m_pchData;
}

void CStrW::ReleaseBuffer(int nNewLength)
{
        if (nNewLength == -1)
                nNewLength = static_cast<int>(wcslen(m_pchData)); // zero terminated

        dspAssert(nNewLength <= m_nAllocLength);
        m_nDataLength = nNewLength;
        m_pchData[m_nDataLength] = '\0';
}

PWSTR CStrW::GetBufferSetLength(int nNewLength)
{
        dspAssert(nNewLength >= 0);

        GetBuffer(nNewLength);
        m_nDataLength = nNewLength;
        m_pchData[m_nDataLength] = '\0';
        return m_pchData;
}

void CStrW::FreeExtra()
{
        dspAssert(m_nDataLength <= m_nAllocLength);
        if (m_nDataLength != m_nAllocLength)
        {
                PWSTR lpszOldData = m_pchData;
                if (!AllocBuffer(m_nDataLength)) return;
                memcpy(m_pchData, lpszOldData, m_nDataLength*sizeof(WCHAR));
                dspAssert(m_pchData[m_nDataLength] == '\0');
                SafeDelete(lpszOldData);
        }
        dspAssert(m_pchData != NULL);
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CStrW::Find(WCHAR ch) const
{
        // find first single character
        PWSTR lpsz = wcschr(m_pchData, ch);

        // return -1 if not found and index otherwise
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CStrW::FindOneOf(LPCWSTR lpszCharSet) const
{
        dspAssert(IsValidString(lpszCharSet, FALSE));
        PWSTR lpsz = wcspbrk(m_pchData, lpszCharSet);
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}


/////////////////////////////////////////////////////////////////////////////
// Windows extensions to strings

BOOL CStrW::LoadString(HINSTANCE hInst, UINT nID)
{
        dspAssert(nID != 0);       // 0 is an illegal string ID

        // Note: resource strings limited to 511 characters
        WCHAR szBuffer[512];
        UINT nSize = StrLoadStringW(hInst, nID, szBuffer);
        AssignCopy(nSize, szBuffer);
        return nSize > 0;
}

int STRAPI StrLoadStringW(HINSTANCE hInst, UINT nID, LPWSTR lpszBuf)
{
        dspAssert(IsValidAddressz(lpszBuf, 512));  // must be big enough for 512 bytes
#ifdef DBG
        // LoadString without annoying warning from the Debug kernel if the
        //  segment containing the string is not present
        if (::FindResource(hInst, MAKEINTRESOURCE((nID>>4)+1), RT_STRING) == NULL)
        {
                lpszBuf[0] = '\0';
                return 0; // not found
        }
#endif //DBG
        int nLen = ::LoadStringW(hInst, nID, lpszBuf, 511);
    dspAssert(nLen);
        if (nLen == 0)
                lpszBuf[0] = '\0';
        return nLen;
}


#ifdef OLE_AUTOMATION
#ifdef  UNICODE
BSTR CStrW::AllocSysString()
{
        BSTR bstr = ::SysAllocStringLen(m_pchData, m_nDataLength);
        if (bstr == NULL)
                ;//REVIEW AfxThrowMemoryException();

        return bstr;
}

BSTR CStrW::SetSysString(BSTR* pbstr)
{
        dspAssert(IsValidAddressz(pbstr, sizeof(BSTR)));

        if (!::SysReAllocStringLen(pbstr, m_pchData, m_nDataLength))
                ; //REVIEW AfxThrowMemoryException();

        dspAssert(*pbstr != NULL);
        return *pbstr;
}
#endif
#endif // #ifdef OLE_AUTOMATION


///////////////////////////////////////////////////////////////////////////////
// Orginally from StrEx.cpp 


CStrW::CStrW(WCHAR ch, int nLength)
{
        if (nLength < 1)
        {
                // return empty string if invalid repeat count
                Init();
        }
        else
        {
                if (!AllocBuffer(nLength))
        {
            Init();
            return;
        }
#ifdef UNICODE
                for (int i = 0; i < nLength; i++)
                        m_pchData[i] = ch;
#else
                memset(m_pchData, ch, nLength);
#endif
        }
}

CStrW::CStrW(LPCWSTR lpch, int nLength)
{
        if (nLength == 0)
                Init();
        else
        {
                dspAssert(IsValidAddressz(lpch, nLength, FALSE));
                if (!AllocBuffer(nLength))
        {
            Init();
            return;
        }
                memcpy(m_pchData, lpch, nLength*sizeof(WCHAR));
        }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CStrW& CStrW::operator=(WCHAR ch)
{
        AssignCopy(1, &ch);
        return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CStrW STRAPI operator+(const CStrW& string1, WCHAR ch)
{
        CStrW s;
        s.ConcatCopy(string1.m_nDataLength, string1.m_pchData, 1, &ch);
        return s;
}

CStrW STRAPI operator+(WCHAR ch, const CStrW& string)
{
        CStrW s;
        s.ConcatCopy(1, &ch, string.m_nDataLength, string.m_pchData);
        return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CStrW CStrW::Mid(int nFirst) const
{
        return Mid(nFirst, m_nDataLength - nFirst);
}

CStrW CStrW::Mid(int nFirst, int nCount) const
{
        dspAssert(nFirst >= 0);
        dspAssert(nCount >= 0);

        // out-of-bounds requests return sensible things
        if (nFirst + nCount > m_nDataLength)
                nCount = m_nDataLength - nFirst;
        if (nFirst > m_nDataLength)
                nCount = 0;

        CStrW dest;
        AllocCopy(dest, nCount, nFirst, 0);
        return dest;
}

CStrW CStrW::Right(int nCount) const
{
        dspAssert(nCount >= 0);

        if (nCount > m_nDataLength)
                nCount = m_nDataLength;

        CStrW dest;
        AllocCopy(dest, nCount, m_nDataLength-nCount, 0);
        return dest;
}

CStrW CStrW::Left(int nCount) const
{
        dspAssert(nCount >= 0);

        if (nCount > m_nDataLength)
                nCount = m_nDataLength;

        CStrW dest;
        AllocCopy(dest, nCount, 0, 0);
        return dest;
}

// strspn equivalent
CStrW CStrW::SpanIncluding(LPCWSTR lpszCharSet) const
{
        dspAssert(IsValidString(lpszCharSet, FALSE));
        return Left(static_cast<int>(wcsspn(m_pchData, lpszCharSet)));
}

// strcspn equivalent
CStrW CStrW::SpanExcluding(LPCWSTR lpszCharSet) const
{
        dspAssert(IsValidString(lpszCharSet, FALSE));
        return Left(static_cast<int>(wcscspn(m_pchData, lpszCharSet)));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CStrW::ReverseFind(WCHAR ch) const
{
        // find last single character
        PWSTR lpsz = wcsrchr(m_pchData, ch);

        // return -1 if not found, distance from beginning otherwise
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CStrW::Find(LPCWSTR lpszSub) const
{
        dspAssert(IsValidString(lpszSub, FALSE));

        // find first matching substring
        PWSTR lpsz = wcsstr(m_pchData, lpszSub);

        // return -1 for not found, distance from beginning otherwise
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// String formatting

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

// formatting (using wsprintf style formatting)
void CStrW::Format(LPCWSTR lpszFormat, ...)
{
        dspAssert(IsValidString(lpszFormat, FALSE));

        va_list argList;
        va_start(argList, lpszFormat);

        // make a guess at the maximum length of the resulting string
        size_t nMaxLen = 0;
        for (LPCWSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _wcsinc(lpsz))
        {
                // handle '%' character, but watch out for '%%'
                if (*lpsz != '%' || *(lpsz = _wcsinc(lpsz)) == '%')
                {
                        nMaxLen += wcslen(lpsz);
                        continue;
                }

                size_t nItemLen = 0;

                // handle '%' character with format
                int nWidth = 0;
                for (; *lpsz != '\0'; lpsz = _wcsinc(lpsz))
                {
                        // check for valid flags
                        if (*lpsz == '#')
                                nMaxLen += 2;   // for '0x'
                        else if (*lpsz == '*')
                                nWidth = va_arg(argList, int);
                        else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
                                *lpsz == ' ')
                                ;
                        else // hit non-flag character
                                break;
                }
                // get width and skip it
                if (nWidth == 0)
                {
                        // width indicated by
                        nWidth = _wtoi(lpsz);
                        for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _wcsinc(lpsz))
                                ;
                }
                dspAssert(nWidth >= 0);

                int nPrecision = 0;
                if (*lpsz == '.')
                {
                        // skip past '.' separator (width.precision)
                        lpsz = _wcsinc(lpsz);

                        // get precision and skip it
                        if (*lpsz == '*')
                        {
                                nPrecision = va_arg(argList, int);
                                lpsz = _wcsinc(lpsz);
                        }
                        else
                        {
                                nPrecision = _wtoi(lpsz);
                                for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _wcsinc(lpsz))
                                        ;
                        }
                        dspAssert(nPrecision >= 0);
                }

                // should be on type modifier or specifier
                int nModifier = 0;
                switch (*lpsz)
                {
                // modifiers that affect size
                case 'h':
                        nModifier = FORCE_ANSI;
                        lpsz = _wcsinc(lpsz);
                        break;
                case 'l':
                        nModifier = FORCE_UNICODE;
                        lpsz = _wcsinc(lpsz);
                        break;

                // modifiers that do not affect size
                case 'F':
                case 'N':
                case 'L':
                        lpsz = _wcsinc(lpsz);
                        break;
                }

                // now should be on specifier
                switch (*lpsz | nModifier)
                {
                // single characters
                case 'c':
                case 'C':
                        nItemLen = 2;
                        (void)va_arg(argList, WCHAR);
                        break;
                case 'c'|FORCE_ANSI:
                case 'C'|FORCE_ANSI:
                        nItemLen = 2;
                        (void)va_arg(argList, char);
                        break;
                case 'c'|FORCE_UNICODE:
                case 'C'|FORCE_UNICODE:
                        nItemLen = 2;
                        (void)va_arg(argList, WCHAR);
                        break;

                // strings
                case 's':
                case 'S':
                        nItemLen = wcslen(va_arg(argList, LPCWSTR));
                        nItemLen = __max(1, nItemLen);
                        break;
                case 's'|FORCE_ANSI:
                case 'S'|FORCE_ANSI:
                        nItemLen = lstrlenA(va_arg(argList, LPCSTR));
                        nItemLen = __max(1, nItemLen);
                        break;
#ifndef _MAC
                case 's'|FORCE_UNICODE:
                case 'S'|FORCE_UNICODE:
                        nItemLen = wcslen(va_arg(argList, LPWSTR));
                        nItemLen = __max(1, nItemLen);
                        break;
#endif
                }

                // adjust nItemLen for strings
                if (nItemLen != 0)
                {
                        nItemLen = __max(nItemLen, static_cast<UINT>(nWidth));
                        if (nPrecision != 0)
                                nItemLen = __min(nItemLen, static_cast<UINT>(nPrecision));
                }
                else
                {
                        switch (*lpsz)
                        {
                        // integers
                        case 'd':
                        case 'i':
                        case 'u':
                        case 'x':
                        case 'X':
                        case 'o':
                                (void)va_arg(argList, int);
                                nItemLen = 32;
                                nItemLen = __max(nItemLen, static_cast<UINT>(nWidth+nPrecision));
                                break;

                        case 'e':
                        case 'f':
                        case 'g':
                        case 'G':
                                (void)va_arg(argList, _STR_DOUBLE);
                                nItemLen = 128;
                                nItemLen = __max(nItemLen, static_cast<UINT>(nWidth+nPrecision));
                                break;

                        case 'p':
                                (void)va_arg(argList, void*);
                                nItemLen = 32;
                                nItemLen = __max(nItemLen, static_cast<UINT>(nWidth+nPrecision));
                                break;

                        // no output
                        case 'n':
                                (void)va_arg(argList, int*);
                                break;

                        default:
                                dspAssert(FALSE);  // unknown formatting option
                        }
                }

                // adjust nMaxLen for output nItemLen
                nMaxLen += nItemLen;
        }
        va_end(argList);

        // finally, set the buffer length and format the string
        va_start(argList, lpszFormat);  // restart the arg list
        GetBuffer(static_cast<int>(nMaxLen));
        if (vswprintf(m_pchData, lpszFormat, argList) > static_cast<int>(nMaxLen))
        {
                dspAssert(FALSE);
        }
        ReleaseBuffer();
        va_end(argList);
}

// formatting (using FormatMessage style formatting)
void CStrW::FormatMessage(PCWSTR pwzFormat, ...)
{
        dspAssert(IsValidString(pwzFormat, FALSE));

   // format message into temporary buffer pwzTemp
   va_list argList;
   va_start(argList, pwzFormat);
   PWSTR pwzTemp = 0;

   if (::FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
       pwzFormat, 0, 0, (PWSTR)&pwzTemp, 0, &argList) == 0 ||
       pwzTemp == NULL)
   {
      ;//REVIEW AfxThrowMemoryException();
   }

   // assign pwzTemp into the resulting string and free the temporary
   *this = pwzTemp;
   LocalFree(pwzTemp);
   va_end(argList);
}

void CStrW::FormatMessage(HINSTANCE hInst, UINT nFormatID, ...)
{
   // get format string from string table
   CStrW strFormat;
   BOOL fLoaded = strFormat.LoadString(hInst, nFormatID);
   dspAssert(fLoaded);

   // format message into temporary buffer pwzTemp
   va_list argList;
   va_start(argList, nFormatID);
   PWSTR pwzTemp = NULL;
   if (::FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
       strFormat, 0, 0, (PWSTR)&pwzTemp, 0, &argList) == 0 ||
       pwzTemp == NULL)
   {
       ;//REVIEW AfxThrowMemoryException();
   }

   // assign pwzTemp into the resulting string and free pwzTemp
   *this = pwzTemp;
   LocalFree(pwzTemp);
   va_end(argList);
}

void CStrW::TrimRight()
{
        // find beginning of trailing spaces by starting at beginning (DBCS aware)
        PWSTR lpsz = m_pchData;
        PWSTR lpszLast = NULL;
        while (*lpsz != '\0')
        {
                if (_istspace(*lpsz))
                {
                        if (lpszLast == NULL)
                                lpszLast = lpsz;
                }
                else
                        lpszLast = NULL;
                lpsz = _wcsinc(lpsz);
        }

        if (lpszLast != NULL)
        {
                // truncate at trailing space start
                *lpszLast = '\0';
                m_nDataLength = (int)(lpszLast - m_pchData);
        }
}

void CStrW::TrimLeft()
{
        // find first non-space character
        LPCWSTR lpsz = m_pchData;
        while (_istspace(*lpsz))
                lpsz = _wcsinc(lpsz);

        // fix up data and length
        int nDataLength = (int)(m_nDataLength - (lpsz - m_pchData));
        memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(WCHAR));
        m_nDataLength = nDataLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\group.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       group.h
//
//  Contents:   DS object property pages class header
//
//  Classes:    CDsPropPagesHost, CDsPropPagesHostCF, CDsTableDrivenPage
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _GROUP_H_
#define _GROUP_H_

#include "proppage.h"
#include "pages.h"
#include "objlist.h"
#include <initguid.h>
#include "objselp.h"

HRESULT
CreateGroupMembersPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                       PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                       DWORD dwFlags, const CDSSmartBasePathsInfo& basePathsInfo,
                       HPROPSHEETPAGE * phPage);

HRESULT
CreateGroupGenObjPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                      PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                      DWORD dwFlags, const CDSSmartBasePathsInfo& basePathsInfo,
                      HPROPSHEETPAGE * phPage);

HRESULT
CreateGrpShlGenPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                    PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                    DWORD dwFlags, const CDSSmartBasePathsInfo& basePathsInfo,
                    HPROPSHEETPAGE * phPage);

HRESULT GetDomainMode(CDsPropPageBase * pObj, PBOOL pfMixed);
HRESULT GetDomainMode(PWSTR pwzDomain, HWND hWnd, PBOOL pfMixed);
HRESULT GetGroupType(CDsPropPageBase * pObj, DWORD * pdwType);

//+----------------------------------------------------------------------------
//
//  Class:      CDsGroupGenObjPage
//
//  Purpose:    property page object class for the general page of the
//              group object.
//
//-----------------------------------------------------------------------------
class CDsGroupGenObjPage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsGroupGenObjPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                       DWORD dwFlags);
    ~CDsGroupGenObjPage(void);

    //
    //  Instance specific wind proc
    //
    INT_PTR CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    void    OnQuerySiblings(WPARAM wParam, LPARAM lParam);
    void    OnAttrChanged(WPARAM wParam);
    LRESULT OnDestroy(void);
    void    SetGroupTypeButtons();
	HRESULT IsSpecialAccount(bool& fIsSpecialAccount);

    CDsIconCtrl       * m_pCIcon;
    BOOL                m_fMixed; // Domain is in mixed mode
    DWORD               m_dwType;
    BOOL                m_fTypeWritable;
    BOOL                m_fDescrWritable;
    BOOL                m_fSamNameWritable;
    BOOL                m_fEmailWritable;
    BOOL                m_fCommentWritable;
    BOOL                m_fTypeDirty;
    BOOL                m_fDescrDirty;
    BOOL                m_fSamNameDirty;
    BOOL                m_fEmailDirty;
    BOOL                m_fCommentDirty;
};

HRESULT FillGroupList(CDsPropPageBase * pPage, CDsMembershipList * pList,
                      DWORD dwGroupRID);
HRESULT GetRealDN(CDsPropPageBase * pPage, CMemberListItem * pItem);
HRESULT FindFPO(PSID pSid, PWSTR pwzDomain, CStrW & strFPODN);

//+----------------------------------------------------------------------------
//
//  CMemberDomainMode helper classes
//
//-----------------------------------------------------------------------------
class CMMMemberListItem : public CDLink
{
public:
    CMMMemberListItem(void) {};
    ~CMMMemberListItem(void) {};

    // CDLink method overrides:
    CMMMemberListItem * Next(void) {return (CMMMemberListItem *)CDLink::Next();};

    CStr    m_strName;
};

class CMMMemberList
{
public:
    CMMMemberList(void) : m_pListHead(NULL) {};
    ~CMMMemberList(void) {Clear();};

    HRESULT Insert(LPCTSTR ptzName);
    void    GetList(CStr & strList);
    void    Clear(void);

private:
    CMMMemberListItem * m_pListHead;
};

class CDomainModeListItem : public CDLink
{
public:
    CDomainModeListItem(void) : m_fMixed(FALSE) {};
    ~CDomainModeListItem(void) {};

    // CDLink method overrides:
    CDomainModeListItem * Next(void) {return (CDomainModeListItem *)CDLink::Next();};

    CStrW   m_strName;
    BOOL    m_fMixed;
};

class CDomainModeList
{
public:
    CDomainModeList(void) : m_pListHead(NULL) {};
    ~CDomainModeList(void);

    HRESULT Insert(PWSTR pwzName, BOOL fMixed);
    BOOL    Find(LPCWSTR pwzDomain, PBOOL pfMixed);

private:
    CDomainModeListItem * m_pListHead;
};

//+----------------------------------------------------------------------------
//
//  Class:      CMemberDomainMode
//
//  Purpose:    Maintains a list of all domains in the enterprise from which
//              members have been added along with those domains' mode. Keeps
//              a second list of members who have been added from mixed-mode
//              domains.
//
//-----------------------------------------------------------------------------
class CMemberDomainMode
{
public:
    CMemberDomainMode(void) {};
    ~CMemberDomainMode(void) {};

    void    Init(CDsPropPageBase * pPage);
    HRESULT CheckMember(PWSTR pwzMemberDN);
    HRESULT ListExternalMembers(CStr & strList);

private:

    CDomainModeList     m_DomainList;
    CMMMemberList       m_MemberList;
    CDsPropPageBase   * m_pPage;
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsSelectionListWrapper
//
//  Purpose:    A wrapper class for the DS_SELECTION_LIST that maintains a 
//              linked list of DS_SELECTION items and can make a DS_SELECTION_LIST
//              from that list
//
//-----------------------------------------------------------------------------
class CDsSelectionListWrapper
{
public:
  CDsSelectionListWrapper() : m_pNext(NULL), m_pSelection(NULL) {}
  ~CDsSelectionListWrapper() {}

  CDsSelectionListWrapper*  m_pNext;
  PDS_SELECTION             m_pSelection;

  static PDS_SELECTION_LIST CreateSelectionList(CDsSelectionListWrapper* pHead);
  static UINT GetCount(CDsSelectionListWrapper* pHead);
  static void DetachItemsAndDeleteList(CDsSelectionListWrapper* pHead);
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsGrpMembersPage
//
//  Purpose:    Property page object class for the group object's membership
//              page.
//
//-----------------------------------------------------------------------------
class CDsGrpMembersPage : public CDsPropPageBase,
                          public ICustomizeDsBrowser
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsGrpMembersPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                      DWORD dwFlags);
    ~CDsGrpMembersPage(void);

    //
    // IUknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //
    // ICustomizeDsBrowser methods 
    //
    STDMETHOD(Initialize)(THIS_
                          HWND         hwnd,
                          PCDSOP_INIT_INFO pInitInfo,
                          IBindHelper *pBindHelper);

    STDMETHOD(GetQueryInfoByScope)(THIS_
                IDsObjectPickerScope *pDsScope,
                PDSQUERYINFO *ppdsqi);

    STDMETHOD(AddObjects)(THIS_
                IDsObjectPickerScope *pDsScope,
                IDataObject **ppdo);

    STDMETHOD(ApproveObjects)(THIS_
                IDsObjectPickerScope*,
                IDataObject*,
                PBOOL) { return S_OK; }  // Approve everything

    STDMETHOD(PrefixSearch)(THIS_
                IDsObjectPickerScope *pDsScope,
                PCWSTR pwzSearchFor,
                IDataObject **pdo);

    STDMETHOD_(PSID, LookupDownlevelName)(THIS_
                                          PCWSTR) { return NULL; }

    //
    //  Instance specific wind proc
    //
    INT_PTR CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL    m_fShowIcons;

protected:
    HRESULT OnInitDialog(LPARAM lParam);
    HRESULT OnInitDialog(LPARAM lParam, BOOL fShowIcons);
    LRESULT OnApply(void);
    virtual LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(void);

private:
    void    InvokeUserQuery(void);
    void    RemoveMember(void);
    HRESULT FillGroupList(void);
    HRESULT GetRealDN(CMemberListItem * pDelItem);

    HRESULT LoadGroupExtraClasses(BOOL bSecurity);
    HRESULT BuildQueryString(PWSTR* ppszFilterString);
    HRESULT CollectDsObjects(PWSTR pszFilter,
                             IDsObjectPickerScope *pDsScope,
                             CDsPropDataObj *pdo);


    PWSTR*              m_pszSecurityGroupExtraClasses;
    DWORD               m_dwSecurityGroupExtraClassesCount;
    PWSTR*              m_pszNonSecurityGroupExtraClasses;
    DWORD               m_dwNonSecurityGroupExtraClassesCount;

    HWND                m_hwndObjPicker;
    PCDSOP_INIT_INFO    m_pInitInfo;
    CComPtr<IBindHelper> m_pBinder;

protected:
    CDsMembershipList * m_pList;
    CMemberLinkList     m_DelList;
    DWORD               m_dwGroupRID;
    BOOL                m_fMixed; // Domain is in mixed mode
    DWORD               m_dwType;
    BOOL                m_fMemberWritable;
    CMemberDomainMode   m_MixedModeMembers;
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsGrpShlGenPage
//
//  Purpose:    Property page object class for the group object's shell general
//              page which includes membership manipulation which is gained by
//              subclassing CDsGrpMembersPage.
//
//-----------------------------------------------------------------------------
class CDsGrpShlGenPage : public CDsGrpMembersPage
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsGrpShlGenPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                     DWORD dwFlags);
    ~CDsGrpShlGenPage(void);

private:
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnApply(void);
    LRESULT OnDestroy(void);

#if !defined(DSADMIN)
    void MakeNotWritable() { m_fMemberWritable = FALSE; m_fDescrWritable = FALSE;}
#endif

    CDsIconCtrl       * m_pCIcon;
    BOOL                m_fDescrWritable;
    BOOL                m_fDescrDirty;
};

#endif // _GROUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\misc.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       misc.cxx, this file is #include'd into the two dllmisc.cxx files.
//
//  Contents:   DS property pages class objects handler DLL fcns. Also, error
//              reporting, message, and miscelaneous functions.
//
//  History:    10-May-01 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "objlist.h"
#if defined(DSPROP_ADMIN)
#   include "chklist.h"
#   include "fpnw.h"
#endif
#include <time.h>
#include <shlobjp.h>

DECLARE_INFOLEVEL(DsProp);

HINSTANCE g_hInstance = NULL;
ULONG CDll::s_cObjs  = 0;
ULONG CDll::s_cLocks = 0;
UINT g_uChangeMsg = 0;
int g_iInstance = 0;

#ifndef DSPROP_ADMIN
CRITICAL_SECTION g_csNotifyCreate;
#endif

ULONG g_ulMemberFilterCount = DSPROP_MEMBER_FILTER_COUNT_DEFAULT;
ULONG g_ulMemberQueryLimit = DSPROP_MEMBER_QUERY_LIMIT_DEFAULT;

#define DIRECTORY_UI_KEY TEXT("Software\\Policies\\Microsoft\\Windows\\Directory UI")
#define MEMBER_QUERY_VALUE TEXT("GroupMemberFilterCount")
#define MEMBER_LIMIT_VALUE TEXT("GroupMemberQueryLimit")

#if defined(DSPROP_ADMIN)
Cache g_FPNWCache;
#endif

HRESULT GlobalInit(void);
void GlobalUnInit(void);
void ReportErrorFallback(HWND hWndMsg, HRESULT hr = ERROR_SUCCESS)
    { ReportError( hr, 0, hWndMsg ); }

//+----------------------------------------------------------------------------
// To set a non-default debug info level outside of the debugger, create the
// below registry key and in it create a value whose name is the component's
// debugging tag name (the "comp" parameter to the DECLARE_INFOLEVEL macro) and
// whose data is the desired infolevel in REG_DWORD format.
//-----------------------------------------------------------------------------

#define SMDEBUGKEY "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug"

#ifndef DSPROP_ADMIN
//+----------------------------------------------------------------------------
//
//  Class:      CNotifyCreateCriticalSection
//
//  Purpose:    Prevents creation race conditions. Without this protection,
//              a second call to CNotifyObj::Create that comes in before the
//              first has created the hidden window will get NULL back from
//              FindSheetNoSetFocus and then go on to create a second hidden
//              window.
//
//-----------------------------------------------------------------------------
CNotifyCreateCriticalSection::CNotifyCreateCriticalSection()
{
    TRACE(CNotifyCreateCriticalSection, CNotifyCreateCriticalSection);
    EnterCriticalSection(&g_csNotifyCreate);
};

CNotifyCreateCriticalSection::~CNotifyCreateCriticalSection()
{
    TRACE(CNotifyCreateCriticalSection, ~CNotifyCreateCriticalSection);
    LeaveCriticalSection(&g_csNotifyCreate);
};

#endif

#define MAX_STRING 1024

//+----------------------------------------------------------------------------
//
//  Function:   LoadStringToTchar
//
//  Synopsis:   Loads the given string into an allocated buffer that must be
//              caller freed using delete.
//
//-----------------------------------------------------------------------------
BOOL LoadStringToTchar(int ids, PTSTR * pptstr)
{
    TCHAR szBuf[MAX_STRING];

    if (!LoadString(g_hInstance, ids, szBuf, MAX_STRING - 1))
    {
        return FALSE;
    }

    *pptstr = new TCHAR[_tcslen(szBuf) + 1];

    CHECK_NULL(*pptstr, return FALSE);

    _tcscpy(*pptstr, szBuf);

    return TRUE;
}

//+----------------------------------------------------------------------------
// Function: LoadStringReport
// Purpose: attempts to load a string, returns FALSE and gives error message
//          if a failure occurs.
//-----------------------------------------------------------------------------
BOOL LoadStringReport(int ids, PTSTR ptz, int len, HWND hwnd)
{
    if (!LoadString(g_hInstance, ids, ptz, len - 1))
    {
        DWORD dwErr = GetLastError();
        dspDebugOut((DEB_ERROR, "LoadString of %d failed with error %lu\n",
                     ids, dwErr));
        ReportError(dwErr, 0, hwnd);
        return FALSE;
    }
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   LoadErrorMessage
//
//  Synopsis:   Attempts to get a user-friendly error message from the system.
//
//-----------------------------------------------------------------------------
void LoadErrorMessage(HRESULT hr, int nStr, PTSTR* pptsz) // free with delete[]
{
    dspAssert( NULL != pptsz && NULL == *pptsz );
    PTSTR ptzFormat = NULL, ptzSysMsg;
    int cch;

    if (nStr)
    {
        LoadStringToTchar(nStr, &ptzFormat);
    }

    cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (PTSTR)&ptzSysMsg, 0, NULL);
    if (!cch)
    {
        // Try ADSI errors.
        //
        cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                            | FORMAT_MESSAGE_FROM_HMODULE,
                            GetModuleHandle(TEXT("activeds.dll")), hr,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (PTSTR)&ptzSysMsg, 0, NULL);
    }

    if (!cch)
    {
        PTSTR ptzMsgTemplate = NULL;
        BOOL fDelMsgTemplate = TRUE;
        LoadStringToTchar(IDS_DEFAULT_ERROR_MSG, &ptzMsgTemplate);
		if (NULL == ptzMsgTemplate)
        {
            ptzMsgTemplate = TEXT("The operation failed with error code %d (0x%08x)");
            fDelMsgTemplate = FALSE;
        }
        *pptsz = new TCHAR[ lstrlen(ptzMsgTemplate)+10 ];
        dspAssert( NULL != *pptsz );
        if (NULL != *pptsz)
        {
            wsprintf(*pptsz, ptzMsgTemplate, hr, hr);
        }
        if (fDelMsgTemplate)
        {
            delete ptzMsgTemplate;
        }
    }
    else
    {
        PTSTR ptzMsg;
        BOOL fDelMsg = FALSE;

        if (ptzFormat)
        {
            ptzMsg = new TCHAR[lstrlen(ptzFormat) + lstrlen(ptzSysMsg) + 1];
            if (ptzMsg)
            {
                wsprintf(ptzMsg, ptzFormat, ptzSysMsg);
                fDelMsg = TRUE;
            }
            else
            {
                ptzMsg = ptzSysMsg;
            }
        }
        else
        {
            ptzMsg = ptzSysMsg;
        }

        *pptsz = new TCHAR[ lstrlen(ptzMsg)+1 ];
        if (NULL != *pptsz)
        {
            lstrcpy( *pptsz, ptzMsg );
        }
        dspAssert( NULL != *pptsz );

        LocalFree(ptzSysMsg);
        if (fDelMsg)
        {
            delete[] ptzMsg;
        }
        if (ptzFormat)
        {
            delete ptzFormat;
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CheckADsError
//
//  Synopsis:   Checks the result code from an ADSI call.
//
//  Returns:    TRUE if no error.
//
//-----------------------------------------------------------------------------
BOOL CheckADsError(HRESULT * phr, BOOL fIgnoreAttrNotFound, PSTR file,
                   int line, HWND hWnd)
{
    if (SUCCEEDED(*phr))
    {
        return TRUE;
    }

    if (((E_ADS_PROPERTY_NOT_FOUND == *phr) ||
         (HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE) == *phr)) &&
        fIgnoreAttrNotFound)
    {
        *phr = S_OK;
        return TRUE;
    }

    HWND hWndMsg = hWnd;

    if (!hWndMsg)
    {
        hWndMsg = GetDesktopWindow();
    }

    DWORD dwErr;
    WCHAR wszErrBuf[MAX_PATH+1];
    WCHAR wszNameBuf[MAX_PATH+1];
    ADsGetLastError(&dwErr, wszErrBuf, MAX_PATH, wszNameBuf, MAX_PATH);
    if ((LDAP_RETCODE)dwErr == LDAP_NO_SUCH_ATTRIBUTE && fIgnoreAttrNotFound)
    {
        *phr = S_OK;
        return TRUE;
    }
    if (dwErr)
    {
        dspDebugOut((DEB_ERROR,
                     "Extended Error 0x%x: %ws %ws <%s @line %d>.\n", dwErr,
                     wszErrBuf, wszNameBuf, file, line));
        ReportError(dwErr, IDS_ADS_ERROR_FORMAT, hWndMsg);
    }
    else
    {
        dspDebugOut((DEB_ERROR, "Error %08lx <%s @line %d>\n", *phr, file, line));
        ReportError(*phr, IDS_ADS_ERROR_FORMAT, hWndMsg);
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:   ReportError
//
//  Synopsis:   Displays an error using a user-friendly error message from the
//              system.
//
//-----------------------------------------------------------------------------
void ReportErrorWorker(HWND hWnd, PTSTR ptzMsg)
{
    HWND hWndMsg = hWnd;
    if (!hWndMsg)
    {
        hWndMsg = GetDesktopWindow();
    }

    PTSTR ptzTitle = NULL;
    if (!LoadStringToTchar(IDS_MSG_TITLE, &ptzTitle))
    {
        MessageBox(hWndMsg, ptzMsg, TEXT("Active Directory"), MB_OK | MB_ICONEXCLAMATION);
        return;
    }

    MessageBox(hWndMsg, ptzMsg, ptzTitle, MB_OK | MB_ICONEXCLAMATION);

    delete ptzTitle;
}

void ReportError(HRESULT hr, int nStr, HWND hWnd)
{
    PTSTR ptzMsg = NULL;
    LoadErrorMessage(hr, nStr, &ptzMsg);
    //NTRAID#NTBUG9-573448-2002/03/10-jmessec   Unlocalized text in code.
	if (NULL == ptzMsg)
    {
        TCHAR tzBuf[80];
        wsprintf(tzBuf, TEXT("Active Directory failure with code '0x%08x'!"), hr);
        ReportErrorWorker( hWnd, tzBuf );
        return;
    }

    ReportErrorWorker( hWnd, ptzMsg );

    delete ptzMsg;
}

#if defined(DSADMIN)
//+----------------------------------------------------------------------------
//
//  Function:   SuperMsgBox
//
//  Synopsis:   Displays a message obtained from a string resource with
//              the parameters expanded. The error param, dwErr, if
//              non-zero, is converted to a string and becomes the first
//              replaceable param.
//
//  Note: this function is UNICODE-only.
//
//-----------------------------------------------------------------------------
int SuperMsgBox(
    HWND hWnd,          // owning window.
    int nMessageId,     // string resource ID of message. Must have replacable params to match nArguments.
    int nTitleId,       // string resource ID of the title. If zero, uses IDS_MSG_TITLE.
    UINT ufStyle,       // MessageBox flags.
    DWORD dwErr,        // Error code, or zero if not needed.
    PVOID * rgpvArgs,   // array of pointers/values for substitution in the nMessageId string.
    int nArguments,     // count of pointers in string array.
    BOOL fTryADSiErrors,// If the failure is the result of an ADSI call, see if an ADSI extended error.
    PSTR szFile,        // use the __FILE__ macro. ignored in retail build.
    int nLine           // use the __LINE__ macro. ignored in retail build.
    )
{
    CStrW strTitle;
    PWSTR pwzMsg = NULL;

    strTitle.LoadString(g_hInstance, (nTitleId) ? nTitleId : IDS_MSG_TITLE);

    if (0 == strTitle.GetLength())
    {
        ReportErrorFallback(hWnd, dwErr);
        return 0;
    }

    DspFormatMessage(nMessageId, dwErr, rgpvArgs, nArguments,
                     fTryADSiErrors, &pwzMsg, hWnd);
    if (!pwzMsg)
    {
       return 0;
    }

    if (dwErr)
    {
        dspDebugOut((DEB_ERROR,
                     "*+*+*+*+* Error <%s @line %d> -> 0x%08x, with message:\n\t%ws\n",
                     szFile, nLine, dwErr, pwzMsg));
    }
    else
    {
        dspDebugOut((DEB_ERROR,
                     "*+*+*+*+* Message <%s @line %d>:\n\t%ws\n",
                     szFile, nLine, pwzMsg));
    }

    int retval = MessageBox(hWnd, pwzMsg, strTitle, ufStyle);

    LocalFree(pwzMsg);
    return retval;
}

//+----------------------------------------------------------------------------
//
//  Function:   DspFormatMessage
//
//  Synopsis:   Loads a string resource with replaceable parameters and uses
//              FormatMessage to populate the replaceable params from the
//              argument array. If dwErr is non-zero, will load the system
//              description for that error and include it in the argument array.
//
//-----------------------------------------------------------------------------
void
DspFormatMessage(
    int nMessageId,     // string resource ID of message. Must have replacable params to match nArguments.
    DWORD dwErr,        // Error code, or zero if not needed.
    PVOID * rgpvArgs,   // array of pointers/values for substitution in the nMessageId string.
    int nArguments,     // count of pointers in string array.
    BOOL fTryADSiErrors,// If the failure is the result of an ADSI call, see if an ADSI extended error.
    PWSTR * ppwzMsg,    // The returned error string, free with LocalFree.
    HWND hWnd           // owning window, defaults to NULL.
    )
{
    int cch;
    PWSTR pwzSysErr = NULL;

    if (dwErr)
    {
        if (fTryADSiErrors)
        {
            DWORD dwStatus;
            WCHAR Buf1[256], Buf2[256];

            ADsGetLastError(&dwStatus, Buf1, 256, Buf2, 256);

            dspDebugOut((DEB_ERROR,
                         "ADsGetLastError returned status of %lx, error: %s, name %s\n",
                          dwStatus, Buf1, Buf2));

            if ((ERROR_INVALID_DATA != dwStatus) && (0 != dwStatus))
            {
                dwErr = dwStatus;
            }
        }

        cch = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                             FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwErr,
                             MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                             (PWSTR)&pwzSysErr, 0, NULL);
        if (!cch)
        {
            ReportErrorFallback(hWnd, dwErr);
            return;
        }
    }

    PWSTR * rgpvArguments = new PWSTR[nArguments + 1];

    if (!rgpvArguments)
    {
        ReportErrorFallback(hWnd, dwErr);
        return;
    }

    int nOffset = 0;

    if (dwErr)
    {
        rgpvArguments[0] = pwzSysErr;
        nOffset = 1;
    }

    if (0 != nArguments)
    {
        CopyMemory(rgpvArguments + nOffset, rgpvArgs, nArguments * sizeof(PVOID));
    }

    CStrW strFormat;

    strFormat.LoadString(g_hInstance, nMessageId);

    if (0 == strFormat.GetLength())
    {
        ReportErrorFallback(hWnd, dwErr);

        // NTRAID#NTBUG9-693720-2002/09/03-sburns

        delete[] rgpvArguments;
        return;
    }

    cch = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                         FORMAT_MESSAGE_FROM_STRING |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY, strFormat, 0, 0,
                         (PWSTR)ppwzMsg, 0, (va_list *)rgpvArguments);

    if (pwzSysErr) LocalFree(pwzSysErr);

    if (!cch)
    {
        ReportErrorFallback(hWnd, dwErr);
    }

    delete[] rgpvArguments;
    return;
}

#endif // defined(DSADMIN)

//+----------------------------------------------------------------------------
//
//  Function:   ErrMsg
//
//  Synopsis:   Displays an error message obtained from a string resource.
//
//-----------------------------------------------------------------------------
void ErrMsg(UINT MsgID, HWND hWndParam)
{
    PTSTR ptz = TEXT("");

    ErrMsgParam(MsgID, (LPARAM)ptz, hWndParam);
}

//+----------------------------------------------------------------------------
//
//  Function:   ErrMsgParam
//
//  Synopsis:   Displays an error message obtained from a string resource with
//              an insertion parameter.
//
//  Note: fixed-size stack buffers are used for the strings because trying to
//        report an allocation failure using dynamically allocated string
//        buffers is not a good idea.
//-----------------------------------------------------------------------------
void ErrMsgParam(UINT MsgID, LPARAM param, HWND hWndParam)
{
    HWND hWnd;
    if (hWndParam == NULL)
    {
        hWnd = GetDesktopWindow();
    }
    else
    {
        hWnd = hWndParam;
    }
    TCHAR szTitle[MAX_TITLE+1];
    TCHAR szFormat[MAX_ERRORMSG+1];
    TCHAR szMsg[MAX_ERRORMSG+1];
    //NTRAID#NTBUG9-573453-2002/03/10-jmessec    Why fall back to a message beep?  
		//1) It's offensive in some languages (Japanese)
		//2) It's unhelpful...why did this thing just beep at me?
		//3) It's arbitrary...this particular failure beeps, but most in this code don't
	LOAD_STRING(IDS_MSG_TITLE, szTitle, MAX_TITLE, MessageBeep(MB_ICONEXCLAMATION); return);
    LOAD_STRING(MsgID, szFormat, MAX_ERRORMSG, MessageBeep(MB_ICONEXCLAMATION); return);
	//NTRAID#NTBUG9-573453-2002/03/10-jmessec   Possible buffer overrun; not checking any lengths here
	wsprintf(szMsg, szFormat, param);
    MessageBox(hWnd, szMsg, szTitle, MB_OK | MB_ICONEXCLAMATION);
}

//+----------------------------------------------------------------------------
//
//  Function:   MsgBox
//
//  Synopsis:   Displays a message obtained from a string resource.
//
//-----------------------------------------------------------------------------
void MsgBox(UINT MsgID, HWND hWnd)
{
    MsgBox2(MsgID, 0, hWnd);
}

//+----------------------------------------------------------------------------
//
//  Function:   MsgBox2
//
//  Synopsis:   Displays a message obtained from a string resource which is
//              assumed to have a replacable parameter where the InsertID
//              string is inserted.
//
//-----------------------------------------------------------------------------
void MsgBox2(UINT MsgID, UINT InsertID, HWND hWnd)
{
    CStr strInsert;
    PTSTR pszInsert = NULL;

    if (InsertID)
    {
        if (!strInsert.LoadString(g_hInstance, InsertID))
        {
            REPORT_ERROR(GetLastError(), hWnd);
            return;
        }

        pszInsert = strInsert.GetBuffer(0);
    }

    MsgBoxParam(MsgID, (LPARAM)pszInsert, hWnd);
}

//+----------------------------------------------------------------------------
//
//  Function:   MsgBoxParam
//
//  Synopsis:   Displays a message obtained from a string resource which is
//              assumed to have a replacable parameter where the argument
//              LPARAM is inserted.
//
//-----------------------------------------------------------------------------
int MsgBoxParam(UINT MsgID, LPARAM lParam, HWND hWnd, int nStyle)
{
    CStr strMsg, strFormat, strInsert, strTitle;

    if (!strTitle.LoadString(g_hInstance, IDS_MSG_TITLE))
    {
        REPORT_ERROR(GetLastError(), hWnd);
        return IDCANCEL;
    }
    if (!strFormat.LoadString(g_hInstance, MsgID))
    {
        REPORT_ERROR(GetLastError(), hWnd);
        return IDCANCEL;
    }

    strMsg.Format(strFormat, lParam);

    if (!nStyle)
    {
       nStyle = MB_OK | MB_ICONINFORMATION;
    }

    return MessageBox(hWnd, strMsg, strTitle, nStyle);
}

//+----------------------------------------------------------------------------
//
//      DLL functions
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Provide a DllMain for Win32
//
//  Arguments:  hInstance - HANDLE to this dll
//              dwReason  - Reason this function was called. Can be
//                          Process/Thread Attach/Detach.
//
//  Returns:    BOOL - TRUE if no error, FALSE otherwise
//
//  History:    24-May-95 EricB created.
//
//-----------------------------------------------------------------------------
extern "C" BOOL
DllMain(HINSTANCE hInstance, DWORD dwReason, PVOID)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            dspDebugOut((DEB_ITRACE, "DllMain: DLL_PROCESS_ATTACH\n"));

            //
            // Get instance handle
            //

            g_hInstance = hInstance;

            //
            // Disable thread notification from OS
            //

            DisableThreadLibraryCalls(hInstance);

            HRESULT hr;

            //
            // Initialize the global values.
            //

            hr = GlobalInit();
            if (FAILED(hr))
            {
                ERR_OUT("GlobalInit", hr);
                return FALSE;
            }
            LinkWindow_RegisterClass ();
            break;

        case DLL_PROCESS_DETACH:
            LinkWindow_UnregisterClass (hInstance);
            dspDebugOut((DEB_ITRACE, "DllMain: DLL_PROCESS_DETACH\n"));
            GlobalUnInit();
            break;
    }
    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Creates a class factory for the requested object.
//
//  Arguments:  [cid]    - the requested class object
//              [iid]    - the requested interface
//              [ppvObj] - returned pointer to class object
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDAPI
DllGetClassObject(REFCLSID cid, REFIID iid, void **ppvObj)
{
    IUnknown *pUnk = NULL;
    HRESULT hr = S_OK;

    for (int i = 0; i < g_DsPPClasses.cClasses; i++)
    {
        if (cid == *g_DsPPClasses.rgpClass[i]->pcid)
        {
            pUnk = CDsPropPagesHostCF::Create(g_DsPPClasses.rgpClass[i]);
            if (pUnk != NULL)
            {
                hr = pUnk->QueryInterface(iid, ppvObj);
                pUnk->Release();
            }
            else
            {
                return E_OUTOFMEMORY;
            }
            return hr;
        }
    }
    return E_NOINTERFACE;
}

//+----------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Indicates whether the DLL can be removed if there are no
//              objects in existence.
//
//  Returns:    S_OK or S_FALSE
//
//-----------------------------------------------------------------------------
STDAPI
DllCanUnloadNow(void)
{
    dspDebugOut((DEB_ITRACE, "DllCanUnloadNow: CDll::CanUnloadNow()? %s\n",
                 (CDll::CanUnloadNow() == S_OK) ? "TRUE" : "FALSE"));
    return CDll::CanUnloadNow();
}

TCHAR const c_szServerType[] = TEXT("InProcServer32");
TCHAR const c_szThreadModel[] = TEXT("ThreadingModel");
TCHAR const c_szThreadModelValue[] = TEXT("Apartment");

//+----------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Adds entries to the system registry.
//
//  Returns:    S_OK or error code.
//
//  Notes:      The keys look like this:
//
//      HKC\CLSID\clsid <No Name> REG_SZ name.progid
//                     \InPropServer32 <No Name> : REG_SZ : adprop.dll/dsprop.dll
//                                     ThreadingModel : REG_SZ : Apartment
//-----------------------------------------------------------------------------
STDAPI
DllRegisterServer(void)
{
    HRESULT hr = S_OK;
    HKEY hKeyCLSID, hKeyDsPPClass, hKeySvr;

    long lRet = RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0,
                             KEY_WRITE, &hKeyCLSID);
    if (lRet != ERROR_SUCCESS)
    {
        dspDebugOut((DEB_ITRACE, "RegOpenKeyEx failed: %d", lRet));
        return (HRESULT_FROM_WIN32(lRet));
    }

    LPOLESTR pszCLSID;
    PTSTR ptzCLSID;
    DWORD dwDisposition;

    for (int i = 0; i < g_DsPPClasses.cClasses; i++)
    {
        hr = StringFromCLSID(*g_DsPPClasses.rgpClass[i]->pcid, &pszCLSID);

        if (FAILED(hr))
        {
            DBG_OUT("StringFromCLSID failed");
            continue;
        }

        if (!UnicodeToTchar(pszCLSID, &ptzCLSID))
        {
            DBG_OUT("Memory Allocation failure!");
            CoTaskMemFree(pszCLSID);
            hr = E_OUTOFMEMORY;
            continue;
        }

        CoTaskMemFree(pszCLSID);

        lRet = RegCreateKeyEx(hKeyCLSID, ptzCLSID, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKeyDsPPClass, &dwDisposition);

        delete ptzCLSID;

        if (lRet != ERROR_SUCCESS)
        {
            dspDebugOut((DEB_ITRACE, "RegCreateKeyEx failed: %d", lRet));
            hr = HRESULT_FROM_WIN32(lRet);
            continue;
        }

        TCHAR szProgID[MAX_PATH];
        _tcscpy(szProgID, c_szDsProppagesProgID);
        _tcscat(szProgID, g_DsPPClasses.rgpClass[i]->szProgID);

        lRet = RegSetValueEx(hKeyDsPPClass, NULL, 0, REG_SZ,
                             (CONST BYTE *)szProgID,
                             sizeof(TCHAR) * (static_cast<DWORD>(_tcslen(szProgID) + 1)));
        if (lRet != ERROR_SUCCESS)
        {
            RegCloseKey(hKeyDsPPClass);
            dspDebugOut((DEB_ITRACE, "RegSetValueEx failed: %d", lRet));
            hr = HRESULT_FROM_WIN32(lRet);
            continue;
        }

        lRet = RegCreateKeyEx(hKeyDsPPClass, c_szServerType, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKeySvr, &dwDisposition);

        RegCloseKey(hKeyDsPPClass);

        if (lRet != ERROR_SUCCESS)
        {
            dspDebugOut((DEB_ITRACE, "RegCreateKeyEx failed: %d", lRet));
            hr = HRESULT_FROM_WIN32(lRet);
            continue;
        }

        lRet = RegSetValueEx(hKeySvr, NULL, 0, REG_SZ,
                             (CONST BYTE *)c_szDsProppagesDllName,
                         sizeof(TCHAR) * (static_cast<DWORD>(_tcslen(c_szDsProppagesDllName) + 1)));
        if (lRet != ERROR_SUCCESS)
        {
            dspDebugOut((DEB_ITRACE, "RegSetValueEx failed: %d", lRet));
            hr = HRESULT_FROM_WIN32(lRet);
        }

        lRet = RegSetValueEx(hKeySvr, c_szThreadModel, 0, REG_SZ,
                             (CONST BYTE *)c_szThreadModelValue,
                         sizeof(TCHAR) * (static_cast<DWORD>(_tcslen(c_szThreadModelValue) + 1)));
        if (lRet != ERROR_SUCCESS)
        {
            dspDebugOut((DEB_ITRACE, "RegSetValueEx failed: %d", lRet));
            hr = HRESULT_FROM_WIN32(lRet);
        }

        RegCloseKey(hKeySvr);
    }
    RegCloseKey(hKeyCLSID);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Removes the entries from the system registry.
//
//  Returns:    S_OK or S_FALSE
//
//  Notes:      The keys look like this:
//
//      HKC\CLSID\clsid <No Name> REG_SZ name.progid
//                     \InPropServer32 <No Name> : REG_SZ : dsprop.dll
//                                     ThreadingModel : REG_SZ : Apartment
//-----------------------------------------------------------------------------
STDAPI
DllUnregisterServer(void)
{
    HRESULT hr = S_OK;
    HKEY hKeyCLSID, hKeyClass;

    long lRet = RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0,
                             KEY_ALL_ACCESS, &hKeyCLSID);
    if (lRet != ERROR_SUCCESS)
    {
        dspDebugOut((DEB_ITRACE, "RegOpenKeyEx failed: %d", lRet));
        return (HRESULT_FROM_WIN32(lRet));
    }

    LPOLESTR pszCLSID;
    PTSTR ptzCLSID;

    for (int i = 0; i < g_DsPPClasses.cClasses; i++)
    {
        hr = StringFromCLSID(*g_DsPPClasses.rgpClass[i]->pcid, &pszCLSID);

        if (FAILED(hr))
        {
            DBG_OUT("StringFromCLSID failed");
            continue;
        }

        if (!UnicodeToTchar(pszCLSID, &ptzCLSID))
        {
            DBG_OUT("CLSID string memory allocation failure!");
            CoTaskMemFree(pszCLSID);
            hr = E_OUTOFMEMORY;
            continue;
        }

        CoTaskMemFree(pszCLSID);

        lRet = RegOpenKeyEx(hKeyCLSID, ptzCLSID, 0, KEY_ALL_ACCESS, &hKeyClass);

        if (lRet != ERROR_SUCCESS)
        {
            dspDebugOut((DEB_ITRACE, "Failed to open key %S\n", ptzCLSID));
            lRet = ERROR_SUCCESS;
            hr = S_FALSE;
        }
        else
        {
            lRet = RegDeleteKey(hKeyClass, c_szServerType);

            RegCloseKey(hKeyClass);

            dspDebugOut((DEB_ITRACE, "Delete of key %S returned code %d\n",
                         c_szServerType, lRet));

            if (lRet != ERROR_SUCCESS)
            {
                lRet = ERROR_SUCCESS;
                hr = S_FALSE;
            }
        }

        lRet = RegDeleteKey(hKeyCLSID, ptzCLSID);

        dspDebugOut((DEB_ITRACE, "Delete of key %S returned code %d\n",
                     ptzCLSID, lRet));

        delete ptzCLSID;

        if (lRet != ERROR_SUCCESS)
        {
            lRet = ERROR_SUCCESS;
            hr = S_FALSE;
        }
    }
    RegCloseKey(hKeyCLSID);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GlobalInit
//
//  Synopsis:   Sets up the global environment.
//
//  Returns:    S_OK or S_FALSE
//
//-----------------------------------------------------------------------------
HRESULT
GlobalInit(void)
{
#if defined(DSADMIN)
   //
   // Enable themed common controls.
   //
   if (!SHFusionInitializeFromModule(g_hInstance))
   {
      dspDebugOut((DEB_ITRACE, "SHFusionInitializeFromModule failed with error %d\n", GetLastError()));
   }
#endif

   //
   // Initialize common controls
   //
   InitCommonControls();

   INITCOMMONCONTROLSEX icce = {0};

   icce.dwSize = sizeof(icce);
   icce.dwICC = ICC_DATE_CLASSES | ICC_WIN95_CLASSES;
   if (!InitCommonControlsEx(&icce))
   {
      dspDebugOut((DEB_ITRACE, "InitCommonControlsEx failed with error %d\n", GetLastError()));
   }

#if defined(DSPROP_ADMIN)
    //
    // Register the "CHECKLIST" control
    //
    RegisterCheckListWndClass();
    //
    // Register the Credential Manager control.
    //
    CredUIInitControls();
#endif

#ifndef DSPROP_ADMIN
    //
    // Register the window class for the notification window.
    //
    RegisterNotifyClass();
#endif

    //
    // Register the attribute-changed message.
    //
    g_uChangeMsg = RegisterWindowMessage(DSPROP_ATTRCHANGED_MSG);

    CHECK_NULL(g_uChangeMsg, ;);

    //
    // Major cheesy hack to allow locating windows that are unique to this
    // instance (since hInstance is invariant).
    //
    srand((unsigned)time(NULL));
    g_iInstance = rand();

#ifndef DSPROP_ADMIN
    ExceptionPropagatingInitializeCriticalSection(&g_csNotifyCreate);
#endif

    HRESULT hr = CheckRegisterClipFormats();
    dspAssert( SUCCEEDED(hr) );

    // If found, read the value of the Member class query clause count and
    // number-of-members limit.
    //
    HKEY hKey;
    LONG lRet;
    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, DIRECTORY_UI_KEY, 0, KEY_READ, &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        DWORD dwSize = sizeof(ULONG);
        RegQueryValueEx(hKey, MEMBER_QUERY_VALUE, NULL, NULL,
                        (LPBYTE)&g_ulMemberFilterCount, &dwSize);

        RegQueryValueEx(hKey, MEMBER_LIMIT_VALUE, NULL, NULL,
                        (LPBYTE)&g_ulMemberQueryLimit, &dwSize);
        RegCloseKey(hKey);
    }

    dspDebugOut((DEB_ITRACE | DEB_USER14, "GroupMemberFilterCount set to %d\n", g_ulMemberFilterCount));
    dspDebugOut((DEB_ITRACE | DEB_USER14, "GroupMemberQueryLimit set to %d\n", g_ulMemberQueryLimit));
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   GlobalUnInit
//
//  Synopsis:   Do resource freeing.
//
//-----------------------------------------------------------------------------
inline void
GlobalUnInit(void)
{
#if defined(DSPROP_ADMIN)
  if (!g_FPNWCache.empty()) 
  {
    for (Cache::iterator i = g_FPNWCache.begin(); i != g_FPNWCache.end(); i++) 
    {
      PFPNWCACHE pElem = (*i).second;
      if (pElem)
      {
        if (pElem->pwzPDCName)
        {
          LocalFree(pElem->pwzPDCName);
        }
        LocalFree(pElem);
      }
    }
    g_FPNWCache.clear();
  }
#endif
  g_ClassIconCache.ClearAll();

#ifndef DSPROP_ADMIN
  DeleteCriticalSection(&g_csNotifyCreate);
#endif

#if defined(DSADMIN)
   SHFusionUninitialize();
#endif
}

//+----------------------------------------------------------------------------
//
//  Debugging routines.
//
//-----------------------------------------------------------------------------
#if DBG == 1

//////////////////////////////////////////////////////////////////////////////

unsigned long SmAssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;
BOOL fInfoLevelInit = FALSE;

//////////////////////////////////////////////////////////////////////////////

static int _cdecl w4dprintf(const char *format, ...);
static int _cdecl w4smprintf(const char *format, va_list arglist);

//////////////////////////////////////////////////////////////////////////////

static int _cdecl w4dprintf(const char *format, ...)
{
   int ret;

   va_list va;
   va_start(va, format);
   ret = w4smprintf(format, va);
   va_end(va);

   return ret;
}


static int _cdecl w4smprintf(const char *format, va_list arglist)
{
   int ret;
   char szMessageBuf[DSP_DEBUG_BUF_SIZE];

   ret = wvnsprintfA(szMessageBuf, DSP_DEBUG_BUF_SIZE - 1, format, arglist);
   OutputDebugStringA(szMessageBuf);
   return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls smprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    smprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   SmAssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

void APINOT
SmAssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
    if (SmAssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s File: %s Line: %u, thread id %d\n",
            szMessage, szFile, iLine, tid);
    }

    if (SmAssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (SmAssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}

//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int APINOT
PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{
    int id;
    static char szAssertCaption[128];
    static char szModuleName[MAX_PATH+1] = {0};

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, MAX_PATH))
    {
        pszModuleName = szModuleName;
    }
    else
    {
        pszModuleName = "Unknown";
    }

	//NTRAID#NTBUG9-573457-2002/03/10-jmessec   Unlocalized text
    wsprintfA(szAssertCaption,"Process: %s File: %s line %u, thread id %d.%d",
              pszModuleName, szFile, iLine, pid, tid);

    id = MessageBoxA(NULL,
                     szMsg,
                     szAssertCaption,
                     MB_SETFOREGROUND
                     | MB_DEFAULT_DESKTOP_ONLY
                     | MB_TASKMODAL
                     | MB_ICONEXCLAMATION
                     | MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //
#ifdef DSPROP_ADMIN
    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBoxA(NULL,
                             szMsg,
                             szAssertCaption,
                             MB_SETFOREGROUND
                             | MB_SERVICE_NOTIFICATION
                             | MB_TASKMODAL
                             | MB_ICONEXCLAMATION
                             | MB_OKCANCEL);
        }
    }
#endif
    return id;
}


//+------------------------------------------------------------
// Function:    smprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

void APINOT
smprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        (ulCompMask | DEF_INFOLEVEL))
    {
        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((DEF_INFOLEVEL & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf("%x.%03x> %s: ", pid, tid, pszComp);
            }

            SYSTEMTIME st;
            GetLocalTime(&st);
            w4dprintf("%02d:%02d:%02d ", st.wHour, st.wMinute, st.wSecond);

            w4smprintf(ppszfmt, pargs);
        }
    }
}

//+----------------------------------------------------------------------------
// Function:    CheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------
void APINOT
CheckInit(char * pInfoLevelString, unsigned long * pulInfoLevel)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwSize;
    if (fInfoLevelInit) return;
    fInfoLevelInit = TRUE;
    lRet = RegOpenKeyExA(HKEY_LOCAL_MACHINE, SMDEBUGKEY, 0, KEY_READ, &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        dwSize = sizeof(unsigned long);
        lRet = RegQueryValueExA(hKey, pInfoLevelString, NULL, NULL,
                                (LPBYTE)pulInfoLevel, &dwSize);
        if (lRet != ERROR_SUCCESS)
        {
            *pulInfoLevel = DEF_INFOLEVEL;
        }
        RegCloseKey(hKey);
    }
}

#endif // DBG == 1

// This wrapper function required to make prefast shut up when we are 
// initializing a critical section in a constructor.

void
ExceptionPropagatingInitializeCriticalSection(LPCRITICAL_SECTION critsec)
{
   __try
   {
      ::InitializeCriticalSection(critsec);
   }

   //
   // propagate the exception to our caller.  
   //
   __except (EXCEPTION_CONTINUE_SEARCH)
   {
   }
}


//+----------------------------------------------------------------------------
//
//  Function:   GetFilterEscapedValue
//
//  Synopsis:   This will take any value that is to be used in an LDAP search
//              filter and make sure that the special characters are escaped
//              per RFC 2254
//
//-----------------------------------------------------------------------------
void GetFilterEscapedValue(PCWSTR value, CStrW& filterEscapedValue)
{
   if (!value)
   {
      return;
   }

   filterEscapedValue.Empty();

   PCWSTR current = value;
   while (current &&
          *current != L'\0')
   {
      switch (*current)
      {
         case L'*':
            filterEscapedValue += L"\\2a";
            break;

         case L'(':
            filterEscapedValue += L"\\28";
            break;

         case L')':
            filterEscapedValue += L"\\29";
            break;

         case L'\\':
            filterEscapedValue += L"\\5c";
            break;

         default:
            filterEscapedValue += *current;
            break;
      }
      current++;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\notify.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       notify.h
//
//  Contents:   Change notification ref-counting object.
//
//  Classes:    CNotifyObj
//
//  History:    20-Jan-98 EricB
//
//-----------------------------------------------------------------------------

/*+----------------------------------------------------------------------------
Property page startup and communication architecture

Caller creates a data object with the DSOBJECTNAMES clip format which names
the DS object. Caller then creates the CLSID_DsPropertyPages object and passes
in the data object pointer with the call to IShellExtInit::Initialize. The
object that implements this class is known as the tab collector. It is in
dsuiext.dll

The caller then calls IShellPropSheetExt::AddPages. The tab collector's
AddPages code reads the Display Specifier for the DS object's class. The
Display Specifier lists the CLSIDs for the COM objects that implement the
pages. AddPages then does a create on each CLSID, and for each calling the
Initialize and AddPages methods.

This iteration of the AddPages method is implemented by the CDsPropPagesHost
class. The host class reads a table to determine the pages to create for this
CLSID. Each page is created (via CreatePropertySheetPage) in the AddPages
method and the page handle is passed back to the original caller via the
AddPages callback parameter. The original caller builds an array of pages
handles and creates the sheet once its call of AddPages returns.

A mechanism is needed for operations that span all the pages of a sheet. These
operations include
a) binding to the DS object and retrieving the set of attributes that are
   needed by all pages,
b) handling errors due to the inability to bind to or fetch attributes from an
   object,
c) firing a single change notification back to the caller when an Apply is
   made,
d) responding to queries for sheet exclusivity,
e) sending a notification back to the caller when the sheet is closed.
The number and order of pages in a sheet is determined by the set of CLSIDs in
the display specifier. The display specifier is user modifiable. Because of
this, a hard-coded scheme that makes assumptions about the order and number of
pages cannot be used for the page-spanning operations enumerated above. Thus a
separate object, called the notification object, is created at sheet creation
time. The pages communicate with the notification object using window messages.
The notification object has a hidden window, a window proceedure, and a message
pump running on its own thread.

One then must ask: when does the notification window get created and when is it
destroyed? The creation will be in CDsPropPagesHost's implementation of
Initialize. The destruction will be signalled by a send message from the pages'
callback function.

The notify creation function will do a FindWindow looking for the notification
window. If not found, it will create it. During the notify object's creation it
will bind to the DS object and request the cn and allowedAttributesEffective
properties. The window's handle will then be returned to the Initialize
function so that the resultant pages can communicate with it. If the
notification object/window cannot be created, then an error will be returned
to the Initialize method which will in turn return the error to the original
caller. The caller should then abort the property display and should report a
catastrophic failure to the user. If the notification object is successfully
created, but the initial attributes cannot be fetched from the DS object, then
an internal error variable will be set in the notify object although it's
creation function will return a success code.

As the individual pages initialize, they will send a message asking for the
ADSI object pointer, the CN, and the effective-attributes list. An error code
will be returned instead if the bind/fetch failed. The page init code will
report this error to the user by substituting an error page for the property
page. This is done at page object initialization time (CDsPropPageBase::Init).
This is before the CreatePropertySheetPage call is made allowing the
substitution of an error page.

typedef struct {
    DWORD              dwSize;          // Set this to the size of the struct.
    DWORD              dwFlags;         // Reserved for future use.
    HRESULT            hr;              // If this is non-zero, then the others
    IDirectoryObject * pDsObj;          // should be ignored.
    LPCWSTR            pwzCN;
    PADS_ATTR_INFO     pWritableAttrs;
} ADSPROPINITPARAMS, * PADSPROPINITPARAMS;

#define WM_ADSPROP_NOTIFY_PAGEINIT
// where LPARAM is the PADSPROPINITPARAMS pointer.

Each page checks its list of attributes against those in the
allowedAttributesEffective array. If an attribute is found in the allowed
list, then it is marked as writable and its corresponding control will be
enabled. If an attribute is set to be un-readable but writable for that user
(an unusual but legal situation), the LDAP read will silently fail so that no
value will be placed in the dialog control, but the control will be left
enabled. Thus the user could unwittingly overwrite an existing value.
Consequently it is not a good idea to grant a user write permission but revoke
read permission on an attribute unless the above behavior is explicitly
intended. Here is the struct that will be used to mark attributes as
writable:

typedef struct {
    BOOL    fWritable;
    PVOID   pAttrData;
} ATTR_DATA, * PATTR_DATA;

An array of these structures will be allocated for each page with one element
per attribute. The ordering will be the same as the table of attributes for the
page.
Methods to check writability:

HRESULT CDsPropPageBase::CheckIfWritable(PATTR_DATA rgAttrData,
                                         PATTR_MAP * rgAttrMap,
                                         DWORD cAttrs,
                                         PADS_ATTR_INFO pWritableAttrs);

BOOL CDsPropPageBase::CheckIfWritable(const PWSTR & wzAttr);

Another private message will be used to pass the page's window handle to the
notify object. The notify object needs to know the property sheet's window
handle, which it can get by calling GetParent on the passed page handle. This
message is sent by each page's WM_DLGINIT function. The notify object's page
count will be incremented at this time.

#define WM_ADSPROP_NOTIFY_PAGEHWND
// where WPARAM => page's HWND

-----------------------------------------------------------------------------*/

#ifndef _NOTIFY_H_
#define _NOTIFY_H_

#include <propcfg.h> // DS Admin definition of PPROPSHEETCFG
#include <adsprop.h>

const TCHAR tzNotifyWndClass[] = TEXT("DsPropNotifyWindow");

#define DSPROP_TITLE_LEN 16

extern "C" BOOL IsSheetAlreadyUp(LPDATAOBJECT);
extern "C" BOOL BringSheetToForeground(PWSTR, BOOL);

VOID __cdecl NotifyThreadFcn(PVOID);
BOOL FindSheet(PWSTR);
HWND FindSheetNoSetFocus(PWSTR);
VOID RegisterNotifyClass(void);

#ifndef DSPROP_ADMIN

//+----------------------------------------------------------------------------
//
//  Class:      CNotifyCreateCriticalSection
//
//  Purpose:    Prevents creation race conditions. Without this protection,
//              a second call to CNotifyObj::Create that comes in before the
//              first has created the hidden window will get NULL back from
//              FindSheetNoSetFocus and then go on to create a second hidden
//              window.
//
//-----------------------------------------------------------------------------
class CNotifyCreateCriticalSection
{
public:
    CNotifyCreateCriticalSection();
    ~CNotifyCreateCriticalSection();
};

#endif // DSPROP_ADMIN

#endif // _NOTIFY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\objlist.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       objlist.h
//
//  Contents:   DS object list object header
//
//  Classes:    
//
//  History:    20-Nov-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _OBJLIST_H_
#define _OBJLIST_H_

//#include <cdlink.hxx>

//+----------------------------------------------------------------------------
//
//  Class:      CMemberListItem
//
//  Purpose:    membership list data item.
//
//-----------------------------------------------------------------------------
class CMemberListItem : public CDLink
{
public:
    CMemberListItem(void) : m_pwzDN(NULL), m_ptzName(NULL), m_pSid(NULL),
                            m_fSidSet(FALSE), m_fCanBePrimarySet(FALSE),
                            m_fCanBePrimary(FALSE), m_fIsPrimary(FALSE),
                            m_fIsAlreadyMember(FALSE), m_fIsExternal(FALSE),
                            m_ulScopeType(0) {};
    ~CMemberListItem(void) {DO_DEL(m_pwzDN);
                            DO_DEL(m_ptzName);
                            DO_DEL(m_pSid);};
    // CDLink method overrides:
    CMemberListItem   * Next(void) {return (CMemberListItem *)CDLink::Next();};

    CMemberListItem   * Copy(void);
    BOOL                IsSidSet(void) {return m_fSidSet;};
    BOOL                IsCanBePrimarySet(void) {return m_fCanBePrimarySet;};
    BOOL                CanBePrimary(void) {return m_fCanBePrimary;};
    void                SetCanBePrimary(BOOL fCanBePrimary)
                        {
                            m_fCanBePrimary = fCanBePrimary;
                            m_fCanBePrimarySet = TRUE;
                        };
    BOOL                SetSid(PSID pSid);
    PSID                GetSid(void) {return m_pSid;};
    BOOL                IsPrimary(void) {return m_fIsPrimary;};

    PWSTR   m_pwzDN;
    PTSTR   m_ptzName;
    PSID    m_pSid;
    ULONG   m_ulScopeType;
    BOOL    m_fSidSet;
    BOOL    m_fCanBePrimarySet;
    BOOL    m_fCanBePrimary;
    BOOL    m_fIsPrimary;
    BOOL    m_fIsAlreadyMember;
    BOOL    m_fIsExternal;      // member is from an external domain and is
                                // identified using the SID.
};

//+----------------------------------------------------------------------------
//
//  Class:      CMemberLinkList
//
//  Purpose:    Linked list of membership class objects.
//
//-----------------------------------------------------------------------------
class CMemberLinkList
{
public:
    CMemberLinkList(void) : m_pListHead(NULL) {};
    ~CMemberLinkList(void);

    CMemberListItem   * FindItemRemove(PWSTR pwzDN);
    CMemberListItem   * FindItemRemove(PSID pSid);
    CMemberListItem   * RemoveFirstItem(void);
    BOOL                AddItem(CMemberListItem * pItem, BOOL fMember = TRUE);
    int                 GetItemCount(void);

private:
    CMemberListItem   * m_pListHead;
};

const int IDX_NAME_COL = 0;
const int IDX_FOLDER_COL = 1;
const int IDX_ERROR_COL = 1;
const int OBJ_LIST_NAME_COL_WIDTH = 100;
const int OBJ_LIST_PAGE_COL_WIDTH = 72;

//+----------------------------------------------------------------------------
//
//  Class:      CDsObjList
//
//  Purpose:    Base class for DS object lists that employ a two column
//              list view to show object Name and Folder.
//
//-----------------------------------------------------------------------------
class CDsObjList
{
public:
    CDsObjList(HWND hPage, int idList);
    ~CDsObjList(void);

    HRESULT Init(BOOL fShowIcons = FALSE);
    HRESULT InsertIntoList(PTSTR ptzDisplayName, PVOID pData, int iIcon = -1);
    HRESULT GetItem(int index, PTSTR * pptzName, PVOID * ppData);
    BOOL    GetCurListItem(int * pIndex, PTSTR * pptzName, PVOID * ppData);
    BOOL    GetCurListItems(int ** ppIndex, PTSTR ** ppptzName, PVOID ** pppData, int* pNumSelected);
    virtual BOOL RemoveListItem(int Index);
    int     GetCount(void) {return ListView_GetItemCount(m_hList);};
    UINT    GetSelectedCount(void) { return ListView_GetSelectedCount(m_hList);}
    virtual void ClearList(void) = 0;

protected:
    HWND    m_hPage;
    HWND    m_hList;
    int     m_idList;
    int     m_nCurItem;
    BOOL    m_fShowIcons;
    BOOL    m_fLimitExceeded;
};

void GetNameParts(const CStr& cstrCanonicalNameEx, CStr& cstrFolder, CStr & cstrName);

//+----------------------------------------------------------------------------
//
//  Class:      CDsMembershipList
//
//  Purpose:    Membership list class for the list-view control.
//
//-----------------------------------------------------------------------------
class CDsMembershipList : public CDsObjList
{
public:
    CDsMembershipList(HWND hPage, int idList) : CDsObjList(hPage, idList) {};
    ~CDsMembershipList(void) {};

    HRESULT InsertIntoList(PTSTR ptzDisplayName, PVOID pData, int iIcon = -1)
                {return CDsObjList::InsertIntoList(ptzDisplayName, pData, iIcon);};

    HRESULT InsertIntoList(PWSTR pwzPath, int iIcon = -1)
                {return CDsMembershipList::InsertIntoList(pwzPath, iIcon, FALSE, FALSE,
                                                          FALSE, FALSE, 0);};

    HRESULT InsertIntoNewList(PWSTR pwzPath, BOOL fPrimary = FALSE)
                {return CDsMembershipList::InsertIntoList(pwzPath, -1, TRUE,
                                                          fPrimary, FALSE, TRUE, 0);};

    HRESULT InsertIntoList(PWSTR pwzPath, int iIcon, BOOL fAlreadyMember, BOOL fPrimary,
                           BOOL fIgnoreDups, BOOL fDontChkDups, ULONG flScopeType);

    HRESULT InsertIntoList(PSID pSid, PWSTR pwzPath);

    HRESULT InsertIntoList(CMemberListItem * pItem);

    HRESULT InsertExternalIntoList(PWSTR pwzPath, ULONG ulScopeType)
                {return CDsMembershipList::InsertIntoList(pwzPath, -1, FALSE,
                                                          FALSE, FALSE,
                                                          FALSE, ulScopeType);};
    HRESULT MergeIntoList(PWSTR pwzPath)
                {return CDsMembershipList::InsertIntoList(pwzPath, -1, TRUE, FALSE, TRUE, FALSE, 0);};

    HRESULT GetItem(int index, CMemberListItem ** ppData)
                {return CDsObjList::GetItem(index, NULL, (PVOID *)ppData);};

    BOOL    GetCurListItem(int * pIndex, PTSTR * pptzName, CMemberListItem ** ppData)
                {return CDsObjList::GetCurListItem(pIndex, pptzName, (PVOID *)ppData);};

    BOOL    GetCurListItems(int ** ppIndex, PTSTR ** ppptzName, CMemberListItem *** pppData, int* pNumSelected)
                {return CDsObjList::GetCurListItems(ppIndex, ppptzName, (PVOID **)pppData, pNumSelected);};

    int     GetIndex(LPCWSTR pwzDN, ULONG ulStart, ULONG ulEnd);

    BOOL    RemoveListItem(int Index);
    void    ClearList(void);

    HRESULT SetMemberIcons(CDsPropPageBase * pPage);
};

struct CLASS_CACHE_ENTRY
{
    WCHAR   wzClass[MAX_PATH];
    int     iIcon;
    int     iDisabledIcon;
};

#define ICON_CACHE_NUM_CLASSES  6

//+--------------------------------------------------------------------------
//
//  Class:      CClassIconCache
//
//  Purpose:    Build an image list for well known DS classes and map the
//              image indices to the class names.
//
//  Notes:      CAUTION: the imagelist is destroyed in the dtor, therefore
//              it should only be used with listview controls that have
//              the LVS_SHAREIMAGELISTS style set.
//
//---------------------------------------------------------------------------
class CClassIconCache
{
public:

  CClassIconCache(void);

 ~CClassIconCache(void);

  int GetClassIconIndex(PCWSTR pwzClass, BOOL fDisabled = FALSE);
  int AddClassIcon(PCWSTR pwzClass, BOOL fDisabled = FALSE);

  HIMAGELIST GetImageList(void);

  void ClearAll();
private:

  HRESULT Initialize(void);

  BOOL                m_fInitialized;
  CLASS_CACHE_ENTRY*  m_prgcce;
  UINT                m_nImageCount;
  HIMAGELIST          m_hImageList;
};

extern CClassIconCache g_ClassIconCache;

#endif // _OBJLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\objlist.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       objlist.cxx
//
//  Contents:   Link-lists of objects and list-view controls displaying objects.
//
//  History:    20-Nov-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "objlist.h"

CClassIconCache g_ClassIconCache;

//+----------------------------------------------------------------------------
//
//  Class:      CMemberLinkList
//
//  Purpose:    Linked list of membership class objects.
//
//-----------------------------------------------------------------------------
CMemberLinkList::~CMemberLinkList(void)
{
    CMemberListItem * pItem = m_pListHead, * pNext;

    while (pItem)
    {
        pNext = pItem->Next();
        delete pItem;
        pItem = pNext;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CMemberLinkList::FindItemRemove
//
//  Synopsis:   Search for an element with a matching DN and, if found, remove
//              it from the list and return its pointer. Returns NULL if not
//              found.
//
//-----------------------------------------------------------------------------
CMemberListItem *
CMemberLinkList::FindItemRemove(PWSTR pwzDN)
{
    CMemberListItem * pItem = m_pListHead;

    while (pItem)
    {
        dspAssert(pItem->m_pwzDN);

        if (_wcsicmp(pItem->m_pwzDN, pwzDN) == 0)
        {
            if (pItem->Prev() == NULL)
            {
                // this item is the list head.
                //
                m_pListHead = pItem->Next();
            }
            pItem->UnLink();
            return pItem;
        }
        pItem = pItem->Next();
    }
    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Method:     CMemberLinkList::FindItemRemove
//
//  Synopsis:   Search for an element with a matching SID and, if found, remove
//              it from the list and return its pointer. Returns NULL if not
//              found.
//
//-----------------------------------------------------------------------------
CMemberListItem *
CMemberLinkList::FindItemRemove(PSID pSid)
{
    CMemberListItem * pItem = m_pListHead;

    while (pItem)
    {
        dspAssert(pItem->m_pwzDN);

        if (pItem->m_pSid && EqualSid(pItem->m_pSid, pSid))
        {
            if (pItem->Prev() == NULL)
            {
                // this item is the list head.
                //
                m_pListHead = pItem->Next();
            }
            pItem->UnLink();
            return pItem;
        }
        pItem = pItem->Next();
    }
    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Method:     CMemberLinkList::RemoveFirstItem
//
//  Synopsis:   Remove the first item from the list.
//
//-----------------------------------------------------------------------------
CMemberListItem *
CMemberLinkList::RemoveFirstItem(void)
{
    CMemberListItem * pItem = m_pListHead;

    if (pItem)
    {
        m_pListHead = pItem->Next();
        pItem->UnLink();
        return pItem;
    }
    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Method:     CMemberLinkList::AddItem
//
//  Synopsis:   Insert an item into the list.
//
//-----------------------------------------------------------------------------
BOOL
CMemberLinkList::AddItem(CMemberListItem * pItem, BOOL fMember)
{
    if (!pItem->m_fIsAlreadyMember)
    {
        return TRUE;
    }
    CMemberListItem * pItemCopy;

    if (m_pListHead == NULL)
    {
        pItemCopy = pItem->Copy();

        CHECK_NULL(pItemCopy, return FALSE);

        pItemCopy->m_fIsAlreadyMember = fMember;

        m_pListHead = pItemCopy;
    }
    else
    {
        CMemberListItem * pCur = m_pListHead;
        //
        // Make sure the item isn't already in the list.
        //
        while (pCur)
        {
            dspAssert(pCur->m_pwzDN);

            if (_wcsicmp(pCur->m_pwzDN, pItem->m_pwzDN) == 0)
            {
                return TRUE;
            }
            pCur = pCur->Next();
        }

        pItemCopy = pItem->Copy();

        CHECK_NULL(pItemCopy, return FALSE);

        pItemCopy->m_fIsAlreadyMember = fMember;

        pItemCopy->LinkAfter(m_pListHead);
    }
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CMemberLinkList::GetItemCount
//
//  Synopsis:   Return the count of elements in the list.
//
//-----------------------------------------------------------------------------
int
CMemberLinkList::GetItemCount(void)
{
    int cItem = 0;
    CMemberListItem * pItem = m_pListHead;

    while (pItem)
    {
        cItem++;
        pItem = pItem->Next();
    }
    return cItem;
}

//+----------------------------------------------------------------------------
//
//  Class:      CDsObjList
//
//  Purpose:    Base class for DS object lists that employ a two column
//              list view to show object Name and Folder.
//
//-----------------------------------------------------------------------------
CDsObjList::CDsObjList(HWND hPage, int idList) :
    m_hPage(hPage),
    m_idList(idList),
    m_nCurItem(0),
    m_fShowIcons(FALSE),
    m_fLimitExceeded(FALSE)
{
}

CDsObjList::~CDsObjList(void)
{
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsObjList::Init
//
//  Synopsis:   Initialize the list view, add its columns.
//
//-----------------------------------------------------------------------------
HRESULT
CDsObjList::Init(BOOL fShowIcons)
{
    m_fShowIcons = fShowIcons;

    m_hList = GetDlgItem(m_hPage, m_idList);

    if (m_hList == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    ListView_SetExtendedListViewStyle(m_hList, LVS_EX_FULLROWSELECT);
    //
    // Set the column headings.
    //
    PTSTR ptsz;
    RECT rect;
    GetClientRect(m_hList, &rect);

    if (!LoadStringToTchar(IDS_COL_TITLE_OBJNAME, &ptsz))
    {
        ReportError(GetLastError(), 0, m_hPage);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    LV_COLUMN lvc = {0};
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = OBJ_LIST_NAME_COL_WIDTH;
    lvc.pszText = ptsz;
    lvc.iSubItem = IDX_NAME_COL;

    ListView_InsertColumn(m_hList, IDX_NAME_COL, &lvc);

    delete ptsz;

    if (!LoadStringToTchar(IDS_COL_TITLE_OBJFOLDER, &ptsz))
    {
        ReportError(GetLastError(), 0, m_hPage);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    lvc.cx = rect.right - OBJ_LIST_NAME_COL_WIDTH;
    lvc.pszText = ptsz;
    lvc.iSubItem = IDX_FOLDER_COL;

    ListView_InsertColumn(m_hList, IDX_FOLDER_COL, &lvc);

    delete ptsz;

    if (m_fShowIcons)
    {
        // Assign the imagelist to the listview
        //
        ListView_SetImageList(m_hList,
                              g_ClassIconCache.GetImageList(),
                              LVSIL_SMALL);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     GetNameParts
//
//  Synopsis:   The folder path and object name should be separated by a
//              newline character. Return a pointer to the name and allocate
//              a buffer for the folder part. Return NULL for the folder part
//              if a newline is not found. No folder is returned if the input
//              pointer pcstrFolder is NULL.
//
//-----------------------------------------------------------------------------
void
GetNameParts(const CStr& cstrCanonicalNameEx, CStr& cstrFolder, CStr & cstrName)
{
    int nCR = cstrCanonicalNameEx.Find(TEXT('\n'));

    if (-1 != nCR)
    {
        cstrFolder = cstrCanonicalNameEx.Left(nCR);

        CStr remaining = cstrCanonicalNameEx.Right(cstrCanonicalNameEx.GetLength() - nCR - 1);

        // Remove any escaping from the name
        //
        int nBackSlash;

        while ((nBackSlash = remaining.Find(TEXT('\\'))) != -1)
        {
            CStr cstrTemp = remaining.Left(nBackSlash);
            if (remaining.GetAt(nBackSlash + 1) == TEXT('\\'))
            {
               cstrTemp += remaining.GetAt(nBackSlash + 1);
               ++nBackSlash;
            }

            cstrName += cstrTemp;

            int count = remaining.GetLength() - nBackSlash - 1;
            if (count > 0)
            {
               remaining = remaining.Right(remaining.GetLength() - nBackSlash - 1);
            }
            else
            {
               // the last character must have been a backslash so just break so
               // that we don't have an infinite loop
          
               remaining = L"";
               break;
            }

        }
        cstrName += remaining;
    }
    else
    {
        cstrName = cstrCanonicalNameEx;
        cstrFolder.Empty();
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsObjList::InsertIntoList
//
//  Synopsis:   Insert the item into the listview control.
//
//-----------------------------------------------------------------------------
HRESULT
CDsObjList::InsertIntoList(PTSTR ptzDisplayName, PVOID pData, int iIcon)
{
    HRESULT hr = S_OK;

    //
    // The name and folder should be separated by a new line character.
    //
    CStr cstrFolder, cstrName;
    CStr cstrDisplayName = ptzDisplayName;

    GetNameParts(cstrDisplayName, cstrFolder, cstrName);

    CHECK_HRESULT(hr, return hr);

    LV_ITEM lvi = {0};
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iSubItem = IDX_NAME_COL;

    lvi.pszText = const_cast<PTSTR>((LPCTSTR)cstrName);
    lvi.lParam = (LPARAM)pData;
    lvi.iItem = m_nCurItem;

    if (-1 != iIcon)
    {
        lvi.mask |= LVIF_IMAGE;
        // if the limit is exceeded use the default icon.
        lvi.iImage = (m_fLimitExceeded) ? 0 : iIcon;
    }

    int NewIndex = ListView_InsertItem(m_hList, &lvi);

    dspAssert(NewIndex != -1);

    if (!cstrFolder.IsEmpty())
    {
        ListView_SetItemText(m_hList, NewIndex, IDX_FOLDER_COL,
                             const_cast<PTSTR>((LPCTSTR)cstrFolder));

        //delete ptzFolder;
    }

    m_nCurItem++;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsObjList::GetItem
//
//  Synopsis:   Returns the name and item data for the indicated item. Any of
//              the input pointers can be NULL to skip that parameter.
//
//-----------------------------------------------------------------------------
HRESULT
CDsObjList::GetItem(int index, PTSTR * pptzName, PVOID * ppData)
{
    TCHAR tzBuf[256];
    LV_ITEM lvi;
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = index;
    lvi.iSubItem = IDX_NAME_COL;
    lvi.pszText = tzBuf;
    lvi.cchTextMax = 256;

    if (!ListView_GetItem(m_hList, &lvi))
    {
        return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
    }

    if (pptzName)
    {
        if (lvi.pszText)
        {
            *pptzName = new TCHAR[_tcslen(lvi.pszText) + 1];

            CHECK_NULL_REPORT(*pptzName, m_hPage, return FALSE);

            _tcscpy(*pptzName, lvi.pszText);
        }
        else
        {
            *pptzName = NULL;
        }
    }
    if (ppData)
    {
        *ppData = (PVOID)lvi.lParam;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsObjList::GetCurListItem
//
//  Synopsis:   Returns the index, name (in an allocated buffer), and pointer
//              to the item data. Any of the input pointers can be NULL to skip
//              that parameter.
//
//-----------------------------------------------------------------------------
BOOL
CDsObjList::GetCurListItem(int * pIndex, PTSTR * pptzName, PVOID * ppData)
{
  int i = ListView_GetNextItem(m_hList, -1, LVNI_SELECTED);

  if (i < 0)
  {
    dspDebugOut((DEB_ITRACE, "DsProp: no list selection.\n"));
    return FALSE;
  }

  HRESULT hr = GetItem(i, pptzName, ppData);

  if (FAILED(hr))
  {
    dspAssert(FALSE);
    return FALSE;
  }

  if (pIndex)
  {
    *pIndex = i;
  }

  return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsObjList::GetCurListItems
//
//  Synopsis:   Returns an array of indexes, names (in an allocated buffers), and pointers
//              to the items data. Any of the input pointers can be NULL to skip
//              that parameter.
//
//  History:    2002/07/05-ArtM     Rewrote to fix NTRAID#NTBUG9-655550 and remove memory leaks.
//
//-----------------------------------------------------------------------------
BOOL
CDsObjList::GetCurListItems(int ** ppIndex, PTSTR ** ppptzName, PVOID ** pppData, int* pNumSelected)
{
  int iStartPoint = -1;
  int i = -1;
  UINT nSelected = ListView_GetSelectedCount(m_hList);
  HRESULT hr = S_OK;
  BOOL fRetrievedItems = TRUE;

  if (ppIndex)
  {
    *ppIndex = new int[nSelected];
    CHECK_NULL(*ppIndex, hr = E_OUTOFMEMORY);
  }
  if (ppptzName)
  {
    *ppptzName = new PTSTR[nSelected];
    CHECK_NULL(*ppptzName, hr = E_OUTOFMEMORY);
  }
  if (pppData)
  {
    *pppData = new PVOID[nSelected];
    CHECK_NULL(*pppData, hr = E_OUTOFMEMORY);
  }

  for (UINT idx = 0; SUCCEEDED(hr) && idx < nSelected; idx++)
  {
    i = ListView_GetNextItem(m_hList, iStartPoint, LVNI_SELECTED);

    if (i < 0)
    {
      dspDebugOut((DEB_ITRACE, "DsProp: no list selection.\n"));
      fRetrievedItems = FALSE;
      break;
    }

    hr = GetItem(
      i, 
      (ppptzName != NULL) ? &((*ppptzName)[idx]) : NULL,
      (pppData != NULL) ? &((*pppData)[idx]) : NULL );

    if (FAILED(hr))
    {
      dspAssert(FALSE);
      fRetrievedItems = FALSE;
      break;
    }

    iStartPoint = i;
    if (ppIndex)
    {
      (*ppIndex)[idx] = i;
    }
  }

  if (pNumSelected != NULL && fRetrievedItems && SUCCEEDED(hr))
  {
    *pNumSelected = nSelected;
  }

  // Clean up any memory allocated if retrieval failed.
  if (FAILED(hr) || !fRetrievedItems)
  {
    dspAssert(FALSE);
    if (ppIndex != NULL)
    {
      delete[] *ppIndex;
      *ppIndex = 0;
    }
    if (ppptzName != NULL)
    {
      delete[] *ppptzName;
      *ppptzName = 0;
    }
    if (pppData != NULL)
    {
      delete[] *pppData;
      *pppData = 0;
    }
  }

  return fRetrievedItems;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipList::InsertIntoList
//
//  Synopsis:   Insert the item into the listview control.
//
//  Arguments:  [pwzPath]        - object DN.
//              [iIcon]          - object icon, -1 means ignore.
//              [fAlreadyMember] - already member of group, not a new member in an add/apply-pending state.
//              [fPrimary]       - member by virtue of primaryGroupID attribute.
//              [fIgnoreDups]    - don't report error if already in list; used for merging in reverse membership.
//              [fDontChkDups]   - don't check for duplicates; used for initial listing of direct membership.
//
//-----------------------------------------------------------------------------
HRESULT
CDsMembershipList::InsertIntoList(PWSTR pwzPath, int iIcon, BOOL fAlreadyMember,
                                  BOOL fPrimary, BOOL fIgnoreDups,
                                  BOOL fDontChkDups, ULONG ulScopeType)
{
    HRESULT hr = S_OK, hrRet = S_OK;
    PWSTR pwzPathCopy = NULL, pwzCanEx = NULL;
    PTSTR ptzCanEx = NULL;
    CMemberListItem * pListItem = NULL;
    BOOL fCanBePrimary = FALSE;

    //
    // Convert the distinguished name to a more friendly variant for display
    // in the list.
    //
    if (DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN == ulScopeType)
    {
        if (!UnicodeToTchar(pwzPath, &ptzCanEx))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            hr = E_OUTOFMEMORY;
            goto ErrorCleanup;
        }
        PTSTR ptzSlash = _tcspbrk(ptzCanEx, TEXT("\\/"));
        if (ptzSlash)
        {
            *ptzSlash = TEXT('\n');
        }
    }
    else
    {
        hr = CrackName(pwzPath, &pwzCanEx, GET_OBJ_CAN_NAME_EX, m_hPage);

        if (DS_NAME_ERROR_NO_MAPPING == HRESULT_CODE(hr))
        {
            hrRet = MAKE_HRESULT(SEVERITY_ERROR, 0, DS_NAME_ERROR_NO_MAPPING);
            hr = S_OK;
        }
        CHECK_HRESULT(hr, goto ErrorCleanup);

        if (!UnicodeToTchar(pwzCanEx, &ptzCanEx))
        {
            LocalFreeStringW(&pwzCanEx);
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            hr = E_OUTOFMEMORY;
            goto ErrorCleanup;
        }
        LocalFreeStringW(&pwzCanEx);
    }

    if (!fDontChkDups)
    {
        //
        // Check to see if the item is already in the list.
        //
        LV_ITEM lvi;
        lvi.mask = LVIF_PARAM;
        lvi.iItem = 0;
        lvi.iSubItem = IDX_NAME_COL;

        while (ListView_GetItem(m_hList, &lvi))
        {
            pListItem = (CMemberListItem *)lvi.lParam;
            dspAssert(pListItem);

            if (_wcsicmp(pListItem->m_pwzDN, pwzPath) == 0)
            {
                if (fIgnoreDups)
                {
                    DO_DEL(ptzCanEx);
                    return S_OK;
                }

                CStr cstrName;
                CStr cstrCanEx = ptzCanEx;
                CStr cstrFolder;

                GetNameParts(cstrCanEx, cstrFolder, cstrName);

                ErrMsgParam(IDS_GRP_ALREADY_MEMBER,
                  reinterpret_cast<LPARAM>((LPCTSTR)cstrName), m_hPage);

                DO_DEL(ptzCanEx);
                return HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
            }
            lvi.iItem++;
        }
    }

    //
    // Put the item into the list.
    //
    pListItem = new CMemberListItem;

    CHECK_NULL_REPORT(pListItem, m_hPage, goto ErrorCleanup);

    if (!AllocWStr(pwzPath, &pwzPathCopy))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        hr = E_OUTOFMEMORY;
        goto ErrorCleanup;
    }

    pListItem->m_ptzName = ptzCanEx;
    pListItem->m_pwzDN = pwzPathCopy;
    pListItem->m_fIsAlreadyMember = fAlreadyMember;
    pListItem->m_fCanBePrimary = fCanBePrimary;
    pListItem->m_fIsPrimary = fPrimary;
    pListItem->m_ulScopeType = ulScopeType;

    hr = CDsObjList::InsertIntoList(ptzCanEx, pListItem, iIcon);

    CHECK_HRESULT(hr, goto ErrorCleanup);

    return hrRet;

ErrorCleanup:

    DO_DEL(pwzPathCopy);
    DO_DEL(ptzCanEx);
    DO_DEL(pListItem);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipList::InsertIntoList
//
//  Synopsis:   Insert the item into the listview control. This method uses
//              the object-SID to identify the new group member which in this
//              case is from an external domain.
//
//  Arguments:  [pSid]    - a binary SID.
//              [pwzPath] - an object name in WINNT format (domain\name or
//                          domain/name).
//
//-----------------------------------------------------------------------------
HRESULT
CDsMembershipList::InsertIntoList(PSID pSid, PWSTR pwzPath)
{
    HRESULT hr;
    PTSTR ptzCanEx, ptzSlash;
    CMemberListItem * pListItem = NULL;

    if (!UnicodeToTchar(pwzPath, &ptzCanEx))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        return E_OUTOFMEMORY;
    }

    ptzSlash = _tcspbrk(ptzCanEx, TEXT("\n"));

    if (!ptzSlash)
    {
        ptzSlash = _tcspbrk(ptzCanEx, TEXT("/\\"));

        dspAssert(ptzSlash);

        if (ptzSlash)
        {
            *ptzSlash = TEXT('\n');
        }
    }

    //
    // Check to see if the item is already in the list. Use the display name
    // (canonical name) rather than the DN since the DN of an existing external
    // domain group member will be different from the initial path name (the
    // <SID=01050xxx> name).
    //
    LV_ITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = 0;
    lvi.iSubItem = IDX_NAME_COL;

    while (ListView_GetItem(m_hList, &lvi))
    {
        pListItem = (CMemberListItem *)lvi.lParam;
        dspAssert(pListItem);

        if (_tcsicmp(pListItem->m_ptzName, ptzCanEx) == 0)
        {
            CStr cstrName;
            CStr cstrCanEx = ptzCanEx;
            CStr cstrFolder;

            GetNameParts(cstrCanEx, cstrFolder, cstrName);

            ErrMsgParam(IDS_GRP_ALREADY_MEMBER,
                        reinterpret_cast<LPARAM>((LPCTSTR)cstrName), m_hPage);

            DO_DEL(ptzCanEx);
            return HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
        }
        lvi.iItem++;
    }

    //
    // Put the item into the list.
    //
    pListItem = new CMemberListItem;

    CHECK_NULL_REPORT(pListItem, m_hPage, return E_OUTOFMEMORY);

    PWSTR pwzSidPath;
    CStrW strSIDname;

    ConvertSidToPath(pSid, strSIDname);

    if (!AllocWStr(const_cast<PWSTR>((LPCWSTR)strSIDname), &pwzSidPath))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        hr = E_OUTOFMEMORY;
        goto ErrorCleanup;
    }

    pListItem->m_ptzName = ptzCanEx;
    pListItem->m_pwzDN = pwzSidPath;
    pListItem->m_fIsExternal = TRUE;
    pListItem->SetSid(pSid);

    hr = CDsObjList::InsertIntoList(ptzCanEx, pListItem);

    CHECK_HRESULT(hr, goto ErrorCleanup);

    return S_OK;

ErrorCleanup:

    DO_DEL(pwzSidPath);
    DO_DEL(ptzCanEx);
    DO_DEL(pListItem);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipList::InsertIntoList
//
//  Synopsis:   Insert the item into the listview control.
//
//-----------------------------------------------------------------------------
HRESULT
CDsMembershipList::InsertIntoList(CMemberListItem * pItem)
{
    HRESULT hr = S_OK;
    PWSTR pwzCanEx = NULL;
    PTSTR ptzCanEx = NULL;

    //
    // Convert the 1779 name to a more friendly variant for display
    // in the list.
    //
    hr = CrackName(pItem->m_pwzDN, &pwzCanEx, GET_OBJ_CAN_NAME_EX, m_hPage);

    CHECK_HRESULT(hr, goto ErrorCleanup);

    if (!UnicodeToTchar(pwzCanEx, &ptzCanEx))
    {
        LocalFreeStringW(&pwzCanEx);
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        hr = E_OUTOFMEMORY;
        goto ErrorCleanup;
    }
    LocalFreeStringW(&pwzCanEx);

    hr = CDsObjList::InsertIntoList(ptzCanEx, pItem);

    CHECK_HRESULT(hr, goto ErrorCleanup);

    return S_OK;

ErrorCleanup:

    DO_DEL(ptzCanEx);
    DO_DEL(pItem);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsObjList::RemoveListItem
//
//  Synopsis:   Removes the indicated list item.
//
//-----------------------------------------------------------------------------
BOOL
CDsObjList::RemoveListItem(int Index)
{
    if (!ListView_DeleteItem(m_hList, Index))
    {
        REPORT_ERROR(GetLastError(), m_hPage);
        return FALSE;
    }

    m_nCurItem--;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipList::RemoveListItem
//
//  Synopsis:   Removes the indicated list item, deleting the item data obj.
//
//-----------------------------------------------------------------------------
BOOL
CDsMembershipList::RemoveListItem(int Index)
{
    CMemberListItem * pItem;
    LV_ITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = Index;
    lvi.iSubItem = IDX_NAME_COL;

    if (!ListView_GetItem(m_hList, &lvi))
    {
        dspAssert(FALSE);
        return FALSE;
    }

    pItem = (CMemberListItem *)lvi.lParam;
    if (pItem)
    {
        delete pItem;
    }

    if (!ListView_DeleteItem(m_hList, Index))
    {
        REPORT_ERROR(GetLastError(), m_hPage);
        return FALSE;
    }

    m_nCurItem--;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipList::ClearList
//
//  Synopsis:   Remove all list items, freeing memory.
//
//-----------------------------------------------------------------------------
void
CDsMembershipList::ClearList(void)
{
    CMemberListItem * pItem;
    LV_ITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = 0;
    lvi.iSubItem = IDX_NAME_COL;

    while (ListView_GetItem(m_hList, &lvi))
    {
        pItem = (CMemberListItem *)lvi.lParam;
        if (pItem)
        {
            delete pItem;
        }
        lvi.iItem++;
    }

    ListView_DeleteAllItems(m_hList);

    m_nCurItem = 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipList::GetIndex
//
//  Synopsis:   Find the list entry whose DN matches and return the index.
//
//  Arguments:  [pwzDN]   - DN to match, matches only first instance.
//              [ulStart] - Index on which to start search.
//              [ulEnd]   - Search end index. If zero or less than ulStart,
//                          search to the end of the list.
//
//-----------------------------------------------------------------------------
int
CDsMembershipList::GetIndex(LPCWSTR pwzDN, ULONG ulStart, ULONG ulEnd)
{
    int i = ulStart;
    CMemberListItem * pItem;

    while (TRUE)
    {
        if (FAILED(GetItem(i, &pItem)))
        {
            return -1;
        }
        if (_wcsicmp(pwzDN, pItem->m_pwzDN) == 0)
        {
            return i;
        }
        if (ulEnd && (ULONG)i >= ulEnd)
        {
            return -1;
        }
        i++;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipList::SetMemberIcons
//
//  Synopsis:   Query the DS for the class and userAccountControl of the list's
//              members. Use the returned info to select an icon for each item.
//
//-----------------------------------------------------------------------------
HRESULT
CDsMembershipList::SetMemberIcons(CDsPropPageBase *pPage)
{
    HRESULT hr = S_OK;

    //
    // Just put this here so /W4 doesn't complain when compiling for Win9x
    //
    pPage;

    if (0 == g_ulMemberFilterCount)
    {
        return S_OK;
    }

    if ((ULONG)GetCount() > g_ulMemberQueryLimit)
    {
        m_fLimitExceeded = TRUE;
        return S_OK;
    }

#if defined (DSADMIN)

    CComPtr <IDirectorySearch> spDsSearch;
    CSmartWStr cswzCleanObj;
    PWSTR pwzDnsDom;

    hr = pPage->SkipPrefix(pPage->GetObjPathName(), &cswzCleanObj);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);
    //
    // To bind to a GC, you need to supply the domain name rather than the
    // server path because the current DC may not be hosting a GC.
    //
    hr = CrackName(cswzCleanObj, &pwzDnsDom, GET_DNS_DOMAIN_NAME, pPage->GetHWnd());

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    hr = DSPROP_GetGCSearchOnDomain(pwzDnsDom,
                                    IID_IDirectorySearch,
                                    (PVOID*)&spDsSearch);
    LocalFreeStringW(&pwzDnsDom);

    if (S_OK != hr)
    {
        if (S_FALSE == hr ||
            HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN) == hr)
        {
            ErrMsg(IDS_WARN_NO_GC_FOUND, pPage->GetHWnd());
        }
        else if (HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE) == hr)
        {
            ErrMsg(IDS_WARN_ACCESS_TO_GC_DENIED, pPage->GetHWnd());
        }
        else
        {
            CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(),;);
        }
        return hr;
    }

    CStrW csFilter = L"(|", csClass, csClause;
    CMemberListItem * pItem;
    ULONG i, ulStart = 0, ulEnd;
    ADS_SEARCHPREF_INFO SearchPref;
    WCHAR wzSearchFormat[] = L"(%s=%s)";
    PWSTR pwzAttrNames[] = {g_wzDN, g_wzObjectClass, g_wzUserAccountControl};

    SearchPref.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPref.vValue.Integer = ADS_SCOPE_SUBTREE;
    SearchPref.vValue.dwType = ADSTYPE_INTEGER;

    hr = spDsSearch->SetSearchPreference(&SearchPref, 1);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    while (TRUE)
    {
        ulEnd = ulStart + g_ulMemberFilterCount;

        for (i = ulStart; i < ulEnd; i++)
        {
            if (GetItem(i, &pItem) == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
            {
                // End Of List, reset end counter.
                //
                ulEnd = i;
                break;
            }
    
            CStrW filterEscapedValue;
            GetFilterEscapedValue(pItem->m_pwzDN, filterEscapedValue);

            csClause.Format(wzSearchFormat, g_wzDN, (LPCWSTR)filterEscapedValue);

            csFilter += csClause;
        }

        csFilter += L")";

        ADS_SEARCH_HANDLE hSrch = NULL;
        dspDebugOut((DEB_USER14 | DEB_ITRACE, "About to do the member search.\n"));

        hr = spDsSearch->ExecuteSearch((PWSTR)(LPCWSTR)csFilter,
                                       pwzAttrNames, ARRAYLENGTH(pwzAttrNames),
                                       &hSrch);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);
        dspDebugOut((DEB_USER14 | DEB_ITRACE, "Member search returned.\n"));

        hr = spDsSearch->GetNextRow(hSrch);

        for (i = ulStart; (i < ulEnd) && (S_OK == hr); i++)
        {
            ADS_SEARCH_COLUMN Column;
            BOOL fDisabled = FALSE;
            CStrW csDN;
            int iIndex;

            //
            // Get the object dn.
            //
            hr = spDsSearch->GetColumn(hSrch, g_wzDN, &Column);

            CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), break);

            csDN = Column.pADsValues->CaseIgnoreString;

            spDsSearch->FreeColumn(&Column);

            //
            // Get the object class.
            //
            hr = spDsSearch->GetColumn(hSrch, g_wzObjectClass, &Column);

            CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), break);

            // Krishna sez the most derived class is *always* the last array element...
            csClass = Column.pADsValues[Column.dwNumValues - 1].CaseIgnoreString;

            spDsSearch->FreeColumn(&Column);

            //
            // Get the object userAccountControl.
            //
            hr = spDsSearch->GetColumn(hSrch, g_wzUserAccountControl, &Column);

            if (S_OK == hr)
            {
                fDisabled = (Column.pADsValues->Integer & UF_ACCOUNTDISABLE) != 0;
                spDsSearch->FreeColumn(&Column);
            }

            if ((iIndex = GetIndex(csDN, ulStart, ulEnd)) == -1)
            {
                dspAssert(FALSE && "list entry not found!");
                return E_FAIL;
            }

            LV_ITEM lvi = {0};
            lvi.mask = LVIF_IMAGE;
            lvi.iSubItem = IDX_NAME_COL;
            lvi.iItem = iIndex;
            lvi.iImage = g_ClassIconCache.GetClassIconIndex(csClass, fDisabled);
            if (lvi.iImage == -1)
            {
              lvi.iImage = g_ClassIconCache.AddClassIcon(csClass, fDisabled);
            }
            ListView_SetItem(m_hList, &lvi);

            hr = spDsSearch->GetNextRow(hSrch);
        }

        dspDebugOut((DEB_USER14 | DEB_ITRACE, "Members updated with icons.\n"));

        spDsSearch->CloseSearchHandle(hSrch);

        if (ulEnd != (ulStart + g_ulMemberFilterCount))
        {
            // EOL, stop processing.
            //
            break;
        }
        ulStart = ulEnd;
        csFilter = L"(|";
    }

#endif // defined (DSADMIN)

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Class:      CMemberListItem
//
//  Purpose:    Item data for the reverse membership list.
//
//-----------------------------------------------------------------------------
//+----------------------------------------------------------------------------
//
//  Method:     CMemberListItem::Copy
//
//  Synopsis:   Return a copy of the original element.
//
//-----------------------------------------------------------------------------
CMemberListItem *
CMemberListItem::Copy(void)
{
    CMemberListItem * pItem = new CMemberListItem;

    CHECK_NULL(pItem, return NULL);

    if (this->m_pwzDN)
    {
        if (!AllocWStr(this->m_pwzDN, &pItem->m_pwzDN))
        {
            delete pItem;
            return NULL;
        }
    }
    if (this->m_ptzName)
    {
        if (!AllocTStr(this->m_ptzName, &pItem->m_ptzName))
        {
            delete pItem;
            return NULL;
        }
    }
    if (this->m_pSid)
    {
        if (!pItem->SetSid(this->m_pSid))
        {
            delete pItem;
            return NULL;
        }
    }
    pItem->m_fIsPrimary = this->m_fIsPrimary;
    pItem->m_ulScopeType = this->m_ulScopeType;
    pItem->m_fSidSet = this->m_fSidSet;
    pItem->m_fCanBePrimarySet = this->m_fCanBePrimarySet;
    pItem->m_fCanBePrimary = this->m_fCanBePrimary;
    pItem->m_fIsAlreadyMember = this->m_fIsAlreadyMember;
    pItem->m_fIsExternal = this->m_fIsExternal;

    return pItem;
}

//+----------------------------------------------------------------------------
//
//  Method:     CMemberListItem::SetSid
//
//  Synopsis:   Copy and store the passed in SID.
//
//-----------------------------------------------------------------------------
BOOL
CMemberListItem::SetSid(PSID pSid)
{
    int cb = GetLengthSid(pSid);
    dspAssert(cb);
    this->m_pSid = new BYTE[cb];
    CHECK_NULL(this->m_pSid, return FALSE);
    memcpy(this->m_pSid, pSid, cb);
    m_fSidSet = TRUE;
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   ConvertSidToPath
//
//  Synopsis:   Converts the binary SID to a string LDAP path.
//
//-----------------------------------------------------------------------------
void
ConvertSidToPath(PSID pObjSID, CStrW &strSIDname)
{
    strSIDname = g_wzSidPathPrefix;
    //
    // Convert the bytes of the sid to hex chars.
    //
    PBYTE  pbSid = (PBYTE)pObjSID;
    ULONG  i;
    PUCHAR  pcSubAuth = NULL;

    pcSubAuth = GetSidSubAuthorityCount(pObjSID);

    dspAssert(pcSubAuth);

    ULONG cbSid = GetSidLengthRequired(*pcSubAuth);

    dspAssert(cbSid);
    dspAssert(cbSid == (*pcSubAuth - 1) * (sizeof(DWORD)) + sizeof(SID));

    for (i = 0; i < cbSid; i++)
    {
        WCHAR wzCur[3];

        wsprintfW(wzCur, L"%02x", *pbSid);
        pbSid++;

        strSIDname += wzCur;
    }

    strSIDname += g_wzSidPathSuffix;
}

//+----------------------------------------------------------------------------
//
//  Method:     CClassIconCache::CClassIconCache
//
//-----------------------------------------------------------------------------
CClassIconCache::CClassIconCache(void) :
    m_fInitialized(FALSE),
    m_prgcce(NULL),
    m_hImageList(NULL)
{
    TRACE(CClassIconCache,CClassIconCache);
    m_nImageCount = 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CClassIconCache::~CClassIconCache
//
//-----------------------------------------------------------------------------
CClassIconCache::~CClassIconCache(void)
{
  TRACE(CClassIconCache,~CClassIconCache);

  ClearAll();
}

//+----------------------------------------------------------------------------
//
//  Method:     CClassIconCache::ClearAll
//
//-----------------------------------------------------------------------------
void CClassIconCache::ClearAll(void)
{
  if (m_hImageList != NULL)
  {
    ImageList_RemoveAll(m_hImageList);
    ImageList_Destroy(m_hImageList);
    m_hImageList = NULL;
  }

  if (m_prgcce != NULL)
  {
    delete[] m_prgcce;
    m_prgcce = NULL;
    m_nImageCount = 0;
  }
  m_fInitialized = FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CClassIconCache::GetClassIconIndex
//
//-----------------------------------------------------------------------------
int CClassIconCache::GetClassIconIndex(PCWSTR pwzClass, BOOL fDisabled)
{
  int iIcon = -1;

  dspAssert(pwzClass);
  if (!pwzClass)
  {
     return iIcon;
  }

  Initialize();

  if (m_prgcce != NULL && m_nImageCount > 0)
  {
    for (UINT i = 0; i < m_nImageCount; i++)
    {
      if (_wcsicmp(pwzClass, m_prgcce[i].wzClass) == 0)
      {
        iIcon = (fDisabled) ? m_prgcce[i].iDisabledIcon : m_prgcce[i].iIcon;
        break;
      }
    }
  }

  dspDebugOut((DEB_USER14, "CClassIconCache::GetClassIconIndex returning %d\n", iIcon));
  
  return iIcon;
}

//+----------------------------------------------------------------------------
//
//  Method:     CClassIconCache::AddClassIcon
//
//-----------------------------------------------------------------------------
int CClassIconCache::AddClassIcon(PCWSTR pwzClass, BOOL fDisabled)
{
  //
  // Retrieves the icon for the class from the DisplaySpecifiers and puts it
  // in the image list
  //
  HICON hIcon = NULL;
  HICON hDisabledIcon = NULL;

  hIcon = DsGetIcon(DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON, const_cast<PWSTR>(pwzClass), 16, 16);

  if (!hIcon)
  {
    DBG_OUT("CClassIconCache::AddClassIcon failed in DsGetIcon for normal icon");
    return E_OUTOFMEMORY;
  }

  hDisabledIcon = DsGetIcon(DSGIF_ISDISABLED | DSGIF_GETDEFAULTICON, const_cast<PWSTR>(pwzClass), 16, 16);

  if (!hDisabledIcon)
  {
    DBG_OUT("CClassIconCache::AddClassIcon failed in DsGetIcon for disabled icon");
    hDisabledIcon = hIcon;
  }

  if (m_prgcce != NULL)
  {
    CLASS_CACHE_ENTRY* pNewList = new CLASS_CACHE_ENTRY[m_nImageCount + 1];
    if (pNewList == NULL)
    {
      return -1;
    }

    memcpy(pNewList, m_prgcce, sizeof(CLASS_CACHE_ENTRY) * m_nImageCount);
    delete[] m_prgcce;
    m_prgcce = pNewList;
  
    m_prgcce[m_nImageCount].iIcon = ImageList_AddIcon(m_hImageList, hIcon);
    
    if (hDisabledIcon == hIcon)
    {
      m_prgcce[m_nImageCount].iDisabledIcon = m_prgcce[m_nImageCount].iIcon;
    }
    else
    {
      m_prgcce[m_nImageCount].iDisabledIcon = ImageList_AddIcon(m_hImageList, hDisabledIcon);
    }
    m_nImageCount++;
  }

  DestroyIcon(hIcon);
  if (hDisabledIcon != hIcon)
  {
    DestroyIcon(hDisabledIcon);
  }
  return (fDisabled) ? m_prgcce[m_nImageCount - 1].iDisabledIcon : m_prgcce[m_nImageCount - 1].iIcon;
}

//+----------------------------------------------------------------------------
//
//  Method:     CClassIconCache::Initialize
//
//-----------------------------------------------------------------------------
HRESULT CClassIconCache::Initialize(void)
{
  if (m_fInitialized)
  {
    return S_OK;
  }

  if (m_prgcce != NULL)
  {
    delete[] m_prgcce;
    m_prgcce = NULL;
    m_nImageCount = 0;
  }
  m_nImageCount = ICON_CACHE_NUM_CLASSES;
  m_prgcce = new CLASS_CACHE_ENTRY[m_nImageCount];
  if (m_prgcce == NULL)
  {
    m_nImageCount = 0;
    return -1;
  }
  memset(m_prgcce, 0, sizeof(CLASS_CACHE_ENTRY) * m_nImageCount);

  dspAssert(m_prgcce != NULL);

  TRACE(CClassIconCache,Initialize);
  
  m_hImageList = ImageList_Create(16, 16, ILC_COLOR | ILC_MASK, 1, 1);

  if (NULL == m_hImageList)
  {
      DBG_OUT("ImageList_Create failed");
      return E_OUTOFMEMORY;
  }

  HICON hIcon;

  //
  // Default
  //
  hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MEMBER));

  if (!hIcon)
  {
      DBG_OUT("DsGetIcon failed for member icon");
      return E_OUTOFMEMORY;
  }

  m_prgcce[0].iIcon = ImageList_AddIcon(m_hImageList, hIcon);

  wcscpy(m_prgcce[0].wzClass, L"default");

  m_prgcce[0].iDisabledIcon = m_prgcce[0].iIcon;

  //
  // User
  //

  hIcon = DsGetIcon(DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON, g_wzUser, 16, 16);

  if (!hIcon)
  {
      DBG_OUT("DsGetIcon failed for user icon");
      return E_OUTOFMEMORY;
  }

  m_prgcce[1].iIcon = ImageList_AddIcon(m_hImageList, hIcon);

  DestroyIcon(hIcon);

  hIcon = DsGetIcon(DSGIF_ISDISABLED | DSGIF_GETDEFAULTICON, g_wzUser, 16, 16);

  if (!hIcon)
  {
      DBG_OUT("DsGetIcon failed for user disable icon");
      return E_OUTOFMEMORY;
  }

  m_prgcce[1].iDisabledIcon = ImageList_AddIcon(m_hImageList, hIcon);

  DestroyIcon(hIcon);

  wcscpy(m_prgcce[1].wzClass, g_wzUser);

  //
  // Computer
  //

  hIcon = DsGetIcon(DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON, g_wzComputer, 16, 16);

  if (!hIcon)
  {
      DBG_OUT("DsGetIcon failed for computer icon");
      return E_OUTOFMEMORY;
  }

  m_prgcce[2].iIcon = ImageList_AddIcon(m_hImageList, hIcon);

  DestroyIcon(hIcon);

  hIcon = DsGetIcon(DSGIF_ISDISABLED | DSGIF_GETDEFAULTICON, g_wzComputer, 16, 16);

  if (!hIcon)
  {
      DBG_OUT("DsGetIcon failed for computer disable icon");
      return E_OUTOFMEMORY;
  }

  m_prgcce[2].iDisabledIcon = ImageList_AddIcon(m_hImageList, hIcon);

  DestroyIcon(hIcon);

  wcscpy(m_prgcce[2].wzClass, g_wzComputer);

  //
  // Contact
  //

  hIcon = DsGetIcon(DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON, g_wzContact, 16, 16);

  if (!hIcon)
  {
      DBG_OUT("DsGetIcon failed for contact icon");
      return E_OUTOFMEMORY;
  }

  m_prgcce[3].iIcon = ImageList_AddIcon(m_hImageList, hIcon);

  DestroyIcon(hIcon);

  m_prgcce[3].iDisabledIcon = -1;

  wcscpy(m_prgcce[3].wzClass, g_wzContact);

  //
  // Group
  //

  hIcon = DsGetIcon(DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON, g_wzGroup, 16, 16);

  if (!hIcon)
  {
      DBG_OUT("DsGetIcon failed for group icon");
      return E_OUTOFMEMORY;
  }

  m_prgcce[4].iIcon = ImageList_AddIcon(m_hImageList, hIcon);

  DestroyIcon(hIcon);

  m_prgcce[4].iDisabledIcon = -1;

  wcscpy(m_prgcce[4].wzClass, g_wzGroup);

  //
  // FPO
  //

  hIcon = DsGetIcon(DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON, g_wzFPO, 16, 16);
  if (!hIcon)
  {
      DBG_OUT("DsGetIcon failed for fpo icon");
      return E_OUTOFMEMORY;
  }

  m_prgcce[5].iIcon = ImageList_AddIcon(m_hImageList, hIcon);

  DestroyIcon(hIcon);

  m_prgcce[5].iDisabledIcon = -1;

  wcscpy(m_prgcce[5].wzClass, g_wzFPO);

  m_fInitialized = TRUE;

  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CClassIconCache::GetImageList
//
//-----------------------------------------------------------------------------
HIMAGELIST CClassIconCache::GetImageList(void)
{
  if (FAILED(Initialize()))
  {
    return NULL;
  }

  return m_hImageList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\pages.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       pages.h
//
//  Contents:   Resource identifiers.
//
//  Notes:      You can view the resources in VC, but DO NOT save from VC! The
//              help IDs do not map 1 to 1 with the control IDs and VC will
//              overwrite them.
//
//-----------------------------------------------------------------------------
#define IDD_SHELL_ADDRESS               101
#define IDC_OTHER_PHONE_BTN             101
#define IDD_SHELL_NAME                  102
#define IDD_SHELL_VOLUME_GEN            103
#define IDC_OTHER_URL_BTN               103
#define IDD_SHELL_COMPUTER_GEN          104
#define IDD_SHELL_GROUP_GENERAL         105
#define IDD_SHELL_GROUP_GEN             106
#define IDD_SHELL_DOMAIN_GEN            107
#define IDD_SHELL_OU_GEN                108
#define IDD_SHELL_BUSINESS              109
#define IDD_SHELL_MEMBERSHIP            110
#define IDD_SHELL_USER_GEN              111
#define IDD_OBJECT                      130
#define IDD_USER                        131
#define IDD_ADDRESS                     134
#define IDD_USER_ORG                    135
#define IDD_ACCOUNT                     136
#define IDD_MEMBER                      139
#define IDD_GROUP                       146
#define IDD_SITE_GENERAL                147
#define IDC_SUBNET_LIST                 148
#define IDD_DS_SERVER_GENERAL           149
#define IDC_ADD_BTN                     149
#define IDC_REMOVE_BTN                  150
#define IDC_LOCAL_PATH_RADIO            151
#define IDC_CONNECT_TO_RADIO            152
#define IDC_DRIVES_COMBO                153
#define IDC_LOCAL_PATH_EDIT             154
#define IDD_GROUP_GEN                   156
#define IDD_NTDSDSA_CONN                157
#define IDC_ACCT_LOCKOUT_CHK            158
#define IDC_ACCT_NEVER_EXPIRES_RADIO    161
#define IDC_ACCT_EXPIRES_ON_RADIO       162
#define IDC_ACCT_EXPIRES                163
#define IDC_PROFILE_PATH_EDIT           164
#define IDC_LOGON_SCRIPT_EDIT           165
#define IDC_LOGON_HOURS_BTN             166
#define IDC_LOGON_TO_BTN                167
#define IDC_CONNECT_TO_PATH_EDIT        168
#define IDC_COUNTRY_COMBO               169
#define IDC_NTDSDSA_GLOBAL_CATALOG      170
#define IDC_HOMEPHONE_EDIT              170
#define IDC_NTDSDSA_REPLICATE_FROM      171
#define IDC_NTDSDSA_REPLICATE_TO        172
#define IDS_TITLE_BUSINESS              172
#define IDC_OTHER_PAGER_BTN             172
#define IDS_CANT_VIEW_EXTERNAL          173
#define IDS_NATIVE_MODE                 174
#define IDC_OTHER_MOBLE_BTN             174
#define IDC_CHECK_LIST                  175
#define IDS_MSG_DISABLING_SECURITY      175
#define IDS_CONFIRM_DOM_RAISE           176
#define IDC_OTHER_FAX_BTN               176
#define IDC_COMMENT_EDIT                177
#define IDS_ERR_LOOKUP_FAILED           177
#define IDS_CHANGED_REBOOT              178
#define IDS_DOMAIN_MODE_CHANGED         178
#define IDS_NO_GC_FOR_MEMBERSHIP        179
#define IDC_VIEW_BTN                    180
#define IDS_TRUST_TRANSITIVE            180
#define IDS_TRUSTED_SUCCEEDED           181
#define IDS_DES_KEY_ONLY                182
#define IDS_ERR_COUNTRY_DATA_BAD        183
#define IDS_BUILTIN_GROUP               184
#define IDS_DONT_REQ_PREAUTH            185
#define IDS_ERRMSG_NO_VOLUME_PATH       186
#define IDC_CLOSE                       187
#define IDS_GRP_NO_NAME_MAPPING         187
#define IDS_UACCT_NO_DOMAIN             188
#define IDS_NO_VALUE                    189
#define IDC_CLASS_STATIC                190
#define IDC_CREATED_TIME_STATIC         191
#define IDC_MODIFIED_TIME_STATIC        192
#define IDC_USN_CREATED_STATIC          193
#define IDC_USN_MODIFIED_STATIC         194
#define IDS_MUST_CHANGE_PW              197
#define IDS_MULTISEL_LIMIT              199
#define IDC_DS_SITE_IN_SUBNET           200
#define IDC_UNC_NAME_EDIT               200
#define IDS_REL_TREE_ROOT               200
#define IDC_BROWSE_BTN                  201
#define IDS_TRUST_RESET_NO_DC           201
#define IDC_LAST_INDEXED_STATIC         202
#define IDS_CANCEL_CANT_VERIFY          202
#define IDC_INDEX_CHECK                 203
#define IDS_MEMBERSHIP_OBJ_NOT_IN_GC    203
#define IDS_FPO_NO_NAME_MAPPING         204
#define IDC_CHECK_COLOR                 205
#define IDC_CHECK_STAPLE                206
#define IDC_EDIT_RESOLUTION             207
#define IDC_EDIT_SPEED                  208
#define IDC_BUTTON_BROWSE               211
#define IDC_LOCATION_EDIT               213
#define IDC_MODEL_EDIT                  214
#define IDC_MANAGER_EDIT                215
#define IDC_DESC_EDIT                   215
#define IDC_MGR_CHANGE_BTN              216
#define IDC_TITLE_EDIT                  217
#define IDD_PHONE                       218
#define IDC_DEPT_EDIT                   218
#define IDC_COMPANY_EDIT                219
#define IDC_PRI_GRP_BTN                 220
#define IDC_MEMBER_LIST                 221
#define IDC_PATH_FIELD                  223
#define IDC_PRI_GRP_STATIC              224
#define IDC_RM_GRP_BTN                  225
#define IDC_COMBO_PAPER_SIZE            226
#define IDD_OU                          226
#define IDD_OU_GEN                      226
#define IDD_DS_CONNECTION_GENERAL       227
#define IDC_MGR_CLEAR_BTN               227
#define IDC_REPORTS_LIST                228
#define IDD_SUBNET_GENERAL              229
#define IDC_MANAGEDBY_EDIT              229
#define IDD_DOMAIN                      230
#define IDC_STREET_EDIT                 230
#define IDD_DOMAINPOLICY                231
#define IDD_VOLUME                      232
#define IDD_GENERAL_PRINTQ              233
#define IDD_MANAGEDBY                   234
#define IDD_DOMAIN_TRUST                237
#define IDD_LOCALPOLICY_GEN             238
#define IDI_LOCAL_POLICY                238
#define IDC_NTDSDSA_QUERY_POLICY        239
#define IDD_COMPUTER                    239
#define IDI_SITEREPL                    239
#define IDD_FOREST_ROUTING              241
#define IDC_SUFFIXES_LIST               242
#define IDD_TRUSTED_DOM_GEN             246
#define IDD_NTDSDSA_GENERAL             249
#define IDD_FRS_CONNECTION_GENERAL      250
#define IDC_TRUSTED_STATIC              273
#define IDC_ADD_TRUST_BTN               274
#define IDC_REMOVE_TRUSTED_BTN          275
#define IDC_VIEW_TRUSTED_BTN            276
#define IDC_TRUSTING_STATIC             277
#define IDC_REMOVE_TRUSTING_BTN         278
#define IDC_VIEW_TRUSTING_BTN           279
#define IDC_SHOW_ROUTING_CHK            280
#define IDC_TRUSTED_LIST                281
#define IDC_TRUSTING_LIST               282
#define IDC_NET_ADDR_EDIT               285
#define IDC_ROLE_EDIT                   286
#define IDC_OS_EDIT                     287
#define IDC_OS_VER_EDIT                 288
#define IDC_DOMAIN_EDIT                 289
#define IDC_PW1_EDIT                    290
#define IDC_PW2_EDIT                    291
#define IDC_SUBNET_ADDRESS              292
#define IDC_SUBNET_MASK                 293
#define IDC_SITESETTINGS_CACHE_MEMB     294
#define IDC_SITESETTINGS_PREFERRED_SITE 295
#define IDS_CLOSE                       296
#define IDS_EMPTY_SAM_NAME              311
#define IDS_CANT_CHANGE_PW              312
#define IDS_ERR_PARENT_CANCELED         314
#define IDD_USR_PROFILE                 315
#define IDS_NO_ACCESS_GC_FOR_MEMBERSHIP 315
#define IDD_MULTI_VALUE                 316
#define IDS_BUILTIN_NO_NEST             316
#define IDD_USER_CERTIFICATES           317
#define IDS_TRUST_NON_TRANSITIVE        317
#define IDS_TRUST_BAD_DOMAIN            318
#define IDS_VERIFY_TRUST_NOGOOD         319
#define IDS_NO_SAMNAME_FOR_PROFILE      320
#define IDC_CRED_PROMPT                 321
#define IDS_VERIFY_DOWNLEVEL_TRUST_NOGOOD 322
#define IDB_CERTIFICATE                 323
#define IDD_COMPUTER_OS                 324
#define IDD_RPC_GEN                     325
#define IDC_TYPE                        329
#define IDI_DS_WARNING                  329
#define IDC_ROLE                        329
#define IDC_TITLE                       330
#define IDC_COMPANY                     331
#define IDC_DEPARTMENT                  332
#define IDC_DIVISION                    333
#define IDC_OFFICE                      334
#define IDC_KEYWORDS_LIST               335
#define IDC_MEMBERS_LIST                336
//#define         337
#define IDC_DOMAIN_NAME_EDIT            340
#define IDC_PEER_NAME_EDIT              341
#define IDC_TRUST_TYPE_EDIT             342
#define IDC_MAKE_PARENT_CHK             343
#define IDC_TRANSITIVE_CHK              345
#define IDC_SCHEDULE_BTN                346
#define IDC_PHONE_EDIT                  346
#define IDC_EMAIL_EDIT                  347
#define IDC_HOME_PAGE_EDIT              348
#define IDC_PAGER_EDIT                  350
#define IDC_MOBILE_EDIT                 351
#define IDC_OTHER_HOME_BTN              352
#define IDC_URL_EDIT                    353
#define IDC_DS_ICON                     354
#define IDC_NT5_NAME_EDIT               355
#ifdef CUSTOM_SCHEDULE
#define IDC_SCHEDULE_CHECKBOX           356
#endif
#define IDC_NT4_DOMAIN                  357
#define IDC_NT4_NAME_EDIT               358
#define IDC_EDIT                        361
#define IDC_LIST                        363
#define IDC_CERT_LIST                   364
#define IDC_VIEW_CERT                   365
#define IDC_COPY_TO_FILE                366
#define IDC_ADD_FROM_STORE              367
#define IDC_ADD_FROM_FILE               368
#define IDC_REMOVE                      369
#define IDC_PRI_GRP_LABEL               370
#define IDC_DIVIDING_LINE               371
#define IDC_PICTURE_BMP                 372
#define IDC_EDIT_COMMENT                374
#define IDC_FOREST_VERSION_STATIC       375
#define IDD_INTERSITE_GENERAL           403
#define IDD_DEFAULT_GENERAL             404
#define IDD_CONTAINER_GENERAL           405
#define IDD_NT_GROUP                    406
#define IDC_FRS_ROOT_PATH               411
#define IDC_FRS_STAGING_PATH            412
#define IDD_DS_SITE_SETTINGS_GENERAL    413
#define IDD_DS_SITE_LICENSE_SETTINGS_GENERAL 414
#define IDD_NTFRS_REPLICA_SET_GENERAL   421
#define IDD_NTFRS_MEMBER_GENERAL        422
#define IDD_NTFRS_SUBSCRIBER_GENERAL    424
#define IDD_SITELINK_GENERAL            430
#define IDD_SITELINKBRIDGE_GENERAL      431
#define IDD_LOGON_WKSTA                 432
#define IDD_ERROR_PAGE                  433
#define IDD_FPO_GENERAL                 434
#define IDD_FPNW_PROPERTIES             440
#define IDC_ADVANCED_BUTTON             441
#define IDC_SCRIPT_BUTTON               442
#define IDC_NETWARE_ENABLE              443
#define IDC_NWPWEXPIRED                 444
#define IDC_UNLIMITED_GRACELOGINS       445
#define IDC_LIMIT_GRACELOGINS           446
#define IDC_CONCURRENT_CONNECTIONS      447
#define IDC_UNLIMITED_CONNECTIONS       448
#define IDC_LIMIT_CONNECTIONS           449
#define IDC_GRACE_SPIN                  450
#define IDC_GRACE_LIMIT                 451
#define IDC_GRACE_REMAINING_SPIN        452
#define IDC_GRACE_REMAINING             453
#define IDC_GRACE_REMAINING_TEXT        454
#define IDC_CONNECTION_SPIN             455
#define IDC_CONNECTION_LIMIT            456
#define IDC_OBJECT_ID                   457
#define IDC_GRACE_LOGINS                458
#define IDC_OBJECTID_TEXT               459
#define IDC_NWHMDIR_RELPATH_TEXT        460
#define IDC_NWHMDIR_RELPATH             461
#define IDD_FPNW_PASSWORD               462
#define IDC_FPNWPASSWORD_USERNAME       463
#define IDC_FPNWPASSWORD_EDIT1          464
#define IDC_FPNWPASSWORD_EDIT2          465
#define IDD_FPNW_LOGON                  466
#define IDC_FPNWLOGON_USERNAME          467
#define IDC_FPNWLOGON_ALL               468
#define IDC_FPNWLOGON_SELECTED          469
#define IDC_FPNWLOGON_ADDRESS           470
#define IDC_FPNWLOGON_ADD               471
#define IDC_FPNWLOGON_REMOVE            472
#define IDD_FPNW_LOGON_ADDDLG           473
#define IDC_FPNWLOGONADD_NETWORKADDR    474
#define IDC_FPNWLOGONADD_NODEADDR       475
#define IDD_FPNW_LOGIN_SCRIPT           476
#define IDC_FPNWLOGINSCRIPT_EDIT        477
#define IDD_SPN_SUFFIX                  477
#define IDC_SPIN                        478
#define IDC_SPIN2                       479
#define IDD_DEFAULT_MULTI_GENERAL       500
#define IDC_OBJECT_TOTAL_STATIC         501
#define IDC_OU_COUNT_STATIC             502
#define IDC_USER_COUNT_STATIC           503
#define IDC_GROUP_COUNT_STATIC          504
#define IDC_COMPUTER_COUNT_STATIC       505
#define IDC_CONTACT_COUNT_STATIC        506
#define IDC_OTHER_COUNT_STATIC          507
#define IDC_ALWAYS_APPLY                525
#define IDD_MULTI_ACCOUNT               550
#define IDC_APPLY_UPN_CHK               551
#define IDC_APPLY_HOURS_CHK             552
#define IDC_APPLY_COMPUTERS_CHK         553
#define IDC_APPLY_EXPIRES_CHK           554
#define IDD_MULTI_USER_GENERAL          555
#define IDC_APPLY_DESC_CHK              556
#define IDC_APPLY_OFFICE_CHK            557
#define IDC_APPLY_PHONE_CHK             558
#define IDC_APPLY_EMAIL_CHK             559
#define IDC_APPLY_WEB_CHK               560
#define IDC_APPLY_FAX_CHK               561
#define IDC_DESC_STATIC                 562
#define IDC_OFFICE_STATIC               563
#define IDC_PHONE_STATIC                564
#define IDC_EMAIL_STATIC                565
#define IDC_WEB_STATIC                  566
#define IDC_FAX_STATIC                  567
#define IDC_SUMMARY_STATIC              568
#define IDD_MULTI_USER_ORG              570
#define IDC_APPLY_TITLE_CHK             571
#define IDC_APPLY_DEPT_CHK              572
#define IDC_APPLY_COMPANY_CHK           573
#define IDC_APPLY_MANAGER_CHK           574
#define IDC_NAME_STATIC                 575
#define IDD_MULTI_USER_PROFILE          578
#define IDC_APPLY_PROFILE_CHK           579
#define IDC_APPLY_SCRIPT_CHK            580
#define IDC_APPLY_HOMEDIR_CHK           581
#define IDC_TO_STATIC                   582
#define IDC_PROPERTIES_BUTTON           583
#define IDD_MULTISELECT_ERROR_DIALOG    585
#define IDC_ERROR_LIST                  586
#define IDC_COPY_BUTTON                 587
#define IDC_SUCCESS_LISTBOX             588
#define IDC_NOT_ATTEMPTED_LISTBOX       589
#define IDD_MULTI_USER_ADDRESS          590
#define IDC_APPLY_STREET_CHK            591
#define IDC_APPLY_POBOX_CHK             592
#define IDC_APPLY_CITY_CHK              593
#define IDC_APPLY_STATE_CHK             594
#define IDC_APPLY_ZIP_CHK               595
#define IDC_APPLY_COUNTRY_CHK           596
#define IDC_ERROR_STATIC                597
#define IDC_OU_LABEL_COUNT_STATIC       598
#define IDC_USER_LABEL_COUNT_STATIC     600
#define IDC_GROUP_LABEL_COUNT_STATIC    601
#define IDC_COMPUTER_LABEL_COUNT_STATIC 602
#define IDC_CONTACT_LABEL_COUNT_STATIC  603
#define IDC_OTHER_LABEL_COUNT_STATIC    604
#define IDC_SUMMARY_LABEL_STATIC        605
#define IDS_TRUST_FOREST_TRANSITIVE     606
#define IDD_RAISE_DOMAIN_VERSION        607
#define IDC_VER_NAME_STATIC             608
#define IDC_CUR_VER_STATIC              609
#define IDC_VER_COMBO                   610
#define IDS_DOM_VER_W2K_MIXED           611
#define IDS_DOM_VER_W2K_NATIVE          612
#define IDS_DOM_VER_XP_BETA_MIXED       613
#define IDS_DOM_VER_XP_BETA_NATIVE      614
#define IDS_DOM_VER_XP                  615
#define IDS_FOR_VER_W2K                 616
#define IDS_FOR_VER_XP_BETA             617
#define IDS_FOR_VER_XP                  618
#define IDD_HIGHEST_DOMAIN_VERSION      619
#define IDS_ERR_NO_DC                   620
#define IDC_CANT_RAISE_STATIC           621
#define IDS_CANT_RAISE_ACCESS           622
#define IDS_CANT_RAISE_PDC              623
#define IDS_CANT_RAISE_FOREST_ACCESS    625
#define IDD_CANT_RAISE_DOMAIN           626
#define IDC_SAVE_LOG                    627
#define IDS_DOM_VER_LOG_PREFIX          628
#define IDS_DOM_VER_LOG_HDR             629
#define IDS_DOM_VER_LOG_CREATE_FAILED   630
#define IDS_VERSION_ERROR_FORMAT        631
#define IDS_RAISE_DOM_VER_TITLE         632
#define IDD_RAISE_FOREST_VERSION        633
#define IDD_HIGHEST_FOREST_VERSION      634
#define IDD_CANT_RAISE_FOREST           635
#define IDS_RAISE_FOR_VER_TITLE         636
#define IDS_CONFIRM_FOR_RAISE           637
#define IDS_FOREST_CANT_RAISE_ACCESS    638
#define IDS_FOREST_CANT_RAISE_FSMO      639
#define IDS_FOR_VER_LOG_PREFIX          640
#define IDS_FOR_VER_LOG_HDR             641
#define IDS_FOR_VER_LOG_MODE_HDR        642
#define IDS_FOR_ERR_NO_DC               643
#define IDC_FOR_CANT_RAISE_STATIC       644
#define IDS_FOR_CANT_RAISE_STATIC       644
#define IDS_TWERR_REALM_ALREADY_EXISTS  645
#define IDS_TWERR_REALM_CANT_CHANGE     646
#define IDC_CONFIRM_NEXT_HINT           647
#define IDD_TRUSTWIZ_VERIFY_INBOUND_PAGE 648
#define IDS_ERR_FOREST_TRUST_MISMATCH   649
#define IDD_CRED_ENTRY                  650
#define IDS_TW_VERIFY_OUTBOUND_TITLE    651
#define IDS_ERR_CHANGE_TRANSITIVITY     652
#define IDD_VERIFY_INBOUND              653
#define IDD_TRUST_RESET                 654
#define IDC_VERIFY_FAILURES             655
#define IDS_VERIFY_INBOUND              656
#define IDS_VERIFY_OUTBOUND             657
#define IDS_VERIFY_BAD_CREDS            658
#define IDS_OUTBOUND_TRUST_VERIFY_DONE  659
#define IDS_VERIFY_MISMATCH_FIX         660
#define IDS_WIZ_VERIFY_MISMATCH_LF      661
#define IDS_WIZ_VERIFY_MISMATCH_RF      662
#define IDD_TRUSTWIZ_PASSWORD_PAGE      663
#define IDS_TW_PW_TITLE                 664
#define IDS_TW_PW_SUBTITLE              665
#define IDS_TW_SIDES_TITLE              666
#define IDS_TW_SIDES_SUBTITLE           667
#define IDS_DOM_VER_NOT_FOUND           668
#define IDD_TRUSTWIZ_SIDES_PAGE         669
#define IDS_TW_BOTH_SIDES_OUTBOUND_ONLY 670
#define IDC_THIS_SIDE_ONLY_RADIO        671
#define IDC_BOTH_SIDES_RADIO            672
#define IDS_TW_SELECTIONS_THIS_SIDE_ONLY 673
#define IDS_TW_SELECTIONS_BOTH_SIDES    674
#define IDS_TW_STATUS_THIS_SIDE_ONLY    675
#define IDS_TW_STATUS_BOTH_SIDES        676
#define IDD_TRUSTWIZ_SUFFIX_FOR_REMOTE_PAGE 677
#define IDD_TW_ERR_NO_REMOTE_PDC        678
#define IDD_TRUSTWIZ_ALREADY_EXISTS_PAGE 679
#define IDS_TW_SUFFIX_FOR_LOCAL_TITLE   680
#define IDS_TW_SUFFIX_FOR_LOCAL_SUBTITLE 681
#define IDS_LOCAL_COLLISIONS_MSG        682
#define IDS_ERR_CREATE_BAD_CREDS        683
#define IDC_TW_SIDES_STATIC             684
#define IDS_TW_SIDES_STATIC             685
#define IDS_TW_SIDES_ERR_REMEDY         686
#define IDS_TW_SIDES_ERR_MIT            687
#define IDS_TW_FOREST_VS_EXTERNAL       688
#define IDS_TW_EXTERNAL_VS_FOREST       689
#define IDS_TW_OTHER_NOT_EXIST          690
#define IDS_TW_OTHER_ALREADY_EXISTS     691
#define IDS_TW_OTHER_WRONG_VER          692
#define IDS_TW_OTHER_FIX_WRONG_VER      693
#define IDS_TW_DONE_ROUTED_TO_SPECIFIED 694
#define IDS_TW_DONE_ROUTED_TO_LOCAL     695
#define IDS_ERR_READ_ENT_VER            696
#define IDS_ERR_NG_ENT_VER              697
#define IDS_ERR_NG_ENT_VER_REMEDY       698
#define IDS_ERR_CANT_CREATE_DEFAULT     699
#define IDD_REMOVE_BOTH_SIDES           700
#define IDS_REMOVE_OUT_CONFIRM_BOTH     701
#define IDS_REMOVE_IN_CONFIRM_BOTH      702
#define IDS_REMOVE_OUT_CONFIRM          703
#define IDS_REMOVE_IN_CONFIRM           704
#define IDS_TW_SIDES_REMEDY_DEL_BOTH    705
#define IDS_TW_SIDES_REMEDY_DEL_OTHER   706
#define IDS_RM_BOTH_SIDES_HAVE_CREDS    707
#define IDS_VERIFY_BOTH_SIDES_HAVE_CREDS 708
#define IDS_RM_OTHER_NO_ACCESS          709
#define IDS_RM_OTHER_NOT_FOUND          710
#define IDS_TRUST_VERIFY_NO_DC          711
#define IDS_ERR_TRUST_NOT_FOUND         712
#define IDS_ERR_WRITE_FTI_TRUST_NOT_FOUND 713
#define IDS_VERSION_UNWILLING_TO_RAISE  714
#define IDS_TRUST_LSAOPEN_NO_RPC        715
#define IDC_FOR_CANT_RAISE_DETAILS      718
#define IDS_ERR_DC_NOT_WORKING          719
#define IDS_LOSTANDFOUND_NTDSDSA        720
#define IDS_PROMOTION_STILL_REPLICATING 721
#define IDS_UNKNOWN                     722
#define IDS_TRUST_LSAOPEN_ERROR         723
#define IDD_TRUSTWIZ_ORGANIZATION_ATTR_PAGE 724
#define IDC_MY_ORG_RADIO                725
#define IDC_OTHER_ORG_RADIO             726
#define IDS_ORGANIZATION_PAGE_TITLE     727
#define IDS_ORG_PAGE_FOREST_SUBTITLE    728
#define IDS_ORG_PAGE_DOMAIN_SUBTITLE    729
#define IDS_TW_ORG_LOCAL_FOREST_LABEL   730
#define IDD_TRUSTWIZ_ORG_ATTR_REMOTE_PAGE 732
#define IDC_ORG_LABEL                   733
#define IDS_ORG_REMOTE_PAGE_TITLE       734
#define IDS_ORG_REMOTE_PAGE_FOREST_SUBTITLE 735
#define IDD_TRUST_THIS_ORG_PAGE         737
#define IDS_THIS_ORG_RADIO_FOREST       738
#define IDS_OTHER_ORG_RADIO_FOREST      739
#define IDS_ORG_PAGE_TITLE              740
#define IDC_TRUST_ORG_LABEL             741
#define IDS_THIS_ORG_RADIO_DOMAIN       742
#define IDS_OTHER_ORG_RADIO_DOMAIN      743
#define IDS_ORG_FOREST_LABEL            744
#define IDS_ORG_DOMAIN_LABEL            745
#define IDS_ERR_WRITE_ORG_TO_TDO        746
#define IDC_FOREST_BULLET               747
#define IDC_FOREST_TEXT                 748
#define IDS_ORG_LOCAL_PAGE_TITLE        749
#define IDS_ORG_REMOTE_PAGE_DOMAIN_SUBTITLE 750
#define IDS_TW_ORG_LOCAL_DOMAIN_LABEL   751
#define IDS_TW_ORG_REMOTE_FOREST_LABEL  752
#define IDS_TW_ORG_REMOTE_DOMAIN_LABEL  753
#define IDS_TW_ORG_LOCAL_FOREST_THIS    754
#define IDS_TW_ORG_LOCAL_DOMAIN_THIS    755
#define IDS_TW_ORG_LOCAL_FOREST_OTHER   756
#define IDS_TW_ORG_LOCAL_DOMAIN_OTHER   757
#define IDS_TW_ORG_REMOTE_FOREST_THIS   758
#define IDS_TW_ORG_REMOTE_DOMAIN_THIS   759
#define IDS_TW_ORG_REMOTE_FOREST_OTHER  760
#define IDS_TW_ORG_REMOTE_DOMAIN_OTHER  761
#define IDS_ORG_LOCAL_PAGE_TITLE_D      762
#define IDS_ORG_REMOTE_PAGE_TITLE_D     763
#define IDS_TW_STATUS_ONE_SIDE_THIS     764
#define IDS_TW_STATUS_ONE_SIDE_THIS_D   765
#define IDS_TW_STATUS_ONE_SIDE_OTHER    766
#define IDS_TW_STATUS_ONE_SIDE_OTHER_D  767
#define IDS_TW_STATUS_BOTH_THIS         768
#define IDS_TW_STATUS_BOTH_THIS_D       769
#define IDS_TW_STATUS_BOTH_OTHER        770
#define IDS_TW_STATUS_BOTH_OTHER_D      771
#define IDS_TW_STATUS_LOCAL_THIS_REMOTE_OTHER   772
#define IDS_TW_STATUS_LOCAL_THIS_REMOTE_OTHER_D 773
#define IDS_TW_STATUS_LOCAL_OTHER_REMOTE_THIS   774
#define IDS_TW_STATUS_LOCAL_OTHER_REMOTE_THIS_D 775
#define IDS_TW_STATUS_REMOTE_SIDE_THIS   776
#define IDS_TW_STATUS_REMOTE_SIDE_THIS_D 777
#define IDS_TW_STATUS_REMOTE_SIDE_OTHER  778
#define IDS_TW_STATUS_REMOTE_SIDE_OTHER_D 779
#define IDS_FOREST_MODE_CHANGED         780

#define IDC_COUNTRY_LABEL               998
#define IDS_COUNTRY_LABEL_NO_ACCEL      999
#define IDC_EDIT1                       1001
#define IDC_EDIT2                       1002
#define IDC_EDIT3                       1003
#define IDC_EDIT4                       1004
#define IDC_EDIT5                       1005
#define IDC_MANAGER                     1006
#define IDC_SVC_PACK_EDIT               1007
#define IDC_FAX_EDIT                    1008
#define IDC_CHECK1                      1010
#define IDC_CHECK2                      1011
#define IDC_CHECK_DOUBLE_SIDED          1012
#define IDC_RADIO_SEC_ENABLED           1012
#define IDC_ANY_WKSTA_RADIO             1012
#define IDC_RADIO_SEC_DISABLED          1013
#define IDC_SPECIFIC_WKSTAS_RADIO       1013
#define IDC_COMBO1                      1016
#define IDC_CHANGE_BTN                  1017
#define IDC_DWNLVL_TRANS_CHK            1021
#define IDC_LIST1                       1022
#define IDC_CLEAR_BTN                   1024
#define IDC_CN                          1025
#define IDC_SAM_NAME                    1028
#define IDS_SMARTCARD_REQ               1028
#define IDC_FIRST_NAME_EDIT             1029
#define IDS_DELEGATION_OK               1029
#define IDC_LAST_NAME_EDIT              1030
#define IDS_NOT_DELEGATED               1030
#define IDC_SH_FIRST_NAME_EDIT          1030
#define IDS_PASSWORD_MUTEX              1031
#define IDC_SH_LAST_NAME_EDIT           1031
#define IDC_INITIALS_EDIT               1031
#define IDC_DESCRIPTION_EDIT            1032
#define IDS_TRUST_SUCCEEDED             1032
#define IDS_TRUSTING_SUCCEEDED          1032
#define IDC_OFFICE_EDIT                 1033
#define IDC_SAM_NAME_EDIT               1033
#define IDS_CANT_WRITE                  1033
#define IDS_ERRMSG_NO_GROUP_ACCESS      1034
#define IDS_ERR_BOTH_PW_BTNS            1035
#define IDS_TRUSTDOM_LABEL_FORMAT       1036
#define IDS_ERR_BAD_TRUST               1037
#define IDC_ADDRESS_EDIT                1038
#define IDS_ADVANCED                    1038
#define IDC_CITY_EDIT                   1039
#define IDS_NO_PW_EXPIRE                1039
#define IDC_STATE_EDIT                  1040
#define IDS_ACCT_DISABLED               1040
#define IDC_ZIP_EDIT                    1041
#define IDS_ERR_UPN_NONUNIQUE           1041
#define IDC_COUNTRY_EDIT                1042
#define IDS_WARN_UPN_NO_GC_FOUND        1042
#define IDC_POBOX_EDIT                  1043
#define IDS_TRUST_RESET_QUERY           1043
#define IDS_PROFILE_USER_TOKEN          1043
#define IDS_TRUST_RESET_DONE            1044
#define IDC_DELETE_BTN                  1045
#define IDS_ERROR_TRUST_RESET           1045
#define IDS_ERR_TRUST_RESET_NOACCESS    1046
#define IDC_BUTTON1                     1047
#define IDC_BUS_ADDR_BTN                1047
#define IDS_ERR_CANT_DELEGATE           1047
#define IDS_TRUST_VERIFY_DONE           1048
#define IDS_HOME_DIR_CREATE_NO_ACCESS   1049
#define IDC_PROPPAGE_BTN                1050
#define IDS_FPNW_HOME_DIR_CREATE_NO_PARENT 1051
#define IDS_FPNW_HOME_DIR_CREATE_NO_ACCESS 1052
#define IDS_FPNW_HOME_DIR_CREATE_OTHER  1053
#define IDC_COMPUTER_BTN                1055
#define IDS_ERR_BOTH_MUST_EXPIRES       1056
#define IDS_ERRMSG_NO_GROUP_ACCESS_SIGN_SEAL 1057
#define IDC_DIALIN_PERMISSION           1072
#define IDC_NO_CALLBACK                 1073
#define IDC_SET_BY_CALLER               1074
#define IDC_PRESET_TO                   1075
#define IDC_PRESET_EDIT                 1076
#define IDD_TLN_EDIT                    1078
#define IDD_TLN_EXCLUDE                 1079
#define IDC_EXCLUDE_LABEL               1080
#define IDC_EXCLUDE_LABEL_LARGE         1081
#define IDC_EXCLUDE_LIST                1082
#define IDC_ADD_EXCLUSION_BTN           1083
#define IDC_REMOVE_EXCLUSION_BTN        1084
#define IDC_SUFFIXES_LABEL              1085
#define IDC_SUFFIX_LABEL_LARGE          1086
#define IDC_EXCLUSION_EDIT              1087
#define IDS_RNSPAGE_ACCESS              1088
#define IDS_VERIFY_MISMATCH_LF          1089
#define IDS_VERIFY_MISMATCH_RF          1090
#define IDS_ERR_CANT_VERIFY_CREDS       1091
#define IDS_ERR_CANT_SAVE_CREDS         1092
#define IDS_ERR_CANT_SAVE               1093
#define IDS_FTFILE_SUFFIX               1094
#define IDS_FTFILE_CSV_EXT              1095
#define IDS_LOG_TYPE                    1096
#define IDS_LOG_NOTES                   1097
#define IDS_LOG_FOR                     1098
#define IDS_LOG_WITH                    1099
#define IDS_FTFILE_FILTER               1100
#define IDS_VIEW                        1101
#define IDS_NETDOM_NO_FTINFOS           1102
#define IDS_NETDOM_CONFLICT_NAME        1103
#define IDS_NETDOM_CONFLICT             1104
#define IDS_NETDOM_TLNEX                1105
#define IDS_NETDOM_RANGE_ERROR          1106
#define IDS_NETDOM_NOT_FOREST           1107
#define IDS_NETDOM_NO_TRUST             1108
#define IDS_ERR_NOT_FORESTTRUST         1109
#define IDS_LOG_UNKNOWN                 1110
#define IDS_NETDOM_SID_CONFLICT_NAME    1111
#define IDS_NETDOM_SID_CONFLICT         1112
#define IDS_NETDOM_WRITE_FTINFO_FAILED  1113
#define IDS_NETDOM_ENABLE_DOMAIN        1114
#define IDS_NETDOM_DISABLE_DOMAIN       1115
#define IDS_NETDOM_EXCLUDED             1116
#define IDS_LOG_MATCHING_EXCLUSION      1117
#define IDS_NETDOM_MATCHING_TLNEX       1118
#define IDS_TWERR_CREATED_NO_NAMES      1119
#define IDS_TWERR_LOGIC                 1120
#define IDC_COMBO2                      1501
#define IDC_PATH                        1504
#define IDC_DS_INTERSITE_IN_CONNECTION  1505
#define IDC_RADIO_RESOURCE              1506
#define IDC_RADIO_ACCOUNT               1507
#define IDC_RADIO_UNIVERSAL             1508
#define IDC_UPDATE_LIST_CHECK           1509
#define IDC_IP_EDIT                     1511
#define IDC_OTHER_IP_BTN                1512
#define IDC_KEYWORDS_BTN                1514
#define IDC_EDIT_BTN                    1515
#define IDC_DELEGATION_CHK              1516
#define IDC_DOWNLEVEL_EDIT              1517
#define IDC_SERVER_EDIT                 1518
#define IDC_SITE_EDIT                   1519
#define IDC_SERVER_BTN                  1520
#define IDC_COMPAT_CHK                  1521
#define IDC_DOM_WARNING_STATIC          1523
#define IDC_WARNING_ICON                1524
#define IDC_DOMAIN_VERSION_STATIC       1525
#define IDC_UPN_SUFFIX_COMBO            1526
#define IDC_COMPUTER_EDIT               1527
#define IDC_MODE_GROUP                  1528
#define IDC_ERROR_MSG                   1529
#define IDC_DOWNLEVEL_NAME              1530
#define IDC_ACCOUNT_EDIT                1531
#define IDC_PW_EDIT                     1532
#define IDC_MSG                         1533
#define IDC_DISPLAYNAME_EDIT            1534
#define IDC_SHARED_FOLDER_EDIT          1535
#define IDC_PEER_LABEL                  1536
#define IDC_TRUST_DIR_EDIT              1537
#define IDC_GROUP_NOTE_STATIC           1538
#define IDC_TRUST_RESET_BTN             1539
#define IDC_SH_POB                      1540
#define IDC_SH_STATE                    1541
#define IDC_SH_STREET                   1542
#define IDC_SH_CITY                     1543
#define IDC_SH_ZIP                      1544
#define IDC_SH_COUNTRY                  1545
#define IDC_SH_DISPLAY_NAME_EDIT        1546
#define IDC_TRUST_TRANS_EDIT            1547
#define IDC_VERIFY_FRAME                1548
#define IDC_VERIFY_STATIC               1549
#define IDC_DUELLING_LB_OUT             1600
#define IDC_DUELLING_RB_ADD             1601
#define IDC_DUELLING_RB_REMOVE          1602
#define IDC_DUELLING_LB_IN              1603
#define IDC_PRI_GROUP_WARN_STATIC       1604
#define IDC_TW_PW_MATCH_TEXT            1605
#define IDS_TW_PW_MATCH_TEXT            1606
#define IDS_TW_PW_INVALID_TITLE         1607
#define IDS_ERR_NO_COMPUTER_OBJECT      1608
#define IDS_FOREST_LOCALUPN_SUFFIX_CONFLICT    1609
#define IDS_FOREST_OTHER_SUFFIX_CONFLICT       1610
#define IDS_NETDOM_FTINFO_READ_FAILED   1611
#define IDS_NETDOM_FTINFO_WRITE_FAILED  1612
#define IDS_NETDOM_ADD_TLN_ALREADY_EXISTS   1613
#define IDS_NETDOM_ADD_TLN_FAILED           1614
#define IDS_NETDOM_ADD_TLN_SUCCEEDED        1615
#define IDS_NETDOM_ADDED_TLN_CONFLICTS      1616
#define IDS_NETDOM_TLN_NOT_FOUND            1617
#define IDS_NETDOM_TLN_WRONG_TYPE           1618
#define IDS_NETDOM_REMOVE_TLN_FAILED        1619
#define IDS_NETDOM_REMOVE_TLN_SUCCEEDED     1620
#define IDS_NETDOM_FTINFO_INVALID_PARAMETER 1621
#define IDS_NETDOM_FTINFO_NO_FTINFO         1622
#define IDS_NETDOM_FTINFO_NO_TDO            1623
#define IDS_NETDOM_FTINFO_INVALID_STATE     1624
#define IDS_TITLE_GENERAL               2000
#define IDS_USER_TITLE_ORG              2001
#define IDS_USER_TITLE_ACCT             2002
#define IDS_USER_TITLE_MBR_OF           2003
#define IDS_TRUST_PARENTCHILD           2004
#define IDS_TITLE_ADDRESS               2005
#define IDS_TITLE_GROUP                 2006
#define IDS_TITLE_SITE                  2007
#define IDS_CLEAR_TEXT_PW               2008
#define IDS_TITLE_DS_SERVER             2009
#define IDS_RM_MBR_TITLE                2011
#define IDS_INVALID_MAIL_ADDR           2011
#define IDS_RM_MBR_MSG                  2012
#define IDS_REL_MIT                     2013
#define IDS_ERR_BAD_TRUST_PW            2014
#define IDS_PHONE_NOTES                 2016
#define IDS_OBJECT                      2017
#define IDS_INVALID_NAME_FORMAT         2018
#define IDS_MSG_TITLE                   2019
#define IDS_ERRMSG_NO_LONGER_EXISTS     2020
#define IDS_MANAGED_BY_TITLE            2021
#define IDS_TRUST_DIR_INBOUND           2023
#define IDS_TRUST_DIR_OUTBOUND          2024
#define IDS_TRUST_DIR_BIDI              2025
#define IDS_TRUST_DISABLED              2026
#define IDS_ERRMSG_GROUP_DELETE         2027
#define IDS_ERR_CREATE_DIR              2028
#define IDS_ERR_DOMAIN_NOT_FOUND        2029
#define IDS_ERRMSG_INVALID_VOLUME_PATH  2030
#define IDS_ERRMSG_GROUP_CONSTRAINT     2033
#define IDS_TITLE_NTDSDSA_CONN          2034
#define IDS_TITLE_TRUST                 2040
#define IDS_COL_TITLE_DOMAIN            2041
#define IDS_COL_TITLE_RELATION          2042
#define IDS_COL_TITLE_TRANSITIVE        2043
#define IDS_COL_TITLE_ROUTING           2044
#define IDS_REL_PARENT                  2045
#define IDS_REL_CROSSLINK               2046
#define IDS_REL_EXTERNAL                2047
#define IDS_REL_CHILD                   2049
#define IDS_REL_INDIRECT                2050
#define IDS_ERRMSG_PW_MATCH             2051
#define IDS_ERRMSG_NO_DOMAIN            2052
#define IDS_ERRMSG_NO_ACCESS            2053
#define IDS_ERRMSG_INVALID_PATH         2054
#define IDS_TRUST_PW_CHECK_FAILED       2055
#define IDS_TW_PWTOOSHORT_SUBTITLE      2056
#define IDS_TW_PWTOOLONG_SUBTITLE       2057
#define IDS_TW_PWNOTSTRONG_SUBTITLE     2058
#define IDS_TW_PWTOOSHORT_TEXT          2059
#define IDS_TW_PWTOOLONG_TEXT           2060
#define IDS_TW_PWNOTSTRONG_TEXT         2061
#define IDS_TW_PWFILTERDLL_TEXT         2062

#define IDS_REL_UNKNOWN                 2074
#define IDS_ERRMSG_NO_DC_RESPONSE       2076
#define IDS_RM_USR_FROM_GRP             2081
#define IDS_RM_USR_TITLE                2082
#define IDS_ROLE_WKS                    2083
#define IDS_ROLE_SVR                    2084
#define IDS_ERRMSG_INVALID_UNC_PATH     2090
#define IDS_ADS_ERROR_FORMAT            2091
#define IDS_MSG_FORCE_REMOVE_CONFIRM    2092
#define IDS_COL_TITLE_OBJNAME           2093
#define IDS_COL_TITLE_OBJFOLDER         2094
#define IDS_GRP_ALREADY_MEMBER          2095
#define IDS_RM_PRI_GRP                  2096
#define IDS_NT_GRP_TITLE                2097
#define IDS_NOTIFYTIMEOUT               2098
#define IDS_TITLE_DS_SITE_SETTINGS      2099
#define IDS_TITLE_DS_SITE_LICENSE_SETTINGS 2100
#define IDS_TITLE_OS                    2101
#define IDS_ERROR_NOSAMNAME             2102
#define IDS_MIXED_MODE                  2103
#define IDS_ERROR_GRP_SELF              2104
#define IDS_ERR_BAD_ADMIN_PW            2105
#define IDS_TRUST_LOGON_MSG             2106
#define IDS_ERR_NO_TRUST_CHECK          2107
#define IDS_ERR_TRUST_EXISTS            2108
#define IDS_ERR_TRUST_NOT_CREATED       2109
#define IDS_INVALID_SID                 2110
#define IDS_TITLE_NTFRS_REPLICA_SET     2111
#define IDS_TITLE_NTFRS_MEMBER          2112
#define IDS_ADMIN_NOCHANGE              2113
#define IDS_TITLE_NTFRS_SUBSCRIBER      2114
#define IDS_TITLE_FRS_CONNECTION        2115
#define IDS_LOGON_WKSTA                 2116
#define IDS_SHAREDNC_NONE               2117
#define IDS_SHAREDNC_NO_FROM_SERVER     2118
#define IDS_SHAREDNC_BOTH_GCS           2119
#define IDS_COL_TITLE_ERRORMSG          2200
#define IDS_COL_TITLE_PAGE              2201
#define IDS_STATUS_EXCEPTIONS           2202
#define IDS_STATUS_CONFLICT_GONE        2203
#define IDS_STATUS_NEW                  2204
#define IDS_ERR_EXCLUSION_EXISTS        2205
#define IDS_ERR_EXCLUSION_NOT_CHILD     2206
#define IDS_ERR_WRITE_FTI_TO_TDO        2207
#define IDS_ERR_EXCLUSION_CHILD         2208
#define IDC_HELP_BTN                    2209

#define IDS_RM_USR_PRI_GRP              2911
#define IDS_CONNECTION_KCC_GENERATED    3028
#define IDS_YES                         3029
#define IDS_NO                          3030
#define IDS_LOGON_HOURS                 3032
#define IDS_s_LOGON_HOURS_FOR           3033
#define IDS_SCHEDULE                    3034
#define IDS_s_SCHEDULE_FOR              3035
#define IDS_USER_TITLE_PROFILE          3036
#define IDS_CERTCOL_ISSUED_TO           3037
#define IDS_CERTCOL_ISSUED_BY           3038
#define IDS_CERTCOL_PURPOSES            3039
#define IDS_CERTCOL_EXP_DATE            3040
#define IDS_NOT_AVAILABLE               3041
#define IDS_ANY                         3042
#define IDS_CONFIRM_DELETE_CERT         3043
#define IDS_REMOVE_CERT                 3044
#define IDS_CERT_SAVE_FILTER            3045
#define IDS_OPEN_FILE_DLG_TITLE         3046
#define IDS_SAVE_FILE_DLG_TITLE         3047
#define IDS_COPY_TO_FILE                3048
#define IDS_COMMIT_CERT_STORE_CHANGES   3049
#define IDS_UNKNOWN_CERT_FILE_TYPE      3050
#define IDS_USER_TITLE_PUBLISHED_CERTS  3051
#define IDS_DUPLICATE_CERT              3052
#define IDS_ADD_FROM_STORE              3053
#define IDS_NOTIFYFAILURE               3054
#define IDS_CANT_OPEN_STORE             3055
#define IDS_CANT_SAVE_STORE             3056
#define IDS_SITELINK_NEEDS_TWO_SITES    3057
#define IDS_SITELINKBRIDGE_NEEDS_TWO_SITELINKS 3058
#define IDS_CONFIRM_DELETE_CERTS        3059
#define IDS_ERR_DNLEVELNAME_MISSING     3060
#define IDS_CANT_OPEN_STORE_OPEN_READ_ONLY 3061
#define IDS_FPNWPAGE_TITLE              3070
#define IDS_FPNWLOGON_NETWORKADDR       3071
#define IDS_FPNWLOGON_NODEADDR          3072
#define IDS_ALL_NODES                   3073
#define IDS_ERRMSG_NETWORKADDR_REQUIRED 3074
#define IDS_FAILED_TO_LOADFPNWCLNTDLL   3075
#define IDS_FAILED_TO_GETNWUSERINFO     3076
#define IDS_FAILED_TO_GETNWLOGINSCRIPTFILE 3077
#define IDS_FAILED_TO_GETUSERPARMS      3078
#define IDS_FAILED_TO_ENABLE_NWUSER     3079
#define IDS_FAILED_TO_UPDATE_NWPARMS    3080
#define IDS_FAILED_TO_WRITE_NWPARMS     3081
#define IDS_FAILED_TO_UPDATE_LOGINSCRIPTS 3082
#define IDS_INVALID_RELPATH             3083
#define IDS_RPC                         3084
#define IDS_INVALID                     3085
#define IDS_MULTIVALUED                 3086
#define IDS_COMPUTER_DELEGATE           3088
#define IDS_ERROR_VIEW_PERMISSIONS      3089
#define IDS_MSG_USER_NOT_PRESENT        3090
#define IDS_FIRST_COUNTRY_CODE          3091
#define IDS_LAST_COUNTRY_CODE           3092
#define IDS_TRUST_DIR_INBOUND_SHORTCUT  3093
#define IDS_TRUST_DIR_OUTBOUND_SHORTCUT 3094
#define IDS_DEFAULT_ERROR_TEXT          3095
#define IDS_LOCAL_GROUP_ONLY            3096
#define IDS_VIEW_SCHEDULE               3097
#define IDS_CONNECTION_WARNING_MARK     3098
#define IDS_CONNECTION_WARNING_CANNOT_MARK 3099
#define IDS_HOME_DIR_EXISTS             3100
#define IDS_CANT_READ_HOME_DIR_SID      3101
#define IDS_TRUST_BROKEN                3102
#define IDS_SC_RESET_FAILED             3103
#define IDS_HOME_DIR_CREATE_FAILED      3104
#define IDS_SC_QUERY_FAILED             3105
#define IDS_ERR_FINDING_UPN             3106
#define IDI_MEMBER                      3108
#define IDS_USG_MIXED_WARNING           3109
#define IDS_OUT_OF_RANGE                3207
#define IDS_DEFAULT_ERROR_MSG           3208
#define IDS_ERR_CANT_TRUST_SELF         3209
#define IDS_TDO_NOT_FOUND               3210
#define IDC_TRANS_GROUPBOX              3211
#define IDC_TRANS_YES_RADIO             3212
#define IDC_TRANS_NO_RADIO              3213
#define IDC_TRANS_STATIC                3214
#define IDS_MULTI_FAILURE_CAPTION       3215
#define IDS_WARN_NO_GC_FOUND            3216
#define IDS_ALL_USERS_GIVEN_FULL_CONTROL 3227
#define IDS_USER_GIVEN_FULL_CONTROL     3228
#define IDS_FIRST_USER_OWNER_ALL_FULL_CONTROL 3229
#define IDS_WARN_UPN_GC_FOUND_ERROR     3230
#define IDD_TRUSTWIZ_INTRO_PAGE         3231
#define IDD_TRUSTWIZ_NAME_PAGE          3232
#define IDD_TRUSTWIZ_CREDS_PAGE         3233
#define IDD_TRUSTWIZ_PW_MATCH_PAGE      3234
#define IDD_TRUSTWIZ_WIN_OR_MIT_PAGE    3235
#define IDD_TRUSTWIZ_DIRECTION_PAGE     3236
#define IDD_TRUSTWIZ_BIDI_PAGE          3237
#define IDD_TRUSTWIZ_EXTERN_OR_FOREST_PAGE 3238
#define IDC_ENABLE_BTN                  3239
#define IDD_TRUSTWIZ_STATUS_PAGE        3240
#define IDD_TRUSTWIZ_SUMMARY_PAGE       3241
#define IDD_TRUSTWIZ_VERIFY_OUTBOUND_PAGE 3242
#define IDD_TRUSTWIZ_VERIFY_STATUS_PAGE 3243
#define IDD_TRUSTWIZ_SUFFIX_FOR_LOCAL_PAGE 3244
#define IDD_TRUSTWIZ_COMPLETE_OK_PAGE   3245
#define IDD_TRUSTWIZ_DONE_NO_OP_PAGE    3246
#define IDD_TRUSTWIZ_DONE_ERRORS_PAGE   3247
#define IDD_TRUSTWIZ_CONFLICTS_POPUP    3248
#define IDS_TW_NAME_TITLE               3249
#define IDS_TW_NAME_SUBTITLE            3250
#define IDB_TW_BANNER16                 3251
#define IDB_TW_BANNER256                3252
#define IDB_TW_WATER16                  3253
#define IDB_TW_WATER256                 3254
#define IDC_COMPLETE_SUBMSG             3255
#define IDC_TW_INTRO_RICHEDIT           3256
#define IDC_STATIC                      3257
#define IDC_BIG_TITLE                   3258
#define IDS_TW_TITLE                    3259
#define IDC_BIG_COMPLETING              3260
#define IDD_TRUSTWIZ_COMPLETE_VER_ERR_PAGE 3261
#define IDC_MIT_TRUST_RADIO             3262
#define IDC_WIN_TRUST_RADIO             3263
#define IDS_TW_TRANS_TITLE              3264
#define IDS_TW_TRANS_SUBTITLE           3265
#define IDS_TW_PWMATCH_TITLE            3266
#define IDS_TW_PWMATCH_SUBTITLE         3267
#define IDS_TW_CREDS_TITLE              3268
#define IDS_TW_CREDS_SUBTITLE_OTHER     3269
#define IDS_TW_WIN_RADIO_LABEL          3270
#define IDS_TW_WINORMIT_SUBTITLE        3271
#define IDC_TW_CREDS_PROMPT             3272
#define IDS_ROUTING_PAGE_TITLE          3273
#define IDS_TW_TYPE_TITLE               3274
#define IDC_TW_BIDI_RADIO               3275
#define IDC_TW_OUTBOUND_RADIO           3276
#define IDC_TW_INBOUND_RADIO            3277
#define IDS_TW_DIRECTION_TITLE          3278
#define IDS_TW_DIRECTION_SUBTITLE       3279
#define IDC_YES_RADIO                   3280
#define IDC_NO_RADIO                    3281
#define IDS_TW_BIDI_SUBTITLE            3282
#define IDS_TW_BIDI_TITLE               3283
#define IDS_TW_BIDI_SUBTITLE_FOREST     3284
#define IDD_TRUSTWIZ_FAILURE_PAGE       3285
#define IDC_BIG_CANNOT_CONTINUE         3286
#define IDC_FAILPAGE_EDIT1              3287
#define IDC_FAILPAGE_EDIT2              3288
#define IDS_FMT_STRING_ERROR_MSG        3289
#define IDS_MAKE_EXISTING_EXCLUSION     3290
//#define           3291
#define IDI_BULLET                      3292
#define IDS_TW_BIDI_SUBTITLE_REALM      3293
#define IDD_TRUSTWIZ_SELECTIONS         3294
#define IDS_TW_SELECTION_EXISTS         3295
#define IDC_PROGRESS                    3296
#define IDS_TW_SELECTIONS_TITLE         3297
#define IDS_TW_SELECTIONS_SUBTITLE      3298
#define IDS_TW_THIS_DOMAIN              3299
#define IDS_TW_SPECIFIED_DOMAIN         3300
#define IDS_TW_TRUST_TYPE_PREFIX        3301
#define IDS_TW_DIRECTION_PREFIX         3302
#define IDS_WZERR_TYPE_MIT              3303
#define IDS_WZERR_TYPE_UNEXPECTED       3304
#define IDS_WZERR_TYPE_DELETE           3305
#define IDC_WZ_PROGRESS_MSG             3306
#define IDS_WZ_PROGRESS_MSG             3307
#define IDC_CREDMAN                     3308
#define IDS_TW_CREDS_SUBTITLE_LOCAL     3309
#define IDC_CRED_DOMAIN                 3310
#define IDS_CRED_LOCAL_DOMAIN           3311
#define IDS_CRED_OTHER_DOMAIN           3312
#define IDS_CRED_ADMIN_OTHER_PROMPT     3313
#define IDS_CRED_ADMIN_LOCAL_PROMPT     3314
#define IDS_CRED_USER_OTHER_PROMPT      3315
#define IDS_TW_CREDS_SUBTITLE_OTHER_NONADMIN 3316
#define IDC_EXTERNAL_RADIO              3316
#define IDC_FOREST_RADIO                3317
#define IDW_TW_TYPE_TITLE               3318
#define IDW_TW_EXORFOR_SUBTITLE         3319
#define IDD_TRUSTWIZ_TRANSITIVITY_PAGE  3320
#define IDS_ERR_DOMAIN_NOT_FOUND1       3321
#define IDS_ERR_DOMAIN_NOT_FOUND2       3322
#define IDS_WZERR_TYPE_NOT_FOUND        3323
#define IDS_WZERR_TYPE_WIN              3324
#define IDS_TWERR_ALREADY_EXISTS        3325
#define IDS_TWERR_NO_CHANGES            3326
#define IDS_TWERR_NOT_TO_SELF1          3327
#define IDS_TWERR_NOT_TO_SELF2          3328
#define IDS_TWERR_CANT_CHANGE           3329
#define IDS_TW_VERIFY_INBOUND_TITLE     3330
#define IDS_TW_VERIFY_SUBTITLE          3331
#define IDS_VERIFY_TCV_FAILED           3332
#define IDS_VERIFY_TCV_LOGSRV           3333
#define IDS_VERIFY_DOING_RESET          3334
#define IDS_VERIFY_TCV_NSUPP            3335
#define IDS_VERIFY_RESET_FAILED         3336
#define IDS_TW_CREATED_OK               3337
#define IDS_TW_VERIFIED_OK              3338
#define IDS_TW_VERIFIED_BAD             3339
#define IDS_TW_VERIFY_ERR_INBOUND       3340
#define IDS_TRUST_VERIFY_OUTBOUND       3341
#define IDS_TRUST_VERIFY_INBOUND        3342
#define IDS_TW_VERIFY_ERR_OUTBOUND      3343
#define IDS_LOG_EXCLUSION               3344
#define IDS_TW_SEL_ACTION               3345
#define IDS_TW_ATTR_XFOREST             3346
#define IDS_REL_FOREST                  3347
#define IDC_WARN_CREATE_STATIC          3348
#define IDS_TW_STATUS_TITLE             3349
#define IDS_TW_STATUS_SUBTITLE          3350
#define IDS_TW_SUFFIX_FOR_REMOTE_TITLE  3351
#define IDS_TW_SUFFIX_FOR_REMOTE_SUBTITLE 3352
#define IDC_TW_SUFFIX_FOREST            3353
#define IDS_COLLISIONS_MSG              3354
#define IDS_DNT_MSG_TITLE               3355
#define IDS_LOGFILE_CREATE_FAILED       3356
#define IDS_FT_NAMES_PREFIX             3357
#define IDS_WZ_TRANS_YES                3358
#define IDS_WZ_TRANS_NO                 3359
#define IDC_DISABLE_BTN                 3360
#define IDC_SUFFIXES_STATIC             3361
#define IDS_COL_TITLE_SUFFIX            3362
#define IDS_COL_TITLE_STATUS            3363
#define IDC_SAVE_FOREST_NAMES_STATIC    3364
#define IDC_SAVE_FOREST_NAMES_BTN       3365
#define IDS_ROUTING_ERR_NO_DC           3366
#define IDC_SUFFIXES_STATIC_BIG         3367
#define IDS_ROUTING_ENABLED             3368
#define IDS_ROUTING_DISABLED            3369
#define IDS_ROUTING_CONFLICT            3370
#define IDS_ERR_FT_CONTACT_DOMAIN       3371
#define IDS_ERR_FT_TRUST_MISSING        3372
#define IDS_NO_FTINFO                   3373
#define IDS_LOG_ADMIN_DISABLED          3374
#define IDS_LOG_NEW_DISABLED            3375
#define IDS_LOG_NAME_SUFFIX             3376
#define IDS_LOG_DOM_DNS_NAME            3377
#define IDS_LOG_DOM_FLAT_NAME           3378
#define IDS_LOG_STATUS                  3379
#define IDS_LOG_PREFIX                  3380
#define IDS_LOG_ENABLED                 3381
#define IDS_LOG_CONFLICT                3382
#define IDS_LOG_HAS_EXCLUSION           3383
#define IDS_LOG_SID                     3384
#define IDS_ERR_READ_FTINFO             3385
#define IDS_TLNEDIT_NAME_COL            3386
#define IDS_TLNEDIT_STATUS_COL          3387
#define IDS_ROUTING_EXCEPT_ENABLE       3388
#define IDS_ROUTING_EXCEPT_DISABLE      3389
#define IDS_ACCOUNT_OPTIONS_NO_ACCEL    3390
#define IDC_OPTIONS_STATIC              3391
#define IDS_TRUST_VERIFY_TEXT           3392
#define IDS_TRUST_VERIFY_FOREST_TEXT    3393
#define IDS_TRUST_UPDATE_FTINFO         3394
#define IDC_QUARANTINE_STATIC           3395
#define IDC_NO_QUARANTINE_STATIC        3396
#define IDD_QUARANTINED_TRUST           3397
#define IDC_QUARANTINE_POPUP_STATIC     3398
#define IDC_QUARANTINE_POPUP_CHK        3399

// NOTE: strings in the range 3999 to 4400 are reserved for the
// ISO-3166 country code strings.

#define IDS_MSG_NO_DOWNLEVEL_PROPERTIES 3400
#define IDS_MSG_MEMBER_ALREADY_GONE     3401
#define IDS_MSG_MEMBER_ALREADY_GONE2    3402
#define IDS_WARN_ACCESS_TO_GC_DENIED    3403
#define IDS_SAMNAME_ILLEGAL             3404
#define IDS_LOGINNAME_ILLEGAL           3405
#define IDS_GROUP_SAMNAME_ILLEGAL       3406
#define IDC_WARNING_STATIC              3407
#define IDD_COMPUTER_DELEGATION         3420
#define IDC_NO_TRUST_RADIO              3421
#define IDC_ANY_SERVICE_RADIO           3422
#define IDC_SPECIFIED_SERVICES_RADIO    3423
#define IDC_KERBEROS_ONLY_RADIO         3424
#define IDC_ANY_RADIO                   3425
#define IDC_SERVICES_LIST               3426
#define IDC_ADD_BUTTON                  3427
#define IDC_REMOVE_BUTTON               3428
#define IDS_TITLE_DELEGATION            3429
#define IDC_LIST_STATIC                 3430
#define IDD_SELECT_SERVICES_DIALOG      3440
#define IDC_USERS_COMPUTERS_BUTTON      3441
#define IDC_SELECT_ALL_BUTTON           3443
#define IDS_SERVICE_TYPE_COLUMN         3450
#define IDS_USER_OR_COMPUTER_COLUMN     3451
#define IDS_PORT_COLUMN                 3452
#define IDS_SERVICE_NAME_COLUMN         3453
#define IDS_DOMAIN_COLUMN               3454
#define IDS_NO_TRUST_USER_RADIO         3455
#define IDS_ANY_SERVICE_USER_RADIO      3456
#define IDS_SPECIFIED_SERVICES_USER_RADIO 3457
#define IDS_ERROR_MUST_HAVE_SPN         3458
#define IDC_NO_OBJECT_WITH_SPN          3459
#define IDS_SITE_REPL_CIRCULAR_REFERENCE 3460
#define IDC_EXPAND_CHECK                3461
#define IDS_DEFAULT_SITE                3462
#define IDS_HOME_DIR_IS_ROOT            3463
#define IDS_HOME_DIR_IS_ROOT_MULTI      3464
#define IDS_CREATE_DIR_MULTI_FAILED_BUT_CONTINUE 3465
#define IDS_CREATE_DIR_MULTI_FAILED_ACCESS_DENIED_BUT_CONTINUE 3466

// NOTE: strings in the range 3999 to 4400 are reserved for the
// ISO-3166 country code strings.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\propbase.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       propbase.cxx
//
//  Contents:   CDsPropPageBase, the base class for property page classes.
//
//  History:    31-March-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"

//+----------------------------------------------------------------------------
//
//  Member:     CADsApplyErrors::~CADsApplyErrors
//
//-----------------------------------------------------------------------------
CADsApplyErrors::~CADsApplyErrors()
{
  if (m_pszTitle != NULL)
  {
    delete[] m_pszTitle;
  }

  Clear();
}



//+----------------------------------------------------------------------------
//
//  Member:     CADsApplyErrors::SetError
//
//-----------------------------------------------------------------------------
void CADsApplyErrors::SetError(PADSPROPERROR pError)
{
  if (m_nCount == m_nArraySize)
  {
    PAPPLY_ERROR_ENTRY pNewTable = new APPLY_ERROR_ENTRY[m_nCount + m_nIncAmount];
    m_nArraySize = m_nCount + m_nIncAmount;

    if (pNewTable != NULL)
    {
      memset(pNewTable, 0, sizeof(APPLY_ERROR_ENTRY) * (m_nCount + m_nIncAmount));

      if (m_pErrorTable != NULL)
      {
        for (UINT nIdx = 0; nIdx < m_nCount; nIdx++)
        {
          pNewTable[nIdx].pszPath = m_pErrorTable[nIdx].pszPath;
          pNewTable[nIdx].pszClass = m_pErrorTable[nIdx].pszClass;
          pNewTable[nIdx].hr = m_pErrorTable[nIdx].hr;
          pNewTable[nIdx].pszStringError = m_pErrorTable[nIdx].pszStringError;
        }
        delete[] m_pErrorTable;
      }
      m_pErrorTable = pNewTable;
    }
  }

  //
  // Copy the path to the object
  //
  if (pError->pszObjPath != NULL)
  {
    m_pErrorTable[m_nCount].pszPath = new WCHAR[wcslen(pError->pszObjPath) + 1];
    dspAssert(m_pErrorTable[m_nCount].pszPath != NULL);
    if (m_pErrorTable[m_nCount].pszPath != NULL)
    {
      wcscpy(m_pErrorTable[m_nCount].pszPath, pError->pszObjPath);
    }
  }

  //
  // Copy the class to the object
  //
  if (pError->pszObjClass != NULL)
  {
    // Note: this memory is freed in the Clear() method which is called from
    // the class destructor

    m_pErrorTable[m_nCount].pszClass = new WCHAR[wcslen(pError->pszObjClass) + 1];
    dspAssert(m_pErrorTable[m_nCount].pszClass != NULL);
    if (m_pErrorTable[m_nCount].pszClass != NULL)
    {
      wcscpy(m_pErrorTable[m_nCount].pszClass, pError->pszObjClass);
    }
  }

  //
  // Copy the error
  //
  if (pError->hr != S_OK)
  {
    m_pErrorTable[m_nCount].hr = pError->hr;
  }
  else
  {
    if (pError->pszError != NULL)
    {
      m_pErrorTable[m_nCount].pszStringError = new WCHAR[wcslen(pError->pszError) + 1];
      dspAssert(m_pErrorTable[m_nCount].pszStringError != NULL);
      if (m_pErrorTable[m_nCount].pszStringError != NULL)
      {
        wcscpy(m_pErrorTable[m_nCount].pszStringError, pError->pszError);
      }
    }
  }

  //
  // Copy the page title
  //
  if (pError->pszPageTitle != NULL)
  {
    m_pszTitle = new WCHAR[wcslen(pError->pszPageTitle) + 1];
    if (m_pszTitle != NULL)
    {
      wcscpy(m_pszTitle, pError->pszPageTitle);
    }
  }

  m_nCount++;
}

//+----------------------------------------------------------------------------
//
//  Member:     CADsApplyErrors::GetError
//
//-----------------------------------------------------------------------------
HRESULT CADsApplyErrors::GetError(UINT nIndex)
{
  dspAssert(nIndex < m_nCount);
  if (nIndex < m_nCount)
  {
    return m_pErrorTable[nIndex].hr;
  }
  return S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CADsApplyErrors::GetStringError
//
//-----------------------------------------------------------------------------
PWSTR CADsApplyErrors::GetStringError(UINT nIndex)
{
  dspAssert(nIndex < m_nCount);
  if (nIndex < m_nCount)
  {
    return m_pErrorTable[nIndex].pszStringError;
  }
  return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CADsApplyErrors::Clear
//
//-----------------------------------------------------------------------------
void CADsApplyErrors::Clear()
{
  if (m_pErrorTable != NULL)
  {
    for (UINT idx = 0; idx < m_nCount; idx++)
    {
      if (m_pErrorTable[idx].pszPath != NULL)
      {
        delete[] m_pErrorTable[idx].pszPath;
        m_pErrorTable[idx].pszPath = NULL;
      }
      if (m_pErrorTable[idx].pszClass != NULL)
      {
        delete[] m_pErrorTable[idx].pszClass;
        m_pErrorTable[idx].pszClass = NULL;
      }
      if (m_pErrorTable[idx].pszStringError != NULL)
      {
        delete[] m_pErrorTable[idx].pszStringError;
        m_pErrorTable[idx].pszStringError = NULL;
      }
    }
    delete[] m_pErrorTable;
    m_pErrorTable = NULL;
  }

  m_nCount = 0;
  m_nArraySize = 0;
}

//+----------------------------------------------------------------------------
//
//  Member:     CADsApplyErrors::GetName
//
//-----------------------------------------------------------------------------
PWSTR CADsApplyErrors::GetName(UINT nIndex)
{
  dspAssert(nIndex < m_nCount);
  if (nIndex < m_nCount)
  {
    return m_pErrorTable[nIndex].pszPath;
  }
  return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CADsApplyErrors::GetClass
//
//-----------------------------------------------------------------------------
PWSTR CADsApplyErrors::GetClass(UINT nIndex)
{
  dspAssert(nIndex < m_nCount);
  if (nIndex < m_nCount)
  {
    return m_pErrorTable[nIndex].pszClass;
  }
  return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageBase::CDsPropPageBase
//
//-----------------------------------------------------------------------------
CDsPropPageBase::CDsPropPageBase(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                 HWND hNotifyObj, DWORD dwFlags) :
    m_hPage(NULL),
    m_fInInit(FALSE),
    m_fPageDirty(FALSE),
    m_fReadOnly(FALSE),
    m_fMultiselectPage(FALSE),
    m_pDataObj(pDataObj),
    m_pWPTDataObj(NULL),
    m_pDataObjStrm(NULL),
    m_pDsObj(NULL),
    m_nPageTitle(pDsPage->nPageTitle),
    m_nDlgTemplate(pDsPage->nDlgTemplate),
    m_cAttrs(pDsPage->cAttrs),
    m_rgpAttrMap(pDsPage->rgpAttrMap),
    m_pwszObjPathName(NULL),
    m_pwszObjClass(NULL),
    m_pwszRDName(NULL),
    m_pDispSpec(NULL),
    m_pObjSel(NULL),
    m_fObjSelInited(FALSE),
    m_rgAttrData(NULL),
    m_uRefs(1),
    m_hNotifyObj(hNotifyObj),
    m_pWritableAttrs(NULL),
    m_hrInit(S_OK)
{
    TRACE2(CDsPropPageBase,CDsPropPageBase);
    //
    // Get the read-only state.
    //
    if (dwFlags & DSOBJECT_READONLYPAGES)
    {
        m_fReadOnly = TRUE;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageBase::~CDsPropPageBase
//
//-----------------------------------------------------------------------------
CDsPropPageBase::~CDsPropPageBase()
{
  TRACE2(CDsPropPageBase,~CDsPropPageBase);
  if (m_pwszObjPathName)
  {
    delete m_pwszObjPathName;
  }
  if (m_pwszObjClass)
  {
    delete m_pwszObjClass;
  }
  if (m_pwszRDName)
  {
    delete m_pwszRDName;
  }
  if (m_rgAttrData)
  {
    delete [] m_rgAttrData;
  }
  if (m_pObjSel)
  {
    m_pObjSel->Release();
  }
  if (m_pDispSpec)
  {
    m_pDispSpec->Release();
  }
  if (m_pDataObjStrm)
  {
    m_pDataObjStrm->Release();
  }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::Init
//
//  Synopsis:   Initialize the page object. This is the second part of a two
//              phase creation where operations that could fail are located.
//              Failures here are recorded in m_hrInit and then an error page
//              is substituted in CreatePage.
//
//-----------------------------------------------------------------------------
void
CDsPropPageBase::Init(PWSTR pwzADsPath, LPWSTR pwzClass, const CDSSmartBasePathsInfo& basePathsInfo)
{
    TRACE(CDsPropPageBase,Init);
    CWaitCursor cWait;
    ADSPROPINITPARAMS InitParams = {0};
    InitParams.dwSize = sizeof(ADSPROPINITPARAMS);

    ADsPropGetInitInfo(m_hNotifyObj, &InitParams);

    if (FAILED(InitParams.hr))
    {
        m_hrInit = InitParams.hr;
        return;
    }

    m_basePathsInfo = basePathsInfo;

    if (!AllocWStr(pwzADsPath, &m_pwszObjPathName) ||
        !AllocWStr(InitParams.pwzCN, &m_pwszRDName)      ||
        !AllocWStr(pwzClass, &m_pwszObjClass))
    {
        m_hrInit = E_OUTOFMEMORY;
        return;
    }

    dspAssert(InitParams.pDsObj);

    m_pDsObj = InitParams.pDsObj;
    DBG_OUT("+++++++++++++++++++++++++++addrefing object");
    m_pDsObj->AddRef();

    m_pWritableAttrs = InitParams.pWritableAttrs;

    //
    // Allocate memory for the attribute data.
    //
    m_rgAttrData = new ATTR_DATA[m_cAttrs];
    CHECK_NULL(m_rgAttrData, m_hrInit = E_OUTOFMEMORY; return);

    memset(m_rgAttrData, 0, m_cAttrs * sizeof(ATTR_DATA));

    //
    // Marshall the data object pointer for passing to the window proc thread.
    //
    HRESULT hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, m_pDataObj,
                                               &m_pDataObjStrm);
    m_pDataObj = NULL; // to make sure no one calls here
    CHECK_HRESULT(hr, m_hrInit = hr; return);

}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::CreatePage
//
//  Synopsis:   Create the prop page
//
//-----------------------------------------------------------------------------
HRESULT
CDsPropPageBase::CreatePage(HPROPSHEETPAGE * phPage)
{
    TCHAR szTitle[MAX_PATH];
    if (!LoadStringReport(m_nPageTitle, szTitle, MAX_PATH, NULL))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    PROPSHEETPAGE   psp;

    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = PSP_USECALLBACK | PSP_USETITLE;
    psp.pszTemplate = MAKEINTRESOURCE((SUCCEEDED(m_hrInit)) ? m_nDlgTemplate : IDD_ERROR_PAGE);
    psp.pfnDlgProc  = StaticDlgProc;
    psp.pfnCallback = PageCallback;
    psp.pcRefParent = NULL; // do not set PSP_USEREFPARENT
    psp.lParam      = (LPARAM) this;
    psp.hInstance   = g_hInstance;
    psp.pszTitle    = szTitle;

    *phPage = CreatePropertySheetPage(&psp);

    if (*phPage == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::StaticDlgProc
//
//  Synopsis:   static dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CDsPropPageBase::StaticDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDsPropPageBase * pPage = (CDsPropPageBase *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE)lParam;

        pPage = (CDsPropPageBase *) ppsp->lParam;
        pPage->m_hPage = hDlg;

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pPage);

        if (pPage->m_pDataObjStrm)
        {
            // Unmarshall the Data Object pointer.
            //
            HRESULT hr;
            hr = CoGetInterfaceAndReleaseStream(pPage->m_pDataObjStrm,
                                                IID_IDataObject,
                                                reinterpret_cast<void**>(&pPage->m_pWPTDataObj));
            CHECK_HRESULT_REPORT(hr, hDlg, return FALSE);

            // The stream should have been released above so set the
            // pointer to NULL so that we don't try to release again

            pPage->m_pDataObjStrm = 0;
        }
        return pPage->DlgProc(hDlg, uMsg, wParam, lParam);
    }

    if (pPage != NULL && (SUCCEEDED(pPage->m_hrInit)))
    {
        if (uMsg == WM_ADSPROP_PAGE_GET_NOTIFY)
        {
            HWND* pHWnd = (HWND*)wParam;
            *pHWnd = pPage->m_hNotifyObj;
            return TRUE;
        }
        return pPage->DlgProc(hDlg, uMsg, wParam, lParam);
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::InitDlg
//
//  Synopsis:   Handles dialog initialization for error cases. Passes non-
//              error initialization to subclass' OnInitDialog.
//
//-----------------------------------------------------------------------------
LRESULT CDsPropPageBase::InitDlg(LPARAM lParam)
{
    m_fInInit = TRUE;

    if (FAILED(m_hrInit))
    {
        // Bind to the object failed, display an error page with the error
        // message string.
        //
        PTSTR ptz = NULL;
        BOOL fSpecialCaseErr = TRUE;

        switch (HRESULT_CODE(m_hrInit))
        {
        case ERROR_DS_NO_ATTRIBUTE_OR_VALUE:
            LoadStringToTchar(IDS_ERROR_VIEW_PERMISSIONS, &ptz);
            break;

        case ERROR_DS_REFERRAL:
            LoadStringToTchar(IDS_ERRMSG_NO_DC_RESPONSE, &ptz);
            break;

        case ERROR_DS_NO_SUCH_OBJECT:
            LoadStringToTchar(IDS_ERRMSG_NO_LONGER_EXISTS, &ptz);
            break;

        default:
            fSpecialCaseErr = FALSE;
            break;
        }

        if (fSpecialCaseErr && ptz)
        {
            SetWindowText(GetDlgItem(m_hPage, IDC_ERROR_MSG), ptz);
            delete ptz;
        }
        else
        {
            int cch;

            cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                | FORMAT_MESSAGE_FROM_SYSTEM, NULL, m_hrInit,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (PTSTR)&ptz, 0, NULL);
            if (!cch)
            {
                // Try ADSI errors.
                //
                cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                    | FORMAT_MESSAGE_FROM_HMODULE,
                                    GetModuleHandle(TEXT("activeds.dll")), m_hrInit,
                                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                    (PTSTR)&ptz, 0, NULL);
            }

            if (cch)
            {
                SetWindowText(GetDlgItem(m_hPage, IDC_ERROR_MSG), ptz);
                LocalFree(ptz);
            }
        }
        m_fInInit = FALSE;
        return S_OK;
    }

    HRESULT hResult = OnInitDialog(lParam);

    m_fInInit = FALSE;
    return hResult;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnNotify
//
//  Synopsis:   Handles notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnNotify(WPARAM, LPARAM lParam)
{
    LRESULT lResult;
    BOOL fPageDirty;

    switch (((LPNMHDR)lParam)->code)
    {
    case PSN_APPLY:
        if (FAILED(m_hrInit))
        {
            return PSNRET_NOERROR;
        }
        lResult = PSNRET_NOERROR;
        //
        // The member var m_fPageDirty gets cleared in OnApply, so save a local
        // copy for passing as the wParam of the WM_ADSPROP_NOTIFY_APPLY msg.
        //
        fPageDirty = m_fPageDirty;

        if (m_fPageDirty)
        {
            // Call the virtual function OnApply()
            lResult = OnApply();
        }
        // Store the result into the dialog
        SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, (LONG_PTR)lResult);
        if (lResult == PSNRET_NOERROR)
        {
          m_fPageDirty = FALSE;
          //
          // Signal the change notification. Note that the notify-apply
          // message must be sent even if the page is not dirty so that the
          // notify ref-counting will properly decrement.
          //
          SendMessage(m_hNotifyObj, WM_ADSPROP_NOTIFY_APPLY, fPageDirty, (LPARAM)m_hPage);
        }
        else
        {
          EnableWindow(GetDlgItem(GetParent(m_hPage), IDCANCEL), TRUE);
        }
        return lResult;

    case PSN_RESET:
        OnCancel();
        return FALSE; // allow the property sheet to be destroyed.

    case PSN_SETACTIVE:
        return OnPSNSetActive(lParam);

    case PSN_KILLACTIVE:
        return OnPSNKillActive(lParam);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnCommand
//
//  Synopsis:   Handles the WM_COMMAND message
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    dspDebugOut((DEB_USER3, "CDsPropPageBase::OnCommand - id: %d, code: %x\n",
                 id, codeNotify));

    if ((codeNotify == EN_CHANGE) && !m_fInInit)
    {
        SetDirty();
    }
    if ((codeNotify == BN_CLICKED) && (id == IDCANCEL))
    {
        //
        // Pressing ESC in a multi-line edit control results in this
        // WM_COMMAND being sent. Pass it on to the parent (the sheet proc) to
        // close the sheet.
        //
        PostMessage(GetParent(m_hPage), WM_COMMAND, MAKEWPARAM(id, codeNotify),
                    (LPARAM)hwndCtl);
    }
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::CheckIfPageAttrsWritable
//
//  Synopsis:   See which attributes are writable by checking if they are in
//              the allowedAttributesEffective array.
//
//  Notes:      The m_rgAttrData array is 1 to 1 with the m_rgpAttrMap array.
//-----------------------------------------------------------------------------
void
CDsPropPageBase::CheckIfPageAttrsWritable(void)
{
    DWORD iAllowed;

    if (m_fReadOnly || !m_pWritableAttrs)
    {
        return;
    }

    for (DWORD iAttrs = 0; iAttrs < m_cAttrs; iAttrs++)
    {
        if (m_rgpAttrMap[iAttrs]->AttrInfo.pszAttrName)
        {
            for (iAllowed = 0; iAllowed < m_pWritableAttrs->dwNumValues; iAllowed++)
            {
                if (_wcsicmp(m_rgpAttrMap[iAttrs]->AttrInfo.pszAttrName,
                             m_pWritableAttrs->pADsValues[iAllowed].CaseIgnoreString) == 0)
                {
                    ATTR_DATA_SET_WRITABLE(m_rgAttrData[iAttrs]);
                    break;
                }
            }
        }
    }
    return;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::CheckIfWritable
//
//  Synopsis:   See if the attribute is writable by checking if it is in
//              the allowedAttributesEffective array.
//
//-----------------------------------------------------------------------------
BOOL
CDsPropPageBase::CheckIfWritable(const PWSTR & wzAttr)
{
    BOOL fWritable = FALSE;

    if (m_fReadOnly || !m_pWritableAttrs)
    {
        return FALSE;
    }

    for (DWORD i = 0; i < m_pWritableAttrs->dwNumValues; i++)
    {
        if (_wcsicmp(m_pWritableAttrs->pADsValues[i].CaseIgnoreString,
                     wzAttr) == 0)
        {
            fWritable = TRUE;
            break;
        }
    }
    return fWritable;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnCancel
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnCancel(void)
{
    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnSetFocus
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnSetFocus(HWND)
{
    // An application should return zero if it processes this message.
    return 1;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnPSNSetActive
//
//  Synopsis:   Page activation event.
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnPSNSetActive(LPARAM)
{
    SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, 0);
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnPSNKillActive
//
//  Synopsis:   Page deactivation event (when other pages cover this one).
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnPSNKillActive(LPARAM)
{
    SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, 0);
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnDestroy(void)
{
    return 1;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnShowWindow
//
//  Synopsis:   On dialog window show operations, resizes the view window.
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnShowWindow(void)
{
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::GetIDispSpec
//
//  Synopsis:   If needed, create the interface instance and return the pointer.
//
//-----------------------------------------------------------------------------
HRESULT
CDsPropPageBase::GetIDispSpec(IDsDisplaySpecifier ** ppDispSpec)
{
    HRESULT hr;
    TRACE2(CDsPropPageBase, GetIDispSpec);
    if (!m_pDispSpec)
    {
        hr = CoCreateInstance(CLSID_DsDisplaySpecifier, NULL, CLSCTX_INPROC_SERVER,
                              IID_IDsDisplaySpecifier, (PVOID *)&m_pDispSpec);

        CHECK_HRESULT(hr, return hr);

        CStrW strDC;

        CComPtr<IDirectoryObject> spDsObj;
        if (m_pDsObj == NULL)
        {
          //
          // For the retrieval of the DS Object names
          //
          FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
          STGMEDIUM objMedium;
          hr = m_pWPTDataObj->GetData(&fmte, &objMedium);
          CHECK_HRESULT(hr, return hr);

          LPDSOBJECTNAMES pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

          //
          // Get the objects path 
          //
          LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                                   pDsObjectNames->aObjects[0].offsetName);

          //
          // Bind to the object
          //
          hr = DSAdminOpenObject(pwzObjADsPath,  
                                 IID_IDirectoryObject, 
                                 (PVOID*)&spDsObj);

          ReleaseStgMedium(&objMedium);

          CHECK_HRESULT(hr, return hr);
        }
        else
        {
          spDsObj = m_pDsObj;
        }
        hr = GetLdapServerName(spDsObj, strDC);

        CHECK_HRESULT(hr, return hr);

        hr = m_pDispSpec->SetServer(strDC, NULL, NULL, 0);

        CHECK_HRESULT(hr, return hr);
    }
    if (ppDispSpec)
    {
        *ppDispSpec = m_pDispSpec;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::GetADsPathname
//
//  Synopsis:   If needed, create the interface instance and return the pointer.
//
//-----------------------------------------------------------------------------
HRESULT
CDsPropPageBase::GetADsPathname(CComPtr<IADsPathname>& refADsPath)
{
    HRESULT hr;

    if (!m_pADsPath)
    {
        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                              IID_IADsPathname, (PVOID *)&m_pADsPath);

        CHECK_HRESULT(hr, return hr);
    }
    refADsPath = m_pADsPath;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::SkipPrefix
//
//  Synopsis:   Given an object name, returns a buffer containing the same
//              name without the provider/server prefix. The buffer must be
//              freed using delete.
//
//  Notes: The fX500 parameter defaults to true and applies whenever the
//         input path uses the LDAP provider prefix. The path cracker
//         interface can be used to strip the prefix in this case. However,
//         if the provider is WINNT, then the path cracker doesn't give the
//         desired results so simple string manipulation is used instead.
//-----------------------------------------------------------------------------
HRESULT
CDsPropPageBase::SkipPrefix(PWSTR pwzObj, PWSTR * ppResult, BOOL fX500)
{
    if (fX500)
    {
        // Strip of the "LDAP://" prefix using the path cracker.
        //
        CComPtr<IADsPathname> spPathname;
        HRESULT hr = GetADsPathname(spPathname);

        CHECK_HRESULT(hr, return hr);

        hr = spPathname->Set(CComBSTR(pwzObj), ADS_SETTYPE_FULL);

        CHECK_HRESULT(hr, return hr);

        BSTR bstr;

        hr = spPathname->Retrieve(ADS_FORMAT_X500_DN, &bstr);

        CHECK_HRESULT(hr, return hr);

        if (!AllocWStr(bstr, ppResult))
        {
            SysFreeString(bstr);
            return E_OUTOFMEMORY;
        }

        SysFreeString(bstr);
    }
    else
    {
        // Strip off the "WINNT://" prefix.
        //
        if (wcslen(pwzObj) < 9 || pwzObj[7] != L'/')
        {
            // Can't be a valid WINNT name if not at least "WINNT://x"
            //
            return E_INVALIDARG;
        }
        
        if (!AllocWStr(&pwzObj[8], ppResult))
        {
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::AddLdapPrefix
//
//  Synopsis:   Given an object name, returns same name with the LDAP provider
//              prefix. The server name is also added by default.
//
//-----------------------------------------------------------------------------
HRESULT
CDsPropPageBase::AddLDAPPrefix(PWSTR pwzObj, CStrW &pstrResult, BOOL fServer)
{
    return ::AddLDAPPrefix(this, pwzObj, pstrResult, fServer);
}

//
// Non-class member version.
//
HRESULT
AddLDAPPrefix(CDsPropPageBase * pPage, PWSTR pwzObj, CStrW &strResult,
              BOOL fServer)
{
    HRESULT hr;
    CComPtr<IADsPathname> spPathCracker;
    strResult.Empty();

    if (pPage)
    {
        hr = pPage->GetADsPathname(spPathCracker);

        CHECK_HRESULT(hr, return hr);
    }
    else
    {
        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                              IID_IADsPathname, (PVOID *)&spPathCracker);

        CHECK_HRESULT(hr, return hr);
    }

    hr = spPathCracker->Set(CComBSTR(L"LDAP"), ADS_SETTYPE_PROVIDER);

    CHECK_HRESULT(hr, return hr);

    if (pPage)
    {
        CStrW strDC;

        CComPtr<IDirectoryObject> spDsObj;
        if (pPage->m_pDsObj == NULL)
        {
          //
          // For the retrieval of the DS Object names
          //
          FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
          STGMEDIUM objMedium;
          hr = pPage->m_pWPTDataObj->GetData(&fmte, &objMedium);
          CHECK_HRESULT(hr, return hr);

          LPDSOBJECTNAMES pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

          //
          // Get the objects path 
          //
          LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                                   pDsObjectNames->aObjects[0].offsetName);

          //
          // Bind to the object
          //
          hr = DSAdminOpenObject(pwzObjADsPath, 
                                 IID_IDirectoryObject, 
                                 (PVOID*)&spDsObj);

          ReleaseStgMedium(&objMedium);

          CHECK_HRESULT(hr, return hr);
        }
        else
        {
          spDsObj = pPage->m_pDsObj;
        }
        hr = GetLdapServerName(spDsObj, strDC);

        CHECK_HRESULT(hr, return hr);

        hr = spPathCracker->Set(CComBSTR(strDC), ADS_SETTYPE_SERVER);

        CHECK_HRESULT(hr, return hr);
    }

    hr = spPathCracker->Set(CComBSTR(pwzObj), ADS_SETTYPE_DN);

    CHECK_HRESULT(hr, return hr);

    CComBSTR bstr;

    hr = spPathCracker->Retrieve((fServer) ? ADS_FORMAT_X500 : ADS_FORMAT_X500_NO_SERVER,
                                &bstr);

    CHECK_HRESULT(hr, return hr);

    strResult = bstr;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::GetObjSel
//
//  Synopsis:   CoCreates the object picker if needed, returns the pointer.
//
//-----------------------------------------------------------------------------
HRESULT
CDsPropPageBase::GetObjSel(IDsObjectPicker ** ppObjSel, PBOOL pfIsInited)
{
    HRESULT hr;
    TRACE2(CDsPropPageBase,GetObjSel);

    if (!m_pObjSel)
    {
        hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker, (PVOID *)&m_pObjSel);
        if (FAILED(hr))
        {
            REPORT_ERROR(hr, m_hPage);
            return hr;
        }
    }

    *ppObjSel = m_pObjSel;

    if (pfIsInited)
    {
        *pfIsInited = m_fObjSelInited;
    }

    return S_OK;
}

#ifdef DO_HELP
#include "helpids.h"
#endif

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnHelp
//
//  Synopsis:   Put up popup help for the control.
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnHelp(LPHELPINFO pHelpInfo)
{
    dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                 pHelpInfo->iCtrlId, pHelpInfo->dwContextId));
    if (pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
    {
        return 0;
    }
    WinHelp(m_hPage, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);
#ifdef DONT_DO_THIS
    WinHelp((HWND)pHelpInfo->hItemHandle, DSPROP_HELP_FILE_NAME, HELP_WM_HELP, (DWORD)g_aHelpIDs);
#endif

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::PageCallback
//
//  Synopsis:   Callback used to free the CDsPropPageBase object when the
//              property sheet has been destroyed.
//
//-----------------------------------------------------------------------------
UINT CALLBACK
CDsPropPageBase::PageCallback(HWND hDlg, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    TRACE_FUNCTION(CDsPropPageBase::PageCallback);

    if (uMsg == PSPCB_RELEASE)
    {
        //
        // Determine instance that invoked this static function
        //
        CDsPropPageBase * pPage = (CDsPropPageBase *) ppsp->lParam;

        //
        // Call all function pointers so that they can do any needed cleanup.
        //
        if (SUCCEEDED(pPage->m_hrInit))
        {
            for (DWORD i = 0; i < pPage->m_cAttrs; i++)
            {
                if (pPage->m_rgpAttrMap[i]->pAttrFcn)
                {
                    (*pPage->m_rgpAttrMap[i]->pAttrFcn)(pPage,
                                                        pPage->m_rgpAttrMap[i],
                                                        NULL, 0,
                                                        &pPage->m_rgAttrData[i],
                                                        fOnCallbackRelease);
                }
            }
        }

        if (IsWindow(pPage->m_hNotifyObj))
        {
            SendMessage(pPage->m_hNotifyObj, WM_ADSPROP_NOTIFY_EXIT, 0, 0);
        }

        // Release on same thread on which created.
        //
        DO_RELEASE(pPage->m_pWPTDataObj);

        //DBG_OUT("-----------------------releasing object in page callback.");
        DO_RELEASE(pPage->m_pDsObj);

        dspDebugOut((DEB_ITRACE, "Deleting CDsPropPageBase instance 0x%x\n",
                     pPage));

        pPage->Release();

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageBase::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPageBase::QueryInterface(REFIID riid, void ** ppvObject)
{
    TRACE2(CDsPropPageBase,QueryInterface);
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageBase::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPageBase::AddRef(void)
{
    dspDebugOut((DEB_USER2, "CDsPropPageBase::AddRef refcount going in %d\n", m_uRefs));
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageBase::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    zero if the reference count is zero or non-zero otherwise
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPageBase::Release(void)
{
    dspDebugOut((DEB_USER2, "CDsPropPageBase::Release ref count going in %d\n", m_uRefs));
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetLdapServerName
//
//  Synopsis:   Given an IDirectoryObject* that supports IADsObjectOptions, it
//              returns the server name ADSI is bound to.
//
//-----------------------------------------------------------------------------
HRESULT
GetLdapServerName(IUnknown * pDsObj, CStrW& strServer)
{
    HRESULT hr;

    strServer.Empty();

    CComPtr<IADsObjectOptions> spIADsObjectOptions;

    hr = pDsObj->QueryInterface(IID_IADsObjectOptions, (void**)&spIADsObjectOptions);

    CHECK_HRESULT(hr, return hr);

    CComVariant var;
    hr = spIADsObjectOptions->GetOption(ADS_OPTION_SERVERNAME, &var);

    CHECK_HRESULT(hr, return hr);

    dspAssert(var.vt == VT_BSTR);
    strServer = V_BSTR(&var);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   BindToGCcopyOfObj
//
//  Synopsis:   Bind to the GC copy of the object.
//
//-----------------------------------------------------------------------------
HRESULT
BindToGCcopyOfObj(CDsPropPageBase * pPage, PWSTR pwzObjADsPath,
                  IDirectoryObject ** ppDsObj)
{
    CSmartWStr cswzCleanObj;
    PWSTR pwzDnsDom;
    PDOMAIN_CONTROLLER_INFOW pDCInfo;
    HRESULT hr = pPage->SkipPrefix(pwzObjADsPath, &cswzCleanObj);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    // To bind to a GC, you need to supply the tree root domain name rather
    // than the server path because the current DC/domain may not be hosting a
    // GC.
    //
    hr = CrackName(cswzCleanObj, &pwzDnsDom, GET_DNS_DOMAIN_NAME, pPage->GetHWnd());

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    DWORD dwErr = DsGetDcNameW(NULL,
                               pwzDnsDom,
                               NULL,NULL,
                               DS_DIRECTORY_SERVICE_REQUIRED,
                               &pDCInfo);
    LocalFreeStringW(&pwzDnsDom);
    hr = HRESULT_FROM_WIN32(dwErr);
    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    CComPtr<IADsPathname> spADsPath;
    long lEscapeMode;

    hr = pPage->GetADsPathname(spADsPath);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    spADsPath->get_EscapedMode(&lEscapeMode);

    hr = spADsPath->Set(CComBSTR(L"GC"), ADS_SETTYPE_PROVIDER);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    hr = spADsPath->Set(CComBSTR(pDCInfo->DnsForestName), ADS_SETTYPE_SERVER);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    NetApiBufferFree(pDCInfo);

    hr = spADsPath->Set(CComBSTR((PCWSTR)cswzCleanObj), ADS_SETTYPE_DN);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    spADsPath->put_EscapedMode(ADS_ESCAPEDMODE_ON);

    CComBSTR bstrEscapedPath;

    hr = spADsPath->Retrieve(ADS_FORMAT_X500, &bstrEscapedPath);

    // restore defaults
    spADsPath->Set(CComBSTR(L"LDAP"), ADS_SETTYPE_PROVIDER);
    spADsPath->put_EscapedMode(lEscapeMode);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    dspDebugOut((DEB_ITRACE, "Binding to object at %ws\n", bstrEscapedPath));

    hr = DSAdminOpenObject(bstrEscapedPath, 
                           IID_IDirectoryObject, 
                           (PVOID*)ppDsObj);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\pch.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       pch.h
//
//  Contents:   precompiled includes
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------
#ifndef _pch_h
#define _pch_h

#ifdef UNICODE
#   ifndef _UNICODE
#       define _UNICODE
#   endif
#endif


//
// Some public headers are still failing on these warnings
// so they need to be disabled in both chk and fre
//
//#ifndef DBG

#pragma warning (disable: 4189 4100)

//#endif // DBG

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <windows.h>
#include <windowsx.h>
#if !defined(_WIN32_IE)
#  define _WIN32_IE 0x0500 // needed by Wizard97 for new trust wizard
#  pragma message("_WIN32_IE defined to be 0x0500")
#else
#  if _WIN32_IE >= 0x0500
#     pragma message("_WIN32_IE >= 0x0500")
#  else
#     pragma message("_WIN32_IE < 0x0500")
#  endif
#endif
#include <commctrl.h>
#include <commdlg.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <cmnquery.h>
#include <winnls.h>
#include <htmlhelp.h>
#include <wincred.h>
#include <wincrui.h>
extern "C"
{
#if defined(DSADMIN)
#  include <shfusion.h>
#endif
#include <ntlsa.h>
}
#include <ntsam.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <string.h>
#include <tchar.h>
#include <stdarg.h>
#include <process.h>

#include <ole2.h>
#include <ntdsapi.h>
#include <rassapi.h>

#include <winldap.h>
#include <activeds.h>
#include <iadsp.h>
#include <dsclient.h>
#include <dsquery.h>
#include <dsclintp.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h> // CComPtr et al

#include <mmc.h>

#define EXPORTDEF   // Needed by cdlink.hxx
#include <cdlink.hxx>

#include <objsel.h>
#include <objselp.h>

#include <seopaque.h> // ACL macros

#define STRSAFE_NO_DEPRECATE
#define STRSAFE_NO_CB_FUNCTIONS
#include <strsafe.h>

#include <windns.h> // for length constants

#include <dspropp.h>
#include "shluuid.h"
#include "propuuid.h"
#include "dll.h"
#include "debug.h"
#include "cstr.h"   // CStr
#include "dscmn.h"
#include "dsadminp.h"
#include "pcrack.h"

// Used to disable these warnings while compiling with /W4
//#pragma warning (disable: 4100)
//#pragma warning (disable: 4663)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\proppage.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       proppage.cxx
//
//  Contents:   CDsPropPagesHost, the class that exposes IShellExtInit and
//              IShellPropSheetExt
//
//  History:    24-March-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include <propcfg.h>
#include <pcrack.h>

CLIPFORMAT g_cfDsObjectNames = 0;
CLIPFORMAT g_cfDsDispSpecOptions = 0;
CLIPFORMAT g_cfShellIDListArray = 0;
CLIPFORMAT g_cfMMCGetNodeType = 0;
CLIPFORMAT g_cfDsPropCfg = 0;
CLIPFORMAT g_cfDsSelList = 0;
CLIPFORMAT g_cfDsMultiSelectProppages = 0;
//CLIPFORMAT g_cfMMCGetCoClass = 0;

static void ToggleMVDefaultBtn(HWND hDlg, BOOL fOK);

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHost::CDsPropPagesHost
//
//-----------------------------------------------------------------------------
CDsPropPagesHost::CDsPropPagesHost(PDSCLASSPAGES pDsPP) :
    m_pDsPPages(pDsPP),
    m_pDataObj(NULL),
    m_hNotifyObj(NULL),
    m_uRefs(1)
{
    TRACE2(CDsPropPagesHost,CDsPropPagesHost);
#ifdef _DEBUG
    strcpy(szClass, "CDsPropPagesHost");
#endif
    m_ObjMedium.tymed = TYMED_NULL;
    m_ObjMedium.hGlobal = NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHost::~CDsPropPagesHost
//
//-----------------------------------------------------------------------------
CDsPropPagesHost::~CDsPropPagesHost()
{
    TRACE(CDsPropPagesHost,~CDsPropPagesHost);
    if (m_pDataObj)
    {
        m_pDataObj->Release();
    }
    if (m_ObjMedium.tymed != TYMED_NULL)
    {
        ReleaseStgMedium(&m_ObjMedium);
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHost::IShellExtInit::Initialize
//
//  Synopsis:   
//
//  Arguments:  
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPagesHost::Initialize(LPCITEMIDLIST, LPDATAOBJECT pDataObj,
                             HKEY)
{
    TRACE2(CDsPropPagesHost,Initialize);

    if (IsBadReadPtr(pDataObj, sizeof(LPDATAOBJECT)))
    {
        DBG_OUT("Failed because we don't have a data object");
        return E_INVALIDARG;
    }

    if (m_pDataObj)
    {
        m_pDataObj->Release();
        m_pDataObj = NULL;
    }

    // Hang onto the IDataObject we are being passed.

    m_pDataObj = pDataObj;
    if (m_pDataObj)
    {
        m_pDataObj->AddRef();
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHost::IShellExtInit::AddPages
//
//  Synopsis:   
//
//  Arguments:  
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPagesHost::AddPages(LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam)
{
    TRACE(CDsPropPagesHost,AddPages);

    CWaitCursor cWait;

    HRESULT hr = S_OK;
    HPROPSHEETPAGE hPage;
    PWSTR pwzObjADsPath, pwzClass;
    DWORD i;
    BOOL fPageCreated = FALSE;

    //
    // Get the unique identifier for the notify object from the data object
    //
    FORMATETC mfmte = {g_cfDsMultiSelectProppages, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM objMedium;
    LPWSTR lpszUniqueID = NULL;
    LPWSTR lpszTempUniqueID = NULL;

    hr = m_pDataObj->GetData(&mfmte, &objMedium);
    if (SUCCEEDED(hr))
    {
      lpszTempUniqueID = (LPWSTR)objMedium.hGlobal;
      if (lpszTempUniqueID == NULL)
      {
        DBG_OUT("Unique identifier not available for property pages.");
        ReleaseStgMedium(&objMedium);
        return ERROR_INVALID_DATA;
      }

      size_t iLength = wcslen(lpszTempUniqueID);
      lpszUniqueID = new WCHAR[iLength + 1];
      if (lpszUniqueID)
      {
         wcscpy(lpszUniqueID, lpszTempUniqueID);
      }

      ReleaseStgMedium(&objMedium);
    }
    //
    // Retrieve the DS object names
    //
    FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    LPDSOBJECTNAMES pDsObjectNames;
    //
    // Get the path to the DS object from the data object.
    // Note: This call runs on the caller's main thread. The pages' window
    // procs run on a different thread, so don't reference the data object
    // from a winproc unless it is first marshalled on this thread.
    //
    hr = m_pDataObj->GetData(&fmte, &m_ObjMedium);
    CHECK_HRESULT(hr, return hr);

    pDsObjectNames = (LPDSOBJECTNAMES)m_ObjMedium.hGlobal;

    if (pDsObjectNames->cItems < 1)
    {
      DBG_OUT("Not enough objects in DSOBJECTNAMES structure");
      return ERROR_INVALID_DATA;
    }

    pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                      pDsObjectNames->aObjects[0].offsetName);
    pwzClass = (PWSTR)ByteOffset(pDsObjectNames,
                                 pDsObjectNames->aObjects[0].offsetClass);
    dspDebugOut((DEB_ITRACE, "Object name: %ws, Class: %ws\n", pwzObjADsPath,
                 pwzClass));

    // Crack the name to get the server name and use that to create a
    // CDSBasePathsInfo that can be used by the pages

    CDSBasePathsInfo* pBasePathsInfo = new CDSBasePathsInfo;
    CHECK_NULL(pBasePathsInfo, return E_OUTOFMEMORY);

    CDSSmartBasePathsInfo basePathsInfo(pBasePathsInfo);
    CPathCracker pathCracker;
    hr = pathCracker.Set(CComBSTR(pwzObjADsPath), ADS_SETTYPE_FULL);
    if (SUCCEEDED(hr))
    {
       CComBSTR sbstrServer;
       hr = pathCracker.Retrieve(ADS_FORMAT_SERVER, &sbstrServer);
       if (SUCCEEDED(hr))
       {
          hr = basePathsInfo->InitFromName(sbstrServer);
       }
       else
       {
          // The shell calls the prop-page without a server in the path.
          //
          hr = basePathsInfo->InitFromName(NULL);
       }
    }

    if (FAILED(hr))
    {
       DBG_OUT("Failed to create/initialize the base paths info for the pages");
       return ERROR_INVALID_DATA;
    }

    //
    // Loop to see if any pages will be created.
    //
    for (i = 0; i < m_pDsPPages->cPages; i++)
    {
        PDSPAGE pDsPage = m_pDsPPages->rgpDsPages[i];

        if ((pDsPage->dwFlags & DSPROVIDER_ADVANCED) &&
            !(pDsObjectNames->aObjects[0].dwProviderFlags & DSPROVIDER_ADVANCED))
        {
            // The page should only be displayed if in advanced mode.
            //
            continue;
        }

        if (pDsPage->nCLSIDs)
        {
            // Only show the page if there is a match on the snapin (namespace)
            // CLSID.
            //
            BOOL fFound = FALSE;
            for (DWORD j = 0; j < pDsPage->nCLSIDs; j++)
            {
                if (IsEqualCLSID(pDsPage->rgCLSID[j],
                                 pDsObjectNames->clsidNamespace))
                {
                    fFound = TRUE;
                }
            }
            if (!fFound)
            {
                continue;
            }
        }

        fPageCreated = TRUE;
    }

    if (fPageCreated)
    {
      //
      // At least one page will be created, so contact the notification
      // object. If it doesn't already exist, it will be created.
      //
      if (lpszUniqueID == NULL)
      {
        //
        // Copy the path to be used as the unique ID for the page
        // This should only be done if the DataObject does not support g_cfDsMultiSelectProppages
        //
        size_t iLength = wcslen(pwzObjADsPath);
        lpszUniqueID = new WCHAR[iLength + 1];
        if (lpszUniqueID)
        {
          wcscpy(lpszUniqueID, pwzObjADsPath);
        }
      }
      hr = ADsPropCreateNotifyObj(m_pDataObj, lpszUniqueID, &m_hNotifyObj);
      delete[] lpszUniqueID;
      CHECK_HRESULT(hr, return hr);
    }
    else
    {
      if (lpszUniqueID)
      {
         delete[] lpszUniqueID;
         lpszUniqueID = 0;
      }
    }

    //
    // Create each page.
    //
    for (i = 0; i < m_pDsPPages->cPages; i++)
    {
        PDSPAGE pDsPage = m_pDsPPages->rgpDsPages[i];

        if ((pDsPage->dwFlags & DSPROVIDER_ADVANCED) &&
            !(pDsObjectNames->aObjects[0].dwProviderFlags & DSPROVIDER_ADVANCED))
        {
            // The page should only be displayed if in advanced mode.
            //
            continue;
        }

        if (pDsPage->nCLSIDs)
        {
            // Only show the page if there is a match on the snapin (namespace)
            // CLSID.
            //
            BOOL fFound = FALSE;
            for (DWORD j = 0; j < pDsPage->nCLSIDs; j++)
            {
                if (IsEqualCLSID(pDsPage->rgCLSID[j],
                                 pDsObjectNames->clsidNamespace))
                {
                    fFound = TRUE;
                }
            }
            if (!fFound)
            {
                continue;
            }
        }

        // Call the page's creation function.
        //
        hr = (*pDsPage->pCreateFcn)(pDsPage, m_pDataObj, pwzObjADsPath,
                                    pwzClass, m_hNotifyObj,
                                    pDsObjectNames->aObjects[0].dwFlags,
                                    basePathsInfo,
                                    &hPage);
        if (hr == S_FALSE)
        {
            // If the page doesn't want to be shown, it should return S_FALSE.
            //
            continue;
        }
        if (hr == HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP))
        {
            break;
        }
        CHECK_HRESULT(hr, continue);

        // Pass the page handle back to the app wanting to post the prop sheet.
        //
        if (!(*pAddPageProc)(hPage, lParam))
        {
            CHECK_HRESULT(E_FAIL, return E_FAIL);
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHost::IShellExtInit::ReplacePage
//
//  Synopsis:   Unused.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPagesHost::ReplacePage(UINT,
                              LPFNADDPROPSHEETPAGE,
                              LPARAM)
{
    TRACE(CDsPropPagesHost,ReplacePage);
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Multi-valued attribute editing.
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Class:      CMultiStringAttrDlg
//
//  Purpose:    Read, edit, and write a multi-valued, string property. This is
//              the dialog that contains the CMultiStringAttr class controls.
//
//-----------------------------------------------------------------------------
CMultiStringAttrDlg::CMultiStringAttrDlg(CDsPropPageBase * pPage) :
    m_pPage(pPage),
    m_MSA(pPage)
{
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttrDlg::Init
//
//  Synopsis:   Do initialization where failures can occur and then be
//              returned. Can be only called once as written.
//
//  Arguments:  [pAttrMap]   - contains the attr name.
//              [pAttrInfo]  - place to store the values.
//              [nLimit]     - the max number of values (zero means no limit).
//              [fCommaList] - if TRUE, pAttrInfo is a single-valued, comma
//                             delimited list.
//-----------------------------------------------------------------------------
HRESULT
CMultiStringAttrDlg::Init(PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                          BOOL fWritable, int nLimit, BOOL fCommaList, BOOL fMultiselectPage)
{
    return m_MSA.Init(pAttrMap, pAttrInfo, fWritable, nLimit, fCommaList, fMultiselectPage);
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttrDlg::Write
//
//  Synopsis:   Return the ADS_ATTR_INFO array of values to be Applied.
//
//-----------------------------------------------------------------------------
HRESULT CMultiStringAttrDlg::Write(PADS_ATTR_INFO pAttrInfo)
{
    return m_MSA.Write(pAttrInfo);
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttrDlg::Edit
//
//  Synopsis:   Post the edit dialog.
//
//-----------------------------------------------------------------------------
INT_PTR CMultiStringAttrDlg::Edit(void)
{
  INT_PTR nRet;

  nRet = DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_MULTI_VALUE),
                        m_pPage->GetHWnd(), StaticDlgProc, (LPARAM)this);
  if (IDOK == nRet)
  {
    EnableWindow(GetDlgItem(GetParent(m_pPage->GetHWnd()), IDOK), TRUE);

    m_pPage->SetDirty();
  }

  return nRet;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttrDlg::StaticDlgProc
//
//  Synopsis:   The static dialog proc for editing a multi-valued attribute.
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CMultiStringAttrDlg::StaticDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                   LPARAM lParam)
{
    CMultiStringAttrDlg * pMSAD = (CMultiStringAttrDlg *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        pMSAD = (CMultiStringAttrDlg *)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pMSAD);
    }

    if (pMSAD)
    {
        return pMSAD->MultiValDlgProc(hDlg, uMsg, wParam, lParam);
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttrDlg::MultiValDlgProc
//
//  Synopsis:   The instancce dialog proc for editing a multi-valued attribute.
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CMultiStringAttrDlg::MultiValDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                     LPARAM lParam)
{
    CMultiStringAttrDlg * pMSAD = (CMultiStringAttrDlg *)GetWindowLongPtr(hDlg, DWLP_USER);
    CMultiStringAttr * pMSA = &pMSAD->m_MSA;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        CHECK_NULL_REPORT(pMSA, hDlg, return 0;);
        return pMSA->DoDlgInit(hDlg);

    case WM_COMMAND:
        CHECK_NULL_REPORT(pMSA, hDlg, return 0;);
        return pMSA->DoCommand(hDlg,
                               GET_WM_COMMAND_ID(wParam, lParam),
                               GET_WM_COMMAND_CMD(wParam, lParam));

    case WM_NOTIFY:
        CHECK_NULL_REPORT(pMSA, hDlg, return 0;);
        return pMSA->DoNotify(hDlg, (NMHDR *)lParam);

    case WM_HELP:
        LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
        dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                     pHelpInfo->iCtrlId, pHelpInfo->dwContextId));
        if (pHelpInfo->iCtrlId < 1)
        {
            return 0;
        }
        WinHelp(hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);
        break;
    }

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Class:      CMultiStringAttr
//
//  Purpose:    Read, edit, and write a multi-valued, string property.
//
//-----------------------------------------------------------------------------
CMultiStringAttr::CMultiStringAttr(CDsPropPageBase * pPage) :
    m_pPage(pPage),
    m_pAttrLDAPname(NULL),
    m_nMaxLen(0),
    m_nCurDefCtrl(IDC_CLOSE),
    m_fListHasSel(FALSE),
    m_nLimit(0),
    m_cValues(0),
    m_fWritable(TRUE),
    m_fCommaList(FALSE),
    m_fDirty(FALSE),
    m_fAppend(FALSE)
{
    m_AttrInfo.pADsValues = NULL;
    m_AttrInfo.dwNumValues = 0;
    m_AttrInfo.pszAttrName = NULL;
}

CMultiStringAttr::~CMultiStringAttr()
{
    ClearAttrInfo();
    DO_DEL(m_pAttrLDAPname);
}

void CMultiStringAttr::ClearAttrInfo(void)
{
    for (DWORD i = 0; i < m_AttrInfo.dwNumValues; i++)
    {
        delete [] m_AttrInfo.pADsValues[i].CaseIgnoreString;
    }
    if (m_AttrInfo.pADsValues)
    {
        delete [] m_AttrInfo.pADsValues;
    }
    m_AttrInfo.pADsValues = NULL;
    m_AttrInfo.dwNumValues = 0;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttr::Init
//
//  Synopsis:   Do initialization where failures can occur and then be
//              returned. Can be only called once as written.
//
//  Arguments:  [pAttrMap]   - contains the attr name.
//              [pAttrInfo]  - place to store the values.
//              [nLimit]     - the max number of values (zero means no limit).
//              [fCommaList] - if TRUE, pAttrInfo is a single-valued, comma
//                             delimited list.
//-----------------------------------------------------------------------------
HRESULT
CMultiStringAttr::Init(PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                       BOOL fWritable, int nLimit, BOOL fCommaList, BOOL fAppend)
{
    if (!AllocWStr(pAttrMap->AttrInfo.pszAttrName, &m_pAttrLDAPname))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
        return E_OUTOFMEMORY;
    }

    m_nLimit = nLimit;
    m_fCommaList = fCommaList;
    m_fWritable = fWritable;
    m_fAppend = fAppend;

    m_nMaxLen = pAttrMap->nSizeLimit;

    m_AttrInfo.dwADsType = pAttrMap->AttrInfo.dwADsType;

    if (NULL == pAttrInfo)
    {
        return S_OK;
    }

    DWORD cItems = 0;
    PWSTR pwzComma, pwzCur;

    if (fCommaList)
    {
        pwzCur = pAttrInfo->pADsValues->CaseIgnoreString;
        //
        // Count the number of elements. This count includes empty elements,
        // e.g. leading, trailing, or adjacent commas.
        //
        while (*pwzCur)
        {
            cItems++;
            pwzComma = wcschr(pwzCur, L',');
            if (pwzComma)
            {
                pwzCur = pwzComma + 1;
            }
            else
            {
                break;
            }
        }
    }
    else
    {
        cItems = pAttrInfo->dwNumValues;
    }

    m_AttrInfo.pADsValues = new ADSVALUE[cItems];

    CHECK_NULL_REPORT(m_AttrInfo.pADsValues, m_pPage->GetHWnd(), return E_OUTOFMEMORY);

    for (DWORD i = 0, j = 0; i < cItems; i++)
    {
        if (fCommaList)
        {
            if (i == 0)
            {
                pwzCur = wcstok(pAttrInfo->pADsValues->CaseIgnoreString, L",\0");
            }
            else
            {
                pwzCur = wcstok(NULL, L",\0");
            }
            if (!pwzCur)
            {
                break;
            }
            if (!*pwzCur)
            {
                // Skip empty elements.
                //
                continue;
            }
            if (!AllocWStr(pwzCur, &m_AttrInfo.pADsValues[j].CaseIgnoreString))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            dspAssert(i == j);

            if (!AllocWStr(pAttrInfo->pADsValues[j].CaseIgnoreString,
                           &m_AttrInfo.pADsValues[j].CaseIgnoreString))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
                return E_OUTOFMEMORY;
            }
        }
        m_AttrInfo.pADsValues[j].dwType = m_AttrInfo.dwADsType;
        m_AttrInfo.dwNumValues++;
        j++;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttr::ToggleDefaultBtn
//
//  Synopsis:   Calls ToggleMVDefaultBtn which sets the default button
//              to the correct control for the state of the dialog
//
//-----------------------------------------------------------------------------
void
CMultiStringAttr::ToggleDefaultBtn(HWND hDlg, BOOL fOK)
{
   ToggleMVDefaultBtn(hDlg, fOK);
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttr::Write
//
//  Synopsis:   Return the ADS_ATTR_INFO array of values to be Applied.
//
//-----------------------------------------------------------------------------
HRESULT CMultiStringAttr::Write(PADS_ATTR_INFO pAttrInfo)
{
    pAttrInfo->dwADsType = m_AttrInfo.dwADsType;
    pAttrInfo->dwNumValues = 0;

    if (!m_fWritable)
    {
        return ADM_S_SKIP;
    }

    if (m_AttrInfo.dwNumValues)
    {
        PADSVALUE pADsValues;

        int nValues = (m_fCommaList) ? 1 : m_AttrInfo.dwNumValues;

        pADsValues = new ADSVALUE[nValues];

        CHECK_NULL_REPORT(pADsValues, m_pPage->GetHWnd(), return E_OUTOFMEMORY);

        if (m_fAppend)
        {
          pAttrInfo->dwControlCode = ADS_ATTR_APPEND;
        }
        else
        {
          pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
        }
        pAttrInfo->pADsValues = pADsValues;

        if (m_fCommaList)
        {
            // For simplicity, just go ahead and allocate the max. That is,
            // there are m_AttrInfo.dwNumValues values each which can be a max
            // length of m_nMaxLen. The comma separator is included in the
            // count.
            //
            pADsValues->CaseIgnoreString = new WCHAR[(m_AttrInfo.dwNumValues * (m_nMaxLen + 1)) + 1];
            CHECK_NULL_REPORT(pADsValues->CaseIgnoreString, m_pPage->GetHWnd(), return E_OUTOFMEMORY);

            wcscpy(pADsValues->CaseIgnoreString,
                   m_AttrInfo.pADsValues[0].CaseIgnoreString);

            for (DWORD i = 1; i < m_AttrInfo.dwNumValues; i++)
            {
                wcscat(pADsValues->CaseIgnoreString, L",");
                wcscat(pADsValues->CaseIgnoreString,
                       m_AttrInfo.pADsValues[i].CaseIgnoreString);
            }
            pADsValues->dwType = m_AttrInfo.dwADsType;
            pAttrInfo->dwNumValues = 1;
        }
        else
        {
            for (DWORD i = 0; i < m_AttrInfo.dwNumValues; i++)
            {
                PWSTR pwz;
                if (!AllocWStr(m_AttrInfo.pADsValues[i].CaseIgnoreString, &pwz))
                {
                    REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
                    return E_OUTOFMEMORY;
                }
                pADsValues[i].dwType = m_AttrInfo.dwADsType;
                pADsValues[i].CaseIgnoreString = pwz;
                pAttrInfo->dwNumValues++;
            }
        }
    }
    else
    {
        pAttrInfo->pADsValues = NULL;
        pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttr::SetDirty
//
//  Synopsis:   Marks the page dirty and enables the OK button
//
//-----------------------------------------------------------------------------
void CMultiStringAttr::SetDirty(HWND hDlg)
{
  m_fDirty = TRUE;
  EnableWindow(GetDlgItem(hDlg, IDC_CLOSE), m_fDirty);
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttr::EnableControls
//
//  Synopsis:   Enable or disable all of the controls.
//
//-----------------------------------------------------------------------------
void
CMultiStringAttr::EnableControls(HWND hDlg, BOOL fEnable)
{
    EnableWindow(GetDlgItem(hDlg, IDC_EDIT), fEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_LIST), fEnable);
    if (!fEnable)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_ADD_BTN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), FALSE);
        m_fListHasSel = FALSE;
    }

    EnableWindow(GetDlgItem(hDlg, IDC_CLOSE), IsDirty());
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttr::DoDlgInit
//
//  Synopsis:   WM_INITDIALOG code.
//
//-----------------------------------------------------------------------------
BOOL
CMultiStringAttr::DoDlgInit(HWND hDlg)
{
    LPTSTR ptz;
    HRESULT hr = S_OK;
    LONG i;
    HWND hList;
    LV_ITEM lvi;
    /*
    //
    // Create the dialog caption: "<obj-name> - <attribute-name>"
    //
    TCHAR szCaption[MAX_PATH];
    if (!UnicodeToTchar(m_pPage->GetObjRDName(), &ptz))
    {
        CHECK_WIN32_REPORT(ERROR_NOT_ENOUGH_MEMORY, hDlg, return FALSE);
    }
    _tcscpy(szCaption, ptz);
    delete [] ptz;
    _tcscat(szCaption, TEXT(" - "));
    int len = _tcslen(szCaption);
    */

    // Get the attribute "friendly" name.
    //
    WCHAR wzBuf[MAX_PATH + 1];
    IDsDisplaySpecifier * pDispSpec;

    hr = m_pPage->GetIDispSpec(&pDispSpec);

    CHECK_HRESULT_REPORT(hr, hDlg, return 0);

    //
    // If this is multi-select it must be a homogenous selection so if 
    // m_pPage->GetObjClass() returns NULL then get the class from the data object
    //
    CStrW szClassName = m_pPage->GetObjClass();
    if (szClassName.IsEmpty())
    {
      //
      // For the retrieval of the DS Object names
      //
      FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
      STGMEDIUM objMedium;
      hr = m_pPage->m_pWPTDataObj->GetData(&fmte, &objMedium);
      CHECK_HRESULT(hr, return FALSE);

      LPDSOBJECTNAMES pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

      //
      // Get the objects class 
      //
      szClassName = (PWSTR)ByteOffset(pDsObjectNames,
                                      pDsObjectNames->aObjects[0].offsetClass);

      ReleaseStgMedium(&objMedium);
    }
    hr = pDispSpec->GetFriendlyAttributeName((LPCWSTR)szClassName,
                                             m_pAttrLDAPname, wzBuf, MAX_PATH);
    CHECK_HRESULT_REPORT(hr, hDlg, return 0);

    if (!UnicodeToTchar(wzBuf, &ptz))
    {
        REPORT_ERROR(E_OUTOFMEMORY, hDlg);
        return 0;
    }
    //_tcscat(szCaption, ptz);
    SetWindowText(hDlg, ptz);
    delete [] ptz;

    // Limit the entry length of the edit control.
    //
    SendDlgItemMessage(hDlg, IDC_EDIT, EM_LIMITTEXT, m_nMaxLen, 0);

    // Initialize the list view.
    //
    RECT rect;
    LV_COLUMN lvc;
    hList = GetDlgItem(hDlg, IDC_LIST);
    ListView_SetExtendedListViewStyle(hList, LVS_EX_FULLROWSELECT);
    if (!m_fWritable)
    {
        LONG_PTR lStyle = GetWindowLongPtr(hList, GWL_STYLE);
        lStyle &= ~(LVS_EDITLABELS);
        SetWindowLongPtr(hList, GWL_STYLE, lStyle);
    }

    GetClientRect(hList, &rect);
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rect.right;
    lvc.iSubItem = 0;

    ListView_InsertColumn(hList, 0, &lvc);

    // Load the list view.
    //
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.lParam = m_nMaxLen;

    for (i = 0; (DWORD)i < m_AttrInfo.dwNumValues; i++)
    {
        if (!UnicodeToTchar(m_AttrInfo.pADsValues[i].CaseIgnoreString,
                            &ptz))
        {
            ReportError(E_OUTOFMEMORY, 0, hDlg);
            return 0;
        }
        lvi.pszText = ptz;
        lvi.iItem = i;
        ListView_InsertItem(hList, &lvi);
        m_cValues++;

        delete[] ptz;
        ptz = 0;
    }

    //
    // Disable the Add, Change, and Remove buttons.
    //
    EnableWindow(GetDlgItem(hDlg, IDC_ADD_BTN), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_CLOSE), FALSE);

    if (!m_fWritable)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_CLOSE), TRUE);

        CStr close;
        BOOL loadResult = close.LoadString(g_hInstance, IDS_CLOSE);
        dspAssert(loadResult);

        if (loadResult)
        {
          SetDlgItemText(hDlg, IDC_CLOSE, close);
        }
    }
    //
    // Make the CLOSE button the default.
    //
    int style;

   style = (int)GetWindowLongPtr(GetDlgItem(hDlg, IDCANCEL), GWL_STYLE);

   style |= BS_DEFPUSHBUTTON;

   SendMessage(hDlg, DM_SETDEFID, (WPARAM)IDCANCEL, 0);
   SendDlgItemMessage(hDlg, IDC_CLOSE, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
   SendDlgItemMessage(hDlg, IDCANCEL, BM_SETSTYLE,
                     (WPARAM)LOWORD(style), MAKELPARAM(TRUE, 0));
   m_nCurDefCtrl = IDCANCEL;
   return 1;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttr::DoCommand
//
//  Synopsis:   WM_COMMAND code.
//
//-----------------------------------------------------------------------------
int
CMultiStringAttr::DoCommand(HWND hDlg, int id, int code)
{
    LPTSTR ptz;
    LONG i;
    HWND hList;
    LV_ITEM lvi;
    switch (code)
    {
    case BN_CLICKED:
        if (id == IDOK)
        {
            // Hitting Return causes IDOK to be sent. Replace that with the
            // ID of the control that is currently the default.
            //
            id = m_nCurDefCtrl;
        }
        switch (id)
        {
        case IDC_ADD_BTN:
            if (m_nLimit && (m_cValues >= m_nLimit))
            {
                ErrMsgParam(IDS_MULTISEL_LIMIT, (LPARAM)m_nLimit, hDlg);
                return 1;
            }
            ptz = new TCHAR[m_nMaxLen + 1];

            CHECK_NULL_REPORT(ptz, hDlg, return -1);
            
            // NTRAID#NTBUG9-525208-2002/01/29-ronmart-off by one error on buffer len
            if (GetWindowText(GetDlgItem(hDlg, IDC_EDIT), ptz,
                              m_nMaxLen + 1))
            {
                hList = GetDlgItem(hDlg, IDC_LIST);
                //
                // See if the string already exists
                //
                LVFINDINFO lvSearchInfo = {0};
                lvSearchInfo.flags = LVFI_STRING;
                lvSearchInfo.psz = ptz;
                i = ListView_FindItem(hList, -1, &lvSearchInfo);
                if (i == -1)
                {
                  i = ListView_GetItemCount(hList);
                  // NTRAID#NTBUG9-525198-2002/01/29-ronmart-store max length in lparam
                  lvi.mask = LVIF_TEXT | LVIF_PARAM;
                  lvi.iSubItem = 0;
                  lvi.pszText = ptz;
                  // NTRAID#NTBUG9-525198-2002/01/29-ronmart-Set the max length allowed
                  lvi.lParam = m_nMaxLen;
                  lvi.iItem = i;
                  ListView_InsertItem(hList, &lvi);                  
                  //Make this item selected and make it  visible
                  ListView_SetItemState( hList, 
                                         i, 
                                         LVIS_SELECTED|LVIS_FOCUSED , 
                                         LVIS_SELECTED|LVIS_FOCUSED );
                }
                ListView_EnsureVisible(hList, i, FALSE);


                m_cValues++;

                SetWindowText(GetDlgItem(hDlg, IDC_EDIT), TEXT(""));
                //
                // Disable the Save button and make the OK button the
                // default.
                //
                ToggleMVDefaultBtn(hDlg, TRUE);

                m_nCurDefCtrl = IDC_CLOSE;
                SetDirty(hDlg);
            }

            delete [] ptz;

            return 1;

        case IDC_DELETE_BTN:
        case IDC_EDIT_BTN:
            hList = GetDlgItem(hDlg, IDC_LIST);

            i = ListView_GetNextItem(hList, -1, LVNI_SELECTED);
            dspDebugOut((DEB_ITRACE, "List element %d selected\n", i));

            if (i >= 0)
            {
                if (id == IDC_DELETE_BTN)
                {
                    ListView_DeleteItem(hList, i);
                    m_cValues--;

                    //Get the count of list view items
                    LONG itemCount = ListView_GetItemCount(hList);
                    if(itemCount)
                    {
                        ListView_SetItemState( hList, 
                                               (itemCount > i) ? i : i-1,
                                               LVIS_SELECTED|LVIS_FOCUSED , 
                                               LVIS_SELECTED|LVIS_FOCUSED );
                    }
                    else
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), FALSE);
                        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), FALSE);
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT));
                        m_fListHasSel = FALSE;
                    }
                    SetDirty(hDlg);
                    ToggleMVDefaultBtn(hDlg, TRUE);
                }
                else
                {
                    ToggleMVDefaultBtn(hDlg, TRUE);
                    SetFocus(GetDlgItem(hDlg, IDC_LIST));
                    ListView_EditLabel(hList, i);
                }
            }


            return 1;

        case IDC_CLOSE:
            {
                // Copy the list box back to the attr info list.
                //
                int nItems;
                ClearAttrInfo();
                m_fListHasSel = FALSE;

                hList = GetDlgItem(hDlg, IDC_LIST);
                nItems = ListView_GetItemCount(hList);

                if (nItems == 0)
                {
                    EndDialog(hDlg, IDOK);
                    return 1;
                }

                m_AttrInfo.pADsValues = new ADSVALUE[nItems];

                CHECK_NULL_REPORT(m_AttrInfo.pADsValues, hDlg, return -1);

                ptz = new TCHAR[m_nMaxLen + 1];

                CHECK_NULL_REPORT(ptz, hDlg, return -1);

                lvi.mask = LVIF_TEXT;
                lvi.iSubItem = 0;
                lvi.pszText = ptz;
                lvi.cchTextMax = m_nMaxLen + 1;

                for (i = 0; i < nItems; i++)
                {
                    lvi.iItem = i;
                    if (!ListView_GetItem(hList, &lvi))
                    {
                        REPORT_ERROR(GetLastError(), hDlg);
                        delete [] ptz;
                        EndDialog(hDlg, IDCANCEL);
                        return -1;
                    }
                    if (!TcharToUnicode(ptz,
                                        &m_AttrInfo.pADsValues[i].CaseIgnoreString))
                    {
                        REPORT_ERROR(E_OUTOFMEMORY, hDlg);
                        return E_OUTOFMEMORY;
                    }
                    m_AttrInfo.pADsValues[i].dwType = m_AttrInfo.dwADsType;
                    m_AttrInfo.dwNumValues++;
                }
                delete [] ptz;
                EndDialog(hDlg, IDOK);
            }
            return IDOK;

        case IDCANCEL:
            m_fListHasSel = FALSE;
            EndDialog(hDlg, IDCANCEL);
            return IDCANCEL;
        }
        break;

    case EN_CHANGE:
        if (id == IDC_EDIT)
        {
            BOOL fEnableAdd = FALSE;
            LRESULT lTextLen = SendDlgItemMessage(hDlg, IDC_EDIT,
                                                  WM_GETTEXTLENGTH,
                                                  0, 0);

            PTSTR pszText = new TCHAR[lTextLen + 1];
            if (pszText != NULL)
            {
              if (!GetDlgItemText(hDlg, IDC_EDIT, pszText, static_cast<int>(lTextLen + 1)))
              {
                fEnableAdd = lTextLen > 0;
              }
              else
              {
                CStr strText;
                strText = pszText;
                strText.TrimLeft();
                strText.TrimRight();

                if (strText.IsEmpty())
                {
                  fEnableAdd = FALSE;
                }
                else
                {
                  fEnableAdd = TRUE;
                }
              }
              delete[] pszText;
            }
            else
            {
              fEnableAdd = lTextLen > 0;
            }

            if (fEnableAdd && (m_nCurDefCtrl == IDC_ADD_BTN))
            {
                return 1;
            }

            m_nCurDefCtrl = (fEnableAdd) ? IDC_ADD_BTN : IDC_CLOSE;

            EnableWindow(GetDlgItem(hDlg, IDC_ADD_BTN), fEnableAdd);

            ToggleMVDefaultBtn(hDlg, !fEnableAdd);

            return 1;
        }
        break;
    }
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttr::DoNotify
//
//  Synopsis:   WM_NOTIFY code.
//
//-----------------------------------------------------------------------------
BOOL
CMultiStringAttr::DoNotify(HWND hDlg, NMHDR * pNmHdr)
{
    if (pNmHdr->idFrom != IDC_LIST)
    {
        return TRUE;
    }

    LV_DISPINFO * pldi = (LV_DISPINFO *)pNmHdr;

    switch (pNmHdr->code)
    {
    case LVN_ENDLABELEDIT:
        if (pldi->item.pszText)
        {
            // NTRAID#NTBUG9-525223-2002/01/29-ronmart-don't allow zero length string
            // NTRAID#NTBUG9-525198-2002/01/29-ronmart-Check the lParam for the max length allowed
            int nLen = lstrlen(pldi->item.pszText);
            if(nLen < 1 || nLen > pldi->item.lParam)
              return FALSE;
            dspDebugOut((DEB_ITRACE, "Editing item %d, new value %S\n",
                         pldi->item.iItem, pldi->item.pszText));
            ListView_SetItemText(pldi->hdr.hwndFrom, pldi->item.iItem, 0,
                                 pldi->item.pszText);

            //
            // Disable the Save button and make the OK button the
            // default.
            //
            SetDirty(hDlg);
            ToggleMVDefaultBtn(hDlg, TRUE);
        }
        break;

    case NM_SETFOCUS:
        dspDebugOut((DEB_ITRACE, "NM_SETFOCUS received\n"));
        if (pldi->hdr.idFrom == IDC_LIST)
        {
            //
            // If the list control gets the focus by tabbing and no item
            // is selected, then set the selection to the first item.
            //
            if (!m_fListHasSel && ListView_GetItemCount(GetDlgItem(hDlg, IDC_LIST)))
            {
                dspDebugOut((DEB_ITRACE, "setting the list selection\n"));
                m_fListHasSel = TRUE;
                ListView_SetItemState(GetDlgItem(hDlg, IDC_LIST), 0, 
                                      LVIS_FOCUSED | LVIS_SELECTED,
                                      LVIS_FOCUSED | LVIS_SELECTED);
                if (m_fWritable)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), TRUE);
                }
            }
        }
        return 1;

    case LVN_ITEMCHANGED:
        if (pldi->hdr.idFrom == IDC_LIST)
        {
            if(ListView_GetSelectedCount(GetDlgItem(hDlg, IDC_LIST)))
            {
                m_fListHasSel = TRUE;
                if (m_fWritable)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), TRUE);
                }
            }
            else
            {
                m_fListHasSel = FALSE;
                if (m_fWritable)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), FALSE);
                }
            }
        }
        return 1;
    }
    return 0;
}


//+----------------------------------------------------------------------------
//
//  Function:   OtherValuesBtn
//
//  Synopsis:   "Others..." button that brings up a dialog (similar to the
//              multi-valued attribute dialog) to modify the otherXXXX
//              attribute. Usage: if a multi-valued property needs to
//              have one value designated at the primary value, then this
//              must be expressed as two separate attributes since multi-
//              valued attributes are un-ordered. For example, consider tele-
//              phone numbers; Telephone-Number, which is single-valued is the
//              primary value and Phone-Office-Other, which is multi-valued,
//              is used to store the "other" numbers.
//
//-----------------------------------------------------------------------------
HRESULT
OtherValuesBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp)
{
    HRESULT hr = S_OK;
    CMultiStringAttrDlg * pMultiS = NULL;

    switch (DlgOp)
    {
    case fInit:
      {
        pMultiS = new CMultiStringAttrDlg(pPage);

        CHECK_NULL_REPORT(pMultiS, pPage->GetHWnd(), return E_OUTOFMEMORY);

        BOOL fMultiselectPage = pPage->IsMultiselectPage();
        hr = pMultiS->Init(pAttrMap, pAttrInfo, PATTR_DATA_IS_WRITABLE(pAttrData), 0, FALSE, fMultiselectPage);

        CHECK_HRESULT(hr, return hr);

        pAttrData->pVoid = reinterpret_cast<LPARAM>(pMultiS);  // save the object pointer.
      }
      break;

    case fOnCommand:
        if (lParam == BN_CLICKED)
        {
            CHECK_NULL(pAttrData->pVoid, return E_OUTOFMEMORY);
            pMultiS = (CMultiStringAttrDlg *)pAttrData->pVoid;

            if (IDOK == pMultiS->Edit())
            {
                PATTR_DATA_SET_DIRTY(pAttrData);
            }
        }
        break;

    case fApply:
        if (!PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }
        CHECK_NULL(pAttrData->pVoid, return E_OUTOFMEMORY);
        pMultiS = (CMultiStringAttrDlg *)pAttrData->pVoid;

        return pMultiS->Write(pAttrInfo);

    case fOnDestroy:
        if (pAttrData->pVoid)
        {
            delete (CMultiStringAttrDlg *)pAttrData->pVoid;
        }
        break;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function    ToggleMVDefaultBtn
//
//  Synopsis:   Toggle the default pushbutton of the multi-valued dialog.
//
//-----------------------------------------------------------------------------
void
ToggleMVDefaultBtn(HWND hDlg, BOOL fOK)
{
    LONG style, newstyle;
    int nDefault = IDC_CLOSE, nNotDefault = IDC_ADD_BTN;

    if (!fOK)
    {
        nDefault = IDC_ADD_BTN;
        nNotDefault = IDC_CLOSE;
    }

    //
    // Clear the default bit on this one.
    //
    style = (LONG)GetWindowLongPtr(GetDlgItem(hDlg, nNotDefault), GWL_STYLE);

    newstyle = style & ~(BS_DEFPUSHBUTTON);

    SendDlgItemMessage(hDlg, nNotDefault, BM_SETSTYLE, (WPARAM)LOWORD(newstyle),
                       MAKELPARAM(TRUE, 0));

    //
    // Make this one the default.
    //
    style = (LONG)GetWindowLongPtr(GetDlgItem(hDlg, nDefault), GWL_STYLE);

    newstyle = style | BS_DEFPUSHBUTTON;

    SendMessage(hDlg, DM_SETDEFID, (WPARAM)nDefault, 0);
    SendDlgItemMessage(hDlg, nDefault, BM_SETSTYLE, (WPARAM)LOWORD(newstyle),
                       MAKELPARAM(TRUE, 0));
    if (fOK)
    {
        SetFocus(GetDlgItem(hDlg, IDC_EDIT));
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   GetObjectClass
//
//  Synopsis:   Object page attribute function for object class.
//
//-----------------------------------------------------------------------------
HRESULT
GetObjectClass(CDsPropPageBase * pPage, PATTR_MAP,
               PADS_ATTR_INFO, LPARAM, PATTR_DATA,
               DLG_OP DlgOp)
{
    if (DlgOp == fInit)
    {
        WCHAR wszBuf[120];
        PTSTR ptz;
        HRESULT hr;
        IDsDisplaySpecifier * pDispSpec;

        hr = pPage->GetIDispSpec(&pDispSpec);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);
        //
        // Look up the localized class name on the object display
        // specification cache.
        //
        hr = pDispSpec->GetFriendlyClassName(pPage->GetObjClass(), wszBuf, 120);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        if (!UnicodeToTchar(wszBuf, &ptz))
        {
            REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
            return E_OUTOFMEMORY;
        }

        SetDlgItemText(pPage->GetHWnd(), IDC_CLASS_STATIC, ptz);

        delete [] ptz;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetObjectTimestamp
//
//  Synopsis:   Object page attribute function for object timestamps.
//
//-----------------------------------------------------------------------------
HRESULT
GetObjectTimestamp(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                   PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
                   DLG_OP DlgOp)
{
    DWORD dwErr;

    if ((DlgOp == fInit) && pPage)
    {
        TCHAR tszBuf[MAX_MSG_LEN];

        if (pAttrInfo && pAttrInfo->dwNumValues && pAttrInfo->pADsValues &&
            pAttrInfo->pADsValues->dwType == ADSTYPE_UTC_TIME)
        {
            SYSTEMTIME st = {0};

            if (!SystemTimeToTzSpecificLocalTime(NULL, &pAttrInfo->pADsValues->UTCTime, &st))
            {
                dwErr = GetLastError();
                CHECK_WIN32_REPORT(dwErr, pPage->GetHWnd(), return dwErr);
            }

            int cch = GetDateFormat(LOCALE_USER_DEFAULT, 0, &st, NULL,
                                    tszBuf, MAX_MSG_LEN);
            if (cch == 0)
            {
                dwErr = GetLastError();
                CHECK_WIN32_REPORT(dwErr, pPage->GetHWnd(), return dwErr);
            }
			//NTRAID#NTBUG9-573434-2002/03/10-jmessec   possible buffer overrun
            _tcscat(tszBuf, TEXT(" "));
            cch = static_cast<int>(_tcslen(tszBuf));

            GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, tszBuf + cch,
                          MAX_MSG_LEN - cch);
        }
        else
        {
            if (!LoadString(g_hInstance, IDS_NO_VALUE, tszBuf, MAX_MSG_LEN - 1))
            {
              _tcscpy(tszBuf, TEXT(" "));
            }
        }

        int nCtrl = 0;

        switch (pAttrMap->nCtrlID)
        {
        case IDC_CREATED_TIME_STATIC:
            DBG_OUT("Getting creation timestamp.");
            nCtrl = IDC_CREATED_TIME_STATIC;
            break;

        case IDC_MODIFIED_TIME_STATIC:
            DBG_OUT("Getting last modification timestamp.");
            nCtrl = IDC_MODIFIED_TIME_STATIC;
            break;

        default:
            REPORT_ERROR(E_INVALIDARG, pPage->GetHWnd());
        }

        SetDlgItemText(pPage->GetHWnd(), nCtrl, tszBuf);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   UnescapeCanonicalNameEx
//
//  Synopsis:   Takes a canonical name in the DS_CANONICAL_NAME format
//              and removes the escaping
//
//-----------------------------------------------------------------------------
HRESULT
UnescapeCanonicalNameEx(
   PCWSTR pszName,
   CStrW& strUnescapedName)
{
   HRESULT hr = S_OK;

   strUnescapedName = pszName;

   return hr;
}
//+----------------------------------------------------------------------------
//
//  Function:   ObjectPathField
//
//  Synopsis:   Handles the Object page path field.
//
//-----------------------------------------------------------------------------
HRESULT
ObjectPathField(CDsPropPageBase * pPage, PATTR_MAP,
                PADS_ATTR_INFO, LPARAM, PATTR_DATA,
                DLG_OP DlgOp)
{
    if (DlgOp == fInit)
    {
        PWSTR pwzPath, pwzDNSname;

        HRESULT hr = pPage->SkipPrefix(pPage->GetObjPathName(), &pwzPath);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        hr = CrackName(pwzPath, &pwzDNSname, GET_OBJ_CAN_NAME, pPage->GetHWnd());

        delete [] pwzPath;

        CHECK_HRESULT(hr, return hr);

        CStrW strUnescapedCanonicalName;
        hr = UnescapeCanonicalNameEx(pwzDNSname, strUnescapedCanonicalName);
        dspAssert(SUCCEEDED(hr));

        LocalFreeStringW(&pwzDNSname);

        PTSTR ptszPath;

        if (!UnicodeToTchar((PWSTR)(PCWSTR)strUnescapedCanonicalName, &ptszPath))
        {
            REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
            return E_OUTOFMEMORY;
        }

        SetDlgItemText(pPage->GetHWnd(), IDC_PATH_FIELD, ptszPath);

        delete [] ptszPath;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\proputil.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       proputil.cxx
//
//  Contents:   CDsPropPagesHost IUnknown and ClassFactory, CDsPropDataObj.
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "notify.h"
#include <propcfg.h> // DS Admin definition of PPROPSHEETCFG
#include <ntdsapip.h>

#include <shlobjp.h> // SHCreatePropertyBag()

//
// This CLSID for the Domain Tree snapin is copied from cdomain.cpp.
//
const CLSID CLSID_DomainAdmin = { /* ebc53a38-a23f-11d0-b09b-00c04fd8dca6 */
    0xebc53a38,
    0xa23f,
    0x11d0,
    {0xb0, 0x9b, 0x00, 0xc0, 0x4f, 0xd8, 0xdc, 0xa6}
};

//BOOL CALLBACK AddPageProc(HPROPSHEETPAGE hPage, LPARAM pCall);
HRESULT PostPropSheetWorker(CDsPropPageBase * pParentPage, PWSTR pwzObjDN,
                            IDataObject * pParentObj, HWND hwndParent, HWND hNotifyObj, BOOL fReadOnly);

HRESULT PostPropSheetWorker(CDsPropPageBase * pParentPage, PWSTR pwzObjDN,
                            IDataObject * pParentObj, HWND hwndParent, BOOL fReadOnly);

//+----------------------------------------------------------------------------
//
//      CDsPropPagesHost IUnknown methods
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHost::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPagesHost::QueryInterface(REFIID riid, void ** ppvObject)
{
    TRACE2(CDsPropPagesHost,QueryInterface);
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)(LPSHELLEXTINIT)this;
    }
    else if (IID_IShellExtInit == riid)
    {
        *ppvObject = (LPSHELLEXTINIT)this;
    }
    else if (IID_IShellPropSheetExt == riid)
    {
        *ppvObject = (LPSHELLPROPSHEETEXT)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHost::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPagesHost::AddRef(void)
{
    dspDebugOut((DEB_USER2, "CDsPropPagesHost::AddRef refcount going in %d\n", m_uRefs));
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHost::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    zero if the reference count is zero or non-zero otherwise
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPagesHost::Release(void)
{
    dspDebugOut((DEB_USER2, "CDsPropPagesHost::Release ref count going in %d\n", m_uRefs));
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//      CDsPropPagesHostCF - class factory for the CDsPropPagesHost object
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHostCF::Create
//
//  Synopsis:   creates a new class factory object
//
//-----------------------------------------------------------------------------
IClassFactory *
CDsPropPagesHostCF::Create(PDSCLASSPAGES pDsPP)
{
    return new CDsPropPagesHostCF(pDsPP);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHostCF::CDsPropPagesHostCF
//
//  Synopsis:   ctor
//
//-----------------------------------------------------------------------------
CDsPropPagesHostCF::CDsPropPagesHostCF(PDSCLASSPAGES pDsPP) :
    m_pDsPP(pDsPP),
    m_uRefs(1)
{
    TRACE2(CDsPropPagesHostCF,CDsPropPagesHostCF);
#ifdef _DEBUG
    strcpy(szClass, "CDsPropPagesHostCF");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHostCF::~CDsPropPagesHostCF
//
//  Synopsis:   dtor
//
//-----------------------------------------------------------------------------
CDsPropPagesHostCF::~CDsPropPagesHostCF(void)
{
    TRACE2(CDsPropPagesHostCF,~CDsPropPagesHostCF);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHostCF::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPagesHostCF::QueryInterface(REFIID riid, void ** ppvObject)
{
    dspDebugOut((DEB_USER2, "CDsPropPagesHostCF::QueryInterface\n"));
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)this;
    }
    else if (IsEqualIID(IID_IClassFactory, riid))
    {
        *ppvObject = (IClassFactory *)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHostCF::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the new reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPagesHostCF::AddRef(void)
{
    dspDebugOut((DEB_USER2, "CDsPropPagesHostCF::AddRef refcount going in %d\n", m_uRefs));
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHostCF::IUnknown::Release
//
//  Synopsis:   decrement the refcount
//
//  Returns:    the new reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPagesHostCF::Release(void)
{
    dspDebugOut((DEB_USER2, "CDsPropPagesHostCF::Release ref count going in %d\n", m_uRefs));
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHostCF::IClassFactory::CreateInstance
//
//  Synopsis:   create an incore instance of the proppage host class object
//
//  Arguments:  [pUnkOuter] - aggregator
//              [riid]      - requested interface
//              [ppvObject] - receptor for itf ptr
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPagesHostCF::CreateInstance(IUnknown*, REFIID riid,
                                   void **ppvObject)
{
    TRACE2(CDsPropPagesHostCF,CreateInstance);
    HRESULT hr = S_OK;
    *ppvObject = NULL;

    CDsPropPagesHost * pPropPage = new CDsPropPagesHost(m_pDsPP);
    if (pPropPage == NULL)
    {
        return E_OUTOFMEMORY;
    }

    hr = pPropPage->QueryInterface(riid, ppvObject);
    if (FAILED(hr))
    {
        ERR_OUT("CDsPropPagesHostCF::CreateInstance, pPropPage->QueryInterface", hr);
        pPropPage->Release();
        return hr;
    }

    //
    // We got a refcount of one when launched, and the above QI increments it
    // to 2, so call release to take it back to 1.
    //
    pPropPage->Release();
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHostCF::IClassFactory::LockServer
//
//  Synopsis:   Called with fLock set to TRUE to indicate that the server
//              should continue to run even if none of its objects are active
//
//  Arguments:  [fLock] - increment/decrement the instance count
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPagesHostCF::LockServer(BOOL fLock)
{
    CDll::LockServer(fLock);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   AllocWStr
//
//  Synopsis:   Creates a copy of the passed in string. Allocates memory for
//              the returned string using new. Callers must free the string
//              memory when done using delete.
//
//  Returns:    FALSE for out of memory failures.
//
//-----------------------------------------------------------------------------
BOOL AllocWStr(PWSTR pwzStrIn, PWSTR * ppwzNewStr)
{
  if (pwzStrIn == NULL)
  {
    *ppwzNewStr = NULL;
    return TRUE;
  }

  *ppwzNewStr = new WCHAR[wcslen(pwzStrIn) + 1];

  if (NULL == *ppwzNewStr)
  {
    return FALSE;
  }

  wcscpy(*ppwzNewStr, pwzStrIn);

  return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   AllocTStr
//
//  Synopsis:   Creates a copy of the passed in string. Allocates memory for
//              the returned string using new. Callers must free the string
//              memory when done using delete.
//
//  Returns:    FALSE for out of memory failures.
//
//-----------------------------------------------------------------------------
BOOL AllocTStr(PTSTR ptzStrIn, PTSTR * pptzNewStr)
{
    *pptzNewStr = new TCHAR[_tcslen(ptzStrIn) + 1];

    if (NULL == *pptzNewStr)
    {
        return FALSE;
    }

    _tcscpy(*pptzNewStr, ptzStrIn);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   UnicodeToTchar
//
//  Synopsis:   Converts a Unicode string to a TCHAR string. Allocates memory
//              for the returned string using new. Callers must free the
//              string memory when done using delete.
//
//  Returns:    FALSE for out of memory failures.
//
//-----------------------------------------------------------------------------
BOOL UnicodeToTchar(LPWSTR pwszIn, LPTSTR * pptszOut)
{
    size_t len;

	#ifdef UNICODE
		len = wcslen(pwszIn);
	#else
		len = WideCharToMultiByte(CP_ACP, 0, pwszIn, -1, NULL, 0, NULL, NULL);
	#endif
	    
		//NTRAID#NTBUG9-572008-2002/03/10-jmessec   Length calculation, for correctness, should not use
  			//mixed metaphor of char length and byte length (if UNICODE, len == cch, else len == byte length of buffer (including NULL) 
		*pptszOut = new TCHAR[len + 1];
    CHECK_NULL(*pptszOut, return FALSE);

#ifdef UNICODE
    wcscpy(*pptszOut, pwszIn);
#else
    if (WideCharToMultiByte(CP_ACP, 0, pwszIn, -1,
                            *pptszOut, len, NULL, NULL) == 0)
    {
        delete [] *pptszOut;
        return FALSE;
    }
#endif
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   TcharToUnicode
//
//  Synopsis:   Converts a TCHAR string to a Unicode string. Allocates memory
//              for the returned string using new. Callers must free the
//              string memory when done using delete.
//
//  Returns:    FALSE for out of memory failures.
//
//-----------------------------------------------------------------------------
BOOL TcharToUnicode(LPTSTR ptszIn, LPWSTR * ppwszOut)
{
    size_t len;

#ifdef UNICODE
    len = wcslen(ptszIn);
#else
    len = MultiByteToWideChar(CP_ACP, 0, ptszIn, -1, NULL, 0);
#endif


    *ppwszOut = new WCHAR[len + 1];
    CHECK_NULL(*ppwszOut, return FALSE);

#ifdef UNICODE
    wcscpy(*ppwszOut, ptszIn);
#else
    if (MultiByteToWideChar(CP_ACP, 0, ptszIn, -1, *ppwszOut, len) == 0)
    {
        delete [] *ppwszOut;
        return FALSE;
    }
#endif
    return TRUE;
}



#ifdef _PROVIDE_CFSTR_SHELLIDLIST_FORMAT

// FROM DIZ (dsuiext\query.cpp)

//#if DELEGATE
//WCHAR c_szDsMagicPath[] = L"::{208D2C60-3AEA-1069-A2D7-08002B30309D}";
//#else
WCHAR c_szDsMagicPath[] = L"::{208D2C60-3AEA-1069-A2D7-08002B30309D}\\EntireNetwork\\::{fe1290f0-cfbd-11cf-a330-00aa00c16e65}";
//#endif


#if !DOWNLEVEL_SHELL
/*-----------------------------------------------------------------------------
/ BindToPath
/ ----------
/   Given a namespace path bind to it returning the shell object
/
/ In:
/   pszPath -> path to bind to
/   riid = interface to request
/   ppvObject -> receives the object pointer
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT BindToPath(LPWSTR pszPath, REFIID riid, LPVOID* ppObject)
{
    HRESULT hres;
    IShellFolder* psfDesktop = NULL;
    LPITEMIDLIST pidl = NULL;

    //TraceEnter(TRACE_VIEW, "BindToPath");

    hres = CoCreateInstance(CLSID_ShellDesktop, NULL, CLSCTX_INPROC_SERVER, IID_IShellFolder, (LPVOID*)&psfDesktop);
    if (FAILED(hres))
    {
        //FailGracefully(hres, "Failed to get IShellFolder for the desktop object");
        goto exit_gracefully;
    }


    hres = psfDesktop->ParseDisplayName(NULL, NULL, pszPath, NULL, &pidl, NULL);
    if (FAILED(hres))
    {
        //FailGracefully(hres, "Failed when getting root path of DS");
        goto exit_gracefully;
    }
    
    if ( ILIsEmpty(pidl) )
    {
        //TraceMsg("PIDL is desktop, therefore just QIing for interface");
        hres = psfDesktop->QueryInterface(riid, ppObject);
    }
    else
    {
        //TraceMsg("Binding to IDLIST via BindToObject");
        hres = psfDesktop->BindToObject(pidl, NULL, riid, ppObject);
    }

exit_gracefully:

    if ( FAILED(hres) )
        *ppObject = NULL;

    if (psfDesktop)
      psfDesktop->Release();

    ILFree(pidl);
    pidl = NULL;

    return hres;
}
#endif

HRESULT _GetDirectorySF(IShellFolder **ppsf)
{
    HRESULT hres;
    IShellFolder *psf = NULL;
    IDsFolderInternalAPI *pdfi = NULL;
#if DOWNLEVEL_SHELL
    IPersistFolder* ppf = NULL;
#endif

    DWORD _dwFlags = 0;

    //TraceEnter(TRACE_VIEW, "CDsQuery::GetDirectorySF");

#if !DOWNLEVEL_SHELL
    // just bind to the path if this is not a downlevel shell.

    hres = BindToPath(c_szDsMagicPath, IID_IShellFolder, (void **)&psf);
    if (FAILED(hres))
    {
        //FailGracefully(hres, "Failed to get IShellFolder view of the DS namespace");
        goto exit_gracefully;
    }
#else
    // on the downlevel shell we need to CoCreate the IShellFolder implementation for the
    // DS namespace and initialize it manually

    hres = CoCreateInstance(CLSID_MicrosoftDS, NULL, CLSCTX_INPROC_SERVER, IID_IShellFolder, (void **)&psf);
    if (FAILED(hres))
    {
        //FailGracefully(hres, "Failed to get the IShellFolder interface we need");
        goto exit_gracefully;
    }
    if ( SUCCEEDED(psf->QueryInterface(IID_IPersistFolder, (void **)&ppf)) )
    {
        ITEMIDLIST idl = { 0 };
        ppf->Initialize(&idl);       // it calls ILCLone, so we are safe with stack stuff
        ppf->Release();
    }
#endif

    // using the internal API set all the parameters for dsfolder

    hres = psf->QueryInterface(IID_IDsFolderInternalAPI, (void **)&pdfi);
    if (FAILED(hres))
    {
        //FailGracefully(hres, "Failed to get the IDsFolderInternalAPI");
        goto exit_gracefully;
    }

    
    pdfi->SetAttributePrefix((_dwFlags & DSQPF_ENABLEADMINFEATURES) ? DS_PROP_ADMIN_PREFIX:NULL);

    if ( _dwFlags & DSQPF_ENABLEADVANCEDFEATURES )
        pdfi->SetProviderFlags(~DSPROVIDER_ADVANCED, DSPROVIDER_ADVANCED);

#if (FALSE)
    hres = pdfi->SetComputer(_pServer, _pUserName, _pPassword);
    //hres = pdfi->SetComputer(L"marcoc201-50.marcocdev.nttest.microsoft.com", NULL, NULL);
    if (FAILED(hres))
    {
        //FailGracefully(hres, "Failed when setting credential information to be used");
        goto exit_gracefully;
    }
#endif

exit_gracefully:
    
    if ( SUCCEEDED(hres) )
        psf->QueryInterface(IID_IShellFolder, (void **)ppsf);

    if (psf)
      psf->Release();
    if (pdfi)
      pdfi->Release();

    return hres;

}



/*-----------------------------------------------------------------------------
/ CDsQuery::_ADsPathToIdList
/ --------------------------
/   Convert an ADsPath into an IDLIST that is suitable for the DS ShellFolder
/   implementation.
/
/ In:
/   ppidl -> receives the resulting IDLIST
/   pPath = name to be parsed / = NULL then generate only the root of the namespace
/   pObjectClass = class to use
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT _ADsPathToIdList(LPITEMIDLIST* ppidl, LPWSTR pPath, LPWSTR pObjectClass)
{
    HRESULT hres;
    IBindCtx *pbc = NULL;
    IPropertyBag *ppb = NULL;
    IShellFolder *psf = NULL;
    VARIANT var;
    USES_CONVERSION;
    
    *ppidl = NULL;                  // incase we fail
                                       
    // if we have an object class then create a bind context containing it

    if ( pObjectClass )
    {
        // create a property bag
      hres = ::SHCreatePropertyBag(IID_IPropertyBag, (void **)&ppb);
        if (FAILED(hres))
        {
            //FailGracefully(hres, "Failed to create a property bag");
            goto exit_gracefully;
        }

        // allocate a variant BSTR and set it
        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = ::SysAllocString(pObjectClass);

        if ( V_BSTR(&var) )
        {
            ppb->Write(DS_PDN_OBJECTLCASS, &var);
            ::VariantClear(&var);
        }

        hres = CreateBindCtx(0, &pbc);
        if (FAILED(hres))
        {
            //FailGracefully(hres, "Failed to create the BindCtx object");
            goto exit_gracefully;
        }

        hres = pbc->RegisterObjectParam(DS_PDN_PROPERTYBAG, ppb);
        if (FAILED(hres))
        {
            //FailGracefully(hres, "Failed to register the property bag with bindctx");
            goto exit_gracefully;
        }

    }

    hres = _GetDirectorySF(&psf);
    if (FAILED(hres))
    {
        //FailGracefully(hres, "Failed to get ShellFolder for DS namespace");
        goto exit_gracefully;
    }

    hres = psf->ParseDisplayName(NULL, pbc, pPath, NULL, ppidl, NULL);
    if (FAILED(hres))
    {
        //FailGracefully(hres, "Failed to parse the name");
        goto exit_gracefully;
    }

exit_gracefully:

    if (pbc)
      pbc->Release();
    if (ppb)
      ppb->Release();
    if (psf)
      psf->Release();

    return hres;
}

#endif // _PROVIDE_CFSTR_SHELLIDLIST_FORMAT


//+----------------------------------------------------------------------------
//
//  Class:  CDsPropDataObj
//
//-----------------------------------------------------------------------------

CDsPropDataObj::CDsPropDataObj(HWND hwndParentPage,
                               BOOL fReadOnly) :
    m_fReadOnly(fReadOnly),
    m_pwszObjName(NULL),
    m_pwszObjClass(NULL),
    m_hwndParent(hwndParentPage),
    m_uRefs(1),
    m_pSelectionList(NULL)
{
#ifdef _DEBUG
    strcpy(szClass, "CDsPropDataObj");
#endif
    dspDebugOut((DEB_USER15, "dsprop's CDsPropDataObj::CDsPropDataObj 0x%x\n", this));
}

CDsPropDataObj::~CDsPropDataObj(void)
{
  if (m_pwszObjName)
  {
    delete [] m_pwszObjName;
  }
  if (m_pwszObjClass)
  {
    delete [] m_pwszObjClass;
  }

  if (m_pSelectionList != NULL)
  {
    for (ULONG idx = 0; idx < m_pSelectionList->cItems; idx++)
    {
      if (m_pSelectionList->aDsSelection[idx].pwzName != NULL)
      {
        delete[] m_pSelectionList->aDsSelection[idx].pwzName;
        m_pSelectionList->aDsSelection[idx].pwzName = NULL;
      }

      if (m_pSelectionList->aDsSelection[idx].pwzADsPath != NULL)
      {
        delete[] m_pSelectionList->aDsSelection[idx].pwzADsPath;
        m_pSelectionList->aDsSelection[idx].pwzADsPath = NULL;
      }

      if (m_pSelectionList->aDsSelection[idx].pwzClass != NULL)
      {
        delete[] m_pSelectionList->aDsSelection[idx].pwzClass;
        m_pSelectionList->aDsSelection[idx].pwzClass = NULL;
      }
    }
    delete m_pSelectionList;
    m_pSelectionList = NULL;
  }

}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropDataObj::Init
//
//  Synopsis:   Second phase of object creation where failable operations are
//              performed.
//
//-----------------------------------------------------------------------------
HRESULT CDsPropDataObj::Init(LPWSTR pwszObjName, LPWSTR pwszClass)
{
  if (!pwszObjName || *pwszObjName == L'\0')
  {
    return E_INVALIDARG;
  }
  if (!pwszClass || *pwszClass == L'\0')
  {
    return E_INVALIDARG;
  }
  m_pwszObjName = new WCHAR[wcslen(pwszObjName) + 1];
  CHECK_NULL(m_pwszObjName, return E_OUTOFMEMORY);
  wcscpy(m_pwszObjName, pwszObjName);

  m_pwszObjClass = new WCHAR[wcslen(pwszClass) + 1];
  CHECK_NULL(m_pwszObjClass, return E_OUTOFMEMORY);
  wcscpy(m_pwszObjClass, pwszClass);

  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropDataObj::Init
//
//  Synopsis:   Second phase of object creation where failable operations are
//              performed.
//
//-----------------------------------------------------------------------------
HRESULT CDsPropDataObj::Init(PDS_SELECTION_LIST pSelectionList)
{
  HRESULT hr = S_OK;

  if (m_pSelectionList != NULL)
  {
    for (ULONG idx = 0; idx < m_pSelectionList->cItems; idx++)
    {
      if (m_pSelectionList->aDsSelection[idx].pwzName != NULL)
      {
        delete[] m_pSelectionList->aDsSelection[idx].pwzName;
        m_pSelectionList->aDsSelection[idx].pwzName = NULL;
      }

      if (m_pSelectionList->aDsSelection[idx].pwzADsPath != NULL)
      {
        delete[] m_pSelectionList->aDsSelection[idx].pwzADsPath;
        m_pSelectionList->aDsSelection[idx].pwzADsPath = NULL;
      }

      if (m_pSelectionList->aDsSelection[idx].pwzClass != NULL)
      {
        delete[] m_pSelectionList->aDsSelection[idx].pwzClass;
        m_pSelectionList->aDsSelection[idx].pwzClass = NULL;
      }
    }
    delete m_pSelectionList;
    m_pSelectionList = NULL;
  }

  m_pSelectionList = pSelectionList;
  return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropDataObj::IDataObject::GetData
//
//  Synopsis:   Returns data, in this case the Prop Page format data.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropDataObj::GetData(FORMATETC * pFormatEtc, STGMEDIUM * pMedium)
{
    TRACE(CDsPropDataObj,GetData);
    if (IsBadWritePtr(pMedium, sizeof(STGMEDIUM)))
    {
        return E_INVALIDARG;
    }
    if (!(pFormatEtc->tymed & TYMED_HGLOBAL))
    {
        return DV_E_TYMED;
    }

    if (pFormatEtc->cfFormat == g_cfDsObjectNames)
    {
        // Return the object name and class.
        //
        size_t cbPath  = sizeof(WCHAR) * (wcslen(m_pwszObjName) + 1);
        size_t cbClass = sizeof(WCHAR) * (wcslen(m_pwszObjClass) + 1);
        size_t cbStruct = sizeof(DSOBJECTNAMES);

        LPDSOBJECTNAMES pDSObj;

        pDSObj = (LPDSOBJECTNAMES)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                              cbStruct + cbPath + cbClass);
        if (pDSObj == NULL)
        {
            return STG_E_MEDIUMFULL;
        }

        pDSObj->clsidNamespace = CLSID_MicrosoftDS;
        pDSObj->cItems = 1;
        pDSObj->aObjects[0].offsetName = static_cast<DWORD>(cbStruct);
        pDSObj->aObjects[0].offsetClass = static_cast<DWORD>(cbStruct + cbPath);
        if (m_fReadOnly)
        {
            pDSObj->aObjects[0].dwFlags = DSOBJECT_READONLYPAGES;
        }
        pDSObj->aObjects[0].dwProviderFlags = 0;

        dspDebugOut((DEB_ITRACE, "returning %ws and %ws\n", m_pwszObjName, m_pwszObjClass));
        wcscpy((PWSTR)((BYTE *)pDSObj + cbStruct), m_pwszObjName);
        wcscpy((PWSTR)((BYTE *)pDSObj + cbStruct + cbPath), m_pwszObjClass);

        pMedium->hGlobal = (HGLOBAL)pDSObj;
    }
    else if (pFormatEtc->cfFormat == g_cfDsPropCfg)
    {
        // Return the property sheet notification info. In this case, it is
        // the invokding sheet's hwnd.
        //
        PPROPSHEETCFG pSheetCfg;

        pSheetCfg = (PPROPSHEETCFG)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                               sizeof(PROPSHEETCFG));
        if (pSheetCfg == NULL)
        {
            return STG_E_MEDIUMFULL;
        }

        ZeroMemory(pSheetCfg, sizeof(PROPSHEETCFG));

        pSheetCfg->hwndParentSheet = m_hwndParent;

        pMedium->hGlobal = (HGLOBAL)pSheetCfg;
    }
#ifdef _PROVIDE_CFSTR_SHELLIDLIST_FORMAT
    else if (pFormatEtc->cfFormat == g_cfShellIDListArray)
    {
        // Return the CFSTR_SHELLIDLIST clipboard format
        LPITEMIDLIST pidl = NULL;
        HRESULT hr = _ADsPathToIdList(&pidl, m_pwszObjName, m_pwszObjClass);
        if (FAILED(hr))
        {
            return hr;
        }
        if (pidl == NULL)
        {
            return E_UNEXPECTED;
        }

        // we have a valid pidl, need to allocate global memory

        // get the count of bytes
        UINT cBytes = sizeof(CIDA) + ILGetSize(pidl) + sizeof(DWORD);

        LPIDA pIDArray = (LPIDA)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                               cBytes);
        if (pIDArray == NULL)
        {
            hr = STG_E_MEDIUMFULL;
        }
        else
        {
            hr = S_OK;
            pIDArray->cidl = 1;
            pIDArray->aoffset[0] = sizeof(CIDA);

            LPBYTE pMem = ((LPBYTE)pIDArray) + sizeof(CIDA);

            // copy the pidl past the CIDA
            ::memcpy(pMem, pidl, ILGetSize(pidl));

            pMem += ILGetSize(pidl);
            // make sure we have a NULL dword past the list
            ::ZeroMemory(pMem, sizeof(DWORD));

            pMedium->hGlobal = (HGLOBAL)pIDArray;
        }

        SHILFree(pidl);
        if (FAILED(hr))
        {
            return hr;
        }
    }
#endif // _PROVIDE_CFSTR_SHELLIDLIST_FORMAT
    else if (pFormatEtc->cfFormat == g_cfDsSelList)
    {
      //
      // Return the selection list for ObjectPicker
      //
      PDS_SELECTION_LIST pSelectionList = NULL;
      if (m_pSelectionList != NULL)
      {
        size_t cbRequired = sizeof(DS_SELECTION_LIST) + 
                            (sizeof(DS_SELECTION) * (m_pSelectionList->cItems - 1));
        pSelectionList = (PDS_SELECTION_LIST)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                                          cbRequired);
        if (pSelectionList == NULL)
        {
            return STG_E_MEDIUMFULL;
        }

        ZeroMemory(pSelectionList, cbRequired);

        memcpy(pSelectionList, m_pSelectionList, cbRequired);

        pMedium->hGlobal = (HGLOBAL)pSelectionList;
      }
      else
      {
        size_t cbRequired = sizeof(DS_SELECTION_LIST);
        pSelectionList = (PDS_SELECTION_LIST)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                                          cbRequired);
        if (pSelectionList == NULL)
        {
            return STG_E_MEDIUMFULL;
        }

        ZeroMemory(pSelectionList, cbRequired);
        pMedium->hGlobal = (HGLOBAL)pSelectionList;
      }
    }
    else
    {
        return DV_E_FORMATETC;
    }

    pMedium->tymed = TYMED_HGLOBAL;
    pMedium->pUnkForRelease = NULL;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropDataObj::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropDataObj::QueryInterface(REFIID riid, void ** ppvObject)
{
    TRACE2(CDsPropDataObj,QueryInterface);
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)this;
    }
    else if (IID_IDataObject == riid)
    {
        *ppvObject = this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropDataObj::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropDataObj::AddRef(void)
{
    dspDebugOut((DEB_USER15, "CDsPropDataObj::AddRef refcount going in %d\n", m_uRefs));
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropDataObj::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    zero if the reference count is zero or non-zero otherwise
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropDataObj::Release(void)
{
    dspDebugOut((DEB_USER15, "CDsPropDataObj::Release ref count going in %d\n", m_uRefs));
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
      delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//  Function:   AddPageProc
//
//  Synopsis:   The IShellPropSheetExt->AddPages callback.
//
//-----------------------------------------------------------------------------
//BOOL CALLBACK
//AddPageProc(HPROPSHEETPAGE hPage, LPARAM pCall)
//{
//    HRESULT hr;

//    hr = ((LPPROPERTYSHEETCALLBACK)pCall)->AddPage(hPage);

//    return hr == S_OK;
//}

//+----------------------------------------------------------------------------
//
//  Function:   PostPropSheet, internal; used by CDsPropPageBase members.
//
//  Synopsis:   Creates a property sheet for the named object using MMC's
//              IPropertySheetProvider so that extension snapins can add pages.
//
//  Arguments:  [pwzObjDN]   - the DN path of the DS object.
//              [pParentPage] - the invoking page's this pointer.
//              [fReadOnly]   - defaults to FALSE.
//
//-----------------------------------------------------------------------------
HRESULT
PostPropSheet(PWSTR pwzObjDN, CDsPropPageBase * pParentPage, BOOL fReadOnly)
{
    HRESULT hr;
    CComPtr<IADsPathname> spADsPath;

    dspDebugOut((DEB_ITRACE, "PostPropSheet passed path %ws\n", pwzObjDN));

    hr = pParentPage->GetADsPathname(spADsPath);

    CHECK_HRESULT_REPORT(hr, pParentPage->GetHWnd(), return hr);

    hr = spADsPath->Set(CComBSTR(pwzObjDN), ADS_SETTYPE_DN);

    CHECK_HRESULT_REPORT(hr, pParentPage->GetHWnd(), return hr);

    hr = spADsPath->put_EscapedMode(ADS_ESCAPEDMODE_ON);

    CHECK_HRESULT_REPORT(hr, pParentPage->GetHWnd(), return hr);

    BSTR bstrEscapedPath;

    hr = spADsPath->Retrieve(ADS_FORMAT_X500_DN, &bstrEscapedPath);

    CHECK_HRESULT_REPORT(hr, pParentPage->GetHWnd(), return hr);

    dspDebugOut((DEB_ITRACE, "PostPropSheet escaped path %ws\n", bstrEscapedPath));

    hr = PostPropSheetWorker(pParentPage, bstrEscapedPath,
                             pParentPage->m_pWPTDataObj,
                             pParentPage->GetHWnd(), fReadOnly);

    SysFreeString(bstrEscapedPath);

    // There is no reason to report an error here because all errors are reported
    // from within PostPropSheetWorker

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function:   PostADsPropSheet, exported from DLL.
//
//  Synopsis:   Creates a property sheet for the named object using MMC's
//              IPropertySheetProvider so that extension snapins can add pages.
//
//  Arguments:  [pwzObjDN]   - the full LDAP DN of the DS object.
//              [pParentObj] - the invoking page's MMC data object pointer.
//              [hwndParent] - the invoking page's window handle.
//              [fReadOnly]  - defaults to FALSE.
//
//-----------------------------------------------------------------------------
HRESULT
PostADsPropSheet(PWSTR pwzObjDN, IDataObject * pParentObj, HWND hwndParent,
                 BOOL fReadOnly)
{
    return PostPropSheetWorker(NULL, pwzObjDN, pParentObj, hwndParent, fReadOnly);
}

//+----------------------------------------------------------------------------
//
//  Function:   PostADsPropSheet, exported from DLL.
//
//  Synopsis:   Creates a property sheet for the named object using MMC's
//              IPropertySheetProvider so that extension snapins can add pages.
//
//  Arguments:  [pwzObjDN]   - the full LDAP DN of the DS object.
//              [pParentObj] - the invoking page's MMC data object pointer.
//              [hwndParent] - the invoking page's window handle.
//              [hNotifyObj] - the handle to the notify object window
//              [fReadOnly]  - defaults to FALSE.
//
//-----------------------------------------------------------------------------
HRESULT
PostADsPropSheet(PWSTR pwzObjDN, IDataObject * pParentObj, HWND hwndParent,
                 HWND hNotifyObj, BOOL fReadOnly)
{
    return PostPropSheetWorker(NULL, pwzObjDN, pParentObj, hwndParent, hNotifyObj, fReadOnly);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateSecondaryPageInfo
//
//  Synopsis:   Helper for posting a second sheet.
//
//-----------------------------------------------------------------------------
PDSA_SEC_PAGE_INFO CreateSecondaryPageInfo(HWND hwndParent,
                                           LPCWSTR lpszTitle,
                                           LPCWSTR lpszName,
                                           LPCWSTR lpszClass,
                                           BOOL fReadOnly)
{
  // determine memory allocation needs
  size_t nTitleLen = wcslen(lpszTitle)+1;
  size_t nNameLen = wcslen(lpszName)+1;
  size_t nClassLen = wcslen(lpszClass)+1;

  size_t cbStruct = sizeof(DSA_SEC_PAGE_INFO);
  size_t cbStrings = (nTitleLen+nNameLen+nClassLen)*sizeof(WCHAR);

  // allocate memory
  PDSA_SEC_PAGE_INFO pDsaSecondaryPageInfo = 
        (PDSA_SEC_PAGE_INFO) ::LocalAlloc(LPTR, (cbStruct + cbStrings));

  if (pDsaSecondaryPageInfo == NULL)
    return NULL;

  // set members

  pDsaSecondaryPageInfo->hwndParentSheet = hwndParent;

  // title string just at the end of the DSA_SEC_PAGE_INFO struct
  pDsaSecondaryPageInfo->offsetTitle = static_cast<DWORD>(cbStruct);
  wcscpy((LPWSTR)((BYTE *)pDsaSecondaryPageInfo + pDsaSecondaryPageInfo->offsetTitle), lpszTitle);


  DSOBJECTNAMES* pDsObjectNames = &(pDsaSecondaryPageInfo->dsObjectNames);
  pDsObjectNames->cItems = 1;

  DSOBJECT* pDsObject = &(pDsObjectNames->aObjects[0]);
  pDsObject->dwFlags = fReadOnly ? DSOBJECT_READONLYPAGES : 0;
  pDsObject->dwProviderFlags = 0; // not set

  // DSOBJECT strings past the DSA_SEC_PAGE_INFO strings
  // offsets are relative to the beginning of DSOBJECT struct
  pDsObject->offsetName = static_cast<DWORD>(sizeof(DSOBJECT) + nTitleLen*sizeof(WCHAR));
  wcscpy((LPWSTR)((BYTE *)pDsObject + pDsObject->offsetName), lpszName);

  pDsObject->offsetClass = static_cast<DWORD>(pDsObject->offsetName + nNameLen*sizeof(WCHAR));
  wcscpy((LPWSTR)((BYTE *)pDsObject + pDsObject->offsetClass), lpszClass);

  return pDsaSecondaryPageInfo;    
}


//+----------------------------------------------------------------------------
//
//  Function:   _WindowsPathFromDN
//
//  Synopsis:   Helper to translate a DN into a windows path
//              for example, from "CN=Joe,OU=test,DN=acme,DN=com"
//              to "LDAP://DN=com/DN=acme/OU=test/CN=Joe
//
//-----------------------------------------------------------------------------

HRESULT
_WindowsPathFromDN(IN PWSTR pwzObjDN, OUT BSTR* pbstrWindowsPath)
{
    // create a path cracker object
    CComPtr<IADsPathname> spIADsPathname;

    HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                    IID_IADsPathname, (void**)&spIADsPathname);
    if (FAILED(hr))
    {
        return hr;
    }

    spIADsPathname->Set(CComBSTR(pwzObjDN), ADS_SETTYPE_DN);
    hr = spIADsPathname->Retrieve(ADS_FORMAT_WINDOWS, pbstrWindowsPath);
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Function:   PostPropSheetWorker
//
//  Synopsis:   Helper for posting a second sheet.
//
//-----------------------------------------------------------------------------
HRESULT
PostPropSheetWorker(CDsPropPageBase * pParentPage, PWSTR pwzObjDN,
                    IDataObject * pParentObj, HWND hwndParent, BOOL fReadOnly)
{
    HWND hNotifyObj = NULL;
    ::SendMessage(hwndParent, WM_ADSPROP_PAGE_GET_NOTIFY, (WPARAM)&hNotifyObj, 0);
    if (hNotifyObj == NULL)
        return E_UNEXPECTED;

    return PostPropSheetWorker(pParentPage, pwzObjDN, pParentObj, hwndParent, hNotifyObj, fReadOnly);
}

HRESULT
PostPropSheetWorker(CDsPropPageBase * pParentPage, PWSTR pwzObjDN,
                    IDataObject * pParentObj, HWND hwndParent, HWND hNotifyObj, BOOL fReadOnly)
{
    HRESULT hr = S_OK;
    CDsPropDataObj * pDataObj = NULL;

    BSTR bstrName = NULL, bstrClass = NULL;
    BSTR bstrPath = NULL;
    CStrW strADsPath;
    CWaitCursor cWait;
    BOOL fShell = FALSE;
    PWSTR pwszName = NULL;
    CComPtr<IADsPathname> spPathCracker;

    hr = AddLDAPPrefix(pParentPage, pwzObjDN, strADsPath);

    CHECK_HRESULT(hr, return hr);

#ifdef DSADMIN

    // Check to see if a sheet is already posted for this object.
    //
    if (FindSheet(const_cast<PWSTR>((LPCWSTR)strADsPath)))
    {
        return S_OK;
    }

#endif // DSADMIN

    //
    // Activate the object as a test of the path's correctness. Get the
    // naming attribute, class, and schema class GUID while we are at it.
    //
    IADs * pObj = NULL;
    dspDebugOut((DEB_USER1, "Opening prop sheet on '%S'\n", strADsPath));

    hr = DSAdminOpenObject(const_cast<PWSTR>((LPCWSTR)strADsPath), 
                           IID_IADs, 
                           (PVOID *)&pObj);

    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        // Display the object-not-found error message.
        //
        TCHAR tzFormat[MAX_ERRORMSG+1], tzTitle[MAX_TITLE+1];
        PTSTR ptzObjDN, ptzMsg;

        LOAD_STRING(IDS_INVALID_NAME_FORMAT, tzFormat, MAX_ERRORMSG, return E_OUTOFMEMORY);
        LOAD_STRING(IDS_MSG_TITLE, tzTitle, MAX_TITLE, return E_OUTOFMEMORY);

        if (!UnicodeToTchar(pwzObjDN, &ptzObjDN))
        {
            return E_OUTOFMEMORY;
        }

		//NTRAID#NTBUG9-571996-2002/03/10-jmessec   Can't use _tcslen(tzFormat) for buffer length determination;
		//%25s could be passed in (resource change, localization, etc), causing a buffer overrun

        ptzMsg = new TCHAR[_tcslen(ptzObjDN) + _tcslen(tzFormat) + 1];

        CHECK_NULL(ptzMsg, delete [] ptzObjDN; return E_OUTOFMEMORY);

        wsprintf(ptzMsg, tzFormat, ptzObjDN);

        delete [] ptzObjDN;

        MessageBox(hwndParent, ptzMsg, tzTitle,
                    MB_ICONEXCLAMATION | MB_OK);

        goto Cleanup;
    }
    if (!CHECK_ADS_HR(&hr, hwndParent))
    {
        goto Cleanup;
    }

    hr = pObj->get_ADsPath(&bstrPath);

    CHECK_HRESULT_REPORT(hr, hwndParent, goto Cleanup;);

    hr = pObj->get_Class(&bstrClass);

    CHECK_HRESULT_REPORT(hr, hwndParent, goto Cleanup;);

    pObj->Release();
    pObj = NULL;

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (PVOID *)&spPathCracker);
    if (SUCCEEDED(hr))
    {
      hr = spPathCracker->Set(bstrPath, ADS_SETTYPE_FULL);
      if (SUCCEEDED(hr))
      {
        LONG lEscapeMode = 0;
        hr = spPathCracker->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
        if (SUCCEEDED(hr))
        {
          hr = spPathCracker->get_EscapedMode(&lEscapeMode);
          if (SUCCEEDED(hr))
          {
            hr = spPathCracker->put_EscapedMode(ADS_ESCAPEDMODE_OFF_EX);
            if (SUCCEEDED(hr))
            {
              hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstrName);
              dspAssert(bstrName != NULL);
            }
          }
        }

        //
        // Set the display back to full so we don't mess up other instances
        //
        hr = spPathCracker->SetDisplayType(ADS_DISPLAY_FULL);
        hr = spPathCracker->put_EscapedMode(lEscapeMode);
      }
    }
    //
    // If something went wrong with the path cracker just hack the name
    // ourselves.
    //
    if (bstrName == NULL)
    {
      hr = pObj->get_Name(&bstrName);

      CHECK_HRESULT_REPORT(hr, hwndParent, goto Cleanup;);

      pwszName = wcschr(bstrName, L'=');
      if (pwszName && (*pwszName != L'\0'))
      {
          pwszName++;
      }
      else
      {
          pwszName = bstrName;
      }
    }
    else
    {
      pwszName = bstrName;
    }

    bool fDomAdmin = false;

    //
    // Are we being called from the shell or from the admin snapin?
    //
    if (!pParentObj)
    {
        fShell = TRUE;
    }
    else
    {
        FORMATETC fmte = {g_cfDsDispSpecOptions, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM ObjMedium;
        PDSDISPLAYSPECOPTIONS pDsDispSpecOptions;
        PWSTR pwzAttribPrefix;

        hr = pParentObj->GetData(&fmte, &ObjMedium);

        if (DV_E_FORMATETC == hr)
        {
            fShell = TRUE;
        }
        else
        {
            CHECK_HRESULT(hr, return hr);

            pDsDispSpecOptions = (PDSDISPLAYSPECOPTIONS)ObjMedium.hGlobal;

            pwzAttribPrefix = (PWSTR)ByteOffset(pDsDispSpecOptions,
                                                pDsDispSpecOptions->offsetAttribPrefix);

            if (_wcsicmp(pwzAttribPrefix, DS_PROP_ADMIN_PREFIX) != 0)
            {
                fShell = TRUE;
            }
            ReleaseStgMedium(&ObjMedium);
        }

        fmte.cfFormat = g_cfDsObjectNames;
        fmte.ptd = NULL;
        fmte.dwAspect = DVASPECT_CONTENT;
        fmte.lindex = -1;
        fmte.tymed = TYMED_HGLOBAL;

        hr = pParentObj->GetData(&fmte, &ObjMedium);

        CHECK_HRESULT(hr, return hr);

        LPDSOBJECTNAMES pDsObjectNames = (LPDSOBJECTNAMES)ObjMedium.hGlobal;

        if (IsEqualCLSID(pDsObjectNames->clsidNamespace, CLSID_DomainAdmin))
        {
           fDomAdmin = true;
        }

        ReleaseStgMedium(&ObjMedium);
    }

    if (fShell)
    {
        // the shell uses windows paths, so we have to convert the DN
        //
        BSTR bstrWindowsPath = NULL;
        CStrW strADsWindowsPath;

        hr = _WindowsPathFromDN(pwzObjDN, &bstrWindowsPath);
        if (SUCCEEDED(hr))
        {
            strADsWindowsPath = bstrWindowsPath;
            ::SysFreeString(bstrWindowsPath);
        }
        else
        {
            // if we fail, try to survive with the regular ADSI path
            strADsWindowsPath = strADsPath;
        }

        // try to see it a sheet with this title is already up
        if (FindSheet(const_cast<PWSTR>((LPCWSTR)strADsWindowsPath)))
        {
            goto Cleanup;
        }
      
        // Create the intermediary data object.
        //
        pDataObj = new CDsPropDataObj(hwndParent, fReadOnly);

        CHECK_NULL_REPORT(pDataObj, hwndParent, goto Cleanup;);

        hr = pDataObj->Init(const_cast<PWSTR>((LPCWSTR)strADsWindowsPath), bstrClass);

        CHECK_HRESULT_REPORT(hr, hwndParent, goto Cleanup;);

        //
        // Have the DS shell folder extension post the sheet.
        //
        IDsFolderProperties * pdfp = NULL;

        hr = CoCreateInstance(CLSID_DsFolderProperties, NULL, CLSCTX_INPROC_SERVER,
                              IID_IDsFolderProperties, (void **)&pdfp);

        CHECK_HRESULT_REPORT(hr, hwndParent, goto Cleanup;);

        hr = pdfp->ShowProperties(hwndParent, pDataObj);

        CHECK_HRESULT_REPORT(hr, hwndParent, ;);

        pdfp->Release();

        goto Cleanup;
    }

    // called from DS Admin, delegate to it
    {
      //
      // First crack the path to something readable
      //
      if (!pwszName)
      {
        PWSTR pwzCanEx = NULL;

        hr = CrackName(pwzObjDN, &pwzCanEx, GET_OBJ_CAN_NAME_EX, hwndParent);

        if (SUCCEEDED(hr) &&
            pwzCanEx)
        {
          PWSTR pwzSlash = wcsrchr(pwzCanEx, L'\n');
          if (pwzSlash)
          {
            pwszName = pwzSlash + 1;
          }
          else
          {
            pwszName = pwzCanEx;
          }
        }
      }

      hr = S_OK;

      PDSA_SEC_PAGE_INFO pDsaSecondaryPageInfo = 
                          CreateSecondaryPageInfo(hwndParent, pwszName, pwzObjDN, bstrClass, fReadOnly);

      if (pDsaSecondaryPageInfo == NULL)
      {
          hr = E_OUTOFMEMORY;
          CHECK_HRESULT_REPORT(hr, hwndParent, goto Cleanup;);
      }

      PWSTR pwzDC = NULL;

      if (fDomAdmin)
      {
         //
         // Get the DC name to send to the snap in.
         //
         CStrW strDC;

         hr = GetLdapServerName(pParentPage->m_pDsObj, strDC);

         if (SUCCEEDED(hr))
         {
            pwzDC = (PWSTR) LocalAlloc(LPTR, (strDC.GetLength() + 1) * sizeof(WCHAR));

            CHECK_NULL_REPORT(pwzDC, hwndParent, goto Cleanup);

            wcscpy(pwzDC, strDC);
         }
      }

      ::SendMessage(hNotifyObj, WM_ADSPROP_SHEET_CREATE, (WPARAM)pDsaSecondaryPageInfo, (LPARAM)pwzDC);
    }

    cWait.SetOld();

Cleanup:

    if (pObj)
    {
        pObj->Release();
    }

    if (pDataObj)
    {
        // The prop sheet holds on to the dataobj, so don't delete it here.
        //
        dspDebugOut((DEB_USER15, "PostPropSheet releasing data obj 0x%x\n", pDataObj));
        pDataObj->Release();
    }

    if (bstrName)
    {
        SysFreeString(bstrName);
    }
    if (bstrClass)
    {
        SysFreeString(bstrClass);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetDomainScope
//
//  Synopsis:   Returns the full LDAP DN of the domain of the current object.
//
//-----------------------------------------------------------------------------
HRESULT GetDomainScope(CDsPropPageBase * pPage, BSTR * pBstrOut)
{
    PWSTR pwzObjDN;
    HRESULT hr = pPage->SkipPrefix(pPage->GetObjPathName(), &pwzObjDN);

    CHECK_HRESULT(hr, return hr);

    hr = GetObjectsDomain(pPage, pwzObjDN, pBstrOut);

    DO_DEL(pwzObjDN);
    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetObjectsDomain
//
//  Synopsis:   Returns the full LDAP DN of the domain of the passed in object.
//
//-----------------------------------------------------------------------------
HRESULT GetObjectsDomain(CDsPropPageBase * pPage, PWSTR pwzObjDN, BSTR * pBstrOut)
{
    PWSTR pwzDomainDN;
    HRESULT hr;

    hr = CrackName(pwzObjDN, &pwzDomainDN, GET_FQDN_DOMAIN_NAME, pPage->GetHWnd());

    CHECK_HRESULT(hr, return hr);
    CComPtr<IADsPathname> spPathCracker;

    hr = pPage->GetADsPathname(spPathCracker);

    CHECK_HRESULT(hr, return hr);

    hr = spPathCracker->Set(CComBSTR(g_wzLDAPProvider), ADS_SETTYPE_PROVIDER);

    CHECK_HRESULT(hr, return hr);

    CStrW strDC;

    hr = GetLdapServerName(pPage->m_pDsObj, strDC);

    CHECK_HRESULT(hr, return hr);

    hr = spPathCracker->Set(CComBSTR(strDC), ADS_SETTYPE_SERVER);

    CHECK_HRESULT(hr, return hr);

    hr = spPathCracker->Set(CComBSTR(pwzDomainDN), ADS_SETTYPE_DN);

    LocalFreeStringW(&pwzDomainDN);
    CHECK_HRESULT(hr, return hr);

    hr = spPathCracker->Retrieve(ADS_FORMAT_X500, pBstrOut);

    CHECK_HRESULT(hr, return hr);

    dspDebugOut((DEB_USER1, "Object's domain is: '%S'\n", *pBstrOut));

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CheckRegisterClipFormats
//
//  Synopsis:   If the clipboard formats haven't been registered yet, register
//              them.
//
//-----------------------------------------------------------------------------
HRESULT
CheckRegisterClipFormats(void)
{
    // Check to see if we have our clipboard formats registered, if not then
    // lets do it.

    if (!g_cfDsObjectNames)
    {
        g_cfDsObjectNames = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
    }
    if (!g_cfDsObjectNames)
    {
        ERR_OUT("No clipboard format registered", 0);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!g_cfDsDispSpecOptions)
    {
        g_cfDsDispSpecOptions = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_DISPLAY_SPEC_OPTIONS);
    }
    if (!g_cfDsDispSpecOptions)
    {
        ERR_OUT("No DS Display Spec Options clipboard format registered", 0);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!g_cfShellIDListArray)
    {
        g_cfShellIDListArray = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
    }
    if (!g_cfShellIDListArray)
    {
        ERR_OUT("No Shell IDList Array clipboard format registered", 0);
        return HRESULT_FROM_WIN32(GetLastError());
    }

#ifdef DSADMIN
    if (!g_cfMMCGetNodeType)
    {
        g_cfMMCGetNodeType = (CLIPFORMAT)RegisterClipboardFormat(CCF_NODETYPE);
    }
    if (!g_cfMMCGetNodeType)
    {
        ERR_OUT("No node-type clipboard format registered", 0);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!g_cfDsPropCfg)
    {
        g_cfDsPropCfg = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_PROPSHEETCONFIG);
    }
    if (!g_cfDsPropCfg)
    {
        ERR_OUT("No propsheet cfg clipboard format registered", 0);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!g_cfDsSelList)
    {
        g_cfDsSelList = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
    }
    if (!g_cfDsSelList)
    {
        ERR_OUT("No object picker clipboard format registered", 0);
        return HRESULT_FROM_WIN32(GetLastError());
    }


    if (!g_cfDsMultiSelectProppages)
    {
      g_cfDsMultiSelectProppages = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_MULTISELECTPROPPAGE);
    }
    if (!g_cfDsMultiSelectProppages)
    {
      ERR_OUT("No multi-select proppages clipboard format registered", 0);
      return HRESULT_FROM_WIN32(GetLastError());
    }

    //if (!g_cfMMCGetCoClass)
    //{
    //    g_cfMMCGetCoClass = (CLIPFORMAT)RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
    //}
    //if (!g_cfMMCGetCoClass)
    //{
    //    ERR_OUT("No clipboard format registered", 0);
    //    return HRESULT_FROM_WIN32(GetLastError());
    //}
#endif
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CrackName
//
//  Synopsis:   Given an object name, returns the requested name. The string
//              allocated to hold this name must be freed using
//              LocalFreeStringW (it and LocalAllocStringW are imported from
//              dsuiext.dll).
//
//  Operations:
//    GET_OBJ_CAN_NAME     - return the object's canonical name.
//    GET_OBJ_CAN_NAME_EX  - leaf element delimited by CR character.
//    GET_OBJ_1779_DN      - return object's FQDN.
//    GET_OBJ_NT4_NAME     - return object's downlevel name (domain\name).
//    GET_DNS_DOMAIN_NAME  - return object's DNS domain name.
//    GET_NT4_DOMAIN_NAME  - return object's NT4 domain name.
//    GET_FQDN_DOMAIN_NAME - return object's FQDN domain name.
//    GET_OBJ_UPN          - return object's User Principal name.
//
//  Assumptions: Object (pwzNameIn) can be in any domain. Therefore, resolving
//               the name may require chasing referrals.
//               Syntactical-only name cracking is much faster, so don't bind
//               to the DC unless syntactical-only fails.
//
//  Methodology:
//    GET_OBJ_CAN_NAME - Try syntactical-only first. If that fails, go through
//      the loop again using the DC. Format requested is DS_CANONICAL_NAME.
//    GET_OBJ_CAN_NAME_EX - Same as above except name format requested is
//      DS_CANONICAL_NAME_EX.
//    GET_OBJ_1779_DN - Same as above except name format requested is
//      DS_FQDN_1779_NAME.
//    GET_OBJ_NT4_NAME = Same as above except name format requested is
//      DS_NT4_ACCOUNT_NAME (flat-domain\name).
//    GET_DNS_DOMAIN_NAME - Same as above except return the pDomain element of
//      the DS_NAME_RESULT struct.
//    GET_NT4_DOMAIN_NAME - The NT4 domain name is returned by DsGetDcName.
//      However, we don't know up front whether pwzNameIn is in the current
//      domain or not. Thus, the goal when the loop is first entered will be
//      to obtain a valid DNS domain name. That is, when DsCrackNames returns
//      with a zero status then pwzDomain will contain the DNS domain name for
//      the object's domain. After that, the DomainName value returned by
//      DsGetDcName will be the downlevel domain name.
//    GET_FQDN_DOMAIN_NAME - This is similar to GET_NT4_DOMAIN_NAME except that
//      once the DNS domain name is obtained, DsCrackNames must be called once
//      more to convert that to the 1779 name for the domain.
//
//-----------------------------------------------------------------------------
HRESULT
CrackName(PWSTR pwzNameIn, PWSTR * ppwzResultName, CRACK_NAME_OPR RequestedOpr,
          HWND hWnd)
{
    HRESULT hr = S_OK;
    CRACK_NAME_OPR CurOpr = RequestedOpr;
    HANDLE hDS = (HANDLE)-1;
    PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;
    DWORD dwErr = 0;
    PDS_NAME_RESULTW pDsNameResult = NULL;
    PWSTR * ppwsIn = &pwzNameIn, pwzNameResult = NULL;
    PWSTR pwzDomain = NULL, pwzNT4Domain = NULL, pwzDomRoot = NULL;
    BOOL fLoopAgain = FALSE, fGotDnsDomain = FALSE, fNeedDcBind = FALSE;
    ULONG GetDcFlags = DS_DIRECTORY_SERVICE_REQUIRED | DS_IP_REQUIRED |
                       DS_WRITABLE_REQUIRED;
    DS_NAME_FORMAT FormatOffered = DS_FQDN_1779_NAME;
    DS_NAME_FORMAT FormatRequested = DS_CANONICAL_NAME, OriginalFormatRequested = DS_CANONICAL_NAME;
    DS_NAME_FLAGS NameFlags = DS_NAME_FLAG_SYNTACTICAL_ONLY;

    dspDebugOut((DEB_USER1, "CrackName input: %ws\n", pwzNameIn));

    switch (RequestedOpr)
    {
    case GET_NT4_DOMAIN_NAME:
    case GET_FQDN_DOMAIN_NAME:
        CurOpr = GET_DNS_DOMAIN_NAME;
        break;

    case GET_OBJ_1779_DN:
        FormatOffered = DS_UNKNOWN_NAME;
        FormatRequested = DS_FQDN_1779_NAME;
        break;

    case GET_OBJ_NT4_NAME:
        FormatRequested = DS_NT4_ACCOUNT_NAME;
        break;

    case GET_OBJ_CAN_NAME_EX:
        FormatRequested = DS_CANONICAL_NAME_EX;
        break;

    case GET_OBJ_UPN:
        FormatOffered = DS_UNKNOWN_NAME;
        FormatRequested = DS_USER_PRINCIPAL_NAME;
        break;
    }

    do
    {
        if (!(NameFlags & DS_NAME_FLAG_SYNTACTICAL_ONLY))
        {
            // Get a DC name for the domain and bind to it.
            //
            if (CurOpr == GET_NT4_DOMAIN_NAME)
            {
                GetDcFlags |= DS_RETURN_FLAT_NAME;
            }

            dspDebugOut((DEB_ITRACE, "Getting DC for domain '%ws'\n", pwzDomain));

            dwErr = DsGetDcNameW(NULL, pwzDomain, NULL, NULL, GetDcFlags,
                                 &pDCInfo);

            CHECK_WIN32_REPORT(dwErr, hWnd, return HRESULT_FROM_WIN32(dwErr));
            dspAssert(pDCInfo != NULL);

            if (CurOpr == GET_NT4_DOMAIN_NAME)
            {
                if (FAILED(LocalAllocStringW(&pwzNT4Domain,
                                             pDCInfo->DomainName)))
                {
                    REPORT_ERROR(E_OUTOFMEMORY, hWnd);
                    return E_OUTOFMEMORY;
                }
            }
            else
            {
                dwErr = DsBindW(pDCInfo->DomainControllerName, NULL, &hDS);
            }

#ifdef DSADMIN
            NetApiBufferFree(pDCInfo);
#else
            LocalFree(pDCInfo);
#endif
            pDCInfo = NULL;

            if (dwErr != ERROR_SUCCESS)
            {
                // Try again, the DC returned above was unavailable (i.e., the
                // cache list was stale).
                //
                GetDcFlags |= DS_FORCE_REDISCOVERY;

                dwErr = DsGetDcNameW(NULL, pwzDomain, NULL, NULL, GetDcFlags,
                                     &pDCInfo);

                CHECK_WIN32_REPORT(dwErr, hWnd, ;);

                if (dwErr == ERROR_SUCCESS)
                {
                    dspAssert(pDCInfo != NULL);

                    if (CurOpr == GET_NT4_DOMAIN_NAME)
                    {
                        LocalFreeStringW(&pwzNT4Domain);

                        if (FAILED(LocalAllocStringW(&pwzNT4Domain,
                                                     pDCInfo->DomainName)))
                        {
                            REPORT_ERROR(E_OUTOFMEMORY, hWnd);
                            return E_OUTOFMEMORY;
                        }
                    }
                    else
                    {
                        dwErr = DsBindW(pDCInfo->DomainControllerName,
                                        NULL, &hDS);
                    }
                }
#ifdef DSADMIN
                NetApiBufferFree(pDCInfo);
#else
                LocalFree(pDCInfo);
#endif
            }
            CHECK_WIN32_REPORT(dwErr, hWnd, return HRESULT_FROM_WIN32(dwErr));

            if (CurOpr == GET_NT4_DOMAIN_NAME)
            {
                break;
            }
        }

        //
        // Convert the object name.
        //
        dwErr = DsCrackNamesW(hDS, NameFlags, FormatOffered,
                              FormatRequested, 1, ppwsIn, &pDsNameResult);

        if (!(NameFlags & DS_NAME_FLAG_SYNTACTICAL_ONLY))
        {
            DsUnBind(&hDS);
        }

        CHECK_WIN32_REPORT(dwErr, hWnd, return HRESULT_FROM_WIN32(dwErr));

        dspAssert(pDsNameResult);

        dspAssert(pDsNameResult->cItems == 1);

        switch (pDsNameResult->rItems->status)
        {
        case DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING:
            //
            // A syntactical-only cracking failed, so do it again and use
            // the DC.
            //
            if (fNeedDcBind)
            {
                // Can't syntactically get the domain name, format offered
                // must not be 1779; nothing we can do.
                //
                fLoopAgain = FALSE;
                fNeedDcBind = FALSE;
                pwzNameResult = pwzNameIn;
                hr = MAKE_HRESULT(SEVERITY_ERROR, 0, DS_NAME_ERROR_NO_MAPPING);
            }
            else
            {
                if (DS_FQDN_1779_NAME == FormatOffered)
                {
                    // If the format offered is 1779, then a syntactic-only
                    // crack for canonical name will supply the DNS domain name.
                    // So, set a flag that says we are getting the domain name.
                    //
                    fNeedDcBind = TRUE;
                    OriginalFormatRequested = FormatRequested;
                    FormatRequested = DS_CANONICAL_NAME;
                    //
                    // The DS_NAME_FLAG_PRIVATE_PURE_SYNTACTIC flag means to
                    // return the syntactic mapping even for FPOs which other-
                    // wise cannot be cracked syntactically.
                    //
                    NameFlags = (DS_NAME_FLAGS)((int)DS_NAME_FLAG_SYNTACTICAL_ONLY
                                                   | DS_NAME_FLAG_PRIVATE_PURE_SYNTACTIC);
                }
                else
                {
                    NameFlags = DS_NAME_NO_FLAGS;
                }
                fLoopAgain = TRUE;
            }
            continue;

        case DS_NAME_ERROR_DOMAIN_ONLY:
            //
            // The object info is in another domain. Go there and try again
            // (unless only the DNS domain name is needed).
            //
            LocalFreeStringW(&pwzDomain);

            if (FAILED(LocalAllocStringW(&pwzDomain,
                                         pDsNameResult->rItems->pDomain)))
            {
                REPORT_ERROR(E_OUTOFMEMORY, hWnd);
                DsFreeNameResultW(pDsNameResult);
                return E_OUTOFMEMORY;
            }
            DsFreeNameResultW(pDsNameResult);
            pDsNameResult = NULL;

            fGotDnsDomain = TRUE;

            if (RequestedOpr == GET_DNS_DOMAIN_NAME)
            {
                fLoopAgain = FALSE;
            }
            else
            {
                NameFlags = DS_NAME_NO_FLAGS;
                fLoopAgain = TRUE;
            }
            break;

        case DS_NAME_NO_ERROR:
            //
            // Success!
            //

            fLoopAgain = FALSE;

            if (CurOpr == GET_DNS_DOMAIN_NAME || fNeedDcBind)
            {
                fGotDnsDomain = TRUE;
                LocalFreeStringW(&pwzDomain);
                if (FAILED(LocalAllocStringW(&pwzDomain,
                                             pDsNameResult->rItems->pDomain)))
                {
                    REPORT_ERROR(E_OUTOFMEMORY, hWnd);
                    DsFreeNameResultW(pDsNameResult);
                    return E_OUTOFMEMORY;
                }
                DsFreeNameResultW(pDsNameResult);
                pDsNameResult = NULL;

                if (fNeedDcBind)
                {
                    fLoopAgain = TRUE;
                    NameFlags = DS_NAME_NO_FLAGS;
                    fNeedDcBind = FALSE;
                    FormatRequested = OriginalFormatRequested;
                }
            }
            else
            {
                pwzNameResult = pDsNameResult->rItems->pName;
            }
            break;

        case DS_NAME_ERROR_RESOLVING:
        case DS_NAME_ERROR_NOT_FOUND:
        case DS_NAME_ERROR_NO_MAPPING:
            //
            // Can't map the name for some reason, just return the original
            // name and set the return value to DS_NAME_ERROR_NO_MAPPING.
            //
            fLoopAgain = FALSE;
            pwzNameResult = pwzNameIn;
            hr = MAKE_HRESULT(SEVERITY_ERROR, 0, DS_NAME_ERROR_NO_MAPPING);
            break;

        default:
            CHECK_WIN32_REPORT(pDsNameResult->rItems->status, hWnd,
                return MAKE_HRESULT(SEVERITY_ERROR, 0, pDsNameResult->rItems->status));
            break;
        }

        if (RequestedOpr == GET_NT4_DOMAIN_NAME ||
            RequestedOpr == GET_FQDN_DOMAIN_NAME)
        {
            if (CurOpr == GET_FQDN_DOMAIN_NAME)
            {
                DO_DEL(*ppwsIn);
            }
            if (CurOpr == GET_DNS_DOMAIN_NAME)
            {
                if (fGotDnsDomain)
                {
                    // Got the DNS domain name, now loop once more to finish.
                    //
                    dspAssert(pwzDomain);
                    fLoopAgain = TRUE;
                    CurOpr = RequestedOpr;
                    NameFlags = DS_NAME_NO_FLAGS;

                    if (RequestedOpr == GET_FQDN_DOMAIN_NAME)
                    {
                        // JonN 3/3/99; per DaveStr this should be
                        FormatOffered = DS_CANONICAL_NAME;
                        NameFlags = DS_NAME_FLAG_SYNTACTICAL_ONLY;
                        // was FormatOffered = DS_UNKNOWN_NAME;
                        FormatRequested = DS_FQDN_1779_NAME;
                        pwzDomRoot = new WCHAR[wcslen(pwzDomain) + 2];
                        CHECK_NULL_REPORT(pwzDomRoot, hWnd, return E_OUTOFMEMORY);
                        wcscpy(pwzDomRoot, pwzDomain);
                        wcscat(pwzDomRoot, L"/");
                        ppwsIn = &pwzDomRoot;
                    }
                }
                else
                {
                    fLoopAgain = FALSE;
                }
            }
        }
    } while (fLoopAgain);

    switch (RequestedOpr)
    {
    case GET_OBJ_CAN_NAME:
    case GET_OBJ_CAN_NAME_EX:
    case GET_OBJ_1779_DN:
    case GET_OBJ_NT4_NAME:
    case GET_FQDN_DOMAIN_NAME:
    case GET_OBJ_UPN:
        dspAssert(pDsNameResult);
        if (FAILED(LocalAllocStringW(ppwzResultName, pwzNameResult)))
        {
            DsFreeNameResultW(pDsNameResult);
            REPORT_ERROR(E_OUTOFMEMORY, hWnd);
            return E_OUTOFMEMORY;
        }

        LocalFreeStringW(&pwzDomain);
        delete [] pwzDomRoot;
        pwzDomRoot = NULL;
        break;

    case GET_DNS_DOMAIN_NAME:
        dspAssert(pwzDomain);
        *ppwzResultName = pwzDomain;
        break;

    case GET_NT4_DOMAIN_NAME:
        dspAssert(pwzNT4Domain);
        *ppwzResultName = pwzNT4Domain;
        LocalFreeStringW(&pwzDomain);
        break;

    default:
        dspAssert(FALSE);
    }

    if (pDsNameResult)
    {
        DsFreeNameResultW(pDsNameResult);
    }

    return hr;
}

#ifdef DSADMIN

HRESULT DSPROP_GetGCSearchOnDomain(
    PWSTR pwzDomainDnsName,
    IN  REFIID iid,
    OUT void** ppvObject )
{
    HRESULT hr = S_OK;
    ASSERT( NULL != ppvObject && NULL == *ppvObject );

    CStrW strGC = L"GC:";

    if (pwzDomainDnsName)
    {
      strGC += L"//";
      //  strGC += pwzDomainDnsName;
      PDOMAIN_CONTROLLER_INFO pDCInfo;
      DWORD dwErr = DsGetDcName (NULL,
                                 pwzDomainDnsName,
                                 NULL,NULL,
                                 DS_DIRECTORY_SERVICE_REQUIRED,
                                 &pDCInfo);
      hr = HRESULT_FROM_WIN32(dwErr);
      CHECK_HRESULT(hr, return hr);
      strGC += pDCInfo->DnsForestName;
      NetApiBufferFree(pDCInfo);
    }

    dspDebugOut((DEB_ITRACE, "Binding to %ws\n", strGC));

    hr = DSAdminOpenObject(const_cast<PWSTR>((LPCWSTR)strGC),
                           iid, 
                           (PVOID *)ppvObject);
    CHECK_HRESULT(hr, return hr);
    return S_OK;
}

//+----------------------------------------------------------------------------
//  SMTP address validation. This is adapted from code provided by Eric Dao
//  and Wayne Cranston of the Exchange team.
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Function:    bParse821IPv4Literal
//
//  parse:  IPv4literal ::= snum 3("." snum)
//                 snum ::= one, two or three digits representing a decimal
//                          integer in the range 0 through 255
//
//-----------------------------------------------------------------------------
static BOOL bParse821IPv4Literal(PSTR* ppsz)
{
    PSTR p        = *ppsz;
    DWORD n       = 0;
    DWORD cOctets = 0;
    DWORD cDigits = 0;

    dspAssert(*p == '[');

    while (*p) 
    {
        p++;
        n = 0;
        cDigits = 0;

        if (!isdigit(*p))
            return FALSE;

        while (isdigit(*p))
        {
            if (++cDigits > 3)
                return FALSE;

            n = n * 10 + *p - '0';
            p++;
        }

        if (++cOctets > 4)
            return FALSE;

        if (n > 255)
            return FALSE;

        if ('.' != *p)
            break;
    }

    if (']' != *p || cOctets != 4)
        return FALSE;

    p++;
    *ppsz = p;

    return TRUE;
}
//+----------------------------------------------------------------------------
//
//  Function:    bParse821AtDomain
//
//  parse:
//             <a-d-l> ::= <at-domain> | <at-domain> "," <a-d-l>
//         <at-domain> ::= "@" <domain>
//            <domain> ::= <element> | <element> "." <domain>
//         // IMC does not support #<number> or [127.0.0.1]
//           <element> ::= <name> | "#" <number> | "[" <dotnum> "]"
//           <element> ::= <name> 
//              <name> ::= <let-dig> <ldh-str> <let-dig>
//           <ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>
//           <let-dig> ::= <a> | <d>
//       <let-dig-hyp> ::= <a> | <d> | "-" | "_" ; underscore is invalid, but still used
//                 <a> ::= [A-Za-z]
//                 <d> ::= [0-9]
//-----------------------------------------------------------------------------
static BOOL bParse821AtDomain(PSTR* ppsz)
{
    PSTR p = *ppsz;

    dspAssert(*p == '@');

    p++;

    if ('\0' == *p)
         return FALSE;

    // Check for IPv4 literals
    // 
    if ('[' == *p)
    {
        if (!bParse821IPv4Literal(&p))
            return FALSE;

        goto Exit;
    }

    //
    // Check to be sure the first character is an alpha
    // or '#'

    if (!isalnum(*p) && '#' != *p)
    {
      return FALSE;
    }
    p++;

    while (*p)
    {
        // NTRAID#NTBUG9-687019-2002/8/13-JeffJon
        // The second character can be either an alpha-numeric
        // or a '-'

        while (*p && (isalnum(*p) || *p == '-'))
        {
            p++;
        }

        if (!isalnum(*(p-1)))
            return FALSE;

        if ('.' != *p)
            break;

        p++;
    }

Exit:
    *ppsz = p;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:    bParse821String
//
//  parse:
//           <string> ::= <char> | <char> <string>
//             <char> ::= <c> | "\" <x>
//                <c> ::= any of the 128 ascii characters, but not any <special>
//                        or <sp>
//                <x> ::= any one of the 128 ascii characters (no exceptions)
//               <sp> ::= space (ASCII 32)
//          <special> ::= "<" | ">" | "(" | ")" | "[" | "]" | "\" | "."
//                            | "," | ";" | ":" | "@" | """ | <control>
//          <control> ::= ASCII 0 through ASCII 31 inclusive, and ASCII 127
//-----------------------------------------------------------------------------
static BOOL bParse821String(PSTR* ppsz)
{
    static char rg821Special[] = "<>()[]\\.,;:@\"";
    PSTR p = *ppsz;

    while (*p)
    {
        if ('\\' == *p)
        {
            p++;

            if ('\0' == *p)
                 return FALSE;
        }
        else
        {
            if (' ' == *p || strchr(rg821Special, *p) || *p < ' ' || '\x7f' == *p)
                 return FALSE;
        }

        p++;

        if ('\0' == *p || '@' == *p || '.' == *p)
            break;

        // Whitespace encountered at this point could be either trailing (if
        // there is no @domain), or it is embedded. We can't really tell the
        // difference (without a lot of work), so fail because there is
        // no other interpretation that is safe.
        //
        if (' ' == *p || '\t' == *p || '>' == *p)
            return FALSE;
    }

    *ppsz = p;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:    bParse821DotString
//
//  parse:
//       <dot-string> ::= <string> | <string> "." <string>
//-----------------------------------------------------------------------------
static BOOL bParse821DotString(PSTR* ppsz)
{
    PSTR p = *ppsz;

    while (*p)
    {
         if (!bParse821String(&p))
             return FALSE;

         if ('.' != *p)
             break;

         p++;
    }

    *ppsz = p;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:    bParse821QuotedString
//
//  parse:
//    <quoted-string> ::= """ <qtext> """
//            <qtext> ::= "\" <x> | "\" <x> <qtext> | <q> | <q> <qtext>
//                <q> ::= any one of the ascii characters except <cr>, <lf>,
//                        quote (") or backslash (\)
//-----------------------------------------------------------------------------
static BOOL bParse821QuotedString(PSTR* ppsz)
{
    PSTR p = *ppsz;

    dspAssert('"' == *p);

    p++;

    while (*p && '"' != *p)
    {
         if ('\\' == *p)
         {
             p++;

             if ('\0' == *p)
                  return FALSE;
         }
         else
         {
             if ('\r' == *p || '\n' == *p)
                  return FALSE;
         }

         p++;
    }
    if ('"' != *p)
         return FALSE;

    p++;

    *ppsz = p;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:    bParse821Mailbox
//
//  parse:
//          <mailbox> ::= <local-part> "@" <domain>
//       <local-part> ::= <dot-string> | <quoted-string>
//-----------------------------------------------------------------------------
static BOOL bParse821Mailbox(PSTR* ppsz)
{
    PSTR p;
    BOOL  bSuccess = FALSE;

    dspAssert(ppsz);

    p = *ppsz;

    if ('\0' == *p)
         return FALSE;

    if ('<' == *p)
    {
      p++;
      if ('"' == *p)
           bSuccess = bParse821QuotedString(&p);
      else
           bSuccess = bParse821DotString(&p);

      if (!bSuccess)
           return FALSE;

      if ('@' == *p && !bParse821AtDomain(&p))
           return FALSE;

      if ('>' != *p)
        return FALSE;

      p++;
    }
    else
    {
      if ('"' == *p)
           bSuccess = bParse821QuotedString(&p);
      else
           bSuccess = bParse821DotString(&p);

      if (!bSuccess)
           return FALSE;

      if ('@' == *p && !bParse821AtDomain(&p))
           return FALSE;
    }

    *ppsz = p;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   FValidSMTPAddress
//
//  Synopsis:   Valididate mailbox + domain/host name (RFC 821).
//
//  Return TRUE if we find a valid RFC821 address at pwzBuffer. The UNICODE
//  buffer is converted to ANSI, checked, then converted back. This insures
//  that only ANSI characters are in the buffer when done.
//
//-----------------------------------------------------------------------------
BOOL
FValidSMTPAddress(PWSTR pwzBuffer)
{
    dspAssert(pwzBuffer);

    BOOL bUnmappedCharUsed = FALSE;
    int len;
    len = WideCharToMultiByte(CP_ACP, 0, pwzBuffer, -1, NULL, 0, NULL, &bUnmappedCharUsed);
    
    if (bUnmappedCharUsed)
    {
       return FALSE;
    }

    PSTR pszBuf = new char[len + 1];

    CHECK_NULL_REPORT(pszBuf, GetDesktopWindow(), return FALSE);

    if (WideCharToMultiByte(CP_ACP, 0, pwzBuffer, -1,
                            pszBuf, len, NULL, NULL) == 0)
    {
        ReportError(GetLastError(), 0);
        delete [] pszBuf;
        return FALSE;
    }

    PSTR p = pszBuf; // working pointer
    CHECK_NULL_REPORT(p, GetDesktopWindow(), return FALSE);

    if ('\0' == *p)
    {
        delete [] pszBuf;
        return FALSE;
    }

    // Parse routing
    //
    if ('@' == *p)
    {
        while ('@' == *p)
        {
            if (!bParse821AtDomain(&p))
            {
                delete [] pszBuf;
                return FALSE;
            }

            while (' ' == *p || '\t' == *p)
            {
                p++;
            }

            if (',' != *p)
                 break;

            p++;

            while (' ' == *p || '\t' == *p)
            {
                p++;
            }
        }

        if (':' != *p)
        {
            delete [] pszBuf;
            return FALSE;
        }

        p++;

        while (' ' == *p || '\t' == *p)
        {
            p++;
        }
    }

    if (!bParse821Mailbox(&p))
    {
        delete [] pszBuf;
        return FALSE;
    }

    // If we are not at end of string, then bParse821Mailbox found an invalid
    // character.
    //
    if ('\0' != *p)
    {
        delete [] pszBuf;
        return FALSE;
    }

    int lenOrig = len;

    len = MultiByteToWideChar(CP_ACP, 0, pszBuf, -1, NULL, 0);

    if (len > lenOrig)
    {
        // Assuming the string won't grow when converted to ANSI and back.
        //
        dspAssert(len <= lenOrig);
        delete [] pszBuf;
        return FALSE;
    }

    if (MultiByteToWideChar(CP_ACP, 0, pszBuf, -1, pwzBuffer, len) == 0)
    {
        ReportError(GetLastError(), 0);
        delete [] pszBuf;
        return FALSE;
    }

    delete [] pszBuf;

    return TRUE;
}

#endif // DSADMIN

void Smart_PADS_ATTR_INFO__Empty( PADS_ATTR_INFO* ppAttrs )
{
  if (NULL != *ppAttrs)
  {
    FreeADsMem( *ppAttrs );
    *ppAttrs = NULL;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\proppage.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       proppage.h
//
//  Contents:   DS object property pages class header
//
//  Classes:    CDsPropPagesHost, CDsPropPagesHostCF, CDsTableDrivenPage
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _PROPPAGE_H_
#define _PROPPAGE_H_

#include "adsprop.h"
#include "pages.h"
#include "strings.h"
#include "notify.h"

#define DSPROP_HELP_FILE_NAME TEXT("adprop.hlp")

#define ADM_S_SKIP  MAKE_HRESULT(SEVERITY_SUCCESS, 0, (PSNRET_INVALID_NOCHANGEPAGE + 2))

#define DSPROP_DESCRIPTION_RANGE_UPPER  1024

struct _DSPAGE; // forward declaration.

class CDsPropPagesHost; // forward declaration.
class CDsPropPageBase;  // forward declaration.

// Prototype for page creation function. The function should return S_FALSE if
// the page shouldn't be created due to a non-error condition.
//
typedef HRESULT (*CREATE_PAGE)(struct _DSPAGE * pDsPage, LPDATAOBJECT pDataObj,
                               PWSTR pwzObjDN, PWSTR pwszObjName,
                               HWND hNotifyWnd, DWORD dwFlags,
                               const CDSSmartBasePathsInfo& basePathsInfo,
                               HPROPSHEETPAGE * phPage);

typedef enum _DlgOp {
    fInit = 0,
    fApply,
    fOnCommand,
    fOnNotify,
    fOnDestroy,
    fOnCallbackRelease,
    fObjChanged,
    fAttrChange,
    fQuerySibling,
    fOnSetActive,
    fOnKillActive
} DLG_OP;

//+----------------------------------------------------------------------------
//
//  Struct:     ATTR_DATA
//
//  Purpose:    Per-Attribute data. The ATTR_DATA_WRITABLE bit is set if the
//              corresponding attribute is found in the Allowed-Attributes-
//              Effective list. The pAttrData struct pointer is passed to the
//              attr function where it can use the pVoid member for its private
//              storage needs.
//
//-----------------------------------------------------------------------------
typedef struct _ATTR_DATA {
    DWORD   dwFlags;
    LPARAM  pVoid;
} ATTR_DATA, * PATTR_DATA;

#define ATTR_DATA_WRITABLE  (0x00000001)
#define ATTR_DATA_DIRTY     (0x00000002)

#define ATTR_DATA_IS_WRITABLE(ad) (ad.dwFlags & ATTR_DATA_WRITABLE)
#define PATTR_DATA_IS_WRITABLE(pad) (pad->dwFlags & ATTR_DATA_WRITABLE)
#define ATTR_DATA_IS_DIRTY(ad) (ad.dwFlags & ATTR_DATA_DIRTY)
#define PATTR_DATA_IS_DIRTY(pad) (pad->dwFlags & ATTR_DATA_DIRTY)
#define ATTR_DATA_SET_WRITABLE(ad) (ad.dwFlags |= ATTR_DATA_WRITABLE)
#define PATTR_DATA_SET_WRITABLE(pad) (pad->dwFlags |= ATTR_DATA_WRITABLE)
#define ATTR_DATA_CLEAR_WRITABLE(ad) (ad.dwFlags &= ~ATTR_DATA_WRITABLE)
#define PATTR_DATA_CLEAR_WRITABLE(pad) (pad->dwFlags &= ~ATTR_DATA_WRITABLE)
#define ATTR_DATA_SET_DIRTY(ad) (ad.dwFlags |= ATTR_DATA_DIRTY)
#define PATTR_DATA_SET_DIRTY(pad) (pad->dwFlags |= ATTR_DATA_DIRTY)
#define ATTR_DATA_CLEAR_DIRTY(ad) (ad.dwFlags &= ~ATTR_DATA_DIRTY)
#define PATTR_DATA_CLEAR_DIRTY(pad) (pad->dwFlags &= ~ATTR_DATA_DIRTY)

struct _ATTR_MAP; // forward declaration.

typedef HRESULT (*PATTR_FCN)(CDsPropPageBase *, struct _ATTR_MAP *,
                             PADS_ATTR_INFO, LPARAM, PATTR_DATA, DLG_OP);

//+----------------------------------------------------------------------------
//
//  Struct:     ATTR_MAP
//
//  Purpose:    For each attribute on a property page, relates the control
//              ID, the attribute name and the attribute type.
//
//  Notes:      The standard table-driven processing assumes that nCtrlID is
//              valid unless pAttrFcn is defined, in which case the attr
//              function may choose to hard code the control ID.
//
//-----------------------------------------------------------------------------
typedef struct _ATTR_MAP {
    int             nCtrlID;        // Control resource ID
    BOOL            fIsReadOnly;
    BOOL            fIsMultiValued; // From schema.ini: Is-Single-Valued
    DWORD           nSizeLimit;
    ADS_ATTR_INFO   AttrInfo;
    PATTR_FCN       pAttrFcn;       // Optional function pointer.
    PVOID           pData;
} ATTR_MAP, * PATTR_MAP;

//+----------------------------------------------------------------------------
//
//  Struct:     DSPAGE
//
//  Purpose:    For each property page, lists the page title resource ID, the
//              page dialog templage ID, flags, the count and list of CLSIDs
//              for which this page should be shown, a pointer to a
//              page-class-specific creation function, and the count and list
//              of attributes. If nCLSIDs is zero, then the page should always
//              be shown.
//
//-----------------------------------------------------------------------------
typedef struct _DSPAGE {
    int             nPageTitle;
    int             nDlgTemplate;
    DWORD           dwFlags;
    DWORD           nCLSIDs;
    const CLSID   * rgCLSID;
    CREATE_PAGE     pCreateFcn;
    DWORD           cAttrs;
    PATTR_MAP     * rgpAttrMap;
} DSPAGE, * PDSPAGE;

//+----------------------------------------------------------------------------
//
//  Struct:     DSCLASSPAGES
//
//  Purpose:    For each CLSID, lists the prog ID, the number of pages, and the
//              list of pages.
//
//-----------------------------------------------------------------------------
typedef struct _DSCLASSPAGES {
    const CLSID * pcid;
    LPTSTR        szProgID;
    DWORD         cPages;
    PDSPAGE     * rgpDsPages;
} DSCLASSPAGES, * PDSCLASSPAGES;

//+----------------------------------------------------------------------------
//
//  Struct:     RGDSPPCLASSES
//
//  Purpose:    Contains the count and list of classes supported by this DLL.
//
//-----------------------------------------------------------------------------
typedef struct _RGDSPPCLASSES {
    int             cClasses;
    PDSCLASSPAGES * rgpClass;
} RGDSPPCLASSES, * PRGDSPPCLASSES;

// Table driven page creation function.
//
HRESULT
CreateTableDrivenPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                      PWSTR pwzADsPath, PWSTR pwzObjName,
                      HWND hNotifyWnd, DWORD dwFlags, 
                      const CDSSmartBasePathsInfo& basePathsInfo, 
                      HPROPSHEETPAGE * phPage);

/*
HRESULT
CreateScheduleObjPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                      LPWSTR pwszObjName, LPWSTR pwszClass,
                      HWND hNotifyWnd, DWORD dwFlags, HPROPSHEETPAGE * phPage);
*/

// Object page attribute function for object class.
//
HRESULT
GetObjectClass(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp);

// Object page attribute function for object timestamps.
//
HRESULT
GetObjectTimestamp(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                   PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                   DLG_OP DlgOp);

HRESULT
ObjectPathField(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                DLG_OP DlgOp);

// FPO general page attribute function for finding account name from the SID.
//
HRESULT
GetAcctName(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp);

// General-purpose attribute function for ES_NUMBER edit controls with
// associated spin button.  This must always be accompanied by a "msctls_updown32"
// control with the SpinButton attribute function.  Set ATTR_MAP.pData to the
// controlID of the associated spin button.
//
HRESULT
EditNumber(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
           DLG_OP DlgOp);

// General-purpose READONLY attribute function for spin buttons accompaying EditNumber
// edit controls.  If you wish to limit the spinbutton range, set ATTR_MAP.nSizeLimit
// to the high end of the range and ATTR_MAP.pData to the low end of the range.
//
HRESULT
SpinButton(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
           DLG_OP DlgOp);

// Special-purpose attribute function for spin buttons to change accelerator
// increment.  Use this as READONLY for controls which already have a
// SpinButton attribute function.  Set ATTR_MAP.pData to the integer
// multiple, e.g. 15 to move in increments of 15.
//
HRESULT
SpinButtonExtendIncrement(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
           DLG_OP DlgOp);

// Special-purpose read-only attribute functions to pick apart a subnet mask and
// fill in an IP Address Control (WC_IPADDRESS)
HRESULT
SubnetExtractAddress(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
           DLG_OP DlgOp);
HRESULT
SubnetExtractMask(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
           DLG_OP DlgOp);

//
// read-only attribute function to calculate the DNS alias of an NTDSDSA
//
HRESULT
NTDSDSA_DNSAlias(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
           DLG_OP DlgOp);

// helper function to delete pADsValues (tablpage.cxx)
void HelperDeleteADsValues( PADS_ATTR_INFO pAttrs );

// global definitions
extern HINSTANCE g_hInstance;
extern RGDSPPCLASSES g_DsPPClasses;
extern CLIPFORMAT g_cfDsObjectNames;
extern CLIPFORMAT g_cfDsDispSpecOptions;
extern CLIPFORMAT g_cfShellIDListArray;
extern CLIPFORMAT g_cfMMCGetNodeType;
extern CLIPFORMAT g_cfDsPropCfg;
extern CLIPFORMAT g_cfDsSelList;
extern CLIPFORMAT g_cfDsMultiSelectProppages;
//extern CLIPFORMAT g_cfMMCGetCoClass;
extern UINT g_uChangeMsg;
extern int g_iInstance;

#ifndef DSPROP_ADMIN
extern CRITICAL_SECTION g_csNotifyCreate;
#endif

//+----------------------------------------------------------------------------
//
//  Class:      CDsPropPagesHost
//
//  Purpose:    property pages host object class
//
//-----------------------------------------------------------------------------
class CDsPropPagesHost : public IShellExtInit, IShellPropSheetExt
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif
    CDsPropPagesHost(PDSCLASSPAGES pDsPP);
    ~CDsPropPagesHost();

    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //
    // IShellExtInit methods
    //
    STDMETHOD(Initialize)(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj,
                          HKEY hKeyID );

    //
    // IShellPropSheetExt methods
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE pReplacePageFunc,
                           LPARAM lParam);

private:

    PDSCLASSPAGES       m_pDsPPages;
    LPDATAOBJECT        m_pDataObj;
    HWND                m_hNotifyObj;
    STGMEDIUM           m_ObjMedium;
    unsigned long       m_uRefs;
    CDllRef             m_DllRef;
};

typedef struct _ApplyErrorEntry
{
  PWSTR     pszPath;          // Path to the object that had the error
  PWSTR     pszClass;         // Class of the object that had the error
  HRESULT   hr;               // HRESULT of the error (if 0 then pszStringError must not be NULL)
  PWSTR     pszStringError;   // User defined string error (used only if hr == NULL)
} APPLY_ERROR_ENTRY, *PAPPLY_ERROR_ENTRY;

//+----------------------------------------------------------------------------
//
//  Class:      CADsApplyErrors
//
//  Purpose:    contains an association between DS objects and errors that
//              occurred while doing an apply
//
//-----------------------------------------------------------------------------
class CADsApplyErrors
{
public:
  CADsApplyErrors() 
    : m_nArraySize(0),
      m_nCount(0),
      m_nIncAmount(5),
      m_pErrorTable(NULL),
      m_hWndPage(NULL),
      m_pszTitle(NULL)
  {}
  ~CADsApplyErrors();

  void      SetError(PADSPROPERROR pError);
  HRESULT   GetError(UINT nIndex);
  PWSTR     GetStringError(UINT nIndex);
  PWSTR     GetName(UINT nIndex);
  PWSTR     GetClass(UINT nIndex);
  HWND      GetPageHwnd() { return m_hWndPage; }
  UINT      GetCount() { return m_nCount; }
  UINT      GetErrorCount() { return m_nCount; }
  PWSTR     GetPageTitle() { return m_pszTitle; }

  void      Clear();

private:
  PAPPLY_ERROR_ENTRY  m_pErrorTable;
  UINT                m_nCount;
  HWND                m_hWndPage;
  PWSTR               m_pszTitle;

  UINT                m_nArraySize;
  UINT                m_nIncAmount;
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsPropPageBase
//
//  Purpose:    property page object base class
//
//-----------------------------------------------------------------------------
class CDsPropPageBase : public IUnknown
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsPropPageBase(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyWnd,
                    DWORD dwFlags);
    virtual ~CDsPropPageBase(void);

    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //
    //  Static WndProc to be passed to CreateWindow
    //
    static INT_PTR CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg,
                                          WPARAM wParam, LPARAM lParam);
    //
    //  Instance specific wind proc
    //
    virtual INT_PTR CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam,
                            LPARAM lParam) = 0;

    void Init(PWSTR pwzADsPath, PWSTR pwzClass, const CDSSmartBasePathsInfo& basePathsInfo);
    HRESULT CreatePage(HPROPSHEETPAGE * phPage);
    const LPWSTR GetObjPathName(void) {return m_pwszObjPathName;};
    const LPWSTR GetObjRDName(void) {return m_pwszRDName;};
    const LPWSTR GetObjClass(void) {return m_pwszObjClass;};
    HWND GetHWnd(void) {return m_hPage;};
    void SetDirty(BOOL fFullDirty = TRUE) {
             m_fPageDirty = TRUE;
             if (fFullDirty)
             {
                PropSheet_Changed(GetParent(m_hPage), m_hPage);
                EnableWindow(GetDlgItem(GetParent(m_hPage), IDCANCEL), TRUE);
             }
         };
    BOOL IsDirty() {return m_fPageDirty;}
    LRESULT OnHelp(LPHELPINFO pHelpInfo);

    virtual BOOL IsMultiselectPage() { return m_fMultiselectPage; }
    const CDSSmartBasePathsInfo& GetBasePathsInfo() { return m_basePathsInfo; }

protected:
    static  UINT CALLBACK PageCallback(HWND hwnd, UINT uMsg,
                                       LPPROPSHEETPAGE ppsp);
    //
    //  Member functions, called by WndProc
    //
    LRESULT InitDlg(LPARAM lParam);
    virtual HRESULT OnInitDialog(LPARAM lParam) = 0;
    virtual LRESULT OnApply(void) = 0;
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnCancel(void);
    LRESULT OnSetFocus(HWND hwndLoseFocus);
    LRESULT OnShowWindow(void);
    LRESULT OnDestroy(void);
    LRESULT OnPSMQuerySibling(WPARAM wParam, LPARAM lParam);
    LRESULT OnPSNSetActive(LPARAM lParam);
    LRESULT OnPSNKillActive(LPARAM lParam);
    LRESULT OnDoInit();

    void    CheckIfPageAttrsWritable(void);
    BOOL    CheckIfWritable(const PWSTR & wzAttr);


public:
    HRESULT GetObjSel(IDsObjectPicker ** ppObjSel, PBOOL pfIsInited = NULL);
    void    ObjSelInited(void) {m_fObjSelInited = TRUE;};
    HRESULT SkipPrefix(PWSTR pwzObj, PWSTR * ppResult, BOOL fX500 = TRUE);
    HRESULT AddLDAPPrefix(PWSTR pwzObj, CStrW &pstrResult, BOOL fServer = TRUE);
    HRESULT GetADsPathname(CComPtr<IADsPathname>& refADsPath);
    HRESULT GetIDispSpec(IDsDisplaySpecifier ** ppDispSpec);
    BOOL    IsReadOnly(void) {return m_fReadOnly;};

    BOOL    SendErrorMessage(PADSPROPERROR pError)
    {
      return ADsPropSendErrorMessage(m_hNotifyObj, pError);
    }
    //
    //  Data members
    //
public:
    LPDATAOBJECT        m_pWPTDataObj;  // Wnd Proc Thread Data Obj.
    IDirectoryObject  * m_pDsObj;

protected:
    HWND                m_hPage;
    BOOL                m_fInInit;
    BOOL                m_fPageDirty;
    BOOL                m_fReadOnly;
    BOOL                m_fMultiselectPage;
    LPDATAOBJECT        m_pDataObj;     // Marshalled to the wndproc thread.
    LPSTREAM            m_pDataObjStrm; // Used to marshal data obj pointer.
    int                 m_nPageTitle;
    int                 m_nDlgTemplate;
    DWORD               m_cAttrs;
    PATTR_MAP         * m_rgpAttrMap;
    PWSTR               m_pwszObjPathName;
    PWSTR               m_pwszObjClass;
    PWSTR               m_pwszRDName;
    CDllRef             m_DllRef;
    CComPtr<IADsPathname> m_pADsPath;
    IDsObjectPicker   * m_pObjSel;
    IDsDisplaySpecifier * m_pDispSpec;
    BOOL                m_fObjSelInited;
    PATTR_DATA          m_rgAttrData;
    unsigned long       m_uRefs;
    HWND                m_hNotifyObj;
    PADS_ATTR_INFO      m_pWritableAttrs;
    HRESULT             m_hrInit;

    CDSSmartBasePathsInfo   m_basePathsInfo;
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsTableDrivenPage
//
//  Purpose:    property page object class for table-driven attributes
//
//-----------------------------------------------------------------------------
class CDsTableDrivenPage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsTableDrivenPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyWnd,
                       DWORD dwFlags);
    ~CDsTableDrivenPage(void);

    //
    //  Instance specific wind proc
    //
    INT_PTR CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL SetNamedAttrDirty( LPCWSTR pszAttrName );

protected:
    void SetDirty(DWORD i) {
        ATTR_DATA_SET_DIRTY(m_rgAttrData[i]);
        CDsPropPageBase::SetDirty();
    }

    LRESULT OnDestroy(void);
private:
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnObjChanged(void);
    LRESULT OnAttrChanged(WPARAM wParam);
    LRESULT OnQuerySibs(WPARAM wParam, LPARAM lParam);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);

    HRESULT ReadAttrsSetCtrls(DLG_OP DlgOp);

    //
    //  Data members
    //
public:
    LPARAM   m_pData;
};

/*
//+----------------------------------------------------------------------------
//
//  Class:      CDsReplSchedulePage
//
//  Purpose:    property page object class for the schedule attribute.
//
//-----------------------------------------------------------------------------
class CDsReplSchedulePage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsReplSchedulePage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, DWORD dwFlags);
    ~CDsReplSchedulePage(void);

    //
    //  Instance specific wind proc
    //
    INT_PTR CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT GetServerName(void);

private:
    LRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnDestroy(void);

    //
    //  Data members
    //
    LPWSTR  m_pwszLdapServer;
};
*/

//+----------------------------------------------------------------------------
//
//  Class:      CDsPropPagesHostCF
//
//  Purpose:    object class factory
//
//-----------------------------------------------------------------------------
class CDsPropPagesHostCF : public IClassFactory
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif
    CDsPropPagesHostCF(PDSCLASSPAGES pDsPP);
    ~CDsPropPagesHostCF();

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IClassFactory methods
    STDMETHOD(CreateInstance)(IUnknown * pUnkOuter, REFIID riid,
                              void ** ppvObject);
    STDMETHOD(LockServer)(BOOL fLock);

    static IClassFactory * Create(PDSCLASSPAGES pDsPP);

private:

    PDSCLASSPAGES   m_pDsPP;
    unsigned long   m_uRefs;
    CDllRef         m_DllRef;
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsPropDataObj
//
//  Purpose:    Data object for property pages.
//
//  Notes:      This is not a first class COM object since there is no class
//              factory.
//
//-----------------------------------------------------------------------------
class CDsPropDataObj : public IDataObject
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif
    CDsPropDataObj(HWND hwndParentPage,
                   BOOL fReadOnly);
    ~CDsPropDataObj(void);

    HRESULT Init(LPWSTR pwszObjName, LPWSTR pwszClass);

    HRESULT Init(PDS_SELECTION_LIST pSelectionList);

    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //
    // Standard IDataObject methods
    //
    // Implemented
    //
    STDMETHOD(GetData)(FORMATETC * pformatetcIn, STGMEDIUM * pmedium);

    // Not Implemented
private:
    STDMETHOD(QueryGetData)(FORMATETC*)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(FORMATETC *,
                                     FORMATETC *)
    { return E_NOTIMPL; };

    STDMETHOD(EnumFormatEtc)(DWORD,
                             LPENUMFORMATETC *)
    { return E_NOTIMPL; };

    STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(FORMATETC *, STGMEDIUM *,
                       BOOL)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(FORMATETC *, DWORD,
                       IAdviseSink *, DWORD *)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(IEnumSTATDATA **)
    { return E_NOTIMPL; };

    BOOL                m_fReadOnly;
    PWSTR               m_pwszObjName;
    PWSTR               m_pwszObjClass;
    HWND                m_hwndParent;
   